<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Chapitre 9. Services Unix</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-fr-FR-1.0-1" /><meta
        name="keywords"
        content="Démarrage du système, Scripts d'initialisation, SSH, Telnet, Droits, Permissions, Supervision, Inetd, Cron, Sauvegarde, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Le cahier de l'administrateur Debian" /><link
        rel="up"
        href="index.html"
        title="Le cahier de l'administrateur Debian" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Installation d'un noyau" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Connexion à distance" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/fr-FR/stable/unix-services.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Précédent</strong></a></li><li
          class="home">Le cahier de l'administrateur Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Suivant</strong></a></li></ul><div
        xml:lang="fr-FR"
        class="chapter"
        lang="fr-FR"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  xmlns=""
                  id="unix-services"></a>Chapitre 9. Services Unix</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. Démarrage du système</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. Le système d'initialisation systemd</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. Le système d'initialisation System V</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Connexion à distance</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Connexion à distance sécurisée : SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Accéder à distance à des bureaux graphiques</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Gestion des droits</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Interfaces d'administration</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Administrer sur interface web : <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Configuration des paquets : <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. Les événements système de <code
                    class="command">syslog</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Principe et fonctionnement</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. Le fichier de configuration</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. Le super-serveur <code
                    class="command">inetd</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Planification de tâches : <code
                    class="command">cron</code> et <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Format d'un fichier <code
                        class="filename">crontab</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Emploi de la commande <code
                        class="command">at</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Planification asynchrone : <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Les quotas</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Sauvegarde</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. Sauvegarde avec <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. Restauration des machines non sauvegardées</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Branchements « à chaud » : <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. Introduction</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. La problématique du nommage</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. Fonctionnement de udev</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. Cas pratique</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Gestion de l'énergie : Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Ce chapitre parcourt un ensemble de services fondamentaux, souvent communs à beaucoup d'Unix. Tout administrateur se doit de les connaître.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    xmlns=""
                    id="sect.system-boot"></a>9.1. Démarrage du système</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			Lorsque l'ordinateur démarre, les messages défilant sur la console révèlent de nombreuses initialisations et configurations automatiques. Parfois, il est souhaitable de modifier légèrement le déroulement de cette étape, ce qui implique de bien la comprendre. C'est l'objet de cette section.
		</div><div
            class="para">
			En tout premier lieu, le BIOS prend le contrôle de l'ordinateur, détecte les disques, charge le <span
              class="emphasis"><em>Master Boot Record</em></span> (enregistrement d'amorçage maître) et l'exécute. Le chargeur d'amorçage prend alors le relais, trouve le noyau sur le disque, le charge et l'exécute. Le noyau s'initialise alors et se met en devoir de trouver et monter la partition contenant la racine de l'arborescence pour enfin démarrer le premier programme : <code
              class="command">init</code>. Il est fréquent que cette « partition racine » et cet <code
              class="command">init</code> soient en réalité sur un système de fichiers virtuel qui n'existe qu'en mémoire vive (d'où son nom <span
              class="foreignphrase"><em
                class="foreignphrase">initramfs</em></span>, anciennement appelé <span
              class="foreignphrase"><em
                class="foreignphrase">initrd</em></span> pour <span
              class="foreignphrase"><em
                class="foreignphrase">initialization RAM disk</em></span>). Ce système de fichiers est chargé en mémoire par le chargeur d'amorçage, souvent à partir d'un fichier sur un disque dur ou sur le réseau. Il contient le strict minimum qui peut être requis par le noyau pour charger le « vrai » système de fichiers racine : il peut s'agir de modules de pilotes pour les disques durs ou d'autres périphériques sans lesquels le système ne peut pas démarrer, ou, plus fréquemment, des modules et des scripts d'initialisation permettant d'assembler des grappes RAID, d'ouvrir des partitions chiffrées, d'activer des volumes LVM… Une fois que la partition racine est montée, l'<span
              class="foreignphrase"><em
                class="foreignphrase">initramfs</em></span> passe la main au vrai <code
              class="command">init</code> et on revient sur le processus de démarrage standard.
		</div><div
            class="figure"><a
              xmlns=""
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Étapes du démarrage d'un ordinateur sous Linux avec systemd" /></div></div><p
              class="title"><strong>Figure 9.1. Étapes du démarrage d'un ordinateur sous Linux avec systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.systemd"></a>9.1.1. Le système d'initialisation systemd</h3></div></div></div><div
              class="para">
				Le « vrai init » est actuellement fourni par <span
                class="pkg pkg">systemd</span>, sur lequel cette section se focalise.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURE</em></span> Avant <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> un « système d'initialisation » relativement récent, et bien qu'il était déjà disponible – dans une certaine mesure – dans <span
                  class="distribution distribution">Wheezy</span>, ce n'est que depuis <span
                  class="distribution distribution">Jessie</span> qu'il est employé par défaut. Les versions précédentes de Debian exploitaient « System V » (du paquet <span
                  class="pkg pkg">sysv-rc</span>), un système d'initialisation bien plus traditionnel qui sera présenté un peu plus loin.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> Autres systèmes d'initialisation</strong></p></div></div></div><div
                class="para">
				Nous décrivons ici le processus d'initialisation utilisé par défaut sous Debian <span
                  class="distribution distribution">Jessie</span> (tel qu'implémenté par le paquet <span
                  class="pkg pkg">systemd</span>), ainsi que l'ancien système, <span
                  class="pkg pkg">sysvinit</span>, qui est dérivé et hérité des Unix de type <span
                  class="emphasis"><em>System V</em></span>, mais il en existe d'autres.
			</div><div
                class="para">
				Citons également le processus simplifié contenu dans le paquet <span
                  class="pkg pkg">file-rc</span>. Ce dernier garde le principe des niveaux de fonctionnement <span
                  class="foreignphrase"><em
                    class="foreignphrase">(runlevels)</em></span>, mais remplace les répertoires et les liens symboliques par un unique fichier de configuration, qui spécifie à <code
                  class="command">init</code> les processus à lancer et l'ordre de lancement.
			</div><div
                class="para">
				Le système <code
                  class="command">upstart</code>, apparu plus récemment, n'est pas encore parfaitement testé sous Debian. Il est basé sur les événements ; les scripts de lancement ne sont plus exécutés de manière séquentielle mais en réponse à des événements comme l'aboutissement d'autres scripts dont ils dépendent. Ce système, initié par Ubuntu, est présent dans Debian <span
                  class="distribution distribution">Jessie</span> mais n'est pas le système par défaut : il vient en fait en remplacement de <span
                  class="package package">sysvinit</span> et une des tâches lancées par <code
                  class="command">upstart</code> est de lancer les scripts écrits pour les systèmes traditionnels, notamment ceux du paquet <span
                  class="package package">sysv-rc</span>.
			</div><div
                class="para">
				Il existe encore bien d'autres systèmes et d'autres modes de fonctionnement, comme <code
                  class="command">runit</code> ou <code
                  class="command">minit</code>, mais ils sont relativement spécialisés et minoritaires.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CAS PARTICULIER</em></span> Le démarrage sur le réseau</strong></p></div></div></div><div
                class="para">
				Dans certaines configurations, le BIOS peut être configuré pour ne pas exécuter le MBR mais aller chercher son équivalent sur le réseau, ce qui permet par exemple de construire des ordinateurs sans disque dur, ou qui se réinstallent complètement à chaque démarrage. Cette possibilité n'est pas offerte par tous les matériels et il faut généralement une combinaison adaptée du BIOS et de la carte réseau.
			</div><div
                class="para">
				Le démarrage sur le réseau peut être utilisé pour lancer <code
                  class="command">debian-installer</code> ou FAI (voir <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Section 4.1, « Méthodes d'installation »</a>).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>B.A.-BA</em></span> Le processus, une invocation de programme</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				Un processus est la représentation en mémoire d'un programme qui s'exécute. Il regroupe toutes les informations nécessaires au bon déroulement du logiciel (le code lui-même, mais aussi les données qu'il a en mémoire, la liste des fichiers qu'il a ouverts, des connexions réseau qu'il a établies, etc.). Un même programme peut faire l'objet de plusieurs processus, y compris sous le même identifiant utilisateur.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SÉCURITÉ</em></span> Gare à la substitution d'<code
                          class="command">init</code> par un shell</strong></p></div></div></div><div
                class="para">
				Le premier processus démarré est par convention le programme <code
                  class="command">init</code> (qui par défaut est un lien symbolique vers <code
                  class="filename">/lib/systemd/systemd</code>). Toutefois, il est possible de passer au noyau une option <code
                  class="literal">init</code> indiquant un autre programme.
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				Toute personne capable d'accéder à l'ordinateur pourra appuyer sur le bouton <span
                  class="keycap"><strong>Reset</strong></span> et ainsi le redémarrer, puis, via l'invite du chargeur d'amorçage, passer au noyau l'option <code
                  class="literal">init=/bin/sh</code> pour obtenir un accès root sans connaître le mot de passe de l'administrateur.
			</div><div
                class="para">
				Pour éviter cela, on peut protéger le chargeur d'amorçage par un mot de passe. Pensez alors à protéger aussi l'accès au BIOS (un mécanisme de protection par mot de passe est presque toujours disponible), sans quoi un indélicat pourra toujours démarrer sur une disquette contenant son propre système Linux, qu'il utilisera pour accéder aux disques durs de l'ordinateur.
			</div><div
                class="para">
				Sachez enfin que la plupart des BIOS disposent de passe-partout génériques. Prévus à l'origine pour dépanner les distraits qui oublient les leurs, ces mots de passe sont désormais publics et diffusés sur Internet (vérifiez vous-même en cherchant <span
                  class="foreignphrase"><em
                    class="foreignphrase">BIOS generic passwords</em></span> sur un moteur de recherche). Toutes ces protections ralentiront donc l'accès non autorisé à la machine, sans pouvoir l'empêcher totalement. C'est pourquoi il est vain de chercher à protéger un ordinateur si l'attaquant peut y accéder physiquement : il pourra de toute manière démonter les disques durs pour les brancher sur un ordinateur sous son contrôle, voire voler l'ordinateur entier, ou vider la mémoire du BIOS pour remettre à zéro le mot de passe...
			</div></div><div
              class="para">
				<code
                class="command">systemd</code> exécute plusieurs processus qui ont la responsabilité de mettre en place le système : clavier, pilotes, systèmes de fichiers, réseau et services. Il effectue cela en conservant une vue globale du système et des exigences de chaque composant. Chaque composant est décrit par un (ou plusieurs) « fichier unité » <span
                class="foreignphrase"><em
                  class="foreignphrase">(unit file)</em></span> ; la syntaxe générale est dérivée de celle des « fichiers *.ini », avec des paires <code
                class="literal"><em
                  class="replaceable">clé</em> = <em
                  class="replaceable">valeur</em></code> regroupées entre des en-têtes <code
                class="literal">[<em
                  class="replaceable">section</em>]</code>. Ces fichiers sont placés dans <code
                class="filename">/lib/systemd/system/</code> et dans <code
                class="filename">/etc/systemd/system/</code> ; ils en existent plusieurs sortes (chacune avec sa spécialité) mais dans cette section on ne traitera que des <span
                class="foreignphrase"><em
                  class="foreignphrase">services</em></span> et des <span
                class="foreignphrase"><em
                  class="foreignphrase">targets</em></span> (« cibles »).
			</div><div
              class="para">
				Un « fichier service » de systemd décrit un processus géré par systemd. Il contient approximativement les mêmes informations que les anciens scripts d'initialisation, mais exprimés d'une manière déclarative (et bien plus concise). <code
                class="command">systemd</code> s'occupe de toutes les tâches répétitives (démarrer et arrêter le processus, vérifier son état, enregistrer des logs, abandonner des privilèges, etc.), et le fichier service n'a plus qu'à préciser les particularités du processus. Voici par exemple celui pour SSH :
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists= !/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				On constate qu'il y a très peu de code dans ce fichier, juste des déclarations. <code
                class="command">systemd</code> s'occupe d'afficher l'état d'avancement, garde une trace des processus, et les redémarre même lorsque c'est nécessaire.
			</div><div
              class="para">
				Un « fichier <span
                class="foreignphrase"><em
                  class="foreignphrase">target</em></span> » de systemd décrit un état « cible » du système, dans lequel un certain nombre de services sont réputés être fonctionnels. On peut le concevoir comme l'équivalent d'un « niveau d'exécution » <span
                class="foreignphrase"><em
                  class="foreignphrase">(runlevel)</em></span> de l'ancien système. Une de ces cibles est <code
                class="literal">local-fs.target</code> ; lorsqu'elle est atteinte, le reste du système peut considérer que tous les systèmes de fichiers locaux sont montés et accessibles. Parmi les autres cibles existantes, citons <code
                class="literal">network-online.target</code> (« réseau en ligne ») et <code
                class="literal">sound.target</code> (« son »). Les dépendances d'une cible peuvent être listées soit dans le fichier <span
                class="foreignphrase"><em
                  class="foreignphrase">target</em></span> lui-même (sur la ligne <code
                class="literal">Requires=</code>), soit en créant un lien symbolique vers un fichier service dans le répertoire <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">nom-de-la-cible</em>.target.wants/</code>. Ainsi, <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> contient un lien vers <code
                class="filename">/lib/systemd/system/cups.service</code> ; systemd s'assurera donc que CUPS soit bien démarré pour atteindre la cible <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Puisque les fichiers de systemd ne sont pas des scripts ou des programmes, ils ne peuvent être exécutés directement : ils doivent être interprétés par systemd. C'est pourquoi l'administrateur dispose de plusieurs utilitaires pour interagir avec systemd, et contrôler l'état du système et de chacun de ses composants.
			</div><div
              class="para">
				Le premier de ces outils est <code
                class="command">systemctl</code>. Lorsqu'il est exécuté sans paramètres, il liste toutes les « unités » connues de systemd (à l'exception de celles qui ont été désactivées), ainsi que leur état. <code
                class="command">systemctl status</code> donne une meilleure vue des services, et des processus associés. En lui passant un nom de service (comme dans <code
                class="command">systemctl status ntp.service</code>), il renvoie encore plus de détails, ainsi que les dernières lignes de log en rapport avec le service (nous reviendrons là dessus plus loin).
			</div><div
              class="para">
				Démarrer un service manuellement se fait simplement avec <code
                class="command">systemctl start <em
                  class="replaceable">nom-de-service</em>.service</code>. Inversement et sans surprise, arrêter un service se fait avec <code
                class="command">systemctl stop <em
                  class="replaceable">nom-de-service</em>.service</code> ; d'autres sous-commandes existent, comme <code
                class="command">reload</code> (« recharger ») et <code
                class="command">restart</code> (« redémarrer »).
			</div><div
              class="para">
				Pour activer un service (autrement dit pour qu'il soit lancé automatiquement au démarrage de l'ordinateur), il convient de faire <code
                class="command">systemctl enable <em
                  class="replaceable">nom-du-service</em>.service</code> (ou <code
                class="command">disable</code> pour le désactiver). La sous-commande <code
                class="command">is-enabled</code> permet de vérifier l'état d'activation du service.
			</div><div
              class="para">
				Une autre particularité de systemd est son système de journalisation – <code
                class="command">journald</code>. Il peut être employé en complément des outils de journalisation traditionnels comme <code
                class="command">syslogd</code> : il rajoute des fonctionnalités intéressantes comme l'association d'un message au service qui l'a généré, et la capacité de capturer les messages émis sur la sortie d'erreur des processus gérés. Les messages peuvent être consultés après coup, grâce à la commande <code
                class="command">journalctl</code>. Sans arguments, elle affiche simplement tous les messages enregistrés depuis le démarrage du système ; on ne l'emploie que rarement de cette manière. La plupart du temps, on lui communique un identifiant de service dont on veut voir les messages :
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at mar. 2015-03-31 10:08:49 CEST, end at mar. 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				Une autre option très utile est <code
                class="command">-f</code>, qui demande à <code
                class="command">journalctl</code> d'afficher les nouveaux messages au fur et à mesure de leur émission (de manière similaire à ce que réalise <code
                class="command">tail -f <em
                  class="replaceable">fichier</em></code>).
			</div><div
              class="para">
				Lorsqu'un service n'a pas l'air de fonctionner correctement, la première étape pour résoudre le problème est de vérifier si le service est lancé avec <code
                class="command">systemctl status</code> ; si ce n'est pas le cas, et si les messages affichés par cette première commande ne suffisent pas à identifier le problème, il convient alors de consulter les messages que journald a collecté au sujet de ce service. Prenons le cas d'un serveur SSH qui ne fonctionne pas :
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since mar. 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at mar. 2015-03-31 17:29:27 CEST, end at mar. 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since mar. 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				Après avoir vérifié l'état du service (<span
                class="foreignphrase"><em
                  class="foreignphrase">failed</em></span>, en échec), nous avons consulté les messages du journal ; ils indiquaient une erreur dans le fichier de configuration. Après avoir corrigé ce dernier, nous avons redémarré le service et nous avons vérifié qu'il fonctionnait pour de bon.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>POUR ALLER PLUS LOIN</em></span> D'autres sortes de fichiers systemd <span
                          class="foreignphrase"><em
                            class="foreignphrase">(unit files)</em></span></strong></p></div></div></div><div
                class="para">
				Dans cette section nous avons découvert les facettes les plus importantes de systemd. Mais il dispose de nombreuses autres fonctionnalités ; nous n'en listerons que quelques-unes ici.
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						activation de socket : un fichier « socket » décrit une socket réseau ou Unix gérée par systemd ; concrètement la socket est créée par systemd, et le service sous-jacent peut être démarré à la demande lorsqu'une demande de connexion est reçue. Cela reprend approximativement les fonctionnalités de <code
                        class="command">inetd</code>. Voir <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						minuterie : un fichier « timer » décrit un événement qui se reproduit à un intervalle régulier ou à un horaire particulier ; lorsqu'un service est lié à une minuterie, la tâche correspondante est exécutée chaque fois que la minuterie se déclenche. Cette fonctionnalité est similaire à celle offerte par <code
                        class="command">cron</code>. Voir <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						réseau : un fichier « network » décrit une interface réseau, ce qui permet de configurer ces interfaces et d'exprimer le fait qu'un service dépend de la disponibilité d'une interface particulière.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.sysvinit"></a>9.1.2. Le système d'initialisation System V</h3></div></div></div><div
              class="para">
				Le système d'initialisation System V exécute tout un ensemble de processus en suivant les indications du fichier <code
                class="filename">/etc/inittab</code>. Le premier programme exécuté (correspondant à l'étape <span
                class="emphasis"><em>sysinit</em></span>) est <code
                class="command">/etc/init.d/rcS</code>, script qui exécute tous les programmes du répertoire <code
                class="filename">/etc/rcS.d/</code>. <a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				Parmi ceux-ci, on trouve successivement :
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						la configuration du clavier de la console ;
					</div></li><li
                  class="listitem"><div
                    class="para">
						le chargement des pilotes : la plupart des modules noyau sont chargés par le noyau lui-même en fonction du matériel détecté ; certains pilotes peuvent ensuite être systématiquement chargés, les modules correspondants doivent être listés dans <code
                      class="filename">/etc/modules</code> ;
					</div></li><li
                  class="listitem"><div
                    class="para">
						la vérification de l'intégrité des systèmes de fichiers ;
					</div></li><li
                  class="listitem"><div
                    class="para">
						le montage des partitions locales ;
					</div></li><li
                  class="listitem"><div
                    class="para">
						la configuration du réseau ;
					</div></li><li
                  class="listitem"><div
                    class="para">
						le montage des systèmes de fichiers distants (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>B.A.-BA</em></span> Modules du noyau et options</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				Les modules du noyau disposent eux aussi d'options qu'on peut paramétrer en plaçant des fichiers dans <code
                  class="filename">/etc/modprobe.d/</code>. Les options sont définies à l'aide de directives <code
                  class="literal">options <em
                    class="replaceable">nom-du-module</em> <em
                    class="replaceable">nom-option</em>=<em
                    class="replaceable">valeur-option</em></code>. Plusieurs options peuvent être spécifiées avec une seule directive si nécessaire.
			</div><div
                class="para">
				Ces fichiers de configuration sont destinés à <code
                  class="command">modprobe</code> — le programme permettant de charger un module noyau avec ses dépendances (les modules peuvent en effet faire appel à d'autres modules). Ce dernier est fourni par le paquet <span
                  class="pkg pkg">kmod</span>.
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				Après cette phase, <code
                class="command">init</code> reprend la main et démarre les programmes associés au niveau d'exécution <span
                class="foreignphrase"><em
                  class="foreignphrase">(runlevel)</em></span> normal, soit par défaut le niveau 2. Il exécute <code
                class="command">/etc/init.d/rc 2</code>, script qui démarre tous les services donnés du répertoire <code
                class="filename">/etc/rc2.d/</code> débutant par la lettre « S ». Le nombre (à deux chiffres) qui suit servait historiquement à classer les services pour les démarrer dans le bon ordre, mais de nos jours le système de démarrage par défaut utilise <code
                class="command">insserv</code>, un système de démarrage où l'ordonnancement se fait en fonction des dépendances entre scripts. Chaque script de démarrage déclare ainsi les contraintes qui s'appliquent à lui (par exemple, s'il doit démarrer avant ou après tel autre service) ; <code
                class="command">init</code> les lance alors dans un ordre qui satisfait les contraintes. La numérotation statique des scripts n'est donc plus prise en compte (mais ils doivent toujours s'appeler d'un nom composé d'un « S » suivi de deux caractères, suivis à leur tour du véritable nom du script utilisé pour les dépendances). D'une manière générale, les services de base (comme le service de collecte des journaux, <code
                class="command">rsyslog</code>, ou celui d'attribution des ports, <code
                class="command">portmap</code>) sont démarrés en premier, suivis par les services standards et l'interface graphique (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				Ce système de démarrage par dépendances permet d'automatiser des renumérotations qui pourraient s'avérer fastidieuses si elles devaient être faites manuellement et il prévient les erreurs humaines, puisque l'ordonnancement se fait en fonction des contraintes exprimées. Il présente également l'avantage supplémentaire de permettre le démarrage de plusieurs services en parallèle, si plusieurs scripts sont indépendants entre eux, ce qui peut accélérer la séquence de démarrage.
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> distingue plusieurs niveaux d'exécution car il peut basculer de l'un à l'autre par la commande <code
                class="command">telinit <em
                  class="replaceable">nouveau-niveau</em></code>. Dès son invocation, <code
                class="command">init</code> exécute à nouveau <code
                class="command">/etc/init.d/rc</code> avec le nouveau niveau d'exécution désiré, script qui démarre à son tour les services manquants et arrête ceux qui ne sont plus souhaités. Pour cela, il se réfère au contenu du répertoire <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> (où <em
                class="replaceable">X</em> représente le nouveau niveau d'exécution). Les scripts débutant par « S » (comme <span
                class="foreignphrase"><em
                  class="foreignphrase">Start</em></span>) sont des services à démarrer, ceux débutant par « K » (comme <span
                class="foreignphrase"><em
                  class="foreignphrase">Kill</em></span>) sont des services à stopper. Le script évite de redémarrer tout service déjà actif dans le niveau d'exécution précédent.
			</div><div
              class="para">
				Dans Debian, le système d'initialisation System V n'utilise par défaut que quatre <span
                class="foreignphrase"><em
                  class="foreignphrase">runlevels</em></span> différents.
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Le niveau 0 n'est utilisé que de manière transitoire, lors de la phase d'extinction de l'ordinateur. Il contient donc de nombreux scripts « K ».
					</div></li><li
                  class="listitem"><div
                    class="para">
						Le niveau 1, aussi connu sous le nom de <span
                      class="foreignphrase"><em
                        class="foreignphrase">single-user</em></span>, correspond au système en mode dégradé ; il ne contient que les services de base et est prévu pour les opérations de maintenance en dehors de l'interaction des utilisateurs.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Le niveau 2 est le niveau de fonctionnement normal, qui inclut les services réseau, l'interface graphique, les connexions des utilisateurs, etc.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Le niveau 6 est similaire au niveau 0, à ceci près qu'il est utilisé lors de la phase d'extinction qui précède un redémarrage.
					</div></li></ul></div><div
              class="para">
				D'autres niveaux existent, notamment de 3 à 5. Ils sont par défaut configurés pour fonctionner de la même manière que le niveau 2, mais l'administrateur peut les modifier (en ajoutant ou supprimant des scripts dans les répertoires <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d/</code> correspondants) pour les adapter à un besoin particulier.
			</div><div
              class="figure"><a
                xmlns=""
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Étapes du démarrage d'un ordinateur sous Linux avec le système d'initialisation System V" /></div></div><p
                class="title"><strong>Figure 9.2. Étapes du démarrage d'un ordinateur sous Linux avec le système d'initialisation System V</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				Tous les scripts contenus dans les différents répertoires <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> ne sont que des liens symboliques, créés à l'installation du paquet concerné par le programme <code
                class="command">update-rc.d</code>, et menant vers les scripts réels, stockés sous <code
                class="filename">/etc/init.d/</code>. Pour adapter à sa guise les services à démarrer ou à stopper à chaque niveau d'exécution, l'administrateur exécutera à nouveau le programme <code
                class="command">update-rc.d</code> en lui fournissant les paramètres adéquats. La page de manuel <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> en détaille la syntaxe précise. Signalons au passage que supprimer tous les liens symboliques (avec le paramètre <code
                class="literal">remove</code>) n'est pas la bonne méthode pour désactiver un service. Il faut simplement le configurer pour ne pas démarrer dans les niveaux d'exécution souhaités (tout en conservant les appels correspondants pour l'arrêter au cas où le service tournait dans le niveau d'exécution précédent). L'utilisation d'<code
                class="command">update-rc.d</code> étant quelque peu alambiquée, on pourra utiliser <code
                class="command">rcconf</code> (du paquet <span
                class="pkg pkg">rcconf</span>) pour se voir présenter une interface plus simple à manipuler.
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CHARTE DEBIAN</em></span> Redémarrage des services</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				Les scripts de configuration des paquets Debian redémarrent parfois certains services pour assurer leur disponibilité ou leur faire prendre en compte certaines nouvelles options. La commande de manipulation d'un service <code
                  class="command">service <em
                    class="replaceable">service</em> <em
                    class="replaceable">opération</em></code> ne prend pas en compte le niveau d'exécution, suppose (à tort) que le service est actuellement employé et peut donc effectuer des opérations inadéquates (démarrage d'un service volontairement arrêté, ou arrêt d'un service déjà stoppé, etc.). Debian a donc introduit le programme <code
                  class="command">invoke-rc.d</code>, auquel les scripts de configuration doivent recourir pour appeler les scripts d'initialisation des services. Il n'exécutera que les commandes nécessaires. Attention, contrairement à l'usage, le suffixe <code
                  class="filename">.d</code> est ici employé sur un nom de programme et non pas sur un répertoire.
			</div></div><div
              class="para">
				Enfin, <code
                class="command">init</code> démarre les programmes de contrôle des différentes consoles virtuelles (<code
                class="command">getty</code>). Ils affichent une invite, attendent un nom d'utilisateur, puis exécutent <code
                class="command">login <em
                  class="replaceable">utilisateur</em></code> pour démarrer une session.
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULAIRE</em></span> Console et terminal</strong></p></div></div></div><div
                class="para">
				Les premiers ordinateurs étaient habituellement séparés en plusieurs parties, très volumineuses : l'armoire de stockage et l'unité de calcul étaient distinctes des organes de contrôle utilisés par les opérateurs. Ceux-ci constituaient donc un meuble à part, la « console ». Ce terme est resté, mais sa signification a évolué. Il est devenu plus ou moins synonyme de « terminal » : un ensemble constitué d'un clavier et d'un écran.
			</div><div
                class="para">
				Au fil de l'évolution de l'informatique, les systèmes d'exploitation ont proposé plusieurs consoles virtuelles pour offrir plusieurs sessions indépendantes en même temps, même s'il n'existe physiquement qu'un clavier et un écran. La plupart des systèmes GNU/Linux proposent ainsi six consoles virtuelles (en mode texte), accessibles grâce aux combinaisons de touches <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> à <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span>.
			</div><div
                class="para">
				Les termes « console » et « terminal » peuvent aussi, au sens large, désigner un émulateur de terminal dans une session graphique X11 (comme <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code> ou <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Précédent</strong>8.11. Installation d'un noyau</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Niveau supérieur</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Sommaire</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Suivant</strong>9.2. Connexion à distance</a></li></ul></body></html>
