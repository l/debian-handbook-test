<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.2. Connexion à distance</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-fr-FR-1.0-1" /><meta
        name="keywords"
        content="Démarrage du système, Scripts d'initialisation, SSH, Telnet, Droits, Permissions, Supervision, Inetd, Cron, Sauvegarde, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Le cahier de l'administrateur Debian" /><link
        rel="up"
        href="unix-services.html"
        title="Chapitre 9. Services Unix" /><link
        rel="prev"
        href="unix-services.html"
        title="Chapitre 9. Services Unix" /><link
        rel="next"
        href="sect.rights-management.html"
        title="9.3. Gestion des droits" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/fr-FR/stable/sect.remote-login.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Précédent</strong></a></li><li
          class="home">Le cahier de l'administrateur Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Suivant</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.remote-login"></a>9.2. Connexion à distance</h2></div></div></div><div
          class="para">
			Il est essentiel pour un administrateur de pouvoir se connecter à distance sur un ordinateur. Les serveurs, confinés dans leur propre salle, disposent en effet rarement d'un clavier et d'un écran connectés en permanence — mais sont reliés au réseau.
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>B.A.-BA</em></span> Client, serveur</strong></p></div></div></div><a
            id="id-1.12.5.3.2"
            class="indexterm"></a><a
            id="id-1.12.5.3.3"
            class="indexterm"></a><div
            class="para">
			Lorsqu'un système comporte plusieurs mécanismes qui communiquent entre eux, on emploie souvent la métaphore client/serveur. Le serveur désigne alors le programme qui attend des requêtes en provenance d'un client, puis les exécute. C'est le client qui dirige les opérations, le serveur ne prenant pas d'initiatives de lui-même.
		</div></div><a
          id="id-1.12.5.4"
          class="indexterm"></a><a
          id="id-1.12.5.5"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ssh"></a>9.2.1. Connexion à distance sécurisée : SSH</h3></div></div></div><a
            id="id-1.12.5.6.2"
            class="indexterm"></a><a
            id="id-1.12.5.6.3"
            class="indexterm"></a><div
            class="para">
				Le protocole <span
              class="emphasis"><em>SSH</em></span> (<span
              class="foreignphrase"><em
                class="foreignphrase">Secured Shell</em></span>, ou shell sécurisé) a été conçu dans une optique de sécurité et de fiabilité. Les connexions ainsi mises en place sont sûres : le partenaire est authentifié et tous les échanges sont chiffrés.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURE</em></span> Telnet et RSH sont obsolètes</strong></p></div></div></div><a
              id="id-1.12.5.6.5.2"
              class="indexterm"></a><a
              id="id-1.12.5.6.5.3"
              class="indexterm"></a><div
              class="para">
				Avant l'apparition de SSH, <span
                class="emphasis"><em>Telnet</em></span> et <span
                class="emphasis"><em>RSH</em></span> étaient les outils les plus largement utilisés pour se connecter à distance. Ils sont maintenant véritablement obsolètes et ne devraient plus être utilisés (même si Debian continue de les fournir).
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOCABULAIRE</em></span> Authentification, chiffrement</strong></p></div></div></div><div
              class="para">
				Lorsqu'il s'agit de donner à un client la possibilité d'effectuer ou de déclencher des actions sur un serveur, les implications de sécurité sont importantes. On doit donc s'assurer de l'identité du client ; c'est l'authentification. Cette identité consistant souvent en un mot de passe, il faut bien entendu protéger la confidentialité de ce dernier, faute de quoi n'importe quel autre client pourra le récupérer ; c'est l'objet du chiffrement, qui est une forme de codage permettant à deux systèmes de communiquer des secrets sur un canal public sans qu'ils puissent être interceptés par des tierces parties.
			</div><div
              class="para">
				L'authentification et le chiffrement sont souvent évoqués ensemble, à la fois parce qu'ils interviennent fréquemment conjointement et parce qu'ils sont en général mis en œuvre à l'aide de concepts mathématiques similaires.
			</div></div><div
            class="para">
				SSH offre encore deux services de transfert de fichiers. <code
              class="command">scp</code> est un utilitaire en ligne de commande qui s'emploie comme <code
              class="command">cp</code> sauf que tout chemin sur une autre machine sera préfixé du nom de celle-ci suivi du caractère deux-points.
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>scp fichier machine:/tmp/</code></strong></pre><div
            class="para">
				<code
              class="command">sftp</code> est un programme interactif très similaire à <code
              class="command">ftp</code>. Ainsi, une même session <code
              class="command">sftp</code> peut transférer plusieurs fichiers et il est possible d'y manipuler les fichiers distants (supprimer, changer leur nom ou leurs droits, etc.).
			</div><a
            id="id-1.12.5.6.10"
            class="indexterm"></a><a
            id="id-1.12.5.6.11"
            class="indexterm"></a><div
            class="para">
				Debian emploie OpenSSH, version libre de SSH maintenue par le projet <code
              class="command">OpenBSD</code> (un système d'exploitation libre basé sur un noyau BSD et qui se focalise sur la sécurité) et <span
              class="foreignphrase"><em
                class="foreignphrase">fork</em></span> du logiciel SSH originel développé par la société finlandaise SSH Communications Security Corp. Celle-ci, qui en avait débuté le développement sous la forme d'un logiciel libre, avait en effet décidé de le poursuivre sous une licence propriétaire. Le projet OpenBSD créa donc OpenSSH pour maintenir une version libre de SSH.
			</div><a
            id="id-1.12.5.6.13"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>B.A.-BA</em></span> Fork</strong></p></div></div></div><a
              id="id-1.12.5.6.14.2"
              class="indexterm"></a><div
              class="para">
				Le terme <span
                class="foreignphrase"><em
                  class="foreignphrase">fork</em></span> (fourche, ou projet dérivé), dans le cadre d'un logiciel, désigne un nouveau projet, concurrent de l'original dont il s'inspire, et qu'il a entièrement copié au début. Ces deux logiciels identiques divergent rapidement sur le plan du développement. C'est souvent un désaccord dans l'équipe qui est à l'origine d'un <span
                class="foreignphrase"><em
                  class="foreignphrase">fork</em></span>.
			</div><div
              class="para">
				Cette possibilité provient directement du caractère libre d'un logiciel ; un <span
                class="foreignphrase"><em
                  class="foreignphrase">fork</em></span> est sain lorsqu'il permet la poursuite du développement sous forme de logiciel libre (en cas de changement de licence par exemple). Un <span
                class="foreignphrase"><em
                  class="foreignphrase">fork</em></span> issu d'un désaccord technique ou relationnel est souvent un gâchis de ressources humaines ; on lui préférera la résolution du différend. Il n'est d'ailleurs pas rare d'assister à la fusion des branches d'un <span
                class="foreignphrase"><em
                  class="foreignphrase">fork</em></span> quand elles font ce constat amer.
			</div></div><div
            class="para">
				OpenSSH est séparé en deux paquets. La partie cliente est dans le paquet <span
              class="pkg pkg">openssh-client</span>, le serveur dans <span
              class="pkg pkg">openssh-server</span>. Le métapaquet <span
              class="pkg pkg">ssh</span> dépend des deux parties et facilite leur installation conjointe (<code
              class="command">apt install ssh</code>).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-key-based-auth"></a>9.2.1.1. Authentification par clé</h4></div></div></div><div
              class="para">
					Chaque fois que l'on se connecte par SSH, le serveur distant demande un mot de passe pour authentifier l'utilisateur. Cela peut être problématique si l'on souhaite automatiser une connexion ou si l'on emploie un outil qui requiert de fréquentes connexions par SSH. C'est pourquoi SSH propose un système d'authentification par clé.
				</div><div
              class="para">
					L'utilisateur génère une biclé sur la machine cliente avec <code
                class="command">ssh-keygen -t rsa</code> : la clé publique est stockée dans <code
                class="filename">~/.ssh/id_rsa.pub</code> tandis que la clé privée correspondante est placée dans <code
                class="filename">~/.ssh/id_rsa</code>. L'utilisateur emploie alors <code
                class="command">ssh-copy-id <em
                  class="replaceable">serveur</em></code> pour ajouter sa clé publique dans le fichier <code
                class="filename">~/.ssh/authorized_keys</code> du serveur. Si, lors de sa création, la clé privée n'a pas été protégée par une « phrase de passe » <span
                class="foreignphrase"><em
                  class="foreignphrase">(passphrase)</em></span> qui la protège, toutes les connexions au serveur fonctionneront désormais sans mot de passe. Sinon, il faudra à chaque fois déchiffrer la clé privée donc saisir la phrase de passe. Heureusement <code
                class="command">ssh-agent</code> va nous permettre de garder en mémoire la (ou les) clé(s) privée(s) afin de ne pas devoir régulièrement ressaisir la phrase de protection. Pour cela, il suffit d'invoquer <code
                class="command">ssh-add</code> (une fois par session de travail) à la condition que la session soit déjà associée à une instance fonctionnelle de <code
                class="command">ssh-agent</code>. Debian l'active en standard dans les sessions graphiques, mais cela peut se désactiver en modifiant <code
                class="filename">/etc/X11/Xsession.options</code>. Pour une session en console, on peut le démarrer manuellement avec <code
                class="command">eval $(ssh-agent)</code>.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SÉCURITÉ</em></span> Protection de la clé privée</strong></p></div></div></div><div
                class="para">
					Quiconque dispose de la clé privée peut se connecter sur le compte ainsi configuré. C'est pourquoi l'accès à la clé privée est protégé par une « phrase de passe ». Quelqu'un qui récupérerait une copie d'un fichier abritant une clé privée (par exemple <code
                  class="filename">~/.ssh/id_rsa</code>) devrait encore retrouver cette phrase avant de pouvoir l'utiliser. Cette protection supplémentaire n'est cependant pas inviolable et si l'on pense que ce fichier a été compromis, il vaut mieux désactiver cette clé sur les ordinateurs où elle a été installée (en la retirant des fichiers <code
                  class="filename">authorized_keys</code>) et la remplacer par une clé nouvellement générée.
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURE</em></span> Faille OpenSSL de Debian <span
                          class="distribution distribution">Etch</span></strong></p></div></div></div><div
                class="para">
					La bibliothèque OpenSSL telle qu'initialement fournie dans Debian <span
                  class="distribution distribution">Etch</span> souffrait d'un grave problème dans son générateur de nombres aléatoires (RNG, <span
                  class="foreignphrase"><em
                    class="foreignphrase">Random Number Generator</em></span>). Le mainteneur Debian avait en effet effectué une modification afin que la bibliothèque ne soit pas la source d'avertissements pour des programmes l'utilisant et qui seraient analysés par des outils vérificateurs de mémoire comme <code
                  class="command">valgrind</code>. Malheureusement, ce changement a également eu pour conséquence que le RNG n'employait plus qu'une seule source d'aléas correspondant au numéro du processus (PID) dont le nombre est très restreint (environ 32 000). <div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="http://www.debian.org/security/2008/dsa-1571">http://www.debian.org/security/2008/dsa-1571</a></div>
				</div><div
                class="para">
					Concrètement, chaque fois que OpenSSL était employé pour générer une clé, il produisait systématiquement une clé comprise dans un ensemble connu de quelques centaines de milliers de clés (32 000, multipliées par un petit nombre de longueurs de clés). Cela affectait les clés SSH, SSL et les certificats X.509 employés par de nombreuses applications comme OpenVPN. Un pirate n'avait plus qu'à essayer toutes les clés pour essayer d'obtenir un accès non autorisé. Pour réduire l'impact du problème, le démon SSH a été modifié pour refuser les clés problématiques qui sont recensées dans les paquets <span
                  class="pkg pkg">openssh-blacklist</span> et <span
                  class="pkg pkg">openssh-blacklist-extra</span>. De plus, le programme <code
                  class="command">ssh-vulnkey</code> permet d'identifier d'éventuelles clés compromises présentes sur le système.
				</div><div
                class="para">
					Une analyse plus poussée de cet incident permet de se rendre compte que c'est le fruit de multiples (petits) problèmes tant au niveau du projet OpenSSL que du mainteneur du paquet Debian. Une bibliothèque aussi largement employée que OpenSSL devrait — sans modifications — ne pas générer d'avertissements lorsque scrutée par <code
                  class="command">valgrind</code>. En outre, le code (en particulier des parties aussi sensibles que le RNG) mériterait d'être mieux commenté pour éviter de telles erreurs. De son côté, le mainteneur Debian, en voulant faire valider sa modification par les développeurs d'OpenSSL, s'est contenté d'expliquer la modification sans fournir de patch à relire, et a négligé de préciser son rôle au sein de Debian. Enfin, ses choix de maintenance n'étaient pas optimaux : les changements effectués par rapport au logiciel original n'étaient pas clairement documentés ; toutes les modifications étaient certes stockées dans un dépôt Subversion mais elles se retrouvaient agglomérées en un seul patch lors de la création du paquet source.
				</div><div
                class="para">
					Difficile dans ces conditions de trouver des mesures correctives pour éviter que de tels incidents ne se reproduisent. La leçon retenue est que chaque divergence introduite par Debian par rapport au logiciel amont doit être justifiée, documentée, soumise au projet amont lorsque possible et largement publiée. C'est dans cette optique qu'ont été développés le nouveau format de paquet source ("3.0 (quilt)") et le service web de consultation des sources Debian. <div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="http://sources.debian.net">http://sources.debian.net</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-x11"></a>9.2.1.2. Utiliser des applications X11 à distance</h4></div></div></div><div
              class="para">
					Le protocole SSH permet de faire suivre <span
                class="foreignphrase"><em
                  class="foreignphrase">(forward)</em></span> les données graphiques (dites « X11 », du nom du système graphique le plus répandu sous Unix) : le serveur leur réserve alors un canal de données spécifique. Concrètement, une application graphique exécutée à distance peut s'afficher sur le serveur X.org de l'écran local et toute la session (manipulation comme affichage) sera sécurisée. Cette fonctionnalité donne à une application exécutée à distance de nombreuses possibilités d'interférer sur le système local, elle est donc préventivement désactivée par défaut ; on l'activera en précisant <code
                class="literal">X11Forwarding yes</code> dans le fichier de configuration <code
                class="filename">/etc/ssh/sshd_config</code> du serveur. L'utilisateur pourra ensuite en profiter en spécifiant l'option <code
                class="literal">-X</code> de <code
                class="command">ssh</code>.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-port-forwarding"></a>9.2.1.3. Créer des tunnels chiffrés avec le <span
                      class="foreignphrase"><em
                        class="foreignphrase">port forwarding</em></span></h4></div></div></div><a
              id="id-1.12.5.6.18.2"
              class="indexterm"></a><div
              class="para">
					Ses options <code
                class="literal">-R</code> et <code
                class="literal">-L</code> permettent à <code
                class="command">ssh</code> de créer des « tunnels chiffrés » entre deux machines, déportant de manière sécurisée un port TCP (voir l'encadré <a
                class="xref"
                href="network-infrastructure.html#sidebar.tcp-udp"><span
                  class="emphasis"><em>B.A.-BA</em></span> TCP/UDP</a>) local vers une machine distante ou vice versa.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULAIRE</em></span> Tunnel</strong></p></div></div></div><a
                id="id-1.12.5.6.18.4.2"
                class="indexterm"></a><a
                id="id-1.12.5.6.18.4.3"
                class="indexterm"></a><div
                class="para">
					Le réseau Internet et la plupart des réseaux locaux qui y sont raccordés fonctionnent en mode paquet et non en mode connecté, c'est-à-dire qu'un paquet émis depuis un ordinateur en direction d'un autre va s'arrêter sur plusieurs routeurs intermédiaires pour être acheminé jusqu'à sa destination. On peut néanmoins simuler un fonctionnement connecté, selon lequel le flux est encapsulé dans des paquets IP normaux ; ces paquets suivent leur chemin habituel, mais le flux est restitué tel quel à destination. On parle alors de « tunnel », par analogie avec un tunnel routier, dans lequel les véhicules roulent directement de l'entrée à la sortie sans rencontrer de carrefours, par opposition au trajet en surface qui impliquerait des intersections et des changements de direction.
				</div><div
                class="para">
					On peut profiter de l'opération pour ajouter du chiffrement au tunnel : le flux qui y circule est alors méconnaissable de l'extérieur, mais il est restauré à son état de flux en clair à la sortie du tunnel.
				</div></div><div
              class="para">
					<code
                class="command">ssh -L 8000:serveur:25 intermediaire</code> lance un <code
                class="command">ssh</code> qui établit une session vers <em
                class="replaceable">intermediaire</em> tout en écoutant le port 8000 local. Toute connexion établie sur ce port fera débuter par <code
                class="command">ssh</code> une connexion de l'ordinateur <em
                class="replaceable">intermediaire</em> vers le port 25 de <em
                class="replaceable">serveur</em>, à laquelle <code
                class="command">ssh</code> la reliera.
				</div><div
              class="para">
					<code
                class="command">ssh -R 8000:serveur:25 intermediaire</code> établit également une session SSH vers <em
                class="replaceable">intermediaire</em>, mais c'est sur cette machine que le processus <code
                class="command">ssh</code> écoute le port 8000. Toute connexion établie sur ce port fera débuter par <code
                class="command">ssh</code> une connexion depuis la machine locale vers le port 25 de <em
                class="replaceable">serveur</em>, à laquelle <code
                class="command">ssh</code> la reliera.
				</div><div
              class="para">
					Dans les deux cas, il s'agit de créer des connexions vers le port 25 de la machine <em
                class="replaceable">serveur</em>, qui passent au travers du tunnel SSH établi entre la machine locale et la machine <em
                class="replaceable">intermediaire</em>. Dans le premier cas, l'entrée du tunnel est le port 8000 local et les données transitent vers <em
                class="replaceable">intermediaire</em> avant de se diriger vers <em
                class="replaceable">serveur</em> sur le réseau « public ». Dans le second cas, l'entrée et la sortie du tunnel sont inversées : l'entrée est le port 8000 d'<em
                class="replaceable">intermediaire</em>, la sortie est locale et les données se dirigent ensuite vers <em
                class="replaceable">serveur</em> depuis la machine locale. En pratique, dans les cas d'usage les plus courants, le serveur est soit la machine locale, soit l'intermédiaire.
				</div><div
              class="figure"><a
                xmlns=""
                id="figure.ssh-L"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-L.png"
                    alt="Déport d'un port local par SSH" /></div></div><p
                class="title"><strong>Figure 9.3. Déport d'un port local par SSH</strong></p></div><div
              class="figure"><a
                xmlns=""
                id="figure.ssh-R"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-R.png"
                    alt="Déport d'un port distant par SSH" /></div></div><p
                class="title"><strong>Figure 9.4. Déport d'un port distant par SSH</strong></p></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.remote-desktops"></a>9.2.2. Accéder à distance à des bureaux graphiques</h3></div></div></div><div
            class="para">
				VNC (<span
              class="foreignphrase"><em
                class="foreignphrase">Virtual Network Computing</em></span>, ou informatique en réseau virtuel) permet d'accéder à distance à des bureaux graphiques.
			</div><a
            id="id-1.12.5.7.3"
            class="indexterm"></a><a
            id="id-1.12.5.7.4"
            class="indexterm"></a><a
            id="id-1.12.5.7.5"
            class="indexterm"></a><a
            id="id-1.12.5.7.6"
            class="indexterm"></a><a
            id="id-1.12.5.7.7"
            class="indexterm"></a><div
            class="para">
				Cet outil sert principalement en assistance technique : l'administrateur peut constater les erreurs de l'utilisateur et lui montrer la bonne manipulation sans devoir se déplacer à ses côtés.
			</div><a
            id="id-1.12.5.7.9"
            class="indexterm"></a><a
            id="id-1.12.5.7.10"
            class="indexterm"></a><a
            id="id-1.12.5.7.11"
            class="indexterm"></a><div
            class="para">
				Il faut tout d'abord que l'utilisateur autorise le partage de sa session. Dans <span
              class="distribution distribution">Jessie</span>, l'environnement de bureau GNOME inclut cette option dans son panneau de configuration (contrairement aux versions précédentes où il était nécessaire d'installer vino). En ce qui concerne KDE, il faut exécuter <code
              class="command">krfb</code> pour pouvoir partager le bureau actif via VNC. Pour les autres environnements bureautiques, la commande <code
              class="command">x11vnc</code> (du paquet Debian éponyme) a le même effet ; on pourra la rendre disponible à l'utilisateur via une icône explicite.
			</div><a
            id="id-1.12.5.7.13"
            class="indexterm"></a><a
            id="id-1.12.5.7.14"
            class="indexterm"></a><a
            id="id-1.12.5.7.15"
            class="indexterm"></a><a
            id="id-1.12.5.7.16"
            class="indexterm"></a><div
            class="para">
				Lorsque la session graphique est rendue disponible par VNC, l'administrateur doit s'y connecter à l'aide d'un client VNC. GNOME propose pour cela <code
              class="command">vinagre</code> et <code
              class="command">remmina</code>, et KDE inclut <code
              class="command">krdc</code> (dans le menu <span
              class="guimenu"><strong>K</strong></span> → <span
              class="guisubmenu"><strong>Internet</strong></span> → <span
              class="guimenuitem"><strong>Krdc Connexion à un bureau distant</strong></span>). Il existe aussi des clients VNC qui s'invoquent en ligne de commande, comme <code
              class="command">xvnc4viewer</code>, du paquet Debian éponyme. Une fois connecté, il peut examiner ce qui se passe, voire intervenir et montrer à l'utilisateur comment procéder.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>SÉCURITÉ</em></span> VNC sur SSH</strong></p></div></div></div><a
              id="id-1.12.5.7.18.2"
              class="indexterm"></a><div
              class="para">
				Si l'on souhaite se connecter par VNC et si on ne veut pas que les données circulent en clair sur le réseau, il est possible de les encapsuler dans un tunnel SSH (voir <a
                class="xref"
                href="sect.remote-login.html#sect.ssh-port-forwarding">Section 9.2.1.3, « Créer des tunnels chiffrés avec le <span
                  class="foreignphrase"><em
                    class="foreignphrase">port forwarding</em></span> »</a>). Il faut simplement savoir que VNC emploie par défaut le port 5900 pour le premier écran (appelé « localhost:0 »), 5901 pour le second (appelé « localhost:1 »), etc.
			</div><div
              class="para">
				La commande <code
                class="command">ssh -L localhost:5901:localhost:5900 -N -T <em
                  class="replaceable">machine</em></code> crée un tunnel entre le port local 5901 de l'interface <code
                class="command">localhost</code> et le port 5900 de l'ordinateur <em
                class="replaceable">machine</em>. Le premier <code
                class="command">localhost</code> contraint SSH à n'écouter, sur la machine locale, que sur cette interface. Le second <code
                class="command">localhost</code> désigne l'interface de la machine distante à laquelle SSH communiquera le trafic réseau expédié à <code
                class="literal">localhost:5901</code>. Ainsi, <code
                class="command">vncviewer localhost:1</code> connectera le client VNC à l'écran distant bien que l'on indique le nom de la machine locale.
			</div><div
              class="para">
				Une fois la session VNC terminée, il convient de ne pas oublier de fermer le tunnel en quittant la session SSH ouverte à cette fin.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>B.A.-BA</em></span> Gestionnaire d'écran</strong></p></div></div></div><a
              id="id-1.12.5.7.19.2"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.3"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.4"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.5"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.6"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.7"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">gdm3</code>, <code
                class="command">kdm</code>, <code
                class="command">lightdm</code> et <code
                class="command">xdm</code> sont des gestionnaires d'écran <span
                class="foreignphrase"><em
                  class="foreignphrase">(Display Manager)</em></span>. Ils prennent le contrôle de l'interface graphique peu après son initialisation afin de proposer à l'utilisateur un écran d'identification. Une fois ce dernier authentifié, il exécute les programmes requis pour démarrer une session de travail graphique.
			</div></div><div
            class="para">
				VNC sert aussi aux utilisateurs nomades, ou responsables d'entreprises, ayant des besoins ponctuels de connexion depuis chez eux, qui retrouvent ainsi à distance un bureau similaire à celui qu'ils ont au travail. La configuration d'un tel service est plus compliquée : il faut d'abord installer le paquet <span
              class="pkg pkg">vnc4server</span>, modifier la configuration du gestionnaire d'écran pour accepter les requêtes <code
              class="literal">XDMCP Query</code> (pour <code
              class="command">gdm3</code>, cela peut se faire en ajoutant <code
              class="literal">Enable=true</code> dans la section « xdmcp » du fichier <code
              class="filename">/etc/gdm3/daemon.conf</code>) et enfin démarrer le serveur VNC via <code
              class="command">inetd</code> pour qu'une session VNC soit démarrée dès qu'un utilisateur essaie de se connecter. On ajoutera par exemple cette ligne dans <code
              class="filename">/etc/inetd.conf</code> :
			</div><pre
            class="programlisting">5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</pre><div
            class="para">
				Rediriger les connexions entrantes vers un gestionnaire d'écran résout le problème de l'authentification, puisque seuls les utilisateurs disposant de comptes locaux passeront le cap de la connexion via <code
              class="command">gdm3</code> (ou les équivalents <code
              class="command">kdm</code>, <code
              class="command">xdm</code>, etc.). Comme ce fonctionnement permet sans problème plusieurs connexions simultanées (à condition que le serveur soit suffisamment puissant), il peut même être utilisé pour offrir des bureaux complets à différents utilisateurs itinérants (voire à des postes bureautiques peu puissants, configurés en clients légers). Les utilisateurs doivent simplement se connecter au 51<sup>e</sup> écran du serveur (<code
              class="command">vncviewer <em
                class="replaceable">serveur</em>:50</code>) parce que le port employé est le 5950.
			</div><a
            id="id-1.12.5.7.23"
            class="indexterm"></a></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Précédent</strong>Chapitre 9. Services Unix</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Niveau supérieur</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Sommaire</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Suivant</strong>9.3. Gestion des droits</a></li></ul></body></html>
