<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Глава 9. Сервисы Unix</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-ru-RU-1.0-1" /><meta
        name="keywords"
        content="Загрузка системы, Сценарии инициализации, SSH, Telnet, Права, Привилегии, Инспектирование, Inetd, Cron, Резервное копирование, Горячее подключение, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Настольная книга администратора Debian" /><link
        rel="up"
        href="index.html"
        title="Настольная книга администратора Debian" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Установка ядра" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Удалённый вход" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/ru-RU/stable/unix-services.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Пред.</strong></a></li><li
          class="home">Настольная книга администратора Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>След.</strong></a></li></ul><div
        xml:lang="ru-RU"
        class="chapter"
        lang="ru-RU"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  xmlns=""
                  id="unix-services"></a>Глава 9. Сервисы Unix</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. Загрузка системы</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. Система инициализации systemd</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. Система инициализации System V</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Удалённый вход</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Защищённый удалённый вход: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Использование удалённых графических рабочих столов</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Управление правами</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Интерфейсы для администрирования</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Администрирование через веб-интерфейс: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Настройка пакетов: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. Системные события <code
                    class="command">syslog</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Принципы и механизм</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. Конфигурационный файл</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. Суперсервер <code
                    class="command">inetd</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Планирование задач с помощью <code
                    class="command">cron</code> и <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Формат файла <code
                        class="filename">crontab</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Использование команды <code
                        class="command">at</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Планирование асинхронных задач: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Квоты</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Резервное копирование</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. Резервное копирование с помощью <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. Восстановление машин без резервных копий</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Горячее подключение: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. Введение</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. Проблема именования</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. Как работает <span
                        class="emphasis"><em>udev</em></span></a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. Конкретный пример</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Управление питанием: ACPI</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Эта глава посвящена нескольким основным сервисам, общим для многих Unix-систем. Все администраторы должны быть хорошо знакомы с ними.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    xmlns=""
                    id="sect.system-boot"></a>9.1. Загрузка системы</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			При загрузке компьютера множество сообщений, пробегающих на консоли, отображает выполнение многочисленных автоматических начальных инициализаций и настроек. Иногда может возникнуть желание несколько изменить работу этого этапа, а значит, необходимо хорошо её понимать. Помочь в этом — назначение данного раздела.
		</div><div
            class="para">
			Сначала BIOS получает контроль над компьютером, определяет диски, считывает <span
              class="emphasis"><em>главную загрузочную запись</em></span> и запускает загрузчик. Загрузчик принимает управление, находит ядро на диске, считывает и запускает его. Затем ядро инициализируется и начинает поиск и монтирование корневой файловой системы и, наконец, запускает первую программу — <code
              class="command">init</code>. Зачастую эти «корневой раздел» и <code
              class="command">init</code> на самом деле находятся на виртуальной файловой системе, существующей только в ОЗУ (отсюда её название — initramfs, ранее — initrd, от "initialization RAM disk"). Эта файловая система загружается в память загрузчиком, часто из файла на жёстком диске или по сети. Он содержит самый минимум, необходимый для того, чтобы ядро загрузило «настоящую» корневую файловую систему: сюда могут входить модуля ядра для жёсткого диска или других устройств, без которых система не способна загрузиться, или, чаще, сценарии инициализации и модули для сборки массивов RAID, открытия зашифрованных разделов, активации томов LVM и т. п. Когда корневой раздел примонтирован, initramfs передаёт управление настоящему процессу "init", и система возвращается к стандартному процессу загрузки.
		</div><div
            class="figure"><a
              xmlns=""
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Порядок загрузки компьютера с Linux и systemd" /></div></div><p
              class="title"><strong>Рисунок 9.1. Порядок загрузки компьютера с Linux и systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.systemd"></a>9.1.1. Система инициализации systemd</h3></div></div></div><div
              class="para">
				«Настоящий init» сейчас предоставляется <span
                class="pkg pkg">systemd</span>, и в данном разделе описывается эта система инициализации.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>КУЛЬТУРА</em></span> До <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> является относительно новой «системой инициализации», но несмотря на это, она уже была доступна в <span
                  class="distribution distribution">Wheezy</span>. По умолчанию, она стала применяться в Debian <span
                  class="distribution distribution">Jessie</span>. До этого, по умолчанию использовалась «System V init» (пакет <span
                  class="pkg pkg">sysv-rc</span>) — гораздо более традиционная система. System V init будет описана позднее.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>АЛЬТЕРНАТИВА</em></span> Другие системы загрузки</strong></p></div></div></div><div
                class="para">
				Эта книга дает описание загрузки системы: использующейся по умолчанию в Debian <span
                  class="distribution distribution">Jessie</span> (пакет <span
                  class="pkg pkg">systemd</span>), предыдущей — <span
                  class="pkg pkg">sysvinit</span>, которая является продолжателем и наследником <span
                  class="emphasis"><em>System V</em></span> из Unix-систем, также есть и другие.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> — это очень просто устроенная система загрузки. Она сохраняет принцип уровней запуска, но заменяет каталоги и символьные ссылки конфигурационным файлом, указывающим <code
                  class="command">init</code>, какие процессы и в каком порядке должны быть запущены.
			</div><div
                class="para">
				Система <code
                  class="command">upstart</code> пока не так хорошо тестировалась в Debian. Она основана на событиях: init-сценарии запускаются не поочерёдно, а отвечают на события, например на завершение другого сценария, от которого данный зависит. Эта система появилась в Ubuntu и может быть выбрана в Debian <span
                  class="distribution distribution">Jessie</span> как замена системы по умолчанию. Таковой она и разрабатывалась на место <span
                  class="pkg pkg">sysvinit</span> и одной из задач <code
                  class="command">upstart</code> был запуск сценариев, написанных для традиционных систем, особенно для <span
                  class="pkg pkg">sysv-rc</span>.
			</div><div
                class="para">
				Есть и другие системы и другие режимы работы: <code
                  class="command">runit</code>, <code
                  class="command">minit</code>. Они не распространены и достаточно специализированы.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ОСОБЫЙ СЛУЧАЙ</em></span> Загрузка по сети</strong></p></div></div></div><div
                class="para">
				В некоторых конфигурациях BIOS может быть настроен не на загрузку MBR, а на поиск её эквивалента в сети, что делает возможным собирать компьютеры без жёсткого диска или полностью переустанавливаемые при каждой загрузке. Такая опция есть не у любого оборудования, и для неё обычно необходимо определённое сочетание BIOS и сетевой карты.
			</div><div
                class="para">
				Загрузка по сети может использоваться для запуска <code
                  class="command">debian-installer</code> или FAI (см. <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Раздел 4.1, «Способы Установки»</a>).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>К ОСНОВАМ</em></span> Процесс — экземпляр программы</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				Процесс является отображением запущенной программы в памяти. Он содержит всю информацию, необходимую для корректной работы программы (сам код, а также данные, хранимые ей в памяти, список открытых ей файлов, установленных ей сетевых соединений и т. п.). Одна программа может быть представлена несколькими процессами, необязательно запущенными от имени разных пользователей.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>БЕЗОПАСНОСТЬ</em></span> Использование командной оболочки в качестве <code
                          class="command">init</code> для получения привилегий root</strong></p></div></div></div><div
                class="para">
				Принято, что первым процессом при загрузке является <code
                  class="command">init</code> (по умолчанию символьная ссылка на <code
                  class="filename">/lib/systemd/systemd</code>). Возможно передать ядру другие параметры для <code
                  class="literal">init</code>.
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				Любой человек, способный получить доступ к компьютеру, может нажать кнопку <span
                  class="keycap"><strong>Reset</strong></span> и перезагрузить его. Потом, в приглашении загрузчика, можно передать ядру опцию <code
                  class="literal">init=/bin/sh</code>, чтобы получить доступ root, не зная пароля администратора.
			</div><div
                class="para">
				Чтобы предотвратить это, можно защитить паролем сам загрузчик. Следует также задуматься о защите доступа к BIOS (механизм защиты паролем почти всегда доступен), без которой злоумышленник всё равно сможет загрузить машину с переносного накопителя c собственной системой Linux, которую он сможет использовать для доступа к данным на жёстком диске компьютера.
			</div><div
                class="para">
				Наконец, нужно знать, что в большинстве BIOS есть пароль, предназначенный для исправления неполадок и для тех, кто забыл установленный пароль. Сейчас, такие пароли находятся в свободном доступе в интернете (попробуйте найти для своего BIOS, набрав «generic BIOS passwords» в поисковике). Следует понимать, что не существует надёжного способа защитить компьютер от проникновения, если злоумышленник имеет к нему прямой способ. Например, он может просто забрать жёсткий диск, или целый компьютер, или стереть память BIOS для сброса пароля…
			</div></div><div
              class="para">
				Systemd запускает несколько процессов для настройки клавиатуры, драйверов, файловых систем, сети, служб. Также соблюдаются требования для всех компонентов системы, каждый из которых описан в «файле элемента» — unit (иногда требуется более одного файла). Синтаксис заимствован из «*.ini файлов» с парами «ключ = значение» — <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code>, разделёнными заголовками <code
                class="literal">[<em
                  class="replaceable">section</em>]</code>. Unit-файлы хранятся в каталогах <code
                class="filename">/lib/systemd/system/</code> и <code
                class="filename">/etc/systemd/system/</code>. Далее будут описаны типы unit «сервис» — service и «цель» — target.
			</div><div
              class="para">
				Файл service описывает процесс systemd. Он содержит ту же информацию, что и прежние init-сценарии, но она описана в декларативном (и сжатом) стиле. Systemd обслуживает повторяющиеся задачи (старт и остановка процесса, проверка его статуса, журнал, привилегии и т . п.) и файл service должен быть наполнен конкретикой, относящейся к процессу. Например для SSH, он выглядит так:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				Как видно из примера, кода очень мало, только объявления. Также systemd описывает ход процесса, отслеживает их выполнение и даже перезапускает, если необходимо.
			</div><div
              class="para">
				Файл «цели» в systemd описывает состояние системы, когда функционирует некоторый набор сервисов. Его можно рассматривать как эквивалент уровня запуска. Одна из целей — <code
                class="literal">local-fs.target</code>; при её достижении остальная система может рассчитывать, что все локальные файловые системы смонтированы и доступны. В число других целей входят <code
                class="literal">network-online.target</code> и <code
                class="literal">sound.target</code>. Зависимости цели могут быть указаны как внутри файла target (в строке <code
                class="literal">Requires=</code>), так и с использованием символьной ссылки на файл service в каталоге <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code>. Например <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> cодержит ссылку на <code
                class="filename">/lib/systemd/system/cups.service</code>, поэтому systemd запустит CUPS для достижения цели <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Так как файлы unit декларативны, в отличие от сценарием и программ, они не могут запускаться отдельно и интерпретируются только systemd, хотя несмотря на это, несколько вспомогательных программ позволяют администратору взаимодействовать с systemd, контролировать состояние системы и отдельных компонентов.
			</div><div
              class="para">
				Первая из них — <code
                class="command">systemctl</code>. При запуске без параметров, выводится список всех unit-файлов, известных системе (за исключением отключенных) и их статус. <code
                class="command">systemctl status</code> дает лучший обзор сервисов и связанных процессов. Выводится имя файла service (как в <code
                class="command">systemctl status ntp.service</code>), также дополнительная информация и последние несколько строчек из журнала, касающиеся этого процесса (позднее про это будет сказано более подробно).
			</div><div
              class="para">
				Для запуска сервиса вручную, нужно просто набрать <code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code>. Как можно догадаться, для остановки: <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code>. Есть другие подкоманды: <code
                class="command">reload</code> и <code
                class="command">restart</code>.
			</div><div
              class="para">
				Для контроля за активность сервиса (запускается при загрузки системы или нет), нужно использовать <code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> (или <code
                class="command">disable</code>). Для проверки запущен ли сервис — <code
                class="command">is-enabled</code>.
			</div><div
              class="para">
				Интересная особенность systemd состоит в журнале <code
                class="command">journald</code>. Он идет как дополнение к традиционному <code
                class="command">syslogd</code>, но содержит особенности, как например формальная ссылка между сервисом и сообщением, им создаваемом при процедуре инициализации. Сообщения можно посмотреть с помощью <code
                class="command">journalctl</code>. Без аргументов, выводится журнал сообщений, создаваемый при загрузке системы, однако в большинстве случаев команда используется с идентификатором сервиса:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				Другой полезный флаг <code
                class="command">-f</code> используется с <code
                class="command">journalctl</code> для просмотра появления новых сообщений (похоже на <code
                class="command">tail -f <em
                  class="replaceable">file</em></code>).
			</div><div
              class="para">
				Если сервис не работает как ожидалось, то первым делом нужно проверить его статус с <code
                class="command">systemctl status</code>, если проблема не решена, то проверьте его журнал. Допустим сервер SSH не работает:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				После проверки статуса (ошибка), был проверен журнал, была обнаружена ошибка в конфигурационном файле. После его редактирования и исправления ошибки, сервис запускается заново, далее проверяется его статус.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>УГЛУБЛЯЕМСЯ</em></span> Другие типы unit файла</strong></p></div></div></div><div
                class="para">
				Мы описали только базовые возможности systemd, но эта система предлагает много других интересных возможностей. Обозначим некоторые из них:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						активация сокета: «socket» unit файл используется для описания сети или Unix сокета. Это означает, что сокет создаётся systemd и текущий сервис может запускаться по запросу, если будет попытка соединения. Тут копируется набор возможностей <code
                        class="command">inetd</code>. Читайте <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						таймеры: «timer» unit файл описывает события, возникающие с установленной частотой или в определённый момент времени. Если сервис ссылается на таймер, процесс будет запущен в установленное время. Тут копируется часть возможностей <code
                        class="command">cron</code>. Читайте <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						сеть: «network» unit файл описывает сетевой интерфейс и позволяет его настраивать, а также отражать зависимость сервиса от какого-либо интерфейса.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.sysvinit"></a>9.1.2. Система инициализации System V</h3></div></div></div><div
              class="para">
				Система инициализации System V (которую называют init для краткости), используя инструкции из файла <code
                class="filename">/etc/inittab</code>, запускает несколько процессов. Первая команда (относящаяся к шагу <span
                class="emphasis"><em>sysvinit</em></span>) — это сценарий <code
                class="command">/etc/init.d/rcS</code>, который запускает все программы в каталоге <code
                class="filename">/etc/rcS.d/</code>. <a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				Среди них можно найти последовательность программ, отвечающих за:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						настройку клавиатуры в консоли;
					</div></li><li
                  class="listitem"><div
                    class="para">
						загрузку драйверов: большая часть модулей ядра загружается самим ядром при обнаружении оборудования; дополнительные драйверы затем загружаются автоматически, если соответствующие модули указаны в <code
                      class="filename">/etc/modules</code>;
					</div></li><li
                  class="listitem"><div
                    class="para">
						проверку целостности файловых систем;
					</div></li><li
                  class="listitem"><div
                    class="para">
						монтирование локальных разделов;
					</div></li><li
                  class="listitem"><div
                    class="para">
						настройку сети;
					</div></li><li
                  class="listitem"><div
                    class="para">
						монтирование сетевых файловых систем (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>К ОСНОВАМ</em></span> Опции модулей ядра</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				У модулей ядра тоже есть опции, которые можно настроить, поместив некоторые файлы в <code
                  class="filename">/etc/modprobe.d/</code>. Эти опции определяются с помощью таких директив: <code
                  class="literal">options <em
                    class="replaceable">имя-модуля</em> <em
                    class="replaceable">имя-опции</em>=<em
                    class="replaceable">значение-опции</em></code>. При необходимости в одной директиве можно указывать несколько опций.
			</div><div
                class="para">
				Эти конфигурационные файлы предназначены для <code
                  class="command">modprobe</code> — программы, которая загружает модуль ядра вместе с его зависимостями (модули могут на самом деле вызывать другие модули). Эта программа предоставляется пакетом <span
                  class="pkg pkg">kmod</span>.
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				Следом, <code
                class="command">init</code> запускает программы уровня запуска по умолчанию (обычно runlevel 2). Запускается сценарий <code
                class="command">/etc/init.d/rc 2</code>, который, в свою очередь, запускает сервисы, перечисленные в <code
                class="filename">/etc/rc2.d/</code>. Названия файлов в каталоге начинаются с буквы «S», за которой идут две цифры, что определяет очерёдность запуска. В настоящее время, загрузочная система по умолчанию использует программу <code
                class="command">insserv</code>, которая автоматически всё организовывает, основываясь на зависимостях сценариев. Каждый сценарий объявляет условия, необходимые для его запуска и остановки (например, очерёдность по отношению к другим сценариям), <code
                class="command">init</code> запускает сценарии в соответствующей последовательности для удовлетворения зависимостей. Поэтому наименование сценариев больше не учитывается (хотя они всё еще должны начинаться с «S» и далее продолжаться двумя цифрами и названием сервиса, которое и используется для организации зависимостей). В общем, основные сервисы (как журналирование с <code
                class="command">rsyslog</code> или назначение портов с <code
                class="command">portmap</code>) запускаются в первую очередь, затем следуют стандартные сервисы и графический интерфейс (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				Такая основанная на зависимостях система загрузки делает возможной автоматизацию смены нумерации, которая была бы весьма утомительной, если бы её приходилось выполнять вручную, и снижает риск человеческой ошибки, поскольку планирование выполняется в соответствии с формальными параметрами. Другим преимуществом является возможность параллельного запуска сервисов, независимых друг от друга, что может ускорить процесс загрузки.
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> различает несколько уровней запуска, так что она может переключаться с одного на другой при посредстве команды <code
                class="command">telinit <em
                  class="replaceable">новый-уровень</em></code>. <code
                class="command">init</code> сразу же запускает <code
                class="command">/etc/init.d/rc</code> заново с новым уровнем запуска. Этот сценарий после этого запускает недостающие сервисы и останавливает те, которые более не нужны. Для этого он руководствуется содержимым <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> (где <em
                class="replaceable">X</em> означает новый уровень запуска). Сценарии, начинающиеся с «S» (как в слове «Start») — это сервисы, которые должны быть запущены; те, что начинаются с «K» (как в слове «Kill») — сервисы, которые должны быть остановлены. Сценарий не запускает никаких сервисов, которые уже были активированы на прежнем уровне запуска.
			</div><div
              class="para">
				По умолчанию, System V init Debian использует четыре разных уровня запуска:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Уровень 0 используется только временно, при выключении питания компьютера. Поэтому он содержит только «K»-сценарии.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Уровень 1, также известный как однопользовательский режим, соответствует системе с урезанной функциональностью; он включает только основные сервисы и предназначается для операций по обслуживанию, когда взаимодействие с обычными пользователями нежелательно.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Уровень 2 — уровень для нормальной работы, включающий сетевые сервисы, графический интерфейс, вход пользователей и т. п.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Уровень 6 похож на уровень 0 с той разницей, что он используется во время остановки системы перед перезагрузкой.
					</div></li></ul></div><div
              class="para">
				Есть и другие уровни, в частности с 3 по 5. По умолчанию они настроены, чтобы работать точно так же, как уровень 2, но администратор может изменить их (путём добавления или удаления сценариев в соответствующие каталоги <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>), чтобы приспособить их под свои специфические нужды.
			</div><div
              class="figure"><a
                xmlns=""
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Последовательность загрузки компьютера с Linux и System V init" /></div></div><p
                class="title"><strong>Рисунок 9.2. Последовательность загрузки компьютера с Linux и System V init</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				Все сценарии, содержащиеся в различных каталогах <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> на самом деле являются лишь символьными ссылками — созданными при установке пакета программой <code
                class="command">update-rc.d</code> — указывающими на сами сценарии, хранящиеся в <code
                class="filename">/etc/init.d/</code>. Администратор может настроить доступность сервисов на каждом уровне запуска путём повторного запуска <code
                class="command">update-rc.d</code> с изменёнными параметрами. На странице руководства <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(8)</span> подробно описан синтаксис. Обратите внимание, что удаление всех символьных ссылок (с помощью параметра <code
                class="literal">remove</code>) — не лучший метод отключения сервиса. Вместо этого следует просто настроить, чтобы он не запускался на нужном уровне запуска (сохранив соответствующие вызовы для остановки его в случае, если сервис работал на предыдущем уровне запуска). Поскольку интерфейс <code
                class="command">update-rc.d</code> несколько запутанный, может оказаться более удобным использовать <code
                class="command">rcconf</code> (из пакета <span
                class="pkg pkg">rcconf</span>), интерфейс которой более дружествен к пользователю.
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ПОЛИТИКА DEBIAN</em></span> Перезапуск сервисов</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				Сценарии сопровождающего пакет Debian иногда перезапускают сервисы для того, чтобы убедиться в их доступности или для применения изменений. Команда для контроля за сервисами <code
                  class="command">service <em
                    class="replaceable">service</em> <em
                    class="replaceable">operation</em></code> не учитывает уровень запуска, подразумевает (ошибочно) что сервис уже используется и может выполнить неправильные операции (запуск сервиса, намеренно остановленного или остановку сервиса, который уже остановлен и т. п.). Поэтому Debian представляет программу <code
                  class="command">invoke-rc.d</code>, которая должна использоваться сопровождающим для запуска сценариев, в свою очередь, предназначенных для запуска сервисов. Она будет запускать только необходимые команды. Заметьте что здесь, по сравнению с традиционным использованием суффикса <code
                  class="filename">.d</code>, он используется как часть названия программы, а не каталога.
			</div></div><div
              class="para">
				Наконец, <code
                class="command">init</code> запускает программу управления виртуальными консолями (<code
                class="command">getty</code>). Она выводит приглашение, ожидает ввода имени пользователя, а затем выполняет <code
                class="command">login <em
                  class="replaceable">пользователь</em></code>, чтобы начать сессию.
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>СЛОВАРЬ</em></span> Консоль и терминал</strong></p></div></div></div><div
                class="para">
				Первые компьютеры обычно состояли из нескольких очень больших частей: устройство хранения данных и вычислительный модуль размещались отдельно от периферийных устройств, используемых операторами для управления. Часть этой оснастки называлась «консоль». Этот термин остался, но смысл его изменился. Он стал синонимом «терминала» — клавиатуры и дисплея.
			</div><div
                class="para">
				С развитием компьютеров операционные системы стали предлагать несколько виртуальных консолей, чтобы сделать возможной одновременную работу нескольких сессий даже при наличии только одной клавиатуры и дисплея. В большинстве систем GNU/Linux шесть виртуальных консолей (в текстовом режиме), доступных путём нажатия сочетаний клавиш с <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> по <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span>.
			</div><div
                class="para">
				Также термины «консоль» и «терминал» могут означать эмулятор терминала в графической сессии X11 (например <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code> или <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Пред.</strong>8.11. Установка ядра</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Наверх</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Начало</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>След.</strong>9.2. Удалённый вход</a></li></ul></body></html>
