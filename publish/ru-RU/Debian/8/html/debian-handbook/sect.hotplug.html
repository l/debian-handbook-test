<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.11. Горячее подключение: hotplug</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ru-RU-1.0-1" /><meta
        name="keywords"
        content="Загрузка системы, Сценарии инициализации, SSH, Telnet, Права, Привилегии, Инспектирование, Inetd, Cron, Резервное копирование, Горячее подключение, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Настольная книга администратора Debian" /><link
        rel="up"
        href="unix-services.html"
        title="Глава 9. Сервисы Unix" /><link
        rel="prev"
        href="sect.backup.html"
        title="9.10. Резервное копирование" /><link
        rel="next"
        href="sect.power-management.html"
        title="9.12. Управление питанием: ACPI" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/ru-RU/stable/sect.hotplug.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.backup.html"><strong>Пред.</strong></a></li><li
          class="home">Настольная книга администратора Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.power-management.html"><strong>След.</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.hotplug"></a>9.11. Горячее подключение: <span
                  class="emphasis"><em>hotplug</em></span></h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.2"></a>9.11.1. Введение</h3></div></div></div><div
            class="para">
				Подсистема ядра <span
              class="emphasis"><em>hotplug</em></span> динамически обрабатывает подключение и отключение устройств, загружая соответствующие драйверы и создавая файлы устройств (с помощью <code
              class="command">udevd</code>). С современным оборудованием и виртуализацией можно подключать «на лету» почти всё: от обычных периферийных устройств USB/PCMCIA/IEEE 1394 до жёстких дисков SATA, и даже процессоров и памяти.
			</div><div
            class="para">
				У ядра есть база данных для сопоставления идентификатора каждого устройства необходимому драйверу. Эта база данных используется при загрузке для подключения драйверов всех периферийных устройств, обнаруженных на разных шинах, а также при горячем подключении дополнительного устройства. Когда устройство готово к использованию, отправляется сообщение <code
              class="command">udevd</code>, чтобы он создал соответствующую запись в <code
              class="filename">/dev/</code>.
			</div><a
            id="id-1.12.14.2.4"
            class="indexterm"></a><a
            id="id-1.12.14.2.5"
            class="indexterm"></a><a
            id="id-1.12.14.2.6"
            class="indexterm"></a><a
            id="id-1.12.14.2.7"
            class="indexterm"></a><a
            id="id-1.12.14.2.8"
            class="indexterm"></a><a
            id="id-1.12.14.2.9"
            class="indexterm"></a></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.3"></a>9.11.2. Проблема именования</h3></div></div></div><div
            class="para">
				До появления горячих подключений было очень просто присвоить устройству фиксированное имя. Оно основывалось просто на расположении устройств на их шине. Но это невозможно, когда такие устройства могут появиться и начать использовать шину. Типичным случаем является использование цифрового фотоаппарата или USB-брелока, которые представляются компьютеру как жёсткие диски. Первый подключённый может стать <code
              class="filename">/dev/sdb</code>, а второй — <code
              class="filename">/dev/sdc</code> (если <code
              class="filename">/dev/sda</code> представляет собой локальный жёсткий диск компьютера). Имя устройства не фиксировано; оно зависит от порядка, в котором устройства подключаются.
			</div><div
            class="para">
				Кроме того, всё больше устройств используют динамические значения своих старшего и младшего номеров, из-за чего становится невозможным использовать для данных устройств статические записи, ведь эти важнейшие характеристики могут меняться после перезагрузки.
			</div><div
            class="para">
				<span
              class="emphasis"><em>udev</em></span> был создан специально для решения этой проблемы.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>НА ПРАКТИКЕ</em></span> Управление сетевыми картами</strong></p></div></div></div><div
              class="para">
				Many computers have multiple network cards (sometimes two wired interfaces and a wifi interface), and with <span
                class="emphasis"><em>hotplug</em></span> support on most bus types, the Linux kernel does not guarantee fixed naming of network interfaces. But users who want to configure their network in <code
                class="filename">/etc/network/interfaces</code> need a fixed name!
			</div><div
              class="para">
				Было бы сложно просить каждого пользователя создавать свои собственные правила <span
                class="emphasis"><em>udev</em></span> для решения этой проблемы. Поэтому <span
                class="emphasis"><em>udev</em></span> был настроен более своеобразным образом; при первой загрузке (и, в более общем случае, при появлении новой сетевой карты) он использует имя сетевой карты и её MAC-адрес, чтобы создать новые правила, которые будут вновь присваивать то же имя при последующих загрузках. Эти правила хранятся в <code
                class="filename">/etc/udev/rules.d/70-persistent-net.rules</code>.
			</div><div
              class="para">
				This mechanism has some side effects that you should know about. Let's consider the case of a computer that has only one PCI network card. The network interface is named <code
                class="literal">eth0</code>, logically. Now say the card breaks down, and the administrator replaces it; the new card will have a new MAC address. Since the old card was assigned the name, <code
                class="literal">eth0</code>, the new one will be assigned <code
                class="literal">eth1</code>, even though the <code
                class="literal">eth0</code> card is gone for good (and the network will not be functional because <code
                class="filename">/etc/network/interfaces</code> likely configures an <code
                class="literal">eth0</code> interface). In this case, it is enough to simply delete the <code
                class="filename">/etc/udev/rules.d/70-persistent-net.rules</code> file before rebooting the computer. The new card will then be given the expected <code
                class="literal">eth0</code> name.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.4"></a>9.11.3. Как работает <span
                    class="emphasis"><em>udev</em></span></h3></div></div></div><div
            class="para">
				Когда ядро уведомляет <span
              class="emphasis"><em>udev</em></span> о появлении нового устройства, последний собирает различную информацию о данном устройстве из соответствующих записей в <code
              class="filename">/sys/</code>, особенно тех, которые позволяют уникально идентифицировать его (MAC-адрес сетевой карты, серийный номер некоторых USB-устройств и т. п.).
			</div><div
            class="para">
				Вооружившись этой информацией, <span
              class="emphasis"><em>udev</em></span> сверяется со всеми правилами, содержащимися в <code
              class="filename">/etc/udev/rules.d/</code> и <code
              class="filename">/lib/udev/rules.d/</code>. В ходе этого процесса он принимает решение, какое имя присвоить устройству, какие символьные ссылки создать (чтобы дать альтернативные имена) и какие команды запустить. Проверяются все эти файлы, и все правила выполняются последовательно (если в файлах не используются директивы «GOTO»). Так что может быть несколько правил, соответствующих отдельному событию.
			</div><div
            class="para">
				Синтаксис файлов правил довольно прост: каждый ряд содержит критерии выбора и присваивание значений переменным. Первые используются для отбора событий, на которые нужно реагировать, а последние определяют действие, которое нужно предпринять. Они все разделяются запятыми, и оператор используется для того, чтобы косвенным образом отличить критерий выбора (с операторами сравнения, такими как <code
              class="literal">==</code> или <code
              class="literal">!=</code>) от директивы присваивания (с такими операторами как <code
              class="literal">=</code>, <code
              class="literal">+=</code> или <code
              class="literal">:=</code>).
			</div><div
            class="para">
				Операторы сравнения используются со следующими переменными:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">KERNEL</code> — имя, которое ядро присваивает устройству;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">ACTION</code> — действие, соответствующее событию («add» при добавлении устройства, «remove» при его удалении);
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">DEVPATH</code> — путь к записи устройства в <code
                    class="filename">/sys/</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">SUBSYSTEM</code> — подсистема ядра, от которой пришёл запрос (их много, например «usb», «ide», «net», «firmware» и т. п.);
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">ATTR{<em
                      class="replaceable">attribute</em>}</code>: file contents of the <em
                    class="replaceable">attribute</em> file in the <code
                    class="filename">/sys/<em
                      class="replaceable">$devpath</em>/</code> directory of the device. This is where you find the MAC address and other bus specific identifiers;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">KERNELS</code>, <code
                    class="literal">SUBSYSTEMS</code> и <code
                    class="literal">ATTRS{<em
                      class="replaceable">атрибуты</em>}</code> — это вариации, которые пытаются найти соответствие разным опциям одного из устройств, являющихся родительскими по отношению к текущему;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">PROGRAM</code> — делегирует проверку указанной программе (истина если она возвращает 0, ложь в противном случае). Содержимое стандартного вывода программы сохраняется, так что его можно использовать в проверке <code
                    class="literal">RESULT</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">RESULT</code> — выполняет проверки стандартного вывода, сохранённого при последнем вызове <code
                    class="literal">PROGRAM</code>.
					</div></li></ul></div><div
            class="para">
				В правых операндах можно использовать шаблонные выражения, соответствующие нескольким значениям одновременно. Например, <code
              class="literal">*</code> соответствует любой строке (даже пустой); <code
              class="literal">?</code> соответствует любому символу, а <code
              class="literal">[]</code> соответствует набору символов, перечисленных внутри квадратных скобок (или наоборот, если первым символом является восклицательный знак, а непрерывные диапазоны символов указываются как <code
              class="literal">a-z</code>).
			</div><div
            class="para">
				Что касается операторов присваивания, <code
              class="literal">=</code> присваивает значение (и заменяет текущее значение); в случае списка он очищается и содержит только присвоенное значение. <code
              class="literal">:=</code> делает то же самое, но запрещает изменение переменной в дальнейшем. <code
              class="literal">+=</code> добавляет запись в список. Можно изменять следующие переменные:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">NAME</code> — имя файла устройства, который надлежит создать в <code
                    class="filename">/dev/</code>. Учитывается только первое присваивание, остальные игнорируются;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">SYMLINK</code> — список символьных ссылок, которые будут указывать на то же устройство;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">OWNER</code>, <code
                    class="literal">GROUP</code> и <code
                    class="literal">MODE</code> определяют пользователя и группу, владеющих устройством, а также назначенные ему разрешения;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">RUN</code> — список программ, которые должны быть запущены в ответ на событие.
					</div></li></ul></div><div
            class="para">
				В значениях, присваиваемых этим переменным, могут использоваться следующие подстановки:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$kernel</code> или <code
                    class="literal">%k</code> — эквивалент <code
                    class="literal">KERNEL</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$number</code> или <code
                    class="literal">%n</code> — порядковый номер устройства, например для <code
                    class="literal">sda3</code> он был бы равен «3»;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$devpath</code> или <code
                    class="literal">%p</code> — эквивалент <code
                    class="literal">DEVPATH</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$attr{<em
                      class="replaceable">атрибут</em>}</code> или <code
                    class="literal">%s{<em
                      class="replaceable">атрибут</em>}</code> — эквивалент <code
                    class="literal">ATTRS{<em
                      class="replaceable">атрибут</em>}</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$major</code> или <code
                    class="literal">%M</code> — старший номер устройства в ядре;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$minor</code> или <code
                    class="literal">%m</code> — младший номер устройства в ядре;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$result</code> или <code
                    class="literal">%c</code> — строковый вывод последней программы, вызванной <code
                    class="literal">PROGRAM</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						и наконец, <code
                    class="literal">%%</code> и <code
                    class="literal">$$</code> означают, соответственно, знак процента и знак доллара.
					</div></li></ul></div><div
            class="para">
				The above lists are not complete (they include only the most important parameters), but the <span
              class="citerefentry"><span
                class="refentrytitle">udev</span>(7)</span> manual page should be exhaustive.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.5"></a>9.11.4. Конкретный пример</h3></div></div></div><div
            class="para">
				Рассмотрим случай простого USB-брелока и попробуем присвоить ему фиксированное имя. Во-первых, необходимо найти элементы, которые идентифицируют его уникальным образом. Для этого надо подключить его и запустить <code
              class="command">udevadm info -a -n /dev/sdc</code> (заменив <em
              class="replaceable">/dev/sdc</em> на действительное имя, присвоенное брелоку).
			</div><pre
            class="screen"><code
              class="computeroutput"># </code><strong
              class="userinput"><code>udevadm info -a -n /dev/sdc</code></strong>
<code
              class="computeroutput">[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</code></pre><div
            class="para">
				Чтобы создать новое правило, можно использовать проверки переменных как устройства, так и его родительских устройств. В приведённом примере можно создать два правила вроде этих:
			</div><pre
            class="programlisting">KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"</pre><div
            class="para">
				После того, как эти правила прописаны в файле с именем, например, <code
              class="filename">/etc/udev/rules.d/010_local.rules</code>, можно просто отсоединить и заново подключить USB-брелок. После этого можно будет убедиться, что <code
              class="filename">/dev/usb_key/disk</code> представляет диск, ассоциированный с USB-брелоком, а <code
              class="filename">/dev/usb_key/part1</code> — его первый раздел.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>УГЛУБЛЯЕМСЯ</em></span> Отладка конфигурации <span
                        class="emphasis"><em>udev</em></span></strong></p></div></div></div><div
              class="para">
				Like many daemons, <code
                class="command">udevd</code> stores logs in <code
                class="filename">/var/log/daemon.log</code>. But it is not very verbose by default, and it is usually not enough to understand what is happening. The <code
                class="command">udevadm control --log-priority=info</code> command increases the verbosity level and solves this problem. <code
                class="command">udevadm control --log-priority=err</code> returns to the default verbosity level.
			</div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.backup.html"><strong>Пред.</strong>9.10. Резервное копирование</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Наверх</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Начало</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.power-management.html"><strong>След.</strong>9.12. Управление питанием: ACPI</a></li></ul></body></html>
