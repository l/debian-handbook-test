<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">8.8. Configurare il bootloader</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-it-IT-1.0-1" /><meta
        name="keywords"
        content="Configurazione, Localizzazione, Localizzazioni, Rete, Risoluzione dei nomi, Utenti, Gruppi, Account, Interprete a riga di comando, Shell, Stampa, Bootloader, Compilazione del kernel" /><link
        rel="home"
        href="index.html"
        title="Il Manuale dell'Amministratore Debian" /><link
        rel="up"
        href="basic-configuration.html"
        title="Capitolo 8. Configurazione di base: rete, account, stampa, ..." /><link
        rel="prev"
        href="sect.config-printing.html"
        title="8.7. Configurazione della stampante" /><link
        rel="next"
        href="sect.config-misc.html"
        title="8.9. Altre configurazioni: Sincronizzazione Ora, Log, Condivisione dell'accesso…" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/it-IT/stable/sect.config-bootloader.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-printing.html"><strong>Indietro</strong></a></li><li
          class="home">Il Manuale dell'Amministratore Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.config-misc.html"><strong>Avanti</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.config-bootloader"></a>8.8. Configurare il bootloader</h2></div></div></div><a
          id="id-1.11.12.2"
          class="indexterm"></a><a
          id="id-1.11.12.3"
          class="indexterm"></a><div
          class="para">
			È probabilmente già funzionante ma è sempre meglio sapere come configurare ed installare il bootloader nel caso scompaia dal Master Boot Record. Questo può avvenire dopo l'installazione di un altro sistema operativo, per esempio Windows. Le seguenti informazioni possono anche aiutare a modificare la configurazione del bootloader se necessario.
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>FONDAMENTALI</em></span> Master boot record</strong></p></div></div></div><a
            id="id-1.11.12.5.2"
            class="indexterm"></a><a
            id="id-1.11.12.5.3"
            class="indexterm"></a><div
            class="para">
			Il Master Boot Record (MBR) occupa i primi 512 byte del primo disco rigido e rappresenta la prima cosa caricata dal BIOS per passare il controllo ad un programma in grado di lanciare il sistema operativo desiderato. Generalmente, il bootloader viene installato nell'MBR, rimuovendo il suo contenuto precedente.
		</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.identify-disks"></a>8.8.1. Identificare i dischi</h3></div></div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURA</em></span> <span
                        class="emphasis"><em>udev</em></span> e <code
                        class="filename">/dev/</code></strong></p></div></div></div><div
              class="para">
				La directory <code
                class="filename">/dev/</code> ospita tradizionalmente i file cosiddetti "speciali", usati per rappresentare le periferiche del sistema (si veda il riquadro <a
                class="xref"
                href="sect.creating-accounts.html#sidebar.special-files"><span
                  class="emphasis"><em>FONDAMENTALI</em></span> Permessi di accesso ai dispositivi</a>). Fino a poco tempo fa, era usato per contenere tutti i file speciali che potevano essere utilizzati. Questo approccio ha avuto una serie di dinconvenienti tra cui il fatto che restringeva il numero di dispositivi che si potevano utilizzare (a causa della lista dei nomi fissa), e che era impossibile sapere quali file speciali erano effettivamente utili.
			</div><div
              class="para">
				Al giorno d'oggi, la gestione dei file speciali è completamente dinamica e corrisponde meglio alla natura hot-swap (collegati a caldo) dei dispositivi informatici. Il kernel collabora con <span
                class="emphasis"><em>udev</em></span> per creare e cancellare i file come necessario quando i dispositivi corrispondenti vengono collegati e scollegati. Per questo motivo, <code
                class="filename">/dev/</code> non ha bisogno di essere persistente ed è quindi un filesystem RAM-based che inizialmente è vuoto e contiene solo le voci adeguate.
			</div><div
              class="para">
				Il kernel comunica molte informazioni su qualsiasi dispositivo appena aggiunto ed assegna una coppia di numeri maggiore/minore per identificarlo. Con questo <code
                class="command">udevd</code> è in grado di creare il file speciali con il nome e le autorizzazioni che vuole. Si può anche creare un alias ed eseguire ulteriori azioni (come l'inizializzazione o la registrazione di attività). Il comportamento di <code
                class="command">udevd</code> è guidato da un grande insieme di regole (personalizzabili).
			</div><div
              class="para">
				Con nomi assegnati dinamicamente, è possibile quindi mantenere lo stesso nome per un dato dispositivo, indipendentemente dal connettore utilizzato o dall'ordine di connessione, che è particolarmente utile quando si utilizzano varie periferiche USB. La prima partizione del primo disco rigido può quindi essere chiamato <code
                class="filename">/dev/sda1</code> per retro compatibilità, o <code
                class="filename">/dev/root-partition</code> se si preferisce, o addirittura entrambi al stesso tempo dato che <code
                class="command">udevd</code> può essere configurato per creare automaticamente un link simbolico.
			</div><div
              class="para">
				In tempi remoti, alcuni moduli del kernel si caricavano quando si tentava di accedere al file del dispositivo corrispondente. Ora non è più così, ed il file specifico della periferica non esiste prima di caricare il modulo; questo è un grosso problema, dal momento che la maggior parte dei moduli vengono caricati all'avvio grazie al riconoscimento automatico dell'hardware. Ma per le periferiche non rilevabili (come dischi molto vecchi o mouse PS/2), questo non funziona. Bisogna considerare l'aggiunti dei moduli, <code
                class="literal">floppy</code>, <code
                class="literal">psmouse</code> e <code
                class="literal">mousedev</code> a <code
                class="filename">/etc/modules</code> per forzare il loro caricamento all'avvio.
			</div></div><a
            id="id-1.11.12.6.3"
            class="indexterm"></a><a
            id="id-1.11.12.6.4"
            class="indexterm"></a><div
            class="para">
				La configurazione del bootloader deve identificare i diversi dischi rigidi e le rispettive partizioni. Linux usa speciali file "a blocchi" conservati nella directory <code
              class="filename">/dev/</code>, per questo scopo. Sin da Debian <span
              class="distribution distribution">Squeeze</span>, lo schema dei nomi degli dischi è stato unificato con il kernel Linux, e tutti i dischi rigidi (IDE/PATA, SATA, SCSI, USB, IEEE 1394) sono ora rappresentati da <code
              class="filename">/dev/sd*</code>.
			</div><div
            class="para">
				Ogni partizione è rappresentata dal suo numero sul disco che la ospita: per esempio <code
              class="filename">/dev/sda1</code> è la prima partizione nel primo disco e <code
              class="filename">/dev/sdb3</code> è la terza partizione nel secondo disco.
			</div><a
            id="id-1.11.12.6.7"
            class="indexterm"></a><a
            id="id-1.11.12.6.8"
            class="indexterm"></a><a
            id="id-1.11.12.6.9"
            class="indexterm"></a><a
            id="id-1.11.12.6.10"
            class="indexterm"></a><div
            class="para">
				L'architettura PC (o "i386", compreso il cugino più giovane "amd64") è stata a lungo limitata dall'uso della tabella delle partizioni "MS-DOS", che permetteva solo quattro partizioni "primarie" per disco. Per superare la limitazione di questo schema, una di esse deve essere creata come partizione "estesa", e può così contenere partizione "secondarie" aggiuntive. Queste partizioni secondarie sono numerate a partire da 5. Così la prima partizione secondaria potrebbe essere <code
              class="filename">/dev/sda5</code>, seguita da <code
              class="filename">/dev/sda6</code>, etc.
			</div><div
            class="para">
				Un'altra limitazione del formato della tabella di partizione MS-DOS è che permette solo dischi fino a 2Tb di dimensione, che sta diventando un vero problema con i dischi più recenti.
			</div><a
            id="id-1.11.12.6.13"
            class="indexterm"></a><a
            id="id-1.11.12.6.14"
            class="indexterm"></a><div
            class="para">
				Un nuovo formato della tabella di partizione denominato GPT allenta questi vincoli sul numero di partizioni (permette fino a 128 partizioni utilizzando le impostazioni standard) e sulle dimensioni dei dischi (fino a 8 ZiB, che sono più di 8 miliardi terabyte). Se avete intenzione di creare molte partizioni fisiche sullo stesso disco, è pertanto necessario assicurarsi di creare una tabella delle partizioni in formato GPT quando si partiziona il disco.
			</div><div
            class="para">
				Non è sempre semplice ricordare quale disco è connesso a quale controller SATA o alla terza posizione nella catena SCSI, specialmente dato che la denominazione dei dischi rigidi collegati a caldo (che include tra gli altri la maggior parte dei dischi SATA e i dischi esterni) può cambiare tra un avvio e l'altro. Fortunatamente <code
              class="command">udev</code> crea in aggiunta a <code
              class="filename">/dev/sd*</code> dei collegamenti simbolici con un nome fisso che è possibile usare se si desidera identificare un disco rigido in modo non ambiguo. Questi collegamenti simbolici sono conservati in <code
              class="filename">/dev/disk/by-id</code>. In una macchina con due dischi fisici, per esempio, si potrebbe trovare questo:
			</div><pre
            class="screen"><code
              class="computeroutput">mirexpress:/dev/disk/by-id# </code><strong
              class="userinput"><code>ls -l
</code></strong><code
              class="computeroutput">total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </code></pre><div
            class="para">
				Si noti che alcuni dischi sono elencati più volte (poiché agiscono simultaneamente come dischi ATA e dischi SCSI), ma l'informazione rilevante principale è il modello ed il numero seriale dei dischi grazie ai quali si può individuare il file periferica.
			</div><div
            class="para">
				I file di configurazione d'esempio che si trovano nelle sezioni seguenti sono basati sulla stessa configurazione: un singolo disco SATA, dove la prima partizione è una vecchia installazione Windows e la seconda contiene Debian GNU/Linux.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.config-lilo"></a>8.8.2. Configurare LILO</h3></div></div></div><a
            id="id-1.11.12.7.2"
            class="indexterm"></a><a
            id="id-1.11.12.7.3"
            class="indexterm"></a><div
            class="para">
				<span
              class="emphasis"><em>LILO</em></span> (LInux LOader) è il bootloader più vecchio: solido ma grezzo. Scrive l'indirizzo fisico del kernel da lanciare nell'MBR, per questo ogni aggiornamento di LILO (o dei suoi file di configurazione) dev'essere seguito dal comando <code
              class="command">lilo</code>. Dimenticarsi di farlo impedisce al sistema di avviarsi se il vecchio kernel è stato rimosso o sostituito dato che quello nuovo non sarà nella stessa posizione sul disco.
			</div><div
            class="para">
				Il file di configurazione di LILO è <code
              class="filename">/etc/lilo.conf</code>: un file semplice per configurazioni standard è presentato nell'esempio che segue.
			</div><div
            class="example"><a
              xmlns=""
              id="example.lilo.conf"></a><p
              class="title"><strong>Esempio 8.3. File di configurazione di LILO</strong></p><div
              class="example-contents"><pre
                class="programlisting">
# Il disco dove LILO dev'essere installato.
# Indicando il disco e non la partizione.
# ordiniamo a LILO di installarsi nell'MBR.
boot=/dev/sda
# la partizione che contiene Debian
root=/dev/sda2
# l'oggetto da caricare in via predefinita
default=Linux

# la più recente immagine kernel
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Vecchio kernel (in caso il nuovo kernel non parta)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# solo per il doppio avvio Linux/Windows
other=/dev/sda1
  label=Windows</pre></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.config-grub"></a>8.8.3. Configurazione di GRUB 2</h3></div></div></div><a
            id="id-1.11.12.8.2"
            class="indexterm"></a><a
            id="id-1.11.12.8.3"
            class="indexterm"></a><div
            class="para">
				<span
              class="emphasis"><em>GRUB</em></span> (GRand Unified Bootloader) è più recente. Non è necessario lanciarlo dopo ogni aggiornamento del kernel: <span
              class="emphasis"><em>GRUB</em></span> sa come leggere i filesystem e trovare la posizione del kernel nel disco autonomamente. Per installarlo nell'MBR del primo disco è sufficiente digitare <code
              class="command">grub-install /dev/sda</code>. <a
              id="id-1.11.12.8.4.4"
              class="indexterm"></a>
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTA</em></span> Nomi dei dischi per GRUB</strong></p></div></div></div><div
              class="para">
				GRUB può identificare i dischi rigidi solo in base alle informazioni fornite dal BIOS. <code
                class="literal">(hd0)</code> corrisponde al primo disco così individuato, <code
                class="literal">(hd1)</code> al secondo, ecc. In molti casi questo ordine corrisponde esattamente al normale ordine dei dischi su Linux, ma dei problemi possono verificarsi se si associano dischi IDE e SCSI. GRUB conserva le corrispondenze che trova nel file <code
                class="filename">/boot/grub/device.map</code>. Se qui si individuano errori (perché è noto che il proprio BIOS individua i dischi in un ordine differente) è possibile correggerli manualmente ed eseguire <code
                class="command">grub-install</code> nuovamente. <code
                class="command">grub-mkdevicemap</code> può aiutare la creazione di un file <code
                class="filename">device.map</code> da cui iniziare.
			</div><div
              class="para">
				Le partizioni hanno inoltre un nome specifico in GRUB. Quando si usano partizioni «classiche» nel formato MS-DOS, la prima partizione nel primo disco è etichettata <code
                class="literal">(hd0,msdos1)</code>, la seconda <code
                class="literal">(hd0,msdos2)</code>, ecc.
			</div></div><div
            class="para">
				La configurazione di GRUB 2 è conservata in <code
              class="filename">/boot/grub/grub.cfg</code>, ma questo file (in Debian) viene generato da altri. Va ricordato di non modificarlo a mano, poiché queste modifiche andrebbero perse alla successiva esecuzione di <code
              class="command">update-grub</code> (che può avvenire durante l'aggiornamento dei vari pacchetti). Le modifiche più comuni del file <code
              class="filename">/boot/grub/grub.cfg</code> (per esempio per aggiungere parametri alla linea di comando del kernel o per cambiare la durata di visualizzazione del menu) vengono fatte tramite variabili in <code
              class="filename">/etc/default/grub</code>. Per aggiungere voci al menu, è possibile creare un file <code
              class="filename">/boot/grub/custom.cfg</code> o modificare il file <code
              class="filename">/etc/grub.d/50_custom</code>. Per configurazioni più complesse, è possibile modificare i file in <code
              class="filename">/etc/grub.d</code> o aggiungerne; questi script devono restituire frammenti di configurazione, eventualmente facendo uso di programmi esterni. Questi script sono quelli che aggiornano la lista dei kernel da avviare: <code
              class="filename">10_linux</code> prende in considerazione i kernel Linux installati, <code
              class="filename">20_linux</code> considera i sistemi virtuali Xen e <code
              class="filename">30_os-prober</code> elenca gli altri sistemi operativi (Windows, Mac OS X, Hurd).
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.config-yaboot"></a>8.8.4. Per i computer Macintosh (PowerPC): configurare Yaboot</h3></div></div></div><a
            id="id-1.11.12.9.2"
            class="indexterm"></a><div
            class="para">
				Yaboot è il bootloader usato dai vecchi computer Macintosh che usano processori PowerPC. Questi non si avviano come i PC, ma si affidano ad una partizione di «bootstrap» da cui il BIOS (o OpenFirmware) esegue il bootloader e dove il programma <code
              class="command">ybin</code> installa <code
              class="command">yaboot</code> e il suo file di configurazione. Sarà necessario eseguire questo comando ogni qual volta <code
              class="filename">/etc/yaboot.conf</code> viene modificato (viene duplicato sulla partizione di bootstrap e <code
              class="command">yaboot</code> sa come trovare la posizione dei kernel sui dischi).
			</div><div
            class="para">
				Prima di eseguire <code
              class="command">ybin</code> si deve avere un file <code
              class="filename">/etc/yaboot.conf</code> valido. Quello che segue è un esempio di configurazione minimale. <a
              id="id-1.11.12.9.4.3"
              class="indexterm"></a>
			</div><div
            class="example"><a
              xmlns=""
              id="example.yaboot.conf"></a><p
              class="title"><strong>Esempio 8.4. File di configurazione di Yaboot</strong></p><div
              class="example-contents"><pre
                class="programlisting">
# partizione di bootstrap
boot=/dev/sda2
# il disco
device=hd:
# la partizione Linux
partition=3
root=/dev/sda3
# avvia dopo 3 secondi di inattività
# (timeout in 30 decimi di secondo)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# ultimo kernel installato
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# vecchio kernel
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# solo per doppio avvio Linux/Mac OSX
macosx=/dev/sda5

# bsd=/dev/sdaX and macos=/dev/sdaX
# è inoltre possibile</pre></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-printing.html"><strong>Indietro</strong>8.7. Configurazione della stampante</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Risali</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Partenza</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.config-misc.html"><strong>Avanti</strong>8.9. Altre configurazioni: Sincronizzazione Ora, ...</a></li></ul></body></html>
