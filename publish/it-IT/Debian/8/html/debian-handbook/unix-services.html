<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Capitolo 9. Servizi Unix</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-it-IT-1.0-1" /><meta
        name="keywords"
        content="Avvio del sistema, Initscripts, SSH, Telnet, Diritti, Permessi, Supervisione, Inetd, Cron, Backup, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Il Manuale dell'Amministratore Debian" /><link
        rel="up"
        href="index.html"
        title="Il Manuale dell'Amministratore Debian" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Installare un kernel" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Accesso remoto" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/it-IT/stable/unix-services.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Indietro</strong></a></li><li
          class="home">Il Manuale dell'Amministratore Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Avanti</strong></a></li></ul><div
        xml:lang="it-IT"
        class="chapter"
        lang="it-IT"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  xmlns=""
                  id="unix-services"></a>Capitolo 9. Servizi Unix</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. Avvio del sistema</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. Il sistema di init systemd</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. Il sistema di init System V</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Accesso remoto</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Accesso remoto sicuro: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Utilizzo di desktop remoti grafici</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Gestione dei permessi</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Interfacce di amministrazione</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Amministrare tramite un'interfaccia Web: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Configurazione dei pacchetti: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code>, eventi di sistema</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Principi e meccanismi</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. Il file di configurazione</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. Il super-server <code
                    class="command">inetd</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Pianificare attività con <code
                    class="command">cron</code> e <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Formato del file <code
                        class="filename">crontab</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Utilizzo del comando <code
                        class="command">at</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Pianificazione di attività asincrone: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Quote</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Backup</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. Backup con <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. ﻿Ripristino di macchine senza backup</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Collegamento a caldo: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. Premessa</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. Il problema dei nomi</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. Come funziona <span
                        class="emphasis"><em>udev</em></span></a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. Un esempio concreto</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Gestione dell'energia: Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Questo capitolo comprende una serie di servizi di base che sono comuni a molti sistemi Unix. Tutti gli amministratori dovrebbero conoscerli bene.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    xmlns=""
                    id="sect.system-boot"></a>9.1. Avvio del sistema</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			Quando si avvia il computer, i molti messaggi che scorrono sulla console visualizzano molte inizializzazioni e configurazioni automatiche che vengono eseguite. Può capitare di voler modificare un po' come funziona questa fase, il che significa che è necessario conoscerla bene. Questo è lo scopo di questa sezione.
		</div><div
            class="para">
			In primo luogo, il BIOS prende il controllo del computer, rileva i dischi, carica il <span
              class="emphasis"><em>Master Boot Record</em></span>, ed esegue il bootloader. Il bootloader subentra, trova il kernel sul disco, lo carica e lo esegue. Il kernel è quindi inizializzato, e comincia a cercare e montare la partizione contenente il file system root, infine esegue il primo programma — <code
              class="command">init</code>. Spesso, questa "partizione root" e questo <code
              class="command">init</code> sono, di fatto, presenti in un filesystem virtuale che esiste solo nella RAM (da qui il suo nome, "initramfs", precedentemente chiamato "initrd" che sta per "disco RAM di inizializzazione"). Questo filesystem è caricato in memoria dal bootloader, spesso da un file su disco rigido o dalla rete. Contiene il minimo indispensabile richiesto dal kernel per caricare il "vero" filesystem root: possono essere moduli driver per l'hard disk, o altri dispositivi senza i quali il sistema non si avvia, o, più frequentemente, gli script di inizializzazione ed i moduli per il montaggio degli array RAID, l'apertura di partizioni cifrate, l'attivazione di volumi LVM, ecc. Una volta che la partizione di root è montata, initramfs passa il controllo all'init reale, e la macchina torna al processo di avvio standard.
		</div><div
            class="figure"><a
              xmlns=""
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Sequenza di avvio di un computer Linux con systemd" /></div></div><p
              class="title"><strong>Figura 9.1. Sequenza di avvio di un computer Linux con systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.systemd"></a>9.1.1. Il sistema di init systemd</h3></div></div></div><div
              class="para">
				Il "vero init" è attualmente fornito da <span
                class="pkg pkg">systemd</span> e questa sezione documenta questo sistema di init.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURA</em></span> Prima di <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> è un "sistema di init" relativamente recente, ed anche se era già disponibile, in una certa misura, in <span
                  class="distribution distribution">Wheezy</span>, è diventato il predefinito solo in Debian <span
                  class="distribution distribution">Jessie</span>. Le precedenti versioni facevano affidamento, per impostazione predefina, su “System V init” (in the <span
                  class="pkg pkg">sysv-rc</span> package), un sistema molto più tradizionale. Descriveremo il System V init in seguito.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVA</em></span> Altri sistemi di avvio</strong></p></div></div></div><div
                class="para">
				Questo libro descrive il sistema di avvio usato in modo predefinito in Debian <span
                  class="distribution distribution">Jessie</span> (come implementato dal pacchetto <span
                  class="pkg pkg">systemd</span>), come il sistema di default precedente, <span
                  class="pkg pkg">sysvinit</span>, che è derivato ed ereditato dal <span
                  class="emphasis"><em>System V</em></span> dei sistemi Unix; ma ce ne sono altri.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> è un sistema di avvio con un procedimento molto semplice. Mantiene il principio dei runlevel, ma sostituisce le directory e i collegamenti simbolici con un file di configurazione, che indica a <code
                  class="command">init</code> i processi che devono essere avviati e il loro ordine di lancio.
			</div><div
                class="para">
				Il sistema <code
                  class="command">upstart</code> non è ancora perfettamente testato su Debian. È basato su eventi: gli script di init non vengono più eseguiti in un ordine sequenziale, ma in risposta a eventi come il completamento di un altro script da cui essi dipendono. Questo sistema, avviato da Ubuntu, è presente in Debian <span
                  class="distribution distribution">Jessie</span>, ma non è il predefinito; viene fornito, di fatto, in sostituzione di <span
                  class="pkg pkg">sysvinit</span>, e uno dei compiti avviati da <code
                  class="command">upstart</code> è quello di avviare gli script scritti per i sistemi tradizionali, in particolare quelli del pacchetto <span
                  class="pkg pkg">sysv-rc</span>.
			</div><div
                class="para">
				Esistono anche altri sistemi e modalità operative, come <code
                  class="command">runit</code> o <code
                  class="command">minit</code>, ma sono relativamente specializzati e non molto diffusi.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CASO SPECIFICO</em></span> Avvio da rete</strong></p></div></div></div><div
                class="para">
				In alcune configurazioni, il BIOS può essere configurato per non eseguire l'MBR, ma per cercare il suo equivalente in rete, rendendo possibile la costruzione di computer senza un disco rigido, o che sono completamente reinstallati ad ogni avvio. Questa opzione non è disponibile su tutto l'hardware e richiede in genere una combinazione appropriata di BIOS e scheda di rete.
			</div><div
                class="para">
				L'avvio da rete può essere utilizzato per lanciare il <code
                  class="command">debian-installer</code> o FAI (vedere la <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Sezione 4.1, «Modalità di installazione»</a> ).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>FONDAMENTALI</em></span> Il processo, un'istanza di programma</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				Un processo è la rappresentazione in memoria di un programma in esecuzione. Esso comprende tutte le informazioni necessarie per la corretta esecuzione del software (il codice stesso, ma anche i dati che ha in memoria, l'elenco di file che ha aperto, le connessioni di rete che ha stabilito, ecc.). Un programma unico può essere istanziato in vari processi diversi, non necessariamente in esecuzione con diversi ID utente.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SICUREZZA</em></span> Usare una shell come <code
                          class="command">init</code> per ottenere i privilegi di root</strong></p></div></div></div><div
                class="para">
				Per convenzione, il primo processo che viene avviato è il programma <code
                  class="command">init</code> (il quale è per impostazione predefinita un link simbolico a <code
                  class="filename">/lib/systemd/systemd</code>). Tuttavia, è possibile passare un'opzione a <code
                  class="literal">init</code> per il kernel che indica un programma diverso.
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				Chiunque è in grado di accedere al computer può premere il pulsante <span
                  class="keycap"><strong>Reset</strong></span> e quindi riavviare. Poi, al prompt del bootloader, è possibile passare l'opzione <code
                  class="literal">init=/bin/sh</code> per il kernel per ottenere l'accesso come root senza conoscere la password dell'amministratore.
			</div><div
                class="para">
				Per evitare ciò, è possibile proteggere lo stesso bootloader con una password. Si potrebbe anche pensare di proteggere l'accesso al BIOS (un meccanismo di protezione con password è quasi sempre disponibile), senza di ciò un intruso malintenzionato potrebbe ancora avviare la macchina su un supporto rimovibile contenente il proprio sistema Linux, che potrebbe utilizzare per accedere ai dati sull'hard disk del computer.
			</div><div
                class="para">
				Infine, fare attenzione al fatto che la maggior parte dei BIOS dispone di una password generica. Inizialmente destinate alla risoluzione di problemi per coloro che hanno dimenticato la password, queste password sono ora pubbliche e disponibili su Internet (provare a cercare "password generica per BIOS" in un motore di ricerca). Tutte queste protezioni ostacoleranno quindi l'accesso non autorizzato alla macchina senza essere in grado di evitarlo completamente. Non c'è un modo affidabile per proteggere un computer se l'utente malintenzionato può accedervi fisicamente; in ogni caso potrebbe smontare gli hard disk per connetterli a un computer sotto il proprio controllo, o addirittura rubare l'intera macchina, o cancellare la memoria del BIOS per ripristinarne la password…
			</div></div><div
              class="para">
				Systemd esegue diversi processi, responsabili della configurazione del sistema: tastiera, drivers, filesystem, rete, servizi. Lo fa mantenendo una vsione globale del sistema nel suo complesso, ed i requisiti dei componenti. Ciascun componente è descritto da un "file unit" (a volte più); la sintassi generale deriva dalla sintassi ampiamente usata nei "file *.ini", con coppie <code
                class="literal"><em
                  class="replaceable">chiave</em> = <em
                  class="replaceable">valore</em></code> raggruppate tra le intestazioni <code
                class="literal">[<em
                  class="replaceable">section</em>]</code>. I file unit vengono memorizzati in <code
                class="filename">/lib/systemd/system/</code> e <code
                class="filename">/etc/systemd/system/</code>; sono disponibili in vari gusti, ma qui ci si concentrerà su "service" e "target".
			</div><div
              class="para">
				Un "service file" di systemd descrive un processo gestito da systemd. Contiene più o meno le stesso informazioni degli script-init vecchio stile, ma ma espresse in modo dichiarativo (e molto più conciso). systemd gestisce la maggior parte dei compiti ripetitivi (avviare e arrestare il processo, controllare il suo stato, la registrazione, far cadere i privilegi, e così via), ed il service file ha bisogno solo di compilare le specifiche dei processi. Per esempio, questo è un service file per SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				Come si può vedere, c'è poco codice lì dentro, solo dichiarazioni. Systemd si occupa di visualizzare i report, tenendo tracci dei processi, ed anche riavviandoli quando necessario.
			</div><div
              class="para">
				Un "target file" di systemd descrive uno stato del sistema, dove un insieme di servizi sono noti per essere operativi. Può essere pensato come un equivalente del runlevel vecchio-stile. Uno dei target è <code
                class="literal">local-fs.target</code>; quando è raggiunto, il resto del sistema può ritenere tutti i filesystem locali montati ed accessibili. Un'altro target include <code
                class="literal">network-online.target</code> e <code
                class="literal">sound.target</code>. Le dipendenze del target possono essere elencate sia nel file di destinazione (alla riga <code
                class="literal">Requires=</code>), oppure usando un collegamento simbolico al file del servizio nella directory <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code>. Per esempio, <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> contiene un collegamento a <code
                class="filename">/lib/systemd/system/cups.service</code>; systemd si assicurerà quindi che CUPS sia in esecuzione in modo da raggiungere il target <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Dal momento che gli unit file sono dichiararativi e non script o programmi, non possono essere eseguiti direttamente, e sono solo interpretati da systemd; diverese utility consentono quindi all'amministratore di interagire con systemd e controllare lo stato del sistema e di ogni componente.
			</div><div
              class="para">
				La prima di queste utility è <code
                class="command">systemctl</code>. Quando viene eseguita senza argomenti, elenca tutti gli unit file noti a systemd (eccetto quelli che sono stati disabilitati), coì come il loro stato. <code
                class="command">systemctl status</code> dà una migliore visione dei servizi, nonchè dei relativi processi. Se viene passato il nome di un servizio (come in <code
                class="command">systemctl status ntp.service</code>), restituisce ancora più dettagli, così come le ultime righe dei log relativi al servizio (ne parleremo più avanti).
			</div><div
              class="para">
				L'avvio manuale del servizio è una cosa semplice eseguendo <code
                class="command">systemctl start <em
                  class="replaceable">nomedelservizio</em>.service</code>. Come si può intuire, l'arresto di un servizio è fatto con <code
                class="command">systemctl stop <em
                  class="replaceable">nomedelservizio</em>.service</code>; altri comandi includono <code
                class="command">reload</code> e <code
                class="command">restart</code>.
			</div><div
              class="para">
				Per controllare se un servizio è attivo (es. se partirà automaticamente all'avvio), usa <code
                class="command">systemctl enable <em
                  class="replaceable">nomedelservizio</em>.service</code> (oppure <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> permette il controllo dello stato del servizio.
			</div><div
              class="para">
				Una caratteristica interessante di systemd è che include un componente di registrazione chiamato <code
                class="command">journald</code>. Si presenta come un complemento a più sistemi di registrazione tradizionali come <code
                class="command">syslogd</code>, ma aggiunge delle caratteristiche interessanti come un collegamento formale tra un servizio ed i messaggi che genera, e la capacità di cattuare i messaggi generati dalla sua sequenza di avvio. I messaggi possono essere visualizzati in seguito, con un piccolo aiuto da parte del comando <code
                class="command">journalctl</code>. Senza argomenti, sputa fuori semplicemente tutti i messaggi di log che si sono verificati dall'avvio del sistema; raramente è usato in questo modo. La maggior parte delle volte sarà utilizzato con un identificatore del servizio:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				Un'altro utile flag da riga di comando è <code
                class="command">-f</code>, che indica a <code
                class="command">journalctl</code> di mantenere la visualizzazione di nuovi messaggi quando sono emessi (più di quanto faccia <code
                class="command">tail -f <em
                  class="replaceable">file</em></code>).
			</div><div
              class="para">
				Se un servizio sembra non funzionare come previsto, la prima cosa da fare per risolvere il problema è quella di verifica se il servizio sia effettivamente in esecuzione con <code
                class="command">systemctl status</code>; se non lo è, ed i messaggi dati dal primo comando non sono sufficienti a diagnosticare il problema, controllare i log raccolti da journald su quel servizio. Ad esempio, si supponga che il server SSH non funzioni:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				Dopo aver controllato lo stato del servizio (fallito), siamo andati a controllare i registri; indicano un errore nel file di configurazione. Dopo aver modificato il file di configurazione e sistemato l'errore, riavviamo il servizio, quindi verifichiamo che sia effettivamente in funzione.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>APPROFONDIMENTO</em></span> Altri tipi di file unit</strong></p></div></div></div><div
                class="para">
				Abbiamo descritto solo la più fondamentale capacità di systemd in questa sezione. Esso offre molte altre caratteristiche interessanti; qui ne elencheremo solo alcune:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						attivazione socket: un'unità file "socket" può essere usata per descrivere una reteo un socket Unix gestito da systemd; questo significa il socket viene creato da systemd, ed il servizio vero e proprio può essere avviato quando arriva un'effettivo tentativo di connessione. Questo più o meno replica il set di funzionalità di <code
                        class="command">inetd</code>. Vedere <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						timer: un'unità file “timer” descriveeventi che si verificano con una frequenza fissa o a tempo; quando un servizio è collegato a tale timer, il compito corrispondernte verrà eseguito ogni volta che scatterà il timer. Questo permette di replicare parte delle caratteristiche del comando <code
                        class="command">cron</code>. Vedere <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						rete: un file di "rete" descrive un'interfaccia di rete, che permette di configurare tali interfacce oltre che manifestare che un servizio dipende da un particolare interfaccia.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.sysvinit"></a>9.1.2. Il sistema di init System V</h3></div></div></div><div
              class="para">
				Il sistema di init System V (che chiameremo init per brevità) esegue diversi processi, seguendo le istruzione del file <code
                class="filename">/etc/inittab</code>. Il primo programma che viene eseguito (che corrisponde al passo <span
                class="emphasis"><em>sysinit</em></span>) è <code
                class="command">/etc/init.d/rcS</code>, uno script che esegue tutti i programmi contenuti nella directory <code
                class="filename">/etc/rcS.d/</code>. <a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				Tra questi, si trovano successivamente i programmi incaricati di:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						configurare la tastiera della console;
					</div></li><li
                  class="listitem"><div
                    class="para">
						caricare i driver: la maggior parte dei moduli del kernel vengono caricati dal kernel stesso, al rilevamento dell'hardware, altri driver aggiuntivi vengono caricati in seguito automaticamente se i moduli corrispondenti sono elencati nel file <code
                      class="filename">/etc/modules</code>;
					</div></li><li
                  class="listitem"><div
                    class="para">
						verificare l'integrità dei file system;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montare partizioni locali;
					</div></li><li
                  class="listitem"><div
                    class="para">
						configurare la rete;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montare file system di rete (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>FONDAMENTALI</em></span> I moduli del kernel e le opzioni</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				I moduli del kernel hanno anche opzioni che possono essere configurate mettendo alcuni file in <code
                  class="filename">/etc/modprobe.d/</code>. Queste opzioni sono definite con direttive come questa: <code
                  class="literal">options <em
                    class="replaceable">nome-modulo</em> <em
                    class="replaceable">nome-opzione</em>=<em
                    class="replaceable">valore-opzione</em></code>. Diverse opzioni possono essere specificate con un'unica direttiva, se necessario.
			</div><div
                class="para">
				Questi file di configurazione sono destinati a <code
                  class="command">modprobe</code>: il programma che carica un modulo del kernel con le sue dipendenze (i moduli possono infatti chiamare altri moduli). Questo programma è fornito dal pacchetto <span
                  class="pkg pkg">kmod</span>.
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				In seguito a questa fase, subentra <code
                class="command">init</code> e avvia quei programmi attivati nel runlevel predefinito (che di solito è il runlevel 2). Viene eseguito <code
                class="command">/etc/init.d/rc 2</code>, uno script che lancia tutti i servizi che sono elencati in <code
                class="filename">/etc/rc2.d/</code> ed i cui nomi iniziano con la lettera «S». Il numero a due cifre che segue era storicamente utilizzato per definire l'ordine in cui i servizi dovevano essere avviati, ma al giorno d'oggi il sistema di avvio predefinito utilizza <code
                class="command">insserv</code>, che pianifica tutto automaticamente in base alle dipendenze degli script. Ogni script di avvio dichiara in tal modo le condizioni che devono essere soddisfatte per avviare o arrestare il servizio (per esempio, se si deve avviare prima o dopo un altro servizio); <code
                class="command">init</code> poi li esegue nell'ordine che soddisfa queste condizioni. La numerazione statica degli script quindi non è più presa in considerazione (ma devono sempre avere un nome che inizia con una «S» seguita da due cifre ed il nome effettivo dello script usato per le dipendenze). In generale, i servizi di base (come la registrazione con <code
                class="command">rsyslog</code>, o l'assegnazione di porte con <code
                class="command">portmap</code>) vengono avviati per primi, seguiti dai servizi standard e dall'interfaccia grafica (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				Questo sistema di avvio basato su dipendenze consente di automatizzare la rinumerazione, che potrebbe risultare piuttosto noiosa se dovesse essere effettuata manualmente, e limita i rischi di errore umano, poiché la pianificazione viene effettuata secondo i parametri indicati. Un altro vantaggio è che i servizi possono essere avviati in parallelo quando sono indipendenti l'uno dall'altro, e quindi è possibile accelerare il processo di avvio.
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> distingue tra diversi runlevel, in modo da poter passare da uno all'altro con il comando <code
                class="command">telinit <em
                  class="replaceable">nuovo-livello</em></code>. Immediatamente, <code
                class="command">init</code> esegue ancora una volta <code
                class="command">/etc/init.d/rc</code> con il nuovo runlevel. Questo script quindi avvia i servizi mancanti e ferma quelli che non sono più desiderati. Per fare ciò, fa riferimento al contenuto di <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> (dove <em
                class="replaceable">X</em> rappresenta il nuovo runlevel). Gli script che iniziano con «S» (come in «Start») sono i servizi da avviare, quelli che iniziano con «K» (come in «Kill») sono i servizi che devono essere arrestati. Lo script non avvia alcun servizio che era già attivo nel runlevel precedente.
			</div><div
              class="para">
				Per impostazione predefinita, System V init in Debian utilizza quattro diversi runlevel:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Il livello 0 è utilizzato solo temporaneamente, mentre il computer si sta spegnendo. Come tale, esso contiene solo molti script «K».
					</div></li><li
                  class="listitem"><div
                    class="para">
						Il livello 1, noto anche come modalità utente singolo, corrisponde al sistema in modalità degradata; include solo i servizi basilari, ed è destinato ad operazioni di manutenzione in cui le interazioni con gli utenti ordinari non sono desiderate.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Il livello 2 è il livello per il normale funzionamento, che include servizi di rete, un'interfaccia utente grafica, accesso utenti, ecc.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Il livello 6 è simile al livello 0, tranne che è utilizzato durante la fase di arresto che precede un riavvio.
					</div></li></ul></div><div
              class="para">
				Esistono altri livelli, in particolare da 3 a 5. In modo predefinito sono configurati per operare allo stesso modo del livello 2, ma l'amministratore può modificarli (aggiungendo o eliminando script nella corrispondente directory <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>) per adattarli a particolari esigenze.
			</div><div
              class="figure"><a
                xmlns=""
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Sequenza di avvio di un computer Linux con System V init" /></div></div><p
                class="title"><strong>Figura 9.2. Sequenza di avvio di un computer Linux con System V init</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				Tutti gli script contenuti nelle varie directory <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> sono solo collegamenti simbolici, creati con l'installazione del pacchetto per il programma <code
                class="command">update-rc.d</code>, che puntano agli script reali che vengono memorizzati in <code
                class="filename">/etc/init.d/</code>. L'amministratore può regolare i servizi disponibili in ogni runlevel attraverso il comando <code
                class="command">update-rc.d</code> con i parametri corretti. La pagina di manuale di <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> descrive la sintassi in dettaglio. Notare che la rimozione di tutti i collegamenti simbolici (con il parametro <code
                class="literal">remove</code>) non è un buon metodo per disabilitare un servizio. Si dovrebbe invece semplicemente configurare quel servizio per non essere lanciato in quel particolare runlevel (pur conservando le chiamate corrispondenti a fermarlo nel caso in cui il servizio viene eseguito nel runlevel precedente). Dal momento che <code
                class="command">update-rc.d</code> ha un'interfaccia un po' complicata, può essere preferibile usare <code
                class="command">rcconf</code> (presente nel pacchetto <span
                class="pkg pkg">rcconf</span>) che fornisce un'interfaccia più intuitiva.
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN POLICY</em></span> Riavvio dei servizi</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				Gli script dei manutentori dei pacchetti Debian, a volte, riavvieranno alcuni servizi per garantire la loro disponibilità o per tenere conto di alcune opzioni. Il comando che controlla un servizio, <code
                  class="command">service<em
                    class="replaceable">servizio</em> <em
                    class="replaceable">operazione</em></code>, non tiene in considerazione i runlevel, presume (erroneamente) che il servizio sia attualmente in uso, e può quindi iniziare delle operazioni errate (avviare un servizio che è stato deliberatamente fermato, o interrompere un servizio che è già stato arrestato, ecc.). Debian ha pertanto introdotto il programma <code
                  class="command">invoke-rc.d</code>: questo programma deve essere utilizzato dagli script del manutentore per eseguire gli script di inizializzazione dei servizi ed eseguirà solo i comandi necessari. Si noti che, contrariamente all'uso comune, il suffisso <code
                  class="filename">.d</code> è qui usato nel nome di un programma, e non in una directory.
			</div></div><div
              class="para">
				Infine, <code
                class="command">init</code> avvia i programmi di controllo per le varie console virtuali (<code
                class="command">getty</code>). Visualizza un prompt, in attesa di un nome utente, poi esegue <code
                class="command">login <em
                  class="replaceable">utente</em></code> per iniziare una sessione.
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABOLARIO</em></span> Console e terminale</strong></p></div></div></div><div
                class="para">
				I primi computer erano generalmente divisi in diversi componenti molto grandi: il contenitore di memorizzazione e l'unità di elaborazione centrale erano separati dai dispositivi periferici utilizzati dagli operatori per controllarli. Questi facevano parte di un mobile separato, la «console». Questo termine è stato mantenuto, ma il suo significato è cambiato. È diventato più o meno sinonimo di «terminale», essendo una tastiera e uno schermo.
			</div><div
                class="para">
				Con lo sviluppo dei computer, i sistemi operativi hanno offerto diverse console virtuali per consentire diverse sessioni indipendenti contemporaneamente, anche se vi è solo una tastiera e uno schermo. La maggior parte dei sistemi GNU/Linux offrono sei console virtuali (in modalità testo), accessibili digitando le combinazioni di tasti da <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> a <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span> .
			</div><div
                class="para">
				Per estensione i termini «console» e «terminale» possono anche riferirsi ad un emulatore di terminale in una sessione grafica X11 (come <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code> o <code
                  class="command">konsole</code> ).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Indietro</strong>8.11. Installare un kernel</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Risali</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Partenza</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Avanti</strong>9.2. Accesso remoto</a></li></ul></body></html>
