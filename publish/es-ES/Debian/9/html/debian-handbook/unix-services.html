<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Capítulo 9. Servicios Unix</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-es-ES-1.0-1" /><meta
        name="keywords"
        content="Arranque del sistema, Scripts de inicio, SSH, Telnet, Derechos, Permisos, Supervisión, Inetd, Cron, Respaldo, Conexión en caliente («hotplug»), PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="El manual del Administrador de Debian" /><link
        rel="up"
        href="index.html"
        title="El manual del Administrador de Debian" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Instalación de un núcleo" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Inicio de sesión remoto" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/es-ES/stable/unix-services.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Anterior</strong></a></li><li
          class="home">El manual del Administrador de Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Siguiente</strong></a></li></ul><div
        xml:lang="es-ES"
        class="chapter"
        lang="es-ES"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  xmlns=""
                  id="unix-services"></a>Capítulo 9. Servicios Unix</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. Arranque del sistema</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. El sistema de inicio systemd</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. El sistema de inicio System V</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Inicio de sesión remoto</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Inicio seguro de sesión remota: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Utilización de escritorios gráficos remotos</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Administración de permisos</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Interfaces de administración</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Administración en una interfaz web: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Configuración de paquetes: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> Eventos de sistema</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Principio y mecanismo</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. El archivo de configuración</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. El superservidor <code
                    class="command">inetd</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Programación de tareas con <code
                    class="command">cron</code> y <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Formato de un archivo <code
                        class="filename">crontab</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Utilización del programa <code
                        class="command">at</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Programación de tareas asincrónicas: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Cuotas</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Respaldo</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. Respaldos con <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. Restauración de equipos sin repaldos</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Conexión en caliente: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. Introducción</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. El problema de nombres</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. Cómo funciona <span
                        class="emphasis"><em>udev</em></span></a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. Un ejemplo concreto</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Gestión de energía: interfaz avanzada de configuración y energía (ACPI: «Advanced Configuration and Power Interface)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Este capítulo cubre un número básico de servicios que son comunes a varios sistemas Unix. Todos los administradores deberían estar familiarizados con ellos.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    xmlns=""
                    id="sect.system-boot"></a>9.1. Arranque del sistema</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			Cuando inicia el equipo, los muchos mensajes que aparecen en la pantalla muestran varias inicializaciones y configuraciones automáticas que se están ejecutando. Algunas veces deseará alterar ligeramente cómo funciona esta etapa, lo que significa que necesitará entenderlas bien. Éste es el propósito de esta sección.
		</div><div
            class="para">
			Primero el BIOS toma el control del equipo, detecta los discos, carga el <span
              class="emphasis"><em>registro maestro de arranque</em></span> («MBR») y ejecuta el gestor de arranque. Éste toma el control, busca el núcleo en el disco, lo carga y lo ejecuta. Luego se inicializa el núcleo y empieza la búsqueda y montaje de la partición que contiene el sistema de archivos raíz y finalmente ejecuta el primer programa — <code
              class="command">init</code>. Frecuentemente esta «partición raíz» y su <code
              class="command">init</code> están, de hecho, ubicados en un archivo virtual del sistema que sólo existe en RAM (de aquí el nombre «initramfs», anteriormente llamado «initrd» por «disco RAM de inicialización»: «initialization RAM disk»). El gestor de arranque carga este sistema de archivos en memoria, muchas veces desde un archivo en el disco duro o desde la red. Contiene sólo lo mínimo requerido por el núcleo para cargar el «verdadero» sistema de archivos raíz: estos pueden ser módulos de controladores para el disco duro u otros dispositivos sin los cuales el sistema no puede iniciar o, más frecuentemente, scripts de inicialización y módulos para ensamblar arreglos RAID, abrir particiones cifradas, activar volúmenes LVM, etc. Una vez que se monta la partición raíz, el initramfs entrega el control al verdadero init y la máquina regresa al proceso de inicio estándar.
		</div><div
            class="figure"><a
              xmlns=""
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Secuencia de inicio de un equipo ejecutando Linux con systemd" /></div></div><p
              class="title"><strong>Figura 9.1. Secuencia de inicio de un equipo ejecutando Linux con systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.systemd"></a>9.1.1. El sistema de inicio systemd</h3></div></div></div><div
              class="para">
				Actualmente <span
                class="pkg pkg">systemd</span> proporciona el «init real» y esta sección documenta este sistema de inicio.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURA</em></span> Antes de <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> es un "sistema de inicio" relativamente reciente. Aunque ya estaba disponible parcialmente en <span
                  class="distribution distribution">Wheezy</span>, se ha convertido en el sistema de arranque estándar en Debian a partir de <span
                  class="distribution distribution">Jessie</span>. Las versiones anteriores utilizaban de forma predeterminada el sistema de inico "System V” (del paquete <span
                  class="pkg pkg">sysv-rc</span>), un sistema mucho más tradicional. Se describirá el sistema de inicio System V más adelante.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVA</em></span> Otros sistemas de inicio</strong></p></div></div></div><div
                class="para">
				Este libro describe el sistema de inicio utilizado de forma predeterminada en Debian <span
                  class="distribution distribution">Jessie</span> (implementado en el paquete <span
                  class="pkg pkg">systemd</span>), así como el estándar anterior, <span
                  class="pkg pkg">sysvinit</span>, el cual se deriva y hereda de los sistemas Unix «<span
                  class="emphasis"><em>System V</em></span>»; existen otros sistemas de inicio.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> es un sistema de inicio con un proceso muy simple. Mantiene el principio de niveles de ejecución pero reemplaza los directorios y enlaces simbólicos con un archivo de configuración que le indica a <code
                  class="command">init</code> los procesos a iniciar y el orden en el que hacerlo.
			</div><div
                class="para">
				El sistema <code
                  class="command">upstart</code> todavía no ha sido probado perfectamente en Debian. Está basado en eventos: los scripts de inicio no se ejecutan en un orden secuencial sino en respuesta a eventos como la finalización de otro script del que depende. Este sistema, creado por Ubuntu, está presente en Debian <span
                  class="distribution distribution">Jessie</span> pero no es el predeterminado; sólo viene como reemplazo para <span
                  class="pkg pkg">sysvinit</span> y una de las tareas ejecutadas por <code
                  class="command">upstart</code> es ejecutar los scripts escritos para sistemas tradicionales, especialmente aquellos del paquete <span
                  class="pkg pkg">sysv-rc</span>.
			</div><div
                class="para">
				También existen otros sistemas y otros modos de operación, como por ejemplo <code
                  class="command">runit</code> o <code
                  class="command">minit</code> pero estos son bastante especializados y están poco difundidos.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CASO ESPECÍFICO</em></span> Arranque desde la red</strong></p></div></div></div><div
                class="para">
				En algunas situaciones, se puede configurar el BIOS para que no ejecute el MBR sino que busque su equivalente en la red, haciendo posible construir equipos sin disco duro o que son completamente reinstalados en cada arranque. Esta opción no está disponible en todo el hardware y generalmente necesita una combinación apropiada de BIOS y placa de red.
			</div><div
                class="para">
				El arranque desde la red puede utilizarse para ejecutar <code
                  class="command">debian-installer</code> o FAI (revise la <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Sección 4.1, “Métodos de instalación”</a>).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOLVER A LOS CIMIENTOS</em></span> El proceso, una instancia de un programa</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				Un proceso es la representación en memoria de un programa en ejecución. Incluye toda la información necesaria para la ejecución apropiada del programa (el código en sí pero también los datos que tiene en memoria, la lista de archivos que ha abierto, las conexiones de red que ha establecido, etc.). Un único programa puede ser instanciado en varios procesos inclusive bajo el mismo ID de usuario.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SEGURIDAD</em></span> Usar una consola como <code
                          class="command">init</code> para obtener derechos de root</strong></p></div></div></div><div
                class="para">
				Por convención el primer proceso que se inicia es el programa <code
                  class="command">init</code> (que por omisión es un enlace simbóico a <code
                  class="filename">/lib/systemd/systemd</code>). Sin embargo, es posible proveer una opción <code
                  class="literal">init</code> al núcleo indicando un programa diferente.
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				Cualquier persona con acceso al equipo puede presionar el botón <span
                  class="keycap"><strong>Reset</strong></span> y así reiniciarla. Entonces es posible, en el prompt del gestor de arranque, pasar la opción <code
                  class="literal">init=/bin/sh</code> al núcleo para obtener acceso root sin conocer la contraseña del administrador.
			</div><div
                class="para">
				Para prevenirlo puede proteger el gestor de arranque con una contraseña. También podría pensar en proteger el acceso al BIOS (casi siempre tiene disponible un mecanismo de protección por contraseña) sin el cual un intruso malicioso podría iniciar la máquina desde un medio removible que contiene su propio sistema Linux, el cual podría utilizar para tener acceso a los datos del disco duro del equipo.
			</div><div
                class="para">
				Finalmente, tenga en cuenta que la mayoría de los BIOS implementan una contraseña genérica. Inicialmente destinado a resolver los problemas de quienes han olvidado su contraseña, éstas ahora son públicas y están disponibles en Internet (puede comprobarlo Vd. mismo buscando «contraseñas genéricas de BIOS» en algún motor de búsqueda). Todas estas protecciones impedirán el acceso no autorizado a la máquina sin poder evitarlo por completo. No existe una forma segura de proteger un equipo si el atacante puede acceder a él físicamente; podría quitar el disco duro para conectarlo a un equipo bajo su control de cualquier manera, o incluso robar la máquina completa o borrar la memoria del BIOS para eliminar la contraseña…
			</div></div><div
              class="para">
				Systemd ejecuta varios procesos que se encargan de configurar el sistema: teclado, controladores, sistemas de archivos, redes, servicios. Hace esto a la vez que mantiene una visión global del sistema como un todo y de los requerimientos de los componentes. Cada componente se describe en un fichero unidad o "unit file" (a veces más de uno). La sintaxis de los mismos se deriva de la de los muy extendidos archivos ".ini". Es decir que utiliza pares <code
                class="literal"><em
                  class="replaceable">clave</em> = <em
                  class="replaceable">valor</em></code> agrupados entre cabeceras de <code
                class="literal">[<em
                  class="replaceable">sección</em>]</code>. Los archivos unit se guardan en <code
                class="filename">/lib/systemd/system/</code> y <code
                class="filename">/etc/systemd/system/</code>. Aunque hay varios tipos, aquí nos vamos a concentrar en los servicios ("services") y metas ("targets").
			</div><div
              class="para">
				Un archivo de servicio ("service file") de systemd describe un proceso gestionado por systemd. Contiene más o menos la misma información que los antiguos scripts de inicio, pero expresada en de forma declarativa (y mucho más concisa). Systemd se ocupa de la mayoría de las tareas repetitivas (arrancar y parar el proceso, comprobar su estado, registrar los errores, soltar privilegios, etc) y el archivo de servico únicamente tiene que proporcionar los parámetros especificos de cada servicio. Por ejemplo aquí se muestra el fichero de servicio para SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				Como se puede comprobar no hay apenas código, únicamente declaraciones. Systemd se ocupa de mostrar los informes de progreso, de controlar los procesos e incluso de reiniciarlos cuando sea necesario.
			</div><div
              class="para">
				Un fichero de meta ("target file") describe un estado del sistema en el cual se sabe que está operativo un conjunto de servicios. Se puede hacer una analogía los antiguos niveles de ejecución ("runlevels"). Una de las metas es <code
                class="literal">local-fs.target</code>; cuando se alcanza, el resto del sistema puede asumir que todos los sistemas de archivos locales están montados y son accesibles. Otros ejemplos de metas pueden ser <code
                class="literal">network-online.target</code> o <code
                class="literal">sound.target</code>. Las dependencias de una meta se pueden establecer directamente en su archivo de configuración o "target file" (en la línea <code
                class="literal">Requires=</code>) o bien utilizando un enlace simbólico a un archivo de servicio ("service file") en el directorio <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code>. Por ejemplo <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> contiene un enlace a <code
                class="filename">/lib/systemd/system/cups.service</code>; systemd se asegurará de que CUPS esté en ejecución para poder alcanzar la meta <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Puesto que los archivos de unidad son declarativos en lugar de scripts o programas, no se pueden ejecutar directamente; tienen que ser interpretados por systemd. Existen varias utilidades que permiten al administrador interactuar con systemd y controlar el estado del sistema y de cada componente.
			</div><div
              class="para">
				La primera de estas utilidades es <code
                class="command">systemctl</code>. Cuando se ejecuta sin argumentos lista todos los archivos de unidad conocidos por systemd (excepto los que han sido deshabilitados), así como su estado. <code
                class="command">systemctl status</code> muestra una visión mejor de los servicios y sus procesos relacionados. Si se proporciona el nombre de un servico (como p.ej. <code
                class="command">systemctl status ntp.service</code>) muestra aún más detealles, así como las últimas líneas del registro relacionadas con el servicio (más información más adelante).
			</div><div
              class="para">
				Para arrancar un servicio manualmente basta ejecutar <code
                class="command">systemctl start <em
                  class="replaceable">nombredelservicio</em>.service</code>. Como se puede suponer, para parar un servicio se hace con <code
                class="command">systemctl stop <em
                  class="replaceable">nombredelservicio</em>.service</code>; otros subcomandos disponibles son <code
                class="command">reload</code> y <code
                class="command">restart</code>.
			</div><div
              class="para">
				Para establecer si un servicio está activo (es decir, si se debe arrancar automáticamente al inicio o no) utilce el comando <code
                class="command">systemctl enable <em
                  class="replaceable">nombredelservicio</em>.service</code> (o <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> permite saber si está activo o no.
			</div><div
              class="para">
				Una característica interesante de systemd es que incluye un componente de registro llamado <code
                class="command">journald</code>. Viene como complemento a los sistemas de registro tradicionales como <code
                class="command">syslogd</code>, pero añade características interesantes como un enlace formal entre un servicio y los mensajes que genera, así como la posibilidad de capturar los mensajes de error generados por su secuencia de inicialización. Los mensajes se pueden mostrar con la ayuda del comando <code
                class="command">journalctl</code>. Sin argumentos símplemente vuelca todos los mensajes que han ocurrido desde el arranque del sistema, aunque no se suele utilizar de esa forma. Normalmente se utiliza con un identificador de servicio:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				Otra opción útil es <code
                class="command">-f</code>, que hace que <code
                class="command">journalctl</code> siga mostrando los nuevos mensajes a medida que se van emitiendo (semejante a lo que ocurre con <code
                class="command">tail -f <em
                  class="replaceable">file</em></code>).
			</div><div
              class="para">
				Si un servicio parece que no está funcionando como debiera, el primer paso para resolver el problema es comprobar si el servicio está ejecutándose realmente mediante <code
                class="command">systemctl status</code>. Si no es así y los mensajes que se muestran no son suficientes para diagnosticar el problema se pueden comprobar los registros que ha recogido journald relacionados con es servicio. Por ejemplo, suponiendo que el servidor SSH no funciona:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				Después de comprobar el estado del servicio (fallido) comprobamos los registros; indican un error en el archivo de configuración. Después de editar el archivo de configuración y corregir el error reiniciamos el servicio y comprobamos que efectivamente está funcionando.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>YENDO MÁS ALLÁ</em></span> Otros tipos de archivos de unidades</strong></p></div></div></div><div
                class="para">
				Sólo hemos descrito las funciones más básicas de systemd en esta sección, pero ofrece otras muchas características interesantes; a continuación mecionamos algunas:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						activación de zócalos ("sockets"): se puede usar un archivo de unidad de zócalo ("socket unit file") para describir un zócalo de red o Unix gestionado por systemd. Esto significa que systemd creará este zócalo y que se ejecutará el servicio correspondiente cuando exista un intento de conexión al mismo. Con esto se duplica aproximadamente la funcionalidad de <code
                        class="command">inetd</code>. Ver <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						temporizadores: un archivo de unidad de temporizador ("timer unit file") describe eventos que se ejecutan periodicamente o en determinados instantes. Cuando un servicio está enlazado con un temporizador la tarea correspondiente se ejecuta cada vez que se dispare el temporizador. Eso permite replicar parte de la funcionalidad de <code
                        class="command">cron</code>. Ver <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						red: un archivo de unidad de red ("network unit file") describe una interfaz de red y permite su configurarla, así como expresar que un servicio depende de que una interfaz de red determinada esté levantada.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.sysvinit"></a>9.1.2. El sistema de inicio System V</h3></div></div></div><div
              class="para">
				El sistema de incio System V (al cual llamaremos init por brevedad) ejecuta varios procesos siguiendo instrucciones del archivo <code
                class="filename">/etc/inittab</code>. El primer programa que ejecuta (que se corresponde con el paso <span
                class="emphasis"><em>sysinit</em></span>) es <code
                class="command">/etc/init.d/rcS</code>, un script que ejecuta todos los programas del directorio <code
                class="filename">/etc/rcS.d/</code>. <a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				Entre estos encontrará sucesivamente programas a cargo de:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						configurar el teclado de la consola;
					</div></li><li
                  class="listitem"><div
                    class="para">
						cargar controladores: el núcleo carga por sí mismo la mayoría de los módulos a medida que el hardware es detectado; los controladores extras se cargan automáticamente cuando los módulos correspondientes son listados en <code
                      class="filename">/etc/modules</code>;
					</div></li><li
                  class="listitem"><div
                    class="para">
						verificar la integridad de los sistemas de archivos;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montar particiones locales;
					</div></li><li
                  class="listitem"><div
                    class="para">
						configurar la red;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montar sistemas de archivos de red (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOLVER A LOS CIMIENTOS</em></span> Módulos y opciones del núcleo</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				Los módulos del núcleo también tienen opciones que puede configurar agregando algunos archivos en <code
                  class="filename">/etc/modprobe.d/</code>. Estas opciones se definen con directivas como: <code
                  class="literal">options <em
                    class="replaceable">nombre-del-módulo</em> <em
                    class="replaceable">nombre-opción</em>=<em
                    class="replaceable">valor-opción</em></code>. Puede especficar varias opciones con una sola directiva si es necesario.
			</div><div
                class="para">
				Estos archivos de configuración están destinados a <code
                  class="command">modprobe</code> — el programa que carga un módulo de núcleo con sus dependencias (los módulos también pueden llamar otros módulos). El paquete <span
                  class="pkg pkg">kmod</span> provee este programa.
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				Despues de esta etapa, <code
                class="command">init</code> toma el control e inicia los programas activados en el nivel de ejecución («runlevel») predeterminado (generalmente el nivel 2). Ejecuta <code
                class="command">/etc/init.d/rc 2</code>, un script que inicia todos los servicios enumerados en <code
                class="filename">/etc/rc2.d/</code> y aquellos cuyos nombres comiencen con la letra «S». Los números de dos cifras que le sigue fueron utilizados históricamente para definir el orden en el que se iniciarán los servicios, pero actualmente el sistema de inicio predeterminado utiliza <code
                class="command">insserv</code>, que programa todo automáticamente basándose en las dependencias de los scripts. Cada script de inicio, por lo tanto, declara las condiciones a cumplir para iniciar o detener el servicio (por ejemplo, si debe iniciar antes o después de otro servicio); <code
                class="command">init</code> luego los ejecuta en un orden que satisfaga estas condiciones. El enumerado estático de los scripts ya no se tiene en cuenta (pero sus nombres siempre deben comenzar con «S» seguidos de dos números y el nombre real del script utilizado para dependencias). Generalmente, se inician primero los servicios de base (como los registros con <code
                class="command">rsyslogd</code> o la asociación de puertos con <code
                class="command">portmap</code>) seguidos de los servicios estándar y la interfaz gráfica (<code
                class="command">gdm</code>).
			</div><div
              class="para">
				Este sistema de inicio basado en dependencias hace posible renumerar automáticamente los scripts, lo que sería tediososo de hacer manualmente y limita el riesgo de error humano ya que se realiza la programación según los parámetros indicados. Otro beneficio es que se pueden iniciar los servicios en paralelo cuando son independientes entre ellos, lo cual puede acelerar el proceso de inicio.
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> distingue varios niveles de ejecución («runlevel») y puede cambiar de uno a otro ejecutando <code
                class="command">telinit <em
                  class="replaceable">nuevo-nivel</em></code>. Inmediatamente, <code
                class="command">init</code> ejecuta nuevamente <code
                class="command">/etc/init.d/rc</code> con el nuevo nivel de ejecución. Luego, este script ejecutará los servicios faltantes y detendrá aquellos que ya no se desean. Para hacerlo, se refiere al contenido del archivo <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> (donde <em
                class="replaceable">X</em> representa el nuevo nivel de ejecución). Los scripts cuyos nombres comienzan con «S» (por «start», iniciar) son los servicios a iniciar; aquellos cuyos nombres comienzan con «K» (por «kill», matar) son los servicios a detener. El script no inicia ningún servicio que ya haya estado activo en el nivel de ejecución anterior.
			</div><div
              class="para">
				De forma predeterminada, el inicio System V en Debian utiliza cuatro niveles de ejecución diferentes:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Nivel 0: sólo se lo utiliza temporalmente mientras se apaga el equipo. Como tal, sólo contiene scripts «K».
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nivel 1: también conocido como modo de usuario único, corresponde al sistema en modo degradado; sólo incluye servicios básicos y está destinado a operaciones de mantenimiento donde no se desea la interacción con usuarios normales.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nivel 2: es el nivel para operaciones normales, lo que incluye servicios de red, una interfaz gráfica, sesiones de usuario, etc.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Nivel 6: similar a nivel 0, excepto a que es utilizada durante la fase de cierre que precede a un reinicio.
					</div></li></ul></div><div
              class="para">
				Existe otros niveles, especialmente del 3 al 5. De forma predeterminara están configurados para operar de la misma forma que el nivel 2, pero el administrador puede modificarlos (agregando o eliminando scripts en los directorios <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> correspondientes) para adaptarlos a necesidades particulares.
			</div><div
              class="figure"><a
                xmlns=""
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Secuencia de inicio de un equipo ejecutando Linux con inicio System V" /></div></div><p
                class="title"><strong>Figura 9.2. Secuencia de inicio de un equipo ejecutando Linux con inicio System V</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				Todos los scripts en los varios directorios <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> son sólo enlaces simbólicos — creados durante la instalación del paquete por el programa <code
                class="command">update-rc.d</code> — que apuntan a los scripts reales que están almacenados en <code
                class="filename">/etc/init.d/</code>. El administrador puede ajustar los servicios disponibles en cada nivel de ejecución ejecutando <code
                class="command">update-rc.d</code> nuevamente con los parámetros correctos. La página de manual <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> describe la sintaxis en detalle. Sepa que eliminar todos los enlaces simbólicos (con el parámetro <code
                class="literal">remove</code>) no es un buen método de desactivar un servicio. En su lugar, simplemente debería configurar para que el mismo no se ejecute en el nivel de ejecución deseado (preservando las llamadas para detenerlo en caso que el servicio esté ejecutando en el nivel de ejecución anterior). Debido a que <code
                class="command">update-rc.d</code> tiene una interfaz bastante compleja, puede preferir utilizar <code
                class="command">rcconf</code> (en el paquete <span
                class="pkg pkg">rcconf</span>) que provee una interfaz mucho más amigable.
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>NORMATIVA DEBIAN</em></span> Reinicialización de servicios</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				Los scripts de mantenimiento para paquetes Debian a veces reinician algunos servicios para asegurar su disponibilidad o conseguir que tengan en cuenta algunas opciones. El script que controla un servicio — <code
                  class="command">service <em
                    class="replaceable">servicio</em> <em
                    class="replaceable">operación</em></code> — no tiene en cuenta el nivel de ejecución, asume (incorrectamente) que el servicio está siendo utilizado actualmente y, por lo tanto, puede iniciar operaciones incorrectas (iniciar un servicio que fue detenido deliberadamente o detener un servicio que no está ejecutando, etc.). Por lo tanto, Debian introdujo el programa <code
                  class="command">invoke-rc.d</code>: los scripts de mantenimiento deben utilizar este programa para ejecutar scripts de inicialización de servicios que sólo ejecutarán las órdenes necesarias. Sepa que, contrario al uso común, aquí se utiliza el sufijo <code
                  class="filename">.d</code> en el nombre de un programa y no en un directorio.
			</div></div><div
              class="para">
				Finalmente, <code
                class="command">init</code> inicia los programas de control para varias consolas virtuales (<code
                class="command">getty</code>). Muestra un prompt esperando por un nombre de usuario y luego ejecuta <code
                class="command">login <em
                  class="replaceable">usuario</em></code> para iniciar una sesión.
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULARIO</em></span> Consola y terminal</strong></p></div></div></div><div
                class="para">
				Los primeros equipos generalmente estaban separados en varias partes muy grandes: el compartimiento de almacenamiento y la unidad de procesamiento central estaban separados de los dispositivos periféricos que los operadores utilizaban para controlarlos. Éstos eran parte de un mobiliario separado: la «consola». Se mantuvo este término pero cambió su significado. Se convirtió, de cierta forma, en sinónimo de «terminal» (un teclado y una pantalla).
			</div><div
                class="para">
				Con el desarrollo de la tecnología, los sistemas operativos han ofrecido varias consolas virtuales que permiten varias sesiones independientes al mismo tiempo, aún si sólo hay un teclado y pantalla. La mayoría de los sistemas GNU/Linux ofrecen seis consolas virtuales (en modo texto) a las que puede acceder presionando las combinaciones de teclas <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> a <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span>.
			</div><div
                class="para">
				Por extensión, los términos «consola» y «terminal» también pueden hacer referencia a emuladores de terminales en una sesión gráfica X11 (como <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code> o <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Anterior</strong>8.11. Instalación de un núcleo</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Subir</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Inicio</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Siguiente</strong>9.2. Inicio de sesión remoto</a></li></ul></body></html>
