<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.5. SELinux の紹介</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ja-JP-1.0-1" /><meta
        name="keywords"
        content="ファイアウォール, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="Debian 管理者ハンドブック" /><link
        rel="up"
        href="security.html"
        title="第 14 章 セキュリティ" /><link
        rel="prev"
        href="sect.apparmor.html"
        title="14.4. AppArmor の紹介" /><link
        rel="next"
        href="sect.other-security-considerations.html"
        title="14.6. セキュリティ関連で他に考慮すべき点" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/ja-JP/stable/sect.selinux.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.apparmor.html"><strong>戻る</strong></a></li><li
          class="home">Debian 管理者ハンドブック</li><li
          class="next"><a
            accesskey="n"
            href="sect.other-security-considerations.html"><strong>次へ</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.selinux"></a>14.5. SELinux の紹介</h2></div></div></div><a
          id="id-1.17.8.2"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.selinux-principles"></a>14.5.1. 原理</h3></div></div></div><div
            class="para">
				SELinux (<span
              class="emphasis"><em>Security Enhanced Linux</em></span>) は Linux の LSM (<span
              class="emphasis"><em>Linux Security Modules</em></span>) インターフェース上に設けられた<span
              class="emphasis"><em>強制アクセス制御</em></span>システムです。具体的に言えば、カーネルはそれぞれのシステムコールの前にシステムコールを発行したプロセスが指定された操作に対する権限を与えられているか SELinux に問い合わせます。
			</div><div
            class="para">
				SELinux はまとめて<span
              class="emphasis"><em>ポリシー</em></span>として知られているルール群を使い、操作を許可したり禁止したりします。これらのルールの作成は難しいです。幸いなことに、設定作業の大部分を避けるために 2 種類の標準的なポリシー (<span
              class="emphasis"><em>targeted</em></span> と <span
              class="emphasis"><em>strict</em></span>) が提供されています。
			</div><div
            class="para">
				SELinux を使うと、権限管理が伝統的な Unix システムとは全く違ったものになります。プロセスの権限は SELinux の<span
              class="emphasis"><em>セキュリティコンテキスト</em></span>に依存します。SELinux の<span
              class="emphasis"><em>セキュリティコンテキスト</em></span>はプロセスを開始したユーザの <span
              class="emphasis"><em>SELinux ユーザ名</em></span>、<span
              class="emphasis"><em>SELinux ロール</em></span>、ユーザがプロセス開始時点で持っていた <span
              class="emphasis"><em>SELinux ドメイン</em></span>によって定義されます。正しく言えばプロセスの権限は SELinux ドメインに依存しますが、SELinux ドメイン間の遷移は SELinux ロールによって制御されます。最後に SELinux ロール間の遷移の可否は SELinux ユーザ名に依存します。
			</div><div
            class="figure"><a
              xmlns=""
              id="id-1.17.8.3.5"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/selinux-context.png"
                  alt="セキュリティコンテキストと Unix ログイン名" /></div></div><p
              class="title"><strong>図 14.3 セキュリティコンテキストと Unix ログイン名</strong></p></div><div
            class="para">
				具体的に言えば、ログイン時にユーザはデフォルトのセキュリティコンテキストを割り当てられます (セキュリティコンテキストはユーザに与える SELinux ロールに依存します)。セキュリティコンテキストは現在の SELinux ドメインを定義し、ここで定義された SELinux ドメインが新しい子プロセスに割り当てられます。ユーザが現在の SELinux ロールと SELinux ロールに対応する SELinux ドメインを変更したい場合、<code
              class="command">newrole -r <em
                class="replaceable">role_r</em> -t <em
                class="replaceable">domain_t</em></code> を実行しなければいけません (通常 SELinux ロールと SELinux ドメインは一対一に対応しているため、<code
              class="literal">-t</code> パラメータは省略されることが多いです)。<code
              class="command">newrole</code> コマンドはユーザに自分のパスワードを入力させることで認証を行います。この機能のおかげで、プログラムが自動的に SELinux ロールを切り替えることを禁止できます。SELinux ロールの変更を行えるのは、ユーザが SELinux ポリシーに基づいて SELinux ロールの変更を許可されている場合に限ります。
			</div><div
            class="para">
				権限がすべての<span
              class="emphasis"><em>オブジェクト</em></span> (ファイル、ディレクトリ、ソケット、デバイスなど) に適用されないのは明らかです。権限はオブジェクトによって異なります。これを実現するために、それぞれのオブジェクトは <span
              class="emphasis"><em>SELinux タイプ</em></span> と結び付けられています (これをラベリングと呼びます)。このため SELinux ドメインの権限はオブジェクトの SELinux タイプ (および、与えられた SELinux タイプによって間接的にラベリングされたすべてのオブジェクト) に対する一連の許可された (されていない) 操作を使って表現されます。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>EXTRA</em></span> SELinux ドメインと SELinux タイプは同じ</strong></p></div></div></div><div
              class="para">
				内部的なことを言えば、SELinux ドメインは SELinux タイプに過ぎません。しかし SELinux タイプはプロセスにのみ適用されます。このため、SELinux ドメインはオブジェクトの SELinux タイプと同様に <code
                class="literal">_t</code> を末尾に付けられています。
			</div></div><div
            class="para">
				デフォルトで、プログラムはプログラムを起動したユーザに割り当てられた SELinux ドメインを継承しますが、標準的な SELinux のポリシーは多くの重要なプログラムが専用の SELinux ドメインで実行されることを要求しています。これを成し遂げるために、重要なプログラムの実行ファイルは専用の SELinux タイプでラベリングされています (たとえば、<code
              class="command">ssh</code> は <code
              class="literal">ssh_exec_t</code> でラベリングされています。<code
              class="command">ssh</code> プログラムが起動すると <code
              class="command">ssh</code> プログラムは <code
              class="literal">ssh_t</code> SELinux ドメインに自動的に切り替わります)。この自動 SELinux ドメイン遷移メカニズムによって、それぞれのプログラムに対して必要な権限だけを認めることが可能です。これが SELinux の基本原則です。
			</div><div
            class="figure"><a
              xmlns=""
              id="id-1.17.8.3.10"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/selinux-transitions.png"
                  alt="SELinux ドメイン間の自動遷移" /></div></div><p
              class="title"><strong>図 14.4 SELinux ドメイン間の自動遷移</strong></p></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>IN PRACTICE</em></span> セキュリティコンテキストの検索</strong></p></div></div></div><a
              id="id-1.17.8.3.11.2"
              class="indexterm"></a><a
              id="id-1.17.8.3.11.3"
              class="indexterm"></a><a
              id="id-1.17.8.3.11.4"
              class="indexterm"></a><div
              class="para">
				あるプロセスのセキュリティコンテキストを表示するには、<code
                class="command">ps</code> の <code
                class="literal">Z</code> オプションを使うべきです。
			</div><pre
              class="screen"><code
                class="computeroutput">$ </code><strong
                class="userinput"><code>ps axZ | grep vstfpd</code></strong>
<code
                class="computeroutput">system_u:system_r:ftpd_t:s0   2094 ?    Ss  0:00 /usr/sbin/vsftpd</code></pre><div
              class="para">
				最初のフィールドをコロンで区切ると、SELinux ユーザ名、SELinux ロール、SELinux ドメイン、MCS レベルの情報がわかります。MCS レベル (<span
                class="emphasis"><em>Multi-Category Security</em></span>) は機密性保護ポリシーのセットアップに干渉するパラメータで、ファイルの重要性に基づいてファイルへのアクセスを管理するものです。本書では MCS の機能を説明しません。
			</div><div
              class="para">
				シェルから現在のセキュリティコンテキストを表示するには、<code
                class="command">id -Z</code> を実行するべきです。
			</div><pre
              class="screen"><code
                class="computeroutput">$ </code><strong
                class="userinput"><code>id -Z</code></strong>
<code
                class="computeroutput">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><div
              class="para">
				最後に、ファイルに割り当てられた SELinux タイプを表示するには <code
                class="command">ls -Z</code> を使います。
			</div><pre
              class="screen"><code
                class="computeroutput">$ </code><strong
                class="userinput"><code>ls -Z test /usr/bin/ssh</code></strong>
<code
                class="computeroutput">unconfined_u:object_r:user_home_t:s0 test
     system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</code></pre><div
              class="para">
				ファイルに割り当てられた SELinux ユーザ名と SELinux ロールには特別な重要性がない (一切使われない) 点は注目に値しますが、統一性を保つ目的ですべてのオブジェクトは完全なセキュリティコンテキストを割り当てられています。
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.selinux-setup"></a>14.5.2. SELinux のセットアップ</h3></div></div></div><div
            class="para">
				SELinux のサポートは Debian の提供する標準的なカーネルに組み込まれています。コア Unix ツールは SELinux をサポートしており、修正は必要ありません。このため、SELinux を有効化することは比較的簡単です。
			</div><div
            class="para">
				<code
              class="command">apt install selinux-basics selinux-policy-default</code> コマンドで、SELinux システムを設定するために必要なパッケージが自動的にインストールされます。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CAUTION</em></span> jessie にはリファレンスポリシーが含まれません</strong></p></div></div></div><div
              class="para">
				残念なことに <span
                class="pkg pkg">refpolicy</span> ソースパッケージのメンテナがリリースクリティカルバグを修正しなかったため、<span
                class="pkg pkg">refpolicy</span> ソースパッケージは jessie から削除されました。このため、現在のところ <span
                class="pkg pkg">selinux-policy-*</span> パッケージは jessie に含まれず、別の場所から <span
                class="pkg pkg">selinux-policy-*</span> パッケージを入手してインストールする必要があります。うまくいけば、<span
                class="pkg pkg">selinux-policy-*</span> パッケージはポイントリリースの 1 つか jessie-backports に含まれることでしょう。それまでの間は、不安定版から <span
                class="pkg pkg">selinux-policy-*</span> パッケージを入手することが可能です。
			</div><div
              class="para">
				この悲しい状況は少なくとも SELinux は Debian の開発版を使っているユーザおよび開発者から高評価を得られないでいることを示しています。そんなわけで、SELinux を使うことを決めた場合、デフォルトポリシーが完全に動くことを期待せず、自分の要求に適したポリシーを作るまでにかなりの時間を費やす覚悟が必要です。
			</div></div><div
            class="para">
				<span
              class="pkg pkg">selinux-policy-default</span> パッケージには、標準的なルールが含まれています。デフォルトで、このポリシーは広範囲にわたって提供されるサービスへのアクセスを制限するだけです。ユーザセッションは制限されませんから、SELinux が正当なユーザ操作を妨害することはほとんどありません。しかしながら、このポリシーはマシンで実行されているシステムサービスのセキュリティを強化します。古い「strict」ルールと同じポリシーをセットアップするには、<code
              class="literal">unconfined</code> モジュールを無効化しなければいけません (モジュール管理に関してはこの節でさらに詳しく説明しています)。
			</div><div
            class="para">
				<span
              class="pkg pkg">selinux-policy-default</span> パッケージをインストールしたら、すべての利用できるファイルをラベリングするべきです (これはファイルに SELinux タイプを割り当てることを意味します)。この操作は <code
              class="command">fixfiles relabel</code> を使って手作業で開始しなければいけません。
			</div><div
            class="para">
				これで SELinux システムの準備が整いました。SELinux を有効化するには、<code
              class="literal">selinux=1 security=selinux</code> パラメータを Linux カーネルに追加する必要があります。<code
              class="literal">audit=1</code> パラメータを指定した場合、SELinux のログ記録が有効化され、すべての拒否された操作が記録されます。最後に <code
              class="literal">enforcing=1</code> パラメータを指定した場合、ルールをアプリケーションに強制します。<code
              class="literal">enforcing=1</code> パラメータを指定しなかった場合、SELinux はデフォルトの <span
              class="emphasis"><em>permissive</em></span> モードで動作します。<span
              class="emphasis"><em>permissive</em></span> モードの場合、拒否された操作はログ記録され、実行されます。このため、GRUB ブートローダ設定ファイルを変更して必要なパラメータを追加するべきです。これを簡単に行うには、<code
              class="filename">/etc/default/grub</code> の中の <code
              class="literal">GRUB_CMDLINE_LINUX</code> 変数に必要なパラメータを追加し、<code
              class="command">update-grub</code> を実行します。SELinux は再起動後に動作状態になります。
			</div><div
            class="para">
				<code
              class="command">selinux-activate</code> スクリプトを使うことで、GRUB ブートローダ設定ファイルに対する変更操作が自動化され、次回起動時にラベリングが強制されます (強制的にラベリングすることで SELinux がまだ動作していなかった時とラベリングの実行中にラベリングされていないファイルが新しく作成されることを避けることが可能です)。この点は注目に値します。
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.selinux-management"></a>14.5.3. SELinux システムの管理</h3></div></div></div><a
            id="id-1.17.8.5.2"
            class="indexterm"></a><a
            id="id-1.17.8.5.3"
            class="indexterm"></a><div
            class="para">
				<span
              class="pkg pkg">selinux-policy-default</span> パッケージに含まれる SELinux ポリシーはモジュール式のルール群で、<span
              class="pkg pkg">selinux-policy-default</span> パッケージはインストール時にインストール済みのサービスに基づいて対応するモジュールを自動的に検出して有効化します。そのため、システムは SELinux ポリシーをすぐに利用できるようになります。しかしながら、SELinux ポリシーを設定した後にサービスをインストールした場合、対応するモジュールを手作業で有効化する必要があります。これを行うのが <code
              class="command">semodule</code> コマンドです。さらに、管理者はそれぞれのユーザに与える SELinux ロールを定義する能力を持っていなければいけません。これは <code
              class="command">semanage</code> を使って行います。
			</div><div
            class="para">
				このため <code
              class="command">semodule</code> と <code
              class="command">semanage</code> コマンドは <code
              class="filename">/etc/selinux/default/</code> に保存されている現在の SELinux 設定を変更するために使われます。<code
              class="filename">/etc/</code> に配置されている SELinux 以外の設定ファイルと異なり、SELinux の設定ファイルはすべて手作業で修正されなければいけません。管理者は SELinux 設定ファイルを編集するために設計されたプログラムを使うべきです。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>GOING FURTHER</em></span> 追加的文書</strong></p></div></div></div><div
              class="para">
				NSA は SELinux に関する公式の文書を提供していないので、それを埋め合わせるためにコミュニティが wiki を設置しています。wiki には多くの情報が寄せ集められていますが、多くの SELinux 貢献者が Fedora ユーザである点に気が付くでしょう (Fedora は SELinux をデフォルトで有効化しています)。そのため、wiki の文書は Fedora の問題の対処に特化しています。<div
                xmlns=""
                class="url">→ <a
                  xmlns="http://www.w3.org/1999/xhtml"
                  href="http://www.selinuxproject.org">http://www.selinuxproject.org</a></div>
			</div><div
              class="para">
				管理者ならば、SELinux に関する専用の Debian wiki ページおよび Russell Coker のブログを見るべきです。Russell Coker は SELinux サポートに取り組んでいる、最も活動的な Debian 開発者の 1 人です。<div
                xmlns=""
                class="url">→ <a
                  xmlns="http://www.w3.org/1999/xhtml"
                  href="http://wiki.debian.org/SELinux">http://wiki.debian.org/SELinux</a></div><div
                xmlns=""
                class="url">→ <a
                  xmlns="http://www.w3.org/1999/xhtml"
                  href="http://etbe.coker.com.au/tag/selinux/">http://etbe.coker.com.au/tag/selinux/</a></div>
			</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.5.7"></a>14.5.3.1. SELinux モジュールの管理</h4></div></div></div><div
              class="para">
					利用できる SELinux モジュールは <code
                class="filename">/usr/share/selinux/default/</code> ディレクトリに保存されています。現在の設定の中で SELinux モジュールの 1 つをインストールするには、<code
                class="command">semodule -i <em
                  class="replaceable">module.pp.bz2</em></code> を使うべきです。<span
                class="emphasis"><em>pp.bz2</em></span> 拡張子は bzip2 で圧縮された<span
                class="emphasis"><em>ポリシーパッケージ</em></span>を意味しています。
				</div><div
              class="para">
					現在の設定からモジュールを削除するには <code
                class="command">semodule -r <em
                  class="replaceable">module</em></code> を使います。最後に、<code
                class="command">semodule -l</code> コマンドは現在インストールされているモジュールとそのバージョンをリストします。モジュールを選択的に有効化するには <code
                class="command">semodule -e</code>、無効化するには <code
                class="command">semodule -d</code> を使います。
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -i /usr/share/selinux/default/abrt.pp.bz2</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -l</code></strong>
<code
                class="computeroutput">abrt    1.5.0   Disabled
accountsd       1.1.0   
acct    1.6.0   
[...]</code>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -e abrt</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -d accountsd</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -l</code></strong>
<code
                class="computeroutput">abrt    1.5.0
accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</code>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -r abrt</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -l</code></strong>
<code
                class="computeroutput">accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</code></pre><div
              class="para">
					<code
                class="command">semodule</code> は <code
                class="literal">-n</code> オプションを付けない限り、すぐさま新しい設定を読み込みます。<code
                class="command">semodule</code> プログラムがデフォルトで現在の設定に対して操作を行う点は注目に値します (現在の設定は <code
                class="filename">/etc/selinux/config</code> 内の <code
                class="literal">SELINUXTYPE</code> 変数によって表されます)。しかし <code
                class="literal">-s</code> オプションを使えば、他の設定に対して操作を行うことも可能です。
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.5.8"></a>14.5.3.2. ユーザの身元管理</h4></div></div></div><div
              class="para">
					ユーザはログイン時に毎回、SELinux ユーザ名を割り当てられます。SELinux ユーザ名はユーザに与える SELinux ロールを定義します。<code
                class="command">semanage</code> コマンドを使えば、2 種類 (Unix ログイン名から SELinux ユーザ名へ、SELinux ユーザ名から SELinux ロールへ) の対応付けを設定することが可能です。
				</div><div
              class="para">
					<code
                class="command">semanage</code> コマンドはサブコマンドごとに管理する要素が決められています。サブコマンドの構文はすべてのサブコマンド間で類似しているとは言うものの、管理者は <span
                class="citerefentry"><span
                  class="refentrytitle">semanage</span>(8)</span> マニュアルページを読むべきです。すべてのサブコマンドに対して共通のオプションが存在します。たとえば <code
                class="literal">-a</code> は追加、<code
                class="literal">-d</code> は削除、<code
                class="literal">-m</code> は修正、<code
                class="literal">-l</code> はリスト、<code
                class="literal">-t</code> は SELinux タイプ (または SELinux ドメイン) の指定を表します。
				</div><div
              class="para">
					<code
                class="command">semanage login -l</code> は Unix ログイン名と SELinux ユーザ名の現在の対応付けをリストします。明確なエントリを設定されていない Unix ログイン名を持つユーザは <code
                class="literal">__default__</code> という Unix ログイン名に対応する SELinux ユーザ名を割り当てられます。<code
                class="command">semanage login -a -s user_u <em
                  class="replaceable">user</em></code> コマンドを使うことで、<em
                class="replaceable">user</em> で指定した Unix ログイン名を持つユーザに <span
                class="emphasis"><em>user_u</em></span> で指定した SELinux ユーザ名を割り当てます。最後に、<code
                class="command">semanage login -d <em
                  class="replaceable">user</em></code> は <em
                class="replaceable">user</em> で指定した Unix ログイン名を持つユーザに関連付けられたエントリを削除します。
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage login -a -s user_u rhertzog</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage login -l</code></strong>
<code
                class="computeroutput">
ログイン名                SELinux ユーザー         MLS/MCS 範囲           サービス

__default__          unconfined_u         SystemLow-SystemHigh *
rhertzog             user_u               SystemLow            *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *
# </code><strong
                class="userinput"><code>semanage login -d rhertzog</code></strong></pre><div
              class="para">
					<code
                class="command">semanage user -l</code> は SELinux ユーザ名と許可された SELinux ロールの対応付けをリストします。新しい SELinux ユーザ名を追加する場合、SELinux ユーザ名に対応する SELinux ロールと、個人ファイル (<code
                class="filename">/home/<em
                  class="replaceable">user</em>/*</code>) に SELinux タイプを割り当てるために使われるラベリングプレフィックスが必要になります。このプレフィックスは <code
                class="literal">user</code>、<code
                class="literal">staff</code>、<code
                class="literal">sysadm</code> のどれか 1 つを選ばなければいけません。「<code
                class="literal">staff</code>」プレフィックスを選んだ場合、ファイルの SELinux タイプは「<code
                class="literal">staff_home_dir_t</code>」になります。新しい SELinux ユーザ名を作成するには <code
                class="command">semanage user -a -R <em
                  class="replaceable">roles</em> -P <em
                  class="replaceable">prefix</em> <em
                  class="replaceable">identity</em></code> を使います。最後に、SELinux ユーザ名を削除するには <code
                class="command">semanage user -d <em
                  class="replaceable">identity</em></code> を使います。
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage user -a -R 'staff_r user_r' -P staff test_u</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage user -l</code></strong>
<code
                class="computeroutput">
                ラベリング      MLS/       MLS/
SELinux ユーザー    プレフィックス    MCS レベル    MCS 範囲                         SELinux ロール

root            sysadm     SystemLow  SystemLow-SystemHigh  staff_r sysadm_r system_r
staff_u         staff      SystemLow  SystemLow-SystemHigh  staff_r sysadm_r
sysadm_u        sysadm     SystemLow  SystemLow-SystemHigh  sysadm_r
system_u        user       SystemLow  SystemLow-SystemHigh  system_r
test_u          staff      SystemLow  SystemLow             staff_r user_r
unconfined_u    unconfined SystemLow  SystemLow-SystemHigh  system_r unconfined_r
user_u          user       SystemLow  SystemLow             user_r
# </code><strong
                class="userinput"><code>semanage user -d test_u</code></strong></pre></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.5.9"></a>14.5.3.3. ファイルコンテキスト、ポート、ブール値の管理</h4></div></div></div><div
              class="para">
					各 SELinux モジュールにはファイルラベリングルール群が含まれますが、特別な場合に応じてラベリングルールをカスタマイズすることも可能です。たとえば、ウェブサーバに <code
                class="filename">/srv/www/</code> ファイル階層内のファイルを読むことを許可する場合、<code
                class="command">semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"</code> を実行し、その後 <code
                class="command">restorecon -R /srv/www/</code> を実行します。<code
                class="command">semanage fcontext -a</code> で新しいラベリングルールを登録し、<code
                class="command">restorecon</code> で現在のラベリングルールに基づいてファイルの SELinux タイプを再設定します。
				</div><div
              class="para">
					同様に TCP/UDP ポートをラベリングして、ポート番号とそのポートのリッスンを許可するデーモンを対応付けることが可能です。たとえば、ウェブサーバがポート 8080 番をリッスンすることを可能にしたい場合、<code
                class="command">semanage port -m -t http_port_t -p tcp 8080</code> を実行します。
				</div><div
              class="para">
					一部の SELinux モジュールでは、ブール値オプションを使ってデフォルトルールの挙動を微調整することが可能です。<code
                class="command">getsebool</code> ユーティリティを使ってブール値オプションを調査します (<code
                class="command">getsebool <em
                  class="replaceable">boolean</em></code> は 1 つのオプションを表示し、<code
                class="command">getsebool -a</code> はすべてのオプションを表示します)。<code
                class="command">setsebool <em
                  class="replaceable">boolean</em> <em
                  class="replaceable">value</em></code> コマンドはブール値オプションの現在の値を変更します。<code
                class="literal">-P</code> オプションを付けるとこの修正が永続的なものになります。つまり、新しい値がデフォルトになり、再起動後も適用されることになります。以下の例では、ウェブサーバにホームディレクトリに対するアクセス権を与えています (ユーザが個人的なウェブサイトを <code
                class="filename">~/public_html/</code> の下に作る場合、この設定を使うと便利です)。
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>getsebool httpd_enable_homedirs</code></strong>
<code
                class="computeroutput">httpd_enable_homedirs --&gt; off
# </code><strong
                class="userinput"><code>setsebool -P httpd_enable_homedirs on</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>getsebool httpd_enable_homedirs</code></strong> 
<code
                class="computeroutput">httpd_enable_homedirs --&gt; on</code></pre></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.selinux-custom-rules"></a>14.5.4. ルールの適用</h3></div></div></div><div
            class="para">
				SELinux ポリシーはモジュール式なので、モジュールの用意されていない (場合によっては特注の) アプリケーション用に新しいモジュールを開発する方法を知っておくと良いでしょう。新しいモジュールは<span
              class="emphasis"><em>リファレンスポリシー</em></span>を満足させなければいけません。
			</div><div
            class="para">
				新しいモジュールを作成するには、<span
              class="pkg pkg">selinux-policy-dev</span> および <span
              class="pkg pkg">selinux-policy-doc</span> パッケージが必要です。<span
              class="pkg pkg">selinux-policy-doc</span> パッケージには、標準的なルールに関する文書 (<code
              class="filename">/usr/share/doc/selinux-policy-doc/html/</code>) と新しいモジュールを作成するためのテンプレートとして使えるサンプルファイルが含まれます。これらのファイルをインストールし、さらにしっかりと勉強してください。
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</code></strong>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.fc ./</code></strong>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.if ./</code></strong>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.te ./</code></strong></pre><div
            class="para">
				<code
              class="filename">.te</code> ファイルは最も重要なファイルです。<code
              class="filename">.te</code> ファイルがルールを定義します。<code
              class="filename">.fc</code> ファイルは「ファイルコンテキスト」を定義します。「ファイルコンテキスト」はこのモジュールに関連するファイルに割り当てる SELinux タイプを意味します。<code
              class="filename">.fc</code> ファイルに含まれるデータはファイルのラベリング中に使われます。最後に、<code
              class="filename">.if</code> ファイルはモジュールのインターフェースを定義します。つまり、モジュールのインターフェースは一連の「公開関数」で、他のモジュールはこの関数を使ってここで作成されたモジュールと情報をやり取りします。
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.6.6"></a>14.5.4.1. <code
                      class="filename">.fc</code> ファイルの書き方</h4></div></div></div><div
              class="para">
					以下の例を読めば、<code
                class="filename">.fc</code> ファイルの構造を十分に理解することが可能です。複数のファイルおよび完全なディレクトリツリーに対して同じセキュリティコンテキストを割り当てるために、正規表現を使うことが可能です。
				</div><div
              class="example"><a
                xmlns=""
                id="id-1.17.8.6.6.3"></a><p
                class="title"><strong>例 14.2 <code
                    class="filename">example.fc</code> ファイル</strong></p><div
                class="example-contents"><pre
                  class="programlisting scale"># myapp 実行ファイルのファイルコンテキスト定義:
# ラベル: system_u:object_r:myapp_exec_t
# MLS sensitivity: s0
# MCS categories: &lt;none&gt;

/usr/sbin/myapp         --      gen_context(system_u:object_r:myapp_exec_t,s0)</pre></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.6.7"></a>14.5.4.2. <code
                      class="filename">.if</code> ファイルの書き方</h4></div></div></div><div
              class="para">
					以下の例では、1 番目のインターフェース (「<code
                class="literal">myapp_domtrans</code>」) はアプリケーションを実行できるユーザを制御します。2 番目のインターフェース (「<code
                class="literal">myapp_read_log</code>」) はアプリケーションのログファイルに対する読み込み権限を制御します。
				</div><div
              class="para">
					それぞれのインターフェースは <code
                class="filename">.te</code> ファイルに組み込むことが可能な有効なルール群を生成しなければいけません。そんなわけで、管理者は (<code
                class="literal">gen_require</code> マクロを使って) 使用するすべての SELinux タイプを宣言し、権限を取得するために標準的な指示文を使うべきです。しかしながら、他のモジュールが提供するインターフェースを使うことが可能な点に注意してください。次の節では、これらの権限を表現する方法についてより詳しく説明します。
				</div><div
              class="example"><a
                xmlns=""
                id="id-1.17.8.6.7.4"></a><p
                class="title"><strong>例 14.3 <code
                    class="filename">example.if</code> ファイル</strong></p><div
                class="example-contents"><pre
                  class="programlisting">## &lt;summary&gt;myapp ポリシーの一例&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              ここには myapp に関する追加説明を書きます。
##              &lt;desc&gt; タグの中では書式指定をするために
##              &lt;p&gt;、&lt;ul&gt;、&lt;ol&gt; html タグを使えます。
##      &lt;/p&gt;
##      &lt;p&gt;
##              本ポリシーは myapp の以下に示す機能を動作させるために必要です。
##              &lt;ul&gt;
##              &lt;li&gt;機能 A&lt;/li&gt;
##              &lt;li&gt;機能 B&lt;/li&gt;
##              &lt;li&gt;機能 C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;summary&gt;
##      myapp を実行するために SELinux ドメインを遷移させます。
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      遷移を許可する SELinux ドメイン。
## &lt;/param&gt;
#
interface(`myapp_domtrans',`
        gen_require(`
                type myapp_t, myapp_exec_t;
        ')

        domtrans_pattern($1,myapp_exec_t,myapp_t)
')

########################################
## &lt;summary&gt;
##      myapp のログファイルを読み込みます。
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      myapp のログファイルの読み込みを許可する SELinux ドメイン。
## &lt;/param&gt;
#
interface(`myapp_read_log',`
        gen_require(`
                type myapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')</pre></div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DOCUMENTATION</em></span> <span
                          class="emphasis"><em>リファレンスポリシー</em></span>に関する説明</strong></p></div></div></div><div
                class="para">
					SELinux の<span
                  class="emphasis"><em>リファレンスポリシー</em></span>はフリーソフトウェアプロジェクトのように発展しています。すなわち、ボランティアの貢献が発展を支えています。このプロジェクトは Tresys によってホストされています。Tresys は SELinux 分野における最も活発な企業の 1 つです。Tresys の wiki には、ルールを構築する方法と新しいルールを作成する方法が説明されています。<div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted">https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.writing-a-te-file"></a>14.5.4.3. <code
                      class="filename">.te</code> ファイルの書き方</h4></div></div></div><div
              class="para">
					それでは <code
                class="filename">example.te</code> を見てみましょう。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> <code
                          class="command">m4</code> マクロ言語</strong></p></div></div></div><div
                class="para">
					適切にポリシーを構築するために、SELinux 開発者はマクロコマンドプロセッサを使いました。数多くの類似した <span
                  class="emphasis"><em>allow</em></span> 指示文を複製する代わりに、SELinux 開発者は高レベル論理を取り扱う「マクロ関数」を作成しました。「マクロ関数」のおかげで、ポリシーがとても読みやすくなりました。
				</div><div
                class="para">
					具体的に言えば、<code
                  class="command">m4</code> は複数のルール群から構成されるポリシーを構築するために使われます。マクロ関数は複数のルール群を 1 つの高レベル論理にまとめたものです。つまり、<code
                  class="command">m4</code> はマクロ関数で記述された高レベル論理を <span
                  class="emphasis"><em>allow</em></span> 指示文の巨大データベースに展開します。
				</div><div
                class="para">
					<code
                  class="filename">example.if</code> ファイルの例で使用した SELinux「interface」は単なるマクロ関数であり、<code
                  class="command">m4</code> によるコンパイル時にルール群に置換されます。同様に、実際のところいくつかのパーミッションは単なるパーミッションの集合であり、<code
                  class="command">m4</code> によるコンパイル時にパーミッションの集合に置換されます。
				</div></div><pre
              class="programlisting">policy_module(myapp,1.0.0) <span
                id="example.te.module"><img
                  class="callout"
                  src="Common_Content/images/1.png"
                  alt="1" /></span>

########################################
#
# SELinux タイプと SELinux ドメインの宣言
#

type myapp_t; <span
                id="example.te.type"><img
                  class="callout"
                  src="Common_Content/images/2.png"
                  alt="2" /></span>
type myapp_exec_t;
domain_type(myapp_t)
domain_entry_file(myapp_t, myapp_exec_t) <span
                id="example.te.domain"><img
                  class="callout"
                  src="Common_Content/images/3.png"
                  alt="3" /></span>

type myapp_log_t;
logging_log_file(myapp_log_t) <span
                id="example.te.interface"><img
                  class="callout"
                  src="Common_Content/images/4.png"
                  alt="4" /></span>

type myapp_tmp_t;
files_tmp_file(myapp_tmp_t)

########################################
#
# myapp のローカルポリシー
#

allow myapp_t myapp_log_t:file { read_file_perms append_file_perms }; <span
                id="example.te.allow"><img
                  class="callout"
                  src="Common_Content/images/5.png"
                  alt="5" /></span>

allow myapp_t myapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(myapp_t,myapp_tmp_t,file)</pre><div
              class="calloutlist"><table
                border="0"
                summary="Callout list"><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.module"><img
                          class="callout"
                          src="Common_Content/images/1.png"
                          alt="1" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							モジュールは名前とバージョン番号で識別されます。policy_module マクロは必須です。
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.type"><img
                          class="callout"
                          src="Common_Content/images/2.png"
                          alt="2" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							モジュールによって新しい SELinux タイプが導入される場合、type 文を使って新しい SELinux タイプを必ず宣言してください。多くの無駄な権限を与えるのでなく、必要な SELinux タイプをすべて作成してください。遠慮はいりません。
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.domain"><img
                          class="callout"
                          src="Common_Content/images/3.png"
                          alt="3" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							ここでは <code
                        class="literal">domain_type</code> および <code
                        class="literal">domain_entry_file</code> インターフェースを使って、<code
                        class="literal">myapp_exec_t</code> とラベリングされた実行ファイルによって使われるプロセスの SELinux ドメインとして <code
                        class="literal">myapp_t</code> SELinux タイプを定義しています。こうすることで、暗黙のうちにオブジェクトに <code
                        class="literal">exec_type</code> 属性が追加されます。このおかげで、他のモジュールは <code
                        class="literal">myapp_exec_t</code> とラベリングされたプログラムを実行する権限を取得することが可能になります。たとえば <code
                        class="literal">userdomain</code> モジュールを使うことで、<code
                        class="literal">user_t</code>、<code
                        class="literal">staff_t</code>、<code
                        class="literal">sysadm_t</code> SELinux ドメインを持つプロセスが自分を実行することが可能になります。他の閉じ込められたアプリケーションの SELinux ドメインは、その SELinux ドメインに割り当てられたルールが同様の権限を取得しない限り (たとえば <code
                        class="literal">dpkg_t</code> SELinux ドメインを持つ <code
                        class="command">dpkg</code> がこの場合に相当します)、<code
                        class="literal">myapp_exec_t</code> とラベリングされたプログラムを実行する権限を持ちません。
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.interface"><img
                          class="callout"
                          src="Common_Content/images/4.png"
                          alt="4" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							<code
                        class="literal">logging_log_file</code> はリファレンスポリシーによって提供されるインターフェースです。これは指定された SELinux タイプでラベリングされたファイルはその SELinux タイプに対応するルールから恩恵を受ける義務があるログファイルであることを表します (たとえば、<code
                        class="command">logrotate</code> がログファイルを処理することを可能にするために、<code
                        class="command">logrotate</code> に権限を与える場合に使います)。
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.allow"><img
                          class="callout"
                          src="Common_Content/images/5.png"
                          alt="5" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							<code
                        class="literal">allow</code> 指示文は操作を許可するために使われる基本的な指示文です。1 番目のパラメータはこの操作を実行することを許されたプロセスの SELinux ドメインです。2 番目のパラメータは 1 番目のパラメータで指定した SELinux ドメインのプロセスが操作することが可能なオブジェクトを定義します。2 番目のパラメータは「<em
                        class="replaceable">type</em>:<em
                        class="replaceable">class</em>」の形で定義します。ここで <em
                        class="replaceable">type</em> は SELinux タイプで <em
                        class="replaceable">class</em> はオブジェクトの種類 (ファイル、ディレクトリ、ソケット、名前付きパイプなど) です。最後に、3 番目のパラメータはパーミッション (許可された操作) を表現します。
						</div><div
                      class="para">
							パーミッションは許可された操作の一式として定義され、以下のテンプレートに従います。すなわち <code
                        class="literal">{ <em
                          class="replaceable">operation1</em> <em
                          class="replaceable">operation2</em> }</code> です。しかしながら、最も役に立つパーミッションを表すマクロを使うことも可能です。<code
                        class="filename">/usr/share/selinux/devel/include/support/obj_perm_sets.spt</code> には、最も役に立つパーミッションのマクロが説明されています。
						</div><div
                      class="para">
							以下のウェブページでは、オブジェクトクラスと与えられるパーミッションの比較的包括的なリストが載せられています。<div
                        xmlns=""
                        class="url">→ <a
                          xmlns="http://www.w3.org/1999/xhtml"
                          href="http://www.selinuxproject.org/page/ObjectClassesPerms">http://www.selinuxproject.org/page/ObjectClassesPerms</a></div>
						</div></td></tr></table></div><div
              class="para">
					さらに、対象のアプリケーションやサービスが正しく動くために必要な最低限のルールセットを見つけ出さなければいけません。これを行うには、アプリケーションの動作方法とアプリケーションが管理および生成するデータの種類に関する詳しい知識が必要です。
				</div><div
              class="para">
					しかしながら、経験的なアプローチが使えます。対応するオブジェクトに対する正しいラベリングが終わっていれば、アプリケーションを permissive モードで使うことが可能です。そして permissive モードでは、禁止されるであろう操作はログ記録されて実行されます。このログを解析することで、許可する操作を識別することが可能になります。以下は permissive モードでアプリケーションを動かした場合に記録されるログエントリの例です。
				</div><pre
              class="programlisting">avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1</pre><div
              class="para">
					このメッセージをより詳しく理解するために、それぞれの要素について勉強しましょう。
				</div><div
              class="table"><a
                xmlns=""
                id="id-1.17.8.6.8.10"></a><p
                class="title"><strong>表 14.1 SELinux ログエントリの解析</strong></p><div
                class="table-contents"><table
                  xmlns:d="http://docbook.org/ns/docbook"
                  class="lt-4-cols gt-7-rows"
                  summary="SELinux ログエントリの解析"><colgroup><col /><col /></colgroup><thead><tr><th>メッセージ</th><th>説明</th></tr></thead><tbody><tr><td><code
                          class="computeroutput">avc: denied</code></td><td>操作が拒否されました。</td></tr><tr><td><code
                          class="computeroutput">{ read write }</code></td><td>この操作には <code
                          class="literal">read</code> と <code
                          class="literal">write</code> パーミッションが必要です。</td></tr><tr><td><code
                          class="computeroutput">pid=1876</code></td><td>PID 1876 のプロセスがこの操作を実行しました (または実行を試行しました)。</td></tr><tr><td><code
                          class="computeroutput">comm="syslogd"</code></td><td>プロセスは <code
                          class="literal">syslogd</code> プログラムのインスタンスです。</td></tr><tr><td><code
                          class="computeroutput">name="xconsole"</code></td><td>対象のオブジェクトは <code
                          class="literal">xconsole</code> と名付けられました。場合によってはこれの代わりにフルパスを含む「path」変数が設定されていることもあります。</td></tr><tr><td><code
                          class="computeroutput">dev=tmpfs</code></td><td>対象のオブジェクトをホストしているデバイスは <code
                          class="literal">tmpfs</code> (メモリ内ファイルシステム) です。実ディスクの場合、オブジェクトをホストしているパーティション (たとえば「sda3」) になります。</td></tr><tr><td><code
                          class="computeroutput">ino=5510</code></td><td>オブジェクトは inode 番号 5510 で識別されています。</td></tr><tr><td><code
                          class="computeroutput">scontext=system_u:system_r:syslogd_t:s0</code></td><td>これは操作を実行したプロセスのセキュリティコンテキストです。</td></tr><tr><td><code
                          class="computeroutput">tcontext=system_u:object_r:device_t:s0</code></td><td>これは対象オブジェクトのセキュリティコンテキストです。</td></tr><tr><td><code
                          class="computeroutput">tclass=fifo_file</code></td><td>対象オブジェクトは FIFO ファイルです。</td></tr></tbody></table></div></div><div
              class="para">
					SELinux ログエントリを観察することで、その操作を許可するために必要なルールを構築することが可能です。たとえば例に挙げた操作を許可するルールは <code
                class="literal">allow syslogd_t device_t:fifo_file { read write }</code> のようになります。この作業は自動化することが可能です。これが <code
                class="command">audit2allow</code> コマンド (<span
                class="pkg pkg">policycoreutils</span> パッケージに含まれます) の役割です。設定する必要のある内容に応じてさまざまなオブジェクトが既に正しくラベリングされている場合にのみ、このアプローチは役に立ちます。いずれにせよ、管理者は必ず生成されたルールを注意深く確認し、アプリケーションに対する知識に基づいてルールの妥当性を検査しなければいけません。事実上、このアプローチはアプリケーションが本当に必要としている権限よりも多くの権限を与えようとします。ほとんどの場合、新しい SELinux タイプを作成し、作成した SELinux タイプだけに権限を与えることが適切な解決策と言えます。また、拒否された操作がアプリケーションにとって致命的でない場合もあります。この場合、「<code
                class="literal">dontaudit</code>」ルールを追加するだけに留めることがより良い解決策かもしれません。こうすることで、実際の実行を拒否するのではなくログエントリの記録だけが拒否されます。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>COMPLEMENTS</em></span> SELinux ロールを設定されていないポリシールール</strong></p></div></div></div><a
                id="id-1.17.8.6.8.12.2"
                class="indexterm"></a><a
                id="id-1.17.8.6.8.12.3"
                class="indexterm"></a><div
                class="para">
					新しいルールを作成した際に、SELinux ロールが 1 つも設定されていないことは不思議に見えるかもしれません。SELinux は許されている操作の見つかった SELinux ドメインだけを使います。SELinux ロールはユーザが他の SELinux ドメインに切り替えることを許可することで間接的に権限処理に介在するだけです。SELinux は <span
                  class="emphasis"><em>Type Enforcement</em></span> として知られる理論に基づいており、権限を獲得する際に考慮される要素は SELinux タイプだけです。
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.6.9"></a>14.5.4.4. ファイルのコンパイル</h4></div></div></div><div
              class="para">
					3 個のファイル (<code
                class="filename">example.if</code>、<code
                class="filename">example.fc</code>、<code
                class="filename">example.te</code>) が新しいルールに関する管理者の期待と一致したら、<code
                class="command">make NAME=devel</code> を実行して <code
                class="filename">example.pp</code> ファイルの形でモジュールを生成します (<code
                class="command">semodule -i example.pp</code> を使ってすぐさまこのモジュールをインストールすることが可能です)。複数のモジュールを定義した場合、<code
                class="command">make</code> はすべての対応する <code
                class="filename">.pp</code> ファイルを生成します。
				</div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.apparmor.html"><strong>戻る</strong>14.4. AppArmor の紹介</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上に戻る</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>ホーム</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.other-security-considerations.html"><strong>次へ</strong>14.6. セキュリティ関連で他に考慮すべき点</a></li></ul></body></html>
