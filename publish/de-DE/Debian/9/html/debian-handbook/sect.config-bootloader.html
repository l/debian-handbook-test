<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">8.8. Den Boot-Loader konfigurieren</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-de-DE-1.0-1" /><meta
        name="keywords"
        content="Konfigurierung, Lokalisierung, Sprachumgebungen, Netzwerk, Namensauflösung, Benutzer, Gruppen, Benutzerkonten, Befehlszeileninterpreter, Shell, Drucken, Boot-Loader, Kernel-Kompilierung" /><link
        rel="home"
        href="index.html"
        title="Das Debian Administrationshandbuch" /><link
        rel="up"
        href="basic-configuration.html"
        title="Kapitel 8. Basis-Konfigurierung: Netzwerk, Benutzerkonten, Drucken..." /><link
        rel="prev"
        href="sect.config-printing.html"
        title="8.7. Druckereinrichtung" /><link
        rel="next"
        href="sect.config-misc.html"
        title="8.9. Weitere Konfigurationen: Zeitsynchronisation, Protokolle, Gemeinsamer Zugang…" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/de-DE/stable/sect.config-bootloader.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-printing.html"><strong>Zurück</strong></a></li><li
          class="home">Das Debian Administrationshandbuch</li><li
          class="next"><a
            accesskey="n"
            href="sect.config-misc.html"><strong>Weiter</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.config-bootloader"></a>8.8. Den Boot-Loader konfigurieren</h2></div></div></div><a
          id="id-1.11.12.2"
          class="indexterm"></a><a
          id="id-1.11.12.3"
          class="indexterm"></a><div
          class="para">
			Er funktioniert wahrscheinlich schon, aber trotzdem ist es immer empfehlenswert zu wissen, wie der Boot-Loader konfiguriert und installiert wird für den Fall, dass er aus dem Master Boot Record verschwindet. Dies kann nach der Installierung eines anderen Betriebssystems, wie zum Beispiel Windows, passieren. Die folgenden Informationen können auch dabei helfen, die Konfiguration des Boot-Loaders, falls nötig, zu verändern.
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Master Boot Record</strong></p></div></div></div><a
            id="id-1.11.12.5.2"
            class="indexterm"></a><a
            id="id-1.11.12.5.3"
            class="indexterm"></a><div
            class="para">
			Der Master Boot Record (MBR) belegt die ersten 512 Bytes der ersten Festplatte und ist die erste Sache, die vom BIOS geladen wird, um die Kontrolle an ein Programm zu übergeben, das in der Lage ist, das gewünschte Betriebssystem hochzufahren. Im allgemeinen wird der Boot-Loader in den MBR installiert und damit sein bisheriger Inhalt überschrieben.
		</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.identify-disks"></a>8.8.1. Die Festplatten kennzeichnen</h3></div></div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>KULTUR</em></span> <span
                        class="emphasis"><em>udev</em></span> und <code
                        class="filename">/dev/</code></strong></p></div></div></div><div
              class="para">
				Traditionell enthält das Verzeichnis <code
                class="filename">/dev/</code> sogenannte „spezielle“ (Geräte-)Dateien, die dazu dienten, Peripheriegeräte des Systems zu darzustellen (siehe <a
                class="xref"
                href="sect.creating-accounts.html#sidebar.special-files"><span
                  class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Zugriffsberechtigungen für Geräte</a> in der Seitenleiste). Früher enthielt es alle möglicherweise benötigten Gerätedateien. Dieser Ansatz hat eine ganze Reihe von Nachteilen, wobei die Tatsache, dass die Anzahl der Geräte, die man nutzen konnte, (aufgrund der hart verdrahteten Namen in der Liste) beschränkt war und weil man nicht wissen konnte, welche Gerätedateien gebraucht würden.
			</div><div
              class="para">
				Heute ist die Verwaltung der Gerätedateien vollständig dynamisch und passt besser zur "Hot-Swap"-Eigenschaft von Peripheriegeräten. Der Kernel kooperiert mit <span
                class="emphasis"><em>udev</em></span> um sie zu erzeugen und zu entfernen, wenn die jeweiligen Geräte angeschlossen oder entfernt werden. Aus diesem Grund muss <code
                class="filename">/dev/</code> nicht persistent (dauerhaft) sein und ist deshalb ein anfänglich leeres RAM-Dateisystem, das nur die benötigten Elementen enthält.
			</div><div
              class="para">
				Der Kernel kommuniziert eine Unmenge von Informationen über jedes neu hinzugefügte Gerät und vergibt ein paar Kennungen um diese zu identifizieren. Mit diesen Informationen kann <code
                class="command">udevd</code> die Gerätedatei mit dem gewünschten Namen und den benötigten Berechtigungen anlegen. Zusätzlich können Aliase angelegt und zusätzliche Aktionen (wie Initialisierungen oder Registrierungen) durchgeführt werden. Das Verhalten von <code
                class="command">udevd</code> wird von einer großen Anzahl an Konfigurationsregeln bestimmt.
			</div><div
              class="para">
				Mit dynamisch zugewiesenen Namen kann man den selben Namen für ein bestimmtes Gerät beibehalten, egal welcher Anschluss in welcher Reihenfolge verwendet wird, was gerade bei Verwendung verschiedener USB-Geräte besonders hilfreich ist. Die erste Partition auf der ersten Festplatte kann dann <code
                class="filename">/dev/sda1</code> benannt werden, um rückwärts kompatibel zu sein, oder <code
                class="filename">/dev/root-partition</code> wenn gewünscht oder gar beides zur selben Zeit, da <code
                class="command">udevd</code> so konfiguriert werden kann, dass eine symbolische Verknüpfung angelegt wird.
			</div><div
              class="para">
				In alten Zeiten wurden einige Kernelmodule automatisch geladen, wenn Sie versuchten, auf die entsprechende Gerätedatei zuzugreifen. Dies ist nicht mehr der Fall, und die spezielle Datei des Peripheriegerätes existiert nicht mehr vor dem Laden des Moduls; das ist kein Problem, da die meisten Module dank der automatischen Hardwareerkennung beim Booten geladen werden. Für nicht erkennbare Peripheriegeräte (z.B. sehr alte Laufwerke oder PS/2-Mäuse) funktioniert dies jedoch nicht. Erwägen Sie, die Module, <code
                class="literal">floppy</code>, <code
                class="literal">psmouse</code> und <code
                class="literal">mousedev</code> zu <code
                class="filename">/etc/modules</code> hinzuzufügen, um sie beim Booten zu laden.
			</div></div><a
            id="id-1.11.12.6.3"
            class="indexterm"></a><a
            id="id-1.11.12.6.4"
            class="indexterm"></a><div
            class="para">
				Die Konfiguration des Bootloaders muss die verschiedenen Festplatten und deren Partitionen identifizieren. Linux verwendet dazu die speziellen "Block"-Dateien, die im Verzeichnis <code
              class="filename">/dev/</code> gespeichert sind. Seit Debian <span
              class="distribution distribution">Squeeze</span> wurde das Namensschema für Festplatten durch den Linux-Kernel vereinheitlicht, und alle Festplatten (IDE/PATA, SATA, SCSI, USB, IEEE 1394) werden nun durch <code
              class="filename">/dev/sd*</code> repräsentiert.
			</div><div
            class="para">
				Jede Partition wird durch ihre Nummer auf der Platte, auf der sie liegt, dargestellt: so ist zum Beispiel <code
              class="filename">/dev/sda1</code> die erste Partition auf der ersten Platte, und <code
              class="filename">/dev/sdb3</code> ist die dritte Partition auf der zweiten Platte.
			</div><a
            id="id-1.11.12.6.7"
            class="indexterm"></a><a
            id="id-1.11.12.6.8"
            class="indexterm"></a><a
            id="id-1.11.12.6.9"
            class="indexterm"></a><a
            id="id-1.11.12.6.10"
            class="indexterm"></a><div
            class="para">
				Die PC-Architektur (oder „i386“ und seine jüngere Kusine) war lange Zeit auf die Verwendung des "MS-DOS"-Partitionstabellenformats beschränkt, das nur vier „primäre“ Partitionen je Platte erlaubt. Um über diese Begrenzung hinauszugehen, muss eine von ihnen als „erweiterte“ Partition erstellt werden, die dann weitere „sekundäre“ Partitionen enthalten kann. Diese sekundären Partitionen werden von 5 aufwärts nummeriert werden. So könnte die erste sekundäre Partition <code
              class="filename">/dev/sda5</code> sein, gefolgt von <code
              class="filename">/dev/sda6</code> usw.
			</div><div
            class="para">
				Eine weitere Einschränkung des MS-DOS-Partitionstabellenformats ist, dass es nur Festplatten bis zu einer Größe von 2 TiB zulässt, was bei aktuellen Festplatten zu einem echten Problem wird.
			</div><a
            id="id-1.11.12.6.13"
            class="indexterm"></a><a
            id="id-1.11.12.6.14"
            class="indexterm"></a><div
            class="para">
				Ein neues Partitionstabellenformat namens GPT löst diese Einschränkungen bei der Anzahl der Partitionen (es erlaubt bis zu 128 Partitionen bei Verwendung von Standardeinstellungen) und der Größe der Festplatten (bis zu 8 ZiB, das sind mehr als 8 Milliarden Terabyte). Wenn Sie vorhaben, viele physische Partitionen auf derselben Festplatte zu erstellen, sollten Sie daher sicherstellen, dass Sie die Partitionstabelle im GPT-Format erstellen, wenn Sie Ihre Festplatte partitionieren.
			</div><div
            class="para">
				Es ist nicht immer leicht sich zu merken, welche Platte mit welchem SATA-Controller verbunden ist, oder welche in der SCSI-Kette an dritter Position steht, vor allem, da sich die Benennung von im laufenden Betrieb austauschbaren Festplatten (zu denen unter anderem die meisten SATA-Platten und externen Platten gehören) von einem Hochfahren zum nächsten ändern kann. Zum Glück erstellt <code
              class="command">udev</code> zusätzlich zu <code
              class="filename">/dev/sd*</code> symbolische Verknüpfungen mit festen Namen, die man dann verwenden kann, wenn man eine Festplatte unmissverständlich kennzeichnen möchte. Diese symbolischen Verknüpfungen sind in der Datei <code
              class="filename">/dev/disk/by-id</code> gespeichert. Auf einem Rechner mit zwei physischen Platten könnte man zum Beispiel folgendes finden:
			</div><pre
            class="screen"><code
              class="computeroutput">mirexpress:/dev/disk/by-id# </code><strong
              class="userinput"><code>ls -l</code></strong><code
              class="computeroutput">total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </code></pre><div
            class="para">
				Beachten Sie, dass einige Platten mehrmals aufgeführt sind (da sie gleichzeitig als ATA-Platten und SCSI-Platten auftreten), aber die relevante Information besteht in erster Linie in den Modell- und Seriennummern der Platten, aufgrund derer man die Peripheriedatei finden kann.
			</div><div
            class="para">
				Die in den folgenden Abschnitten als Beispiele benutzten Konfigurationsdateien basieren auf der gleichen Umgebung: eine einzelne SATA-Platte, auf der die erste Partition eine alte Windows-Installation, die zweite ein Debian GNU/Linux enthält.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.config-lilo"></a>8.8.2. LILO konfigurieren</h3></div></div></div><a
            id="id-1.11.12.7.2"
            class="indexterm"></a><a
            id="id-1.11.12.7.3"
            class="indexterm"></a><div
            class="para">
				<span
              class="emphasis"><em>LILO</em></span> (LInux LOader) ist der älteste Boot-Loader - solide aber derb. Er schreibt die physische Adresse des zu ladenden Kernels in den MBR, weshalb im Anschluss an jede Aktualisierung von LILO (oder seiner Konfigurationsdatei) der Befehl <code
              class="command">lilo</code> ausgeführt werden muss. Wenn man dies vergisst, ist das System nicht mehr in der Lage hochzufahren, falls der alte Kernel entfernt oder ersetzt worden ist, da sich der neue auf der Platte nicht an derselben Stelle befindet.
			</div><div
            class="para">
				LILOs Konfigurationsdatei ist <code
              class="filename">/etc/lilo.conf</code>; eine einfache Datei für eine Standardkonfiguration ist in unten stehendem Beispiel wiedergegeben.
			</div><div
            class="example"><a
              xmlns=""
              id="example.lilo.conf"></a><p
              class="title"><strong>Beispiel 8.4. LILO-Konfigurationsdatei</strong></p><div
              class="example-contents"><pre
                class="programlisting">
# The disk on which LILO should be installed.
# By indicating the disk and not a partition.
# you order LILO to be installed on the MBR.
boot=/dev/sda
# the partition that contains Debian
root=/dev/sda2
# the item to be loaded by default
default=Linux

# the most recent kernel image
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Old kernel (if the newly installed kernel doesn't boot)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# only for Linux/Windows dual boot
other=/dev/sda1
  label=Windows</pre></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.config-grub"></a>8.8.3. Konfigurierung von GRUB 2</h3></div></div></div><a
            id="id-1.11.12.8.2"
            class="indexterm"></a><a
            id="id-1.11.12.8.3"
            class="indexterm"></a><div
            class="para">
				<span
              class="emphasis"><em>GRUB</em></span> (GRand Unified Bootloader) ist neueren Datums. Man muss ihn nicht nach jeder Kernelaktualisierung aufrufen; <span
              class="emphasis"><em>GRUB</em></span> kann die Dateisysteme lesen und die Position des Kernels auf der Platte selbst finden. Um ihn in den MBR der ersten Platte zu installieren, geben Sie einfach <code
              class="command">grub-install /dev/sda</code> ein. <a
              id="id-1.11.12.8.4.4"
              class="indexterm"></a>
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>HINWEIS</em></span> Plattennamen für GRUB</strong></p></div></div></div><div
              class="para">
				GRUB kann Festplatten nur aufgrund von Informationen identifizieren, die vom BIOS bereitgestellt werden. <code
                class="literal">(hd0)</code> entspricht der ersten so erkannten Festplatte, <code
                class="literal">(hd1)</code> der zweiten usw. In den meisten Fällen entspricht diese Reihenfolge genau der üblichen Anordnung der Platten unter Linux, jedoch können Probleme auftreten, wenn man SCSI- und IDE-Platten verbindet. GRUB speichert Übereinstimmungen, die er entdeckt, in der Datei <code
                class="filename">/boot/grub/device.map</code>. Falls Sie darin Fehler finden (weil Sie wissen, dass Ihr BIOS Platten in einer anderen Reihenfolge erkennt), korrigieren Sie sie von Hand und führen dann nochmals <code
                class="command">grub-install</code> aus. <code
                class="command">grub-mkdevicemap</code> kann helfen, eine <code
                class="filename">device.map</code> Datei zu erstellen, von der aus gestartet werden soll.
			</div><div
              class="para">
				Partitionen haben in GRUB ebenfalls besondere Namen. Wenn Sie „klassische“ Partitionen im MS-DOS-Format verwenden, wird die erste Partition auf der ersten Platte als <code
                class="literal">(hd0,msdos1)</code> gekennzeichnet, die zweite als <code
                class="literal">(hd0,msdos2)</code> usw.
			</div></div><div
            class="para">
				GRUB 2 configuration is stored in <code
              class="filename">/boot/grub/grub.cfg</code>, but this file (in Debian) is generated from others. Be careful not to modify it by hand, since such local modifications will be lost the next time <code
              class="command">update-grub</code> is run (which may occur upon update of various packages). The most common modifications of the <code
              class="filename">/boot/grub/grub.cfg</code> file (to add command line parameters to the kernel or change the duration that the menu is displayed, for example) are made through the variables in <code
              class="filename">/etc/default/grub</code>. To add entries to the menu, you can either create a <code
              class="filename">/boot/grub/custom.cfg</code> file or modify the <code
              class="filename">/etc/grub.d/40_custom</code> file. For more complex configurations, you can modify other files in <code
              class="filename">/etc/grub.d</code>, or add to them; these scripts should return configuration snippets, possibly by making use of external programs. These scripts are the ones that will update the list of kernels to boot: <code
              class="filename">10_linux</code> takes into consideration the installed Linux kernels; <code
              class="filename">20_linux_xen</code> takes into account Xen virtual systems, and <code
              class="filename">30_os-prober</code> lists other operating systems (Windows, OS X, Hurd).
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.config-yaboot"></a>8.8.4. Für Macintosh-Computer (PowerPC): Yaboot konfigurieren</h3></div></div></div><a
            id="id-1.11.12.9.2"
            class="indexterm"></a><div
            class="para">
				Yaboot ist der von alten Macintosh-Rechnern mit PowerPC-Prozessoren verwendete Boot-Loader. Sie fahren nicht wie PCs hoch, sondern stützen sich auf eine “Bootstrap“-Partition, von der aus das BIOS (oder OpenFirmware) den Loader ausführt, und auf dem das Programm <code
              class="command">ybin</code> <code
              class="command">yaboot</code> und seine Konfigurationsdatei installiert. Man muss diesen Befehl nur ein weiteres Mal ausführen, wenn <code
              class="filename">/etc/yaboot.conf</code> verändert wurde (sie liegt in Kopie auf der Bootstrap-Partition, und <code
              class="command">yaboot</code> kann die Position des Kernels auf den Platten finden).
			</div><div
            class="para">
				Bevor <code
              class="command">ybin</code> ausgeführt wird, muss man zunächst eine gültige Version der Datei <code
              class="filename">/etc/yaboot.conf</code> haben. Das Folgende ist ein Beispiel einer minimalen Konfiguration. <a
              id="id-1.11.12.9.4.3"
              class="indexterm"></a>
			</div><div
            class="example"><a
              xmlns=""
              id="example.yaboot.conf"></a><p
              class="title"><strong>Beispiel 8.5. Konfigurationsdatei für Yaboot</strong></p><div
              class="example-contents"><pre
                class="programlisting">
# bootstrap partition
boot=/dev/sda2
# the disk
device=hd:
# the Linux partition
partition=3
root=/dev/sda3
# boot after 3 seconds of inactivity
# (timeout is in tenths of seconds)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# last kernel installed
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# old kernel
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# only for Linux/Mac OSX dual-boot
macosx=/dev/sda5

# bsd=/dev/sdaX and macos=/dev/sdaX
# are also possible</pre></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-printing.html"><strong>Zurück</strong>8.7. Druckereinrichtung</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Nach oben</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Zum Anfang</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.config-misc.html"><strong>Weiter</strong>8.9. Weitere Konfigurationen: Zeitsynchronisation...</a></li></ul></body></html>
