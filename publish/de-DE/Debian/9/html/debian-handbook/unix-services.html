<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Kapitel 9. Unix-Dienste</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-de-DE-1.0-1" /><meta
        name="keywords"
        content="Systemstart, Initialisierungsskripten, SSH, Telnet, Rechte, Berechtigungen, Überwachung, Inetd, Cron, Datensicherung, Wechsel im laufenden Betrieb, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Das Debian Administrationshandbuch" /><link
        rel="up"
        href="index.html"
        title="Das Debian Administrationshandbuch" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Einen Kernel installieren" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Remoteanmeldung" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/de-DE/stable/unix-services.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Zurück</strong></a></li><li
          class="home">Das Debian Administrationshandbuch</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Weiter</strong></a></li></ul><div
        xml:lang="de-DE"
        class="chapter"
        lang="de-DE"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  xmlns=""
                  id="unix-services"></a>Kapitel 9. Unix-Dienste</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. Systemstart</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. Das systemd Initialisierungssystem</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. Das System V Initialisierungssystem</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Remoteanmeldung</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Sicheres Remoteanmelden: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Entfernte grafische Arbeitsflächen benutzen</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Berechtigungen verwalten</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Administrations-Schnittstellen</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Über eine Webschnittstelle administrieren: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Pakete konfigurieren: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> Systemereignisse</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Prinzip und Mechanismus</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. Die Konfigurationsdatei</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. Der Superserver <code
                    class="command">inetd</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Aufgaben mit <code
                    class="command">cron</code> und <code
                    class="command">atd</code> zeitlich festlegen</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Aufbau der Datei <code
                        class="filename">crontab</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Verwendung des Befehls <code
                        class="command">at</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Asynchrone Aufgaben planen: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Quotas</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Datensicherung</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. Datensicherung mit <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. Rechner ohne Sicherheitskopien wiederherstellen</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Wechsel im laufenden Betrieb: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. Einführung</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. Das Namensproblem</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. Wie <span
                        class="emphasis"><em>udev</em></span> funktioniert</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. Ein konkretes Beispiel</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Modernes Energiemanagement: Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Dieses Kapitel behandelt eine Reihe grundlegender Dienste, die vielen Unix-Systemen gemein sind. Alle Administratoren sollten mit ihnen vertraut sein.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    xmlns=""
                    id="sect.system-boot"></a>9.1. Systemstart</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			Beim Hochfahren des Rechners zeigen die zahlreichen Meldungen, die auf der Konsole vorüberrollen, viele selbsttätig ausgeführte Initialisierungen und Konfigurationen an. Manchmal möchten Sie vielleicht den Ablauf dieser Phase etwas verändern, weshalb Sie sie gut verstehen müssen. Das ist der Zweck dieses Abschnitts.
		</div><div
            class="para">
			Zunächst übernimmt das BIOS die Kontrolle über den Rechner, erkennt die Festplatten, lädt den <span
              class="emphasis"><em>Master Boot Record</em></span> und führt den Boot-Loader aus. Der Boot-Loader übernimmt, ermittelt den Kernel auf der Festplatte, lädt ihn und führt ihn aus. Der Kernel wird dann initialisiert und beginnt damit, nach der Partition, die das Wurzel-Dateisystem enthält, zu suchen und sie einzuhängen, und führt schließlich das erste Programm aus – <code
              class="command">init</code>. In vielen Fällen befinden sich diese „Wurzel-Partition“ und der <code
              class="command">init</code>-Befehl jedoch in einem virtuellen Dateisystem, das nur im Arbeitsspeicher existiert (daher sein Name „initramfs“, früher „initrd“ genannt für „initialization RAM disk“). Dieses Dateisystem wird vom Boot-Loader in den Speicher geladen, häufig aus einer Datei auf einer Festplatte oder aus dem Netzwerk. Es enthält das absolute Minimum dessen, was vom Kernel benötigt wird, um das „wirkliche“ Wurzel-Dateisystem zu laden: dies können Treiber-Module für die Festplatte oder andere Geräte sein, ohne die das System nicht hochfahren kann, oder häufiger Initialisierungsskripten und -module zum Aufbau von RAID-Arrays, zum Öffnen verschlüsselter Partitionen, zur Aktivierung von LVM-Volumes usw. Sobald die Wurzel-Partition eingehängt ist, übergibt initramfs die Kontrolle an das wirkliche init, und der Rechner kehrt zum Standard-Startprozess zurück.
		</div><div
            class="figure"><a
              xmlns=""
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Boot-Sequenz eines Rechners, auf dem Linux mit systemd läuft" /></div></div><p
              class="title"><strong>Abbildung 9.1. Boot-Sequenz eines Rechners, auf dem Linux mit systemd läuft</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.systemd"></a>9.1.1. Das systemd Initialisierungssystem</h3></div></div></div><div
              class="para">
				Das "tatsächliche init" wird zur Zeit von <span
                class="pkg pkg">systemd</span> bereitgestellt und dieser Abschnitt beschreibt das Init-System.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KULTUR</em></span> Weitere <code
                          class="command">inetd</code> Befehle</strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> ist ein relativ neues "init-System", und obwohl es bis zu einem gewissen Grad bereits in <span
                  class="distribution distribution">Wheezy</span> verfügbar war, ist es nur der Standard in Debian <span
                  class="distribution distribution">Jessie</span> geworden. Frühere Versionen basierten standardmäßig auf dem "System V init" (im Paket <span
                  class="pkg pkg">sysv-rc</span>), einem viel traditionelleren System. Wir beschreiben das System V init später.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIV</em></span> Andere Bootsysteme</strong></p></div></div></div><div
                class="para">
				Dieses Buch beschreibt das von Debian <span
                  class="distribution distribution">Jessie</span>standardmäßig verwendete Bootsystem (wie es vom Paket <span
                  class="pkg pkg">systemd</span> umgesetzt wird) sowie die bisherige Voreinstellung <span
                  class="pkg pkg">sysvinit</span>, das vom Unix-System <span
                  class="emphasis"><em>System V</em></span> abgeleitet und übernommen ist; es gibt jedoch auch andere.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> ist ein Bootsystem mit einem sehr einfachen Ablauf. Es behält das Prinzip der Runlevel bei, ersetzt jedoch die Verzeichnisse und symbolischen Verknüpfungen durch eine Konfigurationsdatei, die für <code
                  class="command">init</code> die zu startenden Prozesse und ihre Startreihenfolge angibt.
			</div><div
                class="para">
				Der Befehl <code
                  class="command">upstart</code> ist auf Debian immer noch nicht vollständig ausgetestet. Es arbeitet ereignisbasiert: Initialisierungsskripten werden nicht mehr der Reihe nach ausgeführt, sondern als Reaktion auf Ereignisse, wie zum Beispiel die Ausführung eines anderen Skripts, von dem sie abhängen. Dieses von Ubuntu eingeführte System ist in Debian <span
                  class="distribution distribution">Jessie</span> vorhanden, aber nicht als Standard eingestellt. Es ist ein Nachfolger für <span
                  class="pkg pkg">sysvinit</span>, und eine der von <code
                  class="command">upstart</code> ausgeführten Aufgaben besteht darin, die für traditionelle Systeme geschriebenen Skripten zu starten, insbesondere die aus dem Paket <span
                  class="pkg pkg">sysv-rc</span>.
			</div><div
                class="para">
				Es gibt weitere Systeme und Betriebsarten wie zum Beispiel <code
                  class="command">runit</code> oder <code
                  class="command">minit</code>, die jedoch recht spezialisiert und nicht weit verbreitet sind.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SONDERFALL</em></span> Aus dem Netzwerk hochfahren</strong></p></div></div></div><div
                class="para">
				Bei einigen Konfigurationen kann das BIOS so eingestellt sein, dass es nicht den MBR ausführt, sondern seine Entsprechung im Netzwerk sucht, wodurch es möglich wird, Rechner ohne Festplatte zu bauen oder solche, die bei jedem Neustart vollständig neu installiert werden. Diese Option steht aber nicht auf jeder Hardware zur Verfügung und erfordert im Allgemeinen eine passende Kombination aus BIOS und Netzwerkkarte.
			</div><div
                class="para">
				Das Hochfahren aus dem Netzwerk kann dazu verwendet werden, den <code
                  class="command">Debian-Installer</code> oder FAI zu starten (siehe <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Abschnitt 4.1, „Installationsmethoden“</a>).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Der Prozess, eine Programminstanz</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				Ein Prozess ist die Darstellung eines laufenden Programms im Speicher. Er umfasst alle Informationen, die für die ordnungsgemäße Ausführung der Software erforderlich sind (den Code selbst, aber auch die Daten, die er im Speicher hält, die Liste der Dateien, die er geöffnet hat, die Netzwerkverbindungen, die er eingerichtet hat, usw.). Ein einzelnes Programm kann in mehreren Prozessen instanziiert sein, die nicht notwendigerweise unter verschiedenen Benutzerkennungen laufen.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SICHERHEIT</em></span> Eine Shell als <code
                          class="command">init</code> verwenden, um Administratorrechte zu erlangen</strong></p></div></div></div><div
                class="para">
				Vereinbarungsgemäß ist der erste Prozess, der gestartet wird, das Programm <code
                  class="command">init</code> (das ein symbolischer Link zu <code
                  class="filename">/lib/systemd/systemd</code> ist). Man kann dem Kernel jedoch eine <code
                  class="literal">init</code>-Option übergeben, die ein anderes Programm angibt.
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				Jeder mit Zugang zum Rechner kann die <span
                  class="keycap"><strong>Reset</strong></span>-Taste drücken und ihn so neu starten. Dann ist es an der Eingabeaufforderung des Boot-Loaders möglich, dem Kernel die Option <code
                  class="literal">init=/bin/sh</code> zu übergeben und so ohne Kenntnis des Administrator-Passworts Root-Rechte zu erlangen.
			</div><div
                class="para">
				Um dieses zu verhindern, kann man den Boot-Loader selbst mit einem Passwort absichern. Man könnte auch den Zugang zum BIOS schützen (ein Passwort-Schutzmechanismus ist fast immer verfügbar), ohne den ein böswilliger Eindringling jedoch den Rechner immer noch mit einem Wechseldatenträger, der sein eigenes Linux-System enthält, hochfahren könnte und das er dann dazu benutzen könnte, um auf Daten auf den Festplatten des Rechners zuzugreifen.
			</div><div
                class="para">
				Schließlich sollten Sie beachten, dass die meisten BIOS ein voreingestelltes Passwort haben. Ursprünglich dazu gedacht, denen zu helfen, die ihr Passwort vergessen haben, sind diese Passwörter inzwischen öffentlich bekannt und im Internet verfügbar (sehen Sie selbst, indem sie in einer Suchmaschine „Standard-Passwörter“ eingeben). Alle diese Sicherheitsmaßnahmen können daher zwar den unbefugten Zugriff auf den Rechner erschweren, ihn aber nicht vollständig verhindern. Es gibt keinen zuverlässigen Weg, einen Computer zu schützen, falls der Angreifer physisch auf ihn zugreifen kann; er könnte die Festplatten ausbauen, um sie an einen Rechner unter seiner Kontrolle anzuschließen oder das ganze Gerät stehlen oder den BIOS-Speicher löschen, um so das Passwort zurückzusetzen…
			</div></div><div
              class="para">
				Systemd führt mehrere Prozesse aus, die für die Einrichtung des Systems verantwortlich sind: Tastatur, Treiber, Dateisysteme, Netzwerk, Dienste. Dabei behält er den Überblick über das Gesamtsystem und die Anforderungen der Komponenten. Jede Komponente wird durch eine "Unit-Datei" (manchmal auch mehrere) beschrieben; die allgemeine Syntax ergibt sich aus der weit verbreiteten "*.ini Dateien" Syntax, mit <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code> Paare gruppiert zwischen <code
                class="literal">[<em
                  class="replaceable">section</em>]</code> headers. Unit-Dateien werden unter <code
                class="filename">/lib/system/system/</code> und <code
                class="filename">/etc/systemd/system/</code> gespeichert; es gibt sie in verschiedenen Varianten, aber wir werden uns hier auf "services" und "targets" konzentrieren.
			</div><div
              class="para">
				Eine systemd "Servicedatei" beschreibt einen von systemd verwalteten Prozess. Es enthält ungefähr die gleichen Informationen wie die alten Initskripte, jedoch in einer deklaratorischen (und viel prägnanteren) Form. Systemd übernimmt den Großteil der sich wiederholenden Aufgaben (Starten und Stoppen des Prozesses, Prüfen seines Status, Protokollieren, Löschen von Berechtigungen, usw.) und die Servicedatei muss nur die Besonderheiten des Prozesses ausfüllen. Hier ist zum Beispiel die Servicedatei für SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				Wie Sie sehen können, gibt es dort sehr wenig Code, nur Deklarationen. Systemd kümmert sich um die Anzeige von Fortschrittsberichten, verfolgt die Prozesse und startet sie bei Bedarf sogar neu.
			</div><div
              class="para">
				Eine systemd "Target-Datei" beschreibt einen Zustand des Systems, in dem ein Satz von Diensten als funktionsfähig bekannt ist. Es kann als Äquivalent zum alten Runlevel angesehen werden. Eines der Targets ist <code
                class="literal">local-fs.target</code>; wenn es erreicht ist, kann der Rest des Systems davon ausgehen, dass alle lokalen Dateisysteme eingebunden und zugänglich sind. Andere Targets sind <code
                class="literal">network-online.target</code> und <code
                class="literal">sound.target</code>. Die Abhängigkeiten eines Ziels können entweder innerhalb der Zieldatei (in der Zeile <code
                class="literal">Requires=</code>) oder über einen symbolischen Link auf eine Servicedatei im Verzeichnis <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">Targetname</em>.target.wants/</code> aufgelistet werden. Zum Beispiel enthält <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> einen Link zu <code
                class="filename">/lib/systemd/system/cups.service</code>; systemd wird daher sicherstellen, dass CUPS läuft, um <code
                class="literal">printer.target</code> zu erreichen.
			</div><div
              class="para">
				Da Unit-Dateien, anders als als Skripte oder Programme, eher deklarativ sind, können sie nicht direkt ausgeführt werden und werden von systemd nur interpretiert. Mehrere Dienstprogramme erlauben es dem Administrator daher, mit systemd zu interagieren und den Zustand des Systems und jeder Komponente zu kontrollieren.
			</div><div
              class="para">
				Das erste derartige Dienstprogramm ist <code
                class="command">systemctl</code>. Wenn es ohne Argumente ausgeführt wird, listet es alle dem System bekannten Unit-Dateien (mit Ausnahme derjenigen, die deaktiviert wurden) sowie deren Status auf. <code
                class="command">systemctl status</code> gibt einen besseren Überblick über die Dienste und die damit verbundenen Prozesse. Wenn der Name eines Dienstes angegeben wird (wie in <code
                class="command">systemctl status ntp.service</code>), gibt er noch mehr Details zurück, sowie die letzten Log-Zeilen, die sich auf den Dienst beziehen (mehr dazu später).
			</div><div
              class="para">
				Das Starten eines Dienstes von Hand ist einfach das Starten von <code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code>. Wie man leicht erraten kann, wird der Dienst mit <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code> beendet; andere Unterbefehle beinhalten <code
                class="command">reload</code> und <code
                class="command">restart</code>.
			</div><div
              class="para">
				Um zu steuern, ob ein Dienst aktiv ist (d.h. ob er beim Booten automatisch gestartet wird), verwenden Sie <code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> (oder <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> ermöglicht die Überprüfung des Status des Dienstes.
			</div><div
              class="para">
				Eine interessante Eigenschaft von systemd ist, dass es eine Protokollierungskomponente namens <code
                class="command">journald</code> enthält. Es ist eine Ergänzung zu herkömmlichen Protokollierungssystemen wie <code
                class="command">syslogd</code>, aber es fügt interessante Funktionen hinzu, wie eine formale Verbindung zwischen einem Dienst und den von ihm erzeugten Nachrichten und die Fähigkeit, Fehlermeldungen zu erfassen, die durch seine Initialisierungssequenz erzeugt werden. Die Meldungen können später mit Hilfe des Befehls <code
                class="command">journalctl</code> angezeigt werden. Ohne Argumente spuckt es einfach alle Logmeldungen aus, die seit dem Systemstart aufgetreten sind; es wird selten so verwendet. Meistens wird es mit einer Service-Kennung verwendet:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				Ein weiterer nützlicher Kommandozeilenparameter ist <code
                class="command">-f</code>, der <code
                class="command">journalctl</code> anweist, neue Nachrichten so anzuzeigen, wie sie ausgegeben werden (ziemlich so wie <code
                class="command">tail -f <em
                  class="replaceable">file</em></code>).
			</div><div
              class="para">
				Wenn ein Dienst nicht wie erwartet funktioniert, ist der erste Schritt zur Lösung des Problems die Überprüfung, ob der Dienst tatsächlich läuft: <code
                class="command">systemctl status</code>. Wenn dies nicht der Fall ist und die Meldungen des ersten Befehls nicht ausreichen, um das Problem zu diagnostizieren, überprüfen Sie die von journald über diesen Dienst gesammelten Protokolle. Angenommen, der SSH-Server funktioniert nicht:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				Nachdem wir den Status des Dienstes überprüft haben (failed), haben wir die Protokolle überprüft; sie zeigen einen Fehler in der Konfigurationsdatei an. Nachdem wir die Konfigurationsdatei bearbeitet und den Fehler behoben haben, starten wir den Dienst neu und überprüfen, ob er tatsächlich läuft.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>WEITERE SCHRITTE</em></span> Andere Arten von Unit-Dateien</strong></p></div></div></div><div
                class="para">
				Wir haben in diesem Abschnitt nur die grundlegendsten Fähigkeiten von systemd beschrieben. Es bietet viele weitere interessante Funktionen; wir werden hier nur einige aufzählen:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						Socket-Aktivierung: eine "Socket"-Unitdatei kann verwendet werden, um einen von systemd verwalteten Netzwerk-Socket oder Unix-Socket zu beschreiben; dies bedeutet, dass der Socket von systemd erstellt wird und der eigentliche Dienst bei Bedarf gestartet werden kann, wenn ein tatsächlicher Verbindungsversuch erfolgt. Dies bildet grob den Funktionsumfang von <code
                        class="command">inetd</code> nach. Siehe <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						Timer: Eine "Timer"-Unitdatei beschreibt Ereignisse, die mit einer festen Frequenz oder zu bestimmten Zeiten auftreten; wenn ein Dienst mit einem solchen Timer verknüpft ist, wird die entsprechende Aufgabe ausgeführt, sobald der Timer ausgelöst wird. Dies erlaubt das Nachbilden eines Teils der Fähigkeiten von <code
                        class="command">cron</code>. Siehe <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						network: Eine "network"-Unitdatei beschreibt eine Netzwerkschnittstelle, die es erlaubt, solche Schnittstellen zu konfigurieren und auszudrücken, dass ein Dienst von einer bestimmten Schnittstelle abhängt.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.sysvinit"></a>9.1.2. Das System V Initialisierungssystem</h3></div></div></div><div
              class="para">
				Das System V init System (das wir init für Kürze nennen werden) führt mehrere Prozesse aus, indem es Anweisungen aus der Datei <code
                class="filename">/etc/inittab</code> befolgt. Das erste Programm, das ausgeführt wird (was dem Schritt <span
                class="emphasis"><em>sysinit</em></span> entspricht), ist <code
                class="command">/etc/init.d/rcS</code>, ein Skript, das alle Programme im Verzeichnis <code
                class="filename">/etc/rcS.d/</code> ausführt. <a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				Unter diesen befinden sich nacheinander Programme, die zuständig sind für:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						das Konfigurieren der Konsolentastatur;
					</div></li><li
                  class="listitem"><div
                    class="para">
						das Laden von Treibern: die meisten Kernelmodule werden beim Erkennen der Hardware vom Kernel selbst geladen; zusätzliche Treiber werden selbsttätig geladen, wenn die entsprechenden Module in der Datei <code
                      class="filename">/etc/modules</code> aufgeführt sind;
					</div></li><li
                  class="listitem"><div
                    class="para">
						die Integritätsprüfung von Dateisystemen;
					</div></li><li
                  class="listitem"><div
                    class="para">
						das Einhängen lokaler Partitionen;
					</div></li><li
                  class="listitem"><div
                    class="para">
						das Konfigurieren des Netzwerks;
					</div></li><li
                  class="listitem"><div
                    class="para">
						das Einhängen von Netzwerkdateisystemen (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Kernelmodule und -optionen</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				Kernelmodule verfügen ebenfalls über Optionen, die konfiguriert werden können, indem man Dateien im Verzeichnis <code
                  class="filename">/etc/modprobe.d/</code> erstellt. Diese Optionen werden durch Anweisungen wie die folgende festgelegt: <code
                  class="literal">options <em
                    class="replaceable">modulname</em> <em
                    class="replaceable">optionsname</em>=<em
                    class="replaceable">optionswert</em></code>. Falls erforderlich, können mehrere Optionen in einer einzelnen Anweisung gesetzt werden.
			</div><div
                class="para">
				Die Konfigurationsdateien sind für das Programm <code
                  class="command">modprobe</code> bestimmt, das ein Kernelmodul mit seinen Abhängigkeiten lädt (Module können auch andere Module aufrufen). Dieses Programm wird durch das Paket <span
                  class="pkg pkg">kmod</span> bereitgestellt.
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				Nach dieser Phase übernimmt <code
                class="command">init</code> und startet die im Standard-Runlevel (der normalerweise Runlevel 2 ist) aktivierten Programme. Es führt <code
                class="command">/etc/init.d/rc 2</code> aus, ein Skript, das alle Dienste startet, die in <code
                class="filename">/etc/rc2.d/</code> aufgeführt sind und mit dem Buchstaben „S“ beginnen. Die anschließenden zweistelligen Zahlen wurden früher dazu benutzt, die Reihenfolge festzulegen, in der die Dienste gestartet werden mussten, aber heute verwendet das Standard-Bootsystem <code
                class="command">insserv</code>, das ausgehend von den Abhängigkeiten der Skripten alles selbsttätig zeitlich festlegt. Jedes Boot-Skript legt die Bedingungen fest, die gelten müssen, damit ein Dienst gestartet oder beendet wird (ob er zum Beispiel vor oder nach einem anderen Dienst gestartet werden muss); <code
                class="command">init</code> startet sie dann in der Reihenfolge, die diese Bedingungen erfüllt. Die feststehende Nummerierung der Skripten wird daher nicht mehr berücksichtigt (sie müssen trotzdem weiterhin einen Namen haben, der mit „S“ beginnt gefolgt von zwei Zahlen und dem Namen des Skripts, das für die Abhängigkeiten verwendet wird). Im Allgemeinen werden grundlegende Dienste (wie das Protokollieren mit <code
                class="command">rsyslog</code> oder die Portzuweisung mit <code
                class="command">portmap</code>) als erste gestartet, gefolgt von Standarddiensten und der grafischen Schnittstelle (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				Dieses Bootsystem auf der Grundlage von Abhängigkeiten ermöglicht es, die Neu-Nummerierung zu automatisieren, die recht mühsam wäre, wenn sie von Hand erledigt werden müsste, und es begrenzt das Risiko menschlichen Versagens, da die Festlegung der zeitlichen Abfolge in Übereinstimmung mit den angegebenen Parametern erfolgt. Ein weiterer Vorteil besteht darin, dass voneinander unabhängige Dienste zeitgleich gestartet werden können, was den Prozess des Hochfahrens beschleunigt.
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> unterscheidet zwischen verschiedenen Runleveln, so dass es mit dem Befehl <code
                class="command">telinit <em
                  class="replaceable">neuer-level</em></code> von einem zum anderen umschalten kann. <code
                class="command">init</code> führt bei einem neuen Runlevel unmittelbar ein weiteres Mal <code
                class="command">/etc/init.d/rc</code> aus. Dieses Skript startet dann die fehlenden Dienste und beendet die nicht mehr benötigten. Hierzu bezieht es sich auf den Inhalt der Datei <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> (wobei <em
                class="replaceable">X</em> den neuen Runlevel bezeichnet). Skripten, deren Namen mit „S“ beginnen (wie in „Start“), verweisen auf zu startende Dienste, solche mit „K“ (wie in „Kill“) auf zu beendende. Das Skript startet keine Dienste, die im vorherigen Runlevel bereits aktiv waren.
			</div><div
              class="para">
				Standardmäßig verwendet System V init in Debian vier verschiedene Runlevel:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Level 0 wird nur vorübergehend beim Herunterfahren des Rechners benutzt. Daher enthält er nur zahlreiche „K“-Skripten.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Level 1, auch Single-User Modus genannt, entspricht dem System in rudimentärem Zustand. Er umfasst einzig grundlegende Dienste und ist hauptsächlich für die Systemwartung gedacht, bei dem Interaktionen mit normalen Benutzern nicht erwünscht sind.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Level 2 ist der Level für den Normalbetrieb, der Netzwerkdienste, eine grafische Schnittstelle, Benutzeranmeldungen usw. umfasst.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Level 6 gleicht Level 0, nur dass er während des Herunterfahrens vor einem Neustart verwendet wird.
					</div></li></ul></div><div
              class="para">
				Es gibt weitere Level, insbesondere 3 bis 5. Standardmäßig sind sie so konfiguriert, dass sie sich wie Level 2 verhalten. Jedoch kann der Administrator sie verändern (indem er in den entsprechenden Verzeichnissen unter <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> Skripten hinzufügt oder löscht), um sie so besonderen Bedürfnissen anzupassen.
			</div><div
              class="figure"><a
                xmlns=""
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Boot-Sequenz eines Rechners, auf dem Linux mit System V init läuft" /></div></div><p
                class="title"><strong>Abbildung 9.2. Boot-Sequenz eines Rechners, auf dem Linux mit System V init läuft</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				Alle in den verschiedenen Verzeichnissen unter <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> enthaltenen Skripten sind in Wirklichkeit symbolische Verknüpfungen - bei der Paketinstallation durch das Programm <code
                class="command">update-rc.d</code> erstellt, die auf die eigentlichen, im Verzeichnis <code
                class="filename">/etc/init.d/</code> gespeicherten, Skripten verweisen. Der Administrator kann die in jedem Runlevel verfügbaren Dienste fein einstellen, indem er den Befehl <code
                class="command">update-rc.d</code> mit angepassten Parametern erneut ausführt. Die Handbuchseite <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> erläutert die Syntax im Detail. Bitte beachten Sie, dass das Entfernen aller symbolischen Verknüpfungen (mit dem Parameter <code
                class="literal">remove</code>) kein gutes Verfahren zum Abschalten eines Dienstes ist. Stattdessen sollten Sie ihn einfach so konfigurieren, dass er in dem gewünschten Runlevel nicht startet (und dabei gleichzeitig die entsprechenden Aufrufe zu seinem Abschalten bewahren, für den Fall, dass er im vorhergehenden Runlevel läuft). Da <code
                class="command">update-rc.d</code> eine etwas verschachtelte Schnittstelle hat, benutzen Sie vielleicht lieber <code
                class="command">rcconf</code> (aus dem Paket <span
                class="pkg pkg">rcconf</span>), das eine benutzerfreundlichere Schnittstelle hat.
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN-RICHTLINIEN</em></span> Dienste neu starten</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				Die Betreuerskripten für Debian-Pakete starten manchmal bestimmte Dienste neu, um ihre Verfügbarkeit sicherzustellen, oder damit sie bestimmte Optionen berücksichtigen. Der Befehl zur Steuerung eines Dienstes - <code
                  class="command">service<em
                    class="replaceable">dienst</em> <em
                    class="replaceable">vorgang</em></code> - berücksichtigt Runlevel nicht, geht (fälschlicherweise) davon aus, dass der Dienst gerade benutzt wird und kann daher falsche Vorgänge auslösen (einen Dienst starten, der bewusst abgeschaltet worden war, einen Dienst anhalten, der bereits angehalten ist usw.). Deshalb hat Debian das Programm <code
                  class="command">invoke-rc.d</code> eingeführt: dieses Programm muss von Betreuerskripten verwendet werden, um Initialisierungsskripten für Dienste aufzurufen und führt nur die erforderlichen Befehle aus. Man beachte, dass das Suffix <code
                  class="filename">.d</code> hier, im Gegensatz zu seiner sonst üblichen Verwendung, in einem Programmnamen und nicht in einem Verzeichnis benutzt wird.
			</div></div><div
              class="para">
				Schließlich startet <code
                class="command">init</code> Steuerprogramme für mehrere virtuelle Konsolen (<code
                class="command">getty</code>). Es zeigt eine Eingabeaufforderung an, an der es auf einen Benutzernamen wartet, und führt dann <code
                class="command">login <em
                  class="replaceable">benutzer</em></code> aus, um eine Sitzung zu starten.
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>WÖRTERVERZEICHNIS</em></span> Konsole und Terminal</strong></p></div></div></div><div
                class="para">
				Die ersten Computer waren gewöhnlich in mehrere, sehr große Teile unterteilt: das Speichergehäuse und die zentrale Verarbeitungseinheit waren von den Peripheriegeräten getrennt, die von den Bedienern zu ihrer Steuerung benutzt wurden. Letztere waren Teil einer separaten Einrichtung, der „Konsole“. Dieser Begriff wurde beibehalten, aber seine Bedeutung hat sich verändert. Er wurde mehr oder weniger zu einem Synonym für „Terminal“, das aus einer Tastatur und einem Bildschirm besteht.
			</div><div
                class="para">
				Im Laufe der Entwicklung der Computer haben Betriebssysteme schließlich mehrere virtuelle Konsolen angeboten, um gleichzeitig mehrere unabhängige Sitzungen zu ermöglichen, selbst wenn es nur eine Tastatur und einen Bildschirm gibt. Die meisten GNU/Linux-Systeme bieten sechs virtuelle Konsolen (im Textmodus) an, die durch die Eingabe der Tastenkombinationen <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> bis <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span> zugänglich sind.
			</div><div
                class="para">
				Im weiteren Sinne können die Begriffe „Konsole“ und „Terminal“ sich auch auf einen Terminal-Emulator in einer grafischen X11-Sitzung beziehen (wie zum Beispiel <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code> oder <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Zurück</strong>8.11. Einen Kernel installieren</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Nach oben</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Zum Anfang</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Weiter</strong>9.2. Remoteanmeldung</a></li></ul></body></html>
