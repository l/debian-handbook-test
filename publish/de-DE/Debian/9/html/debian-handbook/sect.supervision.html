<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.3. Überwachung: Vorbeugung, Entdeckung, Abschreckung</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-de-DE-1.0-1" /><meta
        name="keywords"
        content="Firewall, Netzfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="Das Debian Administrationshandbuch" /><link
        rel="up"
        href="security.html"
        title="Kapitel 14. Sicherheit" /><link
        rel="prev"
        href="sect.firewall-packet-filtering.html"
        title="14.2. Firewall oder Paketfilter" /><link
        rel="next"
        href="sect.apparmor.html"
        title="14.4. Einführung in AppArmor" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/de-DE/stable/sect.supervision.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Zurück</strong></a></li><li
          class="home">Das Debian Administrationshandbuch</li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Weiter</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.supervision"></a>14.3. Überwachung: Vorbeugung, Entdeckung, Abschreckung</h2></div></div></div><a
          id="id-1.17.6.2"
          class="indexterm"></a><div
          class="para">
			Monitoring ist aus mehreren Gründen ein integraler Bestandteil jeder Sicherheitsrichtlinie. Unter anderem deshalb, weil das Ziel der Absicherung gewöhnlich nicht darauf beschränkt ist, die Vertraulichkeit der Daten sicherzustellen, sondern auch vorsieht, dass die Verfügbarkeit der Dienste gewährleistet ist. Es ist daher unerlässlich, zu überprüfen, ob alles wie vorgesehen funktioniert, und rechtzeitig jedes abweichende Verhalten und jede Änderung in der Qualität der erbrachten Leistungen zu erkennen. Monitoring hilft dabei Einbruchsversuche zu entdecken und darauf schnell zu reagieren, bevor sie ernste Folgen haben. Dieser Abschnitt gibt einen Überblick über einige Hilfsprogramme, die zur Überwachung verschiedener Aspekte eines Debian-Systems eingesetzt werden können. Damit vervollständigt er <a
            class="xref"
            href="sect.monitoring.html">Abschnitt 12.4, „Überwachung“</a>.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.logcheck"></a>14.3.1. Protokolle mit <code
                    class="command">logcheck</code> verfolgen</h3></div></div></div><a
            id="id-1.17.6.4.2"
            class="indexterm"></a><a
            id="id-1.17.6.4.3"
            class="indexterm"></a><a
            id="id-1.17.6.4.4"
            class="indexterm"></a><div
            class="para">
				Das Programm <code
              class="command">logcheck</code> überwacht Protokolldateien standardmäßig jede Stunde. Es schickt E-Mails mit ungewöhnlichen Protokollmeldungen zur weiteren Analyse an den Administrator.
			</div><div
            class="para">
				Die Liste der überwachten Dateien wird in <code
              class="filename">/etc/logcheck/logcheck.logfiles</code> gespeichert; die Standardeinstellungen eignen sich gut, solange die Datei <code
              class="filename">/etc/rsyslog.conf</code> nicht vollständig verändert worden ist.
			</div><div
            class="para">
				<code
              class="command">logcheck</code> kann in drei mehr oder weniger detaillierten Modi laufen: <span
              class="emphasis"><em>Paranoid</em></span>, <span
              class="emphasis"><em>Server</em></span> und <span
              class="emphasis"><em>Arbeitsplatzrechner</em></span>. Der erste ist <span
              class="emphasis"><em>sehr</em></span> ausführlich und sollte wohl eher auf besondere Server, wie zum Beispiel Firewalls, beschränkt bleiben. Der zweite (voreingestellte) Modus wird für die meisten Server empfohlen. Der letzte ist für Arbeitsplatzrechner bestimmt und ist noch knapper (er unterdrückt mehr Meldungen).
			</div><div
            class="para">
				In allen drei Fällen sollte <code
              class="command">logcheck</code> wohl so angepasst werden, dass es einige zusätzliche Meldungen ausschließt (in Abhängigkeit von den installierten Diensten), es sei denn, dass der Administrator tatsächlich jede Stunde stapelweise lange uninteressante E-Mails empfangen möchte. Da das Verfahren zur Auswahl der Meldungen recht kompliziert ist, ist es notwendig - wenn auch schwierig - die Datei <code
              class="filename">/usr/share/doc/logcheck-database/README.logcheck-database.gz</code> durchzulesen.
			</div><div
            class="para">
				Die eingesetzten Regeln können in mehrere Arten unterteilt werden:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						solche, die eine Meldung als einen Einbruchsversuch einstufen (in einer Datei im Verzeichnis <code
                    class="filename">/etc/logcheck/cracking.d/</code> gespeichert);
					</div></li><li
                class="listitem"><div
                  class="para">
						solche, die eine derartige Einstufung aufheben (<code
                    class="filename">/etc/logcheck/cracking.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						solche, die eine Meldung als Sicherheitswarnung einordnen (<code
                    class="filename">/etc/logcheck/violations.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						solche, die diese Einordnung aufheben (<code
                    class="filename">/etc/logcheck/violations.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						und schließlich solche, die auf die übrigen Meldungen zutreffen (als sogenannte <span
                    class="emphasis"><em>Systemvorfälle</em></span> angesehen werden).
					</div></li></ul></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VORSICHT</em></span> Eine Meldung ignorieren</strong></p></div></div></div><div
              class="para">
				Eine Meldung, die als Einbruchsversuch oder als Sicherheitswarnung markiert worden ist (aufgrund einer Regel, die in einer Datei namens <code
                class="filename">/etc/logcheck/violations.d/meine_datei</code> gespeichert ist), kann nur mit einer Regel in den Dateien <code
                class="filename">/etc/logcheck/violations.ignore.d/meine_datei</code> oder <code
                class="filename">/etc/logcheck/violations.ignore.d/meine_datei-<em
                  class="replaceable">erweiterung</em></code> ignoriert werden.
			</div></div><div
            class="para">
				Ein Systemvorfall wird immer angezeigt, es sei denn, eine Regel in einem der Verzeichnisse des Typs <code
              class="filename">/etc/logcheck/ignore.d.{paranoid,server,arbeitsplatzrechner}/</code> bestimmt, dass der Vorfall ignoriert werden soll. Es werden natürlich nur die Verzeichnisse berücksichtigt, deren Ausführlichkeitsgrad gleich dem oder höher als der ausgewählte Betriebsmodus ist.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.monitoring-activity"></a>14.3.2. Aktivitäten überwachen</h3></div></div></div><a
            id="id-1.17.6.5.2"
            class="indexterm"></a><a
            id="id-1.17.6.5.3"
            class="indexterm"></a><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.real-time-monitoring"></a>14.3.2.1. In Echtzeit</h4></div></div></div><div
              class="para">
					<code
                class="command">top</code> ist ein interaktives Hilfsprogramm, das eine Liste der gegenwärtig laufenden Prozesse anzeigt. Die voreingestellte Reihenfolge hängt vom momentanen Umfang der Prozessornutzung ab und kann mithilfe der <span
                class="keycap"><strong>P</strong></span>-Taste abgerufen werden. Andere Sortierreihenfolgen sind unter anderem nach belegtem Speicher (<span
                class="keycap"><strong>M</strong></span>-Taste), nach gesamter Prozessorzeit (<span
                class="keycap"><strong>T</strong></span>-Taste) und nach Prozesskennung (<span
                class="keycap"><strong>N</strong></span>-Taste). Mit der <span
                class="keycap"><strong>k</strong></span>-Taste kann ein Prozess abgebrochen werden, indem seine Kennung eingegeben wird. Die <span
                class="keycap"><strong>r</strong></span>-Taste ermöglicht das <span
                class="emphasis"><em>renicing</em></span> eines Prozesses, das heißt, die Änderung seiner Priorität.
				</div><a
              id="id-1.17.6.5.4.3"
              class="indexterm"></a><div
              class="para">
					Wenn das System überlastet zu sein scheint, ist <code
                class="command">top</code> ein großartiges Instrument, um zu sehen, welche Prozesse um die Prozessorzeit konkurrieren oder zu viel Speicher verbrauchen. Insbesondere ist es häufig interessant zu überprüfen, ob die Prozesse, die Ressourcen verbrauchen, den tatsächlichen Diensten entsprechen, die der Rechner bekanntermaßen beherbergt. Ein unbekannter Prozess, der unter dem Benutzernamen www-data läuft, sollte wirklich hervorstechen und kann untersucht werden, da er möglicherweise ein Programm ist, das durch eine Schwachstelle in einer Web-Anwendung auf dem System installiert wurde und ausgeführt wird.
				</div><div
              class="para">
					<code
                class="command">top</code> ist ein sehr flexibles Hilfsprogramm, und seine Handbuchseite beschreibt ausführlich, wie seine Anzeige individuell eingerichtet und an persönliche Bedürfnisse und Gewohnheiten angepasst werden kann.
				</div><div
              class="para">
					Das grafische Hilfsprogramm <code
                class="command">gnome-system-monitor</code> ist <code
                class="command">top</code> ähnlich und bietet etwa die gleichen Leistungsmerkmale.
				</div><a
              id="id-1.17.6.5.4.7"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.monitoring-history"></a>14.3.2.2. Verlauf</h4></div></div></div><a
              id="id-1.17.6.5.5.2"
              class="indexterm"></a><div
              class="para">
					Prozessorauslastung, Netzwerkverkehr und freier Plattenplatz sind Informationen, die sich ständig ändern. Es ist häufig nützlich, den Verlauf ihrer Entwicklung festzuhalten, um genau feststellen zu können, wie der Rechner genutzt wird.
				</div><a
              id="id-1.17.6.5.5.4"
              class="indexterm"></a><a
              id="id-1.17.6.5.5.5"
              class="indexterm"></a><div
              class="para">
					Für diese Aufgabe gibt es zahlreiche spezialisierte Hilfsprogramme. Die meisten von ihnen können Daten über SNMP (<span
                class="emphasis"><em>Simple Network Management Protocol</em></span>) einholen, um diese Informationen an einer Stelle zusammenzufassen. Ein weiterer Nutzen besteht darin, dass auf diese Weise Daten von Netzwerkelementen eingeholt werden können, die keine Universalrechner sind, wie spezialisierte Netzwerkrouter oder -switche.
				</div><div
              class="para">
					Dieses Buch behandelt Munin ausführlich als Teil von <a
                class="xref"
                href="advanced-administration.html">Kapitel 12: „<em>Erweiterte Verwaltung</em>“</a> (siehe <a
                class="xref"
                href="sect.monitoring.html#sect.munin">Abschnitt 12.4.1, „Munin einrichten“</a>). Debian stellt ebenfalls ein ähnliches Hilfsprogramm bereit: <span
                class="pkg pkg">cacti</span>. Sein Einsatz ist etwas komplizierter, da es ausschließlich auf SNMP beruht. Obwohl es eine Web-Schnittstelle hat, benötigt das Verständnis der Konzepte, die für die Konfigurierung verwendet werden, noch einige Anstrengung. Die Lektüre der HTML-Dokumentation (<code
                class="filename">/usr/share/doc/cacti/html/index.html</code>) ist daher als Voraussetzung anzusehen.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> <code
                          class="command">mrtg</code></strong></p></div></div></div><a
                id="id-1.17.6.5.5.8.2"
                class="indexterm"></a><div
                class="para">
					<code
                  class="command">mrtg</code> (in dem Paket ähnlichen Namens) ist ein älteres Hilfsprogramm. Trotz einiger Ecken und Kanten kann es Verlaufsdaten zusammenfassen und als Diagramme anzeigen. Es enthält eine Reihe spezieller Skripte zur Sammlung der am häufigsten überprüften Daten wie Prozessorlast, Netzwerkverkehr, Webseitenzugriffe und so weiter.
				</div><div
                class="para">
					Die Pakete <span
                  class="pkg pkg">mrtg-contrib</span> und <span
                  class="pkg pkg">mrtgutils</span> enthalten Beispielskripte, die direkt verwendet werden können.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.17.6.6"></a>14.3.3. Änderungen erkennen</h3></div></div></div><div
            class="para">
				Nachdem das System installiert und konfiguriert ist, gibt es, abgesehen von Sicherheitsaktualisierungen, normalerweise keinen Grund, dass Dateien und Verzeichnisse sich weiterentwickeln, Daten ausgenommen. Es ist daher interessant sicherzustellen, dass Dateien sich in der Tat nicht ändern: jede unerwartete Veränderung wäre daher eine Untersuchung wert. Dieser Abschnitt stellt einige Hilfsprogramme vor, die Dateien überwachen und den Administrator warnen können, wenn eine unerwartete Veränderung auftritt (oder einfach derartige Veränderungen auflisten).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.dpkg-verify"></a>14.3.3.1. Pakete mit <code
                      class="command">logcheck</code> prüfen</h4></div></div></div><a
              id="id-1.17.6.6.3.2"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>WEITERE SCHRITTE</em></span> Schutz vor vorgelagerten Veränderungen</strong></p></div></div></div><div
                class="para">
					<code
                  class="command">dpkg --verify</code> ist nützlich zur Entdeckung von Änderungen an Dateien, die aus einem Debian-Paket stammen. Jedoch ist es nutzlos, falls das Paket selbst beschädigt ist, weil zum Beispiel der Debian-Spiegelserver kompromittiert wurde. Um sich gegen diese Art von Angriffen zu schützen, ist es erforderlich, APTs Verifikationssystem für digitale Signaturen zu benutzen (siehe <a
                  class="xref"
                  href="sect.package-authentication.html">Abschnitt 6.5, „Die Echtheit eines Paketes prüfen“</a>) und darauf zu achten, nur Pakete zertifizierten Ursprungs zu installieren.
				</div></div><div
              class="para">
					<code
                class="command">dpkg --verify</code> (oder <code
                class="command">dpkg -V</code>) ist ein interessantes Tool, weil es herausfindet welche installierten Dateien (möglicherweise von einem Angreifer) modifiziert wurden aber dies sollte man nicht für bare Münze nehmen. Um seine Arbeit zu verrichten bezieht es sich auf Prüfsummen i der dpkg eigenen Datenbank welche auf der lokalen Festplatte liegt (man findet sie unter <code
                class="filename">/var/lib/dpkg/info/<em
                  class="replaceable">package</em>.md5sums</code>). Ein gründlicher Angreifer wird diese Dateien also mit den neuen Prüfsummen der manipulierten Dateien aktualisieren.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Dateifingerabdruck</strong></p></div></div></div><a
                id="id-1.17.6.6.3.5.2"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.3"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.4"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.5"
                class="indexterm"></a><div
                class="para">
					Zur Erinnerung: ein Fingerabdruck ist ein Wert, häufig eine Zahl (wenn auch in hexadezimaler Schreibweise), die eine Art Signatur für den Inhalt der Datei enthält. Diese Signatur wird mit einem Algorithmus berechnet (MD5 und SHA1 sind bekannte Beispiele), der mehr oder weniger garantiert, dass selbst kleinste Veränderungen des Dateiinhalts eine Änderung des Fingerabdrucks bewirken; dies wird als „Lawineneffekt“ bezeichnet. Er ermöglicht es, einen einfachen numerischen Fingerabdruck als Lackmustest zu verwenden, um zu überprüfen, ob der Inhalt einer Datei verändert wurde. Diese Algorithmen sind nicht umkehrbar; mit anderen Worten, bei den meisten von ihnen ermöglicht die Kenntnis eines Fingerabdrucks es nicht, den dazugehörigen Inhalt zu finden. Jüngste mathematische Fortschritte schwächen anscheinend die absolute Gültigkeit dieser Prinzipien, aber ihre Verwendung ist bisher nicht infrage gestellt, da es wohl nach wie vor eine recht schwierige Aufgabe ist, einen anderen Inhalt zu erstellen, der denselben Fingerabdruck ergibt.
				</div></div><div
              class="para">
					Das Ausführen von <code
                class="command">dpkg -V</code> überprüft alle installierten Pakete und gibt eine Zeile pro Datei mit fehlgeschlagenem Test aus. Das Ausgabeformat ist das gleiche wie das von <code
                class="command">rpm -V</code>, wobei jedes Zeichen einem Test auf bestimmte Metadaten entspricht. Leider speichert <code
                class="command">dpkg</code> die für die meisten Tests benötigten Metadaten nicht und gibt daher Fragezeichen aus. Derzeit kann nur der Prüfsummentest eine "5" für das dritte Zeichen ergeben (wenn er fehlschlägt).
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>dpkg -V</code></strong>
<code
                class="computeroutput">??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</code></pre><div
              class="para">
					Im obigen Beispiel meldet dpkg an der Servicedatei von SSH eine Änderung, die der Administrator an der gepackten Datei vorgenommen hat, anstatt einen entsprechenden <code
                class="filename">/etc/system/system/ssh.service</code> Override zu verwenden (der unter <code
                class="filename">/etc</code> gespeichert würde, so wie jede Änderung einer Konfiguration sein sollte). Außerdem werden mehrere Konfigurationsdateien (gekennzeichnet durch den Buchstaben "c" im zweiten Feld) aufgelistet, die korrekt geändert wurden.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.debsums"></a>14.3.3.2. Pakete auditieren: <code
                      class="command">debsums</code> und seine Grenzen</h4></div></div></div><a
              id="id-1.17.6.6.4.2"
              class="indexterm"></a><div
              class="para">
					<code
                class="command">debsums</code> ist der Vorgänger von <code
                class="command">dpkg -V</code> und damit meist veraltet. Es hat die gleichen Einschränkungen wie dpkg. Glücklicherweise können einige der Einschränkungen umgangen werden (während dpkg keine ähnlichen Workarounds bietet).
				</div><div
              class="para">
					Weil man den Daten auf der Festplatte nicht trauen kann, ermöglicht <code
                class="command">debsums</code> Prüfungen basierend auf <code
                class="filename">.deb</code> Dateien anstatt sich auf die dpkg Datenbank zu verlassen. Um gesicherte <code
                class="filename">.deb</code> Dateien für alle installierten Pakete herunterzuladen können wir uns auf die von APT beglaubigten Downloads verlassen. Diese Aktion kann sehr langsam und langwierig sein und sollte daher als proaktive Technik in Betracht gezogen werden und nicht regelmäßig verwendet werden.
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</code></strong>
<code
                class="computeroutput">[ ... ]
# </code><strong
                class="userinput"><code>debsums -p /var/cache/apt/archives --generate=all</code></strong></pre><div
              class="para">
					Man beachte, dass in diesem Beispiel der Befehl <code
                class="command">grep-status</code> aus dem Paket <span
                class="pkg pkg">grep-dctrl</span> verwendet wird, das nicht standardmäßig installiert ist.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.6.6.5"></a>14.3.3.3. Dateien überwachen: AIDE</h4></div></div></div><a
              id="id-1.17.6.6.5.2"
              class="indexterm"></a><div
              class="para">
					Das Hilfsprogramm AIDE (<span
                class="emphasis"><em>Advanced Intrusion Detection Environment</em></span>) ermöglicht es, die Unversehrtheit von Dateien zu überprüfen und jede Veränderung durch einen Vergleich mit einem zuvor festgehaltenen Abbild des intakten Systems zu entdecken. Dieses Abbild ist als Datenbank (<code
                class="filename">/var/lib/aide/aide.db</code>) abgespeichert, die relevante Informationen über alle Dateien des Systems enthält (Fingerabdrücke, Berechtigungen, Zeitstempel und so weiter). Diese Datenbank wird erstmals mit dem Befehl <code
                class="command">aideinit</code> initialisiert; sie wird dann täglich (mit dem Skript <code
                class="filename">/etc/cron.daily/aide</code>) genutzt, um nachzuprüfen, dass sich nichts Relevantes verändert hat. Wenn Veränderungen entdeckt werden, hält AIDE diese in Protokolldateien fest (<code
                class="filename">/var/log/aide/*.log</code>) und sendet seine Befunde per E-Mail an den Administrator.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>IN DER PRAXIS</em></span> Die Datenbank schützen</strong></p></div></div></div><div
                class="para">
					Da AIDE eine lokale Datenbank nutzt, um den Status der Dateien zu vergleichen, ist die Gültigkeit seiner Ergebnisse direkt an die Gültigkeit der Datenbank gebunden. Falls ein Angreifer auf einem kompromittierten System Administratorrechte erlangt, ist er in der Lage, die Datenbank auszutauschen und so seine Spuren zu verwischen. Eine mögliche Behelfslösung könnte darin bestehen, die Referenzdaten auf einem schreibgeschützten Medium zu speichern.
				</div></div><div
              class="para">
					Viele Optionen in <code
                class="filename">/etc/default/aide</code> können dazu verwendet werden, das Verhalten des Pakets <span
                class="pkg pkg">aide</span> zu justieren. AIDEs eigentliche Konfiguration ist in <code
                class="filename">/etc/aide/aide.conf</code> und <code
                class="filename">/etc/aide/aide.conf.d/</code> gespeichert (diese Dateien werden genau genommen nur von <code
                class="command">update-aide.conf</code> dazu benutzt, die Datei <code
                class="filename">/var/lib/aide/aide.conf.autogenerated</code> zu erstellen). Die Konfiguration gibt an, welche Eigenschaften welcher Dateien überprüft werden sollen. Der Inhalt von Protokolldateien verändert sich zum Beispiel regelmäßig, und derartige Veränderungen können ignoriert werden, solange die Berechtigungen dieser Dateien die gleichen bleiben. Aber sowohl der Inhalt als auch die Berechtigungen von ausführbaren Dateien müssen unverändert bleiben. Obwohl die Konfigurationssyntax nicht sehr komplex ist, ist sie nicht völlig intuitiv. Daher wird empfohlen, die Handbuchseite <span
                class="citerefentry"><span
                  class="refentrytitle">aide.conf</span>(5)</span> zu lesen.
				</div><div
              class="para">
					Eine neue Version der Datenbank wird täglich in <code
                class="filename">/var/lib/aide/aide.db.new</code> erstellt; falls alle aufgenommenen Veränderungen legitim waren, kann sie als Ersatz für die Referenzdatenbank verwendet werden.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> Tripwire und Samhain</strong></p></div></div></div><div
                class="para">
					Tripwire ist AIDE sehr ähnlich; selbst die Syntax der Konfigurationsdatei ist fast die gleiche. Die Hauptergänzung, die von <span
                  class="pkg pkg">tripwire</span> bereitgestellt wird, ist ein Verfahren, die Konfigurationsdatei zu signieren, so dass ein Angreifer mit ihr nicht auf eine andere Version der Referenzdatenbank verweisen kann.
				</div><div
                class="para">
					Samhain bietet ebenfalls ähnliche Leistungsmerkmale, sowie einige Funktionen, um Rootkits zu entdecken (siehe Seitenleiste <a
                  class="xref"
                  href="sect.supervision.html#sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"><span
                    class="emphasis"><em>KURZER BLICK</em></span> Die Pakete <span
                    class="pkg pkg">checksecurity</span> und <span
                    class="pkg pkg">chkrootkit</span>/<span
                    class="pkg pkg">rkhunter</span></a>). Es kann auch netzwerkweit eingesetzt werden und seine Spuren (mit einer Signatur) auf einem zentralen Server festhalten.
				</div></div><div
              class="sidebar"><a
                xmlns=""
                id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"></a><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KURZER BLICK</em></span> Die Pakete <span
                          class="pkg pkg">checksecurity</span> und <span
                          class="pkg pkg">chkrootkit</span>/<span
                          class="pkg pkg">rkhunter</span></strong></p></div></div></div><a
                id="id-1.17.6.6.5.8.2"
                class="indexterm"></a><div
                class="para">
					Das erste dieser Pakete enthält verschiedene kleine Skripte, die grundlegende Prüfungen des Systems durchführen (leere Passwörter, neue setuid-Dateien usw.) und den Administrator, falls nötig, warnen. Allerdings sollte sich trotz seines eindeutigen Namens kein Administrator nur auf dieses Paket verlassen, wenn er dafür sorgen möchte, dass ein Linux-System sicher ist.
				</div><div
                class="para">
					Die Pakete <span
                  class="pkg pkg">chkrootkit</span> und <span
                  class="pkg pkg">rkhunter</span> ermöglichen es, nach möglicherweise auf dem System installierten <span
                  class="emphasis"><em>Rootkits</em></span> Ausschau zu halten. Zur Erinnerung: dies sind Programme, die dazu bestimmt sind, die Kompromittierung eines Systems zu verbergen und gleichzeitig diskret den Rechner im Griff zu halten. Die Tests sind nicht zu 100% zuverlässig, aber sie können gewöhnlich die Aufmerksamkeit des Administrators auf die möglichen Probleme lenken.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.intrusion-detection"></a>14.3.4. Eindringen entdecken (IDS/NIDS)</h3></div></div></div><a
            id="id-1.17.6.7.2"
            class="indexterm"></a><a
            id="id-1.17.6.7.3"
            class="indexterm"></a><a
            id="id-1.17.6.7.4"
            class="indexterm"></a><a
            id="id-1.17.6.7.5"
            class="indexterm"></a><a
            id="id-1.17.6.7.6"
            class="indexterm"></a><a
            id="id-1.17.6.7.7"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Denial of Service</strong></p></div></div></div><a
              id="id-1.17.6.7.8.2"
              class="indexterm"></a><div
              class="para">
				Ein „Denial-of-Service“-Angriff hat nur ein Ziel: einen Dienst nicht verfügbar zu machen. Ob ein solcher Angriff nun darin besteht, den Server mit Anfragen zu überlasten oder einen Fehler auszunutzen, das Ergebnis ist das gleiche: der Dienst ist nicht mehr funktionsfähig. Die normalen Benutzer sind unzufrieden, und der Ruf der Organisation, die den angegriffenen Netzwerkdienst bereitstellt, erleidet Schaden (und verliert möglicherweise Einnahmen, falls zum Beispiel der Dienst eine E-Commerce-Website war).
			</div><div
              class="para">
				Solch ein Angriff erfolgt manchmal „verteilt“; dazu gehört es normalerweise, den Server mit einer großen Anzahl von Anfragen, die von vielen verschiedenen Quellen kommen, zu überlasten, so dass der Server nicht mehr imstande ist, die seriösen Anfragen zu beantworten. Diese Art von Angriffen hat bekannte Abkürzungen erhalten: <acronym
                class="acronym">DDoS</acronym> und <acronym
                class="acronym">DoS</acronym> (je nachdem, ob der Denial-of-Service-Angriff verteilt ist oder nicht).
			</div></div><div
            class="para">
				<code
              class="command">suricata</code> (im gleichnamigen Debian-Paket) ist ein NIDS - ein <span
              class="emphasis"><em>Network Intrusion Detection System</em></span>. Seine Funktion besteht darin, das Netzwerk abzuhören und zu versuchen, Eindringversuche oder feindliche Handlungen (einschließlich eines Denial-of-Service-Angriffs) zu entdecken. Alle diese Vorgänge werden in verschiedenen Dateien unter <code
              class="filename">/var/log/suricata</code> protokolliert. Es gibt Tools von Drittanbietern (Kibana/logstash) mit denen man die gesammelten Daten besser durchsuchen kann. <div
              xmlns=""
              class="url">→ <a
                xmlns="http://www.w3.org/1999/xhtml"
                href="http://suricata-ids.org">http://suricata-ids.org</a></div><div
              xmlns=""
              class="url">→ <a
                xmlns="http://www.w3.org/1999/xhtml"
                href="https://www.elastic.co/products/kibana">https://www.elastic.co/products/kibana</a></div>
			</div><a
            id="id-1.17.6.7.10"
            class="indexterm"></a><a
            id="id-1.17.6.7.11"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VORSICHT</em></span> Wirkungsbereich</strong></p></div></div></div><div
              class="para">
				Die Effektivität von <code
                class="command">suricata</code> wird durch den Datenverkehr begrenzt, der an der überwachten Netzwerk-Schnittstelle sichtbar ist. Es kann natürlich nichts entdecken, wenn es den tatsächlichen Datenverkehr nicht beobachten kann. Wenn es an einen Netzwerkswitch angeschlossen ist, wird es daher nur Angriffe überwachen, die auf den Rechner, auf dem es läuft, abzielen, was möglicherweise nicht die Absicht ist. Der Rechner, der <code
                class="command">suricata</code> beherbergt, sollte daher an den „Spiegel“-Port des Switches angeschlossen werden, der normalerweise speziell dafür vorgesehen ist, Switche zu verketten und daher allen Datenverkehr erhält.
			</div></div><div
            class="para">
				Die Konfiguration von suricata beinhaltet die Überprüfung und Bearbeitung von <code
              class="filename">/etc/suricata/suricata-debian.yaml</code>, was sehr lang daueren kann, da jeder Parameter reichlich kommentiert wird. Eine minimale Konfiguration erfordert die Beschreibung des Adressbereichs, den das lokale Netzwerk abdeckt (Parameter <code
              class="literal">HOME_NET</code>). In der Praxis bedeutet dies der Umfang aller möglichen Angriffsziele. Aber um das Beste daraus zu machen, muss man es vollständig lesen und an die örtlichen Gegebenheiten anpassen.
			</div><div
            class="para">
				Außerdem sollten Sie <code
              class="filename">/etc/default/suricata</code> bearbeiten, um die Netzwerkschnittstelle für die Überwachung zu definieren und das Initskript zu aktivieren (durch Setzen von <code
              class="literal">RUN=yes</code>). Sie können auch <code
              class="literal">LISTENMODE=pcap</code> setzen, da die Standardeinstellung <code
              class="literal">LISTENMODE=nfqueue</code> eine weitere Konfiguration erfordert, um korrekt zu funktionieren (die netfilter-Firewall muss so konfiguriert sein, dass sie Pakete an eine von Suricata verwaltete User Space-Warteschlange über das <code
              class="literal">NFQUEUE</code> Ziel durchreicht).
			</div><div
            class="para">
				<code
              class="command">Suricata</code> muss einen Satz an Monitoring-Regeln erstellen um bösartiges Verhalten zu entdecken: Man findet solche Regeln im <span
              class="pkg pkg">snort-rules-default</span> Paket. <code
              class="command">Snort</code> ist historisch die Referenz im IDS Ökosystem und <code
              class="command">suricata</code> kann die Regelsätze die für Snort geschrieben wurden weiterverwenden. Leider findet man das Paket nicht unter <span
              class="distribution distribution">Debian Jessie</span> und muss daher aus einem anderen Debian Release wie etwa <span
              class="distribution distribution">Testing</span> oder <span
              class="distribution distribution">Unstable</span> bezogen werden.
			</div><div
            class="para">
				Wahlweise kann auch <code
              class="command">oinkmaster</code> (im Paket selben Namens) genutzt werden um Snort Regelsätze von externen Quellen zu beziehen.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>WEITERE SCHRITTE</em></span> Integration mit <code
                        class="command">prelude</code></strong></p></div></div></div><div
              class="para">
				Prelude ermöglicht eine zentralisierte Überwachung von Sicherheitsinformationen. Seine modulare Architektur enthält einen Server (den <span
                class="emphasis"><em>Manager</em></span> im Paket <span
                class="pkg pkg">prelude-manager</span>), der Alarmmeldungen sammelt, die von verschiedenen Arten von <span
                class="emphasis"><em>Sensoren</em></span> erzeugt werden.
			</div><div
              class="para">
				Suricata kann als ein solcher Sensor konfiguriert werden. Eine andere Möglichkeit ist <span
                class="emphasis"><em>prelude-lml</em></span> (<span
                class="emphasis"><em>Log Monitor Lackey</em></span>), das Protokolldateien überwacht (in ähnlicher Weise wie das in <a
                class="xref"
                href="sect.supervision.html#sect.logcheck">Abschnitt 14.3.1, „Protokolle mit <code
                  class="command">logcheck</code> verfolgen“</a> beschriebene <code
                class="command">logcheck</code>).
			</div><a
              id="id-1.17.6.7.17.4"
              class="indexterm"></a></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Zurück</strong>14.2. Firewall oder Paketfilter</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Nach oben</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Zum Anfang</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Weiter</strong>14.4. Einführung in AppArmor</a></li></ul></body></html>
