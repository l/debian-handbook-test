<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.5. Användarrymden</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-sv-SE-1.0-1" /><meta
        name="keywords"
        content="BIOS, Kärna, Unix, Process, Hierarki, Grundläggande kommandon" /><link
        rel="home"
        href="index.html"
        title="Handbok för Debianadministratören" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Appendix B. Kort snabbkurs" /><link
        rel="prev"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. Vissa uppgifter hanteras av kärnan" /><link
        rel="next"
        href="backcover.html"
        title="Appendix C. Handbok för Debianadministratören" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/sv-SE/stable/sect.user-space.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Föregående</strong></a></li><li
          class="home">Handbok för Debianadministratören</li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Nästa</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.user-space"></a>B.5. Användarrymden</h2></div></div></div><a
          id="id-1.21.8.2"
          class="indexterm"></a><a
          id="id-1.21.8.3"
          class="indexterm"></a><div
          class="para">
			”Användarrymd” refererar till körtidsmiljön för normala processor (till skillnad mot kärnprocesser). Detta innebär inte nödvändigtvis att dessa processer faktiskt startades av användare då ett standardsystem normalt har flera ”demon”-processer (eller bakgrundsprocesser) körandes innan användaren ens öppnar en session. Demonprocesser anses också vara användarrymdsprocesser.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.process-basics"></a>B.5.1. Process</h3></div></div></div><a
            id="id-1.21.8.5.2"
            class="indexterm"></a><div
            class="para">
				När kärnan kommer förbi sin initieringsfas startar den den allra första processen, <code
              class="command">init</code>. Process #1 är ensam sällan särskilt användbar, och Unix-liknande system kör med många flera processer.
			</div><a
            id="id-1.21.8.5.4"
            class="indexterm"></a><div
            class="para">
				För det första kan en process klona sig själv (detta är känt som <span
              class="emphasis"><em>fork</em></span>). Kärnan allokerar ett nytt (men identiskt) minnesområde för processen, och en ny process som kan använda den. Vid denna tidpunkt är den enda skillnaden mellan dessa två processer deras <span
              class="emphasis"><em>pid</em></span>. Den nya processen kallas vanligen en barnprocess, och originalprocessen vars <span
              class="emphasis"><em>pid</em></span> inte ändras, kallas för föräldraprocessen.
			</div><div
            class="para">
				Ibland fortsätter barnprocessen att leva sitt eget liv, oberoende från sin förälder, med sin egen data kopierad från föräldraprocessen. I många fall exekverar dock denna barnprocess ett annat program. Med ett fåtal undantag ersätts dess minne helt enkelt med det för det nya programmet och exekvering av detta nya program påbörjas. Detta är mekanismen som används av initprocessen (med processnummer 1) för att starta ytterligare tjänster och exekvera hela uppstartssekvensen. Vid en tidpunkt kommer en process bland <code
              class="command">init</code>s barn att starta ett grafiskt gränssnitt genom vilket användare kan logga in (den faktiska sekvensen av händelser beskrivs i ytterligare detalj i <a
              class="xref"
              href="unix-services.html#sect.system-boot">Avsnitt 9.1, ”System Boot”</a>).
			</div><div
            class="para">
				När en process avslutar uppgiften som var anledningen till att den startades så avslutas den. Kärnan återhämtar sedan minne som tilldelats till denna process och slutar ge den körtidsintervall. Föräldraprocessen informeras om att dess barnprocess avslutats, vilket låter en process vänta på att en uppgift som delegerats till en barnprocess slutförts. Detta beteende syns tydligt i kommandotolkar (kända som <span
              class="emphasis"><em>skal</em></span>). När ett kommando matas in i ett skal, handlar det helt enkelt om att lägga till ett <strong
              class="userinput"><code>&amp;</code></strong> på slutet av kommandot. Prompten visas igen inom kort vilket kan leda till problem om kommandot själv behöver skriva ut data.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.daemons"></a>B.5.2. Demoner</h3></div></div></div><a
            id="id-1.21.8.6.2"
            class="indexterm"></a><a
            id="id-1.21.8.6.3"
            class="indexterm"></a><div
            class="para">
				En ”demon” är en process som startats automatiskt av uppstartssekvensen. Den fortsätter köra (i bakgrunden) för att utföra underhållsuppgifter eller tillhandahålla tjänster till andra processer. Denna ”bakgrundsuppgift” är faktiskt slumpmässig och matchar inte någon särskild typ ur systemets synvinkel. De är helt enkelt processer, liknande andra processer, som kör i turordning när deras tidsintervall kommer. Skillnaden är endast i hur man talar om den: en process som kör utan interaktion med en användare (i synnerhet utan ett grafiskt gränssnitt) kallas för att den kör ”i bakgrunden” eller ”som en demon”.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOKABULÄR</em></span> Demon, ett nedsättande namn?</strong></p></div></div></div><div
              class="para">
				Även om namnet <span
                class="emphasis"><em>demon</em></span> delar sin grekiska etymologi med <span
                class="emphasis"><em>demon</em></span>, implicerar inte den föregående något djävulskt, utan istället bör det förstås som ett slags skyddsande. Denna distinktion är subtil nog på engelska (daemon respektive demon) ; det är än värre på andra språk (till exempel svenska) där samma ord används för båda betydelserna.
			</div></div><div
            class="para">
				Flera sådana demoner beskrivs i detalj i <a
              class="xref"
              href="unix-services.html">Kapitel 9, <em>Unix Services</em></a>.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ipc"></a>B.5.3. Interprocesskommunikation</h3></div></div></div><a
            id="id-1.21.8.7.2"
            class="indexterm"></a><a
            id="id-1.21.8.7.3"
            class="indexterm"></a><div
            class="para">
				En isolerad process, vare sig det är en demon eller ett interaktivt program, är sällan användbar på egen hand, vilket är anledning till att det finns flera sätt att låta separata processer kommunicera med varandra, antingen för att utbyta data eller för att styra varandra. Den generella termen för att referera till detta är <span
              class="emphasis"><em>interprocesskommunikation</em></span>, eller IPC (efter engelskans Inter-Process Communication).
			</div><div
            class="para">
				Det enklaste IPC-systemet är ett använda filer. Processen som önskar skicka data skriver denna till en fil (med ett förutbestämt namn), medan mottagaren endast behöver öppna filen och läsa dess innehåll.
			</div><a
            id="id-1.21.8.7.6"
            class="indexterm"></a><div
            class="para">
				I fallet där du inte önskar spara data på disk kan du använda en <span
              class="emphasis"><em>rörledning</em></span>, vilket helt enkelt är ett objekt med två ändar; byte skrivs i en ände och kan läsas i den andra. Om ändarna styrs av olika processer leder detta till en enkel och behändig kanal för interprocesskommunikation. Rörledningar kan klassificeras i två kategorier: namngivna rörledningar och anonyma rörledningar. En namngiven rörledning representeras av en post i filsystemet (även om den överförda datan inte lagras där), så att båda processerna kan öppna den oberoende av varandra så länge platsen för den namngivna rörledningen är förutbestämd. I fall när kommunicerande processer är relaterade (till exempel en föräldraprocess och dess barnprocess) kan föräldraprocessen också skapa en anonym rörledning innan forkning, och därför kommer barnet att ärva den. Båda processerna kommer sedan kunna utbyta data via rörledningen utan att behöva involvera filsystemet.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>I PRAKTIKEN</em></span> Ett konkret exempel</strong></p></div></div></div><div
              class="para">
				Låt oss beskriva i detalj vad som händer när ett komplext kommando (en <span
                class="emphasis"><em>rörledning</em></span>) körs från ett skal. Vi antar att vi har en <code
                class="command">bash</code>-process (standardskalet på Debian), med <span
                class="emphasis"><em>pid</em></span> 4374; i detta skal matar vi in kommandot: <code
                class="command">ls | sort</code>.
			</div><div
              class="para">
				Skalet tolkar först kommandot som matats in. I vårt fall förstår det att det finns två program(<code
                class="command">ls</code> och <code
                class="command">sort</code>), med en dataström som flödar från ett till ett annat (betecknat av tecknet <strong
                class="userinput"><code>|</code></strong>, känt som <span
                class="emphasis"><em>rörledning</em></span>). <code
                class="command">bash</code> skapar först en icke namngiven rörledning (som i inledningsskedet endast existerar inom <code
                class="command">bash</code>-processen själv).
			</div><div
              class="para">
				Sedan klonar skalet sig själv; detta leder till en ny <code
                class="command">bash</code>-process med <span
                class="emphasis"><em>pid</em></span> #4521 (<span
                class="emphasis"><em>pid</em></span>:ar är abstrakta nummer och har i allmänhet ingen mening). Process #4521 ärver rörledningen, vilket innebär att den kan skriva till dess ”ingångsände”; <code
                class="command">bash</code> omdirigerar sin standard ut-ström till denna rörlednings ingång. Sedan exekverar det (och ersätter sig själv med) programmet <code
                class="command">ls</code>, vilket listar innehållet i den aktuella katalogen. Eftersom <code
                class="command">ls</code> skriver på sin standard ut och denna utgång tidigare har omdirigerats kommer resultaten i att skickas in i rörledningen.
			</div><div
              class="para">
				En liknande åtgärd händer för det andra kommandot: <code
                class="command">bash</code> klonar sig själv igen, vilket leder till en ny <code
                class="command">bash</code>-process med pid #4522. Eftersom detta också är en barn process till #4374, ärver denna också rörledningen; <code
                class="command">bash</code> ansluter sedan sin standard in till rörledningens utgång, sedan kör det (och ersätter sig själv med) <code
                class="command">sort</code>-kommandot, vilket sorterar sin indata och skriver ut resultaten.
			</div><div
              class="para">
				Alla delarna i pusslet är nu inställda: <code
                class="command">ls</code> läser den aktuella katalogen och skriver listan av filer till rörledningen; <code
                class="command">sort</code> läser denna lista, sorterar den alfabetiskt och skriver ut resultaten. Processnummer #4521 och #4522 avslutas sedan och #4374 (vilken väntat på dem under åtgärden), återtar kontrollen och skriver ut en prompt för att låta användaren mata in ett nytt kommando.
			</div></div><div
            class="para">
				Inte all interprocesskommunikation används för att flytta runt data, dock. I många situationer är den enda information som måste överföras kontrollmeddelanden så som ”pausa körning”, eller ”återuppta körning”. Unix (och Linux) tillhandahåller en mekanism känd som <span
              class="emphasis"><em>signaler</em></span> genom vilka en process enkelt kan skicka en specifik signal (vald från en fördefinierad lista av signaler) till en annan process. Det enda kravet är att veta målets <span
              class="emphasis"><em>pid</em></span>.
			</div><div
            class="para">
				För mer komplex kommunikation finns det också mekanismer för att låta en process göra tillgängligt, eller dela, en del av sitt allokerade minne till andra processer. Minne som nu delas mellan dem kan användas för att flytta data mellan processerna.
			</div><div
            class="para">
				Avslutningsvis kan nätverksanslutningar också hjälpa processer att kommunicera; dessa processer kan till och med köras på olika datorer, tusentals kilometer från varandra.
			</div><div
            class="para">
				Det är ganska vanligt för ett typiskt Unix-liknande system att använda alla dessa mekanismer i olika utsträckning.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.libraries"></a>B.5.4. Bibliotek</h3></div></div></div><a
            id="id-1.21.8.8.2"
            class="indexterm"></a><div
            class="para">
				Funktionsbibliotek spelar en väsentlig roll i ett Unix-liknande operativsystem. Det är inte egentliga program, då de inte kan köras för sig, utan är samlingar av kodfragment som kan användas av standardprogram. Bland de vanliga biblioteken hittar du:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						standard C-biblioteket (<span
                    class="emphasis"><em>glibc</em></span>), vilket innehåller grundläggande funktioner för att öppna filer eller nätverksanslutningar, och andra som möjliggör interaktion med kärnan;
					</div></li><li
                class="listitem"><div
                  class="para">
						grafiska verktygslådor, så som Gtk+ och Qt, vilket låter många program återanvända de grafiska objekten de tillhandahåller;
					</div></li><li
                class="listitem"><div
                  class="para">
						biblioteket <span
                    class="emphasis"><em>libpng</em></span>, som möjliggör inläsning, tolkning och sparande av bilder i PNG-formatet.
					</div></li></ul></div><div
            class="para">
				Tack vare dessa bibliotek, kan program återanvända kod. Programutveckling förenklas då många program kan återanvända samma funktioner. Med bibliotek som utvecklats av olika personer tas den globala utvecklingen av systemet närmre Unix historiska filosofi.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>KULTUR</em></span> Unix-sättet: en sak åt gången</strong></p></div></div></div><div
              class="para">
				En av de fundamentala koncepten som underbygger operativsystemen i Unix-familjen är att varje verktyg endast bör göra en sak och göra det bra; program kan sedan återanvända dessa verktyg för att bygga mer avancerad logik ovanpå. Denna filosofi kan ses i många inkarnationer. Skalskript är kanske det bästa exemplet: de förenar komplexa sekvenser från väldigt enkla verktyg (så som <code
                class="command">grep</code>, <code
                class="command">wc</code>, <code
                class="command">sort</code>, <code
                class="command">uniq</code>, o.s.v.) En annan implementation av denna filosofi kan ses i kodbibliotek: biblioteket <span
                class="emphasis"><em>libpng</em></span> tillåter inläsning och skrivning av PNG-bilder, med olika flaggor och på olika sätt, men det gör endast det; det finns ingen chans att det inkluderar funktioner som visar eller redigerar bilder.
			</div></div><div
            class="para">
				Därutöver refereras dessa bibliotek ofta till som ”delade bibliotek” då kärnan kan läsa in dem i minne endast en gång även om flera processer använder samma bibliotek samtidigt. Detta möjliggör sparande av minne, när det jämförs med den motsatta (hypotetiska) situationen där koden för ett bibliotek måste läsas in lika många gånger som det finns processor som använder det.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Föregående</strong>B.4. Vissa uppgifter hanteras av kärnan</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Upp</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Hem</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Nästa</strong>Appendix C. Handbok för Debianadministratören</a></li></ul></body></html>
