<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">第 9 章 Unix 服务</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-zh-CN-1.0-1" /><meta
        name="keywords"
        content="系统启动, 启动脚本, SSH, Telnet, 权限, 许可, 管理, Inetd, Cron, 备份, 热插拔, PCMCIA接口, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Debian 管理员手册" /><link
        rel="up"
        href="index.html"
        title="Debian 管理员手册" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. 安装内核" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. 远程登录" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/zh-CN/stable/unix-services.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>上一页</strong></a></li><li
          class="home">Debian 管理员手册</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>下一页</strong></a></li></ul><div
        xml:lang="zh-CN"
        class="chapter"
        lang="zh-CN"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  xmlns=""
                  id="unix-services"></a>第 9 章 Unix 服务</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. 系统启动</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. Systemd 启动系统</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. System V 初始系统</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. 远程登录</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. 安全远程登录：SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. 使用远程图形桌面</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. 管理权限</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. 管理员界面</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. 管理网页接口：<code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. 用于管理配置的软件包： <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> 系统事件</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. 原则和机制</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. 配置文件</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. The <code
                    class="command">inetd</code> 超级服务器</a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. 使用 <code
                    class="command">cron</code> 和 <code
                    class="command">atd</code>运行计划任务</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. <code
                        class="filename">crontab</code> 文件的格式</a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. 使用 <code
                        class="command">at</code> 命令</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. 调度异步任务：<code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. 配额</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. 备份</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. 使用 <code
                        class="command">rsync</code>备份</a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. 不使用备份恢复系统</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. 热插拔： <span
                    class="emphasis"><em>热插拔</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. 介绍</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. 命名问题</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. <span
                        class="emphasis"><em>udev</em></span> 如何工作</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. 一个具体例子</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. 电源管理：高端配置与电源接口 (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		本章涵盖一些Unix系统共通的服务。管理员应当熟悉他们。
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    xmlns=""
                    id="sect.system-boot"></a>9.1. 系统启动</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			当启动计算机时，控制台上滚动的大量信息显示许多初始化和配置工作自动正在执行。有时候你可能稍稍的改变这一阶段的操作，就要求你需要很好的理解他们。这正是本章节的目的所在。
		</div><div
            class="para">
			首先，BIOS 控制电脑，探测磁盘，加载<span
              class="emphasis"><em>Master Boot Record</em></span>，并执行启动加载器。启动程序接手后，找到磁盘上的内核，加载并执行。然后，内核被初始化，并开始寻找和挂载包含根文件系统的分区，最后执行第一个程序－<code
              class="command">init</code>。根分区和启动程序<code
              class="command">init</code>常常驻留在仅存在于 RAM 中的虚拟文件系统（正如它的名字，“initramfs”，一般称之为“initrd”初始内存磁盘）。启动加载器将文件系统加载到内存中，文件通常位于硬盘或者源于网络。它包含了内核需要的最少裸信息，以便用来加载“真正”的根文件系统：可能是硬盘上的驱动模块，或者其他系统启动必须的设备，或者更常见的是初始化脚本和模块以组建 RAID 阵列，打开加密分区，激活 LVM ，等等。一旦根分区挂载，initramfs 就会把控制权交到真正的启动程序，机器则回到标准的启动过程。
		</div><div
            class="figure"><a
              xmlns=""
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="运行 sytemd 的 Linux 计算机的启动顺序" /></div></div><p
              class="title"><strong>图 9.1. 运行 sytemd 的 Linux 计算机的启动顺序</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.systemd"></a>9.1.1. Systemd 启动系统</h3></div></div></div><div
              class="para">
				“真正的启动器”当前是由<span
                class="pkg pkg">systemd</span> 提供的，本章节讲述该启动系统。
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>文化</em></span> 在 <code
                          class="command">systemd</code> 之前</strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> 是相当新的 “启动系统”，虽然在 <span
                  class="distribution distribution">Wheezy</span> 里已经可以使用到某个程度，直到 Debian <span
                  class="distribution distribution">Jessie</span> 才纳入默认值。稍最的版本，缺省是 “System V init” (在 <span
                  class="pkg pkg">sysv-rc</span> 软件包内)，算是传统的系统。以下描述的是 System V init。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>选择</em></span> 其它启动系统</strong></p></div></div></div><div
                class="para">
				本书描述的是 Debian <span
                  class="distribution distribution">Jessie</span> (如 <span
                  class="pkg pkg">systemd</span> 软件包所应用的) 缺省的启动系统，以及更早的默认值，<span
                  class="pkg pkg">sysvinit</span>，源自于 <span
                  class="emphasis"><em>System V</em></span> Unix 系统；还有若干其他的。
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> 是一个过程很简单的启动系统。它保留运行等级的原则，但是用配置文件取代了目录和符号链接，来告诉<code
                  class="command">init</code>哪些进程必须启动及其顺序。
			</div><div
                class="para">
				此 <code
                  class="command">upstart</code> 系统在 Debian 上仍未完整测试。它以事件为基础：不再依序运行 init 脚本，但以回应另个依附的脚本。由 Ubuntu 开始的这个系统，列在 Debian <span
                  class="distribution distribution">Jessie</span> 内，但还不是缺省；事实上，做为 <span
                  class="pkg pkg">sysvinit</span> 的替代品，由 <code
                  class="command">upstart</code> 启动的工作，系用来启动为传统系统而设的，特别是来自 <span
                  class="pkg pkg">sysv-rc</span> 软件包的脚本。
			</div><div
                class="para">
				也有其他的系统和操作模式，例如：<code
                  class="command">runit</code> 或者 <code
                  class="command">minit</code>，但是他们相对专门且没有那么普遍。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>特例</em></span> 从网络启动</strong></p></div></div></div><div
                class="para">
				在某些配置中，BIOS 可以配置为不执行 MBR，而是在网络上寻找类似的东西，这样就可以制作不需要硬盘的电脑，在每次启动后可以完全重装。不是所有的硬件都支持该选项，它需要 BIOS 和网卡很好的配合。
			</div><div
                class="para">
				从网络启动可以用于执行 <code
                  class="command">debian-installer</code> or FAI （参考 <a
                  class="xref"
                  href="installation.html#sect.installation-methods">第 4.1 节 “安装方式”</a>）。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>回到基础</em></span>进程，一个程序实例</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				一个进程代表一个在内存中运行的程序。它包含了需要正确执行软件的所有必要信息（代码本身，内存数据，打开的文件清单，建立的网络连接，等等）。一个程序可能初始化为几个进程，而没必要使用不同的用户 ID 。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>安全</em></span> 使用 shell 作为 <code
                          class="command">init</code> 获取超级用户权限</strong></p></div></div></div><div
                class="para">
				通常，第一个启动的进程是 <code
                  class="command">init</code> 程序（默认是到 <code
                  class="filename">/lib/systemd/systemd</code> 的符号链接）。然而，也可以通过传递 <code
                  class="literal">init</code> 选项告诉内核使用其他的程序。
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				任何可以接近电脑的人都能按下<span
                  class="keycap"><strong>复位</strong></span> 按，并重新启动。然后，在启动提示下，传递<code
                  class="literal">init=/bin/sh</code>选项给内核，无需知道密码而获取超级用户权限。
			</div><div
                class="para">
				为了防止此类事件，可以给加载器设定密码。你也许会考虑保护 BIOS （密码保护总是可行的），这样可以防止侵入者使用包含自己的 Linux 系统的移动介质启动电脑，使用该系统他们可以读取硬盘上的数据。
			</div><div
                class="para">
				最后，应该知道大多数 BIOS 有一个通用的密码。最初用于让那些忘记自己密码的人解决问题，这些密码现在是公开的并且可以在网上找到（通过搜索引擎搜索“通用 BIOS 密码”）。所有这些保护措施都不太可能完全阻止非授权用户操作机器。如果攻击者能直接接触电脑，就没有可靠的方法保护电脑；他们可以拆下硬盘连到自己的电脑上，甚至是偷走整个机器，或者擦除 BIOS 来重置密码…
			</div></div><div
              class="para">
				Systemd 运行多个进程，设置系统：键盘、驱动程序、文件系统、网络、服务等。同时全面查看系统，以及必要的配件。每个配件都视为一个 “单元文件” (有时为多个)；通用的语法源自于常用的 “*.ini files“ 语法，包括配对的 <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code> 列在 <code
                class="literal">[<em
                  class="replaceable">section</em>]</code> 标头内。单元文件保存在 <code
                class="filename">/lib/systemd/system/</code> 与 <code
                class="filename">/etc/systemd/system/</code> 内；以多种风貌呈现，目前专注在 “服务” 与 “目标”。
			</div><div
              class="para">
				systemd “服务文件” 描述被 systemd 管理的进程。包括与旧型的 init-scripts 相同的数据，但以声明 (同时较为简洁) 的方式表述。Systemd 处理大量重复的工作 (启动与终止进程、检查其状态、日注记录、去除特权等)，以及只供特定进程使用的服务文件。例如，以下是 SSH 用到的服务档：
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				如上文所示，代码极少，只有声明。Systemd 管理显示进度报表、追踪进程、以及必要的重启。
			</div><div
              class="para">
				systemd 的 “目标文件” 描述系统的现状，包括可操作的服务。不妨视为相当于旧型的运行阶段作业。其中一个目标是 <code
                class="literal">local-fs.target</code>；进入之后，系统的其他部分假设所有的本地文件系统均己挂载并可近用。其他的目标包括 <code
                class="literal">network-online.target</code> 与 <code
                class="literal">sound.target</code>。目标的相依性可以列在目标文件内 (于 <code
                class="literal">Requires=</code> 列) 或使用符号链接至在 <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code> 文件夹内的服务文件。例如，<code
                class="filename">/etc/systemd/system/printer.target.wants/</code> 包括一个链接至 <code
                class="filename">/lib/systemd/system/cups.service</code>；systemd 将确保 CUPS 已运行至 <code
                class="literal">printer.target</code>。
			</div><div
              class="para">
				单元文件是声明性的而不是脚本或程序，不能直接运行，只能被 systemd 解译；因些有些工具允许管理者与 systemd 交互且控制系统的状态与其组件。
			</div><div
              class="para">
				第一种这类工具是 <code
                class="command">systemctl</code>。未使用参数运行时，它列出 systemd 已知的所有单元档 (除了已经停用的)，及其现况。<code
                class="command">systemctl status</code> 则以更佳的角度查看服务，以及相关的进程。若提供服务的名称 (如 <code
                class="command">systemctl status ntp.service</code>)，则送回更多详细的数据，以及与该服务有关的最后几个日志档 (还有更多的)。
			</div><div
              class="para">
				运行 <code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code> 就能以人工方式启动服务。同样的，运行 <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code> 就能停止已完成的服务；其他的次命令包括 <code
                class="command">reload</code> 与 <code
                class="command">restart</code>。
			</div><div
              class="para">
				以 <code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> (或 <code
                class="command">disable</code>) 控制启动服务 (即开机后自动启动)。<code
                class="command">is-enabled</code> 可以检查服务的状态。
			</div><div
              class="para">
				systemd 重要的功能之一是包括登录的组件 <code
                class="command">journald</code>。做为补充 <code
                class="command">syslogd</code> 之类传统登录系统的组件，但加入额外的功能包括在服务与其产生消息间的正式链接，以及补捉由初始过程产生的错误消息。在 <code
                class="command">journalctl</code> 命令的协助下，稍后可显示该等消息。不需任何参数，它溢出系统启动后发生的所有日志消息；不过很少用到它。多数时间，把它做为服务的辨识器：
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				另个有用的命令行旗标是 <code
                class="command">-f</code>，用于指示 <code
                class="command">journalctl</code> 继续显示溢出的添加消息 (大部分是在 <code
                class="command">tail -f <em
                  class="replaceable">file</em></code> 之内)。
			</div><div
              class="para">
				若服务状况不如预共，第一个步骤是以 <code
                class="command">systemctl status</code> 检查该服务是否真的已启动；若没有，则第一个命令给的消息就不足以诊断问题之所在，检查 journald 产生的日志档。例如，假设 SSH 服务器未启动时：
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				检查服务的状态 (失败) 后，再检查日志档；它们会指出配置的错误。编辑配置档并修正错误后，重启服务，确认运行中。
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>下一步</em></span> 其他类型的单元档</strong></p></div></div></div><div
                class="para">
				本区只描述 systemd 最基本的功能。其他的功能只能在此列出若干：
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						启用插口：“插口” 单元文件可用于描述 systemd 管理的网络或 Unix 插口；也就是由 systemd 创建的插口，可以在需要的时候再启动实际的服务。通常重制 <code
                        class="command">inetd</code> 的功能。见 <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>。
					</div></li><li
                    class="listitem"><div
                      class="para">
						定时器：“定时器” 单元文件描述定时或在指定时间发生的事件；与定时器链接的服务，其映射的工作将在定时器的要求下才运行。 允许重制 <code
                        class="command">cron</code> 的部分功能。见 <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>。
					</div></li><li
                    class="listitem"><div
                      class="para">
						网络：“网络“ 单元文件描述网络接口，允许配置该等接口以及表述在特定接口的服务。
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.sysvinit"></a>9.1.2. System V 初始系统</h3></div></div></div><div
              class="para">
				System V 初始系统 (简称初始) 运行若干进程，根据 <code
                class="filename">/etc/inittab</code> 文件的指令做事。第一个运行的程序 (映射于 <span
                class="emphasis"><em>sysinit</em></span> 步骤) 是 <code
                class="command">/etc/init.d/rcS</code>，一个运行在 <code
                class="filename">/etc/rcS.d/</code> 文件夹内所有程序的脚本。<a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				其中，你会发现相继的程序会负责：
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						配置控制台键盘；
					</div></li><li
                  class="listitem"><div
                    class="para">
						加载驱动：当探测到硬件，大部分内核模块通过内核自身加载；然后，自动加载 <code
                      class="filename">/etc/modules</code> 中列出的模块；
					</div></li><li
                  class="listitem"><div
                    class="para">
						检查文件系统的完整性；
					</div></li><li
                  class="listitem"><div
                    class="para">
						挂载本地分区；
					</div></li><li
                  class="listitem"><div
                    class="para">
						配置网络；
					</div></li><li
                  class="listitem"><div
                    class="para">
						挂载网络文件系统（NFS）。
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>回到基础</em></span> 内核模块和选项</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				内核模块也有一些选项，可以通过在 <code
                  class="filename">/etc/modprobe.d/</code> 中放置一些文件配置。这些选项通过诸如此类的语法定义：<code
                  class="literal">选项 <em
                    class="replaceable">模块名字</em> <em
                    class="replaceable">选项名字</em>=<em
                    class="replaceable">选项值</em></code>。如果有必要，一些选项可以通过单独的定向命令指示。
			</div><div
                class="para">
				这些配置档系供 <code
                  class="command">modprobe</code> 使用 — 这个程序加载核心模块及其相依者 (才能直正的调用其他模块)。这个程序由 <span
                  class="pkg pkg">kmod</span> 软件包提供。
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				到了这个地步，<code
                class="command">init</code> 接手并启动运行阶段缺省的程序 (通常是运行阶段 2)。它运行 <code
                class="command">/etc/init.d/rc 2</code>，一个启动列在 <code
                class="filename">/etc/rc2.d/</code> 之内的所有服务并命名为 “S” 字母开头。接着的两位数，曾经做为服务启动的顺序，不过现在的缺省启动系统使用 <code
                class="command">insserv</code>，根据脚本的相依性自动决定其先后顺序。每个启动脚本声明的情况必须符合启动或停止服务 (例如，必须在另个服务之前或之后启动)；<code
                class="command">init</code> 再依此情况启动它们。不再考虑静态的脚本编号 (但仍需按相依性使用 “S” 及两个数字与实际的脚本名称)。通常，基本的服务 (诸如以 <code
                class="command">rsyslog</code> 登录，或以 <code
                class="command">portmap</code> 指定端口口) 先列出来，然后才是标准服务与图形接口 (<code
                class="command">gdm3</code>)。
			</div><div
              class="para">
				这种以依赖为基础的启动系统使自动排序成为可能，这样的排序如果要手工完成则显得冗长乏味。由于调度根据明确给出的参数进行，这样就避免了人为错误。另一个好处是，如果两个服务彼此独立，则可以并行启动，进而加速启动过程。
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code>分几个运行等级，它可以通过<code
                class="command">telinit <em
                  class="replaceable">new-level</em></code> 命令，从一个等级切换到另一个等级。马上就会在新等级下重新执行<code
                class="command">init</code> executes <code
                class="command">/etc/init.d/rc</code>。这个脚本会启动漏掉的服务并中止不再需要的服务。为了做到这一点，它读取<code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> 文件的内容（此处 <em
                class="replaceable">X</em> 代表新的运行等级）。以“S"（Start的首字母）开头的服务脚本要启动；以“K"（Kill的首字母）开头的服务要停止。脚本不会启动在之前运行等级已经生效的服务。
			</div><div
              class="para">
				缺省，Debian 的 System V init 使用四个不同的运行阶层：
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						等级０仅作电脑关机时的临时应用。这样，它只包含许多“K”脚本。
					</div></li><li
                  class="listitem"><div
                    class="para">
						等级１，也被称为单用户模式，对应于降级的系统模式；它仅包含基本服务，用于维护，此时不需要与一般用户交互。
					</div></li><li
                  class="listitem"><div
                    class="para">
						等级２用于正常运行，包含网络服务，图形界面，用户登陆，等等。
					</div></li><li
                  class="listitem"><div
                    class="para">
						等级６和等级０类似，不同在于它用于系统重启之前的关机。
					</div></li></ul></div><div
              class="para">
				也存在其他等级，从３到５。默认情况，他们配置为和等级２相同，但是管理员可以修改（通过添加和删除对应<code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>目录下的脚本）它们来适应不同的需求。
			</div><div
              class="figure"><a
                xmlns=""
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="以 System V init 运行 Linux 的启动进程" /></div></div><p
                class="title"><strong>图 9.2. 以 System V init 运行 Linux 的启动进程</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				所有包含在<code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>目录下的脚本都只是符号联接－有<code
                class="command">update-rc.d</code>程序在安装时创建－指向存储在<code
                class="filename">/etc/init.d/</code>中的实际脚本。管理员可以使用调整后的参数重新运行 <code
                class="command">update-rc.d</code> 来微调每个运行等级的服务。<span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span>手册详细介绍了语法。请注意，使用<code
                class="literal">remove</code> 参数移除所有的符号连接不是停用服务的好办法。取而代之的方法是，你可以在特定的运行等级将其配置为不启动（而保留先前等级对应事件的停止调用）。由于<code
                class="command">update-rc.d</code>的接口有些绕，可以考虑使用<code
                class="command">rcconf</code>（出自<span
                class="pkg pkg">rcconf</span> 软件包），它提供了更加友好的界面。
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN 策略</em></span> 重启服务</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				Debian 软件包的维护者脚本将不时重新启动特定服务以确保其有效性或取得特定的选项。控制服务的命令 — <code
                  class="command">service <em
                    class="replaceable">service</em> <em
                    class="replaceable">operation</em></code> — 未考量运行阶层，假设 (错误地) 该服务仍在使用中，且可能启动错误的作业 (启动应该停止的服务，或停止已经停止的服务等)。因此，Debian 有个 <code
                  class="command">invoke-rc.d</code> 程序：必须由维护者的脚本启动，运行服务的初启脚本且只运行必要的命令。注意，不同于常见的用法，在程序名之前使用 <code
                  class="filename">.d</code> 前置，且不能在文件夹内。
			</div></div><div
              class="para">
				最后，<code
                class="command">init</code>启动各种虚拟控制台的控制程序（<code
                class="command">getty</code>）。显示提示符，等待输入用户名，然后执行<code
                class="command">login <em
                  class="replaceable">user</em></code>发起会话。
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>词汇</em></span> 控制台和终端</strong></p></div></div></div><div
                class="para">
				早期的计算机通常被分成几个很大的部分：存储箱和中央处理单元与外围操作员的控制设备相分离。这些部件是单独的装置，即“控制台”。该术语被保留下来，但是其意义改变了。或多或少它已经和“终端”同义，代表键盘和屏幕。
			</div><div
                class="para">
				随着计算机的发展，操作系统提供了许多虚拟终端，从而允许同时存在几个独立的会话，即使是只有一套键盘和屏幕。大部分 GNU/Linux 系统提供六个虚拟终端（在文本模式），通过组合键 <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> 到 <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span> 开启。
			</div><div
                class="para">
				推而广之，术语“控制台”和“终端”也代表在X11图形会话中的终端模拟器（类似<code
                  class="command">xterm</code>，<code
                  class="command">gnome-terminal</code> 或者 <code
                  class="command">konsole</code>）。
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>上一页</strong>8.11. 安装内核</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上一级</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>起始页</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>下一页</strong>9.2. 远程登录</a></li></ul></body></html>
