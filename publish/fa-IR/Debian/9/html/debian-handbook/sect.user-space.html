<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.5. فضای کاربری</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-fa-IR-1.0-1" /><meta
        name="keywords"
        content="بایوس, کرنل, یونیکس, فرآیند, سلسله‌مراتب, دستورات ابتدایی" /><link
        rel="home"
        href="index.html"
        title="راهنمای دبیان برای مدیر سیستم‌ها" /><link
        rel="up"
        href="short-remedial-course.html"
        title="پيوست B. درس کاربردی کوتاه" /><link
        rel="prev"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. برخی از وظایفی که کرنل به آن‌ها رسیدگی می‌کند" /><link
        rel="next"
        href="backcover.html"
        title="پيوست C. راهنمای دبیان برای مدیر سیستم‌ها" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/fa-IR/stable/sect.user-space.html" /></head><body
      dir="rtl"><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>قبلی</strong></a></li><li
          class="home">راهنمای دبیان برای مدیر سیستم‌ها</li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>بعدی</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.user-space"></a>B.5. فضای کاربری</h2></div></div></div><a
          id="id-1.21.8.2"
          class="indexterm"></a><a
          id="id-1.21.8.3"
          class="indexterm"></a><div
          class="para">
			به محیط اجرایی فرآیندهای عادی (بر خلاف کرنل) “فضای کاربر” گفته می‌شود. الزماً به این معنی نیست که این فرآیندها در حقیقت توسط کاربر اجرا می‌شوند چرا که یک سیستم استاندارد شامل چند “daemon” (پس‌زمینه) است که قبل از ورود کاربر به سیستم، فرآیندها را اجرا می‌کنند. این فرآیندها همچنین به عنوان فرآیندهای فضای-کاربر شناخته می‌شوند.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.process-basics"></a>B.5.1. فرآیند</h3></div></div></div><a
            id="id-1.21.8.5.2"
            class="indexterm"></a><div
            class="para">
				زمانی که کرنل فاز اولیه خود را می‌گذراند، اولین فرآیند موجود را آغاز می‌کند، <code
              class="command">init</code>. فرآیند شماره ۱ به خودی خود کاربردی ندارد، به همین دلیل است که سیستم‌های شبه-یونیکس فرآیندهای بسیار دیگری را اجرا می‌کنند.
			</div><a
            id="id-1.21.8.5.4"
            class="indexterm"></a><div
            class="para">
				اول از همه، یک فرآیند می‌تواند خودش را شبیه‌سازی کند (که البته با نام <span
              class="emphasis"><em>fork</em></span> شناخته می‌شود). کرنل در این حالت یک فضای حافظه جدید (اما برابر) همچنین فرآیند دیگری که از آن استفاده کند، اختصاص می‌دهد. در این زمان، تنها تفاوت موجود بین این دو فرآیند <span
              class="emphasis"><em>pid</em></span> آن‌ها است. فرآیند جدید معمولاً بنام فرزند و فرآیند اصلی که <span
              class="emphasis"><em>pid</em></span> آن تغییر نکرده است بنام پدر نامگذاری می‌شوند.
			</div><div
            class="para">
				گاهی اوقات، فرآیند فرزند به حیات خود مستقل از فرآیند پدر ادامه می‌دهد، با داده‌های خودش که از فرآیند پدر کپی شده است. در بسیاری موارد، البته، این فرآیند فرزند برنامه دیگری را اجرا می‌کند. بجز موارد خاص، حافظه آن به سادگی با آن برنامه جدید جایگزین می‌شود و اجرای این برنامه جدید آغاز می‌گردد. این مکانیزمی است که فرآیند init (با شماره فرآیند ۱) از آن استفاده می‌کند تا سرویس‌های اضافی را راه‌اندازی کرده و به اجرای تمام مراحل بارگذاری سیستم بپردازد. در برخی نقاط، یک فرآیند از میان فرزندان <code
              class="command">init</code> مبادرت به اجرای یک رابط گرافیکی می‌کند تا کاربران بتوانند وارد آن شوند (ترتیب دقیق این رویدادها به طور مشروح در <a
              class="xref"
              href="unix-services.html#sect.system-boot">
      قسمت 9.1, “راه‌اندازی سیستم”
    </a> آمده است).
			</div><div
            class="para">
				زمانی که یک فرآیند به اتمام کار خود می‌رسد، نابود می‌گردد. کرنل در این زمان حافظه‌ای که به آن تخصیص داده بود را بازیابی می‌کند و دیگر بازه‌های زمانی در اختیارش قرار نمی‌دهد. همچنین به فرآیند پدر نیز اطلاع داده می‌شود که فرزندش نابود شده است، که این امکان را به یک فرآیندی که تحت فرآیند فرزند اجرا شده است می‌دهد تا عملیات مربوط به خود را قبل از نابودشدن آن انجام دهد. این رفتار به وضوح در مفسرهای خط فرمان (که با نام <span
              class="emphasis"><em>shell</em></span> شناخته می‌شوند) قابل رویت است. زمانی که یک دستور درون خط فرمان نوشته می‌شود، کنترل خط فرمان تنها زمانی به کاربر بر می‌گردد که آن دستور تمام شده باشد. اکثر خط‌فرمان‌ها اجازه اجرای دستور در پس‌زمینه را می‌دهند، که این عمل به سادگی با اضافه کردن یک <strong
              class="userinput"><code>&amp;</code></strong> به انتهای دستور ممکن است. در این حالت، خط فرمان بلافاصله در اختیار کاربر قرار می‌گیرد، البته ممکن است در شرایطی که دستور نیاز به نمایش برخی داده‌ها داشته باشد مشکل آفرین گردد.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.daemons"></a>B.5.2. فرآیندهای پس‌زمینه</h3></div></div></div><a
            id="id-1.21.8.6.2"
            class="indexterm"></a><a
            id="id-1.21.8.6.3"
            class="indexterm"></a><div
            class="para">
				یک “daemon” فرآیندی است که به صورت خودکار در زمان راه‌اندازی سیستم اجرا می‌شود. این فرآیند به اجرای خود (در پس‌زمینه) ادامه می‌دهد تا برخی وظایف نگهداری را انجام داده یا برخی سرویس‌ها را در اختیار سایر فرآیندها بگذارد. این “وظیفه پس‌زمینه” در حقیقت نامی دلخواه است که از دید کلی سیستم معنای خاصی نمی‌دهد. آن‌ها به سادگی، همان فرآیندها هستند، درست مانند سایر فرآیندها که هر زمان نوبتشان فرا برسد اجرا می‌شوند. تفاوت تنها در نامگذاری است که ما برایشان انتخاب کردیم: فرآیندی که بدون تعامل کاربر اجرا می‌شود (به طور خاص، بدون هیچ رابط گرافیکی) به عنوان فرآیند “پس‌زمینه” یا “daemon” شناخته می‌شود.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>واژگان</em></span> Daemon, demon, یک عبارت موهن؟</strong></p></div></div></div><div
              class="para">
				با اینکه عبارت <span
                class="emphasis"><em>daemon</em></span> ریشه‌در لغت یونانی <span
                class="emphasis"><em>demon</em></span> دارد، اولی هیچ ارتباطی با شیطان و مظاهر آن ندارد! در عوض، بیشتر باید به عنوان یک روح یاری‌رسان دیده شود. این تفاوت در زبان انگلیسی نامحسوس است؛ حتی در سایر زبان‌ها که این لغت به هر دو معنایش اشاره می‌کند، شرایط بدتر بنظر می‌آید.
			</div></div><div
            class="para">
				تعدادی از این فرآیندهای پس‌زمینه با جزئیات در قسمت <a
              class="xref"
              href="unix-services.html">
      فصل 9, <em>سرویس‌های یونیکس</em></a> توضیح داده شده‌اند.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ipc"></a>B.5.3. ارتباطات بین‌-فرآیندی</h3></div></div></div><a
            id="id-1.21.8.7.2"
            class="indexterm"></a><a
            id="id-1.21.8.7.3"
            class="indexterm"></a><div
            class="para">
				یک فرآیند جدا شده (ایزوله)، خواه پس‌زمینه باشد یا یک برنامه کاربردی، به خودی خود کاربردی ندارد، به همین دلیل است که روش‌های گوناگونی برای ارتباط و تعامل بین این فرآیندها وجود دارد، خواه برای تبادل داده یا کنترل یکدیگر. عبارت عمومی که به این منظور استفاده می‌شود <span
              class="emphasis"><em>ارتباط بین‌-فرآیندی</em></span> یا به طور خلاصه IPC نام دارد.
			</div><div
            class="para">
				ساده‌ترین سیستم IPC از فایل‌ها استفاده می‌کند. فرآیندی که طی آن فرستنده، داده را جهت ذخیره‌سازی روی یک فایل (با نامی که در ادامه‌اش می‌آید) ارسال می‌کند و گیرنده تنها باید فایل را باز کرده و محتویات آن را بخواند.
			</div><a
            id="id-1.21.8.7.6"
            class="indexterm"></a><div
            class="para">
				در صورتی که نخواهید داده را روی دیسک ذخیره کنید، می‌توانید از یک <span
              class="emphasis"><em>لوله</em></span> استفاده کنید، که در ساده‌ترین حالت یک مدخل دوطرفه است؛ بایت‌هایی که در یک طرف نوشته می‌شوند در طرف دیگر قابل خواندن هستند. اگر طرفین این لوله توسط فرآیندهای جداگانه‌ای کنترل می‌شوند، این عملیات به یک کانال ارتباط بین‌-فرآیندی ساده تبدیل می‌شود. لوله‌ها می‌توانند به دو طبقه‌بندی تقسیم شوند: لوله‌های نامدار و لوله‌های بی‌نام و نشان. یک لوله نامدار توسط یک مدخل در فایل‌سیستم نمایش داده می‌شود (با اینکه داده تبادل یافته آنجا ذخیره نمی‌شود)، بنابراین هر دو فرآیند می‌توانند آن را جداگانه باز کنند در صورتی که مکان لوله نامدار قبل از آن ذکر شده باشد. در مواردی که فرآیندهای در حال تعامل به یکدیگر مربوط هستند (برای نمونه، یک فرآیند پدر و فرزند)، فرآیند پدر می‌تواند قبل از عملیات شبیه‌سازی یک لوله بی‌نام و نشان ایجاد کند تا فرزندش آن را به ارث ببرد. هر دو فرآیند در این حالت قادر به تبادل داده هستند بدون آنکه به فایل‌سیستم نیازی داشته باشند.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>در عمل</em></span> یک نمونه کاربردی</strong></p></div></div></div><div
              class="para">
				بیاید جزئیاتی را تشریح کنیم که هنگام اجرای یک دستور پیچیده (یک <span
                class="emphasis"><em>pipeline</em></span>) از خط فرمان اتفاق می‌افتند. فرض می‌کنیم فرآیند <code
                class="command">bash</code> داریم (خط فرمان استاندارد دبیان) با <span
                class="emphasis"><em>pid</em></span> برابر ۴۳۷۴؛ درون این خط فرمان دستور <code
                class="command">ls | sort</code> را وارد می‌کنیم.
			</div><div
              class="para">
				خط فرمان در ابتدا به تفسیر دستور وارد شده می‌پردازد. در این مورد، درک می‌کند که دو برنامه وجود دارند (<code
                class="command">ls</code> و <code
                class="command">sort</code>) با جریان داده‌ای که از یکی به دیگری سرازیر می‌شود (که با کاراکتر <strong
                class="userinput"><code>|</code></strong> به عنوان <span
                class="emphasis"><em>لوله</em></span> نشان داده می‌شود). در ابتدا <code
                class="command">bash</code> یک لوله بی‌نام و نشان ایجاد می‌کند (که به صورت اولیه در فرآیند خود <code
                class="command">bash</code> وجود دارد).
			</div><div
              class="para">
				آنگاه خط فرمان به شبیه‌سازی خود می‌پردازد؛ که به ایجاد یک فرآیند جدید <code
                class="command">bash</code> منجر می‌شود با شماره <span
                class="emphasis"><em>pid</em></span> ۴۵۲۱ (<span
                class="emphasis"><em>pid</em></span> اعداد انتزاعی هستند و در مجموع معنی خاصی نمی‌دهند). فرآیند ۴۵۲۱ از لوله ارث‌بری می‌کند، به این معنا که می‌تواند در قسمت ... آن بنویسد؛ <code
                class="command">bash</code> جریان خروجی استاندارد خود را به ورودی این لوله سرازیر می‌کند. آنگاه برنامه <code
                class="command">ls</code> اجرا (و جایگزین) می‌شود ،که وظیفه آن نمایش محتویات موجود در دایرکتوری فعلی است. از آنجایی که <code
                class="command">ls</code> روی خروجی استاندارد خود می‌نویسد، و این خروجی قبل از این تغییر کرده است، نتایج با موفقیت به لوله فرستاده می‌شوند.
			</div><div
              class="para">
				عملیات مشابهی برای دستور دوم اجرا می‌شوند: <code
                class="command">bash</code> به شبیه‌سازی (کپی) خود می‌پردازد، که منجر به فرآیند <code
                class="command">bash</code> جدیدی با شماره ۴۵۲۲ می‌شود. از آنجایی که یک فرآیند فرزند برای ۴۳۷۴ به حساب می‌آید، لوله را به ارث می‌برد؛ آنگاه <code
                class="command">bash</code> ورودی استاندارد خود را به خروجی لوله متصل می‌کند، آنگاه دستور <code
                class="command">sort</code> را اجرا (و با خود جایگزین) می‌کند، که این دستور ورودی را به صورت مرتب‌شده نمایش می‌دهد.
			</div><div
              class="para">
				اکنون تمام قطعه‌های پازل در جای خود قرار گرفته‌اند: <code
                class="command">ls</code> محتویات دایرکتوری فعلی را می‌خواند و فهرستی از فایل‌ها را روی لوله قرار می‌دهد؛ <code
                class="command">sort</code> این فهرست را خوانده، به صورت الفبایی مرتب کرده و نتایج را نمایش می‌دهد. شماره فرآیندهای ۴۵۲۱ و ۴۵۲۲ نابود می‌شوند و ۴۳۷۴ (که در طی این مدت منتظر آن‌ها بود) کنترل را ادامه داده و خط فرمان را در اختیار کاربر قرار می‌دهد تا دستور جدیدی وارد کند.
			</div></div><div
            class="para">
				البته، تمام ارتباطات بین‌-فرآیندی جهت تبادل داده بکار نمی‌روند. در شرایط دیگر، تنها اطلاعاتی که نیاز به رد و بدل شدند دارند پیام‌های کنترلی مانند “توقف اجرا” یا “ادامه اجرا” می‌باشند. یونیکس (و لینوکس) مکانیزمی با نام <span
              class="emphasis"><em>سیگنال</em></span> فراهم می‌آورد، که از طریق آن یک فرآیند می‌تواند یک سیگنال مشخص (که از فهرست از پیش آماده شده سیگنال‌ها انتخاب شده است) را به فرآیند دیگر ارسال کند. تنها پیشنیاز این ارتباط، دانستن <span
              class="emphasis"><em>pid</em></span> فرآیند هدف است.
			</div><div
            class="para">
				برای ارتباطات پیچیده‌تر، مکانیزم‌هایی وجود دارند که یه یک فرآیند اجازه دسترسی یا اشتراک‌گذاری برخی از حافظه تخصیص یافته خود را به سایر فرآیندها می‌دهد. اکنون از حافظه اشتراکی بین این دو فرآیند می‌توان به عنوان کانالی جهت تبادل داده استفاده کرد.
			</div><div
            class="para">
				در نهایت، ارتباطات شبکه نیز می‌تواند به ارتباط فرآیندها کمک کند؛ این فرآیندها حتی در رایانه‌های مختلف اجرا می‌شوند، که احتمالاً هزاران کیلومتر از یکدیگر فاصله دارند.
			</div><div
            class="para">
				تقریباً برای یک سیستم شبه‌-یونیکس بسیار متداول است که بسیاری از این مکانیزم‌ها را در درجات مختلف بکار گیرد.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.libraries"></a>B.5.4. کتابخانه‌ها</h3></div></div></div><a
            id="id-1.21.8.8.2"
            class="indexterm"></a><div
            class="para">
				کتابخانه‌های تابعی نقشی حیاتی در سیستم‌های شبه‌-یونیکس ایفا می‌کنند. آن‌ها برنامه‌های آماده نیستند، چرا که به خودی خود قابلیت اجرا شدن ندارند، اما مجموعه‌هایی جدا جدا از کد هستند که قابلیت استفاده توسط برنامه‌های استاندارد را دارند. در میان این کتابخانه‌های عمومی، می‌توانید مواردی زیر را پیدا کنید:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						کتابخانه استاندارد C (<span
                    class="emphasis"><em>glibc</em></span>)، که شامل توابع پایه مانند بازکردن فایل یا ارتباط شبکه و سایر ابزارهای تعاملی با کرنل است؛
					</div></li><li
                class="listitem"><div
                  class="para">
						ابزارهای گرافیکی، مانند +GTK و Qt به بسیاری از برنامه‌ها این امکان را می‌دهند تا از قسمت‌های مختلف یک محیط گرافیکی استفاده کنند؛
					</div></li><li
                class="listitem"><div
                  class="para">
						کتابخانه <span
                    class="emphasis"><em>libpng</em></span>، که امکان بارگذاری، تفسیر و ذخیره تصاویر در قالب PNG را فراهم می‌کند.
					</div></li></ul></div><div
            class="para">
				به لطف این کتابخانه‌ها، برنامه‌های کاربردی می‌توانند از کد موجود استفاده کنند. توسعه برنامه‌ها آسان‌تر شده است چرا از بسیاری توابع موجود استفاده می‌کنند. با کتابخانه‌هایی که توسط افراد گوناگون توسعه یافته است، توسعه سراسری سیستم به فلسفه تاریخی یونیکس نزدیک‌تر شده است.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>فرهنگ</em></span> راه و روش یونیکس: یک کار در هر زمان</strong></p></div></div></div><div
              class="para">
				یکی از بنیادی‌ترین مفاهیمی که در سیستم عامل‌های خانواده یونیکس ریشه دارد این است که هر ابزاری باید تنها یک کار انجام دهد، و آن را درست هم انجام دهد؛ برنامه‌ها می‌توانند از این ابزار استفاده کنند تا منطق پیچیده‌تری را بوجود آورند. این فلسفه می‌تواند حالت‌های گوناگونی به خود بگیرد. اسکریپت‌های خط فرمان شاید بهترین نمونه باشند: آن‌ها با استفاده از ابزار ساده، ترکیبات بسیار پیچیده‌ای بوجود می‌آورند (مانند <code
                class="command">grep</code> و <code
                class="command">wc</code> و <code
                class="command">sort</code> و <code
                class="command">uniq</code>). نمونه پیاده‌سازی شده دیگر از این فلسفه در کتابخانه‌های کد دیده می‌شود: کتابخانه <span
                class="emphasis"><em>libpng</em></span> اجازه خواندن و نوشتن فایل‌های PNG را می‌دهد، با گزینه‌های مختلف و روش‌های گوناگون، اما تنها همین کار را انجام می‌دهد؛ توابعی که باعث نمایش تصاویر یا ویرایش آن‌ها شوند وجود ندارد.
			</div></div><div
            class="para">
				بر این به، أن‌ها اغلب کتابخانه‌های “اشتراکی گفته” می‌شود چرا، که کرنل تنها قادر است علاوه آن‌ها را یکبار در حافظه بارگذاری نماید با اینکه فرآیندهای بسیاری می‌توانند به طور همزمان از آن‌ها استفاده کنند. اینکار امکان صرفه‌جویی در حافظه را فراهم می‌آورد در مقایسه با شرایط عکس آن (به صورت فرضی) که کد موجود در کتابخانه به تعداد دفعاتی که فرآیندها از آن استفاده می‌کنند در حافظه قرار داده شود.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>قبلی</strong>B.4. برخی از وظایفی که کرنل به آن‌ها رسیدگی می‌کند</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>بالا</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>خانه</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>بعدی</strong>
      پيوست C. راهنمای دبیان برای مدیر سیستم‌ها</a></li></ul></body></html>
