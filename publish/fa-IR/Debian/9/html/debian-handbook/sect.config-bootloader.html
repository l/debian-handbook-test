<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">8.8. پیکربندی راه‌انداز اولیه</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-fa-IR-1.0-1" /><meta
        name="keywords"
        content="پیکربندی, بومی‌سازی, مناطق, شبکه, شفافیت نامگذاری, کاربران, گروه‌ها, حساب‌های کاربری, مفسر خط‌-فرمان, پوسته, چاپ, راه‌انداز اولیه, کامپایل کرنل" /><link
        rel="home"
        href="index.html"
        title="راهنمای جامع دبیان" /><link
        rel="up"
        href="basic-configuration.html"
        title="فصل 8. پیکربندی اولیه: شبکه، حساب‌های کاربری، چاپ و ..." /><link
        rel="prev"
        href="sect.config-printing.html"
        title="8.7. پیکربندی چاپگر" /><link
        rel="next"
        href="sect.config-misc.html"
        title="8.9. سایر پیکربندی‌ها: همگام‌سازی زمان، گزارش‌ها، دسترسی اشتراکی..." /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/fa-IR/stable/sect.config-bootloader.html" /></head><body
      dir="rtl"><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-printing.html"><strong>قبلی</strong></a></li><li
          class="home">راهنمای جامع دبیان</li><li
          class="next"><a
            accesskey="n"
            href="sect.config-misc.html"><strong>بعدی</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.config-bootloader"></a>8.8. پیکربندی راه‌انداز اولیه</h2></div></div></div><a
          id="id-1.11.12.2"
          class="indexterm"></a><a
          id="id-1.11.12.3"
          class="indexterm"></a><div
          class="para">
			این قابلیت هم‌اکنون فعال است، اما دانستن اینکه چطور می‌توان در زمان بروز مشکل در راه‌انداز اولیه یا پاک شدن آن از روی MBR آن را عیب‌زدایی و نصب مجدد کرد بسیار مفید است. این اتفاق زمانی می‌افتد که یک سیستم عامل دیگر مانند ویندوز را نصب کنید. اطلاعات پیش رو به شما کمک می‌کنند که راه‌انداز اولیه را به صورت صحیح پیکربندی کنید.
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>بازگشت به مقدمات</em></span> Master Boot Record</strong></p></div></div></div><a
            id="id-1.11.12.5.2"
            class="indexterm"></a><a
            id="id-1.11.12.5.3"
            class="indexterm"></a><div
            class="para">
			رکورد راه‌انداز اصلی یا MBR اولین ۵۱۲ بایت اولین هارددیسک موجود را اشغال می‌کند و اولین چیزی است که توسط BIOS برای شناسایی برنامه‌ای که قادر به راه‌اندازی سیستم عامل باشد فراخوانی می‌گردد. به صورت کلی، راه‌انداز اولیه‌ای که در MBR نصب می‌گردد تمام محتوای قبلی را حذف می‌کند.
		</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.identify-disks"></a>8.8.1. شناسایی دیسک‌ها</h3></div></div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>فرهنگ</em></span> <span
                        class="emphasis"><em>udev</em></span> و <code
                        class="filename">/dev/</code></strong></p></div></div></div><div
              class="para">
				دایرکتوری <code
                class="filename">/dev/</code> از قدیم محل نگهداری فایل‌های به اصطلاح “ویژه” بود، که نمایانگر دستگاه‌های جانبی متصل به سیستم بودند (قسمت <a
                class="xref"
                href="sect.creating-accounts.html#sidebar.special-files"><span
                  class="emphasis"><em>بازگشت به مقدمات</em></span> مجوزهای دسترسی به دستگاه</a> را مشاهده کنید). در زمان‌های گذشته این دایرکتوری شامل تمام فایل‌های ویژه قابل استفاده بود. این رویکرد نقص‌های فراوانی به همراه داشت از جمله اینکه تعداد دستگاه‌هایی که یک نفر می‌توانست از آن‌ها استفاده کند را محدود می‌ساخت (به دلیل دست‌نویس بودن تمام نام‌ها) و اینکه تقریبا غیرممکن بود بفهمید کدام فایل واقعا کاربردی است.
			</div><div
              class="para">
				امروزه، مدیریت فایل‌های ویژه به صورت کامل پویا شده است و با طبیعت دستگاه‌های قابل جداشدن از سیستم بهتر سازگار است. کرنل با <span
                class="emphasis"><em>udev</em></span> ارتباط برقرار می‌کند تا این فایل‌های را ایجاد یا حذف کرده تنها زمانی که دستگاه‌های مربوط به آن‌ها در سیستم شناسایی شوند. به این دلیل، <code
                class="filename">/dev/</code> نیازی ندارد که یک ساختار ثابت روی دیسک باشد و می‌تواند به عنوان یک فایل سیستم موجود در حافظه اصلی یا RAM برای درج دستگاه‌های مورد نیاز سیستم بکار رود.
			</div><div
              class="para">
				کرنل اطلاعات بسیاری را در رابطه با دستگاه‌های جدید رد و بدل می‌کند و از شماره‌های ماژور/مینور برای شناسایی این دستگاه‌ها بهره می‌برد. با این شیوه <code
                class="command">udevd</code> می‌تواند فایل ویژه مورد نیاز را با توجه به مجوزهای لازم هر دستگاه ایجاد کند. همچنین می‌تواند نام‌های مستعار ایجاد کرده و اقدامات بیشتری را انجام دهد (مانند پیکربندی اولیه یا ثبت فعالیت‌ها). عملکرد <code
                class="command">udevd</code> توسط مجموعه بزرگی از قوانین (سفارشی‌سازی) هدایت می‌شود.
			</div><div
              class="para">
				با نام‌هایی که به صورت خودکار اختصاص می‌یابند، می‌توانید یک نام یکسان برای دستگاه مشخصی تعیین کنید جدا از اینکه توسط چه اتصالی برقرار شده یا ترتیب آن به چه صورت بوده، که این عمل هنگام استفاده از درگاه‌های مختلف USB بسیار مفید است. اولین پارتیشن اولین هارددیسک می‌تواند نام <code
                class="filename">/dev/sda1</code> را داشته باشد یا <code
                class="filename">/dev/root-partition</code> اگر آن را ترجیح دهید یا استفاده از هر دو در یک زمان چرا که <code
                class="command">udevd</code> قادر است پیوندهای نمادین از این فایل‌ها بسازد.
			</div><div
              class="para">
				در زمان‌های قدیم، برخی ماژول‌های کرنل به صورت خودکار فراخوانی می‌شدند زمانی که شما دستگاه جدیدی را به سیستم معرفی می‌کردید. این مورد دیگر مصداق ندارد و فایل ویژه مربوط به دستگاه دیگر وجود ندارد که ماژولی برای آن فراخوانی گردد؛ این مشکل بزرگی نیست، چرا که اکثر ماژول‌ها هنگام راه‌اندازی اولیه سیستم توسط فاز شناسایی سخت‌افزار فراخوانی و آماده اجرا می‌گردند. اما برای دستگاه‌هایی که شناسایی نمی‌گردند (مانند هارددیسک‌های بسیار قدیمی یا ماوس PS/2)، این اتفاق نمی‌افتد. می‌توان با افزودن ماژول‌های <code
                class="literal">floppy</code>، <code
                class="literal">psmouse</code> و <code
                class="literal">mousedev</code> به فایل <code
                class="filename">/etc/modules</code> آن‌ها را هنگام راه‌اندازی اولیه سیستم فراخوانی کرد.
			</div></div><a
            id="id-1.11.12.6.3"
            class="indexterm"></a><a
            id="id-1.11.12.6.4"
            class="indexterm"></a><div
            class="para">
				پیکربندی راه‌انداز اولیه باید هارد درایوهای مختلف با پارتیشن‌های مربوطه را شناسایی کند. لینوکس از فایل‌های ویژه “بلاک” که در <code
              class="filename">/dev/</code> ذخیره می‌شوند به این منظور استفاده می‌کند. به این منظور، از دبیان <span
              class="distribution distribution">Squeeze</span>، شیوه نامگذاری هارد درایوها توسط کرنل لینوکس یکپارچه شده است و تمام هارد درایوها (IDE/SATA، SATA، SCSI، USB، IEEE 1394) اکنون توسط <code
              class="filename">/dev/sd*</code> شناخته می‌شوند.
			</div><div
            class="para">
				هر پارتیشن با عدد مخصوص به خود روی دیسک شناسایی می‌گردد: برای نمونه، <code
              class="filename">/dev/sda1</code> اولین پارتیشن روی اولین دیسک و <code
              class="filename">/dev/sdb3</code> سومین پارتیشن روی دومین دیسک است.
			</div><a
            id="id-1.11.12.6.7"
            class="indexterm"></a><a
            id="id-1.11.12.6.8"
            class="indexterm"></a><a
            id="id-1.11.12.6.9"
            class="indexterm"></a><a
            id="id-1.11.12.6.10"
            class="indexterm"></a><div
            class="para">
				معماری PC (یا “i386” به همراه “amd64”) تنها محدود به استفاده از قالب جدول پارتیشن “MS-DOS” بوده است، که تنها اجازه چهار پارتیشن “اولیه” روی هر دیسک را می‌دهد. برای غلبه بر این محدودیت یکی از پارتیشن‌ها باید به صورت “گسترش‌یافته” درآید و در آنجا می‌تواند شامل پارتیشن‌های “ثانویه” باشد. این پارتیشن‌های ثانویه از شماره ۵ آغاز می‌گردند. بنابراین اولیه پارتیشن ثانویه روی دیسک با <code
              class="filename">/dev/sda5</code> شناخته می‌شود و به همین شکل ادامه می‌یابد.
			</div><div
            class="para">
				دیگر محدودیت قالب جدول پارتیشن‌بندی MS-DOS این است که تنها قادر به شناسایی دیسک‌های تا ۲ ترابایت حافظه جانبی است که این مشکل امروزه با توجه به افزایش حجم دیسک‌ها جدی شده است.
			</div><a
            id="id-1.11.12.6.13"
            class="indexterm"></a><a
            id="id-1.11.12.6.14"
            class="indexterm"></a><div
            class="para">
				قالب جدید پارتیشن‌بندی GPT به محدودیت‌های فعلی غلبه می‌کند که شامل تعداد پارتیشن‌ها (تا ۱۲۸ پارتیشن اصلی هنگام استفاده از تنظیمات استاندارد) و اندازه و حجم دیسک‌های مورد استفاده (بالغ بر ۸ زتابایت، که بیش از ۸ میلیارد ترابایت است) می‌باشد. اگر قصد ایجاد تعداد زیادی پارتیشن فیزیکی روی یک دیسک را دارید، باید اطمینان یابید که از قالب پارتیشن‌بندی GPT هنگام پارتیشن‌بندی دیسک‌ها استفاده می‌کنید.
			</div><div
            class="para">
				به خاطر سپردن اینکه کدام دیسک به کدام کنترلر SATA متصل است، یا در کدام موقعیت زنجیره SCSI قرار دارد کار ساده‌ای نیست، به خصوص زمانی که نامگذاری هارد درایوهای جداشونده در هر مرتبه راه‌اندازی اولیه سیستم ممکن است تغییر کند. خوشبختانه، <code
              class="command">udev</code> علاوه بر <code
              class="filename">/dev/sd*</code>، پیوندهای نمادین با نام‌های ثابت ایجاد می‌کند که می‌توانید از آن‌ها برای شناسایی یک هارد درایو به صورت مشخص استفاده کنید. این پیوندهای نمادین در فایل <code
              class="filename">/dev/disk/by-id</code> ذخیره می‌شوند. برای نمونه، در رایانه‌ای با دو دیسک فیزیکی می‌توان به اطلاعات زیر دست یافت:
			</div><pre
            class="screen"><code
              class="computeroutput">mirexpress:/dev/disk/by-id# </code><strong
              class="userinput"><code>ls -l
</code></strong><code
              class="computeroutput">total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </code></pre><div
            class="para">
				برخی از دیسک‌ها چندین بار در این فهرست آورده شده‌اند (چرا که همزمان به صورت دیسک‌های ATA و SCSI رفتار می‌کنند) اما اطلاعات مربوطه در قسمت مدل و شماره سریال هر یک از دیسک‌ها است که از طریق ‌آن‌ها می‌توانید فایل‌های مربوطه را پیدا کنید.
			</div><div
            class="para">
				فایل‌های پیکربندی نمونه که در قسمت‌های بعدی به آن‌ها اشاره می‌شود بر اساس یک تنظیم یکسان هستند: یک دیسک SATA واحد، که اولین پارتیشن آن یک نصب قدیمی از ویندوز است و پارتیشن دوم شامل دبیان گنو/لینوکس است.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.config-lilo"></a>8.8.2. پیکربندی LILO</h3></div></div></div><a
            id="id-1.11.12.7.2"
            class="indexterm"></a><a
            id="id-1.11.12.7.3"
            class="indexterm"></a><div
            class="para">
				<span
              class="emphasis"><em>LILO</em></span> که مخفف LInux LOader است قدیمی‌ترین راه‌انداز اولیه در لینوکس است - قدیمی اما اصیل. نشانی فیزیکی کرنل برای راه‌اندازی را روی MBR می‌نویسد، به همین دلیل هر بروزرسانی LILO یا فایل‌های پیکربندی آن باید به همراه اجرای دستور <code
              class="command">lilo</code> باشد. فراموش کردن این امر باعث می‌شود سیستم در حالتی قرار بگیرد که نشانی کرنل قبلی پاک شده باشد و کرنل جدید نیز اکنون در MBR موجود نباشد.
			</div><div
            class="para">
				فایل پیکربندی LILO با نام <code
              class="filename">/etc/lilo.conf</code> شناخته می‌شود؛ یک فایل نمونه برای پیکربندی استاندارد در ادامه آورده می‌شود.
			</div><div
            class="example"><a
              xmlns=""
              id="example.lilo.conf"></a><p
              class="title"><strong>
      مثال 8.4. فایل پیکربندی LILO</strong></p><div
              class="example-contents"><pre
                class="programlisting">
# The disk on which LILO should be installed.
# By indicating the disk and not a partition.
# you order LILO to be installed on the MBR.
boot=/dev/sda
# the partition that contains Debian
root=/dev/sda2
# the item to be loaded by default
default=Linux

# the most recent kernel image
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Old kernel (if the newly installed kernel doesn't boot)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# only for Linux/Windows dual boot
other=/dev/sda1
  label=Windows</pre></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.config-grub"></a>8.8.3. پیکربندی GRUB2</h3></div></div></div><a
            id="id-1.11.12.8.2"
            class="indexterm"></a><a
            id="id-1.11.12.8.3"
            class="indexterm"></a><div
            class="para">
				<span
              class="emphasis"><em>GRUB</em></span> که مخفف GRand Unified Bootloader نسخه جدید راه‌اندازهای اولیه است. پس از بروزرسانی هر نسخه کرنل الزامی به فراخوانی مجدد آن نیست؛ <span
              class="emphasis"><em>GRUB</em></span> خود می‌داند که چطور فایل‌سیستم را بخواند و موقعیت کرنل را روی دیسک تشخیص دهد. برای نصب آن روی MBR اولین دیسک، تنها کافی است دستور <code
              class="command">grub-install /dev/sda</code> را وارد کنید. <a
              id="id-1.11.12.8.4.4"
              class="indexterm"></a>
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>یادداشت</em></span> نام دیسک‌ها برای GRUB</strong></p></div></div></div><div
              class="para">
				GRUB تنها قادر به شناسایی هارد درایوهایی است که اطلاعات آن‌ها توسط BIOS فراهم شده باشد. <code
                class="literal">(hd0)</code> مطابق با اولین دیسک شناسایی شده است، <code
                class="literal">(hd1)</code> دومین دیسک و به همین ترتیب. در بیشتر موارد، این ترتیب دقیقا همان ترتیب دیسک‌ها در لینوکس است و هنگام استفاده از دیسک‌های SCSI و IDE برخی مشکلات ممکن است بروز کنند. GRUB دیسک‌های شناسایی شده را در فایل <code
                class="filename">/boot/grub/device.map</code> ذخیره می‌کند. اگر در آنجا خطایی مشاهده کردید (چرا که می‌دانید BIOS به شیوه‌ای متفاوت دیسک‌ها را شناسایی می‌کند)، به صورت دستی خطا را اصلاح کرده و دستور <code
                class="command">grub-install</code> را مجدد اجرا کنید. دستور <code
                class="command">grub-mkdevicemap</code> به شما کمک می‌کند تا یک فایل <code
                class="filename">device.map</code> برای ذخیره‌سازی این دیسک‌ها بسازید.
			</div><div
              class="para">
				پارتیشن‌ها همچنین یک نام مخصوص به خود در GRUB دارند. زمانی که از پارتیشن‌های “کلاسیک” در قالب MS-DOS استفاده می‌کنید، اولین پارتیشن اولین دیسک به صورت <code
                class="literal">(hd0,msdos1)</code> برچسب‌گذاری می‌شود، دومین پارتیشن به صورت <code
                class="literal">(hd0,msdos2)</code> و الی آخر.
			</div></div><div
            class="para">
				GRUB 2 configuration is stored in <code
              class="filename">/boot/grub/grub.cfg</code>, but this file (in Debian) is generated from others. Be careful not to modify it by hand, since such local modifications will be lost the next time <code
              class="command">update-grub</code> is run (which may occur upon update of various packages). The most common modifications of the <code
              class="filename">/boot/grub/grub.cfg</code> file (to add command line parameters to the kernel or change the duration that the menu is displayed, for example) are made through the variables in <code
              class="filename">/etc/default/grub</code>. To add entries to the menu, you can either create a <code
              class="filename">/boot/grub/custom.cfg</code> file or modify the <code
              class="filename">/etc/grub.d/40_custom</code> file. For more complex configurations, you can modify other files in <code
              class="filename">/etc/grub.d</code>, or add to them; these scripts should return configuration snippets, possibly by making use of external programs. These scripts are the ones that will update the list of kernels to boot: <code
              class="filename">10_linux</code> takes into consideration the installed Linux kernels; <code
              class="filename">20_linux_xen</code> takes into account Xen virtual systems, and <code
              class="filename">30_os-prober</code> lists other operating systems (Windows, OS X, Hurd).
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.config-yaboot"></a>8.8.4. برای رایانه‌های مکینتاش (PowerPC): پیکربندی Yaboot</h3></div></div></div><a
            id="id-1.11.12.9.2"
            class="indexterm"></a><div
            class="para">
				Yaboot راه‌انداز اولیه مورد استفاده در نسخه‌های قدیمی‌تر مکینتاش با استفاده از پردازنده‌های PowerPC است. آن‌ها مانند PC راه‌اندازی نمی‌گردند، بلکه به یک پارتیشن “راه‌انداز” وابسته هستند که از طریق آن BIOS یا OpenFirmware سیستم راه‌انداز را فراخوانی می‌کند و درون آن برنامه <code
              class="command">ybin</code> اقدام به نصب <code
              class="command">yaboot</code> و پیکربندی‌های مورد نیاز آن می‌نماید. تنها زمانی نیاز دارید این دستور را اجرا کنید که فایل <code
              class="filename">/etc/yaboot.conf</code> ویرایش شده باشد (که در پارتیشن راه‌انداز نیز قرار دارد و <code
              class="command">yaboot</code> می‌داند چطور موقعیت کرنل‌ها روی دیسک را تشخیص دهد).
			</div><div
            class="para">
				قبل از اجرای <code
              class="command">ybin</code>، ابتدا باید یک فایل معتبر <code
              class="filename">/etc/yaboot.conf</code> داشته باشید. مثالی که در ادامه می‌آید حداقل پیکربندی مورد نیاز برای اینکار است. <a
              id="id-1.11.12.9.4.3"
              class="indexterm"></a>
			</div><div
            class="example"><a
              xmlns=""
              id="example.yaboot.conf"></a><p
              class="title"><strong>
      مثال 8.5. فایل پیکربندی Yaboot</strong></p><div
              class="example-contents"><pre
                class="programlisting">
# bootstrap partition
boot=/dev/sda2
# the disk
device=hd:
# the Linux partition
partition=3
root=/dev/sda3
# boot after 3 seconds of inactivity
# (timeout is in tenths of seconds)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# last kernel installed
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# old kernel
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# only for Linux/Mac OSX dual-boot
macosx=/dev/sda5

# bsd=/dev/sdaX and macos=/dev/sdaX
# are also possible</pre></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-printing.html"><strong>قبلی</strong>8.7. پیکربندی چاپگر</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>بالا</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>خانه</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.config-misc.html"><strong>بعدی</strong>8.9. سایر پیکربندی‌ها: همگام‌سازی زمان، گزارش‌ها،...</a></li></ul></body></html>
