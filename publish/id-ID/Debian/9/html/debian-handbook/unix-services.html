<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Bab 9. Layanan Unix</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-id-ID-1.0-1" /><meta
        name="keywords"
        content="Boot sistem, Initscript, SSH, Telnet, Hak, Izin, Pengawasan, Inetd, Cron, Cadangan, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Buku Panduan Administrator Debian" /><link
        rel="up"
        href="index.html"
        title="Buku Panduan Administrator Debian" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Menginstall sebuah Kernel" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Log Masuk Jarak Jauh" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/id-ID/stable/unix-services.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Sebelumnya</strong></a></li><li
          class="home">Buku Panduan Administrator Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Lanjut</strong></a></li></ul><div
        xml:lang="id-ID"
        class="chapter"
        lang="id-ID"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  xmlns=""
                  id="unix-services"></a>Bab 9. Layanan Unix</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. Boot Sistem</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. Sistem init systemd</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. Sistem init System V</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Log Masuk Jarak Jauh</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Login Jarak Jauh Aman: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Memakai Desktop Grafis Jarak Jauh</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Mengelola Hak</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Antarmuka Administrasi</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Pengadministrasian pada Antarmuka Web: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Mengkonfigurasi Paket: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> Kejadian Sistem</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Prinsip dan Mekanisme</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. Berkas Konfigurasi</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. Super Server <code
                    class="command">inetd</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Scheduling Tasks with <code
                    class="command">cron</code> and <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Format dari sebuah Berkas <code
                        class="filename">crontab</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Menggunakan Perintah <code
                        class="command">at</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Menjadwalkan Tugas-tugas Asinkron: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Kuota</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Cadangan</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. Back Up dengan <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. Memulihkan Mesin tanpa Cadangan</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Hot Plugging: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. Pengenalan</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. Masalah Penamaan</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. Bagaimana <span
                        class="emphasis"><em>udev</em></span> Bekerja</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. Contoh konkret</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Manajemen Daya: Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Bab ini membahas tentang layanan dasar yang biasa digunakan pada banyak sistem Unix. Semua administator seharusnya sudah terbiasa dengan mereka.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    xmlns=""
                    id="sect.system-boot"></a>9.1. Boot Sistem</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			Ketika Anda mem-boot komputer, banyak pesan bergulir pada layar konsol yang menampilkan banyak inisialisasi dan konfigurasi otomatis yang sedang dieksekusi. Kadang-kadang Anda mungkin ingin mengubah sedikit bagaimana tahap ini bekerja, yang berarti bahwa Anda perlu untuk memahaminya dengan baik. Itulah tujuan dari bagian ini.
		</div><div
            class="para">
			Pertama, BIOS mengambil kendali komputer, mendeteksi disk, memuat <span
              class="emphasis"><em>Master Boot Record</em></span>, dan mengeksekusi bootloader. Bootloader mengambil alih, menemukan kernel pada disk, memuat dan mengeksekusinya. Kernel kemudian diinisialisasi, dan mulai mencari dan me-mount partisi yang memuat sistem berkas root, dan akhirnya mengeksekusi program pertama — <code
              class="command">init</code>. Seringkali, "partisi root partisi" ini dan =<code
              class="command">init</code> ini, pada kenyataannya, terletak di sistem berkas virtual yang hanya ada dalam RAM (maka namanya, "initramfs", sebelumnya disebut "initrd" untuk "initialization RAM disk"). Sistem berkas ini dimuat ke dalam memori oleh bootloader, sering dari suatu berkas pada hard drive atau dari jaringan. Ini berisi minimal yang diperlukan oleh kernel untuk memuat sistem berkas root yang "benar": ini mungkin modul penggerak untuk hard drive, atau perangkat lain yang tanpanya sistem tidak bisa boot, atau, lebih sering, skrip inisialisasi dan modul untuk merakit larik RAID, membuka partisi yang dienkripsi, mengaktifkan volume LVM, dll. Setelah partisi root di-mount, initramfs menyerahkan kontrol untuk init nyata, dan mesin kembali ke proses boot standar.
		</div><div
            class="figure"><a
              xmlns=""
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Urutan boot dari komputer yang menjalankan Linux dengan systemd" /></div></div><p
              class="title"><strong>Gambar 9.1. Urutan boot dari komputer yang menjalankan Linux dengan systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.systemd"></a>9.1.1. Sistem init systemd</h3></div></div></div><div
              class="para">
				”init sejati” saat ini disediakan oleh <span
                class="pkg pkg">systemd</span> dan seksi ini mendokumentasikan sistem init ini.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KULTUR</em></span> Sebelum <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> adalah ”sistem init” yang relatif baru, dan walaupun sudah tersedia, sampai batas tertentu, dalam <span
                  class="distribution distribution">Wheezy</span>, itu hanya menjadi baku dalam Debian <span
                  class="distribution distribution">Jessie</span>. Rilis-rilis sebelumnya mengandalkan, secara baku, ”init System V” (dalam paket <span
                  class="pkg pkg">sysv-rc</span>), suatu sistem yang jauh lebih tradisional. Kami menjelaskan init System V belakangan.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIF</em></span> Sistem boot lain</strong></p></div></div></div><div
                class="para">
				Buku ini menjelaskan sistem boot yang dipakai secara baku dalam Debian <span
                  class="distribution distribution">Jessie</span> (yang diimplementasikan oleh paket <span
                  class="pkg pkg">systemd</span>), maupun baku sebelumnya, <span
                  class="pkg pkg">sysvinit</span>, yang diturunkan dan diwariskan dari sistem Unix <span
                  class="emphasis"><em>System V</em></span>; ada juga yang lain.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> adalah sistem boot dengan proses yang sangat sederhana. Mempertahankan prinsip runlevel, tapi menggantikan direktori dan taut simbolik dengan sebuah berkas konfigurasi, yang mengindikasikan ke <code
                  class="command">init</code> proses-proses yang mesti dimulai dan urutan peluncuran mereka.
			</div><div
                class="para">
				Sistem <code
                  class="command">upstart</code> belum diuji secara sempurna pada Debian. Itu berbasis peristiwa: skrip-skrip init tidak lagi dijalankan berurutan tapi sebagai respon atas kejadian seperti misalnya selesai dijalankannya skrip lain yang menjadi ketergantungannya. Sistem ini, dimulai oleh Ubuntu, ada dalam Debian <span
                  class="distribution distribution">Jessie</span>, tapi tidak baku; itu hadir, faktanya, sebagai pengganti <span
                  class="pkg pkg">sysvinit</span>, dan satu dari tugas yang diluncurkan oleh <code
                  class="command">upstrart</code> adalah untuk meluncurkan skrip-skrip yang ditulis untuk sistem-sistem tradisional, khususnya yang dari paket <span
                  class="pkg pkg">sysv-rc</span>.
			</div><div
                class="para">
				Ada juga sistem-sistem lain dan mode-mode operasi lain, seperti misalnya <code
                  class="command">runit</code> atau <code
                  class="command">minit</code>, tapi mereka relatif khusus dan tidak meluas.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KASUS SPESIFIK</em></span> Boot dari jaringan</strong></p></div></div></div><div
                class="para">
				Dalam beberapa konfigurasi, BIOS mungkin dikonfigurasi untuk tidak menjalankan MBR, tapi untuk mencari yang setara di jaringan, sehingga memungkinkan untuk membangun komputer tanpa hard drive, atau yang sepenuhnya diinstal ulang pada setiap boot. Opsi ini tidak tersedia pada semua perangkat keras dan umumnya memerlukan kombinasi kartu BIOS dan jaringan yang sesuai.
			</div><div
                class="para">
				Boot dari jaringan dapat digunakan untuk meluncurkan <code
                  class="command">debian-installer</code> atau FAI (lihat <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Bagian 4.1, “Metode Instalasi”</a>.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KEMBALI KE DASAR</em></span> Proses, suatu instansi program</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				Sebuah proses adalah representasi dalam memori dari suau program yang sedang berjalan. Ini mencakup semua informasi yang diperlukan untuk menjalankan perangkat lunak dengan benar (kode itu sendiri, juga data yang dimilikinya dalam memori, daftar berkas yang telah dibukanya, koneksi jaringan yang telah dijalin, dll.). Satu program dapat diinstansikan ke beberapa proses, tidak perlu berjalan di bawah ID pengguna yang berbeda.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KEAMANAN</em></span> Memakai sebuah shell sebagai <code
                          class="command">init</code> untuk mendapatkan hak root</strong></p></div></div></div><div
                class="para">
				Menurut konvensi, proses pertama yang di-boot adalah program <code
                  class="command">init</code> (yang secara baku merupakan taut simbolik ke <code
                  class="filename">/lib/systemd/systemd</code>). Namun, mungkin untuk melewatkan suatu opsi <code
                  class="literal">init</code> ke kernel yang mengindikasikan suatu program lain.
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				Sebarang orang yang dapat mengakses komputer bisa menekan tombol <span
                  class="keycap"><strong>Reset</strong></span>, dan sehingga me-reboot. Kemudian, pada prompt bootloader, mungkin untuk melewatkan opsi <code
                  class="literal">init=/bin/sh</code> ke kernel untuk mendapatkan akses root tanpa mengetahui sandi administrator.
			</div><div
                class="para">
				Untuk mencegah hal ini, Anda dapat melindungi bootloader sendiri dengan kata sandi. Anda juga mungkin berpikir tentang melindungi akses ke BIOS (mekanisme perlindungan sandi hampir selalu tersedia), yang tanpanya penyusup jahat masih bisa mem-boot mesin pada media lepas-pasang yang berisi sistem Linux sendiri, yang kemudian dapat digunakan untuk mengakses data pada hard drive komputer.
			</div><div
                class="para">
				Akhirnya, sadarilah bahwa kebanyakan BIOS memiliki password generik. Awalnya dimaksudkan untuk pemecahan masalah bagi mereka yang telah lupa password, password ini sekarang umum dan tersedia di Internet (lihat sendiri dengan mencari "password BIOS generik" di mesin pencari). Semua perlindungan ini justru akan menghambat akses tidak sah ke mesin tanpa bisa sepenuhnya mencegah itu. Tidak ada cara yang handal untuk melindungi komputer jika penyerang dapat secara fisik mengakses mereka; mereka bisa melepas hard drive untuk menghubungkan mereka ke komputer di bawah kendali mereka sendiri, atau bahkan mencuri seluruh mesin, atau menghapus memori BIOS untuk me-reset password…
			</div></div><div
              class="para">
				Systemd mengeksekusi beberapa proses, yang bertanggung jawab menyiapkan sistem: papan ketik, driver, sistem berkas, jaringan, layanan. Itu melakukan hal ini sambil menyimpan pandangan global sistem secara keseluruhan, serta kebutuhan komponen-komponen. Masing-masing komponen digambarkan oleh ”berkas unit” (kadang-kadang lebih); sintaks yang umum diturunkan dari sintaks ”berkas *.ini” yang banyak digunakan, dengan pasangan-pasangan <code
                class="literal"><em
                  class="replaceable">kunci</em> = <em
                  class="replaceable">nilai</em></code> dikelompokkan antara header-header <code
                class="literal">[<em
                  class="replaceable">bagian</em>]</code>. Berkas unit disimpan di bawah <code
                class="filename">/lib/systemd/sistem/</code> dan <code
                class="filename">/etc/systemd/system/</code>; mereka datang dalam beberapa rasa, tapi kami akan fokus pada ”layanan” dan ”target” di sini.
			</div><div
              class="para">
				Suatu ”berkas layanan” systemd menggambarkan proses yang dikelola oleh systemd. Itu kurang lebih berisi informasi yang sama seperti init-script gaya lama, tetapi dinyatakan dalam cara yang deklaratif (dan jauh lebih ringkas). Systemd menangani sebagian besar tugas-tugas yang berulang (memulai dan menghentikan proses, memeriksa status, mencatat log, menurunkan hak, dan sebagainya), dan berkas layanan hanya perlu mengisi spesifik dari proses. Sebagai contoh, berikut adalah berkas layanan untuk SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				Seperti yang Anda lihat, ada sangat sedikit kode di sana, hanya deklarasi. Systemd mengurus penampilan laporan kemajuan, melacak proses, dan bahkan menjalankan ulang mereka bila diperlukan.
			</div><div
              class="para">
				Suatu "berkas target" Systemd menggambarkan keadaan sistem, dimana satu set layanan diketahui beroperasi. Ini dapat dianggap sebagai setara runlevel gaya lama. Salah satu target adalah <code
                class="literal">local-fs.target</code>; ketika itu dicapai, sisa sistem bisa berasumsi bahwa seluruh sistem berkas lokal dikait dan dapat diakses. Target lain termasuk <code
                class="literal">network-online.target</code> dan <code
                class="literal">sound.target</code>. Dependensi target dapat dicantumkan baik dalam berkas target (di baris <code
                class="literal">Requires</code>), atau menggunakan symlink ke berkas layanan di direktori <code
                class="literal">/lib/systemd/sistem/<em
                  class="replaceable">namatarget</em>.target.wants/ </code>. Sebagai contoh, <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> berisi taut ke <code
                class="filename">/lib/systemd/system/cups.service</code>; systemd karena itu akan memastikan CUPS berjalan untuk mencapai <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Karena berkas unit deklaratif, bukan skrip atau program, mereka tidak dapat dijalankan secara langsung, dan mereka hanya ditafsirkan oleh systemd; beberapa utilitas karena itu memungkinkan administrator untuk berinteraksi dengan systemd dan mengendalikan keadaan sistem dan setiap komponen.
			</div><div
              class="para">
				Utilitas pertama yang seperti itu adalah <code
                class="command">systemctl</code>. Ketika dijalankan tanpa argumen, itu menampilkan semua berkas unit yang dikenal systemd (kecuali yang dinonaktifkan), maupun status mereka. <code
                class="command">systemctl status</code> memberikan pandangan yang lebih baik atas layanan, maupun proses-proses terkait. Bila nama yang diberikan pada suatu layanan (seperti dalam <code
                class="command">systemctl status ntp.service</code>), itu bahkan mengembalikan lebih banyak rincian, maupun beberapa baris log terakhir yang terkait dengan layanan (lebih jauh tentang ini nanti).
			</div><div
              class="para">
				Memulai suatu layanan secara manual hanya sekedar masalah menjalankan <code
                class="command">systemctl start <em
                  class="replaceable">namalayanan</em>.service</code>. Seperti dapat diduga, menghentikan layanan dilakukan dengan <code
                class="command">systemctl stop <em
                  class="replaceable">namalayanan</em>.service</code>; sub perintah lain termasuk <code
                class="command">reload</code> dan <code
                class="command">restart</code>.
			</div><div
              class="para">
				Untuk mengendalikan apakah suatu layanan aktif (yaitu apakah itu akan secara otomatis dijalankan saat boot), gunakan <code
                class="command">systemctl enable <em
                  class="replaceable">namalayanan</em>.service</code> (atau <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> memungkinkan memeriksa status layanan.
			</div><div
              class="para">
				Fitur menarik dari systemd adalah bahwa itu menyertakan komponen log bernama <code
                class="command">journald</code>. Datang sebagai pelengkap untuk sistem log yang lebih tradisional seperti <code
                class="command">syslogd</code>, tetapi itu menambahkan fitur-fitur menarik seperti kaitan formal antara suatu layanan dan pesan-pesan yang dihasilkannya, dan kemampuan untuk menangkap pesan kesalahan yang dihasilkan oleh urutan inisialisasi. Pesan dapat ditampilkan kemudian, dengan sedikit bantuan dari perintah <code
                class="command">journalctl</code>. Tanpa argumen, itu hanya memunculkan semua pesan log yang terjadi sejak boot sistem; itu akan jarang digunakan dengan cara demikian. Kebanyakan, itu akan digunakan dengan suatu tanda pengenal layanan:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				Bendera baris perintah lain yang berguna adalah <code
                class="command">-f</code>, yang memerintahkan <code
                class="command">journalctl</code> untuk tetap menampilkan pesan baru seperti saat mereka dikeluarkan (seperti gaya <code
                class="command">tail -f <em
                  class="replaceable">berkas</em></code>).
			</div><div
              class="para">
				Jika suatu layanan tampaknya tidak bekerja seperti yang diharapkan, langkah pertama untuk memecahkan masalah adalah memeriksa apakah layanan memang sedang berjalan dengan <code
                class="command">systemctl status</code>; jika tidak, dan pesan yang diberikan oleh perintah pertama tidak cukup untuk mendiagnosa masalah, periksa log yang dikumpulkan oleh journald tentang layanan tersebut. Sebagai contoh, asumsikan SSH server tidak bekerja:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				Setelah memeriksa status layanan (gagal), kita melanjutkan memeriksa log; mereka menunjukkan satu kesalahan di berkas konfigurasi. Setelah menyunting berkas konfigurasi dan memperbaiki kesalahan, kita jalankan ulang layanan, kemudian memastikan bahwa itu memang berjalan.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>LEBIH LANJUT</em></span> Berkas unit tipe lain</strong></p></div></div></div><div
                class="para">
				Kami hanya menggambarkan kapabilitas systemd yang paling dasar dalam bagian ini. Itu menawarkan banyak fitur menarik lainnya; kami hanya akan mencantumkan beberapa di sini:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						aktivasi soket: suatu berkas unit "socket" dapat digunakan untuk menggambarkan sebuah jaringan atau soket Unix yang dikelola oleh systemd; ini berarti bahwa soket akan diciptakan oleh systemd, dan layanan yang sebenarnya dapat dimulai saat diminta ketika datang upaya koneksi sebenarnya. Ini kurang lebih mereplikasi set fitur <code
                        class="command">inetd</code>. Lihat <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						timer: suatu berkas unit "timer" menggambarkan peristiwa yang terjadi dengan frekuensi tetap atau pada waktu tertentu; ketika suatu layanan dikaitkan dengan sebuah timer, tugas terkait akan dijalankan setiap kali timer menembak. Hal ini memungkinkan mereplikasi sebagian dari fitur <code
                        class="command">cron</code>. Lihat <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						jaringan: suatu berkas unit "network" menjelaskan sebuah antarmuka jaringan, yang memungkinkan konfigurasi antarmuka tersebut serta mengungkapkan bahwa suatu layanan bergantung kepada satu antarmuka tertentu yang hidup.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.sysvinit"></a>9.1.2. Sistem init System V</h3></div></div></div><div
              class="para">
				Sistem init System V (yang akan kami namai init agar ringkas) mengeksekusi beberapa proses, mengikuti instruksi dari berkas <code
                class="filename">/etc/inittab</code>. Program pertama yang dijalankan (yang sesuai dengan langkah <span
                class="emphasis"><em>sysinit</em></span>) adalah <code
                class="command">/etc/init.d/rcS</code>, sebuah skrip yang menjalankan semua program di direktori <code
                class="filename">/etc/rcS.d/</code>. <a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				Di antara ini, Anda akan menemukan berturut-turut program-program yang bertanggung jawab atas:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						mengkonfigurasi papan ketik konsol;
					</div></li><li
                  class="listitem"><div
                    class="para">
						memuat driver: sebagian besar modul kernel yang dimuat oleh kernel sendiri saat perangkat keras terdeteksi; driver tambahan kemudian dimuat secara otomatis ketika modul sesuai dicantumkan dalam <code
                      class="filename">/etc/modules</code>;
					</div></li><li
                  class="listitem"><div
                    class="para">
						memeriksa integritas sistem berkas;
					</div></li><li
                  class="listitem"><div
                    class="para">
						mengait partisi lokal;
					</div></li><li
                  class="listitem"><div
                    class="para">
						mengkonfigurasi jaringan;
					</div></li><li
                  class="listitem"><div
                    class="para">
						mengait network filesystems (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KEMBALI KE DASAR</em></span> Modul dan opsi kernel</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				Modul kernel juga memiliki pilihan yang dapat dikonfigurasi dengan menempatkan beberapa berkas dalam <code
                  class="filename">/etc/modprobe.d/</code>. Pilihan ini ditentukan dengan perintah seperti ini: <code
                  class="literal">options <em
                    class="replaceable">nama-modul</em> <em
                    class="replaceable">nama-opsi</em>=<em
                    class="replaceable">nilai-opsi</em></code>. Beberapa pilihan dapat dispesifikasikan dalam satu baris jika diperlukan.
			</div><div
                class="para">
				Berkas konfigurasi ini ditujukan untuk <code
                  class="command">modprobe</code> — program yang memuat suatu modul kernel dengan dependensinya (modul memang dapat memanggil modul lain). Program ini disediakan oleh paket <span
                  class="pkg pkg">kmod</span>.
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				Setelah tahap ini, <code
                class="command">init</code> mengambil alih dan memulai program-program yang diaktifkan pada runlevel default (yang biasanya runlevel 2). Itu mengeksekusi <code
                class="command">/etc/init.d/rc 2</code>, skrip yang memulai semua layanan yang tercantum dalam <code
                class="filename">/etc/rc2.d/</code> dan nama-nama yang mulai dengan huruf "S". Nomor dua-angka yang mengikuti secara historis digunakan untuk menentukan urutan dimulainya layanan, tetapi saat ini sistem boot default menggunakan <code
                class="command">insserv</code>, yang menjadwalkan semuanya secara otomatis berdasarkan dependensi skrip. Setiap skrip boot dengan demikian menyatakan kondisi yang harus dipenuhi untuk memulai atau menghentikan layanan (misalnya, jika itu harus dimulai sebelum atau setelah layanan lain); <code
                class="command">init</code> kemudian meluncurkan mereka dalam urutan yang memenuhi kondisi ini. Penomoran statis skrip karena itu tidak lagi dipertimbangkan (tapi mereka selalu harus mempunyai awal nama dengan "S" diikuti oleh dua digit dan nama sebenarnya dari skrip yang digunakan untuk dependensi). Umumnya, layanan dasar (seperti log dengan <code
                class="command">rsyslog</code>), atau penugasan port dengan <code
                class="command">portmap</code> yang mulai pertama, diikuti oleh layanan-layanan standar dan antarmuka grafis (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				Sistem boot berbasis ketergantungan ini memungkinkan mengotomatisasi penomoran ulang, yang bisa menjadi membosankan jika itu harus dilakukan secara manual, dan itu jadi membatasi resiko kesalahan manusia, karena penjadwalan dilakukan berdasarkan parameter yang ditunjukkan. Manfaat lain adalah bahwa layanan dapat dimulai secara paralel ketika mereka independen dari yang lain, yang dapat mempercepat proses boot.
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> membedakan beberapa runlevel, sehingga ia dapat beralih dari satu ke yang lain dengan perintah <code
                class="command">telinit <em
                  class="replaceable">level-baru</em></code>. Seketika, <code
                class="command">init</code> mengeksekusi <code
                class="command">/etc/init.d/rc</code> lagi dengan runlevel baru. Skrip ini kemudian akan memulai pelayanan yang kurang dan menghentikan yang tidak diinginkan. Untuk melakukan ini, mengacu pada isi <code
                class="filename">/etc/rc <em
                  class="replaceable">X</em> .d</code> (dimana <em
                class="replaceable">X</em> mewakili runlevel baru). Skrip yang dimulai dengan "S" (seperti dalam "Start") adalah layanan yang akan dijalankan; yang dimulai dengan "K" (seperti "Kill") adalah layanan yang harus dihentikan. Skrip tidak memulai layanan apapun yang sudah aktif pada runlevel sebelumnya.
			</div><div
              class="para">
				Secara default, init System V dalam Debian menggunakan empat runlevels yang berbeda:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Level 0 hanya digunakan sementara, ketika komputer menuju mati. Dengan demikian, itu hanya berisi banyak skrip "K".
					</div></li><li
                  class="listitem"><div
                    class="para">
						Level 1, juga dikenal sebagai mode pengguna tunggal, berkaitan dengan sistem dalam mode terdegradasi; itu termasuk hanya layanan dasar, dan ditujukan untuk operasi pemeliharaan dimana interaksi dengan pengguna biasa tidak diinginkan.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Level 2 adalah tingkat untuk operasi normal, yang mencakup layanan jaringan, antarmuka grafis, pengguna login, dll.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Level 6 ini mirip dengan tingkat 0, kecuali bahwa itu digunakan selama fase shutdown yang mendahului reboot.
					</div></li></ul></div><div
              class="para">
				Ada tingkat lain, terutama 3-5. Secara default mereka telah dikonfigurasi untuk beroperasi dengan cara yang sama sebagai tingkat 2, namun administrator dapat memodifikasi mereka (dengan menambahkan atau menghapus skrip di direktori <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> yang sesuai) untuk beradaptasi atas kebutuhan tertentu.
			</div><div
              class="figure"><a
                xmlns=""
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Urutan boot dari komputer yang menjalankan Linux dengan init System V" /></div></div><p
                class="title"><strong>Gambar 9.2. Urutan boot dari komputer yang menjalankan Linux dengan init System V</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				Semua skrip yang terkandung dalam berbagai direktori <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> benar-benar hanya link simbolik — dibuat saat instalasi paket oleh program <code
                class="command">update-rc.d</code> — menunjuk ke skrip sebenarnya yang disimpan dalam <code
                class="filename">/etc/init.d/</code>. Administrator dapat menala layanan yang tersedia pada masing-masing runlevel dengan kembali menjalankan <code
                class="command">update-rc.d</code> dengan parameter yang disesuaikan. Halaman manual <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> menjelaskan sintaks secara rinci. Harap dicatat bahwa menghapus semua link simbolik (dengan parameter <code
                class="literal">remove</code>) bukanlah metode yang baik untuk menonaktifkan layanan yang ada. Sebaliknya Anda hanya harus mengkonfigurasi itu untuk tidak mulai berjalan pada runlevel yang diinginkan (sambil mempertahankan panggilan yang sesuai untuk menghentikannya apabila layanan berjalan pada runlevel sebelumnya). Karena <code
                class="command">update-rc.d</code> memiliki antarmuka yang agak rumit, Anda mungkin lebih suka menggunakan <code
                class="command">rcconf</code> (dari paket <span
                class="pkg pkg">rcconf</span>) yang menyediakan antar muka yang lebih mudah dipakai.
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KEBIJAKAN DEBIAN</em></span> Restart layanan</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				Skrip pengelola paket Debian kadang-kadang akan me-restart layanan tertentu untuk memastikan ketersediaan mereka atau membuat mereka memperhitungkan opsi tertentu. Perintah yang mengontrol layanan — <code
                  class="command">service <em
                    class="replaceable">layanan</em> <em
                    class="replaceable">operasi</em></code> — tidak mempertimbangkan runlevel, (salah) mengasumsikan bahwa layanan ini sedang digunakan, dan mungkin dengan demikian memulai operasi salah (memulai layanan yang sengaja dihentikan, atau menghentikan layanan yang sudah dihentikan, dll.). Maka Debian memperkenalkan program <code
                  class="command">invoke-rc.d</code>: program ini harus digunakan oleh pengelola skrip untuk menjalankan skrip inisialisasi layanan dan itu hanya akan menjalankan perintah yang diperlukan. Catat bahwa, bertentangan dengan penggunaan umum, akhiran <code
                  class="filename">.d</code> yang digunakan di sini di dalam nama program, dan bukan dalam sebuah direktori.
			</div></div><div
              class="para">
				Akhirnya, <code
                class="command">init</code> memulai program kontrol untuk berbagai konsol virtual (<code
                class="command">getty</code>). Menampilkan sebuah prompt, menunggu nama pengguna, kemudian mengeksekusi <code
                class="command">login <em
                  class="replaceable">pengguna</em></code> untuk memulai sesi.
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KOSA KATA</em></span> Konsol dan terminal</strong></p></div></div></div><div
                class="para">
				Komputer pertama biasanya dipisahkan menjadi beberapa bagian yang sangat besar: kandang penyimpanan dan unit pemroses sentral yang terpisah dari perangkat periferal yang digunakan oleh operator untuk mengendalikan mereka. Ini adalah bagian dari furnitur yang terpisah, "konsol". Istilah ini dipertahankan, tapi artinya berubah. Hal ini kurang lebih identik dengan "terminal", karena berupa sebuah papan ketik dan suatu layar.
			</div><div
                class="para">
				Dengan perkembangan komputer, sistem operasi telah menawarkan beberapa konsol virtual untuk memungkinkan beberapa sesi independen pada saat yang sama, bahkan jika ada hanya satu papan ketik dan layar. Kebanyakan sistem GNU/Linux menawarkan enam virtual konsol (dalam modus teks), dapat diakses dengan mengetikkan kombinasi tombol <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> sampai <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span>.
			</div><div
                class="para">
				Diperluas, istilah "konsol" dan "terminal" juga dapat merujuk ke emulator terminal dalam sesi X11 grafis (seperti misalnya <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code>, atau <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Sebelumnya</strong>8.11. Menginstall sebuah Kernel</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Induk</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Depan</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Lanjut</strong>9.2. Log Masuk Jarak Jauh</a></li></ul></body></html>
