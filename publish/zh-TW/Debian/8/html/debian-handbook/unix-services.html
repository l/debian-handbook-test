<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">章 9. Unix 服務</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-zh-TW-1.0-1" /><meta
        name="keywords"
        content="系統啟動, 初始化腳本, SSH, Telnet, 權力, 權限, 監督, Inetd, Cron, 備份, 熱插拔, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="The Debian Administrator's Handbook" /><link
        rel="up"
        href="index.html"
        title="The Debian Administrator's Handbook" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. 安裝核心" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. 遠端登入" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/zh-TW/stable/unix-services.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>前一頁</strong></a></li><li
          class="home">The Debian Administrator's Handbook</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>下一頁</strong></a></li></ul><div
        xml:lang="zh-TW"
        class="chapter"
        lang="zh-TW"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  xmlns=""
                  id="unix-services"></a>章 9. Unix 服務</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. 系統啟動</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. systemd 啟動系統</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. System V 初始系統</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. 遠端登入</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. 安全遠程登入：SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. 使用遠端圖形桌面</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. 管理權限</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. 管理介面</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. 管理網頁介面：<code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. 組態套件：<code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> 系統事件</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. 原則與機制</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. 組態檔案</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. The <code
                    class="command">inetd</code> 超級伺服器</a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. 以 <code
                    class="command">cron</code> 和 <code
                    class="command">atd</code> 使用排定的工作</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. <code
                        class="filename">crontab</code> 檔案的格式</a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. 使用 <code
                        class="command">at</code> 命令</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. 排定非同步工作：<code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. 配額</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. 備份</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. 使用 <code
                        class="command">rsync</code> 備份</a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. 供備份恢復系統</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. 熱插拔：<span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. 介绍</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. 命名問題</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. How <span
                        class="emphasis"><em>udev</em></span> Works</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. A concrete example</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Power Management: Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		此章包括若干 Unix 系统共通的服務。管理員應熟悉他們。
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    xmlns=""
                    id="sect.system-boot"></a>9.1. 系統啟動</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			啟動電腦時，螢幕捲動的訊息表示正在自動處理起始化和組態的工作。需要改變此階段的作業時，就必須好好的理解他們。這正是本章的目的所在。
		</div><div
            class="para">
			首先，BIOS 控制電腦，偵測磁碟機，載入 <span
              class="emphasis"><em>Master Boot Record</em></span>，再執行啟動程式。然後，找到磁碟內的核心程式，載入並執行它。先初始化該核心，搜尋並載入包括根檔案系統的分割區，並執行第一個程式 — <code
              class="command">init</code>。通常，此 “根分割區” 以及 <code
              class="command">init</code> 命令祗在在 RAM 的虛擬檔案系統內 (所以被稱為，“initramfs”，舊稱 “initrd” 就是 “初始化 RAM 磁碟” 的意思)。通常經由硬式磁碟機或網路，讓啟動程式把此檔案系統載入記憶體。它包括核心所需的最少量 “真正” 的根檔案系統：足以驅動系統無法啟動的硬式磁碟機或其他裝置、或者初始化腳本與模組以建構 RAID 陣列，開啟加密分割區、啟動 LVM 等。一但掛上根分割區， initramfs 就把控制權交給真正的啟動程式，機器回到標準的啟動程序。
		</div><div
            class="figure"><a
              xmlns=""
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="執行 systemd 的 Linux 機器的啟動程序" /></div></div><p
              class="title"><strong>圖形 9.1. 執行 systemd 的 Linux 機器的啟動程序</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.systemd"></a>9.1.1. systemd 啟動系統</h3></div></div></div><div
              class="para">
				此 “真正啟動” 是由 <span
                class="pkg pkg">systemd</span> 提供的，在本節說明該啟動系統。
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>文化</em></span> 首先 <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> 是相當新的 “啟動系統”，雖然在 <span
                  class="distribution distribution">Wheezy</span> 裡已經可以使用到某個程度，直到 Debian <span
                  class="distribution distribution">Jessie</span> 才納入預設值。稍最的版本，預設是 “System V init” (在 <span
                  class="pkg pkg">sysv-rc</span> 套件內)，算是傳統的系統。以下描述的是 System V init。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>選擇</em></span> 其他啟動系統</strong></p></div></div></div><div
                class="para">
				本書描述的是 Debian <span
                  class="distribution distribution">Jessie</span> (如 <span
                  class="pkg pkg">systemd</span> 套件所應用的) 預設的啟動系統，以及更早的預設值，<span
                  class="pkg pkg">sysvinit</span>，源自於 <span
                  class="emphasis"><em>System V</em></span> Unix 系統；還有若干其他的。
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> 是程序簡單的啟動系統。祗使用執行層次的原則，但以組態檔取代資料夾與符號連結，做為指示 <code
                  class="command">init</code> 命令處理啟動與後續的順序。
			</div><div
                class="para">
				此 <code
                  class="command">upstart</code> 系統在 Debian 上仍未完整測試。它以事件為基礎：不再依序執行 init 腳本，但以回應另個依附的腳本。由 Ubuntu 開始的這個系統，列在 Debian <span
                  class="distribution distribution">Jessie</span> 內，但還不是預設；事實上，做為 <span
                  class="pkg pkg">sysvinit</span> 的替代品，由 <code
                  class="command">upstart</code> 啟動的工作，係用來啟動為傳統系統而設的，特別是來自 <span
                  class="pkg pkg">sysv-rc</span> 套件的腳本。
			</div><div
                class="para">
				作業模式還有其他的系統，例如 <code
                  class="command">runit</code> 或 <code
                  class="command">minit</code>，但都很專門且不普及。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>特例</em></span> 網路啟動</strong></p></div></div></div><div
                class="para">
				有些組態可以讓 BIOS 不執行 MBR，而從網路尋找等同的裝置，在無硬碟的情況下建立電腦、或完全重新安裝每個啟動。並不是所有硬體都支援此選項，需要 BIOS 與網卡適當地搭配。
			</div><div
                class="para">
				可以從網路啟動 <code
                  class="command">debian-installer</code> 或 FAI (見 <a
                  class="xref"
                  href="installation.html#sect.installation-methods">節 4.1, “安裝方式”</a>)。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>回到基礎</em></span> 程序，一個程式實例</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				程序是在記憶體執行程式的代表。包括適當執行軟體的必要資訊 (程式碼本身、記憶體內的資料、開啟的檔案清單、已建立的網路連結等)。單一程式可能安裝成多個程序，不必在不同的使用者帳號下執行。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>安全</em></span> 以 shell 做為 <code
                          class="command">init</code> 取得 root 權限</strong></p></div></div></div><div
                class="para">
				慣例上，第一個啟動的程序是 <code
                  class="command">init</code> 程式(預設為符號連結至 <code
                  class="filename">/lib/systemd/systemd</code>)。然而，也可能繞過 <code
                  class="literal">init</code> 選項直接進入核心使用其他程式。
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				實際接觸電腦人都可以按下 <span
                  class="keycap"><strong>Reset</strong></span> 鈕，重新開機。然後，在啟動程式的提示符號下，可能繞過 <code
                  class="literal">init=/bin/sh</code> 選項不需管理者密碼，就能進入核心取得 root 權限。
			</div><div
                class="para">
				為了防止此類事件發生，可以加設密碼保護啟動程式。也可以保護進入 BIOS (總是可以找到密碼保護的機制)，可以防止入侵者插入含 Linux 系統的移動媒體，近用電腦硬碟內的資料。
			</div><div
                class="para">
				最後的叮嚀，大部份的 BIOS 有通用密碼。原來係供忘記密碼的人使用，目前已經在網際網路上公開了 (以 “generic BIOS passwords” 在搜尋引擎查找)。所有的保護都可以阻絕未授權的近用但還不能完全避免。目前沒有任何方法可以保護電腦不受實質接觸電腦者的入侵；入侵者可以卸載電腦的硬碟再納入其控制之下、或者偷者整部機器、或者抹除 BIOS 記憶體重設密碼…
			</div></div><div
              class="para">
				Systemd 執行多個程序，設定系統：鍵盤、驅動程式、檔案系統、網路、服務等。同時全面檢視系統，以及必要的配件。每個配件都視為一個 “單元檔案” (有時為多個)；通用的語法源自於常用的 “*.ini files“ 語法，包括配對的 <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code> 列在 <code
                class="literal">[<em
                  class="replaceable">section</em>]</code> 標頭內。單元檔案儲存在 <code
                class="filename">/lib/systemd/system/</code> 與 <code
                class="filename">/etc/systemd/system/</code> 內；以多種風貌呈現，目前專注在 “服務” 與 “目標”。
			</div><div
              class="para">
				systemd “服務檔案” 描述被 systemd 管理的程序。包括與舊型的 init-scripts 相同的資料，但以宣告 (同時較為簡潔) 的方式表述。Systemd 處理大量重複的工作 (啟動與終止程序、檢查其狀態、日註記錄、去除特權等)，以及祗供特定程序使用的服務檔案。例如，以下是 SSH 用到的服務檔：
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				如上文所示，程式碼極少，祗有宣告。Systemd 管理顯示進度報表、追蹤程序、以及必要的重啟。
			</div><div
              class="para">
				systemd 的 “目標檔案” 描述系統的現狀，包括可操作的服務。不妨視為相當於舊型的執行階段作業。其中一個目標是 <code
                class="literal">local-fs.target</code>；進入之後，系統的其他部份假設所有的在地檔案系統均己掛載並可近用。其他的目標包括 <code
                class="literal">network-online.target</code> 與 <code
                class="literal">sound.target</code>。目標的相依性可以列在目標檔案內 (於 <code
                class="literal">Requires=</code> 列) 或使用符號連結至在 <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code> 資料夾內的服務檔案。例如，<code
                class="filename">/etc/systemd/system/printer.target.wants/</code> 包括一個連結至 <code
                class="filename">/lib/systemd/system/cups.service</code>；systemd 將確保 CUPS 已執行至 <code
                class="literal">printer.target</code>。
			</div><div
              class="para">
				單元檔案是宣告性的而不是腳本或程式，不能直接執行，祗能被 systemd 解譯；因些有些工具允許管理者與 systemd 互動且控制系統的狀態與其元件。
			</div><div
              class="para">
				第一種這類工具是 <code
                class="command">systemctl</code>。未使用參數執行時，它列出 systemd 已知的所有單元檔 (除了已經停用的)，及其現況。<code
                class="command">systemctl status</code> 則以更佳的角度檢視服務，以及相關的程序。若提供服務的名稱 (如 <code
                class="command">systemctl status ntp.service</code>)，則送回更多詳細的資料，以及與該服務有關的最後幾個日誌檔 (還有更多的)。
			</div><div
              class="para">
				執行 <code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code> 就能以人工方式啟動服務。同樣的，執行 <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code> 就能停止已完成的服務；其他的次命令包括 <code
                class="command">reload</code> 與 <code
                class="command">restart</code>。
			</div><div
              class="para">
				以 <code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> (或 <code
                class="command">disable</code>) 控制啟動服務 (即開機後自動啟動)。<code
                class="command">is-enabled</code> 可以檢查服務的狀態。
			</div><div
              class="para">
				systemd 重要的功能之一是包括登入的組件 <code
                class="command">journald</code>。做為補充 <code
                class="command">syslogd</code> 之類傳統登入系統的組件，但加入額外的功能包括在服務與其產生訊息間的正式連結，以及補捉由初始過程產生的錯誤訊息。在 <code
                class="command">journalctl</code> 命令的協助下，稍後可顯示該等訊息。不需任何參數，它溢出系統啟動後發生的所有日誌訊息；不過很少用到它。多數時間，把它做為服務的辨識器：
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				另個有用的命令列旗標是 <code
                class="command">-f</code>，用於指示 <code
                class="command">journalctl</code> 繼續顯示溢出的新增訊息 (大部份是在 <code
                class="command">tail -f <em
                  class="replaceable">file</em></code> 之內)。
			</div><div
              class="para">
				若服務狀況不如預共，第一個步驟是以 <code
                class="command">systemctl status</code> 檢查該服務是否真的已啟動；若沒有，則第一個命令給的訊息就不足以診斷問題之所在，檢查 journald 產生的日誌檔。例如，假設 SSH 伺服器未啟動時：
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				檢查服務的狀態 (失敗) 後，再檢查日誌檔；它們會指出組態的錯誤。編輯組態檔並修正錯誤後，重啟服務，確認執行中。
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>下一步</em></span> 其他類型的單元檔</strong></p></div></div></div><div
                class="para">
				本區祗描述 systemd 最基本的功能。其他的功能祗能在此列出若干：
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						啟用插口：“插口” 單元檔案可用於描述 systemd 管理的網路或 Unix 插口；也就是由 systemd 建立的插口，可以在需要的時候再啟動實際的服務。通常重製 <code
                        class="command">inetd</code> 的功能。見 <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>。
					</div></li><li
                    class="listitem"><div
                      class="para">
						定時器：“定時器” 單元檔案描述定時或在指定時間發生的事件；與定時器連結的服務，其對映的工作將在定時器的要求下才執行。 允許重製 <code
                        class="command">cron</code> 的部份功能。見 <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>。
					</div></li><li
                    class="listitem"><div
                      class="para">
						網路：“網路“ 單元檔案描述網路介面，允許組態該等介面以及表述在特定介面的服務。
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.sysvinit"></a>9.1.2. System V 初始系統</h3></div></div></div><div
              class="para">
				System V 初始系統 (簡稱初始) 執行若干程序，根據 <code
                class="filename">/etc/inittab</code> 檔案的指令做事。第一個執行的程式 (對映於 <span
                class="emphasis"><em>sysinit</em></span> 步驟) 是 <code
                class="command">/etc/init.d/rcS</code>，一個執行在 <code
                class="filename">/etc/rcS.d/</code> 資料夾內所有程式的腳本。<a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				在這些裡面，可找到負責的程式：
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						組態終端機的鍵盤；
					</div></li><li
                  class="listitem"><div
                    class="para">
						載入驅動程式：大部份的核心模組在偵測到硬體後由核心本身載入；其他的驅動程式在對應模組列在 <code
                      class="filename">/etc/modules</code> 時，才自動載入；
					</div></li><li
                  class="listitem"><div
                    class="para">
						檢查檔案系織的完整性；
					</div></li><li
                  class="listitem"><div
                    class="para">
						掛載在地分區；
					</div></li><li
                  class="listitem"><div
                    class="para">
						組態網路；
					</div></li><li
                  class="listitem"><div
                    class="para">
						掛載網路檔案系統 (NFS)。
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>基本</em></span> 核心模組與選項</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				核心模組也有選項可供置入檔案在 <code
                  class="filename">/etc/modprobe.d/</code> 內做為組態之用。這些選項設定於：<code
                  class="literal">options <em
                    class="replaceable">module-name</em> <em
                    class="replaceable">option-name</em>=<em
                    class="replaceable">option-value</em></code>。必要時，部份選項可以指定給單一用途。
			</div><div
                class="para">
				這些組態檔係供 <code
                  class="command">modprobe</code> 使用 — 這個程式載入核心模組及其相依者 (才能直正的呼叫其他模組)。這個程式由 <span
                  class="pkg pkg">kmod</span> 套件提供。
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				到了這個地步，<code
                class="command">init</code> 接手並啟動執行階段預設的程式 (通常是執行階段 2)。它執行 <code
                class="command">/etc/init.d/rc 2</code>，一個啟動列在 <code
                class="filename">/etc/rc2.d/</code> 之內的所有服務並命名為 “S” 字母開頭。接著的兩位數，曾經做為服務啟動的順序，不過現在的預設啟動系統使用 <code
                class="command">insserv</code>，根據腳本的相依性自動決定其先後順序。每個啟動腳本宣告的情況必須符合啟動或停止服務 (例如，必須在另個服務之前或之後啟動)；<code
                class="command">init</code> 再依此情況啟動它們。不再考慮靜態的腳本編號 (但仍需按相依性使用 “S” 及兩個數字與實際的腳本名稱)。通常，基本的服務 (諸如以 <code
                class="command">rsyslog</code> 登入，或以 <code
                class="command">portmap</code> 指定埠口) 先列出來，然後才是標準服務與圖形介面 (<code
                class="command">gdm3</code>)。
			</div><div
              class="para">
				這種以相依性為基礎的啟動系統可以自動重新編號，避免人工作業的繁瑣，且限縮可能的人為錯誤，因為其排序係依照參數而訂。另個優點是可以同時啟動多個互相獨立的服務，藉以加速啟動程序。
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> 區隔多個執行階層，所以可以用 <code
                class="command">telinit <em
                  class="replaceable">new-level</em></code> 命令切換。立即，<code
                class="command">init</code> 在新的執行階層再次執行 <code
                class="command">/etc/init.d/rc</code>。這個腳本可執行缺失的服務並停止不再用到的服務。為了做到這個程度，它參照 <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> 的內容 (<em
                class="replaceable">X</em> 代表新的執行階層)。以 “S” (表示開始 “Start”) 開始的腳本是將啟動的服務；以 “K” (表示砍掉 “Kill”) 開始的腳本是將停止的服務。腳本不會啟動已經在前個執行階層執行的服務。
			</div><div
              class="para">
				預設，Debian 的 System V init 使用四個不同的執行階層：
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						0 層，祗是暫時的，電腦進入關機程序。所以，祗包括若干 “K” 腳本。
					</div></li><li
                  class="listitem"><div
                    class="para">
						1 層，也稱為單一使用者模式，對應於系統的降級模式；祗包括基本服務，並試圖維護與一般使用者非必要的運作。
					</div></li><li
                  class="listitem"><div
                    class="para">
						2 層是標準運作，包括網路服務、圖形介面、使用者登入等。
					</div></li><li
                  class="listitem"><div
                    class="para">
						6 層類似 0 層，除了在重開機之前先執行關機。
					</div></li></ul></div><div
              class="para">
				其他的階層，尤其是 3 至 5 階。它們預設的組態等同於階層 2，但是管理者可以修改它們 (在對應的 <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> 資料夾新增或刪除腳本) 以適應特定的需求。
			</div><div
              class="figure"><a
                xmlns=""
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="以 System V init 執行 Linux 的啟動程序" /></div></div><p
                class="title"><strong>圖形 9.2. 以 System V init 執行 Linux 的啟動程序</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				在 <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> 資料夾內的腳本祗是符號連結 — 安裝套件時由 <code
                class="command">update-rc.d</code> 程式產生 — 指向儲存在 <code
                class="filename">/etc/init.d/</code> l裡的實際腳本。管理者可以使用調整後的參數重新執行 <code
                class="command">update-rc.d</code> 以微調運行層級的服務。The <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> 手冊詳細地描述其語法。請注意移除所有的符號連結 (使用 <code
                class="literal">remove</code> 參數) 不是停用該服務的好方法。應該是，在特定的執行層級組態其為不啟動 (在前個執行層級已有的服務應保留對應的呼叫停止它)。因為 <code
                class="command">update-rc.d</code> 介面有點麻煩，建議使用較為友善的 <code
                class="command">rcconf</code> (從 <span
                class="pkg pkg">rcconf</span> 套件取用) 介面。
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN 政策</em></span> 重啟服務</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				Debian 套件的維護者腳本將不時重新啟動特定服務以確保其有效性或取得特定的選項。控制服務的命令 — <code
                  class="command">service <em
                    class="replaceable">service</em> <em
                    class="replaceable">operation</em></code> — 未考量執行階層，假設 (錯誤地) 該服務仍在使用中，且可能啟動錯誤的作業 (啟動應該停止的服務，或停止已經停止的服務等)。因此，Debian 有個 <code
                  class="command">invoke-rc.d</code> 程式：必須由維護者的腳本啟動，執行服務的初啟腳本且祗執行必要的命令。注意，不同於常見的用法，在程式名之前使用 <code
                  class="filename">.d</code> 前置，且不能在資料夾內。
			</div></div><div
              class="para">
				最後，<code
                class="command">init</code> 啟動虛擬終端機 (<code
                class="command">getty</code>) 的控制程式。顯示提示符號，等待使用者名稱，然後執行 <code
                class="command">login <em
                  class="replaceable">user</em></code> 啟始一個程序。
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>字彙</em></span> 控制臺與終端機</strong></p></div></div></div><div
                class="para">
				第一組電腦通常由多個非常大的部份組成：儲存裝置與中央處理單元，以及由作業員控制的獨立週邊裝置。這些部份置於獨立的櫃中，“控制臺”。這個術語使用多年，但代表的義意已經改變。離 “終端機”，即鍵盤與螢幕，愈來愈遠。
			</div><div
                class="para">
				在電腦的發展過程中，作業系統建拉多個虛擬控制臺，同時處理多個獨立的程序，即使祗有一個鍵盤與螢幕也可以。大部份的 GNU/Linux 系統提供 6 個虛擬控制臺 (文字模式)，按下組合鍵 <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> 至 <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span> 就能在此 6 個控制臺間切換。
			</div><div
                class="para">
				廣義來說，“控制臺” 與 “終端機” 也可表示圖形 X11 作業 (如 <code
                  class="command">xterm</code>、<code
                  class="command">gnome-terminal</code> 或 <code
                  class="command">konsole</code>) 的模擬終端機。
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>前一頁</strong>8.11. 安裝核心</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上一層</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>起始頁</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>下一頁</strong>9.2. 遠端登入</a></li></ul></body></html>
