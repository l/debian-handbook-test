<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.4. Some Tasks Handled by the Kernel</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-ko-KR-1.0-1" /><meta
        name="keywords"
        content="BIOS, Kernel, Unix, Process, Hierarchy, Basic Commands" /><link
        rel="home"
        href="index.html"
        title="데비안 관리자의 핸드북" /><link
        rel="up"
        href="short-remedial-course.html"
        title="부록 B. Short Remedial Course" /><link
        rel="prev"
        href="sect.computer-layers.html"
        title="B.3. Inner Workings of a Computer: the Different Layers Involved" /><link
        rel="next"
        href="sect.user-space.html"
        title="B.5. The User Space" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/ko-KR/stable/sect.kernel-role-and-tasks.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>이전</strong></a></li><li
          class="home">데비안 관리자의 핸드북</li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>다음</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.kernel-role-and-tasks"></a>B.4. Some Tasks Handled by the Kernel</h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.hardware-drivers"></a>B.4.1. Driving the Hardware</h3></div></div></div><div
            class="para">
				The kernel is, first and foremost, tasked with controlling the hardware parts, detecting them, switching them on when the computer is powered on, and so on. It also makes them available to higher-level software with a simplified programming interface, so applications can take advantage of devices without having to worry about details such as which extension slot the option board is plugged into. The programming interface also provides an abstraction layer; this allows video-conferencing software, for example, to use a webcam independently of its make and model. The software can just use the <span
              class="emphasis"><em>Video for Linux</em></span> (V4L) interface, and the kernel translates the function calls of this interface into the actual hardware commands needed by the specific webcam in use.
			</div><div
            class="para">
				<a
              id="id-1.21.7.2.3.1"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.2"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.3"
              class="indexterm"></a> <a
              id="id-1.21.7.2.3.4"
              class="indexterm"></a> The kernel exports many details about detected hardware through the <code
              class="filename">/proc/</code> and <code
              class="filename">/sys/</code> virtual filesystems. Several tools summarize those details. Among them, <code
              class="command">lspci</code> (in the <span
              class="pkg pkg">pciutils</span> package) lists PCI devices, <code
              class="command">lsusb</code> (in the <span
              class="pkg pkg">usbutils</span> package) lists USB devices, and <code
              class="command">lspcmcia</code> (in the <span
              class="pkg pkg">pcmciautils</span> package) lists PCMCIA cards. These tools are very useful for identifying the exact model of a device. This identification also allows more precise searches on the web, which in turn, lead to more relevant documents.
			</div><div
            class="example"><a
              xmlns=""
              id="id-1.21.7.2.4"></a><p
              class="title"><strong>예 B.1. Example of information provided by <code
                  class="command">lspci</code> and <code
                  class="command">lsusb</code></strong></p><div
              class="example-contents"><pre
                class="screen">
<code
                  class="computeroutput">$ </code><strong
                  class="userinput"><code>lspci</code></strong>
<code
                  class="computeroutput">[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </code><strong
                  class="userinput"><code>lsusb</code></strong>
<code
                  class="computeroutput">Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</code></pre></div></div><div
            class="para">
				These programs have a <code
              class="literal">-v</code> option, that lists much more detailed (but usually not necessary) information. Finally, the <code
              class="command">lsdev</code> command (in the <span
              class="pkg pkg">procinfo</span> package) lists communication resources used by devices.
			</div><div
            class="para">
				Applications often access devices by way of special files created within <code
              class="filename">/dev/</code> (see sidebar <a
              class="xref"
              href="sect.creating-accounts.html#sidebar.special-files"><span
                class="emphasis"><em>BACK TO BASICS</em></span> Device access permissions</a>). These are special files that represent disk drives (for instance, <code
              class="filename">/dev/hda</code> and <code
              class="filename">/dev/sdc</code>), partitions (<code
              class="filename">/dev/hda1</code> or <code
              class="filename">/dev/sdc3</code>), mice (<code
              class="filename">/dev/input/mouse0</code>), keyboards (<code
              class="filename">/dev/input/event0</code>), soundcards (<code
              class="filename">/dev/snd/*</code>), serial ports (<code
              class="filename">/dev/ttyS*</code>), and so on.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.filesystems"></a>B.4.2. Filesystems</h3></div></div></div><a
            id="id-1.21.7.3.2"
            class="indexterm"></a><a
            id="id-1.21.7.3.3"
            class="indexterm"></a><div
            class="para">
				Filesystems are one of the most prominent aspects of the kernel. Unix systems merge all the file stores into a single hierarchy, which allows users (and applications) to access data simply by knowing its location within that hierarchy.
			</div><div
            class="para">
				The starting point of this hierarchical tree is called the root, <code
              class="filename">/</code>. This directory can contain named subdirectories. For instance, the <code
              class="literal">home</code> subdirectory of <code
              class="filename">/</code> is called <code
              class="filename">/home/</code>. This subdirectory can, in turn, contain other subdirectories, and so on. Each directory can also contain files, where the actual data will be stored. Thus, the <code
              class="filename">/home/rmas/Desktop/hello.txt</code> name refers to a file named <code
              class="literal">hello.txt</code> stored in the <code
              class="literal">Desktop</code> subdirectory of the <code
              class="literal">rmas</code> subdirectory of the <code
              class="literal">home</code> directory present in the root. The kernel translates between this naming system and the actual, physical storage on a disk.
			</div><div
            class="para">
				Unlike other systems, there is only one such hierarchy, and it can integrate data from several disks. One of these disks is used as the root, and the others are “mounted” on directories in the hierarchy (the Unix command is called <code
              class="command">mount</code>); these other disks are then available under these “mount points”. This allows storing users' home directories (traditionally stored within <code
              class="filename">/home/</code>) on a second hard disk, which will contain the <code
              class="literal">rhertzog</code> and <code
              class="literal">rmas</code> directories. Once the disk is mounted on <code
              class="filename">/home/</code>, these directories become accessible at their usual locations, and paths such as <code
              class="filename">/home/rmas/Desktop/hello.txt</code> keep working.
			</div><a
            id="id-1.21.7.3.7"
            class="indexterm"></a><div
            class="para">
				There are many filesystem formats, corresponding to many ways of physically storing data on disks. The most widely known are <span
              class="emphasis"><em>ext2</em></span>, <span
              class="emphasis"><em>ext3</em></span> and <span
              class="emphasis"><em>ext4</em></span>, but others exist. For instance, <span
              class="emphasis"><em>vfat</em></span> is the system that was historically used by DOS and Windows operating systems, which allows using hard disks under Debian as well as under Windows. In any case, a filesystem must be prepared on a disk before it can be mounted and this operation is known as “formatting”. Commands such as <code
              class="command">mkfs.ext3</code> (where <code
              class="command">mkfs</code> stands for <span
              class="emphasis"><em>MaKe FileSystem</em></span>) handle formatting. These commands require, as a parameter, a device file representing the partition to be formatted (for instance, <code
              class="filename">/dev/sda1</code>). This operation is destructive and should only be run once, except if one deliberately wishes to wipe a filesystem and start afresh.
			</div><div
            class="para">
				There are also network filesystems, such as <acronym
              class="acronym">NFS</acronym>, where data is not stored on a local disk. Instead, data is transmitted through the network to a server that stores and retrieves them on demand. The filesystem abstraction shields users from having to care: files remain accessible in their usual hierarchical way.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.shared-functions"></a>B.4.3. Shared Functions</h3></div></div></div><div
            class="para">
				Since a number of the same functions are used by all software, it makes sense to centralize them in the kernel. For instance, shared filesystem handling allows any application to simply open a file by name, without needing to worry where the file is stored physically. The file can be stored in several different slices on a hard disk, or split across several hard disks, or even stored on a remote file server. Shared communication functions are used by applications to exchange data independently of the way the data is transported. For instance, transport could be over any combination of local or wireless networks, or over a telephone landline.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.process-management"></a>B.4.4. Managing Processes</h3></div></div></div><a
            id="id-1.21.7.5.2"
            class="indexterm"></a><div
            class="para">
				A process is a running instance of a program. This requires memory to store both the program itself and its operating data. The kernel is in charge of creating and tracking them. When a program runs, the kernel first sets aside some memory, then loads the executable code from the filesystem into it, and then starts the code running. It keeps information about this process, the most visible of which is an identification number known as <span
              class="emphasis"><em>pid</em></span> (<span
              class="emphasis"><em>process identifier</em></span>).
			</div><div
            class="para">
				Unix-like kernels (including Linux), like most other modern operating systems, are capable of “multi-tasking”. In other words, they allow running many processes “at the same time”. There is actually only one running process at any one time, but the kernel cuts time into small slices and runs each process in turn. Since these time slices are very short (in the millisecond range), they create the illusion of processes running in parallel, although they are actually only active during some time intervals and idle the rest of the time. The kernel's job is to adjust its scheduling mechanisms to keep that illusion, while maximizing the global system performance. If the time slices are too long, the application may not appear as responsive as desired. Too short, and the system loses time switching tasks too frequently. These decisions can be tweaked with process priorities. High-priority processes will run for longer and with more frequent time slices than low-priority processes.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTE</em></span> Multi-processor systems (and variants)</strong></p></div></div></div><div
              class="para">
				The limitation described above of only one process being able to run at a time, doesn't always apply. The actual restriction is that there can only be one running process <span
                class="emphasis"><em>per processor core</em></span> at a time. Multi-processor, multi-core or “hyper-threaded” systems allow several processes to run in parallel. The same time-slicing system is still used, though, so as to handle cases where there are more active processes than available processor cores. This is far from unusual: a basic system, even a mostly idle one, almost always has tens of running processes.
			</div></div><div
            class="para">
				Of course, the kernel allows running several independent instances of the same program. But each can only access its own time slices and memory. Their data thus remain independent.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.permissions"></a>B.4.5. Rights Management</h3></div></div></div><div
            class="para">
				Unix-like systems are also multi-user. They provide a rights management system that supports separate users and groups; it also allows control over actions based on permissions. The kernel manages data for each process, allowing it to control permissions. Most of the time, a process is identified by the user who started it. That process is only permitted to take those actions available to its owner. For instance, trying to open a file requires the kernel to check the process identity against access permissions (for more details on this particular example, see <a
              class="xref"
              href="sect.rights-management.html">9.3절. “Managing Rights”</a>).
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.computer-layers.html"><strong>이전</strong>B.3. Inner Workings of a Computer: the Different ...</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>위로</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>처음으로</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.user-space.html"><strong>다음</strong>B.5. The User Space</a></li></ul></body></html>
