<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Rozdział 9. Usługi Uniksa</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-pl-PL-1.0-1" /><meta
        name="keywords"
        content="Bootowanie systemu, Initscripts, SSH, Telnet, Prawa, Uprawnienia, Nadzór, Inetd, Cron, Kopia bezpieczeństwa, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Podręcznik Administratora Debiana" /><link
        rel="up"
        href="index.html"
        title="Podręcznik Administratora Debiana" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Installing a Kernel" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Remote Login" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/pl-PL/stable/unix-services.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Poprzedni</strong></a></li><li
          class="home">Podręcznik Administratora Debiana</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Następny</strong></a></li></ul><div
        xml:lang="pl-PL"
        class="chapter"
        lang="pl-PL"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  xmlns=""
                  id="unix-services"></a>Rozdział 9. Usługi Uniksa</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. Bootowanie systemu</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. The systemd init system</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. The System V init system</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Remote Login</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Secure Remote Login: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Using Remote Graphical Desktops</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Managing Rights</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Administration Interfaces</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Administrating on a Web Interface: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Configuring Packages: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> System Events</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Principle and Mechanism</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. The Configuration File</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. The <code
                    class="command">inetd</code> Super-Server</a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Scheduling Tasks with <code
                    class="command">cron</code> and <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Format of a <code
                        class="filename">crontab</code> File</a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Using the <code
                        class="command">at</code> Command</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Scheduling Asynchronous Tasks: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Quotas</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Kopia bezpieczeństwa</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. Backing Up with <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. Restoring Machines without Backups</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Hot Plugging: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. Introduction</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. The Naming Problem</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. How <span
                        class="emphasis"><em>udev</em></span> Works</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. A concrete example</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Power Management: Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Ten rozdział opisuje kilka podstawowych usług, które są dostępne w wielu systemach Unix. Wszyscy administratorzy powinni je znać.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    xmlns=""
                    id="sect.system-boot"></a>9.1. Bootowanie systemu</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			Kiedy bootujesz komputer, masa wiadomości przewijających się przez konsole ukazuje wykonywane automatyczne inicjalizacje i konfiguracje. Czasami chcesz nieco wpłynąć na działanie tego etapu, co oznacza, ze musisz go dobrze zrozumieć. To jest właśnie celem tej części książki.
		</div><div
            class="para">
			First, the BIOS takes control of the computer, detects the disks, loads the <span
              class="emphasis"><em>Master Boot Record</em></span>, and executes the bootloader. The bootloader takes over, finds the kernel on the disk, loads and executes it. The kernel is then initialized, and starts to search for and mount the partition containing the root filesystem, and finally executes the first program — <code
              class="command">init</code>. Frequently, this “root partition” and this <code
              class="command">init</code> are, in fact, located in a virtual filesystem that only exists in RAM (hence its name, “initramfs”, formerly called “initrd” for “initialization RAM disk”). This filesystem is loaded in memory by the bootloader, often from a file on a hard drive or from the network. It contains the bare minimum required by the kernel to load the “true” root filesystem: this may be driver modules for the hard drive, or other devices without which the system cannot boot, or, more frequently, initialization scripts and modules for assembling RAID arrays, opening encrypted partitions, activating LVM volumes, etc. Once the root partition is mounted, the initramfs hands over control to the real init, and the machine goes back to the standard boot process.
		</div><div
            class="figure"><a
              xmlns=""
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Boot sequence of a computer running Linux with systemd" /></div></div><p
              class="title"><strong>Rysunek 9.1. Boot sequence of a computer running Linux with systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.systemd"></a>9.1.1. The systemd init system</h3></div></div></div><div
              class="para">
				The “real init” is currently provided by <span
                class="pkg pkg">systemd</span> and this section documents this init system.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURE</em></span> Before <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> is a relatively recent “init system”, and although it was already available, to a certain extent, in <span
                  class="distribution distribution">Wheezy</span>, it has only become the default in Debian <span
                  class="distribution distribution">Jessie</span>. Previous releases relied, by default, on the “System V init” (in the <span
                  class="pkg pkg">sysv-rc</span> package), a much more traditional system. We describe the System V init later on.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATYWA</em></span> Inne systemy bootujące</strong></p></div></div></div><div
                class="para">
				This book describes the boot system used by default in Debian <span
                  class="distribution distribution">Jessie</span> (as implemented by the <span
                  class="pkg pkg">systemd</span> package), as well as the previous default, <span
                  class="pkg pkg">sysvinit</span>, which is derived and inherited from <span
                  class="emphasis"><em>System V</em></span> Unix systems; there are others.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> jest systemem bootującym z bardzo prostym procesem. Podtrzymuje zasadę poziomów działania, ale zamienia słownikowe i symboliczne dowiązania do pliku konfiguracyjnego, który wskazuje na procesy <code
                  class="command">init</code>, które muszą zostać wykonane i ustanawia ich kolejność.
			</div><div
                class="para">
				The <code
                  class="command">upstart</code> system is still not perfectly tested on Debian. It is event based: init scripts are no longer executed in a sequential order but in response to events such as the completion of another script upon which they are dependent. This system, started by Ubuntu, is present in Debian <span
                  class="distribution distribution">Jessie</span>, but is not the default; it comes, in fact, as a replacement for <span
                  class="pkg pkg">sysvinit</span>, and one of the tasks launched by <code
                  class="command">upstart</code> is to launch the scripts written for traditional systems, especially those from the <span
                  class="pkg pkg">sysv-rc</span> package.
			</div><div
                class="para">
				There are also other systems and other operating modes, such as <code
                  class="command">runit</code> or <code
                  class="command">minit</code>, but they are relatively specialized and not widespread.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SPECYFICZNY PRZYPADEK</em></span> Bootowanie z sieci</strong></p></div></div></div><div
                class="para">
				W niektórych konfiguracjach, BIOS może być ustawiony tak, aby nie uruchamiać głównego sektora rozruchowego, ale szukać jego równoważności w sieci, stwarzając możliwość działania komputerów bez dysków twardych, albo takie, które będą całkowicie reinstalowane po każdej inicjalizacji systemu.
			</div><div
                class="para">
				Bootowanie z sieci może być używane do uruchomienia <code
                  class="command">debian-installer</code> lub FAI (zobacz <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Sekcja 4.1, „Metody instalacji”</a>).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>POWRÓT DO PODSTAW</em></span> Proces, instancja programu</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				Proces jest reprezentacją uruchomionego programu w pamięci komputera. Zawiera wszystkie informacje niezbędne do poprawnego uruchomienia oprogramowania(kod sam w sobie, ale także dane, które ma w pamięci, listę otwartych plików, ustanowionych połączeń w sieci itd.). Pojedynczy program może zapoczątkować kilka procesów, niekoniecznie uruchamianych po różnymi identyfikatorami użytkowników.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BEZPIECZEŃSTWO</em></span> Używanie powłoki jako <code
                          class="command">init</code>aby zyskać prawa roota</strong></p></div></div></div><div
                class="para">
				By convention, the first process that is booted is the <code
                  class="command">init</code> program (which is a symbolic link to <code
                  class="filename">/lib/systemd/systemd</code> by default). However, it is possible to pass an <code
                  class="literal">init</code> option to the kernel indicating a different program.
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				Każdy człowiek, który ma bezpośredni dostęp do komputera może wcisnąć klawisz <span
                  class="keycap"><strong>Reset</strong></span> i spowodować ponowny rozruch systemu. Następnie przy zgłoszeniu się bootloadera, możliwe jest pominięcie opcji <code
                  class="literal">init=/bin/sh</code>w jądrze systemu, aby zdobyć dostęp do roota bez znajomości hasła administratora systemu.
			</div><div
                class="para">
				Aby temu zapobiec, możesz zabezpieczyć sam bootloader hasłem. Możesz także pomyśleć by zabezpieczyć BIOS(prawie zawsze istnieje możliwość utworzenia hasła), bez którego złośliwy intruz może nadal zbootować system na nośniku wymiennym zawierającym swojego własnego Linuxa, którego może użyć by dostać się do danych na Twoim dysku.
			</div><div
                class="para">
				Finally, be aware that most BIOS have a generic password available. Initially intended for troubleshooting for those who have forgotten their password, these passwords are now public and available on the Internet (see for yourself by searching for “generic BIOS passwords” in a search engine). All of these protections will thus impede unauthorized access to the machine without being able to completely prevent it. There is no reliable way to protect a computer if the attacker can physically access it; they could dismount the hard drives to connect them to a computer under their own control anyway, or even steal the entire machine, or erase the BIOS memory to reset the password…
			</div></div><div
              class="para">
				Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code> pairs grouped between <code
                class="literal">[<em
                  class="replaceable">section</em>]</code> headers. Unit files are stored under <code
                class="filename">/lib/systemd/system/</code> and <code
                class="filename">/etc/systemd/system/</code>; they come in several flavours, but we will focus on “services” and “targets” here.
			</div><div
              class="para">
				A systemd “service file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here is the service file for SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service
</pre><div
              class="para">
				As you can see, there is very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed.
			</div><div
              class="para">
				A systemd “target file” describes a state of the system, where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the targets is <code
                class="literal">local-fs.target</code>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <code
                class="literal">network-online.target</code> and <code
                class="literal">sound.target</code>. The dependencies of a target can be listed either within the target file (in the <code
                class="literal">Requires=</code> line), or using a symbolic link to a service file in the <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code> directory. For instance, <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> contains a link to <code
                class="filename">/lib/systemd/system/cups.service</code>; systemd will therefore ensure CUPS is running in order to reach <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Since unit files are declarative rather than scripts or programs, they cannot be run directly, and they are only interpreted by systemd; several utilities therefore allow the administrator to interact with systemd and control the state of the system and of each component.
			</div><div
              class="para">
				The first such utility is <code
                class="command">systemctl</code>. When run without any arguments, it lists all the unit files known to systemd (except those that have been disabled), as well as their status. <code
                class="command">systemctl status</code> gives a better view of the services, as well as the related processes. If given the name of a service (as in <code
                class="command">systemctl status ntp.service</code>), it returns even more details, as well as the last few log lines related to the service (more on that later).
			</div><div
              class="para">
				Starting a service by hand is a simple matter of running <code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code>. As one can guess, stopping the service is done with <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code>; other subcommands include <code
                class="command">reload</code> and <code
                class="command">restart</code>.
			</div><div
              class="para">
				To control whether a service is active (i.e. whether it will get started automatically on boot), use <code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> (or <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> allows checking the status of the service.
			</div><div
              class="para">
				An interesting feature of systemd is that it includes a logging component named <code
                class="command">journald</code>. It comes as a complement to more traditional logging systems such as <code
                class="command">syslogd</code>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialisation sequence. The messages can be displayed later on, with a little help from the <code
                class="command">journalctl</code> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				Another useful command-line flag is <code
                class="command">-f</code>, which instructs <code
                class="command">journalctl</code> to keep displaying new messages as they are emitted (much in the manner of <code
                class="command">tail -f <em
                  class="replaceable">file</em></code>).
			</div><div
              class="para">
				If a service doesn't seem to be working as expected, the first step to solve the problem is to check that the service is actually running with <code
                class="command">systemctl status</code>; if it is not, and the messages given by the first command are not enough to diagnose the problem, check the logs gathered by journald about that service. For instance, assume the SSH server doesn't work:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				After checking the status of the service (failed), we went on to check the logs; they indicate an error in the configuration file. After editing the configuration file and fixing the error, we restart the service, then verify that it is indeed running.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> Other types of unit files</strong></p></div></div></div><div
                class="para">
				We have only described the most basic of systemd's capabilities in this section. It offers many other interesting features; we will only list a few here:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <code
                        class="command">inetd</code>. See <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						timers: a “timer” unit file describes events that occur with a fixed frequency or on specific times; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. This allows replicating part of the <code
                        class="command">cron</code> features. See <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.sysvinit"></a>9.1.2. The System V init system</h3></div></div></div><div
              class="para">
				The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <code
                class="filename">/etc/inittab</code> file. The first program that is executed (which corresponds to the <span
                class="emphasis"><em>sysinit</em></span> step) is <code
                class="command">/etc/init.d/rcS</code>, a script that executes all of the programs in the <code
                class="filename">/etc/rcS.d/</code> directory. <a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				Wśród nich możesz znaleźć kolejno programy odpowiedzialne za:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						konfigurowanie klawiatury konsoli;
					</div></li><li
                  class="listitem"><div
                    class="para">
						wczytywanie sterowników: większość modułów jądra systemu jest wyczytywana przez nie samodzielnie jak przy wykryciu dysku twardego; następnie automatycznie wczytywane są dodatkowe sterowniki, a lista nawiązujących modułów tworzona jest w <code
                      class="filename">/etc/modules</code>;
					</div></li><li
                  class="listitem"><div
                    class="para">
						sprawdzanie integralności systemu plików;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montowanie lokalnych partycji;
					</div></li><li
                  class="listitem"><div
                    class="para">
						konfigurowanie sieci;
					</div></li><li
                  class="listitem"><div
                    class="para">
						montowanie sieciowego systemu plików(NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>POWRTÓT DO PODSTAW</em></span> Moduły i opcje jądra systemu</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				Moduły jądra systemu maja także opcje, które mogą być konfigurowane poprzez dodanie jakiś plików do <code
                  class="filename">/etc/modprobe.d/</code>. Te opcje są zdefiniowane dyrektywami takimi jak: <code
                  class="literal">options <em
                    class="replaceable">module-name</em> <em
                    class="replaceable">option-name</em>=<em
                    class="replaceable">option-value</em></code>. Jeśli zajdzie taka potrzeba kilka opcji może być określonych przez pojedynczą dyrektywę.
			</div><div
                class="para">
				Te pliki konfiguracyjne są przeznaczone dla <code
                  class="command">modprobe</code>-program, który ładuje moduł jądra systemu z jego zależnościami (moduły mogą wszak powoływać inne moduły). Ten program jest dostarczany przez pakiet <span
                  class="pkg pkg">kmod</span>.
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				After this stage, <code
                class="command">init</code> takes over and starts the programs enabled in the default runlevel (which is usually runlevel 2). It executes <code
                class="command">/etc/init.d/rc 2</code>, a script that starts all services which are listed in <code
                class="filename">/etc/rc2.d/</code> and whose names start with the “S” letter. The two-figures number that follows had historically been used to define the order in which services had to be started, but nowadays the default boot system uses <code
                class="command">insserv</code>, which schedules everything automatically based on the scripts' dependencies. Each boot script thus declares the conditions that must be met to start or stop the service (for example, if it must start before or after another service); <code
                class="command">init</code> then launches them in the order that meets these conditions. The static numbering of scripts is therefore no longer taken into consideration (but they must always have a name beginning with “S” followed by two digits and the actual name of the script used for the dependencies). Generally, base services (such as logging with <code
                class="command">rsyslog</code>, or port assignment with <code
                class="command">portmap</code>) are started first, followed by standard services and the graphical interface (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				System bootowania oparty na zależnościach sprawia, że możliwe jest zautomatyzowanie ponownego numerowania, które potrafi być uciążliwe, jeśli trzeba je przeprowadzić ręcznie, oraz zmniejsza prawdopodobieństwo ludzkiego błędu, ponieważ planowanie odbywa się według wskazanych parametrów. Inną korzyścią jest to, że usługi mogą być uruchomione równolegle, jeśli są od siebie niezależne, co przyśpiesza proces bootowania.
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> wyróżnia kilka poziomów działania, więc może przełączać się między nimi komendą <code
                class="command">telinit <em
                  class="replaceable">new-level</em></code>. <code
                class="command">init</code> natychmiastowo uruchamia<code
                class="command">/etc/init.d/rc</code> z nowym poziomem działania. Następnie ten skrypt uruchamia brakujące usługi i zatrzymuje te, które nie są już pożądane. Aby to zrobić, wskazuje na zawartość <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> (gdzie <em
                class="replaceable">X</em> reprezentuje nowy poziom działania). Skrypty zaczynające się na "S"(jak "Start") są usługami do uruchomienia; te zaczynające się na "K"(jak "Kill") są usługami, które należy zatrzymać. Skrypt nie uruchomi żadnej usługi, która jest już aktywna w poprzednim poziomie działania.
			</div><div
              class="para">
				By default, System V init in Debian uses four different runlevels:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Poziom 0 jest używanym tylko tymczasowo, podczas wyłączania się komputera. Dlatego zawiera wiele skryptów "K".
					</div></li><li
                  class="listitem"><div
                    class="para">
						Poziom 1, znany także jako tryb dla pojedynczego użytkownika( single-user mode), odpowiada systemowi w trybie awaryjnym; zawiera tylko podstawowe usługi i powstał do wykonywania konserwacji, tak więc interakcje ze zwykłym użytkownikiem nie są pożądane.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Poziom 2 służy do wykonywania zwyczajnych operacji, w skład których wchodzą usługi sieciowe, środowisko graficzne, loginy itd.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Poziom 6 jest podobny do poziomu 0, pomijając to, że jest używany podczas fazy zamykania, która poprzedza ponowne uruchomienie.
					</div></li></ul></div><div
              class="para">
				Istnieją inne poziomy, szczególnie od 3 do 5. Domyślnie są skonfigurowane tak, by działać identycznie jak poziom 2, ale administrator może je zmodyfikować(dodając lub usuwając skrypty w <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code>) aby przystosować je do szczególnych potrzeb.
			</div><div
              class="figure"><a
                xmlns=""
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Boot sequence of a computer running Linux with System V init" /></div></div><p
                class="title"><strong>Rysunek 9.2. Boot sequence of a computer running Linux with System V init</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				Wszystkie skrypty zawierające się w różnych <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> directories are really only symbolic links — created upon package installation by the <code
                class="command">update-rc.d</code> program — pointing to the actual scripts which are stored in <code
                class="filename">/etc/init.d/</code>. The administrator can fine tune the services available in each runlevel by re-running <code
                class="command">update-rc.d</code> with adjusted parameters. The <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> manual page describes the syntax in detail. Please note that removing all symbolic links (with the <code
                class="literal">remove</code> parameter) is not a good method to disable a service. Instead you should simply configure it to not start in the desired runlevel (while preserving the corresponding calls to stop it in the event that the service runs in the previous runlevel). Since <code
                class="command">update-rc.d</code> has a somewhat convoluted interface, you may prefer using <code
                class="command">rcconf</code> (from the <span
                class="pkg pkg">rcconf</span> package) which provides a more user-friendly interface.
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN POLICY</em></span> Restarting services</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				The maintainer scripts for Debian packages will sometimes restart certain services to ensure their availability or get them to take certain options into account. The command that controls a service — <code
                  class="command">service <em
                    class="replaceable">service</em> <em
                    class="replaceable">operation</em></code> — doesn't take runlevel into consideration, assumes (wrongly) that the service is currently being used, and may thus initiate incorrect operations (starting a service that was deliberately stopped, or stopping a service that is already stopped, etc.). Debian therefore introduced the <code
                  class="command">invoke-rc.d</code> program: this program must be used by maintainer scripts to run services initialization scripts and it will only execute the necessary commands. Note that, contrary to common usage, the <code
                  class="filename">.d</code> suffix is used here in a program name, and not in a directory.
			</div></div><div
              class="para">
				Finally, <code
                class="command">init</code> starts control programs for various virtual consoles (<code
                class="command">getty</code>). It displays a prompt, waiting for a username, then executes <code
                class="command">login <em
                  class="replaceable">user</em></code> to initiate a session.
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULARY</em></span> Console and terminal</strong></p></div></div></div><div
                class="para">
				The first computers were usually separated into several, very large parts: the storage enclosure and the central processing unit were separate from the peripheral devices used by the operators to control them. These were part of a separate furniture, the “console”. This term was retained, but its meaning has changed. It has become more or less synonymous with “terminal”, being a keyboard and a screen.
			</div><div
                class="para">
				With the development of computers, operating systems have offered several virtual consoles to allow for several independent sessions at the same time, even if there is only one keyboard and screen. Most GNU/Linux systems offer six virtual consoles (in text mode), accessible by typing the key combinations <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> through <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span>.
			</div><div
                class="para">
				By extension, the terms “console” and “terminal” can also refer to a terminal emulator in a graphical X11 session (such as <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code> or <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Poprzedni</strong>8.11. Installing a Kernel</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Początek rozdziału</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Spis treści</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Następny</strong>9.2. Remote Login</a></li></ul></body></html>
