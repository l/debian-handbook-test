<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.5. Không gian người dùng</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-vi-VN-1.0-1" /><meta
        name="keywords"
        content="BIOS, Nhân Kernel, Unix, Quá trình, Phân cấp, Các lệnh cơ bản" /><link
        rel="home"
        href="index.html"
        title="Sổ tay Quản trị Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Phụ lục B. Khoá bổ sung ngắn hạn" /><link
        rel="prev"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. Một số nhiệm vụ được xử lý bởi hạt nhân" /><link
        rel="next"
        href="backcover.html"
        title="Phụ lục C. Sổ tay Quản trị Debian" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/vi-VN/stable/sect.user-space.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Trước đó</strong></a></li><li
          class="home">Sổ tay Quản trị Debian</li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Kế tiếp</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.user-space"></a>B.5. Không gian người dùng</h2></div></div></div><a
          id="id-1.21.8.2"
          class="indexterm"></a><a
          id="id-1.21.8.3"
          class="indexterm"></a><div
          class="para">
			“Không gian người dùng“ đề cập đến môi trường thời gian chạy của các tiến trình bình thường (trái với hạt nhân). Điều này không có nghĩa là các tiến trình này thực sự bắt đầu bởi người dùng vì một hệ thống tiêu chuẩn thường có một số tiến trình “daemon“(hoặc nền) chạy trước khi người dùng mở một phiên làm việc. tiến trình daemon cũng được coi là tiến trình không gian người dùng.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.process-basics"></a>B.5.1. Quá trình</h3></div></div></div><a
            id="id-1.21.8.5.2"
            class="indexterm"></a><div
            class="para">
				Khi hạt nhân được vượt qua giai đoạn khởi tạo của nó, nó bắt đầu tiến trình đầu tiên,<code
              class="command">init</code>. tiến trình # 1 một mình rất hiếm khi hữu ích bởi chính nó, và các hệ thống giống Unix chạy với nhiều tiến trình bổ sung.
			</div><a
            id="id-1.21.8.5.4"
            class="indexterm"></a><div
            class="para">
				Trước tiên, một tiến trình có thể nhân bản chính nó (đây được gọi là<span
              class="emphasis"><em>fork</em></span>). Hạt nhân phân bổ một không gian bộ nhớ tiến trình mới (nhưng giống hệt nhau), và một tiến trình khác để sử dụng nó. Vào thời điểm này, sự khác biệt duy nhất giữa hai tiến trình này là<span
              class="emphasis"><em>pid</em></span>. tiến trình mới thường được gọi là tiến trình con, và tiến trình ban đầu mà<span
              class="emphasis"><em>pid</em></span>không thay đổi, được gọi là tiến trình cha.
			</div><div
            class="para">
				Đôi khi, tiến trình con tiếp tục thực thi hoạt động riêng của nó độc lập với tiến trình cha , với dữ liệu của chính nó được sao chép từ tiến trình cha. Trong nhiều trường hợp, tuy nhiên, tiến trình con này thực thi một chương trình khác. Với một vài ngoại lệ, bộ nhớ của nó chỉ đơn giản là thay thế bằng chương trình mới, và bắt đầu thực hiện chương trình mới này. Đây là cơ chế được sử dụng bởi tiến trình init (với tiến trình số 1) để bắt đầu dịch vụ bổ sung và thực hiện toàn bộ trình tự khởi động. Tại một số điểm, một tiến trình giữa các con của<code
              class="command">init</code>bắt đầu một giao diện đồ họa để người dùng đăng nhập vào (chuỗi các sự kiện thực tế được mô tả chi tiết trong<a
              class="xref"
              href="unix-services.html#sect.system-boot">Phần 9.1, “System Boot”</a>).
			</div><div
            class="para">
				Khi tiến trình hoàn thành nhiệm vụ mà nó đã được bắt đầu, nó sẽ kết thúc. Hạt nhân sẽ phục hồi bộ nhớ được gán cho tiến trình này, và ngừng lát thời gian chạy của nó. tiến trình cha được thông báo về tiến trình con của nó đang bị chấm dứt, cho phép tiến trình chờ đợi cho việc hoàn thành nhiệm vụ mà nó được ủy thác cho tiến trình con. Hành vi này được hiển thị rõ ràng trong trình biên dịch dòng lệnh (được gọi là <span
              class="emphasis"><em>shells</em></span>). Khi một lệnh được nhập vào một trình shell, dấu nhắc chỉ trở lại khi thực hiện lệnh đã kết thúc. Hầu hết các shell cho phép chạy lệnh dưới nền, đó là một vấn đề đơn giản để thêm một <strong
              class="userinput"><code>&amp;</code></strong> vào cuối lệnh. Dấu nhắc được hiển thị ngay lập tức, có thể dẫn đến các vấn đề nếu lệnh cần hiển thị dữ liệu của riêng nó.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.daemons"></a>B.5.2. Daemons tiến trình ẩn</h3></div></div></div><a
            id="id-1.21.8.6.2"
            class="indexterm"></a><a
            id="id-1.21.8.6.3"
            class="indexterm"></a><div
            class="para">
				Một daemon““là một tiến trình được bắt đầu tự động bởi trình tự khởi động. Nó tiếp tục chạy (trong nền) để thực hiện các nhiệm vụ bảo trì hoặc cung cấp các dịch vụ cho các tiến trình khác. “Nhiệm vụ nền“ này thực sự là tùy ý, và không phù hợp bất cứ điều gì đặc biệt từ quan điểm của hệ thống. Chúng chỉ đơn giản là các tiến trình , tương tự như các tiến trình khác, chúng sẽ chạy lần lượt khi thời gian của chúng đến. Sự phân biệt chỉ là vấn đề ngôn ngữ: một tiến trình chạy mà không có tương tác với người dùng (đặc biệt, không có giao diện đồ hoạ) được cho là đang chạy “ở chế độ nền“ hoặc “như daemon“.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>TỪ VỰNG</em></span>Daemon, quỷ, một thuật ngữ xúc phạm?</strong></p></div></div></div><div
              class="para">
				Mặc dù<span
                class="emphasis"><em>daemon</em></span>chia sẻ thuật ngữ Hy Lạp với<span
                class="emphasis"><em>demon</em></span>, nhưng nó không có nghĩa ác quỷ, thay vào đó, nó phải được hiểu là một loại tinh thần giúp đỡ . Sự phân biệt này là tinh tế trong tiếng Anh; Nó thậm chí còn tồi tệ hơn ở các ngôn ngữ khác mà cùng một từ được sử dụng cho cả hai nghĩa.
			</div></div><div
            class="para">
				Một số daemon như vậy được mô tả chi tiết trong<a
              class="xref"
              href="unix-services.html">Chương 9, <em>Unix Services</em></a>.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ipc"></a>B.5.3. Inter-Process Communications</h3></div></div></div><a
            id="id-1.21.8.7.2"
            class="indexterm"></a><a
            id="id-1.21.8.7.3"
            class="indexterm"></a><div
            class="para">
				Một tiến trình bị cô lập, dù là daemon hay một ứng dụng tương tác, hiếm khi hữu ích tự nó, đó là lý do tại sao có một số phương pháp cho phép các tiến trình riêng biệt giao tiếp với nhau, hoặc để trao đổi dữ liệu hoặc để kiểm soát lẫn nhau. Thuật ngữ chung đề cập đến vấn đề này là<span
              class="emphasis"><em>truyền thông nội bộ tiến trình</em></span>, hoặc gọi tắt là IPC.
			</div><div
            class="para">
				Hệ thống IPC đơn giản nhất là sử dụng các tệp. tiến trình muốn gửi dữ liệu thì ghi nó vào một tệp (có tên được biết trước), trong khi người nhận chỉ cần mở tệp và đọc nội dung của nó.
			</div><a
            id="id-1.21.8.7.6"
            class="indexterm"></a><div
            class="para">
				Trong trường hợp bạn không muốn lưu trữ dữ liệu trên đĩa, bạn có thể sử dụng một<span
              class="emphasis"><em>pipe</em></span>, mà chỉ đơn giản là một đối tượng với hai đầu; dữ liệu được viết bằng một đầu có thể đọc được ở đầu kia. Nếu điểm kết thúc được kiểm soát bởi các tiến trình riêng biệt, điều này dẫn đến một kênh truyền thông giữa các tiến trình đơn giản và thuận tiện. Ống có thể được phân thành hai loại: ống dẫn có tên, và ống nặc danh. Một đường ống có tên được đại diện bởi một mục nhập trên hệ thống tập tin (mặc dù dữ liệu truyền không được lưu trữ ở đó), vì vậy cả hai tiến trình có thể mở nó một cách độc lập nếu vị trí của ống tên là được biết đến trước. Trong trường hợp các tiến trình giao tiếp có liên quan (ví dụ như tiến trình cha và con), tiến trình cha cũng có thể tạo ra ống nặc danh trước khi gọi nó, và tiến trình con kế thừa nó. Cả hai tiến trình sau đó sẽ có thể trao đổi dữ liệu qua đường ống mà không cần hệ thống tập tin.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>THỰC HÀNH</em></span>Một ví dụ cụ thể</strong></p></div></div></div><div
              class="para">
				Hãy mô tả chi tiết những gì xảy ra khi một lệnh phức tạp (một<span
                class="emphasis"><em>pipeline</em></span>) được chạy từ trình bao. Chúng tôi giả sử rằng chúng ta có một tiến trình<code
                class="command">bash</code>(trình bao người dùng chuẩn trên Debian), với<span
                class="emphasis"><em>pid</em></span>4374; Vào trong trình bao này, chúng ta gõ lệnh:<code
                class="command">ls | sort</code>.
			</div><div
              class="para">
				Trình shell bash giải thích lệnh nhập vào. Trong trường hợp của chúng ta, nó hiểu rằng có hai chương trình (<code
                class="command">ls</code> và <code
                class="command">sort</code>), với luồng dữ liệu đang chảy Từ một đến khác (biểu thị bởi ký tự <strong
                class="userinput"><code>|</code></strong>, được gọi là <span
                class="emphasis"><em>pipe</em></span>).<code
                class="command">bash</code>tạo một đường dẫn không tên (ban đầu chỉ tồn tại trong tiến trình <code
                class="command">bash</code>).
			</div><div
              class="para">
				Sau đó shell sẽ tự nhân bản; Điều này dẫn đến tiến trình <code
                class="command">bash</code>mới, với<code
                class="command">pid</code># 4521 (<span
                class="emphasis"><em>pids</em></span>là con số trừu tượng, và nói chung Không có ý nghĩa đặc biệt). tiến trình # 4521 kế thừa đường ống, có nghĩa là nó có thể viết ở phía đầu vào của nó;<span
                class="emphasis"><em>bash</em></span>chuyển hướng dòng đầu ra tiêu chuẩn sang đầu vào của đường ống này. Sau đó, nó thực hiện (và thay thế nó bằng) chương trình<code
                class="command">ls</code>, liệt kê nội dung của thư mục hiện tại. Kể từ khi<code
                class="command">ls</code>viết vào đầu ra tiêu chuẩn của nó, và đầu ra này trước đây đã được chuyển hướng, kết quả được gửi hiệu quả vào đường ống.
			</div><div
              class="para">
				Một thao tác tương tự sẽ xảy ra cho lệnh thứ hai:<code
                class="command">bash</code>tự sao chép lại, dẫn đến một tiến trình<code
                class="command">bash</code>mới với pid # 4522. Vì nó cũng là một tiến trình con của # 4374, nó cũng thừa kế các đường ống;<code
                class="command">bash</code>sau đó kết nối đầu vào tiêu chuẩn của nó với đầu ra của ống, sau đó thực thi (và thay thế nó bằng) lệnh<code
                class="command">sort</code>, loại đầu vào của nó và hiển thị các kết quả.
			</div><div
              class="para">
				Tất cả tạo thành một bức tranh hoàn chỉnh:<code
                class="command">ls</code>đọc thư mục hiện tại và ghi danh sách các tập tin vào đường ống;<code
                class="command">sort</code>đọc danh sách này, phân loại theo thứ tự bảng chữ cái, và hiển thị kết quả. Các tiến trình # 4521 và # 4522 sau đó kết thúc, và # 4374 (đang chờ chúng trong tiến trình hoạt động), tiếp tục kiểm soát và hiển thị dấu nhắc để cho phép người dùng gõ lệnh mới.
			</div></div><div
            class="para">
				Mặc dù vậy, không phải tất cả các giao tiếp giữa các tiến trình được sử dụng để di chuyển dữ liệu xung quanh. Trong nhiều trường hợp, thông tin chỉ cần truyền là các thông báo điều khiển như“tạm dừng thực hiện“hoặc“tiếp tục thực hiện“. Unix (và Linux) cung cấp một cơ chế gọi là<span
              class="emphasis"><em>signals</em></span>, thông qua đó một tiến trình chỉ đơn giản có thể gửi một tín hiệu cụ thể (được chọn từ một danh sách các tín hiệu đã được xác định trước) sang một tiến trình khác. Yêu cầu duy nhất là phải biết mục tiêu của<span
              class="emphasis"><em>pid</em></span>.
			</div><div
            class="para">
				Đối với các giao tiếp phức tạp hơn, cũng có các cơ chế cho phép một tiến trình mở truy cập, hoặc chia sẻ, một phần của bộ nhớ được phân bổ của nó cho các tiến trình khác. Bộ nhớ hiện được chia sẻ giữa chúng có thể được sử dụng để di chuyển dữ liệu giữa các tiến trình .
			</div><div
            class="para">
				Cuối cùng, kết nối mạng cũng có thể giúp các tiến trình giao tiếp; Các tiến trình này thậm chí có thể chạy trên các máy tính khác nhau, có thể cách nhau hàng ngàn cây số.
			</div><div
            class="para">
				Tất cả được thiết kế theo chuẩn cho một hệ thống Unix điển hình sử dụng tất cả các cơ chế này theo các mức độ khác nhau.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.libraries"></a>B.5.4. Thư viện</h3></div></div></div><a
            id="id-1.21.8.8.2"
            class="indexterm"></a><div
            class="para">
				Các thư viện chức năng đóng một vai trò quan trọng trong một hệ điều hành giống Unix. Chúng không phải là các chương trình thích hợp, vì chúng không thể thực thi được mà là các bộ sưu tập các đoạn mã có thể được sử dụng bởi các chương trình chuẩn. Trong số các thư viện phổ biến, bạn có thể tìm thấy:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						Thư viện C tiêu chuẩn (<span
                    class="emphasis"><em>glibc</em></span>), chứa các chức năng cơ bản như mở tệp hoặc kết nối mạng, và một số khác hỗ trợ tương tác với hạt nhân;
					</div></li><li
                class="listitem"><div
                  class="para">
						Bộ công cụ đồ hoạ, như Gtk + và Qt, cho phép nhiều chương trình tái sử dụng các đối tượng đồ họa mà chúng cung cấp;
					</div></li><li
                class="listitem"><div
                  class="para">
						Thư viện<span
                    class="emphasis"><em>libpng</em></span>, cho phép tải, giải thích và lưu hình ảnh ở định dạng PNG.
					</div></li></ul></div><div
            class="para">
				Nhờ những thư viện, các ứng dụng có thể tái sử dụng mã hiện có. Phát triển ứng dụng được đơn giản hóa vì nhiều ứng dụng có thể sử dụng lại cùng chức năng. Với các thư viện thường được phát triển bởi những người khác nhau, sự phát triển toàn cầu của hệ thống gần với triết lý lịch sử của Unix.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>TƯ TƯỞNG</em></span>Thiết kế theo kiểu Unix: một điều tại một thời điểm</strong></p></div></div></div><div
              class="para">
				Một trong những khái niệm cơ bản nằm bên dưới hệ điều hành Unix là mỗi công cụ chỉ nên làm một việc và làm tốt; Các ứng dụng có thể sử dụng lại các công cụ này để xây dựng logic cao hơn trên đầu trang. Triết lý này có thể được nhìn thấy trong nhiều ứng dụng cụ thể. Shell script có thể là ví dụ tốt nhất: nó lắp ráp các chuỗi phức tạp của các công cụ rất đơn giản (như <code
                class="command">grep</code>, <code
                class="command">wc</code>,<code
                class="command">sort</code>, <code
                class="command">uniq</code> và vân vân ). Một ví dụ khác của triết lý này có thể được nhìn thấy trong các thư viện mã: thư viện <span
                class="emphasis"><em>libpng</em></span> cho phép đọc và viết các hình ảnh PNG, với các tùy chọn khác nhau và theo nhiều cách khác nhau, nhưng nó chỉ làm điều đó; Không có chức năng bao gồm các chức năng hiển thị hoặc chỉnh sửa hình ảnh.
			</div></div><div
            class="para">
				Hơn nữa, các thư viện này thường được gọi là“thư viện chia sẻ“, vì hạt nhân chỉ có thể nạp chúng vào bộ nhớ một lần, ngay cả khi một vài tiến trình sử dụng cùng một thư viện cùng một lúc. Điều này cho phép tiết kiệm bộ nhớ, khi so sánh với trường hợp ngược lại (giả thuyết) khi mà mã cho một thư viện sẽ được nạp nhiều lần như có tiến trình sử dụng nó.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Trước đó</strong>B.4. Một số nhiệm vụ được xử lý bởi hạt nhân</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Lên</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Đầu</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Kế tiếp</strong>Phụ lục C. Sổ tay Quản trị Debian</a></li></ul></body></html>
