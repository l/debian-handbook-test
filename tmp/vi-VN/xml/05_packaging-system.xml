<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="packaging-system" lang="vi-VN">
	<chapterinfo>
		 <keywordset>
			<keyword>Gói nhị phân</keyword>
			 <keyword>Gói mã nguồn</keyword>
			 <keyword>dpkg</keyword>
			 <keyword>dependencies</keyword>
			 <keyword>conflict</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Hệ thống gói: Công cụ và Nguyên tắc cơ bản</title>
	 <highlights> <para>
		Như một người quản trị hệ thống Debian, bạn sẽ thường xuyên làm việc với các gói <filename>.deb</filename>, vì chúng chứa các đơn vị chức năng (ứng dụng, tài liệu, etc.) trong việc cài đặt và bảo trì. Vì vậy, là một ý tưởng tốt để biết nó là gì và làm sao đế sử dụng nó.
	</para>
	 </highlights> <para>
		Chương này mô tả kiến trúc và nội dung của các gói “binary” và “source”. Định dạng các tệp tin <filename>.deb</filename>, sử dụng trực tiếp bởi <command>dpkg</command>, sau nữa là mã nguồn, cũng như hướng dẫn xây dựng các gói nhị phân.
	</para>
	 <section id="sect.binary-package-structure">
		<title>Cấu trúc của một Gói nhị phân</title>
		 <indexterm>
			<primary>package</primary>
			<secondary>binary package</secondary>
		</indexterm>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <para>
			Định dạng gói Debian được thiết kế sao cho nội dung của nó có thể giải nén trên bất kì hệ thống Unix nào bằng câu lệnh cơ bản <command>ar</command>, <command>tar</command>, and <command>gzip</command> (sometimes <command>xz</command> or <command>bzip2</command>). Tính năng dường như bình thường này lại quan trọng cho tính linh động và khôi phục thảm hoạ.
		</para>
		 <para>
			Thử tưởng tượng một ví dụ, rằng bạn đã lỡ xoá mất chương trình <command>dpkg</command>, và bạn không thể cài đặt các gói Debian. <command>dpkg</command> trở thành gói của chính nó, nó sẽ có vẻ như hệ thống của bạn được thực hiện cho... May mắn thay, bạn hiểu về định dạng của một gói và bạn có thể tải tệp <filename>*.deb</filename> của gói <emphasis role="pkg">dpkg</emphasis> và cài đặt nó bình thường (xem sidebar <xref linkend="sidebar.dpkg-apt-ar" />). Nếu thiếu một hoặc nhiều các chương trình <command>ar</command>, <command>tar</command> hoặc <command>gzip</command>/<command>xz</command>/<command>bzip2</command>, bạn sẽ chỉ cần sao chép chương trình thiếu từ một hệ thống khác (vì mỗi gói là một chương trình hoàn chỉnh, không phụ thuộc, một bản sao là đủ). Nếu hệ thống của bạn đã bị thiếu tài nguyên cần thiết, và thậm chí hệ thống không làm việc (có thể các thư viện sâu của hệ thống bị thiếu?), bạn có thể thử các phiên bản tĩnh của <command>busybox</command> (đã cung cấp trong gói <emphasis role="pkg">busybox-static</emphasis> package), mà thậm chí còn nhiều hơn, cung cấp các câu lệnh con trên chính nó như <command>busybox ar</command>, <command>busybox tar</command> và <command>busybox gunzip</command>.
		</para>
		 <sidebar id="sidebar.dpkg-apt-ar"> <title><emphasis>Các công cụ</emphasis> <command>dpkg</command>, <command>APT</command> and <command>ar</command></title>
		 <indexterm>
			<primary><command>dpkg</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <indexterm>
			<primary>APT</primary>
		</indexterm>
		 <para>
			<command>dpkg</command> là chương trình xử lý tệp tin <filename>.deb</filename>, chủ yếu cài đặt, phân tích và giải nén các tập tin.
		</para>
		 <para>
			<command>APT</command> là một nhóm các chương trình cho phép thực hiện các thay đổi cấp cao hơn tới hệ thống: cài đặt và xoá một gói (trong khi giữ phụ thuộc một cách tốt), cập nhật hệ thống, liệt kê các gói đã có, vân vân.
		</para>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <para>
			Đối với chương trình <command>ar</command>, cho phép xử lý tệp tin như: <command>ar t <replaceable>archive</replaceable></command> hiển thị danh sách các tệp tin ở trong một archive, <command>ar x <replaceable>archive</replaceable></command> giải nén các file từ archive vào thư mục đang làm việc, <command>ar d <replaceable>archive</replaceable> <replaceable>file</replaceable></command> xoá một tệp tin từ archive, vân vân. Trang hướng dấn tất cả tính năng khác của lệnh này (<citerefentry><refentrytitle>ar</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry>). <command>ar</command> là một công cụ rất thô sơ mà một quản trị Unix sử dụng hiếm hoi. Nhưng các quản trị thường xuyên sử dụng <command>tar</command>, một chương trình quản lý và lưu trữ files phát triển hơn. Đây là lý do tịa sao nó rất dễ để khôi phục <command>dpkg</command> khi có sai sot nào đó. Bạn có thể chỉ cần tài gói Debian và giải nén nội dung từ tệp lưu trữ <filename>data.tar.gz</filename> vào thư mục gốc (<filename>/</filename>) của hệ thống:
		</para>
		 
<screen>
<computeroutput># </computeroutput><userinput>ar x dpkg_1.17.23_amd64.deb</userinput>
<computeroutput># </computeroutput><userinput>tar -C / -p -xzf data.tar.gz</userinput></screen>
		 </sidebar> <sidebar> <title><emphasis>Trở về cơ bản</emphasis> Man page notation</title>
		 <para>
			Có thể nhầm lần cho người mới bắt đầu để tham chiếu tới “<citerefentry><refentrytitle>ar</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry>” trong các tài liệu. Đây là thường là một phương tiện tiện lợi để tham chiếu tới trang tài liệu <literal>ar</literal> trong nội dung 1.
		</para>
		 <para>
			Đôi khi những ký hiệu này cũng được sử dụng để loại bỏ những mơ hồ, ví dụ phân biệt giữa lệnh <command>printf</command> lệnh này có thể cũng được chỉ ra bởi <citerefentry><refentrytitle>printf</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry> và hàm <function>printf</function> trong ngôn ngữ lập trình C, có thể được tham chiếu bằng <citerefentry><refentrytitle>printf</refentrytitle>
			<manvolnum>3</manvolnum></citerefentry>.
		</para>
		 <para>
			<xref linkend="solving-problems" /> thảo luận về trang hương dẫn chi tiết hơn (see <xref linkend="sect.manual-pages" />).
		</para>
		 </sidebar> <para>
			Cái nhìn về nội dung trong tệp tin <filename>.deb</filename>
		</para>
		 
<screen><computeroutput>$ </computeroutput><userinput>ar t dpkg_1.17.23_amd64.deb</userinput>
<computeroutput>debian-binary
control.tar.gz
data.tar.gz
$ </computeroutput><userinput>ar x dpkg_1.17.23_amd64.deb</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>control.tar.gz  data.tar.gz  debian-binary  dpkg_1.17.23_amd64.deb
$ </computeroutput><userinput>tar tzf data.tar.gz | head -n 15</userinput>
<computeroutput>./
./var/
./var/lib/
./var/lib/dpkg/
./var/lib/dpkg/parts/
./var/lib/dpkg/info/
./var/lib/dpkg/alternatives/
./var/lib/dpkg/updates/
./etc/
./etc/logrotate.d/
./etc/logrotate.d/dpkg
./etc/dpkg/
./etc/dpkg/dpkg.cfg.d/
./etc/dpkg/dpkg.cfg
./etc/alternatives/
$ </computeroutput><userinput>tar tzf control.tar.gz</userinput>
<computeroutput>./
./conffiles
./postinst
./md5sums
./prerm
./preinst
./control
./postrm
$ </computeroutput><userinput>cat debian-binary</userinput>
<computeroutput>2.0</computeroutput></screen>
		 <para>
			Như bạn có thể thấy, với góc nhìn qua tệp nén từ lệnh <command>ar</command> của một gói Debian gồm có ba tập tin:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					<filename>debian-binary</filename>. Đây là một tệp văn bản đơn thuần mà chỉ ra phiên bản của tệp <filename>.deb</filename> đã sử dụng (từ năm 2015: version 2.0).
				</para>

			</listitem>
			 <listitem>
				<para>
					<filename>control.tar.gz</filename>. Đây là tệp nén chứa tất cả thông tin meta, giống như tên và phiên bản của gói. Một vài thông tin cho phép các công cụ quản lý gói xác định nếu nó có thể cài đặt hoặc gỡ bỏ được nó, ví dụ thể hiện danh sách các gói đã có trên máy tính.
				</para>

			</listitem>
			 <listitem>
				<para>
					<filename>data.tar.gz</filename>. Đây là tệp nén chứa tất cả các tệp tin đã được xuất từ gói; đây là nơi các tệp thực thi, tài liệu, vân vân., được lưu trữ. Vài các gói có thể sử dụng bởi chuẩn nén khách, trong trường hợp đó tệp sẽ có tên khác (<filename>data.tar.bz2</filename> cho bzip2, <filename>data.tar.xz</filename> cho XZ).
				</para>

			</listitem>

		</itemizedlist>

	</section>
	 <section id="sect.package-meta-information">
		<title>Package Meta-Information</title>
		 <indexterm>
			<primary>package meta-information</primary>
		</indexterm>
		 <indexterm>
			<primary>package</primary>
			<secondary>meta-information</secondary>
		</indexterm>
		 <para>
			Gói Debian không chỉ là một lưu trữ của các tệp tin dành cho cài đặt. Nó là một phần tổng thể lớn hơn, và nó mô tả mối quan hệ với các gói Debian khác (phụ thuộc, xung đột hay gợi ý). Nó còn cung cấp các kịch bản cho phép thực hiện các câu lệnh ở các giai đoạn khác nhau trong vòng đời của gói (cài đặt, gỡ bỏ và nâng cấp). Các dữ liệu này được sử dụng bởi trình quản lý gói nhưng không phải là một phần của phần mềm đóng gói; những dữ liệu trong gói, được gọi với tên là “meta-information” (thông tin về các thông tin khác).
		</para>
		 <section id="sect.control">
			<title>Mô tả: tệp tin <filename>control</filename></title>
			 <indexterm>
				<primary>package meta-information</primary>
			</indexterm>
			 <indexterm>
				<primary>package</primary>
				<secondary>meta-information</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>control</filename></primary>
			</indexterm>
			 <para>
				Tệp này sử dụng một cấu trúc giống như headers của email (định nghĩa ở RFC 2822). Ví dụ, cho gói <emphasis role="pkg">apt</emphasis>, tệp tin <filename>control</filename> trông giống như sau:
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>apt-cache show apt</userinput>
<computeroutput>Package: apt
Version: 1.0.9.6
Installed-Size: 3788
Maintainer: APT Development Team &lt;deity@lists.debian.org&gt;
Architecture: amd64
Replaces: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0)
Depends: libapt-pkg4.12 (&gt;= 1.0.9.6), libc6 (&gt;= 2.15), libgcc1 (&gt;= 1:4.1.1), libstdc++6 (&gt;= 4.9), debian-archive-keyring, gnupg
Suggests: aptitude | synaptic | wajig, dpkg-dev (&gt;= 1.17.2), apt-doc, python-apt
Conflicts: python-apt (&lt;&lt; 0.7.93.2~)
Breaks: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0)
Description-en: commandline package manager
 This package provides commandline tools for searching and
 managing as well as querying information about packages
 as a low-level access to all features of the libapt-pkg library.
 .
 These include:
  * apt-get for retrieval of packages and information about them
    from authenticated sources and for installation, upgrade and
    removal of packages together with their dependencies
  * apt-cache for querying available information about installed
    as well as installable packages
  * apt-cdrom to use removable media as a source for packages
  * apt-config as an interface to the configuration settings
  * apt-key as an interface to manage authentication keys
Description-md5: 9fb97a88cb7383934ef963352b53b4a7
Tag: admin::package-management, devel::lang:ruby, hardware::storage,
 hardware::storage:cd, implemented-in::c++, implemented-in::perl,
 implemented-in::ruby, interface::commandline, network::client,
 protocol::ftp, protocol::http, protocol::ipv6, role::program,
 role::shared-lib, scope::application, scope::utility, sound::player,
 suite::debian, use::downloading, use::organizing, use::searching,
 works-with::audio, works-with::software:package, works-with::text
Section: admin
Priority: important
Filename: pool/main/a/apt/apt_1.0.9.6_amd64.deb
Size: 1107560
MD5sum: a325ccb14e69fef2c50da54e035a4df4
SHA1: 635d09fcb600ec12810e3136d51e696bcfa636a6
SHA256: 371a559ce741394b59dbc6460470a9399be5245356a9183bbeea0f89ecaabb03</computeroutput></screen>
			 <sidebar> <title><emphasis>QUAY VỀ CƠ BẢN</emphasis> RFC — Các chuẩn Internet</title>
			 <indexterm>
				<primary>RFC</primary>
			</indexterm>
			 <indexterm>
				<primary>Request For Comments</primary>
			</indexterm>
			 <para>
				RFC là viết tắt của “Request For Comments”. Một RFC nói chung là một tài liệu kỹ thuật mô tả những gì sẽ trở thành một tiêu chuẩn Internet. Trước khi trở thành tiêu chuẩn hóa và đóng băng, các tiêu chuẩn này được gửi cho công cộng xem xét (đó là lý do đặt tên). IETF (Internet Engineering Task Force) quyết định về sự chuyển đổi các trạng thái của các tài liệu (tiêu chuẩn đề xuất, dự thảo tiêu chuẩn, hoặc tiêu chuẩn).
			</para>
			 <para>
				RFC 2026 định nghĩa quá trình tiêu chuẩn hóa của các giao thức Internet. <ulink type="block" url="http://www.faqs.org/rfcs/rfc2026.html" />
			</para>
			 </sidebar> <section>
				<title>Các phụ thuộc: trường <literal>Depends</literal></title>
				 <indexterm>
					<primary>dependency</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Depends</literal>, header field</primary>
				</indexterm>
				 <indexterm>
					<primary>package</primary>
					<secondary>dependency</secondary>
				</indexterm>
				 <para>
					Các phụ thuộc được định nghĩa ở trường <literal>Depends</literal> trong tiêu đề gói. Đây là danh sách các điều kiện để đáp ứng cho các gói làm việc chính xác - thông tin này được sử dụng bởi các công cụ như <command>apt</command> để cài đặt các thư viện cần thiết, với các phiên bản thích hợp phù hợp với các sự phụ thuộc của gói được cài đặt. Đối với mỗi phụ thuộc, nó có thể hạn chế phạm vi của các phiên bản đáp ứng được điều kiện đó. Nói cách khác, nó có thể để bày tỏ một thực tế rằng chúng ta cần gói <emphasis role="pkg">libc6</emphasis> trong một phiên bản tương đương hoặc lớn hơn “2.15” (viết “<command>libc6 (&gt;= 2.15)</command>”). Toán tử so sánh phiên bản như sau:
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							<command>&lt;&lt;</command>: bé hơn;
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&lt;=</command>: bé hơn hoặc bằng;
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>=</command>: bằng (hãy nhớ “<literal>2.6.1</literal>” không bằng với “<literal>2.6.1-1</literal>”);
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&gt;=</command>: lớn hơn hoặc bằng;
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&gt;&gt;</command>: lớn hơn.
						</para>

					</listitem>

				</itemizedlist>
				 <para>
					Trong danh sách các điều kiện cần đáp ứng, các dấu phẩy xem như là một dấu phân cách. Nó phải được hiểu như là toán tử logic “and”. Trong các điều kiện, các thanh dọc (“|”) thể hiện là một toán tử logic “or” (đó là phép hội “or”, không phải là hoặc cái này hoặc cái kia độc quyền “either/or”). Phép “and” được ưu tiên hơn, nó có thể được sử dụng như nhiều lần khi cần thiết. Do đó, sự phụ thuộc “(A or B) and C” được viết <command>A | B, C</command>. Ngược lại, khái niệm “A or (B and C)” nên viết là “(A or B) and (A or C)”, khi trường <literal>Depends</literal> không có dấu ngoặc mà thay đổi thứ tự ưu tiên giữa các toán tử logic “or” and “and”. Như vậy sẽ được viết thành <command>A | B, A | C</command>. <ulink type="block" url="http://www.debian.org/doc/debian-policy/ch-relationships.html" />
				</para>
				 <indexterm>
					<primary>meta-package</primary>
				</indexterm>
				 <para>
					Hệ thống phụ thuộc là một cơ chế tốt để đảm bảo các hoạt động của một chương trình, nhưng nó còn sử dụng cho “meta-packages”. Đây là gói không chứa nội dung chương trình mà chỉ mô tả phụ thuộc. Nó tạo điều kiện cho quá trình cài đặt của một nhóm các chương trình được phù hợp chọn trước bởi nhà bảo trì meta-package; như vậy, <command>apt install <replaceable>meta-package</replaceable></command> sẽ tự động cài đặt tất cả các chương trình sử dụng các phụ thuộc của meta-package. Các gói <emphasis role="pkg">gnome</emphasis>, <emphasis role="pkg">kde-full</emphasis> and <emphasis role="pkg">linux-image-amd64</emphasis> là ví dụ của meta-packages.
				</para>
				 <sidebar> <title><emphasis>DEBIAN POLICY</emphasis> <literal>Pre-Depends</literal>, một đòi hỏi nhiều hơn <literal>Depends</literal></title>
				 <indexterm>
					<primary><literal>Pre-Depends</literal>, trường header</primary>
				</indexterm>
				 <indexterm>
					<primary>pre-dependency</primary>
				</indexterm>
				 <para>
					“Pre-dependencies”, mà được liệt kê ở trường “<literal>Pre-Depends</literal>” trong tiêu đề gói, ổn định cho sự phụ thuộc bình thường; cú pháp của là giống hệt nhau. Một phụ thuộc bình thường chỉ ra rằng các gói trong trường cần phải được giải nén và cấu hình trước khi cấu hình của gói tuyên bố sự phụ thuộc. Một tiền phụ thuộc (pre) quy định rằng các gói trong trường của nó cần phải được giải nén và cấu hình trước khi thực hiện các kịch bản cài đặt sẵn của gói tuyên bố của tiền phụ thuộc, đó là trước khi cài đặt của nó.
				</para>
				 <para>
					Một phụ thuộc trước là rất cần thiết cho <command>apt</command>, vì nó thêm một hạn chế nghiêm ngặt về thứ tự các gói để cài đặt. Vì vậy, các phụ thuộc trước không được khuyến khích trừ khi thật sự cần thiết. Thậm chí còn khuyến khích tham khảo các ý kiến từ các nhà phát triển trên <email>debian-devel@lists.debian.org</email> trước khi thêm một tiền phụ thuộc. Thường có thể tìm thấy giải pháp khác xung quanh vấn đề đấy.
				</para>
				 </sidebar> <sidebar> <title><emphasis>DEBIAN POLICY</emphasis> <literal>Recommends</literal>, <literal>Suggests</literal>, và <literal>Enhances</literal> fields</title>
				 <indexterm>
					<primary><literal>Recommends</literal>, trường header</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Suggests</literal>, trường header</primary>
				</indexterm>
				 <para>
					Trường <literal>Recommends</literal> và <literal>Suggests</literal> mô tả các sự phụ thuộc mà không bắt buộc. Trường “recommended”, quan trọng nhất, cải thiện đáng kể các chức năng được cung cấp bởi các gói nhưng không phải là không thể thiếu để hoạt động. Trường “suggested”, quan trọng thứ 2, chỉ ra rằng gói nhất định có thể bổ sung và tăng tiện ích của mình, nhưng nó là hoàn toàn hợp lý để cài đặt một mà không có những cái khác.
				</para>
				 <para>
					Bạn nên thường xuyên cài đặt các gói “recommended”, trừ khi bạn biết chính xác tại sao bạn không cần chúng. Ngược lại, bạn không cần thiết phải cài đặt các gói “suggested” trừ khi bạn biết tại sao bạn cần chúng.
				</para>
				 <indexterm>
					<primary><literal>Enhances</literal>, trường</primary>
				</indexterm>
				 <para>
					Trường <literal>Enhances</literal> cũng miêu tả một sự gợi ý, nhưng có một điều khác biệt. Nó thực sự nằm trong các gói gợi ý, và không có các lợi ích từ sự gợi ý này. Quan tâm của nó nằm ở chỗ có thểm thêm các gợi ý mà không sửa đổi các gói phần mềm liên quan. Do đó, tất cả các add-on, plug-ins, và các thành phần mở rộng khác của một chương trình có thể xuất hiện ở trường này. Mặc dầu nó đã tồn tại trong vài năm, nhưng trường này vẫn bị bỏ qua bởi các chương trình như <command>apt</command> hoặc <command>synaptic</command>. Mục đích của nó cho một sự gợi ý từ trường <literal>Enhances</literal> cho người dùng trong tìm ra trường <literal>Enhances</literal>.
				</para>
				 </sidebar>
			</section>
			 <section>
				<title>Xung đột: trường <literal>Conflicts</literal></title>
				 <indexterm>
					<primary>conflicts</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Conflicts</literal>, trường header</primary>
				</indexterm>
				 <indexterm>
					<primary>package</primary>
					<secondary>conflict</secondary>
				</indexterm>
				 <para>
					Trường <literal>Conflicts</literal> chỉ ra rằng khi một gói không thể cài đặt trong trường hơp với gói khác. Phần lớn lý do chung cho vấn đề này là cả hai gói đều bao gốm giống tên nhau, hoặc cung cấp các dịch vụ như nhau ở cùng cổng TCP, hoặc sẽ cản trở hoạt động của gói kia.
				</para>
				 <para>
					<command>dpkg</command> sẽ từ chối cài đặt một gói nếu nó gây xung đột với một trong các gói đã cài đặt, ngoại trừ gói mới đặc biệt nó sẽ “thay thế” gói đã cài đặt, trong trường hợp <command>dpkg</command> sẽ chọn để thay thế gói cũ với gói mới, nó sẽ tự động đề nghị gỡ bỏ gói có vẻ có vấn đề.
				</para>

			</section>
			 <section>
				<title>Không tương thích: trường <literal>Breaks</literal></title>
				 <indexterm>
					<primary>incompatibilities</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Breaks</literal>, header trường</primary>
				</indexterm>
				 <indexterm>
					<primary>package</primary>
					<secondary>không tương thích</secondary>
				</indexterm>
				 <para>
					Trường <literal>Breaks</literal> có tác dụng khá giống với trường <literal>Conflicts</literal>, nhưng với một nghĩa đặc biệt. Nó báo hiệu rằng nếu cài đặt gói này sẽ “làm hỏng” gói khác (hoặc cụ thể là phiên bản của nó). Nói chung, sự không thương thích này giữa hai gói là tạm thời, và trường <literal>Breaks</literal> quan hệ đặc biệt với các phiên bản không tương thích.
				</para>
				 <para>
					<command>dpkg</command> sẽ từ chối cài đặt một gói nếu nó làm hỏng một gói đã cài đặt, và <command>apt</command> sẽ cố giải quyết vấn đề bằng cách cập nhật gói đó lên phiên bản mới nhất (đây là giả định sẽ sửa được và do vậy lại tương thích).
				</para>
				 <para>
					Tình hình này có thể xảy ra trong trường hợp cập nhật mà không tương thích ngược: Trong trường hợp này nếu phiên bản mới hơn không còn các chức năng như phiên bản cũ, và gây ra một sự cố trong chương trình khác mà không làm gì đặc biệt. Trường <literal>Breaks</literal> ngăn cản người dùng gặp cả những vấn đề này.
				</para>

			</section>
			 <section>
				<title>Cung cấp Các mục: Trường <literal>Provides</literal></title>
				 <indexterm>
					<primary><literal>Provides</literal>, trường header</primary>
				</indexterm>
				 <para>
					Trường này giới thiệu khái niệm rất thú vị của một “gói ảo”. Nó có nhiều vai trò, nhưng hai trong số đó là quan trọng nhất. Vai trò thứ nhất bao gồm trong sử dụng gói để liên kết với một dịch vụ chung với nó (gói “cung cấp” dịch vụ). Vai trò thứ hai chỉ ra rằng một gói hoàn toàn thay thế một gói khác, và do mục đích này mà nó cũng có thể đáp ứng các phụ thuộc mà gói kia đáp ứng. Do đó có khả năng tạo ra một gói thay thế mà không cần sử dụng cùng tên gói.
				</para>
				 <sidebar> <title><emphasis>VOCABULARY</emphasis> Meta-package và virtual package</title>
				 <indexterm>
					<primary>meta-package</primary>
				</indexterm>
				 <indexterm>
					<primary>package</primary>
					<secondary>virtual package</secondary>
				</indexterm>
				 <indexterm>
					<primary>virtual package</primary>
				</indexterm>
				 <para>
					Cần phân biệt rõ ràng các gói meta từ các gói ảo. Trước đây là các gói thực (bao gồm các tập tin thực <filename>.deb</filename>), mà mục đích duy nhất của nó là để thể hiện sự phụ thuộc.
				</para>
				 <para>
					Các gói ảo, tuy nhiên, không tồn tại về mặt thể chất; chúng chỉ mang nghĩa để xác định các gói thực dựa trên các tiêu chí chung, hợp lý (cung cấp dịch vụ, khả năng tương thích với một chương trình chuẩn hoặc một có sẵn trước, vv).
				</para>
				 </sidebar> <section>
					<title>Đang cung cấp một “Service”</title>
					 <para>
						Chúng ta sẽ thảo luận về trường hợp đầu tiên chi tiết hơn với một ví dụ: tất cả máy chủ mail, ví dụ như <emphasis role="pkg">postfix</emphasis> hoặc <emphasis role="pkg">sendmail</emphasis> “cung cấp” gói <emphasis role="pkg">mail-transport-agent</emphasis> ảo. Thế nên, bất kỳ gói nào cần dịch vụ này để làm tính năng (ví dụ: quản lý mailing list, hay như là <emphasis role="pkg">smartlist</emphasis> hoặc <emphasis role="pkg">sympa</emphasis>) đơn giản là chỉ cần chỉ định phụ thuộc của nó yêu cầu một <emphasis role="pkg">mail-transport-agent</emphasis> thay vi chỉ định một danh sách lớn các giải pháp có thể (ví dụ: <command>postfix | sendmail | exim4 | …</command>). Hơn nữa, không cần thiết phải cài đặt hai máy chủ mail trên cùng một máy, đó là lý do mỗi gói này tuyên bố xung đột với gói ảo <emphasis role="pkg">mail-transport-agent</emphasis>. Một xung đột giữ gói của chính nó sẽ bị hệ thống bỏ qua nhưng kỹ thuật này sẽ cấm cài đặt hai máy chủ mail song song.
					</para>
					 <sidebar> <title><emphasis>DEBIAN POLICY</emphasis> Danh sách các gói ảo</title>
					 <indexterm>
						<primary>package</primary>
						<secondary>virtual package</secondary>
					</indexterm>
					 <para>
						Đối với các gói ảo là hữu ích, tất cả mọi người phải đồng ý về tên của chúng, đây là lý do tại sao chúng được tiêu chuẩn hóa trong Chính sách Debian, trong đó có một số khác<emphasis role="pkg">mail-transport-agent</emphasis> cho máy chủ mail, <emphasis role="pkg">c-compiler</emphasis> cho trình biên dịch ngôn ngữ lập trình C, u<emphasis role="pkg">www-browser</emphasis> cho các trình duyệt web, <emphasis role="pkg">httpd</emphasis> cho các máy chủ web, <emphasis role="pkg">ftp-server</emphasis> cho máy chủ FTP, u<emphasis role="pkg">x-terminal-emulator</emphasis> cho trình mô phỏng thiết bị đầu cuối ở chế độ đồ hoạ (<command>xterm</command>), và <emphasis role="pkg">x-window-manager</emphasis> cho các trình quản lý cửa sổ.
					</para>
					 <para>
						Danh sách đầy đủ có thể được tìm thấy trên Web. <ulink type="block" url="http://www.debian.org/doc/packaging-manuals/virtual-package-names-list.txt" />
					</para>
					 </sidebar>
				</section>
				 <section>
					<title>Khả năng trao đổi với một Gói khác</title>
					 <para>
						Trường <literal>Provides</literal> cũng thú vị khi nội dung của một gói được bao gồm trong một gói lớn hơn. Lấy ví dụ: <emphasis role="pkg">libdigest-md5-perl</emphasis> Mô đun Perl là một mô đun tùy chọn trong Perl 5.6 và đã được tích hợp theo chuẩn ở Perl 5.8 (và các phiên bản sau này, như 5.20 có trong <emphasis role="distribution">Jessie</emphasis>). Gói <emphasis role="pkg">perl</emphasis> kể từ phiên bản 5.8 đã tuyên bố <literal>Provides: libdigest-md5-perl</literal> để các gói phụ thuộc gói này được đáp ứng nếu người dùng có Perl 5.8 (hoặc mới hơn), gói <emphasis role="pkg">libdigest-md5-perl</emphasis> cuối cùng đã bị xóa, vì nó không còn có mục đích nào khi các phiên bản Perl cũ bị xóa.
					</para>
					 <figure>
						<title>Sử dụng trường <literal>Provides</literal> để không phá vỡ sự phụ thuộc</title>
						 <mediaobject>
							<imageobject>
								<imagedata fileref="images/virtual-package.png" format="PNG" width="50%" />
							</imageobject>

						</mediaobject>

					</figure>
					 <para>
						Tính năng này rất hữu ích vì không thể lường trước được sự biến động của sự phát triển và cần phải có khả năng điều chỉnh để đổi tên và thay thế tự động các phần mềm đã lỗi thời.
					</para>
					 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Perl, một ngôn ngữ lập trình</title>
					 <indexterm>
						<primary>Perl</primary>
					</indexterm>
					 <indexterm>
						<primary>CPAN</primary>
					</indexterm>
					 <para>
						Perl (Practical Extraction and Report Language) là một ngôn ngữ lập trình rất phổ biến. Nó có nhiều mô đun sẵn sàng để sử dụng, bao gồm một loạt các ứng dụng rộng lớn và được phân phối bởi các máy chủ CPAN (Mạng Toàn diện Perl Archive), một mạng lưới đầy đủ các gói Perl. <ulink type="block" url="http://www.perl.org/" /> <ulink type="block" url="http://www.cpan.org/" />
					</para>
					 <para>
						Vì nó là một ngôn thông dịch nên một chương trình được viết bằng Perl không yêu cầu biên dịch trước khi thực hiện. Đây là lý do tại sao chúng được gọi là “các kịch bản Perl”.
					</para>
					 </sidebar>
				</section>
				 <section>
					<title>Hạn chế trong Quá khứ</title>
					 <para>
						Các gói ảo được sử dụng để bị một số hạn chế, đáng kể nhất là không có số phiên bản. Trở lại ví dụ trước, một sự phụ thuộc như <literal>Depends: libdigest-md5-perl (&gt;= 1.6)</literal>, bất chấp sự có mặt của Perl_5.10, sẽ không bao giờ được coi là thỏa mãn bởi hệ thống gói - trong khi trên thực tế nó rất có thể là thỏa mãn. Không biết về điều này, hệ thống gói đã chọn lựa chọn ít rủi ro nhất, giả định rằng các phiên bản không khớp.
					</para>
					 <para>
						Giới hạn này đã được bỏ trong <emphasis role="pkg">dpkg</emphasis>1.17.11 và không còn liên quan đến Jessie. Gói có thể gán một phiên bản cho gói ảo mà chúng cung cấp với sự phụ thuộc như <literal role="pkg">Provides: libdigest-md5-perl (= 1.8)</literal>.
					</para>

				</section>

			</section>
			 <section>
				<title>Thay thế Các tệp: Trường <literal>Replaces</literal></title>
				 <indexterm>
					<primary>replacement</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Replaces</literal>, trường tiêu đề </primary>
				</indexterm>
				 <indexterm>
					<primary>package</primary>
					<secondary>replacement</secondary>
				</indexterm>
				 <para>
					Trường <literal>Replaces</literal> chỉ ra rằng gói chứa các tệp có trong gói khác nhưng gói đó có quyền thay thế chúng một cách hợp pháp. Nếu không sử dụng đặc tả này, <literal>dpkg</literal> sẽ báo lỗi, nó không thể ghi đè lên các tệp của một gói khác (về mặt kỹ thuật, dĩ nhiên có thể buộc nó làm như vậy với tùy chọn <literal>--force-overwrite</literal>, nhưng đó không phải là cách hay). Điều này cho phép xác định các vấn đề tiềm ẩn và yêu cầu người bảo trì phải nghiên cứu vấn đề trước khi lựa chọn có nên thêm vào một trường như thế hay không.
				</para>
				 <para>
					Việc sử dụng trường này là hợp lý khi tên gói thay đổi hoặc khi gói được bao gồm trong một gói khác. Điều này cũng xảy ra khi người bảo trì quyết định phân phối các tệp tin khác nhau giữa các gói nhị phân khác nhau được tạo ra từ cùng một gói nguồn: tệp được thay thế không còn thuộc về gói cũ nữa, nhưng chỉ cần tệp thay thế mới.
				</para>
				 <para>
					Nếu tất cả các tệp trong gói được cài đặt đã được thay thế, gói được coi là đã bị xóa. Cuối cùng, trường này cũng khuyến khích <command>dpkg</command> để gỡ bỏ gói thay thế nơi có sự xung đột.
				</para>
				 <sidebar id="sidebar.debtags"> <title><emphasis>GOING FURTHER</emphasis> Trường <literal>Tag</literal></title>
				 <para>
					Trong ví dụ <emphasis role="pkg">apt</emphasis> ở trên, chúng ta có thể thấy sự hiện diện của một trường mà chúng ta chưa mô tả, trường <literal>Tag</literal>. Trường này không mô tả mối quan hệ giữa các gói, nhưng chỉ đơn giản là một cách phân loại một gói theo một chủ đề. Việc phân loại các gói theo một số tiêu chí (kiểu giao diện, ngôn ngữ lập trình, miền ứng dụng, vv) đã có sẵn trong một thời gian dài. Mặc dù vậy, không phải tất cả các gói có thẻ chính xác và nó chưa được tích hợp trong tất cả các công cụ của Debian; <command>aptitude</command> hiển thị các thẻ này và cho phép chúng được sử dụng làm tiêu chí tìm kiếm. Đối với những người bị không thích tiêu chí tìm kiếm của <command>aptitude</command>, trang web sau đây cho phép điều hướng cơ sở dữ liệu của thẻ: <ulink type="block" url="http://debtags.alioth.debian.org/" />
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.configuration-scripts">
			<title>Kịch bản Cấu hình</title>
			 <indexterm>
				<primary><filename>postinst</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>preinst</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>postrm</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>prerm</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>control.tar.gz</filename></primary>
			</indexterm>
			 <para>
				Ngoài tệp <filename>control</filename>, tệp nén <filename>control.tar.gz</filename> của mỗi gói Debian có thể chứa một số kịch bản, được gọi bởi <command>dpkg</command> ở các giai đoạn khác nhau trong việc xử lý gói. Chính sách Debian mô tả có thể có nhiều trường hợp chi tiết, xác định các kịch bản được gọi và các đối số mà chúng nhận được. Các thực hiện kịch bản này có thể phức tạp, vì nếu một trong các kịch bản không thành công, <command>dpkg</command> sẽ cố gắng trở lại trạng thái trước bằng cách hủy bỏ quá trình cài đặt hoặc xóa bỏ tiến trình (trong chừng mực có thể).
			</para>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> cơ sở dữ liệu của <command>dpkg</command></title>
			 <indexterm>
				<primary><filename>/var/lib/dpkg/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>dpkg</primary>
				<secondary>database</secondary>
			</indexterm>
			 <para>
				Tất cả các kịch bản cấu hình cho các gói đã được cài đặt đều được lưu trữ trong thư mục <filename>/var/lib/dpkg/info/</filename>, dưới dạng một tập tin được đặt tên với tiền tố là tên của gói. Thư mục này cũng bao gồm một tệp có phần mở rộng <filename>.list</filename> cho mỗi gói, chứa danh sách các tệp thuộc gói đó.
			</para>
			 <para>
				Tệp tin <filename>/var/lib/dpkg/status</filename> chứa một loạt các khối dữ liệu (theo định dạng của tiêu đề thư nổi tiếng, RFC 2822) mô tả trạng thái của mỗi gói. Thông tin từ tệp tin <filename>control</filename> của các gói được cài đặt cũng được sao chép ở đó.
			</para>
			 </sidebar> <para>
				Nói chung, kịch bản <filename>preinst</filename> được thực hiện trước khi cài đặt gói, trong khi kịch bản <filename>postinst</filename> là sau khi cài đặt. Tương tự, <filename>prerm</filename> được gọi trước khi loại bỏ một gói và <filename>postrm</filename> sau khi loại bỏ gói xong. Bản cập nhật của một gói tương đương với việc loại bỏ phiên bản trước đó và cài đặt gói mới. Không thể mô tả chi tiết tất cả các kịch bản có thể ở đây nhưng chúng ta sẽ thảo luận hai vấn đề phổ biến nhất: cài đặt/cập nhật và gỡ bỏ.
			</para>
			 <sidebar> <title><emphasis>CAUTION</emphasis> Tên tượng trưng của kịch bản</title>
			 <para>
				Trong phần này, chúng ta sẽ gọi các kịch bản cụ thể để phân biệt giữa gói của và gói mới sắp cập nhật, chẳng hạn như là <command>old-prerm</command> hoặc <command>new-postinst</command>. Chúng tưng úng là <command>perm</command> được ở trong phiên bản cũ của gói (được cài đặt trước bản cập nhật) và kịch bản <command>postinst</command> ở trong tệp mới (bản cập nhật gói mới).
			</para>
			 </sidebar> <sidebar> <title><emphasis>TIP</emphasis> Sơ đồ trạng thái</title>
			 <para>
				Manoj Srivastava đã làm những sơ đồ này giải thích cách kịch bản cấu hình được gọi bởi <command>dpkg</command>. Các biểu đồ tương tự cũng đã được dự án Debian Women phát triển; Họ muốn một chút đơn giản để hiểu, nhưng ít hoàn thành hơn. <ulink type="block" url="https://people.debian.org/~srivasta/MaintainerScripts.html" /> <ulink type="block" url="https://wiki.debian.org/MaintainerScripts" />
			</para>
			 </sidebar> <section>
				<title>Cài đặt và Nâng cấp</title>
				 <indexterm>
					<primary><command>dpkg</command></primary>
					<secondary>hoạt động nội bộ</secondary>
				</indexterm>
				 <para>
					Dưới đây là những gì xảy ra trong quá trình cài đặt (hoặc cập nhật):
				</para>
				 <orderedlist>
					<listitem>
						<para>
							Đối với cập nhật, <command>dpkg</command> gọi <command>old-prerm upgrade <replaceable>new-version</replaceable></command>.
						</para>

					</listitem>
					 <listitem>
						<para>
							Vẫn với cập nhật, <command>dpkg</command> sau đó thực hiện <command>new-preinst upgrade <replaceable>old-version</replaceable></command>; đối với lần cài đặt đầu tiên, nó thực hiện <command>new-preinst install</command>. Có thể thêm phiên bản cũ vào tham số theo sau, nếu gói đã được cài đặt và gỡ bỏ trước (nhưng không bị xóa, các tệp cấu hình đã được giữ lại).
						</para>

					</listitem>
					 <listitem>
						<para>
							Các tệp gói mới sau đó được giải nén. Nếu một tập tin đã tồn tại, nó được thay thế, nhưng một bản sao lưu tạm thời được thực hiện.
						</para>

					</listitem>
					 <listitem>
						<para>
							Cho cập nhật, <command>dpkg</command> thực hiện <command>old-postrm upgrade <replaceable>new-version</replaceable></command>.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> cập nhật tất cả dữ liệu nội bộ (danh sách tệp, tập lệnh cấu hình, v.v.) và loại bỏ các bản sao lưu của các tệp được thay thế. Đây là điểm không trở lại: <command>dpkg</command> không còn truy cập vào tất cả các yếu tố cần thiết để trở về trạng thái trước đó.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> sẽ cập nhật các tệp cấu hình, hỏi người dùng quyết định xem nó có thể tự động quản lý tác vụ này không. Các chi tiết của thủ tục này được thảo luận trong <xref linkend="sect.conffiles" />.
						</para>

					</listitem>
					 <listitem>
						<para>
							Cuối cùng, <command>dpkg</command> cấu hình gói bằng cách thực hiện <command>new-postinst configure <replaceable>last-version-configured</replaceable></command>.
						</para>

					</listitem>

				</orderedlist>

			</section>
			 <section>
				<title>Xóa Gói</title>
				 <para>
					Dưới đây là những gì xảy ra trong quá trình loại bỏ gói:
				</para>
				 <orderedlist>
					<listitem>
						<para>
							<command>dpkg</command> gọi <command>prerm remove</command>.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> loại bỏ tất cả các tệp của gói, trừ các tệp cấu hình và tập lệnh cấu hình.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> thực hiện <command>postrm remove</command>. Tất cả các tập lệnh cấu hình, ngoại trừ <filename>postrm</filename>, sẽ bị xóa. Nếu người dùng không sử dụng tùy chọn “purge”, quá trình dừng ở đây.
						</para>

					</listitem>
					 <listitem>
						<para>
							Để xóa toàn bộ gói (lệnh được gọi với <command>dpkg --purge</command> hoặc <command>dpkg -P</command>), các tệp cấu hình cũng sẽ bị xoá. Cũng như là một số lượng nhất định các bản sao (<filename>*.dpkg-tmp</filename>, <filename>*.dpkg-old</filename>, <filename>*.dpkg-new</filename>) và các tập tin tạm; <filename>dpkg</filename> sau đó thực hiện <command>postrm purge</command>.
						</para>

					</listitem>

				</orderedlist>
				 <sidebar> <title><emphasis>VOCABULARY</emphasis> Làm sạch, loại bỏ hoàn toàn</title>
				 <indexterm>
					<primary>Loại bỏ hoàn toàn một gói</primary>
				</indexterm>
				 <para>
					Khi một gói Debian được gỡ bỏ, các tệp cấu hình được giữ lại để tạo điều kiện cho việc cài đặt lại. Tương tự, dữ liệu tạo ra bởi một daemon (như nội dung của một thư mục máy chủ LDAP, hoặc nội dung của một cơ sở dữ liệu cho một máy chủ SQL) thường được giữ lại.
				</para>
				 <para>
					Để loại bỏ tất cả các dữ liệu liên quan đến một gói, cần phải “tẩy” gói với lệnh, <command>dpkg -P <replaceable>package</replaceable></command>, <command>apt-get remove --purge <replaceable>package</replaceable></command> hoặc <command>aptitude purge <replaceable>package</replaceable></command>.
				</para>
				 <para>
					Với tính chất dứt khoát của việc xóa dữ liệu, việc tẩy không nên được xem nhẹ.
				</para>
				 </sidebar> <indexterm>
					<primary><filename>config</filename>, <command>debconf</command> script</primary>
				</indexterm>
				 <para>
					Bốn kịch bản được nêu chi tiết ở trên được bổ sung bởi một tập lệnh <filename>config</filename>, được cung cấp bởi các gói sử dụng <command>debconf</command> để thu thập thông tin từ người dùng để cấu hình. Trong quá trình cài đặt, kịch bản này xác định chi tiết các câu hỏi được yêu cầu bởi <command>debconf</command>. Câu trả lời được ghi lại trong cơ sở dữ liệu <command>debconf</command> để tham khảo trong tương lai. Tập lệnh thường được thực thi bởi <command>apt</command> trước khi cài đặt từng gói một để nhóm tất cả các câu hỏi và yêu cầu tất cả các người dùng vào lúc bắt đầu quá trình. Các tập lệnh trước và sau khi cài đặt có thể sử dụng thông tin này để hoạt động theo ý muốn của người dùng.
				</para>
				 <sidebar> <title><emphasis>TOOL</emphasis> <command>debconf</command></title>
				 <indexterm>
					<primary><command>debconf</command></primary>
				</indexterm>
				 <para>
					<command>debconf</command> được tạo ra để giải quyết một vấn đề định kỳ trong Debian. Tất cả các gói Debian không thể hoạt động mà không có cấu hình tối thiểu được sử dụng để đặt câu hỏi với các cuộc gọi tới các lệnh <command>echo</command> và <command>read</command> trong kịch bản <filename>postinst</filename> (và các kịch bản tương tự khác). Nhưng điều này cũng có nghĩa là trong quá trình cài đặt hoặc cập nhật lớn người dùng phải ở lại máy tính để trả lời các câu hỏi khác nhau có thể phát sinh bất cứ lúc nào. Những tương tác thủ công này đã được hầu như hoàn toàn giải phóng, nhờ công cụ <command>debconf</command>.
				</para>
				 <para>
					<command>debconf</command> có nhiều tính năng thú vị: nó đòi hỏi nhà phát triển phải xác định tương tác người dùng; Nó cho phép nội địa hóa tất cả các chuỗi được hiển thị cho người dùng (tất cả các bản dịch được lưu trong tệp <filename>templates</filename> mô tả các tương tác); Nó có frontend khác nhau để hiển thị các câu hỏi cho người sử dụng (chế độ văn bản, chế độ đồ họa, không tương tác); Và nó cho phép tạo ra một cơ sở dữ liệu trung tâm của các phản hồi để chia sẻ cùng một cấu hình với một số máy tính... nhưng điều quan trọng nhất là bây giờ có thể trình bày tất cả các câu hỏi liên tiếp với người dùng, trước khi bắt đầu quá trình cài đặt hoặc cập nhật dài hơi. Người sử dụng có thể tiến hành công việc của họ trong khi hệ thống tự quản lý việc cài đặt, mà không cần phải ở lại đó nhìn chằm chằm vào màn hình chờ các câu hỏi.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.conffiles">
			<title>Checksums, Danh sách Tệp Cấu hình</title>
			 <indexterm>
				<primary><filename>md5sums</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>conffiles</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>checksums</primary>
			</indexterm>
			 <indexterm>
				<primary>files</primary>
				<secondary>configuration files</secondary>
			</indexterm>
			 <indexterm>
				<primary>configuration</primary>
				<secondary>files</secondary>
			</indexterm>
			 <para>
				Ngoài các kịch bản bảo trì và dữ liệu điều khiển đã được đề cập trong các phần trước, tệp nén <filename>control.tar.gz</filename> của một gói Debian có thể chứa các tệp tin thú vị khác. Đầu tiên, <filename>md5sums</filename>, chứa checksums MD5 cho tất cả các tệp của gói. Ưu điểm chính của nó là nó cho phép <command>dpkg --verify</command> (chúng ta sẽ nghiên cứu trong <xref linkend="sect.dpkg-verify" />) để kiểm tra xem các tệp này đã được sửa đổi từ khi cài đặt hay không. Lưu ý rằng khi tệp này không tồn tại, <command>dpkg</command> sẽ tự động tạo ra nó trong thời gian cài đặt (và lưu trữ nó trong cơ sở dữ liệu dpkg giống như các tệp kiểm soát khác).
			</para>
			 <para>
				<filename>conffiles</filename> liệt kê các tệp tin gói phải được xử lý như tệp cấu hình. Các tệp cấu hình có thể được quản trị viên sửa đổi và <command>dpkg</command> sẽ cố gắng bảo vệ những thay đổi đó trong quá trình cập nhật gói.
			</para>
			 <para>
				Trong trường hợp này, <command>dpkg</command> hoạt động thông minh nhất có thể: nếu tập tin cấu hình tiêu chuẩn không thay đổi giữa hai phiên bản, nó không làm gì cả. Tuy nhiên, nếu tệp đã thay đổi, nó sẽ cố gắng cập nhật tệp này. Có hai trường hợp: quản trị viên không chạm vào tệp cấu hình này, trong trường hợp đó <command>dpkg</command> tự động cài đặt phiên bản mới; Hoặc tập tin đã được sửa đổi, trong trường hợp này <command>dpkg</command> yêu cầu quản trị viên phiên bản nào họ muốn sử dụng (bản cũ có sửa đổi, hoặc phiên bản mới được cung cấp kèm theo gói). Để hỗ trợ đưa ra quyết định này, <command>dpkg</command> cung cấp để hiển thị “<command>diff</command>” cho thấy sự khác biệt giữa hai phiên bản. Nếu người dùng chọn giữ lại phiên bản cũ, tệp mới sẽ được lưu trữ ở cùng vị trí trong một tệp có đuôi <filename>.dpkg-dist</filename>. Nếu người dùng chọn phiên bản mới, phần cũ sẽ được giữ lại trong một tệp có đuôi <filename>.dpkg-old</filename>. Một hành động khả dụng khác bao gồm tạm ngưng <command>dpkg</command> để chỉnh sửa tệp và cố gắng cài đặt lại các sửa đổi có liên quan (trước đây được xác định với <command>diff</command>).
			</para>
			 <sidebar id="sidebar.questions-conffiles"> <title><emphasis>GOING FURTHER</emphasis> Tránh các câu hỏi về tệp cấu hình</title>
			 <para>
				<command>dpkg</command> xử lý các bản cập nhật tập tin cấu hình, nhưng, trong khi làm như vậy, thường xuyên ngắt công việc của nó để yêu cầu nhập từ quản trị viên. Điều này làm cho nó ít thú vị hơn cho những ai muốn chạy các bản cập nhật theo cách không tương tác. Đây là lý do tại sao chương trình này cung cấp các tùy chọn cho phép hệ thống tự động trả lời theo logic tương tự: <command>--force-confold</command> giữ lại phiên bản cũ của tệp; <command>--force-confnew</command> sẽ sử dụng phiên bản mới của tệp tin (các lựa chọn này được tôn trọng, ngay cả khi tệp không bị thay đổi bởi quản trị viên, điều này hiếm khi có hiệu ứng mong muốn). Thêm tùy chọn <command>--force-confdef</command> để <command>dpkg</command> tự quyết định khi có thể (nói cách khác, khi tệp cấu hình ban đầu chưa được chạm vào) và chỉ sử dụng <command>--force-confnew</command> hoặc <command>--force-confold</command> cho các trường hợp khác.
			</para>
			 <para>
				Các tùy chọn này áp dụng cho <command>dpkg</command>, nhưng hầu hết thời gian người quản trị viên sẽ làm việc trực tiếp với chương trình <command>aptitude</command> hoặc <command>apt-get</command>. Do đó, cần biết cú pháp được sử dụng để chỉ ra các tùy chọn để vượt qua lệnh <command>dpkg</command> (các giao diện dòng lệnh của chúng rất giống nhau).
			</para>
			 
<screen>
<computeroutput># </computeroutput><userinput>apt -o DPkg::options::="--force-confdef" -o DPkg::options::="--force-confold" full-upgrade</userinput></screen>
			 <para>
				Các tùy chọn này có thể được lưu trữ trực tiếp trong cấu hình của <command>apt</command>. Để làm như vậy, chỉ cần viết dòng sau trong tệp <filename> /etc/apt/apt.conf.d/local</filename>:
			</para>
			 <informalexample> 
<programlisting>
DPkg::options { "--force-confdef"; "--force-confold"; }</programlisting>
			 </informalexample> <para>
				Bao gồm tùy chọn này trong tệp cấu hình có nghĩa là nó cũng sẽ được sử dụng trong một giao diện đồ họa như <command>aptitude</command>.
			</para>
			 </sidebar> <sidebar id="sidebar.questions-conffiles-bis"> <title><emphasis>GOING FURTHER</emphasis> Buộc dpkg yêu cầu hỏi về tệp cấu hình</title>
			 <para>
				Tùy chọn <command>--force-confask</command> yêu cầu <command>dpkg</command> hiển thị các câu hỏi về các tệp cấu hình, ngay cả trong trường hợp không cần thiết. Do đó, khi cài đặt lại một gói với tùy chọn này, <command>dpkg</command> sẽ hỏi lại tất cả các tập tin cấu hình do quản trị viên sửa đổi. Điều này rất thuận tiện, đặc biệt là để cài đặt lại tập tin cấu hình ban đầu nếu nó đã bị xóa và không có bản sao nào khác có sẵn: trong khi cài đặt lại bình thường sẽ không hoạt động vì <command>dpkg</command> coi việc xóa như một hình thức sửa đổi hợp pháp, và, do đó không cài đặt các tập tin cấu hình mong muốn.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.source-package-structure">
		<title>Cấu trúc của Gói nguồn</title>
		 <indexterm>
			<primary>package</primary>
			<secondary>source package </secondary>
		</indexterm>
		 <indexterm>
			<primary>source</primary>
			<secondary>package</secondary>
		</indexterm>
		 <section>
			<title>Định dạng</title>
			 <indexterm>
				<primary>tệp DSC</primary>
			</indexterm>
			 <indexterm>
				<primary>tệp <filename>diff.gz</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>tệp <filename>debian.tar.gz</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>tệp <filename>orig.tar.gz </filename></primary>
			</indexterm>
			 <para>
				Gói nguồn thường bao gồm ba tệp tin, là <filename>.dsc</filename>, <filename>orig.tar.gz </filename>, và <filename>.debian.tar.gz</filename> (hoặc <filename>.diff.gz </filename>). Chúng cho phép tạo các gói nhị phân (<filename>.deb</filename> các tệp được mô tả ở trên) từ tệp mã nguồn của chương trình, được viết bằng ngôn ngữ lập trình.
			</para>
			 <para>
				Tệp <filename>.dsc</filename> (Debian Source Control) là một tệp văn bản ngắn chứa tiêu đề RFC 2822 (giống như tệp <filename>control</filename> được nghiên cứu trong <xref linkend="sect.control" />) nó mô tả gói nguồn và cho biết tệp nào là một phần của nó. Nó được ký bởi người bảo trì của nó, để đảm bảo tính xác thực. Xem <xref linkend="sect.package-authentication" /> để biết thêm chi tiết về chủ đề này.
			</para>
			 <example>
				<title>Tệp tin <filename>.dsc</filename></title>
				 
<programlisting>
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Format: 3.0 (quilt)
Source: zim
Binary: zim
Architecture: all
Version: 0.62-3
Maintainer: Emfox Zhou &lt;emfox@debian.org&gt;
Uploaders: Raphaël Hertzog &lt;hertzog@debian.org&gt;
Homepage: http://zim-wiki.org
Standards-Version: 3.9.6
Vcs-Browser: http://anonscm.debian.org/gitweb/?p=collab-maint/zim.git
Vcs-Git: git://anonscm.debian.org/collab-maint/zim.git
Build-Depends: debhelper (&gt;= 9), xdg-utils, python (&gt;= 2.6.6-3~), libgtk2.0-0 (&gt;= 2.6), python-gtk2, python-xdg
Package-List:
 zim deb x11 optional arch=all
Checksums-Sha1:
 ad8de170826682323c10195b65b9f1243fd75637 1772246 zim_0.62.orig.tar.gz
 a4f70d6f7fb404022c9cc4870a4e62ea3ca08388 14768 zim_0.62-3.debian.tar.xz
Checksums-Sha256:
 19d62aebd2c1a92d84d80720c6c1dcdb779c39a2120468fed01b7f252511bdc2 1772246 zim_0.62.orig.tar.gz
 fc2e827e83897d5e33f152f124802c46c3c01c5158b75a8275a27833f1f6f1de 14768 zim_0.62-3.debian.tar.xz
Files:
 43419efba07f7086168442e3d698287a 1772246 zim_0.62.orig.tar.gz
 725a69663a6c2961f07673ae541298e4 14768 zim_0.62-3.debian.tar.xz

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2
Comment: Signed by Raphael Hertzog

iQEcBAEBCAAGBQJUR2jqAAoJEAOIHavrwpq5WFcH/RsdzCHc1oXXxHitU23hEqMj
T6ok29M1UFDJDowMXW75jQ1nT4WPUtvEGygkCHeoO/PvjEvB0sjU8GQlX+N9ddSB
aHfqfAYmVhADNGxrXQT5inZXUa8qGeeq2Sqf6YcWtsnuD56lDbvxkyf/XYopoIEl
oltfl05z/AI+vYsW482YrCz0fxNAKAvkyuPhDebYI8jnKWeAANoqmKpsNc/HYyvT
+ZiA5o57OiGdOKT6XGy3/FiF3dkHiRY8lXW7xdr1BbIgulwl9UmiUNwuxwOYbQO7
edtjiTJqOaFUA0x1zB/XGv5tHr1MjP8naT+kfVoVHTOox51CDbeu5D3DZY4imcY=
=Wtoa
-----END PGP SIGNATURE-----</programlisting>

			</example>
			 <indexterm>
				<primary><literal>Build-Depends</literal>, trường tiêu đề </primary>
			</indexterm>
			 <para>
				Lưu ý rằng gói nguồn cũng có phụ thuộc (<literal>Build-Depends</literal>) nó hoàn toàn khác so với các gói nhị phân, vì chúng chỉ ra các công cụ cần thiết để biên dịch phần mềm được đề cập và xây dựng gói nhị phân của nó.
			</para>
			 <sidebar> <title><emphasis>CAUTION</emphasis> Khoảng không tên riêng biệt</title>
			 <para>
				Điều quan trọng cần lưu ý ở đây là không có yêu cầu tương ứng giữa tên của gói nguồn và gói tin nhị phân mà nó tạo ra. Có thể dễ hiểu nếu bạn biết rằng mỗi gói nguồn có thể tạo ra một số gói nhị phân. Đây là lý do tại sao tệp tin <filename>.dsc</filename> có trường <literal>Source</literal> và <literal>Binary</literal> để nêu rõ tên gói nguồn và danh sách các gói nhị phân mà nó tạo ra.
			</para>
			 </sidebar> <sidebar> <title><emphasis>CULTURE</emphasis> Tại sao chia thành nhiều gói</title>
			 <para>
				Rất thường xuyên, gói nguồn (cho một phần mềm nhất định) có thể tạo ra vài gói nhị phân. Sự phân chia này là hợp lý bởi khả năng sử dụng (phần của) phần mềm trong các ngữ cảnh khác nhau. Xem xét một thư viện chia sẻ, nó có thể được cài đặt để thực hiện công việc ứng dụng (ví dụ: <emphasis role="pkg">libc6</emphasis>), hoặc nó có thể được cài đặt để phát triển một chương trình mới (<emphasis role="pkg">libc6-dev</emphasis> sau đó sẽ là gói chính xác). Chúng ta tìm thấy cùng một logic cho các dịch vụ client/server, nơi chúng ta muốn cài đặt phần server trên một máy và phần client trên các máy khác (ví dụ: <emphasis role="pkg">openssh-server</emphasis> và <emphasis role="pkg">openssh-client</emphasis>).
			</para>
			 <para>
				Hay thường xuyên các tài liệu được cung cấp trong một gói phần mềm chuyên dụng: người dùng có thể cài đặt nó độc lập với phần mềm, và có thể tại bất kỳ thời điểm nào chọn để loại bỏ nó để tiết kiệm không gian ổ cứng. Ngoài ra, điều này cũng tiết kiệm không gian ổ cứng trên mirror Debian, vì gói tài liệu sẽ được chia sẻ giữa tất cả các kiến trúc (thay vì có các tài liệu được nhân đôi trong các gói cho mỗi kiến trúc khác nhau).
			</para>
			 </sidebar> <sidebar> <title><emphasis>PERSPECTIVE</emphasis> Định dạng gói nguồn khác nhau</title>
			 <para>
				Ban đầu chỉ có một định dạng gói nguồn. Đó là định dạng <literal>1.0</literal>, kết hợp tệp <filename>.orig.tar.gz </filename> và một <filename>.diff.gz</filename> bản vá “debianization” (hay là một tệp tin nén <filename>.tar.gz</filename> duy nhất, được sử dụng tự động nếu không có tệp <filename>.orig.tar.gz</filename>).
			</para>
			 <para>
				Từ Debian phiên bản <emphasis role="distribution">Squeeze</emphasis>, các nhà phát triển Debian có thể sử dụng định dạng mới để sửa đổi nhiều vấn đề về định dạng cũ. Định dạng <literal>3.0(quilt)</literal> có thể kết hợp nhiều lưu trữ thượng nguồn trong cùng một gói nguồn: thêm vào <filename>.orig.tar.gz</filename>, bổ sung <filename>.orig-<replaceable>component</replaceable>.tar.gz</filename> nếu có thể. Điều này rất hữu ích với phần mềm được phân phối trong một số thành phần thượng nguồn mà chỉ cần một gói nguồn duy nhất. Các tệp nén này có thể được nén với <command>bzip2</command> hoặc <command>xz</command> chứ không phải là <command>gzip</command>, tiết kiệm không gian ổ cứng và tài nguyên mạng. Cuối cùng, miếng vá đồng nhất, <filename>.diff.gz</filename> được thay thế bởi một tệp nén<filename>.debian.tar.gz</filename> chứa các lệnh biên dịch và tập hợp miếng vá đóng góp của người bảo trì gói. Những mục cuối này được ghi lại theo một định dạng tương thích với <filename>quilt</filename> - một công cụ giúp quản lý một loạt các bản vá lỗi.
			</para>
			 </sidebar> <para>
				Tệp <filename>.orig.tar.gz</filename> là tệp nén chứa mã nguồn do nhà phát triển ban đầu cung cấp. Người bảo trì gói Debian được yêu cầu không sửa đổi tệp này để có thể dễ dàng kiểm tra nguồn gốc và tính toàn vẹn của tệp (bằng so sánh đơn giản với checksums) và tôn trọng mong muốn của một số tác giả.
			</para>
			 <para>
				Các <filename>.debian.tar.gz</filename> chứa tất cả các sửa đổi được thực hiện bởi người bảo trì Debian, đặc biệt là bổ sung thư mục <filename>debian</filename>, thư mục chứa các hướng dẫn để thực hiện xây dựng một gói Debian.
			</para>
			 <sidebar> <title><emphasis>TOOL</emphasis> Giải nén gói nguồn</title>
			 <indexterm>
				<primary><command>dpkg-source</command></primary>
			</indexterm>
			 <indexterm>
				<primary>giải nén, gói nguồn </primary>
			</indexterm>
			 <indexterm>
				<primary> giải nén, gói nguồn </primary>
			</indexterm>
			 <indexterm>
				<primary> giải nén </primary>
				<secondary> gói nguồn </secondary>
			</indexterm>
			 <para>
				Nếu bạn có một gói nguồn, bạn có thể sử dụng lệnh <command>dpkg-source</command> (từ gói <emphasis role="pkg">dpkg-dev</emphasis>) để giải nén nó:
			</para>
			 
<screen><computeroutput> $ </computeroutput><userinput> dpkg-source -x package_0.7-1.dsc </userinput></screen>
			 <para>
				Bạn cũng có thể sử dụng <command>apt-get</command> để tải xuống một gói nguồn và giải nén nó ngay. Nó yêu cầu các dòng <literal>deb-src</literal> có trong tập tin <literal>/etc/apt/sources.list</literal> (để biết thêm chi tiết, xem <xref linkend="sect.apt-sources.list" />). Chúng được sử dụng để liệt kê “nguồn” của các gói nguồn (nghĩa là các máy chủ mà trên đó một nhóm các gói nguồn được lưu trữ).
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>apt-get source <replaceable>package</replaceable></userinput></screen>
			 </sidebar>
		</section>
		 <section>
			<title>Cách sử dụng trong Debian</title>
			 <para>
				Gói nguồn là nền tảng của mọi thứ trong Debian. Tất cả các gói Debian đều đến từ một gói nguồn, và mỗi sửa đổi trong một gói Debian là kết quả của một sửa đổi đối với gói nguồn. Các nhà bảo trì Debian làm việc với gói nguồn, tuy nhiên biết được hậu quả của hành động của họ đối với các gói nhị phân. Các thành quả của công việc của họ được tìm thấy trong các gói nguồn có sẵn từ Debian: bạn có thể dễ dàng quay lại gói nguồn và mọi thứ bắt nguồn từ chúng.
			</para>
			 <para>
				Khi một phiên bản mới của gói (gói nguồn và một hoặc nhiều gói nhị phân) xuất hiện trên máy chủ Debian, gói nguồn là quan trọng nhất. Thật vậy, nó sẽ được sử dụng bởi một mạng lưới các máy của các kiến trúc khác nhau để biên dịch trên các kiến trúc đó được hỗ trợ bởi Debian. Thực tế là nhà phát triển cũng gửi một hoặc nhiều gói nhị phân cho một kiến trúc nhất định (thường là i386 hoặc amd64) là tương đối không quan trọng vì chúng cũng có thể được tạo tự động.
			</para>

		</section>

	</section>
	 <section id="sect.manipulating-packages-with-dpkg">
		<title>Thao tác các gói với <command>dpkg</command></title>
		 <indexterm>
			<primary><command>dpkg</command></primary>
		</indexterm>
		 <para>
			<command>dpkg</command> là lệnh cơ sở để xử lý các gói Debian trên hệ thống. Nếu bạn có gói <filename>.deb</filename>, <command>dpkg</command> cho phép cài đặt hoặc phân tích nội dung của gói đó. Nhưng chương trình này chỉ là có một cái nhìn 1 phần của vũ trụ Debian: nó biết những gì được cài đặt trên hệ thống, và bất cứ điều gì nó được đưa ra trên dòng lệnh, nhưng không biết gì về các gói có sẵn khác (ở trên các máy chủ). Như vậy, nó sẽ báo lỗi nếu một sự phụ thuộc không được đáp ứng. Các công cụ như <command>apt</command>, trái lại, sẽ tạo ra một danh sách các phụ thuộc để cài đặt mọi thứ như là tự động có thể.
		</para>
		 <sidebar> <title><emphasis>NOTE</emphasis><command>dpkg</command> hay <command>apt</command>?</title>
		 <para>
			<command>dpkg</command> nên được xem như một công cụ hệ thống (phần lõi), và <command>apt</command> như một công cụ gần gũi hơn với người dùng, vượt qua những hạn chế của nó. Những công cụ này làm việc cùng nhau, mỗi cái có tính đặc thù, phù hợp với các nhiệm vụ cụ thể.
		</para>
		 </sidebar> <section>
			<title>Cài đặt Gói</title>
			 <indexterm>
				<primary>installation</primary>
				<secondary>package installation</secondary>
			</indexterm>
			 <indexterm>
				<primary>package</primary>
				<secondary>installation</secondary>
			</indexterm>
			 <para>
				<command>dpkg</command> là công cụ cài đặt gói Debian đã có sẵn (vì nó không tải bất cứ thứ gì). Để thực hiện việc này, chúng ta sử dụng tùy chọn <literal>-i</literal> hoặc <literal>--install</literal>.
			</para>
			 <example>
				<title>Cài đặt một gói với <command>dpkg</command></title>
				 
<screen role="scale">
<computeroutput># </computeroutput><userinput>dpkg -i man-db_2.7.0.2-5_amd64.deb</userinput>
<computeroutput>(Reading database ... 86425 files and directories currently installed.)
Preparing to unpack man-db_2.7.0.2-5_amd64.deb ...
Unpacking man-db (2.7.0.2-5) over (2.7.0.2-4) ...
Setting up man-db (2.7.0.2-5) ...
Updating database of manual pages ...
Processing triggers for mime-support (3.58) ...</computeroutput></screen>

			</example>
			 <para>
				Chúng ta có thể thấy các bước khác nhau được thực hiện bởi <command>dpkg</command>; Chúng ta biết, do đó, tại những điểm bất kỳ lỗi có thể đã xảy ra. Việc cài đặt cũng có thể được thực hiện trong hai giai đoạn: đầu tiên giải nén, sau đó cấu hình. <command>apt-get</command> tận dụng điều này, hạn chế số lượng cuộc gọi đến <command>dpkg</command> (vì mỗi cuộc gọi tốn kém, do tải cơ sở dữ liệu trong bộ nhớ , đặc biệt là danh sách các tập tin đã được cài đặt).
			</para>
			 <example>
				<title>Giải nén và cấu hình riêng rẽ</title>
				 
<screen role="scale">
<computeroutput># </computeroutput><userinput>dpkg --unpack man-db_2.7.0.2-5_amd64.deb</userinput>
<computeroutput>(Reading database ... 86425 files and directories currently installed.)
Preparing to unpack man-db_2.7.0.2-5_amd64.deb ...
Unpacking man-db (2.7.0.2-5) over (2.7.0.2-5) ...
Processing triggers for mime-support (3.58) ...
# </computeroutput><userinput>dpkg --configure man-db</userinput>
<computeroutput>Setting up man-db (2.7.0.2-5) ...
Updating database of manual pages ...
</computeroutput></screen>

			</example>
			 <indexterm>
				<primary>package</primary>
				<secondary>unpacking</secondary>
			</indexterm>
			 <indexterm>
				<primary>unpacking</primary>
				<secondary>binary package</secondary>
			</indexterm>
			 <para>
				Đôi khi <command>dpkg</command> sẽ không cài đặt gói và trả về lỗi; Nếu người dùng cho nó để bỏ qua điều này, nó sẽ chỉ phát hành một cảnh báo; Vì lý do này mà chúng ta có các tùy chọn <literal>--force-*</literal> khác nhau. Lệnh <command>dpkg --force-help</command> là tài liệu đầy đủ các tùy chọn này. Lỗi thường gặp nhất, mà bạn sẽ gặp phải sớm hay muộn, là một va chạm tập tin. Khi một gói chứa một tập tin đã được cài đặt bởi một gói khác, <command>dpkg</command> sẽ từ chối cài đặt nó. Sau đó các thông báo sau sẽ xuất hiện:
			</para>
			 
<screen>
<computeroutput>Unpacking libgdm (from .../libgdm_3.8.3-2_amd64.deb) ...
dpkg: error processing /var/cache/apt/archives/libgdm_3.8.3-2_amd64.deb (--unpack):
 trying to overwrite '/usr/bin/gdmflexiserver', which is also in package gdm3 3.4.1-9</computeroutput></screen>
			 <para>
				Trong trường hợp này, nếu bạn nghĩ rằng thay thế tệp này không phải ảnh hướng tới tính ổn định của hệ thống (thường là trường hợp này), bạn có thể sử dụng tùy chọn <literal>--force-overwrite</literal>, để cho <command>dpkg</command> biết để bỏ qua lỗi này và ghi đè lên tệp.
			</para>
			 <para>
				Mặc dù có nhiều tùy chọn <literal>--force-*</literal>, chỉ có <literal>--force-overwrite</literal> được sử dụng thường xuyên. Các lựa chọn này chỉ tồn tại trong những trường hợp đặc biệt, và tốt hơn là không dùng chúng càng nhiều càng tốt để tôn trọng các quy tắc áp đặt bởi cơ chế đóng gói. Đừng quên, những quy tắc này đảm bảo tính nhất quán và sự ổn định của hệ thống.
			</para>
			 <sidebar> <title><emphasis>CAUTION</emphasis> Sử dụng hiệu quả <literal>--force-*</literal></title>
			 <indexterm>
				<primary>phá vỡ sự phụ thuộc </primary>
			</indexterm>
			 <para>
				Nếu bạn không cẩn thận, việc sử dụng một tùy chọn <literal>--force-* </literal> có thể dẫn đến một hệ thống mà các gia đình lện APT sẽ từ chối hoạt động. Một số tùy chọn cho phép <command>dpkg</command> cài đặt một gói khi một sự phụ thuộc không thỏa mãn, hoặc ngay cả khi có xung đột. Kết quả là tạo nên một hệ thống không nhất quán từ quan điểm phụ thuộc, và các lệnh của APT sẽ từ chối thực hiện bất kỳ hành động nào, ngoại trừ các lệnh sẽ đưa hệ thống trở lại trạng thái nhất quán (thường bao gồm cài đặt sự phụ thuộc bị thiếu hoặc gỡ bỏ một gói có vấn đề). Điều này thường dẫn đến một thông báo như sau, ví dụ sau khi cài đặt phiên bản mới của <emphasis role="pkg">rdesktop</emphasis> trong khi bỏ qua sự phụ thuộc của nó vào một phiên bản mới hơn của <emphasis role="pkg">libc6</emphasis>:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>apt full-upgrade
</userinput><computeroutput>[...]
You might want to run 'apt-get -f install' to correct these.
The following packages have unmet dependencies:
  rdesktop: Depends: libc6 (&gt;= 2.5) but 2.3.6.ds1-13etch7 is installed
E: Unmet dependencies. Try using -f.</computeroutput></screen>
			 <para>
				Một quản trị viên dũng cảm phải chắc chắn về phân tích chính xác có thể bỏ qua sự phụ thuộc hoặc xung đột và sử dụng tuỳ chọn <literal>--force-*</literal>. Trong trường hợp này, nếu họ muốn có thể tiếp tục sử dụng <command>aptitude</command> hoặc <command>apt</command>&gt;, họ phải chỉnh sửa <filename>/var/lib/dpkg/status</filename> để xóa hay sửa đổi sự phụ thuộc, hoặc xung đột mà họ đã chọn để ghi đè.
			</para>
			 <para>
				Thao tác này xem như là một cách hack đểu, và không bao giờ nên được sử dụng, ngoại trừ trường hợp cực kỳ cần thiết. Thường xuyên, một giải pháp thích hợp hơn là biên dịch lại gói phần mềm gây ra sự cố (xem <xref linkend="sect.rebuilding-package" />) hoặc sử dụng một phiên bản mới (có khả năng sửa chữa) từ một kho như <literal>stable-backports</literal> (xem <xref linkend="sect.backports" />).
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>Xóa Gói</title>
			 <indexterm>
				<primary>removing a package</primary>
			</indexterm>
			 <indexterm>
				<primary>purging a package</primary>
			</indexterm>
			 <indexterm>
				<primary> gói </primary>
				<secondary> loại bỏ </secondary>
			</indexterm>
			 <indexterm>
				<primary> gói </primary>
				<secondary> tẩy rửa </secondary>
			</indexterm>
			 <para>
				Gọi <command>dpkg</command>với tùy chọn <literal>-r</literal> hay <literal>--remove </literal>, theo sau là tên của một gói, để loại bỏ gói đó. Tuy nhiên, việc xóa này không hoàn chỉnh: tất cả các tệp cấu hình, tập lệnh người quản trị, tệp nhật ký (nhật ký hệ thống) và dữ liệu người dùng khác được gói gọn trong gói. Bằng cách đó, vô hiệu hóa chương trình có thể thực hiện dễ dàng bằng cách gỡ cài đặt và vẫn có thể nhanh chóng cài đặt lại nó với cùng cấu hình. Để loại bỏ hoàn toàn mọi thứ liên quan đến một gói, hãy sử dụng tùy chọn <literal>-P</literal> hoặc <literal>--purge</literal>, sau đó là tên gói.
			</para>
			 <example>
				<title>Xoá và tẩy gói <emphasis role="pkg">debian-cd</emphasis></title>
				 
<screen><computeroutput># </computeroutput><userinput>dpkg -r debian-cd</userinput>
<computeroutput>(Reading database ... 97747 files and directories currently installed.)
Removing debian-cd (3.1.17) ...
# </computeroutput><userinput>dpkg -P debian-cd</userinput>
<computeroutput>(Reading database ... 97401 files and directories currently installed.)
Removing debian-cd (3.1.17) ...
Purging configuration files for debian-cd (3.1.17) ...</computeroutput></screen>

			</example>

		</section>
		 <section>
			<title>Truy vấn cơ sở dữ liệu của <command>dpkg</command> và kiểm tra các tệp <filename>.deb</filename></title>
			 <indexterm>
				<primary>package</primary>
				<secondary>status</secondary>
			</indexterm>
			 <indexterm>
				<primary>package</primary>
				<secondary>file list</secondary>
			</indexterm>
			 <indexterm>
				<primary>package</primary>
				<secondary>content inspection</secondary>
			</indexterm>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Cú pháp tùy chọn</title>
			 <para>
				Hầu hết các tùy chọn có sẵn trong một phiên bản"dài"(một hoặc nhiều từ có liên quan, đứng trước dấu gạch đôi) và một phiên bản"ngắn"(một chữ cái, thường là chữ đầu của một từ từ phiên bản dài, và trước bởi một Dash). Quy ước này là phổ biến đến mức nó là một tiêu chuẩn POSIX.
			</para>
			 </sidebar> <para>
				Trước khi kết thúc phần này, chúng ta sẽ nghiên cứu các tùy chọn <command>dpkg</command> để truy vấn cơ sở dữ liệu nội bộ để có được thông tin. Trước tiên các tùy chọn dài và sau đó các tùy chọn ngắn tương ứng (điều đó rõ ràng sẽ có cùng một đối số) chúng ta trích dẫn <literal>--listfiles <replaceable>package</replaceable></literal>(hoặc <literal>-L</literal>), liệt kê các tệp đã được cài đặt bởi gói này; <literal>--search </literal><replaceable>file</replaceable> (hoặc <literal>-S</literal>), tìm gói (các) gói có chứa tệp này; <literal>--status </literal><replaceable>package</replaceable> (hoặc <literal>-s</literal>), hiển thị trạng thái của một gói được cài đặt; <literal>--list</literal> (hoặc <literal>-l</literal>), liệt kê tất cả các gói được biết đối với hệ thống và trạng thái cài đặt của chúng; <literal>--content </literal><replaceable>file.deb</replaceable> (hoặc <literal>-c</literal>), liệt kê các tệp trong gói Debian đó; <literal>--info </literal><replaceable>file.deb</replaceable> (hoặc <literal>-I</literal>), hiển thị tiêu đề của gói Debian này.
			</para>
			 <example>
				<title>Các truy vấn khác nhau với <command>dpkg</command></title>
				 
<screen role="scale" width="80">
<computeroutput>$ </computeroutput><userinput>dpkg -L base-passwd</userinput>
<computeroutput>/.
/usr
/usr/sbin
/usr/sbin/update-passwd
/usr/share
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/base-passwd
/usr/share/doc-base
/usr/share/doc-base/users-and-groups
/usr/share/base-passwd
/usr/share/base-passwd/group.master
/usr/share/base-passwd/passwd.master
/usr/share/man
/usr/share/man/pl
/usr/share/man/pl/man8
/usr/share/man/pl/man8/update-passwd.8.gz
/usr/share/man/ru
/usr/share/man/ru/man8
/usr/share/man/ru/man8/update-passwd.8.gz
/usr/share/man/ja
/usr/share/man/ja/man8
/usr/share/man/ja/man8/update-passwd.8.gz
/usr/share/man/fr
/usr/share/man/fr/man8
/usr/share/man/fr/man8/update-passwd.8.gz
/usr/share/man/es
/usr/share/man/es/man8
/usr/share/man/es/man8/update-passwd.8.gz
/usr/share/man/de
/usr/share/man/de/man8
/usr/share/man/de/man8/update-passwd.8.gz
/usr/share/man/man8
/usr/share/man/man8/update-passwd.8.gz
/usr/share/doc
/usr/share/doc/base-passwd
/usr/share/doc/base-passwd/users-and-groups.txt.gz
/usr/share/doc/base-passwd/changelog.gz
/usr/share/doc/base-passwd/copyright
/usr/share/doc/base-passwd/README
/usr/share/doc/base-passwd/users-and-groups.html
$ </computeroutput><userinput>dpkg -S /bin/date</userinput>
<computeroutput>coreutils: /bin/date
$ </computeroutput><userinput>dpkg -s coreutils</userinput>
<computeroutput>Package: coreutils
Essential: yes
Status: install ok installed
Priority: required
Section: utils
Installed-Size: 13855
Maintainer: Michael Stone &lt;mstone@debian.org&gt;
Architecture: amd64
Multi-Arch: foreign
Version: 8.23-3
Replaces: mktemp, realpath, timeout
Pre-Depends: libacl1 (&gt;= 2.2.51-8), libattr1 (&gt;= 1:2.4.46-8), libc6 (&gt;= 2.17), libselinux1 (&gt;= 2.1.13)
Conflicts: timeout
Description: GNU core utilities
 This package contains the basic file, shell and text manipulation
 utilities which are expected to exist on every operating system.
 .
 Specifically, this package includes:
 arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp
 csplit cut date dd df dir dircolors dirname du echo env expand expr
 factor false flock fmt fold groups head hostid id install join link ln
 logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt
 od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm
 rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac
 tail tee test timeout touch tr true truncate tsort tty uname unexpand
 uniq unlink users vdir wc who whoami yes
Homepage: http://gnu.org/software/coreutils
$ </computeroutput><userinput>dpkg -l 'b*'</userinput>
<computeroutput>Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                    Version          Architecture     Description
+++-=======================-================-================-====================================================
un  backupninja             &lt;none&gt;           &lt;none&gt;           (no description available)
ii  backuppc                3.3.0-2          amd64            high-performance, enterprise-grade system for backin
un  base                    &lt;none&gt;           &lt;none&gt;           (no description available)
un  base-config             &lt;none&gt;           &lt;none&gt;           (no description available)
ii  base-files              8                amd64            Debian base system miscellaneous files
ii  base-passwd             3.5.37           amd64            Debian base system master password and group files
[...]
$ </computeroutput><userinput>dpkg -c /var/cache/apt/archives/gnupg_1.4.18-6_amd64.deb</userinput>
<computeroutput>drwxr-xr-x root/root         0 2014-12-04 23:03 ./
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/udev/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/udev/rules.d/
-rw-r--r-- root/root      2711 2014-12-04 23:03 ./lib/udev/rules.d/60-gnupg.rules
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/lib/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/lib/gnupg/
-rwxr-xr-x root/root     39328 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_ldap
-rwxr-xr-x root/root     92872 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_hkp
-rwxr-xr-x root/root     47576 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_finger
-rwxr-xr-x root/root     84648 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_curl
-rwxr-xr-x root/root      3499 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_mailto
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/bin/
-rwxr-xr-x root/root     60128 2014-12-04 23:03 ./usr/bin/gpgsplit
-rwxr-xr-x root/root   1012688 2014-12-04 23:03 ./usr/bin/gpg
[...]
$ </computeroutput><userinput>dpkg -I /var/cache/apt/archives/gnupg_1.4.18-6_amd64.deb</userinput>
<computeroutput> new debian package, version 2.0.
 size 1148362 bytes: control archive=3422 bytes.
    1264 bytes,    26 lines      control              
    4521 bytes,    65 lines      md5sums              
     479 bytes,    13 lines   *  postinst             #!/bin/sh
     473 bytes,    13 lines   *  preinst              #!/bin/sh
 Package: gnupg
 Version: 1.4.18-6
 Architecture: amd64
 Maintainer: Debian GnuPG-Maintainers &lt;pkg-gnupg-maint@lists.alioth.debian.org&gt;
 Installed-Size: 4888
 Depends: gpgv, libbz2-1.0, libc6 (&gt;= 2.15), libreadline6 (&gt;= 6.0), libusb-0.1-4 (&gt;= 2:0.1.12), zlib1g (&gt;= 1:1.1.4)
 Recommends: gnupg-curl, libldap-2.4-2 (&gt;= 2.4.7)
 Suggests: gnupg-doc, libpcsclite1, parcimonie, xloadimage | imagemagick | eog
 Section: utils
 Priority: important
 Multi-Arch: foreign
 Homepage: http://www.gnupg.org
 Description: GNU privacy guard - a free PGP replacement
  GnuPG is GNU's tool for secure communication and data storage.
  It can be used to encrypt data and to create digital signatures.
  It includes an advanced key management facility and is compliant
  with the proposed OpenPGP Internet standard as described in RFC 4880.
[...]</computeroutput></screen>

			</example>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> So sánh các phiên bản</title>
			 <indexterm>
				<primary>phiên bản, so sánh </primary>
			</indexterm>
			 <indexterm>
				<primary>so sánh các phiên bản </primary>
			</indexterm>
			 <para>
				Vì <command>dpkg</command> là chương trình để xử lý các gói Debian, nó cũng cung cấp việc thực hiện tham chiếu của so sánh logic số phiên bản. Đây là lý do tại sao nó có tùy chọn <literal>--compare-versions</literal>, có thể sử dụng được bởi các chương trình bên ngoài (đặc biệt là các kịch bản cấu hình được thực hiện bởi <command>dpkg</command>). Tùy chọn này yêu cầu ba tham số: số phiên bản, toán tử so sánh và số phiên bản thứ hai. Các toán tử khác nhau có thể là <literal>lt</literal> (nhỏ hơn), <literal>le</literal> (nhỏ hơn hoặc bằng), <literal>eq</literal>(lớn hơn hoặc bằng), và <literal>gt</literal>(lớn hơn). Nếu so sánh là đúng, <literal>dpkg</literal> trả về 0 (thành công); Nếu không, nó sẽ trả về giá trị khác không (chỉ ra sự thất bại).
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>dpkg --compare-versions 1.2-3 gt 1.1-4</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>0
$ </computeroutput><userinput>dpkg --compare-versions 1.2-3 lt 1.1-4</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>1
$ </computeroutput><userinput>dpkg --compare-versions 2.6.0pre3-1 lt 2.6.0-1</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>1</computeroutput></screen>
			 <para>
				Lưu ý sự thất bại không mong muốn của sự so sánh cuối cùng: cho <command>dpkg</command>, <literal>pre</literal>, thường biểu thị một bản phát hành trước, không có ý nghĩa đặc biệt, và chương trình này so sánh các ký tự chữ cái giống như các con số (a &lt; b &lt; c...), theo thứ tự chữ cái. Đây là lý do tại sao nó coi “<literal>0pre3</literal>” lớn hơn “<literal>0</literal>”, Khi chúng ta muốn số phiên bản của gói để cho biết rằng nó là bản phát hành trước, chúng ta sử dụng ký tự dấu ngã, “<literal>~</literal>”
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>dpkg --compare-versions 2.6.0~pre3-1 lt 2.6.0-1</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>0</computeroutput></screen>
			 </sidebar>
		</section>
		 <section>
			<title>Tệp log của <command>dpkg</command></title>
			 <para>
				<command>dpkg</command> giữ bản ghi chú của tất cả hành động của nó trong <filename>/var/log/dpkg.log</filename>. Nhật ký này cực kỳ chi tiết, vì nó mô tả chi tiết từng giai đoạn thông qua đó các gói được xử lý bởi <command>dpkg</command>. Ngoài việc cung cấp một cách để theo dõi hành vi của dpkg, nó giúp đỡ, trên tất cả, để giữ lịch sử của sự phát triển của hệ thống: người ta có thể tìm thấy thời điểm chính xác khi mỗi gói đã được cài đặt hoặc cập nhật, và thông tin này có thể cực kỳ hữu ích trong sự hiểu biết một sự thay đổi gần đây. Ngoài ra, tất cả các phiên bản được ghi lại, bạn có thể kiểm tra chéo thông tin với <filename>changelog.Debian.gz</filename> cho các gói đang được hỏi hoặc thậm chí với các báo cáo lỗi trực tuyến.
			</para>

		</section>
		 <section id="sect.multi-arch">
			<title>Hỗ trợ Multi-Arch</title>
			 <indexterm>
				<primary>Multi-Arch </primary>
			</indexterm>
			 <indexterm>
				<primary>architecture</primary>
				<secondary>multi-arch support</secondary>
			</indexterm>
			 <para>
				Tất cả các gói Debian có một trường <literal>Architecture</literal> trong tệp contol của chúng. Trường này có thể chứa cả “<literal>all</literal>” (đối với các gói có kiến trúc độc lập) hoặc tên của kiến trúc mà nó cung cấp (như “amd64”, “armhf”,...). Trong trường hợp thứ hai, mặc định, <command>dpkg</command> sẽ chỉ chấp nhận cài đặt gói nếu kiến trúc của nó khớp với kiến trúc của máy chủ lưu trữ như trả về bởi <command>dpkg --print-architecture</command>.
			</para>
			 <para>
				Hạn chế này đảm bảo rằng người dùng không cài đặt các chương trình nhị phân được biên dịch cho một kiến trúc không chính xác. Tất cả mọi thứ sẽ hoàn hảo ngoại trừ một số máy tính có thể chạy các chương trình nhị phân cho nhiều kiến trúc, hoặc tự nhiên (một hệ thống “amd64“ hệ thống có thể chạy tệp thực thi của “i386“ ) hoặc thông qua giả lập.
			</para>
			 <section>
				<title>Kích hoạt Multi-Arch</title>
				 <para>
					Hỗ trợ mutil-arch của <command>dpkg</command> cho phép người dùng định nghĩa “foreign architectures” có thể được cài đặt trên hệ thống hiện tại. Điều này chỉ đơn giản được thực hiện với <command>dpkg --add-architecture</command> như trong ví dụ dưới đây. Và <command>dpkg --remove-architecture </command> tương ứng để bỏ hỗ trợ kiến trúc đó, nhưng chỉ có thể sử dụng khi không có gói nào đang chạy trên kiến trúc này.
				</para>
				 
<screen>
<computeroutput># </computeroutput><userinput>dpkg --print-architecture</userinput>
<computeroutput>amd64
# </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput># </computeroutput><userinput>dpkg -i gcc-4.9-base_4.9.1-19_armhf.deb</userinput>
<computeroutput>dpkg: error processing archive gcc-4.9-base_4.9.1-19_armhf.deb (--install):
 package architecture (armhf) does not match system (amd64)
Errors were encountered while processing:
 gcc-4.9-base_4.9.1-19_armhf.deb
# </computeroutput><userinput>dpkg --add-architecture armhf</userinput>
<computeroutput># </computeroutput><userinput>dpkg --add-architecture armel</userinput>
<computeroutput># </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput>armhf
armel
# </computeroutput><userinput>dpkg -i gcc-4.9-base_4.9.1-19_armhf.deb</userinput>
<computeroutput>Selecting previously unselected package gcc-4.9-base:armhf.
(Reading database ... 86425 files and directories currently installed.)
Preparing to unpack gcc-4.9-base_4.9.1-19_armhf.deb ...
Unpacking gcc-4.9-base:armhf (4.9.1-19) ...
Setting up gcc-4.9-base:armhf (4.9.1-19) ...
# </computeroutput><userinput>dpkg --remove-architecture armhf</userinput>
<computeroutput>dpkg: error: cannot remove architecture 'armhf' currently in use by the database
# </computeroutput><userinput>dpkg --remove-architecture armel</userinput>
<computeroutput># </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput>armhf</computeroutput></screen>
				 <sidebar> <title><emphasis>NOTE</emphasis> Hỗ trợ mutil-arch của APT</title>
				 <para>
					APT sẽ tự động phát hiện khi dpkg đã được cấu hình để hỗ trợ kiến trúc khác và sẽ bắt đầu tải xuống các tệp <filename>Packages</filename> trong quá trình cập nhật.
				</para>
				 <para>
					Các gói foreign có thể được cài đặt với <command>apt install <replaceable>package</replaceable>:<replaceable>architecture</replaceable></command>.
				</para>
				 </sidebar> <sidebar> <title><emphasis>IN PRACTICE</emphasis> Sử dụng các chương trình độc quyền i386 trên amd64</title>
				 <para>
					Có nhiều trường hợp sử dụng cho đa kiến trúc, nhưng phổ biến nhất là khả năng thực hiện các chương trình 32 bit (i386) trên các hệ thống 64 bit (amd64), đặc biệt vì một số ứng dụng sở hữu phổ biến (như Skype) chỉ được cung cấp cho phiên bản 32 bit.
				</para>
				 </sidebar>
			</section>
			 <section>
				<title>Thay đổi Liên quan đến Multi-Arch</title>
				 <para>
					Để làm cho mutil-arch thực sự hữu ích và có ích, các thư viện phải được đóng gói lại và chuyển đến một thư mục cụ thể theo kiến trúc để có thể cài đặt nhiều bản sao (nhắm mục tiêu các kiến trúc khác nhau) bên cạnh. Các gói cập nhật như vậy có chứa trường tiêu đề “<literal>Multi-Arch: same</literal>” để báo với hệ thống quản lý gói rằng các kiến trúc khác nhau của gói có thể được đồng bộ an toàn (và rằng các gói chỉ có thể thỏa mãn sự phụ thuộc của các gói của cùng một kiến trúc). Kể từ khi mutil-arch được xuất hiện trong Debian <emphasis role="distribution">Wheezy</emphasis>, không phải tất cả các thư viện đều đã được chuyển đổi.
				</para>
				 
<screen><computeroutput>$ </computeroutput><userinput>dpkg -s gcc-4.9-base
</userinput><computeroutput>dpkg-query: error: --status needs a valid package name but 'gcc-4.9-base' is not: ambiguous package name 'gcc-4.9-base' with more than one installed instance

Use --help for help about querying packages.
$ </computeroutput><userinput>dpkg -s gcc-4.9-base:amd64 gcc-4.9-base:armhf | grep ^Multi
</userinput><computeroutput>Multi-Arch: same
Multi-Arch: same
$ </computeroutput><userinput>dpkg -L libgcc1:amd64 |grep .so
</userinput><computeroutput>/lib/x86_64-linux-gnu/libgcc_s.so.1
$ </computeroutput><userinput>dpkg -S /usr/share/doc/gcc-4.9-base/copyright
</userinput><computeroutput>gcc-4.9-base:amd64, gcc-4.9-base:armhf: /usr/share/doc/gcc-4.9-base/copyright
</computeroutput></screen>
				 <para>
					Cần lưu ý rằng các gói <literal>Multi-Arch: same</literal> phải có tên phù hợp với kiến trúc của chúng để được nhận dạng rõ ràng. Họ cũng có khả năng chia sẻ tập tin với các trường hợp khác của cùng một gói; <command>dpkg</command> đảm bảo rằng tất cả các gói giống hệt nhau từng bit từng bit một khi chúng được chia sẻ. Cuối cùng nhưng không kém phần quan trọng, tất cả các phiên bản kiến trúc của một gói phải có cùng một số phiên bản. Do đó chúng phải được nâng cấp cùng nhau.
				</para>
				 <para>
					Multi-Arch hỗ trợ cũng mang lại một số thách thức thú vị trong cách xử lý sự phụ thuộc. Phù hợp với sự phụ thuộc đòi hỏi phải có một gói được đánh dấu “<literal>Multi-Arch: foreign</literal>” hoặc một gói có kiến trúc phù hợp với một trong các gói tuyên bố sự phụ thuộc (trong quá trình phân giải phụ thuộc này, các gói độc lập với kiến trúc được giả định là có cùng kiến trúc so với máy chủ). Một phụ thuộc cũng có thể bị yếu để cho phép bất kỳ kiến trúc nào hoàn thành nó với cú pháp <literal><replaceable>package</replaceable>:any</literal>, nhưng gói ngoại chỉ có thể thỏa mãn sự phụ thuộc đó nếu chúng được đánh dấu “<literal>Multi-Arch: allowed</literal>”.
				</para>

			</section>

		</section>

	</section>
	 <section id="sect.coexistence-with-other-packaging-systems">
		<title>Cùng tồn tại với các Hệ thống Gói Khác</title>
		 <indexterm>
			<primary>RPM</primary>
		</indexterm>
		 <indexterm>
			<primary>Trình quản lý Gói Red Hat </primary>
		</indexterm>
		 <indexterm>
			<primary><command>alien</command></primary>
		</indexterm>
		 <para>
			Các gói Debian không phải là gói phần mềm duy nhất được sử dụng trong thế giới phần mềm tự do. Đối thủ cạnh tranh chính là định dạng RPM của bản phân phối Red Hat Linux và các dẫn xuất của nó. Red Hat là một phân phối thương mại rất phổ biến. Do đó các phần mềm được cung cấp bởi bên thứ ba được cung cấp ở gói RPM hơn là Debian.
		</para>
		 <para>
			Trong trường hợp này, bạn nên biết rằng chương trình <command>rpm</command>, xử lý các gói RPM, có sẵn như là một gói Debian, vì vậy bạn có thể sử dụng định dạng gói này trên Debian. Tuy nhiên, cần cẩn thận để hạn chế các thao tác này để trích xuất thông tin từ một gói hàng hoặc để xác minh tính toàn vẹn của nó. Đúng vậy, thật không hợp lý để sử dụng <command>rpm</command> để cài đặt RPM trên một hệ thống Debian; RPM sử dụng cơ sở dữ liệu riêng của nó, tách biệt với các phần mềm gốc (như <command>dpkg</command>). Đây là lý do tại sao không thể đảm bảo sự tồn tại ổn định của hai hệ thống gói.
		</para>
		 <para>
			Mặt khác, tiện ích <emphasis role="pkg">alien</emphasis> có thể chuyển đổi gói RPM thành các gói Debian và ngược lại.
		</para>
		 <sidebar> <title><emphasis>COMMUNITY</emphasis> Khuyến khích việc áp dụng <filename>.deb</filename></title>
		 <para>
			Nếu bạn thường xuyên sử dụng chương trình <command>alien</command> để cài đặt các gói RPM đến từ một trong các nhà cung cấp của bạn, đừng ngần ngại viết thư cho họ và thể hiện sự ưu tiên mạnh mẽ của bạn cho địng dạng <filename>.deb</filename>. Lưu ý rằng định dạng của gói không phải là tất cả mọi thứ: một gói <filename>.deb</filename> được xây dựng với <command>alien</command> hoặc chuẩn bị cho một phiên bản của Debian khác với những gì bạn đạng sử dụng, hoặc thậm chí cho một phân phối phái sinh như Ubuntu, có lẽ sẽ không thể cung cấp với một mức chất lượng và sự tích hợp như một gói được phát triển đặc biệt cho <emphasis role="distribution">Jessie</emphasis>.
		</para>
		 </sidebar> 
<screen>
<computeroutput>$ </computeroutput><userinput>fakeroot alien --to-deb phpMyAdmin-2.0.5-2.noarch.rpm</userinput> 
<computeroutput>phpmyadmin_2.0.5-2_all.deb generated
$ </computeroutput><userinput>ls -s phpmyadmin_2.0.5-2_all.deb</userinput>
<computeroutput>  64 phpmyadmin_2.0.5-2_all.deb</computeroutput></screen>
		 <para>
			Bạn sẽ thấy rằng quá trình này rất đơn giản. Tuy nhiên, bạn phải biết rằng gói được tạo ra không có bất kỳ thông tin phụ thuộc nào, vì các phụ thuộc trong hai định dạng đóng gói không có sự tương thích trong hệ thống kia. Quản trị viên phải tự đảm bảo rằng gói được chuyển đổi sẽ hoạt động chính xác, và đó là lý do tại sao các gói Debian được tự tạo ra nên tránh càng nhiều càng tốt. May mắn thay, Debian có bộ sưu tập lớn nhất các gói phần mềm của tất cả các bản phân phối, và có thể là bất cứ điều gì bạn tìm kiếm đã có trong đó.
		</para>
		 <para>
			Nhìn vào man page của lệnh <command>alien</command>, bạn cũng sẽ lưu ý rằng chương trình này xử lý các định dạng đóng gói khác, đặc biệt là sử dụng bởi phân phối Slackware (nó được làm bằng một tệp nén đơn giản <filename>tar.gz</filename>).
		</para>
		 <para>
			Sự ổn định của phần mềm được triển khai sử dụng công cụ <command>dpkg</command> góp phần vào sự nổi tiếng của Debian. Bộ công cụ APT, được mô tả trong chương tiếp theo, bảo tồn lợi thế này, đồng thời giảm bớt quản trị viên khỏi việc quản lý tình trạng của bao bì, một nhiệm vụ cần thiết nhưng rất khó khăn.
		</para>

	</section>
</chapter>

