<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="packaging-system" lang="vi-VN">
	<chapterinfo>
		 <keywordset>
			<keyword>Gói nhị phân</keyword>
			 <keyword>Gói mã nguồn</keyword>
			 <keyword>dpkg</keyword>
			 <keyword>dependencies</keyword>
			 <keyword>conflict</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Hệ thống gói: Công cụ và Nguyên tắc cơ bản</title>
	 <highlights> <para>
		Như một người quản trị hệ thống Debian, bạn sẽ thường xuyên làm việc với các gói <filename>.deb</filename>, vì chúng chứa các đơn vị chức năng (ứng dụng, tài liệu, etc.) trong việc cài đặt và bảo trì. Vì vậy, là một ý tưởng tốt để biết nó là gì và làm sao đế sử dụng nó.
	</para>
	 </highlights> <para>
		Chương này mô tả kiến trúc và nội dung của các gói “binary” và “source”. Định dạng các tệp tin <filename>.deb</filename>, sử dụng trực tiếp bởi <command>dpkg</command>, sau nữa là mã nguồn, cũng như hướng dẫn xây dựng các gói nhị phân.
	</para>
	 <section id="sect.binary-package-structure">
		<title>Cấu trúc của một Gói nhị phân</title>
		 <indexterm>
			<primary>package</primary>
			<secondary>binary package</secondary>
		</indexterm>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <para>
			The Debian package format is designed so that its content may be extracted on any Unix system that has the classic commands <command>ar</command>, <command>tar</command>, and <command>xz</command> (sometimes <command>gzip</command> or <command>bzip2</command>). This seemingly trivial property is important for portability and disaster recovery.
		</para>
		 <para>
			Imagine, for example, that you mistakenly deleted the <command>dpkg</command> program, and that you could thus no longer install Debian packages. <command>dpkg</command> being a Debian package itself, it would seem your system would be done for... Fortunately, you know the format of a package and can therefore download the <filename>.deb</filename> file of the <emphasis role="pkg">dpkg</emphasis> package and install it manually (see sidebar <xref linkend="sidebar.dpkg-apt-ar" />). If by some misfortune one or more of the programs <command>ar</command>, <command>tar</command> or <command>gzip</command>/<command>xz</command>/<command>bzip2</command> have disappeared, you will only need to copy the missing program from another system (since each of these operates in a completely autonomous manner, without dependencies, a simple copy will suffice). If your system suffered some even more outrageous fortune, and even these don't work (maybe the deepest system libraries are missing?), you should try the static version of <command>busybox</command> (provided in the <emphasis role="pkg">busybox-static</emphasis> package), which is even more self-contained, and provides subcommands such as <command>busybox ar</command>, <command>busybox tar</command> and <command>busybox xz</command>.
		</para>
		 <sidebar id="sidebar.dpkg-apt-ar"> <title><emphasis>Các công cụ</emphasis> <command>dpkg</command>, <command>APT</command> and <command>ar</command></title>
		 <indexterm>
			<primary><command>dpkg</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <indexterm>
			<primary>APT</primary>
		</indexterm>
		 <para>
			<command>dpkg</command> là chương trình xử lý tệp tin <filename>.deb</filename>, chủ yếu cài đặt, phân tích và giải nén các tập tin.
		</para>
		 <para>
			<command>APT</command> là một nhóm các chương trình cho phép thực hiện các thay đổi cấp cao hơn tới hệ thống: cài đặt và xoá một gói (trong khi giữ phụ thuộc một cách tốt), cập nhật hệ thống, liệt kê các gói đã có, vân vân.
		</para>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <para>
			As for the <command>ar</command> program, it allows handling files of the same name: <command>ar t <replaceable>archive</replaceable></command> displays the list of files contained in such an archive, <command>ar x <replaceable>archive</replaceable></command> extracts the files from the archive into the current working directory, <command>ar d <replaceable>archive</replaceable> <replaceable>file</replaceable></command> deletes a file from the archive, etc. Its man page (<citerefentry><refentrytitle>ar</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry>) documents all its other features. <command>ar</command> is a very rudimentary tool that a Unix administrator would only use on rare occasions, but admins routinely use <command>tar</command>, a more evolved archive and file management program. This is why it is easy to restore <command>dpkg</command> in the event of an erroneous deletion. You would only have to download the Debian package and extract the content from the <filename>data.tar.xz</filename> archive in the system's root (<filename>/</filename>):
		</para>
		 
<screen>
<computeroutput># </computeroutput><userinput>ar x dpkg_1.18.24_amd64.deb</userinput>
<computeroutput># </computeroutput><userinput>tar -C / -p -xJf data.tar.xz</userinput></screen>
		 </sidebar> <sidebar> <title><emphasis>Trở về cơ bản</emphasis> Man page notation</title>
		 <para>
			Có thể nhầm lần cho người mới bắt đầu để tham chiếu tới “<citerefentry><refentrytitle>ar</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry>” trong các tài liệu. Đây là thường là một phương tiện tiện lợi để tham chiếu tới trang tài liệu <literal>ar</literal> trong nội dung 1.
		</para>
		 <para>
			Đôi khi những ký hiệu này cũng được sử dụng để loại bỏ những mơ hồ, ví dụ phân biệt giữa lệnh <command>printf</command> lệnh này có thể cũng được chỉ ra bởi <citerefentry><refentrytitle>printf</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry> và hàm <function>printf</function> trong ngôn ngữ lập trình C, có thể được tham chiếu bằng <citerefentry><refentrytitle>printf</refentrytitle>
			<manvolnum>3</manvolnum></citerefentry>.
		</para>
		 <para>
			<xref linkend="solving-problems" /> thảo luận về trang hương dẫn chi tiết hơn (see <xref linkend="sect.manual-pages" />).
		</para>
		 </sidebar> <para>
			Cái nhìn về nội dung trong tệp tin <filename>.deb</filename>
		</para>
		 
<screen><computeroutput>$ </computeroutput><userinput>ar t dpkg_1.18.24_amd64.deb</userinput>
<computeroutput>debian-binary
control.tar.gz
data.tar.xz
$ </computeroutput><userinput>ar x dpkg_1.18.24_amd64.deb</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>control.tar.gz  data.tar.xz  debian-binary  dpkg_1.18.24_amd64.deb
$ </computeroutput><userinput>tar tJf data.tar.xz | head -n 15</userinput>
<computeroutput>./
./etc/
./etc/alternatives/
./etc/alternatives/README
./etc/cron.daily/
./etc/cron.daily/dpkg
./etc/dpkg/
./etc/dpkg/dpkg.cfg
./etc/dpkg/dpkg.cfg.d/
./etc/logrotate.d/
./etc/logrotate.d/dpkg
./sbin/
./sbin/start-stop-daemon
./usr/
./usr/bin/
$ </computeroutput><userinput>tar tzf control.tar.gz</userinput>
<computeroutput>./
./conffiles
./postinst
./md5sums
./prerm
./control
./postrm
$ </computeroutput><userinput>cat debian-binary</userinput>
<computeroutput>2.0</computeroutput></screen>
		 <para>
			Như bạn có thể thấy, với góc nhìn qua tệp nén từ lệnh <command>ar</command> của một gói Debian gồm có ba tập tin:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					<filename>debian-binary</filename>. This is a text file which simply indicates the version of the <filename>.deb</filename> file used (in 2017: version 2.0).
				</para>

			</listitem>
			 <listitem>
				<para>
					<filename>control.tar.gz</filename>. Đây là tệp nén chứa tất cả thông tin meta, giống như tên và phiên bản của gói. Một vài thông tin cho phép các công cụ quản lý gói xác định nếu nó có thể cài đặt hoặc gỡ bỏ được nó, ví dụ thể hiện danh sách các gói đã có trên máy tính.
				</para>

			</listitem>
			 <listitem>
				<para>
					<filename>data.tar.xz</filename>. This archive contains all of the files to be extracted from the package; this is where the executable files, documentation, etc., are all stored. Some packages may use other compression formats, in which case the file will be named differently (<filename>data.tar.bz2</filename> for bzip2, <filename>data.tar.gz</filename> for gzip).
				</para>

			</listitem>

		</itemizedlist>

	</section>
	 <section id="sect.package-meta-information">
		<title>Package Meta-Information</title>
		 <indexterm>
			<primary>package meta-information</primary>
		</indexterm>
		 <indexterm>
			<primary>package</primary>
			<secondary>meta-information</secondary>
		</indexterm>
		 <para>
			Gói Debian không chỉ là một lưu trữ của các tệp tin dành cho cài đặt. Nó là một phần tổng thể lớn hơn, và nó mô tả mối quan hệ với các gói Debian khác (phụ thuộc, xung đột hay gợi ý). Nó còn cung cấp các kịch bản cho phép thực hiện các câu lệnh ở các giai đoạn khác nhau trong vòng đời của gói (cài đặt, gỡ bỏ và nâng cấp). Các dữ liệu này được sử dụng bởi trình quản lý gói nhưng không phải là một phần của phần mềm đóng gói; những dữ liệu trong gói, được gọi với tên là “meta-information” (thông tin về các thông tin khác).
		</para>
		 <section id="sect.control">
			<title>Mô tả: tệp tin <filename>control</filename></title>
			 <indexterm>
				<primary>package meta-information</primary>
			</indexterm>
			 <indexterm>
				<primary>package</primary>
				<secondary>meta-information</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>control</filename></primary>
			</indexterm>
			 <para>
				Tệp này sử dụng một cấu trúc giống như headers của email (định nghĩa ở RFC 2822). Ví dụ, cho gói <emphasis role="pkg">apt</emphasis>, tệp tin <filename>control</filename> trông giống như sau:
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>apt-cache show apt</userinput>
<computeroutput>Package: apt
Version: 1.4.8
Installed-Size: 3539
Maintainer: APT Development Team &lt;deity@lists.debian.org&gt;
Architecture: amd64
Replaces: apt-utils (&lt;&lt; 1.3~exp2~)
Depends: adduser, gpgv | gpgv2 | gpgv1, debian-archive-keyring, init-system-helpers (&gt;= 1.18~), libapt-pkg5.0 (&gt;= 1.3~rc2), libc6 (&gt;= 2.15), libgcc1 (&gt;= 1:3.0), libstdc++6 (&gt;= 5.2)
Recommends: gnupg | gnupg2 | gnupg1
Suggests: apt-doc, aptitude | synaptic | wajig, dpkg-dev (&gt;= 1.17.2), powermgmt-base, python-apt
Breaks: apt-utils (&lt;&lt; 1.3~exp2~)
Description-en: commandline package manager
 This package provides commandline tools for searching and
 managing as well as querying information about packages
 as a low-level access to all features of the libapt-pkg library.
 .
 These include:
  * apt-get for retrieval of packages and information about them
    from authenticated sources and for installation, upgrade and
    removal of packages together with their dependencies
  * apt-cache for querying available information about installed
    as well as installable packages
  * apt-cdrom to use removable media as a source for packages
  * apt-config as an interface to the configuration settings
  * apt-key as an interface to manage authentication keys
Description-md5: 9fb97a88cb7383934ef963352b53b4a7
Tag: admin::package-management, devel::lang:ruby, hardware::storage,
 hardware::storage:cd, implemented-in::c++, implemented-in::perl,
 implemented-in::ruby, interface::commandline, network::client,
 protocol::ftp, protocol::http, protocol::ipv6, role::program,
 scope::application, scope::utility, sound::player, suite::debian,
 use::downloading, use::organizing, use::searching, works-with::audio,
 works-with::software:package, works-with::text
Section: admin
Priority: important
Filename: pool/main/a/apt/apt_1.4.8_amd64.deb
Size: 1231676
MD5sum: 4963240f23156b2dda3affc9c0d416a3
SHA256: bc319a3abaf98d76e7e13ac97ab0ee7c238a48e2d4ab85524be8b10cfd23d50d</computeroutput></screen>
			 <sidebar> <title><emphasis>QUAY VỀ CƠ BẢN</emphasis> RFC — Các chuẩn Internet</title>
			 <indexterm>
				<primary>RFC</primary>
			</indexterm>
			 <indexterm>
				<primary>Request For Comments</primary>
			</indexterm>
			 <para>
				RFC là viết tắt của “Request For Comments”. Một RFC nói chung là một tài liệu kỹ thuật mô tả những gì sẽ trở thành một tiêu chuẩn Internet. Trước khi trở thành tiêu chuẩn hóa và đóng băng, các tiêu chuẩn này được gửi cho công cộng xem xét (đó là lý do đặt tên). IETF (Internet Engineering Task Force) quyết định về sự chuyển đổi các trạng thái của các tài liệu (tiêu chuẩn đề xuất, dự thảo tiêu chuẩn, hoặc tiêu chuẩn).
			</para>
			 <para>
				RFC 2026 định nghĩa quá trình tiêu chuẩn hóa của các giao thức Internet. <ulink type="block" url="http://www.faqs.org/rfcs/rfc2026.html" />
			</para>
			 </sidebar> <section>
				<title>Các phụ thuộc: trường <literal>Depends</literal></title>
				 <indexterm>
					<primary>dependency</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Depends</literal>, header field</primary>
				</indexterm>
				 <indexterm>
					<primary>package</primary>
					<secondary>dependency</secondary>
				</indexterm>
				 <para>
					Các phụ thuộc được định nghĩa ở trường <literal>Depends</literal> trong tiêu đề gói. Đây là danh sách các điều kiện để đáp ứng cho các gói làm việc chính xác - thông tin này được sử dụng bởi các công cụ như <command>apt</command> để cài đặt các thư viện cần thiết, với các phiên bản thích hợp phù hợp với các sự phụ thuộc của gói được cài đặt. Đối với mỗi phụ thuộc, nó có thể hạn chế phạm vi của các phiên bản đáp ứng được điều kiện đó. Nói cách khác, nó có thể để bày tỏ một thực tế rằng chúng ta cần gói <emphasis role="pkg">libc6</emphasis> trong một phiên bản tương đương hoặc lớn hơn “2.15” (viết “<command>libc6 (&gt;= 2.15)</command>”). Toán tử so sánh phiên bản như sau:
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							<command>&lt;&lt;</command>: bé hơn;
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&lt;=</command>: bé hơn hoặc bằng;
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>=</command>: bằng (hãy nhớ “<literal>2.6.1</literal>” không bằng với “<literal>2.6.1-1</literal>”);
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&gt;=</command>: lớn hơn hoặc bằng;
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&gt;&gt;</command>: lớn hơn.
						</para>

					</listitem>

				</itemizedlist>
				 <para>
					In a list of conditions to be met, the comma serves as a separator. It must be interpreted as a logical “and”. In conditions, the vertical bar (“|”) expresses a logical “or” (it is an inclusive “or”, not an exclusive “either/or”). Carrying greater priority than “and”, it can be used as many times as necessary. Thus, the dependency “(A or B) and C” is written <command>A | B, C</command>. In contrast, the expression “A or (B and C)” should be written as “(A or B) and (A or C)”, since the <literal>Depends</literal> field does not tolerate parentheses that change the order of priorities between the logical operators “or” and “and”. It would thus be written <command>A | B, A | C</command>. <ulink type="block" url="https://www.debian.org/doc/debian-policy/#document-ch-relationships" />
				</para>
				 <indexterm>
					<primary>meta-package</primary>
				</indexterm>
				 <para>
					Hệ thống phụ thuộc là một cơ chế tốt để đảm bảo các hoạt động của một chương trình, nhưng nó còn sử dụng cho “meta-packages”. Đây là gói không chứa nội dung chương trình mà chỉ mô tả phụ thuộc. Nó tạo điều kiện cho quá trình cài đặt của một nhóm các chương trình được phù hợp chọn trước bởi nhà bảo trì meta-package; như vậy, <command>apt install <replaceable>meta-package</replaceable></command> sẽ tự động cài đặt tất cả các chương trình sử dụng các phụ thuộc của meta-package. Các gói <emphasis role="pkg">gnome</emphasis>, <emphasis role="pkg">kde-full</emphasis> and <emphasis role="pkg">linux-image-amd64</emphasis> là ví dụ của meta-packages.
				</para>
				 <sidebar> <title><emphasis>DEBIAN POLICY</emphasis> <literal>Pre-Depends</literal>, một đòi hỏi nhiều hơn <literal>Depends</literal></title>
				 <indexterm>
					<primary><literal>Pre-Depends</literal>, trường header</primary>
				</indexterm>
				 <indexterm>
					<primary>pre-dependency</primary>
				</indexterm>
				 <para>
					“Pre-dependencies”, mà được liệt kê ở trường “<literal>Pre-Depends</literal>” trong tiêu đề gói, ổn định cho sự phụ thuộc bình thường; cú pháp của là giống hệt nhau. Một phụ thuộc bình thường chỉ ra rằng các gói trong trường cần phải được giải nén và cấu hình trước khi cấu hình của gói tuyên bố sự phụ thuộc. Một tiền phụ thuộc (pre) quy định rằng các gói trong trường của nó cần phải được giải nén và cấu hình trước khi thực hiện các kịch bản cài đặt sẵn của gói tuyên bố của tiền phụ thuộc, đó là trước khi cài đặt của nó.
				</para>
				 <para>
					Một phụ thuộc trước là rất cần thiết cho <command>apt</command>, vì nó thêm một hạn chế nghiêm ngặt về thứ tự các gói để cài đặt. Vì vậy, các phụ thuộc trước không được khuyến khích trừ khi thật sự cần thiết. Thậm chí còn khuyến khích tham khảo các ý kiến từ các nhà phát triển trên <email>debian-devel@lists.debian.org</email> trước khi thêm một tiền phụ thuộc. Thường có thể tìm thấy giải pháp khác xung quanh vấn đề đấy.
				</para>
				 </sidebar> <sidebar> <title><emphasis>DEBIAN POLICY</emphasis> <literal>Recommends</literal>, <literal>Suggests</literal>, và <literal>Enhances</literal> fields</title>
				 <indexterm>
					<primary><literal>Recommends</literal>, trường header</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Suggests</literal>, trường header</primary>
				</indexterm>
				 <para>
					Trường <literal>Recommends</literal> và <literal>Suggests</literal> mô tả các sự phụ thuộc mà không bắt buộc. Trường “recommended”, quan trọng nhất, cải thiện đáng kể các chức năng được cung cấp bởi các gói nhưng không phải là không thể thiếu để hoạt động. Trường “suggested”, quan trọng thứ 2, chỉ ra rằng gói nhất định có thể bổ sung và tăng tiện ích của mình, nhưng nó là hoàn toàn hợp lý để cài đặt một mà không có những cái khác.
				</para>
				 <para>
					Bạn nên thường xuyên cài đặt các gói “recommended”, trừ khi bạn biết chính xác tại sao bạn không cần chúng. Ngược lại, bạn không cần thiết phải cài đặt các gói “suggested” trừ khi bạn biết tại sao bạn cần chúng.
				</para>
				 <indexterm>
					<primary><literal>Enhances</literal>, trường</primary>
				</indexterm>
				 <para>
					Trường <literal>Enhances</literal> cũng miêu tả một sự gợi ý, nhưng có một điều khác biệt. Nó thực sự nằm trong các gói gợi ý, và không có các lợi ích từ sự gợi ý này. Quan tâm của nó nằm ở chỗ có thểm thêm các gợi ý mà không sửa đổi các gói phần mềm liên quan. Do đó, tất cả các add-on, plug-ins, và các thành phần mở rộng khác của một chương trình có thể xuất hiện ở trường này. Mặc dầu nó đã tồn tại trong vài năm, nhưng trường này vẫn bị bỏ qua bởi các chương trình như <command>apt</command> hoặc <command>synaptic</command>. Mục đích của nó cho một sự gợi ý từ trường <literal>Enhances</literal> cho người dùng trong tìm ra trường <literal>Enhances</literal>.
				</para>
				 </sidebar>
			</section>
			 <section>
				<title>Xung đột: trường <literal>Conflicts</literal></title>
				 <indexterm>
					<primary>conflicts</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Conflicts</literal>, trường header</primary>
				</indexterm>
				 <indexterm>
					<primary>package</primary>
					<secondary>conflict</secondary>
				</indexterm>
				 <para>
					Trường <literal>Conflicts</literal> chỉ ra rằng khi một gói không thể cài đặt trong trường hơp với gói khác. Phần lớn lý do chung cho vấn đề này là cả hai gói đều bao gốm giống tên nhau, hoặc cung cấp các dịch vụ như nhau ở cùng cổng TCP, hoặc sẽ cản trở hoạt động của gói kia.
				</para>
				 <para>
					<command>dpkg</command> sẽ từ chối cài đặt một gói nếu nó gây xung đột với một trong các gói đã cài đặt, ngoại trừ gói mới đặc biệt nó sẽ “thay thế” gói đã cài đặt, trong trường hợp <command>dpkg</command> sẽ chọn để thay thế gói cũ với gói mới, nó sẽ tự động đề nghị gỡ bỏ gói có vẻ có vấn đề.
				</para>

			</section>
			 <section>
				<title>Không tương thích: trường <literal>Breaks</literal></title>
				 <indexterm>
					<primary>incompatibilities</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Breaks</literal>, header trường</primary>
				</indexterm>
				 <indexterm>
					<primary>package</primary>
					<secondary>không tương thích</secondary>
				</indexterm>
				 <para>
					Trường <literal>Breaks</literal> có tác dụng khá giống với trường <literal>Conflicts</literal>, nhưng với một nghĩa đặc biệt. Nó báo hiệu rằng nếu cài đặt gói này sẽ “làm hỏng” gói khác (hoặc cụ thể là phiên bản của nó). Nói chung, sự không thương thích này giữa hai gói là tạm thời, và trường <literal>Breaks</literal> quan hệ đặc biệt với các phiên bản không tương thích.
				</para>
				 <para>
					<command>dpkg</command> sẽ từ chối cài đặt một gói nếu nó làm hỏng một gói đã cài đặt, và <command>apt</command> sẽ cố giải quyết vấn đề bằng cách cập nhật gói đó lên phiên bản mới nhất (đây là giả định sẽ sửa được và do vậy lại tương thích).
				</para>
				 <para>
					Tình hình này có thể xảy ra trong trường hợp cập nhật mà không tương thích ngược: Trong trường hợp này nếu phiên bản mới hơn không còn các chức năng như phiên bản cũ, và gây ra một sự cố trong chương trình khác mà không làm gì đặc biệt. Trường <literal>Breaks</literal> ngăn cản người dùng gặp cả những vấn đề này.
				</para>

			</section>
			 <section>
				<title>Cung cấp Các mục: Trường <literal>Provides</literal></title>
				 <indexterm>
					<primary><literal>Provides</literal>, trường header</primary>
				</indexterm>
				 <para>
					Trường này giới thiệu khái niệm rất thú vị của một “gói ảo”. Nó có nhiều vai trò, nhưng hai trong số đó là quan trọng nhất. Vai trò thứ nhất bao gồm trong sử dụng gói để liên kết với một dịch vụ chung với nó (gói “cung cấp” dịch vụ). Vai trò thứ hai chỉ ra rằng một gói hoàn toàn thay thế một gói khác, và do mục đích này mà nó cũng có thể đáp ứng các phụ thuộc mà gói kia đáp ứng. Do đó có khả năng tạo ra một gói thay thế mà không cần sử dụng cùng tên gói.
				</para>
				 <sidebar> <title><emphasis>VOCABULARY</emphasis> Meta-package và virtual package</title>
				 <indexterm>
					<primary>meta-package</primary>
				</indexterm>
				 <indexterm>
					<primary>package</primary>
					<secondary>virtual package</secondary>
				</indexterm>
				 <indexterm>
					<primary>virtual package</primary>
				</indexterm>
				 <para>
					Cần phân biệt rõ ràng các gói meta từ các gói ảo. Trước đây là các gói thực (bao gồm các tập tin thực <filename>.deb</filename>), mà mục đích duy nhất của nó là để thể hiện sự phụ thuộc.
				</para>
				 <para>
					Các gói ảo, tuy nhiên, không tồn tại về mặt thể chất; chúng chỉ mang nghĩa để xác định các gói thực dựa trên các tiêu chí chung, hợp lý (cung cấp dịch vụ, khả năng tương thích với một chương trình chuẩn hoặc một có sẵn trước, vv).
				</para>
				 </sidebar> <section>
					<title>Đang cung cấp một “Service”</title>
					 <para>
						Chúng ta sẽ thảo luận về trường hợp đầu tiên chi tiết hơn với một ví dụ: tất cả máy chủ mail, ví dụ như <emphasis role="pkg">postfix</emphasis> hoặc <emphasis role="pkg">sendmail</emphasis> “cung cấp” gói <emphasis role="pkg">mail-transport-agent</emphasis> ảo. Thế nên, bất kỳ gói nào cần dịch vụ này để làm tính năng (ví dụ: quản lý mailing list, hay như là <emphasis role="pkg">smartlist</emphasis> hoặc <emphasis role="pkg">sympa</emphasis>) đơn giản là chỉ cần chỉ định phụ thuộc của nó yêu cầu một <emphasis role="pkg">mail-transport-agent</emphasis> thay vi chỉ định một danh sách lớn các giải pháp có thể (ví dụ: <command>postfix | sendmail | exim4 | …</command>). Hơn nữa, không cần thiết phải cài đặt hai máy chủ mail trên cùng một máy, đó là lý do mỗi gói này tuyên bố xung đột với gói ảo <emphasis role="pkg">mail-transport-agent</emphasis>. Một xung đột giữ gói của chính nó sẽ bị hệ thống bỏ qua nhưng kỹ thuật này sẽ cấm cài đặt hai máy chủ mail song song.
					</para>
					 <sidebar> <title><emphasis>DEBIAN POLICY</emphasis> Danh sách các gói ảo</title>
					 <indexterm>
						<primary>package</primary>
						<secondary>virtual package</secondary>
					</indexterm>
					 <para>
						Đối với các gói ảo là hữu ích, tất cả mọi người phải đồng ý về tên của chúng, đây là lý do tại sao chúng được tiêu chuẩn hóa trong Chính sách Debian, trong đó có một số khác<emphasis role="pkg">mail-transport-agent</emphasis> cho máy chủ mail, <emphasis role="pkg">c-compiler</emphasis> cho trình biên dịch ngôn ngữ lập trình C, u<emphasis role="pkg">www-browser</emphasis> cho các trình duyệt web, <emphasis role="pkg">httpd</emphasis> cho các máy chủ web, <emphasis role="pkg">ftp-server</emphasis> cho máy chủ FTP, u<emphasis role="pkg">x-terminal-emulator</emphasis> cho trình mô phỏng thiết bị đầu cuối ở chế độ đồ hoạ (<command>xterm</command>), và <emphasis role="pkg">x-window-manager</emphasis> cho các trình quản lý cửa sổ.
					</para>
					 <para>
						Danh sách đầy đủ có thể được tìm thấy trên Web. <ulink type="block" url="http://www.debian.org/doc/packaging-manuals/virtual-package-names-list.txt" />
					</para>
					 </sidebar>
				</section>
				 <section>
					<title>Khả năng trao đổi với một Gói khác</title>
					 <para>
						The <literal>Provides</literal> field is also interesting when the content of a package is included in a larger package. For example, the <emphasis role="pkg">libdigest-md5-perl</emphasis> Perl module was an optional module in Perl 5.6, and has been integrated as standard in Perl 5.8 (and later versions, such as 5.24 present in <emphasis role="distribution">Stretch</emphasis>). As such, the package <emphasis role="pkg">perl</emphasis> has since version 5.8 declared <literal>Provides: libdigest-md5-perl</literal> so that the dependencies on this package are met if the user has Perl 5.8 (or newer). The <emphasis role="pkg">libdigest-md5-perl</emphasis> package itself has eventually been deleted, since it no longer had any purpose when old Perl versions were removed.
					</para>
					 <figure>
						<title>Sử dụng trường <literal>Provides</literal> để không phá vỡ sự phụ thuộc</title>
						 <mediaobject>
							<imageobject>
								<imagedata fileref="images/virtual-package.png" format="PNG" width="50%" />
							</imageobject>

						</mediaobject>

					</figure>
					 <para>
						Tính năng này rất hữu ích vì không thể lường trước được sự biến động của sự phát triển và cần phải có khả năng điều chỉnh để đổi tên và thay thế tự động các phần mềm đã lỗi thời.
					</para>
					 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Perl, một ngôn ngữ lập trình</title>
					 <indexterm>
						<primary>Perl</primary>
					</indexterm>
					 <indexterm>
						<primary>CPAN</primary>
					</indexterm>
					 <para>
						Perl (Practical Extraction and Report Language) là một ngôn ngữ lập trình rất phổ biến. Nó có nhiều mô đun sẵn sàng để sử dụng, bao gồm một loạt các ứng dụng rộng lớn và được phân phối bởi các máy chủ CPAN (Mạng Toàn diện Perl Archive), một mạng lưới đầy đủ các gói Perl. <ulink type="block" url="http://www.perl.org/" /> <ulink type="block" url="http://www.cpan.org/" />
					</para>
					 <para>
						Vì nó là một ngôn thông dịch nên một chương trình được viết bằng Perl không yêu cầu biên dịch trước khi thực hiện. Đây là lý do tại sao chúng được gọi là “các kịch bản Perl”.
					</para>
					 </sidebar>
				</section>
				 <section>
					<title>Hạn chế trong Quá khứ</title>
					 <para>
						Các gói ảo được sử dụng để bị một số hạn chế, đáng kể nhất là không có số phiên bản. Trở lại ví dụ trước, một sự phụ thuộc như <literal>Depends: libdigest-md5-perl (&gt;= 1.6)</literal>, bất chấp sự có mặt của Perl_5.10, sẽ không bao giờ được coi là thỏa mãn bởi hệ thống gói - trong khi trên thực tế nó rất có thể là thỏa mãn. Không biết về điều này, hệ thống gói đã chọn lựa chọn ít rủi ro nhất, giả định rằng các phiên bản không khớp.
					</para>
					 <para>
						This limitation has been lifted in <emphasis role="pkg">dpkg</emphasis> 1.17.11, and is no longer relevant in Stretch. Packages can assign a version to the virtual packages they provide with a dependency such as <literal>Provides: libdigest-md5-perl (= 1.8)</literal>.
					</para>

				</section>

			</section>
			 <section>
				<title>Thay thế Các tệp: Trường <literal>Replaces</literal></title>
				 <indexterm>
					<primary>replacement</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Replaces</literal>, trường tiêu đề </primary>
				</indexterm>
				 <indexterm>
					<primary>package</primary>
					<secondary>replacement</secondary>
				</indexterm>
				 <para>
					Trường <literal>Replaces</literal> chỉ ra rằng gói chứa các tệp có trong gói khác nhưng gói đó có quyền thay thế chúng một cách hợp pháp. Nếu không sử dụng đặc tả này, <literal>dpkg</literal> sẽ báo lỗi, nó không thể ghi đè lên các tệp của một gói khác (về mặt kỹ thuật, dĩ nhiên có thể buộc nó làm như vậy với tùy chọn <literal>--force-overwrite</literal>, nhưng đó không phải là cách hay). Điều này cho phép xác định các vấn đề tiềm ẩn và yêu cầu người bảo trì phải nghiên cứu vấn đề trước khi lựa chọn có nên thêm vào một trường như thế hay không.
				</para>
				 <para>
					Việc sử dụng trường này là hợp lý khi tên gói thay đổi hoặc khi gói được bao gồm trong một gói khác. Điều này cũng xảy ra khi người bảo trì quyết định phân phối các tệp tin khác nhau giữa các gói nhị phân khác nhau được tạo ra từ cùng một gói nguồn: tệp được thay thế không còn thuộc về gói cũ nữa, nhưng chỉ cần tệp thay thế mới.
				</para>
				 <para>
					Nếu tất cả các tệp trong gói được cài đặt đã được thay thế, gói được coi là đã bị xóa. Cuối cùng, trường này cũng khuyến khích <command>dpkg</command> để gỡ bỏ gói thay thế nơi có sự xung đột.
				</para>
				 <sidebar id="sidebar.debtags"> <title><emphasis>GOING FURTHER</emphasis> Trường <literal>Tag</literal></title>
				 <para>
					In the <emphasis role="pkg">apt</emphasis> example above, we can see the presence of a field that we have not yet described, the <literal>Tag</literal> field. This field does not describe a relationship between packages, but is simply a way of categorizing a package in a thematic taxonomy. This classification of packages according to several criteria (type of interface, programming language, domain of application, etc.) has been available for a long time. Despite this, not all packages have accurate tags and it is not yet integrated in all Debian tools; <command>aptitude</command> displays these tags, and allows them to be used as search criteria. For those who are repelled by <command>aptitude</command>'s search criteria, the following website allows navigation of the tag database: <ulink type="block" url="https://wiki.debian.org/Debtags" />
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.configuration-scripts">
			<title>Kịch bản Cấu hình</title>
			 <indexterm>
				<primary><filename>postinst</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>preinst</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>postrm</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>prerm</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>control.tar.gz</filename></primary>
			</indexterm>
			 <para>
				Ngoài tệp <filename>control</filename>, tệp nén <filename>control.tar.gz</filename> của mỗi gói Debian có thể chứa một số kịch bản, được gọi bởi <command>dpkg</command> ở các giai đoạn khác nhau trong việc xử lý gói. Chính sách Debian mô tả có thể có nhiều trường hợp chi tiết, xác định các kịch bản được gọi và các đối số mà chúng nhận được. Các thực hiện kịch bản này có thể phức tạp, vì nếu một trong các kịch bản không thành công, <command>dpkg</command> sẽ cố gắng trở lại trạng thái trước bằng cách hủy bỏ quá trình cài đặt hoặc xóa bỏ tiến trình (trong chừng mực có thể).
			</para>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> cơ sở dữ liệu của <command>dpkg</command></title>
			 <indexterm>
				<primary><filename>/var/lib/dpkg/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>dpkg</primary>
				<secondary>database</secondary>
			</indexterm>
			 <para>
				Tất cả các kịch bản cấu hình cho các gói đã được cài đặt đều được lưu trữ trong thư mục <filename>/var/lib/dpkg/info/</filename>, dưới dạng một tập tin được đặt tên với tiền tố là tên của gói. Thư mục này cũng bao gồm một tệp có phần mở rộng <filename>.list</filename> cho mỗi gói, chứa danh sách các tệp thuộc gói đó.
			</para>
			 <para>
				Tệp tin <filename>/var/lib/dpkg/status</filename> chứa một loạt các khối dữ liệu (theo định dạng của tiêu đề thư nổi tiếng, RFC 2822) mô tả trạng thái của mỗi gói. Thông tin từ tệp tin <filename>control</filename> của các gói được cài đặt cũng được sao chép ở đó.
			</para>
			 </sidebar> <para>
				Nói chung, kịch bản <filename>preinst</filename> được thực hiện trước khi cài đặt gói, trong khi kịch bản <filename>postinst</filename> là sau khi cài đặt. Tương tự, <filename>prerm</filename> được gọi trước khi loại bỏ một gói và <filename>postrm</filename> sau khi loại bỏ gói xong. Bản cập nhật của một gói tương đương với việc loại bỏ phiên bản trước đó và cài đặt gói mới. Không thể mô tả chi tiết tất cả các kịch bản có thể ở đây nhưng chúng ta sẽ thảo luận hai vấn đề phổ biến nhất: cài đặt/cập nhật và gỡ bỏ.
			</para>
			 <sidebar> <title><emphasis>CAUTION</emphasis> Tên tượng trưng của kịch bản</title>
			 <para>
				Trong phần này, chúng ta sẽ gọi các kịch bản cụ thể để phân biệt giữa gói của và gói mới sắp cập nhật, chẳng hạn như là <command>old-prerm</command> hoặc <command>new-postinst</command>. Chúng tưng úng là <command>perm</command> được ở trong phiên bản cũ của gói (được cài đặt trước bản cập nhật) và kịch bản <command>postinst</command> ở trong tệp mới (bản cập nhật gói mới).
			</para>
			 </sidebar> <sidebar> <title><emphasis>TIP</emphasis> Sơ đồ trạng thái</title>
			 <para>
				Manoj Srivastava made these diagrams explaining how the configuration scripts are called by <command>dpkg</command>. Similar diagrams have also been developed by the Debian Women project; they are a bit simpler to understand, but less complete. <ulink type="block" url="https://people.debian.org/~srivasta/MaintainerScripts.html" /> <ulink type="block" url="https://www.debian.org/doc/debian-policy/#maintainer-script-flowcharts" />
			</para>
			 </sidebar> <section>
				<title>Cài đặt và Nâng cấp</title>
				 <indexterm>
					<primary><command>dpkg</command></primary>
					<secondary>hoạt động nội bộ</secondary>
				</indexterm>
				 <para>
					Dưới đây là những gì xảy ra trong quá trình cài đặt (hoặc cập nhật):
				</para>
				 <orderedlist>
					<listitem>
						<para>
							Đối với cập nhật, <command>dpkg</command> gọi <command>old-prerm upgrade <replaceable>new-version</replaceable></command>.
						</para>

					</listitem>
					 <listitem>
						<para>
							Vẫn với cập nhật, <command>dpkg</command> sau đó thực hiện <command>new-preinst upgrade <replaceable>old-version</replaceable></command>; đối với lần cài đặt đầu tiên, nó thực hiện <command>new-preinst install</command>. Có thể thêm phiên bản cũ vào tham số theo sau, nếu gói đã được cài đặt và gỡ bỏ trước (nhưng không bị xóa, các tệp cấu hình đã được giữ lại).
						</para>

					</listitem>
					 <listitem>
						<para>
							Các tệp gói mới sau đó được giải nén. Nếu một tập tin đã tồn tại, nó được thay thế, nhưng một bản sao lưu tạm thời được thực hiện.
						</para>

					</listitem>
					 <listitem>
						<para>
							Cho cập nhật, <command>dpkg</command> thực hiện <command>old-postrm upgrade <replaceable>new-version</replaceable></command>.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> cập nhật tất cả dữ liệu nội bộ (danh sách tệp, tập lệnh cấu hình, v.v.) và loại bỏ các bản sao lưu của các tệp được thay thế. Đây là điểm không trở lại: <command>dpkg</command> không còn truy cập vào tất cả các yếu tố cần thiết để trở về trạng thái trước đó.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> sẽ cập nhật các tệp cấu hình, hỏi người dùng quyết định xem nó có thể tự động quản lý tác vụ này không. Các chi tiết của thủ tục này được thảo luận trong <xref linkend="sect.conffiles" />.
						</para>

					</listitem>
					 <listitem>
						<para>
							Cuối cùng, <command>dpkg</command> cấu hình gói bằng cách thực hiện <command>new-postinst configure <replaceable>last-version-configured</replaceable></command>.
						</para>

					</listitem>

				</orderedlist>

			</section>
			 <section>
				<title>Xóa Gói</title>
				 <para>
					Dưới đây là những gì xảy ra trong quá trình loại bỏ gói:
				</para>
				 <orderedlist>
					<listitem>
						<para>
							<command>dpkg</command> gọi <command>prerm remove</command>.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> loại bỏ tất cả các tệp của gói, trừ các tệp cấu hình và tập lệnh cấu hình.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> thực hiện <command>postrm remove</command>. Tất cả các tập lệnh cấu hình, ngoại trừ <filename>postrm</filename>, sẽ bị xóa. Nếu người dùng không sử dụng tùy chọn “purge”, quá trình dừng ở đây.
						</para>

					</listitem>
					 <listitem>
						<para>
							Để xóa toàn bộ gói (lệnh được gọi với <command>dpkg --purge</command> hoặc <command>dpkg -P</command>), các tệp cấu hình cũng sẽ bị xoá. Cũng như là một số lượng nhất định các bản sao (<filename>*.dpkg-tmp</filename>, <filename>*.dpkg-old</filename>, <filename>*.dpkg-new</filename>) và các tập tin tạm; <filename>dpkg</filename> sau đó thực hiện <command>postrm purge</command>.
						</para>

					</listitem>

				</orderedlist>
				 <sidebar> <title><emphasis>VOCABULARY</emphasis> Làm sạch, loại bỏ hoàn toàn</title>
				 <indexterm>
					<primary>Loại bỏ hoàn toàn một gói</primary>
				</indexterm>
				 <para>
					Khi một gói Debian được gỡ bỏ, các tệp cấu hình được giữ lại để tạo điều kiện cho việc cài đặt lại. Tương tự, dữ liệu tạo ra bởi một daemon (như nội dung của một thư mục máy chủ LDAP, hoặc nội dung của một cơ sở dữ liệu cho một máy chủ SQL) thường được giữ lại.
				</para>
				 <para>
					Để loại bỏ tất cả các dữ liệu liên quan đến một gói, cần phải “tẩy” gói với lệnh, <command>dpkg -P <replaceable>package</replaceable></command>, <command>apt-get remove --purge <replaceable>package</replaceable></command> hoặc <command>aptitude purge <replaceable>package</replaceable></command>.
				</para>
				 <para>
					Với tính chất dứt khoát của việc xóa dữ liệu, việc tẩy không nên được xem nhẹ.
				</para>
				 </sidebar> <indexterm>
					<primary><filename>config</filename>, <command>debconf</command> script</primary>
				</indexterm>
				 <para>
					Bốn kịch bản được nêu chi tiết ở trên được bổ sung bởi một tập lệnh <filename>config</filename>, được cung cấp bởi các gói sử dụng <command>debconf</command> để thu thập thông tin từ người dùng để cấu hình. Trong quá trình cài đặt, kịch bản này xác định chi tiết các câu hỏi được yêu cầu bởi <command>debconf</command>. Câu trả lời được ghi lại trong cơ sở dữ liệu <command>debconf</command> để tham khảo trong tương lai. Tập lệnh thường được thực thi bởi <command>apt</command> trước khi cài đặt từng gói một để nhóm tất cả các câu hỏi và yêu cầu tất cả các người dùng vào lúc bắt đầu quá trình. Các tập lệnh trước và sau khi cài đặt có thể sử dụng thông tin này để hoạt động theo ý muốn của người dùng.
				</para>
				 <sidebar> <title><emphasis>TOOL</emphasis> <command>debconf</command></title>
				 <indexterm>
					<primary><command>debconf</command></primary>
				</indexterm>
				 <para>
					<command>debconf</command> được tạo ra để giải quyết một vấn đề định kỳ trong Debian. Tất cả các gói Debian không thể hoạt động mà không có cấu hình tối thiểu được sử dụng để đặt câu hỏi với các cuộc gọi tới các lệnh <command>echo</command> và <command>read</command> trong kịch bản <filename>postinst</filename> (và các kịch bản tương tự khác). Nhưng điều này cũng có nghĩa là trong quá trình cài đặt hoặc cập nhật lớn người dùng phải ở lại máy tính để trả lời các câu hỏi khác nhau có thể phát sinh bất cứ lúc nào. Những tương tác thủ công này đã được hầu như hoàn toàn giải phóng, nhờ công cụ <command>debconf</command>.
				</para>
				 <para>
					<command>debconf</command> có nhiều tính năng thú vị: nó đòi hỏi nhà phát triển phải xác định tương tác người dùng; Nó cho phép nội địa hóa tất cả các chuỗi được hiển thị cho người dùng (tất cả các bản dịch được lưu trong tệp <filename>templates</filename> mô tả các tương tác); Nó có frontend khác nhau để hiển thị các câu hỏi cho người sử dụng (chế độ văn bản, chế độ đồ họa, không tương tác); Và nó cho phép tạo ra một cơ sở dữ liệu trung tâm của các phản hồi để chia sẻ cùng một cấu hình với một số máy tính... nhưng điều quan trọng nhất là bây giờ có thể trình bày tất cả các câu hỏi liên tiếp với người dùng, trước khi bắt đầu quá trình cài đặt hoặc cập nhật dài hơi. Người sử dụng có thể tiến hành công việc của họ trong khi hệ thống tự quản lý việc cài đặt, mà không cần phải ở lại đó nhìn chằm chằm vào màn hình chờ các câu hỏi.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.conffiles">
			<title>Checksums, Danh sách Tệp Cấu hình</title>
			 <indexterm>
				<primary><filename>md5sums</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>conffiles</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>checksums</primary>
			</indexterm>
			 <indexterm>
				<primary>files</primary>
				<secondary>configuration files</secondary>
			</indexterm>
			 <indexterm>
				<primary>configuration</primary>
				<secondary>files</secondary>
			</indexterm>
			 <para>
				Ngoài các kịch bản bảo trì và dữ liệu điều khiển đã được đề cập trong các phần trước, tệp nén <filename>control.tar.gz</filename> của một gói Debian có thể chứa các tệp tin thú vị khác. Đầu tiên, <filename>md5sums</filename>, chứa checksums MD5 cho tất cả các tệp của gói. Ưu điểm chính của nó là nó cho phép <command>dpkg --verify</command> (chúng ta sẽ nghiên cứu trong <xref linkend="sect.dpkg-verify" />) để kiểm tra xem các tệp này đã được sửa đổi từ khi cài đặt hay không. Lưu ý rằng khi tệp này không tồn tại, <command>dpkg</command> sẽ tự động tạo ra nó trong thời gian cài đặt (và lưu trữ nó trong cơ sở dữ liệu dpkg giống như các tệp kiểm soát khác).
			</para>
			 <para>
				<filename>conffiles</filename> liệt kê các tệp tin gói phải được xử lý như tệp cấu hình. Các tệp cấu hình có thể được quản trị viên sửa đổi và <command>dpkg</command> sẽ cố gắng bảo vệ những thay đổi đó trong quá trình cập nhật gói.
			</para>
			 <para>
				Trong trường hợp này, <command>dpkg</command> hoạt động thông minh nhất có thể: nếu tập tin cấu hình tiêu chuẩn không thay đổi giữa hai phiên bản, nó không làm gì cả. Tuy nhiên, nếu tệp đã thay đổi, nó sẽ cố gắng cập nhật tệp này. Có hai trường hợp: quản trị viên không chạm vào tệp cấu hình này, trong trường hợp đó <command>dpkg</command> tự động cài đặt phiên bản mới; Hoặc tập tin đã được sửa đổi, trong trường hợp này <command>dpkg</command> yêu cầu quản trị viên phiên bản nào họ muốn sử dụng (bản cũ có sửa đổi, hoặc phiên bản mới được cung cấp kèm theo gói). Để hỗ trợ đưa ra quyết định này, <command>dpkg</command> cung cấp để hiển thị “<command>diff</command>” cho thấy sự khác biệt giữa hai phiên bản. Nếu người dùng chọn giữ lại phiên bản cũ, tệp mới sẽ được lưu trữ ở cùng vị trí trong một tệp có đuôi <filename>.dpkg-dist</filename>. Nếu người dùng chọn phiên bản mới, phần cũ sẽ được giữ lại trong một tệp có đuôi <filename>.dpkg-old</filename>. Một hành động khả dụng khác bao gồm tạm ngưng <command>dpkg</command> để chỉnh sửa tệp và cố gắng cài đặt lại các sửa đổi có liên quan (trước đây được xác định với <command>diff</command>).
			</para>
			 <sidebar id="sidebar.questions-conffiles"> <title><emphasis>GOING FURTHER</emphasis> Tránh các câu hỏi về tệp cấu hình</title>
			 <para>
				<command>dpkg</command> xử lý các bản cập nhật tập tin cấu hình, nhưng, trong khi làm như vậy, thường xuyên ngắt công việc của nó để yêu cầu nhập từ quản trị viên. Điều này làm cho nó ít thú vị hơn cho những ai muốn chạy các bản cập nhật theo cách không tương tác. Đây là lý do tại sao chương trình này cung cấp các tùy chọn cho phép hệ thống tự động trả lời theo logic tương tự: <command>--force-confold</command> giữ lại phiên bản cũ của tệp; <command>--force-confnew</command> sẽ sử dụng phiên bản mới của tệp tin (các lựa chọn này được tôn trọng, ngay cả khi tệp không bị thay đổi bởi quản trị viên, điều này hiếm khi có hiệu ứng mong muốn). Thêm tùy chọn <command>--force-confdef</command> để <command>dpkg</command> tự quyết định khi có thể (nói cách khác, khi tệp cấu hình ban đầu chưa được chạm vào) và chỉ sử dụng <command>--force-confnew</command> hoặc <command>--force-confold</command> cho các trường hợp khác.
			</para>
			 <para>
				Các tùy chọn này áp dụng cho <command>dpkg</command>, nhưng hầu hết thời gian người quản trị viên sẽ làm việc trực tiếp với chương trình <command>aptitude</command> hoặc <command>apt-get</command>. Do đó, cần biết cú pháp được sử dụng để chỉ ra các tùy chọn để vượt qua lệnh <command>dpkg</command> (các giao diện dòng lệnh của chúng rất giống nhau).
			</para>
			 
<screen>
<computeroutput># </computeroutput><userinput>apt -o DPkg::options::="--force-confdef" -o DPkg::options::="--force-confold" full-upgrade</userinput></screen>
			 <para>
				Các tùy chọn này có thể được lưu trữ trực tiếp trong cấu hình của <command>apt</command>. Để làm như vậy, chỉ cần viết dòng sau trong tệp <filename> /etc/apt/apt.conf.d/local</filename>:
			</para>
			 <informalexample> 
<programlisting>
DPkg::options { "--force-confdef"; "--force-confold"; }</programlisting>
			 </informalexample> <para>
				Bao gồm tùy chọn này trong tệp cấu hình có nghĩa là nó cũng sẽ được sử dụng trong một giao diện đồ họa như <command>aptitude</command>.
			</para>
			 </sidebar> <sidebar id="sidebar.questions-conffiles-bis"> <title><emphasis>GOING FURTHER</emphasis> Buộc dpkg yêu cầu hỏi về tệp cấu hình</title>
			 <para>
				Tùy chọn <command>--force-confask</command> yêu cầu <command>dpkg</command> hiển thị các câu hỏi về các tệp cấu hình, ngay cả trong trường hợp không cần thiết. Do đó, khi cài đặt lại một gói với tùy chọn này, <command>dpkg</command> sẽ hỏi lại tất cả các tập tin cấu hình do quản trị viên sửa đổi. Điều này rất thuận tiện, đặc biệt là để cài đặt lại tập tin cấu hình ban đầu nếu nó đã bị xóa và không có bản sao nào khác có sẵn: trong khi cài đặt lại bình thường sẽ không hoạt động vì <command>dpkg</command> coi việc xóa như một hình thức sửa đổi hợp pháp, và, do đó không cài đặt các tập tin cấu hình mong muốn.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.source-package-structure">
		<title>Cấu trúc của Gói nguồn</title>
		 <indexterm>
			<primary>package</primary>
			<secondary>source package </secondary>
		</indexterm>
		 <indexterm>
			<primary>source</primary>
			<secondary>package</secondary>
		</indexterm>
		 <section>
			<title>Định dạng</title>
			 <indexterm>
				<primary>tệp DSC</primary>
			</indexterm>
			 <indexterm>
				<primary>tệp <filename>diff.gz</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>tệp <filename>debian.tar.gz</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>tệp <filename>orig.tar.gz </filename></primary>
			</indexterm>
			 <para>
				A source package is usually comprised of three files, a <filename>.dsc</filename>, a <filename>.orig.tar.gz</filename>, and a <filename>.debian.tar.xz</filename> (or <filename>.diff.gz</filename>). They allow creation of binary packages (<filename>.deb</filename> files described above) from the source code files of the program, which are written in a programming language.
			</para>
			 <para>
				Tệp <filename>.dsc</filename> (Debian Source Control) là một tệp văn bản ngắn chứa tiêu đề RFC 2822 (giống như tệp <filename>control</filename> được nghiên cứu trong <xref linkend="sect.control" />) nó mô tả gói nguồn và cho biết tệp nào là một phần của nó. Nó được ký bởi người bảo trì của nó, để đảm bảo tính xác thực. Xem <xref linkend="sect.package-authentication" /> để biết thêm chi tiết về chủ đề này.
			</para>
			 <example>
				<title>Tệp tin <filename>.dsc</filename></title>
				 
<programlisting>
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Format: 3.0 (quilt)
Source: zim
Binary: zim
Architecture: all
Version: 0.65-4
Maintainer: Emfox Zhou &lt;emfox@debian.org&gt;
Uploaders: Raphaël Hertzog &lt;hertzog@debian.org&gt;
Homepage: http://zim-wiki.org
Standards-Version: 3.9.8
Vcs-Browser: https://anonscm.debian.org/cgit/collab-maint/zim.git
Vcs-Git: https://anonscm.debian.org/git/collab-maint/zim.git
Build-Depends: debhelper (&gt;= 9), xdg-utils, python (&gt;= 2.6.6-3~), libgtk2.0-0 (&gt;= 2.6), python-gtk2, python-xdg, dh-python
Package-List:
 zim deb x11 optional arch=all
Checksums-Sha1:
 4a9be85c98b7f4397800f6d301428d64241034ce 1899614 zim_0.65.orig.tar.gz
 0ec38c990ec7662205dd0c843bf81f9033906a2e 10332 zim_0.65-4.debian.tar.xz
Checksums-Sha256:
 5442f3334395a2beafc5b9a2bbec2e53e38270d4bad696b5c4053dd51dc1ed96 1899614 zim_0.65.orig.tar.gz
 78271df16aa166dce916b3ff4ecd705ed3a8832e49d3ef0bd8738a4fe8dd2b4f 10332 zim_0.65-4.debian.tar.xz
Files:
 63ab7a2070e6d1d3fb32700a851d7b8b 1899614 zim_0.65.orig.tar.gz
 648559b38e04eaf4f6caa97563c057ff 10332 zim_0.65-4.debian.tar.xz

-----BEGIN PGP SIGNATURE-----
Comment: Signed by Raphael Hertzog

iQEzBAEBCgAdFiEE1823g1EQnhJ1LsbSA4gdq+vCmrkFAlgzZXkACgkQA4gdq+vC
mrnyXAf+M/PzZFjqk6Hvv1QSbocIDZ3bEqRjVpNLApubsPsEZZT6yw9vypzNE2hZ
/BbLPa0Ntbhew4U+SJpuujV7VnLs9mZgOFuKRHKWYQBQ+oxw+gtM6iePwVj58aP/
LW7K5gE428ohMdjIkf42Lz4Fve3dVPgPLIzQxRZ87N6OKqmS81M6/RRIF3TS/gJp
CwpN1yifCfQs46gxL5/CgA4uhI8taz+g+8ZDd6fL5BQeFuNsgplY4QL1uGno3F7G
VY7WZhM601Re2ePnv+6vjh8kDWMjZhfB4RJy0+hHezuoVGKljyaxc1O4P/fxvXus
CEETju6cAE/HgDubDXDqExMwEd4odA==
=HUvj
-----END PGP SIGNATURE-----</programlisting>

			</example>
			 <indexterm>
				<primary><literal>Build-Depends</literal>, trường tiêu đề </primary>
			</indexterm>
			 <para>
				Lưu ý rằng gói nguồn cũng có phụ thuộc (<literal>Build-Depends</literal>) nó hoàn toàn khác so với các gói nhị phân, vì chúng chỉ ra các công cụ cần thiết để biên dịch phần mềm được đề cập và xây dựng gói nhị phân của nó.
			</para>
			 <sidebar> <title><emphasis>CAUTION</emphasis> Khoảng không tên riêng biệt</title>
			 <para>
				Điều quan trọng cần lưu ý ở đây là không có yêu cầu tương ứng giữa tên của gói nguồn và gói tin nhị phân mà nó tạo ra. Có thể dễ hiểu nếu bạn biết rằng mỗi gói nguồn có thể tạo ra một số gói nhị phân. Đây là lý do tại sao tệp tin <filename>.dsc</filename> có trường <literal>Source</literal> và <literal>Binary</literal> để nêu rõ tên gói nguồn và danh sách các gói nhị phân mà nó tạo ra.
			</para>
			 </sidebar> <sidebar> <title><emphasis>CULTURE</emphasis> Tại sao chia thành nhiều gói</title>
			 <para>
				Rất thường xuyên, gói nguồn (cho một phần mềm nhất định) có thể tạo ra vài gói nhị phân. Sự phân chia này là hợp lý bởi khả năng sử dụng (phần của) phần mềm trong các ngữ cảnh khác nhau. Xem xét một thư viện chia sẻ, nó có thể được cài đặt để thực hiện công việc ứng dụng (ví dụ: <emphasis role="pkg">libc6</emphasis>), hoặc nó có thể được cài đặt để phát triển một chương trình mới (<emphasis role="pkg">libc6-dev</emphasis> sau đó sẽ là gói chính xác). Chúng ta tìm thấy cùng một logic cho các dịch vụ client/server, nơi chúng ta muốn cài đặt phần server trên một máy và phần client trên các máy khác (ví dụ: <emphasis role="pkg">openssh-server</emphasis> và <emphasis role="pkg">openssh-client</emphasis>).
			</para>
			 <para>
				Hay thường xuyên các tài liệu được cung cấp trong một gói phần mềm chuyên dụng: người dùng có thể cài đặt nó độc lập với phần mềm, và có thể tại bất kỳ thời điểm nào chọn để loại bỏ nó để tiết kiệm không gian ổ cứng. Ngoài ra, điều này cũng tiết kiệm không gian ổ cứng trên mirror Debian, vì gói tài liệu sẽ được chia sẻ giữa tất cả các kiến trúc (thay vì có các tài liệu được nhân đôi trong các gói cho mỗi kiến trúc khác nhau).
			</para>
			 </sidebar> <sidebar> <title><emphasis>PERSPECTIVE</emphasis> Định dạng gói nguồn khác nhau</title>
			 <para>
				Ban đầu chỉ có một định dạng gói nguồn. Đó là định dạng <literal>1.0</literal>, kết hợp tệp <filename>.orig.tar.gz </filename> và một <filename>.diff.gz</filename> bản vá “debianization” (hay là một tệp tin nén <filename>.tar.gz</filename> duy nhất, được sử dụng tự động nếu không có tệp <filename>.orig.tar.gz</filename>).
			</para>
			 <para>
				Since Debian <emphasis role="distribution">Squeeze</emphasis>, Debian developers have the option to use new formats that correct many problems of the historical format. Format <literal>3.0 (quilt)</literal> can combine multiple upstream archives in the same source package: in addition to the usual <filename>.orig.tar.gz</filename>, supplementary <filename>.orig-<replaceable>component</replaceable>.tar.gz</filename> archives can be included. This is useful with software that is distributed in several upstream components but for which a single source package is desired. These archives can also be compressed with <command>xz</command> rather than <command>gzip</command>, which saves disk space and network resources. Finally, the monolithic patch, <filename>.diff.gz</filename> is replaced by a <filename>.debian.tar.xz</filename> archive containing the compiling instructions and a set of upstream patches contributed by the package maintainer. These last are recorded in a format compatible with <command>quilt</command> — a tool that facilitates the management of a series of patches.
			</para>
			 </sidebar> <para>
				Tệp <filename>.orig.tar.gz</filename> là tệp nén chứa mã nguồn do nhà phát triển ban đầu cung cấp. Người bảo trì gói Debian được yêu cầu không sửa đổi tệp này để có thể dễ dàng kiểm tra nguồn gốc và tính toàn vẹn của tệp (bằng so sánh đơn giản với checksums) và tôn trọng mong muốn của một số tác giả.
			</para>
			 <para>
				The <filename>.debian.tar.xz</filename> contains all of the modifications made by the Debian maintainer, especially the addition of a <filename>debian</filename> directory containing the instructions to execute to construct a Debian package.
			</para>
			 <sidebar> <title><emphasis>TOOL</emphasis> Giải nén gói nguồn</title>
			 <indexterm>
				<primary><command>dpkg-source</command></primary>
			</indexterm>
			 <indexterm>
				<primary>giải nén, gói nguồn </primary>
			</indexterm>
			 <indexterm>
				<primary> giải nén, gói nguồn </primary>
			</indexterm>
			 <indexterm>
				<primary> giải nén </primary>
				<secondary> gói nguồn </secondary>
			</indexterm>
			 <para>
				Nếu bạn có một gói nguồn, bạn có thể sử dụng lệnh <command>dpkg-source</command> (từ gói <emphasis role="pkg">dpkg-dev</emphasis>) để giải nén nó:
			</para>
			 
<screen><computeroutput> $ </computeroutput><userinput> dpkg-source -x package_0.7-1.dsc </userinput></screen>
			 <para>
				Bạn cũng có thể sử dụng <command>apt-get</command> để tải xuống một gói nguồn và giải nén nó ngay. Nó yêu cầu các dòng <literal>deb-src</literal> có trong tập tin <literal>/etc/apt/sources.list</literal> (để biết thêm chi tiết, xem <xref linkend="sect.apt-sources.list" />). Chúng được sử dụng để liệt kê “nguồn” của các gói nguồn (nghĩa là các máy chủ mà trên đó một nhóm các gói nguồn được lưu trữ).
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>apt-get source <replaceable>package</replaceable></userinput></screen>
			 </sidebar>
		</section>
		 <section>
			<title>Cách sử dụng trong Debian</title>
			 <para>
				Gói nguồn là nền tảng của mọi thứ trong Debian. Tất cả các gói Debian đều đến từ một gói nguồn, và mỗi sửa đổi trong một gói Debian là kết quả của một sửa đổi đối với gói nguồn. Các nhà bảo trì Debian làm việc với gói nguồn, tuy nhiên biết được hậu quả của hành động của họ đối với các gói nhị phân. Các thành quả của công việc của họ được tìm thấy trong các gói nguồn có sẵn từ Debian: bạn có thể dễ dàng quay lại gói nguồn và mọi thứ bắt nguồn từ chúng.
			</para>
			 <para>
				Khi một phiên bản mới của gói (gói nguồn và một hoặc nhiều gói nhị phân) xuất hiện trên máy chủ Debian, gói nguồn là quan trọng nhất. Thật vậy, nó sẽ được sử dụng bởi một mạng lưới các máy của các kiến trúc khác nhau để biên dịch trên các kiến trúc đó được hỗ trợ bởi Debian. Thực tế là nhà phát triển cũng gửi một hoặc nhiều gói nhị phân cho một kiến trúc nhất định (thường là i386 hoặc amd64) là tương đối không quan trọng vì chúng cũng có thể được tạo tự động.
			</para>

		</section>

	</section>
	 <section id="sect.manipulating-packages-with-dpkg">
		<title>Thao tác các gói với <command>dpkg</command></title>
		 <indexterm>
			<primary><command>dpkg</command></primary>
		</indexterm>
		 <para>
			<command>dpkg</command> là lệnh cơ sở để xử lý các gói Debian trên hệ thống. Nếu bạn có gói <filename>.deb</filename>, <command>dpkg</command> cho phép cài đặt hoặc phân tích nội dung của gói đó. Nhưng chương trình này chỉ là có một cái nhìn 1 phần của vũ trụ Debian: nó biết những gì được cài đặt trên hệ thống, và bất cứ điều gì nó được đưa ra trên dòng lệnh, nhưng không biết gì về các gói có sẵn khác (ở trên các máy chủ). Như vậy, nó sẽ báo lỗi nếu một sự phụ thuộc không được đáp ứng. Các công cụ như <command>apt</command>, trái lại, sẽ tạo ra một danh sách các phụ thuộc để cài đặt mọi thứ như là tự động có thể.
		</para>
		 <sidebar> <title><emphasis>NOTE</emphasis><command>dpkg</command> hay <command>apt</command>?</title>
		 <para>
			<command>dpkg</command> nên được xem như một công cụ hệ thống (phần lõi), và <command>apt</command> như một công cụ gần gũi hơn với người dùng, vượt qua những hạn chế của nó. Những công cụ này làm việc cùng nhau, mỗi cái có tính đặc thù, phù hợp với các nhiệm vụ cụ thể.
		</para>
		 </sidebar> <section>
			<title>Cài đặt Gói</title>
			 <indexterm>
				<primary>installation</primary>
				<secondary>package installation</secondary>
			</indexterm>
			 <indexterm>
				<primary>package</primary>
				<secondary>installation</secondary>
			</indexterm>
			 <para>
				<command>dpkg</command> là công cụ cài đặt gói Debian đã có sẵn (vì nó không tải bất cứ thứ gì). Để thực hiện việc này, chúng ta sử dụng tùy chọn <literal>-i</literal> hoặc <literal>--install</literal>.
			</para>
			 <example>
				<title>Cài đặt một gói với <command>dpkg</command></title>
				 
<screen role="scale">
<computeroutput># </computeroutput><userinput>dpkg -i man-db_2.7.6.1-2_amd64.deb</userinput>
<computeroutput>(Reading database ... 110431 files and directories currently installed.)
Preparing to unpack man-db_2.7.6.1-2_amd64.deb ...
Unpacking man-db (2.7.6.1-2) over (2.7.6.1-1) ...
Setting up man-db (2.7.6.1-2) ...
Updating database of manual pages ...
Processing triggers for mime-support (3.60) ...</computeroutput></screen>

			</example>
			 <para>
				Chúng ta có thể thấy các bước khác nhau được thực hiện bởi <command>dpkg</command>; Chúng ta biết, do đó, tại những điểm bất kỳ lỗi có thể đã xảy ra. Việc cài đặt cũng có thể được thực hiện trong hai giai đoạn: đầu tiên giải nén, sau đó cấu hình. <command>apt-get</command> tận dụng điều này, hạn chế số lượng cuộc gọi đến <command>dpkg</command> (vì mỗi cuộc gọi tốn kém, do tải cơ sở dữ liệu trong bộ nhớ , đặc biệt là danh sách các tập tin đã được cài đặt).
			</para>
			 <example>
				<title>Giải nén và cấu hình riêng rẽ</title>
				 
<screen role="scale">
<computeroutput># </computeroutput><userinput>dpkg --unpack man-db_2.7.6.1-2_amd64.deb</userinput>
<computeroutput>(Reading database ... 110431 files and directories currently installed.)
Preparing to unpack man-db_2.7.6.1-2_amd64.deb ...
Unpacking man-db (2.7.6.1-2) over (2.7.6.1-2) ...
Processing triggers for mime-support (3.60) ...
# </computeroutput><userinput>dpkg --configure man-db</userinput>
<computeroutput>Setting up man-db (2.7.6.1-2) ...
Updating database of manual pages ...
</computeroutput></screen>

			</example>
			 <indexterm>
				<primary>package</primary>
				<secondary>unpacking</secondary>
			</indexterm>
			 <indexterm>
				<primary>unpacking</primary>
				<secondary>binary package</secondary>
			</indexterm>
			 <para>
				Đôi khi <command>dpkg</command> sẽ không cài đặt gói và trả về lỗi; Nếu người dùng cho nó để bỏ qua điều này, nó sẽ chỉ phát hành một cảnh báo; Vì lý do này mà chúng ta có các tùy chọn <literal>--force-*</literal> khác nhau. Lệnh <command>dpkg --force-help</command> là tài liệu đầy đủ các tùy chọn này. Lỗi thường gặp nhất, mà bạn sẽ gặp phải sớm hay muộn, là một va chạm tập tin. Khi một gói chứa một tập tin đã được cài đặt bởi một gói khác, <command>dpkg</command> sẽ từ chối cài đặt nó. Sau đó các thông báo sau sẽ xuất hiện:
			</para>
			 
<screen>
<computeroutput>Unpacking libgdm (from .../libgdm_3.8.3-2_amd64.deb) ...
dpkg: error processing /var/cache/apt/archives/libgdm_3.8.3-2_amd64.deb (--unpack):
 trying to overwrite '/usr/bin/gdmflexiserver', which is also in package gdm3 3.4.1-9</computeroutput></screen>
			 <para>
				Trong trường hợp này, nếu bạn nghĩ rằng thay thế tệp này không phải ảnh hướng tới tính ổn định của hệ thống (thường là trường hợp này), bạn có thể sử dụng tùy chọn <literal>--force-overwrite</literal>, để cho <command>dpkg</command> biết để bỏ qua lỗi này và ghi đè lên tệp.
			</para>
			 <para>
				Mặc dù có nhiều tùy chọn <literal>--force-*</literal>, chỉ có <literal>--force-overwrite</literal> được sử dụng thường xuyên. Các lựa chọn này chỉ tồn tại trong những trường hợp đặc biệt, và tốt hơn là không dùng chúng càng nhiều càng tốt để tôn trọng các quy tắc áp đặt bởi cơ chế đóng gói. Đừng quên, những quy tắc này đảm bảo tính nhất quán và sự ổn định của hệ thống.
			</para>
			 <sidebar> <title><emphasis>CAUTION</emphasis> Sử dụng hiệu quả <literal>--force-*</literal></title>
			 <indexterm>
				<primary>phá vỡ sự phụ thuộc </primary>
			</indexterm>
			 <para>
				Nếu bạn không cẩn thận, việc sử dụng một tùy chọn <literal>--force-* </literal> có thể dẫn đến một hệ thống mà các gia đình lện APT sẽ từ chối hoạt động. Một số tùy chọn cho phép <command>dpkg</command> cài đặt một gói khi một sự phụ thuộc không thỏa mãn, hoặc ngay cả khi có xung đột. Kết quả là tạo nên một hệ thống không nhất quán từ quan điểm phụ thuộc, và các lệnh của APT sẽ từ chối thực hiện bất kỳ hành động nào, ngoại trừ các lệnh sẽ đưa hệ thống trở lại trạng thái nhất quán (thường bao gồm cài đặt sự phụ thuộc bị thiếu hoặc gỡ bỏ một gói có vấn đề). Điều này thường dẫn đến một thông báo như sau, ví dụ sau khi cài đặt phiên bản mới của <emphasis role="pkg">rdesktop</emphasis> trong khi bỏ qua sự phụ thuộc của nó vào một phiên bản mới hơn của <emphasis role="pkg">libc6</emphasis>:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>apt full-upgrade
</userinput><computeroutput>[...]
You might want to run 'apt-get -f install' to correct these.
The following packages have unmet dependencies:
  rdesktop: Depends: libc6 (&gt;= 2.5) but 2.3.6.ds1-13etch7 is installed
E: Unmet dependencies. Try using -f.</computeroutput></screen>
			 <para>
				Một quản trị viên dũng cảm phải chắc chắn về phân tích chính xác có thể bỏ qua sự phụ thuộc hoặc xung đột và sử dụng tuỳ chọn <literal>--force-*</literal>. Trong trường hợp này, nếu họ muốn có thể tiếp tục sử dụng <command>aptitude</command> hoặc <command>apt</command>&gt;, họ phải chỉnh sửa <filename>/var/lib/dpkg/status</filename> để xóa hay sửa đổi sự phụ thuộc, hoặc xung đột mà họ đã chọn để ghi đè.
			</para>
			 <para>
				Thao tác này xem như là một cách hack đểu, và không bao giờ nên được sử dụng, ngoại trừ trường hợp cực kỳ cần thiết. Thường xuyên, một giải pháp thích hợp hơn là biên dịch lại gói phần mềm gây ra sự cố (xem <xref linkend="sect.rebuilding-package" />) hoặc sử dụng một phiên bản mới (có khả năng sửa chữa) từ một kho như <literal>stable-backports</literal> (xem <xref linkend="sect.backports" />).
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>Xóa Gói</title>
			 <indexterm>
				<primary>removing a package</primary>
			</indexterm>
			 <indexterm>
				<primary>purging a package</primary>
			</indexterm>
			 <indexterm>
				<primary> gói </primary>
				<secondary> loại bỏ </secondary>
			</indexterm>
			 <indexterm>
				<primary> gói </primary>
				<secondary> tẩy rửa </secondary>
			</indexterm>
			 <para>
				Gọi <command>dpkg</command>với tùy chọn <literal>-r</literal> hay <literal>--remove </literal>, theo sau là tên của một gói, để loại bỏ gói đó. Tuy nhiên, việc xóa này không hoàn chỉnh: tất cả các tệp cấu hình, tập lệnh người quản trị, tệp nhật ký (nhật ký hệ thống) và dữ liệu người dùng khác được gói gọn trong gói. Bằng cách đó, vô hiệu hóa chương trình có thể thực hiện dễ dàng bằng cách gỡ cài đặt và vẫn có thể nhanh chóng cài đặt lại nó với cùng cấu hình. Để loại bỏ hoàn toàn mọi thứ liên quan đến một gói, hãy sử dụng tùy chọn <literal>-P</literal> hoặc <literal>--purge</literal>, sau đó là tên gói.
			</para>
			 <example>
				<title>Xoá và tẩy gói <emphasis role="pkg">debian-cd</emphasis></title>
				 
<screen><computeroutput># </computeroutput><userinput>dpkg -r debian-cd</userinput>
<computeroutput>(Reading database ... 112188 files and directories currently installed.)
Removing debian-cd (3.1.20) ...
# </computeroutput><userinput>dpkg -P debian-cd</userinput>
<computeroutput>(Reading database ... 111613 files and directories currently installed.)
Purging configuration files for debian-cd (3.1.20) ...
</computeroutput></screen>

			</example>

		</section>
		 <section>
			<title>Truy vấn cơ sở dữ liệu của <command>dpkg</command> và kiểm tra các tệp <filename>.deb</filename></title>
			 <indexterm>
				<primary>package</primary>
				<secondary>status</secondary>
			</indexterm>
			 <indexterm>
				<primary>package</primary>
				<secondary>file list</secondary>
			</indexterm>
			 <indexterm>
				<primary>package</primary>
				<secondary>content inspection</secondary>
			</indexterm>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Cú pháp tùy chọn</title>
			 <para>
				Hầu hết các tùy chọn có sẵn trong một phiên bản"dài"(một hoặc nhiều từ có liên quan, đứng trước dấu gạch đôi) và một phiên bản"ngắn"(một chữ cái, thường là chữ đầu của một từ từ phiên bản dài, và trước bởi một Dash). Quy ước này là phổ biến đến mức nó là một tiêu chuẩn POSIX.
			</para>
			 </sidebar> <para>
				Trước khi kết thúc phần này, chúng ta sẽ nghiên cứu các tùy chọn <command>dpkg</command> để truy vấn cơ sở dữ liệu nội bộ để có được thông tin. Trước tiên các tùy chọn dài và sau đó các tùy chọn ngắn tương ứng (điều đó rõ ràng sẽ có cùng một đối số) chúng ta trích dẫn <literal>--listfiles <replaceable>package</replaceable></literal>(hoặc <literal>-L</literal>), liệt kê các tệp đã được cài đặt bởi gói này; <literal>--search </literal><replaceable>file</replaceable> (hoặc <literal>-S</literal>), tìm gói (các) gói có chứa tệp này; <literal>--status </literal><replaceable>package</replaceable> (hoặc <literal>-s</literal>), hiển thị trạng thái của một gói được cài đặt; <literal>--list</literal> (hoặc <literal>-l</literal>), liệt kê tất cả các gói được biết đối với hệ thống và trạng thái cài đặt của chúng; <literal>--content </literal><replaceable>file.deb</replaceable> (hoặc <literal>-c</literal>), liệt kê các tệp trong gói Debian đó; <literal>--info </literal><replaceable>file.deb</replaceable> (hoặc <literal>-I</literal>), hiển thị tiêu đề của gói Debian này.
			</para>
			 <example>
				<title>Các truy vấn khác nhau với <command>dpkg</command></title>
				 
<screen role="scale" width="80">
<computeroutput>$ </computeroutput><userinput>dpkg -L base-passwd</userinput>
<computeroutput>/.
/usr
/usr/sbin
/usr/sbin/update-passwd
/usr/share
/usr/share/base-passwd
/usr/share/base-passwd/group.master
/usr/share/base-passwd/passwd.master
/usr/share/doc
/usr/share/doc/base-passwd
/usr/share/doc/base-passwd/README
/usr/share/doc/base-passwd/changelog.gz
/usr/share/doc/base-passwd/copyright
/usr/share/doc/base-passwd/users-and-groups.html
/usr/share/doc/base-passwd/users-and-groups.txt.gz
/usr/share/doc-base
/usr/share/doc-base/users-and-groups
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/base-passwd
/usr/share/man
/usr/share/man/de
/usr/share/man/de/man8
/usr/share/man/de/man8/update-passwd.8.gz
/usr/share/man/es
/usr/share/man/es/man8
/usr/share/man/es/man8/update-passwd.8.gz
/usr/share/man/fr
/usr/share/man/fr/man8
/usr/share/man/fr/man8/update-passwd.8.gz
/usr/share/man/ja
/usr/share/man/ja/man8
/usr/share/man/ja/man8/update-passwd.8.gz
/usr/share/man/man8
/usr/share/man/man8/update-passwd.8.gz
/usr/share/man/pl
/usr/share/man/pl/man8
/usr/share/man/pl/man8/update-passwd.8.gz
/usr/share/man/ru
/usr/share/man/ru/man8
/usr/share/man/ru/man8/update-passwd.8.gz
$ </computeroutput><userinput>dpkg -S /bin/date</userinput>
<computeroutput>coreutils: /bin/date
$ </computeroutput><userinput>dpkg -s coreutils</userinput>
<computeroutput>Package: coreutils
Essential: yes
Status: install ok installed
Priority: required
Section: utils
Installed-Size: 15103
Maintainer: Michael Stone &lt;mstone@debian.org&gt;
Architecture: amd64
Multi-Arch: foreign
Version: 8.26-3
Replaces: mktemp, realpath, timeout
Pre-Depends: libacl1 (&gt;= 2.2.51-8), libattr1 (&gt;= 1:2.4.46-8), libc6 (&gt;= 2.17), libselinux1 (&gt;= 2.1.13)
Conflicts: timeout
Description: GNU core utilities
 This package contains the basic file, shell and text manipulation
 utilities which are expected to exist on every operating system.
 .
 Specifically, this package includes:
 arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp
 csplit cut date dd df dir dircolors dirname du echo env expand expr
 factor false flock fmt fold groups head hostid id install join link ln
 logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt
 od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm
 rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac
 tail tee test timeout touch tr true truncate tsort tty uname unexpand
 uniq unlink users vdir wc who whoami yes
Homepage: http://gnu.org/software/coreutils
$ </computeroutput><userinput>dpkg -l 'b*'</userinput>
<computeroutput>Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                 Version         Architecture    Description
+++-====================-===============-===============-=============================================
un  backupninja          &lt;none&gt;          &lt;none&gt;          (no description available)
un  backuppc             &lt;none&gt;          &lt;none&gt;          (no description available)
un  baekmuk-ttf          &lt;none&gt;          &lt;none&gt;          (no description available)
un  base                 &lt;none&gt;          &lt;none&gt;          (no description available)
un  base-config          &lt;none&gt;          &lt;none&gt;          (no description available)
ii  base-files           9.9+deb9u1      amd64           Debian base system miscellaneous files
ii  base-passwd          3.5.43          amd64           Debian base system master password and group 
ii  bash                 4.4-5           amd64           GNU Bourne Again SHell
[...]
$ </computeroutput><userinput>dpkg -c /var/cache/apt/archives/gnupg_2.1.18-8~deb9u1_amd64.deb</userinput>
<computeroutput>drwxr-xr-x root/root         0 2017-09-18 20:41 ./
drwxr-xr-x root/root         0 2017-09-18 20:41 ./usr/
drwxr-xr-x root/root         0 2017-09-18 20:41 ./usr/bin/
-rwxr-xr-x root/root    996648 2017-09-18 20:41 ./usr/bin/gpg
-rwxr-xr-x root/root      3444 2017-09-18 20:41 ./usr/bin/gpg-zip
-rwxr-xr-x root/root    161192 2017-09-18 20:41 ./usr/bin/gpgconf
-rwxr-xr-x root/root     26696 2017-09-18 20:41 ./usr/bin/gpgparsemail
-rwxr-xr-x root/root     76112 2017-09-18 20:41 ./usr/bin/gpgsplit
-rwxr-xr-x root/root    158344 2017-09-18 20:41 ./usr/bin/kbxutil
-rwxr-xr-x root/root      1081 2014-06-25 16:17 ./usr/bin/lspgpot
-rwxr-xr-x root/root      2194 2017-09-18 20:41 ./usr/bin/migrate-pubring-from-classic-gpg
-rwxr-xr-x root/root     14328 2017-09-18 20:41 ./usr/bin/watchgnupg
drwxr-xr-x root/root         0 2017-09-18 20:41 ./usr/sbin/
-rwxr-xr-x root/root      3078 2017-09-18 20:41 ./usr/sbin/addgnupghome
-rwxr-xr-x root/root      2219 2017-09-18 20:41 ./usr/sbin/applygnupgdefaults
drwxr-xr-x root/root         0 2017-09-18 20:41 ./usr/share/
drwxr-xr-x root/root         0 2017-09-18 20:41 ./usr/share/doc/
drwxr-xr-x root/root         0 2017-09-18 20:41 ./usr/share/doc/gnupg/
-rw-r--r-- root/root     18964 2017-01-23 18:39 ./usr/share/doc/gnupg/DETAILS.gz
[...]
$ </computeroutput><userinput>dpkg -I /var/cache/apt/archives/gnupg_2.1.18-8~deb9u1_amd64.deb</userinput>
<computeroutput> new debian package, version 2.0.
 size 1124042 bytes: control archive=2221 bytes.
    1388 bytes,    24 lines      control              
    2764 bytes,    43 lines      md5sums              
 Package: gnupg
 Source: gnupg2
 Version: 2.1.18-8~deb9u1
 Architecture: amd64
 Maintainer: Debian GnuPG Maintainers &lt;pkg-gnupg-maint@lists.alioth.debian.org&gt;
 Installed-Size: 2088
 Depends: gnupg-agent (= 2.1.18-8~deb9u1), libassuan0 (&gt;= 2.0.1), libbz2-1.0, libc6 (&gt;= 2.15), libgcrypt20 (&gt;= 1.7.0), libgpg-error0 (&gt;= 1.14), libksba8 (&gt;= 1.3.4), libreadline7 (&gt;= 6.0), libsqlite3-0 (&gt;= 3.7.15), zlib1g (&gt;= 1:1.1.4)
 Recommends: dirmngr (= 2.1.18-8~deb9u1), gnupg-l10n (= 2.1.18-8~deb9u1)
 Suggests: parcimonie, xloadimage
 Breaks: debsig-verify (&lt;&lt; 0.15), dirmngr (&lt;&lt; 2.1.18-8~deb9u1), gnupg2 (&lt;&lt; 2.1.11-7+exp1), libgnupg-interface-perl (&lt;&lt; 0.52-3), libgnupg-perl (&lt;= 0.19-1), libmail-gnupg-perl (&lt;= 0.22-1), monkeysphere (&lt;&lt; 0.38~), php-crypt-gpg (&lt;= 1.4.1-1), python-apt (&lt;= 1.1.0~beta4), python-gnupg (&lt;&lt; 0.3.8-3), python3-apt (&lt;= 1.1.0~beta4)
 Replaces: gnupg2 (&lt;&lt; 2.1.11-7+exp1)
 Provides: gpg
 Section: utils
 Priority: optional
 Multi-Arch: foreign
 Homepage: https://www.gnupg.org/
 Description: GNU privacy guard - a free PGP replacement
  GnuPG is GNU's tool for secure communication and data storage.
  It can be used to encrypt data and to create digital signatures.
  It includes an advanced key management facility and is compliant
  with the proposed OpenPGP Internet standard as described in RFC4880.
[...]</computeroutput></screen>

			</example>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> So sánh các phiên bản</title>
			 <indexterm>
				<primary>phiên bản, so sánh </primary>
			</indexterm>
			 <indexterm>
				<primary>so sánh các phiên bản </primary>
			</indexterm>
			 <para>
				Vì <command>dpkg</command> là chương trình để xử lý các gói Debian, nó cũng cung cấp việc thực hiện tham chiếu của so sánh logic số phiên bản. Đây là lý do tại sao nó có tùy chọn <literal>--compare-versions</literal>, có thể sử dụng được bởi các chương trình bên ngoài (đặc biệt là các kịch bản cấu hình được thực hiện bởi <command>dpkg</command>). Tùy chọn này yêu cầu ba tham số: số phiên bản, toán tử so sánh và số phiên bản thứ hai. Các toán tử khác nhau có thể là <literal>lt</literal> (nhỏ hơn), <literal>le</literal> (nhỏ hơn hoặc bằng), <literal>eq</literal>(lớn hơn hoặc bằng), và <literal>gt</literal>(lớn hơn). Nếu so sánh là đúng, <literal>dpkg</literal> trả về 0 (thành công); Nếu không, nó sẽ trả về giá trị khác không (chỉ ra sự thất bại).
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>dpkg --compare-versions 1.2-3 gt 1.1-4</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>0
$ </computeroutput><userinput>dpkg --compare-versions 1.2-3 lt 1.1-4</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>1
$ </computeroutput><userinput>dpkg --compare-versions 2.6.0pre3-1 lt 2.6.0-1</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>1</computeroutput></screen>
			 <para>
				Lưu ý sự thất bại không mong muốn của sự so sánh cuối cùng: cho <command>dpkg</command>, <literal>pre</literal>, thường biểu thị một bản phát hành trước, không có ý nghĩa đặc biệt, và chương trình này so sánh các ký tự chữ cái giống như các con số (a &lt; b &lt; c...), theo thứ tự chữ cái. Đây là lý do tại sao nó coi “<literal>0pre3</literal>” lớn hơn “<literal>0</literal>”, Khi chúng ta muốn số phiên bản của gói để cho biết rằng nó là bản phát hành trước, chúng ta sử dụng ký tự dấu ngã, “<literal>~</literal>”
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>dpkg --compare-versions 2.6.0~pre3-1 lt 2.6.0-1</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>0</computeroutput></screen>
			 </sidebar>
		</section>
		 <section>
			<title>Tệp log của <command>dpkg</command></title>
			 <para>
				<command>dpkg</command> giữ bản ghi chú của tất cả hành động của nó trong <filename>/var/log/dpkg.log</filename>. Nhật ký này cực kỳ chi tiết, vì nó mô tả chi tiết từng giai đoạn thông qua đó các gói được xử lý bởi <command>dpkg</command>. Ngoài việc cung cấp một cách để theo dõi hành vi của dpkg, nó giúp đỡ, trên tất cả, để giữ lịch sử của sự phát triển của hệ thống: người ta có thể tìm thấy thời điểm chính xác khi mỗi gói đã được cài đặt hoặc cập nhật, và thông tin này có thể cực kỳ hữu ích trong sự hiểu biết một sự thay đổi gần đây. Ngoài ra, tất cả các phiên bản được ghi lại, bạn có thể kiểm tra chéo thông tin với <filename>changelog.Debian.gz</filename> cho các gói đang được hỏi hoặc thậm chí với các báo cáo lỗi trực tuyến.
			</para>

		</section>
		 <section id="sect.multi-arch">
			<title>Hỗ trợ Multi-Arch</title>
			 <indexterm>
				<primary>Multi-Arch </primary>
			</indexterm>
			 <indexterm>
				<primary>architecture</primary>
				<secondary>multi-arch support</secondary>
			</indexterm>
			 <para>
				Tất cả các gói Debian có một trường <literal>Architecture</literal> trong tệp contol của chúng. Trường này có thể chứa cả “<literal>all</literal>” (đối với các gói có kiến trúc độc lập) hoặc tên của kiến trúc mà nó cung cấp (như “amd64”, “armhf”,...). Trong trường hợp thứ hai, mặc định, <command>dpkg</command> sẽ chỉ chấp nhận cài đặt gói nếu kiến trúc của nó khớp với kiến trúc của máy chủ lưu trữ như trả về bởi <command>dpkg --print-architecture</command>.
			</para>
			 <para>
				Hạn chế này đảm bảo rằng người dùng không cài đặt các chương trình nhị phân được biên dịch cho một kiến trúc không chính xác. Tất cả mọi thứ sẽ hoàn hảo ngoại trừ một số máy tính có thể chạy các chương trình nhị phân cho nhiều kiến trúc, hoặc tự nhiên (một hệ thống “amd64“ hệ thống có thể chạy tệp thực thi của “i386“ ) hoặc thông qua giả lập.
			</para>
			 <section>
				<title>Kích hoạt Multi-Arch</title>
				 <para>
					Hỗ trợ mutil-arch của <command>dpkg</command> cho phép người dùng định nghĩa “foreign architectures” có thể được cài đặt trên hệ thống hiện tại. Điều này chỉ đơn giản được thực hiện với <command>dpkg --add-architecture</command> như trong ví dụ dưới đây. Và <command>dpkg --remove-architecture </command> tương ứng để bỏ hỗ trợ kiến trúc đó, nhưng chỉ có thể sử dụng khi không có gói nào đang chạy trên kiến trúc này.
				</para>
				 
<screen>
<computeroutput># </computeroutput><userinput>dpkg --print-architecture</userinput>
<computeroutput>amd64
# </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput># </computeroutput><userinput>dpkg -i gcc-6-base_6.3.0-18_armhf.deb</userinput>
<computeroutput>dpkg: error processing archive gcc-6-base_6.3.0-18_armhf.deb (--install):
 package architecture (armhf) does not match system (amd64)
Errors were encountered while processing:
 gcc-6-base_6.3.0-18_armhf.deb
# </computeroutput><userinput>dpkg --add-architecture armhf</userinput>
<computeroutput># </computeroutput><userinput>dpkg --add-architecture armel</userinput>
<computeroutput># </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput>armhf
armel
# </computeroutput><userinput>dpkg -i gcc-6-base_6.3.0-18_armhf.deb</userinput>
<computeroutput>Selecting previously unselected package gcc-6-base:armhf.
(Reading database ... 112000 files and directories currently installed.)
Preparing to unpack gcc-6-base_6.3.0-18_armhf.deb ...
Unpacking gcc-6-base:armhf (6.3.0-18) ...
Setting up gcc-6-base:armhf (6.3.0-18) ...
# </computeroutput><userinput>dpkg --remove-architecture armhf</userinput>
<computeroutput>dpkg: error: cannot remove architecture 'armhf' currently in use by the database
# </computeroutput><userinput>dpkg --remove-architecture armel</userinput>
<computeroutput># </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput>armhf</computeroutput></screen>
				 <sidebar> <title><emphasis>NOTE</emphasis> Hỗ trợ mutil-arch của APT</title>
				 <para>
					APT sẽ tự động phát hiện khi dpkg đã được cấu hình để hỗ trợ kiến trúc khác và sẽ bắt đầu tải xuống các tệp <filename>Packages</filename> trong quá trình cập nhật.
				</para>
				 <para>
					Các gói foreign có thể được cài đặt với <command>apt install <replaceable>package</replaceable>:<replaceable>architecture</replaceable></command>.
				</para>
				 </sidebar> <sidebar> <title><emphasis>IN PRACTICE</emphasis> Sử dụng các chương trình độc quyền i386 trên amd64</title>
				 <para>
					There are multiple use cases for multi-arch, but the most popular one is the possibility to execute 32 bit binaries (i386) on 64 bit systems (amd64).
				</para>
				 </sidebar>
			</section>
			 <section>
				<title>Thay đổi Liên quan đến Multi-Arch</title>
				 <para>
					To make multi-arch actually useful and usable, libraries had to be repackaged and moved to an architecture-specific directory so that multiple copies (targeting different architectures) can be installed alongside. Such updated packages contain the “<literal>Multi-Arch: same</literal>” header field to tell the packaging system that the various architectures of the package can be safely co-installed (and that those packages can only satisfy dependencies of packages of the same architecture). The most important libraries have been converted since the introduction of multi-arch in Debian <emphasis role="distribution">Wheezy</emphasis>, but there are many libraries that will likely never be converted unless someone specifically requests it (through a bug report for example).
				</para>
				 
<screen><computeroutput>$ </computeroutput><userinput>dpkg -s gcc-6-base
</userinput><computeroutput>dpkg-query: error: --status needs a valid package name but 'gcc-6-base' is not: ambiguous package name 'gcc-6-base' with more than one installed instance

Use --help for help about querying packages.
$ </computeroutput><userinput>dpkg -s gcc-6-base:amd64 gcc-6-base:armhf | grep ^Multi
</userinput><computeroutput>Multi-Arch: same
Multi-Arch: same
$ </computeroutput><userinput>dpkg -L libgcc1:amd64 |grep .so
</userinput><computeroutput>/lib/x86_64-linux-gnu/libgcc_s.so.1
$ </computeroutput><userinput>dpkg -S /usr/share/doc/gcc-6-base/copyright
</userinput><computeroutput>gcc-6-base:amd64, gcc-6-base:armhf: /usr/share/doc/gcc-6-base/copyright
</computeroutput></screen>
				 <para>
					Cần lưu ý rằng các gói <literal>Multi-Arch: same</literal> phải có tên phù hợp với kiến trúc của chúng để được nhận dạng rõ ràng. Họ cũng có khả năng chia sẻ tập tin với các trường hợp khác của cùng một gói; <command>dpkg</command> đảm bảo rằng tất cả các gói giống hệt nhau từng bit từng bit một khi chúng được chia sẻ. Cuối cùng nhưng không kém phần quan trọng, tất cả các phiên bản kiến trúc của một gói phải có cùng một số phiên bản. Do đó chúng phải được nâng cấp cùng nhau.
				</para>
				 <para>
					Multi-Arch hỗ trợ cũng mang lại một số thách thức thú vị trong cách xử lý sự phụ thuộc. Phù hợp với sự phụ thuộc đòi hỏi phải có một gói được đánh dấu “<literal>Multi-Arch: foreign</literal>” hoặc một gói có kiến trúc phù hợp với một trong các gói tuyên bố sự phụ thuộc (trong quá trình phân giải phụ thuộc này, các gói độc lập với kiến trúc được giả định là có cùng kiến trúc so với máy chủ). Một phụ thuộc cũng có thể bị yếu để cho phép bất kỳ kiến trúc nào hoàn thành nó với cú pháp <literal><replaceable>package</replaceable>:any</literal>, nhưng gói ngoại chỉ có thể thỏa mãn sự phụ thuộc đó nếu chúng được đánh dấu “<literal>Multi-Arch: allowed</literal>”.
				</para>

			</section>

		</section>

	</section>
	 <section id="sect.coexistence-with-other-packaging-systems">
		<title>Cùng tồn tại với các Hệ thống Gói Khác</title>
		 <indexterm>
			<primary>RPM</primary>
		</indexterm>
		 <indexterm>
			<primary>Trình quản lý Gói Red Hat </primary>
		</indexterm>
		 <indexterm>
			<primary><command>alien</command></primary>
		</indexterm>
		 <para>
			Các gói Debian không phải là gói phần mềm duy nhất được sử dụng trong thế giới phần mềm tự do. Đối thủ cạnh tranh chính là định dạng RPM của bản phân phối Red Hat Linux và các dẫn xuất của nó. Red Hat là một phân phối thương mại rất phổ biến. Do đó các phần mềm được cung cấp bởi bên thứ ba được cung cấp ở gói RPM hơn là Debian.
		</para>
		 <para>
			Trong trường hợp này, bạn nên biết rằng chương trình <command>rpm</command>, xử lý các gói RPM, có sẵn như là một gói Debian, vì vậy bạn có thể sử dụng định dạng gói này trên Debian. Tuy nhiên, cần cẩn thận để hạn chế các thao tác này để trích xuất thông tin từ một gói hàng hoặc để xác minh tính toàn vẹn của nó. Đúng vậy, thật không hợp lý để sử dụng <command>rpm</command> để cài đặt RPM trên một hệ thống Debian; RPM sử dụng cơ sở dữ liệu riêng của nó, tách biệt với các phần mềm gốc (như <command>dpkg</command>). Đây là lý do tại sao không thể đảm bảo sự tồn tại ổn định của hai hệ thống gói.
		</para>
		 <para>
			Mặt khác, tiện ích <emphasis role="pkg">alien</emphasis> có thể chuyển đổi gói RPM thành các gói Debian và ngược lại.
		</para>
		 <sidebar> <title><emphasis>COMMUNITY</emphasis> Khuyến khích việc áp dụng <filename>.deb</filename></title>
		 <para>
			If you regularly use the <command>alien</command> program to install RPM packages coming from one of your providers, do not hesitate to write to them and amicably express your strong preference for the <filename>.deb</filename> format. Note that the format of the package is not everything: a <filename>.deb</filename> package built with <command>alien</command> or prepared for a version of Debian different than that which you use, or even for a derivative distribution like Ubuntu, would probably not offer the same level of quality and integration as a package specifically developed for Debian <emphasis role="distribution">Stretch</emphasis>.
		</para>
		 </sidebar> 
<screen>
<computeroutput>$ </computeroutput><userinput>fakeroot alien --to-deb phpMyAdmin-4.7.5-2.fc28.noarch.rpm</userinput>
<computeroutput>phpmyadmin_4.7.5-3_all.deb generated
$ </computeroutput><userinput>ls -s phpmyadmin_4.7.5-3_all.deb</userinput>
<computeroutput>  4356 phpmyadmin_4.7.5-3_all.deb</computeroutput></screen>
		 <para>
			Bạn sẽ thấy rằng quá trình này rất đơn giản. Tuy nhiên, bạn phải biết rằng gói được tạo ra không có bất kỳ thông tin phụ thuộc nào, vì các phụ thuộc trong hai định dạng đóng gói không có sự tương thích trong hệ thống kia. Quản trị viên phải tự đảm bảo rằng gói được chuyển đổi sẽ hoạt động chính xác, và đó là lý do tại sao các gói Debian được tự tạo ra nên tránh càng nhiều càng tốt. May mắn thay, Debian có bộ sưu tập lớn nhất các gói phần mềm của tất cả các bản phân phối, và có thể là bất cứ điều gì bạn tìm kiếm đã có trong đó.
		</para>
		 <para>
			Nhìn vào man page của lệnh <command>alien</command>, bạn cũng sẽ lưu ý rằng chương trình này xử lý các định dạng đóng gói khác, đặc biệt là sử dụng bởi phân phối Slackware (nó được làm bằng một tệp nén đơn giản <filename>tar.gz</filename>).
		</para>
		 <para>
			Sự ổn định của phần mềm được triển khai sử dụng công cụ <command>dpkg</command> góp phần vào sự nổi tiếng của Debian. Bộ công cụ APT, được mô tả trong chương tiếp theo, bảo tồn lợi thế này, đồng thời giảm bớt quản trị viên khỏi việc quản lý tình trạng của bao bì, một nhiệm vụ cần thiết nhưng rất khó khăn.
		</para>

	</section>
</chapter>

