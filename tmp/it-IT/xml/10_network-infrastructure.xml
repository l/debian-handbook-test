<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="network-infrastructure" lang="it-IT">
	<chapterinfo>
		 <keywordset>
			<keyword>Rete</keyword>
			 <keyword>Gateway</keyword>
			 <keyword>TCP/IP</keyword>
			 <keyword>IPv6</keyword>
			 <keyword>DNS</keyword>
			 <keyword>Bind</keyword>
			 <keyword>DHCP</keyword>
			 <keyword>QoS</keyword>

		</keywordset>

	</chapterinfo>
	 <title id="infrastructure.title">Infrastruttura di rete</title>
	 <highlights> <para>
		Linux beneficia del notevole patrimonio di Unix nel campo delle reti, e Debian offre una gamma completa di strumenti per la loro creazione e gestione. Questo capitolo esamina questi strumenti.
	</para>
	 </highlights> <section id="sect.gateway">
		<title>Gateway</title>
		 <para>
			Un gateway è un sistema di connessione tra reti diverse. Questo termine si riferisce spesso al «punto di uscita» di una rete locale sul percorso obbligato per tutti gli indirizzi IP esterni. Il gateway è connesso a ciascuna delle reti che collega insieme, e agisce come un router per trasmettere i pacchetti IP tra le varie interfacce.
		</para>
		 <indexterm>
			<primary>gateway</primary>
		</indexterm>
		 <indexterm>
			<primary>rete</primary>
			<secondary>gateway</secondary>
		</indexterm>
		 <indexterm>
			<primary>router</primary>
		</indexterm>
		 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> Pacchetto IP</title>
		 <indexterm>
			<primary>pacchetto</primary>
			<secondary>IP</secondary>
		</indexterm>
		 <para>
			La maggior parte delle reti attuali utilizzano il protocollo IP (protocollo Internet: <emphasis>Internet Protocol</emphasis>). Questo protocollo segmenta i dati trasmessi in pacchetti di dimensioni limitate. Ogni pacchetto contiene, in aggiunta ai dati da trasmettere, un numero di dati necessari per il suo corretto instradamento.
		</para>
		 </sidebar> <sidebar id="sidebar.tcp-udp"> <title><emphasis>FONDAMENTALI</emphasis> TCP/UDP</title>
		 <indexterm>
			<primary>porta</primary>
			<secondary>TCP</secondary>
		</indexterm>
		 <indexterm>
			<primary>porta</primary>
			<secondary>UDP</secondary>
		</indexterm>
		 <indexterm>
			<primary>TCP, porta</primary>
		</indexterm>
		 <indexterm>
			<primary>UDP, porta</primary>
		</indexterm>
		 <para>
			Molti programmi non gestiscono autonomamente i singoli pacchetti, anche se i dati che trasmettono viaggiano su IP, ma generalmente utilizzano TCP (protocollo di controllo trasmissione: <emphasis>Transmission Control Protocol</emphasis>). TCP è un livello sopra IP che consente la creazione di connessioni dedicate a flussi di dati tra due punti. I programmi in seguito visualizzano solo un punto di ingresso in cui i dati possono essere trasmessi con la garanzia che gli stessi dati risulteranno senza perdita (e nella stessa sequenza) nel punto di uscita all'altra estremità della connessione. Benché possono accadere molti tipi di errori negli strati inferiori, questi vengono compensati da TCP: i pacchetti persi vengono ritrasmessi, ed i pacchetti in arrivo nell'ordine sbagliato (per esempio, se hanno usato percorsi differenti) vengono riordinati in modo appropriato.
		</para>
		 <para>
			Un altro protocollo che si basa sull'IP è UDP (<emphasis>User Datagram Protocol</emphasis>). Al contrario di TCP, è orientato al pacchetto di dati (packet-oriented). I suoi obiettivi sono diversi: lo scopo di UDP è solo quello di trasmettere un pacchetto da un'applicazione all'altra. Il protocollo non tenta di compensare la perdita di pacchetti possibile nel percorso, né garantisce che i pacchetti vengano ricevuti nello stesso ordine in cui sono stati inviati. Il vantaggio principale di questo protocollo è che la latenza è notevolmente migliorata, in quanto la perdita di un singolo pacchetto non ritarda la ricezione di tutti i pacchetti successivi fino quando quello perso viene ritrasmesso.
		</para>
		 <para>
			Sia TCP che UDP coinvolgono le porte, che sono «numeri di interno», per stabilire una comunicazione con una determinata applicazione su una macchina. Questo concetto permette di mantenere comunicazioni multiple diverse in parallelo con lo stesso destinatario, visto che possono essere distinte in base al numero di porta.
		</para>
		 <para>
			Alcuni di questi numeri di porta - standardizzati da IANA (<emphasis>Internet Assigned Numbers Authority</emphasis>), sono «ben noti» per essere associati ai servizi di rete. Per esempio, la porta TCP 25 viene generalmente utilizzata dal server di posta elettronica. <ulink type="block" url="http://www.iana.org/assignments/port-numbers" />
		</para>
		 </sidebar> <para>
			Quando una rete locale utilizza un intervallo di indirizzi privati (non instradabili su Internet), il gateway deve attuare il <emphasis>mascheramento degli indirizzi</emphasis> in modo che le macchine sulla rete possano comunicare con il mondo esterno. L'operazione di mascheramento è una sorta di proxy operante a livello di rete: ogni connessione in uscita da una macchina interna viene sostituita con una connessione dal gateway stesso (in quanto il gateway ha un indirizzo instradabile verso l'esterno), i dati che passano dalla connessione mascherata vengono inviati alla nuova, ed i dati che ritornano in risposta vengono inviati attraverso la connessione mascherata alla macchina interna. Il gateway utilizza una serie di porte TCP dedicate a questo scopo, di solito con numeri molto elevati (oltre 60000). Ogni connessione proveniente da una macchina interna appare quindi al mondo esterno, come una connessione proveniente da una di queste porte riservate.
		</para>
		 <indexterm>
			<primary>mascheramento</primary>
		</indexterm>
		 <sidebar> <title><emphasis>CULTURA</emphasis> Intervallo di indirizzi privati</title>
		 <indexterm>
			<primary>indirizzo IP </primary>
			<secondary>privato</secondary>
		</indexterm>
		 <indexterm>
			<primary>indirizzo IP privato</primary>
		</indexterm>
		 <para>
			La RFC 1918 definisce tre intervalli di indirizzi IPv4 che non possono essere instradati su Internet ma utilizzati solo in reti locali. Il primo, <literal>10.0.0.0/8</literal> (vedere il riquadro <xref linkend="sidebar.networking-basics" />), è un intervallo di classe A (con 2<superscript>24</superscript> indirizzi IP). Il secondo, <literal>172.16.0.0/12</literal>, raccoglie 16 intervalli di classe B (da <literal>172.16.0.0/16</literal> a <literal>172.31.0.0/16</literal>), ciascuno contenente 2<superscript>16</superscript> indirizzi IP. Infine, <literal>192.168.0.0/16</literal> è un intervallo di classe B (che raggruppa di 256 intervalli di classe C, da <literal>192.168.0.0/24</literal> a <literal>192.168.255.0/24</literal>, con 256 indirizzi IP ciascuno). <ulink type="block" url="http://www.faqs.org/rfcs/rfc1918.html" />
		</para>
		 </sidebar> <para>
			Il gateway può anche eseguire due tipi di <emphasis>Network Address Translation</emphasis> (Traduzione degli Indirizzi di Rete o abbreviato NAT). Il primo tipo, <emphasis>Destination NAT</emphasis> (DNAT) consiste nel modificare l'indirizzo IP di destinazione (e/o la porta TCP o UDP) per una connessione (generalmente) in ingresso. Il meccanismo di controllo e tracciatura del collegamento modifica anche i pacchetti successivi nella stessa connessione per assicurare la continuità nella comunicazione. Il secondo tipo di NAT è <emphasis>Source NAT</emphasis> (SNAT), di cui è un caso particolare il <emphasis>masquerading</emphasis> (mascheramento). SNAT modifica l'indirizzo IP sorgente (e/o la porta TCP o UDP) del pacchetto (generalmente) in uscita. Come per DNAT, tutti i pacchetti nella connessione sono opportunamente gestiti dal meccanismo di tracciamento della connessione stessa. Si noti che NAT è rilevante solo per IPv4 e il suo limitato spazio di indirizzi; in IPv6, l'ampia disponibilità di indirizzi riduce notevolmente l'utilità di NAT, consentendo a tutti gli indirizzi "interni" di essere direttamente instradabili su Internet (ciò non implica che le macchine interne siano accessibili, in quanto i firewall intermedi sono in grado di filtrare il traffico).
		</para>
		 <indexterm>
			<primary>NAT</primary>
		</indexterm>
		 <indexterm>
			<primary>Network</primary>
			<secondary>Address Translation</secondary>
		</indexterm>
		 <indexterm>
			<primary>SNAT</primary>
		</indexterm>
		 <indexterm>
			<primary>DNAT</primary>
		</indexterm>
		 <indexterm>
			<primary>Destination NAT</primary>
		</indexterm>
		 <indexterm>
			<primary>Source NAT</primary>
		</indexterm>
		 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> Port forwarding</title>
		 <indexterm>
			<primary>port forwarding</primary>
		</indexterm>
		 <para>
			Un'applicazione concreta di DNAT è il <emphasis>port forwarding</emphasis>. Le connessioni in ingresso su una determinata porta di una macchina vengono inoltrate verso una porta su un'altra macchina. Tuttavia esistono altre soluzioni tecniche che possono ottenere un risultato simile, anche se, soprattutto a livello di applicazione con <command>ssh</command> (vedere la <xref linkend="sect.ssh-port-forwarding" /> ) o <command>redir</command>.
		</para>
		 </sidebar> <para>
			Basta teoria, andiamo sul pratico. Trasformare un sistema Debian in un gateway è una questione semplice, basta attivare l'apposita opzione nel kernel Linux, mediante il filesystem virtuale <filename>/proc/</filename>:
		</para>
		 
<screen>
<computeroutput># </computeroutput><userinput>echo 1 &gt; /proc/sys/net/ipv4/conf/default/forwarding</userinput></screen>
		 <para>
			Questa opzione può anche essere attivata automaticamente all'avvio, se <filename>/etc/sysctl.conf</filename> imposta l'opzione <literal>net.ipv4.conf.default.forwarding</literal> a <literal>1</literal>.
		</para>
		 <example id="example.sysctl.conf">
			<title>Il file <filename>/etc/sysctl.conf</filename></title>
			 
<programlisting>
net.ipv4.conf.default.forwarding = 1
net.ipv4.conf.default.rp_filter = 1
net.ipv4.tcp_syncookies = 1</programlisting>

		</example>
		 <para>
			Lo stesso effetto può essere ottenuto per IPv6 semplicemente sostituendo <literal>ipv4</literal> con <literal>ipv6</literal> nel comando manuale e modificando la riga <literal>net.ipv6.conf.all.forwarding</literal> nel file <filename>/etc/sysctl.conf</filename>.
		</para>
		 <para>
			Abilitare il mascheramento IPv4 è un'operazione leggermente più complessa che coinvolge la configurazione del firewall <emphasis>netfilter</emphasis>.
		</para>
		 <para>
			Similmente, l'utilizzo di NAT (per IPv4) richiede configurare <emphasis>netfilter</emphasis>. Dato che lo scopo primario di questo componente è il filtraggio dei pacchetti, i dettagli sono elencati nel <xref linkend="security" xrefstyle="select: label quotedtitle nopage" /> (vedere la <xref linkend="sect.firewall-packet-filtering" />).
		</para>

	</section>
	 <section id="sect.virtual-private-network">
		<title>Rete privata virtuale (VPN)</title>
		 <para>
			Una <emphasis>rete privata virtuale</emphasis> (VPN in breve) è un modo per collegare due diverse reti locali attraverso Internet per mezzo di un tunnel che, per mantenere la riservatezza, di solito è criptato. Le VPN vengono spesso usate per integrare una macchina remota nella rete locale di un'azienda.
		</para>
		 <indexterm>
			<primary>rete</primary>
			<secondary>privata virtuale</secondary>
		</indexterm>
		 <indexterm>
			<primary>VPN</primary>
		</indexterm>
		 <indexterm>
			<primary>rete privata virtuale</primary>
		</indexterm>
		 <para>
			Esistono diversi strumenti utili a questo scopo. OpenVPN è una soluzione efficace, facile da implementare e gestire, basata su SSL/TLS. Un'altra possibilità è l'utilizzo di IPsec per cifrare il traffico IP tra due macchine; la cifratura è trasparente, il che significa che le applicazioni in esecuzione su questi host non devono essere modificate per tener conto della VPN. Può anche essere utilizzato SSH per realizzare una VPN, in aggiunta alle sue caratteristiche più convenzionali. Infine, una VPN può essere stabilita utilizzando il protocollo Microsoft PPTP. Esistono altre soluzioni, ma vanno oltre l'obiettivo di questo libro.
		</para>
		 <section id="sect.openvpn">
			<title>OpenVPN</title>
			 <indexterm>
				<primary>OpenVPN</primary>
			</indexterm>
			 <para>
				OpenVPN è un software dedicato alla creazione di reti private virtuali. La sua configurazione prevede la creazione di interfacce di rete virtuali sul server VPN e sul/sui client; sono supportate entrambe le interfacce <literal>tun</literal> (per tunnel a livello IP) e <literal>tap</literal> (per tunnel a livello di Ethernet). In pratica, generalmente vengono utilizzate le interfacce <literal>tun</literal> tranne quando i client VPN vengono integrati nella rete locale del server per mezzo di un bridge (ponte) Ethernet.
			</para>
			 <para>
				OpenVPN si basa su OpenSSL per tutta la crittografia SSL/TLS e le funzioni associate (riservatezza, autenticazione, integrità, non rifiuto). Può essere configurato sia con una chiave privata condivisa che con certificati X.509 basati su un'infrastruttura a chiave pubblica. Quest'ultima configurazione è fortemente preferibile in quanto permette una maggiore flessibilità di fronte a un numero crescente di utenti in roaming che accedono alla VPN.
			</para>
			 <sidebar> <title><emphasis>CULTURA</emphasis> SSL e TLS</title>
			 <indexterm>
				<primary>SSL</primary>
			</indexterm>
			 <indexterm>
				<primary>TLS</primary>
			</indexterm>
			 <para>
				Il protocollo SSL (<emphasis>Secure Socket Layer</emphasis>) è stato inventato da Netscape per rendere sicure le connessioni ai server web. È stato poi standardizzato da IETF sotto l'acronimo TLS (<emphasis>Transport Layer Security</emphasis>). Da allora TLS ha continuato ad evolversi ed oggi SSL è deprecato a causa di molteplici difetti di progettazione che sono stati scoperti.
			</para>
			 </sidebar> <section id="sect.easy-rsa">
				<title>Infrastruttura a chiave pubblica: <emphasis>easy-rsa</emphasis></title>
				 <indexterm>
					<primary>PKI (Public Key Infrastructure)</primary>
				</indexterm>
				 <indexterm>
					<primary>Public Key Infrastructure</primary>
				</indexterm>
				 <indexterm>
					<primary>X.509, certificato</primary>
				</indexterm>
				 <indexterm>
					<primary>certificato</primary>
					<secondary>X.509</secondary>
				</indexterm>
				 <indexterm>
					<primary><emphasis>easy-rsa</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary>RSA (algoritmo)</primary>
				</indexterm>
				 <indexterm>
					<primary>coppia di chiavi</primary>
				</indexterm>
				 <para>
					Si tratta di una «coppia di chiavL'algoritmo RSA è ampiamente utilizzato nella crittografia a chiave pubblica. i», formata da una chiave privata e una chiave pubblica. Le due chiavi sono strettamente legate l'una all'altra, e le loro proprietà matematiche sono tali che un messaggio cifrato con la chiave pubblica può essere decifrato solo da qualcuno a conoscenza della chiave privata, garantendone la riservatezza. Al contrario, un messaggio cifrato con la chiave privata può essere decodificato da chiunque conosca la chiave pubblica, il che permette di autenticare l'origine di un messaggio in quanto solo una persona con accesso alla chiave privata lo avrebbe potuto generare. Quando è associato ad una funzione hash digitale (MD5, SHA1 o una variante più recente), si ottiene un meccanismo di firma che può essere applicato a qualsiasi messaggio.
				</para>
				 <para>
					Tuttavia, chiunque può creare una coppia di chiavi, archiviarvi qualsiasi identità, e fingere di essere l'identità da lui scelta. Una soluzione implica il concetto di <emphasis>Autorità di certificazione</emphasis> (CA: «Certification Authority» ), formalizzato dallo standard X.509. Questo termine si riferisce a un soggetto che detiene una coppia di chiavi fidate conosciuto come <emphasis>certificato principale</emphasis>. Questo certificato viene utilizzato solamente per firmare altri certificati (coppie di chiavi), dopo che sono state adottate misure adeguate per controllare l'identità memorizzata nella coppia di chiavi. Le applicazioni che utilizzano X.509 possono quindi controllare i certificati presentati, se ne conoscono i certificati principali attendibili.
				</para>
				 <para>
					OpenVPN segue questa regola. Dal momento che le CA pubbliche emettono solamente certificati in cambio di un (costoso) pagamento, è possibile creare un'autorità di certificazione privata all'interno dell'azienda. Il pacchetto <emphasis role="pkg">easy-rsa</emphasis> fornisce gli strumenti che servono come infrastruttura di certificazione X.509, offrendo un insieme di script utilizzando il comando <command>openssl</command>.
				</para>
				 <sidebar> <title><emphasis>NOTA</emphasis> <emphasis>easy-rsa</emphasis> prima di <emphasis role="distribution">Jessie</emphasis></title>
				 <para>
					Nelle versioni di Debian fino a <emphasis role="distribution">Wheezy</emphasis>, <emphasis>easy-rsa</emphasis> è stato distribuito come parte del pacchetto <emphasis role="pkg">openvpn</emphasis>, e gli script potevano esssere trovati in <filename>/usr/share/doc/openvpn/examples/easy-rsa/2.0/</filename>. L'impostazione di una CA richiede la copia di quella directory, invece di usare il comando <command>make-cadir</command> come documentato qui.
				</para>
				 </sidebar> <para>
					Gli amministratori della Falcot Corp utilizzano questo strumento per creare i certificati richiesti, sia per il server che per i client. Questo permette una configurazione simile di tutti i client, dato che dovranno essere impostati solo per considerare attendibili i certificati provenienti dalla CA locale di Falcot. Questa CA crea il primo certificato; a tal fine, gli amministratori impostano in un luogo appropriato la directory con i file richiesti per la CA, preferibilmente su una macchina non connessa alla rete, per ridurre il rischio di furto della chiave privata della CA.
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>make-cadir pki-falcot
</userinput><computeroutput>$ </computeroutput><userinput>cd pki-falcot</userinput></screen>
				 <para>
					Successivamente salvano i parametri richiesti nel file <filename>vars</filename>, specialmente quelli denominati con un prefisso <literal>KEY_</literal>; queste variabili vengono poi integrate nell'ambiente:
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>vim vars
</userinput><computeroutput>$ </computeroutput><userinput>grep KEY_ vars
</userinput><computeroutput>export KEY_CONFIG=`$EASY_RSA/whichopensslcnf $EASY_RSA`
export KEY_DIR="$EASY_RSA/keys"
echo NOTE: If you run ./clean-all, I will be doing a rm -rf on $KEY_DIR
export KEY_SIZE=2048
export KEY_EXPIRE=3650
export KEY_COUNTRY="FR"
export KEY_PROVINCE="Loire"
export KEY_CITY="Saint-Étienne"
export KEY_ORG="Falcot Corp"
export KEY_EMAIL="admin@falcot.com"
export KEY_OU="Certificate authority"
export KEY_NAME="Certificate authority for Falcot Corp"
# If you'd like to sign all keys with the same Common Name, uncomment the KEY_CN export below
# export KEY_CN="CommonName"
$ </computeroutput><userinput>. ./vars
</userinput><computeroutput>NOTE: If you run ./clean-all, I will be doing a rm -rf on /home/roland/pki-falcot/keys
$ </computeroutput><userinput>./clean-all
</userinput></screen>
				 <para>
					Il passo successivo è la creazione della coppia di chiavi della CA stessa (le due parti della coppia di chiavi vengono memorizzate nei file <filename>keys/ca.crt</filename> e <filename>keys/ca.key</filename> durante questa fase):
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>./build-ca</userinput>
<computeroutput>Generating a 2048 bit RSA private key
...................................................................+++
...+++
writing new private key to 'ca.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [Falcot Corp CA]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:
</computeroutput></screen>
				 <para>
					Il certificato per il server VPN può essere creato, così come i parametri Diffie-Hellman necessari dal lato server per una connessione SSL/TLS. Il server VPN è identificato dal suo nome DNS <literal>vpn.falcot.com</literal>; questo nome viene riutilizzato per i file chiave generati (<filename>keys/vpn.falcot.com.crt</filename> per il certificato pubblico, <filename>keys/vpn.falcot.com.key</filename> per la chiave privata):
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>./build-key-server vpn.falcot.com
</userinput><computeroutput>Generating a 2048 bit RSA private key
.....................................................................................................................+++
...........+++
writing new private key to 'vpn.falcot.com.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [vpn.falcot.com]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
Using configuration from /home/roland/pki-falcot/openssl-1.0.0.cnf
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
countryName           :PRINTABLE:'FR'
stateOrProvinceName   :PRINTABLE:'Loire'
localityName          :T61STRING:'Saint-\0xFFFFFFC3\0xFFFFFF89tienne'
organizationName      :PRINTABLE:'Falcot Corp'
organizationalUnitName:PRINTABLE:'Certificate authority'
commonName            :PRINTABLE:'vpn.falcot.com'
name                  :PRINTABLE:'Certificate authority for Falcot Corp'
emailAddress          :IA5STRING:'admin@falcot.com'
Certificate is to be certified until Mar  6 14:54:56 2025 GMT (3650 days)
Sign the certificate? [y/n]:</computeroutput><userinput>y
</userinput><computeroutput>

1 out of 1 certificate requests certified, commit? [y/n]</computeroutput><userinput>y
</userinput><computeroutput>Write out database with 1 new entries
Data Base Updated
$ </computeroutput><userinput>./build-dh
</userinput><computeroutput>Generating DH parameters, 2048 bit long safe prime, generator 2
This is going to take a long time
[…]
</computeroutput></screen>
				 <para>
					Il passo seguente crea i certificati per i client VPN, è richiesto un certificato per ogni computer o persona autorizzata ad usare la VPN:
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>./build-key JoeSmith
</userinput><computeroutput>Generating a 2048 bit RSA private key
................................+++
..............................................+++
writing new private key to 'JoeSmith.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:</computeroutput><userinput>Development unit
</userinput><computeroutput>Common Name (eg, your name or your server's hostname) [JoeSmith]:</computeroutput><userinput>Joe Smith
</userinput><computeroutput>[…]</computeroutput></screen>
				 <para>
					Ora che sono stati creati tutti i certificati, bisogna copiarli dove è appropriato: la chiave pubblica del certificato principale (<filename>keys/ca.crt</filename>) verrà memorizzata su tutte le macchine (sia server che client) come <filename>/etc/ssl/certs/Falcot_CA.crt</filename>. Il certificato del server è installato solo sul server (<filename>keys/vpn.falcot.com.crt</filename> va in <filename>/etc/ssl/vpn.falcot.com.crt</filename>, e <filename>keys/vpn.falcot.com.key</filename> va in <filename>/etc/ssl/private/vpn.falcot.com.key</filename> con permessi limitati in modo che solo l'amministratore possa leggerlo), con i corrispondenti parametri Diffie-Hellman (<filename>keys/dh2048.pem</filename>) installati in <filename>/etc/openvpn/dh2048.pem</filename>. I certificati client vengono installati in modo simile nel corrispondente client VPN.
				</para>

			</section>
			 <section>
				<title>Configurazione del server OpenVPN</title>
				 <para>
					Per impostazione predefinita, lo script di inizializzazione di OpenVPN cerca di avviare tutte le reti private virtuali definite in <filename>/etc/openvpn/*.conf</filename>. Per configurare un server VPN basta quindi memorizzare il corrispondente file di configurazione in questa directory. Un buon punto di partenza è <filename>/usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz</filename>, che porta ad un server abbastanza standard. Naturalmente, alcuni parametri devono essere adattati: <literal>ca</literal>, <literal>cert</literal>, <literal>key</literal> e <literal>dh</literal> devono descrivere le posizioni scelte (rispettivamente, <literal>/etc/ssl/certs/Falcot_CA.crt</literal>, <literal>/etc/ssl/vpn.falcot.com.crt</literal>, <literal>/etc/ssl/private/vpn.falcot.com.key</literal> e <literal>/etc/openvpn/dh2048.pem</literal>). La direttiva <literal>server 10.8.0.0 255.255.255.0</literal> definisce la sottorete utilizzata dalla VPN; il server utilizza il primo indirizzo IP in quell'intervallo (<literal>10.8.0.1</literal>) ed il resto degli indirizzi viene assegnato ai client.
				</para>
				 <para>
					Con questa configurazione, l'avvio di OpenVPN crea l'interfaccia di rete virtuale solitamente con il nome <literal>tun0</literal>. Tuttavia, i firewall sono spesso configurati contemporaneamente alle interfacce di rete reali, e questo avviene prima dell'avvio di OpenVPN. Le buone pratiche raccomandano pertanto la creazione di una interfaccia di rete virtuale persistente e di configurare OpenVPN ad utilizzare questa interfaccia preesistente. Questo permette inoltre di scegliere il nome per questa interfaccia. A tal fine, il comando <command>openvpn --mktun --dev vpn --dev-type tun</command> crea una interfaccia di rete virtuale denominata <literal>vpn</literal> di tipo <literal>tun</literal>; questo comando può essere facilmente integrato nello script di configurazione del firewall, o in una direttiva <literal>up</literal> del file <filename>/etc/network/interfaces</filename>. Il file di configurazione di OpenVPN deve essere aggiornato di conseguenza, con le direttive <literal>dev vpn</literal> e <literal>dev-type tun</literal>.
				</para>
				 <para>
					Salvo ulteriori modifiche, i client VPN possono accedere solo al server VPN stesso attraverso l'indirizzo <literal>10.8.0.1</literal>. Per fornire ai client l'accesso alla rete locale (192.168.0.0/24) è necessario aggiungere una direttiva <literal>push route 192.168.0.0 255.255.255.0</literal> nella configurazione di OpenVPN, in questo modo i client VPN ottengono automaticamente un percorso di rete che gli consente di raggiungere questa rete attraverso la VPN. Inoltre, le macchine sulla rete locale devono anche essere informate che il percorso verso la VPN passa attraverso il server VPN (questo funziona automaticamente quando il server VPN è installato sul gateway). In alternativa, il server VPN può essere configurato per eseguire il mascheramento IP in modo che le connessioni provenienti dai client VPN figurino invece come provenienti dal server VPN (vedere la <xref linkend="sect.gateway" />).
				</para>

			</section>
			 <section>
				<title>Configurazione del client OpenVPN</title>
				 <para>
					Anche l'impostazione di un client OpenVPN richiede la creazione di un file di configurazione in <filename>/etc/openvpn/</filename>. Una configurazione standard può essere ottenuta usando <filename>/usr/share/doc/openvpn/examples/sample-config-files/client.conf</filename> come punto di partenza. La direttiva <literal>remote vpn.falcot.com 1194</literal> indica l'indirizzo e la porta del server OpenVPN. Le direttive <literal>ca</literal>, <literal>cert</literal> e <literal>key</literal> devono essere modificate per indicare le posizioni dei file di chiave.
				</para>
				 <para>
					Se la VPN non deve essere avviata automaticamente all'avvio, impostare la direttiva <literal>AUTOSTART</literal> su <literal>none</literal> nel file <filename>/etc/default/openvpn</filename>. L'avvio o l'arresto di una determinata connessione VPN è sempre possibile con i comandi <command>service openvpn@<replaceable>name</replaceable> start</command> e <command>service openvpn@<replaceable>nome</replaceable> stop</command> (dove il <replaceable>nome</replaceable> della connessione corrisponde a quello definito in <filename>/etc/openvpn/<replaceable>nome</replaceable>.conf</filename>).
				</para>
				 <para>
					Il pacchetto <emphasis role="pkg">network-manager-openvpn-gnome</emphasis> contiene un'estensione per Network Manager (vedere la <xref linkend="sect.roaming-network-config" />) che consente la gestione delle reti private virtuali di OpenVPN. Questo permette ad ogni utente di configurare le connessioni OpenVPN graficamente e di controllarle tramite l'icona di gestione della rete. <indexterm><primary><emphasis role="pkg">network-manager-openvpn-gnome</emphasis></primary></indexterm>
				</para>

			</section>

		</section>
		 <section id="sect.ssh-vpn">
			<title>Rete privata virtuale con SSH</title>
			 <indexterm>
				<primary>SSH</primary>
			</indexterm>
			 <indexterm>
				<primary>PPP</primary>
			</indexterm>
			 <para>
				In realtà ci sono due modi per creare una rete privata virtuale con SSH. La versione storica richiede la creazione di uno strato di PPP sul collegamento SSH. Questo metodo è descritto in un documento HOWTO: <ulink type="block" url="http://www.tldp.org/HOWTO/ppp-ssh/" />
			</para>
			 <para>
				Il secondo metodo è più recente, ed è stato introdotto con OpenSSH 4.3. OpenSSH ora può creare interfacce di rete virtuali (<literal>tun*</literal>) su entrambi i lati di una connessione SSH, e queste interfacce virtuali possono essere configurate esattamente come se fossero interfacce fisiche. Il sistema di tunneling deve essere prima abilitato impostando <literal>PermitTunnel</literal> a «yes» nel file di configurazione del server SSH (<filename>/etc/ssh/sshd_config</filename>). Nello stabilire la connessione SSH, la creazione di un tunnel deve essere esplicitamente richiesta con l'opzione <literal>-w any:any</literal> (<literal>any</literal> può essere sostituito con il numero desiderato per il dispositivo <literal>tun</literal>). Questo richiede che l'utente disponga dei privilegi di amministratore su entrambi i lati, così da poter creare il dispositivo di rete (in altre parole, la connessione deve essere stabilita come root).
			</para>
			 <para>
				Entrambi i metodi, permettono di implementare facilmente la creazione di una rete privata virtuale su SSH. Tuttavia, non nella maniera più efficiente: in particolare le VPN che forniscono non sono adatte per elevati livelli di traffico.
			</para>
			 <para>
				La spiegazione è che quando uno stack TCP/IP è incapsulato all'interno di una connessione TCP/IP (per SSH), il protocollo TCP viene utilizzato per due volte: una per la connessione SSH ed una all'interno del tunnel. Questo comporta problemi, soprattutto per il modo in cui TCP si adatta alle condizioni della rete variando i ritardi di timeout. Sul sito riportato di seguito viene descritto il problema in modo più dettagliato: <ulink type="block" url="http://sites.inka.de/sites/bigred/devel/tcp-tcp.html" />. Le VPN su SSH dovrebbero pertanto essere limitate unicamente a tunnel temporanei senza vincoli di prestazioni.
			</para>

		</section>
		 <section id="sect.ipsec">
			<title>IPSec</title>
			 <indexterm>
				<primary>IPsec</primary>
			</indexterm>
			 <indexterm>
				<primary><command>strongswan</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>racoon</command></primary>
			</indexterm>
			 <para>
				IPsec, pur rappresentando lo standard nelle VPN IP, è molto più difficile da implementare. Il motore di IPsec è integrato nel kernel di Linux; il pacchetto <emphasis role="pkg">ipsec-tools</emphasis> fornisce i componenti necessari nello spazio utente, gli strumenti di controllo e configurazione. In termini concreti, in ogni host è presente un file <filename>/etc/ipsec-tools.conf</filename> che contiene i parametri per i <emphasis>tunnel IPsec</emphasis> (o, nella terminologia IPsec, <emphasis>Security Association</emphasis>) che riguardano l'host; lo script <command>/etc/init.d/setkey</command> fornisce un modo per avviare e arrestare un tunnel (ogni tunnel è un collegamento sicuro ad un altro host collegato alla rete privata virtuale). Questo file può essere costruito a mano a partire dalla documentazione fornita dalla pagina di manuale <citerefentry><refentrytitle>setkey</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry>. Tuttavia, scrivere esplicitamente i parametri per tutti gli host in un insieme non piccolo di macchine diventa rapidamente un compito arduo, in quanto il numero di tunnel cresce velocemente. L'installazione di un demone IKE (per <emphasis>IPsec Key Exchange</emphasis>) come <emphasis role="pkg">racoon</emphasis> o <emphasis role="pkg">strongswan</emphasis> rende il processo molto più semplice rendendo la'mministrazione centralizzata, e più sicura ruotando le chiavi periodicamente.
			</para>
			 <indexterm>
				<primary>IKE</primary>
			</indexterm>
			 <indexterm>
				<primary>IPsec</primary>
				<secondary>Scambio Chiavi IPsec</secondary>
			</indexterm>
			 <indexterm>
				<primary>coppia di chiavi</primary>
			</indexterm>
			 <indexterm>
				<primary><command>setkey</command></primary>
			</indexterm>
			 <para>
				A dispetto del suo status di riferimento, la complessità della configurazione di IPsec limita il suo utilizzo nella pratica. Soluzioni basate su OpenVPN verranno generalmente preferite quando i tunnel richiesti non sono né troppi né troppo dinamici.
			</para>
			 <sidebar> <title><emphasis>ATTENZIONE</emphasis> IPsec e NAT</title>
			 <para>
				I firewall NAT e IPsec non lavorano bene insieme: poiché IPsec firma i pacchetti, qualsiasi cambiamento (eventualmente) fatto dal firewall sui pacchetti renderà la firma non valida e i pacchetti verranno rifiutati a destinazione. Varie implementazioni di IPsec includono ora la tecnica <emphasis>NAT-T</emphasis> (<emphasis>NAT Traversal</emphasis>), che fondamentalmente incapsula il pacchetto IPsec all'interno di un pacchetto UDP standard.
			</para>
			 <indexterm>
				<primary>NAT-T</primary>
			</indexterm>
			 <indexterm>
				<primary>NAT Traversal</primary>
			</indexterm>
			 </sidebar> <sidebar> <title><emphasis>SICUREZZA</emphasis> IPsec e firewall</title>
			 <para>
				La modalità standard di IPsec prevede lo scambio di dati sulla porta UDP 500 per gli scambi delle chiavi (anche sulla porta UDP 4500 nel caso NAT-T sia in funzione). Inoltre, i pacchetti IPsec utilizzano due protocolli IP dedicati che il firewall deve lasciare passare; la ricezione di questi pacchetti è basata sul loro numero di protocollo, 50 (ESP) e 51 (AH).
			</para>
			 <indexterm>
				<primary>ESP, protocollo</primary>
			</indexterm>
			 <indexterm>
				<primary>AH, protocollo</primary>
			</indexterm>
			 <indexterm>
				<primary>protocollo</primary>
				<secondary>AH</secondary>
			</indexterm>
			 <indexterm>
				<primary>protocollo</primary>
				<secondary>ESP</secondary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.pptp">
			<title>PPTP</title>
			 <para>
				PPTP (protocollo di tunneling punto a punto: <emphasis>Point to Point Tunneling Protocol</emphasis>) utilizza due canali di comunicazione, uno per i dati di controllo e uno per i dati di traffico; quest'ultimo utilizza il protocollo GRE (incapsulamento generico di instradamento: <emphasis>Generic Routing Encapsulation</emphasis>). Un collegamento PPP standard viene poi stabilito sopra il canale di scambio dei dati.
			</para>
			 <indexterm>
				<primary>PPTP</primary>
			</indexterm>
			 <indexterm>
				<primary>Point-to-Point Tunneling Protocol</primary>
			</indexterm>
			 <indexterm>
				<primary>GRE, protocollo</primary>
			</indexterm>
			 <indexterm>
				<primary>protocollo</primary>
				<secondary>GRE</secondary>
			</indexterm>
			 <section id="sect.pptp-config-client">
				<title>Configurazione del client</title>
				 <para>
					Il pacchetto <emphasis role="pkg">pptp-linux</emphasis> contiene un client PPTP facilmente configurabile per Linux. Le seguenti istruzioni trovano ispirazione nella documentazione ufficiale: <ulink type="block" url="http://pptpclient.sourceforge.net/howto-debian.phtml" />
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">pptp-linux</emphasis></primary>
				</indexterm>
				 <para>
					Gli amministratori della Falcot hanno creato diversi file: <filename>/etc/ppp/options.pptp</filename>, <filename>/etc/ppp/peers/falcot</filename>, <filename>/etc/ppp/ip-up.d/falcot</filename> e <filename>/etc/ppp/ip-down.d/falcot</filename>.
				</para>
				 <example id="example.ppp-options.pptp">
					<title>Il file <filename>/etc/ppp/options.pptp</filename></title>
					 
<programlisting>
# Opzioni PPP usate per una connessione PPTP
lock
noauth
nobsdcomp
nodeflate</programlisting>

				</example>
				 <example id="example.ppp-peers-falcot">
					<title>Il file <filename>/etc/ppp/peers/falcot</filename></title>
					 
<programlisting>
# vpn.falcot.com e' il server PPTP
pty "pptp vpn.falcot.com --nolaunchpppd"
# la connessione si identifichera' come utente 'vpn'
user vpn
remotename pptp
# e' necessaria la cifratura
require-mppe-128
file /etc/ppp/options.pptp
ipparam falcot</programlisting>

				</example>
				 <example id="example.ppp-ip-up.d-falcot">
					<title>Il file <filename>/etc/ppp/ip-up.d/falcot</filename></title>
					 
<programlisting>
# Creare l'instradamento per la rete Falcot
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 e' la rete Falcot (remota)
  route add -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi</programlisting>

				</example>
				 <example id="example.ppp-ip-down.d-falcot">
					<title>Il file <filename>/etc/ppp/ip-down.d/falcot</filename></title>
					 
<programlisting>
# Eliminare l'instradamento alla rete Falcot
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 e' la rete Falcot (remota)
  route del -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi</programlisting>

				</example>
				 <sidebar> <title><emphasis>SICUREZZA</emphasis> MPPE</title>
				 <para>
					Mettere in sicurezza PPTP implica l'uso della funzionalità di crittografia MPPE (<emphasis>Microsoft Point to Point Encryption</emphasis>), disponibile come modulo nei kernel Debian ufficiali.
				</para>
				 <indexterm>
					<primary>MPPE</primary>
				</indexterm>
				 <indexterm>
					<primary>Microsoft</primary>
					<secondary>Point-to-Point Encryption</secondary>
				</indexterm>
				 </sidebar>
			</section>
			 <section id="sect.pptp-config-serveur">
				<title>Configurazione del server</title>
				 <sidebar> <title><emphasis>ATTENZIONE</emphasis> PPTP e firewall</title>
				 <para>
					I firewall intermedi devono essere configurati per consentire il passaggio dei pacchetti IP che utilizzano il protocollo 47 (GRE). Inoltre, la porta 1723 del server PPTP deve essere aperta in modo che possa attivarsi il canale di comunicazione.
				</para>
				 </sidebar> <para>
					<command>pptpd</command> è il server PPTP per Linux. Il file di configurazione principale, <filename>/etc/pptpd.conf</filename>, richiede pochissime modifiche: <emphasis>localip</emphasis> (indirizzo IP locale) e <emphasis>remoteip</emphasis> (indirizzo IP remoto). Nell'esempio riportato di seguito, il server PPTP utilizza sempre l'indirizzo <literal>192.168.0.199</literal> e i client PPTP ricevono gli indirizzi IP da <literal>192.168.0.200</literal> a <literal>192.168.0.250</literal>.
				</para>
				 <example id="example.pptpd.conf">
					<title>Il file <filename>/etc/pptpd.conf</filename></title>
					 
<programlisting>
# TAG: speed
#
#       Specifies the speed for the PPP daemon to talk at.
#
speed 115200

# TAG: option
#
#       Specifies the location of the PPP options file.
#       By default PPP looks in '/etc/ppp/options'
#
option /etc/ppp/pptpd-options

# TAG: debug
#
#       Turns on (more) debugging to syslog
#
# debug

# TAG: localip
# TAG: remoteip
#
#       Specifies the local and remote IP address ranges.
#
#       You can specify single IP addresses separated by commas or you can
#       specify ranges, or both. For example:
#
#               192.168.0.234,192.168.0.245-249,192.168.0.254
#
#       IMPORTANT RESTRICTIONS:
#
#       1. No spaces are permitted between commas or within addresses.
#
#       2. If you give more IP addresses than MAX_CONNECTIONS, it will
#          start at the beginning of the list and go until it gets
#          MAX_CONNECTIONS IPs. Others will be ignored.
#
#       3. No shortcuts in ranges! ie. 234-8 does not mean 234 to 238,
#          you must type 234-238 if you mean this.
#
#       4. If you give a single localIP, that's ok - all local IPs will
#          be set to the given one. You MUST still give at least one remote
#          IP for each simultaneous client.
#
#localip 192.168.0.234-238,192.168.0.245
#remoteip 192.168.1.234-238,192.168.1.245
#localip 10.0.1.1
#remoteip 10.0.1.2-100
localip 192.168.0.199
remoteip 192.168.0.200-250</programlisting>

				</example>
				 <para>
					La configurazione PPP utilizzata da un server PPTP richiede anche alcuni cambiamenti in <filename>/etc/ppp/pptpd-options</filename>. I parametri importanti sono il nome del server (<literal>pptp</literal>), il nome di dominio (<literal>falcot.com</literal>) e gli indirizzi IP per i server DNS e WINS.
				</para>
				 <example id="example.ppp-pptpd-options">
					<title>Il file <filename>/etc/ppp/pptpd-options</filename></title>
					 
<programlisting>
## turn pppd syslog debugging on
#debug

## change 'servername' to whatever you specify as your server name in chap-secrets
name pptp
## change the domainname to your local domain
domain falcot.com

## these are reasonable defaults for WinXXXX clients
## for the security related settings
# The Debian pppd package now supports both MSCHAP and MPPE, so enable them
# here. Please note that the kernel support for MPPE must also be present!
auth
require-chap
require-mschap
require-mschap-v2
require-mppe-128

## Fill in your addresses
ms-dns 192.168.0.1
ms-wins 192.168.0.1

## Fill in your netmask
netmask 255.255.255.0

## some defaults
nodefaultroute
proxyarp
lock</programlisting>

				</example>
				 <para>
					L'ultimo passaggio prevede la registrazione dell'utente <literal>vpn</literal> (e la sua password associata) nel file <filename>/etc/ppp/chap-secrets</filename>. Contrariamente alle altre istanze dove un asterisco (<literal>*</literal>) potrebbe funzionare, il nome del server deve essere inserito qui in modo esplicito. Inoltre, i client Windows PPTP si identificano con la forma <literal><replaceable>DOMINIO</replaceable>\\<replaceable>UTENTE</replaceable></literal>, anziché fornire il solo nome utente. Questo spiega perché il file cita anche l'utente <literal>FALCOT\vpn</literal>. È anche possibile specificare i singoli indirizzi IP per gli utenti; un asterisco in questo campo specifica che devono essere utilizzati gli indirizzi dinamici.
				</para>
				 <example id="example.ppp-chap-secrets">
					<title>Il file <filename>/etc/ppp/chap-secrets</filename></title>
					 
<programlisting>
# Secrets for authentication using CHAP
# client        server  secret      IP addresses
vpn             pptp    f@Lc3au     *
FALCOT\\vpn     pptp    f@Lc3au     *</programlisting>

				</example>
				 <sidebar> <title><emphasis>SICUREZZA</emphasis> Vulnerabilità in PPTP</title>
				 <para>
					La prima implementazione PPTP di Microsoft ha attirato pesanti critiche perché aveva molte vulnerabilità di sicurezza; da allora, la maggior parte sono state risolte nelle versioni più recenti. La configurazione documentata in questa sezione utilizza l'ultima versione del protocollo. Bisogna essere consapevoli però che rimuovere alcune opzioni (ad esempio <literal>require-mppe-128</literal> e <literal>require-mschap-v2</literal>) renderebbe il servizio nuovamente vulnerabile.
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.quality-of-service">
		<title>Qualità del servizio (QoS)</title>
		 <section id="sect.qos-principe">
			<title>Principi e meccanismi</title>
			 <para>
				Con <emphasis>qualità del servizio</emphasis> (QoS: <emphasis>Quality of Service</emphasis>) ci si riferisce ad un insieme di tecniche che garantiscono o migliorano la qualità del servizio fornito alle applicazioni. La tecnica più diffusa consiste nel classificare il traffico di rete in categorie e differenziare la gestione del traffico in base alla categoria a cui appartiene. La principale applicazione di questa tecnica di differenziazione dei servizi è il <emphasis>traffic shaping</emphasis>, con il quale si limita la velocità di trasmissione dati in base a connessioni relative ad alcuni servizi e/o host per evitare di saturare la banda disponibile ed il collasso di altri servizi importanti. Il traffic shaping è particolarmente adatto al traffico TCP, poiché questo protocollo adatta automaticamente il traffico in base alla larghezza di banda disponibile.
			</para>
			 <indexterm>
				<primary>QoS</primary>
			</indexterm>
			 <indexterm>
				<primary>qualità del servizio</primary>
			</indexterm>
			 <indexterm>
				<primary>qualità</primary>
				<secondary>del servizio</secondary>
			</indexterm>
			 <indexterm>
				<primary>servizio</primary>
				<secondary>qualità</secondary>
			</indexterm>
			 <para>
				È anche possibile modificare la priorità del traffico, il che permette di dare priorità a pacchetti relativi a servizi interattivi (ad esempio <command>ssh</command> e <command>telnet</command>) o ai servizi che si occupano solo di piccoli blocchi di dati.
			</para>
			 <para>
				I kernel Debian includono le funzionalità richieste per QoS insieme ai relativi moduli. Questi moduli sono molti e ciascuno di essi fornisce un servizio diverso, in particolare mediante speciali funzionalità di pianificazione per le code dei pacchetti IP; il vasto insieme di funzionalità di pianificazione disponibile copre l'intera gamma delle possibili necessità.
			</para>
			 <sidebar> <title><emphasis>CULTURA</emphasis> LARTC — Instradamento avanzato e controllo del traffico di Linux (<emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis>)</title>
			 <para>
				L'HOWTO <emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis> è il documento di riferimento che copre tutto quello che c'è da sapere sulla qualità dei servizi di rete. <ulink type="block" url="http://www.lartc.org/howto/" />
			</para>
			 <indexterm>
				<primary>instradamento</primary>
				<secondary>avanzato</secondary>
			</indexterm>
			 <indexterm>
				<primary>traffico</primary>
				<secondary>controllo</secondary>
			</indexterm>
			 <indexterm>
				<primary>controllo del traffico</primary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.qos-config">
			<title>Configurazione ed implementazione</title>
			 <para>
				Attraverso il comando <command>tc</command> (fornito dal pacchetto <emphasis role="pkg">iproute</emphasis>) vengono impostati i parametri di QoS. Dal momento che la sua interfaccia è abbastanza complessa, è consigliabile utilizzare strumenti di livello superiore.
			</para>
			 <indexterm>
				<primary><emphasis>iproute</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><command>tc</command></primary>
			</indexterm>
			 <section id="sect.qos-wondershaper">
				<title>Ridurre le latenze: <command>wondershaper</command></title>
				 <para>
					Lo scopo principale di <command>wondershaper</command> (nel pacchetto omonimo) è quello di ridurre al minimo le latenze indipendentemente dal carico della rete. Questo risultato è ottenuto limitando il traffico totale a un valore che cade appena sotto il valore di saturazione del collegamento.
				</para>
				 <indexterm>
					<primary><command>wondershaper</command></primary>
				</indexterm>
				 <indexterm>
					<primary>limitazione del traffico</primary>
				</indexterm>
				 <indexterm>
					<primary>traffico</primary>
					<secondary>limitazione</secondary>
				</indexterm>
				 <para>
					Una volta configurata un'interfaccia di rete, l'impostazione della limitazione del traffico è ottenuta eseguendo <command>wondershaper <replaceable>interfaccia</replaceable> <replaceable>velocità_download</replaceable> <replaceable>velocità_upload</replaceable></command>. L'interfaccia può essere per esempio <literal>eth0</literal> o <literal>ppp0</literal>, entrambe le velocità sono espresse in kilobit al secondo. Il comando <command>wondershaper remove <replaceable>interfaccia</replaceable></command> disabilita il controllo del traffico sull'interfaccia specificata.
				</para>
				 <para>
					Per una connessione Ethernet, questo script produce un risultato migliore se chiamato subito dopo che l'interfaccia è stata configurata. È possibile ottenere questo risultato aggiungendo le direttive <literal>up</literal> e <literal>down</literal> al file <filename>/etc/network/interfaces</filename> che permettono di dichiarare i comandi da eseguire, rispettivamente dopo aver configurato l'interfaccia e prima che sia disattivata. Ad esempio:
				</para>
				 <example id="example.network-interfaces">
					<title>Modifiche nel file <filename>/etc/network/interfaces</filename></title>
					 
<programlisting>
iface eth0 inet dhcp
    up /sbin/wondershaper eth0 500 100
    down /sbin/wondershaper remove eth0</programlisting>

				</example>
				 <para>
					Nel caso di PPP, la creazione di uno script che richiama <command>wondershaper</command> nella directory <filename>/etc/ppp/ip-up.d/</filename> permetterà il controllo del traffico non appena la connessione è attiva.
				</para>
				 <sidebar> <title><emphasis>APPROFONDIMENTI</emphasis> Configurazione ottimale</title>
				 <para>
					Il file <filename>/usr/share/doc/wondershaper/README.Debian.gz</filename> descrive più in dettaglio il metodo di configurazione consigliato dal responsabile del pacchetto. In particolare, si consiglia di misurare la velocità di caricamento e scaricamento in modo da valutare al meglio i limiti reali.
				</para>
				 </sidebar>
			</section>
			 <section id="sect.qos-config-standard">
				<title>Configurazione standard</title>
				 <para>
					Salvo una specifica configurazione di QoS, il kernel Linux usa il pianificatore di coda <literal>pfifo_fast</literal>, che fornisce alcune interessanti caratteristiche di per sé. La priorità di ogni pacchetto IP processato è basata sul campo ToS (tipo di servizio: <emphasis>Type of Service</emphasis>) del pacchetto stesso; è sufficiente modificare questo campo per sfruttare le funzionalità di pianificazione. Ci sono cinque possibili valori:
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							Normal-Service (0); (servizio normale)
						</para>

					</listitem>
					 <listitem>
						<para>
							Minimize-Cost (2); (minimizza costo)
						</para>

					</listitem>
					 <listitem>
						<para>
							Maximize-Reliability (4); (massimizza affidabilità)
						</para>

					</listitem>
					 <listitem>
						<para>
							Maximize-Throughput (8); (massimizza rendimento)
						</para>

					</listitem>
					 <listitem>
						<para>
							Minimize-Delay (minimizza ritardo) (16).
						</para>

					</listitem>

				</itemizedlist>
				 <indexterm>
					<primary>ToS</primary>
				</indexterm>
				 <indexterm>
					<primary>Type of Service</primary>
				</indexterm>
				 <para>
					Il campo ToS può essere impostato da applicazioni che generano i pacchetti IP, o modificato al volo da <emphasis>netfilter</emphasis>. Le seguenti regole sono sufficienti per aumentare la reattività per il servizio SSH di un server:
				</para>
				 
<programlisting role="scale">
iptables -t mangle -A PREROUTING -p tcp --sport ssh -j TOS --set-tos Minimize-Delay
iptables -t mangle -A PREROUTING -p tcp --dport ssh -j TOS --set-tos Minimize-Delay</programlisting>

			</section>

		</section>

	</section>
	 <section id="sect.dynamic-routing">
		<title>Instradamento dinamico</title>
		 <indexterm>
			<primary>instradamento</primary>
			<secondary>dinamico</secondary>
		</indexterm>
		 <indexterm>
			<primary><command>quagga</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>zebra</command></primary>
		</indexterm>
		 <para>
			Lo strumento di riferimento per l'instradamento dinamico è attualmente <command>quagga</command> (dal pacchetto omonimo in Debian); sostituisce il precedente <command>zebra</command>, il cui sviluppo è stato interrotto. Tuttavia, per ragioni di compatibilità, il progetto <command>quagga</command> ha mantenuto i nomi dei programmi eseguibili, questo spiega perché più sotto vengano usati comandi <command>zebra</command>.
		</para>
		 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> Instradamento dinamico</title>
		 <para>
			L'instradamento dinamico consente ai router di regolare, in tempo reale, i percorsi utilizzati per la trasmissione di pacchetti IP. Ogni protocollo ha i propri metodi per definire i percorsi (calcolare il percorso più breve, utilizzare percorsi annunciati da peer e così via).
		</para>
		 <para>
			Nel kernel di Linux, un instradamento (route) collega un dispositivo di rete ad un insieme di macchine che possono essere raggiunte attraverso questo dispositivo. Il comando <command>route</command> definisce nuovi instradamenti e visualizza quelli esistenti.
		</para>
		 <indexterm>
			<primary><command>route</command></primary>
		</indexterm>
		 </sidebar> <para>
			Quagga è un insieme di demoni che collaborano per definire le tabelle di instradamento che il kernel Linux deve utilizzare; ogni protocollo di routing (in particolare BGP, OSPF e RIP) fornisce il proprio demone. Il demone <command>zebra</command> raccoglie le informazioni provenienti da altri demoni e gestisce le tabelle di routing statico di conseguenza. Gli altri demoni sono conosciuti come <command>bgpd</command>, <command>ospfd</command>, <command>ospf6d</command>, <command>ripd</command>, <command>ripngd</command>, <command>isisd</command>, e <command>babeld</command>.
		</para>
		 <indexterm>
			<primary>OSPF</primary>
		</indexterm>
		 <indexterm>
			<primary>BGP</primary>
		</indexterm>
		 <indexterm>
			<primary>RIP</primary>
		</indexterm>
		 <indexterm>
			<primary>IS-IS</primary>
		</indexterm>
		 <indexterm>
			<primary>BABEL maglia di routing wireless</primary>
		</indexterm>
		 <indexterm>
			<primary><command>bgpd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ospfd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ospf6d</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ripd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ripngd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>isisd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>babeld</command></primary>
		</indexterm>
		 <para>
			I demoni vengono attivati modificando il file <filename>/etc/quagga/daemons</filename> e creando il file di configurazione appropriato in <filename>/etc/quagga/</filename>; questo file di configurazione deve essere richiamato dopo il demone, seguito da un'estensione <filename>.conf</filename>, e deve appartenere all'utente <literal>quagga</literal> e al gruppo <literal>quaggavty</literal>, in modo che lo script <filename>/etc/init.d/quagga</filename> possa richiamare il demone.
		</para>
		 <para>
			La configurazione di ciascuno di questi demoni richiede la conoscenza del protocollo di instradamento in questione. Questi protocolli non possono essere descritti in dettaglio qui, ma il pacchetto <emphasis role="pkg">quagga-doc</emphasis> fornisce una spiegazione ampia sotto forma di file <command>info</command>. Gli stessi contenuti possono essere consultati più facilmente in HTML sul sito di Quagga: <ulink type="block" url="http://www.nongnu.org/quagga/docs/docs-info.html" />
		</para>
		 <para>
			Inoltre, la sintassi è molto vicino all'interfaccia di configurazione di un router standard e gli amministratori di rete si adatteranno rapidamente a <command>quagga</command>.
		</para>
		 <sidebar> <title><emphasis>IN PRATICA</emphasis> OSPF, BGP o RIP?</title>
		 <para>
			OSPF è in genere il miglior protocollo da utilizzare per l'instradamento dinamico su reti private, BGP invece è più comune per l'instradamento su Internet. RIP è obsoleto e non si usa quasi più.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.ipv6">
		<title>IPv6</title>
		 <para>
			IPv6, successore di IPv4, è una nuova versione del protocollo IP progettata per correggere i suoi difetti, in particolare la scarsità di indirizzi IP disponibili. Questo protocollo gestisce il livello di rete, il suo scopo è di fornire indirizzi alle macchine, di trasmettere dati verso la destinazione finale e di gestire la frammentazione dei dati se necessario (in altre parole, di dividere i pacchetti in blocchi con una dimensione che dipende dai collegamenti di rete da utilizzare sul percorso e di ricomporre i pezzi nel loro giusto ordine all'arrivo).
		</para>
		 <para>
			I kernel Debian includono la gestione IPv6 nel nucleo centrale del kernel (con l'eccezione di alcune architetture compilate con un modulo chiamato <literal>ipv6</literal>). Strumenti di base come <command>ping</command> e <command>traceroute</command> hanno i loro equivalenti IPv6 in <command>ping6</command> e <command>traceroute6</command>, disponibili rispettivamente nei pacchetti <emphasis role="pkg">iputils-ping</emphasis> e <emphasis role="pkg">iputils-tracepath</emphasis>.
		</para>
		 <indexterm>
			<primary>IPv6</primary>
		</indexterm>
		 <indexterm>
			<primary><emphasis role="pkg">iputils-ping</emphasis></primary>
		</indexterm>
		 <indexterm>
			<primary><emphasis role="pkg">iputils-tracepath</emphasis></primary>
		</indexterm>
		 <para>
			La rete IPv6 è configurata in modo simile a IPv4, in <filename>/etc/network/interfaces</filename>. Se si vuole rendere questa rete accessibile a livello globale, è necessario assicurarsi di avere un router che supporti il traffico dati IPv6 verso la rete globale IPv6.
		</para>
		 <example id="example.network-interfaces-ipv6">
			<title>Esempio di configurazione IPv6</title>
			 
<programlisting>
iface eth0 inet6 static
    address 2001:db8:1234:5::1:1
    netmask 64
    # Disabling auto-configuration
    # autoconf 0
    # The router is auto-configured and has no fixed address
    # (accept_ra 1). If it had:
    # gateway 2001:db8:1234:5::1</programlisting>

		</example>
		 <para>
			Le sottoreti IPv6 di solito hanno una maschera a 64 bit. Questo significa che esistono 2<superscript>64</superscript> indirizzi distinti all'interno della sottorete. Questo permette a Stateless Address Autoconfiguration (<acronym>SLAAC</acronym>) di scegliere un indirizzo in base all'indirizzo MAC dell'interfaccia di rete. Per impostazione predefinita, se <acronym>SLAAC</acronym> è attivato nella rete e IPv6 sul computer, il kernel troverà automaticamente i router IPv6 e configurerà le interfacce di rete.
		</para>
		 <para>
			Questo comportamento può avere implicazioni per la privacy. Se si passa di frequente tra le reti, per esempio con un computer portatile, si potrebbe desiderare che il proprio indirizzo <acronym>MAC</acronym> non sia parte del proprio indirizzo IPv6 pubblico. Questo rende più facile identificare lo stesso dispositivo attraverso le reti. Una soluzione a questo problema sono le estensioni della privacy di IPv6 (che Debian abilita di default se non viene rilevata la connettività IPv6 durante l'installazione iniziale), che assegneranno un ulteriore indirizzo generato in modo casuale all'interfaccia, cambiato periodicamente e questo verrà preferito per le connessioni in uscita. Connessioni in entrata possono ancora utilizzare l'indirizzo generato da SLAAC. L'esempio che segue, per l'uso in <filename>/etc/network/interfaces</filename>, attiva queste estensioni della privacy.
		</para>
		 <example id="example.network-interface-ipv6-privext">
			<title>estensioni della privacy di IPv6</title>
			 
<programlisting>
iface eth0 inet6 auto
    # Prefer the randomly assigned addresses for outgoing connections.
    privext 2</programlisting>

		</example>
		 <sidebar> <title><emphasis>SUGGERIMENTO</emphasis> Programmi compilati con IPv6</title>
		 <para>
			Molte parti del software devono essere adattate per gestire IPv6. La maggior parte dei pacchetti in Debian sono già stati adattati, ma non tutti. Se il vostro pacchetto preferito non funziona con IPv6, puoi chiedere aiuto alla mailing-list <emphasis>debian-ipv6</emphasis>. Potrebbero sapere di un sostituto che riconosca IPv6 e potrebbero aprire un bug per ottenere un monitoraggio adeguato sulla questione. <ulink type="block" url="http://lists.debian.org/debian-ipv6/" />
		</para>
		 </sidebar> <indexterm>
			<primary>IPv6, firewall</primary>
		</indexterm>
		 <indexterm>
			<primary>firewall</primary>
			<secondary>IPv6</secondary>
		</indexterm>
		 <indexterm>
			<primary><command>ip6tables</command></primary>
		</indexterm>
		 <para>
			Le connessioni IPv6 possono essere limitate, allo stesso modo di IPv4: i kernel standard di Debian contengono un adattamento di <emphasis>netfilter</emphasis> per IPv6. Questo <emphasis>netfilter</emphasis> abilitato a IPv6 è configurato in modo simile alla sua controparte IPv4, salvo che per il programma da utilizzare che è <command>ip6tables</command> invece di <command>iptables</command>.
		</para>
		 <section id="sect.ipv6-tunneling">
			<title>Tunneling</title>
			 <sidebar> <title><emphasis>ATTENZIONE</emphasis>Tunneling IPv6 e firewall</title>
			 <para>
				Il tunneling IPv6 su IPv4 (al contrario dell'IPv6 nativo) richiede il firewall per accettare il traffico, che utilizza numero di protocollo IPv4 41.
			</para>
			 </sidebar> <para>
				Se non è disponibile una connessione IPv6 nativa, il metodo alternativo è quello di utilizzare un tunnel su IPv4. Gogo6 è un fornitore (gratuito) di questi tunnel: <ulink type="block" url="http://www.gogo6.com/freenet6/tunnelbroker" />
			</para>
			 <indexterm>
				<primary>Freenet6</primary>
			</indexterm>
			 <indexterm>
				<primary>Gogo6</primary>
			</indexterm>
			 <para>
				Per utilizzare un tunnel Freenet6, è necessario registrare un account Freenet6 Pro sul sito, quindi installare il pacchetto <emphasis role="pkg">gogoc</emphasis> e configurare il tunnel. Ciò richiede la modifica del file <filename>/etc/gogoc/gogoc.conf</filename>: devono essere aggiunte le righe <literal>userid</literal> e <literal>password</literal> ricevute via e-mail, e la riga <literal>server</literal> dovrebbe essere sostituita con <literal>authenticated.freenet6.net</literal>.
			</para>
			 <para>
				La connettività IPv6 viene proposta a tutte le macchine di una rete locale aggiungendo le tre direttive seguenti al file <filename>/etc/gogoc/gogoc.conf</filename> (supponendo che la rete locale sia collegata all'interfaccia eth0):
			</para>
			 
<programlisting>
host_type=router
prefixlen=56
if_prefix=eth0</programlisting>
			 <para>
				La macchina diventa allora il router di accesso della sottorete con un prefisso di 56 bit. Una volta che il tunnel è a conoscenza di questo cambiamento, la rete locale deve esserne messa al corrente; il che implica l'installazione del demone <command>radvd</command> (dal pacchetto dal nome simile). Questo demone di configurazione per IPv6 ha un ruolo simile a <command>dhcpd</command> nel mondo IPv4.
			</para>
			 <para>
				Il file di configurazione <filename>/etc/radvd.conf</filename> deve essere creato (vedere <filename>/usr/share/doc/radvd/examples/simple-radvd.conf</filename> come punto di partenza). Nel nostro caso, l'unico cambiamento richiesto è il prefisso, che deve essere sostituito con quello fornito da Freenet6 e può essere trovato in output al comando <command>ifconfig</command>, nel blocco relativo all'interfaccia <literal>tun</literal>.
			</para>
			 <indexterm>
				<primary><command>radvd</command></primary>
			</indexterm>
			 <para>
				Quindi eseguire i comandi <command>service gogoc restart</command> e <command>service radvd start</command>, e la rete IPv6 dovrebbe funzionare correttamente.
			</para>

		</section>

	</section>
	 <section id="sect.domain-name-servers">
		<title>Server dei nomi di dominio (DNS)</title>
		 <section id="sect.dns-principe">
			<title>Principi e meccanismi</title>
			 <indexterm>
				<primary>DNS</primary>
			</indexterm>
			 <indexterm>
				<primary>server</primary>
				<secondary>nomi</secondary>
			</indexterm>
			 <para>
				Il server di nomi di dominio (DNS: <emphasis>Domain Name Service</emphasis>) è un componente fondamentale di Internet: infatti associa i nomi host agli indirizzi IP (e viceversa), il che consente l'uso di <literal>www.debian.org</literal> invece di <literal>5.153.231.4</literal> o <literal>2001:41c8:1000:21::21:4</literal>.
			</para>
			 <para>
				I record DNS sono organizzati in zone, ad ogni zona corrisponde un dominio (o sottodominio) o un intervallo di indirizzi IP (dal momento che gli indirizzi IP vengono generalmente assegnati in campi consecutivi). Un server primario è autorevole sul contenuto di una zona; server secondari, di solito ospitati su macchine separate, servono a fornire copie regolarmente aggiornate della zona primaria.
			</para>
			 <indexterm>
				<primary>zona</primary>
				<secondary>DNS</secondary>
			</indexterm>
			 <indexterm>
				<primary>DNS</primary>
				<secondary>zona</secondary>
			</indexterm>
			 <para>
				Ogni zona può contenere diversi tipi di record (record di risorse: <emphasis>Resource Records</emphasis>):
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>A</literal>: indirizzo IPv4. <indexterm><primary>A, record DNS</primary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>CNAME </literal>: alias (<emphasis> nome canonico </emphasis>). <indexterm><primary>CNAME, record DNS</primary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>MX</literal>: <emphasis>mail exchange</emphasis>, un server di posta elettronica. Queste informazioni vengono usate da altri server di posta elettronica per trovare dove inviare e-mail indirizzate ad un determinato indirizzo. Ogni record MX ha una priorità. Viene prima utilizzato il server con la priorità più alta (con il numero più basso, vedere riquadro <xref linkend="sidebar.smtp" /> ); in caso il primo server non risponda, vengono interrogati i successivi in ordine decrescente di priorità. <indexterm><primary>MX</primary><secondary>Record DNS</secondary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>PTR</literal>: risoluzione di un indirizzo IP ad un nome. Tale record viene memorizzato in una zona dedicata alla ricerca inversa «reverse DNS» che prende il nome secondo l'intervallo di indirizzi IP. Per esempio, <literal>1.168.192.in-addr.arpa</literal> è la zona contenente la risoluzione inversa per tutti gli indirizzi nell'intervallo <literal>192.168.1.0/24</literal>. <indexterm><primary>PTR, record DNS</primary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>AAAA</literal>: indirizzo IPv6. <indexterm><primary>AAAA, record DNS</primary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>NS</literal>: associa un nome ad un server di nomi. Ogni dominio deve avere almeno un record NS. Questi record puntano ad un server DNS in grado di rispondere ad interrogazioni relative a questo dominio; di solito puntano ai server primario e secondario per il dominio. Questi record permettono anche la delega DNS. Per esempio, la zona <literal>falcot.com</literal> può comprendere un record NS per <literal>internal.falcot.com</literal>, il che significa che un altro server gestisce la zona <literal>internal.falcot.com</literal>. Naturalmente, questo server deve dichiarare una zona <literal>internal.falcot.com</literal>. <indexterm><primary>NS, record DNS</primary></indexterm>
					</para>

				</listitem>

			</itemizedlist>
			 <indexterm>
				<primary>record</primary>
				<secondary>DNS</secondary>
			</indexterm>
			 <indexterm>
				<primary>record DNS</primary>
			</indexterm>
			 <para>
				Il server di nomi di riferimento, Bind, è stato sviluppato ed è mantenuto dall'ISC (<emphasis>Internet Software Consortium</emphasis>). Viene fornito in Debian dal pacchetto <emphasis role="pkg">bind9</emphasis>. La versione 9 apporta due importanti modifiche rispetto alle versioni precedenti. In primo luogo, il server DNS ora può essere eseguito come utente non privilegiato, in modo che una vulnerabilità di sicurezza nel server non conceda privilegi di root all'autore di un attacco (come si è visto più volte con le versioni 8.x).
			</para>
			 <para>
				Inoltre, Bind supporta lo standard DNSSEC per la firma (e quindi per l'autenticazione) dei record DNS, il che consente di bloccare qualsiasi tentativo di spoofing di questi dati durante attacchi di tipo man-in-the-middle.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">bind9</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>ISC</primary>
			</indexterm>
			 <indexterm>
				<primary>Internet Software Consortium</primary>
			</indexterm>
			 <sidebar> <title><emphasis>CULTURA</emphasis> DNSSEC</title>
			 <indexterm>
				<primary>DNSSEC</primary>
			</indexterm>
			 <para>
				Lo standard DNSSEC è abbastanza complesso; questo spiega in parte perché il suo uso non è ancora diffuso (anche se coesiste perfettamente con i server DNS ignari del DNSSEC). Per capire tutti i pro ed i contro, è consigliato consultare il seguente articolo. <ulink type="block" url="http://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions" />
			</para>
			 </sidebar>
		</section>
		 <section id="sect.dns-config">
			<title>Configurazione</title>
			 <para>
				Qualunque sia la versione di <command>bind</command> usata, i file di configurazione hanno la stessa struttura.
			</para>
			 <para>
				Gli amministratori Falcot hanno creato una zona primaria <literal>falcot.com</literal> per memorizzare le informazioni relative a questo dominio, ed una zona <literal>168.192.in-addr.arpa</literal> per la risoluzione inversa degli indirizzi IP nelle reti locali.
			</para>
			 <sidebar> <title><emphasis>ATTENZIONE</emphasis> Nomi delle zone inverse</title>
			 <indexterm>
				<primary>zona</primary>
				<secondary>inversa</secondary>
			</indexterm>
			 <indexterm>
				<primary>inversa zona</primary>
			</indexterm>
			 <indexterm>
				<primary><literal>in-addr.arpa</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>ip6.arpa</literal></primary>
			</indexterm>
			 <indexterm>
				<primary>formato nibble</primary>
			</indexterm>
			 <para>
				Le zone inverse hanno un nome particolare. La zona che copre la rete <literal>192.168.0.0/16</literal> deve essere chiamata <literal>168.192.in-addr.arpa</literal>: i componenti degli indirizzi IP sono invertiti, e seguiti dal suffisso <literal>in-addr.arpa</literal>.
			</para>
			 <para>
				Per le reti IPv6, il suffisso è <literal>ip6.arpa</literal> e gli elementi di indirizzo IP che vengono invertiti sono ogni carattere nella rappresentazione esadecimale completa dell'indirizzo IP. Come tale, la rete <literal>2001:0bc8:31a0::/48</literal> dovrebbe utilizzare una zona denominata <literal>0.a.1.3.8.c.b.0.1.0.0.2.ip6.arpa</literal>.
			</para>
			 </sidebar> <sidebar> <title><emphasis>SUGGERIMENTO</emphasis> Verifica del server DNS</title>
			 <para>
				Il comando <command>host</command> (nel pacchetto <emphasis role="pkg">bind9-host</emphasis>) interroga un server DNS, e può essere usato per testare la configurazione del server. Per esempio, <command>host macchina.falcot.com localhost</command> controlla la risposta del server locale per <literal>macchina.falcot.com</literal>. <command>host <replaceable>indirizzo ip</replaceable> localhost</command> verifica la risoluzione inversa.
			</para>
			 <indexterm>
				<primary><command>host</command></primary>
			</indexterm>
			 </sidebar> <para>
				Gli estratti di configurazione seguenti, tratti dai file della società Falcot, possono servire come punti di partenza per configurare un server DNS:
			</para>
			 <indexterm>
				<primary><filename>named.conf</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/bind/named.conf</filename></primary>
			</indexterm>
			 <example id="example.bind-named.conf.local">
				<title>Estratto da <filename>/etc/bind/named.conf.local</filename></title>
				 
<programlisting>
zone "falcot.com" {
        type master;
        file "/etc/bind/db.falcot.com";
        allow-query { any; };
        allow-transfer {
                195.20.105.149/32 ; // ns0.xname.org
                193.23.158.13/32 ; // ns1.xname.org
        };
};

zone "internal.falcot.com" {
        type master;
        file "/etc/bind/db.internal.falcot.com";
        allow-query { 192.168.0.0/16; };
};

zone "168.192.in-addr.arpa" {
        type master;
        file "/etc/bind/db.192.168";
        allow-query { 192.168.0.0/16; };
};</programlisting>

			</example>
			 <example id="example.bind-db.falcot.com">
				<title>Estratto da <filename>/etc/bind/db.falcot.com</filename></title>
				 
<programlisting>; falcot.com Zone 
; admin.falcot.com. =&gt; zone contact: admin@falcot.com
$TTL    604800
@       IN      SOA     falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
;
; The @ refers to the zone name ("falcot.com" here)
; or to $ORIGIN if that directive has been used
;
@       IN      NS      ns
@       IN      NS      ns0.xname.org.

internal IN      NS      192.168.0.2

@       IN      A       212.94.201.10
@       IN      MX      5 mail
@       IN      MX      10 mail2

ns      IN      A       212.94.201.10
mail    IN      A       212.94.201.10
mail2   IN      A       212.94.201.11
www     IN      A       212.94.201.11

dns     IN      CNAME   ns</programlisting>

			</example>
			 <sidebar> <title><emphasis>ATTENZIONE</emphasis> Sintassi di un nome</title>
			 <para>
				La sintassi dei nomi delle macchine segue regole severe. Ad esempio, <literal>macchina</literal> sottintende <literal>macchina.<replaceable>dominio</replaceable></literal>. Se il nome di dominio non deve essere aggiunto ad un nome, tale nome deve essere scritto come <literal>macchina.</literal> (con un punto come suffisso). Per indicare un nome DNS al di fuori del dominio corrente è necessaria una sintassi del tipo <literal>macchina.altrodominio.com.</literal> (con il punto finale).
			</para>
			 </sidebar> <example id="example.bind-db.192.168">
				<title>Estratto da <filename>/etc/bind/db.192.168</filename></title>
				 
<programlisting>; Reverse zone for 192.168.0.0/16
; admin.falcot.com. =&gt; zone contact: admin@falcot.com
$TTL    604800
@       IN      SOA     ns.internal.falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL

        IN      NS      ns.internal.falcot.com.

; 192.168.0.1 -&gt; arrakis
1.0     IN      PTR     arrakis.internal.falcot.com.
; 192.168.0.2 -&gt; neptune
2.0     IN      PTR     neptune.internal.falcot.com.

; 192.168.3.1 -&gt; pau
1.3     IN      PTR     pau.internal.falcot.com.</programlisting>

			</example>

		</section>

	</section>
	 <section id="sect.dhcp">
		<title>DHCP</title>
		 <para>
			DHCP (protocollo di configurazione dinamica degli host: <emphasis>Dynamic Host Configuration Protocol</emphasis>) è un protocollo con il quale una macchina può ottenere la configurazione di rete automaticamente al suo avvio. Questo permette di centralizzare la gestione delle configurazioni di rete, e garantire che tutte le macchine desktop abbiano impostazioni simili.
		</para>
		 <indexterm>
			<primary>DHCP</primary>
		</indexterm>
		 <indexterm>
			<primary>Dynamic Host Configuration Protocol</primary>
		</indexterm>
		 <indexterm>
			<primary>rete</primary>
			<secondary>configurazione DHCP</secondary>
		</indexterm>
		 <para>
			Un server DHCP fornisce molti parametri relativi alla rete. Il più comune di questi è un indirizzo IP e la rete a cui la macchina appartiene, ma può anche fornire altre informazioni, come: server DNS, server WINS, server NTP e così via.
		</para>
		 <para>
			L'autore principale del server DHCP è l'Internet Software Consortium (coinvolto anche nello sviluppo di <command>bind</command>). Il pacchetto Debian corrispondente è <emphasis role="pkg">isc-dhcp-server</emphasis>.
		</para>
		 <section id="sect.dhcp-config">
			<title>Configurazione</title>
			 <para>
				I primi elementi che devono essere modificati nel file di configurazione del server DHCP (<filename>/etc/dhcp/dhcpd.conf</filename>) sono il nome di dominio e i server DNS. Se è l'unico server DHCP nella rete locale (come definito dalla propagazione broadcast), deve essere abilitata (o decommentata) la direttiva <literal>authoritative</literal>. Inoltre, è necessario creare anche una sezione <literal>subnet</literal> che descriva la rete locale e le informazioni di configurazione che devono essere fornite. L'esempio seguente è adatto ad una rete locale <literal>192.168.0.0/24</literal> con un router <literal>192.168.0.1</literal> che funge da gateway. Gli indirizzi IP disponibili sono compresi nell'intervallo da <literal>192.168.0.128</literal> a <literal>192.168.0.254</literal>.
			</para>
			 <example id="example.dhcp-dhcpd.conf">
				<title>Estratto da <filename>/etc/dhcp/dhcpd.conf</filename></title>
				 
<programlisting>
#
# Sample configuration file for ISC dhcpd for Debian
#

# The ddns-updates-style parameter controls whether or not the server will
# attempt to do a DNS update when a lease is confirmed. We default to the
# behavior of the version 2 packages ('none', since DHCP v2 didn't
# have support for DDNS.)
ddns-update-style interim;

# option definitions common to all supported networks...
option domain-name "internal.falcot.com";
option domain-name-servers ns.internal.falcot.com;

default-lease-time 600;
max-lease-time 7200;

# If this DHCP server is the official DHCP server for the local
# network, the authoritative directive should be uncommented.
authoritative;

# Use this to send dhcp log messages to a different log file (you also
# have to hack syslog.conf to complete the redirection).
log-facility local7;

# My subnet
subnet 192.168.0.0 netmask 255.255.255.0 {
    option routers 192.168.0.1;
    option broadcast-address 192.168.0.255;
    range 192.168.0.128 192.168.0.254;
    ddns-domainname "internal.falcot.com";
}</programlisting>

			</example>

		</section>
		 <section id="sect.dhcp-dns">
			<title>DHCP e DNS</title>
			 <indexterm>
				<primary>DNS</primary>
				<secondary>aggiornamenti automatici</secondary>
			</indexterm>
			 <para>
				Una caratteristica interessante è la registrazione automatica dei client DHCP nella zona DNS, in modo che ogni macchina abbia un nome significativo (piuttosto che qualcosa di impersonale, come <literal>machine-192-168-0-131.internal.falcot.com</literal>). Per utilizzare questa caratteristica è necessario configurare il server DNS in modo che accetti gli aggiornamenti nella zona DNS <literal>internal.falcot.com</literal> da parte del server DHCP, e la configurazione di quest'ultimo ad inviare gli aggiornamenti ad ogni registrazione.
			</para>
			 <para>
				Nel caso di <command>bind</command>, la direttiva <literal>allow-update</literal> deve essere aggiunta in ciascuna delle zone che il server DHCP deve modificare (quella per il dominio <literal>internal.falcot.com</literal> e la sua zona inversa). Questa direttiva elenca gli indirizzi IP autorizzati ad effettuare questi aggiornamenti. Pertanto dovrebbe contenere i possibili indirizzi del server DHCP (l'indirizzo locale e l'indirizzo pubblico, se opportuno).
			</para>
			 
<programlisting>
allow-update { 127.0.0.1 192.168.0.1 212.94.201.10 !any };</programlisting>
			 <para>
				Attenzione! Una zona che può essere modificata <emphasis>verrà</emphasis> modificata tramite <command>bind</command>, quest'ultimo sovrascriverà i file di configurazione a intervalli regolari. Poiché questa procedura automatizzata produce file che sono meno leggibili rispetto a quelli scritti manualmente, gli amministratori Falcot gestiscono il dominio <literal>internal.falcot.com</literal> con un server DNS delegato; questo significa che il file di zona <literal>falcot.com</literal> resta saldamente sotto il loro controllo manuale.
			</para>
			 <para>
				L'esempio di configurazione del server DHCP precedente include già le direttive necessarie per gli aggiornamenti della zona DNS: sono le righe <literal>ddns-update-style interim;</literal> e <literal>ddns-domain-name "internal.falcot.com";</literal> nel blocco che descrive la sottorete.
			</para>

		</section>

	</section>
	 <section id="sect.network-diagnosis-tools">
		<title>Strumenti di diagnosi di rete</title>
		 <para>
			Quando un'applicazione di rete non viene eseguita come previsto, è importante poter vedere «sotto il cofano». Anche quando tutto sembra funzionare senza problemi, l'esecuzione di una diagnosi di rete può contribuire a garantire che tutto funzioni come dovrebbe. Esistono diversi strumenti di diagnosi per tale scopo; ognuno opera su un livello diverso.
		</para>
		 <section id="sect.netstat">
			<title>Diagnosi locale: <command>netstat</command></title>
			 <indexterm>
				<primary><command>netstat</command></primary>
			</indexterm>
			 <para>
				Menzioniamo per primo il comando <command>netstat</command> (nel pacchetto <emphasis role="pkg">net-tools</emphasis>), che mostra una sintesi immediata delle attività di rete di una macchina. Quando viene invocato senza alcun argomento, questo comando elenca tutte le connessioni aperte. L'elenco può essere molto dettagliato poiché comprende numerosi socket di dominio Unix (ampiamente utilizzati dai demoni), che non coinvolgono affatto la rete (per esempio, la comunicazione <literal>dbus</literal>, il traffico <literal>X11</literal> e le comunicazioni tra i filesystem virtuali e desktop).
			</para>
			 <para>
				Pertanto, invocazioni comuni utilizzano opzioni che alterano il comportamento di <command>netstat</command>. Le opzioni utilizzate più frequentemente sono:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>-t</literal>, che filtra i risultati per includere solo le connessioni TCP;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-u</literal>, che funziona in modo analogo per le connessioni UDP; queste opzioni non si escludono a vicenda, e una di loro è sufficiente per non visualizzare le connessioni di dominio Unix;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-a</literal>, per elencare anche i socket in ascolto (in attesa di connessioni in ingresso);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-n</literal>, per visualizzare i risultati in forma numerica: gli indirizzi IP (senza risoluzione DNS), i numeri di porta (senza alias come definiti in <filename>/etc/services</filename>) e gli ID utente (senza nomi di login);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-p</literal>, per elencare i processi coinvolti; questa opzione è utile solo quando <command>netstat</command> viene eseguito come root, poiché gli utenti normali vedranno solo i propri processi;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-c</literal>, per aggiornare continuamente la lista delle connessioni.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Altre opzioni, documentate nella pagina di manuale <citerefentry><refentrytitle>netstat</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry>, forniscono un controllo più preciso sui risultati visualizzati. Nella pratica, le prime cinque opzioni sono utilizzate così spesso insieme che il comando <command>netstat -tupan</command> è diventato quasi un riflesso tra gli amministratori di sistema e di rete. Il risultato tipico, su una macchina con poco carico, può apparire come il seguente:
			</para>
			 
<screen role="scale">
<computeroutput># </computeroutput><userinput>netstat -tupan</userinput>
<computeroutput>Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      397/rpcbind     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      431/sshd        
tcp        0      0 0.0.0.0:36568           0.0.0.0:*               LISTEN      407/rpc.statd   
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      762/exim4       
tcp        0    272 192.168.1.242:22        192.168.1.129:44452     ESTABLISHED 1172/sshd: roland [
tcp6       0      0 :::111                  :::*                    LISTEN      397/rpcbind     
tcp6       0      0 :::22                   :::*                    LISTEN      431/sshd        
tcp6       0      0 ::1:25                  :::*                    LISTEN      762/exim4       
tcp6       0      0 :::35210                :::*                    LISTEN      407/rpc.statd   
udp        0      0 0.0.0.0:39376           0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:996             0.0.0.0:*                           397/rpcbind     
udp        0      0 127.0.0.1:1007          0.0.0.0:*                           407/rpc.statd   
udp        0      0 0.0.0.0:68              0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:48720           0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:111             0.0.0.0:*                           397/rpcbind     
udp        0      0 192.168.1.242:123       0.0.0.0:*                           539/ntpd        
udp        0      0 127.0.0.1:123           0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:123             0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:5353            0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:39172           0.0.0.0:*                           407/rpc.statd   
udp6       0      0 :::996                  :::*                                397/rpcbind     
udp6       0      0 :::34277                :::*                                407/rpc.statd   
udp6       0      0 :::54852                :::*                                916/dhclient    
udp6       0      0 :::111                  :::*                                397/rpcbind     
udp6       0      0 :::38007                :::*                                451/avahi-daemon: r
udp6       0      0 fe80::5054:ff:fe99::123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:a:123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:5:123 :::*                                539/ntpd        
udp6       0      0 ::1:123                 :::*                                539/ntpd        
udp6       0      0 :::123                  :::*                                539/ntpd        
udp6       0      0 :::5353                 :::*                                451/avahi-daemon: r
</computeroutput></screen>
			 <para>
				Come previsto, vengono elencate le connessioni stabilite, due connessioni SSH in questo caso, e le applicazioni in attesa di connessioni in ingresso (indicate come <literal>LISTEN</literal>), in particolare il server di posta elettronica Exim4 in ascolto sulla porta 25.
			</para>

		</section>
		 <section id="sect.nmap">
			<title>Diagnosi da remoto: <command>nmap</command></title>
			 <indexterm>
				<primary><command>nmap</command></primary>
			</indexterm>
			 <para>
				<command>nmap</command> (nel pacchetto dal nome analogo) è in un certo senso l'equivalente remoto di <command>netstat</command>. Può eseguire la scansione di una serie di porte «note» per uno o più server remoti, ed elencare le porte su cui un'applicazione risponde alle connessioni in ingresso. Inoltre, <command>nmap</command> è in grado di identificare alcune di queste applicazioni e a volte anche il loro numero di versione. La contropartita di questo strumento è che, poiché funziona da remoto, non può fornire informazioni su processi o utenti; tuttavia può operare su più target contemporaneamente.
			</para>
			 <para>
				Una tipica invocazione di <command>nmap</command> utilizza solo l'opzione <literal>-A</literal> (in questo modo <command>nmap</command> tenta di identificare le versioni del software per i server che trova), seguita da uno o più indirizzi IP o dai nomi DNS di macchine su cui effettuare la scansione. Ancora una volta, sono disponibili molte altre opzioni per controllare con precisione il comportamento di <command>nmap</command>; consultare la documentazione nella pagina di manuale <citerefentry><refentrytitle>nmap</refentrytitle>
				 <manvolnum>1</manvolnum></citerefentry>.
			</para>
			 
<screen role="scale" width="80">
<computeroutput># </computeroutput><userinput>nmap mirtuel</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET
Nmap scan report for mirtuel (192.168.1.242)
Host is up (0.000013s latency).
rDNS record for 192.168.1.242: mirtuel.internal.placard.fr.eu.org
Not shown: 998 closed ports
PORT    STATE SERVICE
22/tcp  open  ssh
111/tcp open  rpcbind

Nmap done: 1 IP address (1 host up) scanned in 2.41 seconds
# </computeroutput><userinput>nmap -A localhost</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000013s latency).
Other addresses for localhost (not scanned): 127.0.0.1
Not shown: 997 closed ports
PORT    STATE SERVICE VERSION
22/tcp  open  ssh     OpenSSH 6.7p1 Debian 3 (protocol 2.0)
|_ssh-hostkey: ERROR: Script execution failed (use -d to debug)
25/tcp  open  smtp    Exim smtpd 4.84
| smtp-commands: mirtuel Hello localhost [127.0.0.1], SIZE 52428800, 8BITMIME, PIPELINING, HELP, 
|_ Commands supported: AUTH HELO EHLO MAIL RCPT DATA NOOP QUIT RSET HELP 
111/tcp open  rpcbind 2-4 (RPC #100000)
| rpcinfo: 
|   program version   port/proto  service
|   100000  2,3,4        111/tcp  rpcbind
|   100000  2,3,4        111/udp  rpcbind
|   100024  1          36568/tcp  status
|_  100024  1          39172/udp  status
Device type: general purpose
Running: Linux 3.X
OS CPE: cpe:/o:linux:linux_kernel:3
OS details: Linux 3.7 - 3.15
Network Distance: 0 hops
Service Info: Host: mirtuel; OS: Linux; CPE: cpe:/o:linux:linux_kernel

OS and Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 11.54 seconds
</computeroutput></screen>
			 <para>
				Come previsto, sono elencate le applicazioni SSH ed Exim4. Da notare che non tutte le applicazioni sono in ascolto su tutti gli indirizzi IP; poiché Exim4 è accessibile solo sull'interfaccia di loopback <literal>lo</literal>, appare solo durante l'analisi di <literal>localhost</literal> e non durante la scansione di <literal>mirtuel</literal> (che corrisponde all'interfaccia <literal>eth0</literal> sulla stessa macchina).
			</para>

		</section>
		 <section id="sect.sniffers">
			<title>Sniffer: <command>tcpdump</command> e <command>wireshark</command></title>
			 <para>
				A volte si ha la necessità di osservare ciò che realmente transita sul cavo, pacchetto per pacchetto. In questi casi è richiesto un «analizzatore di frame», più noto come <emphasis>sniffer</emphasis>. Tale strumento rileva tutti i pacchetti che raggiungono una determinata interfaccia di rete e li visualizza in una maniera più facile da consultare.
			</para>
			 <indexterm>
				<primary><command>tcpdump</command></primary>
			</indexterm>
			 <para>
				Il venerabile strumento in questo settore è <command>tcpdump</command>, disponibile come strumento standard su una vasta gamma di piattaforme. Esso consente molte tipologie di cattura del traffico di rete, ma la rappresentazione di questo traffico resta piuttosto oscura. Pertanto non verrà approfondito.
			</para>
			 <indexterm>
				<primary><command>wireshark</command></primary>
			</indexterm>
			 <para>
				Uno strumento più recente (e moderno), <command>wireshark</command> (nel pacchetto <emphasis role="pkg">wireshark</emphasis>), è diventato il nuovo punto di riferimento nell'analisi del traffico di rete grazie ai suoi molti moduli di decodifica che permettono una analisi semplificata dei pacchetti catturati. I pacchetti vengono visualizzati graficamente con un'organizzazione in base ai livelli di protocollo. Questo consente all'utente di visualizzare tutti i protocolli coinvolti in un pacchetto. Ad esempio, prendendo un pacchetto contenente una richiesta HTTP, <command>wireshark</command> visualizza, separatamente, le informazioni relative al livello fisico, il livello Ethernet, le informazioni del pacchetto IP, i parametri di connessione TCP, ed infine la richiesta HTTP stessa.
			</para>
			 <figure id="figure.wireshark">
				<title>L'analizzatore del traffico di rete <command>wireshark</command></title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/wireshark.png" format="PNG" scalefit="1" width="75%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <para>
				Nel nostro esempio, i pacchetti che viaggiano su SSH vengono filtrati (con il filtro <literal>!tcp.port == 22</literal>). Il pacchetto attualmente visualizzato è stato sviluppato sul livello HTTP.
			</para>
			 <sidebar> <title><emphasis>SUGGERIMENTO</emphasis> <command>wireshark</command> senza interfaccia grafica: <command>tshark</command></title>
			 <indexterm>
				<primary><command>tshark</command></primary>
			</indexterm>
			 <para>
				Quando non si può eseguire un'interfaccia grafica, o non si vuole farlo per un qualsiasi motivo, esiste anche una versione solo testo di <command>wireshark</command> che va sotto il nome <command>tshark</command> (nel pacchetto separato <emphasis role="pkg">tshark</emphasis>). La maggior parte delle funzioni di cattura e decodifica sono ancora disponibili, ma la mancanza di una interfaccia grafica limita necessariamente le interazioni con il programma (filtraggio dei pacchetti dopo che sono stati catturati, il monitoraggio di una determinata connessione TCP, e così via). Può comunque essere utilizzato come primo approccio. Se si vogliono fare altre manipolazioni e queste richiedono l'interfaccia grafica, i pacchetti possono essere salvati in un file e questo file può essere caricato in un <command>wireshark</command> con interfaccia grafica in esecuzione su un'altra macchina.
			</para>
			 </sidebar>
		</section>

	</section>
</chapter>

