<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="basic-configuration" lang="it-IT">
	<chapterinfo>
		 <keywordset>
			<keyword>Configurazione</keyword>
			 <keyword>Localizzazione</keyword>
			 <keyword>Localizzazioni</keyword>
			 <keyword>Rete</keyword>
			 <keyword>Risoluzione dei nomi</keyword>
			 <keyword>Utenti</keyword>
			 <keyword>Gruppi</keyword>
			 <keyword>Account</keyword>
			 <keyword>Interprete a riga di comando</keyword>
			 <keyword>Shell</keyword>
			 <keyword>Stampa</keyword>
			 <keyword>Bootloader</keyword>
			 <keyword>Compilazione del kernel</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Configurazione di base: rete, account, stampa, ...</title>
	 <highlights> <para>
		Un computer installato da zero con <command>debian-installer</command> è pensato per essere il più possibile funzionante, ma molti servizidevono ancora essere configurati. Inoltre è sempre meglio conoscere come modificare certi elementi di configurazione impostati durante il processo di installazione iniziale.
	</para>
	 </highlights> <para>
		Questo capitolo copre tutto quanto viene normalmente considerato con «configurazione di base»: rete, lingue e localizzazioni, utenti e gruppi, stampa, punti di mount, ecc.
	</para>
	 <section id="sect.config-language-support">
		<title>Configurare il sistema per un'altra lingua</title>
		 <indexterm>
			<primary>Localizzazione Italiana</primary>
		</indexterm>
		 <para>
			Se il sistema è stato installato inizialmente in Italiano, la macchina avrà già probabilmente l'Italiano come lingue predefinita. È comunque meglio conoscere cosa l'installatore fa per impostare la lingua, cosicché, poi, se ne capita la necessità, la si possa cambiare.
		</para>
		 <sidebar> <title><emphasis>STRUMENTO</emphasis> Il comando <command>locale</command> mostra la configurazione attuale</title>
		 <para>
			Il comando <command>locale</command> riepiloga la configurazione attuale di vari parametri della localizzazione (formato della data, formato dei numeri, ecc.), sotto forma di gruppo di variabili d'ambiente standard dedicate alla modifica dinamica di queste impostazioni.
		</para>
		 </sidebar> <section id="sect.default-language">
			<title>Impostare la Lingua Predefinita</title>
			 <indexterm>
				<primary>localizzazione</primary>
			</indexterm>
			 <indexterm>
				<primary>lingua</primary>
			</indexterm>
			 <indexterm>
				<primary><command>locale-gen</command></primary>
			</indexterm>
			 <para>
				Una localizzazione è un gruppo di impostazioni regionali. Include non solo la lingua per i testi, ma anche il formato di visualizzazione dei numeri, date, orari e valori monetari, così come i metodi di comparazione alfabetici (per l'ordinamento alfabetico, per l'inclusione dei caratteri accentati, dove previsto). Anche se ognuno di questi parametri può essere specificato indipendentemente dagli altri, generalmente viene utilizzata una localizzazione, la quale è un insieme coerente di valori per questi parametri corrispondente ad una "regione" nel senso più ampio del termine. Le localizzazioni sono generalmente indicate con la forma <literal><replaceable>codice-lingua</replaceable>_<replaceable>CODICE-PAESE</replaceable></literal>, alcune volte con un suffisso che specifica l'insieme di caratteri e la codifica da utilizzare. Questo consente di considerare anche le differenze tipografiche e di idioma tra differenti regioni con una lingua comune.
			</para>
			 <sidebar> <title><emphasis>CULTURA</emphasis> Insiemi di caratteri</title>
			 <indexterm>
				<primary>insieme di caratteri</primary>
			</indexterm>
			 <indexterm>
				<primary>codifica</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-1</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-15</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 1</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 9</primary>
			</indexterm>
			 <para>
				Storicamente ogni localizzazione ha un "insieme di caratteri" associati (gruppo di caratteri noti) ed una "codifica" preferita (la rappresentazione interna al computer per i caratteri).
			</para>
			 <para>
				Le codifiche più popolari per le lingue a base-latina sono limitate a 256 caratteri perchè si è scelto di utilizzare un singolo byte per ogni carattere. Poichè 256 caratteri non sono stati suffcienti a coprire tutte le lingue europee, sono state necessarie più codifiche, ed è così che si è arrivati fino a <emphasis>ISO-8859-1</emphasis> (noto anche come “Latin 1”) e <emphasis>ISO-8859-15</emphasis> (noto anche come “Latin 9”), tra gli altri.
			</para>
			 <para>
				Lavorare con le lingue straniere spesso implicava passaggi continui tra diverse codifiche ed insiemi di caratteri. Inoltre scrivere documenti multi-lingua portava ad altri problemi, quasi irrisolvibili. Unicode (un super-catalogo che include quasi tutti i sistemi di scrittura utilizzati da tutte le lingue del mondo) è stato creato per risolvere questo problema. Una delle codifiche Unicode, UTF-8, conserva tutti i 128 simboli ASCII (codici a 7 bit), ma gestisce gli altri caratteri in modo differente. Gli altri sono preceduti da una sequenza di caratteri di escape con una lunghezza variabile, che definisce implicitamente la lunghezza del carattere. Questo consente di codificare tutti i caratteri Unicode tramite una sequenza di uno o più byte. Il suo uso si è diffuso in quanto è la codifica predefinita nei documenti XML.
			</para>
			 <indexterm>
				<primary>ASCII</primary>
			</indexterm>
			 <indexterm>
				<primary>UTF-8</primary>
			</indexterm>
			 <indexterm>
				<primary>Unicode</primary>
			</indexterm>
			 <para>
				Questa è la codifica che generalmente dovrebbe essere utilizzata, ed è quella predefinita sui sitemi Debian.
			</para>
			 </sidebar> <para>
				Il pacchetto <emphasis role="pkg">locales</emphasis> include tutti gli elementi richiesti per il corretto funzionamento della "localizzazione" per varie applicazioni. Durante l'installazione, questo pacchetto presenterà alcune domande per scegliere le lingue supportate. Questo insieme di lingue supportate può essere modificato eseguendo <command>dpkg-reconfigure locales</command> come root.
			</para>
			 <para>
				La prima domanda chiederà di selezionare la "localizzazione" da includere. Selezionare tutte le localizzazioni inglesi (ovvero quelle che iniziano con "<literal>en_</literal>") è una scelta ragionevole. Non si esiti a scegliere altre localizzazioni se la macchina sarà utilizzata da utenti stranieri. L'elenco dell localizzazioni abilitate sul sistema è conservato nel file <filename>/etc/locale.gen</filename>. È possibile modificare manualmente questo file, ma si deve eseguire <command>locale-gen</command> dopo ogni modifica. Questo genera i file necessari per il corretto funzionamento delle localizzazioni aggiunte e rimuove i file obsoleti.
			</para>
			 <para>
				La seconda domanda, chiamata "Localizzazione predefinita per l'ambiente di sistema", richiede di impostare la localizzazione predefinita. La scelta raccomandata negli U.S.A. è "<literal>en_US.UTF-8</literal>". Coloro che usano l'inglese britannico preferiranno "<literal>en_GB.UTF-8</literal>", i canadesi preferiranno o "<literal>en_CA.UTF-8</literal>" o, per il francese, "<literal>fr_CA.UTF-8</literal>". Il file <filename>/etc/default/locale</filename> sarà quindi modificato per memorizzare questa scelta. Da li, è raccolto da tutte le sessioni utente dal PAM che inietterà il suo contenuto nella variabile d'ambiente <varname>LANG</varname>.
			</para>
			 <indexterm>
				<primary>ambiente</primary>
			</indexterm>
			 <indexterm>
				<primary>localizzazione</primary>
			</indexterm>
			 <indexterm>
				<primary><varname>LANG</varname></primary>
			</indexterm>
			 <sidebar id="sidebar.intro-pam"> <title><emphasis>DIETRO LE QUINTE</emphasis> <filename>/etc/environment</filename> e <filename>/etc/default/locale</filename></title>
			 <para>
				Il file <filename>/etc/environment</filename> permette ai programmi <command>login</command>, <command>gdm</command>, o anche <command>ssh</command> di impostare le variabili d'ambiente corrette.
			</para>
			 <para>
				Queste applicazioni non creano queste variabili direttamente, ma attraverso il modulo PAM (<filename>pam_env.so</filename>). PAM (Pluggable Authentication Module) è una libreria modulare che accentra i meccanismi per l'autenticazione, l'inizializzazione della sessione, e la gestione delle password. Si veda la <xref linkend="sect.config-pam" /> per un esempio di configurazione PAM.
			</para>
			 <para>
				Il file <filename>/etc/default/locale</filename> funziona in modo simile, ma contiene solo la variabile d'ambiente <varname>LANG</varname>. Grazie a questa divisione, alcuni utenti PAM erediteranno un ambiente completo senza localizzazione. Infatti, è generalmente sconsigliato eseguire programmi server con la localizzazione abilitata; d'altra parte, la localizzazione e le impostazioni internazionali sono raccomandate per i programmi che aprono le sessioni degli utenti.
			</para>
			 <indexterm>
				<primary>PAM</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>pam_env.so</filename></primary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.keyboard-config">
			<title>Configurare la tastiera</title>
			 <indexterm>
				<primary>disposizione dei tasti</primary>
			</indexterm>
			 <indexterm>
				<primary>layout, tastiera</primary>
			</indexterm>
			 <para>
				Anche se il layout della tastiera viene gestito in modo diverso in console ed in modalità grafica, Debian offre un'interfaccia di configurazione unica che funziona per entrambi: si basa su debconf ed è implementata nel pacchetto <emphasis role="pkg">keyboard-configuration</emphasis>. Perciò per rispristinare il layout della tastiera si può utilizzare in qualsiasi momento il comando <command>dpkg-reconfigure keyboard-configuration</command>.
			</para>
			 <indexterm>
				<primary><emphasis>console-data</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>console-tools</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>keyboard-configuration</emphasis></primary>
			</indexterm>
			 <para>
				<indexterm><primary><literal>azerty</literal></primary></indexterm>Le domande riguardano la disposizione fisica della tastiera (una tastiera PC standard negli Stati Uniti sarà una "Generica 104 tasti"), quindi il layout da scegliere (genericamente "US"), e quindi la posizione del tasto AltGr (Alt di destra). Per ultima arriva la domanda a proposito di quale tasto usare per la funzione "Compose", che consente di inserire i caratteri speciali combinando la pressione di più tasti. Digitare in sequenza <keycombo action="seq"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> produce una "e" accentata ("é"). Tutte queste combinazioni sono descritte nel file <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> (oppure un altro file, determinato in base alla localizzazione corrente indicata in <filename>/usr/share/X11/locale/compose.dir</filename>).
			</para>
			 <indexterm>
				<primary>Tasto, <literal>Compose</literal></primary>
			</indexterm>
			 <indexterm>
				<primary>Tasto, <literal>Meta</literal></primary>
			</indexterm>
			 <indexterm>
				<primary>chiave</primary>
				<secondary><literal>Meta</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary>chiave</primary>
				<secondary><literal>Compose</literal></secondary>
			</indexterm>
			 <para>
				Note that the keyboard configuration for graphical mode described here only affects the default layout; the GNOME and KDE Plasma environments, among others, provide a keyboard control panel in their preferences allowing each user to have their own configuration. Some additional options regarding the behavior of some particular keys are also available in these control panels.
			</para>

		</section>
		 <section id="sect.utf8-migration">
			<title>Migrare ad UTF-8</title>
			 <para>
				La generalizzazione della codifica UTF-8 è stata una soluzione attesa a lungo per le numerose difficoltà con l'interoperabilità, poiché facilita lo scambio internazionale e rimuove i limiti arbitrari sui caratteri che possono essere utilizzati in un documento. L'unica controindicazione è che si è dovuta attraversare una fase di difficile transizione. Poiché non ha potuto essere completamente trasparente (cioè, non è potuta avvenire contemporaneamente in tutto il mondo), due operazioni di conversione sono state necessarie: una sul contenuto dei file e l'altra sul loro nome. Fortunatamente la maggior parte di questa migrazione è stata completata e ne discuteremo più ampiamente per riferimento.
			</para>
			 <sidebar> <title><emphasis>CULTURA</emphasis> <foreignphrase>Mojibake</foreignphrase> ed errori di interpretazione</title>
			 <para>
				Quando un testo è inviato (o conservato) senza informazioni di codifica non è sempre possibile per il destinatario sapere con certezza quale convenzione usare per determinare il significato di un insieme di byte. È generalmente possibile farsi un'idea in proposito effettuando statistiche circa la distribuzione dei valori nel testo, ma questo non fornisce sempre una risposta definitiva. Quando la codifica scelta per la lettura di un file differisce da quella usata per la scrittura, i byte non vengono interpretati correttamente e avremo, nel migliore dei casi errori su alcuni caratteri, nel peggiore qualcosa di completamente illeggibile.
			</para>
			 <para>
				Così, se un testo francese appare normale con l'eccezione delle lettere accentate e di certi simboli che appiono sostituiti con sequenze di caratteri come «Ã©» o «Ã¨» o «Ã§», si tratta probabilmente di un file codificato con UTF-8 ma interpretato come ISO-8859-1 o ISO-8859-15. Questo è sintomo di una installazione locale che non è ancora stata migrata ad UTF-8. Se invece si vedono punti di domanda al posto delle lettere accentate, anche se questi punti di domanda sembrano sostituire anche il carattere che dovrebbe seguire la lettera accentata, molto probabilmente l'installazione è già configurata per UTF-8 ma è stato inviato un documento codificato con la codifica «Western ISO».
			</para>
			 <para>
				Questo riguarda casi «semplici». Questi casi si verificano solo nella cultura occidentale, poiché l'Unicode (e l'UTF-8) è stato progettato per massimizzare i punti comuni con le codifiche storiche per i linguaggi occidentali basati sull'alfabeto latino, che consente di comprendere parti del testo anche se alcuni caratteri sono mancanti.
			</para>
			 <para>
				In configurazioni più complesse dove sono coinvolti, per esempio, due ambienti con due diversi linguaggi che non utilizzano lo stesso alfabeto, i risultati saranno spesso illeggibili, una serie di simboli astratti che non hanno nulla a che fare l'uno con l'altro. Questo è assai comune con le lingue asiatiche a causa del numero elevato di lingue e sistemi di scrittura. La parola giapponese <foreignphrase>mojibake</foreignphrase> è stata adottata per descrivere questo fenomeno. Quando appare la diagnosi è molto complessa e la soluzione più semplice è spesso quella di migrare ad UTF-8 da entrambe le parti.
			</para>
			 </sidebar> <para>
				Per ciò che riguarda i nomi dei file la migrazione può essere relativamente semplice. Lo strumento <command>convmv</command> (contenuto nell'omonimo pacchetto) è stato creato specificatamente a questo scopo: permette di rinominare i file da una codifica ad un'altra. L'uso di questo strumento è relativamente semplice, ma raccomandiamo di farlo in due fasi per evitare sorprese. L'esempio seguente illustra un ambiente UTF-8 che contiene nomi di directory codificati in ISO-8859-15 e l'uso del comando <command>convmv</command> per rinominarli.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Ic?nes  ?l?ments graphiques  Textes
$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>Starting a dry run without changes...
mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
No changes to your files done. Use --notest to finally rename the files.
$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
Ready!
$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput></screen>
			 <para>
				Per il contenuto del file, le procedure di conversione sono più complesse a causa della vastità dei formati esistenti. Alcuni formati di file includono informazioni sulla codifica che facilitano il compito del software usato per trattarli: è sufficiente, in tal caso, aprire questi file e salvarli nuovamente specificando la codifica UTF-8. In altri casi, si dovrà specificare la codifica originale (ISO-8859-1 o "Western", o ISO-8859-15 o "Western (Euro)", secondo ciò che viene indicato) quando si apre il file.
			</para>
			 <para>
				Per file di testo semplice è possibile usare <command>recode</command> (contenuto nell'omonimo pacchetto) che consente la ricodifica automatica. Questo strumento ha numerose opzioni che è possibile specificare per modificare il suo comportamento. Noi raccomandiamo di consultare la documentazione, la pagina di manuale <citerefentry> <refentrytitle>recode</refentrytitle>
				 <manvolnum>1</manvolnum> </citerefentry>, oppure la pagina di info <citerefentry> <refentrytitle>recode</refentrytitle>
				 </citerefentry> (più completa).
			</para>

		</section>

	</section>
	 <section id="sect.network-config">
		<title>Configurazione della rete</title>
		 <sidebar id="sidebar.networking-basics"> <title><emphasis>FONDAMENTALI</emphasis> Concetti di rete essenziali (Ethernet, indirizzo IP, sottorete, broadcast)</title>
		 <indexterm>
			<primary>Ethernet</primary>
		</indexterm>
		 <indexterm>
			<primary>10BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>100BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>1000BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>10GBASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>connettore, RJ45</primary>
		</indexterm>
		 <indexterm>
			<primary>RJ45 connettore</primary>
		</indexterm>
		 <para>
			La maggior parte delle reti locali moderne usa il protocollo Ethernet, il quale divide i dati in piccoli blocchi chiamati frame e li trasmette sul cavo uno alla volta. La velocità dei dati varia dai 10 Mb/s per le vecchie schede Ethernet ai 10 Gb/s delle schede più recenti (attualmente la velocità più comune sta passando da 100 Mb/s a 1 Gb/s). I cavi usati più comunemente sono chiamati 10BASE-T, 100BASE-T, 1000BASE-T o 10GBASE-T in base alla velocità che possono fornire in modo affidabile (la T sta per "twisted pair" ovvero doppino intrecciato); questi cavi terminano con un connettore RJ45. Esistono cavi di altro tipo, per lo più utilizzati per velocità superiori ad 1 Gb/s.
		</para>
		 <indexterm>
			<primary>indirizzo, IP</primary>
		</indexterm>
		 <indexterm>
			<primary>indirizzo IP</primary>
		</indexterm>
		 <para>
			Un indirizzo IP è un numero usato per identificare un'interfaccia di rete installata su un computer in una rete locale oppure su Internet. Nella versione attualmente più diffusa di IP (IPv4), questo numero è codificato in 32 bit e viene generalmente rappresentato come 4 numeri separati da punti (es. <literal>192.168.0.1</literal>), ogni numero è compreso tra 0 e 255 (inclusi, che corrisponde a 8 bit di dati). La prossima versione del protocollo, IPv6, estenderà questo spazio di indirizzamento a 128 bit e gli indirizzi saranno generalmente rappresentati da una serie di numeri esadecimali separati dai due punti (es., 2001:db8:13bb:0002:0000:0000:0020, o 2001:db8:13bb:2::20 nella forma abbreviata).
		</para>
		 <indexterm>
			<primary>sottorete</primary>
		</indexterm>
		 <indexterm>
			<primary>maschera</primary>
			<secondary>maschera di sottorete</secondary>
		</indexterm>
		 <indexterm>
			<primary>rete</primary>
			<secondary>indirizzo</secondary>
		</indexterm>
		 <para>
			Una maschera di sottorete (netmask) definisce tramite il proprio codice binario quale porzione di un indirizzo IP corrisponde alla rete, e quale specifica la macchina. Nell'esempio di configurazione di indirizzo statico IPv4 qui fornito, la maschera di sottorete <literal>255.255.255.0</literal> (24 «1» seguiti da 8 «0» nella rappresentazione binaria) indica che i primi 24 bit dell'indirizzo IP corrispondono alla rete mentre gli altri 8 specificano la macchina. In IPv6, in favore della leggibilità, solo i numeri «1» vengono espressi; la maschera di sottorete per una rete IPv6 potrà essere quindi <literal>64</literal>.
		</para>
		 <para>
			L'indirizzo di rete è un indirizzo IP nel quale la parte che descrive la macchina è pari a 0. L'intervallo di indirizzi IPv4 in una rete completa è spesso indicato con la sintassi <emphasis>a.b.c.d/e</emphasis>, dove <emphasis>a.b.c.d</emphasis> è l'indirizzo della rete ed <emphasis>e</emphasis> è il numero dei bit interessati dalla parte che indica la rete in un indirizzo IP. Una rete ad esempio sarà quindi descritta come segue: <literal>192.168.0.0/24</literal>. La sintassi è simile in IPv6: <literal>2001:db8:13bb::/64</literal>.
		</para>
		 <indexterm>
			<primary>router</primary>
		</indexterm>
		 <indexterm>
			<primary>bridge</primary>
		</indexterm>
		 <para>
			Un router è una macchina che connette diverse reti l'una con l'altra. Tutto il traffico che arriva attraverso un router è instradato verso la rete corretta. Per fare questo il router analizza i pacchetti in arrivo e li ridirige in base all'indirizzo IP della loro destinazione. Il router è spesso indicato come «gateway»: in questa configurazione lavora come una macchina che consente di uscire dalla rete locale (verso una rete estesa, come Internet).
		</para>
		 <indexterm>
			<primary>broadcast</primary>
		</indexterm>
		 <para>
			L'indizzo speciale di broadcast connette tutte le postazioni in una rete. Non viene quasi mai instradato, funziona quindi solo all'interno della stessa rete. Questo significa che un pacchetto destinato all'indirizzo di broadcast non oltrepassa mai il router.
		</para>
		 <para>
			Questo capitolo si concentra sugli indirizzi IPv4 poiché sono attualmente i più utilizzati. I dettagli del protocollo IPv6 sono affrontati nella <xref linkend="sect.ipv6" />, ma i concetti rimangono gli stessi.
		</para>
		 </sidebar> <para>
			The network is automatically configured during the initial installation. If Network Manager gets installed (which is generally the case for full desktop installations), then it might be that no configuration is actually required (for example, if you rely on DHCP on a wired connection and have no specific requirements). If a configuration is required (for example for a WiFi interface), then it will create the appropriate file in <filename>/etc/NetworkManager/system-connections/</filename>.
		</para>
		 <para>
			If Network Manager is not installed, then the installer will configure <emphasis role="pkg">ifupdown</emphasis> by creating the <filename>/etc/network/interfaces</filename> file. A line starting with <literal>auto</literal> gives a list of interfaces to be automatically configured on boot by the <literal>networking</literal> service.
		</para>
		 <para>
			In a server context, <emphasis role="pkg">ifupdown</emphasis> is thus the network configuration tool that you usually get. That is why we will cover it in the next sections.
		</para>
		 <indexterm>
			<primary>rete</primary>
			<secondary>configurazione</secondary>
		</indexterm>
		 <indexterm>
			<primary>configurazione</primary>
			<secondary>della rete</secondary>
		</indexterm>
		 <indexterm>
			<primary>interfaccia</primary>
			<secondary>interfaccia di rete</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>ALTERNATIVA</emphasis> NetworkManager</title>
		 <indexterm>
			<primary><emphasis role="pkg">network-manager</emphasis></primary>
		</indexterm>
		 <para>
			If Network Manager is particularly recommended in roaming setups (see <xref linkend="sect.roaming-network-config" />), it is also perfectly usable as the default network management tool. You can create “System connections” that are used as soon as the computer boots either manually with a <filename>.ini</filename>-like file in <filename>/etc/NetworkManager/system-connections/</filename> or through a graphical tool (<command>nm-connection-editor</command>). Just remember to deactivate all entries in <filename>/etc/network/interfaces</filename> if you want Network Manager to handle them. <ulink type="block" url="https://wiki.gnome.org/Projects/NetworkManager/SystemSettings" /> <ulink type="block" url="https://developer.gnome.org/NetworkManager/1.6/ref-settings.html" />
		</para>
		 </sidebar> <section id="sect.interface-ethernet">
			<title>Interfaccia Ethernet</title>
			 <para>
				Se il computer dispone di una scheda Ethernet, la rete che vi sarà associata dev'essere configurata scegliendo uno tra i due metodi disponibili. Il metodo più semplice è la configurazione dinamica con DHCP, e richiede un server DHCP nella rete locale. Si può indicare il nome host desiderato, corrispondente all'<literal>hostname</literal> impostato nell'esempio seguente. Il server DHCP invia informazioni di configurazione appropriate per la rete.
			</para>
			 <indexterm>
				<primary>Ethernet</primary>
			</indexterm>
			 <indexterm>
				<primary>DHCP</primary>
			</indexterm>
			 <example id="example.config-dhcp">
				<title>Configurazione DHCP</title>
				 
<programlisting>
auto enp0s31f6
iface enp0s31f6 inet dhcp
  hostname arrakis
</programlisting>

			</example>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> Names of network interfaces</title>
			 <indexterm>
				<primary><literal>eth0</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>en*</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>wlan0</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>wl*</literal></primary>
			</indexterm>
			 <para>
				By default, the kernel attributes generic names such a <literal>eth0</literal> (for wired Ethernet) or <literal>wlan0</literal> (for WiFi) to the network interfaces. The number in those names is a simple incremental counter representing the order in which they have been detected. With modern hardware, that order might change for each reboot and thus the default names are not reliable.
			</para>
			 <para>
				Fortunately, systemd and udev are able to rename the interfaces as soon as they appear. The default name policy is defined by <filename>/lib/systemd/network/99-default.link</filename> (see <citerefentry><refentrytitle>systemd.link</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> for an explanation of the <literal>NamePolicy</literal> entry in that file). In practice, the names are often based on the device's physical location (as guessed by where they are connected) and you will see names starting with <literal>en</literal> for wired ethernet and <literal>wl</literal> for WiFi. In the example above, the rest of the name indicates, in abbreviated form, a PCI (<literal>p</literal>) bus number (<literal>0</literal>), a slot number (<literal>s31</literal>), a function number (<literal>f6</literal>).
			</para>
			 <para>
				Obviously, you are free to override this policy and/or to complement it to customize the names of some specific interfaces. You can find out the names of the network interfaces in the output of <command>ip addr</command> (or as filenames in <filename>/sys/class/net/</filename>).
			</para>
			 </sidebar> <para>
				Una configurazione «statica» indica delle impostazioni di rete fisse. Ciò include perlomeno un indirizzo IP ed una maschera di rete; a volte vengono indicati anche indirizzi di rete e broadcast. Un router che connette verso l'esterno viene indicato come «gateway».
			</para>
			 <example id="example.static-network">
				<title>Configurazione statica</title>
				 
<programlisting>
auto enp0s31f6
iface enp0s31f6 inet static
  address 192.168.0.3
  netmask 255.255.255.0
  broadcast 192.168.0.255
  network 192.168.0.0
  gateway 192.168.0.1
</programlisting>

			</example>
			 <sidebar> <title><emphasis>NOTA</emphasis> Indirizzi multipli</title>
			 <para>
				Oltre a poter associare diverse interfacce alla singola scheda di rete è anche possibile associare diversi indirizzi IP alla singola interfaccia. Va ricordato inoltre che un indirizzo IP può corrispondere a più di un nome DNS e che ogni nome può a sua volta corrispondere a qualsiasi numero di indirizzi IP numerici.
			</para>
			 <para>
				Come si può intuire le configurazioni possono essere piuttosto complicate, ma queste opzioni sono usate solo in casi veramente speciali. Gli esempi citati qui rappresentano le configurazioni tipiche.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.interface-wireless">
			<title>Wireless Interface</title>
			 <indexterm>
				<primary>wireless</primary>
			</indexterm>
			 <para>
				Getting wireless network cards to work can be a bit more challenging. First of all, they often require the installation of proprietary firmwares which are not installed by default in Debian. Then wireless networks rely on cryptography to restrict access to authorized users only, this implies storing some secret key in the network configuration. Let's tackle those topics one by one.
			</para>
			 <section>
				<title>Installing the required firmwares</title>
				 <indexterm>
					<primary>firmware</primary>
				</indexterm>
				 <indexterm>
					<primary>isenkram</primary>
				</indexterm>
				 <para>
					First you have to enable the non-free repository in APT's sources.list file: see <xref linkend="sect.apt-sources.list" /> for details about this file. Many firmware are proprietary and are thus located in this repository. You can try to skip this step if you want, but if the next step doesn't find the required firmware, retry after having enabled the non-free section.
				</para>
				 <para>
					Then you have to install the appropriate <literal>firmware-*</literal> packages. If you don't know which package you need, you can install the <emphasis role="pkg">isenkram</emphasis> package and run its <command>isenkram-autoinstall-firmware</command> command. The packages are often named after the hardware manufacturer or the corresponding kernel module: <emphasis role="pkg">firmware-iwlwifi</emphasis> for Intel wireless cards, <emphasis role="pkg">firmware-atheros</emphasis> for Qualcomm Atheros, <emphasis role="pkg">firmware-ralink</emphasis> for Ralink, etc. A reboot is then recommended because the kernel driver usually looks for the firmware files when it is first loaded and no longer afterwards.
				</para>

			</section>
			 <section>
				<title>Wireless specific entries in <filename>/etc/network/interfaces</filename></title>
				 <indexterm>
					<primary>WPA</primary>
				</indexterm>
				 <para>
					<emphasis>ifupdown</emphasis> is able to manage wireless interfaces but it needs the help of the <emphasis role="pkg">wpasupplicant</emphasis> package which provides the required integration between <emphasis>ifupdown</emphasis> and the <command>wpa_supplicant</command> command used to configure the wireless interfaces (when using WPA/WPA2 encryption). The usual entry in <filename>/etc/network/interfaces</filename> needs to be extended with two supplementary parameters to specify the name of the wireless network (aka its SSID) and the <emphasis>Pre-Shared Key</emphasis> (PSK).
				</para>
				 <example id="example.config-wireless">
					<title>DHCP configuration for a wireless interface</title>
					 
<programlisting>
auto wlp4s0
iface wlp4s0 inet dhcp
  wpa-ssid Falcot
  wpa-psk ccb290fd4fe6b22935cbae31449e050edd02ad44627b16ce0151668f5f53c01b
</programlisting>
				</example>
				 <para>
					The <literal>wpa-psk</literal> parameter can contain either the plain text passphrase or its hashed version generated with <command>wpa_passphrase <replaceable>SSID</replaceable> <replaceable>passphrase</replaceable></command>. If you use an unencrypted wireless connection, then you should put a <literal>wpa-key-mgmt NONE</literal> and no <literal>wpa-psk</literal> entry. For more information about the possible configuration options, have a look at <filename>/usr/share/doc/wpasupplicant/README.Debian.gz</filename>.
				</para>
				 <para>
					At this point, you should consider restricting the read permissions on <filename>/etc/network/interfaces</filename> to the root user only since the file contains a private key that not all users should have access to.
				</para>
				 <sidebar> <title><emphasis>HISTORY</emphasis> WEP encryption</title>
				 <indexterm>
					<primary>WEP</primary>
				</indexterm>
				 <para>
					Usage of the deprecated WEP encryption protocol is possible with the <emphasis role="pkg">wireless-tools</emphasis> package. See <filename>/usr/share/doc/wireless-tools/README.Debian</filename> for instructions.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.ppp-rtc">
			<title>Connettersi con PPP attraverso un modem PSTN</title>
			 <indexterm>
				<primary>PPP</primary>
			</indexterm>
			 <indexterm>
				<primary>punto-punto</primary>
			</indexterm>
			 <indexterm>
				<primary>connessione</primary>
				<secondary>con un modem PSTN</secondary>
			</indexterm>
			 <indexterm>
				<primary>modem</primary>
				<secondary>PSTN</secondary>
			</indexterm>
			 <para>
				Una connessione punto-punto (PPP) stabilisce una connessione intermittente: questa è la soluzione più comune per le connessioni realizzate con un modem telefonico (detto anche modem PSTN poiché la connessione transita nella rete telefonica pubblica).
			</para>
			 <para>
				Una connessione tramite modem telefonico richiede un account presso un provider di accesso, che include un numero telefonico, un nome utente, una password ed a volte uno specifico protocollo di autenticazione da utilizzare. Questo tipo di connessione si configura usando lo strumento <command>pppconfig</command> fornito dall'omonimo pacchetto Debian. Per impostazione predefinita, stabilisce una connessione chiamata <literal>provider</literal> (come nel Provider di servizi internet). Quando si hanno dubbi sul protocollo di autenticazione, scegliere <emphasis>PAP</emphasis>: è offerto dalla maggior parte dei provider di servizi Internet.
			</para>
			 <indexterm>
				<primary><command>pppconfig</command></primary>
			</indexterm>
			 <indexterm>
				<primary>PAP</primary>
			</indexterm>
			 <para>
				Dopo la configurazione è possibile connettersi usando il comando <command>pon</command> (fornendo il nome della connessione come parametro, quando il valore predefinito <literal>provider</literal> non è appropriato). Si può terminare il collegamento con il comando <command>poff</command>. Questi due comandi possono essere eseguiti dall'utente root, o da ogni altro utente, purché sia inserito nel gruppo <literal>dip</literal>.
			</para>
			 <indexterm>
				<primary><command>pon</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>poff</command></primary>
			</indexterm>

		</section>
		 <section id="sect.adsl">
			<title>Connessione attraverso un modem ADSL</title>
			 <indexterm>
				<primary>connessione</primary>
				<secondary>via modem ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>modem</primary>
				<secondary>ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>ADSL, modem</primary>
			</indexterm>
			 <para>
				Il termine generico "modem ADSL" ricopre una moltitudine di dispositivi con funzioni molto differenti. I modem più semplici da utilizzare con Linux sono quelli che dispongono di un'interfaccia Ethernet ( e non solo una porta USB). Questi sono tendenzialmente popolari: molti provider di servizi Internet ADSL prestano (o affittano) un "dispositivo" con interfacce Ethernet. In base al tipo di modem, la configurazione richiesta può variare molto.
			</para>
			 <section id="sect.adsl-pppoe">
				<title>Modem che supportano PPPOE</title>
				 <indexterm>
					<primary>PPPOE</primary>
				</indexterm>
				 <indexterm>
					<primary><command>pppoeconf</command></primary>
				</indexterm>
				 <para>
					Alcuni modem Ethernet lavorano con il protocollo PPPOE (Point to Point Protocol over Ethernet). Lo strumento <command>pppoeconf</command> (dall'omonimo pacchetto) configurerà la connessione. Per farlo, modifica il file <filename>/etc/ppp/peers/dsl-provider</filename> con le impostazioni fornite e registra le informazioni di accesso nei file <filename>/etc/ppp/pap-secrets</filename> e <filename>/etc/ppp/chap-secrets</filename>. Si raccomanda di accettare tutte le modifiche proposte.
				</para>
				 <para>
					Quando la configurazione è completata è possibile avviare la connessione ADSL con il comando <command>pon dsl-provider</command> e terminarla con <command>poff dsl-provider</command>.
				</para>
				 <indexterm>
					<primary><literal>dsl-provider</literal></primary>
				</indexterm>
				 <sidebar> <title><emphasis>SUGGERIMENTO</emphasis> Avviare <command>ppp</command> all'avvio</title>
				 <indexterm>
					<primary><command>systemd</command></primary>
				</indexterm>
				 <indexterm>
					<primary><command>init</command></primary>
				</indexterm>
				 <para>
					Le connessioni PPP su ADSL sono, per definizione, intermittenti. Poiché solitamente non sono fatturate in base al tempo, esistono poche ragioni per non tenerle sempre attive. Di solito per farlo si utilizza il sistema di init.
				</para>
				 <para>
					With systemd, adding an automatically restarting task for the ADSL connection is a simple matter of creating a “unit file” such as <filename>/etc/systemd/system/adsl-connection.service</filename>, with contents such as the following:
				</para>
				 
<programlisting>[Unit]
Description=Connessione ADSL

[Service]
Type=forking
ExecStart=/usr/sbin/pppd call dsl-provider
Restart=always

[Install]
WantedBy=multi-user.target</programlisting>
				 <para>
					Una volta definito il file unit, deve essere abilitato con <command>systemctl enable adsl-connection</command>. Poi il ciclo può essere avviato manualmente con <command>systemctl start adsl-connection</command>; che sarà avviato automaticamente all'avvio.
				</para>
				 <para>
					Sui sistemi che non usano <command>systemd</command> (compresa <emphasis role="distribution">Wheezy</emphasis> e le versioni precedenti di Debian), lo standard SytemV funziona in modo diverso. In questi sistemi, tutto quello che bisogna fare è aggiungere una linea come la seguente alla fine del file <filename>/etc/inittab</filename>; quindi, ogni volta che la connessione verrà interrotta, <command>init</command>la riconnettrerà.
				</para>
				 
<programlisting>
adsl:2345:respawn:/usr/sbin/pppd call dsl-provider</programlisting>
				 <para>
					Per le connessioni ADSL che si auto-disconnettono giornalemente, questo metodo riduce la durata dell'interruzione.
				</para>
				 </sidebar>
			</section>
			 <section id="sect.adsl-pptp">
				<title>Modem che supportano PPTP</title>
				 <indexterm>
					<primary>PPTP</primary>
				</indexterm>
				 <para>
					Il protocollo PPTP (Point-to-Point Tunneling Protocol) è stato creato da Microsoft. Sviluppato agli albori dell'ADSL, è stato velocemente sostituito da PPPOE. Se questo protocollo è una scelta forzata per voi, si veda la <xref linkend="sect.pptp" />.
				</para>

			</section>
			 <section id="sect.adsl-dhcp">
				<title>Modem che supportano DHCP</title>
				 <para>
					Quando un modem è connesso al computer tramite un cavo Ethernet (cavo incrociato o «crossover») si configura tipicamente una connessione di rete sul computer attraverso DHCP: il modem agisce automaticamente come gateway in via predefinita e si cura dell'instradamento (significa che gestisce il traffico di rete tra il computer ed Internet).
				</para>
				 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> Cavo incrociato per connessioni Ethernet dirette</title>
				 <indexterm>
					<primary>cavo incrociato</primary>
				</indexterm>
				 <para>
					Le schede di rete dei computer si aspettano di ricevere i dati su fili specifici all'interno del cavo e di inviare i propri dati su altri. Quando ci si connette ad un computer nella rete locale si connette generalmente un cavo (dritto o incrociato) tra la scheda di rete ed il ripetitore o «switch». Tuttavia, qualora si voglia connettere due computer direttamente (senza uno switch o un ripetitore intermediario) è necessario indirizzare il segnale inviato da una scheda al lato ricevente dell'altra scheda e vice-versa. Questo è lo scopo del cavo incrociato, nonché la ragione per cui è utilizzato.
				</para>
				 <para>
					Si noti che questa distinzione è diventata quasi irrilevante nel tempo, tanto che le moderne schede di rete sono in grado non rilevare il tipo di cavo presente e adattarsi di conseguenza, in modo che non sarà insolito che entrambi i tipi di cavo funzioneranno in una data posizione.
				</para>
				 </sidebar> <para>
					Molti "router ADSL" sul mercato possono essere utilizzati in questo modo, come fanno la maggior parte dei modem ADSL forniti dai provider di servizi Internet.
				</para>

			</section>

		</section>
		 <section id="sect.roaming-network-config">
			<title>Automatizzare la configurazione della rete per gli utenti in movimento</title>
			 <indexterm>
				<primary><emphasis role="pkg">network-manager</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>rete</primary>
				<secondary>configurazione in movimento</secondary>
			</indexterm>
			 <para>
				Molti ingegneri della Falcot hanno un computer portatile che, utilizzano anche a casa, per scopi professionali. La configurazione di rete da usare dipende dalla posizione. A casa può esserci una rete wifi (protetta da una chiave WPA), mentre sul luogo di lavoro è disponibile una rete cablata per maggiore sicurezza e velocità.
			</para>
			 <para>
				Per evitare di doversi manualmente connettere o disconnettere alle corrispondenti interfacce di rete, gli amministratori hanno installato il pacchetto <emphasis role="pkg">network-manager</emphasis> su queste macchine in movimento. Questo software abilita l'utente a passare facilmente tra una rete ed un'altra utilizzando la piccola icona visualizzata nell'area notifiche del desktop grafico. Cliccando su questa icona si visualizza una lista di reti disponibili (sia via cavo che wireless) così è possibile scegliere semplicemente la rete che si intende utilizzare. Il programma salva la configurazione per le reti alle quali l'utente si è già connesso ed automaticamente passa alla miglior rete disponibile quando la connessione corrente si interrompe.
			</para>
			 <para>
				Per poter far ciò, il programma è strutturato in due parti: un demone eseguito come root gestisce l'attivazione e la configurazione delle interfacce di rete ed una interfaccia utente controlla questo demone. Il PolicyKit gestisce le autorizzazioni richieste per controllare questo programma ed in Debian il PolicyKit è stato configurato in modo tale che solo i membri del gruppo netdev possono aggiungere o modificare le connessioni del Network Manager.
			</para>
			 <para>
				Network Manager sa come gestire vari tipi di connessione (DHCP, configurazione manuale, rete locale), ma solo se la configurazione è impostata con il programma stesso. Questo è il motivo per cui ignora sistematicamente tutte le interfacce di rete in <filename>/etc/network/interfaces</filename>, che non potrebbe gestire. Poiché Network Manager non fornisce dettagli quando non è visualizzata alcuna connessione di rete, il modo migliore di procedere è cancellare da <filename>/etc/network/interfaces</filename> qualsiasi configurazione riguardante le interfacce che si intende gestire con Network Manager.
			</para>
			 <para>
				Si noti che questo programma è installato in via predefinita quando viene scelto di installare l'ambiente grafico durante l'installazione iniziale.
			</para>

		</section>

	</section>
	 <section id="sect.hostname-name-service">
		<title>Impostare il nome host e configurare il servizio dei nomi</title>
		 <indexterm>
			<primary>nome</primary>
			<secondary>attribuzione e risoluzione</secondary>
		</indexterm>
		 <indexterm>
			<primary>assegnamento dei nomi</primary>
		</indexterm>
		 <para>
			Lo scopo di assegnare dei nomi agli indirizzi IP è quello di rendere più facile la memorizzazione per le persone. In verità, un indirizzo IP identifica un'interfaccia di rete associata con un dispositivo come una scheda di rete. Poiché ogni macchina può avere più schede e più interfacce per ogni scheda, un singolo computer può avere più nomi nel sistema dei nomi di dominio.
		</para>
		 <para>
			Ogni macchina è tuttavia identificata da un nome principale (o «canonico») conservato nel file <filename>/etc/hostname</filename> e comunicato al kernel Linux tramite gli script di inizializzazione attraverso il comando <command>hostname</command>. Il valore corrente è disponibile in un filesystem virtuale e lo si può ottenere con il comando <command>cat /proc/sys/kernel/hostname</command>.
		</para>
		 <indexterm>
			<primary><command>hostname</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> <filename>/proc/</filename> e <filename>/sys/</filename>, filesystem virtuali</title>
		 <indexterm>
			<primary><filename>/proc/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>proc</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/sys/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>sys</filename></primary>
		</indexterm>
		 <para>
			Gli alberi di file <filename>/proc/</filename> e <filename>/sys/</filename> sono generati da filesystem «virtuali». È un modo pratico per recuperare informazioni dal kernel (elencando dei file virtuali) o per comunicare informazioni al kernel (scrivendo sui file virtuali).
		</para>
		 <para>
			<filename>/sys/</filename> in particolar modo è pensato per fornire accesso agli oggetti interni del kernel, specialmente quelli che rappresentano i vari dispositivi di sistema. Il kernel può così condividere diversi frammenti di informazione: lo stato di ogni dispositivo (per esempio se si trova in modalità risparmio energetico), sia se si tratta di un dispositivo removibile, ecc. Notare che <filename>/sys/</filename> ha iniziato ad esistere a partire dalla versione 2.6 del kernel.
		</para>
		 </sidebar> <para>
			Sorprendentemente, il nome del dominio non è gestito allo stesso modo, ma viene ricavato dal nome completo della macchina, acquisito tramite la risoluzione dei nomi. È possibile cambiarlo nel file <filename>/etc/hosts</filename>; si scriva semplicemente un nome completo per la macchina all'inizio della lista di nomi associati all'indirizzo della macchina, come nell'esempio che segue:
		</para>
		 <informalexample> 
<programlisting>
127.0.0.1     localhost
192.168.0.1   arrakis.falcot.com arrakis</programlisting>
		 </informalexample> <indexterm>
			<primary><filename>hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/etc/hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary>dominio</primary>
			<secondary>nome</secondary>
		</indexterm>
		 <indexterm>
			<primary>nome</primary>
			<secondary>del dominio</secondary>
		</indexterm>
		 <indexterm>
			<primary>NSS</primary>
		</indexterm>
		 <section id="sect.name-resolution">
			<title>Risoluzione dei nomi</title>
			 <indexterm>
				<primary>risoluzione</primary>
				<secondary>dei nomi</secondary>
			</indexterm>
			 <indexterm>
				<primary>nomi</primary>
				<secondary>risoluzione</secondary>
			</indexterm>
			 <para>
				Il meccanismo per la risoluzione dei nomi in Linux è modulare e può utilizzare svariate sorgenti di informazione dichiarate nel file <filename>/etc/nsswitch.conf</filename>. L'elemento che coinvolge la risoluzione dei nomi host è <literal>hosts</literal>. Per impostazione predefinita, contiene <literal>dns files</literal>; che significa che il sistema consulta prima di tutto il file <filename>/etc/hosts</filename>, quindi i server DNS. Server NIS/NIS+ o LDAP sono altre possibili sorgenti.
			</para>
			 <sidebar> <title><emphasis>NOTA</emphasis> NSS e DNS</title>
			 <para>
				È bene ricordare che comandi specificatamente intesi per interrogare i DNS (specialmente <command>host</command>) non utilizzano il meccanismo standard per la risoluzione dei nomi (NSS). Conseguentemente non prendono in considerazione <filename>/etc/nsswitch.conf</filename> e, pertanto, nemmeno <filename>/etc/hosts</filename>.
			</para>
			 </sidebar> <section id="sect.dns-server-configuration">
				<title>Configurare i server DNS</title>
				 <indexterm>
					<primary>DNS</primary>
				</indexterm>
				 <indexterm>
					<primary>Domain Name Service</primary>
				</indexterm>
				 <para>
					DNS (Domain Name Service) è un servizio distribuito e gerarchico che mappa i nomi agli indirizzi IP e vice-versa. In particolare converte un nome semplice da utilizzare come <literal>www.eyrolles.com</literal> nell'indirizzo IP corrispondente, <literal>213.244.11.247</literal>.
				</para>
				 <para>
					Per accedere alle informazioni DNS, un server DNS dev'essere disponibile ad inoltrare le richieste. La Falcot ne ha uno proprio, ma un singolo utente utilizzerà probabilmente i server DNS forniti dal proprio provider dei servizi Internet.
				</para>
				 <indexterm>
					<primary><filename>resolv.conf</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><literal>nameserver</literal></primary>
				</indexterm>
				 <para>
					I server DNS da utilizzare sono indicati in <filename>/etc/resolv.conf</filename>, uno per riga, con la parola chiave <literal>nameserver</literal> anteposta all'indirizzo IP, come nell'esempio seguente:
				</para>
				 
<programlisting>
nameserver 212.27.32.176
nameserver 212.27.32.177
nameserver 8.8.8.8</programlisting>
				 <para>
					Si noti che il file <filename>/etc/resolv.conf</filename> può essere gestito automaticamente (e sovrascritto) quando la rete è gestita da NetworkManager o configurata tramite DHCP.
				</para>

			</section>
			 <section id="sect.etc-hosts">
				<title>Il file <filename>/etc/hosts</filename></title>
				 <indexterm>
					<primary><filename>hosts</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/hosts</filename></primary>
				</indexterm>
				 <para>
					Se non esiste un server dei nomi nella rete locale è possibile stabilire una piccola tabella per mappare gli indirizzi IP ai nomi delle macchine nel file <filename>/etc/hosts</filename>, generalmente riservato per le postazioni della rete locale. La sintassi di questo file è molto semplice: ogni linea indica un indirizzo IP seguito dalla lista dei nomi associati (il primo «completamente qualificato», cioè con incluso il nome del dominio).
				</para>
				 <para>
					Questo file è disponibile anche quando la rete non è disponibile o quando i server DNS non sono raggiungibili, ma è realmente utile solo quando viene distribuito su tutte le macchine nella rete. La minima alterazione nelle corrispondenze richiede che il file sia aggiornato ovunque. Ecco perché <filename>/etc/hosts</filename> contiene generalmente solo le voci più importanti.
				</para>
				 <para>
					Questo file è sufficiente per una piccola rete non connessa ad Internet, ma con 5 macchine o più è raccomandato di installare un server DNS.
				</para>
				 <sidebar> <title><emphasis>SUGGERIMENTO</emphasis> Aggirare i DNS</title>
				 <para>
					Poiché le applicazioni controllano il file <filename>/etc/hosts</filename> prima di interrogare i DNS, è possibile includervi informazioni diverse da quelle che il DNS fornirebbe, aggirando di conseguenza la normale risoluzione dei nomi basata sul DNS.
				</para>
				 <para>
					Questo consente, qualora le modifiche DNS non siano ancora propagate, di verificare l'accesso ad un sito con il nome desiderato anche se quest'ultimo non è ancora adeguatamente mappato all'indirizzo IP.
				</para>
				 <para>
					Un altro possibile utilizzo è per reindirizzare il traffico destinato ad uno uno specifico host su un'altra macchina locale, impedendo così qualsiasi comunicazione con l'host dato. Per esempio, i nomi host dei server che inviano banner pubblicitari potrebbero essere deviati per bypassare questi annunci rendendo la navigazione più fluida, meno dispersiva.
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.user-group-databases">
		<title>Database di utenti e gruppi</title>
		 <indexterm>
			<primary>utente</primary>
			<secondary>database</secondary>
		</indexterm>
		 <indexterm>
			<primary>gruppo</primary>
			<secondary>database</secondary>
		</indexterm>
		 <indexterm>
			<primary>database</primary>
			<secondary>degli utenti</secondary>
		</indexterm>
		 <indexterm>
			<primary>database</primary>
			<secondary>dei gruppi</secondary>
		</indexterm>
		 <para>
			La lista degli utenti è generalmente conservata nel file <filename>/etc/passwd</filename>, mentre il file <filename>/etc/shadow</filename> conserva le password cifrate. Entrambi sono file di testo, in un formato relativamente semplice, che può essere letto e modificato con un editor di testo. Ogni utente è elencato su una riga con diversi campi separati dai due punti («<literal>:</literal>»).
		</para>
		 <sidebar> <title><emphasis>NOTA</emphasis> Modificare i file di sistema</title>
		 <para>
			I file di sistema menzionati in questo capitolo sono tutti file di testo semplice, che possono essere modificati con un editor di testo. Considerata la loro importanza per le funzionalità primarie del sistema, è sempre una buona idea prendere precauzioni addizionali quando si modificano questi file di sistema. Prima di tutto, fare sempre una copia o un backup del file di sistema prima di aprirlo o alterarlo. Secondo, sui server o sulle macchine dove più di una persona può avere potenzialmente accesso allo stesso file allo stesso tempo, procedere con ulteriori precauzioni per evitare la corruzione dei file.
		</para>
		 <para>
			Per questo proposito è sufficiente usare il comando <command>vipw</command> per modificare il file <filename>/etc/passwd</filename>, oppure <command>vigr</command> per modificare <filename>/etc/group</filename>. Questi comandi bloccano il file in questione prima di eseguire l'editor di testo ((<command>vi</command> in via predefinita, a meno che la variabile d'ambiente <varname>EDITOR</varname> non sia stata modificata). L'opzione <literal>-s</literal> in questi comandi consente di modificare il file <foreignphrase>shadow</foreignphrase> corrispondente.
		</para>
		 </sidebar> <sidebar> <title><emphasis>FONDAMENTALI</emphasis> crypt, funzione a senso unico</title>
		 <indexterm>
			<primary>crypt</primary>
		</indexterm>
		 <para>
			<command>crypt</command> è una funzione a senso unico che trasforma una stringa <varname>(A)</varname> in un'altra stringa <varname>(B)</varname> in modo tale che <varname>A</varname> non possa essere ricavata da <varname>B</varname>. L'unico modo per identificare <varname>A</varname> è provare tutti i possibili valori, controllando per ognuno se la trasformazione prodotta dalla funzione produce <varname>B</varname> oppure no. Utilizza fino a 8 caratteri come input (stringa <varname>A</varname>) e genera una stringa di 13 caratteri, stampabili ASCII, (stringa <varname>B</varname>).
		</para>
		 </sidebar> <section id="sect.etc-passwd">
			<title>Lista utenti: <filename>/etc/passwd</filename></title>
			 <para>
				Questa è la lista dei campi nel file <filename>/etc/passwd</filename>:
			</para>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/passwd</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>uid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>gid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>GECOS</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>login</literal></primary>
			</indexterm>
			 <itemizedlist>
				<listitem>
					<para>
						login, per esempio <literal>rhertzog</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						password: è una password cifrata con una funzione a senso unico (<command>crypt</command>), basandosi su <literal>DES</literal>, <literal>MD5</literal>, <literal>SHA-256</literal> o <literal>SHA-512</literal>. Il valore speciale "<literal>x</literal>" indica che la password cifrata è conservata in <filename>/etc/shadow</filename>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uid</literal>: numero univoco che identifica ciascun utente;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: numero univoco che identifica il gruppo principale dell'utente (Debian crea in via predefinita un gruppo specifico per ogni utente);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>GECOS</literal>: campo dati che normalmente contiene il nome completo dell'utente;
					</para>

				</listitem>
				 <listitem>
					<para>
						directory di login, assegnata all'utente per conservare i propri file personali (la variabile d'ambiente <varname>$HOME</varname> punta generalmente qui);
					</para>

				</listitem>
				 <listitem>
					<para>
						programma eseguito dopo il login. Questo è generalmente un interprete dei comandi (shell), che dà all'utente carta bianca. Se viene specificato <command>/bin/false</command> (il quale non fa nulla e ritorna immediatamente il controllo), l'utente non può eseguire il login.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> Gruppo Unix</title>
			 <indexterm>
				<primary>gruppo</primary>
			</indexterm>
			 <para>
				Un gruppo Unix è un'entità che include diversi utenti così che possano condividere facilmente file utilizzando il sistema di permessi integrato (avendo esattamente gli stessi privilegi). È anche possibile restringere l'uso di certi programmi ad un gruppo specifico.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-shadow">
			<title>Il file delle password nascoste e cifrate: <filename>/etc/shadow</filename></title>
			 <indexterm>
				<primary><filename>shadow</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/shadow</filename></primary>
			</indexterm>
			 <para>
				Il file <filename>/etc/shadow</filename> contiene i seguenti campi:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						login;
					</para>

				</listitem>
				 <listitem>
					<para>
						password cifrata;
					</para>

				</listitem>
				 <listitem>
					<para>
						diversi campi gestiscono la scadenza della password.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>DOCUMENTAZIONE</emphasis> Formato dei file <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> e <filename>/etc/group</filename></title>
			 <para>
				Questi formati sono documentati nelle seguenti pagine di manuale: <citerefentry><refentrytitle>passwd</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>shadow</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> e <citerefentry><refentrytitle>group</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>.
			</para>
			 </sidebar> <sidebar> <title><emphasis>SICUREZZA</emphasis> La sicurezza del file <filename>/etc/shadow</filename></title>
			 <para>
				<filename>/etc/shadow</filename>, diversamente dal suo alter ego <filename>/etc/passwd</filename>, non può essere letto dai normali utenti. Qualsiasi password cifrata contenuta in <filename>/etc/passwd</filename> è leggibile da chiunque: un cracker potrebbe provare a forzare (o rivelare) una password attraverso diversi metodi a «forza bruta» i quali molto semplicemente provano le combinazioni di caratteri usate comunemente. Questo attacco, chiamato «attacco a dizionario», non è più possibile sui sistemi che utilizzano <filename>/etc/shadow</filename>.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.account-modification">
			<title>Modificare un account o password esistente</title>
			 <indexterm>
				<primary><command>chsh</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chfn</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chage</command></primary>
			</indexterm>
			 <indexterm>
				<primary>password</primary>
			</indexterm>
			 <para>
				I seguenti comandi consentono la modifica delle informazioni conservate in campi specifici dei database utenti: <command>passwd</command> permette ad un utente normale di modificare la propria password, cosa che comporta l'aggiornamento del file <filename>/etc/shadow</filename>. <command>chfn</command> (CHange Full Name), riservato per il super-utente (root), modifica il campo <literal>GECOS</literal>. <command>chsh</command> (CHange SHell) consente all'utente di cambiare la propria shell di login, tuttavia le scelte disponibili sono limitate a quelle elencate in <filename>/etc/shells</filename>: l'amministratore, d'altra parte, non è soggetto a questa restrizione e può impostare la shell a qualsiasi programma scelga.
			</para>
			 <para>
				Infine il comando <command>chage</command> (CHange AGE) consente all'amministratore di cambiare le impostazioni di scadenza della password (l'opzione <literal>-l <replaceable>utente</replaceable></literal> elenca le impostazioni attuali). È possibile inoltre forzare la scandenza di una password utilizzando il comando <command>passwd -e <replaceable>utente</replaceable></command>, il quale richiede all'utente di cambiare la password al prossimo accesso.
			</para>

		</section>
		 <section id="sect.disabling-account">
			<title>Disabilitare un account</title>
			 <indexterm>
				<primary>Disabilitare un account</primary>
			</indexterm>
			 <indexterm>
				<primary>account</primary>
				<secondary>disabilitazione</secondary>
			</indexterm>
			 <para>
				Può rendersi necessario «disabilitare un account» (tagliare fuori un utente) come misura disciplinare, per eseguire delle verifiche o semplicemente in caso di una prolungata o definitiva assenza dell'utente. Un account disabilitato significa che l'utente non potrà fare login o guadagnare accesso alla macchina. L'account rimane intatto nella macchina e né i file né altri dati sono cancellati: sono semplicemente inaccessibili. Questo si ottiene usando il comando <command>passwd -l <replaceable>utente</replaceable></command> (l, per «lock»: blocco). Per riabilitare l'account si utilizza l'opzione <literal>-u</literal> (u, per «unlock»: sblocco).
			</para>
			 <sidebar id="sidebar.intro-nss"> <title><emphasis>APPROFONDIMENTI</emphasis> NSS ed i database di sistema</title>
			 <indexterm>
				<primary>NSS</primary>
			</indexterm>
			 <indexterm>
				<primary>Name Service Switch</primary>
			</indexterm>
			 <para>
				Invece di usare i file tradizionali per gestire le liste di utenti e gruppi, è possibile utilizzare altre tipologie di database, come LDAP o <command>db</command>, utilizzando un modulo NSS (Name Service Switch) appropriato. I moduli utilizzati sono elencati nel file <filename>/etc/nsswitch.conf</filename>, alle voci <literal>passwd</literal>, <literal>shadow</literal> e <literal>group</literal>. Si veda la <xref linkend="sect.config-nss" /> per un esempio specifico circa l'utilizzo di un modulo NSS per LDAP.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-group">
			<title>Lista dei gruppi: <filename>/etc/group</filename></title>
			 <para>
				I gruppi sono elencati nel file <filename>/etc/group</filename>, un semplice database testuale in un formato simile a quello del file <filename>/etc/passwd</filename>, con i seguenti campi:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						nome gruppo;
					</para>

				</listitem>
				 <listitem>
					<para>
						password (opzionale): Questa è utilizzata unicamente per aggiungersi ad un gruppo quando non si è un utente abituale (con i comandi <command>newgrp</command> o <command>sg</command>, si veda il riquadro <xref linkend="sidebar.working-with-several-groups" />);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: numero univoco di identificazione di un gruppo;
					</para>

				</listitem>
				 <listitem>
					<para>
						lista di membri: lista di nomi degli utenti che sono membri del gruppo, separati da virgole.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
			</para>
			 <sidebar id="sidebar.working-with-several-groups"> <title><emphasis>FONDAMENTALI</emphasis> Lavorare con diversi gruppi</title>
			 <indexterm>
				<primary><command>newgrp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sg</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>id</command></primary>
			</indexterm>
			 <indexterm>
				<primary>gruppo</primary>
				<secondary>cambio</secondary>
			</indexterm>
			 <para>
				Ogni utente può essere membro di molti gruppi: uno di questi sarà il suo «gruppo principale». Il gruppo principale di un utente è creato, in via predefinita, durante la configurazione iniziale dell'utente. In via predefinita ogni file che un utente crea gli appartiene, così come viene assegnato al suo gruppo principale. Questo non è sempre desiderabile: per esempio quando l'utente lavora in una directory condivisa da un gruppo diverso dal suo gruppo principale. In questo caso l'utente deve cambiare il proprio gruppo principale usando uno dei seguenti comandi: <command>newgrp</command> che avvia una nuova shell oppure <command>sg</command> che semplicemente esegue comandi usando il gruppo alternativo fornito. Questi comandi consentono inoltre all'utente di unirsi ad un gruppo al quale non appartiene. Se il gruppo è protetto da password avranno bisogno di fornire la password appropriata prima che il comando sia eseguito.
			</para>
			 <para>
				In alternativa, l'utente può impostare il bit <literal>setgid</literal> nella directory, così i file creati in questa directory saranno assegnati automaticamente al gruppo corretto. Per maggiori dettagli, si veda il riquadro <xref linkend="sidebar.setgid-dir" />.
			</para>
			 <para>
				Il comando <command>id</command> visualizza lo stato corrente dell'utente: l'identificativo personale (variabile <varname>uid</varname>), il gruppo principale attuale (variabile <varname>gid</varname>) e la lista dei gruppi ai quali appartiene (variabile <varname>groups</varname>).
			</para>
			 </sidebar> <indexterm>
				<primary><filename>group</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/group</filename></primary>
			</indexterm>
			 <para>
				The <command>addgroup</command> and <command>delgroup</command> commands add or delete a group, respectively. The <command>groupmod</command> command modifies a group's information (its <literal>gid</literal> or identifier). The command <command>gpasswd <replaceable>group</replaceable></command> changes the password for the group, while the <command>gpasswd -r <replaceable>group</replaceable></command> command deletes it.
			</para>
			 <indexterm>
				<primary><command>addgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>delgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>groupmod</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>gpasswd</command></primary>
			</indexterm>
			 <indexterm>
				<primary>gruppo</primary>
				<secondary>creazione</secondary>
			</indexterm>
			 <indexterm>
				<primary>creazione</primary>
				<secondary>di gruppi</secondary>
			</indexterm>
			 <indexterm>
				<primary>gruppo</primary>
				<secondary>cancellazione</secondary>
			</indexterm>
			 <indexterm>
				<primary>cancellazione di un gruppo</primary>
			</indexterm>
			 <sidebar> <title><emphasis>SUGGERIMENTO</emphasis> <command>getent</command></title>
			 <indexterm>
				<primary><command>getent</command></primary>
			</indexterm>
			 <para>
				Il comando <command>getent</command> («get entries»: ottieni le voci) controlla i database di sistema secondo le modalità standard, usando le funzioni di libreria appropriate, che richiamano i moduli NSS configurati nel file <filename>/etc/nsswitch.conf</filename>. Il comando accetta uno o due argomenti: il nome del database da controllare ed una chiave di ricerca opzionale. In questo modo il comando <command>getent passwd rhertzog</command> fornirà informazioni dal database utenti riguardanti l'utente <literal>rhertzog</literal>.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.creating-accounts">
		<title>Creare account</title>
		 <indexterm>
			<primary>account</primary>
			<secondary>creazione</secondary>
		</indexterm>
		 <indexterm>
			<primary>creazione</primary>
			<secondary>di account utente</secondary>
		</indexterm>
		 <para>
			Una delle prime azioni che un amministratore deve fare quando configura una nuova macchina è creare gli account utente. Questo è tipicamente realizzato utilizzando il comando <command>adduser</command> che accetta come argomento un nome utente per il nuovo utente che deve essere creato.
		</para>
		 <indexterm>
			<primary><command>adduser</command></primary>
		</indexterm>
		 <para>
			Il comando <command>adduser</command> presenta alcune domande prima di creare l'account ma il suo utilizzo è piuttosto intuitivo. Il suo file di configurazione, <filename>/etc/adduser.conf</filename>, include tutte le impostazioni interessanti: può essere usato per impostare automaticamente una quota per ogni nuovo utente creando un modello di utente o per cambiare la posizione degli account utente. Quest'ultima impostazione è raramente utile ma diventa pratica quando per esempio si ha un grande numero di utenti e si desidera dividere i loro account in dischi differenti. Inoltre è possibile scegliere una diversa shell predefinita.
		</para>
		 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> Quota</title>
		 <indexterm>
			<primary>quota</primary>
		</indexterm>
		 <para>
			Il termine «quota» si riferisce ad un limite sulle risorse della macchina che un utente è autorizzato ad utilizzare. Frequentemente è riferita allo spazio su disco.
		</para>
		 </sidebar> <para>
			La creazione di un account popola la directory home dell'utente con i contenuti del modello <filename>/etc/skel/</filename>. Quest'ultimo fornisce all'utente un insieme di directory e file di configurazione standard.
		</para>
		 <indexterm>
			<primary>gruppo</primary>
			<secondary>aggiungere un utente</secondary>
		</indexterm>
		 <indexterm>
			<primary>aggiungere un utente ad un gruppo</primary>
		</indexterm>
		 <para>
			In alcuni casi, diventa utile aggiungere un utente ad un gruppo (oltre al suo gruppo "principale" predefinito) per garantirgli permessi addizionali. Per esempio, un utente incluso nel gruppo <emphasis>audio</emphasis> può avere accesso ai dispositivi audio (vedi riquadro <xref linkend="sidebar.special-files" />). Per farlo si può utilizzare un comando come <command>adduser <replaceable>utente</replaceable> <replaceable>gruppo</replaceable></command>.
		</para>
		 <sidebar id="sidebar.special-files"> <title><emphasis>FONDAMENTALI</emphasis> Permessi di accesso ai dispositivi</title>
		 <indexterm>
			<primary>dispositivo</primary>
			<secondary>permessi d'accesso</secondary>
		</indexterm>
		 <indexterm>
			<primary>file</primary>
			<secondary>speciale</secondary>
		</indexterm>
		 <indexterm>
			<primary>modalità</primary>
			<secondary>caratteri</secondary>
		</indexterm>
		 <indexterm>
			<primary>modalità</primary>
			<secondary>blocchi</secondary>
		</indexterm>
		 <indexterm>
			<primary>blocchi, modalità</primary>
		</indexterm>
		 <indexterm>
			<primary>caratteri, modalità</primary>
		</indexterm>
		 <indexterm>
			<primary>speciale, file</primary>
		</indexterm>
		 <indexterm>
			<primary><command>mknod</command></primary>
		</indexterm>
		 <para>
			Ogni dispositivo di periferica hardware è rappresentato su Unix con un file speciale, generalmente conservato nel file system all'interno di <filename>/dev/</filename> (DEVice). Esistono due tipi di file speciali in base alla natura del dispositivo: in modalità a caratteri e in modalità a blocchi. Ogni modalità consente solo un numero limitato di operazioni. La modalità a caratteri limita l'interazione con le operazioni di lettura/scrittura mentre la modalità a blocchi consente anche la ricerca dei dati disponibili. Infine, ogni file speciale è associato a due numeri («maggiore» e «minore») che identificano il dispositivo nel kernel in modo univoco. Questo tipo di file, creato dal comando <command>mknod</command>, contiene semplicemente un nome simbolico (e più pratico).
		</para>
		 <para>
			I permessi di un file speciale mappano ai permessi necessari per accedere al dispositivo stesso. Così, un file come <filename>/dev/mixer</filename>, che rappresenta il mixer audio, concede i permessi di lettura e scrittura solo all'utente root ed ai membri del gruppo <literal>audio</literal>. Solo questi utenti possono azionare il mixer audio.
		</para>
		 <para>
			Va notato che la combinazione di <emphasis role="pkg">udev</emphasis>, <emphasis role="pkg">consolekit</emphasis> e <emphasis role="pkg">policykit</emphasis> può aggiungere ulteriori permessi per consentire agli utenti fisicamente connessi alla console (non attraverso la rete) di avere accesso a certi dispositivi.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.shell-environment">
		<title>Ambiente shell</title>
		 <para>
			Gli interpreti dei comandi (o shell) possono essere il primo punto di contatto dell'utente con il computer, e devono quindi essere piuttosto amichevoli. Molti usano script di inizializzazione che consentono la configurazione del loro comportamento (completamento automatico, testo del prompt, ecc.).
		</para>
		 <indexterm>
			<primary>interfaccia a riga di comando</primary>
		</indexterm>
		 <indexterm>
			<primary>interprete dei comandi</primary>
		</indexterm>
		 <indexterm>
			<primary>shell</primary>
		</indexterm>
		 <indexterm>
			<primary><command>bash</command></primary>
		</indexterm>
		 <para>
			<command>bash</command>, la shell standard, usa lo script di inizializzazione <filename>/etc/bash.bashrc</filename> per shell «interattive» e <filename>/etc/profile</filename> per le shell di «login».
		</para>
		 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> Shell di login e shell (non) interattive</title>
		 <para>
			In termini semplici, una shell di login è invocata quando si esegue il login alla console localmente o da remoto usando <command>ssh</command>, oppure eseguendo il comando esplicito <command>bash --login</command>. Che si tratti di una shell di login oppure no, una shell può essere interattiva (per esempio in un terminale tipo <command>xterm</command>) o non interattiva (quando si esegue uno script).
		</para>
		 </sidebar> <sidebar> <title><emphasis>SCOPERTA</emphasis> Altre shell, altri script</title>
		 <para>
			Each command interpreter has a specific syntax and its own configuration files. Thus, <command>zsh</command> uses <filename>/etc/zshrc</filename> and <filename>/etc/zshenv</filename>; <command>tcsh</command> uses <filename>/etc/csh.cshrc</filename>, <filename>/etc/csh.login</filename> and <filename>/etc/csh.logout</filename>. The man pages for these programs document which files they use.
		</para>
		 <indexterm>
			<primary><command>zsh</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>tcsh</command></primary>
		</indexterm>
		 </sidebar> <para>
			Per quanto riguarda <command>bash</command> è utile attivare il «completamento automatico» nel file <filename>/etc/bash.bashrc</filename> (basta decommentare qualche riga).
		</para>
		 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> Completamento automatico</title>
		 <indexterm>
			<primary>completamento automatico</primary>
		</indexterm>
		 <para>
			Molti interpreti dei comandi forniscono funzionalità di completamento che consentono alla shell di completare automaticamente il nome di comandi parzialmente digitati quando l'utente usa il tasto <keycap>Tab</keycap>. Così gli utenti possono lavorare in modo più efficiente e sono meno soggetti ad errori.
		</para>
		 <para>
			This function is very powerful and flexible. It is possible to configure its behavior according to each command. Thus, the first argument following <command>apt</command> will be proposed according to the syntax of this command, even if it does not match any file (in this case, the possible choices are <literal>install</literal>, <literal>remove</literal>, <literal>upgrade</literal>, etc.).
		</para>
		 </sidebar> <sidebar> <title><emphasis>FONDAMENTALI</emphasis> Il carattere tilde, una scorciatoia per HOME</title>
		 <indexterm>
			<primary>~</primary>
		</indexterm>
		 <indexterm>
			<primary>tilde</primary>
		</indexterm>
		 <para>
			Il carattere tilde è spesso usato per indicare la directory dove punta la variabile d'ambiente <varname>HOME</varname> (è la directory home dell'utente, come <filename>/home/rhertzog/</filename>). Gli interpreti dei comandi realizzano automaticamente la sostituzione: <filename>~/hello.txt</filename> diviene <filename>/home/rhertzog/hello.txt</filename>.
		</para>
		 <para>
			Il carattere tilde consente inoltre di accedere alla directory home di un altro utente. Così <filename>~rmas/bonjour.txt</filename> è sinonimo di <filename>/home/rmas/bonjour.txt</filename>.
		</para>
		 </sidebar> <para>
			Oltre a questi script comuni, ogni utente può creare i propri <filename>~/.bashrc</filename> e <filename>~/.bash_profile</filename> per configurare la propria shell. La modifica più comune riguarda l'aggiunta di alias: sono parole che vengono automaticamente sostituite con l'esecuzione di un comando per rendere più veloce il lancio di tale comando. Per esempio, si può creare l'alias <literal>la</literal> per il comando <command>ls -la | less</command>, così si dovrà digitare semplicemente <command>la</command> per ispezionare i contenuti di una directory in dettaglio.
		</para>
		 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> Variabili d'ambiente</title>
		 <indexterm>
			<primary>ambiente</primary>
			<secondary>variabile d'ambiente</secondary>
		</indexterm>
		 <indexterm>
			<primary>variabile, ambiente</primary>
		</indexterm>
		 <para>
			Le variabili d'ambiente consentono la memorizzazione di impostazioni globali per la shell o per vari altri programmi utilizzati. Sono contestuali (ogni processo ha il suo insieme di variabili d'ambiente) ma ereditabili. Quest'ultima caratteristica offre la possibilità per una shell di login di dichiarare variabili che poi saranno passate a tutti i programmi che esegue.
		</para>
		 </sidebar> <para>
			Impostare le variabili d'ambiente predefinite è un elemento importante per la configurazione della shell. A parte le variabili specifiche di ogni shell, è preferibile inserirle nel file <filename>/etc/environment</filename> poiché viene usato da vari programmi per inizializzare le sessioni shell. Variabili tipicamente definite in questo file sono: <varname>ORGANIZATION</varname> che generalmente contiene il nome dell'azienda o dell'organizzazione, <varname>HTTP_PROXY</varname> che indica l'esistenza e la posizione di un proxy HTTP.
		</para>
		 <sidebar> <title><emphasis>SUGGERIMENTO</emphasis> Tutte le shell configurate allo stesso modo</title>
		 <para>
			Gli utenti desiderano spesso configurare le proprie shell interattive e di login allo stesso modo. Per fare ciò scelgono di interpretare (o «riportare») il contenuto di <filename>~/.bashrc</filename> nel file <filename>~/.bash_profile</filename>. È possibile fare lo stesso con file comuni a tutti gli utenti (richiamando <filename>/etc/bash.bashrc</filename> da <filename>/etc/profile</filename>).
		</para>
		 </sidebar>
	</section>
	 <section id="sect.config-printing">
		<title>Configurazione della stampante</title>
		 <indexterm>
			<primary>configurazione</primary>
			<secondary>stampa</secondary>
		</indexterm>
		 <indexterm>
			<primary>stampa</primary>
			<secondary>configurazione</secondary>
		</indexterm>
		 <para>
			La configurazione della stampante ha generato molti mal di testa sia agli amministratori che agli utenti. Questi mal di testa sono per la maggior parte un ricordo del passato, grazie a <emphasis role="pkg">cups</emphasis>, il server di stampa libero che utilizza il protocollo IPP (Internet Printing Protocol).
		</para>
		 <indexterm>
			<primary>IPP</primary>
		</indexterm>
		 <indexterm>
			<primary>Internet Printing Protocol</primary>
		</indexterm>
		 <indexterm>
			<primary><command>cups</command></primary>
		</indexterm>
		 <para>
			This program is divided over several Debian packages: <emphasis role="pkg">cups</emphasis> is the central print server; <emphasis role="pkg">cups-bsd</emphasis> is a compatibility layer allowing use of commands from the traditional BSD printing system (<command>lpd</command> daemon, <command>lpr</command> and <command>lpq</command> commands, etc.); <emphasis role="pkg">cups-client</emphasis> contains a group of programs to interact with the server (block or unblock a printer, view or delete print jobs in progress, etc.); and finally, <emphasis role="pkg">printer-driver-gutenprint</emphasis> contains a collection of additional printer drivers for <command>cups</command>.
		</para>
		 <indexterm>
			<primary><command>lpr</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpq</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>COMUNITÀ</emphasis> CUPS</title>
		 <indexterm>
			<primary>CUPS</primary>
		</indexterm>
		 <indexterm>
			<primary>Common Unix Printing System</primary>
		</indexterm>
		 <para>
			CUPS (Common Unix Printing System) è un progetto (ed un marchio registrato) gestito dalla Apple, Inc. <ulink type="block" url="http://www.cups.org/" />
		</para>
		 </sidebar> <para>
			Dopo l'installazione di questi diversi pacchetti, <command>cups</command> può essere amministrato facilmente attraverso un'interfaccia web raggiungibile all'indirizzo locale: <literal>http://localhost:631/</literal>. Si possono aggiungere stampanti (incluse quelle di rete), rimuoverle, ed amministrarle. È anche possibile amministrare <command>cups</command> con l'interfaccia grafica fornita dall'ambiente desktop. Infine, c'è anche l'interfaccia grafica <command>system-config-printer</command> (dall'omonimo pacchetto Debian).
		</para>
		 <indexterm>
			<primary><command>cups</command></primary>
			<secondary>amministrazione</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>NOTA</emphasis> Il file obsoleto <filename>/etc/printcap</filename></title>
		 <para>
			<emphasis>cups</emphasis> no longer uses the <filename>/etc/printcap</filename> file, which is now obsolete. Programs that rely upon this file to get a list of available printers will, thus, fail. To avoid this problem, delete this file and make it a symbolic link (see sidebar <xref linkend="sidebar.symbolic-link" />) to <filename>/run/cups/printcap</filename>, which is maintained by <emphasis>cups</emphasis> to ensure compatibility.
		</para>
		 <indexterm>
			<primary><filename>printcap</filename></primary>
		</indexterm>
		 </sidebar>
	</section>
	 <section id="sect.config-bootloader">
		<title>Configurare il bootloader</title>
		 <indexterm>
			<primary>loader</primary>
			<secondary>bootloader</secondary>
		</indexterm>
		 <indexterm>
			<primary>bootloader</primary>
		</indexterm>
		 <para>
			È probabilmente già funzionante ma è sempre meglio sapere come configurare ed installare il bootloader nel caso scompaia dal Master Boot Record. Questo può avvenire dopo l'installazione di un altro sistema operativo, per esempio Windows. Le seguenti informazioni possono anche aiutare a modificare la configurazione del bootloader se necessario.
		</para>
		 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> Master boot record</title>
		 <indexterm>
			<primary>MBR</primary>
		</indexterm>
		 <indexterm>
			<primary>Master Boot Record</primary>
		</indexterm>
		 <para>
			Il Master Boot Record (MBR) occupa i primi 512 byte del primo disco rigido e rappresenta la prima cosa caricata dal BIOS per passare il controllo ad un programma in grado di lanciare il sistema operativo desiderato. Generalmente, il bootloader viene installato nell'MBR, rimuovendo il suo contenuto precedente.
		</para>
		 </sidebar> <section id="sect.identify-disks">
			<title>Identificare i dischi</title>
			 <sidebar> <title><emphasis>CULTURA</emphasis> <emphasis>udev</emphasis> e <filename>/dev/</filename></title>
			 <para>
				La directory <filename>/dev/</filename> ospita tradizionalmente i file cosiddetti "speciali", usati per rappresentare le periferiche del sistema (si veda il riquadro <xref linkend="sidebar.special-files" />). Fino a poco tempo fa, era usato per contenere tutti i file speciali che potevano essere utilizzati. Questo approccio ha avuto una serie di dinconvenienti tra cui il fatto che restringeva il numero di dispositivi che si potevano utilizzare (a causa della lista dei nomi fissa), e che era impossibile sapere quali file speciali erano effettivamente utili.
			</para>
			 <para>
				Al giorno d'oggi, la gestione dei file speciali è completamente dinamica e corrisponde meglio alla natura hot-swap (collegati a caldo) dei dispositivi informatici. Il kernel collabora con <emphasis>udev</emphasis> per creare e cancellare i file come necessario quando i dispositivi corrispondenti vengono collegati e scollegati. Per questo motivo, <filename>/dev/</filename> non ha bisogno di essere persistente ed è quindi un filesystem RAM-based che inizialmente è vuoto e contiene solo le voci adeguate.
			</para>
			 <para>
				Il kernel comunica molte informazioni su qualsiasi dispositivo appena aggiunto ed assegna una coppia di numeri maggiore/minore per identificarlo. Con questo <command>udevd</command> è in grado di creare il file speciali con il nome e le autorizzazioni che vuole. Si può anche creare un alias ed eseguire ulteriori azioni (come l'inizializzazione o la registrazione di attività). Il comportamento di <command>udevd</command> è guidato da un grande insieme di regole (personalizzabili).
			</para>
			 <para>
				Con nomi assegnati dinamicamente, è possibile quindi mantenere lo stesso nome per un dato dispositivo, indipendentemente dal connettore utilizzato o dall'ordine di connessione, che è particolarmente utile quando si utilizzano varie periferiche USB. La prima partizione del primo disco rigido può quindi essere chiamato <filename>/dev/sda1</filename> per retro compatibilità, o <filename>/dev/root-partition</filename> se si preferisce, o addirittura entrambi al stesso tempo dato che <command>udevd</command> può essere configurato per creare automaticamente un link simbolico.
			</para>
			 <para>
				In tempi remoti, alcuni moduli del kernel si caricavano quando si tentava di accedere al file del dispositivo corrispondente. Ora non è più così, ed il file specifico della periferica non esiste prima di caricare il modulo; questo è un grosso problema, dal momento che la maggior parte dei moduli vengono caricati all'avvio grazie al riconoscimento automatico dell'hardware. Ma per le periferiche non rilevabili (come dischi molto vecchi o mouse PS/2), questo non funziona. Bisogna considerare l'aggiunti dei moduli, <literal>floppy</literal>, <literal>psmouse</literal> e <literal>mousedev</literal> a <filename>/etc/modules</filename> per forzare il loro caricamento all'avvio.
			</para>
			 </sidebar> <indexterm>
				<primary>disco rigido, nomi</primary>
			</indexterm>
			 <indexterm>
				<primary>nomi</primary>
				<secondary>dei dischi rigidi</secondary>
			</indexterm>
			 <para>
				La configurazione del bootloader deve identificare i diversi dischi rigidi e le rispettive partizioni. Linux usa speciali file "a blocchi" conservati nella directory <filename>/dev/</filename>, per questo scopo. Sin da Debian <emphasis role="distribution">Squeeze</emphasis>, lo schema dei nomi degli dischi è stato unificato con il kernel Linux, e tutti i dischi rigidi (IDE/PATA, SATA, SCSI, USB, IEEE 1394) sono ora rappresentati da <filename>/dev/sd*</filename>.
			</para>
			 <para>
				Ogni partizione è rappresentata dal suo numero sul disco che la ospita: per esempio <filename>/dev/sda1</filename> è la prima partizione nel primo disco e <filename>/dev/sdb3</filename> è la terza partizione nel secondo disco.
			</para>
			 <indexterm>
				<primary>partizione</primary>
				<secondary>primaria</secondary>
			</indexterm>
			 <indexterm>
				<primary>partizione</primary>
				<secondary>estesa</secondary>
			</indexterm>
			 <indexterm>
				<primary>partizione</primary>
				<secondary>secondaria</secondary>
			</indexterm>
			 <indexterm>
				<primary>tabella partizione</primary>
				<secondary>formato MS-DOS</secondary>
			</indexterm>
			 <para>
				L'architettura PC (o "i386", compreso il cugino più giovane "amd64") è stata a lungo limitata dall'uso della tabella delle partizioni "MS-DOS", che permetteva solo quattro partizioni "primarie" per disco. Per superare la limitazione di questo schema, una di esse deve essere creata come partizione "estesa", e può così contenere partizione "secondarie" aggiuntive. Queste partizioni secondarie sono numerate a partire da 5. Così la prima partizione secondaria potrebbe essere <filename>/dev/sda5</filename>, seguita da <filename>/dev/sda6</filename>, etc.
			</para>
			 <para>
				Un'altra limitazione del formato della tabella di partizione MS-DOS è che permette solo dischi fino a 2Tb di dimensione, che sta diventando un vero problema con i dischi più recenti.
			</para>
			 <indexterm>
				<primary>GPT</primary>
				<secondary>formato tabella partizioni</secondary>
			</indexterm>
			 <indexterm>
				<primary>tabella partizione</primary>
				<secondary>formato GPT</secondary>
			</indexterm>
			 <para>
				Un nuovo formato della tabella di partizione denominato GPT allenta questi vincoli sul numero di partizioni (permette fino a 128 partizioni utilizzando le impostazioni standard) e sulle dimensioni dei dischi (fino a 8 ZiB, che sono più di 8 miliardi terabyte). Se avete intenzione di creare molte partizioni fisiche sullo stesso disco, è pertanto necessario assicurarsi di creare una tabella delle partizioni in formato GPT quando si partiziona il disco.
			</para>
			 <para>
				Non è sempre semplice ricordare quale disco è connesso a quale controller SATA o alla terza posizione nella catena SCSI, specialmente dato che la denominazione dei dischi rigidi collegati a caldo (che include tra gli altri la maggior parte dei dischi SATA e i dischi esterni) può cambiare tra un avvio e l'altro. Fortunatamente <command>udev</command> crea in aggiunta a <filename>/dev/sd*</filename> dei collegamenti simbolici con un nome fisso che è possibile usare se si desidera identificare un disco rigido in modo non ambiguo. Questi collegamenti simbolici sono conservati in <filename>/dev/disk/by-id</filename>. In una macchina con due dischi fisici, per esempio, si potrebbe trovare questo:
			</para>
			 
<screen><computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l
</userinput><computeroutput>total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </computeroutput></screen>
			 <para>
				Si noti che alcuni dischi sono elencati più volte (poiché agiscono simultaneamente come dischi ATA e dischi SCSI), ma l'informazione rilevante principale è il modello ed il numero seriale dei dischi grazie ai quali si può individuare il file periferica.
			</para>
			 <para>
				I file di configurazione d'esempio che si trovano nelle sezioni seguenti sono basati sulla stessa configurazione: un singolo disco SATA, dove la prima partizione è una vecchia installazione Windows e la seconda contiene Debian GNU/Linux.
			</para>

		</section>
		 <section id="sect.config-lilo">
			<title>Configurare LILO</title>
			 <indexterm>
				<primary>LILO</primary>
			</indexterm>
			 <indexterm>
				<primary>Linux Loader</primary>
			</indexterm>
			 <para>
				<emphasis>LILO</emphasis> (LInux LOader) è il bootloader più vecchio: solido ma grezzo. Scrive l'indirizzo fisico del kernel da lanciare nell'MBR, per questo ogni aggiornamento di LILO (o dei suoi file di configurazione) dev'essere seguito dal comando <command>lilo</command>. Dimenticarsi di farlo impedisce al sistema di avviarsi se il vecchio kernel è stato rimosso o sostituito dato che quello nuovo non sarà nella stessa posizione sul disco.
			</para>
			 <para>
				Il file di configurazione di LILO è <filename>/etc/lilo.conf</filename>: un file semplice per configurazioni standard è presentato nell'esempio che segue.
			</para>
			 <example id="example.lilo.conf">
				<title>File di configurazione di LILO</title>
				 
<programlisting>
# Il disco dove LILO dev'essere installato.
# Indicando il disco e non la partizione.
# ordiniamo a LILO di installarsi nell'MBR.
boot=/dev/sda
# la partizione che contiene Debian
root=/dev/sda2
# l'oggetto da caricare in via predefinita
default=Linux

# la più recente immagine kernel
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Vecchio kernel (in caso il nuovo kernel non parta)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# solo per il doppio avvio Linux/Windows
other=/dev/sda1
  label=Windows</programlisting>

			</example>

		</section>
		 <section id="sect.config-grub">
			<title>Configurazione di GRUB 2</title>
			 <indexterm>
				<primary>GRUB</primary>
			</indexterm>
			 <indexterm>
				<primary>GRUB 2</primary>
			</indexterm>
			 <para>
				<emphasis>GRUB</emphasis> (GRand Unified Bootloader) è più recente. Non è necessario lanciarlo dopo ogni aggiornamento del kernel: <emphasis>GRUB</emphasis> sa come leggere i filesystem e trovare la posizione del kernel nel disco autonomamente. Per installarlo nell'MBR del primo disco è sufficiente digitare <command>grub-install /dev/sda</command>. <indexterm><primary><command>grub-install</command></primary></indexterm>
			</para>
			 <sidebar> <title><emphasis>NOTA</emphasis> Nomi dei dischi per GRUB</title>
			 <para>
				GRUB può identificare i dischi rigidi solo in base alle informazioni fornite dal BIOS. <literal>(hd0)</literal> corrisponde al primo disco così individuato, <literal>(hd1)</literal> al secondo, ecc. In molti casi questo ordine corrisponde esattamente al normale ordine dei dischi su Linux, ma dei problemi possono verificarsi se si associano dischi IDE e SCSI. GRUB conserva le corrispondenze che trova nel file <filename>/boot/grub/device.map</filename>. Se qui si individuano errori (perché è noto che il proprio BIOS individua i dischi in un ordine differente) è possibile correggerli manualmente ed eseguire <command>grub-install</command> nuovamente. <command>grub-mkdevicemap</command> può aiutare la creazione di un file <filename>device.map</filename> da cui iniziare.
			</para>
			 <para>
				Le partizioni hanno inoltre un nome specifico in GRUB. Quando si usano partizioni «classiche» nel formato MS-DOS, la prima partizione nel primo disco è etichettata <literal>(hd0,msdos1)</literal>, la seconda <literal>(hd0,msdos2)</literal>, ecc.
			</para>
			 </sidebar> <para>
				GRUB 2 configuration is stored in <filename>/boot/grub/grub.cfg</filename>, but this file (in Debian) is generated from others. Be careful not to modify it by hand, since such local modifications will be lost the next time <command>update-grub</command> is run (which may occur upon update of various packages). The most common modifications of the <filename>/boot/grub/grub.cfg</filename> file (to add command line parameters to the kernel or change the duration that the menu is displayed, for example) are made through the variables in <filename>/etc/default/grub</filename>. To add entries to the menu, you can either create a <filename>/boot/grub/custom.cfg</filename> file or modify the <filename>/etc/grub.d/40_custom</filename> file. For more complex configurations, you can modify other files in <filename>/etc/grub.d</filename>, or add to them; these scripts should return configuration snippets, possibly by making use of external programs. These scripts are the ones that will update the list of kernels to boot: <filename>10_linux</filename> takes into consideration the installed Linux kernels; <filename>20_linux_xen</filename> takes into account Xen virtual systems, and <filename>30_os-prober</filename> lists other operating systems (Windows, OS X, Hurd).
			</para>

		</section>
		 <section id="sect.config-yaboot">
			<title>Per i computer Macintosh (PowerPC): configurare Yaboot</title>
			 <indexterm>
				<primary><command>yaboot</command></primary>
			</indexterm>
			 <para>
				Yaboot è il bootloader usato dai vecchi computer Macintosh che usano processori PowerPC. Questi non si avviano come i PC, ma si affidano ad una partizione di «bootstrap» da cui il BIOS (o OpenFirmware) esegue il bootloader e dove il programma <command>ybin</command> installa <command>yaboot</command> e il suo file di configurazione. Sarà necessario eseguire questo comando ogni qual volta <filename>/etc/yaboot.conf</filename> viene modificato (viene duplicato sulla partizione di bootstrap e <command>yaboot</command> sa come trovare la posizione dei kernel sui dischi).
			</para>
			 <para>
				Prima di eseguire <command>ybin</command> si deve avere un file <filename>/etc/yaboot.conf</filename> valido. Quello che segue è un esempio di configurazione minimale. <indexterm><primary><command>ybin</command></primary></indexterm>
			</para>
			 <example id="example.yaboot.conf">
				<title>File di configurazione di Yaboot</title>
				 
<programlisting>
# partizione di bootstrap
boot=/dev/sda2
# il disco
device=hd:
# la partizione Linux
partition=3
root=/dev/sda3
# avvia dopo 3 secondi di inattività
# (timeout in 30 decimi di secondo)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# ultimo kernel installato
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# vecchio kernel
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# solo per doppio avvio Linux/Mac OSX
macosx=/dev/sda5

# bsd=/dev/sdaX and macos=/dev/sdaX
# è inoltre possibile</programlisting>

			</example>

		</section>

	</section>
	 <section id="sect.config-misc">
		<title>Altre configurazioni: Sincronizzazione Ora, Log, Condivisione dell'accesso…</title>
		 <para>
			È bene conoscere i molti elementi elencati in questa sezione per chiunque voglia padroneggiare tutti gli aspetti di configurazione di un sistema GNU/Linux. Tuttavia sono trattati brevemente e i riferimenti alla documentazione sono frequenti.
		</para>
		 <section id="sect.timezone">
			<title>Fuso orario</title>
			 <indexterm>
				<primary>fuso orario</primary>
			</indexterm>
			 <sidebar id="sidebar.symbolic-link"> <title><emphasis>FONDAMENTALI</emphasis> Collegamenti simbolici</title>
			 <indexterm>
				<primary>simbolico</primary>
				<secondary>collegamento</secondary>
			</indexterm>
			 <indexterm>
				<primary>collegamento simbolico</primary>
			</indexterm>
			 <indexterm>
				<primary><command>ln</command></primary>
			</indexterm>
			 <para>
				Un collegamento simbolico è un puntatore ad un altro file. Quando vi si accede viene aperto il file al quale punta. Rimuovere il collegamento non causa la rimozione del file a cui punta. Allo stesso modo non dispone di un proprio insieme di permessi mentre mantiene i permessi del file a cui punta. Infine può puntare a qualsiasi tipo di file: directory, file speciali (socket, pipe con nome, file di device, ecc.), anche ad altri collegamenti simbolici.
			</para>
			 <para>
				Il comando <command>ln -s <replaceable>destinazione</replaceable> <replaceable>nome-collegamento</replaceable></command> crea un collegamento simbolico chiamato <replaceable>nome-collegamento</replaceable> che punta a <replaceable>destinazione</replaceable>.
			</para>
			 <para>
				Se il file a cui punta non esiste, allora il collegamento è «interrotto» e tentare di accedervi causerà un errore che indica l'assenza del file di destinazione. Se il collegamento punta ad un altro collegamento si avrà una «catena» di collegamenti che diviene un «ciclo» se una delle destinazioni punta ad uno dei predecessori. In questo caso, accedere ad uno dei collegamenti nel ciclo, causerà un errore specifico («too many levels of symbolic links» ovvero troppi livelli di collegamenti simbolici): questo significa che il kernel ha rinunciato dopo alcuni giri nel ciclo.
			</para>
			 </sidebar> <para>
				Il fuso orario, configurato durante l'installazione iniziale, è un elemento di configurazione per il pacchetto <emphasis role="pkg">tzdata</emphasis>. Per modificarlo, usare il comando <command>dpkg-reconfigure tzdata</command>, che consente di scegliere il fuso orario da utilizzare in maniera interattiva. La rispettiva configurazione è conservata nel file <filename>/etc/timezone</filename>. Inoltre, il file corrispondente nella directory <filename>/usr/share/zoneinfo</filename> viene copiato in <filename>/etc/localtime</filename>: questo file contiene le regole per determinare i giorni in cui l'ora legale è attiva, per i paesi che la utilizzano.
			</para>
			 <indexterm>
				<primary><filename>fuso orario</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>zoneinfo</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/usr/share/zoneinfo/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>DST</primary>
			</indexterm>
			 <indexterm>
				<primary>ora legale</primary>
			</indexterm>
			 <para>
				Quando si necessita di cambiare temporaneamente il fuso orario si può utilizzare la variabile d'ambiente <varname>TZ</varname> che ha priorità rispetto alla configurazione predefinita di sistema:
			</para>
			 <indexterm>
				<primary><varname>TZ</varname></primary>
			</indexterm>
			 
<screen id="screen.tz">
<computeroutput>$ </computeroutput><userinput>date</userinput>
<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>
<computeroutput>$ </computeroutput><userinput>TZ="Pacific/Honolulu" date</userinput>
<computeroutput>Thu Feb 19 00:25:21 HST 2015</computeroutput></screen>
			 <sidebar> <title><emphasis>NOTA</emphasis> Orologio di sistema, orologio hardware</title>
			 <para>
				Vi sono due sorgenti per il tempo nel computer. La scheda madre del computer ha un orologio hardware, chiamato "orologio CMOS". Questo orologio non è molto preciso e fornisce tempi d'accesso lenti. Il kernel del sistema operativo ne ha uno proprio, l'orologio software, che mantiene aggiornato con i propri mezzi (eventualmente con l'aiuto dei time server, si veda la <xref linkend="sect.time-synchronization" />). Questo orologio di sistema è generalmente più accurato, specialmente perché non deve accedere alle variabili hardware. Tuttavia, poiché esiste unicamente in memoria, viene azzerato ogni volta che la macchina viene avviata, contrariamente all'orologio CMOS, che è dotato di una batteria che gli consente di "«sopravvivere" ai riavvi o agli arresti della macchina. Così l'orologio di sistema viene impostato dall'orologio CMOS durante l'avvio mentre l'orologio CMOS viene aggiornato allo spegnimento (per prendere in considerazione possibili modifiche o correzioni se era regolato impropriamente).
			</para>
			 <para>
				In pratica c'è un problema perché l'orologio CMOS non è nulla più di un contatore che non contiene informazioni circa il fuso orario. Vi è una scelta da fare riguardo questa interpretazione: o il sistema considera che si configurato nell'orario universale (UTC, precedemente GMT), oppure in orario locale. Questa scelta può sembrare semplice ma le cose sono in verità più complicate: come risultato dell'ora legale questo sfasamento non è costante. Il risultato è che il sistema non ha modo di determinare se lo sfasamento è corretto, specialmente nei periodi del cambio. Poiché è sempre possibile ricostruire l'orario locale dal tempo universale e le informazioni sul fuso orario, raccomandiamo fortemente di utilizzare l'orologio CMOS con l'orario universale.
			</para>
			 <para>
				Sfortunatamente, i sistemi Windows per impostazione predefinita ignorano questa raccomandazione; mantengono l'orologio CMOS all'ora locale, applicando le modifiche quando avviano il computer tentando di indovinare durante i cambiamenti d'orario se la modifica è già stata applicata oppure no. Questo funziona relativamente bene, finché il sistema usa unicamente Windows. Ma quando un computer utilizza diversi sistemi (per esempio in una configurazione "dual-boot" o quando esegue altri sistemi in macchine virtuali), si genera confusione, senza modo alcuno di determinare se l'ora è corretta. Se si deve assolutamente mantenere Windows in un computer, si dovrebbe configurarlo per mantenere l'orologio CMOS in UTC (impostando la chiave di registro <literal>HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</literal> a “1” come DWORD), o usare <command>hwclock --localtime --set</command> sul sistema Debian per impostare l'orologio hardware e tenere traccia dell'ora locale (ed assicurarsi di controllare manualmente il proprio orologio in primavera ed autunno).
			</para>
			 </sidebar>
		</section>
		 <section id="sect.time-synchronization">
			<title>Sincronizzazione del tempo</title>
			 <indexterm>
				<primary>sincronizzazione del tempo</primary>
			</indexterm>
			 <indexterm>
				<primary>orologio</primary>
				<secondary>sincronizzazione</secondary>
			</indexterm>
			 <para>
				La sincronizzazione del tempo, che può sembrare superflua in un computer, è molto importante in una rete. Poiché gli utenti non hanno permessi per poter modificare data ed ora è importante che questa informazione sia precisa per evitare confusione. Inoltre, avere tutti i computer sincronizzati sulla rete permette di ottenere comparazioni migliori tra le informazioni dei log sulle varie macchine. Così, in caso di attacco, è più semplice ricostruire la sequenza cronologica delle azioni sulle varie macchine interessate dalla compromissione. I dati raccolti sulle varie macchine per propositi statistici avrebbero hanno un gran senso se non fossero sincronizzati.
			</para>
			 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> NTP</title>
			 <indexterm>
				<primary>NTP</primary>
			</indexterm>
			 <indexterm>
				<primary>Network</primary>
				<secondary>Time Protocol</secondary>
			</indexterm>
			 <para>
				L'NTP (Network Time Protocol) consente alla macchina di sincronizzarsi con altri in modo piuttosto accurato, prendendo in considerazione i ritardi introdotti dal trasferimento delle informazioni attraverso la rete ed altri possibili sfasamenti.
			</para>
			 <para>
				Mentre ci sono numerosi server NTP su Internet, i più popolari possono essere sovraccarichi. Ecco perché raccomandiamo di usare il server NTP <emphasis>pool.ntp.org</emphasis> che è, in realtà, un gruppo di macchine che hanno accettato di agire come server NTP pubblici. È sempre possibile limitare l'uso ad un sotto-gruppo specifico ad un paese, per esempio con <emphasis>us.pool.ntp.org</emphasis> per gli Stati Uniti o <emphasis>ca.pool.ntp.org</emphasis> per il Canada, ecc.
			</para>
			 <para>
				Tuttavia, se si gestisce una grande rete, si raccomanda di installare un proprio server NTP, che si sincronizzerà con i server pubblici. In questo caso tutte le altre macchine sulla rete potranno usare il server NTP interno anziché incrementare il carico sui server pubblici. Inoltre si aumenterà l'omogeneità dei propri orologi poiché tutte le macchine saranno sincronizzate dalla stessa sorgente e questa sorgente sarà generalmente molto vicina in termini di tempo di trasferimento di rete.
			</para>
			 </sidebar> <section id="sect.ntp-on-workstations">
				<title>Per le postazioni di lavoro</title>
				 <para>
					Poiché le postazioni di lavoro sono regolarmente riavviate (anche solo per risparmiare energia) sincronizzarle con NTP all'avvio è sufficiente. Per farlo si può installare il pacchetto <emphasis role="pkg">ntpdate</emphasis>. Se è necessario bisogna cambiare il server NTP usato modificando il file <filename>/etc/default/ntpdate</filename>.
				</para>
				 <indexterm>
					<primary><filename>ntpdate</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/default/ntpdate</filename></primary>
				</indexterm>

			</section>
			 <section id="sect.ntp-on-servers">
				<title>Per i server</title>
				 <para>
					I server sono riavviati raramente ed è estremamente importante che il loro tempo di sistema sia corretto. Per mantenere costantemente corretto il tempo si dovrebbe installare un server NTP locale, un servizio offerto dal pacchetto <emphasis role="pkg">ntp</emphasis>. Nella configurazione predefinita il server si sincronizza con <emphasis>pool.ntp.org</emphasis> e fornisce il tempo in risposta alle richieste che arrivano dalla rete locale. È possibile configurarlo modificando il file <filename>/etc/ntp.conf</filename> e la modifica più significativa riguarda il cambio dei server NTP a cui fa riferimento. Se la rete ha molti server può essere interessante avere un server del tempo locale che si sincronizza con i server pubblici e viene usato come sorgente del tempo dagli altri server nella rete.
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">ntp</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary>server</primary>
					<secondary>NTP</secondary>
				</indexterm>
				 <indexterm>
					<primary>NTP</primary>
					<secondary>server</secondary>
				</indexterm>
				 <sidebar> <title><emphasis>APPROFONDIMENTI</emphasis> Moduli GPS e altre sorgenti del tempo</title>
				 <indexterm>
					<primary>GPS</primary>
				</indexterm>
				 <indexterm>
					<primary>DCF-77</primary>
				</indexterm>
				 <para>
					Se la sincronizzazione del tempo è particolarmente cruciale per una rete è possibile equipaggiare un server con un modulo GPS (che utilizzerà il tempo fornito dai satelliti GPS) o un modulo DCF-77 (che sincronizzerà il tempo con l'orologio atomico vicino a Francoforte, Germania). In questo caso la configurazione del server NTP è un po' più complicata e si rente assolutamente necessaria la consultazione della documentazione prima di procedere.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.rotation-logs">
			<title>Ruotare i file di log</title>
			 <indexterm>
				<primary>file</primary>
				<secondary>log, rotazione</secondary>
			</indexterm>
			 <indexterm>
				<primary>log</primary>
				<secondary>file, rotazione</secondary>
			</indexterm>
			 <indexterm>
				<primary>rotazione dei file di log</primary>
			</indexterm>
			 <indexterm>
				<primary><command>logrotate</command></primary>
			</indexterm>
			 <para>
				I file di log crescono, velocemente, ed è necessario archiviarli. Lo schema più comune è «ruotare» gli archivi: i file log vengono regolarmente archiviati e solo gli ultimi <replaceable>X</replaceable> archivi vengono mantenuti. <command>logrotate</command>, il programma responsabile di queste rotazioni, segue le direttive specificate nel file <filename>/etc/logrotate.conf</filename> ed in tutti i file all'interno della directory <filename>/etc/logrotate.d/</filename>. L'amministratore può modificare questi file, se desidera adattare le politiche di rotazione definite da Debian. La pagina di manuale <citerefentry><refentrytitle>logrotate</refentrytitle>
				 <manvolnum>1</manvolnum></citerefentry> descrive tutte le opzioni disponibili per questi file di configurazione. Si potrebbe desiderare l'incremento del numero di file mantenuti nella rotazione dei log oppure spostare i file di log in una directory dedicata specifica per archiviarli anziché cancellarli. I log si possono anche inviare via email per archiviarli in altro luogo.
			</para>
			 <para>
				Il programma <command>logrotate</command> viene eseguito giornalmente dal software di programmazione <command>cron</command> (descritto nella <xref linkend="sect.task-scheduling-cron-atd" />).
			</para>

		</section>
		 <section id="sect.sharing-admin-rights">
			<title>Condivisione dei privilegi di amministrazione</title>
			 <indexterm>
				<primary>account</primary>
				<secondary>account dell'amministratore</secondary>
			</indexterm>
			 <indexterm>
				<primary>root</primary>
			</indexterm>
			 <indexterm>
				<primary><command>sudo</command></primary>
			</indexterm>
			 <para>
				Frequentemente diversi amministratori lavorano nella stessa rete. Condividere le password di root non è molto elegante ed apre le porte ad abusi legati all'anonimato che questa condivisione genera. La soluzione a questo problema è il programma <command>sudo</command> che consente a certi utenti di eseguire determinati comandi con privilegi speciali. Nel caso d'uso più comune <command>sudo</command> consente ad un utente fidato di eseguire qualsiasi comando come root. Per farlo l'utente esegue semplicemente <command>sudo <replaceable>comando</replaceable></command> e si autentica utilizzando la propria password personale.
			</para>
			 <para>
				Quando installato, il pacchetto <emphasis role="pkg">sudo</emphasis> concede completi privilegi di root ai membri del gruppo Unix <literal>sudo</literal>. Per delegare questi privilegi, l'amministratore deve usare il comando <command>visudo</command>, che gli consente di modificare il file di configurazione <filename>/etc/sudoers</filename> (ancora una volta, questo esegue l'editor <command>vi</command> o qualsiasi altro editor indicato nella variabile d'ambiente <varname>EDITOR</varname>). Aggiungere una riga con <literal><replaceable>nome-utente</replaceable> ALL=(ALL) ALL</literal> consente all'utente in questione di eseguire qualsiasi comando come root.
			</para>
			 <indexterm>
				<primary><command>visudo</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>sudoers</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/sudoers</filename></primary>
			</indexterm>
			 <para>
				Configurazioni più sofisticate consentono l'autorizzazione solo su specifici comandi per specifici utenti. Tutti i dettagli circa le varie possibilità sono offerti nella pagina di manuale <citerefentry><refentrytitle>sudoers</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry>.
			</para>

		</section>
		 <section id="sect.fstab-mount-points">
			<title>Lista dei punti di mount</title>
			 <indexterm>
				<primary>montaggio, punti di</primary>
			</indexterm>
			 <indexterm>
				<primary>punto di montaggio</primary>
			</indexterm>
			 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> Montare e smontare</title>
			 <para>
				In un sistema tipo Unix come Debian i file sono organizzati in una singola gerarchia ad albero di directory. La directory <filename>/</filename> è chiamata la «directory radice»: tutte le altre directory sono sottodirectory di questa radice. «Montare» è l'azione di includere il contenuto di un dispositivo periferico (spesso un disco rigido) nell'albero generale dei file del sistema. Come conseguenza se si usa un disco rigido separato per conservare i dati personali degli utenti, questo disco dovrà essere «montato» nella directory <filename>/home/</filename>. La radice del filesystem è sempre montata all'avvio dal kernel: altri dispositivi sono spesso montati successivamente durante la sequenza di avvio o manualmente con il comando <command>mount</command>.
			</para>
			 <indexterm>
				<primary><command>mount</command></primary>
			</indexterm>
			 <para>
				Some removable devices are automatically mounted when connected, especially when using the GNOME, Plasma or other graphical desktop environments. Others have to be mounted manually by the user. Likewise, they must be unmounted (removed from the file tree). Normal users do not usually have permission to execute the <command>mount</command> and <command>umount</command> commands. The administrator can, however, authorize these operations (independently for each mount point) by including the <literal>user</literal> option in the <filename>/etc/fstab</filename> file.
			</para>
			 <para>
				Il comando <command>mount</command> può essere usato senza argomenti (visualizza tutti i filesystem montati). I seguenti parametri sono richiesti per montare o smontare un dispositivo. Per la lista completa fare riferimento alle corrispondenti pagine di manuale: <citerefentry><refentrytitle>mount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> e <citerefentry><refentrytitle>umount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry>. Per i casi più semplici la sintassi è altrettanto semplice: per esempio per montare la partizione <filename>/dev/sdc1</filename>, che ha un filesystem ext3, nella directory <filename>/mnt/tmp/</filename> si può semplicemente eseguire <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command>.
			</para>
			 </sidebar> <para>
				Il file <filename>/etc/fstab</filename> fornisce la lista di tutti i possibili montaggi che possono avvenire sia automaticamente all'avvio, sia manualmente per i dispositivi di archiviazione removibili. Ogni punto di montaggio è descritto da una riga con diversi campi separati da spazi: <indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						file system: this indicates where the filesystem to be mounted can be found, it can be a local device (hard drive partition, CD-ROM) or a remote filesystem (such as NFS).
					</para>
					 <para>
						Questo campo è frequentemente sostituito con l'ID univoco del filesystem (che può essere determinato con <command>blkid <userinput>dispositivo</userinput></command>) ed è preceduto da <literal>UUID=</literal>. Questo mette al riparo da un eventuale cambio nel nome del device in caso di aggiunta o rimozione di dischi, o se i dischi vengono individuati in un ordine diverso.
					</para>

				</listitem>
				 <listitem>
					<para>
						punto di montaggio: questa è la posizione nel filesystem locale dove il dispositivo, sistema remoto, o partizione dev'essere montata.
					</para>

				</listitem>
				 <listitem>
					<para>
						tipo: questo campo definisce il filesystem usato sul dispositivo da montare. <literal>ext4</literal>, <literal>ext3</literal>, <literal>vfat</literal>, <literal>ntfs</literal>, <literal>btrfs</literal>, <literal>xfs</literal> sono solo alcuni esempi.
					</para>
					 <sidebar> <title><emphasis>FONDAMENTALI</emphasis> NFS, un filesystem di rete</title>
					 <para>
						NFS è un filesystem di rete: su Linux consente l'accesso trasparente a file remoti includendoli nel filesystem locale.
					</para>
					 </sidebar> <para>
						Una lista completa dei filesystem conosciuti è disponibile nella pagina di manuale <citerefentry><refentrytitle>mount</refentrytitle>
						 <manvolnum>8</manvolnum></citerefentry>. Il valore speciale <literal>swap</literal> è per le partizioni di swap. Il valore speciale <literal>auto</literal> comunica al programma <command>mount</command> di individuare automaticamente il filesystem (cosa particolarmente utile per i lettori e le chiavette USB, poiché ognuna può avere un filesystem diverso dall'altra);
					</para>

				</listitem>
				 <listitem>
					<para>
						opzioni: ne esistono molte, in base al filesystem, e sono documentate nella pagina di manuale <command>mount</command>. Le più comuni sono
					</para>
					 <itemizedlist>
						<listitem>
							<para>
								<literal>rw</literal> o <literal>ro</literal>, significano rispettivamente che il dispositivo può essere montato con i permessi di lettura/scrittura oppure sola lettura.
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>noauto</literal> disattiva il montaggio automatico all'avvio.
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>nofail</literal> permette all'vvio del sistema di procedere anche quando non è presente alcun dispositivo. Assicurasi di abilitare questa opzione per i dischi esterni che potrebbero essere scollegati all'avvio, poichè <command>systemd</command> garantisce che realmente tutti i pinti di mount che devono montati automaticamente siano effettivamente montati prima di lasciare che il processo di avvio continui fino alla fine. Si noti che è possibile combinare questa opzione con <literal>x-systemd.device-timeout=5s</literal> per dire a <command>systemd</command> di aspettare non più di 5 secondi che venga rilevato il dispositivo (si veda <citerefentry><refentrytitle>systemd.mount</refentrytitle>
								<manvolnum>5</manvolnum></citerefentry>).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>user</literal> autorizza tutti gli utenti a montare questo filesystem (un'operazione che sarebbe altrimenti consentita al solo utente root).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>defaults</literal> imposta un insieme di opzioni predefinite: <literal>rw</literal>, <literal>suid</literal>, <literal>dev</literal>, <literal>exec</literal>, <literal>auto</literal>, <literal>nouser</literal> e <literal>async</literal>, ognuna delle quali può essere singolarmente disabilitata dopo <literal>defaults</literal> aggiungendo <literal>nosuid</literal>, <literal>nodev</literal> e così via per bloccare rispettivamente <literal>suid</literal>, <literal>dev</literal> ecc. Aggiungere l'opzione <literal>user</literal> la riattiva, dato che <literal>defaults</literal> include <literal>nouser</literal>.
							</para>

						</listitem>

					</itemizedlist>

				</listitem>
				 <listitem>
					<para>
						dump: this field is almost always set to <literal>0</literal>. When it is <literal>1</literal>, it tells the <command>dump</command> tool that the partition contains data that is to be backed up.
					</para>

				</listitem>
				 <listitem>
					<para>
						pass: this last field indicates whether the integrity of the filesystem should be checked on boot, and in which order this check should be executed. If it is <literal>0</literal>, no check is conducted. The root filesystem should have the value <literal>1</literal>, while other permanent filesystems get the value <literal>2</literal>.
					</para>

				</listitem>

			</itemizedlist>
			 <example id="example.fstab">
				<title>Esempio di file <filename>/etc/fstab</filename></title>
				 
<programlisting>
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
# swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0</programlisting>

			</example>
			 <para>
				L'ultima riga di questo esempio corrisponde ad un filesystem di rete (NFS): la directory <filename>/shared/</filename> sul server <emphasis>arrakis</emphasis> è montata in <filename>/shared/</filename> nella macchina locale. Il formato del file <filename>/etc/fstab</filename> è documentato nella pagina di manuale <citerefentry><refentrytitle>fstab</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>.
			</para>
			 <sidebar> <title><emphasis>APPROFONDIMENTI</emphasis> Montaggio automatico</title>
			 <para>
				systemd is able to manage automount points: those are filesystems that are mounted on-demand when a user attempts to access their target mount points. It can also unmount these filesystems when no process is accessing them any longer.
			</para>
			 <para>
				Like most concepts in systemd, automount points are managed with dedicated units (using the <literal>.automount</literal> suffix). See <citerefentry><refentrytitle>systemd.automount</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> for their precise syntax.
			</para>
			 <indexterm>
				<primary><emphasis>am-utils</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><command>amd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>automount</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>autofs</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>montatore automatico</primary>
			</indexterm>
			 <para>
				Other auto-mounting utilities exist, such as <command>automount</command> in the <emphasis role="pkg">autofs</emphasis> package or <command>amd</command> in the <emphasis role="pkg">am-utils</emphasis>.
			</para>
			 <para>
				Note also that GNOME, Plasma, and other graphical desktop environments work together with <emphasis>udisks</emphasis>, and can automatically mount removable media when they are connected.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.locate-updatedb">
			<title><command>locate</command> e <command>updatedb</command></title>
			 <indexterm>
				<primary><command>locate</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>updatedb</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>mlocate</command></primary>
			</indexterm>
			 <para>
				Il comando <command>locate</command> può trovare la posizione di un file quando se ne conosce solo parte del nome. Fornisce il risultato quasi istantaneamente, poiché consulta un database che conserva la posizione di tutti i file sul sistema; questo database è aggiornato giornalmente dal comando <command>updatedb</command>. Ci sono molte implementazioni del comando <command>locate</command> e Debain ha scelto <emphasis role="pkg">mlocate</emphasis> per il proprio standard di sistema.
			</para>
			 <para>
				<command>mlocate</command> è abbastanza intelligente da restituire solo i file che sono accessibili all'utente che esegue il comando anche se utilizza un database in cui sono presenti tutti i file del sistema (sin dalla sua implementazione <command>updatedb</command> viene eseguito con i privilegi di root). Per una maggiore sicurezza, l'amministratore può utilizzare <varname>PRUNEDPATHS</varname> in <filename>/etc/updatedb.conf</filename> per escludere alcune directory dall'indicizzazione.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-compilation">
		<title>Compilare un kernel</title>
		 <indexterm>
			<primary>compilazione</primary>
			<secondary>di un kernel</secondary>
		</indexterm>
		 <indexterm>
			<primary>kernel</primary>
			<secondary>compilazione</secondary>
		</indexterm>
		 <para>
			I kernel forniti da Debian includono il maggior numero possibile di funzionalità, così come il massimo numero di driver, per coprire lo spettro più ampio di configurazioni hardware esistenti. Ecco perché alcuni utenti preferiscono ricompilare il kernel per includere unicamente ciò di cui necessitano. Ci sono due ragioni per questa scelta. Primo, questo può ottimizzare il consumo di memoria perché il codice del kernel anche se non viene mai utilizzato occupa memoria senza motivo (e non viene mai posto nello spazio di swap, dato che utilizza la vera RAM), cosa che può diminuire le prestazioni complessive del sistema. Inoltre un kernel compilato localmente può anche limitare i rischi di sicurezza poiché solo una frazione del codice del kernel è compilato ed eseguito.
		</para>
		 <sidebar> <title><emphasis>NOTA</emphasis> Aggiornamenti di sicurezza</title>
		 <para>
			Se si sceglie di compilare il proprio kernel, bisogna accettarne le conseguenze: Debian non può assicurare gli aggiornamenti di sicurezza per un kernel personalizzato. Mantenendo il kernel fornito da Debian, si può beneficiare degli aggiornamenti preparati dalla squadra di sicurezza del Progetto Debian.
		</para>
		 </sidebar> <para>
			Ricompilare il kernel è inoltre necessario se si vuole utilizzare certe funzionalità che sono disponibili solo come patch (e non sono incluse nella versione standard del kernel).
		</para>
		 <sidebar> <title><emphasis>ANDARE AVANTI</emphasis> Il Debian Kernel Handbook</title>
		 <indexterm>
			<primary><emphasis role="pkg">debian-kernel-handbook</emphasis></primary>
		</indexterm>
		 <para>
			Le squadre del kernel Debian mantengono “Debian Kernel Handbook (disponibile anche nel pacchetto <emphasis role="pkg">debian-kernel-handbook</emphasis>) offrendo una documentazione completa sulla maggior parte delle operazioni correlate al kernel e su come vengono gestiti i pacchetti ufficiali del kernel Debian. Questo è il primo posto dove si dovrebbe guardare se si ha bisogno di più informazioni rispetto a quelle contenute in questa sezione. <ulink type="block" url="http://kernel-handbook.alioth.debian.org" />
		</para>
		 </sidebar> <section id="sect.kernel-compilation-prerequisites">
			<title>Introduzione e prerequisiti</title>
			 <para>
				Non stupisce che Debian gestisca il kernel sotto forma di pacchetti, diversamente da come i kernel sono stati compilati ed installati tradizionalmente. Poiché il kernel rimane sotto il controllo del sistema di pacchettizazione può essere rimosso in modo pulito, o distribuito su diverse macchine. Inoltre, gli script associati con questi pacchetti automatizzano l'interazione con il bootloader ed il generatore initrd.
			</para>
			 <para>
				I sorgenti originari di Linux contengono tutto il necessario per costruire un pacchetto Debian del kernel. Ma è ancora necessario installare <emphasis role="pkg">build-essential</emphasis> per assicurarsi di avere gli strumenti necessari per costruire un pacchetto Debian. Inoltre, le fasi di configurazione del kernel richiedono il pacchetto <emphasis>libncurses5-dev</emphasis>. Infine, il pacchetto <emphasis>fakeroot</emphasis> consente la creazione del pacchetto Debian senza l'impiego di privilegi di amministratore.
			</para>
			 <sidebar> <title><emphasis>CULTURA</emphasis> I bei vecchi tempi di <emphasis role="pkg">kernel-package</emphasis></title>
			 <indexterm>
				<primary><emphasis role="pkg">kernel-package</emphasis></primary>
			</indexterm>
			 <para>
				Prima che il sistema di compilazione di Linux acquisisse la capacità di costruire pacchetti Debian veri e propri, il metodo consigliato per costruire tali pacchetti era quello di usare <command>make-kpkg</command> dal pacchetto <emphasis role="pkg">kernel-package</emphasis>.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-sources">
			<title>Ottenere i sorgenti</title>
			 <indexterm>
				<primary>Sorgenti del kernel Linux</primary>
			</indexterm>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>sorgenti</secondary>
			</indexterm>
			 <indexterm>
				<primary>sorgente</primary>
				<secondary>del kernel Linux</secondary>
			</indexterm>
			 <para>
				Like anything that can be useful on a Debian system, the Linux kernel sources are available in a package. To retrieve them, just install the <emphasis role="pkg">linux-source-<replaceable>version</replaceable></emphasis> package. The <command>apt search ^linux-source</command> command lists the various kernel versions packaged by Debian. The latest version is available in the <emphasis role="distribution">Unstable</emphasis> distribution: you can retrieve them without much risk (especially if your APT is configured according to the instructions of <xref linkend="sect.apt-mix-distros" />). Note that the source code contained in these packages does not correspond precisely with that published by Linus Torvalds and the kernel developers; like all distributions, Debian applies a number of patches, which might (or might not) find their way into the upstream version of Linux. These modifications include backports of fixes/features/drivers from newer kernel versions, new features not yet (entirely) merged in the upstream Linux tree, and sometimes even Debian specific changes.
			</para>
			 <para>
				The remainder of this section focuses on the 4.9 version of the Linux kernel, but the examples can, of course, be adapted to the particular version of the kernel that you want.
			</para>
			 <para>
				We assume the <emphasis role="pkg">linux-source-4.9</emphasis> package has been installed. It contains <filename>/usr/src/linux-source-4.9.tar.xz</filename>, a compressed archive of the kernel sources. You must extract these files in a new directory (not directly under <filename>/usr/src/</filename>, since there is no need for special permissions to compile a Linux kernel): <filename>~/kernel/</filename> is appropriate.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>
<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-4.9.tar.xz</userinput></screen>
			 <sidebar> <title><emphasis>CULTURA</emphasis> Posizione dei sorgenti del kernel</title>
			 <para>
				Tradizionalmente, i sorgenti del kernel Linux verrebbero posti in <filename>/usr/src/linux/</filename> e questo richiede i permessi di root per la compilazione. Tuttavia, lavorare con i privilegi di amministratore dovrebbe essere evitato quando non è necessario. Esiste un gruppo <literal>src</literal> che consente ai membri di lavorare in questa directory, ma lavorare in <filename>/usr/src/</filename> dovrebbe essere comunque evitato. Mantenendo i sorgenti del kernel in una directory personale si ottiene sicurezza su tutti i fronti: nessun file in <filename>/usr/</filename> sconosciuto al sistema dei pacchetti e nessun rischio che programmi siano ingannati dalla lettura di <filename>/usr/src/linux</filename> quando cercano di ottenere informazioni sul kernel utilizzato.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.config-kernel">
			<title>Configurare il kernel</title>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>configurazione</secondary>
			</indexterm>
			 <indexterm>
				<primary>configurazione</primary>
				<secondary>del kernel</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>.config</filename></primary>
			</indexterm>
			 <para>
				I passi successivi consistono nella configurazione del kernel secondo le proprie necessità. La procedura esatta dipende dagli obiettivi.
			</para>
			 <para>
				Quando si ricompila una versione del kernel più recente (eventualmente con patch aggiuntive) la configurazione sarà probabilmente mantenuta più simile possibile a quella proposta da Debian. In questo caso, e piuttosto di riconfigurare tutto da zero, è sufficiente copiare il file <filename>/boot/config-<replaceable>versione</replaceable></filename> (la versione è quella del kernel correntemente in uso, che può essere trovato con il comando <command>uname -r</command>) in un file <filename>.config</filename> nella directory contenente i sorgenti del kernel.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cp /boot/config-4.9.0-3-amd64 ~/kernel/linux-source-4.9/.config</userinput></screen>
			 <para>
				Se non si necessita di cambiare la configurazione, è possibile fermarsi qui e saltare alla <xref linkend="sect.kernel-build" />. Se invece è necessario modificarla, o se si è deciso di riconfigurare tutto da zero, è necessario prendersi del tempo per configurare il kernel. Ci sono varie interfacce dedicate nella directory dei sorgenti del kernel che possono essere richiamate utilizzando il comando <command>make <replaceable>target</replaceable></command>, dove <replaceable>target</replaceable> sarà uno dei valori descritti di seguito.
			</para>
			 <para>
				<command>make menuconfig</command> compila ed esegue un'interfaccia testuale (ecco perché è richiesto il pacchetto <emphasis role="pkg">libncurses5-dev</emphasis>) che consente la navigazione tra le opzioni disponibili in una struttura gerarchica. La premendo il tasto <keycap>Spazio</keycap> cambia il valore delle opzioni selezionate, ed <keycap>Invio</keycap> conferma il bottone selezionato in basso sullo schermo; <guibutton>Select</guibutton> rimanda al sotto-menu selezionato; <guibutton>Exit</guibutton> chiude la finestra corrente e torna indietro alla gerarchia, <guibutton>Help</guibutton> visualizzerà informazioni maggiormente dettagliate sul ruolo dell'opzione selezionata. Le frecce consentono di muoversi tra la lista di opzioni ed i bottoni. Per uscire dal programma di configurazione, scegliere <guibutton>Exit</guibutton> dal menu principale. Il programma offrirà di salvare le modifiche effettuate; accettare se si è soddisfatti delle proprie scelte.
			</para>
			 <para>
				Altre interfacce hanno funzioni simili, ma lavorano con interfacce grafiche più moderne: come <command>make xconfig</command> che usa l'interfaccia grafica Qt, e <command>make gconfig</command> che usa GTK+. La prima richiede <emphasis role="pkg">libqt4-dev</emphasis>, mentre quest'ultima dipende da <emphasis role="pkg">libglade2-dev</emphasis> e <emphasis role="pkg">libgtk2.0-dev</emphasis>.
			</para>
			 <para>
				Quando si utilizza una di queste interfacce di configurazione, è sempre una buona idea partire da una configurazione predefinita ragionevole. Il kernel fornisce tali configurazioni in <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename> e si può attivare la configurazione selezionata con un comando come <command>make x86_64_defconfig</command> (in caso di un PC a 64-bit) opuure <command>make i386_defconfig</command> (in caso di un PC a 32-bit).
			</para>
			 <sidebar> <title><emphasis>SUGGERIMENTO</emphasis> Trattare con file obsoleti <filename>.config</filename></title>
			 <para>
				Quando si fornisce un <filename>.config</filename> generato con un'altra (di solito più vecchia) versione del kernel, sarà necessario aggiornarlo.E' possibile farlo con <command>make oldconfig</command>, che farà interattivamente le domande corrispondenti alle nuove opzioni di configurazione. Se si desidera utilizzare la risposta predefinita a tutte le domande è possibile utilizzare il comando <command>make olddefconfig</command>. Con <command>make oldnoconfig</command>, si riterranno negative le risposte a tutte le domande.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-build">
			<title>Compilazione e creazione del pacchetto</title>
			 <indexterm>
				<primary><command>make deb-pkg</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>NOTA</emphasis> Fare pulizia prima di una nuova compilazione</title>
			 <para>
				Se avete già compilato una volta nella directory e volete ricostruire tutto da zero (per esempio perchè si è sostanzialmente modificata la configurazione del kernel), si dovrà eseguire il comando <command>make clean</command> per rimuovere i file compilati. <command>make distclean</command> rimuove anche altri file generati, incluso anche il vostro file <filename>.config</filename>, quindi assicuratevi di eseguire un backup prima.
			</para>
			 </sidebar> <para>
				Una volta che la configurazione del kernel è pronta, un semplice <command>make deb-pkg</command> genererà fino a 5 pacchetti Debian: <emphasis role="pkg">linux-image-<replaceable>versione</replaceable></emphasis> che contiene l'immagine del kernel e dei moduli associati, <emphasis role="pkg">linux-headers-<replaceable>versione</replaceable></emphasis> che contiene i file header necessari per compilare moduli esterni, <emphasis role="pkg">linux-firmware-image-<replaceable>versione</replaceable></emphasis> che contiene i file del firmware necessari per alcuni driver ( questo pacchetto potrebbe mancare quando si genera dai sorgenti del kernel forniti da Debian), <emphasis role="pkg">linux-image-<replaceable>versione</replaceable>-dbg</emphasis> che contiene i simboli di debug per l'immagine del kernel e dei suoi moduli, e <emphasis role="pkg">linux-libc-dev</emphasis> che contiene gli header realtivi ad alcune librerie come GNU glibc.
			</para>
			 <para>
				La <replaceable>versione</replaceable> è definita dalla concatenazione della versione originaria (come definita dalle variabili <literal>VERSION</literal>, <literal>PATCHLEVEL</literal>, <literal>SUBLEVEL</literal> e <literal>EXTRAVERSION</literal> in <filename>Makefile</filename>), del parametro di configurazione <literal>LOCALVERSION</literal>, e della variabile d'ambiente <literal>LOCALVERSION</literal>. La versione del pacchetto riutilizza la stessa stringa della versione con aggiunto un numero di revisione che viene viene incrementato regolarmente (e memorizzata in <filename>.version</filename>), almeno che non si sovrascrive con la variabile d'ambiente <literal>KDEB_PKGVERSION</literal>.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1
</userinput><computeroutput>[...]
$ </computeroutput><userinput>ls ../*.deb
</userinput><computeroutput>../linux-headers-4.9.30-ckt4-falcot_4.9.30-1_amd64.deb
../linux-image-4.9.30-ckt4-falcot_4.9.30-1_amd64.deb
../linux-image-4.9.30-ckt4-falcot-dbg_4.9.30-1_amd64.deb
../linux-libc-dev_4.9.30-1_amd64.deb
</computeroutput></screen>

		</section>
		 <section id="sect.modules-build">
			<title>Compilare moduli esterni</title>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>moduli esterni</secondary>
			</indexterm>
			 <indexterm>
				<primary>moduli</primary>
				<secondary>moduli esterni al kernel</secondary>
			</indexterm>
			 <indexterm>
				<primary><command>dkms</command></primary>
			</indexterm>
			 <para>
				Alcuni moduli sono mantenuti fuori dal kernel ufficiale Linux. Per usarli, è necessario compilarli parallelamente al kernel corrispondente. Alcuni moduli comuni di terze parti sono forniti da Debian in pacchetti dedicati, come <emphasis role="pkg">xtables-addons-source</emphasis> (moduli aggiuntivi per iptables) o <emphasis role="pkg">oss4-source</emphasis> (Open Sound System, alcuni driver audio alternativi).
			</para>
			 <para>
				Questi pacchetti esterni sono molti e variegati e non possiamo elencarli tutti qui: il comando <command>apt-cache search source$</command> può restringere il campo alla chiave di ricerca. Comunque una lista completa non sarebbe particolarmente utile visto che non c'è una ragione particolare per compilare moduli esterni se non quando si sa di averne bisogno. In questi casi la documentazione del dispositivo dettaglia tipicamente i moduli specifici di cui necessita per funzionare su Linux.
			</para>
			 <para>
				Per esempio, diamo un'occhiata al pacchetto <emphasis role="pkg">xtables-addons-source</emphasis>: dopo l'installazione, in <filename>/usr/src/</filename> viene memorizato un file <filename>.tar.bz2</filename> dei sorgenti del modulo. Anche se si potrebbe estrarre manualmente l'archivio tarball e creare il modulo, in pratica si preferisce automatizzare il tutto utilizzando DKMS. La maggior parte dei moduli offrono l'integrazione DKMS nei pacchetti che terminano con il suffisso <literal>-dkms</literal>. Nel nostro caso, l'installazione di <emphasis role="pkg">xtables-addons-dkms</emphasis> è tutto ciò che serve per compilare il modulo del kernel per il kernel corrente a condizione che abbiamo il pacchetto <emphasis role="pkg">linux-headers-*</emphasis> corrispondente al kernel installato. Per esempio, se si utilizza <emphasis role="pkg">linux-image-amd64</emphasis>, si dovrebbe installare anche <emphasis role="pkg">linux-headers-amd64</emphasis>.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>
<computeroutput>
[...]
Setting up xtables-addons-dkms (2.12-0.1) ...
Loading new xtables-addons-2.12 DKMS files...
Building for 4.9.0-3-amd64
Building initial module for 4.9.0-3-amd64
Done.

xt_ACCOUNT:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/4.9.0-3-amd64/updates/dkms/
[...]
DKMS: install completed.
$ </computeroutput><userinput>sudo dkms status</userinput>
<computeroutput>xtables-addons, 2.12, 4.9.0-3-amd64, x86_64: installed
$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>
<computeroutput>filename:       /lib/modules/4.9.0-3-amd64/updates/dkms/xt_ACCOUNT.ko
license:        GPL
alias:          ipt_ACCOUNT
author:         Intra2net AG &lt;opensource@intra2net.com&gt;
description:    Xtables: per-IP accounting for large prefixes
[...]
</computeroutput></screen>
			 <sidebar> <title><emphasis>ALTERNATIVA</emphasis> module-assistant</title>
			 <indexterm>
				<primary><emphasis role="pkg">module-assistant</emphasis></primary>
			</indexterm>
			 <para>
				Prima di DKMS, <emphasis role="pkg">module-assistant</emphasis> è stata la soluzione più semplice per creare e distribuire i moduli del kernel. Può essere ancora utilizzata, in particolare per i pacchetti privi di interìgrazione KDMS: con un semplice comando come <command>module-assistant auto-install xtables-addons</command> (oppure in breve <command>m-a a-i xtables-addons</command>), i moduli sono compilati per il kernel corrente, messi in un nuovo pacchetto Debian, e questo pacchetto installato al volo.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-patch">
			<title>Applicare una patch al kernel</title>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>patch</secondary>
			</indexterm>
			 <indexterm>
				<primary>patch del kernel</primary>
			</indexterm>
			 <para>
				Alcune funzionalità non sono incluse nel kernel standard perché non mature o per un mancato accordo tra il manutentore del codice sorgente ed i manutentori del kernel. Alcune funzionalità possono essere distribuite come patch che chiunque può applicare liberamente ai sorgenti del kernel.
			</para>
			 <para>
				Debian sometimes provides some of these patches in <emphasis role="pkg">linux-patch-*</emphasis> packages but they often don't make it into stable releases (sometimes for the very same reasons that they are not merged into the official upstream kernel). These packages install files in the <filename>/usr/src/kernel-patches/</filename> directory.
			</para>
			 <para>
				Per applicare una o più di queste patch installate utilizzare il comando <command>patch</command> nella directory dei sorgenti, poi avviare la compilazione del kernel come descritto sopra.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-4.9</userinput>
<computeroutput>$ </computeroutput><userinput>make clean</userinput>
<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.1-4.9.11-201702181444.patch.gz | patch -p1</userinput></screen>
			 <para>
				Notare che una patch potrebbe non funzionare con ogni versione del kernel: è possibile che <command>patch</command> fallisca quando la applica ai sorgenti del kernel. Un messaggio d'errore sarà visualizzato e fornirà alcuni dettagli a proposito del fallimento. In questo caso, si deve far riferimento alla documentazione disponibile nel pacchetto Debian della patch (nella directory <filename>/usr/share/doc/linux-patch-*/</filename>). In molti casi il manutentore indica per quali versioni del kernel è stata realizzata la patch.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-installation">
		<title>Installare un kernel</title>
		 <indexterm>
			<primary>installazione</primary>
			<secondary>di un kernel</secondary>
		</indexterm>
		 <indexterm>
			<primary>kernel</primary>
			<secondary>installazione</secondary>
		</indexterm>
		 <section id="sect.kernel-package">
			<title>Funzionalità di pacchetto kernel Debian</title>
			 <indexterm>
				<primary><filename>vmlinuz</filename></primary>
			</indexterm>
			 <para>
				Un pacchetto kernel Debian installa l'immagine del kernel (<filename>vmlinuz-<replaceable>versione</replaceable></filename>), la sua configurazione (<filename>config-<replaceable>versione</replaceable></filename>) e la sua tabella dei simboli (<filename>System.map-<replaceable>versione</replaceable></filename>) in <filename>/boot/</filename>. La tabella dei simboli aiuta gli sviluppatori a comprendere il significato di un messaggio d'errore del kernel; senza di essa, il kernel restituirebbe solo un "oops" (un "oops" del kernel è equivalente ad un difetto di segmentazione nei programmi in spazio utente, in altre parole messaggi generati a seguito della dereferenziazione di un puntatore non valido) che contiene unicamente un indirizzo di memoria numerico, che è un'informazione inutile senza una tabella che relazioni questi indirizzi ai simboli ed ai nomi delle funzioni. Questi moduli sono installati nella directory <filename>/lib/modules/<replaceable>versione</replaceable>/</filename>.
			</para>
			 <para>
				Gli script di configurazione del pacchetto generano automaticamente un'immagine initrd, che è un mini-sistema pensato per essere caricato in memoria (da qui il nome, che sta per "init ramdisk") dal bootloader, e utilizzato dal kernel Linux unicamente per caricare i moduli necessari ad accedere ai dispositivi che contengono il sistema Debian completo (per esempio, i driver per i dischi SATA). Alla fine, gli script di post-installazione aggiornano i collegamenti simbolici <filename>/vmlinuz</filename>, <filename>/vmlinuz.old</filename>, <filename>/initrd.img</filename> e <filename>/initrd.img.old</filename> così che possano puntare, rispettivamente, agli ultimi due kernel installati, così come alle corrispondenti immagini initrd.
			</para>
			 <para>
				La maggior parte di questi task sono scaricati per agganciare script nelle directory <filename>/etc/kernel/*.d/</filename>. Per esempio, l'integrazione con <command>grub</command> si basa su <filename>/etc/kernel/postinst.d/zz-update-grub</filename> e <filename>/etc/kernel/postrm.d/zz-update-grub</filename>per chiamare <command>update-grub</command> quando i kernel sono installati o rimossi.
			</para>

		</section>
		 <section id="sect.kernel-installation-with-dpkg">
			<title>Installare con <command>dpkg</command></title>
			 <para>
				Using <command>apt</command> is so convenient that it makes it easy to forget about the lower-level tools, but the easiest way of installing a compiled kernel is to use a command such as <command>dpkg -i <replaceable>package</replaceable>.deb</command>, where <literal><replaceable>package</replaceable>.deb</literal> is the name of a <emphasis role="pkg">linux-image</emphasis> package such as <filename>linux-image-4.9.30-ckt4-falcot_1_amd64.deb</filename>.
			</para>
			 <para>
				I passi di configurazione descritti in questo capitolo sono base ma funzionano sia per un sistema server sia per una postazione di lavoro e possono essere duplicati massivamente con modalità semi-automatiche. Tuttavia non sono sufficienti per fornire da soli un sistema completamente configurato. Alcune parti necessitano ancora di configurazione, cominciando con i programmi di basso livello conosciuti come «servizi Unix».
			</para>

		</section>

	</section>
</chapter>

