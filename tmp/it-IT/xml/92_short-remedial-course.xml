<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course" lang="it-IT">
	<appendixinfo>
		 <keywordset>
			<keyword>BIOS</keyword>
			 <keyword>Kernel</keyword>
			 <keyword>Unix</keyword>
			 <keyword>Processo</keyword>
			 <keyword>Gerarchia</keyword>
			 <keyword>Comandi Base</keyword>

		</keywordset>

	</appendixinfo>
	 <title>Breve Corso di Recupero</title>
	 <highlights> <para>
		Anche se questo libro si rivolge in primo luogo ad amministratori e "power-user", non vorremmo escludere principianti motivati. Questa appendice sarà quindi un corso intensivo che descrive i concetti fondamentali coinvolti nella gestione di un computer Unix.
	</para>
	 </highlights> <section id="sect.shell-and-basic-commands">
		<title>Shell e Comandi di Base</title>
		 <para>
			Nel mondo Unix, ogni amministratore deve usare la riga di comando, prima o poi; ad esempio, quando il sistema non si avvia correttamente e fornisce solo un modalità di ripristino della riga di comando. Essere in grado di gestire questo tipo di interfaccia, quindi, è una competenza di base di sopravvivenza per queste circostanze.
		</para>
		 <sidebar> <title><emphasis>RAPIDO SGUARDO</emphasis> Avvio dell'interprete dei comandi</title>
		 <para>
			Un ambiente a riga di comando può essere eseguito dal desktop grafico, tramite un'applicazione conosciuta come "terminale". In GNOME, è possibile avviarlo dall'overview "Attività" (che si attiva portando il puntatore del mouse nell'angolo in alto a sinistra dello schermo), digitando la prima lettera del nome dell'applicazione. In KDE, si trova nel menu <menuchoice><guimenu>K</guimenu> <guisubmenu>Applicazioni</guisubmenu> <guisubmenu>Sistema</guisubmenu></menuchoice>.
		</para>
		 </sidebar> <para>
			Questa sezione da solo un rapido sguardo ai comandi. Tutti hanno molte opzioni qui non descritte, quindi per favore fare riferimento all'abbondante documentazione nelle loro rispettive pagine di manuale.
		</para>
		 <section>
			<title>Navigazione nell'Albero delle Directory e Gestione dei File</title>
			 <para>
				Una volta aperta la sessione, il comando <command>pwd</command> (che sta per directory del lavoro di stampa <emphasis>print working directory</emphasis>) visualizza la posizione corrente nel filesystem. La directory corrente viene cambiata con il comando <command>cd <replaceable>directory</replaceable></command> (<command>cd</command> sta per cambia directory <emphasis>change directory</emphasis>). La directory superiore è sempre chiamata <literal>..</literal> (due punti), mentre la directory corrente è conosciuta anche come <literal>.</literal> (un punto). Il comando The <command>ls</command> permette di elencare <emphasis>listing</emphasis> il contenuto di una directory. Se non viene passato nessun parametro, opera nella directory corrente.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/marco
$ </computeroutput><userinput>cd Scrivania</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/marco/Scrivania
$ </computeroutput><userinput>cd .</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/marco/Scrivania
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/marco
$ </computeroutput><userinput>ls</userinput>
<computeroutput>Immagini Modelli Pubblici Scrivania 
Documenti Musica Scaricati Video</computeroutput>
</screen>
			 <para>
				Una direcory può essere creata con <command>mkdir <replaceable>directory</replaceable></command>, ed una directory esistente (vuota) può essere rimossa con <command>rmdir <replaceable>directory</replaceable></command>. Il comando <command>mv</command> permette lo <emphasis>spostamento (moving)</emphasis> e/o di rinominare file e directory; la <emphasis>rimozione (removing)</emphasis> di un file è effettuata con <command>rm <replaceable>file</replaceable></command>.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Immagini    Modelli  Pubblici Scrivania  Documenti
Musica  Scaricati      Video    test
$ </computeroutput><userinput>mv test new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Immagini    Modelli  new       Scaricati     Video
Documenti  Musica      Pubblici  Scrivania
$ </computeroutput><userinput>rmdir new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Immagini    Modelli  Pubblici  Scrivania  Documenti
Musica  Scaricati      Video</computeroutput>
</screen>

		</section>
		 <section>
			<title>Visualizzazione e Modifica dei File di Testo</title>
			 <para>
				Il comando <command>cat <replaceable>file</replaceable></command> (destinato a <emphasis>concatenare</emphasis> file al dispositivo di output standard) legge un file e ne visualizza il contenuto sul terminale. Se il file è troppo grande per essere visualizzato sullo schermo, usare un comando come <command>less</command> (oppure <command>more</command>) per visualizzarlo per pagina per pagina.
			</para>
			 <para>
				Il comando <command>editor</command> avvia un editore testi (come ad esempio <command>vi</command> o <command>nano</command>) e permette di creare, modificare e leggere file di testo. È possibile creare file particolarmente semplici, direttamente dalla linea di comando, utilizzando ridirezione: <command>echo "<replaceable>text</replaceable>" &gt;<replaceable>file</replaceable></command> crea un file chiamato <replaceable>file</replaceable> con “<replaceable>text</replaceable>” per contenuto. È anche possibile aggiungere una linea a fine file, con un comando come: <command>echo "<replaceable>moretext</replaceable>" &gt;&gt;<replaceable>file</replaceable></command>. Notare il doppio <literal>&gt;&gt;</literal> in questo secondo esempio.
			</para>

		</section>
		 <section>
			<title>Ricerca dei File e all'interno dei File</title>
			 <para>
				Il comando <command>find <replaceable>directory</replaceable> <replaceable>criterio</replaceable></command> cerca i file all'interno di una <replaceable>directory</replaceable> in base a diversi criteri. Il criterio usato più comunemenete è <literal>-name <replaceable>nome</replaceable></literal>: che permette di ceracre un file tramite il nome.
			</para>
			 <para>
				Il coamndo <command>grep <replaceable>expressione</replaceable> <replaceable>files</replaceable></command> cerac il contenuto dei file ed estrae le linee corrispondenti all'espressione regolare (vedi riquadro <xref linkend="sidebar.regexp" />). Aggiungendo l'opzione <literal>-r</literal> consente una ricerca ricorsiva su tutti i file contenuti nella directory passata come parametro. Questo permette di cercare un file quando è nota solo una parte del suo contenuto.
			</para>

		</section>
		 <section>
			<title>Gestione Processi</title>
			 <para>
				Il comando <command>ps aux</command> elenca i processi in esecuzione ed aiuta ad identificarli mostrando il loro <emphasis>pid</emphasis> (process id). Una volta conosciuto il <emphasis>pid</emphasis> di un processo, il comando <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> permette di inviare un segnale (se il processo appartiene all'utente corrente). Esistono diversi segnali; i più comunemente usati sono <literal>TERM</literal> (una richiesta a terminare in modo naturale) e <literal>KILL</literal> (un'arresto forzato).
			</para>
			 <para>
				L'interprete dei comandi può anche eseguire i programmi in background se il comando è seguito da una "&amp;". Utilizzando la e commerciale, l'utente riprende immediatamente il controllo della shell anche se il comando è ancora in esecuzione (nascosto all'utente; come processo in background). Il comando <command>jobs</command> elenca i processi in esecuzione in background; eseguendo <command>fg %<replaceable>numero-lavoro</replaceable></command> (per <emphasis>foreground</emphasis>) il processo viene riportato in primo piano. Quando un comando è in esecuzione in primo piano (o perché è stato avviato normalmente, o perchè riportato in primo piano con <command>fg</command>), la combinazione dei tasti <keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo> sospende il processo e riprende il controllo della riga di comando. Il processo può essere riavviato in background con <command>bg %<replaceable>numero-lavoro</replaceable></command> (per <foreignphrase>background</foreignphrase>).
			</para>

		</section>
		 <section>
			<title>Informazioni di Sistema: Memoria, Spazio su Disco, Identità</title>
			 <para>
				Il comando <command>free</command> visualizza le informazioni sulla memoria; <command>df</command> (<emphasis>disk free</emphasis>) riporta la disponibilità di spazio su ogni disco montato nel filesystem. La sua opzione <literal>-h</literal> (per <emphasis>human readable</emphasis> leggibile dagli umani) converte le dimensioni in unità più leggibili (solitamente megabyte o gigabyte). Allo stesso modo, il comando <command>free</command> supporta le opzioni <literal>-m</literal> e <literal>-g</literal>, e visualizza i dati, rispettivamente in megabyte o in gigabyte.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       used       free     shared    buffers     cached
Mem:       1028420    1009624      18796          0      47404     391804
-/+ buffers/cache:     570416     458004
Swap:      2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>Filesystem           1K-blocchi      Usati Disponib. Uso% Montato su
/dev/sda2              9614084   4737916   4387796  52% /
tmpfs                   514208         0    514208   0% /lib/init/rw
udev                     10240       100     10140   1% /dev
tmpfs                   514208    269136    245072  53% /dev/shm
/dev/sda5             44552904  36315896   7784380  83% /home
</computeroutput></screen>
			 <para>
				Il <command>id</command> visualizza l'identità dell'utente che esegue la sessione, insieme alla lista dei gruppi a cui appartiene. Poiché l'accesso ad alcuni file o dispositivi può essere limitata ai membri del gruppo, può essere utile verificare l'appartenenza al gruppo disponibile.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
</screen>

		</section>

	</section>
	 <section id="sect.filesystem-hierarchy">
		<title>Organizzazione della Gerarchia del Filesystem</title>
		 <indexterm>
			<primary>Gerarchia del Filesystem</primary>
		</indexterm>
		 <section>
			<title>La Directory Root</title>
			 <para>
				Un sistema Debian è organizzato secondo il <emphasis>Filesystem Hierarchy Standard</emphasis> (FHS). Questo standard definisce lo scopo di ogni directory. Per esempio, le directory di primo livello sono descritte come segue:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<filename>/bin/</filename>: programmi base;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/boot/</filename>: kerne Linux ed altri file necessari per il suo processo d'avvio;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/dev/</filename>: file del dispositivo;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/etc/</filename>: files di configurazione;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/home/</filename>: file personali dell'utente;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/lib/</filename>: libraries di base;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/media/*</filename>: punti di mount per i dispositivi rimovibili (CD-ROM, chiavette USB ecc.);
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/mnt/</filename>: punto di mount temporaneo;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/opt/</filename>: applicazioni extra fornite da terze parti;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/root/</filename>: file personali dell'ammininistratore (dell'utente root);
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/run/</filename>: dati runtime volatili che non rimangono dopo i riavvi (non ancora inclusi nel FHS);
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/sbin/</filename>: programmi di sistema;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/srv/</filename>: dati usati dal server opsitato sul sistema;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/tmp/</filename>: file temporanei; questa directory è spesso svuotata all'avvio;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/usr/</filename>: applicazioni; questa directory è ulteriormente suddivisa in <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (seguendo la logica della directory principale). Inoltre, <filename>/usr/share/</filename> contiene i dati indipendenti dall'architettura. <filename>/usr/local/</filename> è pensato per essere utilizzato dall'amministratore per installare manualmente le applicazioni senza sovrascrivere i file gestiti dal sistema di impacchettamento (<command>dpkg</command>).
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/var/</filename>: dati variabili gestiti dai demoni. Questi includono file di log, code, spool, cache ecc.
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/proc/</filename> e <filename>/sys/</filename> sono specifici per il kernel Linux (e non fanno parte di FHS). Sono utilizzati dal kernel per l'esportazione dei dati nello spazio utente (vedi <xref linkend="sect.userspace-presentation" /> e <xref linkend="sect.user-space" /> per spiegazioni riguardo questo concetto).
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section>
			<title>Directory Home dell'Utente</title>
			 <para>
				I contenuti della directory home dell'utente non sono standardizzati, ma ci sono ancora alcune convenzioni degne di nota. Una è che spesso la directory home dell'utente viene spesso definita da una tilde (“~”). Questo è utile da sapere poichè gli interpreti di comando sostituiscono automaticamente una tilde con la directory corretta (di solito <filename>/home/<replaceable>utente</replaceable>/</filename>).
			</para>
			 <para>
				Tradizionalmente, i file di configurazione dell'applicazione vengono spesso memorizzati direttamente nella directory home dell'utente, ma i loro nomi di solito iniziano con un punto (per esempio, il client email <command>mutt</command> salva la sua configurazione in <filename>~/.muttrc</filename>). Si noti che i nomi dei file che iniziano con un punto sono nascosti per impostazione predefinita; ed il comando <command>ls</command> li elenca solo quando viene utilizzata l'opzione <literal>-a</literal>, ed i file manager grafici hanno bisogno di visualizzare i file nascosti.
			</para>
			 <para>
				Alcuni programmi utilizzano anche più file di configurazione organizzati in una directory (ad esempio, <filename>~/.ssh/</filename>). Alcune applicazioni (come ad esempio il browser Iceweasel) usano anche loro directory per memorizzare una cache di dati scaricati. Questo significa che quelle directory possono occupare un sacco di spazio su disco.
			</para>
			 <para>
				Questi file di configurazione archiviati direttamente nella home directory dell'utente, spesso comunemente denominati <emphasis>dotfiles</emphasis>, si sono nel tempo moltiplicati al punto che potrebbero riempire quasi interamente queste directory. Fortunatamente, uno sforzo condotto collettivamente sotto la direzione di FreeDesktop.org ha portato alla "XDG Base Directory Specification", un convegno che mira a ripulire questi file e directory. Questa specifica stabilisce che i file di configurazione devono essere conservati in <filename>~/.config</filename>, file di cache in <filename>~/.cache</filename>, e file di dati dell'applicazione in <filename>~/.local</filename> (o in sottodirectory). Questa convenzione si sta lentamente consolidando, e diverse applicazioni (specialmente quelle grafiche) hanno iniziato a seguirla.
			</para>
			 <para>
				I desktop grafici di solito visualizzano i contenuti della directory <filename>~/Desktop/</filename> (o qualsiasi altra cosa per i sistemi non configurati in Inglese) sul desktop (vale adire, ciò che visibile sullo schermo una volta che tutte le applicazioni sono state chiuse o ridotte a icona).
			</para>
			 <para>
				Infine,a volte il sistema di posta elettronica memorizza la posta in arrivo nella dierctory <filename>~/Mail/</filename>.
			</para>

		</section>

	</section>
	 <section id="sect.computer-layers">
		<title>Funzionamento Interno di un Computer: i Diversi Livelli Coinvolti</title>
		 <para>
			Un computer è spesso considerato come qualcosa piuttosto astratto, e l'interfaccia visibile esternamente è molto più semplice rispetto alla complessità interna. Tale complessità deriva in parte dal numero di pezzi coinvolti. Tuttavia, questi pezzi possono essere visualizzati in strati, dove uno strato interagisce solo con quelli immediatamente sopra o sotto.
		</para>
		 <para>
			Un utente finale può utilizzarlo senza conoscere questi dettagli... fino a quando tutto funziona. Quando si affronta un problema come, "Internet non funziona!", la prima cosa da fare è identificare in quale strato ha avuto origine il problema. La scheda di rete (hardware) funziona? E' riconosciuta dal computer? Il kernel Linux la vede? I parametri di rete sono configurati correttamente? Tutte queste domande isolano uno strato adeguato e mettono a fuoco la potenziale fonte del problema.
		</para>
		 <section id="sect.hardware">
			<title>Lo Strato più Profondo: l'Hardware</title>
			 <indexterm>
				<primary>IDE</primary>
			</indexterm>
			 <indexterm>
				<primary>SCSI</primary>
			</indexterm>
			 <indexterm>
				<primary>Serial ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>Parallel ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>Firewire</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <para>
				Cominciamo con un promemoria base che un computer è, prima di tutto, un insieme di elementi hardware. C'è generalmente una scheda principale (nota come <emphasis>scheda madre</emphasis>), con uno (o più) processori, qualche RAM, controller di dispositivi, e slot di espansione per schede aggiuntive (per altri controller di dispositivi). I più degni di nota tra questi controller sono gli IDE (Parallel ATA), SCSI e Serial ATA, per il collegamento di dispositivi di memorizzazione come gli hard disk. Altri controller includono l'USB, che è in grado di ospitare una grande varietà di dispositivi (che vanno dalle webcam ai termometri, dalle tastiere ai sistemi di automazione domestica) e l'IEEE 1394 (Firewire). Questi controller spesso consentono il collegamento di più dispositivi così il sottosistema completo gestito da un controller è quindi generalmente noto come "bus". Schede opzionali includono le schede grafiche (alle quali verranno collegati gli schermi dei monitor), le schede audio, le schede di rete, e così via. Alcune schede madri hanno già integrate queste caratteristiche, e non hanno bisogno di schede aggiuntive.
			</para>
			 <sidebar> <title><emphasis>IN PRACTICA</emphasis> Verifica dell'hardware</title>
			 <para>
				La veririfica che una parte di hardware funzioni può essere difficile. D'altra parte, dimostrare che non funziona è qualche volta abbastanza semplice.
			</para>
			 <para>
				Un hard disk è fatto di piatti rotanti e testine magnetica in movimento. Quando un hard disk si accende, il motore del piatto fa un ronzio caratteristico. E dissipa anche energia come calore. Di conseguenza, un disco rigido che rimane freddo e silenzioso quando acceso è rotto.
			</para>
			 <para>
				Le schede di rete spesso includono LED che mostrano lo stato del collegamento. Se un cavo è collegato ad un hub di rete funzionante o ad uno switch, almeno un LED si accende. Se non si accende nessun LED, o la scheda stessa, o il dispositivo di rete, oppure il cavo tra di loro, è difettoso. Il passo successivo è quindi testare ciascun componente singolarmente.
			</para>
			 <para>
				Alcune schede opzionali - le schede video 3D in particolare - includono dispositivi di raffreddamento, come i dissipatori di calore e/o ventilatori. Se la ventola non gira anche se la scheda è alimentata, una spiegazione plausibile è la scheda sia surriscaldata. Questo vale anche per il processore(i) principale(i) situato(i) sulla scheda madre.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.bios">
			<title>L'Avviatore: il BOIS o l'UEFI</title>
			 <indexterm>
				<primary>BIOS</primary>
			</indexterm>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>Master Boot Record (MBR)</primary>
			</indexterm>
			 <para>
				L'hardware, da solo, non è in grado di eseguire operazioni utili il corrispondente pezzo di software che lo guidi. Il controllo e l'interazione con l'hardware è lo scopo del sistema operativo e delle applicazioni. Questi, a loro volta, richiedono hardware funzionale per essere eseguiti.
			</para>
			 <para>
				Questa simbiosi tra hardware e software non avviene da sola. Quando il computer viene acceso dapprima, sono necessarie alcune configurazioni iniziali. Questo compito è assunto dal BIOS o dall'UEFI, un pezzo di software incluso nella scheda madre che si avvia automaticamente al momento dell'accensione. Il suo compito principale è cercare un software a cui possa cui trasferire il controllo. Di solito, nel caso del BIOS, questo comporta la ricerca del primo disco rigido con settore d'avvio (noto anche come <emphasis>master boot record</emphasis> o <acronym>MBR</acronym>), per caricare il settore d'avvio, ed eseguirlo. Da quel momento in poi, il BIOS di solito non è più coinvolto (fino al successivo avvio). Nel caso di EUFI, il processo comporta anche la scansione dei dischi per trovare una partizione EFI dedicata contenente ulteriori applicazioni EFI da eseguire.
			</para>
			 <sidebar> <title><emphasis>STRUMENTO</emphasis> Impostare, lo strumento di configurazione del BIOS/UEFI</title>
			 <indexterm>
				<primary><emphasis>Impostare</emphasis></primary>
			</indexterm>
			 <para>
				Il BIOS/UEFI contiene anche un software chiamato programma di installazione, progettato per consentire di configurare gli spetti del computer. In particolare, consente di scegliere il dispositivo d'avvio preferito (per esempio, il floppy disk o il CD-ROM), di impostare l'orologio di sistema, e così via. L'avvio del setup di solito si ottiene premendo molto presto un tastosubito dopo che il computer si è acceso. Questo tasto è spesso <keycap>Del</keycap> o <keycap>Esc</keycap>, a volte <keycap>F2</keycap> o <keycap>F10</keycap>. L amggior parte delle volte, la scelta è visualizzata sullo schermo durante l'avvio.
			</para>
			 </sidebar> <para>
				Il settore di avvio (o la partizione EFI), a sua volta, contiene un'altro pezzo di software, chiamato bootloader, il cui scopo è quello di trovare ed eseguire un sistema operativo. Dal momento che questo bootloader non è incorporato nella scheda madre, ma è caricato dal disco, può avere più funzionalità del BIOS, il che spiega perché il BIOS non carica il sistema operativo stesso. Ad esempio, il bootloader (spesso GRUB su sistemi Linux) può elencare i sistemi operativi disponibili e chiedere all'utente di sceglierne uno. Di solito, viene fornita una scelta predefinita ed una di timeout. A volte l'utente può anche scegliere di aggiungere parametri da passare al kernel, e così via. Alla fine, un kernel viene trovato, caricato in memoria, ed eseguito.
			</para>
			 <sidebar> <title><emphasis>NOTA</emphasis> UEFI, un moderno sostituto del BIOS</title>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>Avvio Sicuro</primary>
			</indexterm>
			 <para>
				UEFI è uno sviluppo relativamente recente. La maggior parte dei nuovi computer supportano il boot UEFI, ma di solito hanno anche il supporto all'avvio da BIOS per retrocompatibilità con i sistemi operativi che non sono pronti a sfruttare UEFI.
			</para>
			 <para>
				Questo nuovo sistema si libera di alcune delle limitazioni del BIOS: con l'utilizzo di una partizione dedicata, i bootloader non hanno più bisogno trucchi speciali per adattarsi in un piccolo <emphasis>master boot record</emphasis> e poi scoprire il kernel da avviare. Ancora meglio, con un kernel Linux opportunamente costruito, UEFI può avviare direttamente il kernel senza alcun bootloader intermedio. UEFI è anche il fondamento di base usato per fornire <emphasis>Secure Boot</emphasis>, una tecnologia per garantire che si esegua solo software convalidato dal produttore del sistema operativo.
			</para>
			 </sidebar> <para>
				Il BIOS/UEFI è anche responsabile del rilevamento edell'inizializzazione di un numero di dispositivi. Ovviamente, questo include i dispositivi IDE/SATA (di solito hard disk e unità CD/DVD-ROM), ma anche i dispositivi PCI. I dispositivi rilevati sono spesso elencati sullo schermo durante il processo di avvio. Se questo elenco scorre troppo velocemente, utilizzare il tasto <keycap>Pausa</keycap> per fermarlo il tempo sufficiente per leggere. Dispositivi PCI installati che non vengono visualizzati sono un cattivo presagio. Nel peggiore dei casi, il dispositivo è difettoso. Nella migliore delle ipotesi, è semplicemente incompatibile con la versione corrente del BIOS o con la scheda madre. Le specifiche PCI si evolvono, e le vecchie scehde madri non garantiscono di gestire i dispositivi PCI più recenti.
			</para>

		</section>
		 <section id="sect.kernel">
			<title>Il Kernel</title>
			 <para>
				Sia il BIOS/EUFI che il bootloader sono eseguiti solo per pochi secondi ciascuno; ora stiamo ottenendo il primo pezzo di software che viene eseguito per un tempo più lungo, il kernel del sistema operativo. Questo kernel assume il ruolo di un direttore d'orchestra, e assicura il coordinamento tra hardware e software. Questo ruolo prevede diverse attività tra cui: guidare l'hardware, gestire i processi, gli utenti ed i permessi, il filesystem, e così via. Il kernel fornisce una base comune a tutti gli altri programmi sul sistema.
			</para>

		</section>
		 <section id="sect.userspace-presentation">
			<title>Lo Spazio Utente</title>
			 <para>
				Anche se tutto ciò che accade al di fuori del kernel può essere accomunato sottola dicitura "user space" (spazio utente), possiamo ancora separarlo in strati software. Tuttavia, le interazioni tra i processi esterni al kernel sono più complesse rispetto a prima, e le classificazioni possono non essere così semplici. Un'applicazione utilizza comunemente librerie, che a loro volta coinvolgono il kernel, ma le comunicazioni possono coinvolgere anche altri programmi, o anche altre librerie che si chiamano a vicenda.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-role-and-tasks">
		<title>Alcuni Compiti di cui si occupa il Kernel</title>
		 <section id="sect.hardware-drivers">
			<title>Guidare l'Hardware</title>
			 <para>
				Il kernel ha, prima di tutto, il compito di controllare i componenti hardware, individuarli, avviarli quando il computer è acceso, e così via. Fornisce loro anche software di livello superiore con un'interfaccia di programmazione semplificata, cosicchè le applicazioni possono utilizzare i dispositivi senza doversi preoccupare di dettagli come ad esempio a quale slot di espansione è collegata la scheda aggiuntiva. L'interfaccia di programmazione prevede anche un livello di astrazione; questo permette al software di video-conferenza, ad esempio, di usare una webcam indipendentemente dalla sua marca e modello. Il software è in grado appena di utilizzare l'interfaccia <emphasis>Video for Linux</emphasis> (V4L), ed il kernel traduce le chiamate di funzione di questa interfaccia nei comandi hardware effettivi necessari alla specifica webcam in uso.
			</para>
			 <para>
				<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> Il kernel esporta molti dettagli sull'hardware rilevato attraverso i filesystem virtuali <filename>/proc/</filename> e <filename>/sys/</filename>. Diversi strumenti riassumono questi dettagli. Tra questi, <command>lspci</command> (nel pacchetto <emphasis role="pkg">pciutils</emphasis>) elenca i dispositivi USB, e <command>lspcmcia</command> (nel pacchetto <emphasis role="pkg">pcmciautils</emphasis>) elenca le schede PCMCIA. Questi strumenti sono molto utili per identificare il modello esatto del dispositivo. Questa identificazione permette anche le ricerche più precise sul web, che a sua volta, porta a documenti più pertinenti.
			</para>
			 <example>
				<title>Esempio di informazioni fornite da <command>lspci</command> e <command>lsusb</command></title>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>

			</example>
			 <para>
				Questi programmi hanno un'opzione <literal>-v</literal>, che riporta informazioni molto più dettagliate (ma di solito non è necessario). Infine, il comando <command>lsdev</command> (nel pacchetto <emphasis role="pkg">procinfo</emphasis>) elenca le risorse di comunicazione utilizzate dai dispositivi.
			</para>
			 <para>
				Le applicazioni spesso accedono ai dispositivi per mezzo di file speciali creati all'interno della cartella <filename>/dev/</filename> (vedi riquadro <xref linkend="sidebar.special-files" />). Si tratta di file speciali che rappresentano le unità disco (per esempio, <filename>/dev/hda</filename> e <filename>/dev/sdc</filename>), le partizioni(<filename>/dev/hda1</filename> o <filename>/dev/sdc3</filename>), i mouse (<filename>/dev/input/mouse0</filename>), le tastiere (<filename>/dev/input/event0</filename>), le schede audio (<filename>/dev/snd/*</filename>), le porte seriali (<filename>/dev/ttyS*</filename>), e così via.
			</para>

		</section>
		 <section id="sect.filesystems">
			<title>Filesystem</title>
			 <indexterm>
				<primary>filesystem</primary>
			</indexterm>
			 <indexterm>
				<primary>sistema, filesystem</primary>
			</indexterm>
			 <para>
				I filesystem sono uno degli aspetti più importanti del kernel. I sistemi unix uniscono tutti gli archivi in un'unica gerarchia, che permette agli utenti (ed alle applicazioni) di accedere ai dati semplicemente conoscendo la loro posizione all'interno di tale gerarchia.
			</para>
			 <para>
				Il punto di partenza di questo albero gerarchico è chiamato radice (root), <filename>/</filename>. Questa directory può contenere sottodirectory. Ad esempio, la directory <literal>home</literal> sottodirectory di <filename>/</filename> è chiamata <filename>/home/</filename>. Questa sottodirectory può, a sua volta, contiene altre sottodirectory, e così via. Ogni directory può contenere anche file, in cui verranno memorizzati i dati effettivi. Così, il nome <filename>/home/marco/Scrivania/ciao.txt</filename> si riferisce ad un file chiamato <literal>ciao.txt</literal> memorizzato in <literal>Scrivania</literal> sottodirectory di <literal>marco</literal> sottodirectory della directory <literal>home</literal> presente nella radice. Il kernel fa la traduzione tra questo sistema di denominazione e la reale, fisica archiviazione su un disco.
			</para>
			 <para>
				A differenza di altri sistemi, c'è solo un tale gerarchia, e può integrare dati da più dischi. Uno di questi dischi è usato come radice, e gli altri sono "montati" sulle directory nella gerarchia (il comando Unix è chiamato <command>mount</command>); questi altri dischi sono poi disponibili sotto questi "punti di montaggio". Questo permette di memorizzare le directory home degli utenti (di solito memorizzate all'interno di <filename>/home/</filename>) su un secondo hard disk, che conterrà le directory <literal>marco</literal> e <literal>grazia</literal>. Una volta che il disco è montato in <filename>/home/</filename>, queste directory diventano accessibili alle loro solite posizioni, e percorsi come <filename>/home/marco/Scrivania/ciao.txt</filename> continueranno a funzionare.
			</para>
			 <indexterm>
				<primary><command>mkfs</command></primary>
			</indexterm>
			 <para>
				Ci sono molti formati di filesystem, che corrispondono a molti modi per memorizzare fisicamente i dati sui dischi. I più conosciuti sono <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> ed <emphasis>ext4</emphasis>, ma ne esistono altri. Ad esempio, <emphasis>vfat</emphasis> è il sistema che è stato storicamente utilizzato dai sistemi operativi DOS e Windows, e che consente di utilizzare i disci rigidi sotto Debian così come in Windows. In questo caso, il filesystem deve essere preparato sul disco prima che venga montato e questa operazione è nota come "formattazione". I comandi come <command>mkfs.ext3</command> (dove <command>mkfs</command> sta per <emphasis>MaKe FileSystem</emphasis>) gestiscono la formattazione. Questi comandi richiedono, come parametro, un file del dispositivo che rappresenta la partizione che deve essere formattata (per esempio, <filename>/dev/sda1</filename>). Questa operazione è distruttiva e deve essere eseguita una sola volta, a meno che non si voglia deliberatamente ripulire un filesystem e ricominciare da capo.
			</para>
			 <para>
				Ci sono anche i file system di rete, come <acronym>NFS</acronym>, in cui i dati non sono memorizzati su un disco locale. Invece, i dati vengono trasmessi attraverso la rete a un server che li memorizza e li recupera su richiesta. L'astrazione del filesystem protegge gli utenti dal dover fare attenzione: i file rimangono di solito accessibili in modo gerarchico.
			</para>

		</section>
		 <section id="sect.shared-functions">
			<title>Funzioni Condivise</title>
			 <para>
				Dal momento che un certo numero di stesse funzioni è utilizzato da tutti i software, ha senso che vengano centralizzate nel kernel. Ad esempio, la gestione del file system condiviso permette a qualsiasi applicazione semplicemente aprire un file per nome, senza la necessità di preoccuparsi del modo in cui il file è memorizzato fisicamente. Il file può essere memorizzato in parecchie parti diverse su un disco rigido, o diviso su più dischi rigidi, o anche memorizzato su un file server remoto. Le funzioni di comunicazione condivise vengono utilizzate dalle applicazioni per scambiare dati indipendentemente dal modo in cui i dati vengono trasportati. Per esempio, il trasporto potrebbe avvenire su qualsiasi combinazione di reti locali o wireless, o su un telefono fisso.
			</para>

		</section>
		 <section id="sect.process-management">
			<title>Gestione Processi</title>
			 <indexterm>
				<primary><emphasis>pid</emphasis></primary>
			</indexterm>
			 <para>
				Un processo è un'istanza di un programma in esecuzione. Ciò richiede memoria per memorizzare sia il programma che i suoi dati in esecuzione. Il kermel si occupa della creazione e del loro monitoraggio. Quando un programma viene eseguito, il kernel prima mette da parte un pò di memoria, quindi carica il codice eseguibile dal filesystem in esso, e poi avvia l'esecuzione del codice. Mantiene le informazioni su questo processo, delle quali la più visibile è il numero identificativo conosciuto come <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis>).
			</para>
			 <para>
				I kernel Unix-like (incluso Linux), come la maggior parte dei sistemi operativi moderni, sono “multi-tasking”. In altre parole, permettono l'esecuzione di molti processi "contemporaneamente". In realtà c'è solo un processo in esecuzione in un dato momento, ma il kernel fraziona il tempo in intervalli ed esegue ogni processo a turno. Poiché questi intervalli di tempo sono molto brevi (in millisecondi), creano l'illusione di processi in esecuzione in parallelo, anche se in realtà sono attivi solo durante alcuni intervalli di tempo e inattivi il resto del tempo. Il lavoro del kernel è quello di regolare il suo meccanismo di pianificazione per mantenere questa illusione, massimizzando le prestazioni globali del sistema. Se gli intervalli di tempo sono troppo lunghi, l'applicazione potrebbe non mostrarsi così reattiva come si desidera. Se sono troppo brevi, il sitema perde tempo a passare da un lavoro (task) ad un'altro così di frequente. queste decisioni possono essere modificate attraverso le priorità dei processi. I processi ad alta priorità verranno eseguiti per più tempo e con intervalli più frequenti rispetto ai processi a bassa priorità.
			</para>
			 <sidebar> <title><emphasis>NOTA</emphasis> Sistemi Multi-processore (e varianti)</title>
			 <para>
				La limitazione descritta sopra di un solo processo che può essere eseguito per volta, non si applica sempre. L'attuale restrizione è che ci può essere un solo processo in esecuzione <emphasis>per core di processore</emphasis> alla volta. I sistemi multi-processore, multi-core o "hyper-threading" consentono l'esecuzione di più processi in parallelo. Lo stesso sistema time-slicing è ancora usato, anche se, per gestire i casi in cui vi sono processi più attivi che core disponibili. Questo è ben lungi dall'essere insolito: un sistema di base, anche uno in idle, quasi sempre ha decine di processi in esecuzione.
			</para>
			 </sidebar> <para>
				Naturalmente, il kernel permette di eseguire diverse istanze indipendenti dello stesso programma. Ma ciascuno può accedere solo ai propri intervalli di tempo e memoria. I loro dati rimangono quindi indipendenti.
			</para>

		</section>
		 <section id="sect.permissions">
			<title>Gestione dei Diritti</title>
			 <para>
				I sistemi Unix-like sono anche multi-utente. Essi forniscono un sistema di gestione dei diritti che supporta utenti e gruppi separati; permette anche il controllo sulle azioni basate sulle autorizzazioni. Il kernel gestisce i dati per ogni processo, permettendo di controllare i permessi. La maggior parte del tempo, il processo è identificato dall'utente che lo ha iniziato. Tale processo è consentito solo per rendere quelle azioni disponibili al suo proprietario. Ad esempio, il tentativo di aprire un file richiede che il kernel controlli l'identità del processo contro le autorizzazioni di accesso (per maggiori dettagli su questo particolare esempio, vedere <xref linkend="sect.rights-management" />).
			</para>

		</section>

	</section>
	 <section id="sect.user-space">
		<title>Lo Spazio Utente</title>
		 <indexterm>
			<primary>spazio utente</primary>
		</indexterm>
		 <indexterm>
			<primary>spazio kernel</primary>
		</indexterm>
		 <para>
			"Spazio utente" si riferisce l'ambiente di runtime di normali (al contrario di kernel) processi. Questo non significa necessariamente che questi processi siano effettivamente avviati dagli utenti perchè normalmente un sistema standard ha diversi processi "demoni" (o in background) in esecuzione prima che l'utente apri anche una sessione. I processi demoni sono considerati processi user-space.
		</para>
		 <section id="sect.process-basics">
			<title>Processo</title>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				Qunado il kernel ternima la sua fase di inizializzazione, avvia il primo processo, <command>init</command>. Il processo #1 da solo è molto raramente utile di per sé, ed i sistemi Unix-like vengono eseguiti con molti processi aggiuntivi.
			</para>
			 <indexterm>
				<primary><emphasis>fork</emphasis></primary>
			</indexterm>
			 <para>
				Prima di tutto, un processo può clonare se stesso (questo è noto come <emphasis>fork</emphasis>). Il kermel alloca un nuovo (ma identico) spazio di memoria per il processo, ed un'altro processo per usarlo. In questo momento, l'unica differenza tra questi due processi è il loro <emphasis>pid</emphasis>. Il nuovo processo è chiamato di solito processo figlio, ed il processo originale il cui <emphasis>pid</emphasis> non cambia, è chiamato processo padre.
			</para>
			 <para>
				A volte, il processo figlio continua a condurre la sua propria vita indipendentemente dal suo genitore, con i propri dati copiati dal processo genitore. In molti casi, però, questo processo figlio esegue un altro programma. Con poche eccezioni, la memoria viene semplicemente sostituita da quella del nuovo programma, e l'esecuzione di questo nuovo programma inizia. Questo è il meccanismo utilizzato dal processo init (con il processo numero 1) per avviare servizi aggiuntivi ed eseguire l'intera sequenza di avvio. Ad un certo punto, un processo tra i processi figli di <command>init</command> avvia un'interfaccia grafica per gli utenti che devono fare il login (la sequenza reale degli eventi è descritta in dettaglio in <xref linkend="sect.system-boot" />).
			</para>
			 <para>
				Quando un processo completa il compito per cui è stato avviato, termina. Il kernel poi recupera la memoria assegnata a questo processo, e smette di assegnarli porzioni di tempo per l'esecuzione. Al processo genitore viene detto che il proprio processo figlio è terminato, questo permette ad un processo di attendere il completamento del compito delegato ad un processo figlio. Questo comportamento è chiaramente visibile negli interpreti a riga di comando (conosciuti come <emphasis>shell</emphasis>). Quando viene digitato un comando in una shell, il prompt ritorna disponibile solo quando l'esecuzione del comando è completata. La maggior parte delle shell consentono l'esecuzione di comandi in background, si tratta solo di aggiungere un <userinput>&amp;</userinput> alla fine del comando. Il prompt viene subito visualizzato di nuovo, e ciò può causare problemi se il comando ha bisogno di visualizzare i propri dati.
			</para>

		</section>
		 <section id="sect.daemons">
			<title>Demoni</title>
			 <indexterm>
				<primary>demone</primary>
			</indexterm>
			 <indexterm>
				<primary>demone</primary>
			</indexterm>
			 <para>
				Un "demone" è un processo avviato automaticamente dalla sequenza di avvio. Continua a funzionare (in background) per eseguire operazioni di manutenzione o per fornire servizi ad altri processi. Questa "attività in background" è in realtà arbitraria, e non corrisponde a niente di particolare dal punto di vista del sistema. Sono semplicemente processi, molto simili ad altri processi, che a loro volta si avviano quando arriva il loro intervallo di tempo. La distinzione è solo nel linguaggio umano: un processo che viene eseguito senza interazione con l'utente (in particolare, senza alcuna interfaccia grafica) è detto essere in esecuzione "in background" o "come demone".
			</para>
			 <sidebar> <title><emphasis>VOCABOLARIO</emphasis> Daemon, demone, un termine dispregiativo?</title>
			 <para>
				Anche se il termine <emphasis>daemon</emphasis> condivide la sua etimologia greca con <emphasis>demon</emphasis>, il primo non implica il male diabolico, invece, dovrebbe essere inteso come una sorta di spirito aiutante. Questa distinzione è abbastanza sottile in inglese; è anche peggio in altre lingue in cui la stessa parola è usata per entrambi i significati.
			</para>
			 </sidebar> <para>
				Molti di questi demoni sono descritti in dettaglio nella <xref linkend="unix-services" />.
			</para>

		</section>
		 <section id="sect.ipc">
			<title>Comunicazioni tra Processi</title>
			 <indexterm>
				<primary>IPC</primary>
			</indexterm>
			 <indexterm>
				<primary>Inter-Process Communications (Comunicazioni tra Processi)</primary>
			</indexterm>
			 <para>
				Un processo isolato, sia esso un demone o un'applicazione interattiva, raramente è utile di per sé, ed è per questo ci sono diversi metodi che consentono ai processi separati di comunicare tra loro, sia per lo scambio di dati che per controllarsi l'un l'altro. Il termine generico che si riferisce a questo è <emphasis>comunicazione tra processi</emphasis>, o IPC in breve.
			</para>
			 <para>
				Il più semplice sistema di IPC è quello di utilizzare i file. Il processo che desidera inviare dati scrive in un file (con un nome noto in anticipo), mentre il destinatario deve solo aprire il file e leggere i contenuti.
			</para>
			 <indexterm>
				<primary><emphasis>pipe</emphasis></primary>
			</indexterm>
			 <para>
				Nel caso in cui non si desideri memorizzare i dati su disco, è possibile utilizzare una <emphasis>pipe</emphasis>, che è semplicemente un oggetto con due estremità; i byte scritti in una delle estremità sono leggibili dall'altra. Se le estremità sono controllate da processi separati, questo porta ad un canale di comunicazione tra processi semplice e conveniente. Le pipe possono essere classificate in due categorie: pipe con nome, e pipe anonime. Una pipe con nome è rappresentata da una sola voce sul filesystem (anche se i dati trasmessi non sono memorizzati lì), quindi entrambi i processi possono aprirla indipendentemente se la posizione della pipe con nome è nota in anticipo. Nel caso in cui sono collegati processi comunicanti (per esempio, un processo genitore ed un processo figlio), il processo padre può anche creare una pipe anonima prima di fare il fork, ed il processo figlio la eredita. Entrambi i processi saranno quindi in grado di scambiare dati attraverso la pipe senza bisogno del filesystem.
			</para>
			 <sidebar> <title><emphasis>IN PRATICA</emphasis> Un'esempio concreto</title>
			 <para>
				Descriviamo in dettaglio ciò che accade quando un comando complesso (una <emphasis>pipeline</emphasis>) viene eseguita da una shell. Supponiamo di avere un processo <command>bash</command> (la shell utente standard su Debian), con <emphasis>pid</emphasis> 4374; in questa shell, digitiamo il comando: <command>ls | sort</command> .
			</para>
			 <para>
				La shell prima interpreta il comando digitato. Nel nostro caso, si capisce che ci sono due programmi (<command>ls</command> e <command>sort</command>), con un flusso di dati che scorre da uno all'altro (indicato dal carattere <userinput>|</userinput>, noto come <emphasis>pipe</emphasis>). <command>bash</command> crea innanzitutto una pipe senza nome (che inizialmente esiste solo all'interno del processo <command>bash</command> stesso).
			</para>
			 <para>
				Poi la shell clona se stessa; questo porta ad un nuovo processo <command>bash</command>, con <emphasis>pid</emphasis> #4521 (i <emphasis>pid</emphasis> sono numeri astratti, ed in genere non hanno un significato particolare). Il processo #4521 eredita la pipe, che significa che è in grado di scrivere nel suo lato di "input"; la <command>bash</command> reindirizza il suo flusso di output standard verso l'ingresso di questa pipe. Poi esegue (e si sostituisce ad esso) il programma <command>ls</command>, che elenca il contenuto della directory corrente. Dal momento che <command>ls</command> scrive sul suo output standard, e questo output è stato precedentemente reindirizzato, i risultati sono inviati effettivamente nella pipe.
			</para>
			 <para>
				Un'operazione simile avviene per il secondo comando: <command>bash</command> si clona ancora, portando ad un nuovo processo <command>bash</command> con pid # 4522. Dal momento che è anche un processo figlio di # 4374, eredita anche la pipe; <command>bash</command> poi connette il suo input standard all'uscita della pipe, poi esegue (e si sostituisce ad esso) il comando <command>sort</command>, che ordina il suo input e visualizza i risultati.
			</para>
			 <para>
				Tutti i pezzi del puzzle sono ora impostati: <command>ls</command> legge la directory corrente e scrive l'elenco dei file nella pipe; <command>sort</command> legge questa lista, la ordine in ordine alfabetico, e visualizza i risultati. Processi numero #4521 e #4522 poi terminano, e #4374 (che li aspettava durante l'operazione), riprende il controllo e visualizza il prompt per consentire all'utente di digitare un nuovo comando.
			</para>
			 </sidebar> <para>
				Comunque, non tutte le comunicazioni tra processi sono usate per sposteare dati in giro. In molte situazioni, l'unica informazione che deve essere trasmessa sono i messaggi di controllo come "metti in pausa l'esecuzione" oppure "riprendi l'esecuzione". Unix (e Linux) forniscono un meccanismo noto come <emphasis>signals</emphasis>, attraverso il quale un processo può semplicemente inviare un segnale specifico (scelto da un'elenco predefinito di segnali) ad un'altro processo. L'unico requisito è quello di conoscere il <emphasis>pid</emphasis> del bersaglio.
			</para>
			 <para>
				Per le comunicazioni più complesse, ci sono anche meccanismi che consentono ad un processo di aprire l'accesso, o condividere, parte della sua memoria con altri processi. La memoria ora condivisa tra di essi può essere utilizzata per spostare i dati tra i processi.
			</para>
			 <para>
				Infine, le connessioni di rete possono anche aiutare i processi a comunicare; questi processi possono anche essere in esecuzione su computer diversi, forse anche a migliaia di chilometri di distanza.
			</para>
			 <para>
				E 'abbastanza normale per un tipico sistema Unix-like fare uso di tutti questi meccanismi a vari gradi.
			</para>

		</section>
		 <section id="sect.libraries">
			<title>Librerie</title>
			 <indexterm>
				<primary>libreria (di funzioni)</primary>
			</indexterm>
			 <para>
				Le librerie di funzioni svolgono un ruolo cruciale in un sistema operativo Unix-like. Esse non sono programmi veri e propri, poiché non possono essere eseguiti da soli, ma raccolte di frammenti di codice che possono essere utilizzate da programmi standard. Tra le librerie comuni, potete trovare:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						la libreria standard C (<emphasis>glibc</emphasis>), che contiene le funzioni di base come quelle per aprire i file o le connessioni di rete, ed altre che facilitano le interazioni con il kernel;
					</para>

				</listitem>
				 <listitem>
					<para>
						i toolkit grafici, come Gtk e Qt, consentono a molti programmi di riutilizzare gli oggetti grafici che forniscono;
					</para>

				</listitem>
				 <listitem>
					<para>
						la libreria <emphasis>libpng</emphasis>, che consente il caricamento, l'interpretazione ed il salvataggio delle immagini in formato PNG.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Grazie a queste librerie, le applicazioni possono riutilizzare il codice esistente. Lo sviluppo delle applicazioni è semplificato dal momento che molte applicazioni possono riutilizzare le stesse funzioni. Con librerie spesso sviluppate da persone diverse, lo sviluppo globale del sistema è più vicino alla filosofia storica di Unix.
			</para>
			 <sidebar> <title><emphasis>CULTURA</emphasis> Il Modo Unix: una cosa alla volta</title>
			 <para>
				Uno dei concetti fondamentali che sta alla base della famiglia di sistemi operativi Unix è che ogni strumento deve fare solo una cosa, e farla bene; le applicazioni possono poi riutilizzare questi strumenti per costruire logica più avanzata. Questa filosofia può essere visto in molte incarnazioni. Gli script shell possono essere il miglior esempio: sono formati da sequenze complesse di comandi molto semplici (come <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command> e così via). Un'altra applicazione di questa filosofia può essere vista nelle librerie di codice: la libreria <emphasis>libpng</emphasis> permette la lettura e la scrittura di immagini PNG, ma fa solo questo, non include nessuna funzione che permette la visualizzazione o la modifica delle immagini.
			</para>
			 </sidebar> <para>
				Inoltre, queste librerie sono spesso indicate come "librerie condivise", dato che il kernel è in grado di caricarle in memoria solo una volta, anche se più processi utilizzano la stessa libreria allo stesso tempo. Ciò permette risparmio di memoria, se confrontato con la situazione (ipotetica) contraria in cui il codice per una libreria sarebbe caricato tante volte quanti sono i processi che la utilizzano.
			</para>

		</section>

	</section>
</appendix>

