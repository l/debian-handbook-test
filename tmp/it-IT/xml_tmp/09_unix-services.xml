<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="unix-services">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-unix-services.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Avvio del sistema</keyword>
      <keyword>Initscripts</keyword>
      <keyword>SSH</keyword>
      <keyword>Telnet</keyword>
      <keyword>Diritti</keyword>
      <keyword>Permessi</keyword>
      <keyword>Supervisione</keyword>
      <keyword>Inetd</keyword>
      <keyword>Cron</keyword>
      <keyword>Backup</keyword>
      <keyword>Hotplug</keyword>
      <keyword>PCMCIA</keyword>
      <keyword>APM</keyword>
      <keyword>ACPI</keyword>
    </keywordset>
  </chapterinfo>
  <title>Servizi Unix</title>
  <highlights>
    <para>Questo capitolo comprende una serie di servizi di base che sono comuni a molti sistemi Unix. Tutti gli amministratori dovrebbero conoscerli bene.</para>
  </highlights>
  <section id="sect.system-boot">
    <title>Avvio del sistema</title>
    <indexterm><primary>avvio</primary><secondary>del sistema</secondary></indexterm>

    <para>Quando si avvia il computer, i molti messaggi che scorrono sulla console visualizzano molte inizializzazioni e configurazioni automatiche che vengono eseguite. Può capitare di voler modificare un po' come funziona questa fase, il che significa che è necessario conoscerla bene. Questo è lo scopo di questa sezione.</para>

    
    <para>In primo luogo, il BIOS prende il controllo del computer, rileva i dischi, carica il <emphasis>Master Boot Record</emphasis>, ed esegue il bootloader. Il bootloader subentra, trova il kernel sul disco, lo carica e lo esegue. Il kernel è quindi inizializzato, e comincia a cercare e montare la partizione contenente il file system root, infine esegue il primo programma — <command>init</command>. Spesso, questa "partizione root" e questo <command>init</command> sono, di fatto, presenti in un filesystem virtuale che esiste solo nella RAM (da qui il suo nome, "initramfs", precedentemente chiamato "initrd" che sta per "disco RAM di inizializzazione"). Questo filesystem è caricato in memoria dal bootloader, spesso da un file su disco rigido o dalla rete. Contiene il minimo indispensabile richiesto dal kernel per caricare il "vero" filesystem root: possono essere moduli driver per l'hard disk, o altri dispositivi senza i quali il sistema non si avvia, o, più frequentemente, gli script di inizializzazione ed i moduli per il montaggio degli array RAID, l'apertura di partizioni cifrate, l'attivazione di volumi LVM, ecc. Una volta che la partizione di root è montata, initramfs passa il controllo all'init reale, e la macchina torna al processo di avvio standard.</para>

    <figure id="figure.boot-process-systemd">
      <title>Sequenza di avvio di un computer Linux con systemd</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/startup-systemd.png" scalefit="1" width="80%" />
        </imageobject>
      </mediaobject>
    </figure>

    <section id="sect.systemd"><title>Il sistema di init systemd</title>

    <para>Il "vero init" è attualmente fornito da <emphasis role="pkg">systemd</emphasis> e questa sezione documenta questo sistema di init.</para>

    <sidebar>
      <title><emphasis>CULTURA</emphasis> Prima di <command>systemd</command></title>

      <para><command>systemd</command>  è un "sistema di init" relativamente recente, ed anche se era già disponibile, in una certa misura, in <emphasis role="distribution">Wheezy</emphasis>, è diventato il predefinito solo in Debian <emphasis role="distribution">Jessie</emphasis>. Le precedenti versioni facevano affidamento, per impostazione predefina, su “System V init” (in the <emphasis role="pkg">sysv-rc</emphasis> package), un sistema molto più tradizionale. Descriveremo il System V init in seguito.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVA</emphasis> Altri sistemi di avvio</title>

      <para>Questo libro descrive il sistema di avvio usato in modo predefinito in Debian <emphasis role="distribution">Jessie</emphasis> (come implementato dal pacchetto <emphasis role="pkg">systemd</emphasis>), come il sistema di default precedente, <emphasis role="pkg">sysvinit</emphasis>, che è derivato ed ereditato dal <emphasis>System V</emphasis> dei sistemi Unix; ma ce ne sono altri.</para>

      <para><emphasis role="pkg">file-rc</emphasis> è un sistema di avvio con un procedimento molto semplice. Mantiene il principio dei runlevel, ma sostituisce le directory e i collegamenti simbolici con un file di configurazione, che indica a <command>init</command> i processi che devono essere avviati e il loro ordine di lancio.</para>

      <para>Il sistema <command>upstart</command> non è ancora perfettamente testato su Debian. È basato su eventi: gli script di init non vengono più eseguiti in un ordine sequenziale, ma in risposta a eventi come il completamento di un altro script da cui essi dipendono. Questo sistema, avviato da Ubuntu, è presente in Debian <emphasis role="distribution">Jessie</emphasis>, ma non è il predefinito; viene fornito, di fatto, in sostituzione di <emphasis role="pkg">sysvinit</emphasis>, e uno dei compiti avviati da <command>upstart</command> è quello di avviare gli script scritti per i sistemi tradizionali, in particolare quelli del pacchetto <emphasis role="pkg">sysv-rc</emphasis>.</para>

      <para>Esistono anche altri sistemi e modalità operative, come <command>runit</command> o <command>minit</command>, ma sono relativamente specializzati e non molto diffusi.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>CASO SPECIFICO</emphasis> Avvio da rete</title>

      <para>In alcune configurazioni, il BIOS può essere configurato per non eseguire l'MBR, ma per cercare il suo equivalente in rete, rendendo possibile la costruzione di computer senza un disco rigido, o che sono completamente reinstallati ad ogni avvio. Questa opzione non è disponibile su tutto l'hardware e richiede in genere una combinazione appropriata di BIOS e scheda di rete.</para>

      <para>L'avvio da rete può essere utilizzato per lanciare il <command>debian-installer</command> o FAI (vedere la <xref linkend="sect.installation-methods" /> ).</para>
    </sidebar>

    <sidebar>
      <title><emphasis>FONDAMENTALI</emphasis> Il processo, un'istanza di programma</title>
      <indexterm><primary>processo</primary></indexterm>

      <para>Un processo è la rappresentazione in memoria di un programma in esecuzione. Esso comprende tutte le informazioni necessarie per la corretta esecuzione del software (il codice stesso, ma anche i dati che ha in memoria, l'elenco di file che ha aperto, le connessioni di rete che ha stabilito, ecc.). Un programma unico può essere istanziato in vari processi diversi, non necessariamente in esecuzione con diversi ID utente.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>SICUREZZA</emphasis> Usare una shell come <command>init</command> per ottenere i privilegi di root</title>

      <para>Per convenzione, il primo processo che viene avviato è il programma <command>init</command> (il quale è per impostazione predefinita un link simbolico a <filename>/lib/systemd/systemd</filename>). Tuttavia, è possibile passare un'opzione a <literal>init</literal> per il kernel che indica un programma diverso.</para>
      <indexterm><primary><command>init</command></primary></indexterm>

      <para>Chiunque è in grado di accedere al computer può premere il pulsante <keycap>Reset</keycap> e quindi riavviare. Poi, al prompt del bootloader, è possibile passare l'opzione <literal>init=/bin/sh</literal> per il kernel per ottenere l'accesso come root senza conoscere la password dell'amministratore.</para>

      <para>Per evitare ciò, è possibile proteggere lo stesso bootloader con una password. Si potrebbe anche pensare di proteggere l'accesso al BIOS (un meccanismo di protezione con password è quasi sempre disponibile), senza di ciò un intruso malintenzionato potrebbe ancora avviare la macchina su un supporto rimovibile contenente il proprio sistema Linux, che potrebbe utilizzare per accedere ai dati sull'hard disk del computer.</para>

      <para>Infine, fare attenzione al fatto che la maggior parte dei BIOS dispone di una password generica. Inizialmente destinate alla risoluzione di problemi per coloro che hanno dimenticato la password, queste password sono ora pubbliche e disponibili su Internet (provare a cercare "password generica per BIOS" in un motore di ricerca). Tutte queste protezioni ostacoleranno quindi l'accesso non autorizzato alla macchina senza essere in grado di evitarlo completamente. Non c'è un modo affidabile per proteggere un computer se l'utente malintenzionato può accedervi fisicamente; in ogni caso potrebbe smontare gli hard disk per connetterli a un computer sotto il proprio controllo, o addirittura rubare l'intera macchina, o cancellare la memoria del BIOS per ripristinarne la password…</para>
    </sidebar>


<para>Systemd esegue diversi processi, responsabili della configurazione del sistema: tastiera, drivers, filesystem, rete, servizi. Lo fa mantenendo una vsione globale del sistema nel suo complesso, ed i requisiti dei componenti. Ciascun componente è descritto da un "file unit" (a volte più); la sintassi generale deriva dalla sintassi ampiamente usata nei "file *.ini", con coppie <literal><replaceable>chiave</replaceable> = <replaceable>valore</replaceable></literal> raggruppate tra le intestazioni <literal>[<replaceable>section</replaceable>]</literal>. I file unit vengono memorizzati in <filename>/lib/systemd/system/</filename> e <filename>/etc/systemd/system/</filename>; sono disponibili in vari gusti, ma qui ci si concentrerà su "service" e "target".</para>

<para>Un "service file" di systemd descrive un processo gestito da systemd. Contiene più o meno le stesso informazioni degli script-init vecchio stile, ma ma espresse in modo dichiarativo (e molto più conciso). systemd gestisce la maggior parte dei compiti ripetitivi (avviare e arrestare il processo, controllare il suo stato, la registrazione, far cadere i privilegi, e così via), ed il service file ha bisogno solo di compilare le specifiche dei processi. Per esempio, questo è un service file per SSH:</para>

<programlisting>[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</programlisting>

<para>Come si può vedere, c'è poco codice lì dentro, solo dichiarazioni. Systemd si occupa di visualizzare i report, tenendo tracci dei processi, ed anche riavviandoli quando necessario.</para>

<para>Un "target file" di systemd descrive uno stato del sistema, dove un insieme di servizi sono noti per essere operativi. Può essere pensato come un equivalente del runlevel vecchio-stile. Uno dei target è <literal>local-fs.target</literal>; quando è raggiunto, il resto del sistema può ritenere tutti i filesystem locali montati ed accessibili. Un'altro target include <literal>network-online.target</literal> e <literal>sound.target</literal>. Le dipendenze del target possono essere elencate sia nel file di destinazione (alla riga <literal>Requires=</literal>), oppure usando un collegamento simbolico al file del servizio nella directory <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal>. Per esempio, <filename>/etc/systemd/system/printer.target.wants/</filename> contiene un collegamento a <filename>/lib/systemd/system/cups.service</filename>; systemd si assicurerà quindi che CUPS sia in esecuzione in modo da raggiungere il target <literal>printer.target</literal>.</para>

<para>Dal momento che gli unit file sono dichiararativi e non script o programmi, non possono essere eseguiti direttamente, e sono solo interpretati da systemd; diverese utility consentono quindi all'amministratore di interagire con systemd e controllare lo stato del sistema e di ogni componente.</para>

<para>La prima di queste utility è <command>systemctl</command>. Quando viene eseguita senza argomenti, elenca tutti gli unit file noti a systemd (eccetto quelli che sono stati disabilitati), coì come il loro stato. <command>systemctl status</command> dà una migliore visione dei servizi, nonchè dei relativi processi. Se viene passato il nome di un servizio (come in <command>systemctl status ntp.service</command>), restituisce ancora più dettagli, così come le ultime righe dei log relativi al servizio (ne parleremo più avanti).</para>

<para>L'avvio manuale del servizio è una cosa semplice eseguendo <command>systemctl start <replaceable>nomedelservizio</replaceable>.service</command>. Come si può intuire, l'arresto di un servizio è fatto con <command>systemctl stop <replaceable>nomedelservizio</replaceable>.service</command>; altri comandi includono <command>reload</command> e <command>restart</command>.</para>

<para>Per controllare se un servizio è attivo (es. se partirà automaticamente all'avvio), usa <command>systemctl enable <replaceable>nomedelservizio</replaceable>.service</command> (oppure <command>disable</command>). <command>is-enabled</command> permette il controllo dello stato del servizio.</para>

<para>Una caratteristica interessante di systemd è che include un componente di registrazione chiamato <command>journald</command>. Si presenta come un complemento a più sistemi di registrazione tradizionali come <command>syslogd</command>, ma aggiunge delle caratteristiche interessanti come un collegamento formale tra un servizio ed i messaggi che genera, e la capacità di cattuare i messaggi generati dalla sua sequenza di avvio. I messaggi possono essere visualizzati in seguito, con un piccolo aiuto da parte del comando <command>journalctl</command>. Senza argomenti, sputa fuori semplicemente tutti i messaggi di log che si sono verificati dall'avvio del sistema; raramente è usato in questo modo. La maggior parte delle volte sarà utilizzato con un identificatore del servizio:</para>

<screen><computeroutput># </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</computeroutput></screen>

<para>Un'altro utile flag da riga di comando è <command>-f</command>, che indica a <command>journalctl</command> di mantenere la visualizzazione di nuovi messaggi quando sono emessi (più di quanto faccia <command>tail -f <replaceable>file</replaceable></command>).</para>

<para>Se un servizio sembra non funzionare come previsto, la prima cosa da fare per risolvere il problema è quella di verifica se il servizio sia effettivamente in esecuzione con <command>systemctl status</command>; se non lo è, ed i messaggi dati dal primo comando non sono sufficienti a diagnosticare il problema, controllare i log raccolti da journald su quel servizio. Ad esempio, si supponga che il server SSH non funzioni:</para>

<screen><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>vi /etc/ssh/sshd_config
</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service
</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </computeroutput></screen>

<para>Dopo aver controllato lo stato del servizio (fallito), siamo andati a controllare i registri; indicano un errore nel file di configurazione. Dopo aver modificato il file di configurazione e sistemato l'errore, riavviamo il servizio, quindi verifichiamo che sia effettivamente in funzione.</para>

<sidebar><title><emphasis>APPROFONDIMENTO</emphasis> Altri tipi di file unit</title>

<para>Abbiamo descritto solo la più fondamentale capacità di systemd in questa sezione. Esso offre molte altre caratteristiche interessanti; qui ne elencheremo solo alcune:</para>

<itemizedlist>

<listitem><para>attivazione socket: un'unità file "socket" può essere usata per descrivere una reteo un socket Unix gestito da systemd; questo significa il socket viene creato da systemd, ed il servizio vero e proprio può essere avviato quando arriva un'effettivo tentativo di connessione. Questo più o meno replica il set di funzionalità di <command>inetd</command>. Vedere <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para></listitem>

<listitem><para>timer: un'unità file  “timer” descriveeventi che si verificano con una frequenza fissa o a tempo; quando un servizio è collegato a tale timer, il compito corrispondernte verrà eseguito ogni volta che scatterà il timer. Questo permette di replicare parte delle caratteristiche del comando <command>cron</command>. Vedere <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para></listitem>

<listitem><para>rete: un file di "rete" descrive un'interfaccia di rete, che permette di configurare tali interfacce oltre che manifestare che un servizio dipende da un particolare interfaccia.</para></listitem>

</itemizedlist>
</sidebar>

</section>

<section id="sect.sysvinit"><title>Il sistema di init System V</title>
    <para>Il sistema di init System V (che chiameremo init per brevità) esegue diversi processi, seguendo le istruzione del file <filename>/etc/inittab</filename>. Il primo programma che viene eseguito (che corrisponde al passo <emphasis>sysinit</emphasis>) è <command>/etc/init.d/rcS</command>, uno script che esegue tutti i programmi contenuti nella directory <filename>/etc/rcS.d/</filename>. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm></para>

    <para>Tra questi, si trovano successivamente i programmi incaricati di:</para>
    <itemizedlist>
      <listitem>
	<para>configurare la tastiera della console;</para>
      </listitem>
      <listitem>
	<para>caricare i driver: la maggior parte dei moduli del kernel vengono caricati dal kernel stesso, al rilevamento dell'hardware, altri driver aggiuntivi vengono caricati in seguito automaticamente se i moduli corrispondenti sono elencati nel file <filename>/etc/modules</filename>;</para>
      </listitem>
      <listitem>
	<para>verificare l'integrità dei file system;</para>
      </listitem>
      <listitem>
	<para>montare partizioni locali;</para>
      </listitem>
      <listitem>
	<para>configurare la rete;</para>
      </listitem>
      <listitem>
	<para>montare file system di rete (NFS).</para>
      </listitem>
    </itemizedlist>

    <sidebar>
      <title><emphasis>FONDAMENTALI</emphasis> I moduli del kernel e le opzioni</title>
      <indexterm><primary>moduli</primary><secondary>moduli del kernel</secondary></indexterm>

      <para>I moduli del kernel hanno anche opzioni che possono essere configurate mettendo alcuni file in <filename>/etc/modprobe.d/</filename>. Queste opzioni sono definite con direttive come questa: <literal>options <replaceable>nome-modulo</replaceable> <replaceable>nome-opzione</replaceable>=<replaceable>valore-opzione</replaceable></literal>. Diverse opzioni possono essere specificate con un'unica direttiva, se necessario.</para>

      <para>Questi file di configurazione sono destinati a <command>modprobe</command>: il programma che carica un modulo del kernel con le sue dipendenze (i moduli possono infatti chiamare altri moduli). Questo programma è fornito dal pacchetto <emphasis role="pkg">kmod</emphasis>.</para>
      <indexterm><primary><command>modprobe</command></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">kmod</emphasis></primary></indexterm>
    </sidebar>

    <para>In seguito a questa fase, subentra <command>init</command> e avvia quei programmi attivati nel runlevel predefinito (che di solito è il runlevel 2). Viene eseguito <command>/etc/init.d/rc 2</command>, uno script che lancia tutti i servizi che sono elencati in <filename>/etc/rc2.d/</filename> ed i cui nomi iniziano con la lettera «S». Il numero a due cifre che segue era storicamente utilizzato per definire l'ordine in cui i servizi dovevano essere avviati, ma al giorno d'oggi il sistema di avvio predefinito utilizza <command>insserv</command>, che pianifica tutto automaticamente in base alle dipendenze degli script. Ogni script di avvio dichiara in tal modo le condizioni che devono essere soddisfatte per avviare o arrestare il servizio (per esempio, se si deve avviare prima o dopo un altro servizio); <command>init</command> poi li esegue nell'ordine che soddisfa queste condizioni. La numerazione statica degli script quindi non è più presa in considerazione (ma devono sempre avere un nome che inizia con una «S» seguita da due cifre ed il nome effettivo dello script usato per le dipendenze). In generale, i servizi di base (come la registrazione con <command>rsyslog</command>, o l'assegnazione di porte con <command>portmap</command>) vengono avviati per primi, seguiti dai servizi standard e dall'interfaccia grafica (<command>gdm3</command>).</para>

    <para>Questo sistema di avvio basato su dipendenze consente di automatizzare la rinumerazione, che potrebbe risultare piuttosto noiosa se dovesse essere effettuata manualmente, e limita i rischi di errore umano, poiché la pianificazione viene effettuata secondo i parametri indicati. Un altro vantaggio è che i servizi possono essere avviati in parallelo quando sono indipendenti l'uno dall'altro, e quindi è possibile accelerare il processo di avvio.</para>

    <indexterm><primary>runlevel</primary></indexterm>
    <indexterm><primary>livello, runlevel</primary></indexterm>

    <para><command>init</command> distingue tra diversi runlevel, in modo da poter passare da uno all'altro con il comando <command>telinit <replaceable>nuovo-livello</replaceable></command>. Immediatamente, <command>init</command> esegue ancora una volta <command>/etc/init.d/rc</command> con il nuovo runlevel. Questo script quindi avvia i servizi mancanti e ferma quelli che non sono più desiderati. Per fare ciò, fa riferimento al contenuto di <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (dove <replaceable>X</replaceable> rappresenta il nuovo runlevel). Gli script che iniziano con «S» (come in «Start») sono i servizi da avviare, quelli che iniziano con «K» (come in «Kill») sono i servizi che devono essere arrestati. Lo script non avvia alcun servizio che era già attivo nel runlevel precedente.</para>

    <para>Per impostazione predefinita, System V init in Debian utilizza quattro diversi runlevel:</para>
    <itemizedlist>
      <listitem>
	<para>Il livello 0 è utilizzato solo temporaneamente, mentre il computer si sta spegnendo. Come tale, esso contiene solo molti script «K».</para>
      </listitem>
      <listitem>
	<para>Il livello 1, noto anche come modalità utente singolo, corrisponde al sistema in modalità degradata; include solo i servizi basilari, ed è destinato ad operazioni di manutenzione in cui le interazioni con gli utenti ordinari non sono desiderate.</para>
      </listitem>
      <listitem>
	<para>Il livello 2 è il livello per il normale funzionamento, che include servizi di rete, un'interfaccia utente grafica, accesso utenti, ecc.</para>
      </listitem>
      <listitem>
	<para>Il livello 6 è simile al livello 0, tranne che è utilizzato durante la fase di arresto che precede un riavvio.</para>
      </listitem>
    </itemizedlist>

    <para>Esistono altri livelli, in particolare da 3 a 5. In modo predefinito sono configurati per operare allo stesso modo del livello 2, ma l'amministratore può modificarli (aggiungendo o eliminando script nella corrispondente directory <filename>/etc/rc<replaceable>X</replaceable>.d</filename>) per adattarli a particolari esigenze.</para>

    <figure id="figure.boot-process-sysvinit">
      <title>Sequenza di avvio di un computer Linux con System V init</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/startup-sysvinit.png" scalefit="1" width="80%" />
        </imageobject>
      </mediaobject>
    </figure>
    <indexterm><primary>script di inizializzazione</primary></indexterm>

    <para>Tutti gli script contenuti nelle varie directory <filename>/etc/rc<replaceable>X</replaceable>.d</filename> sono solo collegamenti simbolici, creati con l'installazione del pacchetto per il programma <command>update-rc.d</command>, che puntano agli script reali che vengono memorizzati in <filename>/etc/init.d/</filename>. L'amministratore può regolare i servizi disponibili in ogni runlevel attraverso il comando <command>update-rc.d</command> con i parametri corretti. La pagina di manuale di <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> descrive la sintassi in dettaglio. Notare che la rimozione di tutti i collegamenti simbolici (con il parametro <literal>remove</literal>) non è un buon metodo per disabilitare un servizio. Si dovrebbe invece semplicemente configurare quel servizio per non essere lanciato in quel particolare runlevel (pur conservando le chiamate corrispondenti a fermarlo nel caso in cui il servizio viene eseguito nel runlevel precedente). Dal momento che <command>update-rc.d</command> ha un'interfaccia un po' complicata, può essere preferibile usare <command>rcconf</command> (presente nel pacchetto <emphasis role="pkg">rcconf</emphasis>) che fornisce un'interfaccia più intuitiva.</para>
    <indexterm><primary><command>update-rc.d</command></primary></indexterm>

    <sidebar>
      <title><emphasis>DEBIAN POLICY</emphasis> Riavvio dei servizi</title>
      <indexterm><primary><command>invoke-rc.d</command></primary></indexterm>
      <indexterm><primary>servizio</primary><secondary>riavvio</secondary></indexterm>
      <indexterm><primary>riavvio dei servizi</primary></indexterm>

      <para>Gli script dei manutentori dei pacchetti Debian, a volte, riavvieranno alcuni servizi per garantire la loro disponibilità o per tenere conto di alcune opzioni. Il comando che controlla un servizio, <command>service<replaceable>servizio</replaceable> <replaceable>operazione</replaceable></command>, non tiene in considerazione i runlevel, presume (erroneamente) che il servizio sia attualmente in uso, e può quindi iniziare delle operazioni errate (avviare un servizio che è stato deliberatamente fermato, o interrompere un servizio che è già stato arrestato, ecc.). Debian ha pertanto introdotto il programma <command>invoke-rc.d</command>: questo programma deve essere utilizzato dagli script del manutentore per eseguire gli script di inizializzazione dei servizi ed eseguirà solo i comandi necessari. Si noti che, contrariamente all'uso comune, il suffisso <filename>.d</filename> è qui usato nel nome di un programma, e non in una directory.</para>
    </sidebar>

    <para>Infine, <command>init</command> avvia i programmi di controllo per le varie console virtuali (<command>getty</command>). Visualizza un prompt, in attesa di un nome utente, poi esegue <command>login <replaceable>utente</replaceable></command> per iniziare una sessione.</para>
    <indexterm><primary><command>getty</command></primary></indexterm>

    <sidebar>
      <title><emphasis>VOCABOLARIO</emphasis> Console e terminale</title>

      <para>I primi computer erano generalmente divisi in diversi componenti molto grandi: il contenitore di memorizzazione e l'unità di elaborazione centrale erano separati dai dispositivi periferici utilizzati dagli operatori per controllarli. Questi facevano parte di un mobile separato, la «console». Questo termine è stato mantenuto, ma il suo significato è cambiato. È diventato più o meno sinonimo di «terminale», essendo una tastiera e uno schermo.</para>

      <para>Con lo sviluppo dei computer, i sistemi operativi hanno offerto diverse console virtuali per consentire diverse sessioni indipendenti contemporaneamente, anche se vi è solo una tastiera e uno schermo. La maggior parte dei sistemi GNU/Linux offrono sei console virtuali (in modalità testo), accessibili digitando le combinazioni di tasti da <keycombo action="simul"> <keycap>Control</keycap><keycap>Alt</keycap><keycap>F1</keycap></keycombo> a <keycombo action="simul"><keycap>Control</keycap><keycap>Alt</keycap><keycap>F6</keycap></keycombo> .</para>

      <para>Per estensione i termini «console» e «terminale» possono anche riferirsi ad un emulatore di terminale in una sessione grafica X11 (come <command>xterm</command>, <command>gnome-terminal</command> o <command>konsole</command> ).</para>
    </sidebar>
</section>
  </section>
  <section id="sect.remote-login">
    <title>Accesso remoto</title>

    <para>È essenziale per un amministratore essere in grado di connettersi ad un computer remoto. I server, confinati nella propria stanza, sono raramente dotati di tastiere e monitor permanenti, ma sono connessi alla rete.</para>

    <sidebar>
      <title><emphasis>FONDAMENTALI</emphasis> Client, server</title>
      <indexterm><primary>client</primary><secondary>architettura client/server</secondary></indexterm>
      <indexterm><primary>server</primary><secondary>architettura client/server</secondary></indexterm>

      <para>Un sistema in cui diversi processi comunicano tra loro è spesso descritto con la metafora «clientserver». Il server è il programma che prende le richieste provenienti da un client e le esegue. Il client controlla le operazioni, il server non prende alcuna iniziativa propria.</para>
    </sidebar>

    <indexterm><primary>accesso</primary><secondary>accesso remoto</secondary></indexterm>
    <indexterm><primary>accesso remoto</primary></indexterm>

    <section id="sect.ssh">
      <title>Accesso remoto sicuro: SSH</title>
      <indexterm><primary>SSH</primary></indexterm>
      <indexterm><primary>Secure Shell</primary></indexterm>

      <para>Il protocollo <emphasis>SSH</emphasis> (Secure SHell) è stato progettato tenendo a mente sicurezza ed affidabilità. Le connessioni con SSH sono sicure: il partner è autenticato e tutti gli scambi di dati sono cifrati.</para>

      <sidebar>
        <title><emphasis>CULTURA</emphasis> Telnet e RSH sono obsoleti</title>
	<indexterm><primary><command>telnet</command></primary></indexterm>
	<indexterm><primary><command>rsh</command></primary></indexterm>

	<para>Prima di SSH, <emphasis>Telnet</emphasis> e <emphasis>RSH</emphasis> erano i principali strumenti usati per fare il login da remoto. Sono ora per la maggior parte obsoleti e non dovrebbero essere usati anche se Debian li fornisce ancora.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>VOCABOLARIO</emphasis> Autenticazione, cifratura</title>

	<para>Quando è necessario dare ad un client la possibilità di condurre o attivare azioni su un server, la sicurezza è importante. È necessario verificare l'identità del client, questa è l'autenticazione. Questa identità di solito consiste in una password che deve essere tenuta segreta, o qualsiasi altro client potrebbe ottenere la password. Questo è lo scopo della cifratura, che è una forma di codifica che consente a due sistemi di comunicare informazioni riservate su un canale pubblico, proteggendole dall'essere leggibili ad altri.</para>

	<para>L'autenticazione e la cifratura sono spesso menzionate insieme, sia perché esse sono spesso usate insieme, sia perché sono di solito implementate con simili concetti matematici.</para>
      </sidebar>

      <para>SSH offre anche due servizi di trasferimento di file. <command>scp</command> è uno strumento a riga di comando che può essere utilizzato come <command>cp</command>, tranne che qualsiasi percorso a un altro computer è fatto precedere dal nome della macchina, seguito da due punti («:»).</para>

      <screen><computeroutput>$ </computeroutput><userinput>file macchina scp:/tmp/</userinput></screen>

      <para><command>sftp</command> è un comando interattivo, simile a <command>ftp</command>. In una singola sessione, <command>sftp</command> è in grado di trasferire più file, ed è possibile usarlo per manipolare i file remoti (eliminare, rinominare, modificare i permessi, ecc.).</para>
      <indexterm><primary><command>scp</command></primary></indexterm>
      <indexterm><primary><command>sftp</command></primary></indexterm>

      <para>Debian utilizza OpenSSH, una versione libera di SSH, mantenuta dal progetto <command>OpenBSD</command> (un sistema operativo libero basato sul kernel BSD, incentrato sulla sicurezza) e fork del software originale SSH sviluppato dalla società finlandese SSH Communications Security Corp. Questa società ha inizialmente sviluppato SSH come software libero, ma alla fine ha deciso di continuare il suo sviluppo sotto una licenza proprietaria. Il progetto OpenBSD quindi ha creato OpenSSH per mantenere una versione free di SSH.</para>
      <indexterm><primary>OpenSSH</primary></indexterm>

      <sidebar>
        <title><emphasis>FONDAMENTALI</emphasis><foreignphrase>Fork</foreignphrase></title>
        <indexterm><primary>fork</primary></indexterm>

	<para>Un «fork», in materia di software, significa un nuovo progetto che inizia come un clone di un progetto esistente, e che compete con esso. Da lì in poi, entrambi i software di solito divergono rapidamente in termini di nuovi sviluppi. Un fork è spesso il risultato di disaccordi all'interno del team di sviluppo.</para>

	<para>L'opzione di fare il fork di un progetto è una diretta conseguenza della natura stessa del software libero, un fork è un evento sano quando permette la continuazione di un progetto come software libero (per esempio in caso di cambiamenti nella licenza). Un fork derivante da divergenze tecniche o personali è spesso uno spreco di risorse umane; un'altra soluzione sarebbe preferibile. Fusioni di due progetti che in precedenza hanno attraversato un fork non sono inedite.</para>
      </sidebar>

      <para>OpenSSH è diviso in due pacchetti: la parte client è nel pacchetto <emphasis role="pkg">openssh-client</emphasis>, mentre il server è nel pacchetto <emphasis role="pkg">openssh-server</emphasis>. Il metapacchetto <emphasis role="pkg">ssh</emphasis> dipende da entrambe le parti e facilita l'installazione di entrambi (<command>apt install ssh</command>).</para>

      <section id="sect.ssh-key-based-auth">
        <title>Autenticazione basata su chiave</title>

	<para>Ogni volta che qualcuno si collega tramite SSH il server remoto richiede una password per autenticare l'utente. Questo può essere problematico se si vuole automatizzare una connessione, o se si utilizza uno strumento che richiede collegamenti frequenti su SSH. È per questo che SSH offre un sistema di autenticazione basato su chiave.</para>

	<para>L'utente genera una coppia di chiavi sulla macchina client con <command>ssh-keygen -t rsa</command>; la chiave pubblica è conservata in <filename>~/.ssh/id_rsa.pub</filename>, mentre la corrispondente chiave privata è conservata in <filename>~/.ssh/id_rsa</filename>. Successivamente l'utente usa <command>ssh-copy-id <replaceable>server</replaceable></command> per aggiungere la propria chiave pubblica nel file <filename>~/.ssh/authorized_keys</filename> presente sul server. Se la chiave privata non è stata protetta con una «passphrase» al momento della sua creazione, tutti gli accessi successivi sul server funzioneranno senza una password. In caso contrario, la chiave privata dovrà essere decifrata ogni volta inserendo la «passphrase». Fortunatamente, <command>ssh-agent</command> ci permette di mantenere in memoria le chiavi private in modo da non dover reinserire continuamente la password. Per questo, è sufficiente utilizzare <command>ssh-add</command> (una volta per ogni sessione di lavoro), a condizione che la sessione sia già associata ad un'istanza funzionante di <command>ssh-agent</command>. Debian la attiva come impostazione predefinita nelle sessioni grafiche, ma è possibile disattivare questo comportamento cambiando <filename>/etc/X11/Xsession.options</filename>. Per una sessione della console, è possibile avviarla manualmente tramite <command>eval $(ssh-agent)</command>.</para>

        <sidebar>
          <title><emphasis>SICUREZZA</emphasis> Protezione della chiave privata</title>

	  <para>Chi ha la chiave privata può effettuare il login sull'account così configurato. Per questo motivo l'accesso alla chiave privata viene protetto da una «passphrase». Chi viene in possesso di una copia di una chiave privata (ad esempio, <filename>~/.ssh/id_rsa</filename>) deve comunque sapere questa frase per essere in grado di utilizzarla. Questa protezione aggiuntiva non è, tuttavia, inespugnabile, e se si pensa che questo file è stato compromesso, è meglio disabilitare la chiave sui computer in cui è stata installata (rimuovendola dal file <filename>authorized_keys</filename>) e sostituendola con una nuova chiave generata.</para>
        </sidebar>

        <sidebar>
          <title><emphasis>CULTURA</emphasis> Problemi di OpenSSL in Debian <emphasis role="distribution">Etch</emphasis></title>

	  <para>La libreria OpenSSL, come inizialmente fornita in Debian <emphasis role="distribution">Etch</emphasis>, aveva un problema serio nel suo generatore di numeri casuali (RNG). Infatti, il manutentore Debian ha fatto un cambiamento in modo che le applicazioni che la usavano non generassero più avvertimenti quando erano analizzati con strumenti di test di memoria, come <command>valgrind</command>. Sfortunatamente, questo cambiamento comportava anche che la RNG impiegasse una sola fonte di entropia, corrispondente al numero di processo (PID) i cui possibili 32.000 valori non offrono abbastanza casualità. <ulink type="block" url="http://www.debian.org/security/2008/dsa-1571" /></para>

	  <para>Nello specifico, quando OpenSSL veniva impiegato per generare una chiave, produceva sempre una chiave all'interno di un insieme noto di centinaia di migliaia di chiavi (32.000 moltiplicato per un piccolo numero di lunghezze di chiave). Questo riguardava le chiavi SSH, le chiavi SSL ed i certificati X.509 utilizzati da numerose applicazioni, come ad esempio OpenVPN. Un cracker doveva quindi solo provare tutte le chiavi per ottenere un accesso non autorizzato. Per ridurre l'impatto del problema, il demone SSH è stato modificato in modo da rifiutare le chiavi problematiche che sono elencate nei pacchetti <emphasis role="pkg">openssh-blacklist</emphasis> e <emphasis role="pkg">openssh-blacklist-extra</emphasis>. Inoltre, il comando <command>ssh-vulnkey</command> consente l'identificazione delle chiavi eventualmente compromesse nel sistema.</para>

	  <para>Un'analisi più approfondita di questo incidente mette in luce che è il risultato di molteplici (piccoli) problemi, sia all'interno del progetto OpenSSL, che con il responsabile del paccheto Debian. Una libreria ampiamente utilizzata come OpenSSL non dovrebbe — senza modifiche — generare avvisi quando viene testata da <command>valgrind</command>. Inoltre, il codice (in particolare quelle parti tanto delicate come la RNG) dovrebbe essere commentate meglio per evitare  questi errori. Da parte sua il reponsabile del pacchetto Debian, vuole confermare le sue modifiche dagli sviluppatori di OpenSSL, ma le ha semplicemente spiegate senza fornire loro la corrispondente patch da revisionare ed ha omesso di mesionare il suo ruolo all'interno di Debian. Infine, le scelte di manutenzioneerano sub-attimali: le modifiche fatte al codice originale non sono state chiaramente documentate; tutte le modifiche sono effettivamente memorizzate in un repository Subversion, ma sono finite tutte concentrate in una singola patch durante la creazione del pacchetto sorgente.</para>

	  <para>In queste condizioni è difficile trovare le misure correttive per evitare il ripetersi di questi incidenti. La lezione da trarre è che ogni divergenza che Debian introduce nel software originale deve essere giustificata, documentata, presentata nel progetto principale, quando possibile, e ampiamente pubblicizzata. È in base a questa prospettiva che sono stati sviluppati il nuovo formato dei pacchetti sorgente ("3.0 (quilt)") ed i servizi web dei sorgenti Debian. <ulink type="block" url="http://sources.debian.net" /></para>
        </sidebar>
      </section>
      <section id="sect.ssh-x11">
        <title>Utilizzo di applicazioni X11 remote</title>

	<para>Il protocollo SSH consente la trasmissione dei dati grafici (sessione «X11», dal nome del più diffuso sistema grafico in Unix), il server mantiene un canale dedicato per tali dati. In particolare, un programma grafico eseguito da remoto può essere visualizzato sul server X.org dello schermo locale e l'intera sessione (ingresso e visualizzazione) sarà sicura. Poiché questa funzionalità consente alle applicazioni remote di interferire con il sistema locale, è disabilitata in modo predefinito. È possibile abilitare questa funzionalità specificando <literal>X11Forwarding yes</literal> nel file di configurazione del server (<filename>/etc/ssh/sshd_config</filename>). Infine, l'utente deve anche richiederla aggiungendo l'opzione <literal>-X</literal> alla riga di comando di <command>ssh</command>.</para>
      </section>
      <section id="sect.ssh-port-forwarding">
        <title>Creazione di tunnel cifrati con il port forwarding</title>
        <indexterm><primary>port forwarding</primary></indexterm>

	<para>Le opzioni <literal>-R</literal> e <literal>-L</literal> consentono a <command>ssh</command> di creare «tunnel cifrati» tra due macchine, inoltrando in modo sicuro una porta TCP locale (vedere il riquadro <xref linkend="sidebar.tcp-udp" />) ad un computer remoto o viceversa.</para>

        <sidebar>
          <title><emphasis>VOCABOLARIO</emphasis> Tunnel</title>
          <indexterm><primary>tunnel (SSH)</primary><seealso>VPN</seealso></indexterm>
          <indexterm><primary>SSH, tunnel</primary><seealso>VPN</seealso></indexterm>

	  <para>Internet, e la maggior parte delle LAN che vi sono collegate, opera in modalità a pacchetto e non in modalità connessa, il che significa che un pacchetto emesso da un computer verso un altro verrà fermato in vari router intermedi per trovare la strada verso la destinazione. È ancora possibile simulare il funzionamento in collegamento in cui il flusso è racchiuso in pacchetti IP normali. Questi pacchetti seguono il loro percorso abituale, ma il flusso viene ricostruito invariato a destinazione. Questo viene chiamato «tunnel», analogo ad una galleria stradale in cui i veicoli viaggiano direttamente dall'ingresso (input) all'uscita (output) senza incontrare alcun incrocio, al contrario di un percorso sulla superficie che comporterebbe incroci e cambiamenti di direzione.</para>

	  <para>È possibile utilizzare questa opportunità per aggiungere la cifratura al tunnel: il flusso che scorre attraverso di esso è quindi irriconoscibile dall'esterno, ma viene riportato alla forma decifrata all'uscita del tunnel.</para>
        </sidebar>

	<para><command>ssh -L 8000:server:25 intermediario</command> stabilisce una sessione SSH con l'host <replaceable>intermediario</replaceable> e ascolta sulla porta locale 8000 (vedere <xref linkend="figure.ssh-L" />). Per ogni connessione stabilita su questa porta, <command>ssh</command> avvierà una connessione dal computer <replaceable>intermediario</replaceable> alla porta 25 sul <replaceable>server</replaceable> legando insieme entrambe le connessioni.</para>

	<para>Anche <command>ssh -R 8000:server:25 intermediario</command> stabilisce una sessione SSH al computer <replaceable>intermediario</replaceable>, ma è in questa macchina che <command>ssh</command> è in ascolto sulla porta 8000 (vedere <xref linkend="figure.ssh-R" />). Ogni connessione stabilita sulla porta farà sì che <command>ssh</command> aprirà una connessione dalla macchina locale alla porta 25 del <replaceable>server</replaceable> legando insieme entrambe le connessioni.</para>

	<para>In entrambi i casi, le connessioni sono realizzate sulla porta 25 dell'host <replaceable>server</replaceable>, e passano attraverso il tunnel SSH stabilito tra la macchina locale e la macchina <replaceable>intermediario</replaceable>. Nel primo caso, l'ingresso del tunnel è locale sulla porta 8000, ed i dati si muovono verso la macchina <replaceable>intermediario</replaceable> prima di essere diretti al <replaceable>server</replaceable> sulla rete «pubblica». Nel secondo caso, l'ingresso e l'uscita del tunnel sono invertiti, l'ingresso è la porta 8000 sulla macchina <replaceable>intermediario</replaceable>, l'uscita è sulla macchina locale, ed i dati vengono poi indirizzati al <replaceable>server</replaceable>. In pratica, il server è di solito o la macchina locale o l'intermediario. In questo modo SSH rende sicura la connessione da un'estremità all'altra.</para>

        <figure id="figure.ssh-L">
          <title>Inoltro di una porta locale con SSH</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ssh-L.png" width="35%" />
            </imageobject>
          </mediaobject>
        </figure>

        <figure id="figure.ssh-R">
          <title>Inoltro di una porta remota con SSH</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ssh-R.png" width="35%" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>
    <section id="sect.remote-desktops">
      <title>Utilizzo di desktop remoti grafici</title>

      <para>VNC (Virtual Network Computing) permette l'accesso remoto a desktop grafici.</para>
      <indexterm><primary>VNC</primary></indexterm>
      <indexterm><primary>Virtual Network Computing</primary></indexterm>
      <indexterm><primary>desktop grafico</primary><secondary>remoto</secondary></indexterm>
      <indexterm><primary>desktop remoto grafico</primary></indexterm>
      <indexterm><primary>remoto, desktop grafico remoto</primary></indexterm>

      <para>Questo strumento è usato soprattutto per l'assistenza tecnica; l'amministratore può visualizzare gli errori che l'utente si trova ad affrontare, e mostrargli la cosa corretta da fare, senza dover essere fisicamente presente.</para>
      <indexterm><primary><emphasis role="pkg">vino</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">krfb</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">x11vnc</emphasis></primary></indexterm>

      <para>In primo luogo, l'utente deve autorizzare la condivisione della sessione. L'ambiente desktop grafico GNOME in <emphasis role="distribution">Jessie</emphasis> include questa opzione nel suo pannello di configurazione (contrariamente alle precedenti versioni di Debian, nelle quali l'utente deve installare ed utilizzare <command>vino</command>). KDE richiede ancora l'uso di <command>krfb</command> per consentire la condivisione di una sessione esistente tramite VNC. Per gli altri ambienti desktop grafici, il comando <command>x11vnc</command> (dal pacchetto Debian con lo stesso nome) serve allo stesso scopo; è possibile renderlo disponibile per l'utente con un'icona esplicita.</para>

      <indexterm><primary><emphasis role="pkg">vinagre</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">tsclient</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">krdc</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">xvnc4viewer</emphasis></primary></indexterm>

      <para>Quando la sessione grafica è messa a disposizione da VNC, l'amministratore deve connettersi con un client VNC. GNOME ha <command>vinagre</command> e <command>remmina</command> per questo scopo, mentre KDE include <command>krdc</command> (nel menu <menuchoice><guimenu>K</guimenu><guisubmenu>Internet</guisubmenu><guimenuitem>Client per connessione a desktop remoto</guimenuitem></menuchoice>). Ci sono altri client VNC che utilizzano la riga di comando, come ad esempio <command>xvnc4viewer</command> nel pacchetto Debian con lo stesso nome. Una volta connesso, l'amministratore può vedere cosa sta succedendo, lavorare sulla macchina in remoto, e mostrare all'utente come procedere.</para>

      <sidebar>
        <title><emphasis>SICUREZZA</emphasis> VNC su SSH</title>
        <indexterm><primary>SSH, tunnel</primary><secondary>VNC</secondary></indexterm>

	<para>Se si desidera connettersi a VNC, e non si desidera che i dati siano trasmessi in chiaro sulla rete, è possibile incapsulare i dati in un tunnel SSH (vedere la <xref linkend="sect.ssh-port-forwarding" />). È sufficiente sapere che VNC usa la porta 5900 per impostazione predefinita per il primo schermo (chiamato «localhost: 0»), 5901 per il secondo (chiamato «localhost: 1»), ecc.</para>

	<para>Il comando <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>macchina</replaceable></command> crea un tunnel tra porta locale 5901 nell'interfaccia localhost e la porta 5900 della <replaceable>macchina</replaceable> host. Il primo «localhost» limita SSH in modo che ascolti solo sull'interfaccia della macchina locale. Il secondo «localhost» indica l'interfaccia sul computer remoto che riceverà il traffico di rete in entrata su «localhost:5901». Così <command>vncviewer localhost:1</command> collegherà il client VNC allo schermo remoto, anche se si indica il nome della macchina locale.</para>

	<para>Quando la sessione VNC è chiusa, bisogna ricordarsi di chiudere il tunnel, uscendo anche dalla corrispondente sessione SSH.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>FONDAMENTALI</emphasis> Display manager</title>
        <indexterm><primary><command>gdm3</command></primary></indexterm>
        <indexterm><primary><command>kdm</command></primary></indexterm>
        <indexterm><primary><command>xdm</command></primary></indexterm>
        <indexterm><primary><command>lightdm</command></primary></indexterm>
        <indexterm><primary>manager</primary><secondary>display manager</secondary></indexterm>
        <indexterm><primary>display manager</primary></indexterm>

	<para><command>gdm3</command>, <command>kdm</command>, <command>lightdm</command> e <command>xdm</command> sono display manager. Assumono il controllo dell'interfaccia grafica poco dopo l'avvio in modo da fornire all'utente una schermata di accesso. Una volta che l'utente si è connesso, vengono eseguiti i programmi necessari per avviare una sessione grafica di lavoro.</para>
      </sidebar>

      <para>VNC funziona anche per utenti mobili, o dirigenti di società, che a volte hanno bisogno di effettuare il login da casa per accedere a un desktop remoto simile a quello che utilizzano sul posto di lavoro. La configurazione di tale servizio è più complicata: per prima cosa si installa il pacchetto <emphasis role="pkg">vnc4server</emphasis>, si modifica la configurazione del display manager in modo da accettare richieste <literal>XDMCP query</literal> (per <command>gdm3</command>, ciò può essere fatto aggiungendo <literal>Enable=true</literal> nella sezione «xdmcp» di <filename>/etc/gdm3/daemon.conf</filename>) e infine  si avvia il server VNC con <command>inetd</command> in modo che una sessione venga avviata automaticamente quando un utente tenta di effettuare l'accesso. Ad esempio, si può aggiungere questa riga a <filename>/etc/inetd.conf</filename>:</para>

      <programlisting>5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</programlisting>

      <para>Deviare le connessioni in entrata al display manager risolve il problema dell'autenticazione, in quanto solo gli utenti con account locali supereranno la schermata di accesso di <command>gdm3</command> (o l'equivalente di <command>kdm</command>, <command>xdm</command>, ecc.). Poiché questo sistema consente più connessioni simultanee senza alcun problema (se il server è abbastanza potente), può anche essere utilizzato per fornire desktop completi per gli utenti mobili (o per sistemi desktop meno potenti, configurati come thin client). Gli utenti devono semplicemente accedere allo schermo del server con <command>vncviewer <replaceable>server</replaceable>:50</command>, perché la porta utilizzata è 5950.</para>
      <indexterm><primary><emphasis role="pkg">vnc4server</emphasis></primary></indexterm>
    </section>
  </section>
  <section id="sect.rights-management">
    <title>Gestione dei permessi</title>

    <para>Linux è decisamente un sistema multi-utente, per cui è necessario fornire un sistema di permessi per il controllo delle operazioni autorizzate su file e directory, che comprende tutte le risorse di sistema e i device (in un sistema Unix, qualsiasi dispositivo è rappresentato da un file o directory). Questo principio è comune a tutti i sistemi Unix, ma un promemoria è sempre utile, soprattutto perché ci sono alcuni utilizzi avanzati interessanti e relativamente sconosciuti.</para>
    <indexterm><primary>privilegi</primary></indexterm>
    <indexterm><primary>permessi</primary></indexterm>
    <indexterm><primary>utente</primary><secondary>proprietario</secondary></indexterm>
    <indexterm><primary>gruppo</primary><secondary>proprietario</secondary></indexterm>
    <indexterm><primary>proprietario</primary><secondary>utente</secondary></indexterm>
    <indexterm><primary>proprietario</primary><secondary>gruppo</secondary></indexterm>

    <para>Ogni file o directory ha permessi specifici per tre categorie di utenti:</para>
    <itemizedlist>
      <listitem>
	<para>il proprietario (simboleggiato dalla lettera <literal>u</literal> di «user»);</para>
      </listitem>
      <listitem>
	<para>il gruppo proprietario (simboleggiato dalla lettera <literal>g</literal> di «group»), in rappresentanza di tutti i membri del gruppo;</para>
      </listitem>
      <listitem>
	<para>gli altri (simboleggiati dalla lettera <literal>o</literal> di «other»).</para>
      </listitem>
    </itemizedlist>

    <para>Si possono combinare tre tipi di diritti:</para>
    <itemizedlist>
      <listitem>
	<para>lettura (simboleggiata dalla lettera <literal>r</literal> di «read»);</para>
      </listitem>
      <listitem>
	<para>scrittura (o modifica, simboleggiata dalla lettera <literal>w</literal> di «write»);</para>
      </listitem>
      <listitem>
	<para>esecuzione (simboleggiata dalla lettera <literal>x</literal> come in «eXecute»).</para>
      </listitem>
    </itemizedlist>
    <indexterm><primary>lettura, permesso di</primary></indexterm>
    <indexterm><primary>scrittura, permesso di</primary></indexterm>
    <indexterm><primary>modifica, permesso di</primary></indexterm>
    <indexterm><primary>esecuzione, permesso di</primary></indexterm>

    <para>Nel caso di un file, questi diritti sono di facile comprensione: l'accesso in lettura permette di leggerne il contenuto (incluso farne una copia), l'accesso in scrittura permette di cambiarlo, e l'accesso in esecuzione permette di eseguirlo (che funziona solo se si tratta di un programma).</para>

    <sidebar>
      <title><emphasis>SICUREZZA</emphasis> eseguibili <literal>setuid</literal> e <literal>setgid</literal></title>

      <para>Due diritti particolari sono rilevanti per i file eseguibili: <literal>setuid</literal> e <literal>setgid</literal> (simboleggiati con la lettera «s»). Si noti che spesso si parla di «bit», poiché ciascuno di questi valori booleani può essere rappresentato da uno 0 o un 1. Questi due diritti consentono a qualsiasi utente di eseguire il programma con i diritti del proprietario o del gruppo, rispettivamente. Questo meccanismo garantisce l'accesso alle funzionalità che richiedono permessi di livello superiore rispetto a quelli che l'utente avrebbe di solito.</para>
      <indexterm><primary><literal>setuid</literal>, permesso</primary></indexterm>
      <indexterm><primary><literal>setgid</literal>, permesso</primary></indexterm>

      <para>Poiché un programma con <literal>setuid</literal> root è sistematicamente eseguito con l'identità del superutente, è molto importante assicurarsi che sia sicuro e affidabile. Infatti, un utente che riuscisse a sovvertirlo per invocare un comando di sua scelta potrebbe poi impersonare l'utente root ed avere tutti i diritti sul sistema.</para>
    </sidebar>

    <para>Una directory è gestita in modo diverso. L'accesso in lettura dà il diritto di consultare l'elenco delle sue voci (file e directory), l'accesso in scrittura permette di creare o eliminare file, mentre l'accesso in esecuzione permette di attraversarla (soprattutto di andarvi con il comando <command>cd</command>). Essere in grado di attraversare una directory senza essere in grado di leggerla dà il permesso di accedere alle voci al suo interno di cui si conosce il nome, ma non di trovarle senza sapere che esistono o sotto quale nome esatto.</para>

    <sidebar id="sidebar.setgid-dir">
      <title><emphasis>SICUREZZA</emphasis> directory <literal>setgid</literal> e <emphasis>sticky bit</emphasis></title>
      <indexterm><primary><literal>setgid</literal> directory</primary></indexterm>

      <para>Il bit <literal>setgid</literal> vale anche per le directory. Qualsiasi elemento appena creato in tali directory viene assegnato automaticamente al gruppo proprietario della directory genitore, invece di ereditare il gruppo principale del creatore come al solito. Questa configurazione evita che l'utente debba cambiare il suo gruppo principale (con il comando <command>newgrp</command>) quando lavora in un albero di file condiviso tra più utenti dello stesso gruppo dedicato.</para>
      <indexterm><primary>sticky bit</primary></indexterm>

      <para>Lo «sticky» bit (simboleggiato dalla lettera «t») è un permesso che è utile solo nelle directory. È particolarmente utilizzato per le directory temporanee in cui tutti hanno accesso in scrittura (come <filename>/tmp/</filename>): esso limita l'eliminazione di file in modo che solo il loro proprietario (o il proprietario della directory genitore) possa farlo. In mancanza di questo, tutti potrebbero eliminare i file di altri utenti in <filename>/tmp/</filename>.</para>
    </sidebar>

    <para>Tre comandi controllano i permessi associati ad un file:</para>
    <itemizedlist>
      <listitem>
	<para><command>chown <replaceable>utente</replaceable> <replaceable>file</replaceable></command> cambia il proprietario del file;</para>
      </listitem>
      <listitem>
	<para><command>chgrp <replaceable>gruppo</replaceable> <replaceable>file</replaceable></command> cambia il gruppo proprietario;</para>
      </listitem>
      <listitem>
	<para><command>chmod <replaceable>permessi</replaceable> <replaceable>file</replaceable></command> cambia i permessi per il file.</para>
      </listitem>
    </itemizedlist>

    <para>Ci sono due modi di rappresentare i permessi. Tra questi, la rappresentazione simbolica è probabilmente la più facile da capire e ricordare. Utilizza i simboli lettera descritti in precedenza. È possibile definire i permessi per ogni categoria di utenti (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), impostandoli in modo esplicito (con <literal>=</literal> ), aggiungendone (<literal>+</literal>) o sottraendone (<literal>-</literal>). Così la formula <literal>u=rwx,g+rw,o-r</literal> conferisce al proprietario i permessi di lettura, scrittura ed esecuzione, aggiunge i permessi di lettura e scrittura per il gruppo proprietario, e rimuove i diritti di lettura per altri utenti. I permessi non alterati con le aggiunte o sottrazioni fatte da tale comando non vengono modificati. La lettera <literal>a</literal>, per «all» (tutti), copre tutte le tre categorie di utenti, così che <literal>a=rx</literal> garantisce a tutte e tre le categorie gli stessi diritti (lettura ed esecuzione, ma non scrittura).</para>
    <indexterm><primary><command>chmod</command></primary></indexterm>
    <indexterm><primary><command>chown</command></primary></indexterm>
    <indexterm><primary><command>chgrp</command></primary></indexterm>
    <indexterm><primary>rappresentazione ottale dei permessi</primary></indexterm>
    <indexterm><primary>permessi</primary><secondary>rappresentazione ottale</secondary></indexterm>

    <para>La rappresentazione numerica (ottale) associa ogni permesso ad un valore: 4 per la lettura, 2 per la scrittura e 1 per l'esecuzione. Ogni combinazione di permessi viene associata con la somma delle cifre. I valori vengono quindi assegnati alle diverse categorie di utenti mettendoli in fila nell'ordine consueto (proprietario, gruppo, altri).</para>

    <para>Ad esempio, il comando <command>chmod 754 <replaceable>file</replaceable></command> imposta i seguenti permessi: lettura, scrittura ed esecuzione per il proprietario (perché 7 = 4 + 2 + 1), lettura ed esecuzione per il gruppo (perché 5 = 4 + 1), sola lettura per gli altri. Il numero <literal>0</literal> significa che non si hanno permessi; così <command>chmod 600 <replaceable>file</replaceable></command> permette la lettura/scrittura per il proprietario, e nessun diritto per chiunque altro. Le combinazioni di permessi più frequenti sono <literal>755</literal> per le directory e i file eseguibili, e <literal>644</literal> per i file di dati.</para>

    <para>Per rappresentare i permessi speciali, è possibile anteporre una quarta cifra a questo numero in base allo stesso principio, in cui il bit <literal>setuid</literal>, il bit <literal>setgid</literal> e lo <literal>sticky</literal> bit sono rispettivamente 4, 2 e 1. <command>chmod 4754</command> assocerà il bit <literal>setuid</literal> con i permessi descritti in precedenza.</para>

    <para>Si noti che l'uso della notazione ottale consente solo di impostare tutti i permessi in una sola volta su un file, non è possibile utilizzarla per aggiungere semplicemente un nuovo permesso, come l'accesso in lettura per il gruppo proprietario, in quanto è necessario tener conto dei diritti esistenti e calcolare il nuovo valore numerico corrispondente.</para>

    <sidebar>
      <title><emphasis>SUGGERIMENTO</emphasis> Operazioni ricorsive</title>

      <para>A volte è necessario cambiare i permessi per un intero albero di file. Tutti i comandi sopra descritti hanno l'opzione <literal>-R</literal> per operare ricorsivamente in sotto-directory.</para>

      <para>La distinzione tra le directory ed i file a volte causa problemi con le operazioni ricorsive. Ecco perché è stata introdotta la lettera «X» nella rappresentazione simbolica dei permessi. Essa rappresenta un permesso di esecuzione che si applica solo alle directory (e non ai file privi di tale diritto). Così, <command>chmod -R a+X <replaceable>directory</replaceable></command> aggiungerà i permessi di esecuzione per tutte le categorie di utenti (<literal>a</literal>) solo per tutte le sotto-directory e tutti i file che hanno già i diritti di esecuzione per almeno una categoria di utenti (anche se solo per il proprietario).</para>
    </sidebar>

    <sidebar>
      <title><emphasis>SUGGERIMENTO</emphasis> Cambiare utente e gruppo</title>

      <para>Spesso si desidera cambiare il gruppo di un file nello stesso momento in cui si cambia il proprietario. Il comando <command>chown</command> ha una sintassi speciale a questo scopo: <command>chown <replaceable>utente</replaceable>:<replaceable>gruppo</replaceable> <replaceable>file</replaceable></command></para>
    </sidebar>

    <sidebar>
      <title><emphasis>APPROFONDIMENTI</emphasis><command>umask</command></title>

      <para>Quando un'applicazione crea un file, assegna i permessi indicativi, sapendo che il sistema rimuove automaticamente alcuni permessi, grazie al comando <command>umask</command>. Se si digta <command>umask</command> in una shell, si vedrà una maschera come <computeroutput>0022</computeroutput>. Questa è semplicemente una rappresentazione ottale dei diritti automaticamente rimossi (in questo caso, il diritto di scrittura per il gruppo e altri utenti).</para>
      <indexterm><primary>umask</primary></indexterm>
      <indexterm><primary>permessi</primary><secondary>maschera</secondary></indexterm>
      <indexterm><primary>maschera</primary><secondary>maschera dei permessi</secondary></indexterm>

      <para>Se gli si fornisce un nuovo valore ottale, il comando <command>umask</command> modifica la maschera. Utilizzato in un file di inizializzazione della shell (per esempio, <filename>~/.bash_profile</filename>), cambierà effettivamente la maschera predefinita per le sessioni di lavoro dell'utente.</para>
    </sidebar>
  </section>
  <section id="sect.administration-interfaces">
    <title>Interfacce di amministrazione</title>
    <indexterm><primary>interfaccia</primary><secondary>interfaccia di amministrazione</secondary></indexterm>
    <indexterm><primary>amministrazione, interfacce</primary></indexterm>

    <para>L'utilizzo di un'interfaccia grafica per l'amministrazione è interessante per diversi motivi. Un amministratore non deve necessariamente conoscere tutti i dettagli di configurazione per tutti i servizi, e non sempre ha il tempo per andare a cercare documentazione in materia. Un'interfaccia grafica per l'amministrazione può quindi accelerare la messa in opera di un nuovo servizio. Può anche semplificare la configurazione di quei servizi che sono difficili da configurare.</para>

    <para>Tale interfaccia è solo di aiuto, e non un fine in sé. In ogni caso, l'amministratore deve padroneggiare il suo comportamento al fine di capire e risolvere eventuali problemi.</para>

    <para>Dal momento che nessuna interfaccia è perfetta, si può essere tentati di provare diverse soluzioni. Questo è da evitare per quanto possibile, dal momento che i diversi strumenti sono a volte incompatibili tra di loro. Anche se tutti mirano ad essere molto flessibili e cercano di adottare il file di configurazione come unico riferimento, non sono sempre in grado di integrare cambiamenti esterni.</para>
    <section id="sect.webmin">
      <title>Amministrare tramite un'interfaccia Web: <command>webmin</command></title>
      <indexterm><primary><emphasis>webmin</emphasis></primary></indexterm>

      <para>Questa è, senza dubbio, una delle interfacce di amministrazione di maggior successo. Si tratta di un sistema modulare gestito attraverso un browser web, che copre una vasta gamma di aree e strumenti. Inoltre, è internazionalizzato e disponibile in molte lingue.</para>

      <para>Purtroppo, <command>webmin</command> non fa più parte di Debian. Il suo manutentore Debian, Jaldhar H. Vyas, ha rimosso i pacchetti che ha creato, perché non aveva più il tempo necessario per mantenerli a un livello qualitativo accettabile. Nessuno ha ufficialmente preso il suo posto, così in <emphasis role="distribution">Jessie</emphasis> il pacchetto <command>webmin</command> non è presente.</para>

      <para>Esiste, comunque, un pacchetto non ufficiale distribuito sul sito web <literal>webmin.com</literal>. Contrariamente ai pacchetti Debian originali, questo pacchetto è monolitico, tutti i suoi moduli di configurazione sono installati e attivati in modo predefinito, anche se il servizio corrispondente non è installato sulla macchina.</para>

      <sidebar>
        <title><emphasis>SICUREZZA</emphasis> Cambiare la password di root</title>

	<para>Per il primo accesso, l'identificazione è basata sul nome utente root e la sua password abituale. Si raccomanda di modificare la password utilizzata per <command>webmin</command> il più presto possibile, in modo che se venisse compromessa, la password di root del server non sarà coinvolta, anche se questo conferisce importanti diritti amministrativi per la macchina.</para>

	<para>Attenzione! Dato che <command>webmin</command> ha così tante funzionalità, un utente malintenzionato accedendo potrebbe compromettere la sicurezza dell'intero sistema. In generale, questo tipo di interfacce non sono raccomandate per quei sistemi importanti con forti vincoli di sicurezza (firewall, server sensibili, ecc.).</para>
      </sidebar>

      <para>Webmin viene usato tramite un'interfaccia web, ma non richiede che Apache sia installato. In sostanza, questo software dispone di un proprio mini-server web integrato. Questo server è in ascolto in modo predefinito sulla porta 10000 e accetta connessioni HTTP sicure.</para>

      <para>I moduli inclusi coprono una vasta gamma di servizi, tra cui:</para>
      <itemizedlist>
        <listitem>
	  <para>tutti i servizi di base: creazione di utenti e gruppi, gestione dei file <filename>crontab</filename>, script di init, visualizzazione dei log, ecc.</para>
        </listitem>
        <listitem>
	  <para>bind: configurazione del server DNS (servizio dei nomi);</para>
        </listitem>
        <listitem>
	  <para>postfix: configurazione del server SMTP (e-mail);</para>
        </listitem>
        <listitem>
	  <para>inetd: configurazione del super-server <command>inetd</command>;</para>
        </listitem>
        <listitem>
	  <para>quota: gestione delle quote degli utenti;</para>
        </listitem>
        <listitem>
	  <para>dhcpd: configurazione del server DHCP;</para>
        </listitem>
        <listitem>
	  <para>proftpd: configurazione del server FTP;</para>
        </listitem>
        <listitem>
	  <para>samba: configurazione del server di file Samba;</para>
        </listitem>
        <listitem>
	  <para>software: installazione o rimozione di software di pacchetti Debian e aggiornamenti di sistema.</para>
        </listitem>
      </itemizedlist>

      <para>L'interfaccia di amministrazione è disponibile in un browser web all'URL <literal>https://localhost:10000</literal>. Attenzione! Non tutti i moduli sono direttamente utilizzabili. A volte devono essere configurati specificando i percorsi dei file di configurazione corrispondenti e di alcuni file eseguibili (programma). Spesso il sistema chiedere all'utente nel caso non riesca ad attivare un modulo richiesto.</para>

      <sidebar>
        <title><emphasis>ALTERNATIVA</emphasis> Centro di controllo di GNOME</title>
        <indexterm><primary><emphasis role="pkg">gnome-control-center</emphasis></primary></indexterm>

	<para>Il progetto GNOME fornisce anche diverse interfacce di amministrazione che sono solitamente accessibili attraverso la voce «Impostazioni» nel menu utente in alto a destra. <command>gnome-control-center</command> è il programma principale che le riunisce tutte, ma molti degli strumenti di configurazione a livello di intero sistema sono in effetti forniti da altri pacchetti (<emphasis role="pkg">accountsservice</emphasis>, <emphasis role="pkg">system-config-printer</emphasis>, ecc.). Anche se facili da usare, queste applicazioni coprono solo un numero limitato di servizi di base: la gestione degli utenti, la configurazione di data e ora, la configurazione della rete, della stampa e così via.</para>
      </sidebar>
    </section>
    <section id="sect.debconf">
      <title>Configurazione dei pacchetti: <command>debconf</command></title>
      <indexterm><primary><command>debconf</command></primary></indexterm>
      <indexterm><primary><command>dpkg-reconfigure</command></primary></indexterm>

      <para>Molti pacchetti vengono configurati automaticamente dopo aver posto alcune domande durante l'installazione attraverso lo strumento Debconf. Questi pacchetti possono essere riconfigurati mediante l'esecuzione di <command>dpkg-reconfigure <replaceable>pacchetto</replaceable></command>.</para>

      <para>Nella maggior parte dei casi, queste impostazioni sono molto semplici, solo alcune importanti variabili nel file di configurazione vengono modificate. Queste variabili sono spesso raggruppate tra due «righe di demarcazione» in modo che la riconfigurazione del pacchetto influisca solo sull'area racchiusa. In altri casi, la riconfigurazione non cambierà nulla se lo script rileva una modifica manuale del file di configurazione, al fine di conservare questi interventi umani (perché lo script non può garantire che le sue proprie modifiche non ostacoleranno le impostazioni esistenti).</para>

      <sidebar>
        <title><emphasis>DEBIAN POLICY</emphasis> Preservare le modifiche</title>

	<para>La Debian Policy prevede espressamente che dovrebbe essere fatto tutto il possibile per mantenere le modifiche manuali apportate a un file di configurazione, perciò sempre più script prendono le dovute precauzioni durante la modifica dei file di configurazione. Il principio generale è semplice: lo script apporta modifiche solo se conosce lo stato del file di configurazione, il quale viene verificato confrontando il checksum del file con quello dell'ultimo file generato automaticamente. Se sono uguali, lo script è autorizzato a modificare il file di configurazione. In caso contrario, determina che il file è stato modificato e chiede quale comportamento deve adottare (installare il nuovo file, salvare il vecchio file, o cercare di integrare i nuovi cambiamenti con il file esistente). Questo principio di precauzione è stato a lungo specifico di Debian, ma altre distribuzioni hanno gradualmente cominciato ad abbracciarlo.</para>

	<para>Il programma <command>ucf</command> (dal pacchetto Debian omonimo) può essere utilizzato per implementare un tale comportamento.</para>
        <indexterm><primary><command>ucf</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.syslog">
    <title><command>syslog</command>, eventi di sistema</title>
    <indexterm><primary><command>rsyslogd</command></primary></indexterm>
    <indexterm><primary>file</primary><secondary>file di log</secondary></indexterm>
    <indexterm><primary>log</primary><secondary>distribuzione</secondary></indexterm>
    <section id="sect.syslog-principe">
      <title>Principi e meccanismi</title>

      <para>Il demone <command>rsyslogd</command> è responsabile della raccolta dei messaggi di servizio provenienti da applicazioni e dal kernel, distribuendoli poi nei file di log (di solito memorizzati nella directory <filename>/var/log/</filename>). Obbedisce al file di configurazione <filename>/etc/rsyslog.conf</filename>.</para>

      <para>Ciascun messaggio di log è associato a un sottosistema di applicazioni (denominata «facility» nella documentazione):</para>
      <itemizedlist>
        <listitem>
	  <para><literal>auth</literal> e <literal>authpriv</literal>: per l'autenticazione;</para>
        </listitem>
        <listitem>
	  <para><literal>cron</literal>: proviene da servizi di pianificazione delle attività, <command>cron</command> e <command>atd</command>;</para>
        </listitem>
        <listitem>
	  <para><literal>daemon</literal>: interessa un demone senza alcuna classificazione speciale (DNS, NTP, ecc.);</para>
        </listitem>
        <listitem>
	  <para><literal>ftp</literal>: riguarda il server FTP;</para>
        </listitem>
        <listitem>
	  <para><literal>kern</literal>: messaggio proveniente dal kernel;</para>
        </listitem>
        <listitem>
	  <para><literal>lpr</literal>: deriva dal sottosistema di stampa;</para>
        </listitem>
        <listitem>
	  <para><literal>mail</literal>: proviene dal sottosistema per la posta elettronica;</para>
        </listitem>
        <listitem>
	  <para><literal>news</literal>: messaggio del sottosistema Usenet (specialmente da un server NNTP, Network News Transfer Protocol, che gestisce i newsgroup);</para>
        </listitem>
        <listitem>
	  <para><literal>syslog</literal>: messaggi dal server <command>syslogd</command> stesso;</para>
        </listitem>
        <listitem>
	  <para><literal>user</literal>: messaggi utente (generico);</para>
        </listitem>
        <listitem>
	  <para><literal>uucp</literal>: messaggi dal server UUCP (Unix to Unix Copy Program, un vecchio protocollo utilizzato in particolare per distribuire i messaggi di posta elettronica);</para>
        </listitem>
        <listitem>
	  <para>da <literal>local0</literal> a <literal>local7</literal>: riservato per l'uso locale.</para>
        </listitem>
      </itemizedlist>

      <para>Ogni messaggio è anche associato a un livello di priorità. Ecco l'elenco in ordine decrescente:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>emerg</literal>: «Aiuto!» C'è un'emergenza, il sistema è probabilmente inutilizzabile.</para>
        </listitem>
        <listitem>
	  <para><literal>alert</literal>: affrettarsi, ogni ritardo può essere pericoloso, bisogna agire immediatamente;</para>
        </listitem>
        <listitem>
	  <para><literal>crit</literal>: le condizioni sono critiche;</para>
        </listitem>
        <listitem>
	  <para><literal>err</literal>: errore;</para>
        </listitem>
        <listitem>
	  <para><literal>warn</literal>: avvertimento (potenziale errore);</para>
        </listitem>
        <listitem>
	  <para><literal>notice</literal>: le condizioni sono normali, ma il messaggio è importante;</para>
        </listitem>
        <listitem>
	  <para><literal>info</literal>: messaggio informativo;</para>
        </listitem>
        <listitem>
	  <para><literal>debug</literal>: messaggio di debug.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="sect.syslog-config">
      <title>Il file di configurazione</title>

      <para>La sintassi del file <filename>/etc/rsyslog.conf</filename> viene specificata nella pagina di manuale <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>, ma c'è anche la documentazione HTML disponibile nel pacchetto <emphasis role="pkg">rsyslog-doc</emphasis> (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). Il principio generale è quello di scrivere coppie di «selettori» e «azioni». Il selettore definisce tutti i messaggi rilevanti, e le azioni descrivono come trattarli.</para>
      <section id="sect.syslog-selector-syntax">
        <title>Sintassi del selettore</title>

	<para>Il selettore è un elenco separato da punti e virgola di coppie <literal><replaceable>sottosistema</replaceable>.<replaceable>priorità</replaceable></literal> (esempio: <literal>auth.notice;mail.info</literal>). Un asterisco può rappresentare tutti i sottosistemi o tutte le priorità (esempi: <literal>*.alert</literal> o <literal>mail.*</literal>). Vari sottosistemi possono essere raggruppati, separandoli con una virgola (esempio: <literal>auth,mail.info</literal>). La priorità indicata copre anche i messaggi di priorità uguale o superiore: così <literal>auth.alert</literal> indica i messaggi del sottosistema <literal>auth</literal> con priorità <literal>alert</literal> o <literal>emerg</literal>. Se fatta precedere da un punto esclamativo (!), indica il contrario, in altre parole le priorità strettamente inferiori; <literal>auth.!notice</literal>, perciò, indica i messaggi emessi da <literal>auth</literal> con priorità <literal>info</literal> o<literal>debug</literal>. Se preceduto da un segno di uguale (=) corrisponde solo ed esclusivamente alla priorità indicata (<literal>auth.=notice</literal> riguarda solo i messaggi provenienti da <literal>auth</literal> con priorità <literal>notice</literal>).</para>

	<para>Ogni elemento della lista sul selettore sovrascrive gli elementi precedenti. È così possibile limitare un insieme o escludere alcuni elementi da esso. Per esempio, <literal>kern.info;kern.!err</literal> significa i messaggi dal kernel con priorità compresa tra <literal>info</literal> e <literal>warn</literal>. La priorità <literal>none</literal> indica l'insieme vuoto (nessuna priorità), e può servire per escludere un sottosistema da un insieme di messaggi. Perciò, <literal>*.crit;kern.none</literal> indica tutti i messaggi con priorità uguale o superiore a <literal>crit</literal> che non provengono dal kernel.</para>
      </section>
      <section id="sect.syslog-action-syntax">
        <title>Sintassi delle azioni</title>

        <sidebar>
          <title><emphasis>FONDAMENTALI</emphasis> La pipe con nome, una pipe persistente</title>
          <indexterm><primary>pipe con nome</primary></indexterm>
          <indexterm><primary>pipe, pipe con nome (named pipe)</primary></indexterm>

	  <para>Una pipe con nome è un particolare tipo di file che funziona come una pipe tradizionale (la pipe che si fa con il simbolo «|» sulla riga di comando), ma tramite un file. Questo meccanismo ha il vantaggio di essere in grado di collegare due processi indipendenti. Qualunque cosa scritta su una pipe con nome blocca il processo che scrive fino a che un altro processo tenta di leggere i dati scritti. Questo secondo processo legge i dati scritti dal primo, che può quindi riprendere l'esecuzione.</para>

	  <para>Un file di questo tipo viene creato con il comando <command>mkfifo</command>.</para>
        </sidebar>

	<para>Le varie azioni possibili sono:</para>
        <itemizedlist>
          <listitem>
	    <para>aggiungere il messaggio ad un file (esempio: <filename>/var/log/messages</filename>);</para>
          </listitem>
          <listitem>
	    <para>inviare il messaggio ad un server <command>syslog</command> remoto (esempio: <literal>@log.falcot.com</literal>);</para>
          </listitem>
          <listitem>
	    <para>inviare il messaggio ad una pipe con nome esistente (esempio: <literal>|/dev/xconsole</literal>);</para>
          </listitem>
          <listitem>
	    <para>inviare il messaggio ad uno o più utenti, se sono connessi (esempio: <literal>root,rhertzog</literal>);</para>
          </listitem>
          <listitem>
	    <para>inviare un messaggio a tutti gli utenti connessi (ad esempio: <literal>*</literal>);</para>
          </listitem>
          <listitem>
	    <para>scrivere il messaggio in una console di testo (ad esempio: <literal>/dev/tty8</literal>).</para>
          </listitem>
        </itemizedlist>

        <sidebar>
          <title><emphasis>SICUREZZA</emphasis> Inoltro dei log</title>
          <indexterm><primary>log</primary><secondary>inoltro</secondary></indexterm>

	  <para>È una buona idea registrare i log più importanti su una macchina separata (magari dedicata a questo scopo), questo per prevenire ogni possibilità che un intruso elimini le tracce della propria intrusione (a meno che, naturalmente, non comprometta anche questo altro server). Inoltre, in caso di un grave problema (come un crash del kernel), si hanno a disposizione i log su un altro computer, il che aumenta le possibilità di determinare la sequenza di eventi che ha causato il crash.</para>

	  <para>Per accettare messaggi di log inviati da altre macchine, è necessario configurare <emphasis>rsyslog</emphasis>: in pratica, è sufficiente attivare le voci già pronte all'uso in <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> e <literal>$UDPServerRun 514</literal>).</para>
        </sidebar>
      </section>
    </section>
  </section>
  <section id="sect.inetd">
    <title>Il super-server <command>inetd</command></title>

    <para>Inetd (spesso chiamato «Internet super-server») è un server di server. Esegue a richiesta i server usati raramente, in modo che debbano essere eseguiti continuamente.</para>
    <indexterm><primary><command>inetd</command></primary></indexterm>
    <indexterm><primary>super-server</primary></indexterm>

    <para>Il file <filename>/etc/inetd.conf</filename> elenca questi server con le rispettive porte. Il comando <command>inetd</command> rimane in ascolto, quando rileva una connessione verso una qualsiasi di queste porte, esegue il programma server corrispondente.</para>

    <sidebar>
      <title><emphasis>DEBIAN POLICY</emphasis> Registrare un server in <filename>inetd.conf</filename></title>

      <para>I pacchetti spesso vogliono registrare un nuovo server nel file <filename>/etc/inetd.conf</filename>, ma la Debian Policy vieta a qualsiasi pacchetto di modificare un file di configurazione che non possiede. Per questo motivo è stato creato lo script <command>update-inetd</command> (nel pacchetto omonimo): gestisce il file di configurazione, e gli altri pacchetti possono quindi utilizzarlo per registrare un nuovo server nella configurazione del super-server.</para>
    </sidebar>

    <para>Ogni riga significativa del file <filename>/etc/inetd.conf</filename> descrive un server attraverso sette campi (separati da spazi):</para>
    <itemizedlist>
      <listitem>
	<para>Il numero della porta TCP o UDP, o il nome del servizio (che viene associato a un numero di porta standard con le informazioni contenute nel file <filename>/etc/services</filename>).</para>
      </listitem>
      <listitem>
	<para>Il tipo di socket: <literal>stream</literal> per una connessione TCP, <literal>dgram</literal> per datagrammi UDP.</para>
      </listitem>
      <listitem>
	<para>Il protocollo: <literal>tcp</literal> o <literal>udp</literal>.</para>
      </listitem>
      <listitem>
	<para>Le opzioni: due valori possibili: <literal>wait</literal> o <literal>nowait</literal>, per dire a <command>inetd</command> se deve attendere o meno la fine del processo avviato prima di accettare un'altra connessione. Per le connessioni TCP, facilmente usabili in multiplexing, di solito si può usare <literal>nowait</literal>. Per i programmi che rispondono su UDP, si dovrebbe utilizzare <literal>nowait</literal> solo se il server è in grado di gestire diverse connessioni in parallelo. È possibile aggiungere a questo campo un suffisso con un punto, seguito dal numero massimo di connessioni autorizzate al minuto (il limite predefinito è 256).</para>
      </listitem>
      <listitem>
	<para>Il nome utente dell'utente sotto la cui identità verrà eseguito il server.</para>
      </listitem>
      <listitem>
	<para>Il percorso completo del programma server da eseguire.</para>
      </listitem>
      <listitem>
	<para>Gli argomenti: si tratta di un elenco completo degli argomenti del programma, compreso il suo stesso nome (<literal>argv[0]</literal> in C).</para>
      </listitem>
    </itemizedlist>

    <para>L'esempio seguente illustra i casi più comuni:</para>

    <example id="example.inetd-conf">
      <title>Estratto dal file <filename>/etc/inetd.conf</filename></title>

      <programlisting>talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd
finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd
ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i</programlisting>
    </example>
    <indexterm><primary><command>tcpd</command></primary></indexterm>

    <para>Il programma <command>tcpd</command> viene frequentemente utilizzato nel file <filename>/etc/inetd.conf</filename>. Consente di limitare le connessioni in entrata mediante l'applicazione di regole di controllo degli accessi, documentate nella pagina di manuale <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry>, e che sono configurate nei file <filename>/etc/hosts.allow</filename> e <filename>/etc/hosts.deny</filename>. Una volta determinato che la connessione è autorizzata, <command>tcpd</command> esegue il server reale (come <command>in.fingerd</command> nel nostro esempio). È bene notare che <command>tcpd</command> si basa sul nome con cui è stato invocato (cioè il primo argomento, <literal>argv[0]</literal>) per identificare l'effettivo programma da eseguire. Perciò non si dovrebbe iniziare la lista degli argomenti con <literal>tcpd</literal> ma con il programma a cui fare da wrapper.</para>

    <sidebar>
      <title><emphasis>COMUNITÀ</emphasis> Wietse Venema</title>
      <indexterm><primary>Wietse Venema</primary></indexterm>
      <indexterm><primary>Venema, Wietse</primary></indexterm>

      <para>Wietse Venema, la cui esperienza in materia di sicurezza lo ha reso un programmatore conosciuto, è l'autore del programma <command>tcpd</command>. Egli è anche il principale artefice di Postfix, il server di posta elettronica modulare (SMTP, Simple Mail Transfer Protocol), progettato per essere più sicuro e più affidabile di <command>sendmail</command> che ha una lunga storia di vulnerabilità di sicurezza.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVA</emphasis> Altri comandi <command>inetd</command></title>

      <para>Sebbene Debian installi <emphasis role="pkg">openbsd-inetd</emphasis> in modo predefinito, le alternative non mancano: possiamo menzionare <emphasis role="pkg">inetutils-inetd</emphasis>, <emphasis role="pkg">micro-inetd</emphasis>, <emphasis role="pkg">rlinetd</emphasis> e <emphasis role="pkg">xinetd</emphasis>.</para>

      <para>Questa ultima incarnazione di un super-server offre possibilità molto interessanti. In particolare, la sua configurazione può essere suddivisa in più file (memorizzati, naturalmente, nella directory <filename>/etc/xinetd.d/</filename>), cosa che può rendere la vita più facile ad un amministratore.</para>

      <para>Ultimo ma non meno importante, è possibile emulare il comportamento di <command>inetd</command> con il meccanismo di socket-activation di <command>systemd</command> (vedere la <xref linkend="sect.systemd" />).</para>
    </sidebar>
  </section>
  <section id="sect.task-scheduling-cron-atd">
    <title>Pianificare attività con <command>cron</command> e <command>atd</command></title>
    <indexterm><primary><command>cron</command></primary></indexterm>
    <indexterm><primary><command>atd</command></primary></indexterm>
    <indexterm><primary>comandi pianificati</primary></indexterm>
    <indexterm><primary>pianificazione di comandi</primary></indexterm>

    <para><command>cron</command> è il demone responsabile dell'esecuzione di comandi pianificati e ricorrenti (ogni giorno, ogni settimana, ecc.); <command>atd</command> è quello che si occupa dei comandi da eseguire una sola volta, ma in un determinato momento nel futuro.</para>

    <para>In un sistema Unix, molte attività sono pianificate per una esecuzione regolare:</para>
    <itemizedlist>
      <listitem>
	<para>rotazione dei log;</para>
      </listitem>
      <listitem>
	<para>aggiornamento del database per il programma <command>locate</command>;</para>
      </listitem>
      <listitem>
	<para>backup;</para>
      </listitem>
      <listitem>
	<para>script di manutenzione (come ad esempio la pulizia dei file temporanei).</para>
      </listitem>
    </itemizedlist>

    <para>Per impostazione predefinita, tutti gli utenti possono programmare l'esecuzione di attività. Ogni utente ha quindi il proprio <emphasis>crontab</emphasis> in cui può registrare i comandi pianificati. Esso può essere modificato eseguendo <command>crontab -e</command> (il suo contenuto è memorizzato nel file <filename>/var/spool/cron/crontab/<replaceable>utente</replaceable></filename>).</para>

    <sidebar>
      <title><emphasis>SICUREZZA</emphasis> Limitare <command>cron</command> o <command>atd</command></title>

      <para>È possibile limitare l'accesso a <command>cron</command> creando un file con autorizzazioni esplicite (whitelist) in <filename>/etc/cron.allow</filename>, in cui si indicano i soli utenti autorizzati a pianificare i comandi. Tutti gli altri saranno automaticamente privati di questa funzionalità. Al contrario, per bloccare solo uno o due utenti problematici, si può scrivere il corrispondente nome utente nel file divieti espliciti (blacklist): <filename>/etc/cron.deny</filename>. Questa stessa caratteristica è disponibile per <command>atd</command>, con i file <filename>/etc/at.allow</filename> e <filename>/etc/at.deny</filename>.</para>
    </sidebar>

    <para>L'utente root ha un proprio <emphasis>crontab</emphasis>, ma può anche utilizzare il file <filename>/etc/crontab</filename>, o scrivere file <emphasis>crontab</emphasis> supplementari nella directory <filename>/etc/cron.d</filename>. Queste ultime due soluzioni presentano il vantaggio di essere in grado di specificare l'identità dell'utente da usare quando si esegue il comando.</para>

    <para>Il pacchetto <emphasis>cron</emphasis> include in modo predefinito alcuni comandi pianificati che eseguono:</para>
    <itemizedlist>
      <listitem>
	<para>i programmi nella directory <filename>/etc/cron.hourly/</filename> una volta ogni ora;</para>
      </listitem>
      <listitem>
	<para>i programmi in <filename>/etc/cron.daily/</filename> una volta al giorno;</para>
      </listitem>
      <listitem>
	<para>i programmi in <filename>/etc/cron.weekly/</filename> una volta a settimana;</para>
      </listitem>
      <listitem>
	<para>i programmi in <filename>/etc/cron.monthly/</filename> una volta al mese.</para>
      </listitem>
    </itemizedlist>

    <para>Molti pacchetti Debian contano su questo servizio: mettendo gli script di manutenzione in queste directory, garantiscono un funzionamento ottimale dei loro servizi.</para>
    <section id="sect.format-crontab">
      <title>Formato del file <filename>crontab</filename></title>
      <indexterm><primary><filename>crontab</filename></primary></indexterm>

      <sidebar>
        <title><emphasis>SUGGERIMENTO</emphasis> Scorciatoie di testo per <command>cron</command></title>

	<para><command>cron</command> riconosce alcune abbreviazioni che sostituiscono i primi cinque campi in una voce di <filename>crontab</filename>. Questi corrispondono alle opzioni di pianificazione più classiche:</para>
        <itemizedlist>
          <listitem>
	    <para><literal>@yearly</literal>: una volta all'anno (1° gennaio alle 00:00);</para>
          </listitem>
          <listitem>
	    <para><literal>@monthly</literal>: una volta al mese (il 1° del mese, alle 00:00);</para>
          </listitem>
          <listitem>
	    <para><literal>@weekly</literal>: una volta a settimana (domenica alle 00:00);</para>
          </listitem>
          <listitem>
	    <para><literal>@daily</literal>: una volta al giorno (alle 00:00);</para>
          </listitem>
          <listitem>
	    <para><literal>@hourly</literal>: una volta all'ora (all'inizio di ogni ora).</para>
          </listitem>
        </itemizedlist>
      </sidebar>

      <sidebar>
        <title><emphasis>CASO SPECIFICO</emphasis><command> cron</command> e l'ora legale</title>

	<para>In Debian, <command>cron</command> tiene in considerazione come meglio può il cambiamento di orario (per l'ora legale, o di fatto per qualsiasi cambiamento significativo nell'ora locale). In questo modo, i comandi che avrebbero dovuto essere eseguiti nel corso di un'ora che non è mai esistita (per esempio, le operazioni pianificate alle 2.30 durante il cambio di primavera in Italia, dato che alle 2.00 l'orologio salta direttamente alle 3.00) vengono eseguiti subito dopo il cambio di orario (e quindi intorno alle 3.00 ora legale). D'altra parte, in autunno, quando i comandi verrebbero eseguiti più volte (2.30 ora legale, poi un'ora dopo, alle 2.30 del mattino, ora standard, in quanto alle 3.00 ora legale l'orologio torna alle 2.00), vengono eseguiti solo una volta.</para>

	<para>Attenzione, tuttavia, che se l'ordine in cui i diversi compiti previsti e il ritardo tra le rispettive esecuzioni sono importanti, si deve verificare la compatibilità di questi vincoli con il comportamento di <command>cron</command>; se necessario, si può preparare un piano speciale per quelle due notti problematiche all'anno.</para>
      </sidebar>

      <para>Ogni riga significativa di <emphasis>crontab</emphasis> descrive un comando programmato con i sei (o sette) seguenti campi:</para>
      <itemizedlist>
        <listitem>
	  <para>il valore per il minuto (numero da 0 a 59);</para>
        </listitem>
        <listitem>
	  <para>il valore per l'ora (da 0 a 23);</para>
        </listitem>
        <listitem>
	  <para>il valore per il giorno del mese (da 1 a 31);</para>
        </listitem>
        <listitem>
	  <para>il valore per il mese (da 1 a 12);</para>
        </listitem>
        <listitem>
	  <para>il valore per il giorno della settimana (da 0 a 7, con 1 che corrisponde a lunedì, e domenica che è rappresentata sia da 0 che da 7; è anche possibile utilizzare le prime tre lettere del nome del giorno della settimana in inglese, come <literal>Sun</literal>, <literal>Mon</literal>, ecc.);</para>
        </listitem>
        <listitem>
	  <para>il nome utente dell'identità con cui deve essere eseguito il comando (nel file <filename>/etc/crontab</filename> e nei frammenti situati in <filename>/etc/cron.d/</filename>, ma non nei file crontab degli utenti);</para>
        </listitem>
        <listitem>
	  <para>il comando da eseguire (quando le condizioni definite dalle prime cinque colonne sono soddisfatte).</para>
        </listitem>
      </itemizedlist>

      <para>Tutti questi dettagli sono documentati nella pagina di manuale <citerefentry><refentrytitle>crontab</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para>

      <para>Ogni valore può essere espresso nella forma di un elenco di possibili valori (separati da virgole). La sintassi <literal>a-b</literal> descrive l'intervallo di tutti i valori tra <literal>a</literal> e <literal>b</literal>. La sintassi <literal>a-b/c</literal> descrive l'intervallo con un incremento <literal>c</literal> (esempio: <literal>0-10/2</literal> significa <literal>0,2,4,6,8,10</literal>). Un asterisco <literal>*</literal> è un carattere jolly che rappresenta tutti i possibili valori.</para>

      <example id="example.crontab">
        <title>Esempio di file <filename>crontab</filename></title>

        <programlisting>#Format
#min hour day mon dow  command

# Download data every night at 7:25 pm
 25  19   *   *   *    $HOME/bin/get.pl

# 8:00 am, on weekdays (Monday through Friday)
 00  08   *   *   1-5  $HOME/bin/dosomething

# Restart the IRC proxy after each reboot
@reboot /usr/bin/dircproxy</programlisting>
      </example>

      <sidebar>
        <title><emphasis>SUGGERIMENTO</emphasis> Esecuzione di un comando all'avvio del sistema</title>

	<para>Per eseguire un comando una sola volta, subito dopo l'avvio del computer, è possibile utilizzare la macro <literal>@reboot</literal> (un semplice riavvio di <command>cron</command> non innesca un comando pianificato con <literal>@reboot</literal>). Questa macro sostituisce i primi cinque campi di una voce <emphasis>crontab</emphasis>.</para>
      </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVA</emphasis> Emulare <command>cron</command> con <command>systemd</command></title>

      <para>E' possibile emulare parte del comportamento di <command>cron</command> con il meccanismo timer di <command>systemd</command> (vedere la <xref linkend="sect.systemd" />).</para>
    </sidebar>

    </section>
    <section id="sect.at-command">
      <title>Utilizzo del comando <command>at</command></title>
      <indexterm><primary><command>at</command></primary></indexterm>

      <para>Il comando <command>at</command> esegue un comando in un specifico momento nel futuro. Basta specificare come parametri della riga di comando la data e l'ora desiderata, e il comando da eseguire nel suo standard input. Il comando verrà eseguito come se fosse stato inserito nella shell corrente. <command>at</command> si preoccupa anche di mantenere l'ambiente attuale, in modo da riprodurre le stesse condizioni quando esegue il comando. L'ora viene indicata seguendo le solite convenzioni: <literal>16:12</literal> o <literal>4:12 PM</literal> rappresentano le 16.12. La data può essere specificata in diversi formati europei ed occidentali, che includono <literal>GG.MM.AA</literal> (<literal>27.07.15</literal> rappresenta quindi il 27 luglio 2015), <literal>AAAA-MM-GG</literal> (questa stessa data è indicata con <literal>2015-07-27</literal>), <literal>MM/GG/[CC]AA</literal> (cioè, <literal>12/25/15</literal> o <literal>12/25/2015</literal> rappresenterà il 25 dicembre 2015), o semplicemente <literal>MMGG[CC]AA</literal> (in modo che <literal>122515</literal> o <literal>12252015</literal> rappresenteranno, anch'esse, il 25 dicembre 2015). Senza di essa, il comando verrà eseguito non appena l'orologio raggiunge l'ora indicata (lo stesso giorno, o il successivo se quell'ora è già passata durante lo stesso giorno). Si può anche semplicemente scrivere "today»" (oggi) o "tomorrow" (domani) che si spiegano da soli.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>
<computeroutput>&gt; </computeroutput><userinput>echo "Don't forget to wish a Happy Birthday to Raphaël!" \</userinput>
<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>
<computeroutput>&gt; </computeroutput><userinput>END</userinput>
<computeroutput>warning: commands will be executed using /bin/sh
job 31 at Mon Jul 27 09:00:00 2015</computeroutput></screen>

      <para>Una sintassi alternativa rimanda l'esecuzione per un determinato periodo: <command>at now + <replaceable>numero</replaceable> <replaceable>periodo</replaceable></command>. <replaceable>periodo</replaceable> può essere <literal>minutes</literal>, <literal>hours</literal>, <literal>days</literal> o <literal>weeks</literal>. <replaceable>numero</replaceable> indica semplicemente il numero di dette unità che devono trascorrere prima dell'esecuzione del comando.</para>

      <para>Per annullare un'operazione pianificata in <command>cron</command>, è sufficiente eseguire <command>crontab -e</command> ed eliminare la riga corrispondente nel file <emphasis>crontab</emphasis>. Per le attività <command>at</command>, è quasi altrettanto facile: eseguire <command>atrm <replaceable>numero-attività</replaceable></command>. Il numero dell'attività è indicato dal comando <command>at</command> quando la si pianifica, ma è possibile ritrovarlo con il comando <command>atq</command>, che mostra l'attuale elenco di operazioni pianificate.</para>
      <indexterm><primary><command>atrm</command></primary></indexterm>
      <indexterm><primary><command>atq</command></primary></indexterm>
    </section>
  </section>
  <section id="sect.asynchronous-task-scheduling-anacron">
    <title>Pianificazione di attività asincrone: <command>anacron</command></title>

    <para><command>anacron</command> è il demone che completa <command>cron</command> per i computer che non sono sempre accesi. Dal momento che le attività normali sono di solito programmate per la metà della notte, non saranno mai eseguite se il computer è spento in quel momento. Lo scopo di <command>anacron</command> è quello di eseguirle, tenendo conto dei periodi in cui il computer non funziona.</para>
    <indexterm><primary><command>anacron</command></primary></indexterm>

    <para>Da notare che <command>anacron</command> molto spesso esegue le attività pochi minuti dopo l'avvio della macchina, il che può rendere il computer meno reattivo. Ecco perché i compiti nel file <filename>/etc/anacrontab</filename> vengono avviati con il comando <command>nice</command>, che riduce la priorità di esecuzione e limita così il loro impatto sul resto del sistema. Attenzione al fatto che il formato del file non è lo stesso di <filename>/etc/crontab</filename>; se si hanno esigenze particolari per <command>anacron</command>, consultare la pagina di manuale <citerefentry><refentrytitle>anacrontab</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para>

    <sidebar>
      <title><emphasis>FONDAMENTALI</emphasis> Priorità e <command>nice</command></title>

      <para>I sistemi Unix (e quindi Linux) sono sistemi multi-tasking e multi-utente. Infatti, più processi possono essere eseguiti in parallelo, ed essere di proprietà di diversi utenti: il kernel controlla l'accesso alle risorse dei diversi processi. Come parte di questo compito, ha un concetto di priorità, che consente di favorire certi processi rispetto ad altri, secondo le necessità. Quando si sa che un processo può essere eseguito a bassa priorità, è possibile indicarlo eseguendolo con <command>nice <replaceable>programma</replaceable></command>. Il programma avrà quindi una quota minore della CPU, e avrà un minore impatto su altri processi in esecuzione. Naturalmente, se nessun altro processo deve essere eseguito, il programma non verrà artificialmente rallentato.</para>

      <para><command>nice</command> lavora con «livelli di nice»: i livelli positivi (da 1 a 19) diminuiscono progressivamente la priorità, mentre i livelli negativi (da -1 a -20) la aumentano, ma solo root può usare questi livelli negativi. Salvo diversa indicazione (si veda la pagina di manuale <citerefentry><refentrytitle>nice</refentrytitle><manvolnum>1</manvolnum></citerefentry>), <command>nice</command> aumenta il livello corrente di 10.</para>

      <para>Se ci si accorge che un compito già in esecuzione avrebbe dovuto essere avviato con <command>nice</command> non è troppo tardi per risolvere il problema: il comando <command>renice</command> modifica la priorità di un processo già in esecuzione, in entrambe le direzioni (ma ridurre il «livello di nice» di un processo è riservato all'utente root).</para>
    </sidebar>

    <para>L'installazione del pacchetto <emphasis role="pkg">anacron</emphasis> disattiva tramite <command>cron</command> l'esecuzione degli script nelle directory <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename> e <filename>/etc/cron.monthly/</filename>. Questo evita la loro doppia esecuzione tramite <command>anacron</command> e <command>cron</command>. Il comando <command>cron</command> rimane attivo e continuerà a gestire le altre attività programmate (in particolare quelle pianificate dagli utenti).</para>
  </section>
  <section id="sect.quotas">
    <title>Quote</title>
    <indexterm><primary>quota</primary></indexterm>

    <para>Il sistema delle quote permette di limitare lo spazio su disco assegnato a un utente o a un gruppo di utenti. Per configurarlo, è necessario disporre di un kernel che lo supporti (compilato con l'opzione <varname>CONFIG_QUOTA</varname>) — come è nel caso dei kernel di Debian. Il software di gestione delle quote si trova nel pacchetto Debian <emphasis role="pkg">quota</emphasis>.</para>

    <para>Per attivare le quote in un file system, è necessario indicare le opzioni <literal>usrquota</literal> e <literal>grpquota</literal> in <filename>/etc/fstab</filename> per le quote di utenti e gruppi, rispettivamente. Riavviare il computer quindi aggiornerà le quote in assenza di attività del disco (una condizione necessaria per un'adeguata contabilità dello spazio su disco già utilizzato).</para>

    <para>Il comando <command>edquota <replaceable>utente</replaceable></command> (o <command>edquota -g <replaceable>gruppo</replaceable></command>) consente di modificare i limiti mentre si controlla l'utilizzo attuale dello spazio su disco.</para>
    <indexterm><primary><command>edquota</command></primary></indexterm>

    <sidebar>
      <title><emphasis>APPROFONDIMENTO</emphasis> Definire le quote con uno script</title>
      <indexterm><primary><command>setquota</command></primary></indexterm>

      <para>Il programma <command>setquota</command> può essere utilizzato in uno script per cambiare automaticamente numerose quote. La sua pagina di manuale <citerefentry><refentrytitle>setquota</refentrytitle><manvolnum>8</manvolnum></citerefentry> descrive la sintassi da utilizzare.</para>
    </sidebar>

    <para>Il sistema delle quote consente di impostare quattro limiti:</para>
    <itemizedlist>
      <listitem>
	<para>due limiti (chiamati «soft» e «hard») si riferiscono al numero di blocchi consumati. Se il file system è stato creato con una dimensione dei blocchi di 1 kibibyte, un blocco contiene 1024 byte di uno stesso file. Blocchi non saturi quindi portano a perdite di spazio su disco. Una quota di 100 blocchi, che permette teoricamente la memorizzazione di 102.400 byte, sarà comunque satura con soli 100 file di 500 byte ciascuno, che rappresentano solo 50.000 byte in totale.</para>
      </listitem>
      <listitem>
	<para>due limiti (soft e hard) si riferiscono al numero di inode utilizzati. Ogni file occupa almeno un inode per memorizzare le sue informazioni (permessi, proprietario, data e ora dell'ultimo accesso, ecc.). È quindi un limite al numero di file dell'utente.</para>
      </listitem>
    </itemizedlist>

    <para>Un limite «soft» può essere temporaneamente superato, l'utente sarà semplicemente avvertito che sta superando la quota dal comando <command>warnquota</command>, che di solito è invocato da <command>cron</command>. Un limite «hard» non può mai essere superato: il sistema rifiuterà qualsiasi operazione che causerebbe il superamento della quota.</para>

    <sidebar>
      <title><emphasis>VOCABOLARIO</emphasis> Blocchi e inode</title>
      <indexterm><primary>blocco (disco)</primary></indexterm>
      <indexterm><primary>inode</primary></indexterm>

      <para>Il file system divide il disco rigido in blocchi: piccole aree contigue. La dimensione di questi blocchi è definita durante la creazione del file system, e varia generalmente tra 1 e 8 kibibyte.</para>

      <para>Un blocco può essere utilizzato per memorizzare i dati reali di un file, o per i meta-dati utilizzati dal file system. Tra questi metadati, in particolare ci sono gli inode. Un inode utilizza un blocco sul disco rigido (ma questo blocco non è preso in considerazione per la quota dei blocchi, ma solo per la quota degli inode), e contiene sia le informazioni sul file a cui corrisponde (nome, proprietario, permessi, ecc.) sia i puntatori ai blocchi di dati che vengono effettivamente utilizzati. Per i file molto grandi che occupano un numero di blocchi più alto di quella a cui è possibile fare riferimento in un singolo inode, esiste un sistema di blocchi indiretto; l'inode fa riferimento ad un elenco di blocchi che non contengono direttamente i dati, ma un altro elenco di blocchi.</para>
    </sidebar>
    <indexterm><primary><command>warnquota</command></primary></indexterm>

    <para>Con il comando <command>edquota -t</command>, è possibile definire un «periodo di grazia» massimo autorizzato in cui un limite soft può essere superato. Dopo questo periodo, il limite soft verrà trattato come un limite rigido («hard»), e l'utente dovrà ridurre l'utilizzo dello spazio su disco entro questo limite per poter scrivere altro sul disco rigido.</para>

    <sidebar>
      <title><emphasis>APPROFONDIMENTO</emphasis> Impostazione di una quota predefinita per i nuovi utenti</title>

      <para>Per configurare automaticamente una quota per i nuovi utenti, è necessario configurare un modello di utente (con <command>edquota</command> o <command>setquota</command>) ed indicare il loro nome utente nella variabile <varname>QUOTAUSER</varname> del file <filename>/etc/adduser.conf</filename>. Questa configurazione della quota verrà applicata automaticamente ad ogni nuovo utente creato con il comando <command>adduser</command>.</para>
    </sidebar>
  </section>
  <section id="sect.backup">
    <title>Backup</title>

    <para>Fare copie di backup è uno dei compiti principali di ogni amministratore, ma rappresenta un argomento complesso, che coinvolge potenti strumenti che sono spesso difficili da padroneggiare.</para>
    <indexterm><primary>backup</primary></indexterm>
    <indexterm><primary>ripristino</primary></indexterm>

    <para>Esistono molti programmi, come <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. Sono sistemi client/server con molte opzioni, la cui configurazione è piuttosto difficile. Alcuni di essi forniscono interfacce web facili da usare per mitigare il problema. Debian tuttavia contiene decine di altri software per i backup che coprono tutti i casi d'uso, come si può facilmente confermare con <command>apt-cache search backup</command>.</para>
    <indexterm><primary><command>amanda</command></primary></indexterm>
    <indexterm><primary><command>bacula</command></primary></indexterm>
    <indexterm><primary><command>BackupPC</command></primary></indexterm>

    <para>Invece di descriverne in dettaglio alcuni, questa sezione esporrà i pensieri degli amministratori della Falcot Corp quando definirono la loro strategia di backup.</para>

    <para>Nella Falcot Corp, i backup hanno due obiettivi: recuperare i file erroneamente cancellati e ripristinare rapidamente qualsiasi computer (server o desktop), il cui disco rigido è venuto meno.</para>
    <section>
      <title>Backup con <command>rsync</command></title>

      <para>Dato che i backup su nastro sono stati ritenuti troppo lenti e costosi, il backup dei dati viene fatto su hard disk su un server dedicato, in cui l'uso di RAID software (vedere la <xref linkend="sect.raid-soft" />) proteggerà i dati da guasti del disco rigido. I backup dei computer desktop non vengono fatti singolarmente, ma gli utenti sono avvisati che verrà eseguito il backup del loro account personale sul file server del proprio dipartimento. Il comando <command>rsync</command> (dal pacchetto omonimo) viene utilizzato quotidianamente per eseguire il backup di questi server diversi.</para>
      <indexterm><primary><command>rsync</command></primary></indexterm>

      <sidebar>
        <title><emphasis>FONDAMENTALI</emphasis> Il collegamento fisico, un secondo nome per il file</title>
        <indexterm><primary>collegamento</primary><secondary>collegamento fisico</secondary></indexterm>
        <indexterm><primary>hard link</primary></indexterm>

	<para>Un collegamento fisico, al contrario di un collegamento simbolico, non può essere distinto dal file collegato. La creazione di un collegamento fisico essenzialmente equivale a dare ad un file esistente un secondo nome. Ecco perché la rimozione di un collegamento fisico rimuove solo uno dei nomi associati al file. Finché un altro nome è ancora assegnato al file, i dati in esso rimangono presenti sul file system. È interessante notare che, a differenza di una copia, il collegamento fisico non occupa spazio aggiuntivo sul disco rigido.</para>

	<para>Un collegamento fisico viene creato con il comando <command>ln <replaceable>obiettivo</replaceable> <replaceable>collegamento</replaceable></command>. Il file <replaceable>collegamento</replaceable> è quindi un nuovo nome per il file <replaceable>obiettivo</replaceable>. I collegamenti fisici possono essere creati solo sullo stesso file system, mentre i collegamenti simbolici non sono soggetti a questa limitazione.</para>
      </sidebar>

      <para>Lo spazio disponibile sul disco fisso vieta l'attuazione di un backup completo ogni giorno. Pertanto, il comando <command>rsync</command> è preceduto da una duplicazione del contenuto del backup precedente con collegamenti fisici, il che impedisce l'utilizzo eccessivo di spazio su disco. Il processo <command>rsync</command> quindi sostituisce solo i file che sono stati modificati dall'ultimo backup. Con questo meccanismo un gran numero di backup può essere mantenuto in una piccola quantità di spazio. Dal momento che tutti i backup sono immediatamente disponibili e accessibili (per esempio, in diverse directory di una determinata condivisione della rete), è possibile fare rapidamente paragoni tra due date.</para>
      <indexterm><primary>copia, copia di backup</primary></indexterm>
      <indexterm><primary>backup</primary><secondary>copia</secondary></indexterm>
      <indexterm><primary><emphasis role="pkg">dirvish</emphasis></primary></indexterm>

      <para>Questo meccanismo di backup viene facilmente implementato con il programma <command>dirvish</command>. Utilizza uno spazio di archiviazione di backup («banca» nel suo vocabolario), in cui colloca copie con l'indicazione della data di insiemi di file di backup (questi insiemi sono chiamati «casseforti» («vault») nella documentazione di dirvish).</para>

      <para>La configurazione principale è nel file <filename>/etc/dirvish/master.conf</filename>. Esso definisce la posizione dello spazio di archiviazione di backup, l'elenco delle «casseforti» da gestire, ed i valori predefiniti per la scadenza dei backup. Il resto della configurazione si trova nel file <filename><replaceable>banca</replaceable>/<replaceable>cassaforte</replaceable>/dirvish/default.conf</filename> e contiene una configurazione specifica per il corrispondente insieme di file.</para>

      <example id="example.dirvish-master">
        <title>Il file <filename>/etc/dirvish/master.conf</filename></title>

        <programlisting>bank:
    /backup
exclude:
    lost+found/
    core
    *~
Runall:
    root    22:00
expire-default: +15 days
expire-rule:
#   MIN HR    DOM MON       DOW  STRFTIME_FMT
    *   *     *   *         1    +3 months
    *   *     1-7 *         1    +1 year
    *   *     1-7 1,4,7,10  1</programlisting>
      </example>

      <para>L'impostazione <literal>bank</literal> indica la directory in cui sono memorizzati i backup. L'impostazione <literal>exclude</literal> consente di indicare i file (o i tipi di file) da escludere dal backup. <literal>Runall</literal> è un elenco di insiemi di file di cui fare il backup, ciascuno con una marcatura temporale che permette di assegnare la data corretta alla copia nel caso in cui il backup non venga avviato precisamente al tempo stabilito. Si deve indicare una data appena precedente all'effettiva ora di esecuzione (che in Debian sono in modo predefinito le 22.04, secondo il contenuto di <filename>/etc/cron.d/dirvish</filename>). Da ultimo, le impostazioni <literal>expire-default</literal> e <literal>expire-rule</literal> definiscono la politica di scadenza per i backup. Nell'esempio precedente vengono conservati per sempre i backup che sono generati la prima domenica di ogni trimestre, quelli della prima domenica di ogni mese sono cancellati dopo un anno e quelli delle altre domeniche dopo 3 mesi. Gli altri backup giornalieri sono conservati per 15 giorni. L'ordine in cui sono scritte le regole non ha importanza, Dirvish usa l'ultima regola che fa corrispondenza, o <literal>expire-default</literal> se nessuna altra regola <literal>expire-rule</literal> corrisponde.</para>

      <sidebar>
        <title><emphasis>IN PRATICA</emphasis> Scadenza programmata</title>

	<para>Le regole di scadenza non vengono utilizzate da <command>dirvish-expire</command> per fare il suo lavoro. In realtà, le regole di scadenza vengono applicate quando si crea una nuova copia di backup per definire la data di scadenza associata a quella copia. <command>dirvish-expire</command> analizza semplicemente le copie memorizzate ed elimina quelle per le quali la data di scadenza è trascorsa.</para>
      </sidebar>

      <example id="example.dirvish-vault">
        <title>Il file <filename>/backup/root/dirvish/default.conf</filename></title>

        <programlisting>client: rivendell.falcot.com
tree: /
xdev: 1
index: gzip
image-default: %Y%m%d
exclude:
    /var/cache/apt/archives/*.deb
    /var/cache/man/**
    /tmp/**
    /var/tmp/**
    *.bak</programlisting>
      </example>

      <para>L'esempio precedente specifica l'insieme di file di cui eseguire il backup: questi sono i file sulla macchina <emphasis>rivendell.falcot.com</emphasis> (per il backup locale dei dati, è sufficiente specificare il nome della macchina locale come indicato da <command>hostname</command>), in particolare quelli nell'albero radice (<literal>tree: /</literal>), eccetto quelli elencati in <literal>exclude</literal>. Il backup sarà limitato ai contenuti di un file system (<literal>xdev: 1</literal>). Non include i file da altri punti di mount. Sarà generato un indice dei file salvati (<literal>index: gzip</literal>), e il nome dell'immagine sarà creato in base alla data corrente (<literal>image-default: %Y%m%d</literal>).</para>

      <para>Ci sono molte opzioni disponibili, tutte documentate nella pagina di manuale <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>. Una volta che questi file di configurazione sono impostati, è necessario inizializzare ogni insieme di file con il comando <command>dirvish --vault <replaceable>cassaforte</replaceable> --init</command>. Da quel momento in poi l'invocazione quotidiana di <command>dirvish-runall</command> creerà automaticamente una nuova copia di backup subito dopo aver cancellato quelle scadute.</para>

      <sidebar>
        <title><emphasis>IN PRATICA</emphasis> Backup remoto tramite SSH</title>

	<para>Quando dirvish ha bisogno di salvare i dati in un computer remoto, utilizzerà <command>ssh</command> per connettersi ed avvierà <command>rsync</command> come server. Questo richiede che l'utente root sia in grado di connettersi automaticamente. L'utilizzo di una chiave di autenticazione SSH consente appunto questo (vedere la <xref linkend="sect.ssh-key-based-auth" />).</para>
      </sidebar>
    </section>
    <section>
      <title>﻿Ripristino di macchine senza backup</title>

      <para>I computer desktop, di cui non esiste il backup, saranno facile da reinstallare da DVD-ROM personalizzati preparati con <emphasis>Simple-CDD</emphasis> (vedere la <xref linkend="sect.simple-cdd" />). Dato che questo fa un'installazione da zero, viene persa ogni personalizzazione eventualmente fatta dopo l'installazione iniziale. Ciò non è un problema, dato che i sistemi sono tutti agganciati ad una directory LDAP centralizzata per gli account e la maggior parte delle applicazioni desktop è preconfigurata grazie a dconf (per ulteriori informazioni su questo vedere la <xref linkend="sect.gnome-desktop" />).</para>

      <para>Gli amministratori della Falcot Corp sono consapevoli dei limiti della loro politica di backup. Dal momento che non possono proteggere il server di backup così efficacemente come un nastro in una cassetta di sicurezza a prova di fuoco, l'hanno installato in una stanza separata in modo che un disastro come un incendio nella stanza del server non distruggerà i backup insieme a tutto il resto. Inoltre, ne fanno un backup incrementale su DVD-ROM, una volta a settimana: vengono inclusi solo quei file che sono stati modificati dopo l'ultimo backup.</para>

      <sidebar>
        <title><emphasis>APPROFONDIMENTO</emphasis> Backup dei servizi SQL e LDAP</title>

	<para>Per molti servizi (ad esempio i database SQL o LDAP) non è possibile fare il backup semplicemente copiando i loro file (a meno che non siano interrotti correttamente durante la creazione dei backup, il che è spesso problematico, in quanto sono destinati ad essere disponibili in qualsiasi momento). Perciò, è necessario utilizzare un meccanismo di «esportazione» per creare un «dump dei dati» di cui si può tranquillamente fare il backup. Si tratta spesso di file di grandi dimensioni, ma si comprimono bene. Per ridurre lo spazio di archiviazione necessario, è consigliato salvare un file di testo completo a settimana, e un <command>diff</command> ogni giorno, creato con un comando del tipo <command>diff <replaceable>file_di_ieri</replaceable> <replaceable>file_di_oggi</replaceable></command>. Il programma <command>xdelta</command> produce differenze incrementali da dump binari.</para>
        <indexterm><primary><command>xdelta</command></primary></indexterm>
        <indexterm><primary><command>diff</command></primary></indexterm>
        <indexterm><primary>dump</primary></indexterm>
      </sidebar>

      <sidebar>
        <title><emphasis>CULTURA</emphasis> <emphasis>TAR</emphasis>, lo standard per i backup su nastro</title>
        <indexterm><primary>backup</primary><secondary>su nastro</secondary></indexterm>
        <indexterm><primary>nastro, backup</primary></indexterm>
        <indexterm><primary>TAR</primary></indexterm>

	<para>Storicamente, il mezzo più semplice per fare un backup in Unix era quello di memorizzare un archivio <emphasis>TAR</emphasis> su un nastro. Il comando <command>tar</command> ha preso il suo nome da «Tape ARchive» (archivio su nastro).</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.hotplug">
    <title>Collegamento a caldo: <emphasis>hotplug</emphasis></title>
    <section>
      <title>Premessa</title>

      <para>Il sottosistema <emphasis>hotplug</emphasis> del kernel gestisce dinamicamente l'aggiunta e la rimozione dei dispositivi, caricando i driver appropriati e creando i corrispondenti file di device (con l'aiuto di <command>udevd</command>). Con l'hardware moderno e la virtualizzazione, quasi tutto può essere inserito a caldo: dalle comuni periferiche USB/PCM/IEEE 1394 agli hard disk SATA, ma anche la CPU e la memoria.</para>

      <para>Il kernel ha un database che associa ogni ID di dispositivo con il driver richiesto. Questo database viene utilizzato durante l'avvio per caricare tutti i driver per le periferiche rilevate sui diversi bus, ma anche quando viene aggiunto un dispositivo supplementare collegato a caldo. Una volta che il dispositivo è pronto all'uso, viene inviato un messaggio a <command>udevd</command> che quindi sarà in grado di creare la voce corrispondente in <filename>/dev/</filename>.</para>

      <indexterm><primary><emphasis>hotplug</emphasis></primary></indexterm>
      <indexterm><primary>collegamento a caldo (hotplug)</primary></indexterm>
      <indexterm><primary>USB</primary></indexterm>
      <indexterm><primary>IEEE 1394</primary></indexterm>
      <indexterm><primary>PCMCIA</primary></indexterm>
      <indexterm><primary>SATA</primary></indexterm>
    </section>
    <section>
      <title>Il problema dei nomi</title>

      <para>Prima della comparsa dei collegamenti a caldo, era facile assegnare un nome fisso ad un dispositivo. Esso era basato semplicemente sulla posizione dei dispositivi sui loro rispettivi bus. Ma questo non è possibile quando tali dispositivi possono andare e venire sul bus. Il caso tipico è l'uso di una macchina fotografica digitale e una chiave USB che appaiono entrambe al computer come unità disco. La prima ad essere collegata potrebbe essere <filename>/dev/sdb</filename> e la seconda <filename>/dev/sdc</filename> (con <filename>/dev/sda</filename> che rappresenta il disco rigido del computer). Il nome del dispositivo non è fisso, ma dipende dall'ordine in cui sono collegati i dispositivi.</para>

      <para>Inoltre, sempre più driver usano valori dinamici per i numeri maggiori/minori di device, il che rende impossibile avere voci statiche per i dispositivi indicati, in quanto tali caratteristiche essenziali possono variare dopo un riavvio.</para>

      <para><emphasis>udev</emphasis> è stato creato proprio per risolvere questo problema.</para>

      <sidebar>
        <title><emphasis>IN PRATICA</emphasis> Gestione delle schede di rete</title>

	<para>Molti computer hanno più schede di rete (a volte due interfacce cablate e un'interfaccia wifi), e con il supporto per <emphasis>hotplug</emphasis> per la maggior parte dei tipi di bus, il kernel di Linux non garantisce una denominazione fissa per le interfacce di rete. Ma un utente che vuole configurare la propria rete in <filename>/etc/network/interfaces</filename> ha bisogno di un nome fisso!</para>

	<para>Sarebbe difficile chiedere ad ogni utente di creare le proprie regole <emphasis>udev</emphasis> per affrontare questo problema. Questo è il motivo per cui <emphasis>udev</emphasis> è stato configurato in un modo piuttosto singolare; al primo avvio (e, più in generale, ogni volta che appare una nuova scheda di rete) utilizza il nome dell'interfaccia di rete e il suo indirizzo MAC per creare nuove regole che riassegneranno lo stesso nome agli avvii successivi. Queste regole sono memorizzate in <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>.</para>

        
	<para>Questo meccanismo produce alcuni effetti collaterali che bisogna conoscere. Consideriamo il caso di computer che hanno una sola scheda di rete PCI. L'interfaccia di rete è denominata <literal>eth0</literal>, logicamente. Ora immaginiamo che la scheda si rompa, e l'amministratore la sostituisca, la nuova scheda avrà un nuovo indirizzo MAC. Dal momento che alla vecchia scheda era stato assegnato il nome <literal>eth0</literal>, alla nuova verrà assegnato <literal>eth1</literal>, anche se la scheda <literal>eth0</literal> è andata per sempre (e la rete non sarà funzionante, perché <filename>/etc/network/interfaces</filename> configura probabilmente un'interfaccia <literal>eth0</literal>). In questo caso, è sufficiente eliminare semplicemente il file <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> presente prima di riavviare il computer. Alla nuova scheda verrà allora assegnato il nome atteso <literal>eth0</literal>.</para>
      </sidebar>
    </section>
    <section>
      <title>Come funziona <emphasis>udev</emphasis></title>

      <para>Quando il kernel notifica a <emphasis>udev</emphasis> la comparsa di un nuovo dispositivo, quest'ultimo raccoglie diverse informazioni sul dispositivo dato consultando le voci corrispondenti in <filename>/sys/</filename>, specialmente quelle che lo identificano in modo univoco (indirizzo MAC di una scheda di rete, numero di serie per alcuni dispositivi USB, ecc.).</para>

      <para>Armato di tutte queste informazioni, <emphasis>udev</emphasis> consulta allora tutte le regole contenute in <filename>/etc/udev/rules.d/</filename> e <filename>/lib/udev/rules.d/</filename>. In base a ciò decide quale nome dare al device, quali collegamenti simbolici creare (per avere nomi alternativi), e quali comandi eseguire. Tutti questi file vengono consultati e tutte le regole vengono valutate in sequenza (tranne quando un file utilizza direttive «GOTO»). Così, vi possono essere diverse regole che corrispondono ad un dato evento.</para>

      <para>La sintassi dei file delle regole è molto semplice: ogni riga contiene i criteri di selezione e le assegnazioni delle variabili. I primi sono utilizzati per selezionare gli eventi per i quali esiste una necessità di reagire, mentre le seconde definiscono l'azione da eseguire. Sono tutti semplicemente separati da virgole e l'operatore distingue implicitamente tra un criterio di selezione (con operatori di confronto, come <literal>==</literal> o <literal>!=</literal>) e una direttiva di assegnazione (con operatori come <literal>=</literal>, <literal>+=</literal> o <literal>:=</literal>).</para>

      <para>Gli operatori di confronto vengono utilizzati per le seguenti variabili:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>KERNEL</literal>: il nome che il kernel assegna al device;</para>
        </listitem>
        <listitem>
	  <para><literal>ACTION</literal>: l'azione corrispondente all'evento («add» quando un dispositivo è stato aggiunto, «remove» quando è stato rimosso);</para>
        </listitem>
        <listitem>
	  <para><literal>DEVPATH</literal>: il percorso della voce in <filename>/sys/</filename> per il dispositivo;</para>
        </listitem>
        <listitem>
	  <para><literal>SUBSYSTEM</literal>: il sottosistema del kernel che ha generato la richiesta (ce ne sono molti, ma alcuni esempi sono «usb», «ide», «net», «firmware», ecc.);</para>
        </listitem>
        <listitem>
	  <para><literal>ATTR{<replaceable>attributo</replaceable>}</literal>: il contenuto del file <replaceable>attributo</replaceable> nella directory <filename>/sys/<replaceable>$devpath</replaceable>/</filename> del dispositivo. Qui è possibile trovare l'indirizzo MAC e altri identificatori specifici dei bus;</para>
        </listitem>
        <listitem>
	  <para><literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> e <literal>ATTRS{<replaceable>attributi</replaceable>}</literal> sono variazioni che cercheranno di soddisfare le diverse opzioni su uno dei dispositivi progenitori del dispositivo di corrente;</para>
        </listitem>
        <listitem>
	  <para><literal>PROGRAM</literal>: delega il test al programma indicato (true se restituisce 0, false in caso contrario). Il contenuto dello standard output del programma è memorizzato in modo da poter essere riutilizzato dal test <literal>RESULT</literal>;</para>
        </listitem>
        <listitem>
	  <para><literal>RESULT</literal>: esegue test sullo standard output memorizzato durante l'ultima chiamata a <literal>PROGRAM</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>Gli operandi di destra possono utilizzare modelli di espressioni per trovare corrispondere a diversi valori allo stesso tempo. Ad esempio, <literal>*</literal> corrisponde a qualsiasi stringa (anche vuota), <literal>?</literal> corrisponde a qualsiasi carattere e <literal>[]</literal> corrisponde all'insieme di caratteri elencati tra le parentesi quadre (o l'opposto se il primo carattere è un punto esclamativo, e gli intervalli di caratteri contigui sono indicati come <literal>a-z</literal>).</para>

      <para>Per quanto riguarda gli operatori di assegnazione, <literal>=</literal> assegna un valore (e sostituisce il valore corrente); nel caso di un elenco, questo viene svuotato e contiene solo il valore assegnato. <literal>:=</literal> fa la stessa cosa, ma impedisce successive modifiche alla stessa variabile. Per quanto riguarda <literal>+=</literal>, esso aggiunge un elemento a un elenco. Le seguenti variabili possono essere modificate:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>NAME</literal>: il nome del file di device da creare in <filename>/dev/</filename>. Vale solo la prima assegnazione, le altre vengono ignorate;</para>
        </listitem>
        <listitem>
	  <para><literal>SYMLINK</literal>: l'elenco dei collegamenti simbolici che puntano allo stesso device;</para>
        </listitem>
        <listitem>
	  <para><literal>OWNER</literal>, <literal>GROUP</literal> e <literal>MODE</literal> definiscono l'utente e il gruppo che possiedono il device, nonché i permessi associati;</para>
        </listitem>
        <listitem>
	  <para><literal>RUN</literal>: l'elenco dei programmi da eseguire in risposta a questo evento.</para>
        </listitem>
      </itemizedlist>

      <para>I valori assegnati a queste variabili possono utilizzare diverse sostituzioni:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>$kernel</literal> o <literal>%k</literal>: equivalente a <literal>KERNEL</literal>;</para>
        </listitem>
        <listitem>
	  <para><literal>$number</literal> o <literal>%n</literal>: il numero d'ordine del dispositivo, per esempio, per <literal>sda3</literal> sarebbe «3»;</para>
        </listitem>
        <listitem>
	  <para><literal>$devpath</literal> o <literal>%p</literal>: equivalente a <literal>DEVPATH</literal>;</para>
        </listitem>
        <listitem>
	 
	  <para><literal>$attr{<replaceable>attributo</replaceable>}</literal> o <literal>%s{<replaceable>attributo</replaceable>}</literal>: equivalente a <literal>ATTRS {<replaceable>attributo</replaceable>}</literal>;</para>
        </listitem>
        <listitem>
	  <para><literal>$major</literal> o <literal>%M</literal>: il numero kernel maggiore del device;</para>
        </listitem>
        <listitem>
	  <para><literal>$minor</literal> o <literal>%m</literal>: il numero kernel minore del device;</para>
        </listitem>
        <listitem>
	  <para><literal>$result</literal> o <literal>%c</literal>: la stringa prodotta in output dell'ultimo programma invocato da <literal>PROGRAM</literal>;</para>
        </listitem>
        <listitem>
	  <para>e, infine, <literal>%%</literal> e <literal>$$</literal> per, rispettivamente, il segno di percentuale e di dollaro.</para>
        </listitem>
      </itemizedlist>

      <para>Gli elenchi precedenti non sono completi (comprendono solo i parametri più importanti), ma la pagina di manuale <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry> dovrebbe essere completa.</para>
    </section>
    <section>
      <title>Un esempio concreto</title>

      <para>Consideriamo il caso di una semplice penna USB e tentiamo di assegnarle un nome fisso. In primo luogo, è necessario individuare gli elementi che la identificano in modo univoco. Per far questo, collegarla ed eseguire <command>udevadm info -a -n /dev/sdc</command> (sostituendo <replaceable>/dev/sdc</replaceable> con il nome effettivo assegnato alla chiave).</para>

      <screen><computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>
<computeroutput>[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</computeroutput></screen>

      <para>Per creare una nuova regola, è possibile utilizzare i test sulle variabili del device, così come quelle di uno dei device genitore. Il caso di cui sopra permette di creare due regole come queste:</para>

      <programlisting>KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"</programlisting>

      <para>Una volta che queste regole sono specificate in un file, chiamato ad esempio <filename>/etc/udev/rules.d/010_local.rules</filename>, si può semplicemente rimuovere e ricollegare la chiave USB. È quindi possibile vedere che <filename>/dev/usb_key/disk</filename> rappresenta il disco associato alla chiave USB e <filename>/dev/usb_key/part1</filename> è la sua prima partizione.</para>

      <sidebar>
        <title><emphasis>APPROFONDIMENTI</emphasis> Debug della configurazione di <emphasis>udev</emphasis></title>

	<para>Come molti demoni, <command>udevd</command> memorizza i file di log in <filename>/var/log/daemon.log</filename>. Non è però molto dettagliato per impostazione predefinita e non è, di solito, sufficiente per capire cosa sta succedendo. Il comando <command>udevadm control --log-priority=info</command> aumenta il livello di dettaglio e risolve questo problema. Mentre invece <command>udevadm control --log-priority=err</command> torna al livello di dettaglio predefinito.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.power-management">
    <title>Gestione dell'energia: Advanced Configuration and Power Interface (ACPI)</title>
    <indexterm><primary>gestione energetica</primary></indexterm>
    <indexterm><primary>energia, gestione energetica</primary></indexterm>

    <para>Il tema della gestione energetica è spesso problematico. Infatti, per sospendere correttamente il computer è necessario che tutti i driver delle periferiche del computer sappiano come andare in stand-by, per poi riconfigurare correttamente i dispositivi al risveglio. Purtroppo, ci sono ancora alcuni dispositivi che non sono in grado di essere sospesi correttamente sotto Linux, perché i loro produttori non hanno fornito le specifiche necessarie.</para>

    <para>Linux supporta ACPI (Advanced Configuration and Power Interface): lo standard più recente per la gestione dell'energia. Il pacchetto <emphasis role="pkg">acpid</emphasis> fornisce un demone che cerca eventi legati alla gestione energetica (il passaggio tra l'alimentazione da rete e dalla batteria su un portatile, ecc.) e che può eseguire vari comandi in risposta.</para>

    <indexterm><primary>ACPI</primary></indexterm>
    <indexterm><primary>Advanced Configuration and Power Interface</primary></indexterm>
    <indexterm><primary><command>acpid</command></primary></indexterm>
    
    <sidebar>
      <title><emphasis>ATTENZIONE</emphasis> Scheda grafica e standby</title>

      <para>Quando lo standby non funziona correttamente è spesso per problemi con il driver della scheda grafica. In questo caso, è una buona idea testare l'ultima versione del server grafico X.org.</para>
    </sidebar>

    <para>Dopo questa panoramica dei servizi di base comuni a molti sistemi Unix, ci concentreremo sull'ambiente delle macchine amministrate: la rete. Molti servizi sono necessari affinché la rete funzioni correttamente. Essi saranno discussi nel prossimo capitolo.</para>
  </section>
</chapter>
