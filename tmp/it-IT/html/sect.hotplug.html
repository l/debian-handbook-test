<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.11. Collegamento a caldo: hotplug</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-it-IT-1.0-1" /><meta
        name="keywords"
        content="Avvio del sistema, Initscripts, SSH, Telnet, Diritti, Permessi, Supervisione, Inetd, Cron, Backup, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Il Manuale dell'Amministratore Debian" /><link
        rel="up"
        href="unix-services.html"
        title="Capitolo 9. Servizi Unix" /><link
        rel="prev"
        href="sect.backup.html"
        title="9.10. Backup" /><link
        rel="next"
        href="sect.power-management.html"
        title="9.12. Gestione dell'energia: Advanced Configuration and Power Interface (ACPI)" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/it-IT/stable/sect.hotplug.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.backup.html"><strong>Indietro</strong></a></li><li
          class="home">Il Manuale dell'Amministratore Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.power-management.html"><strong>Avanti</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.hotplug"></a>9.11. Collegamento a caldo: <span
                  class="emphasis"><em>hotplug</em></span></h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.2"></a>9.11.1. Premessa</h3></div></div></div><div
            class="para">
				Il sottosistema <span
              class="emphasis"><em>hotplug</em></span> del kernel gestisce dinamicamente l'aggiunta e la rimozione dei dispositivi, caricando i driver appropriati e creando i corrispondenti file di device (con l'aiuto di <code
              class="command">udevd</code>). Con l'hardware moderno e la virtualizzazione, quasi tutto può essere inserito a caldo: dalle comuni periferiche USB/PCM/IEEE 1394 agli hard disk SATA, ma anche la CPU e la memoria.
			</div><div
            class="para">
				Il kernel ha un database che associa ogni ID di dispositivo con il driver richiesto. Questo database viene utilizzato durante l'avvio per caricare tutti i driver per le periferiche rilevate sui diversi bus, ma anche quando viene aggiunto un dispositivo supplementare collegato a caldo. Una volta che il dispositivo è pronto all'uso, viene inviato un messaggio a <code
              class="command">udevd</code> che quindi sarà in grado di creare la voce corrispondente in <code
              class="filename">/dev/</code>.
			</div><a
            id="id-1.12.14.2.4"
            class="indexterm"></a><a
            id="id-1.12.14.2.5"
            class="indexterm"></a><a
            id="id-1.12.14.2.6"
            class="indexterm"></a><a
            id="id-1.12.14.2.7"
            class="indexterm"></a><a
            id="id-1.12.14.2.8"
            class="indexterm"></a><a
            id="id-1.12.14.2.9"
            class="indexterm"></a></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.3"></a>9.11.2. Il problema dei nomi</h3></div></div></div><div
            class="para">
				Prima della comparsa dei collegamenti a caldo, era facile assegnare un nome fisso ad un dispositivo. Esso era basato semplicemente sulla posizione dei dispositivi sui loro rispettivi bus. Ma questo non è possibile quando tali dispositivi possono andare e venire sul bus. Il caso tipico è l'uso di una macchina fotografica digitale e una chiave USB che appaiono entrambe al computer come unità disco. La prima ad essere collegata potrebbe essere <code
              class="filename">/dev/sdb</code> e la seconda <code
              class="filename">/dev/sdc</code> (con <code
              class="filename">/dev/sda</code> che rappresenta il disco rigido del computer). Il nome del dispositivo non è fisso, ma dipende dall'ordine in cui sono collegati i dispositivi.
			</div><div
            class="para">
				Inoltre, sempre più driver usano valori dinamici per i numeri maggiori/minori di device, il che rende impossibile avere voci statiche per i dispositivi indicati, in quanto tali caratteristiche essenziali possono variare dopo un riavvio.
			</div><div
            class="para">
				<span
              class="emphasis"><em>udev</em></span> è stato creato proprio per risolvere questo problema.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>IN PRATICA</em></span> Gestione delle schede di rete</strong></p></div></div></div><div
              class="para">
				Molti computer hanno più schede di rete (a volte due interfacce cablate e un'interfaccia wifi), e con il supporto per <span
                class="emphasis"><em>hotplug</em></span> per la maggior parte dei tipi di bus, il kernel di Linux non garantisce una denominazione fissa per le interfacce di rete. Ma un utente che vuole configurare la propria rete in <code
                class="filename">/etc/network/interfaces</code> ha bisogno di un nome fisso!
			</div><div
              class="para">
				Sarebbe difficile chiedere ad ogni utente di creare le proprie regole <span
                class="emphasis"><em>udev</em></span> per affrontare questo problema. Questo è il motivo per cui <span
                class="emphasis"><em>udev</em></span> è stato configurato in un modo piuttosto singolare; al primo avvio (e, più in generale, ogni volta che appare una nuova scheda di rete) utilizza il nome dell'interfaccia di rete e il suo indirizzo MAC per creare nuove regole che riassegneranno lo stesso nome agli avvii successivi. Queste regole sono memorizzate in <code
                class="filename">/etc/udev/rules.d/70-persistent-net.rules</code>.
			</div><div
              class="para">
				Questo meccanismo produce alcuni effetti collaterali che bisogna conoscere. Consideriamo il caso di computer che hanno una sola scheda di rete PCI. L'interfaccia di rete è denominata <code
                class="literal">eth0</code>, logicamente. Ora immaginiamo che la scheda si rompa, e l'amministratore la sostituisca, la nuova scheda avrà un nuovo indirizzo MAC. Dal momento che alla vecchia scheda era stato assegnato il nome <code
                class="literal">eth0</code>, alla nuova verrà assegnato <code
                class="literal">eth1</code>, anche se la scheda <code
                class="literal">eth0</code> è andata per sempre (e la rete non sarà funzionante, perché <code
                class="filename">/etc/network/interfaces</code> configura probabilmente un'interfaccia <code
                class="literal">eth0</code>). In questo caso, è sufficiente eliminare semplicemente il file <code
                class="filename">/etc/udev/rules.d/70-persistent-net.rules</code> presente prima di riavviare il computer. Alla nuova scheda verrà allora assegnato il nome atteso <code
                class="literal">eth0</code>.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.4"></a>9.11.3. Come funziona <span
                    class="emphasis"><em>udev</em></span></h3></div></div></div><div
            class="para">
				Quando il kernel notifica a <span
              class="emphasis"><em>udev</em></span> la comparsa di un nuovo dispositivo, quest'ultimo raccoglie diverse informazioni sul dispositivo dato consultando le voci corrispondenti in <code
              class="filename">/sys/</code>, specialmente quelle che lo identificano in modo univoco (indirizzo MAC di una scheda di rete, numero di serie per alcuni dispositivi USB, ecc.).
			</div><div
            class="para">
				Armato di tutte queste informazioni, <span
              class="emphasis"><em>udev</em></span> consulta allora tutte le regole contenute in <code
              class="filename">/etc/udev/rules.d/</code> e <code
              class="filename">/lib/udev/rules.d/</code>. In base a ciò decide quale nome dare al device, quali collegamenti simbolici creare (per avere nomi alternativi), e quali comandi eseguire. Tutti questi file vengono consultati e tutte le regole vengono valutate in sequenza (tranne quando un file utilizza direttive «GOTO»). Così, vi possono essere diverse regole che corrispondono ad un dato evento.
			</div><div
            class="para">
				La sintassi dei file delle regole è molto semplice: ogni riga contiene i criteri di selezione e le assegnazioni delle variabili. I primi sono utilizzati per selezionare gli eventi per i quali esiste una necessità di reagire, mentre le seconde definiscono l'azione da eseguire. Sono tutti semplicemente separati da virgole e l'operatore distingue implicitamente tra un criterio di selezione (con operatori di confronto, come <code
              class="literal">==</code> o <code
              class="literal">!=</code>) e una direttiva di assegnazione (con operatori come <code
              class="literal">=</code>, <code
              class="literal">+=</code> o <code
              class="literal">:=</code>).
			</div><div
            class="para">
				Gli operatori di confronto vengono utilizzati per le seguenti variabili:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">KERNEL</code>: il nome che il kernel assegna al device;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">ACTION</code>: l'azione corrispondente all'evento («add» quando un dispositivo è stato aggiunto, «remove» quando è stato rimosso);
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">DEVPATH</code>: il percorso della voce in <code
                    class="filename">/sys/</code> per il dispositivo;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">SUBSYSTEM</code>: il sottosistema del kernel che ha generato la richiesta (ce ne sono molti, ma alcuni esempi sono «usb», «ide», «net», «firmware», ecc.);
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">ATTR{<em
                      class="replaceable">attributo</em>}</code>: il contenuto del file <em
                    class="replaceable">attributo</em> nella directory <code
                    class="filename">/sys/<em
                      class="replaceable">$devpath</em>/</code> del dispositivo. Qui è possibile trovare l'indirizzo MAC e altri identificatori specifici dei bus;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">KERNELS</code>, <code
                    class="literal">SUBSYSTEMS</code> e <code
                    class="literal">ATTRS{<em
                      class="replaceable">attributi</em>}</code> sono variazioni che cercheranno di soddisfare le diverse opzioni su uno dei dispositivi progenitori del dispositivo di corrente;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">PROGRAM</code>: delega il test al programma indicato (true se restituisce 0, false in caso contrario). Il contenuto dello standard output del programma è memorizzato in modo da poter essere riutilizzato dal test <code
                    class="literal">RESULT</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">RESULT</code>: esegue test sullo standard output memorizzato durante l'ultima chiamata a <code
                    class="literal">PROGRAM</code>.
					</div></li></ul></div><div
            class="para">
				Gli operandi di destra possono utilizzare modelli di espressioni per trovare corrispondere a diversi valori allo stesso tempo. Ad esempio, <code
              class="literal">*</code> corrisponde a qualsiasi stringa (anche vuota), <code
              class="literal">?</code> corrisponde a qualsiasi carattere e <code
              class="literal">[]</code> corrisponde all'insieme di caratteri elencati tra le parentesi quadre (o l'opposto se il primo carattere è un punto esclamativo, e gli intervalli di caratteri contigui sono indicati come <code
              class="literal">a-z</code>).
			</div><div
            class="para">
				Per quanto riguarda gli operatori di assegnazione, <code
              class="literal">=</code> assegna un valore (e sostituisce il valore corrente); nel caso di un elenco, questo viene svuotato e contiene solo il valore assegnato. <code
              class="literal">:=</code> fa la stessa cosa, ma impedisce successive modifiche alla stessa variabile. Per quanto riguarda <code
              class="literal">+=</code>, esso aggiunge un elemento a un elenco. Le seguenti variabili possono essere modificate:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">NAME</code>: il nome del file di device da creare in <code
                    class="filename">/dev/</code>. Vale solo la prima assegnazione, le altre vengono ignorate;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">SYMLINK</code>: l'elenco dei collegamenti simbolici che puntano allo stesso device;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">OWNER</code>, <code
                    class="literal">GROUP</code> e <code
                    class="literal">MODE</code> definiscono l'utente e il gruppo che possiedono il device, nonché i permessi associati;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">RUN</code>: l'elenco dei programmi da eseguire in risposta a questo evento.
					</div></li></ul></div><div
            class="para">
				I valori assegnati a queste variabili possono utilizzare diverse sostituzioni:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$kernel</code> o <code
                    class="literal">%k</code>: equivalente a <code
                    class="literal">KERNEL</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$number</code> o <code
                    class="literal">%n</code>: il numero d'ordine del dispositivo, per esempio, per <code
                    class="literal">sda3</code> sarebbe «3»;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$devpath</code> o <code
                    class="literal">%p</code>: equivalente a <code
                    class="literal">DEVPATH</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$attr{<em
                      class="replaceable">attributo</em>}</code> o <code
                    class="literal">%s{<em
                      class="replaceable">attributo</em>}</code>: equivalente a <code
                    class="literal">ATTRS {<em
                      class="replaceable">attributo</em>}</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$major</code> o <code
                    class="literal">%M</code>: il numero kernel maggiore del device;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$minor</code> o <code
                    class="literal">%m</code>: il numero kernel minore del device;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$result</code> o <code
                    class="literal">%c</code>: la stringa prodotta in output dell'ultimo programma invocato da <code
                    class="literal">PROGRAM</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						e, infine, <code
                    class="literal">%%</code> e <code
                    class="literal">$$</code> per, rispettivamente, il segno di percentuale e di dollaro.
					</div></li></ul></div><div
            class="para">
				Gli elenchi precedenti non sono completi (comprendono solo i parametri più importanti), ma la pagina di manuale <span
              class="citerefentry"><span
                class="refentrytitle">udev</span>(7)</span> dovrebbe essere completa.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.5"></a>9.11.4. Un esempio concreto</h3></div></div></div><div
            class="para">
				Consideriamo il caso di una semplice penna USB e tentiamo di assegnarle un nome fisso. In primo luogo, è necessario individuare gli elementi che la identificano in modo univoco. Per far questo, collegarla ed eseguire <code
              class="command">udevadm info -a -n /dev/sdc</code> (sostituendo <em
              class="replaceable">/dev/sdc</em> con il nome effettivo assegnato alla chiave).
			</div><pre
            class="screen"><code
              class="computeroutput"># </code><strong
              class="userinput"><code>udevadm info -a -n /dev/sdc</code></strong>
<code
              class="computeroutput">[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</code></pre><div
            class="para">
				Per creare una nuova regola, è possibile utilizzare i test sulle variabili del device, così come quelle di uno dei device genitore. Il caso di cui sopra permette di creare due regole come queste:
			</div><pre
            class="programlisting">KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"</pre><div
            class="para">
				Una volta che queste regole sono specificate in un file, chiamato ad esempio <code
              class="filename">/etc/udev/rules.d/010_local.rules</code>, si può semplicemente rimuovere e ricollegare la chiave USB. È quindi possibile vedere che <code
              class="filename">/dev/usb_key/disk</code> rappresenta il disco associato alla chiave USB e <code
              class="filename">/dev/usb_key/part1</code> è la sua prima partizione.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>APPROFONDIMENTI</em></span> Debug della configurazione di <span
                        class="emphasis"><em>udev</em></span></strong></p></div></div></div><div
              class="para">
				Come molti demoni, <code
                class="command">udevd</code> memorizza i file di log in <code
                class="filename">/var/log/daemon.log</code>. Non è però molto dettagliato per impostazione predefinita e non è, di solito, sufficiente per capire cosa sta succedendo. Il comando <code
                class="command">udevadm control --log-priority=info</code> aumenta il livello di dettaglio e risolve questo problema. Mentre invece <code
                class="command">udevadm control --log-priority=err</code> torna al livello di dettaglio predefinito.
			</div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.backup.html"><strong>Indietro</strong>9.10. Backup</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Risali</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Partenza</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.power-management.html"><strong>Avanti</strong>9.12. Gestione dell'energia: Advanced Configurati...</a></li></ul></body></html>
