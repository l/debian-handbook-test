<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.2. Accesso remoto</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-it-IT-1.0-1" /><meta
        name="keywords"
        content="Avvio del sistema, Initscripts, SSH, Telnet, Diritti, Permessi, Supervisione, Inetd, Cron, Backup, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Il Manuale dell'Amministratore Debian" /><link
        rel="up"
        href="unix-services.html"
        title="Capitolo 9. Servizi Unix" /><link
        rel="prev"
        href="unix-services.html"
        title="Capitolo 9. Servizi Unix" /><link
        rel="next"
        href="sect.rights-management.html"
        title="9.3. Gestione dei permessi" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/it-IT/stable/sect.remote-login.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Indietro</strong></a></li><li
          class="home">Il Manuale dell'Amministratore Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Avanti</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.remote-login"></a>9.2. Accesso remoto</h2></div></div></div><div
          class="para">
			È essenziale per un amministratore essere in grado di connettersi ad un computer remoto. I server, confinati nella propria stanza, sono raramente dotati di tastiere e monitor permanenti, ma sono connessi alla rete.
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>FONDAMENTALI</em></span> Client, server</strong></p></div></div></div><a
            id="id-1.12.5.3.2"
            class="indexterm"></a><a
            id="id-1.12.5.3.3"
            class="indexterm"></a><div
            class="para">
			Un sistema in cui diversi processi comunicano tra loro è spesso descritto con la metafora «clientserver». Il server è il programma che prende le richieste provenienti da un client e le esegue. Il client controlla le operazioni, il server non prende alcuna iniziativa propria.
		</div></div><a
          id="id-1.12.5.4"
          class="indexterm"></a><a
          id="id-1.12.5.5"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ssh"></a>9.2.1. Accesso remoto sicuro: SSH</h3></div></div></div><a
            id="id-1.12.5.6.2"
            class="indexterm"></a><a
            id="id-1.12.5.6.3"
            class="indexterm"></a><div
            class="para">
				Il protocollo <span
              class="emphasis"><em>SSH</em></span> (Secure SHell) è stato progettato tenendo a mente sicurezza ed affidabilità. Le connessioni con SSH sono sicure: il partner è autenticato e tutti gli scambi di dati sono cifrati.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURA</em></span> Telnet e RSH sono obsoleti</strong></p></div></div></div><a
              id="id-1.12.5.6.5.2"
              class="indexterm"></a><a
              id="id-1.12.5.6.5.3"
              class="indexterm"></a><div
              class="para">
				Prima di SSH, <span
                class="emphasis"><em>Telnet</em></span> e <span
                class="emphasis"><em>RSH</em></span> erano i principali strumenti usati per fare il login da remoto. Sono ora per la maggior parte obsoleti e non dovrebbero essere usati anche se Debian li fornisce ancora.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOCABOLARIO</em></span> Autenticazione, cifratura</strong></p></div></div></div><div
              class="para">
				Quando è necessario dare ad un client la possibilità di condurre o attivare azioni su un server, la sicurezza è importante. È necessario verificare l'identità del client, questa è l'autenticazione. Questa identità di solito consiste in una password che deve essere tenuta segreta, o qualsiasi altro client potrebbe ottenere la password. Questo è lo scopo della cifratura, che è una forma di codifica che consente a due sistemi di comunicare informazioni riservate su un canale pubblico, proteggendole dall'essere leggibili ad altri.
			</div><div
              class="para">
				L'autenticazione e la cifratura sono spesso menzionate insieme, sia perché esse sono spesso usate insieme, sia perché sono di solito implementate con simili concetti matematici.
			</div></div><div
            class="para">
				SSH offre anche due servizi di trasferimento di file. <code
              class="command">scp</code> è uno strumento a riga di comando che può essere utilizzato come <code
              class="command">cp</code>, tranne che qualsiasi percorso a un altro computer è fatto precedere dal nome della macchina, seguito da due punti («:»).
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>file macchina scp:/tmp/</code></strong></pre><div
            class="para">
				<code
              class="command">sftp</code> è un comando interattivo, simile a <code
              class="command">ftp</code>. In una singola sessione, <code
              class="command">sftp</code> è in grado di trasferire più file, ed è possibile usarlo per manipolare i file remoti (eliminare, rinominare, modificare i permessi, ecc.).
			</div><a
            id="id-1.12.5.6.10"
            class="indexterm"></a><a
            id="id-1.12.5.6.11"
            class="indexterm"></a><div
            class="para">
				Debian utilizza OpenSSH, una versione libera di SSH, mantenuta dal progetto <code
              class="command">OpenBSD</code> (un sistema operativo libero basato sul kernel BSD, incentrato sulla sicurezza) e fork del software originale SSH sviluppato dalla società finlandese SSH Communications Security Corp. Questa società ha inizialmente sviluppato SSH come software libero, ma alla fine ha deciso di continuare il suo sviluppo sotto una licenza proprietaria. Il progetto OpenBSD quindi ha creato OpenSSH per mantenere una versione free di SSH.
			</div><a
            id="id-1.12.5.6.13"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>FONDAMENTALI</em></span><span
                        class="foreignphrase"><em
                          class="foreignphrase">Fork</em></span></strong></p></div></div></div><a
              id="id-1.12.5.6.14.2"
              class="indexterm"></a><div
              class="para">
				Un «fork», in materia di software, significa un nuovo progetto che inizia come un clone di un progetto esistente, e che compete con esso. Da lì in poi, entrambi i software di solito divergono rapidamente in termini di nuovi sviluppi. Un fork è spesso il risultato di disaccordi all'interno del team di sviluppo.
			</div><div
              class="para">
				L'opzione di fare il fork di un progetto è una diretta conseguenza della natura stessa del software libero, un fork è un evento sano quando permette la continuazione di un progetto come software libero (per esempio in caso di cambiamenti nella licenza). Un fork derivante da divergenze tecniche o personali è spesso uno spreco di risorse umane; un'altra soluzione sarebbe preferibile. Fusioni di due progetti che in precedenza hanno attraversato un fork non sono inedite.
			</div></div><div
            class="para">
				OpenSSH è diviso in due pacchetti: la parte client è nel pacchetto <span
              class="pkg pkg">openssh-client</span>, mentre il server è nel pacchetto <span
              class="pkg pkg">openssh-server</span>. Il metapacchetto <span
              class="pkg pkg">ssh</span> dipende da entrambe le parti e facilita l'installazione di entrambi (<code
              class="command">apt install ssh</code>).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-key-based-auth"></a>9.2.1.1. Autenticazione basata su chiave</h4></div></div></div><div
              class="para">
					Ogni volta che qualcuno si collega tramite SSH il server remoto richiede una password per autenticare l'utente. Questo può essere problematico se si vuole automatizzare una connessione, o se si utilizza uno strumento che richiede collegamenti frequenti su SSH. È per questo che SSH offre un sistema di autenticazione basato su chiave.
				</div><div
              class="para">
					L'utente genera una coppia di chiavi sulla macchina client con <code
                class="command">ssh-keygen -t rsa</code>; la chiave pubblica è conservata in <code
                class="filename">~/.ssh/id_rsa.pub</code>, mentre la corrispondente chiave privata è conservata in <code
                class="filename">~/.ssh/id_rsa</code>. Successivamente l'utente usa <code
                class="command">ssh-copy-id <em
                  class="replaceable">server</em></code> per aggiungere la propria chiave pubblica nel file <code
                class="filename">~/.ssh/authorized_keys</code> presente sul server. Se la chiave privata non è stata protetta con una «passphrase» al momento della sua creazione, tutti gli accessi successivi sul server funzioneranno senza una password. In caso contrario, la chiave privata dovrà essere decifrata ogni volta inserendo la «passphrase». Fortunatamente, <code
                class="command">ssh-agent</code> ci permette di mantenere in memoria le chiavi private in modo da non dover reinserire continuamente la password. Per questo, è sufficiente utilizzare <code
                class="command">ssh-add</code> (una volta per ogni sessione di lavoro), a condizione che la sessione sia già associata ad un'istanza funzionante di <code
                class="command">ssh-agent</code>. Debian la attiva come impostazione predefinita nelle sessioni grafiche, ma è possibile disattivare questo comportamento cambiando <code
                class="filename">/etc/X11/Xsession.options</code>. Per una sessione della console, è possibile avviarla manualmente tramite <code
                class="command">eval $(ssh-agent)</code>.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SICUREZZA</em></span> Protezione della chiave privata</strong></p></div></div></div><div
                class="para">
					Chi ha la chiave privata può effettuare il login sull'account così configurato. Per questo motivo l'accesso alla chiave privata viene protetto da una «passphrase». Chi viene in possesso di una copia di una chiave privata (ad esempio, <code
                  class="filename">~/.ssh/id_rsa</code>) deve comunque sapere questa frase per essere in grado di utilizzarla. Questa protezione aggiuntiva non è, tuttavia, inespugnabile, e se si pensa che questo file è stato compromesso, è meglio disabilitare la chiave sui computer in cui è stata installata (rimuovendola dal file <code
                  class="filename">authorized_keys</code>) e sostituendola con una nuova chiave generata.
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURA</em></span> Problemi di OpenSSL in Debian <span
                          class="distribution distribution">Etch</span></strong></p></div></div></div><div
                class="para">
					La libreria OpenSSL, come inizialmente fornita in Debian <span
                  class="distribution distribution">Etch</span>, aveva un problema serio nel suo generatore di numeri casuali (RNG). Infatti, il manutentore Debian ha fatto un cambiamento in modo che le applicazioni che la usavano non generassero più avvertimenti quando erano analizzati con strumenti di test di memoria, come <code
                  class="command">valgrind</code>. Sfortunatamente, questo cambiamento comportava anche che la RNG impiegasse una sola fonte di entropia, corrispondente al numero di processo (PID) i cui possibili 32.000 valori non offrono abbastanza casualità. <div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="http://www.debian.org/security/2008/dsa-1571">http://www.debian.org/security/2008/dsa-1571</a></div>
				</div><div
                class="para">
					Nello specifico, quando OpenSSL veniva impiegato per generare una chiave, produceva sempre una chiave all'interno di un insieme noto di centinaia di migliaia di chiavi (32.000 moltiplicato per un piccolo numero di lunghezze di chiave). Questo riguardava le chiavi SSH, le chiavi SSL ed i certificati X.509 utilizzati da numerose applicazioni, come ad esempio OpenVPN. Un cracker doveva quindi solo provare tutte le chiavi per ottenere un accesso non autorizzato. Per ridurre l'impatto del problema, il demone SSH è stato modificato in modo da rifiutare le chiavi problematiche che sono elencate nei pacchetti <span
                  class="pkg pkg">openssh-blacklist</span> e <span
                  class="pkg pkg">openssh-blacklist-extra</span>. Inoltre, il comando <code
                  class="command">ssh-vulnkey</code> consente l'identificazione delle chiavi eventualmente compromesse nel sistema.
				</div><div
                class="para">
					Un'analisi più approfondita di questo incidente mette in luce che è il risultato di molteplici (piccoli) problemi, sia all'interno del progetto OpenSSL, che con il responsabile del paccheto Debian. Una libreria ampiamente utilizzata come OpenSSL non dovrebbe — senza modifiche — generare avvisi quando viene testata da <code
                  class="command">valgrind</code>. Inoltre, il codice (in particolare quelle parti tanto delicate come la RNG) dovrebbe essere commentate meglio per evitare questi errori. Da parte sua il reponsabile del pacchetto Debian, vuole confermare le sue modifiche dagli sviluppatori di OpenSSL, ma le ha semplicemente spiegate senza fornire loro la corrispondente patch da revisionare ed ha omesso di mesionare il suo ruolo all'interno di Debian. Infine, le scelte di manutenzioneerano sub-attimali: le modifiche fatte al codice originale non sono state chiaramente documentate; tutte le modifiche sono effettivamente memorizzate in un repository Subversion, ma sono finite tutte concentrate in una singola patch durante la creazione del pacchetto sorgente.
				</div><div
                class="para">
					In queste condizioni è difficile trovare le misure correttive per evitare il ripetersi di questi incidenti. La lezione da trarre è che ogni divergenza che Debian introduce nel software originale deve essere giustificata, documentata, presentata nel progetto principale, quando possibile, e ampiamente pubblicizzata. È in base a questa prospettiva che sono stati sviluppati il nuovo formato dei pacchetti sorgente ("3.0 (quilt)") ed i servizi web dei sorgenti Debian. <div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="http://sources.debian.net">http://sources.debian.net</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-x11"></a>9.2.1.2. Utilizzo di applicazioni X11 remote</h4></div></div></div><div
              class="para">
					Il protocollo SSH consente la trasmissione dei dati grafici (sessione «X11», dal nome del più diffuso sistema grafico in Unix), il server mantiene un canale dedicato per tali dati. In particolare, un programma grafico eseguito da remoto può essere visualizzato sul server X.org dello schermo locale e l'intera sessione (ingresso e visualizzazione) sarà sicura. Poiché questa funzionalità consente alle applicazioni remote di interferire con il sistema locale, è disabilitata in modo predefinito. È possibile abilitare questa funzionalità specificando <code
                class="literal">X11Forwarding yes</code> nel file di configurazione del server (<code
                class="filename">/etc/ssh/sshd_config</code>). Infine, l'utente deve anche richiederla aggiungendo l'opzione <code
                class="literal">-X</code> alla riga di comando di <code
                class="command">ssh</code>.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-port-forwarding"></a>9.2.1.3. Creazione di tunnel cifrati con il port forwarding</h4></div></div></div><a
              id="id-1.12.5.6.18.2"
              class="indexterm"></a><div
              class="para">
					Le opzioni <code
                class="literal">-R</code> e <code
                class="literal">-L</code> consentono a <code
                class="command">ssh</code> di creare «tunnel cifrati» tra due macchine, inoltrando in modo sicuro una porta TCP locale (vedere il riquadro <a
                class="xref"
                href="network-infrastructure.html#sidebar.tcp-udp"><span
                  class="emphasis"><em>FONDAMENTALI</em></span> TCP/UDP</a>) ad un computer remoto o viceversa.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABOLARIO</em></span> Tunnel</strong></p></div></div></div><a
                id="id-1.12.5.6.18.4.2"
                class="indexterm"></a><a
                id="id-1.12.5.6.18.4.3"
                class="indexterm"></a><div
                class="para">
					Internet, e la maggior parte delle LAN che vi sono collegate, opera in modalità a pacchetto e non in modalità connessa, il che significa che un pacchetto emesso da un computer verso un altro verrà fermato in vari router intermedi per trovare la strada verso la destinazione. È ancora possibile simulare il funzionamento in collegamento in cui il flusso è racchiuso in pacchetti IP normali. Questi pacchetti seguono il loro percorso abituale, ma il flusso viene ricostruito invariato a destinazione. Questo viene chiamato «tunnel», analogo ad una galleria stradale in cui i veicoli viaggiano direttamente dall'ingresso (input) all'uscita (output) senza incontrare alcun incrocio, al contrario di un percorso sulla superficie che comporterebbe incroci e cambiamenti di direzione.
				</div><div
                class="para">
					È possibile utilizzare questa opportunità per aggiungere la cifratura al tunnel: il flusso che scorre attraverso di esso è quindi irriconoscibile dall'esterno, ma viene riportato alla forma decifrata all'uscita del tunnel.
				</div></div><div
              class="para">
					<code
                class="command">ssh -L 8000:server:25 intermediario</code> stabilisce una sessione SSH con l'host <em
                class="replaceable">intermediario</em> e ascolta sulla porta locale 8000 (vedere <a
                class="xref"
                href="sect.remote-login.html#figure.ssh-L">Figura 9.3, «Inoltro di una porta locale con SSH»</a>). Per ogni connessione stabilita su questa porta, <code
                class="command">ssh</code> avvierà una connessione dal computer <em
                class="replaceable">intermediario</em> alla porta 25 sul <em
                class="replaceable">server</em> legando insieme entrambe le connessioni.
				</div><div
              class="para">
					Anche <code
                class="command">ssh -R 8000:server:25 intermediario</code> stabilisce una sessione SSH al computer <em
                class="replaceable">intermediario</em>, ma è in questa macchina che <code
                class="command">ssh</code> è in ascolto sulla porta 8000 (vedere <a
                class="xref"
                href="sect.remote-login.html#figure.ssh-R">Figura 9.4, «Inoltro di una porta remota con SSH»</a>). Ogni connessione stabilita sulla porta farà sì che <code
                class="command">ssh</code> aprirà una connessione dalla macchina locale alla porta 25 del <em
                class="replaceable">server</em> legando insieme entrambe le connessioni.
				</div><div
              class="para">
					In entrambi i casi, le connessioni sono realizzate sulla porta 25 dell'host <em
                class="replaceable">server</em>, e passano attraverso il tunnel SSH stabilito tra la macchina locale e la macchina <em
                class="replaceable">intermediario</em>. Nel primo caso, l'ingresso del tunnel è locale sulla porta 8000, ed i dati si muovono verso la macchina <em
                class="replaceable">intermediario</em> prima di essere diretti al <em
                class="replaceable">server</em> sulla rete «pubblica». Nel secondo caso, l'ingresso e l'uscita del tunnel sono invertiti, l'ingresso è la porta 8000 sulla macchina <em
                class="replaceable">intermediario</em>, l'uscita è sulla macchina locale, ed i dati vengono poi indirizzati al <em
                class="replaceable">server</em>. In pratica, il server è di solito o la macchina locale o l'intermediario. In questo modo SSH rende sicura la connessione da un'estremità all'altra.
				</div><div
              class="figure"><a
                xmlns=""
                id="figure.ssh-L"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-L.png"
                    alt="Inoltro di una porta locale con SSH" /></div></div><p
                class="title"><strong>Figura 9.3. Inoltro di una porta locale con SSH</strong></p></div><div
              class="figure"><a
                xmlns=""
                id="figure.ssh-R"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-R.png"
                    alt="Inoltro di una porta remota con SSH" /></div></div><p
                class="title"><strong>Figura 9.4. Inoltro di una porta remota con SSH</strong></p></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.remote-desktops"></a>9.2.2. Utilizzo di desktop remoti grafici</h3></div></div></div><div
            class="para">
				VNC (Virtual Network Computing) permette l'accesso remoto a desktop grafici.
			</div><a
            id="id-1.12.5.7.3"
            class="indexterm"></a><a
            id="id-1.12.5.7.4"
            class="indexterm"></a><a
            id="id-1.12.5.7.5"
            class="indexterm"></a><a
            id="id-1.12.5.7.6"
            class="indexterm"></a><a
            id="id-1.12.5.7.7"
            class="indexterm"></a><div
            class="para">
				Questo strumento è usato soprattutto per l'assistenza tecnica; l'amministratore può visualizzare gli errori che l'utente si trova ad affrontare, e mostrargli la cosa corretta da fare, senza dover essere fisicamente presente.
			</div><a
            id="id-1.12.5.7.9"
            class="indexterm"></a><a
            id="id-1.12.5.7.10"
            class="indexterm"></a><a
            id="id-1.12.5.7.11"
            class="indexterm"></a><div
            class="para">
				In primo luogo, l'utente deve autorizzare la condivisione della sessione. L'ambiente desktop grafico GNOME in <span
              class="distribution distribution">Jessie</span> include questa opzione nel suo pannello di configurazione (contrariamente alle precedenti versioni di Debian, nelle quali l'utente deve installare ed utilizzare <code
              class="command">vino</code>). KDE richiede ancora l'uso di <code
              class="command">krfb</code> per consentire la condivisione di una sessione esistente tramite VNC. Per gli altri ambienti desktop grafici, il comando <code
              class="command">x11vnc</code> (dal pacchetto Debian con lo stesso nome) serve allo stesso scopo; è possibile renderlo disponibile per l'utente con un'icona esplicita.
			</div><a
            id="id-1.12.5.7.13"
            class="indexterm"></a><a
            id="id-1.12.5.7.14"
            class="indexterm"></a><a
            id="id-1.12.5.7.15"
            class="indexterm"></a><a
            id="id-1.12.5.7.16"
            class="indexterm"></a><div
            class="para">
				Quando la sessione grafica è messa a disposizione da VNC, l'amministratore deve connettersi con un client VNC. GNOME ha <code
              class="command">vinagre</code> e <code
              class="command">remmina</code> per questo scopo, mentre KDE include <code
              class="command">krdc</code> (nel menu <span
              class="guimenu"><strong>K</strong></span> → <span
              class="guisubmenu"><strong>Internet</strong></span> → <span
              class="guimenuitem"><strong>Client per connessione a desktop remoto</strong></span>). Ci sono altri client VNC che utilizzano la riga di comando, come ad esempio <code
              class="command">xvnc4viewer</code> nel pacchetto Debian con lo stesso nome. Una volta connesso, l'amministratore può vedere cosa sta succedendo, lavorare sulla macchina in remoto, e mostrare all'utente come procedere.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>SICUREZZA</em></span> VNC su SSH</strong></p></div></div></div><a
              id="id-1.12.5.7.18.2"
              class="indexterm"></a><div
              class="para">
				Se si desidera connettersi a VNC, e non si desidera che i dati siano trasmessi in chiaro sulla rete, è possibile incapsulare i dati in un tunnel SSH (vedere la <a
                class="xref"
                href="sect.remote-login.html#sect.ssh-port-forwarding">Sezione 9.2.1.3, «Creazione di tunnel cifrati con il port forwarding»</a>). È sufficiente sapere che VNC usa la porta 5900 per impostazione predefinita per il primo schermo (chiamato «localhost: 0»), 5901 per il secondo (chiamato «localhost: 1»), ecc.
			</div><div
              class="para">
				Il comando <code
                class="command">ssh -L localhost:5901:localhost:5900 -N -T <em
                  class="replaceable">macchina</em></code> crea un tunnel tra porta locale 5901 nell'interfaccia localhost e la porta 5900 della <em
                class="replaceable">macchina</em> host. Il primo «localhost» limita SSH in modo che ascolti solo sull'interfaccia della macchina locale. Il secondo «localhost» indica l'interfaccia sul computer remoto che riceverà il traffico di rete in entrata su «localhost:5901». Così <code
                class="command">vncviewer localhost:1</code> collegherà il client VNC allo schermo remoto, anche se si indica il nome della macchina locale.
			</div><div
              class="para">
				Quando la sessione VNC è chiusa, bisogna ricordarsi di chiudere il tunnel, uscendo anche dalla corrispondente sessione SSH.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>FONDAMENTALI</em></span> Display manager</strong></p></div></div></div><a
              id="id-1.12.5.7.19.2"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.3"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.4"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.5"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.6"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.7"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">gdm3</code>, <code
                class="command">kdm</code>, <code
                class="command">lightdm</code> e <code
                class="command">xdm</code> sono display manager. Assumono il controllo dell'interfaccia grafica poco dopo l'avvio in modo da fornire all'utente una schermata di accesso. Una volta che l'utente si è connesso, vengono eseguiti i programmi necessari per avviare una sessione grafica di lavoro.
			</div></div><div
            class="para">
				VNC funziona anche per utenti mobili, o dirigenti di società, che a volte hanno bisogno di effettuare il login da casa per accedere a un desktop remoto simile a quello che utilizzano sul posto di lavoro. La configurazione di tale servizio è più complicata: per prima cosa si installa il pacchetto <span
              class="pkg pkg">vnc4server</span>, si modifica la configurazione del display manager in modo da accettare richieste <code
              class="literal">XDMCP query</code> (per <code
              class="command">gdm3</code>, ciò può essere fatto aggiungendo <code
              class="literal">Enable=true</code> nella sezione «xdmcp» di <code
              class="filename">/etc/gdm3/daemon.conf</code>) e infine si avvia il server VNC con <code
              class="command">inetd</code> in modo che una sessione venga avviata automaticamente quando un utente tenta di effettuare l'accesso. Ad esempio, si può aggiungere questa riga a <code
              class="filename">/etc/inetd.conf</code>:
			</div><pre
            class="programlisting">5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</pre><div
            class="para">
				Deviare le connessioni in entrata al display manager risolve il problema dell'autenticazione, in quanto solo gli utenti con account locali supereranno la schermata di accesso di <code
              class="command">gdm3</code> (o l'equivalente di <code
              class="command">kdm</code>, <code
              class="command">xdm</code>, ecc.). Poiché questo sistema consente più connessioni simultanee senza alcun problema (se il server è abbastanza potente), può anche essere utilizzato per fornire desktop completi per gli utenti mobili (o per sistemi desktop meno potenti, configurati come thin client). Gli utenti devono semplicemente accedere allo schermo del server con <code
              class="command">vncviewer <em
                class="replaceable">server</em>:50</code>, perché la porta utilizzata è 5950.
			</div><a
            id="id-1.12.5.7.23"
            class="indexterm"></a></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Indietro</strong>Capitolo 9. Servizi Unix</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Risali</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Partenza</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Avanti</strong>9.3. Gestione dei permessi</a></li></ul></body></html>
