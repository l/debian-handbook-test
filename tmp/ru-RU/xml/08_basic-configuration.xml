<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="basic-configuration" lang="ru-RU">
	<chapterinfo>
		 <keywordset>
			<keyword>Конфигурация</keyword>
			 <keyword>Локализация</keyword>
			 <keyword>Локали</keyword>
			 <keyword>Сеть</keyword>
			 <keyword>Разрешение имён</keyword>
			 <keyword>Пользователи</keyword>
			 <keyword>Группы</keyword>
			 <keyword>Аккаунты</keyword>
			 <keyword>Интерпретатор командной строки</keyword>
			 <keyword>Оболочка</keyword>
			 <keyword>Печать</keyword>
			 <keyword>Загрузчик</keyword>
			 <keyword>Компиляция ядра</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Базовая конфигурация: Сеть, Аккаунты, Печать...</title>
	 <highlights> <para>
		Компьютер с новой инсталляции, созданной с помощью <command>debian-installer</command>в большинстве случаев функционалены, но некоторые службы требуют определённой настройки. Более того, всегда полезно знать как поменять некоторые настройки, которые были сделаны во время установки системы.
	</para>
	 </highlights> <para>
		Данная глава включает в себя все, что можно назвать "базовой настройкой": сеть, язык и локали, пользователи и группы, печать, точки монтирования и т. п.
	</para>
	 <section id="sect.config-language-support">
		<title>Настройка системы для использования с другим языком</title>
		 <indexterm>
			<primary>Французская локализация</primary>
		</indexterm>
		 <para>
			Если при установке системы был использован французский язык, он будет в дальнейшем использоваться как язык системы по умолчанию. Однако полезно знать, как можно его поменять при необходимости.
		</para>
		 <sidebar> <title><emphasis>ИНСТРУМЕНТ</emphasis> Команда <command>locale</command> отображает текущую настройку - какой язык в настоящее время установлен в системе как основной</title>
		 <para>
			Команда <command>locale</command> отображает суммарно различные параметры конфигурации текущей локали (представление даты, чисел и т. п.) в форме групп стандартных переменных окружения, которые предназначенны для динамического изменения тех настроек.
		</para>
		 </sidebar> <section id="sect.default-language">
			<title>Установка языка по умолчанию</title>
			 <indexterm>
				<primary>локали</primary>
			</indexterm>
			 <indexterm>
				<primary>язык</primary>
			</indexterm>
			 <indexterm>
				<primary><command>locale-gen</command></primary>
			</indexterm>
			 <para>
				Локаль представляет собой группу региональных настроек. Они включают в себя не только язык текста, но и формат отображения чисел, дат, времени и денежных сумм, а также алфавитные правила сравнения (чтобы правильно учитывать диакритические знаки). Хотя каждый из этих параметров может быть установлен независимо от остальных, мы обычно используем локаль, которая является согласованным набором значений всех параметров, соответствующих «региону» в самом широком смысле. Локали обычно указаны в форме <literal><replaceable>код-языка</replaceable>_<replaceable>КОД-СТРАНЫ</replaceable></literal>, а иногда с суффиксом, для указания набора символов и кодировки, которые будут использоваться. Это позволяет решить идиоматические или типографские различия между различными регионами с одинаковым языком.
			</para>
			 <sidebar> <title><emphasis>КУЛЬТУРА</emphasis> Набор символов (кодировка)</title>
			 <indexterm>
				<primary>набор символов</primary>
			</indexterm>
			 <indexterm>
				<primary>кодировка</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-1</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-15</primary>
			</indexterm>
			 <indexterm>
				<primary>Латиница 1</primary>
			</indexterm>
			 <indexterm>
				<primary>Латиница 9</primary>
			</indexterm>
			 <para>
				Исторически сложилось так, что каждый язык имеет связанный «набор символов» (группа известных символов) и предпочтительную «кодировку» (внутреннее представление символов внутри компьютера).
			</para>
			 <para>
				Наиболее популярные кодировки для языков, созданных на базе латиницы, были ограничены 256 символами, потому что для каждого символа использовался 1 байт. Поскольку 256-ю символами невозможно было охватить все буквы европейских языков, появилась необходимость в других кодировках, так , среди других, появились <emphasis>ISO-8859-1</emphasis> (также известный как «Латиница 1») вплоть до <emphasis>ISO-8859-15</emphasis> (также известный как «Латиница 9»).
			</para>
			 <para>
				Работа с иностранными языками часто подразумевает регулярное переключение между различными наборами символов и кодировки. Кроме того написание многоязычных документов привели к дальнейшим, почти неразрешимым проблемам. Юникод (супер-каталог почти всех систем письменности из всех языков мира) был создан для решения этой проблемы. Одной из кодировок Юникода UTF-8, сохраняет все 128 символов ASCII (7-битные коды), но по-разному обрабатывает другие символы. Их предваряет конкретная управляющая последовательность из нескольких битов, которая определяет длину символа. Это позволяет кодировать все символы Юникода в последовательность одного или более байтов. Его использование популяризировало то обстоятельство, что это кодировка по умолчанию в XML-документах.
			</para>
			 <indexterm>
				<primary>ASCII</primary>
			</indexterm>
			 <indexterm>
				<primary>UTF-8</primary>
			</indexterm>
			 <indexterm>
				<primary>Юникод</primary>
			</indexterm>
			 <para>
				Эта кодировка должна использоваться повсеместно и таким образом используется по умолчанию на системах Debian.
			</para>
			 </sidebar> <para>
				Пакет <emphasis role="pkg">locales</emphasis> включает все элементы, необходимые для надлежащего функционирования «локализации» в различных приложениях. Во время установки этот пакет попросит выбрать набор поддерживаемых языков. Этот набор можно изменить в любое время, запустив <command>dpkg-reconfigure locales</command> являясь администратором.
			</para>
			 <para>
				Первый вопрос приглашает вас выбрать «языки» для поддержки. Выбор всех английских языков (то есть начинающиеся с «<literal>en_</literal>») является разумным выбором. Можно также включить другие языки, если машина будет использоваться иноязычными пользователями. Список языков хранится в файле <filename>/etc/locale.gen</filename>. Можно отредактировать этот файл вручную, но вы должны запустить <command>locale-gen</command> после любых изменений. Это создаст необходимые файлы для добавленных языков и удалит все неиспользуемые файлы.
			</para>
			 <para>
				Второй вопрос, озаглавленный «Локаль по умолчанию для системной среды», запрашивает языковой стандарт по умолчанию. Для России используйте «<literal>ru_RU.UTF-8</literal>». Рекомендуемый выбор в США является «<literal>en_US.UTF-8</literal>», канадцы предпочитают либо «<literal>en_CA.UTF-8</literal>» или, для французского языка, «<literal>fr_CA.UTF-8</literal>». Файл <filename>/etc/default/locale</filename> будет изменен для хранения результатов выбора. Он будет использоваться для всех пользовательскиз сеансов, PAM будет вводить его содержание в переменную среды <varname>LANG</varname>.
			</para>
			 <indexterm>
				<primary>окружение</primary>
			</indexterm>
			 <indexterm>
				<primary>локаль</primary>
			</indexterm>
			 <indexterm>
				<primary><varname>LANG</varname></primary>
			</indexterm>
			 <sidebar id="sidebar.intro-pam"> <title><emphasis>ЗА КУЛИСАМИ</emphasis> <filename>/etc/environment</filename> и <filename>/etc/default/locale</filename></title>
			 <para>
				Файл <filename>/etc/environment</filename> предоставляет возможность использовать <command>login</command>, <command>gdm</command> или даже <command>ssh</command> с правильными переменными среды.
			</para>
			 <para>
				Эти приложения не создают эти переменные напрямую, а используют модуль PAM (<filename>pam_env.so</filename>). PAM (подключаемый модуль аутентификации) — это модульная библиотека централизации механизмов аутентификации, сессии инициализации и управления паролями. См. <xref linkend="sect.config-pam" /> для примера конфигурации PAM.
			</para>
			 <para>
				Файл <filename>/etc/default/locale</filename> работает аналогично, но содержит только переменную среды <varname>LANG</varname>. Благодаря такому разделению некоторые пользователи PAM могут наследовать полноценную среду без локализации. Действительно, как правило не рекомендуется запускать серверные программы с включённой локализацией; с другой стороны локализация и региональные параметры рекомендуются для программ, которые открывают сеансы пользователей.
			</para>
			 <indexterm>
				<primary>PAM</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>pam_env.so</filename></primary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.keyboard-config">
			<title>Настройка клавиатуры</title>
			 <indexterm>
				<primary>раскладка клавиатуры</primary>
			</indexterm>
			 <indexterm>
				<primary>клавиатура, раскладка</primary>
			</indexterm>
			 <para>
				Даже если раскладка клавиатуры осуществляется по-разному в консоли и в графическом режиме, Debian предлагает единый конфигурационный интерфейс, который работает для обоих режимов: он основан на debconf и реализован в пакете <emphasis role="pkg">keyboard-configuration</emphasis>. Таким образом, команда <command>dpkg-reconfigure keyboard-configuration</command> может использоваться в любое время для смены раскладки клавиатуры.
			</para>
			 <indexterm>
				<primary><emphasis>console-data</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>console-tools</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>keyboard-configuration</emphasis></primary>
			</indexterm>
			 <para>
				<indexterm><primary><literal>azerty</literal></primary></indexterm>Сомнения есть в соответствии раскладки физической клавиатуре (стандартная компьютерная клавиатура в США - это “Generic 104 key” - то есть обычная, стандартная), кроме того изменения раскладки (обычно “US”), и расположение клавиши AltGr (правая Alt). И в завершении обычно возникает вопрос о клавише, используемой как “Compose key”, которая позволяет вводить специальные символы посредством сочетания клавиш. Выполняя последовательно <keycombo action="seq"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> и будет создан специальный символ е-острый(“é”). Все эте сочетания клавиш описаны в файле <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> (или в другом файле, определенном, согласно настоящей локали, и указывать в файле <filename>/usr/share/X11/locale/compose.dir</filename>).
			</para>
			 <indexterm>
				<primary><literal>Compose</literal>, клавиша</primary>
			</indexterm>
			 <indexterm>
				<primary><literal>Meta</literal>, клавиша</primary>
			</indexterm>
			 <indexterm>
				<primary>клавиша</primary>
				<secondary><literal>Meta</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary>клавиша</primary>
				<secondary><literal>Compose</literal></secondary>
			</indexterm>
			 <para>
				Запомните, что клавиатурная конфигурация, описанная здесь для графического режима, затрагивает только раскладку по умолчанию; GNOME и KDE окружающие обстановки, среди других, поддерживают контрольную панель клавиатуры, настраиваемую по своим предпочтениям, что делает возможным каждому пользователю иметь их собственную конфигурацию. Некоторые дополнительные опции относительно поведения некоторых индивидуальных клавиш доступны также в тех контрольных панелях.
			</para>

		</section>
		 <section id="sect.utf8-migration">
			<title>Переход на UTF-8</title>
			 <para>
				Подводя итоги, можем констатировать тот факт, что перекодирование в UTF-8 наконец-то получило долгожданное решение, ранее тормозящееся из-за многочисленных затруднений с совместимостью. Теперь устранены препятствия и помехи для международного обмена и произвольные ограничения на алфавит, который теперь может быть использован в документах. Единственной отрицательной стороной было, что пришлось пройти через довольно затруднительную переходную стадию. Поскольку это еще не является сейчас общемировым стандартом (так как одновременный переход всех компьютеров в мире на UTF-8 не может произойти одномоментно), необходимо все же в настоящее время еще выполнить две операции преобразования: одна - работа по перекодированию содержания файла и другая - тоже с именем файла. К счастью, основная часть самой процедуры перекодирования на UTF-8 уже выполнена и в данный момент мы дискутируем на эту тему в значительной степени для справки.
			</para>
			 <sidebar> <title><emphasis>КУЛЬТУРА</emphasis> <foreignphrase>Крокозябры</foreignphrase> и интерпретация ошибок</title>
			 <para>
				Когда текст посылают (или сохраняют) не уведомляя получателя о том, какую кодировку использовал отправитель, получатель не всегда имеет возможность уверенно определить - каким подходящим инстументом ему надо воспользоваться, чтобы понять смысл полученного набора байтов. Первой идеей у вас может возникнуть мысль - получить статистику о расположении значений, представленных в тексте, но это не всегда дает правильный ответ. Когда система перекодирования текста выбирает для чтения файла кодировку, отличающуюся от той, что использовалась при записи файла, байты будут неверно истолкованы, и вы получите, в лучшем случае, ошибки на некоторых символах, или, в худшем - некий комплект кое-чего неразборчивого.
			</para>
			 <para>
				Таким образом, если текст на французском при просмотре выглядит нормально, за исключением диакритических знаков и конечно символов, которые появляются для замены комбинации символов, похожие на “Ã©” или Ã¨” или “Ã§”, то в данном случае возможно файл закодирован как UTF-8, но интерпретируется как ISO-8859-1 или ISO-8859-15. Это говорит о том, что локальная система на данном компьютере еще не переведена на UTF-8. В другом случае, вы видите места, помеченные вопросами, взамен диакритических знаков — даже если эти, маркированные вопросами, места возможно и будут перезаписывать и символ, следующий за диакритической буквой — тогда вероятнее всего, ваша система уже настроена на работу с UTF-8 а вам прислали документ, созданный в Западной кодировке ISO.
			</para>
			 <para>
				Такого рода случаи относятся к “простым”. И они возникают только в Западной культуре. Это связано с тем, что когда был создан Unicode (и UTF-8), то постарались найти общие точки соприкосновения (совпадения символов) для исторически сложившихся наборов символов (кодировки) для Западных языков, базирующихся на латинском алфавите, что позволило распознавать части текста даже в случаях, когда некоторые символы отсутствуют.
			</para>
			 <para>
				В более сложных конфигурациях, например в случае, который включает в себя два окружения (среды), согласованные с двумя различными языками, при этом эти языки созданы на базе непохожих алфавитов. В таком варианте вы часто получите комплект нечитаемых результатов — серию абстрактных символов, не имеющих ничего общего друг с другом. Это, главным образом, связано с Азиатскими языками, и обусловленно их многочисленными языками и системами для записи. Японское слово <foreignphrase>mojibake</foreignphrase> (крокозябры) был позаимствован (у них) для описания этого явления. Когда появляется такая ситуация, диагностировать причину становиться сложнее и наипростейшим решением очень часто является принятие решение о переходе на UTF-8 для обоих окружений (сред).
			</para>
			 </sidebar> <para>
				Касательно перекодирования имени файла из одной кодировки в другую - это можно сделать относительно просто. Инструмент (программа) <command>convmv</command> (в пакете с похожим именем) была создана специально для такого случая; это позволит переименовать названия файлов из одной кодировки в другую. Использование этого инструмента относительно просто, но мы рекомендует делать это за два шага - чтобы избежать сюрпризов. Следующий пример иллюстрирует это - окружающая среда на компьютере настроена на UTF-8, и имеются каталоги, чьи имена составлены в кодировке ISO-8859-15, и использование упомянутой выше программы <command>convmv</command> переименует их.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Ic?nes  ?l?ments graphiques  Textes
$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>Starting a dry run without changes...
mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"   "travail/Icônes"
No changes to your files done. Use --notest to finally rename the files.
$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
Ready!
$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput></screen>
			 <para>
				Для перекодирования содержимого файла, процедура предобразования более сложна и это обусловленно многочисленным разнообразием существующих форматов файлов. Некоторые форматы файлов включают в себя кодирующую информацию. Это облегчает задачу программам, которые используют эту внутреннюю информацию при обработке файлов. В обычном случае этого бывает достаточно, чтобы открыть файлы и пересохранить их, установив в момент сохранения кодировку UTF-8. В других случаях, вы должны указать исходную кодировку при открытии файла (ISO-8859-1 или “Западная”, или ISO-8859-15 or “Западная (Евро)”, в соответствии с формулировками).
			</para>
			 <para>
				Для простых текстовых файлов, вы можете использовать команду <command>recode</command> (в пакете с похожим именем), которая позволит автоматически перекодировать. Это средство имеет многочисленные опции, так что вы можете поиграть с его поведением. Мы рекомендуем вам консультироваться с документацией, man-страница - <citerefentry> <refentrytitle>recode</refentrytitle>
				 <manvolnum>1</manvolnum> </citerefentry>, или инфо-страница the <citerefentry> <refentrytitle>recode</refentrytitle>
				 </citerefentry> (более полный).
			</para>

		</section>

	</section>
	 <section id="sect.network-config">
		<title>Настройка Сети</title>
		 <sidebar id="sidebar.networking-basics"> <title><emphasis>К ОСНОВАМ</emphasis> Необходимое понятие о сети (Ethernet, IP адрес, подсети, широковещательная рассылка пакетов)</title>
		 <indexterm>
			<primary>Ethernet</primary>
		</indexterm>
		 <indexterm>
			<primary>10BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>100BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>1000BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>10GBASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>разъем, RJ45</primary>
		</indexterm>
		 <indexterm>
			<primary>разъём RJ45</primary>
		</indexterm>
		 <para>
			Большинство современных локальных сетей используют протокол Ethernet, где данные разделяются на небольшие блоки, называемые кадрами и передаются по кабелю - за один раз - один кадр. Скорость передачи данных изменяется от 10 Мб/с для старых карт Ethernet до 10 Гбит/с - в новейших картах (с более распространенными в настоящее время скорость вырастает с 100 Мб/с до 1 Гбит/с). Наиболее широко используемые кабели называются 10BASE-T, 100BASE-T, 1000BASE-T или 10GBASE-T, которые в зависимости от своей пропускной способности могут надежно обеспечить передачу данных (Т означает “витая пара”); эти провода на окончаниях оформляются разъемами RJ45. Имеются и другие типы кабелей, используемых в основном для скорости 1 Гбит/с и выше.
		</para>
		 <indexterm>
			<primary>адрес, IP адрес</primary>
		</indexterm>
		 <indexterm>
			<primary>IP адрес</primary>
		</indexterm>
		 <para>
			IP-адрес представляет собой номер, используемый для идентификации сетевого интерфейса на компьютере, на локальной сети или в Интернете. В настоящее время наиболее распространенной версией протокола является IP (IPv4). Номер IP кодируется в 32 бита, и обычно представляет из себя 4 блока 3-х значных чисел, разделенных точками (например <literal>192.168.0.1</literal>), значение каждого блока находится в интервале от 0 до 255 (включительно, что соответствует 8-ми битной кодировке). Следующая версия протокола IPv6 расширяет адресное пространство до 128-бит, а сами адреса обычно представляют из себя последовательность из шестнадцатеричных чисел, разделенные на колонки через двоеточие (например, 2001:0db8:13bb:0002:0000:0000:0000:0020, или 2001:db8:13bb:2::20 для краткости).
		</para>
		 <indexterm>
			<primary>subnet</primary>
		</indexterm>
		 <indexterm>
			<primary>mask</primary>
			<secondary>subnet mask</secondary>
		</indexterm>
		 <indexterm>
			<primary>network</primary>
			<secondary>address</secondary>
		</indexterm>
		 <para>
			Маска подсети (netmask) определяется в двоичном коде, у которой адрес IP делится на две части - одна определяет адрес в наружной сети (например интернет), а вторая часть - определяет адрес машины во внутренней (локальной) сети. В примере, приведенном здесь, сконфигурирован статичный адрес IPv4, маска подсети, <literal>255.255.255.0</literal> (24 "1"-к и следом за ними 8 "0"-й в бинарном представлении, то есть 11111111111111111111111100000000) указывает на то, что первые 24 бит статичного IP-адреса соотносятся с адресом в наружной сети (например интернет или, в крупной сети, - надсеть -то есть сеть, рангом повыше), и другие 8 являются специфическими для данной машины. В IPv6, для удобочитаемости, только количество “1”-к выражено; маска сети для IPv6-сети может, таким образом, быть <literal>64</literal>.
		</para>
		 <para>
			В IP-адресе, который приведен выше, номером машины является 0. Диапазон сетевых IPv4-адресов в сформированной сети часто синтаксически указывается следующим образом, <emphasis>a.b.c.d/e</emphasis>, в котором <emphasis>a.b.c.d</emphasis> является сетевым адресом и <emphasis>e</emphasis> - количество бит затрагивающие сетевую часть в IP-адресе. Пример сети, таким образом, можно записать: <literal>192.168.0.0/24</literal>. Похожий синтаксис и в IPv6: <literal>2001:db8:13bb:2::/64</literal>.
		</para>
		 <indexterm>
			<primary>маршрутизатор</primary>
		</indexterm>
		 <indexterm>
			<primary>bridge</primary>
		</indexterm>
		 <para>
			Маршрутизатор представляет собой устройство, которое соединяет несколько сетей друг с другом. Весь трафик, проходящий через маршрутизатор, направляется в нужную сеть. Для этого, маршрутизатор анализирует входящие пакеты и перенаправляет их в соответствии с IP-адресом места их конечного назначения. Маршрутизатор часто знают как шлюз; в этой конфигурации, он работает как машина, которая помогает выйти за пределы своей локальной сети (по направлению к расширенной сети, такой как Интернет).
		</para>
		 <indexterm>
			<primary>broadcast</primary>
		</indexterm>
		 <para>
			Специальный широковещательный адрес (broadcast address - xxx.xxx.xxx.255) устанавливает непосредственную связь всех станций в сети. Почти никогда не “направляется по определённому маршруту”, его функции в сети - рассылка компьютерам данной сети дейтаграмм. Следовательно, это значит, что пакеты с данными, адресованные в этот специальный широковещательный адрес никогда не проходят через маршрутизатор (broadcast address выполняют функцию только внутри сети).
		</para>
		 <para>
			Данная глава посвящена адресам IPv4, поскольку они сейчас наиболее часто используются. К особенностям протокола IPv6 мы обращаемся в разделе <xref linkend="sect.ipv6" />, но основные принципы остаются теми же.
		</para>
		 </sidebar> <para>
			The network is automatically configured during the initial installation. If Network Manager gets installed (which is generally the case for full desktop installations), then it might be that no configuration is actually required (for example, if you rely on DHCP on a wired connection and have no specific requirements). If a configuration is required (for example for a WiFi interface), then it will create the appropriate file in <filename>/etc/NetworkManager/system-connections/</filename>.
		</para>
		 <para>
			If Network Manager is not installed, then the installer will configure <emphasis role="pkg">ifupdown</emphasis> by creating the <filename>/etc/network/interfaces</filename> file. A line starting with <literal>auto</literal> gives a list of interfaces to be automatically configured on boot by the <literal>networking</literal> service.
		</para>
		 <para>
			In a server context, <emphasis role="pkg">ifupdown</emphasis> is thus the network configuration tool that you usually get. That is why we will cover it in the next sections.
		</para>
		 <indexterm>
			<primary>network</primary>
			<secondary>configuration</secondary>
		</indexterm>
		 <indexterm>
			<primary>configuration</primary>
			<secondary>of the network</secondary>
		</indexterm>
		 <indexterm>
			<primary>interface</primary>
			<secondary>network interface</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>АЛЬТЕРНАТИВА</emphasis> Диспетчер сети</title>
		 <indexterm>
			<primary><emphasis role="pkg">network-manager</emphasis></primary>
		</indexterm>
		 <para>
			If Network Manager is particularly recommended in roaming setups (see <xref linkend="sect.roaming-network-config" />), it is also perfectly usable as the default network management tool. You can create “System connections” that are used as soon as the computer boots either manually with a <filename>.ini</filename>-like file in <filename>/etc/NetworkManager/system-connections/</filename> or through a graphical tool (<command>nm-connection-editor</command>). Just remember to deactivate all entries in <filename>/etc/network/interfaces</filename> if you want Network Manager to handle them. <ulink type="block" url="https://wiki.gnome.org/Projects/NetworkManager/SystemSettings" /> <ulink type="block" url="https://developer.gnome.org/NetworkManager/1.6/ref-settings.html" />
		</para>
		 </sidebar> <section id="sect.interface-ethernet">
			<title>Интерфейс Ethernet</title>
			 <para>
				Если компьютер имеет Ethernet-карту, IP-сеть, что будет с ней связанна это должно быть настроено выбирая один из двух методов. Простейшим методом является динамическая настройка с DHCP, и это потребует установки DHCP-сервера в локальной сети. Здесь же можно определить имя вашего компьютера, которое будет соответствовать имени <literal>hostname</literal> в примере ниже. Запущенный DHCP-сервер рассылает информацию о том, как настроена сеть, всем компьютерам в локальной сети.
			</para>
			 <indexterm>
				<primary>Ethernet</primary>
			</indexterm>
			 <indexterm>
				<primary>DHCP</primary>
			</indexterm>
			 <example id="example.config-dhcp">
				<title>Настройка DHCP</title>
				 
<programlisting>
auto enp0s31f6
iface enp0s31f6 inet dhcp
  hostname arrakis
</programlisting>

			</example>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> Names of network interfaces</title>
			 <indexterm>
				<primary><literal>eth0</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>en*</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>wlan0</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>wl*</literal></primary>
			</indexterm>
			 <para>
				By default, the kernel attributes generic names such a <literal>eth0</literal> (for wired Ethernet) or <literal>wlan0</literal> (for WiFi) to the network interfaces. The number in those names is a simple incremental counter representing the order in which they have been detected. With modern hardware, that order might change for each reboot and thus the default names are not reliable.
			</para>
			 <para>
				Fortunately, systemd and udev are able to rename the interfaces as soon as they appear. The default name policy is defined by <filename>/lib/systemd/network/99-default.link</filename> (see <citerefentry><refentrytitle>systemd.link</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> for an explanation of the <literal>NamePolicy</literal> entry in that file). In practice, the names are often based on the device's physical location (as guessed by where they are connected) and you will see names starting with <literal>en</literal> for wired ethernet and <literal>wl</literal> for WiFi. In the example above, the rest of the name indicates, in abbreviated form, a PCI (<literal>p</literal>) bus number (<literal>0</literal>), a slot number (<literal>s31</literal>), a function number (<literal>f6</literal>).
			</para>
			 <para>
				Obviously, you are free to override this policy and/or to complement it to customize the names of some specific interfaces. You can find out the names of the network interfaces in the output of <command>ip addr</command> (or as filenames in <filename>/sys/class/net/</filename>).
			</para>
			 </sidebar> <para>
				В варианте с выбором “статичной” настройкой сети необходимо установить фиксированные значения. Это включает в себя, по меньшей мере, IP-адрес и маску подсети; а также иногда необходимо указать сетевые и широковещательные адреса. Маршрутизатор, соединяющий с внешним миром, будет обозначен как шлюз.
			</para>
			 <example id="example.static-network">
				<title>Настройка статического IP-адреса</title>
				 
<programlisting>
auto enp0s31f6
iface enp0s31f6 inet static
  address 192.168.0.3
  netmask 255.255.255.0
  broadcast 192.168.0.255
  network 192.168.0.0
  gateway 192.168.0.1
</programlisting>

			</example>
			 <sidebar> <title><emphasis>ЗАМЕТКА</emphasis> Настройка нескольких адресов</title>
			 <para>
				Можно взаимно увязать не только несколько интерфейсов с одной, физически установленной в компьютер, сетевой картой, но также присвоить несколько IP-адресов на одиночный интерфейс. Запомните также, что IP-адрес может соответствовать любому количеству имен через DNS, и что имя также может быть соотнесено с любым количеством пронумерованных IP-адресов.
			</para>
			 <para>
				Как вы уже наверное догадались, конфигурация сети может быть достаточно сложной, но те опции обычно используются только в очень специфичных случаях. Примеры, приведенные здесь, характерны для обычных конфигураций.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.interface-wireless">
			<title>Wireless Interface</title>
			 <indexterm>
				<primary>wireless</primary>
			</indexterm>
			 <para>
				Getting wireless network cards to work can be a bit more challenging. First of all, they often require the installation of proprietary firmwares which are not installed by default in Debian. Then wireless networks rely on cryptography to restrict access to authorized users only, this implies storing some secret key in the network configuration. Let's tackle those topics one by one.
			</para>
			 <section>
				<title>Installing the required firmwares</title>
				 <indexterm>
					<primary>firmware</primary>
				</indexterm>
				 <indexterm>
					<primary>isenkram</primary>
				</indexterm>
				 <para>
					First you have to enable the non-free repository in APT's sources.list file: see <xref linkend="sect.apt-sources.list" /> for details about this file. Many firmware are proprietary and are thus located in this repository. You can try to skip this step if you want, but if the next step doesn't find the required firmware, retry after having enabled the non-free section.
				</para>
				 <para>
					Then you have to install the appropriate <literal>firmware-*</literal> packages. If you don't know which package you need, you can install the <emphasis role="pkg">isenkram</emphasis> package and run its <command>isenkram-autoinstall-firmware</command> command. The packages are often named after the hardware manufacturer or the corresponding kernel module: <emphasis role="pkg">firmware-iwlwifi</emphasis> for Intel wireless cards, <emphasis role="pkg">firmware-atheros</emphasis> for Qualcomm Atheros, <emphasis role="pkg">firmware-ralink</emphasis> for Ralink, etc. A reboot is then recommended because the kernel driver usually looks for the firmware files when it is first loaded and no longer afterwards.
				</para>

			</section>
			 <section>
				<title>Wireless specific entries in <filename>/etc/network/interfaces</filename></title>
				 <indexterm>
					<primary>WPA</primary>
				</indexterm>
				 <para>
					<emphasis>ifupdown</emphasis> is able to manage wireless interfaces but it needs the help of the <emphasis role="pkg">wpasupplicant</emphasis> package which provides the required integration between <emphasis>ifupdown</emphasis> and the <command>wpa_supplicant</command> command used to configure the wireless interfaces (when using WPA/WPA2 encryption). The usual entry in <filename>/etc/network/interfaces</filename> needs to be extended with two supplementary parameters to specify the name of the wireless network (aka its SSID) and the <emphasis>Pre-Shared Key</emphasis> (PSK).
				</para>
				 <example id="example.config-wireless">
					<title>DHCP configuration for a wireless interface</title>
					 
<programlisting>
auto wlp4s0
iface wlp4s0 inet dhcp
  wpa-ssid Falcot
  wpa-psk ccb290fd4fe6b22935cbae31449e050edd02ad44627b16ce0151668f5f53c01b
</programlisting>
				</example>
				 <para>
					The <literal>wpa-psk</literal> parameter can contain either the plain text passphrase or its hashed version generated with <command>wpa_passphrase <replaceable>SSID</replaceable> <replaceable>passphrase</replaceable></command>. If you use an unencrypted wireless connection, then you should put a <literal>wpa-key-mgmt NONE</literal> and no <literal>wpa-psk</literal> entry. For more information about the possible configuration options, have a look at <filename>/usr/share/doc/wpasupplicant/README.Debian.gz</filename>.
				</para>
				 <para>
					At this point, you should consider restricting the read permissions on <filename>/etc/network/interfaces</filename> to the root user only since the file contains a private key that not all users should have access to.
				</para>
				 <sidebar> <title><emphasis>HISTORY</emphasis> WEP encryption</title>
				 <indexterm>
					<primary>WEP</primary>
				</indexterm>
				 <para>
					Usage of the deprecated WEP encryption protocol is possible with the <emphasis role="pkg">wireless-tools</emphasis> package. See <filename>/usr/share/doc/wireless-tools/README.Debian</filename> for instructions.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.ppp-rtc">
			<title>Подключение с PPP через PSTN-модем</title>
			 <indexterm>
				<primary>PPP</primary>
			</indexterm>
			 <indexterm>
				<primary>point to point</primary>
			</indexterm>
			 <indexterm>
				<primary>соединение</primary>
				<secondary>через модем PSTN</secondary>
			</indexterm>
			 <indexterm>
				<primary>modem</primary>
				<secondary>PSTN</secondary>
			</indexterm>
			 <para>
				При использовании протокола точка-точка (PPP) устанавливается постоянное соединение с передачей сигналов прерывистым методом; этот вариант является наиболее общим решением для соединения, основанного на телефонном модеме (“PSTN модем”, в данном случае соединение осуществляется поверх телефонной сети общего пользования).
			</para>
			 <para>
				Для соединия с провайдером через телефонный модем необходимо получить у провайдера account (имя для входа), который включает в себя также номер телефона, фамилию-имя-отчество, пароль, и, иногда необходимо указать - какой протокол проверки подлинности надо использовать. Такого рода соединения настраиваются с применением инструмента <command>pppconfig</command>, расположенного в Debian пакете с похожим именем. По умолчанию, он устанавливает соединение с именем <literal>provider</literal> (к примеру с именем вашего Интернет-провайдера). Если вы сомневаетесь, какой протокол проверки подлинности надо применить, выбирайте <emphasis>PAP</emphasis>: его применяют большинство Интернет-сервис провайдеров.
			</para>
			 <indexterm>
				<primary><command>pppconfig</command></primary>
			</indexterm>
			 <indexterm>
				<primary>PAP</primary>
			</indexterm>
			 <para>
				После настройки, становится возможным подсоединиться используя команду <command>pon</command> (давая ей имя соединения как параметр, когда установленное по умолчанию значение <literal>provider</literal> не подходит). Отключить это соединение можно с командой <command>poff</command>. Указанные две команды могут быть выполнены пользователем администратор (root), или любым другим пользователем, включенным в группу <literal>dip</literal>.
			</para>
			 <indexterm>
				<primary><command>pon</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>poff</command></primary>
			</indexterm>

		</section>
		 <section id="sect.adsl">
			<title>Подключение через ADSL модем</title>
			 <indexterm>
				<primary>соединение</primary>
				<secondary>через ADSL модем</secondary>
			</indexterm>
			 <indexterm>
				<primary>модем</primary>
				<secondary>ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>ADSL, модем</primary>
			</indexterm>
			 <para>
				Общим названием “ADSL модем” обозначают большую группу устройств с очень различными функциями. Модемы, что могут быть запросто использованы с Linux имеют в своем составе интерфейс Ethernet (а не только интерфейс USB). Это направление (развития модемов с интегрированным интерфейсом Ethernet) становится все более популярным. Большинство Интернет провайдеров, оказывающих услуги по предоставлению доступа в интернет по технологии ADSL, предлагают пользователям долгосрочную ссуду или дают в аренду “коробку” с интерфейсом Ethernet. В зависимости от типа модема, параметры их настройки могут изменяться в широком диапазоне.
			</para>
			 <section id="sect.adsl-pppoe">
				<title>Модемы, поддерживающие протокол PPPoE</title>
				 <indexterm>
					<primary>PPPOE</primary>
				</indexterm>
				 <indexterm>
					<primary><command>pppoeconf</command></primary>
				</indexterm>
				 <para>
					Некоторые Ethernet - модемы работают с протоколом PPPOE (Point to Point Protocol over Ethernet - протокол "точка-точка поверх Интернет"). Инструмент <command>pppoeconf</command> (из пакета с похожим именем) настраивает такое соединение. Для этого, он изменяет файл с настройками провайдера <filename>/etc/ppp/peers/dsl-provider</filename> и записывает данные для входа (login) в файлы <filename>/etc/ppp/pap-secrets</filename> и <filename>/etc/ppp/chap-secrets</filename>. Мы рекомендуем принять все, предложенные командой, изменения.
				</para>
				 <para>
					Как только настройка будет закончена, вы можете открыть ADSL-соединение с командой <command>pon dsl-provider</command> или закрыть с <command>poff dsl-provider</command>.
				</para>
				 <indexterm>
					<primary><literal>dsl-provider</literal></primary>
				</indexterm>
				 <sidebar> <title><emphasis>СОВЕТ</emphasis> Включите команду <command>ppp</command> в автостарт (boot)</title>
				 <indexterm>
					<primary><command>systemd</command></primary>
				</indexterm>
				 <indexterm>
					<primary><command>init</command></primary>
				</indexterm>
				 <para>
					PPP соединение поверх ADSL является, по определению, неустойчивым. Поскольку оно обычно не тарифицируется по времени, у пользователя появляется соблазн держать его всегда открытыми. Однако имеется и несколько минусов такого решения. Стандартным решением для этого является использование системы инициализации (init).
				</para>
				 <para>
					With systemd, adding an automatically restarting task for the ADSL connection is a simple matter of creating a “unit file” such as <filename>/etc/systemd/system/adsl-connection.service</filename>, with contents such as the following:
				</para>
				 
<programlisting>[Unit]
Description=ADSL connection

[Service]
Type=forking
ExecStart=/usr/sbin/pppd call dsl-provider
Restart=always

[Install]
WantedBy=multi-user.target</programlisting>
				 <para>
					Как только этот unit file будет создан, его надо будет включить командой <command>systemctl enable adsl-connection</command>. Этот цикл можно запустить вручную командой <command>systemctl start adsl-connection</command>; также он будет автоматически запущен при старте системы.
				</para>
				 <para>
					На системах, не использующих <command>systemd</command> (включая <emphasis role="distribution">Wheezy</emphasis> и более ранние версии Debian), стандартная система инициализации SystemV работает по-другому. На таких системах, все, что нужно — это добавить в конец файла <filename>/etc/inittab</filename> строку, аналогичную следующей; при разрыве соединения <command>init</command> его переподключит.
				</para>
				 
<programlisting>
adsl:2345:respawn:/usr/sbin/pppd call dsl-provider</programlisting>
				 <para>
					Для ADSL соединений, выполняющих автовыключение ежедневно, этот способ сокращает длительность прерывания.
				</para>
				 </sidebar>
			</section>
			 <section id="sect.adsl-pptp">
				<title>Модемы, поддерживающие PPTP</title>
				 <indexterm>
					<primary>PPTP</primary>
				</indexterm>
				 <para>
					PPTP (туннельный протокол типа точка-точка - Point-to-Point Tunneling Protocol) был создан компанией Microsoft. Его использование брало свое начало от ADSL, однако очень быстро было заменено на PPPOE. Если вас принуждают использовать этот протокол, то смотрите <xref linkend="sect.pptp" />.
				</para>

			</section>
			 <section id="sect.adsl-dhcp">
				<title>Модемы, поддерживающие DHCP</title>
				 <para>
					Когда модем подключён к компьютеру кабелем Ethernet (перекрестный кабель - crossover cable), обычно на компьютере вы настраиваете сетевое соединение с помощью DHCP, а модем работает как шлюз (gateway) и берет на себя заботу о маршрутизации (то есть управляет сетевым трафиком между компьютером и Интернет).
				</para>
				 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Перекрестный (crossover) кабель для прямого соединения Ethernet</title>
				 <indexterm>
					<primary>перекрёстный кабель (кроссовер)</primary>
				</indexterm>
				 <para>
					Компьютерные сетевые карты ожидают получать данные по конкретным проводам (жилкам) в кабеле и посылают такие же данные по другим. При подключении компьютера к локальной сети, обычно вы соединяете кабелем (прямым или перекрестным) сетевую карту с концентратором или коммутатором. Однако, если вы хотите соединить между собою два компьютера напрямую (без концентратора или коммутатора) необходимо направлять сигнал, посылаемый одной картой в получающую часть другой карты, и наоборот. Для этого предназначен перекрестный кабель, и это основание его использования.
				</para>
				 <para>
					Обратите внимание, что это различие стало почти неактуальным в настоящее время, так как современные сетевые карты могут определять тип используемого кабеля и подстраиваться под него, поэтому не удивляйтесь, что оба вида кабеля будут работать в некотором месте.
				</para>
				 </sidebar> <para>
					Большинство “ADSL маршрутизаторов”, имеющихся сегодня в продаже, можно использовать так же, как ADSL модемы, которые предоставляют пользователям провайдеры Internet.
				</para>

			</section>

		</section>
		 <section id="sect.roaming-network-config">
			<title>Автоматическая настройка сети для мобильных пользователей</title>
			 <indexterm>
				<primary><emphasis role="pkg">network-manager</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>network</primary>
				<secondary>roaming configuration</secondary>
			</indexterm>
			 <para>
				Многие инженеры Falcot имеют портативный компьютер, который они используют и дома в рабочих целях. Настройки используемых сетевых подключений различны в зависимости от местоположения. Дома это может быть радиосвязь wifi (защищенная ключом WPA), а на рабочем месте проводная сеть для улучшения безопасности и большей полосы пропускания.
			</para>
			 <para>
				Чтобы избежать ручного подсоединения и отсоединения от интерфейса соответствующей сети, администраторы установили пакет <emphasis role="pkg">network-manager</emphasis> (диспетчер связи) на те машины, которые осуществляют маршрутизацию. Это программное обеспечение позволяет пользователям быстро переключаться из одной сети в другую используя маленькую иконку, показанную в области уведомлений у них на графическом столе. Нажав на эту иконку можно увидеть все доступные сети (обе проводную и радиосвязь - wireless), и далее можно выбрать из них ту сеть, к которой пользователь хочет подсоединиться. Программа запоминает настройки сетей для переключения пользователя, чтобы было всегда соединение, и автоматически переключает на лучшую доступную сеть в случае обрыва связи.
			</para>
			 <para>
				Чтобы достичь такого результата, программа была разделена на 2 части: запущенный с правами администратора (root) процесс (daemon) активирует и настраивает сетевой интерфейс, и этот процесс контролирует пользовательский интерфейс. PolicyKit обрабатывает необходимые проверки авторизации для контроля этой программы и Debian настраивает PolicyKit таким образом, что участники группы netdev могут добавлять и изменять соединения Сетевого Диспетчера.
			</para>
			 <para>
				Сетевой диспетчер знает как обработать различные типы соединений (DHCP, ручная настройка, локальная сеть), но только в случае, если эти настройки программа сделала сама. Это объясняет, почему иногда программа систематически игнорирует все сетевые интерфейсы в <filename>/etc/network/interfaces</filename>, для которых он не подходит. Так как Сетевой Диспетчер не дает деталей в случае если сетевое соединение не показано в иконке, быстрый путь для решения данной проблемы - это надо удалить из <filename>/etc/network/interfaces</filename> любые настройки для всех интерфейсов, что должны управляться самим Сетевым Диспетчером (и потом запустив эту программу вы получите созданные самой программой конфигурационные файлы).
			</para>
			 <para>
				Обратите внимание, что эта программа устанавливается по умолчанию в случае, если в процессе первоначальной установки системы был выбран комплект программ “Окружение рабочего стола”.
			</para>

		</section>

	</section>
	 <section id="sect.hostname-name-service">
		<title>Присваивание Имени Компьютеру (Hostname) и Настройка Службы Имен</title>
		 <indexterm>
			<primary>name</primary>
			<secondary>attribution and resolution</secondary>
		</indexterm>
		 <indexterm>
			<primary>assignment of names</primary>
		</indexterm>
		 <para>
			Смысл присваивания IP-адресам имен, состоящих из слов, в том, чтобы облегчить людям их запоминание. В действительности, IP-адрес идентифицирующий сетевой интерфейс связан с устройством, таким как сетевая карта. Поскольку каждая машина может иметь несколько сетевых карт, и несколько сетевых интерфейсов на каждой карте, такой одиночный компьютер может иметь несколько имен в доменной системы имен.
		</para>
		 <para>
			Однако, вначале каждая машина идентифицируется по главному (или “каноническому”) имени, сохраненном в файле <filename>/etc/hostname</filename> и общается с Linux-ядром сценариями инициализации через команду <command>hostname</command>. Настоящее значение доступно в виртуальной файловой системе, и может быть получено с командой <command>cat /proc/sys/kernel/hostname</command>.
		</para>
		 <indexterm>
			<primary><command>hostname</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Виртуальные файловые системы <filename>/proc/</filename> и <filename>/sys/</filename></title>
		 <indexterm>
			<primary><filename>/proc/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>proc</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/sys/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>sys</filename></primary>
		</indexterm>
		 <para>
			Файлы, расположенные в древовидных каталогах <filename>/proc/</filename> и <filename>/sys/</filename>, образуют так называемую “виртуальную” файловую систему. Их практическое значение состоит в том, чтобы восстанавливать (считывать) информацию от ядра (помещенную тем в виртуальные файлы) и общаться с ним таким образом (записывая информацию в виртуальные файлы - для передачи ядру).
		</para>
		 <para>
			Например файлы, расположенные в каталоге <filename>/sys/</filename>, предназначены для обеспечения доступа к внутренним объектам в ядре, особенно к тем, которые представляют различные устройства в системе. Ядро таким образом может делиться различного рода информацией: сообщать например статус каждого устройства (к примеру, находится ли оно в режиме энергосбережения), является ли это устройство съемным и т.д. Обратите внимание, что каталог с файлами <filename>/sys/</filename> появился с моменты выхода в свет версии ядра 2.6.
		</para>
		 </sidebar> <para>
			Удивительным является то, что доменное имя не управляется подобным образом, а приходит в ядро извне от полного имени машины, которое той присвоено через систему разрешения имен. Вы можете изменить имя машины в файле <filename>/etc/hosts</filename>; просто запишите полное имя для машины там вначале перечня имен, связав его с адресом машины, как в следующем примере:
		</para>
		 <informalexample> 
<programlisting>
127.0.0.1     localhost
192.168.0.1    arrakis.falcot.com arrakis</programlisting>
		 </informalexample> <indexterm>
			<primary><filename>hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/etc/hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary>domain</primary>
			<secondary>name</secondary>
		</indexterm>
		 <indexterm>
			<primary>name</primary>
			<secondary>domain</secondary>
		</indexterm>
		 <indexterm>
			<primary>NSS</primary>
		</indexterm>
		 <section id="sect.name-resolution">
			<title>Разрешение Имен</title>
			 <indexterm>
				<primary>resolution</primary>
				<secondary>name</secondary>
			</indexterm>
			 <indexterm>
				<primary>name</primary>
				<secondary>resolution</secondary>
			</indexterm>
			 <para>
				Механизм разрешения имен в Linux модульный и может использовать различные источники информации, объявленные в файле <filename>/etc/nsswitch.conf</filename>. Запись <literal>hosts</literal> включает в себя порядок разрешения имен. По умолчанию эта запись содержит <literal>files dns</literal>, а это значит, что система вначале консультируется с файлом <filename>/etc/hosts</filename>, затем с указанными в нем DNS серверами. NIS/NIS+ или LDAP серверы являются другими возможными источниками.
			</para>
			 <sidebar> <title><emphasis>ЗАМЕТКА</emphasis> NSS и DNS</title>
			 <para>
				Имейти в виду, что команды, специально предназначенные для DNS-запросов (особенно <command>host</command>) не используют стандартный механизм разрешения имен (NSS). Как следствие, они не принимают во внимание <filename>/etc/nsswitch.conf</filename>, и следовательно, не учитывают и <filename>/etc/hosts</filename> также.
			</para>
			 </sidebar> <section id="sect.dns-server-configuration">
				<title>Настройка DNS-серверов</title>
				 <indexterm>
					<primary>DNS</primary>
				</indexterm>
				 <indexterm>
					<primary>Служба доменных имен</primary>
				</indexterm>
				 <para>
					DNS (Служба доменных имен) является распределенной и иерархической службой, переводящей имена машин в IP-адреса (десятичные), и наоборот. В частности, она может превратить хорошо понятное людям имя, такое как <literal>www.eyrolles.com</literal> в реальный IP адрес, <literal>213.244.11.247</literal>.
				</para>
				 <para>
					Для доступа к информации, размещенной на DNS сервере, сам сервер должен быть доступен для того, чтобы передавать запросы дальше (ретранслировать). У Falcot Corp имеется свой DNS сервер, но индивидуальным пользователям более подойдет вариант использовать DNS сервер, предоставляемый их ISP (интернет-провайдером).
				</para>
				 <indexterm>
					<primary><filename>resolv.conf</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><literal>nameserver</literal></primary>
				</indexterm>
				 <para>
					DNS серверы, которые будут использоваться, указываются в файле <filename>/etc/resolv.conf</filename>, по одному в строке, где вначале строки идет слово <literal>nameserver</literal>, а далее указан десятичный IP адрес (это при варианте статичного адреса IP вашей машины, при использовании DHCP здесь будет другая запись), так как показано в следуюшем примере:
				</para>
				 
<programlisting>
nameserver 212.27.32.176
nameserver 212.27.32.177
nameserver 8.8.8.8
</programlisting>
				 <para>
					Обратите внимание, что файл <filename>/etc/resolv.conf</filename> может быть обработан автоматически (и перезаписан) когда сетью или вашим одиноким компьютером управляет Диспетчер связи (NetworkManager) или этот файл сконфигурирован службой DHCP (или ваш модем может включать в себя такую возможность, как организация DNS сервера, следовательно такие настройки вы сделаете внутри него).
				</para>

			</section>
			 <section id="sect.etc-hosts">
				<title>Файл <filename>/etc/hosts</filename></title>
				 <indexterm>
					<primary><filename>hosts</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/hosts</filename></primary>
				</indexterm>
				 <para>
					Если в локальной сети нет сервера имен, то можно создать небольшую таблицу соответствия IP адресов и имен узлов машин в файле <filename>/etc/hosts</filename>, который обычно зерезервирован для локальной сети станций (статичная адресация). Синтаксис этого файла очень простой: каждая линия включает определенный IP адрес, а далее перечисляются любые связанные с ним имена, (первым идет настоящее доменное имя вашего компьютера, так называемое “полностью квалифицированное” имя, например "192.168.200.6 example.debian.org example").
				</para>
				 <para>
					Этот файл доступен даже во время отключения от сети (интернета) или когда DNS серверы недоступны. Для того, чтобы в данных случаях все нормально работало необходимо, чтобы копия этого файла была расположена на каждой машине в вашей сети. Как только внесли изменения в этот файл на одной из машин, тут же необходимо скопировать его на все машины вашей сети. Это объясняет, почему файл <filename>/etc/hosts</filename> обычно содержит только самые важные записи (не перегружен другой информацией).
				</para>
				 <para>
					Такой файл будет достаточен для маленькой сети, не подсоединенной к Интернету, но с 5-ью машинами и более, рекомендуется установить правильно настроенный DNS сервер.
				</para>
				 <sidebar> <title><emphasis>СОВЕТ</emphasis> В обход DNS</title>
				 <para>
					Поскольку приложения, перед тем, как сделать запрос DNS, проверяют файл <filename>/etc/hosts</filename>, становится возможным включить в данный файл информацию о том, что есть отличия, каким образом DNS запрос будет возвращаться, и поэтому необходимо обойти нормальную DNS-базирующуюся службу разрешения имен.
				</para>
				 <para>
					Это может пригодиться в следующей ситуации: предположим, в установленной системе адрес вэб-сайта некорректно сопоставлен с правильным IP-адресом. При проведении тестирования вэб-сайта это выяснилось. Внесены изменения в DNS записи, но еще до вступления их в силу, уже можно повторно тестировать вэб-сайт (осуществляя DNS запросы "в обход" действующей в настоящей момент службы разрешения имен).
				</para>
				 <para>
					Другое возможное применение - это перенаправление трафика, предназначенного в специфический узел на локальном узле, таким образом предотвращая любое сообщение с данным узлом. Для примера - можно изменить направление трафика таким образом, чтобы они обходили узлы, обслуживающие объявления. Это приведет к большей гибкости, меньшему отвлечению внимания, лучшей навигации.
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.user-group-databases">
		<title>Базы данных пользователей и групп</title>
		 <indexterm>
			<primary>user</primary>
			<secondary>database</secondary>
		</indexterm>
		 <indexterm>
			<primary>group</primary>
			<secondary>database</secondary>
		</indexterm>
		 <indexterm>
			<primary>database</primary>
			<secondary>of users</secondary>
		</indexterm>
		 <indexterm>
			<primary>database</primary>
			<secondary>of groups</secondary>
		</indexterm>
		 <para>
			Список пользователей обычно хранится в файле <filename>/etc/passwd</filename>, а пароли в зашифрованном виде хранятся в файле <filename>/etc/shadow</filename>. Оба этих файла являются текстовыми, в относительно простом формате, который может быть прочитан и изменен с помощью текстового редактора. Каждому пользователю, упомянутому там, отводится для описания одна строка, включающая в себя несколько полей, разделенных двоеточием (“<literal>:</literal>”).
		</para>
		 <sidebar> <title><emphasis>ЗАМЕТКА</emphasis> Редактирование системных файлов</title>
		 <para>
			Все системные файлы, упоминаемые в этой главе, являются текстовыми и могут быть отредактированы с помощью текстового редактора. Так как эти файлы очень важны для функциональности ядра системы, хорошим решением будет принять дополнительные меры предосторожности до начала их редактирования. Во-первых, всегда делайте копию (этих файлов) или резервную копию файловой системы перед открытием или внесением изменений в них. Во вторых, на серверах и машинах, где более чем один человек может потенциально иметь доступ к одинаковым файлам в одно и то же время, необходимо предпринять дополнительные меры для предотвращения повреждения файлов.
		</para>
		 <para>
			Для редактирования важнейших файлов системы достаточно использовать команды <command>vipw</command> - внести изменения в файл <filename>/etc/passwd</filename>, или <command>vigr</command> - для редактирования файла <filename>/etc/group</filename>. Эти команды блокируют файл и предлагают выбрать текстовый редактор, ранее по умолчанию была программа (<command>vi</command> (а в Debian 9.2 программа "vipw" предлагает на выбор 4 программы для редактирования - nano, emacs24, mcedit, vim.tiny), кроме случаев, когда переменная окружения <varname>EDITOR</varname> была изменена). Параметр <literal>-s</literal> в этих командах позволит редактировать соответствующий файл <foreignphrase>shadow</foreignphrase>.
		</para>
		 </sidebar> <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Шифрование, односторонняя функция</title>
		 <indexterm>
			<primary>crypt</primary>
		</indexterm>
		 <para>
			Команда <command>crypt</command> - это односторонняя функция, которая преобразует строку (<varname>A</varname>) в другую строку (<varname>B</varname>) таким образом, что <varname>A</varname> нельзя извлечь из <varname>B</varname>. Единственный путь, чтобы идентифицировать <varname>A</varname> - это тестировать все возможные варианты, проверив каждое из них - определяя, будет ли при преобразовании через функцию создано <varname>B</varname> или нет. Программа использует до 8 символов на входе (строка <varname>A</varname>) и производит строку из 13-ти, годную для печати, ASCII символы (строка <varname>B</varname>).
		</para>
		 </sidebar> <section id="sect.etc-passwd">
			<title>Список пользователей: <filename>/etc/passwd</filename></title>
			 <para>
				Здесь можно увидеть список полей, что используются в файле <filename>/etc/passwd</filename>:
			</para>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/passwd</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>uid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>gid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>GECOS</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>login</literal></primary>
			</indexterm>
			 <itemizedlist>
				<listitem>
					<para>
						login - имя для входа, например <literal>rhertzog</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						password - пароль: пароль зашифрован односторонней функцией (<command>crypt</command>), опираясь на <literal>DES</literal>, <literal>MD5</literal>, <literal>SHA-256</literal> или <literal>SHA-512</literal>. Специальное обозначение “<literal>x</literal>” показывает, что зашифрованный пароль сохранён в файле <filename>/etc/shadow</filename>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uid</literal>: уникальный номер, идентифицирующий каждого пользователя (например номер 1002 присвоен пользователю rhertzog);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: уникальный номер главной группы данного пользователя (Debian создает особенную группу для каждого пользователя по умолчанию, например, номер 1002 присвоен группе rhertzog, которая является главной для пользователя rhertzog);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>GECOS</literal>: данные этого заголовка обычно содержат полное имя пользователя (в данном примере - это GECOS, или фамилия-имя-отчество, через запятую);
					</para>

				</listitem>
				 <listitem>
					<para>
						login directory - каталог пользователя (совпадает с именем для входа), предназначенный для того, чтобы пользователь хранил свои персональные файлы (переменная окружения <varname>$HOME</varname> обычно указывается здесь);
					</para>

				</listitem>
				 <listitem>
					<para>
						program to execute upon login - первая программа, выполненная сразу после входа пользователя в систему. Обычно это командный интерпретатор (shell), например "/bin/bash", дающий пользователю возможность управления (в объеме его прав). Если указать специальное значение <command>/bin/false</command> (которое ничего не делает и возвращает контроль системе немедленно), то пользователь не сможет войти в систему.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Группа в Unix-системе</title>
			 <indexterm>
				<primary>group</primary>
			</indexterm>
			 <para>
				Группа в Unix-системе включает в себя несколько пользователей, которые могут легко обмениваться между собою файлами. Эта группа пользуется системой комплексных разрешений прав доступа (получая выгоду от одинаковых прав). Вы можете также запретить использование определенных программ для конкретных групп.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-shadow">
			<title>Скрытый и Зашифрованный Файл Паролей: <filename>/etc/shadow</filename></title>
			 <indexterm>
				<primary><filename>shadow</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/shadow</filename></primary>
			</indexterm>
			 <para>
				Файл <filename>/etc/shadow</filename> содержит следующие поля:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						login - имя входа пользователя в систему;
					</para>

				</listitem>
				 <listitem>
					<para>
						зашифрованный пароль;
					</para>

				</listitem>
				 <listitem>
					<para>
						несколько полей относятся к окончанию срока действия пароля.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>ДОКУМЕНТАЦИЯ</emphasis> Формат файлов <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> and <filename>/etc/group</filename></title>
			 <para>
				Документацию по этим программах расположена в следующих страницах руководства (man) : <citerefentry><refentrytitle>passwd</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>shadow</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>, и <citerefentry><refentrytitle>group</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>.
			</para>
			 </sidebar> <sidebar> <title><emphasis>БЕЗОПАСНОСТЬ</emphasis> Файл <filename>/etc/shadow</filename> относится к безопасности системы</title>
			 <para>
				Файл <filename>/etc/shadow</filename>, непохож на своего алтер-эго (_лат. "второе я", т.е. дубликат) <filename>/etc/passwd</filename>. Он не может быть прочитан обычными пользователями. Если в системе не применяется защита паролей через shadow, то любой сможет прочитать пароль, сохраненный в файле <filename>/etc/passwd</filename>. Взломщик может попытаться “расколоть” (или вскрыть) его одним из нескольких способов “грубой силы”, когда берут последовательность символов, которые надо опознать и, с помощью специальных программ, делают простой перебор часто используемых комбинаций символов. Этот тип нападения на систему называется "атака по словарю" — и сейчас его уже невозможно применять на системах, которые используют <filename>/etc/shadow</filename>.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.account-modification">
			<title>Изменение существующей учетной записи или пароля</title>
			 <indexterm>
				<primary><command>chsh</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chfn</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chage</command></primary>
			</indexterm>
			 <indexterm>
				<primary>password</primary>
			</indexterm>
			 <para>
				Следующие команды позволяют изменять информацию, размещенную в конкретных полях базы данных пользователей. Команда <command>passwd</command> позволяет обычному пользователю изменять их пароль, в этом случае сразу происходит изменение и обновление файла <filename>/etc/shadow</filename>. Команда <command>chfn</command> (CHange Full Name - Изменить Полное Имя), зарезервирована для администратора (super-user, root), изменяет поле <literal>GECOS</literal>. Команда <command>chsh</command> (CHange SHell - Изменить командный интерпретатор) позволяет пользователю изменить свой первоначальный командный интерпретатор во время входа в систему, однако доступный выбор будет ограничен только теми, что расположены в файле <filename>/etc/shells</filename>. На администратора это ограничение не распространяется и он может установить себе любую программу, по своему выбору.
			</para>
			 <para>
				И наконец, команда <command>chage</command> (CHange AGE - Изменить возраст) позволит администратору изменить пароль с истекающим сроком действия (Параметр <literal>-l <replaceable>user</replaceable></literal> покажет настоящие значения). Вы можете также принудительно завершить срок действия пароля для пользователя используя команду <command>passwd -e <replaceable>user</replaceable></command>. В этом случае при следующем входе пользователя в систему ему будет предложено заменить существующий пароль (принудительно, без всяких "хочу" или "не хочу").
			</para>

		</section>
		 <section id="sect.disabling-account">
			<title>Отключение учетной записи</title>
			 <indexterm>
				<primary>Отключение учетной записи</primary>
			</indexterm>
			 <indexterm>
				<primary>account</primary>
				<secondary>disable</secondary>
			</indexterm>
			 <para>
				Вам может понадобиться “отключить учетную запись” (заблокировать пользователя), в качестве дисциплинарной меры, для целей расследования, или просто в случае длительного или окончательного отсутствия пользователя. Отключённая учетная запись означает, что пользователь не может войти или получить доступ к машине. Учетная запись остается неизменной на машине и никаких файлов или данных не удаляется, запись просто становится недоступна. Для этого надо применить команду <command>passwd -l <replaceable>user</replaceable></command> (блокировать). Снять блокировку учетной записи можно похожим способом, с параметром <literal>-u</literal> (разблокировать).
			</para>
			 <sidebar id="sidebar.intro-nss"> <title><emphasis>УГЛУБЛЯЕМСЯ</emphasis> NSS и база данных системы</title>
			 <indexterm>
				<primary>NSS</primary>
			</indexterm>
			 <indexterm>
				<primary>Диспетчер службы имен (NSS)</primary>
			</indexterm>
			 <para>
				Взамен использования обычных файлов, управляющих списком пользователей и групп, вы можете использовать другие типы базы данных, такие как LDAP или <command>db</command>, используя соответствующий модуль NSS (Диспетчер службы имен). Используемые модули можно просмотреть в файле <filename>/etc/nsswitch.conf</filename>, в местах расположения <literal>passwd</literal>, <literal>shadow</literal> и <literal>group</literal>. Смотри <xref linkend="sect.config-nss" /> для конкретных примеров использования модулей NSS через LDAP.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-group">
			<title>Список групп: <filename>/etc/group</filename></title>
			 <para>
				Группы, существующие в системе, перечислены в файле <filename>/etc/group</filename>, простая текстовая база данных в формате, похожем на тот, что используется в файле <filename>/etc/passwd</filename>, со следующими полями:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						имя группы;
					</para>

				</listitem>
				 <listitem>
					<para>
						пароль (необязательно): это поле используется в случаях, если необходимо присоединить кого-то к группе, при этом, не давать ему те же права, как у других членов этой группы (с командами <command>newgrp</command> или <command>sg</command>, смотри вставку <xref linkend="sidebar.working-with-several-groups" />);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: уникальный идентификационный номер группы;
					</para>

				</listitem>
				 <listitem>
					<para>
						список участников (данной группы): перечень имен пользователей, которые являются членами указанной группы, разделенные запятыми.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
			</para>
			 <sidebar id="sidebar.working-with-several-groups"> <title><emphasis>К ОСНОВАМ</emphasis> Работа с несколькими группами</title>
			 <indexterm>
				<primary><command>newgrp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sg</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>id</command></primary>
			</indexterm>
			 <indexterm>
				<primary>group</primary>
				<secondary>change</secondary>
			</indexterm>
			 <para>
				Каждый пользователь может быть включён сразу в несколько групп, Одной их них является “главная группа”. Она появляется в момент создания нового пользователя в системе и в дальнейшем считается для него "группой по умолчанию" (главной группой). Каждому файлу, создаваемому пользователю, тут же присваивается та группа, которая является главной для него. Однако не всегда это желательно, например, когда пользователь вынужден работать в каталоге, который является разделяемым с пользователями других групп, отличной от его главной группы. В этом случае, пользователь вынужден временно изменить свою главную группу используя одну из следующих команд: <command>newgrp</command>, когда запускается новый командный интерпретатор, или <command>sg</command>, которая просто выполняется с использованием предоставленной ей альтернативной группы. Эти команды также позволят пользователю присоединиться к группе, к которой они не принадлежат. Если группа защищена паролем, необходимо будет ввести пароль до того, как команда будет выполнена.
			</para>
			 <para>
				Другой вариант - пользователь может установить бит <literal>setgid</literal> на каталог, который при вызове файла, созданного в том каталоге автоматически присвоит ему корректную группу. Для больших деталей, смотри вкладку <xref linkend="sidebar.setgid-dir" />.
			</para>
			 <para>
				Команда <command>id</command> отобразит настоящее состояние пользователя, с персональным идентификатором (<varname>uid</varname> variable), действующей главной группой (<varname>gid</varname> variable), и перечень групп, в которые он включен (<varname>groups</varname> variable).
			</para>
			 </sidebar> <indexterm>
				<primary><filename>group</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/group</filename></primary>
			</indexterm>
			 <para>
				The <command>addgroup</command> and <command>delgroup</command> commands add or delete a group, respectively. The <command>groupmod</command> command modifies a group's information (its <literal>gid</literal> or identifier). The command <command>gpasswd <replaceable>group</replaceable></command> changes the password for the group, while the <command>gpasswd -r <replaceable>group</replaceable></command> command deletes it.
			</para>
			 <indexterm>
				<primary><command>addgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>delgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>groupmod</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>gpasswd</command></primary>
			</indexterm>
			 <indexterm>
				<primary>group</primary>
				<secondary>creation</secondary>
			</indexterm>
			 <indexterm>
				<primary>creation</primary>
				<secondary>of groups</secondary>
			</indexterm>
			 <indexterm>
				<primary>group</primary>
				<secondary>deletion</secondary>
			</indexterm>
			 <indexterm>
				<primary>deletion of a group</primary>
			</indexterm>
			 <sidebar> <title><emphasis>СОВЕТ</emphasis> Команда <command>getent</command></title>
			 <indexterm>
				<primary><command>getent</command></primary>
			</indexterm>
			 <para>
				Команда <command>getent</command> (получить записи) проверяет системные базы данных стандартным способом, используя соответствующие библиотечные функции, которые в свою очередь вызывают модули, сконфигурированне в файле <filename>/etc/nsswitch.conf</filename>. Команда принимает один или два аргумента: имя базы данных для проверки, и ключ, по которому будет выполнен поиск. Таким образом, команда <command>getent passwd rhertzog</command> предоставит информацию из базы данных, касающуюся пользователя <literal>rhertzog</literal>.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.creating-accounts">
		<title>Создание Учетных Записей</title>
		 <indexterm>
			<primary>account</primary>
			<secondary>creation</secondary>
		</indexterm>
		 <indexterm>
			<primary>creation</primary>
			<secondary>of user accounts</secondary>
		</indexterm>
		 <para>
			Одним из первых действий, которые необходимо сделать администратору при первоначальной установке системы на машину, является создание учетной записи пользователя. Обычно это делают с командой <command>adduser</command>, которая при создании в качестве аргумента использует имя нового пользователя.
		</para>
		 <indexterm>
			<primary><command>adduser</command></primary>
		</indexterm>
		 <para>
			Несмотря на то, что команда <command>adduser</command> задает несколько вопросов еще до создания учетной записи (login пользователя), тем не менее ее использование остается сказочно простым. Его конфигурационный файл <filename>/etc/adduser.conf</filename> включает все важные настройки: можно настроить автоматически установливать квоту для каждого нового пользователя, определив здесь же шаблон для этого, или изменить месторасположение учётных записей пользователей; последнее обычно редко используется, но иногда эта возможность выручит вас в трудных ситуациях, если вы имеете большое количество пользователей и хотите разделить их учётные записи на несколько дисков. А также вы можете задать здесь различные командные интерпретаторы, которые будут использоваться по умолчанию для всех пользователей.
		</para>
		 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Квота (выделение объёмов для чего-либо)</title>
		 <indexterm>
			<primary>квота</primary>
		</indexterm>
		 <para>
			Термин “квота” относится к ограничению каких-либо машинных ресурсов, выделенных в распоряжение пользователю. Это понятие часто применяют в отношении распределения емкости дискового пространства.
		</para>
		 </sidebar> <para>
			При создании пользователя, для него создается домашний каталог с заданными (разработчиками) параметрами, которые предусмотрены в шаблонах файлов, расположенных в <filename>/etc/skel/</filename>. То есть для пользователя создаётся как бы заготовка (скелет) стандартного домашнего каталога и файлов настроек, которыми он будет пользоваться.
		</para>
		 <indexterm>
			<primary>group</primary>
			<secondary>add a user</secondary>
		</indexterm>
		 <indexterm>
			<primary>add a user to a group</primary>
		</indexterm>
		 <para>
			В некоторых случаях, может быть полезным добавить пользователя в другие группы также (отличные от его “главной” группы, которая создана для него "по умолчанию"). Это иногда необходимо для того, чтобы добавить пользователю ещё какие-то узкоспециализированные права доступа. Например, пользователь, включённый в группу <emphasis>audio</emphasis> может получить доступ к аудио-устройствам (или дать пользователю разрешение на работу с видео - video) (смотри вкладку <xref linkend="sidebar.special-files" />). Чтобы получить такой результат надо выполнить команду <command>adduser <replaceable>user</replaceable> <replaceable>group</replaceable></command> (команду "adduser пользователь audio" выполнить через администратора).
		</para>
		 <sidebar id="sidebar.special-files"> <title><emphasis>К ОСНОВАМ</emphasis> Права доступа к устройству</title>
		 <indexterm>
			<primary>device</primary>
			<secondary>access permissions</secondary>
		</indexterm>
		 <indexterm>
			<primary>file</primary>
			<secondary>special</secondary>
		</indexterm>
		 <indexterm>
			<primary>mode</primary>
			<secondary>character</secondary>
		</indexterm>
		 <indexterm>
			<primary>mode</primary>
			<secondary>block</secondary>
		</indexterm>
		 <indexterm>
			<primary>block, mode</primary>
		</indexterm>
		 <indexterm>
			<primary>character, mode</primary>
		</indexterm>
		 <indexterm>
			<primary>special, file</primary>
		</indexterm>
		 <indexterm>
			<primary><command>mknod</command></primary>
		</indexterm>
		 <para>
			Каждое устройство перифирии представлено в Unix-системах как специальный файл, обычно расположенный в каталоге <filename>/dev/</filename> (DEV - сокращённое от "device"). Существует два типа специальных файлов, соответствующие реальным устройствам в системе: "символьный тип" (“character mode”) и "блочный тип" (“block mode”), с каждым типом файлов можно делать только определённое количество операций. Тогда как символьный тип файла ограничивается интерактивными операциями чтения/записи (обычно выполняется последовательной ввод-вывод символов), блочный тип позволяет также искать, записывать, перемещать данные внутри определённой области устройства (осуществляемое блоками). Наконец, каждому специальному файлу присвоено двузначное число (первая цифра слева - "главный" - “major” и вторая цифра - "меньший из двух, второстепенный" - “minor”), с помощью которых ядро может идентифицировать устройства своим, единственным в своем роде, образом. Файлы каких типов создаются с помощью команды <command>mknod</command>, а их название имеет простое символическое название (и более понятное для восприятия людьми, например "/dev/video0" - это устройство видео).
		</para>
		 <para>
			Карту прав доступа к файлам специального типа можно увидеть в упомянутом каталоге. Она показывает, какими правами пользователь должен обладать для доступа к самому устройству (к примеру - "crw-rw----+ 1 root video 81, 0 окт 25 05:22 video0", то есть данный файл символьного типа "с" пользователь администратор может читать "r" и записывать в него "w", а члены группы video могут выполнять тоже "rw", другие пользователи не могут этого делать "---" -8-ая, 9-ая, 10-ая позиции). Таким образом можно увидеть, что для файла <filename>/dev/mixer</filename>, представляющее аудио микшер в системе (диспетчер управления настройками звуковой карты), имеют права доступа на чтение и запись только администратор и члены группы <literal>audio</literal>. И только эти пользователи могут производить операции (настройка и др.) с аудио микшером (буква "w").
		</para>
		 <para>
			Полезно напомнить, что комбинируя <emphasis role="pkg">udev</emphasis>, <emphasis role="pkg">consolekit</emphasis> и <emphasis role="pkg">policykit</emphasis> можно добавлять дополнительные права доступа. Они разрешат пользователю физически подсоединиться к консоле (и не только через сетевые устройства) и получить доступ к определённым устройствам (например получить доступ к COM - порту при разработке драйвера для какого-то устройства).
		</para>
		 </sidebar>
	</section>
	 <section id="sect.shell-environment">
		<title>Среда окружения (пользователя)</title>
		 <para>
			Командные интерпретаторы (или оболочки) могут быть первыми точками соприкосновения пользователя с компьютером, и поэтому они должны быть довольно дружелюбны с ним. Большинство из них используют сценарии инициализации, которые позволят настроить их поведение (автоматическое завершение, текст приглашения и т.д.).
		</para>
		 <indexterm>
			<primary>command line interface</primary>
		</indexterm>
		 <indexterm>
			<primary>command interpreter</primary>
		</indexterm>
		 <indexterm>
			<primary>оболочка</primary>
		</indexterm>
		 <indexterm>
			<primary><command>bash</command></primary>
		</indexterm>
		 <para>
			Стандартная оболочка <command>bash</command> использует скрипт инициализации <filename>/etc/bash.bashrc</filename> для "интерактивной" оболочки, и <filename>/etc/profile</filename> для оболочки “учетная запись” ("login") (В этих файлах можно делать настройку bash - для всех пользователей на данном компьютере - "интерактивной" оболочки и оболочки “учетная запись”).
		</para>
		 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Оболочки “учетная запись” и (не-) интерактивная оболочка</title>
		 <para>
			Проще говоря, оболочка учетной записи вызывается сразу, когда вы входите в консоль, любым способом - локально или удаленно через <command>ssh</command>, или когда вы запускаете в явной форме команду <command>bash --login</command>. Независимо от того есть ли это оболочка учетной записи или нет, оболочка может быть интерактивной (для примера - при выполнении в <command>xterm</command>-подобном терминале); или не-интерактивной (когда выполняется сценарий).
		</para>
		 </sidebar> <sidebar> <title><emphasis>ОТКРЫТИЕ</emphasis> Другие оболочки, другие сценарии</title>
		 <para>
			Each command interpreter has a specific syntax and its own configuration files. Thus, <command>zsh</command> uses <filename>/etc/zshrc</filename> and <filename>/etc/zshenv</filename>; <command>tcsh</command> uses <filename>/etc/csh.cshrc</filename>, <filename>/etc/csh.login</filename> and <filename>/etc/csh.logout</filename>. The man pages for these programs document which files they use.
		</para>
		 <indexterm>
			<primary><command>zsh</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>tcsh</command></primary>
		</indexterm>
		 </sidebar> <para>
			Для <command>bash</command>, полезнее активировать “автоматическое завершение” в файле <filename>/etc/bash.bashrc</filename> (простро раскомментируйте несколько строк).
		</para>
		 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Автоматическое завершение (автозавершение)</title>
		 <indexterm>
			<primary>automatic completion</primary>
		</indexterm>
		 <para>
			Многие командные интерпретаторы поддерживают функцию завершения, которая позволяет оболочке автоматически завершать частично введенное наименование программы или аргумента, когда пользователь нажимает клавишу <keycap>Tab</keycap>. Это дает возможность пользователям работать более эффективно и быть менее подверженным ошибкам.
		</para>
		 <para>
			This function is very powerful and flexible. It is possible to configure its behavior according to each command. Thus, the first argument following <command>apt</command> will be proposed according to the syntax of this command, even if it does not match any file (in this case, the possible choices are <literal>install</literal>, <literal>remove</literal>, <literal>upgrade</literal>, etc.).
		</para>
		 </sidebar> <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Тильда, короткий путь в ДОМАШНИЙ каталог (HOME)</title>
		 <indexterm>
			<primary>~</primary>
		</indexterm>
		 <indexterm>
			<primary>tilde</primary>
		</indexterm>
		 <para>
			Тильда часто используется для отображения каталога, который является переменной окружения данного пользователя, <varname>HOME</varname> (это точка монтирования домашнего каталога пользователя в системе, например <filename>/home/rhertzog/</filename>). Командные интерпретаторы, встречая тильду в командной строке или сценарии, автоматически делают замену, например: <filename>~/hello.txt</filename> заменят на <filename>/home/rhertzog/hello.txt</filename>.
		</para>
		 <para>
			Тильда позволяет также получить доступ в домашнюю директорию другого пользователя. Так например, эти две записи являются синонимами: <filename>~rmas/bonjour.txt</filename> и <filename>/home/rmas/bonjour.txt</filename>.
		</para>
		 </sidebar> <para>
			В дополнение к имеющимся общим сценариям, каждый пользователь может создать их собственный сценарий <filename>~/.bashrc</filename> и <filename>~/.bash_profile</filename> для настройки своих оболочек. Наиболее частые изменения касаются добавления псевдонимов (alias). После ввода псевдонима оболочка автоматически заменяет его на строку запуска команды, которую вы соотнесли с данным псевдонимом. Это значительно убыстряет запуск команд (включающих в себя длинную последовательность операторов). Для примера, вы можете создать псевдоним <literal>la</literal> для запуска строки команды следующего вида <command>ls -la | less</command>; и тогда, как только вы введёте в консоле <command>la</command> и нажмете ВВОД, то сразу сможете детально проверить содержимое каталога (вывод будет осуществляться постранично программой less).
		</para>
		 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Переменные окружения (изменяемые значения в окружающей среде - оболочке)</title>
		 <indexterm>
			<primary>environment</primary>
			<secondary>environment variable</secondary>
		</indexterm>
		 <indexterm>
			<primary>variable, environment</primary>
		</indexterm>
		 <para>
			Переменные среды позволяют сохранить глобальные настройки, чтобы предоставлять их по мере необходимости оболочке или различным другим программам. Они имеют контекстный характер (каждому процессу выделяется необходимый ему набор переменных окружения), и имеют права наследования. Эта последняя характеристика делает возможным объявлять переменные для входа в оболочку учетной записи, которые будут передаваться всем запускаемым, данным пользователем, программам.
		</para>
		 </sidebar> <para>
			Настройка переменных окружения, используемых по умолчанию, является важным элементом конфигурирования оболочки. Предпочитаемым местом хранения в резерве переменных, характерных для оболочки, является файл <filename>/etc/environment</filename>. Именно его используют различные программы как вероятный источник информации по переменным при их старте в оболочке (в консоле и без нее). Переменные, обычно включаемые в этот файл, являются: <varname>ORGANIZATION</varname> - содержит название компании или организации и <varname>HTTP_PROXY</varname> - включает наличие и месторасположение HTTP-прокси.
		</para>
		 <sidebar> <title><emphasis>СОВЕТ</emphasis> Все оболочки настраиваются одинаково</title>
		 <para>
			Пользователи часто хотят настроить свои учетные записи и интерактивные оболочки похожим способом. Чтобы сделать это, они выбирают для интерпретации (или “источник”) содержимое файлов <filename>~/.bashrc</filename> и <filename>~/.bash_profile</filename>. Это можно сделать так же с файлами для всех пользователей (вызывая через текстовый редактор файлы <filename>/etc/bash.bashrc</filename> и <filename>/etc/profile</filename> и сохраняя их к себе для редактирования как соответственно файлы ".bashrc" и ".bash_profile").
		</para>
		 </sidebar>
	</section>
	 <section id="sect.config-printing">
		<title>Настройка принтера</title>
		 <indexterm>
			<primary>configuration</primary>
			<secondary>printing</secondary>
		</indexterm>
		 <indexterm>
			<primary>printing</primary>
			<secondary>configuration</secondary>
		</indexterm>
		 <para>
			Настройка принтера для печати создавала ранее много проблем, что вызывало головную боль как у администраторов, так и у пользователей. Сейчас эти проблемы по большей части уже в прошлом благодаря программе <emphasis role="pkg">cups</emphasis>, которая является свободным сервером печати, использующим протокол IPP (Internet Printing Protocol - Протокол печати через сеть Интернет).
		</para>
		 <indexterm>
			<primary>IPP</primary>
		</indexterm>
		 <indexterm>
			<primary>Internet Printing Protocol</primary>
		</indexterm>
		 <indexterm>
			<primary><command>cups</command></primary>
		</indexterm>
		 <para>
			This program is divided over several Debian packages: <emphasis role="pkg">cups</emphasis> is the central print server; <emphasis role="pkg">cups-bsd</emphasis> is a compatibility layer allowing use of commands from the traditional BSD printing system (<command>lpd</command> daemon, <command>lpr</command> and <command>lpq</command> commands, etc.); <emphasis role="pkg">cups-client</emphasis> contains a group of programs to interact with the server (block or unblock a printer, view or delete print jobs in progress, etc.); and finally, <emphasis role="pkg">printer-driver-gutenprint</emphasis> contains a collection of additional printer drivers for <command>cups</command>.
		</para>
		 <indexterm>
			<primary><command>lpr</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpq</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>СООБЩЕСТВО</emphasis> CUPS</title>
		 <indexterm>
			<primary>CUPS</primary>
		</indexterm>
		 <indexterm>
			<primary>Common Unix Printing System</primary>
		</indexterm>
		 <para>
			Общая система печати в UNIX (английское сокращение CUPS™) является проектом (и торговой маркой), управляемым компанией Apple, Inc. <ulink type="block" url="http://www.cups.org/" />
		</para>
		 </sidebar> <para>
			После установки вышеуказанных пакетов, управлять программой <command>cups</command> легко через браузер (веб-интерфейс), введя в адресной строке: <literal>http://localhost:631/</literal> (адрес принт-сервера в вашей локальной сети). Здесь вы можете добавить принтеры (включая сетевые принтеры), удалить их, и управлять ими. Вы можете также использовать <command>cups</command> через графический интерфейс, предоставленный вам окружением рабочего стола (программы, установленные в комплекте с вашим дистибутивом). Наконец, имеется ещё графический интерфейс <command>system-config-printer</command> (из Debian пакета с похожим именем).
		</para>
		 <indexterm>
			<primary><command>cups</command></primary>
			<secondary>administration</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>ЗАМЕТКА</emphasis> Устаревàние файла <filename>/etc/printcap</filename></title>
		 <para>
			<emphasis>cups</emphasis> no longer uses the <filename>/etc/printcap</filename> file, which is now obsolete. Programs that rely upon this file to get a list of available printers will, thus, fail. To avoid this problem, delete this file and make it a symbolic link (see sidebar <xref linkend="sidebar.symbolic-link" />) to <filename>/run/cups/printcap</filename>, which is maintained by <emphasis>cups</emphasis> to ensure compatibility.
		</para>
		 <indexterm>
			<primary><filename>printcap</filename></primary>
		</indexterm>
		 </sidebar>
	</section>
	 <section id="sect.config-bootloader">
		<title>Настройка Загрузчика</title>
		 <indexterm>
			<primary>загрузчик</primary>
			<secondary>начальный загрузчик</secondary>
		</indexterm>
		 <indexterm>
			<primary>загрузчик</primary>
		</indexterm>
		 <para>
			На вашей системе загрузчик скорее всего нормально настроен и полностью работоспособен, но не лишним будет знать и как настроить или установить (переустановить) загрузчик в случае, если он исчезнет из Главной Загрузочной Записи (Master Boot Record). Такое может случиться например после установки другой операционной системы, такой как Windows. Следующая информация поможет вам изменить настройку загрузчика если понадобится (или восстановить).
		</para>
		 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Главная загрузочная запись</title>
		 <indexterm>
			<primary>MBR</primary>
		</indexterm>
		 <indexterm>
			<primary>Master Boot Record</primary>
		</indexterm>
		 <para>
			Главная Загрузочная Запись (The Master Boot Record - MBR) занимает блок размером 512 байт, размещённый вначале первого жёсткого диска (на который устанавливается загрузчик), и это первая программа, которой передаётся управление от BIOS для последующей загрузки нужной операционной системы. В общем, при установке загрузчика в Главную Загрузочную Запись, происходит удаление (перезапись) предыдущего содержания.
		</para>
		 </sidebar> <section id="sect.identify-disks">
			<title>Идентификация Дисков</title>
			 <sidebar> <title><emphasis>КУЛЬТУРА</emphasis> <emphasis>udev</emphasis> и <filename>/dev/</filename></title>
			 <para>
				Каталог <filename>/dev/</filename> является домашним для так называемых “специальных” файлов. В нём представлены все имеющиеся в системе периферийные устройства (смотри вкладку <xref linkend="sidebar.special-files" />). Ранее использовался следующий порядок: в этот каталог были включены все специальные файлы, которые могли быть потенциально использованы. Этот подход имел ряд недостатков. Одним из них было ограничение количества устройств, которые могли быть использованы (из-за жёстко прописанного списка имен). Кроме того было не известно, какие специальные файлы фактически пригодились для работы, а какие - нет.
			</para>
			 <para>
				В настоящее время управление специальными файлами полностью осуществляется ядром, которое быстро создает или удаляет файлы в данном каталоге по мере подключения или отключения компьютерных устройств. Это происходит динамично и более сответствует сложившемуся на сегодня положению дел, когда практически всё подключается в "горячем режиме". Для этих целей ядро взаимодействует с <emphasis>udev</emphasis> при появлении или исчезновении устройств когда необходимо. По этой причине нет необходимости держать каталог <filename>/dev/</filename> постоянно полностью заполненным специальными файлами (используемыми и нет). Этот каталог создаётся в файловой системе (так называемая "псевдофайловая" система), которая размещается в памяти компьютера (RAM). При начале загрузки системы он пустой и далее, после наполнения, содержит всегда только актуальные специальные файлы, относящиеся к конкретным устройствам, имеющимся в системе в данный момент.
			</para>
			 <para>
				Ядро сообщает много информации о любом, вновь добавленном, устройстве и выдает пару - старший/младший номер для его идентификации. Совместно с <command>udevd</command> создаёт специальный файл с подходящим именем и правами доступа, которые необходимы. Может также создать псевдонимы и выполнить дополнительные действия (такие как инициализация или регистрация задач). Поведение <command>udevd</command> определяется большим набором (настраиваемых) правил.
			</para>
			 <para>
				Таким образом, с динамически определяемыми именами вы можете сохранить одинаковое имя для данного устройства, не думая о том, какой физический разъём и последовательность подключения были использованы, а это особенно полезно если вы используете различные USB перифирийные устройства. Первый раздел на первом жёстком диске может тогда быть назван <filename>/dev/sda1</filename> для обратной совместимости, или <filename>/dev/root-partition</filename> - если вы так предпочитаете, или даже оба этих названия в одно и то же время. Для этого надо лишь настроить <command>udevd</command>, чтобы автоматически создавалась символическая ссылка.
			</para>
			 <para>
				В давние времена, некоторые модули ядра автоматически подзагружались при вашей попытке получить доступ к соответствующему файлу устройства. Сейчас это уже не так, и периферийные специальные файлы не существуют до тех пор, пока не загружен модуль. Это не создает больших проблем, так как, благодаря автоматическому определению аппаратных средств, большинство модулей загружаются в ядро во время загрузки системы. Но для периферийных устройств, не обнаруживаемых на старте системы, (таких как очень старый диск или PS/2 мышь), это не работает. В этом случае предлагается рассмотреть вариант с добавлением модулей: <literal>floppy</literal>, <literal>psmouse</literal> и <literal>mousedev</literal> в файл <filename>/etc/modules</filename> для принудительной загрузки их во время загрузки системы.
			</para>
			 </sidebar> <indexterm>
				<primary>hard drive, names</primary>
			</indexterm>
			 <indexterm>
				<primary>names</primary>
				<secondary>of hard drives</secondary>
			</indexterm>
			 <para>
				При настройке загрузчик должен выполнить идентификацию различных жёстких дисков и их разделов. Linux использует “блочные” специальные файлы, располагаемые для этих целей в каталоге <filename>/dev/</filename>. Начиная с версии Debian <emphasis role="distribution">Squeeze</emphasis>, схема присвоения имён специальным файлам, обозначающих жёсткие диски, стала единообразной в ядре Linux, и все жесткие диски (IDE/PATA, SATA, SCSI, USB, IEEE 1394) сейчас представлены как файлы следующего вида <filename>/dev/sd*</filename>.
			</para>
			 <para>
				Каждый раздел представлен в следующем виде: "sdxX", где "x" - номер диска, а "X" - номер раздела: для примера, <filename>/dev/sda1</filename> - это первый раздел (X=1) на первом диске (x=a), и <filename>/dev/sdb3</filename> - это третий раздел (X=3) на следующем (втором) диске (x=b). Таким образом всегда можно определить, какой раздел какому диску соответствует.
			</para>
			 <indexterm>
				<primary>partition</primary>
				<secondary>primary</secondary>
			</indexterm>
			 <indexterm>
				<primary>partition</primary>
				<secondary>extended</secondary>
			</indexterm>
			 <indexterm>
				<primary>partition</primary>
				<secondary>secondary</secondary>
			</indexterm>
			 <indexterm>
				<primary>partition table</primary>
				<secondary>MS-DOS format</secondary>
			</indexterm>
			 <para>
				Архитектура ПК (или “i386”, включая его младшего двоюродного брата “amd64”) уже давно подошла к ограничению своих возможностей при использовании формата таблицы разделов типа “MS-DOS”. В соответствии с этой таблицей было позволено разместить на одном жёстком диске только четыре “основных” раздела. Для обхода этого ограничения, один из них можно было создать как “расширенный” раздел, который мог содержать внутри себя дополнительные “вторичные” разделы. Они начинали нумероваться с 5-го раздела. Таким образом вторичный раздел мог быть <filename>/dev/sda5</filename>, следующий - <filename>/dev/sda6</filename>, и т.д.
			</para>
			 <para>
				Другой недостаток формата таблицы разделов типа “MS-DOS” касается ограничения на размер жёсткого диска - он не должен превышать 2 Терабайта. Это создает реальную проблему в настоящее время в связи с появлением в продаже жёстких дисков большого размера.
			</para>
			 <indexterm>
				<primary>GPT</primary>
				<secondary>partition table format</secondary>
			</indexterm>
			 <indexterm>
				<primary>partition table</primary>
				<secondary>GPT format</secondary>
			</indexterm>
			 <para>
				Новый формат таблицы разделов, называемый GPT, ослабляет вышеуказанные ограничения на количество разделов на одном диске (он позволяет создать до 128 разделов при использовании стандартных настроек) и увеличивает разрешённый максимальный размер жесткого диска (до 8 зебибайтов или 512 x 2(в 64-ой степени) байтов - по IEEE1541, а это более чем 8 биллионов терабайт). Если вы планируете создать много физических разделов на одном диске, то вначале должны убедиться, что создали таблицу разделов в GPT-формате в момент первоначальной разбивки на разделы диска (то есть это будет ваше первое действие при разделении диска на разделы - сначала создается таблица GPT, а потом разбивается на разделы). Справочно: GPT - это GUID Partition Table - все разделы диска снабжены Глобальными Уникальными Идентификаторами и каждый раздел диска имеет уникальный (даже в рамках мира) идентификатор. GPT разработан компанией Intel.
			</para>
			 <para>
				Не всегда можно быстро вспомнить, какой диск подсоединён к какому SATA контроллеру, или он находится в третьей позиции в цепочке SCSI. Особенно это касается жёстких дисков (которые включают в себя, среди прочих, большинство SATA дисков и внешние диски), подключаемых "горячим способом", поскольку присваиваемые им имена могут изменяться от одной загрузки к другой. К счастью, <command>udev</command> создаёт, в дополнение к <filename>/dev/sd*</filename>, ещё и символические ссылки с фиксированными именами, которые вы можете использовать если захотите идентифицировать жесткий диск в явной, недвусмысленной, манере. Эти символические ссылки располагаются в <filename>/dev/disk/by-id</filename>. На машине с двумя жесткими дисками, например, они могут быть найдены следующим образом:
			</para>
			 
<screen><computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l
</userinput><computeroutput>total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[....]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </computeroutput></screen>
			 <para>
				Обратите внимание, что некоторые диски перечислены несколько раз с разными именами (потому что они ведут себя одновременно как ATA-диски и SCSI-диски). Это не затруднит пользователю опознание жёстких дисков. Зная номер модели и серийный номер жесткого диска можно легко по ссылкам определить, каким образом ядро поименовало второстепенные специальные файлы (периферийные).
			</para>
			 <para>
				Примеры файлов конфигурации, приведённые в следующих разделах базируются на следующих исходных данных: одиночный SATA-диск, где на первом разделе установлена старая Windows а второй раздел содержит Debian GNU/Linux.
			</para>

		</section>
		 <section id="sect.config-lilo">
			<title>Настройка LILO</title>
			 <indexterm>
				<primary>LILO</primary>
			</indexterm>
			 <indexterm>
				<primary>Linux Loader</primary>
			</indexterm>
			 <para>
				Старейшим загрузчиком системы является <emphasis>LILO</emphasis> (LInux LOader) — надёжный, но простой. Он записывает физический адрес рабочего ядра (его местоположение на жёстком диске) в MBR для загрузки, и это объясняет почему, каждый раз после каждого обновления LILO (или изменения его файла настройки), должна быть выполнена следующая команда <command>lilo</command>. За свою забывчивость можно расплатиться невозможностью загрузить систему (с того раздела, где были выполнены изменения, но не уведомили LILO об этом). Например, если старое ядро было удалено или перезаписано как новое с тем же именем (например было скомпилировано новое изменённое ядро с тем же именем), а обновление LILO не было выполнено, то при загрузке будет выдана ошибка, что LILO не может найти ядра (в том месте жёсткого диска, где она его ожидала увидеть).
			</para>
			 <para>
				Файл для настройки LILO называется <filename>/etc/lilo.conf</filename>, Ниже приведен пример простого файла для стандартной конфигурации.
			</para>
			 <example id="example.lilo.conf">
				<title>Файл настройки LILO</title>
				 
<programlisting>
# The disk on which LILO should be installed.
# By indicating the disk and not a partition.
# you order LILO to be installed on the MBR.
boot=/dev/sda
# the partition that contains Debian
root=/dev/sda2
# the item to be loaded by default
default=Linux

# the most recent kernel image
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

#  Old kernel (if the newly installed kernel doesn't boot)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# only for Linux/Windows dual boot
other=/dev/sda1
  label=Windows</programlisting>

			</example>

		</section>
		 <section id="sect.config-grub">
			<title>Настройка GRUB 2</title>
			 <indexterm>
				<primary>GRUB</primary>
			</indexterm>
			 <indexterm>
				<primary>GRUB 2</primary>
			</indexterm>
			 <para>
				Более поздней версией загрузчика (по времени создания программы) является <emphasis>GRUB</emphasis> (GRand Unified Bootloader). Теперь нет необходимости вызывать загрузчик после каждого обновления ядра; <emphasis>GRUB</emphasis> знает - как читать файловую систему и найти (место)положение ядра на диске самому. Устанавливается программа в MBR на первом диске, для этого надо просто выполнить <command>grub-install /dev/sda</command>. <indexterm><primary><command>grub-install</command></primary></indexterm>
			</para>
			 <sidebar> <title><emphasis>ЗАМЕТКА</emphasis> Обозначение дисков в GRUB</title>
			 <para>
				Идентификацию жёстких дисков GRUB выполняет только на основе считываемых данных из BIOS. Первый жёсткий диск, определяемый им в системе, по нумерации программы, соответствует <literal>(hd0)</literal>, <literal>(hd1)</literal> - это второй, и т.д. В большинстве случаев, этот порядок в точности соответствует обычному порядку нумерации дисков под Linux, но проблемы могут возникнуть в случае, например, если вы захотите связать SCSI и IDE диски. GRUB сохраняет соответствия, что он обнаружил, в файле <filename>/boot/grub/device.map</filename>. Если вы найдёте в этом файле ошибки (потому что вы знаете, что ваш BIOS определил диски в другом порядке), надо просто отредактировать вручную этот файл и запустить снова <command>grub-install</command>. Команда <command>grub-mkdevicemap</command> может помочь создать файл <filename>device.map</filename>, с которого начинает работу GRUB. Информация: Grub входит в пакет grub-legacy (старая версия), grub2 - в пакет grub-pc, grub-install - в пакет grub2-common, grub-mkdevicemap - в пакет grub-common.
			</para>
			 <para>
				Разделы могут иметь особенные имена в GRUB. Когда вы используете “классические” разделы в формате MS-DOS, первый раздел на первом диске имеет метку <literal>(hd0,msdos1)</literal>, второй <literal>(hd0,msdos2)</literal>, и т.д.
			</para>
			 </sidebar> <para>
				GRUB 2 configuration is stored in <filename>/boot/grub/grub.cfg</filename>, but this file (in Debian) is generated from others. Be careful not to modify it by hand, since such local modifications will be lost the next time <command>update-grub</command> is run (which may occur upon update of various packages). The most common modifications of the <filename>/boot/grub/grub.cfg</filename> file (to add command line parameters to the kernel or change the duration that the menu is displayed, for example) are made through the variables in <filename>/etc/default/grub</filename>. To add entries to the menu, you can either create a <filename>/boot/grub/custom.cfg</filename> file or modify the <filename>/etc/grub.d/40_custom</filename> file. For more complex configurations, you can modify other files in <filename>/etc/grub.d</filename>, or add to them; these scripts should return configuration snippets, possibly by making use of external programs. These scripts are the ones that will update the list of kernels to boot: <filename>10_linux</filename> takes into consideration the installed Linux kernels; <filename>20_linux_xen</filename> takes into account Xen virtual systems, and <filename>30_os-prober</filename> lists other operating systems (Windows, OS X, Hurd).
			</para>

		</section>
		 <section id="sect.config-yaboot">
			<title>Для компьютеров Macintosh (PowerPC): Настройка Yaboot</title>
			 <indexterm>
				<primary><command>yaboot</command></primary>
			</indexterm>
			 <para>
				На старых компьютерах Macintosh, использующих процессоры PowerPC, используется загрузчик Yaboot. Они не загружаются подобно ПК, а полагаются на “загрузочный” раздел (bootstrap), с которого BIOS (или OpenFirmware) выполняет загрузку. На этот раздел программа <command>ybin</command> устанавливает загрузчик <command>yaboot</command> и размещает там его файлы настройки (и дублирует их). Если файл <filename>/etc/yaboot.conf</filename> будет изменён, то вам нужно будет только запустить эту команду снова (а благодаря дубликату, <command>yaboot</command> всегда знает, как найти месторасположение ядра на диске).
			</para>
			 <para>
				До выполнения команды <command>ybin</command>, вы должны вначале убедиться, что имеете правильно составленный файл <filename>/etc/yaboot.conf</filename>. В следующем примере приводится минимальная конфигурация данного файла. <indexterm><primary><command>ybin</command></primary></indexterm>
			</para>
			 <example id="example.yaboot.conf">
				<title>Файл настройки Yaboot</title>
				 
<programlisting>
# bootstrap partition
boot=/dev/sda2
# the disk
device=hd:
# the Linux partition
partition=3
root=/dev/sda3
# boot after 3 seconds of inactivity
# (timeout is in tenths of seconds)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# last kernel installed
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

#  old kernel
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# only for Linux/Mac OSX dual-boot
macosx=/dev/sda5

# bsd=/dev/sdaX and macos=/dev/sdaX
# are also possible</programlisting>

			</example>

		</section>

	</section>
	 <section id="sect.config-misc">
		<title>Другие настройки: Синхронизация времени, Журналы, Разделение Доступа…</title>
		 <para>
			Многие элементы, перечисленные в данной главе, полезно знать тем, кто хочет освоить все стороны настройки систем GNU/Linux. Однако, они описаны кратко, а за подробной информацией рекомендуется обратиться к документации.
		</para>
		 <section id="sect.timezone">
			<title>Timezone (Часовой пояс)</title>
			 <indexterm>
				<primary>timezone</primary>
			</indexterm>
			 <sidebar id="sidebar.symbolic-link"> <title><emphasis>К ОСНОВАМ</emphasis> Символические ссылки</title>
			 <indexterm>
				<primary>link</primary>
				<secondary>symbolic</secondary>
			</indexterm>
			 <indexterm>
				<primary>symbolic link</primary>
			</indexterm>
			 <indexterm>
				<primary><command>ln</command></primary>
			</indexterm>
			 <para>
				Символическая ссылка является указателем на другой файл. Когда вы обращаетесь к ссылке, то открывается тот файл, на который она указывает. При удалении ссылки, сам файл, на который она указывает, не удаляется. Более того, ссылка не имеет своих прав доступа, а получает права доступа (в момент своего создания) как бы "в наследство" от файла, на который она ссылается. Кроме того, ссылка может указывать на любой файл: на каталоги, на специальные файлы (сокеты, именованные каналы, файлы устройств, и т.д.), даже на другие символические ссылки.
			</para>
			 <para>
				Команда <command>ln -s <replaceable>target</replaceable> <replaceable>link-name</replaceable></command> создаст символическую ссылку (параметр "s" - "мягкую"), называемую <replaceable>link-name</replaceable>, и указывающую на существующий файл (каталог и т.д., target - цель) <replaceable>target</replaceable>.
			</para>
			 <para>
				Если файл, на который указывает ссылка, не существует, то ссылка считается “бúтой”. При попытке получить доступ к ней будет получен результат с ошибками, сообщающими, что файл, на который она ссылается, не существует. Если ссылка указывает на другую ссылку, вы будете иметь "цепочку" ссылок, которая превратится в "цикл" (cycle), если в этой цепочке ссылок хотя бы одна из них показывает на один из предыдущих файлов (ссылок, по цепочке). То есть вся цепочка закольцована. В этом случае, при попытке получить доступ к одному звену (ссылке, файлу) этой цепочки будет выдана особая ошибка (“слишком много уровней символических ссылок”). Значит ядро отказалось делать далее бессмысленную (с его точки зрения) работу (после нескольких неудачных попыток разобраться с круговыми цепочками).
			</para>
			 </sidebar> <para>
				Часовой пояс определяется в процессе установки дистибутива на машину, входит в пакет <emphasis role="pkg">tzdata</emphasis>. При возникновении необходимости изменить часовой пояс запустите команду <command>dpkg-reconfigure tzdata</command>. Ответив на несколько вопросов в интерактивном режиме, программа установит новый часовой пояс на вашей машине, который будет использоваться в дальнейшем. Эти настройки сохраняются в файле <filename>/etc/timezone</filename>. Кроме этого будет скопирован соответствующий файл из каталога <filename>/usr/share/zoneinfo</filename> в <filename>/etc/localtime</filename>. Он содержит правила, каким образом переводится время на летний (зимний) период в той или иной стране, для стран, использующих такой порядок (в Debian 9.2 создана мягкая ссылка).
			</para>
			 <indexterm>
				<primary><filename>timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>zoneinfo</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/usr/share/zoneinfo/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>DST</primary>
			</indexterm>
			 <indexterm>
				<primary>daylight saving time</primary>
			</indexterm>
			 <para>
				Если вам понадобится временно изменить часовой пояс, используйте переменную окружения <varname>TZ</varname>, которая будет иметь приоритет над настройками окружения, которые обычно используются "по умолчанию":
			</para>
			 <indexterm>
				<primary><varname>TZ</varname></primary>
			</indexterm>
			 
<screen id="screen.tz">
<computeroutput>$ </computeroutput><userinput>date</userinput>
<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>
<computeroutput>$ </computeroutput><userinput>TZ="Pacific/Honolulu" date</userinput>
<computeroutput>Thu Feb 19 00:25:21  HST 2015</computeroutput></screen>
			 <sidebar> <title><emphasis>ЗАМЕТКА</emphasis> Системные часы, аппаратные часы</title>
			 <para>
				На компьютере часы представлены в двух вариантах. Часы установленные на материнской плате (в BIOS) являются аппаратными и называются “CMOS часы”. Эти часы не очень точные, и обеспечивает довольно медленное время доступа к ним. Ядро операционной системы имеет свои, внутренние, часы, реализованные как маленькая программа. Эти программные часы самостоятельно рассчитывает время и сохраняют его между перезагрузками системы (возможно с помощью серверов времени, смотри <xref linkend="sect.time-synchronization" />). Эти системные часы обычно более точные, особенно потому, что им не надо получать доступ к аппаратным переменным. Однако, поскольку программные системные часы существуют только в "живой" памяти (то есть в "работающей" системе), они обнуляются каждый раз как только машина загружается (перегружается). Часы CMOS, напротив, имеют аккумулятор и поэтому они “выживают” при перезагрузке или остановке машины. Поэтому во время загрузки компьютера системные часы установлены по данным из CMOS (то есть аппаратно), в момент работы системы - работают программные системные часы в ядре, а в момент выключения компьютера часы в CMOS обновляются по данным из системных программных часов (для того, чтобы учесть возможные изменения или исправления, если аппаратные часы неправильно отрегулированы).
			</para>
			 <para>
				На практике часто встречается проблема: поскольку CMOS часы не более чем простой счётчик времени, то они не содержат информацию о часовом поясе. Следовательно установленное в CMOS время система может толковать двояко: установлены часы в режиме мирового времени (UTC, бывшее GMT), или в режиме местного времени. Казалось бы, что можно просто изменить время в CMOS, когда понадобится и всё. Однако в действительности это немного сложнее: в частности смещение времени из-за переключения на летнее время не является постоянной величиной. В результате нет универсального способа дать понять системе как ей, ежегодно два раза в год, переключать часы на летнее время и обратно. Описываемая проблема касается случаев, когда в CMOS установлено местное время. Поэтому, поскольку всегда есть возможность воссоздать местное время путём суммирования информации из двух источников: всемирного времени и информации о часовом поясе на локальном компьютере, настоятельно рекомендуем устанавливать в CMOS часах мировое время (если на компьютере не установлены отличные от Linux операционные системы).
			</para>
			 <para>
				К сожаленью, операционные системы Windows игнорируют эту рекомендацию в настройках по умолчанию. Они контролируют, чтобы часы CMOS всегда были установлены в местное время. При этом, каждый раз во время загрузки (перегрузки), они просматривают часы CMOS, определяя были ли внесены изменения в настройку часов, и если были - то сами, не спрашивая пользователя, опять устанавливают (в CMOS) местное время. Это работает довольно хорошо для случаев, когда только одна из упомянутых операционных систем запущена на компьютере (или несколько из одного семейства Windows, например Windows XP на разделе sda1, Windows Vista на разделе sda2 и тд, то есть "двойная и более" загрузка этих систем). Но в случаях, когда компьютер имеет несколько установленных систем от разных производителей (в режиме "мультизагрузки") происходит хаос ("образно говоря") на компьютере при попытке самих систем определить - установлено ли время корректно (это варианты с “двойной-и-более загрузкой” или запуск другой системы через виртуальную машину). Если вам (по какой-то причине) невозможно обойтись без установленной Windows на компьютере, то немного подкорректируйте её настройки следующим образом. В частности, чтобы установленные в UTC часы CMOS не переустанавливались снова и снова этими операционными системами, в настройках реестра введите параметр "1" и "DWORD" в ключ <literal>HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</literal>. Другой вариант решения данной проблемы (для Debian систем) - это выполнить в консоле такую команду <command>hwclock --localtime --set</command> (и добавить --date "ввести время и дату"), чтобы установить аппаратные часы в нужное вам время и пометить, чтобы система отслеживала местное время (не забудьте вручную иногда контролировать летнее и зимнее время).
			</para>
			 </sidebar>
		</section>
		 <section id="sect.time-synchronization">
			<title>Синхронизация Времени</title>
			 <indexterm>
				<primary>time synchronization</primary>
			</indexterm>
			 <indexterm>
				<primary>clock</primary>
				<secondary>synchronization</secondary>
			</indexterm>
			 <para>
				Синхронизация времени может показаться излишней для отдельно взятого компьютера, однако её выполнение крайне важно для локальных сетей. Чтобы не происходила путаница, простым пользователям запрещено изменять время и дату. В локальной сети, где регулярно выполняется синхронизация времени всех компьютеров в системе, делать перекрёстный анализ информации из журналов событий, полученных с разных машин в сети, гораздо удобнее. К тому же, в случае нападения на сеть извне, можно будет быстро реконструировать хронологическую цепочку событий, предшествующую этому: определить какие машины и в какое время подвергались атаке и, как следствие этого, они могли быть скомпрометированы. Собираемые с разных машин в сети данные для статистических целей, не имеют большого смысла, если все эти машины не синхронизированы между собой по времени.
			</para>
			 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> NTP</title>
			 <indexterm>
				<primary>NTP</primary>
			</indexterm>
			 <indexterm>
				<primary>Network</primary>
				<secondary>Time Protocol</secondary>
			</indexterm>
			 <para>
				NTP (Сетевой Протокол Времени) позволяет машине синхронизироваться с другими (машинами) довольно точно, учитывая задержки, вызванные передачей информации по сети (интернет) или другие возможные отклонения.
			</para>
			 <para>
				Хотя существует множество серверов NTP в Интернете, наиболее популярные из них могут быть перегружены. Именно по этой причине мы рекомендуем использовать NTP сервер <emphasis>pool.ntp.org</emphasis>. Под данным адресам работает на самом деле группа машин, которые согласились предоставлять услуги (неограниченному кругу пользователей) в качестве публичных серверов NTP. Вы можете конкретизировать и выбрать для данных целей именно свою страну. Например <emphasis>us.pool.ntp.org</emphasis> можно использовать для США, или <emphasis>ca.pool.ntp.org</emphasis> для Канада и т.д.
			</para>
			 <para>
				Однако, если вы управляете большой сетью, рекомендуется установить ваш собственный NTP сервер (в пакете с похожим именем), который будет синхронизироваться с публичными серверами (дата и время). В этом случае, все другие машины вашей сети могут использовать ваш внутренний NTP сервер вместо того, чтобы увеличивать нагрузку на публичные сервера. Из за того, что все ваши машины будут синхронизированы по дате и времени с одним внутренним источником, разбалансировка по времени на всех машинах в локальной сети будет минимальна. Уменьшается время прохождения информации по сети (каждый пакет проходит более короткий путь).
			</para>
			 </sidebar> <section id="sect.ntp-on-workstations">
				<title>Для Рабочих Станций</title>
				 <para>
					Поскольку рабочие станции регулярно перезагружаются (или выключаются иногда даже, только для сохранения электричества), то синхронизации их по NTP в момент загрузки бывает обычно достаточно. Для этого надо просто установить пакет <emphasis role="pkg">ntpdate</emphasis>. Можно также изменить NTP сервер, который будет использоваться, отредактировав файл <filename>/etc/default/ntpdate</filename>.
				</para>
				 <indexterm>
					<primary><filename>ntpdate</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/default/ntpdate</filename></primary>
				</indexterm>

			</section>
			 <section id="sect.ntp-on-servers">
				<title>Для Серверов</title>
				 <para>
					Сервера крайне редко перезагружаются, поэтому очень важно, чтобы их системное время всегда было корректно установлено. Чтобы постоянно поддерживать правильное время, установите локальный NTP сервер. Данная возможность включена в пакет <emphasis role="pkg">ntp</emphasis>. В настройках по умолчанию сервер, с одной стороны, будет синхронизироваться с внешним публичным сервером <emphasis>pool.ntp.org</emphasis> и, с другой стороны, будет предоставлять данные о дате и времени в ответ на запросы, поступающие из локальной сети. Вы можете редактировать файл <filename>/etc/ntp.conf</filename>, изменив в нем NTP сервер, который будет использоваться для синхронизации (наиболее часто изменяемая опция). Если в сети много серверов, то вас может заинтересовать вариант с локальным сервером времени, синхронизирующимся с публичным сервером. Он же будет использоваться в качестве источника для других серверов сети.
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">ntp</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary>server</primary>
					<secondary>NTP</secondary>
				</indexterm>
				 <indexterm>
					<primary>NTP</primary>
					<secondary>server</secondary>
				</indexterm>
				 <sidebar> <title><emphasis>УГЛУБЛЯЕМСЯ</emphasis> GPS модули и другие источники времени</title>
				 <indexterm>
					<primary>GPS</primary>
				</indexterm>
				 <indexterm>
					<primary>DCF-77</primary>
				</indexterm>
				 <para>
					Если синхронизация времени имеет особо важное значение для вашей сети, то можно оборудовать сервер GPS модулем (который будет использовать время со спутников GPS) или DCF-77 модулем (который будет синхронизировать время с атомными часами недалеко от Франкфурта, Германия). В этом случае, настройка NTP сервера немного сложнее, и предварительное изучение документации (руководства и т.д.) по ntp является абсолютной необходимостью.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.rotation-logs">
			<title>Смена Журналов Событий</title>
			 <indexterm>
				<primary>file</primary>
				<secondary>logs, rotation</secondary>
			</indexterm>
			 <indexterm>
				<primary>logs</primary>
				<secondary>files, rotation</secondary>
			</indexterm>
			 <indexterm>
				<primary>rotation of log files</primary>
			</indexterm>
			 <indexterm>
				<primary><command>logrotate</command></primary>
			</indexterm>
			 <para>
				Так как со временем журналы событий могут увеличиваться, иногда очень быстро, возникает необходимость архивирования их время от времени. Наиболее распространённой схемой является чередование архивов: журнал событий регулярно архивируется, и только последний <replaceable>X</replaceable> архив сохраняется. Программа <command>logrotate</command> является инициатором этих чередований, она руководствуется правилами, прописанными в: файле <filename>/etc/logrotate.conf</filename> и во всех файлах, расположенных в каталоге <filename>/etc/logrotate.d/</filename>. Администратор может модифицировать эти файлы, если желает приспособить политику чередования событий, определённую в Debian, к своим нуждам. Страница руководства <citerefentry><refentrytitle>logrotate</refentrytitle>
				 <manvolnum>1</manvolnum></citerefentry> описывает все параметры, доступные в тех конфигурационных файлах. Возможно вы захотите: увеличить количество файлов, сохраняемых при чередовании журналов событий, или переместить журналы событий в особенный каталог, предназначенный для их архивирования (предпочтитая не удалять старые журналы). Вы можете также послать их по e-mail для архивирования где-нибудь в другом месте.
			</para>
			 <para>
				Программа <command>logrotate</command> выполняется ежедневно, её запуск выполняет планировщик задач <command>cron</command> (смотри раздел <xref linkend="sect.task-scheduling-cron-atd" />).
			</para>

		</section>
		 <section id="sect.sharing-admin-rights">
			<title>Разделение Прав Администратора (делегирование части полномочий другому пользователю или старшему администратору)</title>
			 <indexterm>
				<primary>учётная запись</primary>
				<secondary>администратора</secondary>
			</indexterm>
			 <indexterm>
				<primary>root</primary>
			</indexterm>
			 <indexterm>
				<primary><command>sudo</command></primary>
			</indexterm>
			 <para>
				Часто несколько администраторов работают в одной и той же сети. Первый самый простой способ для обеспечения возможности им совместно работать - вариант, при котором все администраторы имеют право работать в этой сети под одним и тем же паролем администратора. Такое решение не является наилучшим, та как открывает лазейки для выполнения кем-то из них недопустимых действий, а из-за анонимности - избежать ответственности в дальнейшем. Решением данной проблемы является программа <command>sudo</command>, которая позволяет определённым пользователям выполнять оговоренные команды со специальными правами. В наиболее распространённом случае её использования (применяемом часто из-за простоты а не из-за того, что это наилучшее решение), <command>sudo</command> позволяет доверить пользователю выполнение любой команды от лица администратора. Для этого пользователь просто выполняет <command>sudo <replaceable>command</replaceable></command> и для проверки подлинности использует свой персональный пароль (при этом, что очень важно, все действия такого пользователя записываются в специальный журнал событий и в дальнейшем можно легко отследить кто и что сделал).
			</para>
			 <para>
				После установки пакета <emphasis role="pkg">sudo</emphasis>, во вновь созданную Unix группу <literal>sudo</literal> будут добавлены новые участники - пользователи, которым разрешается работать с полными правами администратора. Для перераспределения других прав (делегирование полномочий) администратор должен использовать команду <command>visudo</command>, которая позволит ему модифицировать файлы настройки <filename>/etc/sudoers</filename> (в данном примере "visudo" - это запуск текстового редактора <command>vi</command> с правами "sudo" для редактирования упомянутого файла. Вы можете использовать свой редактор, тот, что установлен у вас как переменная окружения <varname>EDITOR</varname>). Добавление строки <literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal> позволит пользователю, о котором идёт речь, выполнить любую команду как администратор.
			</para>
			 <indexterm>
				<primary><command>visudo</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>sudoers</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/sudoers</filename></primary>
			</indexterm>
			 <para>
				Более тонкие настройки дают возможность наделить определёнными полномочиями оговоренных пользователей, то есть уполномочить их на выполнение тех или иных действий, не давая им при этом полных прав администратора, даже под "sudo". Детальную информацию вы можете получить на страницах руководства <citerefentry><refentrytitle>sudoers</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry>.
			</para>

		</section>
		 <section id="sect.fstab-mount-points">
			<title>Список Точек Монтирования</title>
			 <indexterm>
				<primary>point, mount</primary>
			</indexterm>
			 <indexterm>
				<primary>точка монтирования</primary>
			</indexterm>
			 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Монтирование и размонтирование (устройств)</title>
			 <para>
				В Unix-подобной системе, такой как Debian, файлы организованы в единую древовидную структуру каталогов. Каталог <filename>/</filename> называется “корневым каталогом”; все дополнительные каталоги (имеющиеся в системе, кроме корневого) являются подкаталогами внутри этого "корневого" каталога. “Монтирование” - это действие, подключающее содержимое периферийного устройства (часто жёсткого диска) к системному общему каталогу файлов в качестве подкаталога. Следовательно, если вы используете отдельный жёсткий диск для размещения персональных данных пользователей, этот диск должен быть “смонтирован” в каталоге <filename>/home/</filename>. Корневая файловая система всегда монтируется ядром на старте системы; другие устройства часто монтируются позднее, в процессе выполнения последовательности сценариев загрузки системы (например подключается файл подкачки) или вручную с командой <command>mount</command>.
			</para>
			 <indexterm>
				<primary><command>mount</command></primary>
			</indexterm>
			 <para>
				Некоторые съёмные устроства автоматически монтируются сразу после физического подсоединения, особенно при использовании графических оболочек GNOME, KDE или других окружений рабочего стола. Другие монтируются пользователями вручную. Но и в том и в другом случае они должны быть размонтированы до того, как будут физически отсоединены от компьютера (в этом случае из каталога файлов, после размонтирования, исчезнут эти отмонтированные подкаталоги). Рядовые пользователи обычно не имеют прав на выполнение команд <command>mount</command> и <command>umount</command>. Однако, администратор может разрешить им выполнение данных действий (конкретно для каждой точки монтирования) включив параметр <literal>user</literal> в файл <filename>/etc/fstab</filename>.
			</para>
			 <para>
				Команда <command>mount</command> может быть использована без аргументов (тогда она просмотрит и отобразит все смонтированные в настоящее время файловые системы). Добавление в строку с командой параметров необходимо для монтирования или размонтирования устройств (которые не перечислены в файле "/etc/fstab"). Для детальной информации, пожалуйста, обратитесь к страницам руководства, <citerefentry><refentrytitle>mount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> и <citerefentry><refentrytitle>umount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry>. Для рядовых случаев, синтаксис достаточно прост: для примера, монтировать раздел <filename>/dev/sdc1</filename>, с файловой системой ext3, в точку монтирования каталог <filename>/mnt/tmp/</filename> вы можете просто - выполнив команду <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command>. (Чтобы определить, как ядро опознало ваш USB-диск например, сделайте до этого "dmesg". Вы увидите "/dev/sdc1" или другое имя вашего устройства, которое и надо будет смонтировать).
			</para>
			 </sidebar> <para>
				В файле <filename>/etc/fstab</filename> перечислены все возможные варианты монтирования (разрешённые администратором на данной системе): которые выполняются автоматически при загрузке системы и позволенные опции для монтирования в дальнейшем вручную для съёмных запоминающих устройств (например CDROM). Каждой точке монтирования выделена одна строка. Она содержит несколько полей, используя в качестве разделителей пробелы: <indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						file system: this indicates where the filesystem to be mounted can be found, it can be a local device (hard drive partition, CD-ROM) or a remote filesystem (such as NFS).
					</para>
					 <para>
						Это поле часто заменяется записью с указанием уникального ID файловой системы (который вы можете определить выполнив команду <command>blkid <userinput>device</userinput></command>), введя в качестве префикса <literal>UUID=</literal> (то есть вы указываете что нужно смонтировать не в привычном нам виде, как например "/dev/sdc1", а в виде "mount UUID=8e9cb4e1-5aa0-4340-b43e-a489741299fa1 /mnt/point"). Такой подход предотвращает возникновение путаницы с присвоением имён подсоединяемым устройствам (поскольку ядро нумерует все присоединяемые физически к компьютеру устройства по мере их подключения. К примеру ранее опознанное устройство как sdc1 через два-три дня может быть опознано как sdf1, смотрите "dmesg"). Чтобы этого избежать и рекомендуется при монтировании указывать ID устройства в явной, то есть конкретной форме (UUID=8e9cb4e1-5aa0-4340-b43e-a489741299fa1) Таким образом это ID устройство будет одно и то же и через день и через месяц.
					</para>

				</listitem>
				 <listitem>
					<para>
						точка монтирования: это точка (местоположение в вашей системе каталогов), в которую будет присоединено (примонтировано) устройство, удалённая система, раздел диска и т.д.
					</para>

				</listitem>
				 <listitem>
					<para>
						тип: это поле описывает, какая файловая система используется на монтируемом устройстве. К примеру: <literal>ext4</literal>, <literal>ext3</literal>, <literal>vfat</literal>, <literal>ntfs</literal>, <literal>btrfs</literal>, <literal>xfs</literal> и другие.
					</para>
					 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> NFS, сетевая файловая система</title>
					 <para>
						NFS является сетевой файловой системой; под Linux-ом она позволяет прозрачно получить доступ к удалённым файлам, включая их в локальную файловую систему.
					</para>
					 </sidebar> <para>
						С полным перечнем, известных программе "mount (unmount)" файловых систем, можно ознакомиться в руководстве <citerefentry><refentrytitle>mount</refentrytitle>
						 <manvolnum>8</manvolnum></citerefentry>. Специальный тип файловой системы <literal>swap</literal> предназначен для раздела подкачки (виртуальная память); специальный параметр <literal>auto</literal> сообщит программе <command>mount</command>, что ей нужно попытаться самой автоматически определить тип файловой системы (данная опция особенно полезна при использовании различных приспособлений, в которые всталяются диски и USB-устройства, так как каждое из них может иметь свою собственную файловую систему);
					</para>

				</listitem>
				 <listitem>
					<para>
						параметры: их имеется много, все они разные и зависят от особенностей той или иной файловой системы, для более детальной информации читаете руководства в <command>mount</command>. Наиболее известные из них
					</para>
					 <itemizedlist>
						<listitem>
							<para>
								<literal>rw</literal> или <literal>ro</literal> - эти параметры сообщают программе с какими правами доступа надо смотрировать устройство: в режиме "чтения-записи" ("rw" - read/write) или в режиме "только для чтения" ("ro" - read only).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>noauto</literal> - отключает автоматическое монтирование устройства в процессе выполнения загрузки системы (в нижерасположенном примере можно заменить scd0 на sr0 для CDROM/DVD, если dmesg таким образом опознаёт его).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>nofail</literal> - позволит выполнять далее загрузку, несмотря на то, что какое-то внешнее устройство не представлено в настоящий момент в системе. Убедитесь, что включили этот параметр именно для того дополнительного устройства, которое, так может случиться, будет отсоединено физически от компьютера в момент загрузки системы. Команда <command>systemd</command> действительно гарантирует то, что всё, что должно было быть смонтировано в системе, будет сделано своевременно, присвоив им до этого наименования, и далее процесс загрузки нормально дойдёт до конца. Обратите внимание, что вы можете скомбинировать этот параметр с <literal>x-systemd.device-timeout=5s</literal>, чтобы сказать <command>systemd</command> не ожидать более чем 5 сек появления внешнего устройства в системе (смотрите руководство <citerefentry><refentrytitle>systemd.mount</refentrytitle>
								<manvolnum>5</manvolnum></citerefentry>).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>user</literal> - разрешает всем пользователям монтировать эту файловую систему (а например записанное в этом поле "root" - напротив позволяет делать это только администратору).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>defaults</literal> - значит применить группу параметров по умолчанию, включающих в себя: <literal>rw</literal>, <literal>suid</literal>, <literal>dev</literal>, <literal>exec</literal>, <literal>auto</literal>, <literal>nouser</literal> и <literal>async</literal>. Каждый из них может быть отлючён индивидуально добавлением после <literal>defaults</literal> следующих записей - <literal>nosuid</literal>, <literal>nodev</literal>, которые исключат тот или иной параметр из группы по умолчанию (в данном примере исключаются <literal>suid</literal>, <literal>dev</literal>). При добавлении после "defaults" слова <literal>user</literal> будет выполнено противоположное по смыслу действие - то есть отключение "группы параметров по умолчанию", поскольку <literal>defaults</literal> сам в своём перечне уже включает <literal>nouser</literal>.
							</para>

						</listitem>

					</itemizedlist>

				</listitem>
				 <listitem>
					<para>
						dump: this field is almost always set to <literal>0</literal>. When it is <literal>1</literal>, it tells the <command>dump</command> tool that the partition contains data that is to be backed up.
					</para>

				</listitem>
				 <listitem>
					<para>
						pass: this last field indicates whether the integrity of the filesystem should be checked on boot, and in which order this check should be executed. If it is <literal>0</literal>, no check is conducted. The root filesystem should have the value <literal>1</literal>, while other permanent filesystems get the value <literal>2</literal>.
					</para>

				</listitem>

			</itemizedlist>
			 <example id="example.fstab">
				<title>Пример файла <filename>/etc/fstab</filename></title>
				 
<programlisting>
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
#  swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0</programlisting>

			</example>
			 <para>
				В нижерасположенном примере последней записью подключается каталог сетевой файловой системы (NFS): каталог <filename>/shared/</filename>, размещённый физически на сервере <emphasis>arrakis</emphasis> будет присоединён в точку монтирования <filename>/shared/</filename> на локальной машине. Формат файла <filename>/etc/fstab</filename> задокументирован в руководстве <citerefentry><refentrytitle>fstab</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>.
			</para>
			 <sidebar> <title><emphasis>УГЛУБЛЯЕМСЯ</emphasis> Автомонтирование</title>
			 <para>
				systemd is able to manage automount points: those are filesystems that are mounted on-demand when a user attempts to access their target mount points. It can also unmount these filesystems when no process is accessing them any longer.
			</para>
			 <para>
				Like most concepts in systemd, automount points are managed with dedicated units (using the <literal>.automount</literal> suffix). See <citerefentry><refentrytitle>systemd.automount</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> for their precise syntax.
			</para>
			 <indexterm>
				<primary><emphasis>am-utils</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><command>amd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>automount</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>autofs</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>automounter</primary>
			</indexterm>
			 <para>
				Other auto-mounting utilities exist, such as <command>automount</command> in the <emphasis role="pkg">autofs</emphasis> package or <command>amd</command> in the <emphasis role="pkg">am-utils</emphasis>.
			</para>
			 <para>
				Заметим также, что GNOME, KDE, и другие графические окружения рабочего стол работают совместно с <emphasis>udisks</emphasis>, и могут автоматически монтировать съёмные устройства после их подключения (физически) к машине.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.locate-updatedb">
			<title><command>locate</command> и <command>updatedb</command></title>
			 <indexterm>
				<primary><command>locate</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>updatedb</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>mlocate</command></primary>
			</indexterm>
			 <para>
				Команда <command>locate</command> может найти месторасположение файла даже если вы знаете только часть его имени. Она выдаёт результат почти мгновенно, сначала лишь проконсультировавшись с базой данных, которая сохраняет месторасположение всех файлов, имеющихся в системе. Эта база данных обновляется ежедневно командой <command>updatedb</command>. Существует несколько разновидностей (вариантов) команды <command>locate</command>. Для включения в стандартную систему Debian выбрана её разновидность, называемая <emphasis role="pkg">mlocate</emphasis> (входит в пакет с похожим именем).
			</para>
			 <para>
				Команда <command>mlocate</command> достаточно умна - при выдаче результата она учитывает права доступа и выдаёт лишь те файлы, что доступны запустившему её пользователю. несмотря на то, что она знает про все файлы, имеющиеся в системе (поскольку реализация этой программы <command>updatedb</command> запускается с правами администратора). Для дополнительной безопасности администратор может использовать <varname>PRUNEDPATHS</varname> в файле <filename>/etc/updatedb.conf</filename> для исключения из индексирования некоторых каталогов.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-compilation">
		<title>Компиляция Ядра</title>
		 <indexterm>
			<primary>компиляция</primary>
			<secondary>ядра</secondary>
		</indexterm>
		 <indexterm>
			<primary>kernel</primary>
			<secondary>compilation</secondary>
		</indexterm>
		 <para>
			Включаемые в дистибутивы Debian ядра содержат в себе максимально количество функциональных возможностей, а также максимум драйверов. В результате этого становится возможным с помощью ядра настроить как можно больше аппаратных устройств уже на стадии установки, загрузки и дальнейшей эксплуатации системы (которые могут быть установлены на компьютерах пользователей. Большинство их такая ситуация устраивает - максимально опознаются аппаратные средства, а расточительное использование ресурсов компьютера для них не критично). Но некоторые предпочитают перекомпилировать (пересобрать) ядро, включив в них только то, что им действительно нужно. Для такого подхода имеются две причины. Первая - возможность оптимизации использования физической памяти (RAM) поскольку код ядра постоянно находится в ней (и никогда не “выгружается”, даже часть его, на файл подкачки). Избыточное использование ядром физической памяти (а она недёшева, и её часто не хватает на компьютерах пользователей) может уменьшить общую производительность системы. Вторая причина - локально скомпилированные ядра помогут снизить риск проблем безопасности. За счёт исключения ненужного (только незначительное количество кода ядра будет включено в состав ядра, скомпилировано и в дальнейшем выполняться) в конечном итоге повысится защищённость и производительность системы.
		</para>
		 <sidebar> <title><emphasis>ЗАМЕТКА</emphasis> Обновления Системы Безопасности</title>
		 <para>
			Если вы решитесь скомпилировать собственную версию ядра, вы должны понимать (и принимать) последствия, к которым это вас приведёт: Debian не сможет гарантировать обновления системы безопасности для вашего самосборного ядра. И напротив, сохраняя (и используя) ядро, поддерживаемое Debian, вы получите пользу от таких обновлений, подготовливаемых регулярно командой безопасности Проекта Debian.
		</para>
		 </sidebar> <para>
			Перекомпиляция ядра необходима также, если вы хотите использовать некоторые особенности, которые доступны только как заплатки (и не включены в стандартную версию ядра).
		</para>
		 <sidebar> <title><emphasis>УГЛУБЛЯЕМСЯ</emphasis> Настольная Книга по Ядру Debian</title>
		 <indexterm>
			<primary><emphasis role="pkg">debian-kernel-handbook</emphasis></primary>
		</indexterm>
		 <para>
			Настольную книгу по ядру Debian ведёт команда сопровождающих ядра Debian (в оригинале название на английском “Debian Kernel Handbook”. Она включена в пакет <emphasis role="pkg">debian-kernel-handbook</emphasis>). В её составе имеется подробнейшая информация о том, как ядро в большинстве случаев устанавливает взаимосвязи задач и как ядра из официальных пакетов Debian работают. Если вам нужно больше информации, чем имеющаяся в данном разделе, то первое место, куда вам стоит заглянуть - посетить сайт <ulink type="block" url="http://kernel-handbook.alioth.debian.org" />
		</para>
		 </sidebar> <section id="sect.kernel-compilation-prerequisites">
			<title>Введение и предпосылки</title>
			 <para>
				Неудивительно, что в Debian управление ядром организовано в виде готового пакета, а не как ранее - традиционная компиляция и устанавка вручную. Поскольку ядро (в составе пакета) всегда остается под контролем системы управления пакетами, то удаление или установка ядра на одной, или на нескольких машинах сразу, выполняется чисто. Кроме того, в пакетах кроме ядра имеются ещё и сценарии, автоматизирующие процесс подключения устанавливаемого ядра в загрузчик и создающие образ initrd для загрузки.
			</para>
			 <para>
				Скачиваемый из хранилища Debian пакет с исходным кодом ядра Linux содержит в себе всё необходимое для построения Debian пакета, включающего в себя скомпилированное вами ядро. Но кроме этого, рекомендуется проверить установлены ли у вас пакеты вспомогательного назначения (которые необходимо доустановить, если они отсутствуют в вашей системе). К ним относятся: 1) пакет <emphasis role="pkg">build-essential</emphasis>. 2) Для этапа конфигурирования ядра нужен пакет <emphasis role="pkg">libncurses5-dev</emphasis>. 3) С помощью пакета <emphasis role="pkg">fakeroot</emphasis> создаются условия сборки Debian пакета не прибегая к правам администратора.
			</para>
			 <sidebar> <title><emphasis>КУЛЬТУРА</emphasis> Старые добрые времена пакета <emphasis role="pkg">kernel-package</emphasis></title>
			 <indexterm>
				<primary><emphasis role="pkg">kernel-package</emphasis></primary>
			</indexterm>
			 <para>
				Ранее рекомендованным способом сборки пакетов было использование программы <command>make-kpkg</command> из пакета <emphasis role="pkg">kernel-package</emphasis>. В настоящее время у системы построения пакетов Linux уже появилась возможность создания пакетов Debian надлежащего качества.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-sources">
			<title>Получение исходного кода</title>
			 <indexterm>
				<primary>Исходные коды Linux ядра</primary>
			</indexterm>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>sources</secondary>
			</indexterm>
			 <indexterm>
				<primary>исходные коды</primary>
				<secondary>Linux ядра</secondary>
			</indexterm>
			 <para>
				Like anything that can be useful on a Debian system, the Linux kernel sources are available in a package. To retrieve them, just install the <emphasis role="pkg">linux-source-<replaceable>version</replaceable></emphasis> package. The <command>apt search ^linux-source</command> command lists the various kernel versions packaged by Debian. The latest version is available in the <emphasis role="distribution">Unstable</emphasis> distribution: you can retrieve them without much risk (especially if your APT is configured according to the instructions of <xref linkend="sect.apt-mix-distros" />). Note that the source code contained in these packages does not correspond precisely with that published by Linus Torvalds and the kernel developers; like all distributions, Debian applies a number of patches, which might (or might not) find their way into the upstream version of Linux. These modifications include backports of fixes/features/drivers from newer kernel versions, new features not yet (entirely) merged in the upstream Linux tree, and sometimes even Debian specific changes.
			</para>
			 <para>
				The remainder of this section focuses on the 4.9 version of the Linux kernel, but the examples can, of course, be adapted to the particular version of the kernel that you want.
			</para>
			 <para>
				We assume the <emphasis role="pkg">linux-source-4.9</emphasis> package has been installed. It contains <filename>/usr/src/linux-source-4.9.tar.xz</filename>, a compressed archive of the kernel sources. You must extract these files in a new directory (not directly under <filename>/usr/src/</filename>, since there is no need for special permissions to compile a Linux kernel): <filename>~/kernel/</filename> is appropriate.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>
<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-4.9.tar.xz</userinput></screen>
			 <sidebar> <title><emphasis>КУЛЬТУРА</emphasis> Месторасположение исходных кодов ядра</title>
			 <para>
				Традиционно, исходные коды ядра Linux размещаются в <filename>/usr/src/linux/</filename>, следовательно, при компилировании ядра нужно иметь права доступа администратора. Однако, надо стараться избегать работать с правами администратора, если в этом нет острой необходимости. Участникам существующей группы <literal>src</literal> позволяется работать в этом каталоге, тем не менее следует избегать работать в каталоге <filename>/usr/src/</filename>. Сохраняя коды ядра в персональный каталог, вы обеспечите безопасность по всем пунктам: нет файлов в каталоге <filename>/usr/</filename>, неизвестных системе управления пакетами, и нет риска ввести в заблуждение программы, что читают каталог <filename>/usr/src/linux</filename>, когда они пытаются получить информацию об используемом ядре.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.config-kernel">
			<title>Настройка ядра</title>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>configuration</secondary>
			</indexterm>
			 <indexterm>
				<primary>настройка</primary>
				<secondary>ядра</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>.config</filename></primary>
			</indexterm>
			 <para>
				Следующий шаг содержит настройку ядра в соответствии с вашими потребностями. Более точный алгоритм работы зависит от ваших целей.
			</para>
			 <para>
				При перекомпиляции более современной версии ядра (возможно с дополнительными заплатками), конфигурация ядра должна быть как можно ближе к тому, что предлагает Debian. В этом случае достаточно просто скопировать файл <filename>/boot/config-<replaceable>version</replaceable></filename> (узнать версию ядра, работающего сейчас на вашем компьютере, можно командой <command>uname -r</command> command) в новый файл с именем <filename>.config</filename>, разместив его в каталог, содержащий исходные коды ядра. Это будет намного быстрее чем пересобрать ядро с нуля.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cp /boot/config-4.9.0-3-amd64 ~/kernel/linux-source-4.9/.config</userinput></screen>
			 <para>
				Если вам не нужно изменять конфигурацию ядра, вы можете остановиться здесь и пропустить раздел <xref linkend="sect.kernel-build" />. В противном случае, если необходимо внести изменения в конфигурацию ядра или вы решили сами всё настроить с нуля, то необходимо выделить достаточно время на эту работу. В каталоге с исходными кодами ядра присутствуют и различные специальные интерфейсы, которые могут быть использованы посредством вызова команды <command>make <replaceable>target</replaceable></command>, где в качестве <replaceable>target</replaceable> выступает одно из значений, описанных ниже.
			</para>
			 <para>
				<command>make menuconfig</command> компилирует и выполняет в псевдографическом интерфейсе (для этого необходимо установить пакет <emphasis role="pkg">libncurses5-dev</emphasis>). В программе можно передвигаться и выбирать опции в иерархической структуре. Нажатием клавиши <keycap>Space</keycap> изменяется значение выбираемой опции, а нажатием <keycap>Enter</keycap> войти внутрь того названия, на котором расположен в тот момент указатель; кнопка интерфейса <guibutton>Select</guibutton> возвращает на выбранное подменю; <guibutton>Exit</guibutton> закрывает настоящий экран и сдвигает позицию курсора назад по иерархии; <guibutton>Help</guibutton> отобразит более детальную информацию о роли выбранной опции. Клавиши навигации позволяют передвигаться в списке опций и кнопок. Для выхода из программы выберете <guibutton>Exit</guibutton> из главного меню. В этот момент программа предложит сохранить сделанные изменения - если вы удовлетворены сделанными изменениями, то сохраните.
			</para>
			 <para>
				Другие интерфейсы имеют похожие функциональные возможности, но они работают в более современных графических оболочках; такие как <command>make xconfig</command>, которая использует графический интерфейс Qt, и <command>make gconfig</command>, использующий GTK+. Первый нуждается в пакете <emphasis role="pkg">libqt4-dev</emphasis>, в то время как второй зависит от наличия пакетов <emphasis role="pkg">libglade2-dev</emphasis> и <emphasis role="pkg">libgtk2.0-dev</emphasis>.
			</para>
			 <para>
				Хорошей идеей было бы использовать совместно с теми интерфейсами одну из конфигураций по умолчанию, имеющиеся в комплекте с исходным кодом ядра. Они спроектированы оптимальным образом и расположены в <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename>. Вы можете взять выбранную вами оттуда конфигурацию поместив её в новое место командой похожей на <command>make x86_64_defconfig</command> (в случае 64-битного ПК) или <command>make i386_defconfig</command> (в случае 32-разрядный ПК). Программа возьмёт .config из заготовленных разработчиками оптимальных конфигураций и сохраняет его в каталог, где будет компилироваться ядро, то есть по сути копирует этот файл.
			</para>
			 <sidebar> <title><emphasis>СОВЕТ</emphasis> Применение устаревших файлов <filename>.config</filename></title>
			 <para>
				Если вы хотите использовать старый файл <filename>.config</filename>, который был создан ранее в другой (обычно старой) версии ядра, вам необходимо будет его обновить. Для этого имеются три варианта. Первый - при запуске <command>make oldconfig</command> программа в интерактивной форме задаст вам вопросы, касающиеся вновь введённых в ядро опций или изменений, которые возможно имели место быть в новой версии ядра (длительный по времени процесс). Второй - запуск <command>make olddefconfig</command> уведомит программу о том, что вы, как бы, ответили на все задаваемые ею вопросы положительно. Третий - команда <command>make oldnoconfig</command> даст понять команде, что на все вопросы вы дали отрицательные ответы.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-build">
			<title>Компиляция и Сборка Пакета</title>
			 <indexterm>
				<primary><command>make deb-pkg</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>ЗАМЕТКА</emphasis> Очистка каталога до пересборки</title>
			 <para>
				Если вы уже компилировали в данном каталоге а теперь желаете пересобрать в нём с нуля другое новое ядро (к примеру потому, что вы существенно изменили конфигурацию ядра), то вам необходимо будет выполнить команду <command>make clean</command> для удаления скомпилированных файлов. Команда <command>make distclean</command> удалит даже больше сгенерированных ранее файлов, включая также и ваш файл <filename>.config</filename>. Так что не забудьте и сохраните вначале всё, что вам может понадобиться в дальнейшем, например файл .config, и только потом выполняйте эти команды.
			</para>
			 </sidebar> <para>
				Как только вы определились с конфигурацией вашего будущего ядра, выполнение команды <command>make deb-pkg</command> сгенерирует до 5 пакетов Debian: 1) <emphasis role="pkg">linux-image-<replaceable>version</replaceable></emphasis>, который содержит образ ядра и связанные с ними модули, 2) <emphasis role="pkg">linux-headers-<replaceable>version</replaceable></emphasis>, который содержит заголовочные файлы, необходимые для сборки внешних модулей, 3) <emphasis role="pkg">linux-firmware-image-<replaceable>version</replaceable></emphasis>, который содержит файлы прошивки аппаратной части, нужные некоторым драйверам (эти пакеты могут отсутствовать, если вы строите из исходных кодов ядра, поддерживаемого Debian), 4) <emphasis role="pkg">linux-image-<replaceable>version</replaceable>-dbg</emphasis>, который содержит символы отладки для образа ядра и его модулей, и 5) <emphasis role="pkg">linux-libc-dev</emphasis>, который содержит заголовки, актуальные для некоторых библиотек, поддерживающих пространство пользователя подобно GNU glibc.
			</para>
			 <para>
				Слово-приставка, добавляемая в конце к названию ядра, <replaceable>version</replaceable> образуется путём слияния нескольких значений, характеризующих место данной версии в цепочке нумерации ядра (следующие переменные <literal>VERSION</literal>, <literal>PATCHLEVEL</literal>, <literal>SUBLEVEL</literal> и <literal>EXTRAVERSION</literal> определены в файле <filename>Makefile</filename>), параметра настройки <literal>LOCALVERSION</literal>, и переменной окружения <literal>LOCALVERSION</literal>. Вновь создаваемые пакеты с ядром для своего наименования заимствуют часть строки от названия версии ядра с добавлением номера ревизии, который регулярно увеличивается (и сохраняется в файле <filename>.version</filename>). Из этого правила есть исключение: если вы сами определите имя новой версии ядра с помощью переменной окружения <literal>KDEB_PKGVERSION</literal>.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1
</userinput><computeroutput>[...]
$ </computeroutput><userinput>ls ../*.deb
</userinput><computeroutput>../linux-headers-4.9.30-ckt4-falcot_4.9.30-1_amd64.deb
../linux-image-4.9.30-ckt4-falcot_4.9.30-1_amd64.deb
../linux-image-4.9.30-ckt4-falcot-dbg_4.9.30-1_amd64.deb
../linux-libc-dev_4.9.30-1_amd64.deb
</computeroutput></screen>

		</section>
		 <section id="sect.modules-build">
			<title>Компиляция Внешних Модулей (динамически загружаемые модули ядра)</title>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>external modules</secondary>
			</indexterm>
			 <indexterm>
				<primary>modules</primary>
				<secondary>external kernel modules</secondary>
			</indexterm>
			 <indexterm>
				<primary><command>dkms</command></primary>
			</indexterm>
			 <para>
				Некоторые модули, не включённые в официальный проект ядра Linux, поддерживаются за его пределами. Чтобы была возможность их использовать, они должны быть скомпилированы рядом с соответствующим ядром. Определённое количество таких модулей поддерживается Debian путём включения их в специальные пакеты, такие как <emphasis role="pkg">xtables-addons-source</emphasis> (дополнительные модули для iptables) или <emphasis role="pkg">oss4-source</emphasis> (некоторые альтернативные звуковые драйверы).
			</para>
			 <para>
				Так как этих внешних модулей (и пакетов с ними) имеется великое множество и все они разные, то мы не будем перечислять их здесь все. Помощь вам может сослужить команда <command>apt-cache search source$</command>, которая проведёт поиск только по заголовкам пакетов (установленных и неустановленных в системе). Однако, знание полного перечня врешних модулей не принесёт вам большой пользы, поскольку в большинстве случаев компиляция внешних модулей не нужна, за редким исключением, когда вы сами знаете, что вам надо. В таких случаях, документация на аппаратное устройство, как правило, детально описывает, каким образом данный конкретный модуль функционирует под операционной системой Linux.
			</para>
			 <para>
				Для примера, давайте рассмотрим пакет <emphasis role="pkg">xtables-addons-source</emphasis>: после его установки появится архив исходного кода модуля <filename>.tar.bz2</filename>, располагающийся в каталоге <filename>/usr/src/</filename>. Далее можно было бы вручную извлечь данные из архива и построить модуль, но на практике предпочтительным способом является использование DKMS (инфраструктура для поддержки динамически загружаемых модулей ядра). Пакеты, название которых оканчивается на суффикс <literal>-dkms</literal>, предлагаются для большинства модулей, которым необходима интеграция с ядром через DKMS. В приведённом примере, установка пакета <emphasis role="pkg">xtables-addons-dkms</emphasis> добавит всё необходимое, что нужно для компиляции внешнего модуля для настоящего ядра. Обратите только внимание, чтобы был установлен и пакет <emphasis role="pkg">linux-headers-*</emphasis>, соответствующий версии ядра. Например, если вы используете <emphasis role="pkg">linux-image-amd64</emphasis>, то вам необходимо доустановить и пакет <emphasis role="pkg">linux-headers-amd64</emphasis>.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>
<computeroutput>
[...]
Setting up xtables-addons-dkms (2.12-0.1) ...
Loading new xtables-addons-2.12 DKMS files...
Building for 4.9.0-3-amd64
Building initial module for 4.9.0-3-amd64
Done.

xt_ACCOUNT:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/4.9.0-3-amd64/updates/dkms/
[...]
DKMS: install completed.
$ </computeroutput><userinput>sudo dkms status</userinput>
<computeroutput>xtables-addons, 2.12, 4.9.0-3-amd64, x86_64: installed
$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>
<computeroutput>filename:       /lib/modules/4.9.0-3-amd64/updates/dkms/xt_ACCOUNT.ko
license:        GPL
alias:          ipt_ACCOUNT
author:         Intra2net AG &lt;opensource@intra2net.com&gt;
description:    Xtables: per-IP accounting for large prefixes
[...]
</computeroutput></screen>
			 <sidebar> <title><emphasis>АЛЬТЕРНАТИВА</emphasis> модуль-помошник</title>
			 <indexterm>
				<primary><emphasis role="pkg">module-assistant</emphasis></primary>
			</indexterm>
			 <para>
				До появления DKMS, <emphasis role="pkg">module-assistant</emphasis> был простейшим решением построения и развёртывания модулей ядра. Такое решение и сегодня ещё используется, в частности для тех пакетов, которым не хватает возможностей, заложенных в механизм интеграции через DKMS с ядром: после выполнения простой команды, подобной этой, <command>module-assistant auto-install xtables-addons</command> (или <command>m-a a-i xtables-addons</command> для краткости), модули будут скомпилированы для настоящего ядра, помещены в новый пакет Debian, и этот новый пакет будет установлен в систему. Всё это будет проделано "на летỳ".
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-patch">
			<title>Установка Заплатки на Ядро</title>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>patch</secondary>
			</indexterm>
			 <indexterm>
				<primary>заплатка ядра</primary>
			</indexterm>
			 <para>
				Некоторые особенности не включены в стандартное ядро из-за недостатка завершённости кода или некоторых разногласий с сопровождающими ядро. Они могут быть включены в отдельные заплатки и распространяться в таком виде (разработчиками заплатки). В дальнейшем кто угодно может установить такую заплатку на исходные коды ядра.
			</para>
			 <para>
				Debian sometimes provides some of these patches in <emphasis role="pkg">linux-patch-*</emphasis> packages but they often don't make it into stable releases (sometimes for the very same reasons that they are not merged into the official upstream kernel). These packages install files in the <filename>/usr/src/kernel-patches/</filename> directory.
			</para>
			 <para>
				После установки в систему пакета с заплаткой, наложить её на исходные коды ядра можно следующей командой <command>patch</command>. В этот момент необходимо находиться курсором в каталоге с исходными кодами ядра (а сама заплатка должна находиться на один уровень выше). Пример: "xz -cd ../linux-patch-3.16-rt.patch.xz | patch -p1". Далее, перейдите к этапу конфигурирования нового ядра и его компилиляции, как было описано выше.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-4.9</userinput>
<computeroutput>$ </computeroutput><userinput>make clean</userinput>
<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.1-4.9.11-201702181444.patch.gz | patch -p1</userinput></screen>
			 <para>
				Обратите внимание, что устанавливаемая заплатка не обязательно будет совместима с каждой версией ядра. Может случиться, что команда <command>patch</command>, при попытке наложить заплатку на исходные коды ядра, потерпит неудачу. Возникшие ошибки будут показаны и даны некоторые подробности, касательно возникшего сбоя. В этом случае, руководствуйтесь документацией, доступной в Debian пакете данной заплатки (в каталоге <filename>/usr/share/doc/linux-patch-*/</filename>). В большинстве случаев, сопровождающие заплаток указывают, для каких версий ядра они предназначены.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-installation">
		<title>Установка ядра</title>
		 <indexterm>
			<primary>установка</primary>
			<secondary>ядра</secondary>
		</indexterm>
		 <indexterm>
			<primary>kernel</primary>
			<secondary>installation</secondary>
		</indexterm>
		 <section id="sect.kernel-package">
			<title>Особенности ядра Debian пакета</title>
			 <indexterm>
				<primary><filename>vmlinuz</filename></primary>
			</indexterm>
			 <para>
				Пакет Debian с ядром устанавливает ядро (<filename>vmlinuz-<replaceable>version</replaceable></filename>), файл конфигурации этого ядра (<filename>config-<replaceable>version</replaceable></filename>) и таблицу символов того же ядра(<filename>System.map-<replaceable>version</replaceable></filename>) в каталог <filename>/boot/</filename>. Таблица символов поможет разработчикам понять значения сообщений ядра об ошибках. Без этой таблицы ядро ошибается - “сбоѝт (пáдает)”. Это происходит потому, что ядро в момент сбоя имеет в наличии только перечень некоторого количества адресов памяти, который для него бесполезен (он неполноцѐнен) - нет сопоставления тех адресов с символами и функциональными именами (“oopses” - “сбоѝт”, происходит сбой ядра, “oops” это эквивалент ошибки сегментации ядра для программ из пользовательского окружения, другими словами - сообщения ядра уведомляют пользователя о том, что произошла ошибка в распределении адресов памяти для пользовательских программ - ошибки в указателях на те или иные адреса памяти). Модули этого ядра устанавливаются в каталог <filename>/lib/modules/<replaceable>version</replaceable>/</filename>.
			</para>
			 <para>
				Сценарий настройки пакета автоматически создает образ initrd, который представляет из себя по сути мини-систему, размещаемую в памяти компьютера для загрузчика (отсюда и возникло его название, от сокращения словосочетания “init ramdisk” - "init+r+d"). Этот образ используется ядром Linux единственно лишь для нахождения модулей (содержащимися в комплекте Debian систем), необходимых для обеспечения доступа к устройствам (например, драйвер для SATA дисков). В финале, послеустановочный сценарий обновляет символические ссылки <filename>/vmlinuz</filename>, <filename>/vmlinuz.old</filename>, <filename>/initrd.img</filename> и <filename>/initrd.img.old</filename> таким образом, чтобы они указывали на два последних установленных ядра, и соответствующие им образы initrd.
			</para>
			 <para>
				Большинство вышеупомянутых задач выполняется сценариями, размещёнными в каталоге <filename>/etc/kernel/*.d/</filename>. Для примера, за счёт интеграции с командой <command>grub</command>, сценарии <filename>/etc/kernel/postinst.d/zz-update-grub</filename> и <filename>/etc/kernel/postrm.d/zz-update-grub</filename> вызовут <command>update-grub</command> в случаях установки или удаления ядра.
			</para>

		</section>
		 <section id="sect.kernel-installation-with-dpkg">
			<title>Установка с <command>dpkg</command></title>
			 <para>
				Using <command>apt</command> is so convenient that it makes it easy to forget about the lower-level tools, but the easiest way of installing a compiled kernel is to use a command such as <command>dpkg -i <replaceable>package</replaceable>.deb</command>, where <literal><replaceable>package</replaceable>.deb</literal> is the name of a <emphasis role="pkg">linux-image</emphasis> package such as <filename>linux-image-4.9.30-ckt4-falcot_1_amd64.deb</filename>.
			</para>
			 <para>
				Описанные в этой главе шаги настройки являются базовыми и могут быть применены как на серверных системах, так и на рабочих станциях, а также могут быть массово продублированы в полуавтоматическом режиме. Однако, их недостаточно для того, чтобы всё прошло в автоматическом режиме. Некоторые моменты требуют особого внимания и ручной настройки, например запуск тех или иных низкоуровневых программ, известных как “сервисы Unix”.
			</para>

		</section>

	</section>
</chapter>

