<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="unix-services" lang="ru-RU">
	<chapterinfo>
		 <keywordset>
			<keyword>Загрузка системы</keyword>
			 <keyword>Сценарии инициализации</keyword>
			 <keyword>SSH</keyword>
			 <keyword>Telnet</keyword>
			 <keyword>Права</keyword>
			 <keyword>Привилегии</keyword>
			 <keyword>Инспектирование</keyword>
			 <keyword>Inetd</keyword>
			 <keyword>Cron</keyword>
			 <keyword>Резервное копирование</keyword>
			 <keyword>Горячее подключение</keyword>
			 <keyword>PCMCIA</keyword>
			 <keyword>APM</keyword>
			 <keyword>ACPI</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Сервисы Unix</title>
	 <highlights> <para>
		Эта глава посвящена нескольким основным сервисам, общим для многих Unix-систем. Все администраторы должны быть хорошо знакомы с ними.
	</para>
	 </highlights> <section id="sect.system-boot">
		<title>Загрузка системы</title>
		 <indexterm>
			<primary>загрузка</primary>
			<secondary>системы</secondary>
		</indexterm>
		 <para>
			При загрузке компьютера множество сообщений, пробегающих на консоли, отображает выполнение многочисленных автоматических начальных инициализаций и настроек. Иногда может возникнуть желание несколько изменить работу этого этапа, а значит, необходимо хорошо её понимать. Помочь в этом — назначение данного раздела.
		</para>
		 <para>
			Сначала BIOS получает контроль над компьютером, определяет диски, считывает <emphasis>главную загрузочную запись</emphasis> и запускает загрузчик. Загрузчик принимает управление, находит ядро на диске, считывает и запускает его. Затем ядро инициализируется и начинает поиск и монтирование корневой файловой системы и, наконец, запускает первую программу — <command>init</command>. Зачастую эти «корневой раздел» и <command>init</command> на самом деле находятся на виртуальной файловой системе, существующей только в ОЗУ (отсюда её название — initramfs, ранее — initrd, от <foreignphrase>initialization RAM disk</foreignphrase>). Эта файловая система загружается в память загрузчиком, часто из файла на жёстком диске или по сети. Он содержит самый минимум, необходимый для того, чтобы ядро загрузило «настоящую» корневую файловую систему: сюда могут входить модуля ядра для жёсткого диска или других устройств, без которых система не способна загрузиться, или, чаще, сценарии инициализации и модули для сборки массивов RAID, открытия зашифрованных разделов, активации томов LVM и т. п. Когда корневой раздел примонтирован, initramfs передаёт управление настоящему <command>init</command>, и система возвращается к стандартному процессу загрузки.
		</para>
		 <figure id="figure.boot-process-systemd">
			<title>Порядок загрузки компьютера с Linux и systemd</title>
			 <mediaobject>
				<imageobject>
					<imagedata fileref="images/startup-systemd.png" format="PNG" scalefit="1" width="80%" />
				</imageobject>

			</mediaobject>

		</figure>
		 <section id="sect.systemd">
			<title>Система инициализации systemd</title>
			 <para>
				«Настоящий init» сейчас предоставляется <emphasis role="pkg">systemd</emphasis>, и в данном разделе описывается эта система инициализации.
			</para>
			 <sidebar> <title><emphasis>КУЛЬТУРА</emphasis> До <command>systemd</command></title>
			 <para>
				<command>systemd</command> является относительно новой «системой инициализации», но несмотря на это, она уже была доступна в <emphasis role="distribution">Wheezy</emphasis>. По умолчанию, она стала применяться в Debian <emphasis role="distribution">Jessie</emphasis>. До этого, по умолчанию использовалась «System V init» (пакет <emphasis role="pkg">sysv-rc</emphasis>) — гораздо более традиционная система. System V init будет описана позднее.
			</para>
			 </sidebar> <sidebar> <title><emphasis>АЛЬТЕРНАТИВА</emphasis> Другие системы загрузки</title>
			 <para>
				Эта книга дает описание загрузки системы: использующейся по умолчанию в Debian <emphasis role="distribution">Jessie</emphasis> (пакет <emphasis role="pkg">systemd</emphasis>), предыдущей — <emphasis role="pkg">sysvinit</emphasis>, которая является продолжателем и наследником <emphasis>System V</emphasis> из Unix-систем, также есть и другие.
			</para>
			 <para>
				<emphasis role="pkg">file-rc</emphasis> — это очень просто устроенная система загрузки. Она сохраняет принцип уровней запуска, но заменяет каталоги и символьные ссылки конфигурационным файлом, указывающим <command>init</command>, какие процессы и в каком порядке должны быть запущены.
			</para>
			 <para>
				Система <command>upstart</command> пока не так хорошо тестировалась в Debian. Она основана на событиях: init-сценарии запускаются не поочерёдно, а отвечают на события, например на завершение другого сценария, от которого данный зависит. Эта система появилась в Ubuntu и может быть выбрана в Debian <emphasis role="distribution">Jessie</emphasis> как замена системы по умолчанию. Таковой она и разрабатывалась на место <emphasis role="pkg">sysvinit</emphasis> и одной из задач <command>upstart</command> был запуск сценариев, написанных для традиционных систем, особенно для <emphasis role="pkg">sysv-rc</emphasis>.
			</para>
			 <para>
				Есть и другие системы и другие режимы работы: <command>runit</command>, <command>minit</command>. Они не распространены и достаточно специализированы.
			</para>
			 </sidebar> <sidebar> <title><emphasis>ОСОБЫЙ СЛУЧАЙ</emphasis> Загрузка по сети</title>
			 <para>
				В некоторых конфигурациях BIOS может быть настроен не на загрузку MBR, а на поиск её эквивалента в сети, что делает возможным собирать компьютеры без жёсткого диска или полностью переустанавливаемые при каждой загрузке. Такая опция есть не у любого оборудования, и для неё обычно необходимо определённое сочетание BIOS и сетевой карты.
			</para>
			 <para>
				Загрузка по сети может использоваться для запуска <command>debian-installer</command> или FAI (см. <xref linkend="sect.installation-methods" />).
			</para>
			 </sidebar> <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Процесс — экземпляр программы</title>
			 <indexterm>
				<primary>процесс</primary>
			</indexterm>
			 <para>
				Процесс является отображением запущенной программы в памяти. Он содержит всю информацию, необходимую для корректной работы программы (сам код, а также данные, хранимые ей в памяти, список открытых ей файлов, установленных ей сетевых соединений и т. п.). Одна программа может быть представлена несколькими процессами, необязательно запущенными от имени разных пользователей.
			</para>
			 </sidebar> <sidebar> <title><emphasis>БЕЗОПАСНОСТЬ</emphasis> Использование командной оболочки в качестве <command>init</command> для получения привилегий root</title>
			 <para>
				Принято, что первым процессом при загрузке является <command>init</command> (по умолчанию символьная ссылка на <filename>/lib/systemd/systemd</filename>). Возможно передать ядру другие параметры для <literal>init</literal>.
			</para>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				Любой человек, способный получить доступ к компьютеру, может нажать кнопку <keycap>Reset</keycap> и перезагрузить его. Потом, в приглашении загрузчика, можно передать ядру опцию <literal>init=/bin/sh</literal>, чтобы получить доступ root, не зная пароля администратора.
			</para>
			 <para>
				Чтобы предотвратить это, можно защитить паролем сам загрузчик. Следует также задуматься о защите доступа к BIOS (механизм защиты паролем почти всегда доступен), без которой злоумышленник всё равно сможет загрузить машину с переносного накопителя c собственной системой Linux, которую он сможет использовать для доступа к данным на жёстком диске компьютера.
			</para>
			 <para>
				Наконец, нужно знать, что в большинстве BIOS есть пароль, предназначенный для исправления неполадок и для тех, кто забыл установленный пароль. Сейчас, такие пароли находятся в свободном доступе в интернете (попробуйте найти для своего BIOS, набрав «generic BIOS passwords» в поисковике). Следует понимать, что не существует надёжного способа защитить компьютер от проникновения, если злоумышленник имеет к нему прямой способ. Например, он может просто забрать жёсткий диск, или целый компьютер, или стереть память BIOS для сброса пароля…
			</para>
			 </sidebar> <para>
				Systemd запускает несколько процессов для настройки клавиатуры, драйверов, файловых систем, сети, служб. Также соблюдаются требования для всех компонентов системы, каждый из которых описан в «файле элемента» — unit (иногда требуется более одного файла). Синтаксис заимствован из «*.ini файлов» с парами «ключ = значение» — <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal>, разделёнными заголовками <literal>[<replaceable>section</replaceable>]</literal>. Unit-файлы хранятся в каталогах <filename>/lib/systemd/system/</filename> и <filename>/etc/systemd/system/</filename>. Далее будут описаны типы unit «сервис» — service и «цель» — target.
			</para>
			 <para>
				Файл service описывает процесс systemd. Он содержит ту же информацию, что и прежние init-сценарии, но она описана в декларативном (и сжатом) стиле. Systemd обслуживает повторяющиеся задачи (старт и остановка процесса, проверка его статуса, журнал, привилегии и т . п.) и файл service должен быть наполнен конкретикой, относящейся к процессу. Например для SSH, он выглядит так:
			</para>
			 
<programlisting>[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</programlisting>
			 <para>
				Как видно из примера, кода очень мало, только объявления. Также systemd описывает ход процесса, отслеживает их выполнение и даже перезапускает, если необходимо.
			</para>
			 <para>
				Файл «цели» в systemd описывает состояние системы, когда функционирует некоторый набор сервисов. Его можно рассматривать как эквивалент уровня запуска. Одна из целей — <literal>local-fs.target</literal>; при её достижении остальная система может рассчитывать, что все локальные файловые системы смонтированы и доступны. В число других целей входят <literal>network-online.target</literal> и <literal>sound.target</literal>. Зависимости цели могут быть указаны как внутри файла target (в строке <literal>Requires=</literal>), так и с использованием символьной ссылки на файл service в каталоге <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal>. Например <filename>/etc/systemd/system/printer.target.wants/</filename> cодержит ссылку на <filename>/lib/systemd/system/cups.service</filename>, поэтому systemd запустит CUPS для достижения цели <literal>printer.target</literal>.
			</para>
			 <para>
				Так как файлы unit декларативны, в отличие от сценарием и программ, они не могут запускаться отдельно и интерпретируются только systemd, хотя несмотря на это, несколько вспомогательных программ позволяют администратору взаимодействовать с systemd, контролировать состояние системы и отдельных компонентов.
			</para>
			 <para>
				Первая из них — <command>systemctl</command>. При запуске без параметров, выводится список всех unit-файлов, известных системе (за исключением отключенных) и их статус. <command>systemctl status</command> дает лучший обзор сервисов и связанных процессов. Выводится имя файла service (как в <command>systemctl status ntp.service</command>), также дополнительная информация и последние несколько строчек из журнала, касающиеся этого процесса (позднее про это будет сказано более подробно).
			</para>
			 <para>
				Для запуска сервиса вручную, нужно просто набрать <command>systemctl start <replaceable>servicename</replaceable>.service</command>. Как можно догадаться, для остановки: <command>systemctl stop <replaceable>servicename</replaceable>.service</command>. Есть другие подкоманды: <command>reload</command> и <command>restart</command>.
			</para>
			 <para>
				Для контроля за активность сервиса (запускается при загрузки системы или нет), нужно использовать <command>systemctl enable <replaceable>servicename</replaceable>.service</command> (или <command>disable</command>). Для проверки запущен ли сервис — <command>is-enabled</command>.
			</para>
			 <para>
				Интересная особенность systemd состоит в журнале <command>journald</command>. Он идет как дополнение к традиционному <command>syslogd</command>, но содержит особенности, как например формальная ссылка между сервисом и сообщением, им создаваемом при процедуре инициализации. Сообщения можно посмотреть с помощью <command>journalctl</command>. Без аргументов, выводится журнал сообщений, создаваемый при загрузке системы, однако в большинстве случаев команда используется с идентификатором сервиса:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</computeroutput></screen>
			 <para>
				Другой полезный флаг <command>-f</command> используется с <command>journalctl</command> для просмотра появления новых сообщений (похоже на <command>tail -f <replaceable>file</replaceable></command>).
			</para>
			 <para>
				Если сервис не работает как ожидалось, то первым делом нужно проверить его статус с <command>systemctl status</command>, если проблема не решена, то проверьте его журнал. Допустим сервер SSH не работает:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>vi /etc/ssh/sshd_config
</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service
</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </computeroutput></screen>
			 <para>
				После проверки статуса (ошибка), был проверен журнал, была обнаружена ошибка в конфигурационном файле. После его редактирования и исправления ошибки, сервис запускается заново, далее проверяется его статус.
			</para>
			 <sidebar><title><emphasis>УГЛУБЛЯЕМСЯ</emphasis> Другие типы unit файла</title>
			 <para>
				Мы описали только базовые возможности systemd, но эта система предлагает много других интересных возможностей. Обозначим некоторые из них:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						активация сокета: «socket» unit файл используется для описания сети или Unix сокета. Это означает, что сокет создаётся systemd и текущий сервис может запускаться по запросу, если будет попытка соединения. Тут копируется набор возможностей <command>inetd</command>. Читайте <citerefentry><refentrytitle>systemd.socket</refentrytitle>
						<manvolnum>5</manvolnum></citerefentry>.
					</para>
				</listitem>
				 <listitem>
					<para>
						таймеры: «timer» unit файл описывает события, возникающие с установленной частотой или в определённый момент времени. Если сервис ссылается на таймер, процесс будет запущен в установленное время. Тут копируется часть возможностей <command>cron</command>. Читайте <citerefentry><refentrytitle>systemd.timer</refentrytitle>
						<manvolnum>5</manvolnum></citerefentry>.
					</para>
				</listitem>
				 <listitem>
					<para>
						сеть: «network» unit файл описывает сетевой интерфейс и позволяет его настраивать, а также отражать зависимость сервиса от какого-либо интерфейса.
					</para>
				</listitem>

			</itemizedlist>
			</sidebar>
		</section>
		 <section id="sect.sysvinit">
			<title>Система инициализации System V</title>
			 <para>
				Система инициализации System V (которую называют init для краткости), используя инструкции из файла <filename>/etc/inittab</filename>, запускает несколько процессов. Первая команда (относящаяся к шагу <emphasis>sysvinit</emphasis>) — это сценарий <command>/etc/init.d/rcS</command>, который запускает все программы в каталоге <filename>/etc/rcS.d/</filename>. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm>
			</para>
			 <para>
				Среди них можно найти последовательность программ, отвечающих за:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						настройку клавиатуры в консоли;
					</para>

				</listitem>
				 <listitem>
					<para>
						загрузку драйверов: большая часть модулей ядра загружается самим ядром при обнаружении оборудования; дополнительные драйверы затем загружаются автоматически, если соответствующие модули указаны в <filename>/etc/modules</filename>;
					</para>

				</listitem>
				 <listitem>
					<para>
						проверку целостности файловых систем;
					</para>

				</listitem>
				 <listitem>
					<para>
						монтирование локальных разделов;
					</para>

				</listitem>
				 <listitem>
					<para>
						настройку сети;
					</para>

				</listitem>
				 <listitem>
					<para>
						монтирование сетевых файловых систем (NFS).
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Опции модулей ядра</title>
			 <indexterm>
				<primary>модули</primary>
				<secondary>ядра</secondary>
			</indexterm>
			 <para>
				У модулей ядра тоже есть опции, которые можно настроить, поместив некоторые файлы в <filename>/etc/modprobe.d/</filename>. Эти опции определяются с помощью таких директив: <literal>options <replaceable>имя-модуля</replaceable> <replaceable>имя-опции</replaceable>=<replaceable>значение-опции</replaceable></literal>. При необходимости в одной директиве можно указывать несколько опций.
			</para>
			 <para>
				Эти конфигурационные файлы предназначены для <command>modprobe</command> — программы, которая загружает модуль ядра вместе с его зависимостями (модули могут на самом деле вызывать другие модули). Эта программа предоставляется пакетом <emphasis role="pkg">kmod</emphasis>.
			</para>
			 <indexterm>
				<primary><command>modprobe</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">kmod</emphasis></primary>
			</indexterm>
			 </sidebar> <para>
				Следом, <command>init</command> запускает программы уровня запуска по умолчанию (обычно runlevel 2). Запускается сценарий <command>/etc/init.d/rc 2</command>, который, в свою очередь, запускает сервисы, перечисленные в <filename>/etc/rc2.d/</filename>. Названия файлов в каталоге начинаются с буквы «S», за которой идут две цифры, что определяет очерёдность запуска. В настоящее время, загрузочная система по умолчанию использует программу <command>insserv</command>, которая автоматически всё организовывает, основываясь на зависимостях сценариев. Каждый сценарий объявляет условия, необходимые для его запуска и остановки (например, очерёдность по отношению к другим сценариям), <command>init</command> запускает сценарии в соответствующей последовательности для удовлетворения зависимостей. Поэтому наименование сценариев больше не учитывается (хотя они всё еще должны начинаться с «S» и далее продолжаться двумя цифрами и названием сервиса, которое и используется для организации зависимостей). В общем, основные сервисы (как журналирование с <command>rsyslog</command> или назначение портов с <command>portmap</command>) запускаются в первую очередь, затем следуют стандартные сервисы и графический интерфейс (<command>gdm3</command>).
			</para>
			 <para>
				Такая основанная на зависимостях система загрузки делает возможной автоматизацию смены нумерации, которая была бы весьма утомительной, если бы её приходилось выполнять вручную, и снижает риск человеческой ошибки, поскольку планирование выполняется в соответствии с формальными параметрами. Другим преимуществом является возможность параллельного запуска сервисов, независимых друг от друга, что может ускорить процесс загрузки.
			</para>
			 <indexterm>
				<primary>уровень запуска</primary>
			</indexterm>
			 <indexterm>
				<primary>запуск, уровень запуска</primary>
			</indexterm>
			 <para>
				<command>init</command> различает несколько уровней запуска, так что она может переключаться с одного на другой при посредстве команды <command>telinit <replaceable>новый-уровень</replaceable></command>. <command>init</command> сразу же запускает <command>/etc/init.d/rc</command> заново с новым уровнем запуска. Этот сценарий после этого запускает недостающие сервисы и останавливает те, которые более не нужны. Для этого он руководствуется содержимым <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (где <replaceable>X</replaceable> означает новый уровень запуска). Сценарии, начинающиеся с «S» (как в слове «Start») — это сервисы, которые должны быть запущены; те, что начинаются с «K» (как в слове «Kill») — сервисы, которые должны быть остановлены. Сценарий не запускает никаких сервисов, которые уже были активированы на прежнем уровне запуска.
			</para>
			 <para>
				По умолчанию, System V init Debian использует четыре разных уровня запуска:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						Уровень 0 используется только временно, при выключении питания компьютера. Поэтому он содержит только «K»-сценарии.
					</para>

				</listitem>
				 <listitem>
					<para>
						Уровень 1, также известный как однопользовательский режим, соответствует системе с урезанной функциональностью; он включает только основные сервисы и предназначается для операций по обслуживанию, когда взаимодействие с обычными пользователями нежелательно.
					</para>

				</listitem>
				 <listitem>
					<para>
						Уровень 2 — уровень для нормальной работы, включающий сетевые сервисы, графический интерфейс, вход пользователей и т. п.
					</para>

				</listitem>
				 <listitem>
					<para>
						Уровень 6 похож на уровень 0 с той разницей, что он используется во время остановки системы перед перезагрузкой.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Есть и другие уровни, в частности с 3 по 5. По умолчанию они настроены, чтобы работать точно так же, как уровень 2, но администратор может изменить их (путём добавления или удаления сценариев в соответствующие каталоги <filename>/etc/rc<replaceable>X</replaceable>.d</filename>), чтобы приспособить их под свои специфические нужды.
			</para>
			 <figure id="figure.boot-process-sysvinit">
				<title>Последовательность загрузки компьютера с Linux и System V init</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/startup-sysvinit.png" format="PNG" scalefit="1" width="80%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <indexterm>
				<primary>инициализационный сценарий</primary>
			</indexterm>
			 <para>
				Все сценарии, содержащиеся в различных каталогах <filename>/etc/rc<replaceable>X</replaceable>.d</filename> на самом деле являются лишь символьными ссылками — созданными при установке пакета программой <command>update-rc.d</command> — указывающими на сами сценарии, хранящиеся в <filename>/etc/init.d/</filename>. Администратор может настроить доступность сервисов на каждом уровне запуска путём повторного запуска <command>update-rc.d</command> с изменёнными параметрами. На странице руководства <citerefentry><refentrytitle>update-rc.d</refentrytitle>
				<manvolnum>8</manvolnum></citerefentry> подробно описан синтаксис. Обратите внимание, что удаление всех символьных ссылок (с помощью параметра <literal>remove</literal>) — не лучший метод отключения сервиса. Вместо этого следует просто настроить, чтобы он не запускался на нужном уровне запуска (сохранив соответствующие вызовы для остановки его в случае, если сервис работал на предыдущем уровне запуска). Поскольку интерфейс <command>update-rc.d</command> несколько запутанный, может оказаться более удобным использовать <command>rcconf</command> (из пакета <emphasis role="pkg">rcconf</emphasis>), интерфейс которой более дружествен к пользователю.
			</para>
			 <indexterm>
				<primary><command>update-rc.d</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>ПОЛИТИКА DEBIAN</emphasis> Перезапуск сервисов</title>
			 <indexterm>
				<primary><command>invoke-rc.d</command></primary>
			</indexterm>
			 <indexterm>
				<primary>сервис</primary>
				<secondary>перезапуск</secondary>
			</indexterm>
			 <indexterm>
				<primary>перезапуск сервисов</primary>
			</indexterm>
			 <para>
				Сценарии сопровождающего пакет Debian иногда перезапускают сервисы для того, чтобы убедиться в их доступности или для применения изменений. Команда для контроля за сервисами <command>service <replaceable>service</replaceable> <replaceable>operation</replaceable></command> не учитывает уровень запуска, подразумевает (ошибочно) что сервис уже используется и может выполнить неправильные операции (запуск сервиса, намеренно остановленного или остановку сервиса, который уже остановлен и т. п.). Поэтому Debian представляет программу <command>invoke-rc.d</command>, которая должна использоваться сопровождающим для запуска сценариев, в свою очередь, предназначенных для запуска сервисов. Она будет запускать только необходимые команды. Заметьте что здесь, по сравнению с традиционным использованием суффикса <filename>.d</filename>, он используется как часть названия программы, а не каталога.
			</para>
			 </sidebar> <para>
				Наконец, <command>init</command> запускает программу управления виртуальными консолями (<command>getty</command>). Она выводит приглашение, ожидает ввода имени пользователя, а затем выполняет <command>login <replaceable>пользователь</replaceable></command>, чтобы начать сессию.
			</para>
			 <indexterm>
				<primary><command>getty</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>СЛОВАРЬ</emphasis> Консоль и терминал</title>
			 <para>
				Первые компьютеры обычно состояли из нескольких очень больших частей: устройство хранения данных и вычислительный модуль размещались отдельно от периферийных устройств, используемых операторами для управления. Часть этой оснастки называлась «консоль». Этот термин остался, но смысл его изменился. Он стал синонимом «терминала» — клавиатуры и дисплея.
			</para>
			 <para>
				С развитием компьютеров операционные системы стали предлагать несколько виртуальных консолей, чтобы сделать возможной одновременную работу нескольких сессий даже при наличии только одной клавиатуры и дисплея. В большинстве систем GNU/Linux шесть виртуальных консолей (в текстовом режиме), доступных путём нажатия сочетаний клавиш с <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> по <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo>.
			</para>
			 <para>
				Также термины «консоль» и «терминал» могут означать эмулятор терминала в графической сессии X11 (например <command>xterm</command>, <command>gnome-terminal</command> или <command>konsole</command>).
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.remote-login">
		<title>Удалённый вход</title>
		 <para>
			Для администратора крайне важно иметь возможность подключиться к компьютеру удалённо. Серверы, заключённые в своей собственной комнате, редко оснащаются постоянными клавиатурами и мониторами — но они подключены к сети.
		</para>
		 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Клиент, сервер</title>
		 <indexterm>
			<primary>клиент</primary>
			<secondary>клиент-серверная архитектура</secondary>
		</indexterm>
		 <indexterm>
			<primary>сервер</primary>
			<secondary>клиент-серверная архитектура</secondary>
		</indexterm>
		 <para>
			Система, в которой несколько процессов взаимодействуют друг с другом, часто описывается с помощью терминов «клиент» и «сервер». Сервер — это программа, принимающая запрос от клиента и выполняющая его. Все действия контролируются клиентом, сервер сам по себе не проявляет никакой инициативы.
		</para>
		 </sidebar> <indexterm>
			<primary>вход</primary>
			<secondary>удалённый вход</secondary>
		</indexterm>
		 <indexterm>
			<primary>удалённый вход</primary>
		</indexterm>
		 <section id="sect.ssh">
			<title>Защищённый удалённый вход: SSH</title>
			 <indexterm>
				<primary>SSH</primary>
			</indexterm>
			 <indexterm>
				<primary>Secure Shell</primary>
			</indexterm>
			 <para>
				Протокол <emphasis>SSH</emphasis> (<foreignphrase>Secure SHell</foreignphrase> — защищённая командная оболочка) был разработан из соображений безопасности и надёжности. Соединения, использующие SSH, защищены: другая сторона аутентифицируется, а весь обмен данными зашифрован.
			</para>
			 <sidebar> <title><emphasis>КУЛЬТУРА</emphasis> Telnet и RSH устарели</title>
			 <indexterm>
				<primary><command>telnet</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>rsh</command></primary>
			</indexterm>
			 <para>
				До SSH основными средствами удалённого доступа были <emphasis>Telnet</emphasis> и <emphasis>RSH</emphasis>. Сейчас они сильно устарели, и их не следует использовать, хотя они всё ещё есть в Debian.
			</para>
			 </sidebar> <sidebar> <title><emphasis>СЛОВАРЬ</emphasis> Аутентификация, шифрование</title>
			 <para>
				Безопасность важна, когда необходимо дать клиенту возможность управления или выполнения действий на сервере. Необходимо надёжно идентифицировать клиента; это называется аутентификацией. Для идентификации обычно используется пароль, который должен храниться в секрете, иначе другой клиент мог бы воспользоваться им. Для этого служит шифрование — форма кодирования, позволяющая двум системам обмениваться конфиденциальной информацией по публичному каналу, защищая её от чтения другими.
			</para>
			 <para>
				Аутентификация и шифрование часто упоминаются вместе, потому что они часто используются совместно, и потому что они обычно основываются на сходных математических принципах.
			</para>
			 </sidebar> <para>
				В состав SSH также входят две транспортных службы. <command>scp</command> — это инструмент командной строки, который можно использовать наподобие <command>cp</command> с той разницей, что любой путь к другой машине начинается с указания её имени, за которым следует двоеточие.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput></screen>
			 <para>
				<command>sftp</command> — это интерактивная команда, похожая на <command>ftp</command>. В рамках одной сессии <command>sftp</command> может передать несколько файлов, а также с её помощью можно манипулировать удалёнными файлами (удалять, переименовывать, менять права доступа и т. д.).
			</para>
			 <indexterm>
				<primary><command>scp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sftp</command></primary>
			</indexterm>
			 <para>
				В Debian используется OpenSSH — свободная реализация SSH, развиваемая в рамках проекта <command>OpenBSD</command> (свободной операционной системы, основанной на ядре BSD и делающей акцент на безопасности), и являющаяся ответвлением оригинальной программы SSH, разработанной финской компанией SSH Communications Security Corp. Эта компания изначально разрабатывала SSH как свободное ПО, но впоследствии решила продолжить разработку под собственнической лицензией. Тогда проект OpenBSD создал OpenSSH, чтобы развивать свободную версию SSH.
			</para>
			 <indexterm>
				<primary>OpenSSH</primary>
			</indexterm>
			 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Ответвление (<foreignphrase>fork</foreignphrase>)</title>
			 <indexterm>
				<primary>форк</primary>
			</indexterm>
			 <para>
				В области программного обеспечения «ответвление» или «форк» означает новый проект, начатый как клон существующего проекта и конкурирующий с ним. В дальнейшем оба программных продукта как правило быстро расходятся в плане новых доработок. Форк часто является результатом конфликтов внутри команды разработчиков.
			</para>
			 <para>
				Возможность создать ответвление прямо следует из самой природы свободного ПО; форк — это здоровое явление, если оно позволяет продолжить развитие проекта как свободного ПО (например в случае изменения лицензии). Форк, возникающий из-за технических или личных разногласий зачастую является транжирством человеческого ресурса; другое решение было бы более предпочтительным. Случаются и слияния двух проектов, ранее разошедшихся вследствие форка.
			</para>
			 </sidebar> <para>
				OpenSSH разделён на два пакета: клиент <emphasis role="pkg">openssh-client</emphasis> и сервер <emphasis role="pkg">openssh-server</emphasis>. Мета-пакет <emphasis role="pkg">ssh</emphasis> устанавливает оба (<command>apt install ssh</command>).
			</para>
			 <section id="sect.ssh-key-based-auth">
				<title>Аутентификация по ключу</title>
				 <para>
					При каждом входе по SSH удалённый сервер запрашивает пароль, чтобы аутентифицировать пользователя. Это может создать проблему, если хочется автоматизировать соединение, или если используется некий инструмент, которому нужно часто устанавливать соединения через SSH. По этой причине в SSH предусмотрен механизм аутентификации по ключу.
				</para>
				 <para>
					Пользователь создаёт на клиентской машине пару ключей с помощью <command>ssh-keygen -t rsa</command>; публичный ключ сохраняется в <filename>~/.ssh/id_rsa.pub</filename>, а соответствующий ему секретный ключ — в <filename>~/.ssh/id_rsa</filename>. Затем пользователь с помощью команды <command>ssh-copy-id <replaceable>сервер</replaceable></command> добавляет публичный ключ в файл <filename>~/.ssh/authorized_keys</filename> на сервере. Если секретный ключ не был при создании защищён «парольной фразой», все последующие входы на сервер будут работать без пароля. В противном случае потребуется расшифровывать секретный ключ каждый раз, вводя парольную фразу. К счастью, <command>ssh-agent</command> позволяет хранить секретные ключи в памяти, чтобы не приходилось то и дело вводить пароль. Для этого ипользуется <command>ssh-add</command> (однократно за рабочую сессию) при условии, что сессия уже ассощиирована с работающим экземпляром <command>ssh-agent</command>. Debian активирует его по умолчанию в графических сессиях, но это можно отключить, изменив <filename>/etc/X11/Xsession.options</filename>. Для консольной сессии можно запустить его вручную с помощью <command>eval $(ssh-agent)</command>.
				</para>
				 <sidebar> <title><emphasis>БЕЗОПАСНОСТЬ</emphasis> Защита секретного ключа</title>
				 <para>
					Кто угодно, имеющий секретный ключ, может войти в настроенную таким образом учётную запись. Поэтому доступ к секретному ключу защищается «парольной фразой». Некто, получивший копию секретного ключа (например <filename>~/.ssh/id_rsa</filename>) всё равно должен знать эту фразу, чтобы иметь возможность воспользоваться им. Эта дополнительная защита не является, однако, неприступной, и если есть основания полагать, что данный файл был скомпроментирован, лучше отключить этот ключ на компьютерах, на которые он был установлен, (путём удаления его из файлов <filename>authorized_keys</filename>) и заменить его вновь созданным ключом.
				</para>
				 </sidebar> <sidebar> <title><emphasis>КУЛЬТУРА</emphasis> Уязвимость OpenSSL в Debian <emphasis role="distribution">Etch</emphasis></title>
				 <para>
					У библиотеки OpenSSL в том виде, в каком она поставлялась в Debian <emphasis role="distribution">Etch</emphasis>, была серьёзная проблема с генератором случайных чисел (ГСЧ). На самом деле сопровождающий Debian внёс изменение, чтобы приложения, используемые библиотекой, перестали выводить предупреждения при анализе их инструментами тестирования памяти вроде <command>valgrind</command>. К сожалению, это изменение также привело к тому, что ГСЧ стал использовать только один источник энтропии, соответствующий идентификатору процесса (PID), 32.000 возможных значений которого не обеспечивают должного уровня случайности. <ulink type="block" url="http://www.debian.org/security/2008/dsa-1571" />
				</para>
				 <para>
					В частности, когда OpenSSL использовалась для генерации ключа, она всегда создавала ключ из известного набора нескольких сотен тысяч ключей (32.000, помноженные на небольшое число длин ключей). Это затронуло ключи SSH и SSL, а также сертификаты X.509, используемые многочисленными приложениями, такими как OpenVPN. Взломщику оставалось только перепробовать все ключи, чтобы получить неавторизованный доступ. Чтобы уменьшить последствия этой проблемы, демон SSH был модифицирован таким образом, чтобы отклонять проблемные ключи, перечисленные в пакетах <emphasis role="pkg">openssh-blacklist</emphasis> и <emphasis role="pkg">openssh-blacklist-extra</emphasis>. Кроме того, команда <command>ssh-vulnkey</command> позволяет обнаружить возможно скомпроментированные ключи в системе.
				</para>
				 <para>
					Более детальный анализ выявил, что это результат нескольких (небольших) проблем и в проекте OpenSSL и у сопровождающего пакет Debian. Такие широко используемые библиотеки как OpenSSL должны без изменений проходить тест <command>valgrind</command> без предупреждений. Более того, код (особенно чувствительные части, как RNG) должен быть лучше сопровождён комментариями для предотвращения таких ошибок. Сопровождающий пакета Debian хотел согласовать изменения вместе с разработчиками OpenSSL, но просто объяснил их, не предоставив соответствующий патч для проверки и не уведомил о своей роли в Debian. Наконец, его выбор не был оптимальным: изменения в исходном коде не были отчётливо сопровождены комментариями. Они были сохранены в репозитории Subversion, затем свалены в один патч во время создания пакета с исходным кодом.
				</para>
				 <para>
					При таких условиях трудно найти средства для предотвращения подобных инцидентов в будущем. Урок, который можно вынести из этого — каждое изменение, внесённое Debian в апстрим программное обеспечение, должно быть подтверждено, документировано, внесено в проект и широко оглашено. В соответствии с этим разработан новый формат для исходников («3.0 (quilt)») и веб-сервис. <ulink type="block" url="http://sources.debian.net" />
				</para>
				 </sidebar>
			</section>
			 <section id="sect.ssh-x11">
				<title>Использование удалённых приложений X11</title>
				 <para>
					Протокол SSH позволяет пересылать графические данные (сессию «X11», по названию наиболее широко распространённой в Unix графической системы); в таком случае сервер сохраняет выделенный канал для этих данных. Так, графическая программа, запущенная удалённо, может быть отображена сервером X.org на локальном экране, и вся сессия (ввод и отображение) будет защищена. Поскольку эта возможность позволяет удалённым приложениям перекрываться с локальной системой, она отключена по умолчанию. Её можно включить, указав <literal>X11Forwarding yes</literal> в конфигурационном файле сервера (<filename>/etc/ssh/sshd_config</filename>). Пользователь также должен явно запросить её, добавив опцию <literal>-X</literal> к командной строке <command>ssh</command>.
				</para>

			</section>
			 <section id="sect.ssh-port-forwarding">
				<title>Создание шифрованных туннелей</title>
				 <indexterm>
					<primary>перенаправление портов</primary>
				</indexterm>
				 <para>
					Опции <literal>-R</literal> и <literal>-L</literal> указывают <command>ssh</command>, что нужно создать «шифрованный туннель» между двумя машинами, безопасно перенаправив локальный порт TCP (см. врезку <xref linkend="sidebar.tcp-udp" />) на удалённую машину или наоборот.
				</para>
				 <sidebar> <title><emphasis>СЛОВАРЬ</emphasis> Туннель</title>
				 <indexterm>
					<primary>туннель (SSH)</primary>
					<seealso>VPN</seealso>
				</indexterm>
				 <indexterm>
					<primary>SSH-туннель</primary>
					<seealso>VPN</seealso>
				</indexterm>
				 <para>
					Интернет, как и большинство подключённых к нему локальных сетей, работает в пакетном режиме, а не в подключённом. Это означает, что пакет, отправленный одним компьютером другому, будет останавливаться на нескольких промежуточных маршрутизаторах для выяснения пути к его месту назначения. Но всё же можно симулировать подключённую работу, энкапсулируя поток в обычные пакеты IP. Эти пакеты следуют своим обычным путём, а поток восстанавливается в неизменном виде в месте назначения. Это называется «туннелем» по аналогии с дорожным туннелем, по которому автомобили следуют напрямую от въезда (ввод) к выезду (вывод) без каких бы то ни было перекрёстков, в противоположность движению по поверхности, где встречались бы перекрёстки и менялось направление движения.
				</para>
				 <para>
					Эту возможность можно использовать, чтобы добавить шифрование в туннель: поток, идущий через него, не распознаваем извне, но возвращается к расшифрованному виду на выходе из туннеля.
				</para>
				 </sidebar> <para>
					<command>ssh -L 8000:server:25 intermediary</command> устанавливает сессию SSH с узлом <replaceable>intermediary</replaceable> и слушает локальный порт 8000 (см. <xref linkend="figure.ssh-L" />). Для любого соединения, установленного на этом порту, <command>ssh</command> инициирует соединение с машины<replaceable>intermediary</replaceable> на порт 25 машины <replaceable>server</replaceable> и свяжет оба соединения друг с другом.
				</para>
				 <para>
					<command>ssh -R 8000:server:25 intermediary</command> также устанавливают сессию SSH с компьютером <replaceable>intermediary</replaceable>, но слушает порт 8000 уже на этой машине (см. <xref linkend="figure.ssh-R" />). Любое соединение с этим портом заставит <command>ssh</command> открыть соединение с локальной машины на порт 25 машины <replaceable>server</replaceable> и связать между собой два соединения.
				</para>
				 <para>
					В обоих случаях соединения устанавливаются с портом 25 узла <replaceable>server</replaceable>, проходя через туннель SSH между локальной машиной и машиной <replaceable>intermediary</replaceable>. В первом случае входом в туннель является локальный порт 8000, и данные идут на машину <replaceable>intermediary</replaceable> перед тем, как направиться на <replaceable>server</replaceable> в «публичной» сети. Во втором случае вход и выход из туннеля меняются местами; входом является порт 8000 на машине <replaceable>intermediary</replaceable>, а выход расположен на локальном узле, и данные затем направляются на <replaceable>server</replaceable>. На практике сервером обычно является либо локальная машина, либо промежуточная. В таком случае SSH защищает соединение от одного конца до другого.
				</para>
				 <figure id="figure.ssh-L">
					<title>Перенаправление локального порта с помощью SSH</title>
					 <mediaobject>
						<imageobject>
							<imagedata fileref="images/ssh-L.png" format="PNG" width="35%" />
						</imageobject>

					</mediaobject>

				</figure>
				 <figure id="figure.ssh-R">
					<title>Перенаправление удалённого порта с помощью SSH</title>
					 <mediaobject>
						<imageobject>
							<imagedata fileref="images/ssh-R.png" format="PNG" width="35%" />
						</imageobject>

					</mediaobject>

				</figure>

			</section>

		</section>
		 <section id="sect.remote-desktops">
			<title>Использование удалённых графических рабочих столов</title>
			 <para>
				VNC (<foreignphrase>Virtual Network Computing</foreignphrase>) позволяет удалённо подключаться к графическим рабочим столам.
			</para>
			 <indexterm>
				<primary>VNC</primary>
			</indexterm>
			 <indexterm>
				<primary>Virtual Network Computing</primary>
			</indexterm>
			 <indexterm>
				<primary>графический рабочий стол</primary>
				<secondary>удалённый</secondary>
			</indexterm>
			 <indexterm>
				<primary>удалённый графический рабочий стол</primary>
			</indexterm>
			 <indexterm>
				<primary>рабочий стол, удалённый графический</primary>
			</indexterm>
			 <para>
				Этот инструмент используется в основном для технической помощи; администратор может видеть ошибки, с которыми сталкивается пользователь, и показывать ему правильный путь их решения без необходимости стоять у него за спиной.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vino</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">krfb</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">x11vnc</emphasis></primary>
			</indexterm>
			 <para>
				Для начала, пользователь должен разрешить доступ к сессии. Графическая среда GNOME в <emphasis role="distribution">Jessie</emphasis> включает эту возможность (на конфигурационной панели, хотя в предыдущих выпусках Debian пользователь должен был устанавливать и запускать <command>vino</command>). В KDE нужно использовать <command>krfb</command> для предоставления доступа к существующей сессии через VNC. Для остальных сред следует использовать команду (пакет имеет аналогичное название) <command>x11vnc</command>; для пользователя, вы можете создать значок для запуска.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vinagre</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">tsclient</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">krdc</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">xvnc4viewer</emphasis></primary>
			</indexterm>
			 <para>
				Когда всё готово для VNC, администратор должен использовать VNC-клиент для соединения. GNOME использует <command>vinagre</command> и <command>remmina</command>, KDE использует <command>krdc</command> (в меню <menuchoice> <guimenu>K</guimenu> <guisubmenu>Интернет</guisubmenu> <guimenuitem>Клиент удалённого рабочего стола</guimenuitem></menuchoice>). Существуют другие VNC-клиенты, использующие консоль, например <command>xvnc4viewer</command> — пакет Debian имеет такое же название. После подключения, администратор может видеть что происходит, работать на машине удалённо и показать пользователю как действовать.
			</para>
			 <sidebar> <title><emphasis>БЕЗОПАСНОСТЬ</emphasis> VNC через SSH</title>
			 <indexterm>
				<primary>SSH-туннель</primary>
				<secondary>VNC</secondary>
			</indexterm>
			 <para>
				Если хочется подключиться по VNC, но так, чтобы данные не передавались по сети в открытом виде, можно энкапсулировать их в SSH-туннель (см. <xref linkend="sect.ssh-port-forwarding" />). Для этого нужно только знать, что по умолчанию VNC использует порт 5900 для первого экрана (называемого «localhost:0»), 5901 — для второго (называемого «localhost:1») и т. д.
			</para>
			 <para>
				Команда <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command> создаёт туннель между портом 5901 локального интерфейса и портом 5900 узла <replaceable>machine</replaceable>. Первое слово «localhost» указывает SSH, что надо слушать только этот интерфейс на локальной машине. Второе вхождение «localhost» указывает интерфейс на удалённой машине, который будет получать трафик, входящий в «localhost:5901». В таком случае команда <command>vncviewer localhost:1</command> установит подключение клиента VNC к удалённому экрану, хотя ей и указано имя локальной машины.
			</para>
			 <para>
				После закрытия сессии VNC не забудьте также закрыть туннель путём выхода из соответствующей сессии SSH.
			</para>
			 </sidebar> <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Менеджер дисплея</title>
			 <indexterm>
				<primary><command>gdm3</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>kdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>xdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>lightdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary>менеджер</primary>
				<secondary>дисплея</secondary>
			</indexterm>
			 <indexterm>
				<primary>дисплейный менеджер</primary>
			</indexterm>
			 <para>
				<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, и <command>xdm</command> — менеджеры рабочего стола. Они используются для регистрации пользователей, запускаются после загрузки системы и используют графический интерфейс. После регистрации пользователя, они запускают программы, необходимые для запуска рабочей графической сессии.
			</para>
			 </sidebar> <para>
				VNC также подходит для мобильных пользователей или для руководителей компании, которым время от времени требуется получать доступ к удалённому рабочему столу из своего дома, как если бы они были на работе. Настройка такого сервиса сложнее: сперва нужно установить пакет <emphasis role="pkg">vnc4server</emphasis>, изменить настройки менеджера дисплея, чтобы он принимал запросы <literal>XDMCP Query</literal> (для <command>gdm3</command> это делается путём добавления строки <literal>Enable=true</literal> в раздел «xdmcp» файла <filename>/etc/gdm3/daemon.conf</filename>) и, наконец, запустить сервер VNC с помощью <command>inetd</command>, чтобы сессия автоматически запускалась при попытке пользователя войти в систему. Например, можно добавить следующую строчку в <filename>/etc/inetd.conf</filename>:
			</para>
			 
<programlisting>5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</programlisting>
			 <para>
				Redirecting incoming connections to the display manager solves the problem of authentication, because only users with local accounts will pass the <command>gdm3</command> login screen (or equivalent <command>kdm</command>, <command>xdm</command>, etc.). As this operation allows multiple simultaneous logins without any problem (provided the server is powerful enough), it can even be used to provide complete desktops for mobile users (or for less powerful desktop systems, configured as thin clients). Users simply login to the server's screen with <command>vncviewer <replaceable>server</replaceable>:50</command>, because the port used is 5950.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vnc4server</emphasis></primary>
			</indexterm>

		</section>

	</section>
	 <section id="sect.rights-management">
		<title>Управление правами</title>
		 <para>
			Linux — многопользовательская система, поэтому она должна предоставлять систему разрешений, чтобы контролировать авторизованные операции с файлами и каталогами, к которым относятся все системные ресурсы и устройства (в Unix-системах любое устройство представляется в виде файла или каталога). Этот принцип является общим для всех Unix-систем, но напомнить об этом ещё раз будет не лишним, тем более что существуют некоторые интересные и сравнительно малоизвестные способы применения.
		</para>
		 <indexterm>
			<primary>права</primary>
		</indexterm>
		 <indexterm>
			<primary>разрешения</primary>
		</indexterm>
		 <indexterm>
			<primary>пользователь</primary>
			<secondary>владелец</secondary>
		</indexterm>
		 <indexterm>
			<primary>группа</primary>
			<secondary>владелец</secondary>
		</indexterm>
		 <indexterm>
			<primary>владелец</primary>
			<secondary>пользователь</secondary>
		</indexterm>
		 <indexterm>
			<primary>владелец</primary>
			<secondary>группа</secondary>
		</indexterm>
		 <para>
			У каждого файла и каталога имеются специальные разрешения для трёх категорий пользователей:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					его владельца (обозначается <literal>u</literal>, от «user»);
				</para>

			</listitem>
			 <listitem>
				<para>
					его группы-владельца (обозначается <literal>g</literal>, от «group»), представленная всеми членами группы;
				</para>

			</listitem>
			 <listitem>
				<para>
					остальных (обозначается <literal>o</literal>, от «other»).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Три типа прав могут использоваться совместно:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					чтение (обозначается <literal>r</literal>, от «read»);
				</para>

			</listitem>
			 <listitem>
				<para>
					запись (или изменение, обозначается <literal>w</literal>, от «write»);
				</para>

			</listitem>
			 <listitem>
				<para>
					исполнение (обозначается <literal>x</literal>, от «eXecute»).
				</para>

			</listitem>

		</itemizedlist>
		 <indexterm>
			<primary>чтение, право</primary>
		</indexterm>
		 <indexterm>
			<primary>запись, право</primary>
		</indexterm>
		 <indexterm>
			<primary>изменение, право</primary>
		</indexterm>
		 <indexterm>
			<primary>исполнение, право</primary>
		</indexterm>
		 <para>
			In the case of a file, these rights are easily understood: read access allows reading the content (including copying), write access allows changing it, and execute access allows you to run it (which will only work if it is a program).
		</para>
		 <sidebar> <title><emphasis>БЕЗОПАСНОСТЬ</emphasis> исполняемые файлы с <literal>setuid</literal> и <literal>setgid</literal></title>
		 <para>
			Два своеобразных права имеют смысл для исполняемых файлов: <literal>setuid</literal> и <literal>setgid</literal> (обозначаются буквой «s»). Обратите внимание, что они часто называются «битами», поскольку каждое из этих логических значений может быть представлено как 0 или 1. Эти два права позволяют любому пользователю выполнять программу на правах её владельца или группы соответственно. Данный механизм предоставляет доступ к функциям, требующим разрешений более высокого уровня, чем обычно есть у пользователя.
		</para>
		 <indexterm>
			<primary><literal>setuid</literal>, право</primary>
		</indexterm>
		 <indexterm>
			<primary><literal>setgid</literal>, право</primary>
		</indexterm>
		 <para>
			Поскольку <literal>setuid</literal>-программа, принадлежащая root, систематически запускается с правами суперпользователя, крайне важно убедиться в её безопасности и надёжности. Действительно, пользователь, которому удастся заставить её вызвать другую произвольную программу, сможет представиться как root и получить все права в системе.
		</para>
		 </sidebar> <para>
			Каталоги обрабатываются иначе. Доступ на чтение даёт право получить список его содержимого (файлов и каталогов), доступ на запись позволяет создавать и удалять файлы, а доступ на исполнение позволяет проходить через него (в частности переходить в него с помощью команды <command>cd</command>). Возможность проходить через каталог, не имея возможности прочесть его, позволяет получить доступ к файлам внутри него, если они известны по имени, но не находить их, если о их существовании или их точных именах не известно.
		</para>
		 <sidebar id="sidebar.setgid-dir"> <title><emphasis>БЕЗОПАСНОСТЬ</emphasis> Каталог с <literal>setgid</literal> и <emphasis>sticky bit</emphasis></title>
		 <indexterm>
			<primary><literal>setgid</literal>-каталог</primary>
		</indexterm>
		 <para>
			Бит <literal>setgid</literal> применим и к каталогам. Любой вновь созданный файл внутри таких каталогов автоматически присваивается группе-владельцу родительского каталога вместо того, чтобы унаследовать основную группу создателя, как происходит обычно. Эта настройка позволяет пользователю не изменять свою основную группу (с помощью команды <command>newgrp</command>) при работе в дереве файлов, общих для нескольких пользователей из одной конкретной группы.
		</para>
		 <indexterm>
			<primary>sticky bit</primary>
		</indexterm>
		 <para>
			Так называемый «sticky bit» (обозначаемый буквой «t») является разрешением, имеющим смысл только для каталогов. Он, в частности, используется для временных каталогов, куда у всех есть доступ на запись (например <filename>/tmp/</filename>): он ограничивает возможность удаления файлов, так что только их владелец (или владелец родительского каталога) может это сделать. Если бы данной функции не было, любой мог бы удалить файлы других пользователей в <filename>/tmp/</filename>.
		</para>
		 </sidebar> <para>
			Три команды для управления разрешениями, связанными с файлом:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					<command>chown <replaceable>пользователь</replaceable> <replaceable>файл</replaceable></command> изменяет владельца файла;
				</para>

			</listitem>
			 <listitem>
				<para>
					<command>chgrp <replaceable>группа</replaceable> <replaceable>файл</replaceable></command> меняет группу-владельца;
				</para>

			</listitem>
			 <listitem>
				<para>
					<command>chmod <replaceable>права</replaceable> <replaceable>файл</replaceable></command> изменяет разрешения на файл.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Есть два способа представления прав. Из них символьное, пожалуй, более легко для понимания и запоминания. В нём используются указанные выше символы. Можно определить права для каждой категории пользователей (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), присвоив их явно (с помощью <literal>=</literal>), добавив (<literal>+</literal>) или отняв (<literal>-</literal>). Так, выражение <literal>u=rwx,g+rw,o-r</literal> даёт владельцу права на чтение, запись и исполнение, добавляет права на чтение и запись для группы-владельца и отнимает право на чтение у остальных пользователей. Права, не затрагиваемые добавлением или отъёмом, остаются без изменений. Буква <literal>a</literal> (от «all») обозначает все три категории пользователей, так что <literal>a=rx</literal> даёт всем трём категориям одинаковые права (читать и исполнять, но не записывать).
		</para>
		 <indexterm>
			<primary><command>chmod</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>chown</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>chgrp</command></primary>
		</indexterm>
		 <indexterm>
			<primary>восьмеричное представление прав</primary>
		</indexterm>
		 <indexterm>
			<primary>права</primary>
			<secondary>восьмеричное представление</secondary>
		</indexterm>
		 <para>
			В цифровом (восьмеричном) представлении каждому праву соответствует конкретное значение: 4 — чтению, 2 — записи, 1 — исполнению. Каждая комбинация прав соответствует сумме этих чисел. Каждое значение затем присваивается своей категории пользователей, будучи записанным подряд с остальными в обычном порядке (владелец, группа, остальные).
		</para>
		 <para>
			Например, команда <command>chmod 754 <replaceable>файл</replaceable></command> установит следующие права: на чтение, запись и исполнение для владельца (поскольку 7 = 4 + 2 + 1); на чтение и исполнение для группы (поскольку 5 = 4 + 1); только на чтение для остальных. <literal>0</literal> означает отсутствие прав, так что <command>chmod 600 <replaceable>файл</replaceable></command> разрешает чтение и запись владельцу и не даёт никаких прав всем остальным. Наиболее распространённые комбинации прав — <literal>755</literal> для исполняемых файлов и каталогов и <literal>644</literal> для файлов с данными.
		</para>
		 <para>
			Для представления в таком виде специальных прав можно указать в начале четвёртую цифру в соответствии с тем же принципом, где битам <literal>setuid</literal>, <literal>setgid</literal> <literal>sticky</literal> соответствуют 4, 2 и 1. <command>chmod 4754</command> установит бит <literal>setuid</literal> наравне с вышеописанными правами.
		</para>
		 <para>
			Note that the use of octal notation only allows to set all the rights at once on a file; you cannot use it to simply add a new right, such as read access for the group owner, since you must take into account the existing rights and compute the new corresponding numerical value.
		</para>
		 <sidebar> <title><emphasis>СОВЕТ</emphasis> Рекурсивная работа</title>
		 <para>
			Иногда требуется изменить права для целого дерева файлов. У всех вышеуказанных команд есть опция <literal>-R</literal>, при использовании которой программа рекурсивно обходит подкаталоги.
		</para>
		 <para>
			The distinction between directories and files sometimes causes problems with recursive operations. That is why the “X” letter has been introduced in the symbolic representation of rights. It represents a right to execute which applies only to directories (and not to files lacking this right). Thus, <command>chmod -R a+X <replaceable>directory</replaceable></command> will only add execute rights for all categories of users (<literal>a</literal>) for all of the sub-directories and files for which at least one category of user (even if their sole owner) already has execute rights.
		</para>
		 </sidebar> <sidebar> <title><emphasis>СОВЕТ</emphasis> Смена пользователя и группы</title>
		 <para>
			Frequently you want to change the group of a file at the same time that you change the owner. The <command>chown</command> command has a special syntax for that: <command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command>
		</para>
		 </sidebar> <sidebar> <title><emphasis>УГЛУБЛЯЕМСЯ</emphasis> <command>umask</command></title>
		 <para>
			Когда приложение создаёт файл, оно присваивает ему ориентировочные разрешения, зная, что система автоматически удаляет некоторые права, заданные командой <command>umask</command>. Введите <command>umask</command> в командной оболочке; вы увидите маску наподобие <computeroutput>0022</computeroutput>. Это всего лишь восьмеричное представление прав, которые методично удаляются (в данном случае — право записи для группы и для остальных пользователей).
		</para>
		 <indexterm>
			<primary>umask</primary>
		</indexterm>
		 <indexterm>
			<primary>права</primary>
			<secondary>маска</secondary>
		</indexterm>
		 <indexterm>
			<primary>маска</primary>
			<secondary>маска прав</secondary>
		</indexterm>
		 <para>
			Если передать ей новое восьмеричное значение, команда <command>umask</command> изменяет маску. При использовании в файле инициализации оболочки (например <filename>~/.bash_profile</filename>) она изменит маску во всех пользовательских сессиях.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.administration-interfaces">
		<title>Интерфейсы для администрирования</title>
		 <indexterm>
			<primary>интерфейс</primary>
			<secondary>администрирования</secondary>
		</indexterm>
		 <indexterm>
			<primary>административные интерфейсы</primary>
		</indexterm>
		 <para>
			Использование графического интерфейса для администрирования представляет интерес при разных обстоятельствах. Администратор не обязательно знает все подробности настройки всех своих сервисов, и у него не всегда есть время на поиск документации по этой теме. В таком случае графический интерфейс может ускорить развёртывание нового сервиса. Он также упрощает настройку сервисов, конфигурирование которых слишком сложно.
		</para>
		 <para>
			Такой интерфейс является лишь вспомогательным средством, а не самоцелью. В любом случае администратор должен освоить его, чтобы суметь понять и обойти любую потенциальную проблему.
		</para>
		 <para>
			Since no interface is perfect, you may be tempted to try several solutions. This is to be avoided as much as possible, since different tools are sometimes incompatible in their work methods. Even if they all aim to be very flexible and try to adopt the configuration file as a single reference, they are not always able to integrate external changes.
		</para>
		 <section id="sect.webmin">
			<title>Администрирование через веб-интерфейс: <command>webmin</command></title>
			 <indexterm>
				<primary><emphasis>webmin</emphasis></primary>
			</indexterm>
			 <para>
				Это, несомненно, один из самых удачных интерфейсов для администрирования. Это модульная система, управляемая через веб-обозреватель и покрывающая широкий набор областей и инструментов. Кроме того, он интернационализирован и доступен на множестве языков.
			</para>
			 <para>
				Sadly, <command>webmin</command> is no longer part of Debian. Its Debian maintainer — Jaldhar H. Vyas — removed the packages he created because he no longer had the time required to maintain them at an acceptable quality level. Nobody has officially taken over, so <emphasis role="distribution">Jessie</emphasis> does not have the <command>webmin</command> package.
			</para>
			 <para>
				Однако существует неофициальный пакет, распространяемый на сайте <literal>webmin.com</literal>. В отличие от оригинальных пакетов Debian, этот пакет — монолитный; все его конфигурационные модули устанавливаются и включаются по умолчанию, даже если соответствующий сервис не установлен на машине.
			</para>
			 <sidebar> <title><emphasis>БЕЗОПАСНОСТЬ</emphasis> Изменение пароля root</title>
			 <para>
				On the first login, identification is conducted with the root username and its usual password. It is recommended to change the password used for <command>webmin</command> as soon as possible, so that if it is compromised, the root password for the server will not be involved, even if this confers important administrative rights to the machine.
			</para>
			 <para>
				Будьте осторожны! Поскольку <command>webmin</command> настолько функционален, злоумышленник получивший доступ к нему, может скомпроментировать безопасность всей системы. Как правило, интерфейсы такого рода не рекомендуются к использованию на важных системах со строгими требованиями к безопасности (межсетевых экранах, серверах с ценными данными и т. п.).
			</para>
			 </sidebar> <para>
				Webmin используется при посредстве веб-интерфейса, но для него не требуется установка Apache. Дело в том, что в его состав входит свой собственный небольшой веб-сервер. Этот сервер по умолчанию слушает порт 10000 и принимает защищённые HTTP-соединения.
			</para>
			 <para>
				Входящие в поставку модули предназначены для широкого круга сервисов, среди которых:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						все базовые сервисы: создание пользователей и групп, управление файлами <filename>crontab</filename>, сценариями инициализации, отображение журналов и т. п.;
					</para>

				</listitem>
				 <listitem>
					<para>
						bind: настройка сервера DNS (службы имён);
					</para>

				</listitem>
				 <listitem>
					<para>
						postfix: настройка SMTP-сервера (e-mail);
					</para>

				</listitem>
				 <listitem>
					<para>
						inetd: настройка суперсервера <command>inetd</command>;
					</para>

				</listitem>
				 <listitem>
					<para>
						quota: управление пользовательскими квотами;
					</para>

				</listitem>
				 <listitem>
					<para>
						dhcpd: настройка сервера DHCP;
					</para>

				</listitem>
				 <listitem>
					<para>
						proftpd: настройка сервера FTP;
					</para>

				</listitem>
				 <listitem>
					<para>
						samba: Настройка файлового сервера Samba;
					</para>

				</listitem>
				 <listitem>
					<para>
						software: установка или удаление программного обеспечения из пакетов Debian и обновлений системы.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Административный интерфейс доступен в веб-обозревателе по адресу <literal>https://localhost:10000</literal>. Внимание! Не все модули сразу готовы к использованию. Иногда их надо настроить, указав расположение соответствующих конфигурационных файлов и некоторых исполняемых файлов (программ). Как правило, система любезно напоминает об этом, если не может активировать запрошенный модуль.
			</para>
			 <sidebar> <title><emphasis>АЛЬТЕРНАТИВА</emphasis> Центр управления GNOME</title>
			 <indexterm>
				<primary><emphasis role="pkg">gnome-control-center</emphasis></primary>
			</indexterm>
			 <para>
				The GNOME project also provides multiple administration interfaces that are usually accessible via the “Settings” entry in the user menu on the top right. <command>gnome-control-center</command> is the main program that brings them all together but many of the system wide configuration tools are effectively provided by other packages (<emphasis role="pkg">accountsservice</emphasis>, <emphasis role="pkg">system-config-printer</emphasis>, etc.). Although they are easy to use, these applications cover only a limited number of base services: user management, time configuration, network configuration, printer configuration, and so on.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.debconf">
			<title>Настройка пакетов: <command>debconf</command></title>
			 <indexterm>
				<primary><command>debconf</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>dpkg-reconfigure</command></primary>
			</indexterm>
			 <para>
				Многие пакеты автоматически настраиваются после того, как зададут несколько вопросов с помощью Debconf в ходе установки. Эти пакеты можно перенастроить, запустив <command>dpkg-reconfigure <replaceable>пакет</replaceable></command>.
			</para>
			 <para>
				В большинстве случаев эти настройки очень просты; изменяются только некоторые важнейшие переменные конфигурационного файла. Эти переменные нередко содержатся между двумя «пограничными» строками, так что перенастройка пакета влияет только на ограниченную область. В других случаях перенастройка не будет ничего менять, если сценарий обнаружит, что конфигурационный файл был изменён вручную, чтобы сохранить результаты вмешательства человека (поскольку сценарий не может удостовериться, что вносимые им самим изменения не нарушат текущих настроек).
			</para>
			 <sidebar> <title><emphasis>ПОЛИТИКА DEBIAN</emphasis> Сохранение изменений</title>
			 <para>
				Политика Debian явно оговаривает, что необходимо делать всё возможное, чтобы сохранить внесённые вручную изменения в конфигурационных файлах. Главный принцип прост: сценарий будет вносить изменения только в том случае, если ему известен статус конфигурационного файла, который проверяется путём сверки контрольной суммы файла с той, которая была после того, как файл последний раз менялся автоматически. Если они совпадают, сценарий авторизуется для изменения конфигурационного файла. В противном случае он определяет, что файл был изменён, и спрашивает, какое действие ему следует предпринять (установить новый файл, сохранить старый файл или попытаться интегрировать изменения в существующий файл). Этот предупредительный принцип долгое время был уникален для Debian, но со временем и другие дистрибутивы стали перенимать его.
			</para>
			 <para>
				Для реализации такого поведения можно использовать программу <command>usf</command> (из одноимённого пакета Debian).
			</para>
			 <indexterm>
				<primary><command>ucf</command></primary>
			</indexterm>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.syslog">
		<title>Системные события <command>syslog</command></title>
		 <indexterm>
			<primary><command>rsyslogd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>файлы</primary>
			<secondary>журналов</secondary>
		</indexterm>
		 <indexterm>
			<primary>журналы</primary>
			<secondary>управление</secondary>
		</indexterm>
		 <section id="sect.syslog-principe">
			<title>Принципы и механизм</title>
			 <para>
				Демон <command>rsyslogd</command> отвечает за сбор служебных сообщений от приложений и ядра и дальнейшее распределение их по файлам журналов (обычно хранящимся в каталоге <filename>/var/log/</filename>). Он управляется конфигурационным файлом <filename>/etc/rsyslog.conf</filename>.
			</para>
			 <para>
				Каждое сообщение в журнале соответствует подсистеме приложений (в документации называемой «facility»):
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>auth</literal> и <literal>authpriv</literal>: для аутентификации;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>cron</literal>: от сервисов планировки заданий, <command>cron</command> и <command>atd</command>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>daemon</literal>: относится к демонам, не выделенным в особую группу (DNS, NTP и т. д.);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ftp</literal>: относится к FTP-серверу;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>kern</literal>: сообщение от ядра;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>lpr</literal>: от подсистемы печати;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>mail</literal>: от подсистемы электронной почты;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>news</literal>: сообщение подсистемы Usenet (в частности от сервера NNTP — Network News Transfer Protocol — управляющего новостными группами);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>syslog</literal>: сообщения от самого сервера <command>syslogd</command>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>user</literal>: пользовательские сообщения (основные);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uucp</literal>: сообщения от сервера UUCP (Unix to Unix Copy Program, старый протокол, широко использовавшийся для распространения сообщений электронной почты);
					</para>

				</listitem>
				 <listitem>
					<para>
						с <literal>local0</literal> по <literal>local7</literal>: зарезервированы для локального использования.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Каждому сообщению также присваивается уровень приоритета. Вот их список в порядке убывания:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>emerg</literal>: “Help!” There is an emergency, the system is probably unusable.
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>alert</literal>: поспешите, промедление небезопасно, нужно срочно принимать меры;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>crit</literal>: условия критические;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>err</literal>: ошибка;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>warn</literal>: предупреждение (возможная ошибка);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>notice</literal>: условия нормальные, но сообщение важное;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>info</literal>: информационное сообщение;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>debug</literal>: сообщение для отладки.
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section id="sect.syslog-config">
			<title>Конфигурационный файл</title>
			 <para>
				Синтаксис файла <filename>/etc/rsyslog.conf</filename> описан на странице руководства <citerefentry><refentrytitle>rsyslog.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>, но также есть и документация в формате HTML, доступная в пакете <emphasis role="pkg">rsyslog-doc</emphasis> (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). Общий принцип состоит в написании пар «селектор» и «действие». Селектор определяет подмножество сообщений, а действия описывают, что с ними делать.
			</para>
			 <section id="sect.syslog-selector-syntax">
				<title>Синтаксис селектора</title>
				 <para>
					Селектор представляет собой Разделённый точками с запятой список пар <literal><replaceable>подсистема</replaceable>.<replaceable>приоритет</replaceable></literal> (пример: <literal>auth.notice;mail.info</literal>). Звёздочка может означать все подсистемы или все приоритеты (примеры: <literal>*.alert</literal> или <literal>mail.*</literal>). Несколько подсистем можно сгруппировать, разделяя их запятой (пример: <literal>auth,mail.info</literal>). Указанный приоритет подразумевает сообщения того же или более высокого уровня; так, <literal>auth.alert</literal> соответствует сообщениям подсистемы <literal>auth</literal> с приоритетом <literal>alert</literal> или <literal>emerg</literal>. Если в начале стоит восклицательный знак, такая запись означает прямо противоположное, то есть строго более низкие приоритеты; <literal>auth.!notice</literal>, таким образом, означает сообщения от <literal>auth</literal> с приоритетом <literal>info</literal> или <literal>debug</literal>. Если в начале стоит знак равенства, такая запись означает точное соответствие указанному приоритету и только ему (<literal>auth.=notice</literal> соответствует сообщениям от <literal>auth</literal> с приоритетом <literal>notice</literal>).
				</para>
				 <para>
					Каждый элемент в списке селектора переписывает предыдущие элементы. Благодаря этому возможно ограничить выборку или исключить из неё некоторые элементы. Например, <literal>kern.info;kern.!err</literal> означает сообщения от ядра с приоритетом между <literal>info</literal> и <literal>warn</literal>. Приоритет <literal>none</literal> указывает на пустую выборку (нет приоритетов) и может использоваться для исключения подсистемы из выборки сообщений. Так, <literal>*.crit;kern.none</literal> означает все сообщения с приоритетом, равным или более высоким, чем <literal>crit</literal>, исходящим не от ядра.
				</para>

			</section>
			 <section id="sect.syslog-action-syntax">
				<title>Синтаксис действий</title>
				 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Именованный канал — постоянный канал</title>
				 <indexterm>
					<primary>именованный канал</primary>
				</indexterm>
				 <indexterm>
					<primary>канал, именованный</primary>
				</indexterm>
				 <para>
					Именованный канал — это специальный тип файла, работающий как обычный канал (канал, который создаётся с помощью символа «|» в командной строке), но через файл. Преимущество этого механизма заключается в возможности связи между двумя не взаимосвязанными процессами. Запись чего бы то ни было в именованный канал блокирует записывающий процесс до тех пор, пока другой процесс не попытается прочитать записанные данные. Этот второй процесс читает данные, записанные первым, которые после этого может продолжить работу.
				</para>
				 <para>
					Такой файл создаётся с помощью команды <command>mkfifo</command>.
				</para>
				 </sidebar> <para>
					В число возможных действий входят:
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							добавление сообщения в файл (пример: <filename>/var/log/messages</filename>);
						</para>

					</listitem>
					 <listitem>
						<para>
							отправка сообщения удалённому серверу <command>syslog</command> (пример: <literal>@log.falcot.com</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							отправка сообщения в существующий именованный канал (пример: <literal>|/dev/xconsole</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							отправка сообщения одному или нескольким пользователям, если они вошли в систему (пример: <literal>root,rhertzog</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							отправка сообщения всем пользователям в системе (пример: <literal>*</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							вывод сообщения в текстовую консоль (пример: <literal>/dev/tty8</literal>).
						</para>

					</listitem>

				</itemizedlist>
				 <sidebar> <title><emphasis>БЕЗОПАСНОСТЬ</emphasis> Пересылка журналов</title>
				 <indexterm>
					<primary>журнал</primary>
					<secondary>пересылка</secondary>
				</indexterm>
				 <para>
					Хорошей идеей будет записывать наиболее важные журналы на отдельной машине (возможно, специально выделенной для этой цели), поскольку это не позволит возможному взломщику удалить следы своего проникновения (если, конечно, он также не скомпроментировал и этот другой сервер). Кроме того, в случае большой проблемы (такой как сбой ядра) журналы будут доступны на другой машине, что повышает шансы на выявление последовательности событий, приведших к сбою.
				</para>
				 <para>
					Чтобы принимать сообщения журнала, посылаемые другими машинами, нужно перенастроить <emphasis>rsyslog</emphasis>: нужно только активировать готовые записи в <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> и <literal>$UDPServerRun 514</literal>).
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.inetd">
		<title>Суперсервер <command>inetd</command></title>
		 <para>
			Inetd (часто называемый «Интернет-суперсервером») — это сервер серверов. Он запускает редко используемые серверы по требованию, так что им не приходится работать постоянно.
		</para>
		 <indexterm>
			<primary><command>inetd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>суперсервер</primary>
		</indexterm>
		 <para>
			В файле <filename>/etc/inetd.conf</filename> перечисляются эти серверы и обычно используемые ими порты. Команда <command>inetd</command> слушает их все; когда она обнаруживает соединение с любым таким портом, она запускает соответствующую серверную программу.
		</para>
		 <sidebar> <title><emphasis>ПОЛИТИКА DEBIAN</emphasis> Регистрация сервера в <filename>inetd.conf</filename></title>
		 <para>
			Packages frequently want to register a new server in the <filename>/etc/inetd.conf</filename> file, but Debian Policy prohibits any package from modifying a configuration file that it doesn't own. This is why the <command>update-inetd</command> script (in the package with the same name) was created: It manages the configuration file, and other packages can thus use it to register a new server to the super-server's configuration.
		</para>
		 </sidebar> <para>
			Каждая значащая строка файла <filename>/etc/inetd.conf</filename> описывает сервер в сми полях (разделённых пробелами):
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					Номер порта TCP или UDP или имя сервиса (которое преобразуется в стандартный номер порта с помощью информации, содержащейся в файле <filename>/etc/services</filename>).
				</para>

			</listitem>
			 <listitem>
				<para>
					Тип сокета: <literal>stream</literal> для TCP-соединения, <literal>dgram</literal> для UDP-датаграмм.
				</para>

			</listitem>
			 <listitem>
				<para>
					Протокол: <literal>tcp</literal> или <literal>udp</literal>.
				</para>

			</listitem>
			 <listitem>
				<para>
					Опции: два возможных значения — <literal>wait</literal> или <literal>nowait</literal>, сообщающих <command>inetd</command>, следует ли ждать завершения запущенного процесса прежде чем принимать новое соединение. Для TCP-соединений, которые легко мультиплексируются, обычно можно использовать <literal>nowait</literal>. Для программ, отвечающих через UDP, следует использовать <literal>nowait</literal> только если сервер способен управляться с несколькими соединениями параллельно. В конце этой опции можно добавить точку, и после неё указать максимально разрешённое число сединений в минуту (по умолчанию используется ограничение в 256 соединений).
				</para>

			</listitem>
			 <listitem>
				<para>
					Имя пользователя, от имени которого будет запускаться сервер.
				</para>

			</listitem>
			 <listitem>
				<para>
					Полный путь к серверной программе, которую нужно запустить.
				</para>

			</listitem>
			 <listitem>
				<para>
					Аргументы: полный список аргументов программы, включая её собственное имя ((<literal>argv[0]</literal> в Си).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Следующий пример иллюстрирует наиболее распространённые случаи:
		</para>
		 <example id="example.inetd-conf">
			<title>Выдержка из <filename>/etc/inetd.conf</filename></title>
			 
<programlisting>talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd
finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd
ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i</programlisting>

		</example>
		 <indexterm>
			<primary><command>tcpd</command></primary>
		</indexterm>
		 <para>
			Программа <command>tcpd</command> часто используется в файле <filename>/etc/inetd.conf</filename>. Она позволяет ограничить входящие сообщения, применяя правила контроля доступа, описанные на странице руководства <citerefentry><refentrytitle>hosts_access</refentrytitle>
			<manvolnum>5</manvolnum></citerefentry> и настраиваемые в файлах <filename>/etc/hosts.allow</filename> и <filename>/etc/hosts.deny</filename>. Когда подтверждается, что соединение разрешено, <command>tcpd</command> запускает настоящий сервер (<command>in.fingerd</command> в нашем примере). Для <command>tcpd</command> ничего не стоит определить, какой сервис следует запустить, по имени, под которым он был вызван (которое является первым аргументом, <literal>argv[0]</literal>). Поэтому список аргументов должен начинаться не с <literal>tcpd</literal>, а с программы, для которой он служит обёрткой.
		</para>
		 <sidebar> <title><emphasis>СООБЩЕСТВО</emphasis> Виетс Венема</title>
		 <indexterm>
			<primary>Виетс Венема</primary>
		</indexterm>
		 <indexterm>
			<primary>Венема, Виетс</primary>
		</indexterm>
		 <para>
			Виетс Венема, чья компетенция в области безопасности сделала его известным программистом, является автором программы <command>tcpd</command>. Он также и главный разработчик Postfix, модульного сервера электронной почты (SMTP, Simple Mail Transfer Protocol), спроектированного так, чтобы быть более безопасным и надёжным, чем <command>sendmail</command>, имевший долгую историю уязвимостей.
		</para>
		 </sidebar> <sidebar> <title><emphasis>АЛЬТЕРНАТИВА</emphasis> Другие команды <command>inetd</command></title>
		 <para>
			Хотя по умолчанию в Debian устанавливается <emphasis role="pkg">openbsd-inetd</emphasis>, есть и немало альтернативных решений: упомянем <emphasis role="pkg">inetutils-inetd</emphasis>, <emphasis role="pkg">micro-inetd</emphasis>, <emphasis role="pkg">rlinetd</emphasis> и <emphasis role="pkg">xinetd</emphasis>.
		</para>
		 <para>
			Эта последняя инкарнация суперсервера предоставляет очень интересные возможности. Самой примечательной из них является возможность разбивки конфигурации на несколько файлов (хранящихся, разумеется, в каталоге <filename>/etc/xinetd.d/</filename>), что может облегчить жизнь администратора.
		</para>
		 <para>
			Last but not least, it is even possible to emulate <command>inetd</command>'s behaviour with <command>systemd</command>'s socket-activation mechanism (see <xref linkend="sect.systemd" />).
		</para>
		 </sidebar>
	</section>
	 <section id="sect.task-scheduling-cron-atd">
		<title>Планирование задач с помощью <command>cron</command> и <command>atd</command></title>
		 <indexterm>
			<primary><command>cron</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>atd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>планирование задач</primary>
		</indexterm>
		 <indexterm>
			<primary>задачи, планирование</primary>
		</indexterm>
		 <para>
			<command>cron</command> — это демон, отвечающий за запуск запланированных и повторяющихся команд (каждый день, каждую неделю и т. д.); <command>atd</command> — демон, работающий с командами ,которые должны запускаться однократно, но в конкретный момент времени в будущем.
		</para>
		 <para>
			В системе Unix многие задачи планируются для регулярного запуска:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					ротация журналов;
				</para>

			</listitem>
			 <listitem>
				<para>
					обновление базы данных для программы <command>locate</command>;
				</para>

			</listitem>
			 <listitem>
				<para>
					резервное копирование;
				</para>

			</listitem>
			 <listitem>
				<para>
					сценарии обслуживания (такие как удаление временных файлов).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			По умолчанию все пользователи могут планировать запуск задач. У каждого пользователя есть свой собственный <emphasis>crontab</emphasis>, в который он может записывать запланированные команды. Его можно отредактировать, запустив <command>crontab -e</command> (его содержимое хранится в файле <filename>/var/spool/cron/crontabs/<replaceable>пользователь</replaceable></filename>).
		</para>
		 <sidebar> <title><emphasis>БЕЗОПАСНОСТЬ</emphasis> Ограничение использования <command>cron</command> или <command>atd</command></title>
		 <para>
			Доступ к <command>cron</command> можно ограничить, создав файл авторизации (белый список) в <filename>/etc/cron.allow</filename>, где указываются только пользователи, которым разрешено планировать задачи. Все остальные автоматически будут лишены такой возможности. Наоборот, чтобы заблокировать только одного-двух бедокуров, можно вписать их имена в файл блокировки (чёрный список), <filename>/etc/cron.deny</filename>. Такая же возможность есть и для <command>atd</command>, соответствующие файлы называются <filename>/etc/at.allow</filename> и <filename>/etc/at.deny</filename>.
		</para>
		 </sidebar> <para>
			У пользователя root есть свой собственный <emphasis>crontab</emphasis>, но он также может использовать файл <filename>/etc/crontab</filename> или создавать дополнительные файлы <emphasis>crontab</emphasis> в каталоге <filename>/etc/cron.d</filename>. У последних двух решений есть то преимущество, что можно указать пользователя, от имени которого запускается команда.
		</para>
		 <para>
			Пакет <emphasis>cron</emphasis> по умолчанию содержит некоторые запланированные задачи, которые выполняются:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					программы из каталога <filename>/etc/cron.hourly/</filename> — каждый час;
				</para>

			</listitem>
			 <listitem>
				<para>
					программы из каталога <filename>/etc/cron.daily/</filename> — каждый день;
				</para>

			</listitem>
			 <listitem>
				<para>
					программы из каталога <filename>/etc/cron.weekly/</filename> — каждую неделю;
				</para>

			</listitem>
			 <listitem>
				<para>
					программы из каталога <filename>/etc/cron.monthly/</filename> — раз в месяц.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Многие пакеты Debian зависят от этого сервиса: помещая сценарии обслуживания в эти каталоги, они обеспечивают оптимальную работу своих сервисов.
		</para>
		 <section id="sect.format-crontab">
			<title>Формат файла <filename>crontab</filename></title>
			 <indexterm>
				<primary><filename>crontab</filename></primary>
			</indexterm>
			 <sidebar> <title><emphasis>СОВЕТ</emphasis> Текстовые сокращения для <command>cron</command></title>
			 <para>
				<command>cron</command> распознаёт некоторые сокращения, заменяющие первые пять полей в записи <filename>crontab</filename>. Они соответствуют наиболее классическим опциям планирования:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>@yearly</literal> — раз в год (1 января, в 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@monthly</literal> — раз в месяц (1 числа, в 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@weekly</literal> — раз в неделю (в воскресенье, в 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@daily</literal> — раз в день (в 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@hourly</literal> — раз в час (в начале каждого часа).
					</para>

				</listitem>

			</itemizedlist>
			 </sidebar> <sidebar> <title><emphasis>SPECIAL CASE</emphasis> <command>cron</command> and daylight savings time</title>
			 <para>
				В Debian <command>cron</command> учитывает смену времени (при переходе на летнее время, а фактически — при любом значительном изменении локального времени) лучшим образом, какой только возможен. Так, команды, которые должны были запуститься в течение часа, который никогда не существовал, (например задачи, запланированные на 2:30 утра при весенней смене времени во Франции, когда в 2:00 часы переводятся на 3:00) запускаются вскоре после изменения времени (то есть около 3:00 по летнему времени). С другой стороны, осенью, когда задачи могли бы запуститься дважды (в 2:30 по летнему времени, а потом в 2:30 по обычному времени, поскольку в 3:00 утра летнего времени часы переводятся на 2:00), запускаются только однократно.
			</para>
			 <para>
				Следует, однако, соблюдать осторожность, если порядок запуска разных запланированных задач и величина задержки между ними имеют значение. В таком случае следует проверить совместимость этих ограничений с поведением <command>cron</command>; при необходимости можно подготовить специальное расписание для двух проблемных ночей в году.
			</para>
			 </sidebar> <para>
				Каждая значащая строка <emphasis>crontab</emphasis> описывает запланированную команду в следующих шести (или семи) полях:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						значение минуты (число от 0 до 59);
					</para>

				</listitem>
				 <listitem>
					<para>
						значение часа (от 0 до 23);
					</para>

				</listitem>
				 <listitem>
					<para>
						значение числа месяца (от 1 до 31);
					</para>

				</listitem>
				 <listitem>
					<para>
						значение месяца (от 1 до 12);
					</para>

				</listitem>
				 <listitem>
					<para>
						значение дня недели (от 0 до 7, где 1 соответствует понедельнику, а воскресенье может быть представлено как 0 или 7; также можно использовать первые три буквы англоязычного названия дня недели, например <literal>Sun</literal>, <literal>Mon</literal> и т. д.);
					</para>

				</listitem>
				 <listitem>
					<para>
						имя пользователя, от имени которого должна выполняться команда (в файле <filename>/etc/crontab</filename> и в фрагментах, расположенных в <filename>/etc/cron.d/</filename>, но не в пользовательских файлах crontab);
					</para>

				</listitem>
				 <listitem>
					<para>
						команда, которая должна быть запущена (при выполнении условий, определённых в первых пяти колонках).
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Все эти подробности описаны на странице man <citerefentry><refentrytitle>crontab</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry>.
			</para>
			 <para>
				Каждое значение может быть представлено в виде списка возможных значений (разделённого запятыми). Синтаксис <literal>a-b</literal> описывает интервал всех значений между <literal>a</literal> и <literal>b</literal>. Синтаксис <literal>a-b/c</literal> описывает интервал с промежутками <literal>c</literal> (пример: <literal>0-10/2</literal> означает <literal>0,2,4,6,8,10</literal>). Звёздочка <literal>*</literal> является шаблоном, означающим все допустимые значения.
			</para>
			 <example id="example.crontab">
				<title>Пример файла <filename>crontab</filename></title>
				 
<programlisting>#Format
#min hour day mon dow  command

# Download data every night at 7:25 pm
 25  19   *   *   *    $HOME/bin/get.pl

# 8:00 am, on weekdays (Monday through Friday)
 00  08   *   *   1-5  $HOME/bin/dosomething

# Restart the IRC proxy after each reboot
@reboot /usr/bin/dircproxy
</programlisting>

			</example>
			 <sidebar> <title><emphasis>СОВЕТ</emphasis> Запуск команды при загрузке</title>
			 <para>
				Для однократного запуска команды сразу после загрузки компьютера можно использовать макрос <literal>@reboot</literal> (простой перезапуск <command>cron</command> не вызовет команду, запланированную с использованием <literal>@reboot</literal>). Этот макрос заменяет первые пять полей записи <emphasis>crontab</emphasis>.
			</para>
			 </sidebar> <sidebar> <title><emphasis>ALTERNATIVE</emphasis> Emulating <command>cron</command> with <command>systemd</command></title>
			 <para>
				It is possible to emulate part of <command>cron</command>'s behaviour with <command>systemd</command>'s timer mechanism (see <xref linkend="sect.systemd" />).
			</para>
			 </sidebar>
		</section>
		 <section id="sect.at-command">
			<title>Использование команды <command>at</command></title>
			 <indexterm>
				<primary><command>at</command></primary>
			</indexterm>
			 <para>
				The <command>at</command> executes a command at a specified moment in the future. It takes the desired time and date as command-line parameters, and the command to be executed in its standard input. The command will be executed as if it had been entered in the current shell. <command>at</command> even takes care to retain the current environment, in order to reproduce the same conditions when it executes the command. The time is indicated by following the usual conventions: <literal>16:12</literal> or <literal>4:12pm</literal> represents 4:12 pm. The date can be specified in several European and Western formats, including <literal>DD.MM.YY</literal> (<literal>27.07.15</literal> thus representing 27 July 2015), <literal>YYYY-MM-DD</literal> (this same date being expressed as <literal>2015-07-27</literal>), <literal>MM/DD/[CC]YY</literal> (ie., <literal>12/25/15</literal> or <literal>12/25/2015</literal> will be December 25, 2015), or simple <literal>MMDD[CC]YY</literal> (so that <literal>122515</literal> or <literal>12252015</literal> will, likewise, represent December 25, 2015). Without it, the command will be executed as soon as the clock reaches the time indicated (the same day, or tomorrow if that time has already passed on the same day). You can also simply write “today” or “tomorrow”, which is self-explanatory.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>
<computeroutput>&gt; </computeroutput><userinput>echo "Don't forget to wish a Happy Birthday to Raphaël!" \</userinput>
<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>
<computeroutput>&gt; </computeroutput><userinput>END</userinput>
<computeroutput>warning: commands will be executed using /bin/sh
job 31 at Mon Jul 27 09:00:00 2015</computeroutput></screen>
			 <para>
				Альтернативный синтаксис откладывает запуск на заданный промежуток времени: <command>at now + <replaceable>число</replaceable> <replaceable>период</replaceable></command>. Значение <replaceable>период</replaceable> может быть <literal>minutes</literal>, <literal>hours</literal>, <literal>days</literal> или <literal>weeks</literal>. Значение <replaceable>число</replaceable> указывает число указанных единиц, которое должно пройти перед запуском программы.
			</para>
			 <para>
				Для отмены задачи, запланированной <command>cron</command>, нужно просто запустить <command>crontab -e</command> и удалить соответствующую строку в файле <emphasis>crontab</emphasis>. Для задач <command>at</command> это почти так же легко: надо запустить <command>atrm <replaceable>номер-задачи</replaceable></command>. Номер задачи указывается командой <command>at</command> при её планировании, а также её можно найти с помощью команды <command>atq</command>, выводящей текущий список запланированных задач.
			</para>
			 <indexterm>
				<primary><command>atrm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>atq</command></primary>
			</indexterm>

		</section>

	</section>
	 <section id="sect.asynchronous-task-scheduling-anacron">
		<title>Планирование асинхронных задач: <command>anacron</command></title>
		 <para>
			<command>anacron</command> — это демон, дополняющий <command>cron</command> на компьютерах, которые не включены всё время. Поскольку регулярные задачи обычно планируются на середину ночи, они никогда не будут запускаться, если компьютер в это время выключен. Назначение <command>anacron</command> — запустить их, принимая во внимание периоды, в которые компьютер не работает.
		</para>
		 <indexterm>
			<primary><command>anacron</command></primary>
		</indexterm>
		 <para>
			Обратите внимание, что <command>anacron</command> зачастую будет запускать такие действия через несколько минут после загрузки машины, что может привести к ухудшению отзывчивости системы. Поэтому задачи в файле <filename>/etc/anacrontab</filename> запускаются с помощью команды <command>nice</command>, понижающей приоритет их выполнения и тем самым ограничивающей их влияние на остальную систему. Будьте внимательны, формат этого файла отличается от <filename>/etc/crontab</filename>; при необходимости использовать <command>anacron</command> следует ознакомиться со страницей руководства <citerefentry><refentrytitle>anacrontab</refentrytitle>
			 <manvolnum>5</manvolnum></citerefentry>.
		</para>
		 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Приоритеты и <command>nice</command></title>
		 <para>
			Unix-системы (включая Linux) — это многозадачные и многопользовательские системы. Несколько процессов могут работать параллельно и принадлежать разным пользователям: ядро регулирует доступ различных приложений к ресурсам. Для решения этой задачи служит концепция приоритетов, позволяющая при необходимости отдавать предпочтение одним процессам перед другими. Если известно, что процесс можно запустить с низким приоритетом, можно указать это, запустив его с помощью <command>nice <replaceable>программа</replaceable></command>. После этого программа будет получать меньше процессорного времени и оказывать меньшее влияние на другие работающие процессы. Разумеется, если других ожидающих выполнения процессов нет, программа не будет искусственно притормаживаться.
		</para>
		 <para>
			<command>nice</command> работает с разными уровнями «уступчивости»: положительные уровни (с 1 по 19) постепенно понижают приоритет, в то время как отрицательные уровни (от −1 до −20) увеличат его — но такие отрицательные уровни дозволено использовать только root. Если не указано что-либо другое (см. страницу руководства <citerefentry><refentrytitle>nice</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry>), <command>nice</command> повышает текущий уровень на 10.
		</para>
		 <para>
			If you discover that an already running task should have been started with <command>nice</command> it is not too late to fix it; the <command>renice</command> command changes the priority of an already running process, in either direction (but reducing the “niceness” of a process is reserved for the root user).
		</para>
		 </sidebar> <para>
			При установке пакета <emphasis role="pkg">anacron</emphasis> отключается выполнение <command>cron</command> сценариев в каталогах <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename>, и <filename>/etc/cron.monthly/</filename>. Это позволяет избежать их двукратного запуска как <command>anacron</command> так и <command>cron</command>. Команда <command>cron</command> остаётся активной и продолжает обслуживать другие запланированные задания (в частности заданные пользователями).
		</para>

	</section>
	 <section id="sect.quotas">
		<title>Квоты</title>
		 <indexterm>
			<primary>квота</primary>
		</indexterm>
		 <para>
			The quota system allows limiting disk space allocated to a user or group of users. To set it up, you must have a kernel that supports it (compiled with the <varname>CONFIG_QUOTA</varname> option) — as is the case with Debian kernels. The quota management software is found in the <emphasis role="pkg">quota</emphasis> Debian package.
		</para>
		 <para>
			To activate quota in a filesystem, you have to indicate the <literal>usrquota</literal> and <literal>grpquota</literal> options in <filename>/etc/fstab</filename> for the user and group quotas, respectively. Rebooting the computer will then update the quotas in the absence of disk activity (a necessary condition for proper accounting of already used disk space).
		</para>
		 <para>
			команда <command>edquota <replaceable>пользователь</replaceable></command> (или <command>edquota -g <replaceable>группа</replaceable></command>) позволяет изменить лимиты, проверив текущее использование дискового пространства.
		</para>
		 <indexterm>
			<primary><command>edquota</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>УГЛУБЛЯЕМСЯ</emphasis> Определение квот с помощью сценария</title>
		 <indexterm>
			<primary><command>setquota</command></primary>
		</indexterm>
		 <para>
			Программа <command>setquota</command> может использоваться в сценарии для автоматического изменения множества квот. На её странице руководства <citerefentry><refentrytitle>setquota</refentrytitle>
			 <manvolnum>8</manvolnum></citerefentry> подробно описан используемый синтаксис.
		</para>
		 </sidebar> <para>
			Система квот позволяет задать четыре лимита:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					два лимита (называемые «мягким» и «жёстким») соответствуют числу используемых блоков. Если файловая система создана с размером блока 1 кибибайт, блок содержит фрагмент файла длиной 1024 байта. Незаполненные блоки поэтому приводят к потере дискового пространства. Квота в 100 блоков, теоретически позволяющая хранить 102.400 байтов, будет исчерпана всего 100 файлами размером по 500 байтов каждый, что составляет в сумме всего 50.000 байтов.
				</para>

			</listitem>
			 <listitem>
				<para>
					два лимита (мягкий и жёсткий) соответствуют числу использованных записей inode. Каждый файл занимает как минимум один inode для хранения информации о себе (разрешения, владелец, временная метка последнего доступа и т. д.). Поэтому фактически это лимит на число файлов пользователя.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			«Мягкий» лимит может быть временно превышен; пользователь просто получит предупреждение о превышении квоты от команды <command>warnquota</command>, обычно вызываемой <command>cron</command>. «Жёсткий» лимит никогда не может быть превышен: система отклонит любую операцию, приводящую к превышению жёсткой квоты.
		</para>
		 <sidebar> <title><emphasis>СЛОВАРЬ</emphasis> Блоки и inode</title>
		 <indexterm>
			<primary>блок (на диске)</primary>
		</indexterm>
		 <indexterm>
			<primary>inode</primary>
		</indexterm>
		 <para>
			Файловая система делит диск на блоки — маленькие неразрывные области. Размер этих областей определяется при создании файловой системы и обычно имеет значение от 1 до 8 кибибайт.
		</para>
		 <para>
			Блок может использоваться или для хранения данных файла, или для хранения метаданных, используемых файловой системой. Среди этих метаданных особо выделяются inode. Inode занимает блок на жёстком диске (но этот блок не учитывается квотой на блоки, только квотой на inode) и содержит информацию о соответствующем файле (имя, владелец, разрешения и т. д.) и указатели на занятые блоки данных. Для очень больших файлов, занимающих слишком большое число блоков, чтобы на них можно было сослаться из одного inode, существует непрямая система блоков; inode ссылается на список блоков, которые содержат не сами данные, а другой список блоков.
		</para>
		 </sidebar> <indexterm>
			<primary><command>warnquota</command></primary>
		</indexterm>
		 <para>
			С помощью команды <command>edquota -t</command> можно определить максимально дозволенный «кредитный период», в течение которого может быть превышен мягкий лимит. По истечении этого периода мягкий лимит будет обрабатываться как жёсткий, и пользователю нужно будет уменьшить использование дискового пространства в соответствии с этим лимитом, чтобы получить возможность записи чего бы то ни было на жёсткий диск.
		</para>
		 <sidebar> <title><emphasis>УГЛУБЛЯЕМСЯ</emphasis> Установка квоты по умолчанию для новых пользователей</title>
		 <para>
			Чтобы автоматически устанавливать квоту для новых пользователей, нужно настроить шаблонного пользователя (с помощью <command>edquota</command> или <command>setquota</command>) и указать его имя пользователя в переменной <varname>QUOTAUSER</varname> в файле <filename>/etc/adduser.conf</filename>. Эта настройка квоты будет автоматически применяться ко всем новым пользователям, созданным с помощью команды <command>adduser</command>.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.backup">
		<title>Резервное копирование</title>
		 <para>
			Создание резервных копий — одна из основных обязанностей любого администратора, но это сложная задача, для которой используются мощные инструменты, которыми подчас непросто овладеть.
		</para>
		 <indexterm>
			<primary>резервное копирование</primary>
		</indexterm>
		 <indexterm>
			<primary>восстановление</primary>
		</indexterm>
		 <para>
			Существует множество программ, таких как <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. Это клиент-серверные системы, имеющие много опций, настройка которых довольно сложна. Некоторые из них предоставляют дружественный веб-интерфейс, чтобы компенсировать это. Но в Debian есть десятки других программ для резервного копирования на все возможные случаи, в чём можно легко убедиться с помощью <command>apt-cache search backup</command>.
		</para>
		 <indexterm>
			<primary><command>amanda</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>bacula</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>BackupPC</command></primary>
		</indexterm>
		 <para>
			Вместо того, чтобы описывать некоторые из них, в этом разделе будут приведены рассуждения администраторов Falcot Corp при определении ими стратегии резервного копирования.
		</para>
		 <para>
			В Falcot Corp резервные копии нужны для двух целей: восстановления ошибочно удалённых файлов и быстрого восстановления любого компьютера (сервера или рабочей станции) после отказа жёсткого диска.
		</para>
		 <section>
			<title>Резервное копирование с помощью <command>rsync</command></title>
			 <para>
				Поскольку резервные копии на магнитной ленте сочли слишком медленными и дорогими, данные будут сохраняться на жёстких дисках на выделенном сервере, на котором использование программного RAID (см. <xref linkend="sect.raid-soft" />) защитит данные от сбоя диска. Резервные копии отдельных настольных компьютеров не делаются, но пользователи извещены, что будет выполняться резервное копирование их учётных записей на файловом сервере их отдела. Команда <command>rsync</command> ежедневно используется для резервного копирования этих серверов.
			</para>
			 <indexterm>
				<primary><command>rsync</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>К ОСНОВАМ</emphasis> Жёсткая ссылка, второе имя файла</title>
			 <indexterm>
				<primary>ссылка</primary>
				<secondary>жёсткая ссылка</secondary>
			</indexterm>
			 <indexterm>
				<primary>жёсткая ссылка</primary>
			</indexterm>
			 <para>
				A hard link, as opposed to a symbolic link, cannot be differentiated from the linked file. Creating a hard link is essentially the same as giving an existing file a second name. This is why the deletion of a hard link only removes one of the names associated with the file. As long as another name is still assigned to the file, the data therein remain present on the filesystem. It is interesting to note that, unlike a copy, the hard link does not take up additional space on the hard drive.
			</para>
			 <para>
				Жёсткая ссылка создаётся командой <command>ln <replaceable>цель</replaceable> <replaceable>ссылка</replaceable></command>. Файл <replaceable>ссылка</replaceable> станет новым именем для файла <replaceable>target</replaceable>. Жёсткие ссылки можно создавать только в пределах одной файловой системы, в то время как на символьные ссылки это ограничение не распространяется.
			</para>
			 </sidebar> <para>
				Доступное дисковое пространство не позволяет реализовать полное ежедневное резервное копирование. Поэтому команде <command>rsync</command> предшествует дублирование содержимого предыдущей резервной копии с помощью жёстких ссылок, что предупреждает использование слишком большого дискового пространства. Процесс <command>rsync</command> затем заменяет только те файлы, которые были изменены с момента создания предыдущей копии. С помощью этого механизма огромное число резервных копий можно хранить на небольшом пространстве. Поскольку все резервные копии немедленно становятся доступными (например в разных каталогах на сетевом ресурсе), можно быстро выполнять сравнения между двумя заданными датами.
			</para>
			 <indexterm>
				<primary>копия, резервная копия</primary>
			</indexterm>
			 <indexterm>
				<primary>резервная копия</primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">dirvish</emphasis></primary>
			</indexterm>
			 <para>
				Этот механизм резервного копирования легко реализуется с помощью программы <command>dirvish</command>. Она использует хранилище резервных копий («bank» — «банк» — в её терминологии), в котором размещает копии наборов файлов резервных копий с временными метками (в документации dirvish эти наборы называются «vaults» — «подвалы»).
			</para>
			 <para>
				Основные настройки хранятся в файле <filename>/etc/dirvish/master.conf</filename>. Он определяет местоположение пространства для резервных копий, список управляемых «подвалов» и значения сроков хранения резервных копий по умолчанию. Остальные настройки находятся в файлах <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> и содержат конфигурацию соответствующего набора файлов.
			</para>
			 <example id="example.dirvish-master">
				<title>Файл <filename>/etc/dirvish/master.conf</filename></title>
				 
<programlisting>bank:
    /backup
exclude:
    lost+found/
    core
    *~
Runall:
    root    22:00
expire-default: +15 days
expire-rule:
#   MIN HR    DOM MON       DOW  STRFTIME_FMT
    *   *     *   *         1    +3 months
    *   *     1-7 *         1    +1 year
    *   *     1-7 1,4,7,10  1
</programlisting>

			</example>
			 <para>
				В настройке <literal>bank</literal> указывается каталог, в котором хранятся резервные копии. Настройка <literal>exclude</literal> позволяет указать файлы (или типы файлов), которые не должны включаться в резервную копию. <literal>Runall</literal> — это список наборов файлов для резервного копирования с временной меткой для каждого набора, что позволяет установить корректную дату копии, если резервное копирование ну запускается периодически в определённое время. Нужно указать время, непосредственно предшествующее времени запуска (по умолчанию в Debian это 22:04, в соответствии с файлом <filename>/etc/cron.d/dirvish</filename>). Наконец, настройки <literal>expire-default</literal> и <literal>expire-rule</literal> определяют политику хранения резервных копий. В приведённом выше примере резервные копии, созданные в первое воскресенье каждого квартала, хранятся вечно, созданные в первое воскресенье каждого месяца — удаляются через год, а созданные в другие воскресенья — через 3 месяца. Прочие ежедневные резервные копии хранятся 15 дней. Порядок правил имеет значение: Dirvish применяет последнее подходящее правило или <literal>expire-default</literal>, если ни одно из других правил <literal>expire-rule</literal> не подходит.
			</para>
			 <sidebar> <title><emphasis>НА ПРАКТИКЕ</emphasis> Запланированное истечение сроков хранения</title>
			 <para>
				Правила хранения не используются <command>dirvish-expire</command> для выполнения её работы. На самом деле эти правила применяются при создании новой резервной копии, чтобы определить дату истечения срока хранения, ассоциированную с этой копией. <command>dirvish-expire</command> просто просматривает сохранённые копии и удаляет те, для которых эта дата прошла.
			</para>
			 </sidebar> <example id="example.dirvish-vault">
				<title>Файл <filename>/backup/root/dirvish/default.conf</filename></title>
				 
<programlisting>client: rivendell.falcot.com
tree: /
xdev: 1
index: gzip
image-default: %Y%m%d
exclude:
    /var/cache/apt/archives/*.deb
    /var/cache/man/**
    /tmp/**
    /var/tmp/**
    *.bak
</programlisting>

			</example>
			 <para>
				В вышеприведённом примере определяется набор файлов для резервного копирования: это файлы на машине <emphasis>rivendell.falcot.com</emphasis> (для копирования локальных данных нужно просто указать имя локальной машины в том виде, как оно отображается командой <command>hostname</command>), а именно файлы корневого каталога (<literal>tree: /</literal>) за исключением тех, которые перечислены в <literal>exclude</literal>. Резервная копия будет ограничена содержимым одной файловой системы (<literal>xdev: 1</literal>). В неё не войдут файлы из других точек монтирования. Будет создан индекс сохранённых файлов (<literal>index: gzip</literal>), и имя образа будет соответствовать текущей дате (<literal>image-default: %Y%m%d</literal>).
			</para>
			 <para>
				Существует множество других опций, и все они описаны на странице руководства <citerefentry><refentrytitle>dirvish.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>. Когда конфигурационные файлы подготовлены, необходимо инициализировать каждый набор файлов с помощью команды <command>dirvish --vault <replaceable>vault</replaceable> --init</command>.После этого при ежедневном вызове <command>dirvish-runall</command> будет автоматически создаваться новая резервная копия после удаления устаревшей.
			</para>
			 <sidebar> <title><emphasis>НА ПРАКТИКЕ</emphasis> Удалённое резервное копирование через SSH</title>
			 <para>
				Когда dirvish требуется сохранить данные на удалённой машине, он использует <command>ssh</command> для подключения к ней, и запускает <command>rsync</command> как сервер. Для этого необходимо, чтобы пользователь root мог автоматически подключиться к ней. Использование ключа аутентификации SSH позволяет сделать именно это (см. <xref linkend="sect.ssh-key-based-auth" />).
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>Восстановление машин без резервных копий</title>
			 <para>
				На настольных компьютерах, резервное копирование которых не выполняется, будет легко переустановить программное обеспечение со специальных DVD-ROM, подготовленных с помощью <emphasis>Simple-CDD</emphasis> (см. <xref linkend="sect.simple-cdd" />). Поскольку при этом происходит установка с нуля, все настройки, которые могли быть сделаны после предыдущей установки, теряются. Это не страшно, поскольку все системы привязаны к центральному каталогу LDAP с учётными записями, и большая часть настольных приложений предварительно настроены благодаря dconf (более подробно об этом см. в <xref linkend="sect.gnome-desktop" />).
			</para>
			 <para>
				Администраторы Falcot Corp осознают ограничения своей политики резервного копирования. Поскольку они не могут защитить сервер резервных копий так же хорошо, как магнитную ленту в несгораемом шкафу, они установили его в отдельной комнате, чтобы стихийное бедствие, такое как пожар в серверной комнате, не уничтожило резервные копии вместе со всем остальным. Кроме того, они делают инкрементальные резервные копии на DVD-ROM раз в неделю — туда включаются только те файлы, которые были изменены со времени предыдущего резервного копирования.
			</para>
			 <sidebar> <title><emphasis>УГЛУБЛЯЕМСЯ</emphasis> Резервное копирование сервисов SQL и LDAP</title>
			 <para>
				Many services (such as SQL or LDAP databases) cannot be backed up by simply copying their files (unless they are properly interrupted during creation of the backups, which is frequently problematic, since they are intended to be available at all times). As such, it is necessary to use an “export” mechanism to create a “data dump” that can be safely backed up. These are often quite large, but they compress well. To reduce the storage space required, you will only store a complete text file per week, and a <command>diff</command> each day, which is created with a command of the type <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command>. The <command>xdelta</command> program produces incremental differences from binary dumps.
			</para>
			 <indexterm>
				<primary><command>xdelta</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>diff</command></primary>
			</indexterm>
			 <indexterm>
				<primary>дамп</primary>
			</indexterm>
			 </sidebar> <sidebar> <title><emphasis>КУЛЬТУРА</emphasis> <emphasis>TAR</emphasis>, стандарт резервных копий на плёнке</title>
			 <indexterm>
				<primary>резервное копирование</primary>
				<secondary>на плёнке</secondary>
			</indexterm>
			 <indexterm>
				<primary>плёнка, резервное копирование</primary>
			</indexterm>
			 <indexterm>
				<primary>TAR</primary>
			</indexterm>
			 <para>
				Исторически самым простым способом создания резервных копий в Unix было сохранение архива <emphasis>TAR</emphasis> на плёнке. Команда <command>tar</command> даже получила своё название от «Tape ARchive» — «плёночный архив».
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.hotplug">
		<title>Горячее подключение: <emphasis>hotplug</emphasis></title>
		 <section>
			<title>Введение</title>
			 <para>
				Подсистема ядра <emphasis>hotplug</emphasis> динамически обрабатывает подключение и отключение устройств, загружая соответствующие драйверы и создавая файлы устройств (с помощью <command>udevd</command>). С современным оборудованием и виртуализацией можно подключать «на лету» почти всё: от обычных периферийных устройств USB/PCMCIA/IEEE 1394 до жёстких дисков SATA, и даже процессоров и памяти.
			</para>
			 <para>
				У ядра есть база данных для сопоставления идентификатора каждого устройства необходимому драйверу. Эта база данных используется при загрузке для подключения драйверов всех периферийных устройств, обнаруженных на разных шинах, а также при горячем подключении дополнительного устройства. Когда устройство готово к использованию, отправляется сообщение <command>udevd</command>, чтобы он создал соответствующую запись в <filename>/dev/</filename>.
			</para>
			 <indexterm>
				<primary><emphasis>hotplug</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>hotplug</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>PCMCIA</primary>
			</indexterm>
			 <indexterm>
				<primary>SATA</primary>
			</indexterm>

		</section>
		 <section>
			<title>Проблема именования</title>
			 <para>
				До появления горячих подключений было очень просто присвоить устройству фиксированное имя. Оно основывалось просто на расположении устройств на их шине. Но это невозможно, когда такие устройства могут появиться и начать использовать шину. Типичным случаем является использование цифрового фотоаппарата или USB-брелока, которые представляются компьютеру как жёсткие диски. Первый подключённый может стать <filename>/dev/sdb</filename>, а второй — <filename>/dev/sdc</filename> (если <filename>/dev/sda</filename> представляет собой локальный жёсткий диск компьютера). Имя устройства не фиксировано; оно зависит от порядка, в котором устройства подключаются.
			</para>
			 <para>
				Кроме того, всё больше устройств используют динамические значения своих старшего и младшего номеров, из-за чего становится невозможным использовать для данных устройств статические записи, ведь эти важнейшие характеристики могут меняться после перезагрузки.
			</para>
			 <para>
				<emphasis>udev</emphasis> был создан специально для решения этой проблемы.
			</para>
			 <sidebar> <title><emphasis>НА ПРАКТИКЕ</emphasis> Управление сетевыми картами</title>
			 <para>
				Many computers have multiple network cards (sometimes two wired interfaces and a wifi interface), and with <emphasis>hotplug</emphasis> support on most bus types, the Linux kernel does not guarantee fixed naming of network interfaces. But users who want to configure their network in <filename>/etc/network/interfaces</filename> need a fixed name!
			</para>
			 <para>
				Было бы сложно просить каждого пользователя создавать свои собственные правила <emphasis>udev</emphasis> для решения этой проблемы. Поэтому <emphasis>udev</emphasis> был настроен более своеобразным образом; при первой загрузке (и, в более общем случае, при появлении новой сетевой карты) он использует имя сетевой карты и её MAC-адрес, чтобы создать новые правила, которые будут вновь присваивать то же имя при последующих загрузках. Эти правила хранятся в <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>.
			</para>
			 <para>
				This mechanism has some side effects that you should know about. Let's consider the case of a computer that has only one PCI network card. The network interface is named <literal>eth0</literal>, logically. Now say the card breaks down, and the administrator replaces it; the new card will have a new MAC address. Since the old card was assigned the name, <literal>eth0</literal>, the new one will be assigned <literal>eth1</literal>, even though the <literal>eth0</literal> card is gone for good (and the network will not be functional because <filename>/etc/network/interfaces</filename> likely configures an <literal>eth0</literal> interface). In this case, it is enough to simply delete the <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> file before rebooting the computer. The new card will then be given the expected <literal>eth0</literal> name.
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>Как работает <emphasis>udev</emphasis></title>
			 <para>
				Когда ядро уведомляет <emphasis>udev</emphasis> о появлении нового устройства, последний собирает различную информацию о данном устройстве из соответствующих записей в <filename>/sys/</filename>, особенно тех, которые позволяют уникально идентифицировать его (MAC-адрес сетевой карты, серийный номер некоторых USB-устройств и т. п.).
			</para>
			 <para>
				Вооружившись этой информацией, <emphasis>udev</emphasis> сверяется со всеми правилами, содержащимися в <filename>/etc/udev/rules.d/</filename> и <filename>/lib/udev/rules.d/</filename>. В ходе этого процесса он принимает решение, какое имя присвоить устройству, какие символьные ссылки создать (чтобы дать альтернативные имена) и какие команды запустить. Проверяются все эти файлы, и все правила выполняются последовательно (если в файлах не используются директивы «GOTO»). Так что может быть несколько правил, соответствующих отдельному событию.
			</para>
			 <para>
				Синтаксис файлов правил довольно прост: каждый ряд содержит критерии выбора и присваивание значений переменным. Первые используются для отбора событий, на которые нужно реагировать, а последние определяют действие, которое нужно предпринять. Они все разделяются запятыми, и оператор используется для того, чтобы косвенным образом отличить критерий выбора (с операторами сравнения, такими как <literal>==</literal> или <literal>!=</literal>) от директивы присваивания (с такими операторами как <literal>=</literal>, <literal>+=</literal> или <literal>:=</literal>).
			</para>
			 <para>
				Операторы сравнения используются со следующими переменными:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>KERNEL</literal> — имя, которое ядро присваивает устройству;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ACTION</literal> — действие, соответствующее событию («add» при добавлении устройства, «remove» при его удалении);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>DEVPATH</literal> — путь к записи устройства в <filename>/sys/</filename>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SUBSYSTEM</literal> — подсистема ядра, от которой пришёл запрос (их много, например «usb», «ide», «net», «firmware» и т. п.);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ATTR{<replaceable>attribute</replaceable>}</literal>: file contents of the <replaceable>attribute</replaceable> file in the <filename>/sys/<replaceable>$devpath</replaceable>/</filename> directory of the device. This is where you find the MAC address and other bus specific identifiers;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> и <literal>ATTRS{<replaceable>атрибуты</replaceable>}</literal> — это вариации, которые пытаются найти соответствие разным опциям одного из устройств, являющихся родительскими по отношению к текущему;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>PROGRAM</literal> — делегирует проверку указанной программе (истина если она возвращает 0, ложь в противном случае). Содержимое стандартного вывода программы сохраняется, так что его можно использовать в проверке <literal>RESULT</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>RESULT</literal> — выполняет проверки стандартного вывода, сохранённого при последнем вызове <literal>PROGRAM</literal>.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				В правых операндах можно использовать шаблонные выражения, соответствующие нескольким значениям одновременно. Например, <literal>*</literal> соответствует любой строке (даже пустой); <literal>?</literal> соответствует любому символу, а <literal>[]</literal> соответствует набору символов, перечисленных внутри квадратных скобок (или наоборот, если первым символом является восклицательный знак, а непрерывные диапазоны символов указываются как <literal>a-z</literal>).
			</para>
			 <para>
				Что касается операторов присваивания, <literal>=</literal> присваивает значение (и заменяет текущее значение); в случае списка он очищается и содержит только присвоенное значение. <literal>:=</literal> делает то же самое, но запрещает изменение переменной в дальнейшем. <literal>+=</literal> добавляет запись в список. Можно изменять следующие переменные:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>NAME</literal> — имя файла устройства, который надлежит создать в <filename>/dev/</filename>. Учитывается только первое присваивание, остальные игнорируются;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SYMLINK</literal> — список символьных ссылок, которые будут указывать на то же устройство;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>OWNER</literal>, <literal>GROUP</literal> и <literal>MODE</literal> определяют пользователя и группу, владеющих устройством, а также назначенные ему разрешения;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>RUN</literal> — список программ, которые должны быть запущены в ответ на событие.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				В значениях, присваиваемых этим переменным, могут использоваться следующие подстановки:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>$kernel</literal> или <literal>%k</literal> — эквивалент <literal>KERNEL</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$number</literal> или <literal>%n</literal> — порядковый номер устройства, например для <literal>sda3</literal> он был бы равен «3»;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$devpath</literal> или <literal>%p</literal> — эквивалент <literal>DEVPATH</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$attr{<replaceable>атрибут</replaceable>}</literal> или <literal>%s{<replaceable>атрибут</replaceable>}</literal> — эквивалент <literal>ATTRS{<replaceable>атрибут</replaceable>}</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$major</literal> или <literal>%M</literal> — старший номер устройства в ядре;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$minor</literal> или <literal>%m</literal> — младший номер устройства в ядре;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$result</literal> или <literal>%c</literal> — строковый вывод последней программы, вызванной <literal>PROGRAM</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						и наконец, <literal>%%</literal> и <literal>$$</literal> означают, соответственно, знак процента и знак доллара.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				The above lists are not complete (they include only the most important parameters), but the <citerefentry><refentrytitle>udev</refentrytitle>
				<manvolnum>7</manvolnum></citerefentry> manual page should be exhaustive.
			</para>

		</section>
		 <section>
			<title>Конкретный пример</title>
			 <para>
				Рассмотрим случай простого USB-брелока и попробуем присвоить ему фиксированное имя. Во-первых, необходимо найти элементы, которые идентифицируют его уникальным образом. Для этого надо подключить его и запустить <command>udevadm info -a -n /dev/sdc</command> (заменив <replaceable>/dev/sdc</replaceable> на действительное имя, присвоенное брелоку).
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>
<computeroutput>[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</computeroutput></screen>
			 <para>
				Чтобы создать новое правило, можно использовать проверки переменных как устройства, так и его родительских устройств. В приведённом примере можно создать два правила вроде этих:
			</para>
			 
<programlisting>KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"</programlisting>
			 <para>
				После того, как эти правила прописаны в файле с именем, например, <filename>/etc/udev/rules.d/010_local.rules</filename>, можно просто отсоединить и заново подключить USB-брелок. После этого можно будет убедиться, что <filename>/dev/usb_key/disk</filename> представляет диск, ассоциированный с USB-брелоком, а <filename>/dev/usb_key/part1</filename> — его первый раздел.
			</para>
			 <sidebar> <title><emphasis>УГЛУБЛЯЕМСЯ</emphasis> Отладка конфигурации <emphasis>udev</emphasis></title>
			 <para>
				Like many daemons, <command>udevd</command> stores logs in <filename>/var/log/daemon.log</filename>. But it is not very verbose by default, and it is usually not enough to understand what is happening. The <command>udevadm control --log-priority=info</command> command increases the verbosity level and solves this problem. <command>udevadm control --log-priority=err</command> returns to the default verbosity level.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.power-management">
		<title>Управление питанием: ACPI</title>
		 <indexterm>
			<primary>управление питанием</primary>
		</indexterm>
		 <indexterm>
			<primary>питание, управление питанием</primary>
		</indexterm>
		 <para>
			Тема управления питанием часто связана с проблемами. Действительно, для корректного перевода компьютера в режим ожидания необходимо, чтобы драйверы всех устройств знали, как переключить их в режим пониженного энергопотребления, и чтобы они корректно перенастроили устройства при возврате в обычный режим. К сожалению, иногда ещё встречаются устройства, неспособные правильно «уснуть» в Linux, поскольку их производители не предоставили необходимых спецификаций.
		</para>
		 <para>
			Linux поддерживает ACPI (<foreignphrase>Advanced Configuration and Power Interface</foreignphrase> — усовершенствованный интерфейс управления конфигурацией и питанием) — самый последний стандарт управления питанием. Пакет <emphasis role="pkg">acpid</emphasis> предоставляет демона, который следит за событиями, связанными с управлением питанием (переключение между питанием от сети и от батареи на ноутбуках и т. п.) и может запускать разные команды в ответ.
		</para>
		 <indexterm>
			<primary>ACPI</primary>
		</indexterm>
		 <indexterm>
			<primary>Advanced Configuration and Power Interface</primary>
		</indexterm>
		 <indexterm>
			<primary><command>acpid</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>ОСТОРОЖНО</emphasis> Видеокарта и режим ожидания</title>
		 <para>
			Драйвер видеокарты часто является виновником некорректной работы режима ошидания. В таком случае хорошей идеей будет проверить последнюю версию графического сервера X.org.
		</para>
		 </sidebar> <para>
			После этого обзора базовых сервисов, общих для многих Unix-систем, мы сосредоточимся на окружении администрируемых машин — на сети. Для её корректной работы необходимо множество сервисов. Они будут обсуждаться в следующей главе.
		</para>

	</section>
</chapter>

