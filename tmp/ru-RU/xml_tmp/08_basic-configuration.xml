<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="basic-configuration">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-basic-configuration.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Конфигурация</keyword>
      <keyword>Локализация</keyword>
      <keyword>Локали</keyword>
      <keyword>Сеть</keyword>
      <keyword>Разрешение имён</keyword>
      <keyword>Пользователи</keyword>
      <keyword>Группы</keyword>
      <keyword>Аккаунты</keyword>
      <keyword>Интерпретатор командной строки</keyword>
      <keyword>Оболочка</keyword>
      <keyword>Печать</keyword>
      <keyword>Загрузчик</keyword>
      <keyword>Компиляция ядра</keyword>
    </keywordset>
  </chapterinfo>
  <title>Базовая конфигурация: Сеть, Аккаунты, Печать...</title>
  <highlights>
    <para>Компьютер с новой инсталляции, созданной с помощью <command>debian-installer</command>в большинстве случаев функционалены, но некоторые службы требуют определённой настройки. Более того, всегда полезно знать как поменять некоторые настройки, которые были сделаны во время установки системы.</para>
  </highlights>

  <para>Данная глава включает в себя все, что можно назвать "базовой настройкой": сеть, язык и локали, пользователи и группы, печать, точки монтирования и т. п.</para>

  <section id="sect.config-language-support">
    <title>Настройка системы для использования с другим языком</title>
    <indexterm><primary>Французская локализация</primary></indexterm>

    <para>Если при установке системы был использован французский язык, он будет в дальнейшем использоваться как язык системы по умолчанию. Однако полезно знать, как можно его поменять при необходимости.</para>

    <sidebar>
      <title><emphasis>ИНСТРУМЕНТ</emphasis> Команда <command>locale</command> отображает текущую настройку - какой язык в настоящее время установлен в системе как основной</title>

      <para>Команда <command>locale</command> отображает суммарно различные параметры конфигурации текущей локали (представление даты, чисел и т. п.) в форме групп стандартных переменных окружения, которые предназначенны для динамического изменения тех настроек.</para>
    </sidebar>

    <section id="sect.default-language">
      <title>Установка языка по умолчанию</title>
      <indexterm><primary>локали</primary></indexterm>
      <indexterm><primary>язык</primary></indexterm>
      <indexterm><primary><command>locale-gen</command></primary></indexterm>

      <para>Локаль представляет собой группу региональных настроек. Они включают в себя не только язык текста, но и формат отображения чисел, дат, времени и денежных сумм, а также алфавитные правила сравнения (чтобы правильно учитывать диакритические знаки). Хотя каждый из этих параметров может быть установлен независимо от остальных, мы обычно используем локаль, которая является согласованным набором значений всех параметров, соответствующих «региону» в самом широком смысле. Локали обычно указаны в форме <literal><replaceable>код-языка</replaceable>_<replaceable>КОД-СТРАНЫ</replaceable></literal>, а иногда с суффиксом, для указания набора символов и кодировки, которые будут использоваться. Это позволяет решить идиоматические или типографские различия между различными регионами с одинаковым языком.</para>

      <sidebar>
        <title><emphasis>КУЛЬТУРА</emphasis> Набор символов (кодировка)</title>
        <indexterm><primary>набор символов</primary></indexterm>
        <indexterm><primary>кодировка</primary></indexterm>
        <indexterm><primary>ISO-8859-1</primary></indexterm>
        <indexterm><primary>ISO-8859-15</primary></indexterm>
        <indexterm><primary>Латиница 1</primary></indexterm>
        <indexterm><primary>Латиница 9</primary></indexterm>

	<para>Исторически сложилось так, что каждый язык имеет связанный «набор символов» (группа известных символов) и предпочтительную «кодировку» (внутреннее представление символов внутри компьютера).</para>

	<para>Наиболее популярные кодировки для языков, созданных на базе латиницы, были ограничены 256 символами, потому что для каждого символа использовался 1 байт. Поскольку 256-ю символами невозможно было охватить все буквы европейских языков, появилась необходимость в других кодировках, так , среди других, появились <emphasis>ISO-8859-1</emphasis> (также известный как «Латиница 1») вплоть до <emphasis>ISO-8859-15</emphasis> (также известный как «Латиница 9»).</para>

	<para>Работа с иностранными языками часто подразумевает регулярное переключение между различными наборами символов и кодировки. Кроме того написание многоязычных документов привели к дальнейшим, почти неразрешимым проблемам. Юникод (супер-каталог почти всех систем письменности из всех языков мира) был создан для решения этой проблемы. Одной из кодировок Юникода UTF-8, сохраняет все 128 символов ASCII (7-битные коды), но по-разному обрабатывает другие символы. Их предваряет конкретная управляющая последовательность из нескольких битов, которая определяет длину символа. Это позволяет кодировать все символы Юникода в последовательность одного или более байтов. Его использование популяризировало то обстоятельство, что это кодировка по умолчанию в XML-документах.</para>
        <indexterm><primary>ASCII</primary></indexterm>
        <indexterm><primary>UTF-8</primary></indexterm>
        <indexterm><primary>Юникод</primary></indexterm>

	<para>Эта кодировка должна использоваться повсеместно и таким образом используется по умолчанию на системах Debian.</para>
      </sidebar>

      <para>Пакет <emphasis role="pkg">locales</emphasis> включает все элементы, необходимые для надлежащего функционирования «локализации» в различных приложениях. Во время установки этот пакет попросит выбрать набор поддерживаемых языков. Этот набор можно изменить в любое время, запустив <command>dpkg-reconfigure locales</command> являясь администратором.</para>

      <para>Первый вопрос приглашает вас выбрать «языки» для поддержки. Выбор всех английских языков (то есть начинающиеся с «<literal>en_</literal>») является разумным выбором. Можно также включить другие языки, если машина будет использоваться иноязычными пользователями. Список языков хранится в файле <filename>/etc/locale.gen</filename>. Можно отредактировать этот файл вручную, но вы должны запустить <command>locale-gen</command> после любых изменений. Это создаст необходимые файлы для добавленных языков и удалит все неиспользуемые файлы.</para>

      <para>Второй вопрос, озаглавленный «Локаль по умолчанию для системной среды», запрашивает языковой стандарт по умолчанию. Для России используйте «<literal>ru_RU.UTF-8</literal>». Рекомендуемый выбор в США является «<literal>en_US.UTF-8</literal>», канадцы предпочитают либо «<literal>en_CA.UTF-8</literal>» или, для французского языка, «<literal>fr_CA.UTF-8</literal>». Файл <filename>/etc/default/locale</filename> будет изменен для хранения результатов выбора. Он будет использоваться для всех пользовательскиз сеансов, PAM будет вводить его содержание в переменную среды <varname>LANG</varname>.</para>
      <indexterm><primary>окружение</primary></indexterm>
      <indexterm><primary>локаль</primary></indexterm>
      <indexterm><primary><varname>LANG</varname></primary></indexterm>

      <sidebar id="sidebar.intro-pam">
        <title><emphasis>ЗА КУЛИСАМИ</emphasis> <filename>/etc/environment</filename> и <filename>/etc/default/locale</filename></title>

	<para>Файл <filename>/etc/environment</filename> предоставляет возможность использовать <command>login</command>, <command>gdm</command> или даже <command>ssh</command> с правильными переменными среды.</para>

	<para>Эти приложения не создают эти переменные напрямую, а используют модуль PAM (<filename>pam_env.so</filename>). PAM (подключаемый модуль аутентификации) —  это модульная библиотека централизации механизмов аутентификации, сессии инициализации и управления паролями. См. <xref linkend="sect.config-pam" /> для примера конфигурации PAM.</para>

	<para>Файл <filename>/etc/default/locale</filename> работает аналогично, но содержит только переменную среды <varname>LANG</varname>. Благодаря такому разделению некоторые пользователи PAM могут наследовать полноценную среду без локализации. Действительно, как правило не рекомендуется запускать серверные программы с включённой локализацией; с другой стороны локализация и региональные параметры рекомендуются для программ, которые открывают сеансы пользователей.</para>
        <indexterm><primary>PAM</primary></indexterm>
        <indexterm><primary><filename>pam_env.so</filename></primary></indexterm>
      </sidebar>
    </section>

    <section id="sect.keyboard-config">
      <title>Настройка клавиатуры</title>
      <indexterm><primary>раскладка клавиатуры</primary></indexterm>
      <indexterm><primary>клавиатура, раскладка</primary></indexterm>

      <para>Даже если раскладка клавиатуры осуществляется по-разному в консоли и в графическом режиме, Debian предлагает единый конфигурационный интерфейс, который работает для обоих режимов: он основан на debconf и реализован в пакете <emphasis role="pkg">keyboard-configuration</emphasis>. Таким образом, команда <command>dpkg-reconfigure keyboard-configuration</command> может использоваться в любое время для смены раскладки клавиатуры.</para>

      <indexterm><primary><emphasis>console-data</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>console-tools</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>keyboard-configuration</emphasis></primary></indexterm>

      <para><indexterm><primary><literal>azerty</literal></primary></indexterm>Сомнения есть в соответствии раскладки физической клавиатуре (стандартная компьютерная клавиатура в США - это “Generic 104 key” - то есть обычная, стандартная), кроме того изменения раскладки (обычно “US”), и расположение клавиши AltGr  (правая Alt). И в завершении обычно возникает вопрос о клавише, используемой как “Compose key”, которая позволяет вводить специальные символы посредством сочетания клавиш. Выполняя последовательно <keycombo action="seq"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> и будет создан специальный символ е-острый(“é”). Все эте сочетания клавиш описаны в файле <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> (или в другом файле, определенном, согласно настоящей локали, и указывать в файле <filename>/usr/share/X11/locale/compose.dir</filename>).</para>
      <indexterm><primary><literal>Compose</literal>, клавиша</primary></indexterm>
      <indexterm><primary><literal>Meta</literal>, клавиша</primary></indexterm>
      <indexterm><primary>клавиша</primary><secondary><literal>Meta</literal></secondary></indexterm>
      <indexterm><primary>клавиша</primary><secondary><literal>Compose</literal></secondary></indexterm>

      <para>Запомните, что клавиатурная конфигурация, описанная здесь для графического режима, затрагивает только раскладку по умолчанию; GNOME и KDE окружающие обстановки, среди других, поддерживают контрольную панель клавиатуры, настраиваемую по своим предпочтениям, что делает возможным каждому пользователю иметь их собственную конфигурацию. Некоторые дополнительные опции относительно поведения некоторых индивидуальных клавиш доступны также в тех контрольных панелях.</para>


    </section>
    <section id="sect.utf8-migration">
      <title>Переход на UTF-8</title>

      <para>Подводя итоги, можем констатировать тот факт, что перекодирование в UTF-8 наконец-то получило долгожданное решение, ранее тормозящееся из-за многочисленных затруднений с совместимостью. Теперь устранены препятствия и помехи для международного обмена и произвольные ограничения на алфавит, который теперь может быть использован в документах. Единственной отрицательной стороной было, что пришлось пройти через довольно затруднительную переходную стадию. Поскольку это еще не является сейчас общемировым стандартом (так как одновременный переход всех компьютеров в мире на UTF-8 не может произойти одномоментно), необходимо все же в настоящее время еще выполнить две операции преобразования: одна - работа по перекодированию содержания файла и другая - тоже с именем файла. К счастью, основная часть самой процедуры перекодирования на UTF-8 уже выполнена и в данный момент мы дискутируем на эту тему в значительной степени для справки.</para>

      <sidebar>
        <title><emphasis>КУЛЬТУРА</emphasis> <foreignphrase>Крокозябры</foreignphrase> и интерпретация ошибок</title>

	<para>Когда текст посылают (или сохраняют) не уведомляя получателя о том, какую кодировку использовал отправитель, получатель не всегда имеет возможность уверенно определить - каким подходящим инстументом ему надо воспользоваться, чтобы понять смысл полученного набора байтов. Первой идеей у вас может возникнуть мысль - получить статистику о расположении значений,  представленных в тексте, но это не всегда дает правильный ответ. Когда система перекодирования текста выбирает для чтения файла кодировку, отличающуюся от той, что использовалась при записи файла, байты будут неверно истолкованы, и вы получите, в лучшем случае, ошибки на некоторых символах, или, в худшем - некий комплект кое-чего неразборчивого.</para>

	<para>Таким образом, если текст на французском при просмотре выглядит нормально, за исключением диакритических знаков и конечно символов, которые появляются для замены комбинации символов, похожие на “Ã©” или Ã¨” или “Ã§”, то в данном случае возможно файл закодирован как UTF-8, но интерпретируется как ISO-8859-1 или ISO-8859-15. Это говорит о том, что локальная система на данном компьютере еще не переведена на UTF-8. В другом случае, вы видите места, помеченные вопросами, взамен диакритических знаков — даже если эти, маркированные вопросами, места возможно и будут перезаписывать и символ, следующий за диакритической буквой — тогда вероятнее всего, ваша система уже настроена на работу с UTF-8 а вам  прислали документ, созданный в Западной кодировке ISO.</para>

	<para>Такого рода случаи относятся к “простым”. И они возникают только в Западной культуре. Это связано с тем, что когда был создан Unicode (и UTF-8), то постарались найти общие точки соприкосновения (совпадения символов) для исторически сложившихся наборов символов (кодировки) для Западных языков, базирующихся на латинском алфавите, что позволило распознавать части текста даже в случаях, когда некоторые символы отсутствуют.</para>

	<para>В более сложных конфигурациях, например в случае, который включает в себя два окружения (среды), согласованные с двумя различными языками, при этом эти языки созданы на базе непохожих алфавитов. В таком варианте вы часто получите комплект нечитаемых результатов — серию абстрактных символов, не имеющих ничего общего друг с другом. Это, главным образом, связано с Азиатскими языками, и обусловленно их многочисленными языками и системами для записи. Японское слово <foreignphrase>mojibake</foreignphrase> (крокозябры) был позаимствован (у них) для описания этого явления. Когда появляется такая ситуация, диагностировать причину становиться сложнее и наипростейшим решением очень часто является принятие решение о переходе на UTF-8 для обоих окружений (сред).</para>
      </sidebar>

      <para>Касательно перекодирования имени файла из одной кодировки в другую - это можно сделать относительно просто. Инструмент (программа) <command>convmv</command> (в пакете с похожим именем) была создана специально для такого случая; это позволит переименовать названия файлов из одной кодировки в другую. Использование этого инструмента относительно просто, но мы рекомендует делать это за два шага - чтобы избежать сюрпризов. Следующий пример иллюстрирует это - окружающая среда на компьютере настроена на UTF-8, и имеются каталоги, чьи имена составлены в кодировке ISO-8859-15, и использование упомянутой выше программы <command>convmv</command> переименует их.</para>

      <screen><computeroutput>$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Ic?nes  ?l?ments graphiques  Textes
$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>Starting a dry run without changes...
mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"   "travail/Icônes"
No changes to your files done. Use --notest to finally rename the files.
$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
Ready!
$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput></screen>

      <para>Для перекодирования содержимого файла, процедура предобразования более сложна и это обусловленно многочисленным разнообразием существующих форматов файлов. Некоторые форматы файлов включают в себя кодирующую информацию. Это облегчает задачу программам, которые используют эту внутреннюю информацию при обработке файлов. В обычном случае этого бывает достаточно, чтобы открыть файлы и пересохранить их, установив в момент сохранения кодировку UTF-8. В других случаях, вы должны указать исходную кодировку при открытии файла (ISO-8859-1 или “Западная”, или ISO-8859-15 or “Западная (Евро)”, в соответствии с формулировками).</para>

      <para>Для простых текстовых файлов, вы можете использовать команду <command>recode</command> (в пакете с похожим именем), которая позволит автоматически перекодировать. Это средство имеет многочисленные опции, так что вы можете поиграть с его поведением. Мы рекомендуем вам консультироваться с документацией, man-страница - <citerefentry> <refentrytitle>recode</refentrytitle> <manvolnum>1</manvolnum> </citerefentry>, или инфо-страница the <citerefentry> <refentrytitle>recode</refentrytitle> </citerefentry> (более полный).</para>
    </section>
  </section>
  <section id="sect.network-config">
    <title>Настройка Сети</title>

    <sidebar id="sidebar.networking-basics">
      <title><emphasis>К ОСНОВАМ</emphasis> Необходимое понятие о сети (Ethernet, IP адрес, подсети, широковещательная рассылка пакетов)</title>
      <indexterm><primary>Ethernet</primary></indexterm>
      <indexterm><primary>10BASE-T</primary></indexterm>
      <indexterm><primary>100BASE-T</primary></indexterm>
      <indexterm><primary>1000BASE-T</primary></indexterm>
      <indexterm><primary>10GBASE-T</primary></indexterm>
      <indexterm><primary>разъем, RJ45</primary></indexterm>
      <indexterm><primary>RJ45 connector</primary></indexterm>

      <para>Большинство современных локальных сетей используют протокол Ethernet, где данные разделяются на небольшие блоки, называемые кадрами и передаются по кабелю - за один раз - один кадр. Скорость передачи данных изменяется от 10 Мб/с для старых карт Ethernet до 10 Гбит/с - в новейших картах (с более распространенными в настоящее время скорость вырастает с 100 Мб/с до 1 Гбит/с). Наиболее широко используемые кабели называются 10BASE-T, 100BASE-T, 1000BASE-T или 10GBASE-T, которые в зависимости от своей пропускной способности могут надежно обеспечить передачу данных (Т означает “витая пара”); эти провода на окончаниях оформляются разъемами RJ45. Имеются и другие типы кабелей, используемых в основном для скорости 1 Гбит/с и выше.</para>

      <indexterm><primary>address, IP address</primary></indexterm>
      <indexterm><primary>IP address</primary></indexterm>

      <para>IP-адрес представляет собой номер, используемый для идентификации сетевого интерфейса на компьютере, на локальной сети или в Интернете. В настоящее время наиболее распространенной версией протокола является IP (IPv4). Номер IP  кодируется в 32 бита, и обычно представляет из себя 4 блока 3-х значных чисел, разделенных точками  (например <literal>192.168.0.1</literal>), значение каждого блока находится в интервале от 0 до 255 (включительно, что соответствует 8-ми битной кодировке). Следующая версия протокола IPv6 расширяет адресное пространство до 128-бит, а сами адреса обычно представляют из себя последовательность из шестнадцатеричных чисел, разделенные на колонки через двоеточие (например,  2001:0db8:13bb:0002:0000:0000:0000:0020, или 2001:db8:13bb:2::20 для краткости).</para>

      <indexterm><primary>subnet</primary></indexterm>
      <indexterm><primary>mask</primary><secondary>subnet mask</secondary></indexterm>
      <indexterm><primary>network</primary><secondary>address</secondary></indexterm>

      <para>Маска подсети (netmask) определяется в двоичном коде, у которой адрес IP делится на две части - одна определяет адрес в наружной сети (например интернет), а вторая часть - определяет адрес машины во внутренней (локальной) сети. В примере, приведенном здесь, сконфигурирован статичный адрес IPv4, маска подсети, <literal>255.255.255.0</literal> (24 "1"-к и следом за ними 8 "0"-й в бинарном представлении, то есть 11111111111111111111111100000000) указывает на то, что первые  24 бит статичного IP-адреса соотносятся с адресом в наружной сети (например интернет или, в крупной сети, - надсеть -то есть сеть, рангом повыше), и другие 8 являются специфическими для данной машины. В IPv6, для удобочитаемости, только  количество “1”-к выражено; маска сети для IPv6-сети может, таким образом, быть <literal>64</literal>.</para>

      <para>В IP-адресе, который приведен выше, номером машины является 0. Диапазон сетевых IPv4-адресов в сформированной сети часто синтаксически указывается следующим образом, <emphasis>a.b.c.d/e</emphasis>, в котором <emphasis>a.b.c.d</emphasis> является сетевым адресом и <emphasis>e</emphasis> - количество бит затрагивающие сетевую часть в IP-адресе. Пример сети, таким образом, можно записать: <literal>192.168.0.0/24</literal>. Похожий синтаксис и в IPv6: <literal>2001:db8:13bb:2::/64</literal>.</para>

      <indexterm><primary>маршрутизатор</primary></indexterm>
      <indexterm><primary>bridge</primary></indexterm>

      <para>Маршрутизатор представляет собой устройство, которое соединяет несколько сетей друг с другом. Весь трафик, проходящий через маршрутизатор, направляется в нужную сеть. Для этого, маршрутизатор анализирует входящие пакеты и  перенаправляет их в соответствии с IP-адресом места их конечного назначения. Маршрутизатор часто знают как шлюз; в этой конфигурации, он работает как машина, которая помогает выйти за пределы своей локальной сети (по направлению к расширенной сети, такой как Интернет).</para>

      <indexterm><primary>broadcast</primary></indexterm>

      <para>Специальный широковещательный адрес (broadcast address - xxx.xxx.xxx.255) устанавливает непосредственную связь всех станций в сети. Почти никогда не “направляется по определённому маршруту”, его функции в сети - рассылка компьютерам данной сети дейтаграмм. Следовательно, это значит, что пакеты с данными, адрессованные в этот специальный широковещательный адрес никогда не проходят через маршрутизатор (broadcast address выполняют функцию только внутри сети).</para>

      <para>Данная глава посвящена адресам IPv4, поскольку они сейчас наиболее часто используются. К особенностям протокола IPv6 мы обращаемся в разделе <xref linkend="sect.ipv6" />, но основные принципы остаются теми же.</para>
    </sidebar>

    <para>Поскольку настройка сети выполняется автоматически в процессе первоначальной установки системы на компьютер, файл <filename>/etc/network/interfaces</filename> как правило уже содержит действующую конфигурацию. Линии, начинающиеся с <literal>auto</literal> дают перечень интерфейсов, которые будут автоматически сконфигурированы при запуске системы командой <emphasis role="pkg">ifupdown</emphasis> и следующими инициализирующими скриптами <filename>/etc/init.d/networking</filename>. Это часто будет <literal>eth0</literal>, который считается первой сетевой Ethernet картой.</para>

    <indexterm><primary>network</primary><secondary>configuration</secondary></indexterm>
    <indexterm><primary>configuration</primary><secondary>of the network</secondary></indexterm>
    <indexterm><primary>interface</primary><secondary>network interface</secondary></indexterm>
    <indexterm><primary><literal>eth0</literal></primary></indexterm>

    <sidebar>
      <title><emphasis>АЛЬТЕРНАТИВА</emphasis> Диспетчер сети</title>
      <indexterm><primary><emphasis role="pkg">network-manager</emphasis></primary></indexterm>

      
      <para>Если Диспетчер сети настойчиво рекомендуется в настройках роуминга (see <xref linkend="sect.roaming-network-config" />), то значит данный инстумент отлично подходит по умолчанию для управления сетями. Вы можете сами создать “Системные соединения” и это будет использовано сразу, как только ваш компьютер начнет загружаться после старта (или перегрузки системы). Вы можете сделать настройки вручную в <filename>.ini</filename>-подобном файле, расположенном в <filename>/etc/NetworkManager/system-connections/</filename> или воспользоваться графической оболочкой программы (<command>nm-connection-editor</command>). Только запомните - надо отключить все записи в <filename>/etc/network/interfaces</filename> если вы хотите, чтобы Диспетчер сети сам сделал эти записи (то есть по своему разумению). Ссылки: <ulink type="block" url="https://wiki.gnome.org/Projects/NetworkManager/SystemSettings/jessie" /> <ulink type="block" url="https://developer.gnome.org/NetworkManager/0.9/ref-settings.html" /></para>
    </sidebar>

    <section id="sect.interface-ethernet">
      <title>Интерфейс Ethernet</title>

      <para>Если компьютер имеет Ethernet-карту, IP-сеть, что будет с ней связанна это должно быть настроено выбирая один из двух методов. Простейшим методом является динамическая настройка с DHCP, и это потребует установки DHCP-сервера в локальной сети. Здесь же можно определить имя вашего компьютера, которое будет соответствовать имени <literal>hostname</literal> в примере ниже. Запущенный DHCP-сервер рассылает информацию о том, как настроена сеть, всем компьютерам в локальной сети.</para>

      <indexterm><primary>Ethernet</primary></indexterm>
      <indexterm><primary>DHCP</primary></indexterm>

      <example id="example.config-dhcp">
        <title>Настройка DHCP</title>

        <programlisting>
auto eth0
iface eth0 inet dhcp
   hostname arrakis</programlisting>
      </example>

      <para>В варианте с выбором “статичной” настройкой сети необходимо установить фиксированные значения. Это включает в себя, по меньшей мере, IP-адрес и маску подсети; а также иногда необходимо указать сетевые и широковещательные адреса. Маршрутизатор, соединяющий с внешним миром, будет обозначен как шлюз.</para>

      <example id="example.static-network">
        <title>Настройка статического IP-адреса</title>

        <programlisting>
auto eth0
iface eth0 inet static
 address 192.168.0.3
 netmask 255.255.255.0
 broadcast 192.168.0.255
 network 192.168.0.0
 gateway 192.168.0.1</programlisting>
      </example>

      <sidebar>
        <title><emphasis>ЗАМЕТКА</emphasis> Настройка нескольких адресов</title>

	<para>Можно взаимно увязать не только несколько интерфейсов с одной, физически установленной в компьютер, сетевой картой, но также присвоить несколько IP-адресов на одиночный интерфейс. Запомните также, что IP-адрес может соответствовать любому количеству имен через DNS, и что имя также может быть соотнесено с любым количеством пронумерованных IP-адресов.</para>

	<para>Как вы уже наверное догадались, конфигурация сети может быть достаточно сложной, но те опции обычно испльзуются только в очень специфичных случаях. Примеры, приведенные здесь, характерны для обычных конфигураций.</para>
      </sidebar>
    </section>
    <section id="sect.ppp-rtc">
      <title>Подключение с PPP через PSTN-модем</title>
      <indexterm><primary>PPP</primary></indexterm>
      <indexterm><primary>point to point</primary></indexterm>
      <indexterm><primary>connection</primary><secondary>by PSTN modem</secondary></indexterm>
      <indexterm><primary>modem</primary><secondary>PSTN</secondary></indexterm>

      <para>При использовании протокола точка-точка (PPP) устанавливается постоянное соединение с передачей сигналов прерывистым методом; этот вариант является наиболее общим решением для соединения, основанного на телефонном модеме (“PSTN модем”, в данном случае соединение осуществляется поверх телефонной сети общего пользования).</para>

      <para>Для соединия с провайдером через телефонный модем необходимо получить у провайдера account (имя для входа), который включает в себя также номер телефона, фамилию-имя-отчество, пароль, и, иногда необходимо указать - какой протокол проверки подлинности надо использовать. Такого рода соединения настраиваются с применением инструмента  <command>pppconfig</command>, расположенного в Debian пакете с похожим именем. По умолчанию, он устанавливает соединение с именем <literal>provider</literal> (к примеру с именем вашего Интернет-провайдера). Если вы сомневаетесь, какой протокол проверки подлинности надо применить, выбирайте <emphasis>PAP</emphasis>: его применяют большинство Интернет-сервис провайдеров.</para>

      <indexterm><primary><command>pppconfig</command></primary></indexterm>
      <indexterm><primary>PAP</primary></indexterm>

      <para>После настройки, становится возможным подсоединиться используя команду <command>pon</command> (давая ей имя соединения как параметр, когда установленное по умолчанию значение <literal>provider</literal> не подходит). Отключить это соединение можно с командой <command>poff</command>. Указанные две команды могут быть выполнены пользователем администратор (root), или любым другим пользователем, включенным в группу <literal>dip</literal>.</para>

      <indexterm><primary><command>pon</command></primary></indexterm>
      <indexterm><primary><command>poff</command></primary></indexterm>

    </section>
    <section id="sect.adsl">
      <title>Подключение через ADSL модем</title>
      <indexterm><primary>connection</primary><secondary>by ADSL modem</secondary></indexterm>
      <indexterm><primary>modem</primary><secondary>ADSL</secondary></indexterm>
      <indexterm><primary>ADSL, modem</primary></indexterm>

      <para>Общим названием “ADSL модем” обозначают большую группу устройств с очень различными функциями. Модемы, что могут быть запросто использованы с Linux имеют в своем составе интерфейс Ethernet (а не только интерфейс USB). Это направление (развития модемов с интегрированным интерфейсом Ethernet) становится все более популярным. Большинство Интернет провайдеров, оказывающих услуги по предоставлению доступа в интернет по технологии ADSL, предлагают пользователям долгосрочную ссуду или дают в аренду “коробку” с интерфейсом Ethernet. В зависимости от типа модема, параметры их настройки могут изменяться в широком диапазоне.</para>
      <section id="sect.adsl-pppoe">
        <title>Модемы, поддерживающие протокол PPPoE</title>
        <indexterm><primary>PPPOE</primary></indexterm>
        <indexterm><primary><command>pppoeconf</command></primary></indexterm>

	<para>Некоторые Ethernet - модемы работают с протоколом PPPOE (Point to Point Protocol over Ethernet - протокол "точка-точка поверх Интернет"). Инструмент <command>pppoeconf</command> (из пакета с похожим именем) настраивает такое соединение. Для этого, он изменяет файл с настройками провайдера <filename>/etc/ppp/peers/dsl-provider</filename>  и записывает данные для входа (login) в файлы <filename>/etc/ppp/pap-secrets</filename> и <filename>/etc/ppp/chap-secrets</filename>. Мы рекомендуем принять все, предложенные командой, изменения.</para>

	<para>Как только настройка будет закончена, вы можете открыть ADSL-соединение с командой <command>pon dsl-provider</command> или закрыть с <command>poff dsl-provider</command>.</para>
        <indexterm><primary><literal>dsl-provider</literal></primary></indexterm>

        <sidebar>
          <title><emphasis>СОВЕТ</emphasis> Включите команду <command>ppp</command> в автостарт (boot)</title>
          <indexterm><primary><command>systemd</command></primary></indexterm>
          <indexterm><primary><command>init</command></primary></indexterm>

	  <para>PPP соединение поверх ADSL является, по определению, неустойчивым. Поскольку оно обычно не тарифицируется по времени, у пользователя появляется соблазн держать его всегда открытыми. Однако имеется и несколько минусов такого решения. Стандартным решением, чтобы сделать это, является - использовать систему инициализации (init).</para>

          <para>По умолчанию системой инициализации на <emphasis role="distribution">Jessie</emphasis> является <command>systemd</command>. Добавление задачи по автоматическому перезапуску ADSL-соединения выполнить очень просто, создавая “unit file” такой как <filename>/etc/systemd/system/adsl-connection.service</filename>, с содержанием, таким как приведен пример здесь:</para>

<programlisting>[Unit]
Description=ADSL connection

[Service]
Type=forking
ExecStart=/usr/sbin/pppd call dsl-provider
Restart=always

[Install]
WantedBy=multi-user.target</programlisting>

          <para>Как только этот unit file будет определен, его надо будет подключить к системе командой <command>systemctl enable adsl-connection</command>. Этот цикл можно подключить и вручную с командой <command>systemctl start adsl-connection</command>; а также включить его запуск в автостарт при загрузке (boot).</para>

          <para>На системах, не использующих <command>systemd</command> (включая <emphasis role="distribution">Wheezy</emphasis> и более ранние версии Debian), стандартная система инициализации SystemV работает по другому. На таких системах, все, что нужно - это добавить строку, такая как следующая, в конец файла <filename>/etc/inittab</filename>; затем, в любое время соединение может быть разорвано, а <command>init</command> снова переподключит это.</para>

          <programlisting>
adsl:2345:respawn:/usr/sbin/pppd call dsl-provider
</programlisting>

	  <para>Для ADSL соединений, выполняющих автовыключение ежедневно, этот способ сокращает длительность прерывания.</para>
        </sidebar>
      </section>
      <section id="sect.adsl-pptp">
        <title>Модемы, поддерживающие протокол PPTP</title>
        <indexterm><primary>PPTP</primary></indexterm>

	<para>Протокол PPTP (туннельный протокол типа точка-точка - Point-to-Point Tunneling Protocol) был создан компанией Microsoft. Его использование брало свое начало от ADSL, однако очень быстро было заменено на PPPOE. Если вас принуждают использовать этот протокол, то смотрите <xref linkend="sect.pptp" />.</para>
      </section>
      <section id="sect.adsl-dhcp">
        <title>Модемы, поддерживающие протокол DHCP</title>

	<para>Когда модем присоединили к компьютеру через кабель Ethernet (перекрестный кабель - crossover cable), вы выполняете настройку соединения сети через DHCP на компьютере; а модем автоматически настраивается выполнять роль шлюза (gateway) и берет на себя заботу о маршрутизации пакетов (то есть управляет сетевым трафиком между компьютером и Интернет).</para>

        <sidebar>
          <title><emphasis>К ОСНОВАМ</emphasis> Перекрестный (crossover) кабель для прямого соединения Ethernet</title>
          <indexterm><primary>crossover cable</primary></indexterm>

	  <para>Компьютерная сетевая карта ожидает получать данные по конкретным проводам (жилкам) в кабеле, а посылать такие же данные по другим. Когда вы присоединяете компьютер в локальную сеть, вы обычно присоединяете кабель (прямой или перекрестный) в место, расположенное между сетевой картой и повторителем или переключателем. Однако, если вы хотите соединить между собою два компьютера напрямую (без посредников в лице повторителя или переключателя), вы должны направить сигнал, посылаемый одной картой в адрес другой получающей карты, и наоборот. Для этого делают перекрестный кабель, где жилки смещены на другую сторону, для этих целей его и используют.</para>

          <para>Обратите внимание, что это различие стало почти неактуальным в настоящее время, так как современные сетевые карты имеют возможность определять тип использующегося кабеля и подстраиваться под него соответственно, поэтому не удивляйтесь, что оба вида кабеля будут работать в данном месте.</para>
        </sidebar>

	<para>Большинство “ADSL маршрутизаторов”, имеющихся сегодня в продаже, можно использовать точно так же, как используются  такие же ADSL модемы, которые предоставляют пользователям для работы Internet-сервисные провайдеры.</para>
      </section>
    </section>
    <section id="sect.roaming-network-config">
      <title>Автоматическая настройки сети для мобильных пользователей</title>
      <indexterm><primary><emphasis role="pkg">network-manager</emphasis></primary></indexterm>
      <indexterm><primary>network</primary><secondary>roaming configuration</secondary></indexterm>

      <para>Многие инженеры Falcot имеют портативный компьютер, который они используют также и дома, для профессиональных целей. Настройки сетей, к которым подсоединяется в тот или иной момент времени портативный компьютер, разные, в зависимости от местоположения (на работе и дома). Дома это может быть радиосвязь через wifi (защищенная ключом WPA), а на рабочем месте используется проводной широкополосный доступ к сети для увеличения безопасности и повышения производительности.</para>

      <para>Чтобы избежать ручного подсоединения и отсоединения от интерфейса соответствующей сети, администраторы установили пакет  <emphasis role="pkg">network-manager</emphasis> (диспетчер связи) на те машины, которые осуществляют маршрутизацию. Это программное обеспечение позволяет пользователям быстро переключаться из одной сети в другую используя маленькую иконку, показанную в области уведомлений у них на графическом столе. Нажав на эту иконку можно увидеть все доступные сети (обе проводную и радиосвязь - wireless), и далее можно выбрать из них ту сеть, к которой пользователь хочет подсоединиться. Программа запоминает настройки  сетей для переключения пользователя, чтобы было всегда соединение, и автоматически переключает на лучшую доступную сеть в случае обрыва связи.</para>

      <para>Чтобы достичь такого результата, программа была разделена на 2 части: запущенный с правами администратора (root) процесс (daemon) активирует и настраивает сетевой интерфейс, и этот процесс контролирует пользовательский интерфейс. PolicyKit обрабатывает необходимые проверки авторизации для контроля этой программы и Debian настраивает PolicyKit таким образом, что участники группы netdev могут добавлять и изменять соединения Сетевого Диспетчера.</para>

      <para>Сетевой диспетчер знает как обработать различные типы соединений (DHCP, ручная настройка, локальная сеть), но только в случае, если эти настройки программа сделала сама. Это объясняет, почему иногда программа систематически игнорирует все сетевые интерфейсы в  <filename>/etc/network/interfaces</filename>, для которых он не подходит. Так как Сетевой Диспетчер не дает деталей в случае если сетевое соединение не показано в иконке, быстрый путь для решения данной проблемы - это надо удалить из <filename>/etc/network/interfaces</filename> любые настройки для всех интерфейсов, что должны управляться самим Сетевым Диспетчером (и потом запустив эту программу вы получите созданные самой программой конфигурационные файлы).</para>

      <para>Обратите внимание, что эта программа устанавливается по умолчанию в случае, если в процессе первоначальной установки системы был выбран комплект программ  “Окружение рабочего стола”.</para>

      <sidebar>
        <title><emphasis>АЛЬТЕРНАТИВА</emphasis> Настройка через “сетевой профиль”</title>
        <indexterm><primary><emphasis role="pkg">guessnet</emphasis></primary></indexterm>

	<para>Более продвинутые пользователи могут захотеть попробовать пакет <emphasis role="pkg">guessnet</emphasis> для настройки автоматической конфигурации сети. Группа тестовых сценариев определяет какой сетевой профиль должен быть активирован и настроит это "на лету" (то есть влегкую, быстро).</para>

	<para>Пользователи, предпочитающие ручную настройку сетевого профиля, предпочтут программу <emphasis role="pkg">netenv</emphasis>, находящуюся в пакете с похожим именем.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.hostname-name-service">
    <title>Присваивание Имени Компьютеру (Hostname) и Настройка Службы Имен</title>
    <indexterm><primary>name</primary><secondary>attribution and resolution</secondary></indexterm>
    <indexterm><primary>assignment of names</primary></indexterm>

    <para>Смысл присваивания IP-адресам имен, состоящих из слов, в том, чтобы облегчить людям их запоминание. В действительности, IP-адрес идентифицирующий сетевой интерфейс связан с устройством, таким как сетевая карта. Поскольку каждая машина может иметь несколько сетевых карт, и несколько сетевых интерфейсов на каждой карте, такой одиночный компьютер может иметь несколько имен в доменной системы имен.</para>

    <para>Однако, вначале каждая машина идентифицируется по главному (или “каноническому”) имени, сохраненном в файле <filename>/etc/hostname</filename> и общается с Linux-ядром сценариями инициализации через команду <command>hostname</command>. Настоящее значение доступно в виртуальной файловой системе, и может быть получено с командой <command>cat /proc/sys/kernel/hostname</command>.</para>

    <indexterm><primary><command>hostname</command></primary></indexterm>

    <sidebar>
      <title><emphasis>К ОСНОВАМ</emphasis> Виртуальные файловые системы <filename>/proc/</filename> и <filename>/sys/</filename></title>
      <indexterm><primary><filename>/proc/</filename></primary></indexterm>
      <indexterm><primary><filename>proc</filename></primary></indexterm>
      <indexterm><primary><filename>/sys/</filename></primary></indexterm>
      <indexterm><primary><filename>sys</filename></primary></indexterm>

      <para>Файлы, расположенные в древовидных каталогах <filename>/proc/</filename> и <filename>/sys/</filename>, образуют так называемую “виртуальную” файловую систему. Их практическое значение состоит в том, чтобы восстанавливать (считывать) информацию от ядра (помещенную тем в виртуальные файлы) и общаться с ним таким образом (записывая информацию в виртуальные файлы - для передачи ядру).</para>

      <para>Например файлы, расположенные в каталоге <filename>/sys/</filename>, предназначены для обеспечения доступа к внутренним объектам в ядре, особенно к тем, которые представляют различные устройства в системе. Ядро таким образом может делиться различного рода информацией: сообщать например статус каждого устройства (к примеру, находится ли оно в режиме энергосбережения), является ли это устройство съемным и т.д. Обратите внимание, что каталог с файлами <filename>/sys/</filename> появился с моменты выхода в свет версии ядра 2.6.</para>
    </sidebar>

    <para>Удивительным является то, что доменное имя не управляется подобным образом, а приходит в ядро извне от полного имени машины, которое той присвоено через систему разрешения имен. Вы можете изменить имя машины в файле <filename>/etc/hosts</filename>; просто запишите полное имя для машины там вначале перечня имен, связав его с адресом машины, как в следующем примере:</para>
    <informalexample>
      <programlisting>
127.0.0.1     localhost
192.168.0.1    arrakis.falcot.com arrakis</programlisting>
    </informalexample>
    <indexterm><primary><filename>hosts</filename></primary></indexterm>
    <indexterm><primary><filename>/etc/hosts</filename></primary></indexterm>
    <indexterm><primary>domain</primary><secondary>name</secondary></indexterm>
    <indexterm><primary>name</primary><secondary>domain</secondary></indexterm>
    <indexterm><primary>NSS</primary></indexterm>
    <section id="sect.name-resolution">
      <title>Разрешение Имен</title>
      <indexterm><primary>resolution</primary><secondary>name</secondary></indexterm>
      <indexterm><primary>name</primary><secondary>resolution</secondary></indexterm>

      <para>Механизм разрешения имен в Linux модульный и может использовать различные источники информации, объявленные в файле <filename>/etc/nsswitch.conf</filename>. Запись <literal>hosts</literal> включает в себя порядок разрешения имен. По умолчанию эта запись содержит <literal>files dns</literal>, а это значит, что система вначале консультируется с файлом <filename>/etc/hosts</filename>, затем с указанными в нем DNS серверами. NIS/NIS+ или LDAP серверы являются другими возможными источниками.</para>

      <sidebar>
        <title><emphasis>ЗАМЕТКА</emphasis> NSS и DNS</title>

	<para>Имейти в виду, что команды, специально предназначенные для DNS-запросов (особенно <command>host</command>) не используют стандартный механизм разрешения имен (NSS). Как следствие, они не принимают во внимание <filename>/etc/nsswitch.conf</filename>, и следовательно, не учитывают и <filename>/etc/hosts</filename> также.</para>
      </sidebar>
      <section id="sect.dns-server-configuration">
        <title>Настройка DNS-серверов</title>
        <indexterm><primary>DNS</primary></indexterm>
        <indexterm><primary>Служба доменных имен</primary></indexterm>

	<para>DNS (Служба доменных имен) является распределенной и иерархической службой, переводящей имена машин в IP-адреса (десятичные), и наоборот. В частности, она может превратить хорошо понятное людям имя, такое как  <literal>www.eyrolles.com</literal> в реальный IP адрес, <literal>213.244.11.247</literal>.</para>

	<para>Для доступа к информации, размещенной на DNS сервере, сам сервер должен быть доступен для того, чтобы передавать запросы дальше (ретранслировать). У Falcot Corp имеется свой DNS сервер, но индивидуальным пользователям более подойдет вариант использовать DNS сервер, предоставляемый их ISP (интернет-провайдером).</para>

        <indexterm><primary><filename>resolv.conf</filename></primary></indexterm>
        <indexterm><primary><literal>nameserver</literal></primary></indexterm>

	<para>DNS серверы, которые будут использоваться, указываются в файле <filename>/etc/resolv.conf</filename>, по одному в строке, где вначале строки идет слово <literal>nameserver</literal>, а далее указан десятичный IP адрес (это при варианте статичного адреса IP вашей машины, при использовании DHCP здесь будет другая запись), так как показано в следуюшем примере:</para>

        <programlisting>
nameserver 212.27.32.176
nameserver 212.27.32.177
nameserver 8.8.8.8
</programlisting>

        <para>Обратите внимание, что файл <filename>/etc/resolv.conf</filename> может быть обработан автоматически (и перезаписан) когда сетью  или вашим одиноким компьютером управляет Диспетчер связи (NetworkManager) или этот файл сконфигурирован службой DHCP (или ваш модем может включать в себя такую возможность, как организация DNS сервера, следовательно такие настройки вы сделаете внутри него).</para>

      </section>
      <section id="sect.etc-hosts">
        <title>Файл <filename>/etc/hosts</filename></title>
        <indexterm><primary><filename>hosts</filename></primary></indexterm>
        <indexterm><primary><filename>/etc/hosts</filename></primary></indexterm>

	<para>Если в локальной сети нет сервера имен, то можно создать небольшую таблицу соответствия IP адресов и имен узлов машин в файле <filename>/etc/hosts</filename>, который обычно зерезервирован для локальной сети станций (статичная адресация). Синтаксис этого файла очень простой: каждая линия включает определенный IP адрес, а далее перечисляются любые связанные с ним имена, (первым идет настоящее доменное имя вашего компьютера, так называемое “полностью квалифицированное” имя, например "192.168.200.6    example.debian.org    example").</para>

	<para>Этот файл доступен даже во время отключения от сети (интернета) или когда DNS серверы недоступны. Для того, чтобы в данных случаях все нормально работало необходимо, чтобы копия этого файла была расположена на каждой машине в вашей сети. Как только внесли изменения в этот файл на одной из машин, тут же необходимо скопировать его на все машины вашей сети. Это объясняет, почему файл <filename>/etc/hosts</filename> обычно содержит только самые важные записи (не перегружен другой информацией).</para>

	<para>Такой файл будет достаточен для маленькой сети, не подсоединенной к Интернету, но с 5-ью машинами и более, рекомендуется установить правильно настроенный DNS сервер.</para>

        <sidebar>
          <title><emphasis>СОВЕТ</emphasis> В обход DNS</title>

	  <para>Поскольку приложения, перед тем, как сделать запрос DNS, проверяют файл <filename>/etc/hosts</filename>, становится возможным включить в данный файл информацию о том, что есть отличия, каким образом DNS запрос будет возвращаться, и поэтому необходимо обойти нормальную DNS-базирующуюся службу разрешения имен.</para>

	  <para>Это может пригодиться в следующей ситуации: предположим, в установленной системе адрес вэб-сайта некорректно сопоставлен с правильным IP-адресом. При проведении тестирования вэб-сайта это выяснилось. Внесены изменения в DNS записи, но еще до вступления их в силу, уже можно повторно тестировать вэб-сайт (осуществляя DNS запросы "в обход" действующей в настоящей момент службы разрешения имен).</para>

	  <para>Другое возможное применение - это перенаправление трафика, предназначенного в специфический узел на локальном узле, таким образом предотвращая любое сообщение с данным узлом. Для примера - можно изменить направление трафика таким образом, чтобы они обходили узлы, обслуживающие объявления. Это приведет к большей гибкости, меньшему отвлечению внимания, лучшей навигации.</para>
        </sidebar>
      </section>
    </section>
  </section>
  <section id="sect.user-group-databases">
    <title>Базы данных пользователей и групп</title>
    <indexterm><primary>user</primary><secondary>database</secondary></indexterm>
    <indexterm><primary>group</primary><secondary>database</secondary></indexterm>
    <indexterm><primary>database</primary><secondary>of users</secondary></indexterm>
    <indexterm><primary>database</primary><secondary>of groups</secondary></indexterm>

    <para>Список пользователей обычно хранится в файле <filename>/etc/passwd</filename>, а пароли в зашифрованном виде хранятся в файле <filename>/etc/shadow</filename>. Оба этих файла являются текстовыми, в относительно простом формате, который может быть прочитан и изменен с помощью текстового редактора. Каждому пользователю, упомянутому там, отводится для описания одна строка, включающая в себя несколько полей, разделенных двоеточием (“<literal>:</literal>”).</para>

    <sidebar>
      <title><emphasis>ЗАМЕТКА</emphasis> Редактирование системных файлов</title>

      <para>Все системные файлы, упоминаемые в этой главе, являются текстовыми и могут быть отредактированы с помощью текстового редактора. Так как эти файлы очень важны для функциональности ядра системы, хорошим решением будет принять дополнительные меры предосторожности до начала их редактирования. Во-первых, всегда делайте копию (этих файлов) или резервную копию файловой системы перед открытием или внесением изменений в них. Во вторых, на серверах и машинах, где более чем один человек может потенциально иметь доступ к одинаковым файлам в одно и то же время, необходимо предпринять дополнительные меры для предотвращения повреждения файлов.</para>

      <para>Для редактирования важнейших файлов системы достаточно использовать команды <command>vipw</command> - внести изменения в файл <filename>/etc/passwd</filename>, или <command>vigr</command> - для редактирования файла <filename>/etc/group</filename>. Эти команды блокируют файл и предлагают выбрать текстовый редактор, ранее по умолчанию была программа (<command>vi</command> (а в Debian 9.2 программа "vipw" предлагает на выбор 4 программы для редактирования - nano, emacs24, mcedit, vim.tiny), кроме случаев, когда переменная окружения <varname>EDITOR</varname> была изменена). Параметр <literal>-s</literal> в этих командах позволит редактировать соответствующий файл <foreignphrase>shadow</foreignphrase>.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>К ОСНОВАМ</emphasis> Шифрование, односторонняя функция</title>
      <indexterm><primary>crypt</primary></indexterm>

      <para>Команда <command>crypt</command>  - это односторонняя функция, которая преобразует строку (<varname>A</varname>) в другую строку (<varname>B</varname>) таким образом, что <varname>A</varname> нельзя извлечь из <varname>B</varname>. Единственный путь, чтобы идентифицировать <varname>A</varname> - это тестировать все возможные варианты, проверив каждое из них  -  определяя, будет ли при преобразовании через функцию создано <varname>B</varname> или нет. Программа использует до 8 символов на входе (строка <varname>A</varname>) и производит строку из 13-ти, годную для печати, ASCII символы (строка <varname>B</varname>).</para>
    </sidebar>
    <section id="sect.etc-passwd">
      <title>Список пользователей: <filename>/etc/passwd</filename></title>

      <para>Здесь можно увидеть список полей, что используются в файле <filename>/etc/passwd</filename>:</para>
      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm><primary><filename>/etc/passwd</filename></primary></indexterm>
      <indexterm><primary><literal>uid</literal></primary></indexterm>
      <indexterm><primary><literal>gid</literal></primary></indexterm>
      <indexterm><primary><literal>GECOS</literal></primary></indexterm>
      <indexterm><primary><literal>login</literal></primary></indexterm>
      <itemizedlist>
        <listitem>
	  <para>login - имя для входа, например <literal>rhertzog</literal>;</para>
        </listitem>
        <listitem>
	  <para>password - пароль: пароль зашифрован односторонней функцией (<command>crypt</command>), опираясь на <literal>DES</literal>, <literal>MD5</literal>, <literal>SHA-256</literal> или <literal>SHA-512</literal>. Специальное обозначение  “<literal>x</literal>” показывает, что зашифрованный пароль сохранён в файле <filename>/etc/shadow</filename>;</para>
        </listitem>
        <listitem>
	  <para><literal>uid</literal>: уникальный номер, идентифицирующий каждого пользователя (например номер 1002 присвоен пользователю rhertzog);</para>
        </listitem>
        <listitem>
	  <para><literal>gid</literal>: уникальный номер главной группы данного пользователя (Debian создает особенную группу для каждого пользователя по умолчанию, например, номер 1002 присвоен группе rhertzog, которая является главной для пользователя rhertzog);</para>
        </listitem>
        <listitem>
	  <para><literal>GECOS</literal>: данные этого заголовка обычно содержат полное имя пользователя (в данном примере - это GECOS, или фамилия-имя-отчество, через запятую);</para>
        </listitem>
        <listitem>
	  <para>login directory - каталог пользователя (совпадает с именем для входа), предназначенный для того, чтобы пользователь хранил свои персональные файлы (переменная окружения <varname>$HOME</varname> обычно указывается здесь);</para>
        </listitem>
        <listitem>
	  <para>program to execute upon login - первая программа, выполненная сразу после входа пользователя в систему. Обычно это командный интерпретатор (shell), например "/bin/bash", дающий пользователю возможность управления (в объеме его прав). Если указать специальное значение <command>/bin/false</command> (которое ничего не делает и возвращает контроль системе  немедленно), то пользователь не сможет войти в систему.</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>К ОСНОВАМ</emphasis> Группа в Unix-системе</title>
        <indexterm><primary>group</primary></indexterm>

	<para>Группа в Unix-системе включает в себя несколько пользователей, которые могут легко обмениваться между собою файлами. Эта группа пользуется системой комплексных разрешений прав доступа (получая выгоду от одинаковых прав). Вы можете также запретить использование определенных программ для конкретных групп.</para>
      </sidebar>
    </section>
    <section id="sect.etc-shadow">
      <title>Скрытый и Зашифрованный Файл Паролей: <filename>/etc/shadow</filename></title>
      <indexterm><primary><filename>shadow</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/shadow</filename></primary></indexterm>

      <para>Файл <filename>/etc/shadow</filename> содержит следующие поля:</para>
      <itemizedlist>
        <listitem>
	  <para>login - имя входа пользователя в систему;</para>
        </listitem>
        <listitem>
	  <para>зашифрованный пароль;</para>
        </listitem>
        <listitem>
	  <para>несколько полей относятся к окончанию срока действия пароля.</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>ДОКУМЕНТАЦИЯ</emphasis> Формат файлов <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> and <filename>/etc/group</filename></title>

	<para>Документацию по этим программах расположена в следующих страницах руководства (man) : <citerefentry><refentrytitle>passwd</refentrytitle><manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>shadow</refentrytitle><manvolnum>5</manvolnum></citerefentry>, и <citerefentry><refentrytitle>group</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>БЕЗОПАСНОСТЬ</emphasis> Файл <filename>/etc/shadow</filename> относится к безопасности системы</title>

	<para>Файл <filename>/etc/shadow</filename>, непохож на своего алтер-эго (_лат. "второе я", т.е. дубликат) <filename>/etc/passwd</filename>. Он не может быть прочитан обычными пользователями. Если в системе не применяется защита паролей через shadow, то любой сможет прочитать пароль, сохраненный в файле <filename>/etc/passwd</filename>. Взломщик может попытаться “расколоть” (или вскрыть) его одним из нескольких способов “грубой силы”, когда берут последовательность символов, которые надо опознать и, с помощью специальных программ, делают простой перебор часто используемых комбинаций символов. Этот тип нападения на систему называется "атака по словарю" — и сейчас его уже невозможно применять на системах, которые используют <filename>/etc/shadow</filename>.</para>
      </sidebar>
    </section>
    <section id="sect.account-modification">
      <title>Изменение существующей учетной записи или пароля</title>
      <indexterm><primary><command>chsh</command></primary></indexterm>
      <indexterm><primary><command>chfn</command></primary></indexterm>
      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm><primary><command>chage</command></primary></indexterm>
      <indexterm><primary>password</primary></indexterm>

      <para>Следующие команды позволяют изменять информацию, размещенную в конкретных полях базы данных пользователей. Команда <command>passwd</command> позволяет обычному пользователю изменять их пароль, в этом случае сразу происходит изменение и обновление файла <filename>/etc/shadow</filename>. Команда <command>chfn</command> (CHange Full Name - Изменить Полное Имя), зарезервирована для администратора (super-user, root), изменяет поле  <literal>GECOS</literal>. Команда <command>chsh</command> (CHange SHell - Изменить командный интерпретатор) позволяет пользователю изменить свой первоначальный командный интерпретатор во время входа в систему, однако доступный выбор будет ограничен только теми, что расположены в файле <filename>/etc/shells</filename>. На администратора это ограничение не распространяется и он может установить себе любую программу, по своему выбору.</para>

      <para>И наконец, команда <command>chage</command> (CHange AGE - Изменить возраст) позволит администратору изменить пароль с истекающим сроком действия (Параметр <literal>-l <replaceable>user</replaceable></literal> покажет настоящие значения). Вы можете также принудительно завершить срок действия пароля для пользователя используя команду <command>passwd -e <replaceable>user</replaceable></command>. В этом случае при следующем входе пользователя в систему ему будет предложено заменить существующий пароль (принудительно, без всяких "хочу" или "не хочу").</para>
    </section>
    <section id="sect.disabling-account">
      <title>Disabling an Account</title>
      <indexterm><primary>Отключение учетной записи</primary></indexterm>
      <indexterm><primary>account</primary><secondary>disable</secondary></indexterm>

      <para>Вам может понадобиться “отключить учетную запись” (заблокировать пользователя), в качестве дисциплинарной меры, для целей расследования, или просто в случае длительного или окончательного отсутствия пользователя. Отключённая учетная запись означает, что пользователь не может войти или получить доступ к машине. Учетная запись остается неизменной на машине и никаких файлов или данных не удаляется, запись просто становится недоступна. Для этого надо применить команду <command>passwd -l <replaceable>user</replaceable></command> (блокировать). Снять блокировку учетной записи можно похожим способом, с параметром <literal>-u</literal> (разблокировать).</para>

      <sidebar id="sidebar.intro-nss">
        <title><emphasis>УГЛУБЛЯЕМСЯ</emphasis> NSS и база данных системы</title>
        <indexterm><primary>NSS</primary></indexterm>
        <indexterm><primary>Диспетчер службы имен (NSS)</primary></indexterm>

	<para>Взамен использования обычных файлов, управляющих списком пользователей и групп, вы можете использовать другие типы базы данных, такие как LDAP или <command>db</command>, используя соответствующий модуль NSS (Диспетчер службы имен). Используемые модули можно просмотреть в файле <filename>/etc/nsswitch.conf</filename>, в местах расположения <literal>passwd</literal>, <literal>shadow</literal> и <literal>group</literal>. Смотри <xref linkend="sect.config-nss" /> для конкретных примеров использования модулей NSS через LDAP.</para>
      </sidebar>
    </section>
    <section id="sect.etc-group">
      <title>Список групп: <filename>/etc/group</filename></title>

      <para>Группы, существующие в системе, перечислены в файле <filename>/etc/group</filename>, простая текстовая база данных в формате, похожем на тот, что используется в файле <filename>/etc/passwd</filename>, со следующими полями:</para>
      <itemizedlist>
        <listitem>
	  <para>имя группы;</para>
        </listitem>
        <listitem>
	  <para>пароль (необязательно): это поле используется в случаях, если необходимо присоединить кого-то к группе, при этом, не давать ему те же права, как у других членов этой группы (с командами <command>newgrp</command> или  <command>sg</command>, смотри вставку <xref linkend="sidebar.working-with-several-groups" />);</para>
        </listitem>
        <listitem>
	  <para><literal>gid</literal>: уникальный идентификационный номер группы;</para>
        </listitem>
        <listitem>
	  <para>список участников (данной группы): перечень имен пользователей, которые являются членами указанной группы, разделенные запятыми.</para>
        </listitem>
      </itemizedlist>

      <para></para>

      <sidebar id="sidebar.working-with-several-groups">
        <title><emphasis>К ОСНОВАМ</emphasis> Работа с несколькими группами</title>
        <indexterm><primary><command>newgrp</command></primary></indexterm>
        <indexterm><primary><command>sg</command></primary></indexterm>
        <indexterm><primary><command>id</command></primary></indexterm>
        <indexterm><primary>group</primary><secondary>change</secondary></indexterm>

	<para>Каждый пользователь может быть включён сразу в несколько групп, Одной их них является “главная группа”. Она появляется в момент создания нового пользователя в системе и в дальнейшем считается для него "группой по умолчанию" (главной группой). Каждому файлу, создаваемому пользователю, тут же присваивается та группа, которая является главной для него. Однако не всегда это желательно, например, когда пользователь вынужден работать в каталоге, который является разделяемым с пользователями других  групп, отличной от его главной группы. В этом случае, пользователь вынужден временно изменить свою главную группу используя одну из следующих команд: <command>newgrp</command>, когда запускается новый командный интерпретатор, или <command>sg</command>, которая просто выполняется с использованием предоставленной ей альтернативной группы. Эти команды также позволят пользователю присоединиться к группе, к которой они не принадлежат. Если группа защищена паролем, необходимо будет ввести пароль до того, как команда будет выполнена.</para>

	<para>Другой вариант - пользователь может установить бит <literal>setgid</literal> на каталог, который при вызове файла, созданного в том каталоге автоматически присвоит ему корректную группу. Для больших деталей, смотри вкладку <xref linkend="sidebar.setgid-dir" />.</para>

	<para>Команда <command>id</command> отобразит настоящее состояние пользователя, с персональным идентификатором (<varname>uid</varname> variable), действующей главной группой (<varname>gid</varname> variable), и перечень групп, в которые он включен (<varname>groups</varname> variable).</para>
      </sidebar>
      <indexterm><primary><filename>group</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/group</filename></primary></indexterm>

      <para>Команды <command>addgroup</command> и <command>delgroup</command> соответственно добавляют или удаляют группы. Команда <command>groupmod</command> изменит информацию о группе (его <literal>gid</literal> или идентификатор). Команда <command>passwd -g <replaceable>group</replaceable></command> изменит пароль для группы, а команда <command>passwd -r -g <replaceable>group</replaceable></command> удалит его.</para>
      <indexterm><primary><command>addgroup</command></primary></indexterm>
      <indexterm><primary><command>delgroup</command></primary></indexterm>
      <indexterm><primary><command>groupmod</command></primary></indexterm>
      <indexterm><primary>group</primary><secondary>creation</secondary></indexterm>
      <indexterm><primary>creation</primary><secondary>of groups</secondary></indexterm>
      <indexterm><primary>group</primary><secondary>deletion</secondary></indexterm>
      <indexterm><primary>deletion of a group</primary></indexterm>

      <sidebar>
        <title><emphasis>СОВЕТ</emphasis> Команда <command>getent</command></title>
        <indexterm><primary><command>getent</command></primary></indexterm>

	<para>Команда <command>getent</command> (получить записи) проверяет системные базы данных стандартным способом, используя соответствующие библиотечные функции, которые в свою очередь вызывают модули, сконфигурированне в файле <filename>/etc/nsswitch.conf</filename>. Команда принимает один или два аргумента: имя базы данных для проверки, и ключ, по которому будет выполнен поиск. Таким образом, команда <command>getent passwd rhertzog</command> предоставит информацию из базы данных, касающуюся пользователя <literal>rhertzog</literal>.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.creating-accounts">
    <title>Создание Учетных Записей</title>
    <indexterm><primary>account</primary><secondary>creation</secondary></indexterm>
    <indexterm><primary>creation</primary><secondary>of user accounts</secondary></indexterm>

    <para>Одним из первых действий, которые необходимо сделать администратору при первоначальной установке системы на машину, является создание учетной записи пользователя. Обычно это делают с командой <command>adduser</command>, которая при создании в качестве аргумента использует имя нового пользователя.</para>
    <indexterm><primary><command>adduser</command></primary></indexterm>

    <para>Несмотря на то, что команда <command>adduser</command> задает несколько вопросов еще до создания учетной записи (login пользователя), тем не менее ее использование остается сказочно простым. Его конфигурационный файл <filename>/etc/adduser.conf</filename> включает все важные настройки: можно настроить автоматически установливать квоту для каждого нового пользователя, определив здесь же шаблон для этого, или изменить месторасположение учётных записей пользователей; последнее обычно редко используется, но иногда эта возможность  выручит вас в трудных ситуациях, если вы имеете большое количество пользователей и хотите разделить их учётные записи на несколько дисков. А также вы можете задать здесь различные командные интерпретаторы, которые будут использоваться по умолчанию для всех пользователей.</para>

    <sidebar>
      <title><emphasis>К ОСНОВАМ</emphasis> Квота (выделение объёмов для чего-либо)</title>
      <indexterm><primary>квота</primary></indexterm>

      <para>Термин “квота” относится к ограничению каких-либо машинных ресурсов, выделенных в распоряжение пользователю. Это понятие часто применяют в отношении распределения емкости дискового пространства.</para>
    </sidebar>

    <para>При создании пользователя, для него создается домашний каталог с заданными (разработчиками) параметрами, которые предусмотрены в шаблонах файлов, расположенных в <filename>/etc/skel/</filename>. То есть для пользователя создаётся как бы заготовка (скелет) стандартного домашнего каталога и файлов настроек, которыми он будет пользоваться.</para>
    <indexterm><primary>group</primary><secondary>add a user</secondary></indexterm>
    <indexterm><primary>add a user to a group</primary></indexterm>

    <para>В некоторых случаях, может быть полезным добавить пользователя в другие группы также (отличные от его “главной” группы, которая создана для него "по умолчанию"). Это иногда необходимо для того, чтобы добавить пользователю ещё какие-то узкоспециализированные права доступа. Например, пользователь, включённый в группу  <emphasis>audio</emphasis> может получить доступ к аудио-устройствам (или дать пользователю разрешение на работу с видео - video) (смотри вкладку <xref linkend="sidebar.special-files" />). Чтобы получить такой результат надо выполнить команду <command>adduser <replaceable>user</replaceable> <replaceable>group</replaceable></command> (команду "adduser пользователь audio" выполнить через администратора).</para>

    <sidebar id="sidebar.special-files">
      <title><emphasis>К ОСНОВАМ</emphasis> Права доступа к устройству</title>
      <indexterm><primary>device</primary><secondary>access permissions</secondary></indexterm>
      <indexterm><primary>file</primary><secondary>special</secondary></indexterm>
      <indexterm><primary>mode</primary><secondary>character</secondary></indexterm>
      <indexterm><primary>mode</primary><secondary>block</secondary></indexterm>
      <indexterm><primary>block, mode</primary></indexterm>
      <indexterm><primary>character, mode</primary></indexterm>
      <indexterm><primary>special, file</primary></indexterm>
      <indexterm><primary><command>mknod</command></primary></indexterm>

      <para>Каждое устройство перифирии представлено в Unix-системах как специальный файл, обычно расположенный в каталоге <filename>/dev/</filename> (DEV - сокращённое от "device"). Существует два типа специальных файлов, соответствующие реальным устройствам в системе: "символьный тип" (“character mode”) и "блочный тип" (“block mode”), с каждым типом файлов можно делать только определённое количество операций. Тогда как символьный тип файла ограничивается интерактивными операциями чтения/записи (обычно выполняется последовательной ввод-вывод символов), блочный тип позволяет  также искать, записывать, перемещать данные внутри определённой области устройства (осуществляемое блоками). Наконец, каждому специальному файлу присвоено двузначное число (первая цифра слева - "главный" - “major” и вторая цифра - "меньший из двух, второстепенный" - “minor”), с помощью которых ядро может идентифицировать устройства своим, единственным в своем роде, образом. Файлы каких типов создаются с помощью команды <command>mknod</command>, а их название имеет простое символическое название (и более понятное для восприятия людьми, например "/dev/video0" - это устройство видео).</para>

      <para>Карту прав доступа к файлам специального типа можно увидеть в упомянутом каталоге. Она показывает, какими правами пользователь должен обладать для доступа к самому устройству (к примеру - "crw-rw----+ 1 root   video    81,   0 окт 25 05:22 video0", то есть данный файл символьного типа "с" пользователь администратор может читать "r" и записывать в него "w", а члены группы video  могут выполнять тоже "rw", другие пользователи не могут этого делать "---" -8-ая, 9-ая, 10-ая позиции). Таким образом можно увидеть, что для файла <filename>/dev/mixer</filename>, представляющее аудио микшер в системе (диспетчер управления настройками звуковой карты), имеют права доступа на чтение и запись только администратор и члены группы <literal>audio</literal>. И только эти пользователи могут производить операции (настройка и др.) с аудио микшером (буква "w").</para>

      <para>Полезно напомнить, что комбинируя <emphasis role="pkg">udev</emphasis>, <emphasis role="pkg">consolekit</emphasis> и <emphasis role="pkg">policykit</emphasis> можно добавлять дополнительные права доступа. Они разрешат пользователю физически подсоединиться к консоле (и не только через сетевые устройства) и получить доступ к определённым устройствам (например получить доступ к COM - порту при разработке драйвера для какого-то устройства).</para>
    </sidebar>
  </section>
  <section id="sect.shell-environment">
    <title>Среда окружения (пользователя)</title>

    <para>Командные интерпретаторы (или оболочки) могут быть первыми точками соприкосновения пользователя с компьютером, и поэтому они должны быть довольно дружелюбны с ним. Большинство из них используют сценарии инициализации, которые позволят настроить их поведение (автоматическое завершение, текст приглашения и т.д.).</para>
    <indexterm><primary>command line interface</primary></indexterm>
    <indexterm><primary>command interpreter</primary></indexterm>
    <indexterm><primary>оболочка</primary></indexterm>
    <indexterm><primary><command>bash</command></primary></indexterm>

    <para>Стандартная оболочка <command>bash</command> использует скрипт инициализации <filename>/etc/bash.bashrc</filename> для "интерактивной" оболочки, и <filename>/etc/profile</filename> для  оболочки “учетная запись” ("login") (В этих файлах можно делать настройку bash - для всех пользователей на данном компьютере - "интерактивной" оболочки и оболочки “учетная запись”).</para>

    <sidebar>
      <title><emphasis>К ОСНОВАМ</emphasis> Оболочки “учетная запись” и (не-) интерактивная оболочка</title>

      <para>Проще говоря, оболочка учетной записи вызывается сразу, когда вы входите в консоль, любым способом - локально или удаленно через <command>ssh</command>, или когда вы запускаете в явной форме команду <command>bash --login</command>. Независимо от того есть ли это оболочка учетной записи или нет, оболочка может быть интерактивной (для примера - при выполнении в <command>xterm</command>-подобном терминале); или не-интерактивной (когда  выполняется сценарий).</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ОТКРЫТИЕ</emphasis> Другие оболочки, другие сценарии</title>

      <para>Каждый командный интерпретатор имеет свой особенный синтаксис и свои файлы настройки. Таким образом, <command>zsh</command> использует <filename>/etc/zshrc</filename> и <filename>/etc/zshenv</filename>; <command>csh</command> использует <filename>/etc/csh.cshrc</filename>, <filename>/etc/csh.login</filename> и <filename>/etc/csh.logout</filename>. Руководства по этим программам включают в себя и указание на те файлы, в которых осуществляется настройка.</para>
      <indexterm><primary><command>zsh</command></primary></indexterm>
      <indexterm><primary><command>csh</command></primary></indexterm>
    </sidebar>

    <para>Для <command>bash</command>, полезнее активировать “автоматическое завершение” в файле <filename>/etc/bash.bashrc</filename> (простро раскомментируйте несколько строк).</para>

    <sidebar>
      <title><emphasis>К ОСНОВАМ</emphasis> Автоматическое завершение (автозавершение)</title>
      <indexterm><primary>automatic completion</primary></indexterm>

      <para>Многие командные интерпретаторы поддерживают функцию завершения, которая позволяет оболочке автоматически завершать частично введенное наименование программы или аргумента, когда пользователь нажимает клавишу  <keycap>Tab</keycap>. Это дает возможность пользователям работать более эффективно и быть менее подверженным ошибкам.</para>

      
      <para>Эта функция очень мощная и гибкая. Имеется возможность настроить ее поведение в соответствии с каждой командой. Таким образом, первый аргумент, следующий за <command>apt-get</command> будет предлагать автозавершение в соответствии с синтаксисом этой команды, даже если этот аргумент не будет подходить к названию любого файла (в случае с программой "apt-get", возможными вариантами аргументов будут <literal>install</literal>, <literal>remove</literal>, <literal>upgrade</literal>, и т.д.).</para>
    </sidebar>

    <sidebar>
      <title><emphasis>К ОСНОВАМ</emphasis> Тильда, короткий путь в ДОМАШНИЙ каталог (HOME)</title>
      <indexterm><primary>~</primary></indexterm>
      <indexterm><primary>tilde</primary></indexterm>

      <para>Тильда часто используется для отображения каталога, который является переменной окружения данного пользователя, <varname>HOME</varname> (это точка монтирования домашнего каталога пользователя в системе, например <filename>/home/rhertzog/</filename>). Командные интерпретаторы, встречая тильду в командной строке или сценарии, автоматически делают замену, например: <filename>~/hello.txt</filename> заменят на <filename>/home/rhertzog/hello.txt</filename>.</para>

      <para>Тильда позволяет также получить доступ в домашнюю директорию другого пользователя. Так например, эти две записи являются синонимами: <filename>~rmas/bonjour.txt</filename> и <filename>/home/rmas/bonjour.txt</filename>.</para>
    </sidebar>

    <para>В дополнение к имеющимся общим сценариям, каждый пользователь может создать их собственный сценарий <filename>~/.bashrc</filename> и <filename>~/.bash_profile</filename> для настройки своих оболочек. Наиболее частые изменения касаются добавления псевдонимов (alias). После ввода псевдонима оболочка автоматически заменяет его на строку запуска команды, которую вы соотнесли с данным псевдонимом. Это значительно убыстряет запуск команд (включающих в себя длинную последовательность операторов). Для примера, вы можете создать псевдоним <literal>la</literal> для запуска строки команды следующего вида <command>ls -la | less</command>; и тогда, как только вы введёте в консоле <command>la</command> и нажмете ВВОД, то сразу сможете детально проверить содержимое каталога (вывод будет осуществляться постранично программой less).</para>

    <sidebar>
      <title><emphasis>К ОСНОВАМ</emphasis> Переменные окружения (изменяемые значения в окружающей среде - оболочке)</title>
      <indexterm><primary>environment</primary><secondary>environment variable</secondary></indexterm>
      <indexterm><primary>variable, environment</primary></indexterm>

      <para>Переменные среды позволяют сохранить глобальные настройки, чтобы предоставлять их по мере необходимости оболочке или различным другим программам. Они имеют контекстный характер (каждому процессу выделяется необходимый ему набор переменных окружения), и имеют права наследования. Эта последняя характеристика делает возможным объявлять переменные для входа в оболочку учетной записи, которые будут передаваться всем запускаемым, данным пользователем, программам.</para>
    </sidebar>

    <para>Настройка переменных окружения, используемых по умолчанию, является важным элементом конфигурирования оболочки. Предпочитаемым местом хранения в резерве переменных, характерных для оболочки, является файл <filename>/etc/environment</filename>. Именно его используют различные программы как вероятный источник информации по переменным при их старте в оболочке (в консоле и без нее). Переменные, обычно включаемые в этот файл, являются:  <varname>ORGANIZATION</varname> - содержит название компании или организации и  <varname>HTTP_PROXY</varname> - включает наличие и месторасположение HTTP-прокси.</para>

    <sidebar>
      <title><emphasis>СОВЕТ</emphasis> Все оболочки настраиваются одинаково</title>

      <para>Пользователи часто хотят настроить свои учетные записи и интерактивные оболочки похожим способом. Чтобы сделать это, они выбирают для интерпретации (или “источник”) содержимое файлов <filename>~/.bashrc</filename> и <filename>~/.bash_profile</filename>. Это можно сделать так же с файлами для всех пользователей (вызывая через текстовый редактор файлы <filename>/etc/bash.bashrc</filename> и <filename>/etc/profile</filename> и сохраняя их к себе для редактирования как соответственно файлы ".bashrc" и ".bash_profile").</para>
    </sidebar>
  </section>
  <section id="sect.config-printing">
    <title>Printer Configuration</title>
    <indexterm><primary>configuration</primary><secondary>printing</secondary></indexterm>
    <indexterm><primary>printing</primary><secondary>configuration</secondary></indexterm>

    <para>Настройка принтера для печати создавала ранее много проблем. что вызывало головную боль как у администраторов так и у пользователей. Сейчас эти проблемы по большей части уже в прошлом благодаря программе <emphasis role="pkg">cups</emphasis>, которая является свободным сервером печати, использующим протокол IPP (Internet Printing Protocol - Протокол печати через сеть Интернет).</para>
    <indexterm><primary>IPP</primary></indexterm>
    <indexterm><primary>Internet Printing Protocol</primary></indexterm>
    <indexterm><primary><command>cups</command></primary></indexterm>

    <para>Эта программа делится на несколько Debian пакетов: 1) <emphasis role="pkg">cups</emphasis> - это центральный сервер принтера; 2) <emphasis role="pkg">cups-bsd</emphasis> - создает слой совместимости, позволяющий использовать команды традиционной BSD системы печати - процесс (<command>lpd</command>, команды <command>lpr</command> и <command>lpq</command>, и т.д.); 3) <emphasis role="pkg">cups-client</emphasis> - содержит группу программ для интерактивного общения с сервером (блокировать и разблокировать принтер, просматривать или удалять задания в очереди печати, и т.д.); и наконец, 4) <emphasis role="pkg">cups-driver-gutenprint</emphasis> содержит коллекцию дополнительных драйверов принтера для <command>cups</command> (печать фотографий и др.).</para>
    <indexterm><primary><command>lpr</command></primary></indexterm>
    <indexterm><primary><command>lpd</command></primary></indexterm>
    <indexterm><primary><command>lpq</command></primary></indexterm>

    <sidebar>
      <title><emphasis>COMMUNITY</emphasis> CUPS</title>
      <indexterm><primary>CUPS</primary></indexterm>
      <indexterm><primary>Common Unix Printing System</primary></indexterm>

      <para>Общая система печати в UNIX (английское сокращение CUPS™) является проектом (и торговой маркой), управляемым компанией Apple, Inc. <ulink type="block" url="http://www.cups.org/" /></para>
    </sidebar>

    <para>После установки вышеуказанных пакетов, управлять программой <command>cups</command> легко через браузер (веб-интерфейс), введя в адресной строке: <literal>http://localhost:631/</literal> (адрес принт-сервера в вашей локальной сети). Здесь вы можете добавить принтеры (включая сетевые принтеры), удалить их, и управлять ими. Вы можете также использовать <command>cups</command> через графический интерфейс, предоставленный вам окружением рабочего стола (программы, установленные в комплекте с вашим дистибутивом). Наконец, имеется ещё графический интерфейс <command>system-config-printer</command> (из Debian пакета с похожим именем).</para>
    <indexterm><primary><command>cups</command></primary><secondary>administration</secondary></indexterm>

    <sidebar>
      <title><emphasis>ЗАМЕТКА</emphasis> Устаревàние файла <filename>/etc/printcap</filename></title>

      <para>Ещё недавно <emphasis>cups</emphasis>  использовал файл <filename>/etc/printcap</filename>. Однако в настоящее время он уже устарел. Программы, которые рассчитывают получить перечень доступных принтеров из этого файла, будут ошибаться. Во избежание возникновения такой проблемы, удалите этот файл и сделайте символическую ссылку (смотри вкладку <xref linkend="sidebar.symbolic-link" />) на файл <filename>/var/run/cups/printcap</filename>, который управляется через  <emphasis>cups</emphasis> для обеспечения совместимости.</para>
      <indexterm><primary><filename>printcap</filename></primary></indexterm>
    </sidebar>
  </section>
  <section id="sect.config-bootloader">
    <title>Configuring the Bootloader</title>
    <indexterm><primary>загрузчик</primary><secondary>начальный загрузчик</secondary></indexterm>
    <indexterm><primary>загрузчик</primary></indexterm>

    <para>It is probably already functional, but it is always good to know
    how to configure and install the bootloader in case it disappears from
    the Master Boot Record. This can occur after installation of another
    operating system, such as Windows. The following information can also
    help you to modify the bootloader configuration if needed.</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Master boot record</title>
      <indexterm><primary>MBR</primary></indexterm>
      <indexterm><primary>Master Boot Record</primary></indexterm>

      <para>The Master Boot Record (MBR) occupies the first 512 bytes of
      the first hard disk, and is the first thing loaded by the BIOS to
      hand over control to a program capable of booting the desired
      operating system. In general, a bootloader gets installed in the MBR,
      removing its previous content.</para>
    </sidebar>
    <section id="sect.identify-disks">
      <title>Identifying the Disks</title>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> <emphasis>udev</emphasis> and <filename>/dev/</filename></title>

	<para>The <filename>/dev/</filename> directory traditionally houses
	so-called “special” files, intended to represent system
	peripherals (see sidebar <xref linkend="sidebar.special-files" />). Once upon a time, it used to contain
	all special files that could potentially be used. This approach had a number
	of drawbacks among which the fact that it restricted the number of devices
	that one could use (due to the hardcoded list of names), and that it was
	impossible to know which special files were actually useful.</para>

	<para>Nowadays, the management of special files is entirely
	dynamic and matches better the nature of hot-swappable computer
	devices. The kernel cooperates with <emphasis>udev</emphasis> to
	create and delete them as needed when the corresponding devices
	appear and disappear.  For this reason, <filename>/dev/</filename>
	doesn't need to be persistent and is thus a RAM-based filesystem
	that starts empty and contains only the relevant entries.</para>

	<para>The kernel communicates lots of information about any
	newly added device and hands out a pair of major/minor numbers
	to identify it. With this <command>udevd</command> can create
	the special file under the name and with the permissions that
	it wants. It can also create aliases and perform additional
	actions (such as initialization or registration
	tasks). <command>udevd</command>'s behavior is driven by a
	large set of (customizable) rules.</para>

	<para>With dynamically assigned names, you can thus keep the same name
	for a given device, regardless of the connector used or the connection order, which is
	especially useful when you use various USB peripherals. The
	first partition on the first hard drive can then be called
	<filename>/dev/sda1</filename> for backwards compatibility, or
	<filename>/dev/root-partition</filename> if you prefer, or even
	both at the same time since <command>udevd</command> can be
	configured to automatically create a symbolic link.</para>

	<para>In ancient times, some kernel modules did automatically
	load when you tried to access the corresponding device file.
	This is no longer the case, and the peripheral's special file
	no longer exists prior to loading the module; this is no big
	deal, since most modules are loaded on boot thanks to
	automatic hardware detection. But for undetectable peripherals
	(such as very old disk drives or PS/2 mice), this doesn't
	work. Consider adding the modules, <literal>floppy</literal>,
	<literal>psmouse</literal> and <literal>mousedev</literal> to
	<filename>/etc/modules</filename> in order to force loading
	them on boot.</para>
      </sidebar>

      <indexterm><primary>hard drive, names</primary></indexterm>
      <indexterm><primary>names</primary><secondary>of hard drives</secondary></indexterm>

      <para>Configuration of the bootloader must identify the
      different hard drives and their partitions. Linux uses “block”
      special files stored in the <filename>/dev/</filename>
      directory, for this purpose.  Since Debian <emphasis role="distribution">Squeeze</emphasis>, the naming scheme for
      hard drives has been unified by the Linux kernel, and all hard
      drives (IDE/PATA, SATA, SCSI, USB, IEEE 1394) are now
      represented by <filename>/dev/sd*</filename>.</para>

      <para>Each partition is represented by its number on the disk on
      which it resides: for instance, <filename>/dev/sda1</filename> is the
      first partition on the first disk, and <filename>/dev/sdb3</filename>
      is the third partition on the second disk.</para>

      <indexterm><primary>partition</primary><secondary>primary</secondary></indexterm>
      <indexterm><primary>partition</primary><secondary>extended</secondary></indexterm>
      <indexterm><primary>partition</primary><secondary>secondary</secondary></indexterm>
      <indexterm><primary>partition table</primary><secondary>MS-DOS format</secondary></indexterm>
      <para>The PC architecture (or “i386”, including its younger
      cousin “amd64”) has long been limited to using the “MS-DOS”
      partition table format, which only allows four “primary”
      partitions per disk. To go beyond this limitation under this
      scheme, one of them has to be created as an “extended”
      partition, and it can then contain additional “secondary”
      partitions. These secondary partitions are numbered from 5. Thus
      the first secondary partition could be
      <filename>/dev/sda5</filename>, followed by
      <filename>/dev/sda6</filename>, etc.</para>

      <para>Another restriction of the MS-DOS partition table format is
      that it only allows disks up to 2 TiB in size, which is becoming
      a real problem with recent disks.</para>

      <indexterm><primary>GPT</primary><secondary>partition table format</secondary></indexterm>
      <indexterm><primary>partition table</primary><secondary>GPT format</secondary></indexterm>
      <para>A new partition table format called GPT loosens these
      constraints on the number of partitions (it allows up to 128
      partitions when using standard settings) and on the size of the
      disks (up to 8 ZiB, which is more than 8 billion terabytes).  If
      you intend to create many physical partitions on the same disk,
      you should therefore ensure that you are creating the partition table
      in the GPT format when partitioning your disk.</para>

      <para>It is not always easy to remember what disk is connected to
      which SATA controller, or in third position in the SCSI chain,
      especially since the naming of hotplugged hard drives (which includes
      among others most SATA disks and external disks) can change from one
      boot to another. Fortunately, <command>udev</command> creates, in
      addition to <filename>/dev/sd*</filename>, symbolic links with a
      fixed name, which you could then use if you wished to identify a hard
      drive in a non-ambiguous manner. These symbolic links are stored in
      <filename>/dev/disk/by-id</filename>. On a machine with two physical
      disks, for example, one could find the following:</para>

      <screen><computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l
</userinput><computeroutput>total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[....]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </computeroutput></screen>

      <para>Note that some disks are listed several times (because they
      behave simultaneously as ATA disks and SCSI disks), but the relevant
      information is mainly in the model and serial numbers of the disks,
      from which you can find the peripheral file.</para>

      <para>The example configuration files given in the following sections
      are based on the same setup: a single SATA disk, where the
      first partition is an old Windows installation and the second
      contains Debian GNU/Linux.</para>
    </section>
    
    <section id="sect.config-lilo">
      <title>Configuring LILO</title>
      <indexterm><primary>LILO</primary></indexterm>
      <indexterm><primary>Linux Loader</primary></indexterm>

      <para><emphasis>LILO</emphasis> (LInux LOader) is the oldest
      bootloader — solid but rustic. It writes the physical address of
      the kernel to boot on the MBR, which is why each update to LILO (or
      its configuration file) must be followed by the command
      <command>lilo</command>. Forgetting to do so will render a system
      unable to boot if the old kernel was removed or replaced as the new
      one will not be in the same location on the disk.</para>

      <para>LILO's configuration file is
      <filename>/etc/lilo.conf</filename>; a simple file for standard
      configuration is illustrated in the example below.</para>

      <example id="example.lilo.conf">
        <title>Файл настройки LILO</title>

        <programlisting>
# The disk on which LILO should be installed.
# By indicating the disk and not a partition.
# you order LILO to be installed on the MBR.
boot=/dev/sda
# the partition that contains Debian
root=/dev/sda2
# the item to be loaded by default
default=Linux

# the most recent kernel image
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

#  Old kernel (if the newly installed kernel doesn't boot)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# only for Linux/Windows dual boot
other=/dev/sda1
  label=Windows</programlisting>
      </example>
    </section>
    <section id="sect.config-grub">
      <title>Настройка GRUB 2</title>
      <indexterm><primary>GRUB</primary></indexterm>
      <indexterm><primary>GRUB 2</primary></indexterm>

      <para><emphasis>GRUB</emphasis> (GRand Unified Bootloader) is more
      recent. It is not necessary to invoke it after each update of the
      kernel; <emphasis>GRUB</emphasis> knows how to read the filesystems
      and find the position of the kernel on the disk by itself. To install
      it on the MBR of the first disk, simply type <command>grub-install
      /dev/sda</command>.
      <indexterm><primary><command>grub-install</command></primary></indexterm></para>

      <sidebar>
        <title><emphasis>ЗАМЕТКА</emphasis> Обозначение дисков в GRUB</title>

	<para>GRUB can only identify hard drives based on information
	provided by the BIOS. <literal>(hd0)</literal> corresponds to
	the first disk thus detected, <literal>(hd1)</literal> the
	second, etc.  In most cases, this order corresponds exactly to
	the usual order of disks under Linux, but problems can occur
	when you associate SCSI and IDE disks. GRUB stores
	correspondences that it detects in the file
	<filename>/boot/grub/device.map</filename>. If you find errors
	there (because you know that your BIOS detects drives in a
	different order), correct them manually and run
	<command>grub-install</command> again.
	<command>grub-mkdevicemap</command> can help creating a
	<filename>device.map</filename> file from which to
	start.</para>

	<para>Partitions also have a specific name in GRUB. When you use
	“classical” partitions in MS-DOS format, the first partition on
	the first disk is labeled, <literal>(hd0,msdos1)</literal>, the
	second <literal>(hd0,msdos2)</literal>, etc.</para>
      </sidebar>

      <para>GRUB 2 configuration is stored in
      <filename>/boot/grub/grub.cfg</filename>, but this file (in Debian)
      is generated from others. Be careful not to modify it by hand, since
      such local modifications will be lost the next time
      <command>update-grub</command> is run (which may occur upon update of
      various packages). The most common modifications of the
      <filename>/boot/grub/grub.cfg</filename> file (to add command line
      parameters to the kernel or change the duration that the menu is
      displayed, for example) are made through the variables in
      <filename>/etc/default/grub</filename>. To add entries to the menu,
      you can either create a <filename>/boot/grub/custom.cfg</filename>
      file or modify the <filename>/etc/grub.d/50_custom</filename> file.
      For more complex configurations, you can modify other files in
      <filename>/etc/grub.d</filename>, or add to them; these scripts
      should return configuration snippets, possibly by making use of
      external programs. These scripts are the ones that will update the
      list of kernels to boot: <filename>10_linux</filename> takes into
      consideration the installed Linux kernels;
      <filename>20_linux_xen</filename> takes into account Xen virtual systems,
      and <filename>30_os-prober</filename> lists other operating systems
      (Windows, OS X, Hurd).</para>
    </section>
    
    <section id="sect.config-yaboot">
      <title>For Macintosh Computers (PowerPC): Configuring Yaboot</title>
      <indexterm><primary><command>yaboot</command></primary></indexterm>

      <para>Yaboot is the bootloader used by old Macintosh computers using
      PowerPC processors. They do not boot like PCs, but rely on a
      “bootstrap” partition, from which the BIOS (or OpenFirmware)
      executes the loader, and on which the <command>ybin</command> program
      installs <command>yaboot</command> and its configuration file. You
      will only need to run this command again if the
      <filename>/etc/yaboot.conf</filename> is modified (it is duplicated
      on the bootstrap partition, and <command>yaboot</command> knows how
      to find the position of the kernels on the disks).</para>

      <para>Before executing <command>ybin</command>, you must first have a
      valid <filename>/etc/yaboot.conf</filename>. The following is an
      example of a minimal configuration.
      <indexterm><primary><command>ybin</command></primary></indexterm></para>

      <example id="example.yaboot.conf">
        <title>Файл настройки Yaboot</title>

        <programlisting>
# bootstrap partition
boot=/dev/sda2
# the disk
device=hd:
# the Linux partition
partition=3
root=/dev/sda3
# boot after 3 seconds of inactivity
# (timeout is in tenths of seconds)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# last kernel installed
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

#  old kernel
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# only for Linux/Mac OSX dual-boot
macosx=/dev/sda5

# bsd=/dev/sdaX and macos=/dev/sdaX
# are also possible</programlisting>
      </example>
    </section>
  </section>
  <section id="sect.config-misc">
    <title>Other Configurations: Time Synchronization, Logs, Sharing Access…</title>

    <para>The many elements listed in this section are good to know for
    anyone who wants to master all aspects of configuration of the
    GNU/Linux system. They are, however, treated briefly and frequently
    refer to the documentation.</para>

    <section id="sect.timezone">
      <title>Timezone (Часовой пояс)</title>
      <indexterm><primary>timezone</primary></indexterm>

      <sidebar id="sidebar.symbolic-link">
        <title><emphasis>К ОСНОВАМ</emphasis> Символические ссылки</title>
        <indexterm><primary>link</primary><secondary>symbolic</secondary></indexterm>
        <indexterm><primary>symbolic link</primary></indexterm>
        <indexterm><primary><command>ln</command></primary></indexterm>

	<para>A symbolic link is a pointer to another file. When you access
	it, the file to which it points is opened. Removal of the link will
	not cause deletion of the file to which it points. Likewise, it
	does not have its own set of permissions, but rather retains the
	permissions of its target. Finally, it can point to any type of
	file: directories, special files (sockets, named pipes, device
	files, etc.), even other symbolic links.</para>

	<para>The <command>ln -s <replaceable>target</replaceable>
	<replaceable>link-name</replaceable></command> command creates a
	symbolic link, named <replaceable>link-name</replaceable>, pointing
	to <replaceable>target</replaceable>.</para>

	<para>If the target does not exist, then the link is “broken”
	and accessing it will result in an error indicating that the target
	file does not exist. If the link points to another link, you will
	have a “chain” of links that turns into a “cycle” if one of
	the targets points to one of its predecessors. In this case,
	accessing one of the links in the cycle will result in a specific
	error (“too many levels of symbolic links”); this means the
	kernel gave up after several rounds of the cycle.</para>
      </sidebar>

      <para>The timezone, configured during initial installation, is a
      configuration item for the <emphasis role="pkg">tzdata</emphasis>
      package. To modify it, use the <command>dpkg-reconfigure
      tzdata</command> command, which allows you to choose the timezone to
      be used in an interactive manner. Its configuration is stored in the
      <filename>/etc/timezone</filename> file. Additionally, the
      corresponding file in the <filename>/usr/share/zoneinfo</filename>
      directory is copied into <filename>/etc/localtime</filename>; this file
      contains the rules governing the dates where daylight saving time is
      active, for countries that use it.</para>
      <indexterm><primary><filename>timezone</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/timezone</filename></primary></indexterm>
      <indexterm><primary><filename>zoneinfo</filename></primary></indexterm>
      <indexterm><primary><filename>/usr/share/zoneinfo/</filename></primary></indexterm>
      <indexterm><primary>DST</primary></indexterm>
      <indexterm><primary>daylight saving time</primary></indexterm>

      <para>When you need to temporarily change the timezone, use the
      <varname>TZ</varname> environment variable, which takes priority over
      the configured system default:</para>
      <indexterm><primary><varname>TZ</varname></primary></indexterm>

      <screen id="screen.tz">
<computeroutput>$ </computeroutput><userinput>date</userinput>
<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>
<computeroutput>$ </computeroutput><userinput>TZ="Pacific/Honolulu" date</userinput>
<computeroutput>Thu Feb 19 00:25:21  HST 2015</computeroutput></screen>

      <sidebar>
        <title><emphasis>NOTE</emphasis> System clock, hardware clock</title>

	<para>There are two time sources in a computer. A computer's
	motherboard has a hardware clock, called the “CMOS clock”. This
	clock is not very precise, and provides rather slow access times.
	The operating system kernel has its own, the software clock, which
	it keeps up to date with its own means (possibly with the help of
	time servers, see <xref linkend="sect.time-synchronization" />). This
	system clock is generally more accurate, especially since it
	doesn't need access to hardware variables. However, since it only
	exists in live memory, it is zeroed out every time the machine is
	booted, contrary to the CMOS clock, which has a battery and
	therefore “survives” rebooting or halting of the machine. The
	system clock is, thus, set from the CMOS clock during boot, and the
	CMOS clock is updated on shutdown (to take into account possible
	changes or corrections if it has been improperly adjusted).</para>

	<para>In practice, there is a problem, since the CMOS clock is
	nothing more than a counter and contains no information regarding
	the time zone. There is a choice to make regarding its
	interpretation: either the system considers it runs in universal
	time (UTC, formerly GMT), or in local time. This choice could be a
	simple shift, but things are actually more complicated: as a result
	of daylight saving time, this offset is not constant. The result is
	that the system has no way to determine whether the offset is
	correct, especially around periods of time change. Since it is
	always possible to reconstruct local time from universal time and
	the timezone information, we strongly recommend using the CMOS
	clock in universal time.</para>

	<para>Unfortunately, Windows systems in their default configuration
	ignore this recommendation; they keep the CMOS clock on local time,
	applying time changes when booting the computer by trying to guess
	during time changes if the change has already been applied or not.
	This works relatively well, as long as the system has only Windows
	running on it. But when a computer has several systems (whether it
	be a “dual-boot” configuration or running other systems via
	virtual machine), chaos ensues, with no means to determine if the
	time is correct. If you absolutely must retain Windows on a
	computer, you should either configure it to keep the CMOS clock as
	UTC (setting the registry key
	<literal>HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</literal>
	to “1” as a DWORD), or use <command>hwclock --localtime --set</command>
	on the Debian system to set the hardware clock and mark it as tracking
	the local time (and make sure to manually check your clock in spring and
	autumn).</para>
      </sidebar>
    </section>
    <section id="sect.time-synchronization">
      <title>Синхронизация Времени</title>
      <indexterm><primary>time synchronization</primary></indexterm>
      <indexterm><primary>clock</primary><secondary>synchronization</secondary></indexterm>

      <para>Time synchronization, which may seem superfluous on a computer,
      is very important on a network. Since users do not have permissions
      allowing them to modify the date and time, it is important for this
      information to be precise to prevent confusion. Furthermore, having
      all of the computers on a network synchronized allows better
      cross-referencing of information from logs on different machines.
      Thus, in the event of an attack, it is easier to reconstruct the
      chronological sequence of actions on the various machines involved in
      the compromise. Data collected on several machines for statistical
      purposes won't make a great deal of sense if they are not
      synchronized.</para>

      <sidebar>
        <title><emphasis>К ОСНОВАМ</emphasis> NTP</title>
        <indexterm><primary>NTP</primary></indexterm>
        <indexterm><primary>Network</primary><secondary>Time Protocol</secondary></indexterm>

	<para>NTP (Network Time Protocol) allows a machine to synchronize
	with others fairly accurately, taking into consideration the delays
	induced by the transfer of information over the network and other
	possible offsets.</para>

	<para>While there are numerous NTP servers on the Internet, the
	more popular ones may be overloaded. This is why we recommend using
	the <emphasis>pool.ntp.org</emphasis> NTP server, which is, in
	reality, a group of machines that have agreed to serve as public
	NTP servers. You could even limit use to a sub-group specific to a
	country, with, for example, <emphasis>us.pool.ntp.org</emphasis>
	for the United States, or <emphasis>ca.pool.ntp.org</emphasis> for
	Canada, etc.</para>

	<para>However, if you manage a large network, it is recommended
	that you install your own NTP server, which will synchronize with
	the public servers. In this case, all the other machines on your
	network can use your internal NTP server instead of increasing the
	load on the public servers. You will also increase homogeneity with
	your clocks, since all the machines will be synchronized on the
	same source, and this source is very close in terms of network
	transfer times.</para>
      </sidebar>
      <section id="sect.ntp-on-workstations">
        <title>Для Рабочих Станций</title>

	<para>Since work stations are regularly rebooted (even if only to
	save energy), synchronizing them by NTP at boot is enough. To do
	so, simply install the <emphasis role="pkg">ntpdate</emphasis>
	package. You can change the NTP server used if needed by modifying
	the <filename>/etc/default/ntpdate</filename> file.</para>
        <indexterm><primary><filename>ntpdate</filename></primary></indexterm>
        <indexterm><primary><filename>/etc/default/ntpdate</filename></primary></indexterm>
      </section>
      <section id="sect.ntp-on-servers">
        <title>Для Серверов</title>

        
	<para>Servers are only rarely rebooted, and it is very important
	for their system time to be correct. To permanently maintain
	correct time, you would install a local NTP server, a service
	offered in the <emphasis role="pkg">ntp</emphasis> package. In its
	default configuration, the server will synchronize with
	<emphasis>pool.ntp.org</emphasis> and provide time in response to
	requests coming from the local network. You can configure it by
	editing the <filename>/etc/ntp.conf</filename> file, the most
	significant alteration being the NTP server to which it refers. If
	the network has a lot of servers, it may be interesting to have one
	local time server which synchronizes with the public servers and is
	used as a time source by the other servers of the network.</para>
        <indexterm><primary><emphasis role="pkg">ntp</emphasis></primary></indexterm>
        <indexterm><primary>server</primary><secondary>NTP</secondary></indexterm>
        <indexterm><primary>NTP</primary><secondary>server</secondary></indexterm>

        <sidebar>
          <title><emphasis>GOING FURTHER</emphasis> GPS modules and other time sources</title>
          <indexterm><primary>GPS</primary></indexterm>
          <indexterm><primary>DCF-77</primary></indexterm>

	  <para>If time synchronization is particularly crucial to your
	  network, it is possible to equip a server with a GPS module
	  (which will use the time from GPS satellites) or a DCF-77 module
	  (which will sync time with the atomic clock near Frankfurt,
	  Germany). In this case, the configuration of the NTP server is a
	  little more complicated, and prior consultation of the
	  documentation is an absolute necessity.</para>
        </sidebar>
      </section>
    </section>
    <section id="sect.rotation-logs">
      <title>Rotating Log Files</title>
      <indexterm><primary>file</primary><secondary>logs, rotation</secondary></indexterm>
      <indexterm><primary>logs</primary><secondary>files, rotation</secondary></indexterm>
      <indexterm><primary>rotation of log files</primary></indexterm>
      <indexterm><primary><command>logrotate</command></primary></indexterm>

      <para>Log files can grow, fast, and it is necessary to archive them.
      The most common scheme is a rotating archive: the log file is
      regularly archived, and only the latest <replaceable>X</replaceable>
      archives are retained. <command>logrotate</command>, the program
      responsible for these rotations, follows directives given in the
      <filename>/etc/logrotate.conf</filename> file and all of the files in
      the <filename>/etc/logrotate.d/</filename> directory. The
      administrator may modify these files, if they wish to adapt the log
      rotation policy defined by Debian. The
      <citerefentry><refentrytitle>logrotate</refentrytitle>
      <manvolnum>1</manvolnum></citerefentry> man page describes all of the
      options available in these configuration files. You may want to
      increase the number of files retained in log rotation, or move the
      log files to a specific directory dedicated to archiving them rather
      than delete them. You could also send them by e-mail to archive them
      elsewhere.</para>

      <para>The <command>logrotate</command> program is executed daily by
      the <command>cron</command> scheduling program (described in <xref linkend="sect.task-scheduling-cron-atd" />).</para>
    </section>
    <section id="sect.sharing-admin-rights">
      <title>Sharing Administrator Rights</title>
      <indexterm><primary>учётная запись</primary><secondary>администратора</secondary></indexterm>
      <indexterm><primary>root</primary></indexterm>
      <indexterm><primary><command>sudo</command></primary></indexterm>

      <para>Frequently, several administrators work on the same network.
      Sharing the root passwords is not very elegant, and opens the
      door for abuse due to the anonymity such sharing creates. The
      solution to this problem is the <command>sudo</command> program,
      which allows certain users to execute certain commands with special
      rights. In the most common use case, <command>sudo</command> allows a
      trusted user to execute any command as root. To do so, the user
      simply executes <command>sudo
      <replaceable>command</replaceable></command> and authenticates using
      their personal password.</para>

      <para>When installed, the <emphasis role="pkg">sudo</emphasis>
      package gives full root rights to members of the
      <literal>sudo</literal> Unix group. To delegate other rights, the
      administrator must use the <command>visudo</command> command, which
      allows them to modify the <filename>/etc/sudoers</filename>
      configuration file (here again, this will invoke the
      <command>vi</command> editor, or any other editor indicated in the
      <varname>EDITOR</varname> environment variable). Adding a line with
      <literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal>
      allows the user in question to execute any command as root.</para>
      <indexterm><primary><command>visudo</command></primary></indexterm>
      <indexterm><primary><filename>sudoers</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/sudoers</filename></primary></indexterm>

      <para>More sophisticated configurations allow authorization of only
      specific commands to specific users. All the details of the various
      possibilities are given in the
      <citerefentry><refentrytitle>sudoers</refentrytitle>
      <manvolnum>5</manvolnum></citerefentry> man page.</para>
    </section>
    <section id="sect.fstab-mount-points">
      <title>List of Mount Points</title>
      <indexterm><primary>point, mount</primary></indexterm>
      <indexterm><primary>точка монтирования</primary></indexterm>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> Mounting and unmounting</title>

	<para>In a Unix-like system such as Debian, files are organized in
	a single tree-like hierarchy of directories. The
	<filename>/</filename> directory is called the “root
	directory”; all additional directories are sub-directories within
	this root. “Mounting” is the action of including the content of
	a peripheral device (often a hard drive) into the system's general
	file tree. As a consequence, if you use a separate hard drive to
	store users' personal data, this disk will have to be “mounted”
	in the <filename>/home/</filename> directory. The root filesystem
	is always mounted at boot by the kernel; other devices are often
	mounted later during the startup sequence or manually with the
	<command>mount</command> command.</para>
        <indexterm><primary><command>mount</command></primary></indexterm>

	<para>Some removable devices are automatically mounted when
	connected, especially when using the GNOME, KDE or other graphical
	desktop environments. Others have to be mounted manually by the
	user. Likewise, they must be unmounted (removed from the file
	tree). Normal users do not usually have permission to execute the
	<command>mount</command> and <command>umount</command> commands.
	The administrator can, however, authorize these operations
	(independently for each mount point) by including the
	<literal>user</literal> option in the
	<filename>/etc/fstab</filename> file.</para>

	<para>The <command>mount</command> command can be used without
	arguments (it then lists all mounted filesystems). The following
	parameters are required to mount or unmount a device. For the
	complete list, please refer to the corresponding man pages,
	<citerefentry><refentrytitle>mount</refentrytitle>
	<manvolnum>8</manvolnum></citerefentry> and
	<citerefentry><refentrytitle>umount</refentrytitle>
	<manvolnum>8</manvolnum></citerefentry>. For simple cases, the
	syntax is simple too: for example, to mount the
	<filename>/dev/sdc1</filename> partition, which has an ext3
	filesystem, into the <filename>/mnt/tmp/</filename> directory, you
	would simply run <command>mount -t ext3 /dev/sdc1
	/mnt/tmp/</command>.</para>
      </sidebar>

      <para>The <filename>/etc/fstab</filename> file gives a list of all
      possible mounts that happen either automatically on boot or manually
      for removable storage devices. Each mount point is described by a
      line with several space-separated fields:
      <indexterm><primary><filename>fstab</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm></para>
      <itemizedlist>
        <listitem>
	  <para>device to mount: this can be a local partition (hard drive,
	  CD-ROM) or a remote filesystem (such as NFS).</para>

	  <para>This field is frequently replaced with the unique ID of the
	  filesystem (which you can determine with <command>blkid
	  <userinput>device</userinput></command>) prefixed with
	  <literal>UUID=</literal>. This guards against a change in the
	  name of the device in the event of addition or removal of disks,
	  or if disks are detected in a different order.</para>
        </listitem>
        <listitem>
	  <para>mount point: this is the location on the local filesystem
	  where the device, remote system, or partition will be
	  mounted.</para>
        </listitem>
        <listitem>
	  <para>type: this field defines the filesystem used on the mounted
	  device. <literal>ext4</literal>, <literal>ext3</literal>,
	  <literal>vfat</literal>, <literal>ntfs</literal>,
	  <literal>btrfs</literal>, <literal>xfs</literal> are a few
	  examples.</para>

          <sidebar>
            <title><emphasis>BACK TO BASICS</emphasis> NFS, a network filesystem</title>

	    <para>NFS is a network filesystem; under Linux, it allows
	    transparent access to remote files by including them in the
	    local filesystem.</para>
          </sidebar>

	  <para>A complete list of known filesystems is available in the
	  <citerefentry><refentrytitle>mount</refentrytitle>
	  <manvolnum>8</manvolnum></citerefentry> man page. The
	  <literal>swap</literal> special value is for swap partitions; the
	  <literal>auto</literal> special value tells the
	  <command>mount</command> program to automatically detect the
	  filesystem (which is especially useful for disk readers and USB
	  keys, since each one might have a different filesystem);</para>
        </listitem>
        <listitem>
	  <para>options: there are many of them, depending on the
	  filesystem, and they are documented in the
	  <command>mount</command> man page. The most common are</para>
          <itemizedlist>
            <listitem>
	      <para><literal>rw</literal> or <literal>ro</literal>,
	      meaning, respectively, that the device will be mounted with
	      read/write or read-only permissions.</para>
            </listitem>
            <listitem>
	      <para><literal>noauto</literal> deactivates automatic
	      mounting on boot.</para>
            </listitem>
            <listitem>
              <para>
                <literal>nofail</literal> allows the boot to proceed
                even when the device is not present. Make sure to put this
                option for external drives that might be unplugged
                when you boot, because <command>systemd</command> really
                ensures that all mount points that must be automatically
                mounted are actually mounted before letting the boot
                process continue to its end. Note that you can combine
                this with <literal>x-systemd.device-timeout=5s</literal>
                to tell <command>systemd</command> to not wait more than
                5 seconds for the device to appear (see
                <citerefentry><refentrytitle>systemd.mount</refentrytitle><manvolnum>5</manvolnum></citerefentry>).
	      </para>
            </listitem>
            <listitem>
	      <para><literal>user</literal> authorizes all users to mount
	      this filesystem (an operation which would otherwise be
	      restricted to the root user).</para>
            </listitem>
            <listitem>
	      <para><literal>defaults</literal> means the group of default
	      options: <literal>rw</literal>, <literal>suid</literal>,
	      <literal>dev</literal>, <literal>exec</literal>,
	      <literal>auto</literal>, <literal>nouser</literal> and
	      <literal>async</literal>, each of which can be individually
	      disabled after <literal>defaults</literal> by adding
	      <literal>nosuid</literal>, <literal>nodev</literal> and so on
	      to block <literal>suid</literal>, <literal>dev</literal> and
	      so on. Adding the <literal>user</literal> option reactivates
	      it, since <literal>defaults</literal> includes
	      <literal>nouser</literal>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
	  <para>backup: this field is almost always set to
	  <literal>0</literal>. When it is <literal>1</literal>, it tells
	  the <command>dump</command> tool that the partition contains data
	  that is to be backed up.</para>
        </listitem>
        <listitem>
	  <para>check order: this last field indicates whether the
	  integrity of the filesystem should be checked on boot, and in
	  which order this check should be executed. If it is
	  <literal>0</literal>, no check is conducted. The root filesystem
	  should have the value <literal>1</literal>, while other permanent
	  filesystems get the value <literal>2</literal>.</para>
        </listitem>
      </itemizedlist>

      <example id="example.fstab">
        <title>Пример файла <filename>/etc/fstab</filename></title>

        <programlisting>
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
#  swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0</programlisting>
      </example>

      <para>The last entry in this example corresponds to a network
      filesystem (NFS): the <filename>/shared/</filename> directory on the
      <emphasis>arrakis</emphasis> server is mounted at
      <filename>/shared/</filename> on the local machine. The format of the
      <filename>/etc/fstab</filename> file is documented on the
      <citerefentry><refentrytitle>fstab</refentrytitle><manvolnum>5</manvolnum></citerefentry>
      man page.</para>

      <sidebar>
        <title><emphasis>УГЛУБЛЯЕМСЯ</emphasis> Автомонтирование</title>

        
	<para>The <emphasis>am-utils</emphasis> package provides the
	<command>amd</command> auto-mounting utility, able to mount
	removable media on demand when a user attempts to access their
	usual mount point. It will unmount these devices when no process is
	accessing them any longer.</para>
        <indexterm><primary><emphasis>am-utils</emphasis></primary></indexterm>
        <indexterm><primary><command>amd</command></primary></indexterm>
        <indexterm><primary><command>automount</command></primary></indexterm>
        <indexterm><primary><emphasis>autofs</emphasis></primary></indexterm>
        <indexterm><primary>automounter</primary></indexterm>

	<para>Other auto-mounting utilities exist, such as
	<command>automount</command> in the <emphasis>autofs</emphasis>
	package.</para>

	<para>Note also that GNOME, KDE, and other graphical desktop
	environments work together with <emphasis>udisks</emphasis>,
	and can automatically mount removable media when they are connected.</para>
      </sidebar>
    </section>
    <section id="sect.locate-updatedb">
      <title><command>locate</command> and <command>updatedb</command></title>
      <indexterm><primary><command>locate</command></primary></indexterm>
      <indexterm><primary><command>updatedb</command></primary></indexterm>
      <indexterm><primary><command>mlocate</command></primary></indexterm>

      
      <para>The <command>locate</command> command can find the location of
      a file when you only know part of the name. It sends a result almost
      instantaneously, since it consults a database that stores the
      location of all the files on the system; this database is updated
      daily by the <command>updatedb</command> command. There are multiple
      implementations of the <command>locate</command> command and Debian
      picked <emphasis role="pkg">mlocate</emphasis> for its standard
      system.</para>

      <para><command>mlocate</command> is smart enough to only return
      files which are accessible to the user running the command even
      though it uses a database that knows about all files on the system
      (since its <command>updatedb</command> implementation runs with
      root rights). For extra safety, the administrator can use
      <varname>PRUNEDPATHS</varname> in
      <filename>/etc/updatedb.conf</filename> to exclude some directories
      from being indexed.</para>
    </section>
  </section>
  <section id="sect.kernel-compilation">
    <title>Compiling a Kernel</title>
    <indexterm><primary>compilation</primary><secondary>of a kernel</secondary></indexterm>
    <indexterm><primary>kernel</primary><secondary>compilation</secondary></indexterm>

    <para>The kernels provided by Debian include the largest possible
    number of features, as well as the maximum of drivers, in order to
    cover the broadest spectrum of existing hardware configurations. This
    is why some users prefer to recompile the kernel in order to only
    include what they specifically need. There are two reasons for this
    choice. First, it may be to optimize memory consumption, since the
    kernel code, even if it is never used, occupies memory for nothing (and
    never “goes down” on the swap space, since it is actual RAM that it
    uses), which can decrease overall system performance. A locally
    compiled kernel can also limit the risk of security problems since only
    a fraction of the kernel code is compiled and run.</para>

    <sidebar>
      <title><emphasis>NOTE</emphasis> Security updates</title>

      <para>If you choose to compile your own kernel, you must accept the
      consequences: Debian cannot ensure security updates for your custom
      kernel. By keeping the kernel provided by Debian, you benefit from
      updates prepared by the Debian Project's security team.</para>
    </sidebar>

    <para>Recompilation of the kernel is also necessary if you want to use
    certain features that are only available as patches (and not included
    in the standard kernel version).</para>

    <sidebar>
      <title><emphasis>GOING FURTHER</emphasis> The Debian Kernel Handbook</title>
      <indexterm><primary><emphasis role="pkg">debian-kernel-handbook</emphasis></primary></indexterm>

      <para>The Debian kernel teams maintains the “Debian Kernel Handbook”
      (also available in the <emphasis role="pkg">debian-kernel-handbook</emphasis> package) with
      comprehensive documentation about most kernel related tasks and about how
      official Debian kernel packages are handled. This is the first place
      you should look into if you need more information than what is
      provided in this section.
      <ulink type="block" url="http://kernel-handbook.alioth.debian.org" />
      </para>
    </sidebar>

    <section id="sect.kernel-compilation-prerequisites">
      <title>Introduction and Prerequisites</title>

      <para>Unsurprisingly Debian manages the kernel in the form of a
      package, which is not how kernels have traditionally been compiled
      and installed. Since the kernel remains under
      the control of the packaging system, it can then be removed cleanly,
      or deployed on several machines. Furthermore, the scripts associated
      with these packages automate the interaction with the
      bootloader and the initrd generator.</para>

      <para>The upstream Linux sources contain everything needed to build a
      Debian package of the kernel. But you still need to install
      <emphasis role="pkg">build-essential</emphasis> to ensure that you have
      the tools required to build a Debian package. Furthermore, the
      configuration step for the kernel requires the
      <emphasis role="pkg">libncurses5-dev</emphasis> package. Finally, the
      <emphasis role="pkg">fakeroot</emphasis> package will enable creation of the
      Debian package without using administrator's rights.</para>

      
      <sidebar>
        <title><emphasis>CULTURE</emphasis> The good old days of <emphasis role="pkg">kernel-package</emphasis></title>
        <indexterm><primary><emphasis role="pkg">kernel-package</emphasis></primary></indexterm>

	<para>Before the Linux build system gained the ability to build
	proper Debian packages, the recommended way to build such packages
	was to use <command>make-kpkg</command> from the
	<emphasis role="pkg">kernel-package</emphasis> package.</para>
	
      </sidebar>

    </section>
    <section id="sect.kernel-sources">
      <title>Получение исходного кода</title>
      <indexterm><primary>Linux kernel sources</primary></indexterm>
      <indexterm><primary>kernel</primary><secondary>sources</secondary></indexterm>
      <indexterm><primary>source</primary><secondary>of the Linux kernel</secondary></indexterm>

      <para>Like anything that can be useful on a Debian system, the Linux
      kernel sources are available in a package. To retrieve them, just
      install the <emphasis role="pkg">linux-source-<replaceable>version</replaceable></emphasis>
      package. The <command>apt-cache search ^linux-source</command>
      command lists the various kernel versions packaged by Debian. The
      latest version is available in the <emphasis role="distribution">Unstable</emphasis> distribution: you can
      retrieve them without much risk (especially if your APT is configured
      according to the instructions of <xref linkend="sect.apt-mix-distros" />). Note that the source code
      contained in these packages does not correspond precisely with that
      published by Linus Torvalds and the kernel developers; like all
      distributions, Debian applies a number of patches, which might (or
      might not) find their way into the upstream version of Linux. These
      modifications include backports of fixes/features/drivers from newer
      kernel versions, new features not yet (entirely) merged in the upstream
      Linux tree, and sometimes even Debian specific changes.</para>

      <para>The remainder of this section focuses on the 3.16 version of
      the Linux kernel, but the examples can, of course, be adapted to the
      particular version of the kernel that you want.</para>

      <para>We assume the <emphasis role="pkg">linux-source-3.16</emphasis> package has been installed.
      It contains
      <filename>/usr/src/linux-source-3.16.tar.xz</filename>, a
      compressed archive of the kernel sources. You must extract these
      files in a new directory (not directly under
      <filename>/usr/src/</filename>, since there is no need for special
      permissions to compile a Linux kernel):
      <filename>~/kernel/</filename> is appropriate.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>
<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-3.16.tar.xz</userinput>
</screen>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> Location of kernel sources</title>

	<para>Traditionally, Linux kernel sources would be placed in
	<filename>/usr/src/linux/</filename> thus requiring root
	permissions for compilation. However, working with administrator
	rights should be avoided when not needed. There is a
	<literal>src</literal> group that allows members to work in this
	directory, but working in <filename>/usr/src/</filename> should be
	avoided nevertheless. By keeping the kernel sources in a personal
	directory, you get security on all counts: no files in
	<filename>/usr/</filename> unknown to the packaging system, and
	no risk of misleading programs that read
	<filename>/usr/src/linux</filename> when trying to gather
	information on the used kernel.</para>
      </sidebar>
    </section>
    <section id="sect.config-kernel">
      <title>Настройка ядра</title>
      <indexterm><primary>kernel</primary><secondary>configuration</secondary></indexterm>
      <indexterm><primary>configuration</primary><secondary>of the kernel</secondary></indexterm>
      <indexterm><primary><filename>.config</filename></primary></indexterm>

      <para>The next step consists of configuring the kernel according to
      your needs. The exact procedure depends on the goals.</para>

      <para>When recompiling a more recent version of the kernel (possibly
      with an additional patch), the configuration will most likely be kept
      as close as possible to that proposed by Debian. In this case, and
      rather than reconfiguring everything from scratch, it is sufficient
      to copy the
      <filename>/boot/config-<replaceable>version</replaceable></filename>
      file (the version is that of the kernel currently used, which can be
      found with the <command>uname -r</command> command) into a
      <filename>.config</filename> file in the directory containing the
      kernel sources.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>cp /boot/config-3.16.0-4-amd64 ~/kernel/linux-source-3.16/.config</userinput>
</screen>

      <para>Unless you need to change the configuration, you can stop here
      and skip to <xref linkend="sect.kernel-build" />. If you need to change it, on the other
      hand, or if you decide to reconfigure everything from scratch, you
      must take the time to configure your kernel. There are various
      dedicated interfaces in the kernel source directory that can be used
      by calling the <command>make
      <replaceable>target</replaceable></command> command, where
      <replaceable>target</replaceable> is one of the values described
      below.</para>

      <para><command>make menuconfig</command> compiles and executes a
      text-mode interface (this is where the <emphasis role="pkg">libncurses5-dev</emphasis> package is required) which
      allows navigating the options available in a hierarchical structure.
      Pressing the <keycap>Space</keycap> key changes the value of the
      selected option, and <keycap>Enter</keycap> validates the button
      selected at the bottom of the screen; <guibutton>Select</guibutton>
      returns to the selected sub-menu; <guibutton>Exit</guibutton> closes
      the current screen and moves back up in the hierarchy;
      <guibutton>Help</guibutton> will display more detailed information on
      the role of the selected option. The arrow keys allow moving within the
      list of options and buttons. To exit the configuration program,
      choose <guibutton>Exit</guibutton> from the main menu. The program
      then offers to save the changes you've made; accept if you are
      satisfied with your choices.</para>

      <para>Other interfaces have similar features, but they work within
      more modern graphical interfaces; such as <command>make
      xconfig</command> which uses a Qt graphical interface, and
      <command>make gconfig</command> which uses GTK+. The former requires
      <emphasis role="pkg">libqt4-dev</emphasis>, while the latter
      depends on <emphasis role="pkg">libglade2-dev</emphasis> and
      <emphasis role="pkg">libgtk2.0-dev</emphasis>.</para>

      <para>When using one of those configuration interfaces, it is always
      a good idea to start from a reasonable default configuration. The
      kernel provides such configurations in
      <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename>
      and you can put your selected configuration in place with a command
      like <command>make x86_64_defconfig</command> (in the case of a
      64-bit PC) or <command>make i386_defconfig</command> (in the case of
      a 32-bit PC).</para>

      <sidebar>
        <title><emphasis>TIP</emphasis> Dealing with outdated <filename>.config</filename> files</title>

	<para>When you provide a <filename>.config</filename> file that has been
	generated with another (usually older) kernel version, you will have to
	update it. You can do so with <command>make oldconfig</command>, it will
	interactively ask you the questions corresponding to the new
	configuration options. If you want to use the default answer to
	all those questions you can use <command>make
	olddefconfig</command>. With <command>make oldnoconfig</command>,
	it will assume a negative answer to all questions.</para>
      </sidebar>
    </section>
    <section id="sect.kernel-build">
      <title>Compiling and Building the Package</title>
      <indexterm><primary><command>make deb-pkg</command></primary></indexterm>

      <sidebar>
        <title><emphasis>NOTE</emphasis> Clean up before rebuilding</title>

	<para>If you have already compiled once in the directory and wish
	to rebuild everything from scratch (for example because you substantially
	changed the kernel configuration), you will have to run
	<command>make clean</command> to remove the compiled files.
	<command>make distclean</command> removes even more generated files,
	including your <filename>.config</filename> file too, so make sure to
	backup it first.</para>
      </sidebar>

      <para>Once the kernel configuration is ready, a simple <command>make
      deb-pkg</command> will generate up to 5 Debian packages: <emphasis role="pkg">linux-image-<replaceable>version</replaceable></emphasis>
      that contains the kernel image and the associated modules,
      <emphasis role="pkg">linux-headers-<replaceable>version</replaceable></emphasis>
      which contains the header files required to build external modules,
      <emphasis role="pkg">linux-firmware-image-<replaceable>version</replaceable></emphasis>
      which contains the firmware files needed by some drivers (this package
      might be missing when you build from the kernel sources provided by Debian),
      <emphasis role="pkg">linux-image-<replaceable>version</replaceable>-dbg</emphasis>
      which contains the debugging symbols for the kernel image and its modules,
      and <emphasis role="pkg">linux-libc-dev</emphasis> which contains headers
      relevant to some user-space libraries like GNU glibc.</para>

      <para>The <replaceable>version</replaceable> is defined by the concatenation
      of the upstream version (as defined by the variables <literal>VERSION</literal>,
      <literal>PATCHLEVEL</literal>, <literal>SUBLEVEL</literal> and
      <literal>EXTRAVERSION</literal> in the <filename>Makefile</filename>),
      of the <literal>LOCALVERSION</literal> configuration parameter,
      and of the <literal>LOCALVERSION</literal> environment variable. The package
      version reuses the same version string with an appended revision
      that is regularly incremented (and stored in <filename>.version</filename>),
      except if you override it with the
      <literal>KDEB_PKGVERSION</literal> environment variable.
      </para>

      <screen><computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1
</userinput><computeroutput>[...]
$ </computeroutput><userinput>ls ../*.deb
</userinput><computeroutput>../linux-headers-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb
../linux-image-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb
../linux-image-3.16.7-ckt4-falcot-dbg_3.16.7-1_amd64.deb
../linux-libc-dev_3.16.7-1_amd64.deb
</computeroutput></screen>
    </section>
    <section id="sect.modules-build">
      <title>Compiling External Modules</title>
      <indexterm><primary>kernel</primary><secondary>external modules</secondary></indexterm>
      <indexterm><primary>modules</primary><secondary>external kernel modules</secondary></indexterm>
      <indexterm><primary><command>dkms</command></primary></indexterm>

      <para>Some modules are maintained outside of the official Linux
      kernel. To use them, they must be compiled alongside the
      matching kernel. A number of common third party modules are
      provided by Debian in dedicated packages, such as <emphasis role="pkg">xtables-addons-source</emphasis> (extra modules for
      iptables) or <emphasis role="pkg">oss4-source</emphasis> (Open
      Sound System, some alternative audio drivers).</para>

      <para>These external packages are many and varied and we won't list
      them all here; the <command>apt-cache search source$</command>
      command can narrow down the search field. However, a complete list
      isn't particularly useful since there is no particular reason for
      compiling external modules except when you know you need it. In such
      cases, the device's documentation will typically detail the specific
      module(s) it needs to function under Linux.</para>

      <para>For example, let's look at the <emphasis role="pkg">xtables-addons-source</emphasis> package: after installation, a
      <filename>.tar.bz2</filename> of the module's sources is stored in
      <filename>/usr/src/</filename>. While we could manually extract
      the tarball and build the module, in practice we prefer to automate
      all this using DKMS. Most modules offer the required DKMS integration
      in a package ending with a <literal>-dkms</literal> suffix. In our case,
      installing <emphasis role="pkg">xtables-addons-dkms</emphasis> is all that is
      needed to compile the kernel module for the current kernel provided that
      we have the <emphasis role="pkg">linux-headers-*</emphasis> package
      matching the installed kernel. For instance, if you use
      <emphasis role="pkg">linux-image-amd64</emphasis>, you would
      also install <emphasis role="pkg">linux-headers-amd64</emphasis>.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>
<computeroutput>
[...]
Setting up xtables-addons-dkms (2.6-1) ...
Loading new xtables-addons-2.6 DKMS files...
First Installation: checking all kernels...
Building only for 3.16.0-4-amd64
Building initial module for 3.16.0-4-amd64
Done.

xt_ACCOUNT:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/3.16.0-4-amd64/updates/dkms/
[...]
DKMS: install completed.
$ </computeroutput><userinput>sudo dkms status</userinput>
<computeroutput>xtables-addons, 2.6, 3.16.0-4-amd64, x86_64: installed
$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>
<computeroutput>filename:       /lib/modules/3.16.0-4-amd64/updates/dkms/xt_ACCOUNT.ko
license:        GPL
alias:          ipt_ACCOUNT
author:         Intra2net AG &lt;opensource@intra2net.com&gt;
description:    Xtables: per-IP accounting for large prefixes
[...]
</computeroutput>
</screen>

      <sidebar>
        <title><emphasis>ALTERNATIVE</emphasis> module-assistant</title>
        <indexterm><primary><emphasis role="pkg">module-assistant</emphasis></primary></indexterm>

	<para>Before DKMS, <emphasis role="pkg">module-assistant</emphasis> was the simplest
	solution to build and deploy kernel modules. It can still be
	used, in particular for packages lacking DKMS integration:
	with a simple command like <command>module-assistant
	auto-install xtables-addons</command> (or <command>m-a a-i
	xtables-addons</command> for short), the modules are compiled
	for the current kernel, put in a new Debian package, and that
	package gets installed on the fly.
	</para>
      </sidebar>
    </section>
    <section id="sect.kernel-patch">
      <title>Applying a Kernel Patch</title>
      <indexterm><primary>kernel</primary><secondary>patch</secondary></indexterm>
      <indexterm><primary>patch of the kernel</primary></indexterm>

      <para>Some features are not included in the standard kernel due to a
      lack of maturity or to some disagreement with the kernel maintainers.
      Such features may be distributed as patches that anyone is then free
      to apply to the kernel sources.</para>

      <para>Debian distributes some of these patches in <emphasis role="pkg">linux-patch-*</emphasis> or <emphasis role="pkg">kernel-patch-*</emphasis> packages (for instance,
      <emphasis role="pkg">linux-patch-grsecurity2</emphasis>, which
      tightens some of the kernel's security policies). These packages
      install files in the <filename>/usr/src/kernel-patches/</filename>
      directory.</para>

      <para>To apply one or more of these installed patches, use the
      <command>patch</command> command in the sources directory then start
      compilation of the kernel as described above.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-3.16</userinput>
<computeroutput>$ </computeroutput><userinput>make clean</userinput>
<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.0-3.17.1-201410250027.patch.gz | patch -p1</userinput>
</screen>

      <para>Note that a given patch may not necessarily work with every
      version of the kernel; it is possible for <command>patch</command> to
      fail when applying them to kernel sources. An error message will be
      displayed and give some details about the failure; in this case,
      refer to the documentation available in the Debian package of the
      patch (in the <filename>/usr/share/doc/linux-patch-*/</filename>
      directory). In most cases, the maintainer indicates for which kernel
      versions their patch is intended.</para>
    </section>
  </section>
  <section id="sect.kernel-installation">
    <title>Installing a Kernel</title>
    <indexterm><primary>installation</primary><secondary>of a kernel</secondary></indexterm>
    <indexterm><primary>kernel</primary><secondary>installation</secondary></indexterm>
    <section id="sect.kernel-package">
      <title>Features of a Debian Kernel Package</title>

      <indexterm><primary><filename>vmlinuz</filename></primary></indexterm>

      <para>A Debian kernel package installs the kernel image
      (<filename>vmlinuz-<replaceable>version</replaceable></filename>),
      its configuration
      (<filename>config-<replaceable>version</replaceable></filename>) and
      its symbols table
      (<filename>System.map-<replaceable>version</replaceable></filename>)
      in <filename>/boot/</filename>. The symbols table helps
      developers understand the meaning of a kernel error message; without
      it, kernel “oopses” (an “oops” is the kernel equivalent
      of a segmentation fault for user-space programs, in other
      words messages generated following an invalid pointer dereference)
      only contain numeric memory addresses, which is useless information
      without the table mapping these addresses to symbols and function
      names. The modules are installed in the
      <filename>/lib/modules/<replaceable>version</replaceable>/</filename>
      directory.</para>

      <para>The package's configuration scripts automatically generate an
      initrd image, which is a mini-system designed to be loaded in memory
      (hence the name, which stands for “init ramdisk”) by the
      bootloader, and used by the Linux kernel solely for loading the
      modules needed to access the devices containing the complete Debian
      system (for example, the driver for SATA disks). Finally, the
      post-installation scripts update the symbolic links
      <filename>/vmlinuz</filename>, <filename>/vmlinuz.old</filename>,
      <filename>/initrd.img</filename> and
      <filename>/initrd.img.old</filename> so that they point to the latest
      two kernels installed, respectively, as well as the corresponding
      initrd images.</para>

      <para>Most of those tasks are offloaded to hook scripts in
      the <filename>/etc/kernel/*.d/</filename> directories. For instance,
      the integration with <command>grub</command> relies on
      <filename>/etc/kernel/postinst.d/zz-update-grub</filename>
      and <filename>/etc/kernel/postrm.d/zz-update-grub</filename>
      to call <command>update-grub</command> when kernels
      are installed or removed.</para>
    </section>
    <section id="sect.kernel-installation-with-dpkg">
      <title>Installing with <command>dpkg</command></title>

      <para>Using <command>apt</command> is so convenient that it makes
      it easy to forget about the lower-level tools, but the easiest way of
      installing a compiled kernel is to use a command such as
      <command>dpkg -i <replaceable>package</replaceable>.deb</command>,
      where <literal><replaceable>package</replaceable>.deb</literal> is
      the name of a <emphasis role="pkg">linux-image</emphasis> package
      such as
      <filename>linux-image-3.16.7-ckt4-falcot_1_amd64.deb</filename>.</para>

      <para>The configuration steps described in this chapter are basic and
      can lead both to a server system or a workstation, and it can be
      massively duplicated in semi-automated ways. However, it is not
      enough by itself to provide a fully configured system. A few pieces
      are still in need of configuration, starting with low-level programs
      known as the “Unix services”.</para>
    </section>
  </section>
</chapter>
