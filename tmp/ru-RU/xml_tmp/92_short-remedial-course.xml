<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course">
  <appendixinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-short-remedial-course.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>BIOS</keyword>
      <keyword>Ядро</keyword>
      <keyword>Unix</keyword>
      <keyword>Процесс</keyword>
      <keyword>Иерархия</keyword>
      <keyword>Базовые команды</keyword>
    </keywordset>
  </appendixinfo>
  <title>Краткий Коррективный Курс</title>
  <highlights>
    <para>Несмотря на то, что эта книга ориентирована на администраторов и опытных пользователей, мы не хотели исключать заинтересовавшихся новичков. Это приложение - ускоренный курс,в котором описываются основные понятия, затрагивающие обращение с компьютером в Unix.</para>
  </highlights>
  <section id="sect.shell-and-basic-commands">
    <title>Shell и Базовые команды</title>

    <para>В мире Unix каждый администратор рано или поздно использует командную строку; например, когда система не запускается должным образом и имеется только командная строка режима восстановления. Умение управляться с командной строкой -  базовое для выживания в таких условиях.</para>

    <sidebar>
      <title><emphasis>КРАТКИЙ ЭКСКУРС</emphasis> Запуск командного интерпритатора</title>

      <para>Окружение командной строки может быть запущено из графической среды, приложением, известным как "Терминал". В GNOME вы можете запустить его из обзора “Activities” (в русской локализации - "Обзор", который открывается когда вы перемещаете курсор мыши в левый верхний угол экрана) после ввода первых букв названия приложения. В KDE, вы найдете его в <menuchoice><guimenu>K</guimenu> <guisubmenu>Applications</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice> меню.</para>
    </sidebar>

    <para>Эта секция дает только краткий обзор команд. Они все имеют много опций, не описанных здесь. Поэтому, пожалуйста, обратитесь к документации в соответствующих страницах руководства.</para>
    <section>
      <title>Обзор Дерева Каталогов и Управления Файлами</title>

      <para>После того, как сеанс открыт, команда <command>pwd</command>  (которая служит для <emphasis>вывода рабочего каталога</emphasis>) показывает текущее местоположение в файловой системе. Текущий каталог изменяется с помощью команды <command>cd <replaceable>каталог</replaceable></command> (<command>cd</command> для того, чтобы <emphasis>изменить каталог</emphasis>). Родительский каталог всегда называют <literal>..</literal> (две точки), тогда как текущий каталог - <literal>.</literal> (одна точка). Команда <command>ls</command> выводит <emphasis>список</emphasis> содержимого каталога. Если никаких параметров не задано, она работает в текущем каталоге.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>cd Desktop</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd .</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates
Documents  Music      Public    Videos</computeroutput>
      </screen>

      <para>Новый каталог может быть создан с помощью команды <command>mkdir <replaceable>каталог</replaceable></command>, а удален существующий (пустой) каталог может быть с помощью - <command>rmdir <replaceable>каталог</replaceable></command>. Команда <command>mv</command> позволяет <emphasis>переместить</emphasis> и/или переименовать файлы и каталоги; <emphasis>удаление</emphasis> файлов достигается с помощью команды <command>rm <replaceable>файл</replaceable></command>.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public    test
$ </computeroutput><userinput>mv test new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  new       Public     Videos
Documents  Music      Pictures  Templates
$ </computeroutput><userinput>rmdir new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public</computeroutput>
      </screen>
    </section>
    <section>
      <title>Отображение и Изменение Текстовых Файлов</title>

      <para>Команда <command>cat <replaceable>файл</replaceable></command> (предназначенная для <emphasis>связывания</emphasis> файла со стандартным устройством вывода) считывает файл и отображает его содержимое на терминале. Если файл слишком большой чтобы поместиться на экране, используйте пейджер (полоса прокрутки) например <command>меньше</command> (или <command>больше</command>) для прокрутки содержимого файла на странице.</para>

      <para>Команда <command>editor</command> запускает текстовый редактор (например <command>vi</command> или <command>nano</command>) и позволяет создавать, редактировать и читать текстовые файлы. Простейшие файлы иногда могут быть созданы непосредственно из интерпретатора команд с помощью перенаправления: <command>echo "<replaceable>текст</replaceable>" &gt;<replaceable>файл</replaceable></command>. Оно создает <replaceable>файл</replaceable> с “<replaceable>текстом</replaceable>” в качестве содержимого. Добавить строку в конце файла тоже возможно, с помощью такой команды как <command>echo "<replaceable>еще текст</replaceable>" &gt;&gt;<replaceable>файл</replaceable></command>. Запишите  <literal>&gt;&gt;</literal> в этот пример.</para>
    </section>
    <section>
      <title>Поиск Файлов и в пределах Файла</title>

      <para>Команда <command>find <replaceable>каталог</replaceable> <replaceable>критерий</replaceable></command> ищет файлы внутри каталога <replaceable>каталог</replaceable> по особым критериям. Наиболее часто используемым критерием является <literal>-name <replaceable>имя</replaceable></literal>: что позволяет найти файл по его имени.</para>

      <para>Команда <command>grep <replaceable>выражение</replaceable> <replaceable>файл</replaceable></command> ищет содержимое файла и извлекает строки, совпадающие с выражением (смотри боковую панель <xref linkend="sidebar.regexp" />). Добавление опции <literal>-r</literal> включает рекурсивный поиск всех файлов, содержащихся в каталоге, используемом в качестве параметра. Это позволяет найти файл когда известна лишь часть содержимого.</para>
    </section>
    <section>
      <title>Управление Процессами</title>

      <para>Команда <command>ps aux</command> выводит список запущенных процессов и помогает идентифицировать, показывая их <emphasis>pid</emphasis> (Идентификационный номер процесса). Когда <emphasis>pid</emphasis> процесса известен, команда <command>kill -<replaceable>сигнал</replaceable> <replaceable>pid</replaceable></command> позволяет отправить ему сигнал (если процесс принадлежит текущему пользователю). Существует несколько сигналов; наиболее часто используемые - это <literal>TERM</literal> (запрос завершиться корректно) и <literal>KILL</literal> (принудительно убить).</para>

      <para>Командный интерпретатор может запускать программы в фоновом режиме, если за командой следует “&amp;”. Используя амперсанд, пользователь немедленно возобновляет контроль над оболочкой, хотя команда все еще выполняется (как фоновый процесс). Команда <command>jobs</command> выводит список процессов, запущенных в фоновом режим; ввод <command>fg %<replaceable>номер фонового процесса</replaceable></command> (от  <emphasis>foreground</emphasis>) возвращает процесс на передний план. Когда команда выполняется на переднем плане (была запущена обычным образом или перенесена на передний план с помощью <command>fg</command>), комбинация клавиш <keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>приостанавливает процесс и возвращает контроль над командной строкой. Процесс может быть возобновлен в фоновом режиме с помощью <command>bg %<replaceable>номер фонового процесса</replaceable></command> (от <foreignphrase>background</foreignphrase>).</para>
    </section>
    <section>
      <title>Информация о системе: Память, Дисковое пространство, Идентификатор</title>

      <para>Команда <command>free</command> отображает сведения о памяти; <command>df</command> (<emphasis>disk free</emphasis>) выводит отчет о доступном дисковом пространстве на каждом из дисков, смонтированных в файловой системе. Опция <literal>-h</literal> (для <emphasis>читаемости человеком</emphasis>) преобразует размеры в более разборчивый вид (обычно в мегабайты или гигабайты).Аналогичным образом, команда <command>free</command> поддерживает опции <literal>-m</literal> и <literal>-g</literal> для отображения данных в мегабайтах или гигабайтах, соответственно.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       used       free     shared    buffers     cached
Mem:       1028420    1009624      18796          0      47404     391804
-/+ buffers/cache:     570416     458004
Swap:      2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda2              9614084   4737916   4387796  52% /
tmpfs                   514208         0    514208   0% /lib/init/rw
udev                     10240       100     10140   1% /dev
tmpfs                   514208    269136    245072  53% /dev/shm
/dev/sda5             44552904  36315896   7784380  83% /home
</computeroutput></screen>

      <para>Команда <command>id</command> выводит идентификатор пользователя, запустившего сессию, а также список групп, в которые он входит. Поскольку доступ к некоторым файлам или устройствам может быть ограничен для членов некоторых групп, проверка групп (в которых состоит пользователь) может быть полезной.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
      </screen>
    </section>
  </section>
  <section id="sect.filesystem-hierarchy">
    <title>Организация Иерархии Файловой системы</title>
    <indexterm><primary>Иерархия Файловой системы</primary></indexterm>
    <section>
      <title>Корневой каталог</title>

      <para>Система Debian организована по <emphasis>Стандарту иерархии файловой системы</emphasis> (FHS от англ. Filesystem Hierarchy Standard). Этот стандарт определяет назначение каждого каталога. Например, каталоги верхнего уровня описываются следующим образом:</para>
      <itemizedlist>
        <listitem>
	  <para><filename>/bin/</filename>: основные программы;</para>
        </listitem>
        <listitem>
	  <para><filename>/boot/</filename>: ядро Linux и другие файлы, необходимые для его своевременного процесса загрузки;</para>
        </listitem>
        <listitem>
	  <para><filename>/dev/</filename>: файлы устройств;</para>
        </listitem>
        <listitem>
	  <para><filename>/etc/</filename>: конфигурационные файлы;</para>
        </listitem>
        <listitem>
	  <para><filename>/home/</filename>: личные файлы пользователей;</para>
        </listitem>
        <listitem>
	  <para><filename>/lib/</filename>: основные библиотеки;</para>
        </listitem>
        <listitem>
	  <para><filename>/media/*</filename>: точки монтирования съемных устройств (CD-ROM, USB ключей и так далее);</para>
        </listitem>
        <listitem>
	  <para><filename>/mnt/</filename>: временные точки монтирования;</para>
        </listitem>
        <listitem>
	  <para><filename>/opt/</filename>: дополнительные приложения, поставляемые третьими сторонами;</para>
        </listitem>
        <listitem>
	  <para><filename>/root/</filename>: личные файлы администратора (root);</para>
        </listitem>
        <listitem>
          <para><filename>/run/</filename>: непостоянные данные среды выполнения, которые не сохраняются после перезагрузки (еще не включены в FHS)</para>
        </listitem>
        <listitem>
	  <para><filename>/sbin/</filename>: системные программы;</para>
        </listitem>
        <listitem>
	  <para><filename>/srv/</filename>: данные, используемые серверами, размещенными в этой системе;</para>
        </listitem>
        <listitem>
	  <para><filename>/tmp/</filename>: временные файлы; часто этот каталог очищается при загрузке;</para>
        </listitem>
        <listitem>
	  <para><filename>/usr/</filename>: приложения; этот каталог далее подразделяется на <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (согласно той же логике,что и в корневом каталоге). Кроме того, <filename>/usr/share/</filename> содержит архитектурно независимые данные. <filename>/usr/local/</filename> предназначен для использования администратором при установке приложения вручную без перезаписи файлов, обрабатываемых системой управления пакетами (<command>dpkg</command>).</para>
        </listitem>
        <listitem>
	  <para><filename>/var/</filename>: переменные данные, обрабатываемые демонами. Включает в себя файлы логов, очередей, буфера, кэша и так далее.</para>
        </listitem>
        <listitem>
	  <para><filename>/proc/</filename> и <filename>/sys/</filename> являются специфическими для ядра Linux (и не входят в FHS). Они используются ядром для экспорта данных в пространство пользователя (смотри <xref linkend="sect.userspace-presentation" /> и <xref linkend="sect.user-space" /> для разъяснения этой идеи).</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Домашний Каталог Пользователя</title>

      <para>Содержимое домашнего каталога пользователя не стандартизировано, однако имеет несколько заслуживающих внимания соглашений. Одно из них: домашний каталог пользователя часто называют тильдой (“~”). Это полезно знать, потому что интерпретатор команд автоматически заменяет тильду в текущей директории (обычно на <filename>/home/<replaceable>имя пользователя</replaceable>/</filename>).</para>

      <para>Традиционно, конфигурационные файлы приложения хранятся непосредственно в домашнем каталоге пользователя,но их имена обычно начинаются с точки (например, почтовый клиент <command>mutt</command> хранит свои настройки в <filename>~/.muttrc</filename>). Обратите внимание, что имена, начинающиеся с точки, скрыты по умолчанию; и <command>ls</command> показывает их только, когда используется с опцией <literal>-a</literal>, а графическому файловому менеджеру нужно включить в настройках "показывать скрытые файлы".</para>

      <para>Некоторые программы используют несколько конфигурационных файлов, расположенных в одной директории (например, <filename>~/.ssh/</filename>). Некоторые приложения (такие как веб-браузер Iceweasel) также используют их каталоги для хранения кэша загруженных данных. Таким образом, эти каталоги могут занимать много дискового пространства..</para>

      <para>Эти конфигурационные файлы хранятся непосредственно в домашнем каталоге пользователя, часто называемые <emphasis>dotfiles</emphasis>, быстро разрастаются, что приводит к беспорядку. К счастью, коллективные усилия под эгидой FreeDesktop.org привели к созданию “XDG базовой спецификации каталогов”, соглашения, направленного на наведение порядка среди этих файлов и каталогов. Эта спецификация устанавливает, что конфигурационные файлы должны храниться в каталоге <filename>~/.config</filename>, файлы кэша в <filename>~/.cache</filename>, а данные приложений в <filename>~/.local</filename> (или в его подкаталогах). Это соглашение постепенно набирает силу, и некоторые приложения (особенно графические) начали следовать ему.</para>

      <para>Рабочий стол графического окружения обычно отображает содержимое каталога <filename>~/Desktop/</filename> (или каталога, названного соответственно переводу в системах, сконфигурированных на языках отличных от английского).</para>

      <para>Наконец, система электронной почты иногда сохраняет входящие сообщения в каталоге <filename>~/Mail/</filename>.</para>
    </section>
  </section>
  <section id="sect.computer-layers">
    <title>Внутренняя Работа Компьютера: Различные Уровни Сложности</title>

    <para>Компьютер обычно рассматривается как нечто весьма абстрактное, и внешний видимый интерфейс намного проще, чем его внутренняя замысловатость. Такая запутанность вызвана отчасти количеством частей, из которых она состоит. Однако, эти части можно рассматривать слоями, где каждый уровень взаимодействует только с теми, что непосредственно выше или ниже его.</para>

    <para>Конечный пользователь может не знать этих деталей… до тех пор пока все работает. При решении таких проблем как “Интернет не работает!” первое, что нужно сделать - это определить на каком уровне проблема возникает. Сетевая карта (аппаратное обеспечение) работает? Она распознается компьютером? Ядро Linux видит ее? Параметры сети настроены правильно? Все эти вопросы позволяют выделить соответствующие уровни и сосредоточиться на потенциальном источнике проблемы.</para>
    <section id="sect.hardware">
      <title>Нижний Уровень: Аппаратное Обеспечение</title>
      <indexterm><primary>IDE</primary></indexterm>
      <indexterm><primary>SCSI</primary></indexterm>
      <indexterm><primary>Serial ATA</primary></indexterm>
      <indexterm><primary>Parallel ATA</primary></indexterm>
      <indexterm><primary>ATA</primary></indexterm>
      <indexterm><primary>IEEE 1394</primary></indexterm>
      <indexterm><primary>Firewire</primary></indexterm>
      <indexterm><primary>USB</primary></indexterm>

      <para>Давайте начнем с базового напоминания о том, что компьютер - это, прежде всего, набор аппаратных элементов. Обычно это основная плата (известная как <emphasis>материнская плата</emphasis>), с одним (или больше) процессором, некоторым ОЗУ, контроллерами устройств, и слотами расширения для дополнительных плат (для остальных контроллеров устройств). Наиболее примечательные из этих контроллеров: IDE (Parallel ATA), SCSI и Serial ATA, для подключения к устройствам хранения данных, таких как жёсткие диски. "Другие контроллеры" в себя включают USB, который способен подключить огромное количество разнообразных устройств (начиная от веб-камеры до термометров, от клавиатуры до системы домашней автоматизации) и IEEE 1394 (Firewire). Эти контроллеры часто позволяют подключить несколько устройств, так контроллер обрабатывает их как целую подсистему (из-за этого его обычно называют "шиной"). "Дополнительные платы" включают в себя видео карты (к ним подключается монитор), аудио карты, сетевые карты и так далее. В некоторых основных платах эти функции встроены, и нет нужды в дополнительных платах.</para>

      <sidebar>
        <title><emphasis>НА ПРАКТИКЕ</emphasis> Проверка работоспособности оборудования</title>

	<para>Проверить работает ли какое-то оборудование может быть весьма сложно. С другой стороны, доказать, что оно не работает, иногда довольно легко.</para>

	<para>Жёсткий диск состоит из шпинделя с пластинками и движущихся магнитных головок. Когда жёсткий диск включается, мотор пластинок издает характерное жужжание. Он также рассеивает энергию в виде тепла. Следовательно, жёсткий диск, остающийся холодным и тихим, когда на него подается питание, сломан.</para>

	<para>Сетевые карты обычно оснащены светодиодами, показывающими состояние соединения. Если кабель одним концом подключен к сетевой карте (а другим к концентратору или коммутатору), по крайней мере один светодиод будет гореть. Если ни один светодиод не светится, сама сетевая карта, сетевое оборудование или кабель между ними неисправны. Следовательно, следующий шаг - тестировать каждый компонент отдельно.</para>

	<para>Некоторые дополнительные платы — особенно 3D видео карты — имеют системы охлаждения, такие как радиаторы и/или вентиляторы. Если вентилятор не вращается, несмотря на то, что карта включена, правдоподобное объяснение - перегрев карты. Это также относится к центральному процессору (процессорам), расположенным на основной карте.</para>
      </sidebar>
    </section>
    <section id="sect.bios">
      <title>Загрузчик: BIOS или UEFI</title>
      <indexterm><primary>BIOS</primary></indexterm>
      <indexterm><primary>UEFI</primary></indexterm>
      <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

      <para>Оборудование, само по себе, не в состоянии выполнять задачи без соответствующей программной части, управляющей им. Управление и взаимодействие с оборудованием - задача операционной системы и приложений. Они, в свою очередь, требует   функционального оборудования для запуска.</para>

      <para>Этот симбиоз между аппаратным обеспечением и программным обеспечением не возникает сам собой. Когда компьютер включается, требуется небольшая начальная настройка. Эту роль берёт на себя BIOS или UEFI (части программного обеспечения, встроенные в материнскую плату), запускающийся автоматически при включении питания. Его основная задача - поиск программного обеспечения, которому он может передать управление. Обычно, в случае с BIOS, это включает поиск первого жёсткого диска с загрузочным сектором (обычно известного как <emphasis>master boot record</emphasis> или <acronym>MBR</acronym>), загрузку этого загрузочного сектора, и его запуск. С этого момента, BIOS обычно не используется (до следующей загрузки). В случае с UEFI, процесс включает сканирование дисков с целью найти выделенные разделы EFI, содержащие дальнейшие для выполнения EFI приложения.</para>

      <sidebar>
        <title><emphasis>ИНСТРУМЕНТ</emphasis> Настройки, средства конфигурирования BIOS/UEFI</title>
        <indexterm><primary><emphasis>Настройки</emphasis></primary></indexterm>

	<para>BIOS/UEFI также содержит часть программного обеспечения под названием "Настройки", позволяющую конфигурировать аспекты компьютера. В частности, она позволяет выбрать устройства, предпочтительные для загрузки (например, floppy-диск или CD-ROM), настроить системные часы и так далее. Запуск программы "Настройки" обычно осуществляется нажатием специальной клавиши сразу же после включения компьютера. Обычно, это клавиша <keycap>Del</keycap> или <keycap>Esc</keycap>, иногда это <keycap>F2</keycap> или <keycap>F10</keycap>. Большую часть времени выбор мигает на экране во время загрузки.</para>
      </sidebar>

      <para>Загрузочный сектор (или раздел EFI), в свою очередь, содержит другие части программного обеспечения, называемые загрузчиками, цель которых - найти и запустить операционную систему. Так как эти загрузчики не встроены в основную плату, а загружаются с диска, они могут быть умнее чем BIOS (это объясняет почему BIOS не загружает операционную систему самостоятельно). Например, загрузчик (обычно GRUB для Linux систем) может вывести список доступных операционных систем и попросить пользователя выбрать. Обычно, по истечению времени производится выбор по-умолчанию. Иногда пользователь может также выбрать параметры для запуска ядра, и так далее. В конце концов ядро найдено, загружено в память, и запущено.</para>

      <sidebar>
        <title><emphasis>ЗАМЕТКА</emphasis> UEFI - современная замена BIOS</title>
        <indexterm><primary>UEFI</primary></indexterm>
        <indexterm><primary>Безопасная загрузка</primary></indexterm>

        <para>UEFI - относительно современная разработка. Большинство новых компьютеров поддерживают загрузку UEFI, но обычно они также поддерживают загрузку BIOS для обратной совместимости с операционными системами, не готовыми использовать UEFI.</para>
        <para>Эта новая система свободна от некоторых ограничений загрузчика BIOS: с использованием выделенных разделов, загрузчикам больше не нужны специальные трюки, чтобы поместиться в крошечную <emphasis>главную загрузочную запись (MBR)</emphasis>, а затем искать ядро для загрузки. Даже лучше, с соответствующей сборкой ядра Linux UEFI может загрузить непосредственно ядро без каких-либо промежуточных загрузчиков. UEFI  также является основой для произведения <emphasis>Безопасной загрузки (Secure Boot)</emphasis> (технологии, обеспечивающей выполнение только программного обеспечения, подтвержденного производителем Вашей операционной системы).</para>
      </sidebar>

      <para>BIOS/UEFI  также отвечает за обнаружение и инициализацию ряда устройств. Очевидно, это IDE/SATA устройства (обычно это жесткие диски и CD/DVD-ROM приводы), а также еще и PCI устройства. Обнаруженные устройства часто перечислены на экране во время процесса загрузки. Если этот список выводится слишком быстро, используйте клавишу <keycap>Pause</keycap> для его остановки на время, достаточное для прочтения. Не появившиеся установленные PCI устройства являются плохим знаком. В худшем случае, прибор неисправен. В лучшем - он просто не совместим с текущей версией BIOS или материнской платой. Спецификация PCI  развивается, и старые основные платы не гарантируют поддержку более новых PCI устройств.</para>
    </section>
    <section id="sect.kernel">
      <title>Ядро</title>

      <para>BIOS/UEFI с загрузчиком работают всего по несколько секунд. Далее идет первая часть программного обеспечения, работающая длительное время - ядро операционной системы. Ядро берет на себя роль дирижера в оркестре и обеспечивает координацию между аппаратным обеспечением и программным обеспечением. Эта роль включает в себя несколько задач: управление оборудованием, процессами, пользователями и разрешениями, файловой системой и так далее. Ядро предоставляет общую базу для всех остальных программ в системе.</para>
    </section>
    <section id="sect.userspace-presentation">
      <title>Пространство пользователя</title>

      <para>Хотя все что происходит за пределами ядра можно собрать в кучу "пространство пользователя", мы по-прежнему можем разделить это программное обеспечение на уровни. Однако, их взаимодействие намного сложнее прежних, и классифицировать их не так просто. Приложения обычно используют библиотеки, которые в свою очередь окутывают ядро, но взаимодействие может также происходить с другими программами, или множеством библиотек, вызывающих друг друга.</para>
    </section>
  </section>
  <section id="sect.kernel-role-and-tasks">
    <title>Некоторые Выполняемые Ядром Задачи</title>
    <section id="sect.hardware-drivers">
      <title>Управление Оборудованием</title>

      <para>Ядро, прежде всего, предназначено для контролирования оборудования, его обнаружения, его включения когда компьютер запускается и так далее. Это также делает оборудование доступным для программного обеспечения более высокого уровня с упрощенным интерфейсом программирования,  так что последнее может воспользоваться преимуществами устройств, не беспокоясь о деталях, таких как: в какой слот расширения вставлена дополнительная плата. Программный интерфейс также предоставляет уровень абстракции; это позволяет, например, программе для видео-конференции использовать веб-камеру независимо от ее производителя и модели. Программа может просто использовать интерфейс <emphasis>Video for Linux</emphasis> (V4L), а ядро транслирует функциональные вызовы этого интерфейса в фактические машинные команды, необходимые для использования веб-камеры.</para>

     
      <para><indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> Ядро экспортирует информацию об обнаруженном аппаратном обеспечении в виртуальные файловые системы <filename>/proc/</filename> и <filename>/sys/</filename>. Некоторые инструменты суммируют эту информацию. Среди них, <command>lspci</command> (из пакета <emphasis role="pkg">pciutils</emphasis>) выводит список PCI устройств, <command>lsusb</command> (из пакета <emphasis role="pkg">usbutils</emphasis>) выводит список USB устройств, а <command>lspcmcia</command> (из пакета <emphasis role="pkg">pcmciautils</emphasis>) выводит список PCMCIA плат. Эти инструменты очень полезны для определения точной модели какого-либо устройства. Эта идентификация также позволяет находить в интернете более точную информацию, которая в свою очередь, приводит к актуальной документации.</para>

      <example>
        <title>Пример информации, предоставляемой <command>lspci</command> и <command>lsusb</command></title>

        <screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>
      </example>

      <para>Эти программы имеют опцию <literal>-v</literal>, с которой выводятся списки с более подробной (но зачастую ненужной) информацией. Наконец, команда <command>lsdev</command> (из пакета <emphasis role="pkg">procinfo</emphasis>) выводит список коммуникационных ресурсов, используемых устройствами.</para>

      <para>Приложения часто получают доступ к устройствам через специальные файлы, созданные в <filename>/dev/</filename> (см. на боковой панели <xref linkend="sidebar.special-files" />). Это специальные файлы, представляющие дисковые устройства (например, <filename>/dev/hda</filename> и <filename>/dev/sdc</filename>), разделы (<filename>/dev/hda1</filename> или <filename>/dev/sdc3</filename>), мыши (<filename>/dev/input/mouse0</filename>), клавиатуры (<filename>/dev/input/event0</filename>), звуковые карты (<filename>/dev/snd/*</filename>), серийные порты (<filename>/dev/ttyS*</filename>) и так далее.</para>
    </section>
    <section id="sect.filesystems">
      <title>Файловые системы</title>
      <indexterm><primary>файловая система</primary></indexterm>
      <indexterm><primary>система, файловая система</primary></indexterm>

      <para>Файловые системы - один из наиболее выдающихся аспектов ядра. Unix системы соединяют все хранилища файлов в одну  единственную иерархическую систему, которая позволяет пользователям (и приложениям) получать доступ к данным просто, зная их местоположение в этой иерархии.</para>

      <para>Начальная точка этого иерархического дерева называется корнем, <filename>/</filename>. Этот каталог может содержать именованные подкаталоги. Например, подкаталог <literal>home</literal> каталога <filename>/</filename> называется <filename>/home/</filename>. Эти подкаталоги могут, в свою очередь, содержать другие подкаталоги и так далее. Каждый каталог также может содержать файлы, в которых  фактически и хранятся данные. Таким образом, имя <filename>/home/rmas/Desktop/hello.txt</filename> ссылается на файл с именем <literal>hello.txt</literal>, хранящийся в подкаталоге <literal>Desktop</literal> подкаталога <literal>rmas</literal> подкаталога <literal>home</literal> корневого каталога. Ядро занимается преобразованием между этой системой именования и фактической, физической памятью на диске.</para>

      <para>В отличии от других систем, есть только одна такая иерархия, и она может содержать данные с разных дисков. Один из этих дисков используется в качестве корня, а остальные - монтируются как каталоги в этой иерархии (в Unix команда называется <command>mount</command>); после чего, эти диски становятся доступны в этих "точках монтирования". Это позволяет хранить домашние каталоги пользователей (традиционно хранятся в <filename>/home/</filename>) на втором жёстком диске, который будет содержать каталоги <literal>rhertzog</literal> и <literal>rmas</literal>. После того как диск монтируется в <filename>/home/</filename>, эти каталоги становятся доступны в их обычных местах, и будут работать пути, такие как <filename>/home/rmas/Desktop/hello.txt</filename>.</para>
      <indexterm><primary><command>mkfs</command></primary></indexterm>

      <para>Существует множество форматов файловых систем, соответствующих множеству способов физического хранения данных на диске. Наиболее широко известны: <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> и <emphasis>ext4</emphasis>, но есть и другие. Например, <emphasis>vfat</emphasis> исторически используется в операционных системах DOS и Windows, и позволяет использовать жёсткие диски как в Debian так и в Windows. В любом случае, файловая система должна быть подготовлена на диске перед тем, как он будет монтироваться (эта операция известна как “форматирование”). Команды, такие как <command>mkfs.ext3</command> (где <command>mkfs</command> от <emphasis>MaKe FileSystem</emphasis>) производят форматирование. Эти команды нуждаются, в качестве параметра, в представляющем раздел для форматирования файле устройства (например, <filename>/dev/sda1</filename>). Эта операция является разрушительной и должна выполняться только один раз, за исключением тех случаев, если нужно будет уничтожить файловую систему и начать все заново.</para>

      <para>Также есть и сетевые файловые системы такие как <acronym>NFS</acronym>, в которых данные на хранятся на локальном диске. Вместо этого, данные передаются через сеть на сервер, который хранит и извлекает их по требованию. Абстракция файловой системы защищает пользователей от необходимости беспокоится о том, чтобы файлы оставались по их обычному иерархическому пути.</para>
    </section>
    <section id="sect.shared-functions">
      <title>Общие Функции</title>

      <para>Поскольку некоторые функции используются всем программным обеспечением, имеет смысл их централизация в ядре. Например, общая файловая система позволяет любому приложению просто открыть файл по его имени, не заботясь о том, где физически находится файл. Файл может храниться, разделенным на множество частей, на одном или нескольких жёстких дисках или на уделенном сервере. Общие функции взаимодействия используются приложениями для обмена данными, независимо от способа их передачи. К примеру, пусть может проходить через комбинацию локальных или беспроводных сетей, или по телефонной линии.</para>
    </section>
    <section id="sect.process-management">
      <title>Управление Процессами</title>
      <indexterm><primary><emphasis>pid</emphasis></primary></indexterm>

      <para>Процесс - запущенный экземпляр программы. Он требует памяти для хранения как самой программы, так и ее оперативных данных. Ядро отвечает за их создание и отслеживание. Когда программа запускается, ядро выделяет некоторый объем памяти, потом загружает исполняемый код из файловой системы в эту память, а затем начинает исполнение этого кода. Оно хранит сведения об этом процессе, наиболее просматриваемое из которых - идентификационный номер, известный как <emphasis>pid</emphasis> (от англ. <emphasis>process identifier</emphasis>).</para>

      <para>Unix-подобные ядра (включая Linux), как и большинство других современных операционных систем, поддерживают “многозадачность”. Другими словами, они позволяют запускать много процессов "одновременно". Хотя на самом деле только один процесс выполняется в одну единицу времени, но ядро делит время на маленькие промежутки и исполняет каждый процесс пошагово. Так как эти временные интервалы очень короткие (в диапазоне миллисекунды), создается иллюзия параллельного выполнения процессов, хотя на самом деле они активны только в течение нескольких временных промежутков и простаивают остальную часть времени. Работа ядра заключается в регулировании его механизма планирования для поддержания этой иллюзии, увеличивая производительность системы в целом. Если временные интервалы слишком большие, приложение может показаться не таким отзывчивым как хотелось бы. Если слишком короткие, то система будет терять много времени на переключение между задачами. Эти решения могут изменяться с приоритетами процессов. Процессы с высоким приоритетом будут работать дольше и с большей частотой временных промежутков нежели процессы с низким приоритетом.</para>

      <sidebar>
        <title><emphasis>НА ЗАМЕТКУ</emphasis> Многопроцессорные системы (и их разновидности)</title>

	<para>Описанное выше ограничение одним процессом, запущенным в единицу времени, не всегда выполняется. На самом деле идет ограничение одним запущенным процессом <emphasis>на ядро процессора</emphasis> в единицу времени. Многопроцессорные, многоядерные или “гиперпоточные” системы позволяют запускать параллельно несколько процессов. В них также используется та же система временных интервалов, однако, она используется таким образом, чтобы обрабатывать случаи, когда активных процессов больше, чем доступных процессорных ядер. Это совсем не удивительно: базовые системы, по большей части простаивающие, почти всегда имеют десятки запущенных процессов.</para>
      </sidebar>

      <para>Конечно, ядро позволяет запускать несколько независимых экземпляров одной и той же программы. Но каждый из них имеет доступ только к собственным временным интервалам и памяти. Их данные, таким образом, остаются независимыми.</para>
    </section>
    <section id="sect.permissions">
      <title>Управление Правами</title>

      <para>Также Unix-подобные системы являются многопользовательскими. Они предоставляют систему управления правами, которая поддерживает создание отдельных пользователей и групп; она также позволяет контролировать действия на основе разрешений. Ядро управляет данными для каждого процесса, что позволяет контролировать разрешения. Большую часть времени процесс идентифицируется пользователем, запустившем его. Этот процесс имеет право на действия, доступные его владельцу. Например, попытка открыть файл, требует от ядра проверить идентификатор процесса для предоставления доступа (для более подробной информации по данному примеру, см. <xref linkend="sect.rights-management" />).</para>
    </section>
  </section>
  <section id="sect.user-space">
    <title>Пространство пользователя</title>
    <indexterm><primary>пространство пользователя</primary></indexterm>
    <indexterm><primary>пространство ядра</primary></indexterm>

    <para>“Пространство пользователя” относится к среде выполнения нормальных (в отличии от ядра) процессов. Это не обязательно означает, что процессы были запущены пользователем, потому что стандартная система обычно имеет несколько “демонов” (фоновых процессов), запускающихся до того как пользователь даже откроет сеанс. Демоны - также считаются процессами пользовательского пространства.</para>
    <section id="sect.process-basics">
      <title>Процесс</title>
      <indexterm><primary><command>init</command></primary></indexterm>

      <para>Когда ядро находится на последней фазе его инициализации, оно запускает первый процесс - <command>init</command>. Процесс #1 очень редко полезен сам по себе, и Unix-подобные системы работают с множеством дополнительных процессов.</para>
      <indexterm><primary><emphasis>fork</emphasis></primary></indexterm>

      <para>Прежде всего, процесс может клонировать себя (это действие называется <emphasis>fork</emphasis>). Ядро выделяет пространство в памяти (точно такое же как и для исходного процесса), и новый процесс его занимает. Единственная разница между этими двумя процессами - их <emphasis>pid</emphasis>. Новый процесс обычно зовется дочерним процессом, а оригинальный (<emphasis>pid</emphasis> которого не изменился) - родительским процессом.</para>

      <para>Иногда, дочерний процесс продолжает жить своей собственной жизнью независимо от родителя, со своими собственными данными, скопированными у родительского процесса. Во многих случаях, однако, этот дочерний процесс выполняется другой программой. За некоторыми исключениями, его память просто замещается новой программой, и начинается выполнение новой программы. Это механизм, используемый init процессом (с процессом #1) для запуска дополнительных сервисов и выполнения последовательности всей загрузки. В определенный момент один процесс из потомства <command>init</command> запускает графический интерфейс для пользователей и входа в систему (подробно эта последовательность событий описана в <xref linkend="sect.system-boot" />).</para>

      <para>Когда процесс выполняет задачу для которой он был запущен, он завершается. Затем ядро высвобождает память, выделенную для этого процесса и перестает предоставлять ему интервалы времени выполнения. Родительский процесс оповещается о том, что его дочерний процесс был завершен, что позволяет процессу ожидать выполнения задач, поставленных дочернему процессу. Это поведение ясно видно в интерпретаторе командной строки (известной как <emphasis>shells</emphasis>). При вводе команды в командной строке, запрос возвращается только после завершения выполнения этой команды. Большинство оболочек позволяют выполнять команды в фоновом режиме (на заднем плане), для этого надо просто добавить <userinput>&amp;</userinput> в конец команды. Запрос тут же выводится снова, что может вызвать проблемы если команде нужно выводить ее собственные данные.</para>
    </section>
    <section id="sect.daemons">
      <title>Демоны</title>
      <indexterm><primary>демон</primary></indexterm>
      <indexterm><primary>демон</primary></indexterm>

      <para>“Демон” - это процесс, запускаемый автоматически в последовательности загрузки. Он продолжает работать (в фоновом режиме), выполняя задачи по обслуживанию или предоставлению сервисов другим процессам. Эти “фоновые задачи” на самом деле произвольны, и не соответствуют ничему конкретному, с точки зрения системы. Это просто процессы, очень похожие на другие процессы, которые выполняются в свои промежутки времени. Различие состоит только в человеческом языке: процесс, который выполняется без взаимодействия с пользователем (в частности, без графического интерфейса) называется “выполняющимся в фоновом режиме” или “демоном”.</para>

      <sidebar>
        <title><emphasis>СЛОВАРЬ</emphasis> Daemon, demon, уничижительный термин?</title>

	<para>Хотя термин <emphasis>daemon</emphasis> разделяет его Греческую этимологию с <emphasis>demon</emphasis>, первый не подразумевает дьявольское зло, вместо этого, следует воспринимать его как своего рода вспомогательного духа. Это различие достаточно тонко в английском языке; и еще хуже в других языках, где то же самое слово используется для обоих значений.</para>
      </sidebar>

      <para>Несколько таких демонов подробно описаны в <xref linkend="unix-services" />.</para>
    </section>
    <section id="sect.ipc">
      <title>Межпроцессное взаимодействие</title>
      <indexterm><primary>IPC</primary></indexterm>
      <indexterm><primary>Межпроцессное взаимодействие</primary></indexterm>

      <para>Изолированный процесс, демон или интерактивное приложение, редко бывает полезным сам по себе, поэтому существует несколько методов, позволяющих отдельным процессам взаимодействовать друг с другом для обмена данными или управления друг другом. Общий термин обозначающий их - <emphasis>межпроцессное взаимодействие</emphasis>, или коротко IPC (от англ. Inter-Process Communication).</para>

      <para>Простейшая система IPC - использование файлов. Процесс, желающий передать данные, пишет их в файл (с заранее известным именем), при этом получатель только открывает файл и читает его содержимое.</para>
      <indexterm><primary><emphasis>канал</emphasis></primary></indexterm>

      <para>В случае, когда вы не хотите сохранять данные на диск, вы можете использовать <emphasis>канал</emphasis>, который является простым объектом с двумя концами; байты, написанные в одном конце, доступны для чтения на другом. Это простой и удобный способ межпроцессного взаимодействия, т.к. концы управляются отдельными процессами. Каналы могут быть разделены на две категории: именованные и анонимные. Именованный канал представляет собой запись в файловой системе (хотя передаваемые данные не хранятся там), так оба процесса могут самостоятельно открыть его, если расположение именованного канала заранее известно. В тех случаях, когда взаимодействующие процессы связаны между собой (например, родительский и дочерний процессы), родительский процесс также может создать анонимный канал перед тем как "форкнется", а дочерний процесс наследует его. Таким образом оба процесса могут обмениваться данными через канал без необходимости задействовать файловую систему.</para>

      <sidebar>
        <title><emphasis>НА ПРАКТИКЕ</emphasis> Конкретный пример</title>

	<para>Давайте опишем подробнее, что происходит когда составная команда (<emphasis>конвейер</emphasis>) запускается в оболочке. Мы предполагаем, что у нас есть процесс <command>bash</command> (стандартная оболочка в Debian), с <emphasis>pid</emphasis> 4374; в этой оболочке мы вводим команду: <command>ls | sort</command>.</para>

	<para>Вначале оболочка интерпретирует введенную команду. В нашем случае, он понимает, что это две программы (<command>ls</command> и <command>sort</command>) с потоком данных, идущим из одного в другой (обозначается знаком <userinput>|</userinput>, известным как <emphasis>канал</emphasis>). Сначала <command>bash</command> создает анонимный канал (который изначально существует только в рамках самого процесса <command>bash</command>).</para>

	<para>Потом оболочка клонирует себя; это создает новый процесс <command>bash</command> с <emphasis>pid</emphasis> #4521 (<emphasis>идентификаторы процессов</emphasis> - абстрактные номера, обычно не имеющие конкретного смысла). Процесс #4521 наследует канал, что означает, что он может писать в его “входную” часть; <command>bash</command> перенаправляет его стандартный поток вывода во вход этого канала. Затем он выполняет программу <command>ls</command> (и заменяет себя на нее), которая выводит список содержимого текущего каталога. Так как <command>ls</command> пишет в свой стандартный вывод, а этот вывод был заранее перенаправлен, результат эффективно отправляется в канал.</para>

	<para>Похожая операция происходит и со второй командой: <command>bash</command> клонирует себя снова, что создает новый процесс <command>bash</command> с pid #4522. Так как это тоже дочерний процесс #4374, он также наследует канал; затем <command>bash</command> соединяет его стандартный ввод с выходом канала, выполняет команду <command>sort</command> (и заменяет себя на нее), которая сортирует ее входные данные и выводит результат.</para>

	<para>Теперь все кусочки головоломки собраны воедино: <command>ls</command> читает текущую директорию и пишет список файлов в канал; <command>sort</command> читает этот список, сортирует его в алфавитном порядке и выводит результат. Затем процессы с номерами #4521 и #4522 завершаются, а #4374 (который ждал их во время операции) возобновляет управление и выводит приглашение, позволяющее пользователю ввести новую команду.</para>
      </sidebar>

      <para>Однако, межпроцессное взаимодействие используется не только для передачи данных. Во многих ситуациях, единственная информация, которую нужно передать:  это управляющие сообщения такие как “приостановить выполнения” или “возобновить выполнение”. Unix (и Linux) предоставляют механизм, известный как <emphasis>сигналы</emphasis>, через которые процесс может легко отправлять другому процессу специальные сигналы, выбранные из определенного списка. Необходимо лишь знать <emphasis>pid</emphasis> целевого процесса.</para>

      <para>Для более сложного взаимодействия существует механизм, предоставляющий процессу возможность открыть доступ (полностью или частично) к своей выделенной памяти другому процессу. Эта память может использоваться процессами для обмена данными между ними.</para>

      <para>Наконец, сетевое подключение может также помогать процессам взаимодействовать друг с другом; причем, эти процессы могут быть запущенны на разных компьютерах и находиться в тысячах километров друг от друга.</para>

      <para>Это нормально для Unix-подобных систем: использовать все эти механизмы в разной степени.</para>
    </section>
    <section id="sect.libraries">
      <title>Библиотеки</title>
      <indexterm><primary>библиотека (функций)</primary></indexterm>

      <para>Библиотеки функций играют решающую роль в Unix-подобных операционных системах. Они не являются программами (они не могут быть выполнены самостоятельно), а представляют собой фрагменты кода, которые могут быть использованы обычными программами. Среди общих библиотек вы можете найти:</para>
      <itemizedlist>
        <listitem>
	  <para>стандартная библиотека C (<emphasis>glibc</emphasis>), содержащая базовые функции, такие как функции открывания файлов, сетевого соединения, и другие облегчающие взаимодействие с ядром функции;</para>
        </listitem>
        <listitem>
	  <para>графические инструментарии (такие как Gtk+ и Qt) позволяют множеству программ многократно использовать поддерживаемые ими графические объекты;</para>
        </listitem>
        <listitem>
	  <para>библиотека <emphasis>libpng</emphasis>, позволяющая загружать, интерпретировать и сохранять изображения в формате PNG.</para>
        </listitem>
      </itemizedlist>

      <para>Благодаря этим библиотекам, приложения могут многократно использовать уже существующий код. Разработка приложений упрощается, т.к. множество приложений может использовать одни и те же функции. С библиотеками, часто разрабатываемыми разными людьми, глобальная разработка системы становится ближе к исторической философии Unix.</para>

      <sidebar>
        <title><emphasis>КУЛЬТУРА</emphasis> Путь Unix: что-то одно</title>

	<para>Одна из фундаментальных концепций, лежащих в основе семейства операционных систем Unix гласит: "каждый инструмент должен делать только одну вещь, и делать её хорошо; приложения могут впоследствии использовать эти инструменты для строительства в итоге более продвинутой логики". Эта философия просматривается во множестве воплощений. Скрипты оболочки могут быть лучшим примером: они собирают сложные последовательности из очень простых инструментов (таких как <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command> и т.д.). Еще одной реализацией этой философии являются библиотеки кода: библиотека <emphasis>libpng</emphasis> позволяет считывать и записывать изображения в формате PNG с разными опциями и различными путями, но она делает только это; нет необходимости в функциях отображения или редактирования изображения.</para>
      </sidebar>

      <para>Кроме того, эти библиотеки часто называют “общими библиотеками”, так как ядро может загружать их в память единожды, тогда как несколько процессов будут использовать эти библиотеки одновременно. Это позволяет экономить память, в сравнении с обратной (гипотетической) ситуацией, когда код библиотеки будет загружаться в память столько раз, сколько процессов его использует.</para>
    </section>
  </section>
</appendix>
