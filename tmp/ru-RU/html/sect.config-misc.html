<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">8.9. Другие настройки: Синхронизация времени, Журналы, Разделение Доступа…</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ru-RU-1.0-1" /><meta
        name="keywords"
        content="Конфигурация, Локализация, Локали, Сеть, Разрешение имён, Пользователи, Группы, Аккаунты, Интерпретатор командной строки, Оболочка, Печать, Загрузчик, Компиляция ядра" /><link
        rel="home"
        href="index.html"
        title="Настольная книга администратора Debian" /><link
        rel="up"
        href="basic-configuration.html"
        title="Глава 8. Базовая конфигурация: Сеть, Аккаунты, Печать..." /><link
        rel="prev"
        href="sect.config-bootloader.html"
        title="8.8. Настройка Загрузчика" /><link
        rel="next"
        href="sect.kernel-compilation.html"
        title="8.10. Compiling a Kernel" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/ru-RU/stable/sect.config-misc.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-bootloader.html"><strong>Пред.</strong></a></li><li
          class="home">Настольная книга администратора Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-compilation.html"><strong>След.</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.config-misc"></a>8.9. Другие настройки: Синхронизация времени, Журналы, Разделение Доступа…</h2></div></div></div><div
          class="para">
			Многие элементы, перечисленные в данной главе, полезно знать тем, кто хочет освоить все стороны настройки систем GNU/Linux. Однако, они описаны кратко, а за подробной информацией рекомендуется обратиться к документации.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.timezone"></a>8.9.1. Timezone (Часовой пояс)</h3></div></div></div><a
            id="id-1.11.13.3.2"
            class="indexterm"></a><div
            class="sidebar"><a
              xmlns=""
              id="sidebar.symbolic-link"></a><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>К ОСНОВАМ</em></span> Символические ссылки</strong></p></div></div></div><a
              id="id-1.11.13.3.3.2"
              class="indexterm"></a><a
              id="id-1.11.13.3.3.3"
              class="indexterm"></a><a
              id="id-1.11.13.3.3.4"
              class="indexterm"></a><div
              class="para">
				Символическая ссылка является указателем на другой файл. Когда вы обращаетесь к ссылке, то открывается тот файл, на который она указывает. При удалении ссылки, сам файл, на который она указывает, не удаляется. Более того, ссылка не имеет своих прав доступа, а получает права доступа (в момент своего создания) как бы "в наследство" от файла, на который она ссылается. Кроме того, ссылка может указывать на любой файл: на каталоги, на специальные файлы (сокеты, именованные каналы, файлы устройств, и т.д.), даже на другие символические ссылки.
			</div><div
              class="para">
				Команда <code
                class="command">ln -s <em
                  class="replaceable">target</em> <em
                  class="replaceable">link-name</em></code> создаст символическую ссылку (параметр "s" - "мягкую"), называемую <em
                class="replaceable">link-name</em>, и указывающую на существующий файл (каталог и т.д., target - цель) <em
                class="replaceable">target</em>.
			</div><div
              class="para">
				Если файл, на который указывает ссылка, не существует, то ссылка считается “бúтой”. При попытке получить доступ к ней будет получен результат с ошибками, сообщающими, что файл, на который она ссылается, не существует. Если ссылка указывает на другую ссылку, вы будете иметь "цепочку" ссылок, которая превратится в "цикл" (cycle), если в этой цепочке ссылок хотя бы одна из них показывает на один из предыдущих файлов (ссылок, по цепочке). То есть вся цепочка закольцована. В этом случае, при попытке получить доступ к одному звену (ссылке, файлу) этой цепочки будет выдана особая ошибка (“слишком много уровней символических ссылок”). Значит ядро отказалось делать далее бессмысленную (с его точки зрения) работу (после нескольких неудачных попыток разобраться с круговыми цепочками).
			</div></div><div
            class="para">
				Часовой пояс определяется в процессе установки дистибутива на машину, входит в пакет <span
              class="pkg pkg">tzdata</span>. При возникновении необходимости изменить часовой пояс запустите команду <code
              class="command">dpkg-reconfigure tzdata</code>. Ответив на несколько вопросов в интерактивном режиме, программа установит новый часовой пояс на вашей машине, который будет использоваться в дальнейшем. Эти настройки сохраняются в файле <code
              class="filename">/etc/timezone</code>. Кроме этого будет скопирован соответствующий файл из каталога <code
              class="filename">/usr/share/zoneinfo</code> в <code
              class="filename">/etc/localtime</code>. Он содержит правила, каким образом переводится время на летний (зимний) период в той или иной стране, для стран, использующих такой порядок (в Debian 9.2 создана мягкая ссылка).
			</div><a
            id="id-1.11.13.3.5"
            class="indexterm"></a><a
            id="id-1.11.13.3.6"
            class="indexterm"></a><a
            id="id-1.11.13.3.7"
            class="indexterm"></a><a
            id="id-1.11.13.3.8"
            class="indexterm"></a><a
            id="id-1.11.13.3.9"
            class="indexterm"></a><a
            id="id-1.11.13.3.10"
            class="indexterm"></a><div
            class="para">
				Если вам понадобится временно изменить часовой пояс, используйте переменную окружения <code
              class="varname">TZ</code>, которая будет иметь приоритет над настройками окружения, которые обычно используются "по умолчанию":
			</div><a
            id="id-1.11.13.3.12"
            class="indexterm"></a><a
            xmlns=""
            id="screen.tz"></a><pre
            class="screen">
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>date</code></strong>
<code
              class="computeroutput">Thu Feb 19 11:25:18 CET 2015</code>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>TZ="Pacific/Honolulu" date</code></strong>
<code
              class="computeroutput">Thu Feb 19 00:25:21  HST 2015</code></pre><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ЗАМЕТКА</em></span> Системные часы, аппаратные часы</strong></p></div></div></div><div
              class="para">
				На компьютере часы представлены в двух вариантах. Часы установленные на материнской плате (в BIOS) являются аппаратными и называются “CMOS часы”. Эти часы не очень точные, и обеспечивает довольно медленное время доступа к ним. Ядро операционной системы имеет свои, внутренние, часы, реализованные как маленькая программа. Эти программные часы самостоятельно рассчитывает время и сохраняют его между перезагрузками системы (возможно с помощью серверов времени, смотри <a
                class="xref"
                href="sect.config-misc.html#sect.time-synchronization">Раздел 8.9.2, «Синхронизация Времени»</a>). Эти системные часы обычно более точные, особенно потому, что им не надо получать доступ к аппаратным переменным. Однако, поскольку программные системные часы существуют только в "живой" памяти (то есть в "работающей" системе), они обнуляются каждый раз как только машина загружается (перегружается). Часы CMOS, напротив, имеют аккумулятор и поэтому они “выживают” при перезагрузке или остановке машины. Поэтому во время загрузки компьютера системные часы установлены по данным из CMOS (то есть аппаратно), в момент работы системы - работают программные системные часы в ядре, а в момент выключения компьютера часы в CMOS обновляются по данным из системных программных часов (для того, чтобы учесть возможные изменения или исправления, если аппаратные часы неправильно отрегулированы).
			</div><div
              class="para">
				На практике часто встречается проблема: поскольку CMOS часы не более чем простой счётчик времени, то они не содержат информацию о часовом поясе. Следовательно установленное в CMOS время система может толковать двояко: установлены часы в режиме мирового времени (UTC, бывшее GMT), или в режиме местного времени. Казалось бы, что можно просто изменить время в CMOS, когда понадобится и всё. Однако в действительности это немного сложнее: в частности смещение времени из-за переключения на летнее время не является постоянной величиной. В результате нет универсального способа дать понять системе как ей, ежегодно два раза в год, переключать часы на летнее время и обратно. Описываемая проблема касается случаев, когда в CMOS установлено местное время. Поэтому, поскольку всегда есть возможность воссоздать местное время путём суммирования информации из двух источников: всемирного времени и информации о часовом поясе на локальном компьютере, настоятельно рекомендуем устанавливать в CMOS часах мировое время (если на компьютере не установлены отличные от Linux операционные системы).
			</div><div
              class="para">
				К сожаленью, операционные системы Windows игнорируют эту рекомендацию в настройках по умолчанию. Они контролируют, чтобы часы CMOS всегда были установлены в местное время. При этом, каждый раз во время загрузки (перегрузки), они просматривают часы CMOS, определяя были ли внесены изменения в настройку часов, и если были - то сами, не спрашивая пользователя, опять устанавливают (в CMOS) местное время. Это работает довольно хорошо для случаев, когда только одна из упомянутых операционных систем запущена на компьютере (или несколько из одного семейства Windows, например Windows XP на разделе sda1, Windows Vista на разделе sda2 и тд, то есть "двойная и более" загрузка этих систем). Но в случаях, когда компьютер имеет несколько установленных систем от разных производителей (в режиме "мультизагрузки") происходит хаос ("образно говоря") на компьютере при попытке самих систем определить - установлено ли время корректно (это варианты с “двойной-и-более загрузкой” или запуск другой системы через виртуальную машину). Если вам (по какой-то причине) невозможно обойтись без установленной Windows на компьютере, то немного подкорректируйте её настройки следующим образом. В частности, чтобы установленные в UTC часы CMOS не переустанавливались снова и снова этими операционными системами, в настройках реестра введите параметр "1" и "DWORD" в ключ <code
                class="literal">HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</code>. Другой вариант решения данной проблемы (для Debian систем) - это выполнить в консоле такую команду <code
                class="command">hwclock --localtime --set</code> (и добавить --date "ввести время и дату"), чтобы установить аппаратные часы в нужное вам время и пометить, чтобы система отслеживала местное время (не забудьте вручную иногда контролировать летнее и зимнее время).
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.time-synchronization"></a>8.9.2. Синхронизация Времени</h3></div></div></div><a
            id="id-1.11.13.4.2"
            class="indexterm"></a><a
            id="id-1.11.13.4.3"
            class="indexterm"></a><div
            class="para">
				Синхронизация времени может показаться излишней для отдельно взятого компьютера, однако её выполнение крайне важно для локальных сетей. Чтобы не происходила путаница, простым пользователям запрещено изменять время и дату. В локальной сети, где регулярно выполняется синхронизация времени всех компьютеров в системе, делать перекрёстный анализ информации из журналов событий, полученных с разных машин в сети, гораздо удобнее. К тому же, в случае нападения на сеть извне, можно будет быстро реконструировать хронологическую цепочку событий, предшествующую этому: определить какие машины и в какое время подвергались атаке и, как следствие этого, они могли быть скомпрометированы. Собираемые с разных машин в сети данные для статистических целей, не имеют большого смысла, если все эти машины не синхронизированы между собой по времени.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>К ОСНОВАМ</em></span> NTP</strong></p></div></div></div><a
              id="id-1.11.13.4.5.2"
              class="indexterm"></a><a
              id="id-1.11.13.4.5.3"
              class="indexterm"></a><div
              class="para">
				NTP (Сетевой Протокол Времени) позволяет машине синхронизироваться с другими (машинами) довольно точно, учитывая задержки, вызванные передачей информации по сети (интернет) или другие возможные отклонения.
			</div><div
              class="para">
				Хотя существует множество серверов NTP в Интернете, наиболее популярные из них могут быть перегружены. Именно по этой причине мы рекомендуем использовать NTP сервер <span
                class="emphasis"><em>pool.ntp.org</em></span>. Под данным адресам работает на самом деле группа машин, которые согласились предоставлять услуги (неограниченному кругу пользователей) в качестве публичных серверов NTP. Вы можете конкретизировать и выбрать для данных целей именно свою страну. Например <span
                class="emphasis"><em>us.pool.ntp.org</em></span> можно использовать для США, или <span
                class="emphasis"><em>ca.pool.ntp.org</em></span> для Канада и т.д.
			</div><div
              class="para">
				Однако, если вы управляете большой сетью, рекомендуется установить ваш собственный NTP сервер (в пакете с похожим именем), который будет синхронизироваться с публичными серверами (дата и время). В этом случае, все другие машины вашей сети могут использовать ваш внутренний NTP сервер вместо того, чтобы увеличивать нагрузку на публичные сервера. Из за того, что все ваши машины будут синхронизированы по дате и времени с одним внутренним источником, разбалансировка по времени на всех машинах в локальной сети будет минимальна. Уменьшается время прохождения информации по сети (каждый пакет проходит более короткий путь).
			</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ntp-on-workstations"></a>8.9.2.1. Для Рабочих Станций</h4></div></div></div><div
              class="para">
					Поскольку рабочие станции регулярно перезагружаются (или выключаются иногда даже, только для сохранения электричества), то синхронизации их по NTP в момент загрузки бывает обычно достаточно. Для этого надо просто установить пакет <span
                class="pkg pkg">ntpdate</span>. Можно также изменить NTP сервер, который будет использоваться, отредактировав файл <code
                class="filename">/etc/default/ntpdate</code>.
				</div><a
              id="id-1.11.13.4.6.3"
              class="indexterm"></a><a
              id="id-1.11.13.4.6.4"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ntp-on-servers"></a>8.9.2.2. Для Серверов</h4></div></div></div><div
              class="para">
					Сервера крайне редко перезагружаются, поэтому очень важно, чтобы их системное время всегда было корректно установлено. Чтобы постоянно поддерживать правильное время, установите локальный NTP сервер. Данная возможность включена в пакет <span
                class="pkg pkg">ntp</span>. В настройках по умолчанию сервер, с одной стороны, будет синхронизироваться с внешним публичным сервером <span
                class="emphasis"><em>pool.ntp.org</em></span> и, с другой стороны, будет предоставлять данные о дате и времени в ответ на запросы, поступающие из локальной сети. Вы можете редактировать файл <code
                class="filename">/etc/ntp.conf</code>, изменив в нем NTP сервер, который будет использоваться для синхронизации (наиболее часто изменяемая опция). Если в сети много серверов, то вас может заинтересовать вариант с локальным сервером времени, синхронизирующимся с публичным сервером. Он же будет использоваться в качестве источника для других серверов сети.
				</div><a
              id="id-1.11.13.4.7.3"
              class="indexterm"></a><a
              id="id-1.11.13.4.7.4"
              class="indexterm"></a><a
              id="id-1.11.13.4.7.5"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>УГЛУБЛЯЕМСЯ</em></span> GPS модули и другие источники времени</strong></p></div></div></div><a
                id="id-1.11.13.4.7.6.2"
                class="indexterm"></a><a
                id="id-1.11.13.4.7.6.3"
                class="indexterm"></a><div
                class="para">
					Если синхронизация времени имеет особо важное значение для вашей сети, то можно оборудовать сервер GPS модулем (который будет использовать время со спутников GPS) или DCF-77 модулем (который будет синхронизировать время с атомными часами недалеко от Франкфурта, Германия). В этом случае, настройка NTP сервера немного сложнее, и предварительное изучение документации (руководства и т.д.) по ntp является абсолютной необходимостью.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.rotation-logs"></a>8.9.3. Смена Журналов Событий</h3></div></div></div><a
            id="id-1.11.13.5.2"
            class="indexterm"></a><a
            id="id-1.11.13.5.3"
            class="indexterm"></a><a
            id="id-1.11.13.5.4"
            class="indexterm"></a><a
            id="id-1.11.13.5.5"
            class="indexterm"></a><div
            class="para">
				Log files can grow, fast, and it is necessary to archive them. The most common scheme is a rotating archive: the log file is regularly archived, and only the latest <em
              class="replaceable">X</em> archives are retained. <code
              class="command">logrotate</code>, the program responsible for these rotations, follows directives given in the <code
              class="filename">/etc/logrotate.conf</code> file and all of the files in the <code
              class="filename">/etc/logrotate.d/</code> directory. The administrator may modify these files, if they wish to adapt the log rotation policy defined by Debian. The <span
              class="citerefentry"><span
                class="refentrytitle">logrotate</span>(1)</span> man page describes all of the options available in these configuration files. You may want to increase the number of files retained in log rotation, or move the log files to a specific directory dedicated to archiving them rather than delete them. You could also send them by e-mail to archive them elsewhere.
			</div><div
            class="para">
				The <code
              class="command">logrotate</code> program is executed daily by the <code
              class="command">cron</code> scheduling program (described in <a
              class="xref"
              href="sect.task-scheduling-cron-atd.html">Раздел 9.7, «Планирование задач с помощью <code
                class="command">cron</code> и <code
                class="command">atd</code>»</a>).
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.sharing-admin-rights"></a>8.9.4. Sharing Administrator Rights</h3></div></div></div><a
            id="id-1.11.13.6.2"
            class="indexterm"></a><a
            id="id-1.11.13.6.3"
            class="indexterm"></a><a
            id="id-1.11.13.6.4"
            class="indexterm"></a><div
            class="para">
				Frequently, several administrators work on the same network. Sharing the root passwords is not very elegant, and opens the door for abuse due to the anonymity such sharing creates. The solution to this problem is the <code
              class="command">sudo</code> program, which allows certain users to execute certain commands with special rights. In the most common use case, <code
              class="command">sudo</code> allows a trusted user to execute any command as root. To do so, the user simply executes <code
              class="command">sudo <em
                class="replaceable">command</em></code> and authenticates using their personal password.
			</div><div
            class="para">
				When installed, the <span
              class="pkg pkg">sudo</span> package gives full root rights to members of the <code
              class="literal">sudo</code> Unix group. To delegate other rights, the administrator must use the <code
              class="command">visudo</code> command, which allows them to modify the <code
              class="filename">/etc/sudoers</code> configuration file (here again, this will invoke the <code
              class="command">vi</code> editor, or any other editor indicated in the <code
              class="varname">EDITOR</code> environment variable). Adding a line with <code
              class="literal"><em
                class="replaceable">username</em> ALL=(ALL) ALL</code> allows the user in question to execute any command as root.
			</div><a
            id="id-1.11.13.6.7"
            class="indexterm"></a><a
            id="id-1.11.13.6.8"
            class="indexterm"></a><a
            id="id-1.11.13.6.9"
            class="indexterm"></a><div
            class="para">
				More sophisticated configurations allow authorization of only specific commands to specific users. All the details of the various possibilities are given in the <span
              class="citerefentry"><span
                class="refentrytitle">sudoers</span>(5)</span> man page.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.fstab-mount-points"></a>8.9.5. List of Mount Points</h3></div></div></div><a
            id="id-1.11.13.7.2"
            class="indexterm"></a><a
            id="id-1.11.13.7.3"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BACK TO BASICS</em></span> Mounting and unmounting</strong></p></div></div></div><div
              class="para">
				In a Unix-like system such as Debian, files are organized in a single tree-like hierarchy of directories. The <code
                class="filename">/</code> directory is called the “root directory”; all additional directories are sub-directories within this root. “Mounting” is the action of including the content of a peripheral device (often a hard drive) into the system's general file tree. As a consequence, if you use a separate hard drive to store users' personal data, this disk will have to be “mounted” in the <code
                class="filename">/home/</code> directory. The root filesystem is always mounted at boot by the kernel; other devices are often mounted later during the startup sequence or manually with the <code
                class="command">mount</code> command.
			</div><a
              id="id-1.11.13.7.4.3"
              class="indexterm"></a><div
              class="para">
				Some removable devices are automatically mounted when connected, especially when using the GNOME, KDE or other graphical desktop environments. Others have to be mounted manually by the user. Likewise, they must be unmounted (removed from the file tree). Normal users do not usually have permission to execute the <code
                class="command">mount</code> and <code
                class="command">umount</code> commands. The administrator can, however, authorize these operations (independently for each mount point) by including the <code
                class="literal">user</code> option in the <code
                class="filename">/etc/fstab</code> file.
			</div><div
              class="para">
				The <code
                class="command">mount</code> command can be used without arguments (it then lists all mounted filesystems). The following parameters are required to mount or unmount a device. For the complete list, please refer to the corresponding man pages, <span
                class="citerefentry"><span
                  class="refentrytitle">mount</span>(8)</span> and <span
                class="citerefentry"><span
                  class="refentrytitle">umount</span>(8)</span>. For simple cases, the syntax is simple too: for example, to mount the <code
                class="filename">/dev/sdc1</code> partition, which has an ext3 filesystem, into the <code
                class="filename">/mnt/tmp/</code> directory, you would simply run <code
                class="command">mount -t ext3 /dev/sdc1 /mnt/tmp/</code>.
			</div></div><div
            class="para">
				The <code
              class="filename">/etc/fstab</code> file gives a list of all possible mounts that happen either automatically on boot or manually for removable storage devices. Each mount point is described by a line with several space-separated fields: <a
              id="id-1.11.13.7.5.2"
              class="indexterm"></a> <a
              id="id-1.11.13.7.5.3"
              class="indexterm"></a>
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						device to mount: this can be a local partition (hard drive, CD-ROM) or a remote filesystem (such as NFS).
					</div><div
                  class="para">
						This field is frequently replaced with the unique ID of the filesystem (which you can determine with <code
                    class="command">blkid <strong
                      class="userinput"><code>device</code></strong></code>) prefixed with <code
                    class="literal">UUID=</code>. This guards against a change in the name of the device in the event of addition or removal of disks, or if disks are detected in a different order.
					</div></li><li
                class="listitem"><div
                  class="para">
						mount point: this is the location on the local filesystem where the device, remote system, or partition will be mounted.
					</div></li><li
                class="listitem"><div
                  class="para">
						type: this field defines the filesystem used on the mounted device. <code
                    class="literal">ext4</code>, <code
                    class="literal">ext3</code>, <code
                    class="literal">vfat</code>, <code
                    class="literal">ntfs</code>, <code
                    class="literal">btrfs</code>, <code
                    class="literal">xfs</code> are a few examples.
					</div><div
                  class="sidebar"><div
                    class="titlepage"><div><div><p
                          class="title"><strong><span
                              class="emphasis"><em>BACK TO BASICS</em></span> NFS, a network filesystem</strong></p></div></div></div><div
                    class="para">
						NFS is a network filesystem; under Linux, it allows transparent access to remote files by including them in the local filesystem.
					</div></div><div
                  class="para">
						A complete list of known filesystems is available in the <span
                    class="citerefentry"><span
                      class="refentrytitle">mount</span>(8)</span> man page. The <code
                    class="literal">swap</code> special value is for swap partitions; the <code
                    class="literal">auto</code> special value tells the <code
                    class="command">mount</code> program to automatically detect the filesystem (which is especially useful for disk readers and USB keys, since each one might have a different filesystem);
					</div></li><li
                class="listitem"><div
                  class="para">
						options: there are many of them, depending on the filesystem, and they are documented in the <code
                    class="command">mount</code> man page. The most common are
					</div><div
                  class="itemizedlist"><ul><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">rw</code> or <code
                          class="literal">ro</code>, meaning, respectively, that the device will be mounted with read/write or read-only permissions.
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">noauto</code> deactivates automatic mounting on boot.
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">nofail</code> allows the boot to proceed even when the device is not present. Make sure to put this option for external drives that might be unplugged when you boot, because <code
                          class="command">systemd</code> really ensures that all mount points that must be automatically mounted are actually mounted before letting the boot process continue to its end. Note that you can combine this with <code
                          class="literal">x-systemd.device-timeout=5s</code> to tell <code
                          class="command">systemd</code> to not wait more than 5 seconds for the device to appear (see <span
                          class="citerefentry"><span
                            class="refentrytitle">systemd.mount</span>(5)</span>).
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">user</code> authorizes all users to mount this filesystem (an operation which would otherwise be restricted to the root user).
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">defaults</code> means the group of default options: <code
                          class="literal">rw</code>, <code
                          class="literal">suid</code>, <code
                          class="literal">dev</code>, <code
                          class="literal">exec</code>, <code
                          class="literal">auto</code>, <code
                          class="literal">nouser</code> and <code
                          class="literal">async</code>, each of which can be individually disabled after <code
                          class="literal">defaults</code> by adding <code
                          class="literal">nosuid</code>, <code
                          class="literal">nodev</code> and so on to block <code
                          class="literal">suid</code>, <code
                          class="literal">dev</code> and so on. Adding the <code
                          class="literal">user</code> option reactivates it, since <code
                          class="literal">defaults</code> includes <code
                          class="literal">nouser</code>.
							</div></li></ul></div></li><li
                class="listitem"><div
                  class="para">
						backup: this field is almost always set to <code
                    class="literal">0</code>. When it is <code
                    class="literal">1</code>, it tells the <code
                    class="command">dump</code> tool that the partition contains data that is to be backed up.
					</div></li><li
                class="listitem"><div
                  class="para">
						check order: this last field indicates whether the integrity of the filesystem should be checked on boot, and in which order this check should be executed. If it is <code
                    class="literal">0</code>, no check is conducted. The root filesystem should have the value <code
                    class="literal">1</code>, while other permanent filesystems get the value <code
                    class="literal">2</code>.
					</div></li></ul></div><div
            class="example"><a
              xmlns=""
              id="example.fstab"></a><p
              class="title"><strong>Пример 8.5. Пример файла <code
                  class="filename">/etc/fstab</code></strong></p><div
              class="example-contents"><pre
                class="programlisting">
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
#  swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0</pre></div></div><div
            class="para">
				The last entry in this example corresponds to a network filesystem (NFS): the <code
              class="filename">/shared/</code> directory on the <span
              class="emphasis"><em>arrakis</em></span> server is mounted at <code
              class="filename">/shared/</code> on the local machine. The format of the <code
              class="filename">/etc/fstab</code> file is documented on the <span
              class="citerefentry"><span
                class="refentrytitle">fstab</span>(5)</span> man page.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>УГЛУБЛЯЕМСЯ</em></span> Автомонтирование</strong></p></div></div></div><div
              class="para">
				The <span
                class="emphasis"><em>am-utils</em></span> package provides the <code
                class="command">amd</code> auto-mounting utility, able to mount removable media on demand when a user attempts to access their usual mount point. It will unmount these devices when no process is accessing them any longer.
			</div><a
              id="id-1.11.13.7.9.3"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.4"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.5"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.6"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.7"
              class="indexterm"></a><div
              class="para">
				Other auto-mounting utilities exist, such as <code
                class="command">automount</code> in the <span
                class="emphasis"><em>autofs</em></span> package.
			</div><div
              class="para">
				Note also that GNOME, KDE, and other graphical desktop environments work together with <span
                class="emphasis"><em>udisks</em></span>, and can automatically mount removable media when they are connected.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.locate-updatedb"></a>8.9.6. <code
                    class="command">locate</code> and <code
                    class="command">updatedb</code></h3></div></div></div><a
            id="id-1.11.13.8.2"
            class="indexterm"></a><a
            id="id-1.11.13.8.3"
            class="indexterm"></a><a
            id="id-1.11.13.8.4"
            class="indexterm"></a><div
            class="para">
				The <code
              class="command">locate</code> command can find the location of a file when you only know part of the name. It sends a result almost instantaneously, since it consults a database that stores the location of all the files on the system; this database is updated daily by the <code
              class="command">updatedb</code> command. There are multiple implementations of the <code
              class="command">locate</code> command and Debian picked <span
              class="pkg pkg">mlocate</span> for its standard system.
			</div><div
            class="para">
				<code
              class="command">mlocate</code> is smart enough to only return files which are accessible to the user running the command even though it uses a database that knows about all files on the system (since its <code
              class="command">updatedb</code> implementation runs with root rights). For extra safety, the administrator can use <code
              class="varname">PRUNEDPATHS</code> in <code
              class="filename">/etc/updatedb.conf</code> to exclude some directories from being indexed.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-bootloader.html"><strong>Пред.</strong>8.8. Настройка Загрузчика</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Наверх</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Начало</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-compilation.html"><strong>След.</strong>8.10. Compiling a Kernel</a></li></ul></body></html>
