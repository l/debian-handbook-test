<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.5. Пространство пользователя</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-ru-RU-1.0-1" /><meta
        name="keywords"
        content="BIOS, Ядро, Unix, Процесс, Иерархия, Базовые команды" /><link
        rel="home"
        href="index.html"
        title="Настольная книга администратора Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Приложение B. Краткий Коррективный Курс" /><link
        rel="prev"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. Некоторые Выполняемые Ядром Задачи" /><link
        rel="next"
        href="backcover.html"
        title="Приложение C. Настольная книга администратора Debian" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/ru-RU/stable/sect.user-space.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Пред.</strong></a></li><li
          class="home">Настольная книга администратора Debian</li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>След.</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.user-space"></a>B.5. Пространство пользователя</h2></div></div></div><a
          id="id-1.21.8.2"
          class="indexterm"></a><a
          id="id-1.21.8.3"
          class="indexterm"></a><div
          class="para">
			“Пространство пользователя” относится к среде выполнения нормальных (в отличии от ядра) процессов. Это не обязательно означает, что процессы были запущены пользователем, потому что стандартная система обычно имеет несколько “демонов” (фоновых процессов), запускающихся до того как пользователь даже откроет сеанс. Демоны - также считаются процессами пользовательского пространства.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.process-basics"></a>B.5.1. Процесс</h3></div></div></div><a
            id="id-1.21.8.5.2"
            class="indexterm"></a><div
            class="para">
				Когда ядро находится на последней фазе его инициализации, оно запускает первый процесс - <code
              class="command">init</code>. Процесс #1 очень редко полезен сам по себе, и Unix-подобные системы работают с множеством дополнительных процессов.
			</div><a
            id="id-1.21.8.5.4"
            class="indexterm"></a><div
            class="para">
				Прежде всего, процесс может клонировать себя (это действие называется <span
              class="emphasis"><em>fork</em></span>). Ядро выделяет пространство в памяти (точно такое же как и для исходного процесса), и новый процесс его занимает. Единственная разница между этими двумя процессами - их <span
              class="emphasis"><em>pid</em></span>. Новый процесс обычно зовется дочерним процессом, а оригинальный (<span
              class="emphasis"><em>pid</em></span> которого не изменился) - родительским процессом.
			</div><div
            class="para">
				Иногда, дочерний процесс продолжает жить своей собственной жизнью независимо от родителя, со своими собственными данными, скопированными у родительского процесса. Во многих случаях, однако, этот дочерний процесс выполняется другой программой. За некоторыми исключениями, его память просто замещается новой программой, и начинается выполнение новой программы. Это механизм, используемый init процессом (с процессом #1) для запуска дополнительных сервисов и выполнения последовательности всей загрузки. В определенный момент один процесс из потомства <code
              class="command">init</code> запускает графический интерфейс для пользователей и входа в систему (подробно эта последовательность событий описана в <a
              class="xref"
              href="unix-services.html#sect.system-boot">Раздел 9.1, «Загрузка системы»</a>).
			</div><div
            class="para">
				Когда процесс выполняет задачу для которой он был запущен, он завершается. Затем ядро высвобождает память, выделенную для этого процесса и перестает предоставлять ему интервалы времени выполнения. Родительский процесс оповещается о том, что его дочерний процесс был завершен, что позволяет процессу ожидать выполнения задач, поставленных дочернему процессу. Это поведение ясно видно в интерпретаторе командной строки (известной как <span
              class="emphasis"><em>shells</em></span>). При вводе команды в командной строке, запрос возвращается только после завершения выполнения этой команды. Большинство оболочек позволяют выполнять команды в фоновом режиме (на заднем плане), для этого надо просто добавить <strong
              class="userinput"><code>&amp;</code></strong> в конец команды. Запрос тут же выводится снова, что может вызвать проблемы если команде нужно выводить ее собственные данные.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.daemons"></a>B.5.2. Демоны</h3></div></div></div><a
            id="id-1.21.8.6.2"
            class="indexterm"></a><a
            id="id-1.21.8.6.3"
            class="indexterm"></a><div
            class="para">
				“Демон” - это процесс, запускаемый автоматически в последовательности загрузки. Он продолжает работать (в фоновом режиме), выполняя задачи по обслуживанию или предоставлению сервисов другим процессам. Эти “фоновые задачи” на самом деле произвольны, и не соответствуют ничему конкретному, с точки зрения системы. Это просто процессы, очень похожие на другие процессы, которые выполняются в свои промежутки времени. Различие состоит только в человеческом языке: процесс, который выполняется без взаимодействия с пользователем (в частности, без графического интерфейса) называется “выполняющимся в фоновом режиме” или “демоном”.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>СЛОВАРЬ</em></span> Daemon, demon, уничижительный термин?</strong></p></div></div></div><div
              class="para">
				Хотя термин <span
                class="emphasis"><em>daemon</em></span> разделяет его Греческую этимологию с <span
                class="emphasis"><em>demon</em></span>, первый не подразумевает дьявольское зло, вместо этого, следует воспринимать его как своего рода вспомогательного духа. Это различие достаточно тонко в английском языке; и еще хуже в других языках, где то же самое слово используется для обоих значений.
			</div></div><div
            class="para">
				Несколько таких демонов подробно описаны в <a
              class="xref"
              href="unix-services.html">Глава 9, <em>Сервисы Unix</em></a>.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ipc"></a>B.5.3. Межпроцессное взаимодействие</h3></div></div></div><a
            id="id-1.21.8.7.2"
            class="indexterm"></a><a
            id="id-1.21.8.7.3"
            class="indexterm"></a><div
            class="para">
				Изолированный процесс, демон или интерактивное приложение, редко бывает полезным сам по себе, поэтому существует несколько методов, позволяющих отдельным процессам взаимодействовать друг с другом для обмена данными или управления друг другом. Общий термин обозначающий их - <span
              class="emphasis"><em>межпроцессное взаимодействие</em></span>, или коротко IPC (от англ. Inter-Process Communication).
			</div><div
            class="para">
				Простейшая система IPC - использование файлов. Процесс, желающий передать данные, пишет их в файл (с заранее известным именем), при этом получатель только открывает файл и читает его содержимое.
			</div><a
            id="id-1.21.8.7.6"
            class="indexterm"></a><div
            class="para">
				В случае, когда вы не хотите сохранять данные на диск, вы можете использовать <span
              class="emphasis"><em>канал</em></span>, который является простым объектом с двумя концами; байты, написанные в одном конце, доступны для чтения на другом. Это простой и удобный способ межпроцессного взаимодействия, т.к. концы управляются отдельными процессами. Каналы могут быть разделены на две категории: именованные и анонимные. Именованный канал представляет собой запись в файловой системе (хотя передаваемые данные не хранятся там), так оба процесса могут самостоятельно открыть его, если расположение именованного канала заранее известно. В тех случаях, когда взаимодействующие процессы связаны между собой (например, родительский и дочерний процессы), родительский процесс также может создать анонимный канал перед тем как "форкнется", а дочерний процесс наследует его. Таким образом оба процесса могут обмениваться данными через канал без необходимости задействовать файловую систему.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>НА ПРАКТИКЕ</em></span> Конкретный пример</strong></p></div></div></div><div
              class="para">
				Давайте опишем подробнее, что происходит когда составная команда (<span
                class="emphasis"><em>конвейер</em></span>) запускается в оболочке. Мы предполагаем, что у нас есть процесс <code
                class="command">bash</code> (стандартная оболочка в Debian), с <span
                class="emphasis"><em>pid</em></span> 4374; в этой оболочке мы вводим команду: <code
                class="command">ls | sort</code>.
			</div><div
              class="para">
				Вначале оболочка интерпретирует введенную команду. В нашем случае, он понимает, что это две программы (<code
                class="command">ls</code> и <code
                class="command">sort</code>) с потоком данных, идущим из одного в другой (обозначается знаком <strong
                class="userinput"><code>|</code></strong>, известным как <span
                class="emphasis"><em>канал</em></span>). Сначала <code
                class="command">bash</code> создает анонимный канал (который изначально существует только в рамках самого процесса <code
                class="command">bash</code>).
			</div><div
              class="para">
				Потом оболочка клонирует себя; это создает новый процесс <code
                class="command">bash</code> с <span
                class="emphasis"><em>pid</em></span> #4521 (<span
                class="emphasis"><em>идентификаторы процессов</em></span> - абстрактные номера, обычно не имеющие конкретного смысла). Процесс #4521 наследует канал, что означает, что он может писать в его “входную” часть; <code
                class="command">bash</code> перенаправляет его стандартный поток вывода во вход этого канала. Затем он выполняет программу <code
                class="command">ls</code> (и заменяет себя на нее), которая выводит список содержимого текущего каталога. Так как <code
                class="command">ls</code> пишет в свой стандартный вывод, а этот вывод был заранее перенаправлен, результат эффективно отправляется в канал.
			</div><div
              class="para">
				Похожая операция происходит и со второй командой: <code
                class="command">bash</code> клонирует себя снова, что создает новый процесс <code
                class="command">bash</code> с pid #4522. Так как это тоже дочерний процесс #4374, он также наследует канал; затем <code
                class="command">bash</code> соединяет его стандартный ввод с выходом канала, выполняет команду <code
                class="command">sort</code> (и заменяет себя на нее), которая сортирует ее входные данные и выводит результат.
			</div><div
              class="para">
				Теперь все кусочки головоломки собраны воедино: <code
                class="command">ls</code> читает текущую директорию и пишет список файлов в канал; <code
                class="command">sort</code> читает этот список, сортирует его в алфавитном порядке и выводит результат. Затем процессы с номерами #4521 и #4522 завершаются, а #4374 (который ждал их во время операции) возобновляет управление и выводит приглашение, позволяющее пользователю ввести новую команду.
			</div></div><div
            class="para">
				Однако, межпроцессное взаимодействие используется не только для передачи данных. Во многих ситуациях, единственная информация, которую нужно передать: это управляющие сообщения такие как “приостановить выполнения” или “возобновить выполнение”. Unix (и Linux) предоставляют механизм, известный как <span
              class="emphasis"><em>сигналы</em></span>, через которые процесс может легко отправлять другому процессу специальные сигналы, выбранные из определенного списка. Необходимо лишь знать <span
              class="emphasis"><em>pid</em></span> целевого процесса.
			</div><div
            class="para">
				Для более сложного взаимодействия существует механизм, предоставляющий процессу возможность открыть доступ (полностью или частично) к своей выделенной памяти другому процессу. Эта память может использоваться процессами для обмена данными между ними.
			</div><div
            class="para">
				Наконец, сетевое подключение может также помогать процессам взаимодействовать друг с другом; причем, эти процессы могут быть запущенны на разных компьютерах и находиться в тысячах километров друг от друга.
			</div><div
            class="para">
				Это нормально для Unix-подобных систем: использовать все эти механизмы в разной степени.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.libraries"></a>B.5.4. Библиотеки</h3></div></div></div><a
            id="id-1.21.8.8.2"
            class="indexterm"></a><div
            class="para">
				Библиотеки функций играют решающую роль в Unix-подобных операционных системах. Они не являются программами (они не могут быть выполнены самостоятельно), а представляют собой фрагменты кода, которые могут быть использованы обычными программами. Среди общих библиотек вы можете найти:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						стандартная библиотека C (<span
                    class="emphasis"><em>glibc</em></span>), содержащая базовые функции, такие как функции открывания файлов, сетевого соединения, и другие облегчающие взаимодействие с ядром функции;
					</div></li><li
                class="listitem"><div
                  class="para">
						графические инструментарии (такие как Gtk+ и Qt) позволяют множеству программ многократно использовать поддерживаемые ими графические объекты;
					</div></li><li
                class="listitem"><div
                  class="para">
						библиотека <span
                    class="emphasis"><em>libpng</em></span>, позволяющая загружать, интерпретировать и сохранять изображения в формате PNG.
					</div></li></ul></div><div
            class="para">
				Благодаря этим библиотекам, приложения могут многократно использовать уже существующий код. Разработка приложений упрощается, т.к. множество приложений может использовать одни и те же функции. С библиотеками, часто разрабатываемыми разными людьми, глобальная разработка системы становится ближе к исторической философии Unix.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>КУЛЬТУРА</em></span> Путь Unix: что-то одно</strong></p></div></div></div><div
              class="para">
				Одна из фундаментальных концепций, лежащих в основе семейства операционных систем Unix гласит: "каждый инструмент должен делать только одну вещь, и делать её хорошо; приложения могут впоследствии использовать эти инструменты для строительства в итоге более продвинутой логики". Эта философия просматривается во множестве воплощений. Скрипты оболочки могут быть лучшим примером: они собирают сложные последовательности из очень простых инструментов (таких как <code
                class="command">grep</code>, <code
                class="command">wc</code>, <code
                class="command">sort</code>, <code
                class="command">uniq</code> и т.д.). Еще одной реализацией этой философии являются библиотеки кода: библиотека <span
                class="emphasis"><em>libpng</em></span> позволяет считывать и записывать изображения в формате PNG с разными опциями и различными путями, но она делает только это; нет необходимости в функциях отображения или редактирования изображения.
			</div></div><div
            class="para">
				Кроме того, эти библиотеки часто называют “общими библиотеками”, так как ядро может загружать их в память единожды, тогда как несколько процессов будут использовать эти библиотеки одновременно. Это позволяет экономить память, в сравнении с обратной (гипотетической) ситуацией, когда код библиотеки будет загружаться в память столько раз, сколько процессов его использует.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Пред.</strong>B.4. Некоторые Выполняемые Ядром Задачи</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Наверх</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Начало</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>След.</strong>Приложение C. Настольная книга администратора Deb...</a></li></ul></body></html>
