<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.5. Ruang Pengguna</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-id-ID-1.0-1" /><meta
        name="keywords"
        content="BIOS, Kernel, Unix, Proses, Hirarki, Perintah-perintah Dasar" /><link
        rel="home"
        href="index.html"
        title="Buku Panduan Administrator Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Lampiran B. Kursus Remedial Singkat" /><link
        rel="prev"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. Beberapa Tugas yang Ditangani oleh Kernel" /><link
        rel="next"
        href="backcover.html"
        title="Lampiran C. Buku Panduan Administrator Debian" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/id-ID/stable/sect.user-space.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Sebelumnya</strong></a></li><li
          class="home">Buku Panduan Administrator Debian</li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Lanjut</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.user-space"></a>B.5. Ruang Pengguna</h2></div></div></div><a
          id="id-1.21.8.2"
          class="indexterm"></a><a
          id="id-1.21.8.3"
          class="indexterm"></a><div
          class="para">
			”Ruang pengguna” mengacu pada lingkungan runtime proses normal (sebagai lawan dari kernel). Ini tidak selalu berarti proses-proses ini benar-benar dimulai oleh pengguna karena sistem standar biasanya memiliki beberapa proses ”daemon” (atau latar belakang) yang berjalan sebelum pengguna bahkan membuka sesi. Proses daemon juga dianggap sebagai proses ruang pengguna.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.process-basics"></a>B.5.1. Proses</h3></div></div></div><a
            id="id-1.21.8.5.2"
            class="indexterm"></a><div
            class="para">
				Ketika kernel berhasil melewati tahap inisialisasi, ia memulai proses pertama, <code
              class="command">init</code>. Proses #1 sendiri sangat jarang berguna sendirian, dan sistem mirip Unix berjalan dengan banyak proses tambahan.
			</div><a
            id="id-1.21.8.5.4"
            class="indexterm"></a><div
            class="para">
				Pertama-tama, proses dapat mengklon dirinya sendiri (dikenal sebagai sebuah <span
              class="emphasis"><em>fork</em></span>). Kernel mengalokasikan ruang memori proses yang baru (tapi identik), dan proses lain yang menggunakannya. Saat ini, satu-satunya perbedaan antara dua proses ini adalah <span
              class="emphasis"><em>pid</em></span> mereka. Proses baru biasanya disebut proses anak, dan proses asli yang <span
              class="emphasis"><em>pid</em></span>-nya tidak berubah, disebut proses induk.
			</div><div
            class="para">
				Kadang-kadang, proses anak terus menjalani hidupnya sendiri secara mandiri dari induknya, dengan data sendiri yang disalin dari proses induk. Dalam banyak kasus, proses anak ini menjalankan program lain. Dengan beberapa pengecualian, memorinya hanya digantikan oleh program baru, dan eksekusi program baru ini dimulai. Ini adalah mekanisme yang digunakan oleh proses init (dengan proses nomor 1) untuk memulai layanan tambahan dan menjalankan seluruh urutan startup. Pada titik tertentu, satu proses di antara anak-anak <code
              class="command">init</code> memulai antarmuka grafis bagi pengguna untuk masuk (urutan kejadian yang sebenarnya dijelaskan lebih detail di <a
              class="xref"
              href="unix-services.html#sect.system-boot">Bagian 9.1, “Boot Sistem”</a>).
			</div><div
            class="para">
				Ketika sebuah proses menyelesaikan tugas yang dimulai, itu berakhir. Kernel kemudian memulihkan memori yang ditugaskan untuk proses ini, dan berhenti memberikannya irisan waktu berjalan. Proses induk diberitahu tentang proses anaknya yang dihentikan, yang memungkinkan proses untuk menunggu penyelesaian tugas yang didelegasikan kepada proses anak. Perilaku ini terlihat jelas dalam penerjemah baris perintah (dikenal sebagai <span
              class="emphasis"><em>shells</em></span>). Ketika sebuah perintah diketik ke dalam shell, prompt hanya akan kembali ketika eksekusi perintah selesai. Kebanyakan shell memungkinkan untuk menjalankan perintah di latar belakang, itu sekedar menambahkan <strong
              class="userinput"><code>&amp;</code></strong> ke ujung perintah. Prompt ditampilkan lagi segera, yang dapat menyebabkan masalah jika perintah perlu menampilkan data sendiri.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.daemons"></a>B.5.2. Daemon</h3></div></div></div><a
            id="id-1.21.8.6.2"
            class="indexterm"></a><a
            id="id-1.21.8.6.3"
            class="indexterm"></a><div
            class="para">
				A ”daemon” adalah proses yang dimulai secara otomatis oleh urutan boot. Itu terus berjalan (di latar belakang) untuk melakukan tugas-tugas pemeliharaan atau memberikan layanan ke proses lain. ”Tugas latar belakang” ini sebenarnya sebarang, dan tidak cocok dengan apa pun dari sudut pandang sistem. Mereka hanyalah proses, sangat mirip dengan proses lain, yang berjalan pada gilirannya ketika irisan waktu mereka datang. Perbedaannya hanya dalam bahasa manusia: sebuah proses yang berjalan tanpa interaksi dengan pengguna (khususnya, tanpa antarmuka grafis) dikatakan berjalan ”di latar belakang” atau ”sebagai daemon”.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>KOSA KATA</em></span> Daemon, demon, istilah yang merendahkan?</strong></p></div></div></div><div
              class="para">
				Meskipun istilah <span
                class="emphasis"><em>daemon</em></span> memiliki etimologi Yunani yang sama dengan <span
                class="emphasis"><em>demon</em></span> (setan), yang pertama tidak menyiratkan setan jahat, sebaliknya, harus dipahami sebagai semacam roh penolong. Perbedaan ini cukup halus dalam bahasa Inggris; hal ini bahkan lebih buruk dalam bahasa lain yang mana kata yang sama digunakan untuk kedua makna.
			</div></div><div
            class="para">
				Beberapa daemon tersebut dijelaskan secara rinci dalam <a
              class="xref"
              href="unix-services.html">Bab 9, <em>Layanan Unix</em></a>.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ipc"></a>B.5.3. Inter-Process Communications</h3></div></div></div><a
            id="id-1.21.8.7.2"
            class="indexterm"></a><a
            id="id-1.21.8.7.3"
            class="indexterm"></a><div
            class="para">
				Suatu proses yang terisolasi, apakah itu daemon atau aplikasi interaktif, jarang berguna saat berdiri sendiri, itulah sebabnya ada beberapa metode yang memungkinkan proses terpisah untuk saling berkomunikasi, baik untuk bertukar data atau mengendalikan satu sama lain. Istilah umum yang mengacu pada ini adalah <span
              class="emphasis"><em>inter-process communication</em></span>, atau disingkat IPC.
			</div><div
            class="para">
				Sistem IPC yang paling sederhana adalah menggunakan berkas. Proses yang ingin mengirim data menulis ke berkas (dengan nama diketahui sebelumnya), sementara renerima hanya harus membuka berkas dan mebaca isinya.
			</div><a
            id="id-1.21.8.7.6"
            class="indexterm"></a><div
            class="para">
				Dalam kasus dimana Anda tidak ingin menyimpan data pada disk, Anda dapat menggunakan <span
              class="emphasis"><em>pipe</em></span>, yang hanya merupakan objek dengan dua ujung; byte yang ditulis dalam satu ujung dapat dibaca di ujung yang lain. Jika ujungnya dikendalikan oleh proses terpisah, ini mengarah ke saluran komunikasi antar-proses yang sederhana dan nyaman. Pipa dapat diklasifikasikan menjadi dua kategori: pipa bernama, dan pipa anonim. Sebuah pipa bernama diwakili oleh sebuah entri pada sistem berkas (meskipun data yang ditransmisikan tidak disimpan di sana), sehingga kedua proses dapat membukanya secara independen jika lokasi dari pipa bernama diketahui sebelumnya. Dalam kasus dimana proses-proses yang berkomunikasi saling terkait (misalnya, induk dan proses anaknya), proses induk juga dapat membuat pipa anonim sebelum fork, dan anak mewarisi itu. Kedua proses kemudian akan dapat bertukar data melalui pipa tanpa perlu sistem berkas.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>DALAM PRAKTEK</em></span> Contoh konkret</strong></p></div></div></div><div
              class="para">
				Mari kita menjelaskan secara rinci apa yang terjadi ketika suatu perintah kompleks (suatu <span
                class="emphasis"><em>pipa</em></span>) dijalankan dari shell. Kita berasumsi kita memiliki proses <code
                class="command">bash</code> (shell pengguna standar pada Debian), dengan <span
                class="emphasis"><em>pid</em></span> 4374; ke shell ini, kita ketik perintah: <code
                class="command">ls | sort</code> .
			</div><div
              class="para">
				Shell pertama menafsirkan perintah yang diketikkan. Dalam kasus kita, ia mengerti ada dua program (<code
                class="command">ls</code> dan <code
                class="command">sort</code>), dengan data yang mengalir dari satu ke yang lain (dilambangkan oleh karakter <strong
                class="userinput"><code>|</code></strong>, dikenal sebagai <span
                class="emphasis"><em>pipa</em></span>). <code
                class="command">bash</code> pertama menciptakan pipa tanpa nama (yang awalnya ada hanya dalam proses <code
                class="command">bash</code> itu sendiri).
			</div><div
              class="para">
				Kemudian shell meng-klon dirinya sendiri; ini mengantar ke sebuah proses <code
                class="command">bash</code> baru, dengan <span
                class="emphasis"><em>pid</em></span> #4521 (<span
                class="emphasis"><em>pid</em></span> adalah bilangan abstrak, dan umumnya tidak punya arti khusus). Proses #4521 mewarisi pipa, yang berarti itu dapat menulis ke sisi “masukan”; <code
                class="command">bash</code> mengalihkan stream keluaran standarnya ke masukan pipa ini. Kemudian itu menjalankan (dan menggantikan dirinya sendiri dengan) program <code
                class="command">ls</code>, yang menampilkan daftar isi dari direktori saat ini. Karena <code
                class="command">ls</code> menulis ke keluaran standarnya, dan keluaran ini sebelumnya telah dialihkan, hasilnya secara efektif dikirim ke dalam pipa.
			</div><div
              class="para">
				Sebuah operasi serupa yang terjadi untuk perintah ke dua: <code
                class="command">bash</code> meng-klon dirinya sendiri lagi, mengarah ke proses <code
                class="command">bash</code> baru dengan pid #4522. Karena itu juga proses anak dari #4374, itu juga mewarisi pipa; <code
                class="command">bash</code> kemudian menghubungkan masukan standar ke keluaran pipa, lalu mengeksekusi (dan menggantikan dirinya sendiri dengan) perintah <code
                class="command">sort</code>, yang mengurutkan masukan dan menampilkan hasilnya.
			</div><div
              class="para">
				Semua potongan teka-teki sekarang siap: <code
                class="command">ls</code> membaca direktori saat ini dan menulis daftar berkas ke dalam pipa; <code
                class="command">sort</code> membaca daftar ini, mengurutkan berdasarkan abjad, dan menampilkan hasilnya. Proses nomor #4521 dan #4522 kemudian berakhir, dan #4374 (yang menunggu mereka selama operasi), melanjutkan kendali dan menampilkan sapaan yang memungkinkan pengguna untuk mengetik perintah baru.
			</div></div><div
            class="para">
				Tidak semua komunikasi antar-proses digunakan untuk memindahkan data. Dalam banyak situasi, satu-satunya informasi yang perlu ditransmisikan adalah pesan kontrol seperti “jeda eksekusi” atau “melanjutkan eksekusi”. Unix (dan Linux) menyediakan mekanisme yang dikenal sebagai <span
              class="emphasis"><em>sinyal</em></span>, dimana suatu proses dapat sekedar mengirim sinyal tertentu (dipilih dari daftar sinyal yang telah ditentukan) ke proses lain. Satu-satunya persyaratan adalah mengetahui <span
              class="emphasis"><em>pid</em></span> dari target.
			</div><div
            class="para">
				Untuk komunikasi yang lebih kompleks, ada juga mekanisme yang memungkinkan proses untuk membuka akses, atau berbagi, bagian dari memori yang dialokasikan untuk proses lain. Memori yang sekarang dipakai bersama di antara mereka dapat digunakan untuk memindahkan data antar proses.
			</div><div
            class="para">
				Akhirnya, koneksi jaringan juga dapat membantu proses-proses berkomunikasi; proses-proses ini bahkan dapat berjalan di komputer yang berbeda, mungkin terpisah ribuan kilometer.
			</div><div
            class="para">
				Sudah biasa bagi sistem mirip Unix untuk, sedikit banyak, menggunakan semua mekanisme ini.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.libraries"></a>B.5.4. Pustaka</h3></div></div></div><a
            id="id-1.21.8.8.2"
            class="indexterm"></a><div
            class="para">
				Pustaka fungsi memainkan peran penting dalam sistem operasi mirip Unix. Mereka bukan program yang utuh, karena mereka tidak dapat dieksekusi sendiri, tetapi merupakan koleksi fragmen kode yang dapat digunakan oleh program standar. Di antara pustaka umum, Anda dapat menemukan:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						pustaka C standar (<span
                    class="emphasis"><em>glibc</em></span>), yang berisi fungsi-fungsi dasar seperti untuk membuka berkas atau koneksi jaringan, dan yang lain memfasilitasi interaksi dengan kernel;
					</div></li><li
                class="listitem"><div
                  class="para">
						toolkit grafis, seperti Gtk+ dan Qt, memungkinkan banyak program untuk menggunakan kembali objek grafis yang mereka sediakan;
					</div></li><li
                class="listitem"><div
                  class="para">
						pustaka <span
                    class="emphasis"><em>libpng</em></span>, yang memungkinkan memuat, menafsirkan, dan menyimpan gambar dalam format PNG.
					</div></li></ul></div><div
            class="para">
				Berkat pustaka tersebut, aplikasi dapat menggunakan kembali kode yang ada. Pengembangan aplikasi disederhanakan karena banyak aplikasi dapat menggunakan kembali fungsi yang sama. Dengan pustaka yang sering dikembangkan oleh orang yang berbeda, perkembangan global dari sistem lebih dekat dengan filosofi sejarah Unix.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BUDAYA</em></span> Cara Unix: satu hal pada suatu waktu</strong></p></div></div></div><div
              class="para">
				Satu dari konsep fundamental yang mendasari keluarga sistem operasi Unix adalah bahwa setiap alat mesti hanya melakukan satu hal, dan melakukannya dengan baik; aplikasi kemudian dapat memakai lagi alat-alat ini untuk membangun lebih banyak logika tingkat lanjut di atasnya. Filosofi ini dapat dilihat dalam banyak inkarnasi. Skrip shell mungkin adalah contoh terbaik: mereka merangkai urutan yang kompleks dari alat-alat yang sangat sederhana (seperti misalnya <code
                class="command">grep</code>, <code
                class="command">wc</code>, <code
                class="command">sort</code>, <code
                class="command">uniq</code>, dan seterusnya). Implementasi lain dari filosofi ini dapat dilihat dalam pustaka kode: pustaka <span
                class="emphasis"><em>libpng</em></span> memungkinkan membaca dan menulis citra-citra PNG, dengan opsi-opsi lain dan dalam cara-cara yang berbeda, tapi hanya melakukan itu; tidak ada pertanyaan untuk memasukkan fungsi-fungsi yang menampilkan atau menyunting citra.
			</div></div><div
            class="para">
				Selain itu, pustaka ini sering dirujuk sebagai “pustaka bersama”, karena kernel bisa hanya memuat mereka ke dalam memori sekali, bahkan jika beberapa proses menggunakan pustaka yang sama pada waktu yang sama. Hal ini memungkinkan penghematan memori, bila dibandingkan dengan situasi (hipotetis) sebaliknya dimana kode untuk pustaka akan dimuat sebanyak proses yang menggunakannya.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Sebelumnya</strong>B.4. Beberapa Tugas yang Ditangani oleh Kernel</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Induk</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Depan</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Lanjut</strong>Lampiran C. Buku Panduan Administrator Debian</a></li></ul></body></html>
