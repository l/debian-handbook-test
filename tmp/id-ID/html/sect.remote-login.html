<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.2. Log Masuk Jarak Jauh</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-id-ID-1.0-1" /><meta
        name="keywords"
        content="Boot sistem, Initscript, SSH, Telnet, Hak, Izin, Pengawasan, Inetd, Cron, Cadangan, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Buku Panduan Administrator Debian" /><link
        rel="up"
        href="unix-services.html"
        title="Bab 9. Layanan Unix" /><link
        rel="prev"
        href="unix-services.html"
        title="Bab 9. Layanan Unix" /><link
        rel="next"
        href="sect.rights-management.html"
        title="9.3. Mengelola Hak" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/id-ID/stable/sect.remote-login.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Sebelumnya</strong></a></li><li
          class="home">Buku Panduan Administrator Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Lanjut</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.remote-login"></a>9.2. Log Masuk Jarak Jauh</h2></div></div></div><div
          class="para">
			Sangat penting bagi administrator untuk dapat menyambung ke suatu komputer dari jarak jauh. Server, dikurung dalam kamar mereka sendiri, jarang dilengkapi dengan papan ketik dan monitor permanen — tetapi mereka terhubung ke jaringan.
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>KEMBALI KE DASAR</em></span> Klien, server</strong></p></div></div></div><a
            id="id-1.12.5.3.2"
            class="indexterm"></a><a
            id="id-1.12.5.3.3"
            class="indexterm"></a><div
            class="para">
			Sebuah sistem yang beberapa prosesnya berkomunikasi satu sama lain sering digambarkan dengan metafora "klien/server". Server adalah program yang mengambil permintaan yang datang dari klien dan mengeksekusi mereka. Ini adalah klien yang mengendalikan operasi, server tidak mengambil setiap inisiatif sendiri.
		</div></div><a
          id="id-1.12.5.4"
          class="indexterm"></a><a
          id="id-1.12.5.5"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ssh"></a>9.2.1. Login Jarak Jauh Aman: SSH</h3></div></div></div><a
            id="id-1.12.5.6.2"
            class="indexterm"></a><a
            id="id-1.12.5.6.3"
            class="indexterm"></a><div
            class="para">
				Protokol <span
              class="emphasis"><em>SSH</em></span> (Secure SHell) dirancang dengan keamanan dan kehandalan. Koneksi yang menggunakan SSH aman: mitra diotentikasi dan semua pertukaran data dienkripsi.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BUDAYA</em></span> Telnet dan RSH itu usang</strong></p></div></div></div><a
              id="id-1.12.5.6.5.2"
              class="indexterm"></a><a
              id="id-1.12.5.6.5.3"
              class="indexterm"></a><div
              class="para">
				Sebelum SSH, <span
                class="emphasis"><em>Telnet</em></span> dan <span
                class="emphasis"><em>RSH</em></span> adalah alat utama yang digunakan untuk login jarak jauh. Mereka sekarang sebagian besar usang dan sebaiknya tidak lagi digunakan bahkan walaupun Debian masih menyediakan mereka.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>KOSAKATA</em></span> Otentikasi, enkripsi</strong></p></div></div></div><div
              class="para">
				Ketika Anda perlu memberikan klien kemampuan untuk melakukan atau memicu tindakan pada server, keamanan penting. Anda harus memastikan identitas dari klien; ini adalah otentikasi. Identitas ini biasanya terdiri dari password yang harus dirahasiakan, atau klien lain jadi bisa mendapatkankan password tersebut. Ini adalah tujuan dari enkripsi, yang merupakan bentuk enkoding yang memungkinkan dua sistem untuk mengkomunikasikan informasi rahasia pada saluran umum sekaligus melindungi dari dapat dibaca oleh orang lain.
			</div><div
              class="para">
				Otentikasi dan enkripsi sering disebut bersama, baik karena mereka sering digunakan bersama-sama, dan karena mereka biasanya diimplementasikan dengan konsep-konsep matematika yang serupa.
			</div></div><div
            class="para">
				SSH juga menawarkan dua layanan transfer berkas. <code
              class="command">SCP</code> adalah alat baris perintah yang dapat digunakan seperti <code
              class="command">cp</code>, kecuali bahwa sebarang path ke mesin lain diawali dengan nama mesin, diikuti oleh titik dua.
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>scp berkas mesin:/tmp/</code></strong></pre><div
            class="para">
				<code
              class="command">sftp</code> adalah perintah yang interaktif, mirip dengan <code
              class="command">ftp</code>. Dalam satu sesi, <code
              class="command">sftp</code> dapat mentransfer beberapa berkas, dan mungkin untuk memanipulasi berkas remote dengannya (menghapus, mengubah nama, mengubah hak akses, dll).
			</div><a
            id="id-1.12.5.6.10"
            class="indexterm"></a><a
            id="id-1.12.5.6.11"
            class="indexterm"></a><div
            class="para">
				Debian menggunakan OpenSSH, sebuah SSH versi gratis yang dikelola oleh proyek <code
              class="command">OpenBSD</code> (sistem operasi bebas berbasis pada kernel BSD, berfokus pada keamanan) dan fork dari perangkat lunak SSH asli yang dikembangkan oleh perusahaan SSH Communication Corp, dari Finlandia. Perusahaan ini awalnya mengembangkan SSH sebagai perangkat lunak bebas, tetapi akhirnya memutuskan untuk melanjutkan perkembangan di bawah lisensi tak bebas. Proyek OpenBSD kemudian menciptakan OpenSSH untuk mempertahankan versi gratis dari SSH.
			</div><a
            id="id-1.12.5.6.13"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>KEMBALI KE DASAR</em></span> <span
                        class="foreignphrase"><em
                          class="foreignphrase">Fork</em></span></strong></p></div></div></div><a
              id="id-1.12.5.6.14.2"
              class="indexterm"></a><div
              class="para">
				"Fork", dalam bidang perangkat lunak, berarti sebuah proyek baru yang dimulai sebagai klon dari proyek yang sudah ada, dan akan bersaing dengannya. Dari sana, kedua perangkat lunak biasanya cepat akan menyimpang dalam hal perkembangan baru. Fork ini sering merupakan akibat dari perselisihan dalam tim pengembangan.
			</div><div
              class="para">
				Pilihan untuk melakukan fork atas sebuah proyek adalah akibat langsung dari sifat perangkat lunak bebas; fork merupakan kejadian yang sehat saat itu memungkinkan keberlanjutan proyek sebagai perangkat lunak bebas (misalnya dalam kasus perubahan lisensi). Sebuah fork yang timbul dari perselisihan teknis atau pribadi sering membuang-buang sumber daya manusia; resolusi lain akan lebih baik. Merger dua proyek yang sebelumnya mengalami fork bukan tidak pernah terjadi.
			</div></div><div
            class="para">
				OpenSSH dipecah menjadi dua paket: bagian klien dalam paket <span
              class="pkg pkg">openssh-client</span>, dan server dalam paket <span
              class="pkg pkg">openssh-server</span>. Meta-paket <span
              class="pkg pkg">ssh</span> bergantung pada kedua bagian dan memfasilitasi instalasi keduanya (<code
              class="command">apt install ssh</code>).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-key-based-auth"></a>9.2.1.1. Otentikasi Berbasis Kunci</h4></div></div></div><div
              class="para">
					Setiap kali seseorang log masuk melalui SSH, server remote meminta password untuk mengotentikasi pengguna. Ini bisa menjadi bermasalah jika Anda ingin mengotomatisasi sambungan, atau jika Anda menggunakan alat yang membutuhkan koneksi sering melalui SSH. Inilah sebabnya mengapa SSH menawarkan sistem otentikasi berbasis kunci.
				</div><div
              class="para">
					Pengguna membuat sepasang kunci pada mesin klien dengan <code
                class="command">ssh-keygen-t rsa</code>; kunci publik disimpan dalam <code
                class="filename">~/.ssh/id_rsa.pub</code>, sementara kunci privat disimpan dalam <code
                class="filename">~/.ssh/id_rsa</code>. Pengguna kemudian menggunakan <code
                class="command">ssh-copy-id <em
                  class="replaceable">server</em></code> untuk menambahkan kunci publik mereka ke berkas <code
                class="filename">~/.ssh/authorized_keys</code> pada server. Jika kunci privat tidak dilindungi dengan "frasa sandi" pada saat penciptaan, semua login berikutnya pada server akan bekerja tanpa kata sandi. Sebaliknya, kunci pribadi harus didekripsi setiap kali dengan memasukkan kata sandi. Untungnya, <code
                class="command">ssh-agent</code> memungkinkan kita untuk menjaga kunci privat dalam memori untuk tidak perlu secara teratur memasukkan kembali kata sandi. Untuk ini, Anda hanya menggunakan <code
                class="command">ssh-add</code> (sekali per sesi) asalkan sesi sudah terkait dengan instansi fungsional <code
                class="command">ssh-agent</code>. Debian mengaktifkannya secara default dalam sesi grafis, tapi ini dapat dinonaktifkan dengan mengubah <code
                class="filename">/etc/X11/Xsession.options</code>. Untuk sesi konsol, Anda dapat secara manual memulainya dengan <code
                class="command">eval $(ssh-agent)</code>.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KEAMANAN</em></span> Perlindungan kunci privat</strong></p></div></div></div><div
                class="para">
					Barangsiapa memiliki kunci privat tersebut dapat login di akun yang dikonfigurasi. Inilah sebabnya mengapa akses ke kunci privat dilindungi oleh "frasa sandi". Seseorang yang memperoleh salinan berkas kunci pribvat (misalnya, <code
                  class="filename">~/.ssh/id_rsa</code>) masih harus tahu frasa ini agar dapat menggunakannya. Perlindungan tambahan ini tidak anti tembus, dan jika Anda berpikir bahwa berkas ini telah dikompromikan, paling baik untuk menonaktifkan kunci tersebut pada komputer tempat itu telah diinstal (dengan menghapus dari berkas <code
                  class="filename">authorized_keys</code>) dan menggantikannya dengan kunci baru yang dibuat.
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KULTUR</em></span> Cacat OpenSSL dalam Debian <span
                          class="distribution distribution">Etch</span></strong></p></div></div></div><div
                class="para">
					Pustaka OpenSSL, sebagaimana awalnya disediakan di Debian <span
                  class="distribution distribution">Etch</span>, memiliki masalah yang serius dalam pembangkit angka acak (RNG). Memang, pengelola Debian telah membuat perubahan sehingga aplikasi yang menggunakan itu tidak lagi menghasilkan peringatan ketika dianalisis oleh alat pengujian memori seperti <code
                  class="command">valgrind</code>. Sayangnya, perubahan ini juga berarti bahwa RNG hanya mempekerjakan salah satu sumber entropi sesuai dengan nomor proses (PID) yang 32.000 kemungkinan nilainya tidak menawarkan cukup keacakan. <div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="http://www.debian.org/security/2008/dsa-1571">http://www.debian.org/security/2008/dsa-1571</a></div>
				</div><div
                class="para">
					Secara khusus, setiap kali OpenSSL digunakan untuk menghasilkan sebuah kunci, itu selalu menghasilkan kunci dalam kumpulan ratusan ribu kunci yang dikenal (32.000 dikalikan dengan sejumlah kecil panjang kunci). Ini mempengaruhi kunci SSH, kunci SSL, dan sertifikat X.509 yang digunakan oleh banyak aplikasi, seperti misalnya OpenVPN. Seorang cracker hanya perlu mencoba semua kunci untuk mendapatkan akses yang tidak sah. Untuk mengurangi dampak dari masalah, SSH daemon diubah untuk menolak bermasalah kunci yang tercantum dalam paket <span
                  class="pkg pkg">openssh-blacklist</span> dan <span
                  class="pkg pkg">openssh-blacklist-extra</span>. Selain itu, perintah <code
                  class="command">ssh-vulnkey</code> memungkinkan identifikasi kunci yang mungkin terkompromikan dalam sistem.
				</div><div
                class="para">
					Analisis lebih mendalam terhadap kejadian ini mengungkap bahwa itu adalah hasil dari beberapa masalah (kecil), baik dalam proyek OpenSSL dan dengan para pengelola paket Debian. Sebuah perpustakaan yang banyak digunakan seperti OpenSSL harus — tanpa modifikasi — tidak menghasilkan peringatan saat diuji oleh <code
                  class="command">valgrind</code>. Selain itu, kode (terutama bagian RNG yang sensitif) harus memuat komentar yang lebih baik untuk mencegah kesalahan tersebut. Di sisi Debian, pengelola ingin memvalidasi modifikasi dengan pengembang OpenSSL, tetapi hanya menjelaskan modifikasi tanpa memberikan patch yang sesuai untuk ditinjau dan gagal untuk menyebutkan perannya dalam Debian. Akhirnya, pilihan-pilihan perawatan sub-optimal: perubahan yang dibuat ke kode asli tidak didokumentasikan jelas; semua modifikasi secara efektif tersimpan dalam repositori Subversion, tapi mereka akhirnya semua digabung ke dalam satu patch selama penciptaan sumber paket.
				</div><div
                class="para">
					It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="http://sources.debian.org">http://sources.debian.org</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-x11"></a>9.2.1.2. Menggunakan Aplikasi-aplikasi X11 Jarak Jauh</h4></div></div></div><div
              class="para">
					Protokol SSH memungkinkan penerusan data grafis (sesi "X11", dari nama sistem grafis yang paling terkenal di Unix); server kemudian mempertahankan saluran khusus untuk data tersebut. Secara khusus, program grafis yang dijalankan dari jarak jauh dapat ditampilkan pada layar lokal server XFree86, dan seluruh sesi (masukan dan tampilan) akan aman. Karena fitur ini memungkinkan aplikasi remote untuk mengganggu sistem lokal, ini dinonaktifkan secara default. Anda dapat mengaktifkannya dengan menetapkan <code
                class="literal">X11Forwarding yes</code> di berkas konfigurasi server (<code
                class="filename">/etc/ssh/sshd_config</code>). Akhirnya, pengguna juga harus memintanya dengan menambahkan opsi <code
                class="literal">-X</code> untuk baris perintah <code
                class="command">ssh</code>.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-port-forwarding"></a>9.2.1.3. Menciptakan Tunnel Terenkripsi dengan Penerusan Port</h4></div></div></div><a
              id="id-1.12.5.6.18.2"
              class="indexterm"></a><div
              class="para">
					Opsi <code
                class="literal">-R</code> dan <code
                class="literal">-L</code> memungkinkan <code
                class="command">ssh</code> untuk menciptakan "terowongan terenkripsi" antara dua mesin, secara aman meneruskan port TCP lokal (lihat sidebar <a
                class="xref"
                href="network-infrastructure.html#sidebar.tcp-udp"><span
                  class="emphasis"><em>KEMBALI KE DASAR</em></span> TCP/UDP</a>) ke mesin remote atau sebaliknya.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KOSAKATA</em></span> Tunnel</strong></p></div></div></div><a
                id="id-1.12.5.6.18.4.2"
                class="indexterm"></a><a
                id="id-1.12.5.6.18.4.3"
                class="indexterm"></a><div
                class="para">
					Internet, dan kebanyakan LAN yang terhubung, beroperasi dalam mode paket dan tidak dalam modus yang terhubung, berarti bahwa paket yang diterbitkan dari satu komputer ke yang lain akan berhenti di beberapa router perantara untuk menemukan jalan ke tujuan. Anda masih dapat mensimulasikan operasi yang terhubung dimana stream dibungkus dalam paket-paket IP normal. Paket ini mengikuti rute biasa mereka, tapi stream ini direkonstruksi tidak berubah di tujuan. Kami menyebutnya "tunnel", analog dengan terowongan jalan tempat kendaraan langsung berjalan dari pintu masuk (masukan) ke tempat keluar (keluaran) tanpa menemui persimpangan apapun, dibandingkan dengan jalur pada permukaan yang akan melibatkan persimpangan dan mengubah arah.
				</div><div
                class="para">
					Anda dapat menggunakan kesempatan ini untuk menambahkan enkripsi ke tunnel: stream yang mengalir melaluinya kemudian tidak dikenali dari luar, tapi dikembalikan ke dalam bentuk terdekripsi di pintu keluar tunnel.
				</div></div><div
              class="para">
					<code
                class="command">ssh -L 8000:server:25 perantara</code> menjalin suatu sesi SSH dengan host <em
                class="replaceable">perantara</em> dan mendengarkan port lokal 8000 (lihat <a
                class="xref"
                href="sect.remote-login.html#figure.ssh-L">Gambar 9.3, “Penerusan suatu port lokal dengan SSH”</a>). Untuk sebarang koneksi yang terjalin pada port ini, <code
                class="command">ssh</code> akan memulai koneksi dari komputer <em
                class="replaceable">perantara</em> ke port 25 pada <em
                class="replaceable">server</em>, dan akan mengikat kedua koneksi bersama-sama.
				</div><div
              class="para">
					<code
                class="command">ssh -R 8000:server:25 perantara</code> juga menjalin sesi SSH ke komputer <em
                class="replaceable">perantara</em>, tetapi pada mesin ini <code
                class="command">ssh</code> mendengarkan port 8000 (lihat <a
                class="xref"
                href="sect.remote-login.html#figure.ssh-R">Gambar 9.4, “Penerusan suatu port jauh dengan SSH”</a>). Sebarang koneksi yang dijalin pada port ini akan menyebabkan <code
                class="command">ssh</code> membuka koneksi dari mesin lokal ke port 25 <em
                class="replaceable">server</em> dan mengikat kedua koneksi bersama-sama.
				</div><div
              class="para">
					Dalam kedua kasus, sambungan dibuat ke port 25 pada host <em
                class="replaceable">server</em>, melewati tunnel SSH yang dijalin antara mesin lokal dan mesin <em
                class="replaceable">perantara</em>. Dalam kasus pertama, pintu masuk ke tunnel adalah port lokal 8000, dan data bergerak menuju mesin <em
                class="replaceable">perantara</em> sebelum diarahkan ke <em
                class="replaceable">server</em> pada jaringan "publik". Dalam kedua kasus, masukan dan keluaran di tunnel dibalik; pintu masuk adalah port 8000 pada mesin <em
                class="replaceable">perantara</em>, keluaran adalah pada host lokal, dan data diarahkan ke <em
                class="replaceable">server</em>. Dalam prakteknya, server ini biasanya mesin lokal atau perantara. Dengan cara itu SSH mengamankan koneksi dari satu ujung ke yang lain.
				</div><div
              class="figure"><a
                xmlns=""
                id="figure.ssh-L"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-L.png"
                    alt="Penerusan suatu port lokal dengan SSH" /></div></div><p
                class="title"><strong>Gambar 9.3. Penerusan suatu port lokal dengan SSH</strong></p></div><div
              class="figure"><a
                xmlns=""
                id="figure.ssh-R"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-R.png"
                    alt="Penerusan suatu port jauh dengan SSH" /></div></div><p
                class="title"><strong>Gambar 9.4. Penerusan suatu port jauh dengan SSH</strong></p></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.remote-desktops"></a>9.2.2. Memakai Desktop Grafis Jarak Jauh</h3></div></div></div><div
            class="para">
				VNC (Virtual Network Computing) memungkinkan akses remote ke desktop grafis.
			</div><a
            id="id-1.12.5.7.3"
            class="indexterm"></a><a
            id="id-1.12.5.7.4"
            class="indexterm"></a><a
            id="id-1.12.5.7.5"
            class="indexterm"></a><a
            id="id-1.12.5.7.6"
            class="indexterm"></a><a
            id="id-1.12.5.7.7"
            class="indexterm"></a><div
            class="para">
				Alat ini banyak digunakan untuk bantuan teknis; administrator dapat melihat kesalahan yang dihadapi pengguna, dan menunjukkan kepada mereka tindakan yang benar tanpa harus berdiri di samping mereka.
			</div><a
            id="id-1.12.5.7.9"
            class="indexterm"></a><a
            id="id-1.12.5.7.10"
            class="indexterm"></a><a
            id="id-1.12.5.7.11"
            class="indexterm"></a><div
            class="para">
				First, the user must authorize sharing their session. The GNOME graphical desktop environment in <span
              class="distribution distribution">Jessie</span> includes that option in its configuration panel (contrary to previous versions of Debian, where the user had to install and run <code
              class="command">vino</code>). KDE Plasma still requires using <code
              class="command">krfb</code> to allow sharing an existing session over VNC. For other graphical desktop environments, the <code
              class="command">x11vnc</code> command (from the Debian package of the same name) serves the same purpose; you can make it available to the user with an explicit icon.
			</div><a
            id="id-1.12.5.7.13"
            class="indexterm"></a><a
            id="id-1.12.5.7.14"
            class="indexterm"></a><a
            id="id-1.12.5.7.15"
            class="indexterm"></a><a
            id="id-1.12.5.7.16"
            class="indexterm"></a><div
            class="para">
				When the graphical session is made available by VNC, the administrator must connect to it with a VNC client. GNOME has <code
              class="command">vinagre</code> and <code
              class="command">remmina</code> for that, while the KDE project provides <code
              class="command">krdc</code> (in the menu at <span
              class="guimenu"><strong>K</strong></span> → <span
              class="guisubmenu"><strong>Internet</strong></span> → <span
              class="guimenuitem"><strong>Remote Desktop Client</strong></span>). There are other VNC clients that use the command line, such as <code
              class="command">xvnc4viewer</code> in the Debian package of the same name. Once connected, the administrator can see what is going on, work on the machine remotely, and show the user how to proceed.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>KEAMANAN</em></span> VNC di atas SSH</strong></p></div></div></div><a
              id="id-1.12.5.7.18.2"
              class="indexterm"></a><div
              class="para">
				Jika Anda ingin terhubung oleh VNC, dan Anda tidak ingin data Anda dikirim dalam bentuk teks polos pada jaringan, mungkin untuk membungkus data dalam tunnel SSH (lihat <a
                class="xref"
                href="sect.remote-login.html#sect.ssh-port-forwarding">Bagian 9.2.1.3, “Menciptakan Tunnel Terenkripsi dengan Penerusan Port”</a>). Anda hanya perlu tahu bahwa VNC menggunakan port 5900 secara default untuk layar pertama (disebut "localhost:0"), 5901 untuk kedua (disebut "localhost:1"), dll.
			</div><div
              class="para">
				Perintah <code
                class="command">ssh -L localhost:5901:localhost:5900 -N -T <em
                  class="replaceable">mesin</em></code> menciptakan sebuah tunnel antara port lokal 5901 di antarmuka localhost dan port 5900 host <em
                class="replaceable">mesin</em>. "localhost" pertama membatasi SSH untuk mendengarkan hanya pada antarmuka tersebut di komputer lokal. "localhost" kedua menunjukkan antarmuka pada mesin remote yang akan menerima lalu lintas jaringan masuk "localhost:5901". Dengan demikian <code
                class="command">vncviewer localhost:1</code> akan menghubungkan klien VNC ke layar remote, meskipun Anda menunjukkan nama dari mesin lokal.
			</div><div
              class="para">
				Ketika sesi VNC ditutup, ingatlah untuk menutup tunnel juga dengan menghentikan sesi SSH yang sesuai.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>KEMBALI KE DASAR</em></span> Manajer tampilan</strong></p></div></div></div><a
              id="id-1.12.5.7.19.2"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.3"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.4"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.5"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.6"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.7"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">gdm3</code>, <code
                class="command">kdm</code>, <code
                class="command">lightdm</code>, dan <code
                class="command">xdm</code> adalah Manajer Tampilan. Mereka mengambil kontrol antarmuka grafis tak lama setelah boot untuk menyediakan layar login ke pengguna. Setelah pengguna login, mereka menjalankan program-program yang dibutuhkan untuk memulai sesi grafis.
			</div></div><div
            class="para">
				VNC juga bekerja untuk pengguna ponsel, atau eksekutif perusahaan, yang kadang-kadang perlu untuk login dari rumah mereka untuk mengakses desktop remote seperti yang mereka gunakan di tempat kerja. Konfigurasi layanan seperti itu lebih rumit: Anda pertama memasang paket <span
              class="pkg pkg">vnc4server</span>, mengubah konfigurasi dari layar manajer untuk menerima permintaan <code
              class="literal">XDMCP Query</code> (untuk <code
              class="command">gdm3 </code>, ini dapat dilakukan dengan menambahkan <code
              class="literal">Enable=true</code> di bagian "xdmcp" <code
              class="filename">/etc/gdm3/daemon.conf</code>), dan akhirnya, memulai server VNC dengan <code
              class="command">inetd</code> sehingga sesi secara otomatis dimulai ketika pengguna mencoba untuk login. Misalnya, Anda dapat menambahkan baris ini untuk <code
              class="filename">/etc/inetd.conf</code>:
			</div><pre
            class="programlisting">5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</pre><div
            class="para">
				Mengarahkan koneksi masuk ke manajer tampilan memecahkan masalah otentikasi, karena hanya pengguna dengan akun lokal yang akan melewati layar login <code
              class="command">gdm3</code> (atau yang setara <code
              class="command">kdm</code>, <code
              class="command">xdm</code>, dll). Karena operasi ini memungkinkan beberapa login simultan tanpa masalah (asal server cukup kuat), bahkan dapat digunakan untuk menyediakan desktop yang lengkap bagi pengguna ponsel (atau untuk sistem desktop yang kurang kuat, dikonfigurasi sebagai thin client). Pengguna cukup login ke layar server dengan <code
              class="command">vncviewer <em
                class="replaceable">server</em>:50</code>, karena port yang digunakan adalah 5950.
			</div><a
            id="id-1.12.5.7.23"
            class="indexterm"></a></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Sebelumnya</strong>Bab 9. Layanan Unix</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Induk</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Depan</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Lanjut</strong>9.3. Mengelola Hak</a></li></ul></body></html>
