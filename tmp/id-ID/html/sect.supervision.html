<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.3. Supervisi: Pencegahan, Deteksi, Deteren</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-id-ID-1.0-1" /><meta
        name="keywords"
        content="Firewall, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="Buku Panduan Administrator Debian" /><link
        rel="up"
        href="security.html"
        title="Bab 14. Keamanan" /><link
        rel="prev"
        href="sect.firewall-packet-filtering.html"
        title="14.2. Firewall atau Penyaringan Paket" /><link
        rel="next"
        href="sect.apparmor.html"
        title="14.4. Pengantar AppArmor" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/id-ID/stable/sect.supervision.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Sebelumnya</strong></a></li><li
          class="home">Buku Panduan Administrator Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Lanjut</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.supervision"></a>14.3. Supervisi: Pencegahan, Deteksi, Deteren</h2></div></div></div><a
          id="id-1.17.6.2"
          class="indexterm"></a><div
          class="para">
			Pemantauan adalah bagian integral dari kebijakan keamanan untuk beberapa alasan. Di antara mereka, bahwa tujuan keamanan adalah biasanya tidak terbatas pada menjamin kerahasiaan data, tetapi juga termasuk memastikan ketersediaan layanan. Oleh karena itu sangat penting untuk memeriksa bahwa semuanya bekerja seperti yang diharapkan, dan untuk mendeteksi tepat perilaku menyimpang atau mengubah kualitas layanan yang diberikan. Memantau aktivitas dapat membantu mendeteksi upaya intrusi dan memungkinkan reaksi cepat sebelum mereka menimbulkan konsekuensi serius. Bagian ini mengulas beberapa alat yang dapat digunakan untuk memonitor beberapa aspek dari sistem Debian. Dengan demikian, itu melengkapi <a
            class="xref"
            href="sect.monitoring.html">Bagian 12.4, “Pemantauan”</a>.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.logcheck"></a>14.3.1. Memantau Log dengan <code
                    class="command">logcheck</code></h3></div></div></div><a
            id="id-1.17.6.4.2"
            class="indexterm"></a><a
            id="id-1.17.6.4.3"
            class="indexterm"></a><a
            id="id-1.17.6.4.4"
            class="indexterm"></a><div
            class="para">
				Program <code
              class="command">logcheck</code> memonitor berkas log setiap jam secara default. Ia akan mengirimkan pesan-pesan log yang tidak biasa melalui email ke administrator untuk analisa lebih lanjut.
			</div><div
            class="para">
				Daftar berkas yang dipantau disimpan dalam <code
              class="filename">/etc/logcheck/logcheck.logfiles</code>; nilai-nilai default bekerja dengan baik jika berkas <code
              class="filename">/etc/rsyslog.conf</code> belum dibongkar habis.
			</div><div
            class="para">
				<code
              class="command">logcheck</code> dapat bekerja di salah satu dari tiga mode yang lebih atau kurang rinci: <span
              class="emphasis"><em>paranoid</em></span>, <span
              class="emphasis"><em>server</em></span>, dan <span
              class="emphasis"><em>workstation</em></span>. Yang pertama adalah <span
              class="emphasis"><em>sangat</em></span> rinci, dan mungkin dapat dibatasi ke server tertentu seperti firewall. Modus kedua (dan default) dianjurkan bagi kebanyakan server. Terakhir dirancang untuk workstation, dan ini bahkan lebih ringkas (itu menyaring lebih banyak pesan).
			</div><div
            class="para">
				Dalam ketiga kasus, <code
              class="command">logcheck</code> mungkin perlu disesuaikan untuk mengecualikan beberapa pesan tambahan (tergantung pada layanan yang terpasang), kecuali jika admin benar-benar ingin menerima batch per jam surel-surel panjang yang tidak menarik. Karena mekanisme pemilihan pesan agak rumit, perlu membaca <code
              class="filename">/usr/share/doc/logcheck-database/README.logcheck-database.gz</code> — walaupun menantang.
			</div><div
            class="para">
				Aturan yang diterapkan dapat dipecah menjadi beberapa jenis:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						yang memenuhi syarat sebuah pesan sebagai upaya memecah kata sandi (disimpan dalam berkas dalam direktori <code
                    class="filename">/etc/logcheck/cracking.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						yang membatalkan kualifikasi seperti itu (<code
                    class="filename">/etc/logcheck/cracking.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						yang mengklasifikasi pesan sebagai sebuah peringatan keamanan (<code
                    class="filename">/etc/logcheck/violations.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						yang membatalkan klasifikasi ini (<code
                    class="filename">/etc/logcheck/violations.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						akhirnya, yang diterapkan ke pesan yang tersisa (dianggap sebagai <span
                    class="emphasis"><em>kejadian-kejadian sistem</em></span>).
					</div></li></ul></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>HATI-HATI</em></span> Mengabaikan suatu pesan</strong></p></div></div></div><div
              class="para">
				Setiap pesan yang ditandai sebagai upaya crack atau sebuah peringatan keamanan (mengikuti aturan yang disimpan dalam berkas <code
                class="filename">/etc/logcheck/violations.d/myfile</code>) hanya dapat diabaikan oleh aturan di berkas <code
                class="filename">/etc/logcheck/violations.ignore.d/myfile</code> atau <code
                class="filename">/etc/logcheck/violations.ignore.d/myfile-<em
                  class="replaceable">ekstensi</em></code>.
			</div></div><div
            class="para">
				Suatu kejadian sistem selalu diberi sinyal kecuali aturan di salah satu dari direktori <code
              class="filename">/etc/logcheck/ignore.d.{paranoid, server, workstation}/</code> menyatakan bahwa kejadian tersebut harus diabaikan. Tentu saja, direktori yang diperhitungkan adalah hanya mereka yang tingkat verbositasnya sama atau lebih dari mode operasi yang dipilih.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.monitoring-activity"></a>14.3.2. Memantau Aktivitas</h3></div></div></div><a
            id="id-1.17.6.5.2"
            class="indexterm"></a><a
            id="id-1.17.6.5.3"
            class="indexterm"></a><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.real-time-monitoring"></a>14.3.2.1. Secara Real Time</h4></div></div></div><div
              class="para">
					<code
                class="command">top</code> adalah alat interaktif yang menampilkan daftar proses yang sedang berjalan. Pengurutan baku berdasarkan banyaknya menggunakan prosesor pada saat ini dan dapat diperoleh dengan tombol <span
                class="keycap"><strong>P</strong></span>. Urutan lain termasuk besarnya memori yamg diduduki (<span
                class="keycap"><strong>M</strong></span> kunci), oleh waktu total prosesor (kunci <span
                class="keycap"><strong>T</strong></span>), dan pengenal proses (<span
                class="keycap"><strong>N</strong></span> kunci). Kunci <span
                class="keycap"><strong>k</strong></span> memungkinkan mematikan suatu proses dengan memasukkan pengenal prosesnya. Kunci <span
                class="keycap"><strong>r</strong></span> memungkinkan <span
                class="emphasis"><em>pengaturan ulang nice</em></span> proses, yaitu mengubah prioritas.
				</div><a
              id="id-1.17.6.5.4.3"
              class="indexterm"></a><div
              class="para">
					Ketika sistem tampaknya terbeban lebih, <code
                class="command">top</code> adalah alat yang hebat untuk melihat proses yang bersaing untuk waktu prosesor atau mengkonsumsi terlalu banyak memori. Secara khusus, hal ini sering menarik untuk diperiksa jika proses yang memakan sumber daya cock dengan layanan nyata yang diketahui diwadahi oleh mesin ini. Proses tidak dikenal yang berjalan sebagai pengguna www-data akan menonjol dan mesti diselidiki, karena mungkin adalah suatu instansi perangkat lunak yang diinstal dan dijalankan pada sistem melalui kerentanan dalam aplikasi web.
				</div><div
              class="para">
					<code
                class="command">top</code> adalah alat yang sangat fleksibel dan halaman manualnya memberikan rincian tentang bagaimana menyesuaikan tampilan dan mengadaptasi ke kebutuhan pribadi dan kebiasaan seseorang.
				</div><div
              class="para">
					Alat grafis <code
                class="command">gnome-system-monitor</code> mirip dengan <code
                class="command">top</code> dan kurang lebih menyediakan fitur yang sama.
				</div><a
              id="id-1.17.6.5.4.7"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.monitoring-history"></a>14.3.2.2. Riwayat</h4></div></div></div><a
              id="id-1.17.6.5.5.2"
              class="indexterm"></a><div
              class="para">
					Beban prosesor, lalu lintas jaringan, dan ruang bebas disk adalah informasi yang terus-menerus berubah. Mencatat riwayat evolusi mereka sering berguna dalam menentukan persis bagaimana komputer digunakan.
				</div><a
              id="id-1.17.6.5.5.4"
              class="indexterm"></a><a
              id="id-1.17.6.5.5.5"
              class="indexterm"></a><div
              class="para">
					Ada banyak alat khusus untuk tugas ini. Sebagian dapat mengambil data melalui SNMP (<span
                class="emphasis"><em>Simple Network Management Protocol</em></span>) untuk memusatkan informasi ini. Manfaat tambahan adalah bahwa hal ini memungkinkan pengambilan data dari elemen-elemen jaringan yang mungkin bukan komputer untuk keperluan umum, seperti router jaringan atau switch.
				</div><div
              class="para">
					Buku ini membahas Munin secara cukup rinci (lihat <a
                class="xref"
                href="sect.monitoring.html#sect.munin">Bagian 12.4.1, “Menyiapkan Munin”</a>) sebagai bagian dari <a
                class="xref"
                href="advanced-administration.html">Bab 12: “<em>Administrasi Tingkat Lanjut</em>”</a>. Debian juga menyediakan alat yang mirip, <span
                class="pkg pkg">cacti</span>. Penggelarannya sedikit lebih rumit, karena didasarkan semata-mata pada SNMP. Meskipun memiliki antarmuka web, menangkap konsep yang terlibat dalam konfigurasi masih memerlukan usaha. Membaca dokumentasi HTML (<code
                class="filename">/usr/share/doc/cacti/html/index.html</code>) mesti dianggap sebagai prasyarat.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIF</em></span> <code
                          class="command">mrtg</code></strong></p></div></div></div><a
                id="id-1.17.6.5.5.8.2"
                class="indexterm"></a><div
                class="para">
					<code
                  class="command">mrtg</code> (dalam paket yang bernama sama) adalah alat yang lebih tua. Meskipun ada beberapa sisi kasar, ini dapat mengumpulkan data historis dan menampilkan mereka sebagai grafik. Ini mencakup sejumlah skrip yang didedikasikan untuk pengumpulan data paling sering dipantau seperti beban prosesor, trafik jaringan, klik halaman web, dan sebagainya.
				</div><div
                class="para">
					Paket-paket <span
                  class="pkg pkg">mrtg-contrib</span> dan <span
                  class="pkg pkg">mrtgutils</span> berisi contoh skrip-skrip yang dapat digunakan secara langsung.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.17.6.6"></a>14.3.3. Mendeteksi Perubahan</h3></div></div></div><div
            class="para">
				Setelah sistem diinstal dan dikonfigurasi, dan selain peningkatan keamanan, biasanya tidak ada alasan bagi sebagian besar berkas dan direktori untuk berevolusi, kecuali data. Oleh karena itu menarik untuk memastikan bahwa berkas sebenarnya tidak berubah: setiap perubahan yang tidak terduga akan layak untuk diselidiki. Bagian ini menyajikan beberapa alat yang dapat memonitor berkas dan memperingatkan administrator ketika terjadi perubahan yang tidak terduga (atau hanya untuk membuat daftar perubahan tersebut).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.dpkg-verify"></a>14.3.3.1. Mengaudit Paket-paket dengan <code
                      class="command">dpkg --verify</code></h4></div></div></div><a
              id="id-1.17.6.6.3.2"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>LEBIH JAUH</em></span> Melindungi terhadap perubahan hulu</strong></p></div></div></div><div
                class="para">
					<code
                  class="command">dpkg --verify</code> berguna dalam mendeteksi perubahan atas berkas-berkas yang berasal dari paket Debian, tetapi tidak akan berguna jika paket itu sendiri terkompromi, misalnya jika cermin Debian terkompromi. Melindungi terhadap serangan kelas ini melibatkan penggunaan sistem verifikasi tanda tangan digital APT (lihat <a
                  class="xref"
                  href="sect.package-authentication.html">Bagian 6.5, “Pemeriksaan Otentikasi Paket”</a>), dan hanya menginstal paket dari asal yang bersertifikat.
				</div></div><div
              class="para">
					<code
                class="command">dpkg --verify</code> (atau <code
                class="command">dpkg -V</code>) adalah alat yang menarik karena memungkinkan mencari berkas terpasang mana yang telah dimodifikasi (mungkin oleh penyerang), tapi ini tidak boleh dipercaya begitu saja. Untuk melakukan tugasnya, dia bergantung pada checksum yang disimpan dalam basis data dpkg sendiri yang ada pada hard disk (dapat ditemukan di <code
                class="filename">/var/lib/dpkg/info/<em
                  class="replaceable">paket</em> .md5sums</code>); penyerang yang menyeluruh karena itu akan memperbarui berkas ini sehingga mereka mengandung checksum baru untuk berkas yang dipalsukan.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KEMBALI KE DASAR</em></span> Sidik jari berkas</strong></p></div></div></div><a
                id="id-1.17.6.6.3.5.2"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.3"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.4"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.5"
                class="indexterm"></a><div
                class="para">
					As a reminder: a fingerprint is a value, often a number (even though in hexadecimal notation), that contains a kind of signature for the contents of a file. This signature is calculated with an algorithm (MD5 or SHA1 being well-known examples) that more or less guarantee that even the tiniest change in the file contents implies a change in the fingerprint; this is known as the “avalanche effect”. This allows a simple numerical fingerprint to serve as a litmus test to check whether the contents of a file have been altered. These algorithms are not reversible; in other words, for most of them, knowing a fingerprint doesn't allow finding the corresponding contents. Recent mathematical advances seem to weaken the absoluteness of these principles, but their use is not called into question so far, since creating different contents yielding the same fingerprint still seems to be quite a difficult task.
				</div></div><div
              class="para">
					Running <code
                class="command">dpkg -V</code> will verify all installed packages and will print out a line for each file with a failing test. The output format is the same as the one of <code
                class="command">rpm -V</code> where each character denotes a test on some specific meta-data. Unfortunately <code
                class="command">dpkg</code> does not store the meta-data needed for most tests and will thus output question marks for them. Currently only the checksum test can yield a "5" on the third character (when it fails).
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>dpkg -V</code></strong>
<code
                class="computeroutput">??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</code></pre><div
              class="para">
					In the sample above, dpkg reports a change to SSH's service file that the administrator made to the packaged file instead of using an appropriate <code
                class="filename">/etc/systemd/system/ssh.service</code> override (which would be stored below <code
                class="filename">/etc</code> like any configuration change should be). It also lists multiple configuration files (identified by the "c" letter on the second field) that had been legitimately modified.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.debsums"></a>14.3.3.2. Mengaudit Paket: <code
                      class="command">debsums</code> dan keterbatasannya</h4></div></div></div><a
              id="id-1.17.6.6.4.2"
              class="indexterm"></a><div
              class="para">
					<code
                class="command">debsums</code> is the ancestor of <code
                class="command">dpkg -V</code> and is thus mostly obsolete. It suffers from the same limitations than dpkg. Fortunately, some of the limitations can be worked-around (whereas dpkg does not offer similar work-arounds).
				</div><div
              class="para">
					Since the data on the disk cannot be trusted, <code
                class="command">debsums</code> offers to do its checks based on <code
                class="filename">.deb</code> files instead of relying on dpkg's database. To download trusted <code
                class="filename">.deb</code> files of all the packages installed, we can rely on APT's authenticated downloads. This operation can be slow and tedious, and should therefore not be considered a proactive technique to be used on a regular basis.
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</code></strong>
<code
                class="computeroutput">[ ... ]
# </code><strong
                class="userinput"><code>debsums -p /var/cache/apt/archives --generate=all</code></strong></pre><div
              class="para">
					Note that this example uses the <code
                class="command">grep-status</code> command from the <span
                class="pkg pkg">dctrl-tools</span> package, which is not installed by default.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.6.6.5"></a>14.3.3.3. Memantau Berkas: AIDE</h4></div></div></div><a
              id="id-1.17.6.6.5.2"
              class="indexterm"></a><div
              class="para">
					The AIDE tool (<span
                class="emphasis"><em>Advanced Intrusion Detection Environment</em></span>) allows checking file integrity, and detecting any change against a previously recorded image of the valid system. This image is stored as a database (<code
                class="filename">/var/lib/aide/aide.db</code>) containing the relevant information on all files of the system (fingerprints, permissions, timestamps and so on). This database is first initialized with <code
                class="command">aideinit</code>; it is then used daily (by the <code
                class="filename">/etc/cron.daily/aide</code> script) to check that nothing relevant changed. When changes are detected, AIDE records them in log files (<code
                class="filename">/var/log/aide/*.log</code>) and sends its findings to the administrator by email.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DALAM PRAKTEK</em></span> Melindungi basis data</strong></p></div></div></div><div
                class="para">
					Since AIDE uses a local database to compare the states of the files, the validity of its results is directly linked to the validity of the database. If an attacker gets root permissions on a compromised system, they will be able to replace the database and cover their tracks. A possible workaround would be to store the reference data on read-only storage media.
				</div></div><div
              class="para">
					Many options in <code
                class="filename">/etc/default/aide</code> can be used to tweak the behavior of the <span
                class="pkg pkg">aide</span> package. The AIDE configuration proper is stored in <code
                class="filename">/etc/aide/aide.conf</code> and <code
                class="filename">/etc/aide/aide.conf.d/</code> (actually, these files are only used by <code
                class="command">update-aide.conf</code> to generate <code
                class="filename">/var/lib/aide/aide.conf.autogenerated</code>). Configuration indicates which properties of which files need to be checked. For instance, the contents of log files changes routinely, and such changes can be ignored as long as the permissions of these files stay the same, but both contents and permissions of executable programs must be constant. Although not very complex, the configuration syntax is not fully intuitive, and reading the <span
                class="citerefentry"><span
                  class="refentrytitle">aide.conf</span>(5)</span> manual page is therefore recommended.
				</div><div
              class="para">
					A new version of the database is generated daily in <code
                class="filename">/var/lib/aide/aide.db.new</code>; if all recorded changes were legitimate, it can be used to replace the reference database.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIF</em></span> Tripwire dan Samhain</strong></p></div></div></div><div
                class="para">
					Tripwire is very similar to AIDE; even the configuration file syntax is almost the same. The main addition provided by <span
                  class="pkg pkg">tripwire</span> is a mechanism to sign the configuration file, so that an attacker cannot make it point at a different version of the reference database.
				</div><div
                class="para">
					Samhain also offers similar features, as well as some functions to help detecting rootkits (see the sidebar <a
                  class="xref"
                  href="sect.supervision.html#sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"><span
                    class="emphasis"><em>LIHAT CEPAT</em></span> Paket-paket <span
                    class="pkg pkg">checksecurity</span> dan <span
                    class="pkg pkg">chkrootkit</span>/<span
                    class="pkg pkg">rkhunter</span></a>). It can also be deployed globally on a network, and record its traces on a central server (with a signature).
				</div></div><div
              class="sidebar"><a
                xmlns=""
                id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"></a><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>LIHAT CEPAT</em></span> Paket-paket <span
                          class="pkg pkg">checksecurity</span> dan <span
                          class="pkg pkg">chkrootkit</span>/<span
                          class="pkg pkg">rkhunter</span></strong></p></div></div></div><a
                id="id-1.17.6.6.5.8.2"
                class="indexterm"></a><div
                class="para">
					The first of these packages contains several small scripts performing basic checks on the system (empty passwords, new setuid files, and so on) and warning the administrator if required. Despite its explicit name, an administrator should not rely solely on it to make sure a Linux system is secure.
				</div><div
                class="para">
					The <span
                  class="pkg pkg">chkrootkit</span> and <span
                  class="pkg pkg">rkhunter</span> packages allow looking for <span
                  class="emphasis"><em>rootkits</em></span> potentially installed on the system. As a reminder, these are pieces of software designed to hide the compromise of a system while discreetly keeping control of the machine. The tests are not 100% reliable, but they can usually draw the administrator's attention to potential problems.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.intrusion-detection"></a>14.3.4. Mendeteksi Intrusi (IDS/NIDS)</h3></div></div></div><a
            id="id-1.17.6.7.2"
            class="indexterm"></a><a
            id="id-1.17.6.7.3"
            class="indexterm"></a><a
            id="id-1.17.6.7.4"
            class="indexterm"></a><a
            id="id-1.17.6.7.5"
            class="indexterm"></a><a
            id="id-1.17.6.7.6"
            class="indexterm"></a><a
            id="id-1.17.6.7.7"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>KEMBALI KE DASAR</em></span> Denial of service</strong></p></div></div></div><a
              id="id-1.17.6.7.8.2"
              class="indexterm"></a><div
              class="para">
				A “denial of service” attack has only one goal: to make a service unavailable. Whether such an attack involves overloading the server with queries or exploiting a bug, the end result is the same: the service is no longer operational. Regular users are unhappy, and the entity hosting the targeted network service suffers a loss in reputation (and possibly in revenue, for instance if the service was an e-commerce site).
			</div><div
              class="para">
				Such an attack is sometimes “distributed”; this usually involves overloading the server with large numbers of queries coming from many different sources so that the server becomes unable to answer the legitimate queries. These types of attacks have gained well-known acronyms: <acronym
                class="acronym">DDoS</acronym> and <acronym
                class="acronym">DoS</acronym> (depending on whether the denial of service attack is distributed or not).
			</div></div><div
            class="para">
				<code
              class="command">suricata</code> (in the Debian package of the same name) is a NIDS — a <span
              class="emphasis"><em>Network Intrusion Detection System</em></span>. Its function is to listen to the network and try to detect infiltration attempts and/or hostile acts (including denial of service attacks). All these events are logged in multiple files in <code
              class="filename">/var/log/suricata</code>. There are third party tools (Kibana/logstash) to better browse all the data collected. <div
              xmlns=""
              class="url">→ <a
                xmlns="http://www.w3.org/1999/xhtml"
                href="http://suricata-ids.org">http://suricata-ids.org</a></div> <div
              xmlns=""
              class="url">→ <a
                xmlns="http://www.w3.org/1999/xhtml"
                href="https://www.elastic.co/products/kibana">https://www.elastic.co/products/kibana</a></div>
			</div><a
            id="id-1.17.6.7.10"
            class="indexterm"></a><a
            id="id-1.17.6.7.11"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>HATI-HATI</em></span> Rentang aksi</strong></p></div></div></div><div
              class="para">
				The effectiveness of <code
                class="command">suricata</code> is limited by the traffic seen on the monitored network interface. It will obviously not be able to detect anything if it cannot observe the real traffic. When plugged into a network switch, it will therefore only monitor attacks targeting the machine it runs on, which is probably not the intention. The machine hosting <code
                class="command">suricata</code> should therefore be plugged into the “mirror” port of the switch, which is usually dedicated to chaining switches and therefore gets all the traffic.
			</div></div><div
            class="para">
				Configuring suricata involves reviewing and editing <code
              class="filename">/etc/suricata/suricata-debian.yaml</code>, which is very long because each parameter is abundantly commented. A minimal configuration requires describing the range of addresses that the local network covers (<code
              class="literal">HOME_NET</code> parameter). In practice, this means the set of all potential attack targets. But getting the most of it requires reading it in full and adapting it to the local situation.
			</div><div
            class="para">
				On top of this, you should also edit <code
              class="filename">/etc/default/suricata</code> to define the network interface to monitor and to enable the init script (by setting <code
              class="literal">RUN=yes</code>). You might also want to set <code
              class="literal">LISTENMODE=pcap</code> because the default <code
              class="literal">LISTENMODE=nfqueue</code> requires further configuration to work properly (the netfilter firewall must be configured to pass packets to some user-space queue handled by suricata via the <code
              class="literal">NFQUEUE</code> target).
			</div><div
            class="para">
				To detect bad behaviour, <code
              class="command">suricata</code> needs a set of monitoring rules: you can find such rules in the <span
              class="pkg pkg">snort-rules-default</span> package. <code
              class="command">snort</code> is the historical reference in the IDS ecosystem and <code
              class="command">suricata</code> is able to reuse rules written for it. Unfortunately that package is missing from <span
              class="distribution distribution">Debian Jessie</span> and should be retrieved from another Debian release like <span
              class="distribution distribution">Testing</span> or <span
              class="distribution distribution">Unstable</span>.
			</div><div
            class="para">
				Alternatively, <code
              class="command">oinkmaster</code> (in the package of the same name) can be used to download Snort rulesets from external sources.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>LEBIH LANJUT</em></span> Integrasi dengan <code
                        class="command">prelude</code></strong></p></div></div></div><div
              class="para">
				Prelude brings centralized monitoring of security information. Its modular architecture includes a server (the <span
                class="emphasis"><em>manager</em></span> in <span
                class="pkg pkg">prelude-manager</span>) which gathers alerts generated by <span
                class="emphasis"><em>sensors</em></span> of various types.
			</div><div
              class="para">
				Suricata dapat dikonfigurasi sebagai sebuah sensor. Kemungkinan lain adalah <span
                class="emphasis"><em>prelude-lml</em></span> (<span
                class="emphasis"><em>Log Monitor Lackey</em></span>) yang memonitor berkas log (dengan cara yang mirip dengan <code
                class="command">logcheck</code>, dijelaskan dalam <a
                class="xref"
                href="sect.supervision.html#sect.logcheck">Bagian 14.3.1, “Memantau Log dengan <code
                  class="command">logcheck</code>”</a>).
			</div><a
              id="id-1.17.6.7.17.4"
              class="indexterm"></a></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Sebelumnya</strong>14.2. Firewall atau Penyaringan Paket</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Induk</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Depan</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Lanjut</strong>14.4. Pengantar AppArmor</a></li></ul></body></html>
