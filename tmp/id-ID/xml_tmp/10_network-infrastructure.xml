<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="network-infrastructure">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-network-infrastructure.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Jaringan</keyword>
      <keyword>Gateway</keyword>
      <keyword>TCP/IP</keyword>
      <keyword>IPv6</keyword>
      <keyword>DNS</keyword>
      <keyword>Bind</keyword>
      <keyword>DHCP</keyword>
      <keyword>QoS</keyword>
    </keywordset>
  </chapterinfo>
  <title id="infrastructure.title">Infrastruktur Jaringan</title>
  <highlights>
    <para>Linux memperoleh seluruh warisan Unix untuk jaringan, dan Debian menyediakan set lengkap peralatan untuk membuat dan mengelola mereka. Bab ini mengulas peralatan tersebut.</para>
  </highlights>
  <section id="sect.gateway">
    <title>Gateway</title>

    <para>Gateway adalah sebuah sistem yang menghubungkan beberapa jaringan. Istilah ini sering mengacu pada "titik keluar" jaringan lokal pada jalur wajib untuk semua alamat IP eksternal. Gateway terhubung ke masing-masing jaringan yang dihubungkannya, dan bertindak sebagai sebuah router untuk menyampaikan paket-paket IP antara berbagai antarmuka.</para>
    <indexterm><primary>gateway</primary></indexterm>
    <indexterm><primary>network</primary><secondary>gateway</secondary></indexterm>
    <indexterm><primary>router</primary></indexterm>

    <sidebar>
      <title><emphasis>KEMBALI KE DASAR</emphasis> paket IP</title>
      <indexterm><primary>paket</primary><secondary>IP</secondary></indexterm>

      <para>Sebagian besar jaringan saat ini menggunakan protokol IP (<emphasis>Internet Protocol</emphasis>). Protokol ini mensegmentasi data yang ditransmisikan ke paket-paket ukuran terbatas. Setiap packet berisi, selain muatan datanya, sejumlah rincian yang diperlukan untuk routing yang tepat.</para>
    </sidebar>

    <sidebar id="sidebar.tcp-udp">
      <title><emphasis>KEMBALI KE DASAR</emphasis> TCP/UDP</title>
      <indexterm><primary>port</primary><secondary>TCP</secondary></indexterm>
      <indexterm><primary>port</primary><secondary>UDP</secondary></indexterm>
      <indexterm><primary>TCP, port</primary></indexterm>
      <indexterm><primary>UDP, port</primary></indexterm>

      <para>Banyak program yang tidak menangani sendiri paket-paket individu, walaupun data yang mereka transmisikan berjalan melalui IP; mereka sering memakai TCP (<emphasis>Transmission Control Protocol</emphasis>). TCP adalah suatu lapisan di atas IP yang mengizinkan terjalinnya koneksi yang didedikasikan ke stream data antara dua titik. Program kemudian hanya melihat suatu titik masuk tempat data diasupkan dengan garansi bahwa data yang sama keluar tanpa ada kehilangan (dan dalam urutan yang sama) di titik keluar di ujung lain koneksi. Walaupun banyak jenis kesalahan dapat terjadi dalam lapisan-lapisan yang lebih rendah, mereka dikompensasi oleh TCP: paket hilang dipancarkan ulang, dan paket yang datang tak berurut (sebagai contoh, bila mereka memakai path yang berbeda) diurutkan ulang secara tepat.</para>

      <para>Protokol lain yang mengandalkan IP adalah UDP (<emphasis>User Datagram Protocol</emphasis>). Berbeda dengan TCP, ini berorientasi paket. Sasarannya berbeda: tujuan UDP hanya untuk mentransmisikan satu paket dari sebuah aplikasi ke lainnya. Protokol tidak mencoba mengkompensasi kemungkinan kehilangan paket di jalan, maupun tidak memastikan bahwa paket diterima dalam urutan yang sama dengan saat dikirim. Keuntungan utama atas protokol ini adalah latensinya jauh lebih baik, karena kehilangan satu paket tidak menunda penerimaan semua paket yang mengikuti sampai satu yang hilang ditransmisikan ulang.</para>

      <para>TCP dan UDP keduanya melibatkan port, yang merupakan “nomor ekstensi” untuk menjalin komunikasi dengan suatu aplikasi pada sebuah mesin. Konsep ini mengizinkan menjaga beberapa komunikasi yang berbeda secara paralel dengan korespondensi yang sama, karena komunikasi ini dapat dibedakan menurut nomor portnya.</para>

      <para>Beberapa dari nomor port ini — distandarkan oleh IANA (<emphasis>Internet Assigned Numbers Authority</emphasis>) — "dikenal baik" berasosiasi dengan layanan-layanan jaringan. Sebagai contoh, TCP port 25 biasanya dipakai oleh server surel. <ulink type="block" url="http://www.iana.org/assignments/port-numbers" /></para>
    </sidebar>

    <para>Ketika suatu jaringan lokal memakai sebuah rentang alamat privat (yang tidak dapat di-route di Internet), gateway perlu mengimplementasikan <emphasis>masquerading alamat</emphasis> sehingga mesin-mesin pada jaringan dapat berkomunikasi dengan dunia luar. Operasi masquerading adalah semacam proksi yang beroperasi pada level jaringa: setiap koneksi arah luar dari suatu mesin internal digantikan dengan suatu koneksi dari gateway itu sendiri (karena gateway memiliki alamat eksternal, yang dapat di-route), data yang melalui koneksi yang di-masquerade dikirim ke yang baru, dan data yang kembali dalam jawaban dikirim melalui koneksi yang di-masquerade ke mesin internal. Gateway memakai suatu rentang port TCP yang terdedikasi untuk tujuan ini, biasanya dengan nomor sangat tinggi (di atas 60000). Setiap koneksi yang datang dari suatu mesin internal kemudian muncul ke dunia luar sebagai suatu koneksi yang datang dari salah satu port yang dicadangkan ini.</para>
    <indexterm><primary>masquerading</primary></indexterm>

    <sidebar>
      <title><emphasis>KULTUR</emphasis> Rentang alamat privat</title>
      <indexterm><primary>alamat IP</primary><secondary>privat</secondary></indexterm>
      <indexterm><primary>alamat IP privat</primary></indexterm>

      <para>RFC 1918 mendefinisikan tiga rentang alamat IPv4 yang tidak dimaksudkan untuk di-route di Internet tapi hanya dipakai di jaringan lokal. Yang pertama, <literal>10.0.0.0/8</literal> (lihat bilah sisi <xref linkend="sidebar.networking-basics" />), adalah suatu rentang kelas-A (dengan 2<superscript>24</superscript> alamat IP). Yang kedua, <literal>172.16.0.0/12</literal>, mengumpulkan 16 rentang kelas-B (<literal>172.16.0.0/16</literal> sampai <literal>172.31.0.0/16</literal>), masing-masing memuat 2<superscript>16</superscript> alamat IP. Akhirnya, <literal>192.168.0.0/16</literal> adalah suatu rentang kelas-B (mengelompokkan 256 rentang kelas-C, <literal>192.168.0.0/24</literal> sampai <literal>192.168.255.0/24</literal>, masing-masing dengan 256 alamat IP). <ulink type="block" url="http://www.faqs.org/rfcs/rfc1918.html" /></para>
    </sidebar>

    <para>Gateway juga bisa melaksanakan dua macam <emphasis>network address translation</emphasis> (atau NAT). Jenis pertama, <emphasis>Destination NAT</emphasis> (DNAT) adalah suatu teknik yang mengubah alamat IP tujuan (dan/atau port TCP atau UDP) (umumnya) untuk suatu koneksi masuk. Mekanisme pelacakan koneksi juga mengubah paket-paket yang mengikuti dalam koneksi yang sama untuk memastikan keberlangsungan dalam komunikasi. NAT jenis kedua adalah <emphasis>Source NAT</emphasis> (SNAT), dimana <emphasis>masquerading</emphasis> adalah suatu kasus khusus; SNAT mengubah alamat IP sumber (dan/atau port TCP atau UDP) (umumnya) dari suatu koneksi keluar. Seperti pada DNAT, semua paket dalam koneksi secara tepat ditangani oleh mekanisme pelacakan koneksi. Perhatikan bahwa NAT hanya relevan bagi IPv4 dan ruang alamatnya yang terbatas; dalam IPv6, ketersediaan luas dari alamat sangat mengurangi kebergunaan NAT dengan mengizinkan semua alamat "internal" dapat di-route secara langsung pada Internet (ini tidak mengimplikasikan bahwa mesin-mesin internal dapat diakses, karena firewal perantara dapat menyaring lalu lintas).</para>
    <indexterm><primary>NAT</primary></indexterm>
    <indexterm><primary>Network</primary><secondary>Address Translation</secondary></indexterm>
    <indexterm><primary>SNAT</primary></indexterm>
    <indexterm><primary>DNAT</primary></indexterm>
    <indexterm><primary>Destination NAT</primary></indexterm>
    <indexterm><primary>Source NAT</primary></indexterm>

    <sidebar>
      <title><emphasis>KEMBALI KE DASAR</emphasis> Penerusan port</title>
      <indexterm><primary>penerusan port</primary></indexterm>

      <para>Aplikasi konkrit DNAT adalah <emphasis>port forwarding</emphasis>. Koneksi masuk ke port tertentu dari suatu mesin diteruskan ke port pada komputer lain. Solusi lain mungkin ada untuk mencapai efek yang sama, terutama pada tingkat aplikasi dengan <command>ssh</command> (Lihat <xref linkend="sect.ssh-port-forwarding" />) atau <command>redir</command> .</para>
    </sidebar>

    <para>Teori cukup, mari kita praktek. Mengubah sistem Debian menjadi gateway adalah sekedar mengaktifkan opsi yang sesuai untuk kernel Linux, melalui sistem berkas virtual <filename>/proc/</filename>:</para>

    <screen>
<computeroutput># </computeroutput><userinput>echo 1 &gt; /proc/sys/net/ipv4/conf/default/forwarding</userinput></screen>

    <para>Opsi ini dapat juga secara otomatis diaktifkan saat boot jika <filename>/etc/sysctl.conf</filename> menetapkan opsi <literal>net.ipv4.conf.default.forwarding</literal> ke <literal>1</literal>.</para>

    <example id="example.sysctl.conf">
      <title>Berkas <filename>/etc/sysctl.conf</filename></title>

      <programlisting>
net.ipv4.conf.default.forwarding = 1
net.ipv4.conf.default.rp_filter = 1
net.ipv4.tcp_syncookies = 1</programlisting>
    </example>

    <para>Efek yang sama dapat diperoleh untuk IPv6 hanya dengan mengganti <literal>ipv4</literal> dengan <literal>ipv6</literal> dalam perintah manual dan menggunakan <literal>net.ipv6.conf.all.forwarding</literal> dalam <filename>/etc/sysctl.conf</filename>.</para>

    <para>Mengaktifkan masquerading IPv4 adalah operasi yang sedikit lebih kompleks yang melibatkan konfigurasi <emphasis> netfilter </emphasis> firewall.</para>

    <para>Demikian pula dengan menggunakan NAT (untuk IPv4) membutuhkan konfigurasi <emphasis>netfilter</emphasis>. Karena tujuan utama komponen ini adalah penyaringan paket, rinciannya tercantum dalam <xref linkend="security" xrefstyle="select: label quotedtitle nopage" /> (Lihat <xref linkend="sect.firewall-packet-filtering" />).</para>
  </section>
  <section id="sect.virtual-private-network">
    <title>Virtual Private Network</title>

    <para>Sebuah <emphasis>Virtual Private Network</emphasis> (disingkat VPN) adalah suatu cara untuk menyambung dua jaringan lokal yang berbeda melalui Internet melalui suatu tunnel; tunnel biasanya dienkripsi untuk kerahasiaan data. VPN sering dipakai untuk mengintegrasikan suatu mesin di lokasi jauh ke dalam suatu jaringan lokal perusahaan.</para>
    <indexterm><primary>network</primary><secondary>virtual private</secondary></indexterm>
    <indexterm><primary>VPN</primary></indexterm>
    <indexterm><primary>virtual private network</primary></indexterm>

    <para>Beberapa perkakas menyediakan ini. OpenVPN adalah suatu solusi yang efisien, mudah digelar dan dipelihara, berbasis SSL/TLS. Kemungkinan lain adalah memakai IPsec untuk mengenkripsi lalu lintas IP antara dua mesin; enkripsi ini transparan, yang berarti bahwa aplikasi yang berjalan pada host-host ini tidak perlu dimodifikasi untuk melibatkan VPN. SSH juga bisa menyediakan suatu VPN, selain fitur-fitur konvensionalnya. Terakhir, suatu VPN dapat dijalin memakai protokol PPTP Microsoft. Solusi-solusi lain ada, tapi di luar fokus buku ini.</para>
    <section id="sect.openvpn">
      <title>OpenVPN</title>
      <indexterm><primary>OpenVPN</primary></indexterm>

      <para>OpenVPN adalah perangkat lunak yang didedikasikan untuk menciptakan virtual private network. Penyiapannya melibatkan menciptakan antarmuka jaringan virtual VPN server dan klien; <literal>tun</literal> (untuk tunnel level IP) dan antarmuka <literal>tap</literal> (tunnel level terowongan) yang didukung. Dalam prakteknya, antarmuka <literal>tun</literal> akan paling sering digunakan kecuali ketika klien VPN yang dimaksudkan untuk diintegrasikan ke dalam jaringan lokal server melalui bridge Ethernet.</para>

      <para>OpenVPN mengandalkan OpenSSL untuk semua kriptografi SSL/TLS dan fitur terkait (kerahasiaan, otentikasi, integritas, non-repudiation). Hal ini dapat dikonfigurasi dengan kunci pribadi bersama atau menggunakan sertifikat X.509 berdasarkan infrastuktur kunci publik. Konfigurasi terakhir ini sangat disukai karena memungkinkan fleksibilitas yang lebih besar ketika dihadapkan dengan meningkatnya jumlah pengguna roaming yang mengakses VPN.</para>

      <sidebar>
        <title><emphasis>KULTUR</emphasis> SSL dan TLS</title>
        <indexterm><primary>SSL</primary></indexterm>
        <indexterm><primary>TLS</primary></indexterm>

	<para>Protokol SSL (<emphasis>Secure Socket Layer</emphasis>) diciptakan oleh Netscape untuk mengamankan koneksi ke server-server web. Itu kemudian distandarkan oleh IETF dengan singkatan TLS (<emphasis>Transport Layer Security</emphasis>). Sejak itu TLS terus berkembang dan saat ini SSL usang karena beberapa cacat desain yang telah ditemukan.</para>
      </sidebar>
      <section id="sect.easy-rsa">
        <title>Infrastruktur Kunci Publik: <emphasis>easy-rsa</emphasis></title>
        <indexterm><primary>IKP (Infrastruktur Kunci Publik)</primary></indexterm>
        <indexterm><primary>Infrastruktur Kunci Publik</primary></indexterm>
        <indexterm><primary>X.509, sertifikat</primary></indexterm>
        <indexterm><primary>sertifikat</primary><secondary>X.509</secondary></indexterm>
        <indexterm><primary><emphasis>easy-rsa</emphasis></primary></indexterm>
        <indexterm><primary>RSA (algoritme)</primary></indexterm>
        <indexterm><primary>pasangan kunci</primary></indexterm>

	<para>Algoritme RSA banyak dipakai dalam kriptografi kunci publik. Ini melibatkan suatu "pasangan kunci", yang terdiri dari sebuah kunci privat dan publik. Kedua kunci terkait dekat satu sama lain, dan properti matematisnya sedemikian sehingga sebuah pesan yang dienkripsi dengan kunci kunci publik hanya dapat didekripsi oleh seseorang yang mengetahui kunci privatnya, yang memastikan kerahasiaan. Pada arah yang berlawanan, sebuah pesan yang dienkripsi dengan kunci privatnya dapat didekripsi oleh siapapun yang mengetahui kunci publiknya, yang mengizinkan otentikasi asal-usul dari suatu pesan karena hanya seseorang yang punya akses ke kunci privat yang dapat membuatnya. Ketika dihubungkan dengan dengan sebuah fungsi hash digital (MD5, SHA1, atau varian yang lebih terkini), ini mengarah ke suatu mekanisme tanda tangan yang dapat diterapkan ke sebarang pesan.</para>

	<para>Namun, siapapun dapat mencipta suatu pasangan kunci, menyimpan sebarang identitas padanya, dan menyaru menjadi identitas pilihan mereka. Satu solusi melibatkan konsep <emphasis>Certification Authority</emphasis> (CA), diformalkan oleh standar X.509. Istilah ini mencakup suatu entitas yang menyimpan suatu pasangan kunci terpercaya yang dikenal sebagai <emphasis>sertifikat root</emphasis>. Sertifikat ini hanya dipakai untuk menandatangani sertifikat lain (pasangan kunci), setelah langkah-langkah yang tepat dilaksanakan untuk memeriksa identitas yang disimpan dalam pasangan kunci. Aplikasi-aplikasi yang memakai X.509 kemudian dapat memeriksa sertifikat yang disajikan ke mereka, bila mereka tahu tentang sertifikat root yang terpercaya.</para>

	<para>OpenVPN mengikuti aturan ini. Karena CA publik hanya mengeluarkan sertifikat dengan biaya (yang mahal), dimungkinkan untuk membuat otoritas sertifikasi pribadi dalam perusahaan. Paket <emphasis role="pkg">easy-rsa</emphasis> menyediakan alat untuk melayani sebagai infrastruktur sertifikasi X.509, diimplementasikan sebagai satu set skrip menggunakan perintah <command>openssl</command> .</para>

        <sidebar>
          <title><emphasis>CATATAN</emphasis> <emphasis>easy-rsa</emphasis> sebelum <emphasis role="distribution">Jessie</emphasis></title>

          <para>Dalam versi Debian hingga <emphasis role="distribution">Wheezy</emphasis>, <emphasis>easy-rsa</emphasis> didistribusikan sebagai bagian dari paket <emphasis role="pkg">openvpn</emphasis>, dan skripnya yang dapat ditemukan di bawah <filename>/usr/share/doc/openvpn/examples/easy-rsa/2.0/</filename>. Menyiapkan CA melibatkan menyalin direktori tersebut, bukan menggunakan perintah <command>make-cadir</command> seperti yang didokumentasikan di sini.</para>
        </sidebar>

	<para>Para admin Falcot Corp memakai perkakas ini untuk membuat sertifikat-sertifikat yang diperlukan, untuk server dan klien. Ini memungkinkan konfigurasi semua klien serupa karena mereka hanya perlu menyiapkan agar mempercayai sertifkat yang datang dari CA lokal Falcot. CA ini adalah sertifikat pertama yang dibuat; sampai titik ini, para administrator menyiapkan sebuah direktori dengan berkas-berkas yang diperlukan bagi CA dalam suatu lokasi yang sesuai, lebih disukai pada sebuah mesin yang tidak tersambung ke jaringan untuk memitigasi risiko kunci privat CA dicuri.</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>make-cadir pki-falcot
</userinput><computeroutput>$ </computeroutput><userinput>cd pki-falcot</userinput></screen>

	<para>Mereka kemudian menyimpan parameter-parameter yang diperlukan ke dalam berkas <filename>vars</filename>, terutama mereka dengan nama berawalan <literal>KEY_</literal>; variabel-variabel ini kemudian diintegrasikan ke dalam lingkungan:</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>vim vars
</userinput><computeroutput>$ </computeroutput><userinput>grep KEY_ vars
</userinput><computeroutput>export KEY_CONFIG=`$EASY_RSA/whichopensslcnf $EASY_RSA`
export KEY_DIR="$EASY_RSA/keys"
echo NOTE: If you run ./clean-all, I will be doing a rm -rf on $KEY_DIR
export KEY_SIZE=2048
export KEY_EXPIRE=3650
export KEY_COUNTRY="FR"
export KEY_PROVINCE="Loire"
export KEY_CITY="Saint-Étienne"
export KEY_ORG="Falcot Corp"
export KEY_EMAIL="admin@falcot.com"
export KEY_OU="Certificate authority"
export KEY_NAME="Certificate authority for Falcot Corp"
# If you'd like to sign all keys with the same Common Name, uncomment the KEY_CN export below
# export KEY_CN="CommonName"
$ </computeroutput><userinput>. ./vars
</userinput><computeroutput>NOTE: If you run ./clean-all, I will be doing a rm -rf on /home/roland/pki-falcot/keys
$ </computeroutput><userinput>./clean-all
</userinput></screen>

	<para>Langkah berikutnya adalah penciptaan pasangan kunci CA (dua bagian dari pasangan kunci akan disimpan di bawah <filename>keys/ca.crt</filename> dan <filename>keys/ca.key</filename> selama langkah ini):</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>./build-ca</userinput>
<computeroutput>Generating a 2048 bit RSA private key
...................................................................+++
...+++
writing new private key to 'ca.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [Falcot Corp CA]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:
</computeroutput></screen>

	<para>Sertifikat untuk server VPN dapat sekarang dibuat, maupun parameter Diffie-Hellman yang diperlukan untuk koneksi SSL/TLS sisi server. Server VPN diidentifikasi oleh nama DNS <literal>vpn.falcot.com</literal>; nama ini digunakan kembali untuk berkas-berkas kunci yang dihasilkan (<filename>keys/vpn.falcot.com.crt</filename> bagi sertifikat publik, <filename>keys/vpn.falcot.com.key</filename> untuk kunci privat):</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>./build-key-server vpn.falcot.com
</userinput><computeroutput>Generating a 2048 bit RSA private key
.....................................................................................................................+++
...........+++
writing new private key to 'vpn.falcot.com.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [vpn.falcot.com]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
Using configuration from /home/roland/pki-falcot/openssl-1.0.0.cnf
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
countryName           :PRINTABLE:'FR'
stateOrProvinceName   :PRINTABLE:'Loire'
localityName          :T61STRING:'Saint-\0xFFFFFFC3\0xFFFFFF89tienne'
organizationName      :PRINTABLE:'Falcot Corp'
organizationalUnitName:PRINTABLE:'Certificate authority'
commonName            :PRINTABLE:'vpn.falcot.com'
name                  :PRINTABLE:'Certificate authority for Falcot Corp'
emailAddress          :IA5STRING:'admin@falcot.com'
Certificate is to be certified until Mar  6 14:54:56 2025 GMT (3650 days)
Sign the certificate? [y/n]:</computeroutput><userinput>y
</userinput><computeroutput>

1 out of 1 certificate requests certified, commit? [y/n]</computeroutput><userinput>y
</userinput><computeroutput>Write out database with 1 new entries
Data Base Updated
$ </computeroutput><userinput>./build-dh
</userinput><computeroutput>Generating DH parameters, 2048 bit long safe prime, generator 2
This is going to take a long time
[…]
</computeroutput></screen>

	<para>Langkah berikut menciptakan sertifikat untuk klien VPN; satu sertifikat diperlukan untuk setiap komputer atau orang yang diizinkan untuk menggunakan VPN:</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>./build-key JoeSmith
</userinput><computeroutput>Generating a 2048 bit RSA private key
................................+++
..............................................+++
writing new private key to 'JoeSmith.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:</computeroutput><userinput>Development unit
</userinput><computeroutput>Common Name (eg, your name or your server's hostname) [JoeSmith]:</computeroutput><userinput>Joe Smith
</userinput><computeroutput>[…]</computeroutput></screen>

	<para>Kini semua sertifikat sudah dibuat, mereka perlu disalin bila diperlukan: kunci publik sertifikat root (<filename>keys/ca.crt</filename>) akan disimpan pada semua mesin (server dan klien) sebagai <filename>/etc/ssl/certs/Falcot_CA.crt</filename>. Sertifikat server hanya dipasang pada server (<filename>keys/vpn.falcot.com.crt</filename> diletakkan di <filename>/etc/ssl/vpn.falcot.com.crt</filename>, dan <filename>keys/vpn.falcot.com.key</filename> ke <filename>/etc/ssl/private/vpn.falcot.com.key</filename> dengan hak terbatas sehingga hanya administrator yang dapat membacanya), dengan parameter Diffie-Hellman terkait <filename>keys/dh2048.pem</filename>) dipasang ke <filename>/etc/openvpn/dh2048.pem</filename>. Sertifikat klien dipasang pada klien VPN terkait dengan cara serupa.</para>
      </section>
      <section>
        <title>Mengkonfigurasi Server OpenVPN</title>

	<para>Secara baku, skrip inisialisasi OpenVPN mencoba memulai semua virtual private network yang didefinisikan di dalam <filename>/etc/openvpn/*.conf</filename>. Maka menyiapkan suatu server VPN cukup dengan menyimpan suatu berkas konfigurasi yang terkait dalam direktori ini. Satu titik awal yang baik adalah <filename>/usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz</filename>, yang mengarahkan ke sebuah server agak standar. Tentu saja, beberapa parameter perlu diadaptasi: <literal>ca</literal>, <literal>cert</literal>, <literal>key</literal>, dan <literal>dh</literal> perlu menjelaskan lokasi yang dipilih (masing-masing, <literal>/etc/ssl/certs/Falcot_CA.crt</literal>, <literal>/etc/ssl/vpn.falcot.com.crt</literal>, <literal>/etc/ssl/private/vpn.falcot.com.key</literal>, dan <literal>/etc/openvpn/dh2048.pem</literal>). Direktif <literal>server 10.8.0.0 255.255.255.0</literal> mendefinisikan subnet yang akan dipakai oleh VPN; server memakai alamat IP pertama dalam rentang tersebut (<literal>10.8.0.1</literal>) dan sisa alamat dialokasikan ke klien.</para>

	<para>Dengan konfigurasi ini, memulai OpenVPN membuat antarmuka jaringan virtual, biasanya dengan nama <literal>tun0</literal>. Namun, firewall seringkali dikonfigurasi pada waktu yang sama dengan antarmuka jaringan nyata, yang terjadi sebelum OpenVPN dimulai. Praktik yang baik menyarankan membuat suatu antarmuka jaringan virtual yang persisten, dan menata OpenVPN untuk memakai antarmuka yang telah dibuat ini. Lebih jauh ini mengizinkan pemilihan nama antarmuka. Perintah <command>openvpn —mktun —dev vpn —dev-type tun</command> membuat suatu antarmuka jaringan virtual bernama <literal>vpn</literal> dengan tipe <literal>tun</literal>; perintah ini dapat dengan mudah diintegrasikan dalam skrip konfigurasi firewall, atau dalam suatu direktif <literal>up</literal> dari berkas <filename>/etc/network/interfaces</filename>. Berkas konfigurasi OpenVPN juga mesti diperbarui, dengan direktif <literal>dev vpn</literal> dan <literal>dev-type tun</literal>.</para>

	<para>Kecuali ada tindakan lebih lanjut, klien VPN hanya dapat mengakses server VPN itu sendiri melalui alamat <literal>10.8.0.1</literal>. Memberi akses untuk klien ke jaringan lokal (192.168.0.0/24), memerlukan penambahan direktif <literal>push route 192.168.0.0 255.255.255.0</literal> ke konfigurasi OpenVPN sehingga klien VPN secara otomatis mendapatkan route yang memberi tahu mereka bahwa jaringan ini dapat dicapai melalui VPN. Lebih jauh, mesin-mesin pada jaringan lokal juga perlu diberitahu bahwa route ke VPN adalah melalui server VPN (ini secara otomatis berjalan ketika server VPN dipasang pada gateway). Alternatifnya, server VPN dapat dikonfigurasi untuk melaksanakan masquerading IP sehingga koneksi yang datang dari klien-klien VPN tampak seperti datang dari server VPN (lihat <xref linkend="sect.gateway" />).</para>
      </section>
      <section>
        <title>Mengkonfigurasi Klien OpenVPN</title>

	<para>Menyiapkan suatu klien OpenVPN juga memerlukan pembuatan suatu berkas konfigurasi dalam <filename>/etc/openvpn/</filename>. Sebuah konfigurasi standar dapat diperoleh dengan memakai <filename>/usr/share/doc/openvpn/examples/sample-config-files/client.conf</filename> sebagai titik awal. Direktif <literal>remote vpn.falcot.com 1194</literal> menjelaskan alamat dan port server OpenVPN; <literal>ca</literal>, <literal>cert</literal>, dan <literal>key</literal> juga perlu diadaptasi untuk menjelaskan lokasi berkas-berkas kunc.</para>

	<para>Bila VPN tidak akan dijalankan secara otomatis saat boot, atur direktif <literal>AUTOSTART</literal> ke <literal>none</literal> dalam berkas <filename>/etc/default/openvpn</filename>. Memulai atau menghentikan suatu koneksi VPN tertentu selalu mungkin dengan perintah <command>service openvpn@<replaceable>nama</replaceable> start</command> dan <command>service openvpn@<replaceable>nama</replaceable> stop</command> (dimana <replaceable>nama</replaceable> koneksi cocok dengan yang didefinisikan dalam <filename>/etc/openvpn/<replaceable>nama</replaceable>.conf</filename>).</para>

	<para>Paket <emphasis role="pkg">network-manager-openvpn-gnome</emphasis> berisi sebuah ekstensi untuk Network Manager (Lihat <xref linkend="sect.roaming-network-config" />) yang memungkinkan mengelola virtual private network OpenVPN. Hal ini memungkinkan setiap pengguna untuk mengkonfigurasi koneksi OpenVPN secara grafis dan untuk mengendalikan mereka dari ikon manajemen jaringan. <indexterm><primary><emphasis role="pkg">network-manager-openvpn-gnome</emphasis></primary></indexterm></para>
      </section>
    </section>
    <section id="sect.ssh-vpn">
      <title>Virtual Private Network dengan SSH</title>
      <indexterm><primary>SSH</primary></indexterm>
      <indexterm><primary>PPP</primary></indexterm>

      <para>Sebenarnya ada dua cara membuat sebuah virtual private network dengan SSH. Yang bersejarah melibatkan menjalin lapisan PPP atas link SSH. Metode ini dijelaskan dalam dokumen HOWTO: <ulink type="block" url="http://www.tldp.org/HOWTO/ppp-ssh/" /></para>

      <para>Metode kedua lebih baru, dan diperkenalkan dengan OpenSSH 4.3; sekarang mungkin bagi OpenSSH untuk membuat antarmuka jaringan virtual (<literal>tun*</literal>) pada kedua sisi dari koneksi SSH, dan antarmuka virtual ini dapat dikonfigurasi secara persis seolah mereka antarmuka fisik. Sistem tunnel pertama mesti difungsikan dengan menata <literal>PermitTunnel</literal> ke ”yes” dalam berkas konfigurasi server SSH (<filename>/etc/ssh/sshd_config</filename>). Ketika menjalin suatu koneksi SSH, pembuatan tunnel mesti diminta secara eksplisit dengan opsi <literal>-w any:any</literal> (<literal>any</literal> dapat digantikan dengan nomor peranti <literal>tun</literal> yang dikehendaki). Ini memerlukan pengguna memiliki hak administrator pada kedua sisi, sehingga dapat membuat peranti jaringan (dengan kata lain, koneksi mesti dijalin sebagai root).</para>

      <para>Kedua metode untuk membuat sebuah virtual private network melalui SSH cukup sederhana. Namun, VPN yang mereka sediakan bukan yang paling efisien; khususnya, ia tidak menangani lalu lintas tingkat tinggi dengan sangat baik.</para>

      <para>Penjelasannya adalah bahwa ketika suatu stack TCP/IP dienkapsulasi di dalam suatu koneksi TCP/IP (untuk SSH), protokol TCP dipakai dua kalai, sekali untuk koneksi SSH dan sekali di dalam tunnel. Ini mengarah ke masalah, khususnya karena cara TCP menyesuaikan ke kondisi jaringan dengan mengubah tundaan waktu tunggu. Situs berikut menguraikan masalah tersebut secara lebih terrinci: <ulink type="block" url="http://sites.inka.de/sites/bigred/devel/tcp-tcp.html" /> Maka VPN di atas SSH mesti dibatasi ke tunnel one-off tanpa kendala kinerja.</para>
    </section>
    <section id="sect.ipsec">
      <title>IPsec</title>
      <indexterm><primary>IPsec</primary></indexterm>
      <indexterm><primary><command>strongswan</command></primary></indexterm>
      <indexterm><primary><command>racoon</command></primary></indexterm>

      <para>IPsec, walaupun menjadi standar dalam VPN IP, agak rumit dalam implementasinya. Mesin IPsec itu sendiri terintegrasi dalam kernel Linux; bagian-bagian ruang-pengguna yang diperlukan, perkakas konfirugasi dan kendali, disediakan oleh paket <emphasis role="pkg">ipsec-tools</emphasis>. Dalam istilah konkrit, setiap <filename>/etc/ipsec-tools.conf</filename> milik host memuat parameter untuk <emphasis>tunnel IPsec</emphasis> (atau <emphasis>Security Associations</emphasis>, dalam terminologi IPsec) terkait host; skrip <command>/etc/init.d/setkey</command> menyediakan suatu cara untuk memulai dan menghentikan sebuah tunnel (setiap tunnel adalah suatu link aman ke host lain yang tersambung ke virtual private network). Berkas ini dapat dibangun secara manual dari dokumentasi yang disediakan oleh halaman manual <citerefentry><refentrytitle>setkey</refentrytitle> <manvolnum>8</manvolnum></citerefentry>. Namun, menulis parameter secara eksplisit untuk semua host dalam sekumpulan mesin yang tidak trivial segera menjadi pekerjaan yang melelahkan karena banyaknya tunnel tumbuh dengan cepat. Memasang suatu daemon IKE (singkatan dari <emphasis>IPsec Key Exchange</emphasis>) seperti misalnya <emphasis role="pkg">racoon</emphasis> atau <emphasis role="pkg">strongswan</emphasis> membuat proses jauh lebih sederhana dengan mengumpulkan administrasi ke suatu titik pusat, dan lebih aman dengan merotasi kunci secara periodik.</para>
      <indexterm><primary>IKE</primary></indexterm>
      <indexterm><primary>IPsec</primary><secondary>Pertukaran Kunci IPsec</secondary></indexterm>
      <indexterm><primary>pasangan kunci</primary></indexterm>
      <indexterm><primary><command>setkey</command></primary></indexterm>

      <para>Meskipun statusnya sebagai referensi, kompleksitas menyiapkan IPsec membatasi penggunaannya dalam praktek. Solusi berbasis OpenVPN umumnya akan lebih disukai bila diperlukan tunnel yang tidak terlalu banyak atau dinamis.</para>

      <sidebar>
        <title><emphasis>HATI-HATI</emphasis> IPsec dan NAT</title>

	<para>Firewall yang melakukan NAT dan IPsec tidak bekerja sama dengan baik: karena IPsec menandatangani paket-paket, perubahan pada paket-paket ini yang mungkin dilakukan oleh firewall akan membatalkan tanda tangan, dan paket-paket akan ditolak di tempat tujuan. Berbagai implementasi IPsec sekarang termasuk teknik <emphasis>NAT-T</emphasis> (untuk <emphasis>NAT Traversal</emphasis>), yang pada dasarnya membungkus paket IPsec dalam paket UDP standar.</para>
        <indexterm><primary>NAT-T</primary></indexterm>
        <indexterm><primary>NAT Traversal</primary></indexterm>
      </sidebar>

      <sidebar>
        <title><emphasis>KEAMANAN</emphasis> IPsec dan firewall</title>

	<para>Mode standar pengoperasian IPsec melibatkan pertukaran data di UDP port 500 untuk pertukaran kunci (juga dalam port UDP 4500 dalam kasus digunakannya NAT-T). Selain itu, paket-paket IPsec menggunakan dua protokol IP terdedikasi yang mesti dibiarkan lewat oleh firewall; penerimaan paket ini didasarkan pada nomor protokol mereka, 50 (ESP) dan 51 (AH).</para>
        <indexterm><primary>ESP, protokol</primary></indexterm>
        <indexterm><primary>AH, protokol</primary></indexterm>
        <indexterm><primary>protokol</primary><secondary>AH</secondary></indexterm>
        <indexterm><primary>protokol</primary><secondary>ESP</secondary></indexterm>
      </sidebar>
    </section>
    <section id="sect.pptp">
      <title>PPTP</title>

      <para>PPTP (untuk <emphasis>Point-to-Point Tunneling Protocol</emphasis>) menggunakan dua saluran komunikasi, satu untuk data kontrol dan satu untuk data muatan; yang terakhir menggunakan protokol GRE (<emphasis>Generik Routing enkapsulasi</emphasis>). Link PPP standar kemudian disiapkan di atas kanal pertukaran data.</para>
      <indexterm><primary>PPTP</primary></indexterm>
      <indexterm><primary>Point-to-Point Tunneling Protocol</primary></indexterm>
      <indexterm><primary>GRE, protokol</primary></indexterm>
      <indexterm><primary>protokol</primary><secondary>GRE</secondary></indexterm>
      <section id="sect.pptp-config-client">
        <title>Mengkonfigurasi Klien</title>

	<para>Paket <emphasis role="pkg">pptp-linux</emphasis> berisi klien PPTP yang mudah dikonfigurasi untuk Linux. Instruksi berikut mengambil inspirasi dari dokumentasi resmi: <ulink type="block" url="http://pptpclient.sourceforge.net/howto-debian.phtml" /></para>
        <indexterm><primary><emphasis role="pkg">pptp-linux</emphasis></primary></indexterm>

	<para>Administrator Falcot membuat beberapa berkas: <filename>/etc/ppp/options.pptp</filename>, <filename>/etc/ppp/peers/falcot</filename>, <filename>/etc/ppp/ip-up.d/falcot</filename>, dan <filename>/etc/ppp/ip-down.d/falcot</filename>.</para>

        <example id="example.ppp-options.pptp">
          <title>Berkas <filename>/etc/ppp/options.pptp</filename></title>

          <programlisting>
# PPP options used for a PPTP connection
lock
noauth
nobsdcomp
nodeflate</programlisting>
        </example>

        <example id="example.ppp-peers-falcot">
          <title>Berkas <filename>/etc/ppp/peers/falcot</filename></title>

          <programlisting>
# vpn.falcot.com is the PPTP server
pty "pptp vpn.falcot.com --nolaunchpppd"
# the connection will identify as the "vpn" user
user vpn
remotename pptp
# encryption is needed
require-mppe-128
file /etc/ppp/options.pptp
ipparam falcot</programlisting>
        </example>

        <example id="example.ppp-ip-up.d-falcot">
          <title>Berkas <filename>/etc/ppp/ip-up.d/falcot</filename></title>

          <programlisting>
# Create the route to the Falcot network
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 is the (remote) Falcot network
  route add -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi</programlisting>
        </example>

        <example id="example.ppp-ip-down.d-falcot">
          <title>Berkas <filename>/etc/ppp/ip-down.d/falcot</filename></title>

          <programlisting>
# Delete the route to the Falcot network
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 is the (remote) Falcot network
  route del -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi</programlisting>
        </example>

        <sidebar>
          <title><emphasis>KEAMANAN</emphasis> MPPE</title>

	  <para>Mengamankan PPTP melibatkan penggunaan fitur MPPE (<emphasis>Microsoft Point-to-Point Encryption</emphasis>), yang tersedia di kernel Debian resmi sebagai modul.</para>
          <indexterm><primary>MPPE</primary></indexterm>
          <indexterm><primary>Microsoft</primary><secondary>Point-to-Point Encryption</secondary></indexterm>
        </sidebar>
      </section>
      <section id="sect.pptp-config-serveur">
        <title>Menata Server</title>

        <sidebar>
          <title><emphasis>HATI-HATI</emphasis> PPTP dan firewall</title>

	  <para>Firewall intermediate perlu dikonfigurasi untuk membiarkan paket IP menggunakan protokol 47 (GRE). Selain itu, port server PPTP 1723 harus terbuka sehingga saluran komunikasi dapat terjadi.</para>
        </sidebar>

	<para><command>pptpd</command> adalah server PPTP untuk Linux. Berkas konfigurasi utamanya, <filename>/etc/pptpd.conf</filename>, memerlukan sangat sedikit perubahan: <emphasis>localip</emphasis> (alamat IP lokal) dan <emphasis>remoteip</emphasis> (alamat IP remote). Dalam contoh di bawah, server PPTP selalu memakai alamat <literal>192.168.0.199</literal>dan klien PPTP menerima alamat IP dari <literal>192.168.0.200</literal> sampai <literal>192.168.0.250</literal>.</para>

        <example id="example.pptpd.conf">
          <title>Berkas <filename>/etc/pptpd.conf</filename></title>

          <programlisting>
# TAG: speed
#
#       Specifies the speed for the PPP daemon to talk at.
#
speed 115200

# TAG: option
#
#       Specifies the location of the PPP options file.
#       By default PPP looks in '/etc/ppp/options'
#
option /etc/ppp/pptpd-options

# TAG: debug
#
#       Turns on (more) debugging to syslog
#
# debug

# TAG: localip
# TAG: remoteip
#
#       Specifies the local and remote IP address ranges.
#
#       You can specify single IP addresses separated by commas or you can
#       specify ranges, or both. For example:
#
#               192.168.0.234,192.168.0.245-249,192.168.0.254
#
#       IMPORTANT RESTRICTIONS:
#
#       1. No spaces are permitted between commas or within addresses.
#
#       2. If you give more IP addresses than MAX_CONNECTIONS, it will
#          start at the beginning of the list and go until it gets
#          MAX_CONNECTIONS IPs. Others will be ignored.
#
#       3. No shortcuts in ranges! ie. 234-8 does not mean 234 to 238,
#          you must type 234-238 if you mean this.
#
#       4. If you give a single localIP, that's ok - all local IPs will
#          be set to the given one. You MUST still give at least one remote
#          IP for each simultaneous client.
#
#localip 192.168.0.234-238,192.168.0.245
#remoteip 192.168.1.234-238,192.168.1.245
#localip 10.0.1.1
#remoteip 10.0.1.2-100
localip 192.168.0.199
remoteip 192.168.0.200-250</programlisting>
        </example>

	<para>Konfigurasi PPP yang digunakan oleh server PPTP juga memerlukan beberapa perubahan kecil di <filename>/etc/ppp/pptpd-options</filename>. Parameter penting adalah nama server (<literal>pptp</literal>), nama domain (<literal>falcot.com</literal>), dan alamat IP untuk server DNS dan WINS.</para>

        <example id="example.ppp-pptpd-options">
          <title>Berkas <filename>/etc/ppp/pptpd-options</filename></title>

          <programlisting>
## turn pppd syslog debugging on
#debug

## change 'servername' to whatever you specify as your server name in chap-secrets
name pptp
## change the domainname to your local domain
domain falcot.com

## these are reasonable defaults for WinXXXX clients
## for the security related settings
# The Debian pppd package now supports both MSCHAP and MPPE, so enable them
# here. Please note that the kernel support for MPPE must also be present!
auth
require-chap
require-mschap
require-mschap-v2
require-mppe-128

## Fill in your addresses
ms-dns 192.168.0.1
ms-wins 192.168.0.1

## Fill in your netmask
netmask 255.255.255.0

## some defaults
nodefaultroute
proxyarp
lock</programlisting>
        </example>

	<para>Langkah terakhir melibatkan mendaftarkan pengguna <literal>vpn</literal> (dan kata sandi terkait) dalam berkas <filename>/etc/ppp/chap-secrets</filename>. Berbeda dengan instansi lain dimana bintang (<literal>*</literal>) akan bekerja, nama server harus diisi secara eksplisit di sini. Lebih jauh, klien-klien PPTP Windows mengidentifikasi diri mereka sendiri dalam bentuk <literal><replaceable>DOMAIN</replaceable>\\<replaceable>USER</replaceable></literal>, bukan sekedar menyediakan nama pengguna. Ini menjelaskan mengapa berkas juga menyinggung pengguna <literal>FALCOT\\vpn</literal>. Juga dimungkinkan untuk menyatakan alamat IP individu untuk para pengguna; bintang dalam ruas ini menyatakan bahwa pengalamat dinamis mesti dipakai.</para>

        <example id="example.ppp-chap-secrets">
          <title>Berkas <filename>/etc/ppp/chap-secrets</filename></title>

          <programlisting>
# Secrets for authentication using CHAP
# client        server  secret      IP addresses
vpn             pptp    f@Lc3au     *
FALCOT\\vpn     pptp    f@Lc3au     *</programlisting>
        </example>

        <sidebar>
          <title><emphasis>KEAMANAN</emphasis> Kerentanan PPTP</title>

	  <para>Implementasi PPTP pertama Microsoft mengundang kritik keras karena memiliki banyak kerentanan keamanan; sebagian besar sejak saat itu telah diperbaiki dalam versi yang lebih baru. Konfigurasi yang didokumentasikan di bagian ini menggunakan versi terbaru dari protokol. Sadarilah bahwa menghapus beberapa opsi (seperti <literal>require-mppe-128</literal> dan <literal>require-mschap-v2</literal>) akan membuat layanan rentan lagi.</para>
        </sidebar>
      </section>
    </section>
  </section>
  <section id="sect.quality-of-service">
    <title>Kualitas Layanan</title>
    <section id="sect.qos-principe">
      <title>Prinsip dan Mekanisme</title>

      <para><emphasis>Quality of Service</emphasis> (Kualitas Layanan atau disingkat <emphasis>QoS</emphasis>) mengacu ke sekumpulan teknik yang menjamin atau memperbaiki kualitas layanan yang disediakan ke aplikasi. Teknik paling populer melibatkan penggolongan trafik jaringan ke dalam kategori-kategori, dan membedakan penanganan trafik sesuai dengan kategori yang menaunginya. Penerapan utama dari konsep layanan terdiferensiasi ini adalah <emphasis>traffic shaping</emphasis>, yang membatasi laju transmisi data untuk koneksi yang terkait dengan beberapa layanan dan/atau host agar tidak membuat jenuh lebar pita yang tersedia dan mencekik layanan penting lain. Traffic shaping khususnya sangat cocok bagi trafik TCP, karena protokol ini secara otomatis menyesuaikan ke lebar pita yang tersedia.</para>
      <indexterm><primary>QoS</primary></indexterm>
      <indexterm><primary>kualitas layanan</primary></indexterm>
      <indexterm><primary>kualitas</primary><secondary>layanan</secondary></indexterm>
      <indexterm><primary>layanan</primary><secondary>kualitas</secondary></indexterm>

      <para>Mungkin juga untuk mengubah prioritas pada lalu lintas, yang memungkinkan memprioritaskan paket-paket yang berhubungan dengan layanan interaktif (seperti <command>ssh</command> dan <command>telnet</command>) atau ke layanan yang hanya berhubungan dengan blok-block kecil data.</para>

      <para>Kernel Debian menyertakan fitur-fitur yang diperlukan untuk QoS bersama dengan modul-modul terkait. Modul ini banyak, dan masing-masing menyediakan layanan berbeda, terutama skeduler khusus untuk antrian paket IP; berbagai macam perilaku skeduler tersedia mencakup seluruh kemungkinan persyaratan.</para>

      <sidebar>
        <title><emphasis>KULTUR</emphasis> LARTC — <emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis></title>

	<para>HOWTO <emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis> adalah dokumen referensi yang mencakup segala hal yang perlu diketahui tentang kualitas layanan jaringan. <ulink type="block" url="http://www.lartc.org/howto/" /></para>
        <indexterm><primary>routing</primary><secondary>tingkat lanjut</secondary></indexterm>
        <indexterm><primary>trafik</primary><secondary>kontrol</secondary></indexterm>
        <indexterm><primary>kontrol lalu lintas</primary></indexterm>
      </sidebar>
    </section>
    <section id="sect.qos-config">
      <title>Mengkonfigurasi dan Mengimplementasi</title>

      <para>Parameter QoS ditetapkan melalui perintah <command>tc</command> (yang disediakan oleh paket <emphasis role="pkg">iproute</emphasis> ). Karena antarmukanya cukup kompleks, dianjurkan menggunakan alat-alat dengan tingkat lebih tinggi.</para>
      <indexterm><primary><emphasis>iproute</emphasis></primary></indexterm>
      <indexterm><primary><command>tc</command></primary></indexterm>
      <section id="sect.qos-wondershaper">
        <title>Mengurangi Latensi: <command>wondershaper</command></title>

	<para>Tujuan utama dari <command>wondershaper</command> (dalam paket yang bernama sama) adalah untuk meminimalkan latensi independen dari beban jaringan. Hal ini dicapai dengan membatasi total lalu lintas ke nilai yang sedikit kurang dari nilai saturasi link.</para>
        <indexterm><primary><command>wondershaper</command></primary></indexterm>
        <indexterm><primary>pembatasan lalu lintas</primary></indexterm>
        <indexterm><primary>trafik</primary><secondary>limitasi</secondary></indexterm>

	<para>Sekali suatu antarmuka jaringan dikonfigurasi, menyiapkan pembatasan trafik ini dicapai dengan menjalankan <command>wondershaper <replaceable>antarmuka</replaceable> <replaceable>laju_unduh</replaceable> <replaceable>laju_unggah</replaceable></command>. Antarmuka bisa berupa <literal>eth0</literal> atau <literal>ppp0</literal> misalnya, dan kedua kecepatan dinyatakan dalam kilobit per detik. Perintah <command>wondershaper remove <replaceable>antarmuka</replaceable></command> menonaktifkan kendali trafik pada antarmuka yang dinyatakan.</para>

	<para>Untuk sambungan Ethernet, skrip ini terbaik dipanggil tepat setelah antar muka dikonfigurasi. Hal ini dilakukan dengan menambahkan arahan <literal>up</literal> dan <literal>down</literal> ke berkas <filename>/etc/network/interfaces</filename> yang memungkinkan perintah-perintah yang dideklarasikan dijalankan, masing-masing, setelah antar muka dikonfigurasi dan sebelum itu di-dekonfigurasi. Sebagai contoh:</para>

        <example id="example.network-interfaces">
          <title>Perubahan dalam berkas <filename>/etc/network/interfaces</filename></title>

          <programlisting>
iface eth0 inet dhcp
    up /sbin/wondershaper eth0 500 100
    down /sbin/wondershaper remove eth0</programlisting>
        </example>

	<para>Dalam kasus PPP, menciptakan sebuah skrip yang panggilan <command>wondershaper</command> di <filename>/etc/ppp/ip-up.d/</filename> akan memungkinkan kontrol lalu lintas segera setelah sambungan hidup.</para>

        <sidebar>
          <title><emphasis>LEBIH LANJUT</emphasis> Konfigurasi optimal</title>

	  <para>Berkas <filename>/Usr/share/doc/wondershaper/README.Debian.gz</filename> menjelaskan, secara agak rinci, metode konfigurasi yang direkomendasikan oleh pengelola paket. Secara khusus, itu menyarankan mengukur kecepatan unduh dan unggah untuk mengevaluasi secara terbaik batas nyata.</para>
        </sidebar>
      </section>
      <section id="sect.qos-config-standard">
        <title>Konfigurasi Standar</title>

	<para>Kecuali konfigurasi QoS tertentu, kernel Linux menggunakan penjadwal antrian <literal>pfifo_fast</literal>, yang menyediakan beberapa fitur menarik. Prioritas dari setiap paket IP yang diproses didasarkan pada ruas QoS (<emphasis>Type of Service</emphasis>) paket ini; memodifikasi ruas ini cukup untuk mengambil keuntungan dari fitur penjadwalan. Ada lima nilai yang mungkin:</para>
        <itemizedlist>
          <listitem>
	    <para>Normal-Service (0);</para>
          </listitem>
          <listitem>
	    <para>Minimize-Cost (2);</para>
          </listitem>
          <listitem>
	    <para>Maximize-Reliability (4);</para>
          </listitem>
          <listitem>
	    <para>Maximize-Throughput (8);</para>
          </listitem>
          <listitem>
	    <para>Minimize-Delay (16).</para>
          </listitem>
        </itemizedlist>
        <indexterm><primary>ToS</primary></indexterm>
        <indexterm><primary>Tipe Layanan</primary></indexterm>

	<para>Bidang ToS dapat diatur oleh aplikasi yang menghasilkan paket IP, atau diubah sambil jalan oleh <emphasis>netfilter</emphasis>. Aturan berikut cukup untuk meningkatkan responsivitas untuk server layanan SSH:</para>

        <programlisting role="scale">
iptables -t mangle -A PREROUTING -p tcp --sport ssh -j TOS --set-tos Minimize-Delay
iptables -t mangle -A PREROUTING -p tcp --dport ssh -j TOS --set-tos Minimize-Delay</programlisting>
      </section>
    </section>
  </section>
  <section id="sect.dynamic-routing">
    <title>Routing Dinamis</title>
    <indexterm><primary>routing</primary><secondary>dinamis</secondary></indexterm>
    <indexterm><primary><command>quagga</command></primary></indexterm>
    <indexterm><primary><command>zebra</command></primary></indexterm>

    <para>Alat referensi untuk routing dinamis saat ini <command>quagga</command>, dari paket yang dinamai serupa; dulu <command>zebra</command> sampai pengembangan yang terakhir berhenti. Namun, <command>quagga</command> mempertahankan nama-nama program untuk alasan kompatibilitas yang menjelaskan perintah <command>zebra</command> di bawah ini.</para>

    <sidebar>
      <title><emphasis>KEMBALI KE DASAR</emphasis> Ruting dinamis</title>

      <para>Routing dinamis memungkinkan router untuk menyesuaikan, secara real time, jalur yang digunakan untuk transmisi paket IP. Setiap protokol melibatkan metode sendiri dalam mendefinisikan rute (jalur terpendek, menggunakan rute yang diiklankan oleh teman sebaya, dan sebagainya).</para>

      <para>Di kernel Linux, rute menghubungkan perangkat jaringan ke satu set mesin yang dapat dihubungi melalui perangkat ini. Perintah <command>route</command> mendefinisikan rute baru dan menampilkan yang sudah ada.</para>
      <indexterm><primary><command>route</command></primary></indexterm>
    </sidebar>

    <para>Quagga adalah suatu kumpulan daemon yang bekerja sama untuk mendefinisikan tabel routing yang dipakai oleh kernel Linux; setiap protokol routing (terutama BGP, OSPF, dan RIP) menyediakan daemon masing-masing. Daemon <command>zebra</command> mengumpulkan informasi dari daemon-daemon lain dan menangani tabel routing statik yang sesuai. Daemon-daemon lain dikenal sebagai <command>bgpd</command>, <command>ospfd</command>, <command>ospf6d</command>, <command>ripd</command>, <command>ripngd</command>, <command>isisd</command>, dan <command>babeld</command>.</para>
    <indexterm><primary>OSPF</primary></indexterm>
    <indexterm><primary>BGP</primary></indexterm>
    <indexterm><primary>RIP</primary></indexterm>
    <indexterm><primary>IS-IS</primary></indexterm>
    <indexterm><primary>BABEL routing mesh nirkabel</primary></indexterm>
    <indexterm><primary><command>bgpd</command></primary></indexterm>
    <indexterm><primary><command>ospfd</command></primary></indexterm>
    <indexterm><primary><command>ospf6d</command></primary></indexterm>
    <indexterm><primary><command>ripd</command></primary></indexterm>
    <indexterm><primary><command>ripngd</command></primary></indexterm>
    <indexterm><primary><command>isisd</command></primary></indexterm>
    <indexterm><primary><command>babeld</command></primary></indexterm>

    <para>Daemon diaktifkan dengan mengedit berkas <filename>/etc/quagga/daemons</filename> dan menciptakan berkas konfigurasi yang sesuai di <filename>/etc/quagga/</filename>; berkas konfigurasi ini harus dinamai sama dengan daemonnya, dengan ekstensi <filename>.conf</filename> , dan dimiliki oleh pengguna <literal>quagga</literal> dan kelompok <literal>quaggavty</literal>, agar skrip <filename>/etc/init.d/quagga</filename> menjalankan daemon.</para>

    <para>Konfigurasi masing-masing daemon ini membutuhkan pengetahuan tentang protokol routing yang bersangkutan. Protokol-protokol ini tidak dapat dijelaskan secara rinci di sini, tetapi <emphasis role="pkg">quagga-doc</emphasis> memberikan penjelasan yang cukup dalam bentuk sebuah berkas <command>info</command>. Isi yang sama mungkin lebih mudah dibaca dalam bentuk HTML pada situs web Quagga:<ulink type="block" url="http://www.nongnu.org/quagga/docs/docs-info.html" /></para>

    <para>Selain itu, sintaks ini sangat dekat dengan konfigurasi antarmuka router standar, dan administrator jaringan akan beradaptasi dengan cepat ke <command>quagga</command>.</para>

    <sidebar>
      <title><emphasis>DALAM PRAKTEK</emphasis> OSPF, BGP, atau RIP?</title>

      <para>OSPF umumnya adalah protokol yang terbaik untuk digunakan untuk routing dinamis pada jaringan privat, tetapi BGP lebih umum untuk routing seluruh Internet. RIP agak kuno, dan hampir tidak digunakan lagi.</para>
    </sidebar>
  </section>
  <section id="sect.ipv6">
    <title>IPv6</title>

    <para>IPv6, penerus IPv4, adalah sebuah versi baru dari protokol IP yang dirancang untuk memperbaiki cacatnya, paling menonjol adalah langkanya alamat IP yang tersedia. Protokol ini menangani layer jaringan; tujuannya adalah untuk menyediakan suatu cara untuk memberi alamat ke mesin-mesin, mengangkut data ke tujuan yang diinginkan, dan untuk menangani fragmentasi data bila diperlukan (dengan kata lain, untuk membelah paket-paket ke dalam penggalan-penggalan dengan suatu ukuran yang bergantung kepada link jaringan yang akan dipakai pada path dan untuk merakit ulang penggalan-penggalan dalam urutan yang sesuai saat kedatangan).</para>

    <para>Kernel Debian termasuk penanganan IPv6 di kernel inti (dengan pengecualian beberapa arsitektur yang mengkompilasinya sebagai module bernama <literal>ipv6</literal>). Perkakas dasar seperti <command>ping</command> dan <command>traceroute</command> memiliki yang setara untuk IPv6 di <command>ping6</command> dan <command>traceroute6</command>, masing-masing tersedia dalam paket-paket <emphasis role="pkg">iputils-ping</emphasis> dan <emphasis role="pkg">iputils-tracepath</emphasis> .</para>
    <indexterm><primary>IPv6</primary></indexterm>
    <indexterm><primary><emphasis role="pkg">iputils-ping</emphasis></primary></indexterm>
    <indexterm><primary><emphasis role="pkg">iputils-tracepath</emphasis></primary></indexterm>

    <para>Jaringan IPv6 dikonfigurasi secara mirip dengan IPv4, di <filename>/etc/network/interfaces</filename>. Tetapi jika Anda ingin jaringan yang akan tersedia secara global, Anda harus memastikan bahwa Anda memiliki router mampu-IPv6 yang meneruskan lalu lintas ke jaringan IPv6 global.</para>

    <example id="example.network-interfaces-ipv6">
      <title>Contoh konfigurasi IPv6</title>

      <programlisting>
iface eth0 inet6 static
    address 2001:db8:1234:5::1:1
    netmask 64
    # Disabling auto-configuration
    # autoconf 0
    # The router is auto-configured and has no fixed address
    # (accept_ra 1). If it had:
    # gateway 2001:db8:1234:5::1</programlisting>
    </example>

    <para>Subnet IPv6 biasanya memiliki netmask dari 64 bit. Ini berarti bahwa 2<superscript>64</superscript> alamat yang berbeda ada dalam subnet. Hal ini memungkinkan Stateless Address Autoconfiguration (<acronym>SLAAC</acronym>) untuk memilih alamat berdasarkan alamat MAC antarmuka jaringan. Secara default, jika <acronym>SLAAC</acronym> diaktifkan dalam jaringan dan IPv6 di komputer Anda, kernel akan otomatis menemukan router IPv6 dan mengkonfigurasi antarmuka jaringan.</para>

    <para>Perilaku ini mungkin punya implikasi privasi. Bila Anda sering berpindah jaringan, mis. dengan suatu laptop, Anda mungkin tidak ingin alamat <acronym>MAC</acronym> menjadi bagian dari alamat IPv6 publik Anda. Hal ini membuat mudah mengidentifikasi peranti yang sama di manapun di jaringan. Suatu solusi untuk ini adalah ekstensi privasi IPv6 (yang secara baku difungsikan oleh Debian bila konektivitas IPv6 terdeteksi selama instalasi awal), yang akan menugaskan alamat tambahan yang dibuat secara acak ke antarmuka, secara berkala mengubah mereka dan lebih menyukai mereka untuk koneksi arah keluar. Koneksi arah masuk masih tetap dapat memakai alamat yang dibuat oleh SLAAC. Contoh berikut, untuk dipakai dalam <filename>/etc/network/interfaces</filename>, mengaktifkan ekstensi privasi ini.</para>

    <example id="example.network-interface-ipv6-privext">
      <title>Ekstensi privasi IPv6</title>

      <programlisting>
iface eth0 inet6 auto
    # Prefer the randomly assigned addresses for outgoing connections.
    privext 2</programlisting>
    </example>

    <sidebar>
      <title><emphasis>TIP</emphasis> Program-program yang dibangun dengan IPv6</title>

      <para>Banyak potongan perangkat lunak yang perlu disesuaikan untuk menangani IPv6. Sebagian besar paket Debian telah usai disesuaikan, tetapi tidak semua. Jika paket favorit Anda belum bekerja dengan IPv6, Anda dapat meminta bantuan pada milis <emphasis>debian-ipv6</emphasis>. Mereka mungkin tahu tentang pengganti yang IPv6-aware dan dapat melaporkan bug agar masalah dilacak dengan benar. <ulink type="block" url="http://lists.debian.org/debian-ipv6/" /></para>
    </sidebar>

    <indexterm><primary>firewall IPv6</primary></indexterm>
    <indexterm><primary>firewall</primary><secondary>IPv6</secondary></indexterm>
    <indexterm><primary><command>ip6tables</command></primary></indexterm>
    <para>Koneksi IPv6 dapat dibatasi, dalam cara yang sama untuk IPv4: kernel Debian standar termasuk sebuah adaptasi dari <emphasis>netfilter</emphasis> untuk IPv6. <emphasis>netfilter</emphasis> yang mendukung IPv6 ini dikonfigurasi dengan cara yang serupa untuk mitra IPv4-nya, kecuali program yang dipakai adalah <command>ip6tables</command> bukan <command>iptables</command>.</para>

    <section id="sect.ipv6-tunneling">
      <title>Tunneling</title>

      <sidebar>
        <title><emphasis>HATI-HATI</emphasis> tunnel dan firewall IPv6</title>

        <para>Tunneling IPv6 di IPv4 (alih-alih IPv6 native) memerlukan firewall untuk menerima lalu lintas, yang menggunakan protokol IPv4 nomor 41.</para>
      </sidebar>

      <para>Jika koneksi IPv6 yang native tidak tersedia, metode alternatif adalah dengan menggunakan sebuah tunnel di atas IPv4. Gogo6 adalah salah satu penyedia (gratis) tunnel tersebut: <ulink type="block" url="http://www.gogo6.com/freenet6/tunnelbroker" /></para>
      <indexterm><primary>Freenet6</primary></indexterm>
      <indexterm><primary>Gogo6</primary></indexterm>

      <para>Untuk menggunakan sebuah tunnel Freenet6, Anda perlu mendaftar ke akun Freenet6 Pro pada situs web, kemudian memasang paket <emphasis role="pkg">gogoc</emphasis> dan mengkonfigurasi tunnel. Hal ini memerlukan menyunting berkas <filename>/etc/gogoc/gogoc.conf</filename>: baris <literal>userid</literal> dan <literal>password</literal> yang diterima melalui surel harus ditambahkan, dan <literal>server</literal> harus diganti dengan <literal>authenticated.freenet6.net</literal>.</para>

      <para>Konektivitas IPv6 diusulkan untuk semua mesin di jaringan lokal dengan menambahkan tiga arahan berikut ke berkas <filename>/etc/gogoc/gogoc.conf</filename> (dengan asumsi jaringan lokal terhubung ke antarmuka eth0):</para>

      <programlisting>
host_type=router
prefixlen=56
if_prefix=eth0</programlisting>

      <para>Mesin ini kemudian menjadi akses router untuk subnet dengan prefiks 56-bit. Setelah tunnel menyadari perubahan ini, jaringan lokal harus diberitahu tentang hal itu; ini berarti memasang daemon <command>radvd</command> (dari paket yang bernama sama). Daemon konfigurasi IPv6 ini memiliki peran mirip <command>dhcpd</command> di dunia IPv4.</para>

      <para>Berkas konfigurasi <filename>/etc/radvd.conf</filename> harus kemudian dibuat (Lihat <filename>/usr/share/doc/radvd/examples/simple-radvd.conf</filename> sebagai titik awal). Dalam kasus kami, satu-satunya perubahan yang diperlukan adalah awalan, yang perlu diganti dengan yang disediakan oleh Freenet6; hal ini dapat ditemukan dalam keluaran perintah <command>ifconfig</command>, di blok mengenai antarmuka <literal>tun</literal> .</para>
      <indexterm><primary><command>radvd</command></primary></indexterm>

      <para>Kemudian jalankan <command>service gogoc restart</command> dan <command>service radvd start</command>, dan jaringan IPv6 yang seharusnya bekerja.</para>
    </section>

  </section>
  <section id="sect.domain-name-servers">
    <title>Domain Name Servers (DNS)</title>
    <section id="sect.dns-principe">
      <title>Prinsip dan Mekanisme</title>
      <indexterm><primary>DNS</primary></indexterm>
      <indexterm><primary>server</primary><secondary>nama</secondary></indexterm>

      <para><emphasis>Layanan Nama Domain</emphasis> (Domain Name Service, DNS) adalah komponen fundamental dari Internet: itu memetakan nama host ke alamat IP (dan sebaliknya), yang memungkinkan penggunaan <literal>www.debian.org</literal> daripada <literal>5.153.231.4</literal> atau <literal>2001:41c8:1000:21::21:4</literal>.</para>

      <para>Record-record DNS disusun dalam zona; setiap zona cocok dengan suatu domain (atau subdomain) atau suatu rentang alamat IP (karena alamat IP umumnya dialokasikan dalam rentang berturutan). Sebuah server adalah otoritatif atas isi suatu zona; server sekunder, sering diwadahi pada mesin terpisah, menyediakan salinan zona utama yang diperbarui secara teratur.</para>
      <indexterm><primary>zona</primary><secondary>DNS</secondary></indexterm>
      <indexterm><primary>DNS</primary><secondary>zone</secondary></indexterm>

      <para>Setiap zona dapat berisi record dari berbagai jenis (<emphasis>Record Sumber Daya</emphasis>):</para>
      <itemizedlist>
        <listitem>
	  <para><literal>A</literal>: Alamat IPv4. <indexterm><primary>A, record DNS </primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>CNAME</literal>: alias (<emphasis>nama kanonis</emphasis>). <indexterm><primary>CNAME, record DNS</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>MX</literal>: <emphasis>pertukaran surat</emphasis>, server surel. Informasi ini digunakan oleh server surel lain untuk menemukan tempat mengirim surel yang ditujukan ke alamat yang diberikan. Setiap data MX memiliki prioritas. Server prioritas tertinggi (dengan angka terendah) dicoba terlebih dahulu (lihat bilah sisi <xref linkend="sidebar.smtp" /> ); server lain dihubungi dalam prioritas menurun jika yang pertama tidak membalas. <indexterm><primary>MX</primary><secondary>record DNS</secondary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>PTR</literal>: pemetaan alamat IP ke suatu nama. Record semacam itu disimpan dalam zona "reverse DNS" yang diberi nama sesuai dengan rentang alamat IP. Sebagai contoh, <literal>1.168.192.in-addr.arpa</literal> adalah zona yang berisi pemetaan balik untuk semua alamat di rentang <literal>192.168.1.0/24</literal>. <indexterm><primary>PTR, record DNS</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>AAAA</literal>: Alamat IPv6. <indexterm><primary>AAAA, record DNS</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>NS</literal>: memetakan suatu nama ke sebuah server nama. Setiap domain harus punya paling tidak satu record NS. Record ini menunjuk ke suatu server DNS yang dapat menjawab kueri-kueri menyangkut domain ini; mereka biasanya menunjuk ke server primer dan sekunder bagi domain tersebut. Record ini juga mengizinkan delegasi DNS; sebagai contoh, zona <literal>falcot.com</literal> bisa termasuk suatu record NS bagi <literal>internal.falcot.com</literal>, yang berarti bahwa zona <literal>internal.falcot.com</literal> ditangani oleh server lain. Tentu saja, server ini mesti mendeklarasikan zona <literal>internal.falcot.com</literal>. <indexterm><primary>NS, record DNS</primary></indexterm></para>
        </listitem>
      </itemizedlist>
      
      <indexterm><primary>record</primary><secondary>DNS</secondary></indexterm>
      <indexterm><primary>Record DNS</primary></indexterm>

      <para>Server nama referensi, Bind, dikembangkan dan dikelola oleh ISC (<emphasis>Internet Software Consortium</emphasis>). Disediakan di Debian oleh paket <emphasis role="pkg">bind9</emphasis>. Versi 9 membawa dua perubahan besar dibandingkan dengan versi sebelumnya. Pertama, server DNS sekarang dapat dijalankan di bawah pengguna tanpa hak khusus, sehingga kerentanan keamanan di server tidak memberikan hak akses root ke penyerang (seperti yang terlihat berkali-kali dengan versi 8.x).</para>

      <para>Selain itu, Bind mendukung standar DNSSEC untuk penandatanganan (dan karena itu otentikasi) record DNS, yang memungkinkan memblokir setiap spoofing data ini selama serangan man-in-the-middle.</para>
      <indexterm><primary><emphasis role="pkg">bind9</emphasis></primary></indexterm>
      <indexterm><primary>ISC</primary></indexterm>
      <indexterm><primary>Internet Software Consortium</primary></indexterm>

      <sidebar>
        <title><emphasis>KULTUR</emphasis> DNSSEC</title>
        <indexterm><primary>DNSSEC</primary></indexterm>

	<para>Norma DNSSEC cukup kompleks; ini menjelaskan sebagian mengapa DNSSEC belum digunakan secara luas (bahkan jika itu secara sempurna berdampingan dengan dengan server DNS yang tidak sadar-DNSSEC). Untuk memahami semua seluk-beluknya, Anda harus memeriksa artikel berikut. <ulink type="block" url="http://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions" />&gt;</para>
      </sidebar>
    </section>
    <section id="sect.dns-config">
      <title>Mengkonfigurasi</title>

      <para>Berkas konfigurasi untuk <command>bind</command>, terlepas dari versi, memiliki struktur yang sama.</para>

      <para>Para administrator Falcot menciptakan sebuah zona utama <literal>falcot.com</literal> untuk menyimpan informasi yang terkait dengan domain ini, dan zona <literal>168.192.in-addr.arpa</literal> untuk pemetaan balik alamat IP pada jaringan lokal.</para>

      <sidebar>
        <title><emphasis>HATI-HATI</emphasis> Nama-nama zone reverse</title>
        <indexterm><primary>zona</primary><secondary>reverse</secondary></indexterm>
        <indexterm><primary>reverse zone</primary></indexterm>
        <indexterm><primary><literal>in-addr.arpa</literal></primary></indexterm>
        <indexterm><primary><literal>ip6.arpa</literal></primary></indexterm>
	<indexterm><primary>format nibble</primary></indexterm>

	<para>Zona reverse memiliki nama khusus. Zona yang meliputi jaringan <literal>192.168.0.0/16</literal> perlu diberi nama <literal>168.192.in-addr.arpa</literal>: komponen alamat IP dibalik, dan diikuti oleh akhiran <literal>in-addr.arpa</literal>.</para>

	<para>Untuk jaringan IPv6, akhiran adalah <literal>ip6.arpa</literal> dan komponen alamat IP yang dibalik adalah setiap karakter pada perwakilan penuh heksadesimal alamat IP. Dengan demikian, jaringan <literal>2001:0bc8:31a0::/48</literal> akan menggunakan zona yang bernama <literal>0.a.1.3.8.c.b.0.1.0.0.2.ip6.arpa</literal>.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>TIP</emphasis> Pengujian DNS server</title>

	<para>Perintah <command>host</command> (dalam paket <emphasis role="pkg">bind9-host</emphasis>) mengkueri server DNS, dan dapat digunakan untuk menguji konfigurasi server. Sebagai contoh, <command>host machine.falcot.com localhost</command> memeriksa balasan server lokal untuk permintaan <literal>machine.falcot.com</literal>. <command>host <replaceable>alamatip</replaceable> localhost</command> menguji resolusi terbalik.</para>
	<indexterm><primary><command>host</command></primary></indexterm>
      </sidebar>

      <para>Kutipan-kutipan konfigurasi berikut, diambil dari berkas Falcot, dapat berfungsi sebagai titik awal untuk mengkonfigurasi sebuah server DNS:</para>
      <indexterm><primary><filename>named.conf</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/bind/named.conf</filename></primary></indexterm>

      <example id="example.bind-named.conf.local">
        <title>Kutipan dari <filename>/etc/bind/named.conf.local</filename></title>

        <programlisting>
zone "falcot.com" {
        type master;
        file "/etc/bind/db.falcot.com";
        allow-query { any; };
        allow-transfer {
                195.20.105.149/32 ; // ns0.xname.org
                193.23.158.13/32 ; // ns1.xname.org
        };
};

zone "internal.falcot.com" {
        type master;
        file "/etc/bind/db.internal.falcot.com";
        allow-query { 192.168.0.0/16; };
};

zone "168.192.in-addr.arpa" {
        type master;
        file "/etc/bind/db.192.168";
        allow-query { 192.168.0.0/16; };
};</programlisting>
      </example>

      <example id="example.bind-db.falcot.com">
        <title>Kutipan dari <filename>/etc/bind/db.falcot.com</filename></title>

        <programlisting>; falcot.com Zone 
; admin.falcot.com. =&gt; zone contact: admin@falcot.com
$TTL    604800
@       IN      SOA     falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
;
; The @ refers to the zone name ("falcot.com" here)
; or to $ORIGIN if that directive has been used
;
@       IN      NS      ns
@       IN      NS      ns0.xname.org.

internal IN      NS      192.168.0.2

@       IN      A       212.94.201.10
@       IN      MX      5 mail
@       IN      MX      10 mail2

ns      IN      A       212.94.201.10
mail    IN      A       212.94.201.10
mail2   IN      A       212.94.201.11
www     IN      A       212.94.201.11

dns     IN      CNAME   ns</programlisting>
      </example>

      <sidebar>
        <title><emphasis>HATI-HATI</emphasis> Sintaks nama</title>

	<para>Sintaks nama-nama mesin mengikuti aturan ketat. Contohnya, <literal>mesin</literal> menyiratkan <literal>mesin.<replaceable>domain</replaceable></literal>. Jika nama domain tidak harus ditambahkan ke nama, nama tersebut harus ditulis sebagai <literal>mesin.</literal> (dengan titik sebagai sufiks). Maka menunjukkan nama DNS di luar domain saat ini memerlukan sintaks seperti <literal>mesin.domainlain.com.</literal> (dengan titik akhir).</para>
      </sidebar>

      <example id="example.bind-db.192.168">
        <title>Kutipan dari <filename> /etc/bind/db.192.168 </filename></title>

        <programlisting>; Reverse zone for 192.168.0.0/16
; admin.falcot.com. =&gt; zone contact: admin@falcot.com
$TTL    604800
@       IN      SOA     ns.internal.falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL

        IN      NS      ns.internal.falcot.com.

; 192.168.0.1 -&gt; arrakis
1.0     IN      PTR     arrakis.internal.falcot.com.
; 192.168.0.2 -&gt; neptune
2.0     IN      PTR     neptune.internal.falcot.com.

; 192.168.3.1 -&gt; pau
1.3     IN      PTR     pau.internal.falcot.com.</programlisting>
      </example>
    </section>
  </section>
  <section id="sect.dhcp">
    <title>DHCP</title>

    <para>DHCP (untuk <emphasis>Dynamic Host Configuration Protocol</emphasis>) adalah protokol yang dengannya suatu mesin dapat secara otomatis mendapatkan konfigurasi jaringannya ketika boot. Ini memungkinkan sentralisasi manajemen konfigurasi jaringan, dan memastikan bahwa semua mesin desktop mendapatkan pengaturan yang serupa.</para>
    <indexterm><primary>DHCP</primary></indexterm>
    <indexterm><primary>Dynamic Host Configuration Protocol</primary></indexterm>
    <indexterm><primary>jaringan</primary><secondary>konfigurasi DHCP</secondary></indexterm>

    <para>Sebuah server DHCP menyediakan banyak parameter terkait jaringan. Yang paling umum adalah alamat IP dan mesin masuk jaringan mana, tetapi juga bisa menyediakan informasi lainnya, seperti server DNS, server WINS, server NTP, dan sebagainya.</para>

    <para>Internet Software Consortium (juga terlibat dalam mengembangkan <command>bind</command>) adalah penulis utama dari server DHCP. Paket Debian yang cocok adalah <emphasis role="pkg">isc-dhcp-server</emphasis>.</para>

    <section id="sect.dhcp-config">
      <title>Mengkonfigurasi</title>

      <para>Elemen pertama yang perlu disunting dalam berkas konfigurasi DHCP (<filename>/etc/dhcp/dhcpd.conf</filename>) adalah nama domain dan server DNS. Bila server hanya sendiri pada jaringan lokal (sebagaimana didefinisikan oleh propagasi broadcast), direktif <literal>authoritative</literal> juga mesti difungsika (atau dihapus tanda komentarnya). Kita juga perlu membuat suatu bagian <literal>subnet</literal> yang menjelaskan jaringan lokal dan informasi konfigurasi yang akan disediakan. Contoh berikut pas ke jaringan lokal <literal>192.168.0.0/24</literal> dengan sebuah router pada <literal>192.168.0.1</literal> melayani sebagai gateway. Alamat IP yang tersedia ada dalam rentang <literal>192.168.0.128</literal> sampai <literal>192.168.0.254</literal>.</para>

      <example id="example.dhcp-dhcpd.conf">
        <title>Kutipan dari <filename>/etc/dhcp/dhcpd.conf</filename></title>

        <programlisting>
#
# Sample configuration file for ISC dhcpd for Debian
#

# The ddns-updates-style parameter controls whether or not the server will
# attempt to do a DNS update when a lease is confirmed. We default to the
# behavior of the version 2 packages ('none', since DHCP v2 didn't
# have support for DDNS.)
ddns-update-style interim;

# option definitions common to all supported networks...
option domain-name "internal.falcot.com";
option domain-name-servers ns.internal.falcot.com;

default-lease-time 600;
max-lease-time 7200;

# If this DHCP server is the official DHCP server for the local
# network, the authoritative directive should be uncommented.
authoritative;

# Use this to send dhcp log messages to a different log file (you also
# have to hack syslog.conf to complete the redirection).
log-facility local7;

# My subnet
subnet 192.168.0.0 netmask 255.255.255.0 {
    option routers 192.168.0.1;
    option broadcast-address 192.168.0.255;
    range 192.168.0.128 192.168.0.254;
    ddns-domainname "internal.falcot.com";
}</programlisting>
      </example>
    </section>
    <section id="sect.dhcp-dns">
      <title>DHCP dan DNS</title>
      <indexterm><primary>DNS</primary><secondary>pembaruan otomatis</secondary></indexterm>

      <para>Fitur bagus adalah pendaftaran otomatis klien DHCP di zona DNS, sehingga setiap mesin mendapat nama yang signifikan (daripada sesuatu yang impersonal seperti <literal>mesin-192-168-0-131.internal.falcot.com</literal>). Menggunakan fitur ini memerlukan konfigurasi server DNS untuk menerima update bagi zona DNS <literal>internal.falcot.com</literal> dari server DHCP, dan mengkonfigurasi yang terakhir untuk mengirimkan pambaruan bagi setiap pendaftaran.</para>

      <para>Dalam kasus <command>bind</command>, direktif <literal>allow-update</literal> perlu ditambahkan ke masing-masing zona yang akan disuting oleh server DHCP server (satu untuk domain <literal>internal.falcot.com</literal>, dan zona balik). Direktif ini memuat daftar alamat IP yang diizinkan untuk melakukan pembaruan ini; oleh karena itu harus mengandung alamat-alamat server DHCP yang mungkin (alamat lokal dan alamat publik, jika sesuai).</para>

      <programlisting>
allow-update { 127.0.0.1 192.168.0.1 212.94.201.10 !any };</programlisting>

      <para>Berhati-hatilah! Zona yang dapat diubah <emphasis>akan</emphasis> diganti oleh <command>bind</command>, dan yang kedua akan menimpa berkas-berkas konfigurasi secara berkala. Karena prosedur ini otomatis menghasilkan berkas yang kurang terbaca-manusia daripada ditulis secara manual, para administrator Falcot menangani domain <literal>internal.falcot.com</literal> dengan server DNS yang didelegasikan; ini berarti berkas zona <literal>falcot.com</literal> tetap tegas di bawah kontrol manual mereka.</para>

      <para>Kutipan konfigurasi server DHCP di atas sudah termasuk petunjuk yang diperlukan untuk pembaruan zona DNS: mereka adalah baris <literal>ddns-update-style interim;</literal> dan <literal>ddns-domain-name "internal.falcot.com";</literal> di blok yang menggambarkan subnet.</para>
    </section>
  </section>
  <section id="sect.network-diagnosis-tools">
    <title>Alat Diagnosis Jaringan</title>

    <para>Ketika sebuah aplikasi jaringan tidak berjalan seperti yang diharapkan, sangat penting untuk dapat melihat di belakang layar. Bahkan ketika semuanya tampaknya berjalan lancar, menjalankan diagnosis jaringan dapat membantu memastikan semuanya bekerja seperti seharusnya. Ada beberapa alat diagnosis untuk tujuan ini; masing-masing beroperasi pada tingkat yang berbeda.</para>
    <section id="sect.netstat">
      <title>Diagnosis Lokal: <command>netstat</command></title>
      <indexterm><primary><command>netstat</command></primary></indexterm>

      <para>Pertama mari kita bahas perintah <command>netstat</command> (dalam paket <emphasis role="pkg">net-tools</emphasis>); itu menampilkan suatu ringkasan seketika dari aktivitas jaringan komputer. Ketika dipanggil tanpa argumen, perintah ini menmpilkan daftar semua koneksi yang terbuka; daftar ini bisa jadi sangat panjang karena itu termasuk soket-soket domain Unix (yang biasa dikenal sebagai daemon) yang sama sekali tidak melibatkan jaringan (sebagai contoh, komunikasi <literal>dbus</literal>, lalu lintas <literal>X11</literal>, dan komunikasi antar sistem berkas virtual dan dekstop.</para>

      <para>Invokasi yang umum karena itu menggunakan pilihan yang mengubah perilaku <command>netstat</command>. Pilihan yang paling sering digunakan antara lain:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>-t</literal>, yang menyaring hasil untuk hanya menyertakan koneksi TCP;</para>
        </listitem>
        <listitem>
	  <para><literal>-u</literal>, yang bekerja secara serupa untuk koneksi UDP; pilihan ini tidak saling eksklusif, dan salah satunya cukup untuk menghentikan menampilkan hubungan Unix-domain;</para>
        </listitem>
        <listitem>
	  <para><literal>-</literal>, juga menampilkan daftar soket yang mendengar (menunggu untuk koneksi masuk);</para>
        </listitem>
        <listitem>
	  <para><literal>-n</literal>, untuk menampilkan hasil secara numerik: alamat IP (tanpa resolusi DNS), nomor port (bukan alias sebagaimana didefinisikan dalam <filename>/etc/services</filename>) dan id pengguna (tidak ada nama login);</para>
        </listitem>
        <listitem>
	  <para><literal>-p</literal>, untuk daftar proses yang terlibat; pilihan ini hanya berguna ketika <command>netstat</command> dijalankan sebagai root, karena pengguna normal hanya akan melihat proses mereka sendiri;</para>
        </listitem>
        <listitem>
	  <para><literal>-c</literal>, untuk terus-menerus menyegarkan daftar koneksi.</para>
        </listitem>
      </itemizedlist>

      <para>Pilihan lain, didokumentasikan dalam halaman manual <citerefentry> <refentrytitle>netstat</refentrytitle> <manvolnum>8</manvolnum> </citerefentry>, menyediakan kontrol yang bahkan lebih halus atas hasil yang ditampilkan. Dalam prakteknya, lima pilihan pertama begitu sering digunakan bersama bahwa sistem dan administrator jaringan praktis mengakuisisi <command>netstat -tupan</command> sebagai refleks. Hasil yang khas, pada mesin bermuatan ringan, mungkin terlihat seperti berikut:</para>

      <screen role="scale">
<computeroutput># </computeroutput><userinput>netstat -tupan</userinput>
<computeroutput>Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      397/rpcbind     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      431/sshd        
tcp        0      0 0.0.0.0:36568           0.0.0.0:*               LISTEN      407/rpc.statd   
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      762/exim4       
tcp        0    272 192.168.1.242:22        192.168.1.129:44452     ESTABLISHED 1172/sshd: roland [
tcp6       0      0 :::111                  :::*                    LISTEN      397/rpcbind     
tcp6       0      0 :::22                   :::*                    LISTEN      431/sshd        
tcp6       0      0 ::1:25                  :::*                    LISTEN      762/exim4       
tcp6       0      0 :::35210                :::*                    LISTEN      407/rpc.statd   
udp        0      0 0.0.0.0:39376           0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:996             0.0.0.0:*                           397/rpcbind     
udp        0      0 127.0.0.1:1007          0.0.0.0:*                           407/rpc.statd   
udp        0      0 0.0.0.0:68              0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:48720           0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:111             0.0.0.0:*                           397/rpcbind     
udp        0      0 192.168.1.242:123       0.0.0.0:*                           539/ntpd        
udp        0      0 127.0.0.1:123           0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:123             0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:5353            0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:39172           0.0.0.0:*                           407/rpc.statd   
udp6       0      0 :::996                  :::*                                397/rpcbind     
udp6       0      0 :::34277                :::*                                407/rpc.statd   
udp6       0      0 :::54852                :::*                                916/dhclient    
udp6       0      0 :::111                  :::*                                397/rpcbind     
udp6       0      0 :::38007                :::*                                451/avahi-daemon: r
udp6       0      0 fe80::5054:ff:fe99::123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:a:123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:5:123 :::*                                539/ntpd        
udp6       0      0 ::1:123                 :::*                                539/ntpd        
udp6       0      0 :::123                  :::*                                539/ntpd        
udp6       0      0 :::5353                 :::*                                451/avahi-daemon: r
</computeroutput></screen>

      <para>Seperti yang diharapkan, daftar ini menampilkan koneksi yang terjalin, dua koneksi SSH dalam kasus ini, dan aplikasi yang menunggu koneksi masuk (terdaftar sebagai <literal>LISTEN</literal>), terutama server surel Exim4 yang mendengarkan di port 25.</para>
    </section>
    <section id="sect.nmap">
      <title>Diagnosis Jarak Jauh: <command>nmap</command></title>
      <indexterm><primary><command>nmap</command></primary></indexterm>

      <para><command>nmap</command> (dalam paket yang bernama mirip) adalah, sedikit banyak, ekuivalen remote untuk <command>netstat</command>. Itu dapat memindai suatu set port yang "dikenal luas" untuk satu server remote atau lebih, dan menampilkan daftar port dimana suatu aplikasi ditemukan yang menjawab koneksi masuk. Lebih jauh, <command>nmap</command> dapat mengidentifikasi beberapa dari aplikasi ini, bahkan terkadang nomor versi mereka. Kekurangan dari perkakas ini adalah, karena itu dijalankan secara remote, tidak dapat menyediakan informasi tentang proses-proses atau para pengguna; namun, itu dapat beroperasi pada beberapa target sekaligus.</para>

      <para>Pemanggilan tipikal <command>nmap</command> hanya menggunakan pilihan <literal>-A</literal> (sehingga <command>nmap</command> mencoba mengidentifikasi versi perangkat lunak server yang ditemukannya) diikuti oleh satu atau lebih alamat IP atau nama DNS mesin yang akan dipindai. Sekali lagi, lebih banyak opsi yang ada untuk mengendalikan perilaku <command>nmap</command>; silakan lihat dokumentasi di halaman manual <citerefentry><refentrytitle>nmap</refentrytitle><manvolnum>1</manvolnum></citerefentry>.</para>

      <screen role="scale" width="80">
<computeroutput># </computeroutput><userinput>nmap mirtuel</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET
Nmap scan report for mirtuel (192.168.1.242)
Host is up (0.000013s latency).
rDNS record for 192.168.1.242: mirtuel.internal.placard.fr.eu.org
Not shown: 998 closed ports
PORT    STATE SERVICE
22/tcp  open  ssh
111/tcp open  rpcbind

Nmap done: 1 IP address (1 host up) scanned in 2.41 seconds
# </computeroutput><userinput>nmap -A localhost</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000013s latency).
Other addresses for localhost (not scanned): 127.0.0.1
Not shown: 997 closed ports
PORT    STATE SERVICE VERSION
22/tcp  open  ssh     OpenSSH 6.7p1 Debian 3 (protocol 2.0)
|_ssh-hostkey: ERROR: Script execution failed (use -d to debug)
25/tcp  open  smtp    Exim smtpd 4.84
| smtp-commands: mirtuel Hello localhost [127.0.0.1], SIZE 52428800, 8BITMIME, PIPELINING, HELP, 
|_ Commands supported: AUTH HELO EHLO MAIL RCPT DATA NOOP QUIT RSET HELP 
111/tcp open  rpcbind 2-4 (RPC #100000)
| rpcinfo: 
|   program version   port/proto  service
|   100000  2,3,4        111/tcp  rpcbind
|   100000  2,3,4        111/udp  rpcbind
|   100024  1          36568/tcp  status
|_  100024  1          39172/udp  status
Device type: general purpose
Running: Linux 3.X
OS CPE: cpe:/o:linux:linux_kernel:3
OS details: Linux 3.7 - 3.15
Network Distance: 0 hops
Service Info: Host: mirtuel; OS: Linux; CPE: cpe:/o:linux:linux_kernel

OS and Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 11.54 seconds
</computeroutput></screen>

      <para>Seperti yang diharapkan, aplikasi SSH dan Exim4 tercantum. Perhatikan bahwa tidak semua aplikasi mendengarkan pada semua alamat IP; karena Exim4 ini hanya dapat diakses pada antarmuka loopback <literal>lo</literal>, itu hanya muncul selama analisis <literal>localhost</literal> dan tidak ketika pemindaian <literal>mirtuel</literal> (yang terpetakan ke antarmuka <literal>eth0</literal> di mesin yang sama).</para>
    </section>
    <section id="sect.sniffers">
      <title>Sniffer: <command>tcpdump</command> dan <command>wireshark</command></title>

      <para>Kadang-kadang, orang perlu untuk melihat apa yang sebenarnya terjadi pada kabel, paket per paket. Kasus ini panggilan untuk “penganalsis frame”, lebih dikenal sebagai <emphasis>niffer</emphasis>. Suatu alat yang mengamati semua paket yang mencapai antarmuka jaringan tertentu, dan menampilkan mereka dalam cara yang ramah pengguna.</para>
      <indexterm><primary><command>tcpdump</command></primary></indexterm>

      <para>Alat mulia dalam domain ini adalah <command>tcpdump</command>, tersedia sebagai alat standar pada berbagai platform. Hal ini memungkinkan menangkap banyak jenis lalu lintas jaringan, tapi representasi dari lalu lintas ini tetap agak kabur. Karenanya kami tidak akan menjelaskan secara lebih terperinci.</para>
      <indexterm><primary><command>wireshark</command></primary></indexterm>

      <para>Perkakas yang lebih terkini (dan lebih modern), <command>wireshark</command> (dalam paket <emphasis role="pkg">wireshark</emphasis>), telah menjadi acuan baru dalam analisis lalu lintas jaringan karena banyak modul pendekodeannya yang mengizinkan analisis yang disederhanakan atas paket-paket yang ditangkap. Paket-paket ditampilkan secara grafis dengan suatu pengorganisasian berbasis layer protokol. Ini memungkinkan pengguna memvisualisasi semua protokol yang terlibat dalam sebuah paket. Sebagai contoh, diberikan suatu paket yang memuat sebuah permintaan HTTP, <command>wireshark</command> menampilkan, secara terpisah, informasi terkait layer fisik, layer Ethernet, informasi paket IP, parameter koneksi TCP, dan akhirnya permintaan HTTP itu sendiri.</para>

      <figure id="figure.wireshark">
        <title><command>wireshark</command> penganalisis lalu lintas jaringan</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/wireshark.png" scalefit="1" width="75%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Dalam contoh kita, paket-paket yang berjalan di atas SSH disaring (dengan penyaring <literal>!tcp.port == 22</literal>). Paket yang sedang ditampilkan dikembangkan pada layer HTTP.</para>

      <sidebar>
        <title><emphasis>TIP</emphasis> <command>wireshark</command> tanpa antar muka grafis: <command>tshark</command></title>
        <indexterm><primary><command>tshark</command></primary></indexterm>

	<para>Ketika seseorang tidak dapat menjalankan antarmuka grafis, atau tidak ingin menjalankannya dengan alasan apapun, suatu versi hanya-teks dari <command>wireshark</command> juga ada dengan nama <command>tshark</command> (dalam sebuah paket terpisah <emphasis role="pkg">tshark</emphasis>). Kebanyakan dari fitur tangkap dan dekode masih tersedia, tapi ketiadaan antarmuka grafis membatasi interaksi dengan program (menyaring paket setelah ditangkap, melacak koneksi TCP tertentu, dan seterusnya). Itu masih dapat dipakai sebagai sebuah pendekatan pertama. Bila manipulasi lebih lanjut dikehendaki dan memerlukan antarmuka grafis, paket-paket dapat disimpan ke suatu berkas dan berkas ini dapat dimuat ke dalam sebuah <command>wireshark</command> grafis yang berjalan pada mesin lain.</para>
      </sidebar>
    </section>
  </section>
</chapter>
