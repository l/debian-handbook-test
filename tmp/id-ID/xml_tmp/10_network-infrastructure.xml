<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="network-infrastructure">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-network-infrastructure.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Jaringan</keyword>
      <keyword>Gateway</keyword>
      <keyword>TCP/IP</keyword>
      <keyword>IPv6</keyword>
      <keyword>DNS</keyword>
      <keyword>Bind</keyword>
      <keyword>DHCP</keyword>
      <keyword>QoS</keyword>
    </keywordset>
  </chapterinfo>
  <title id="infrastructure.title">Infrastruktur Jaringan</title>
  <highlights>
    <para>Linux memperoleh seluruh warisan Unix untuk jaringan, dan Debian menyediakan set lengkap peralatan untuk membuat dan mengelola mereka. Bab ini mengulas peralatan tersebut.</para>
  </highlights>
  <section id="sect.gateway">
    <title>Gateway</title>

    <para>Gateway adalah sebuah sistem yang menghubungkan beberapa jaringan. Istilah ini sering mengacu pada "titik keluar" jaringan lokal pada jalur wajib untuk semua alamat IP eksternal. Gateway terhubung ke masing-masing jaringan yang dihubungkannya, dan bertindak sebagai sebuah router untuk menyampaikan paket-paket IP antara berbagai antarmuka.</para>
    <indexterm><primary>gateway</primary></indexterm>
    <indexterm><primary>network</primary><secondary>gateway</secondary></indexterm>
    <indexterm><primary>router</primary></indexterm>

    <sidebar>
      <title><emphasis>KEMBALI KE DASAR</emphasis> paket IP</title>
      <indexterm><primary>paket</primary><secondary>IP</secondary></indexterm>

      <para>Sebagian besar jaringan saat ini menggunakan protokol IP (<emphasis>Internet Protocol</emphasis>). Protokol ini mensegmentasi data yang ditransmisikan ke paket-paket ukuran terbatas. Setiap packet berisi, selain muatan datanya, sejumlah rincian yang diperlukan untuk routing yang tepat.</para>
    </sidebar>

    <sidebar id="sidebar.tcp-udp">
      <title><emphasis>KEMBALI KE DASAR</emphasis> TCP/UDP</title>
      <indexterm><primary>port</primary><secondary>TCP</secondary></indexterm>
      <indexterm><primary>port</primary><secondary>UDP</secondary></indexterm>
      <indexterm><primary>TCP, port</primary></indexterm>
      <indexterm><primary>UDP, port</primary></indexterm>

      <para>Banyak program yang tidak menangani sendiri paket-paket individu, walaupun data yang mereka transmisikan berjalan melalui IP; mereka sering memakai TCP (<emphasis>Transmission Control Protocol</emphasis>). TCP adalah suatu lapisan di atas IP yang mengizinkan terjalinnya koneksi yang didedikasikan ke stream data antara dua titik. Program kemudian hanya melihat suatu titik masuk tempat data diasupkan dengan garansi bahwa data yang sama keluar tanpa ada kehilangan (dan dalam urutan yang sama) di titik keluar di ujung lain koneksi. Walaupun banyak jenis kesalahan dapat terjadi dalam lapisan-lapisan yang lebih rendah, mereka dikompensasi oleh TCP: paket hilang dipancarkan ulang, dan paket yang datang tak berurut (sebagai contoh, bila mereka memakai path yang berbeda) diurutkan ulang secara tepat.</para>

      <para>Protokol lain yang mengandalkan IP adalah UDP (<emphasis>User Datagram Protocol</emphasis>). Berbeda dengan TCP, ini berorientasi paket. Sasarannya berbeda: tujuan UDP hanya untuk mentransmisikan satu paket dari sebuah aplikasi ke lainnya. Protokol tidak mencoba mengkompensasi kemungkinan kehilangan paket di jalan, maupun tidak memastikan bahwa paket diterima dalam urutan yang sama dengan saat dikirim. Keuntungan utama atas protokol ini adalah latensinya jauh lebih baik, karena kehilangan satu paket tidak menunda penerimaan semua paket yang mengikuti sampai satu yang hilang ditransmisikan ulang.</para>

      <para>TCP dan UDP keduanya melibatkan port, yang merupakan “nomor ekstensi” untuk menjalin komunikasi dengan suatu aplikasi pada sebuah mesin. Konsep ini mengizinkan menjaga beberapa komunikasi yang berbeda secara paralel dengan korespondensi yang sama, karena komunikasi ini dapat dibedakan menurut nomor portnya.</para>

      <para>Beberapa dari nomor port ini — distandarkan oleh IANA (<emphasis>Internet Assigned Numbers Authority</emphasis>) — "dikenal baik" berasosiasi dengan layanan-layanan jaringan. Sebagai contoh, TCP port 25 biasanya dipakai oleh server surel. <ulink type="block" url="http://www.iana.org/assignments/port-numbers" /></para>
    </sidebar>

    <para>Ketika suatu jaringan lokal memakai sebuah rentang alamat privat (yang tidak dapat di-route di Internet), gateway perlu mengimplementasikan <emphasis>masquerading alamat</emphasis> sehingga mesin-mesin pada jaringan dapat berkomunikasi dengan dunia luar. Operasi masquerading adalah semacam proksi yang beroperasi pada level jaringa: setiap koneksi arah luar dari suatu mesin internal digantikan dengan suatu koneksi dari gateway itu sendiri (karena gateway memiliki alamat eksternal, yang dapat di-route), data yang melalui koneksi yang di-masquerade dikirim ke yang baru, dan data yang kembali dalam jawaban dikirim melalui koneksi yang di-masquerade ke mesin internal. Gateway memakai suatu rentang port TCP yang terdedikasi untuk tujuan ini, biasanya dengan nomor sangat tinggi (di atas 60000). Setiap koneksi yang datang dari suatu mesin internal kemudian muncul ke dunia luar sebagai suatu koneksi yang datang dari salah satu port yang dicadangkan ini.</para>
    <indexterm><primary>masquerading</primary></indexterm>

    <sidebar>
      <title><emphasis>KULTUR</emphasis> Rentang alamat privat</title>
      <indexterm><primary>alamat IP</primary><secondary>privat</secondary></indexterm>
      <indexterm><primary>alamat IP privat</primary></indexterm>

      <para>RFC 1918 mendefinisikan tiga rentang alamat IPv4 yang tidak dimaksudkan untuk di-route di Internet tapi hanya dipakai di jaringan lokal. Yang pertama, <literal>10.0.0.0/8</literal> (lihat bilah sisi <xref linkend="sidebar.networking-basics" />), adalah suatu rentang kelas-A (dengan 2<superscript>24</superscript> alamat IP). Yang kedua, <literal>172.16.0.0/12</literal>, mengumpulkan 16 rentang kelas-B (<literal>172.16.0.0/16</literal> sampai <literal>172.31.0.0/16</literal>), masing-masing memuat 2<superscript>16</superscript> alamat IP. Akhirnya, <literal>192.168.0.0/16</literal> adalah suatu rentang kelas-B (mengelompokkan 256 rentang kelas-C, <literal>192.168.0.0/24</literal> sampai <literal>192.168.255.0/24</literal>, masing-masing dengan 256 alamat IP). <ulink type="block" url="http://www.faqs.org/rfcs/rfc1918.html" /></para>
    </sidebar>

    <para>The gateway can also perform two kinds of <emphasis>network
    address translation</emphasis> (or NAT for short). The first kind,
    <emphasis>Destination NAT</emphasis> (DNAT) is a technique to alter the
    destination IP address (and/or the TCP or UDP port) for a (generally)
    incoming connection. The connection tracking mechanism also alters the
    following packets in the same connection to ensure continuity in the
    communication. The second kind of NAT is <emphasis>Source
    NAT</emphasis> (SNAT), of which <emphasis>masquerading</emphasis> is a
    particular case; SNAT alters the source IP address (and/or the TCP or
    UDP port) of a (generally) outgoing connection. As for DNAT, all the
    packets in the connection are appropriately handled by the connection
    tracking mechanism. Note that NAT is only relevant for IPv4 and its
    limited address space; in IPv6, the wide availability of addresses
    greatly reduces the usefulness of NAT by allowing all “internal”
    addresses to be directly routable on the Internet (this does not imply
    that internal machines are accessible, since intermediary firewalls can
    filter traffic).</para>
    <indexterm><primary>NAT</primary></indexterm>
    <indexterm><primary>Network</primary><secondary>Address Translation</secondary></indexterm>
    <indexterm><primary>SNAT</primary></indexterm>
    <indexterm><primary>DNAT</primary></indexterm>
    <indexterm><primary>Destination NAT</primary></indexterm>
    <indexterm><primary>Source NAT</primary></indexterm>

    <sidebar>
      <title><emphasis>KEMBALI KE DASAR</emphasis> Penerusan port</title>
      <indexterm><primary>penerusan port</primary></indexterm>

      <para>Aplikasi konkrit DNAT adalah <emphasis>port forwarding</emphasis>. Koneksi masuk ke port tertentu dari suatu mesin diteruskan ke port pada komputer lain. Solusi lain mungkin ada untuk mencapai efek yang sama, terutama pada tingkat aplikasi dengan <command>ssh</command> (Lihat <xref linkend="sect.ssh-port-forwarding" />) atau <command>redir</command> .</para>
    </sidebar>

    <para>Teori cukup, mari kita praktek. Mengubah sistem Debian menjadi gateway adalah sekedar mengaktifkan opsi yang sesuai untuk kernel Linux, melalui sistem berkas virtual <filename>/proc/</filename>:</para>

    <screen>
<computeroutput># </computeroutput><userinput>echo 1 &gt; /proc/sys/net/ipv4/conf/default/forwarding</userinput></screen>

    <para>This option can also be automatically enabled on boot if
    <filename>/etc/sysctl.conf</filename> sets the
    <literal>net.ipv4.conf.default.forwarding</literal> option to
    <literal>1</literal>.</para>

    <example id="example.sysctl.conf">
      <title>Berkas <filename>/etc/sysctl.conf</filename></title>

      <programlisting>
net.ipv4.conf.default.forwarding = 1
net.ipv4.conf.default.rp_filter = 1
net.ipv4.tcp_syncookies = 1</programlisting>
    </example>

    <para>Efek yang sama dapat diperoleh untuk IPv6 hanya dengan mengganti <literal>ipv4</literal> dengan <literal>ipv6</literal> dalam perintah manual dan menggunakan <literal>net.ipv6.conf.all.forwarding</literal> dalam <filename>/etc/sysctl.conf</filename>.</para>

    <para>Mengaktifkan masquerading IPv4 adalah operasi yang sedikit lebih kompleks yang melibatkan konfigurasi <emphasis> netfilter </emphasis> firewall.</para>

    <para>Demikian pula dengan menggunakan NAT (untuk IPv4) membutuhkan konfigurasi <emphasis>netfilter</emphasis>. Karena tujuan utama komponen ini adalah penyaringan paket, rinciannya tercantum dalam <xref linkend="security" xrefstyle="select: label quotedtitle nopage" /> (Lihat <xref linkend="sect.firewall-packet-filtering" />).</para>
  </section>
  <section id="sect.virtual-private-network">
    <title>Virtual Private Network</title>

    <para>A <emphasis>Virtual Private Network</emphasis> (VPN for short) is
    a way to link two different local networks through the Internet by way
    of a tunnel; the tunnel is usually encrypted for confidentiality. VPNs
    are often used to integrate a remote machine within a company's local
    network.</para>
    <indexterm><primary>network</primary><secondary>virtual private</secondary></indexterm>
    <indexterm><primary>VPN</primary></indexterm>
    <indexterm><primary>virtual private network</primary></indexterm>

    <para>Several tools provide this. OpenVPN is an efficient solution,
    easy to deploy and maintain, based on SSL/TLS. Another possibility is
    using IPsec to encrypt IP traffic between two machines; this encryption
    is transparent, which means that applications running on these hosts
    need not be modified to take the VPN into account. SSH can also be used
    to provide a VPN, in addition to its more conventional features.
    Finally, a VPN can be established using Microsoft's PPTP protocol.
    Other solutions exist, but are beyond the focus of this book.</para>
    <section id="sect.openvpn">
      <title>OpenVPN</title>
      <indexterm><primary>OpenVPN</primary></indexterm>

      <para>OpenVPN adalah perangkat lunak yang didedikasikan untuk menciptakan virtual private network. Penyiapannya melibatkan menciptakan antarmuka jaringan virtual VPN server dan klien; <literal>tun</literal> (untuk tunnel level IP) dan antarmuka <literal>tap</literal> (tunnel level terowongan) yang didukung. Dalam prakteknya, antarmuka <literal>tun</literal> akan paling sering digunakan kecuali ketika klien VPN yang dimaksudkan untuk diintegrasikan ke dalam jaringan lokal server melalui bridge Ethernet.</para>

      <para>OpenVPN mengandalkan OpenSSL untuk semua kriptografi SSL/TLS dan fitur terkait (kerahasiaan, otentikasi, integritas, non-repudiation). Hal ini dapat dikonfigurasi dengan kunci pribadi bersama atau menggunakan sertifikat X.509 berdasarkan infrastuktur kunci publik. Konfigurasi terakhir ini sangat disukai karena memungkinkan fleksibilitas yang lebih besar ketika dihadapkan dengan meningkatnya jumlah pengguna roaming yang mengakses VPN.</para>

      <sidebar>
        <title><emphasis>KULTUR</emphasis> SSL dan TLS</title>
        <indexterm><primary>SSL</primary></indexterm>
        <indexterm><primary>TLS</primary></indexterm>

	<para>Protokol SSL (<emphasis>Secure Socket Layer</emphasis>) diciptakan oleh Netscape untuk mengamankan koneksi ke server-server web. Itu kemudian distandarkan oleh IETF dengan singkatan TLS (<emphasis>Transport Layer Security</emphasis>). Sejak itu TLS terus berkembang dan saat ini SSL usang karena beberapa cacat desain yang telah ditemukan.</para>
      </sidebar>
      <section id="sect.easy-rsa">
        <title>Infrastruktur Kunci Publik: <emphasis>easy-rsa</emphasis></title>
        <indexterm><primary>IKP (Infrastruktur Kunci Publik)</primary></indexterm>
        <indexterm><primary>Infrastruktur Kunci Publik</primary></indexterm>
        <indexterm><primary>X.509, sertifikat</primary></indexterm>
        <indexterm><primary>sertifikat</primary><secondary>X.509</secondary></indexterm>
        <indexterm><primary><emphasis>easy-rsa</emphasis></primary></indexterm>
        <indexterm><primary>RSA (algoritme)</primary></indexterm>
        <indexterm><primary>pasangan kunci</primary></indexterm>

	<para>The RSA algorithm is widely used in public-key cryptography.
	It involves a “key pair”, comprised of a private and a public
	key. The two keys are closely linked to each other, and their
	mathematical properties are such that a message encrypted with the
	public key can only be decrypted by someone knowing the private
	key, which ensures confidentiality. In the opposite direction, a
	message encrypted with the private key can be decrypted by anyone
	knowing the public key, which allows authenticating the origin of a
	message since only someone with access to the private key could
	generate it. When associated with a digital hash function (MD5,
	SHA1, or a more recent variant), this leads to a signature
	mechanism that can be applied to any message.</para>

	<para>However, anyone can create a key pair, store any identity on
	it, and pretend to be the identity of their choice. One solution
	involves the concept of a <emphasis>Certification
	Authority</emphasis> (CA), formalized by the X.509 standard. This
	term covers an entity that holds a trusted key pair known as a
	<emphasis>root certificate</emphasis>. This certificate is only
	used to sign other certificates (key pairs), after proper steps
	have been undertaken to check the identity stored on the key pair.
	Applications using X.509 can then check the certificates presented
	to them, if they know about the trusted root certificates.</para>

	<para>OpenVPN mengikuti aturan ini. Karena CA publik hanya mengeluarkan sertifikat dengan biaya (yang mahal), dimungkinkan untuk membuat otoritas sertifikasi pribadi dalam perusahaan. Paket <emphasis role="pkg">easy-rsa</emphasis> menyediakan alat untuk melayani sebagai infrastruktur sertifikasi X.509, diimplementasikan sebagai satu set skrip menggunakan perintah <command>openssl</command> .</para>

        <sidebar>
          <title><emphasis>CATATAN</emphasis> <emphasis>easy-rsa</emphasis> sebelum <emphasis role="distribution">Jessie</emphasis></title>

          <para>Dalam versi Debian hingga <emphasis role="distribution">Wheezy</emphasis>, <emphasis>easy-rsa</emphasis> didistribusikan sebagai bagian dari paket <emphasis role="pkg">openvpn</emphasis>, dan skripnya yang dapat ditemukan di bawah <filename>/usr/share/doc/openvpn/examples/easy-rsa/2.0/</filename>. Menyiapkan CA melibatkan menyalin direktori tersebut, bukan menggunakan perintah <command>make-cadir</command> seperti yang didokumentasikan di sini.</para>
        </sidebar>

	<para>The Falcot Corp administrators use this tool to create
	the required certificates, both for the server and the
	clients. This allows the configuration of all clients to be
	similar since they will only have to be set up so as to trust
	certificates coming from Falcot's local CA. This CA is the
	first certificate to create; to this end, the administrators
	set up a directory with the files required for the CA in an
	appropriate location, preferably on a machine not connected to
	the network in order to mitigate the risk of the CA's private
	key being stolen.</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>make-cadir pki-falcot
</userinput><computeroutput>$ </computeroutput><userinput>cd pki-falcot</userinput></screen>

	<para>They then store the required parameters into the
	<filename>vars</filename> file, especially those named with a
	<literal>KEY_</literal> prefix; these variables are then integrated
	into the environment:</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>vim vars
</userinput><computeroutput>$ </computeroutput><userinput>grep KEY_ vars
</userinput><computeroutput>export KEY_CONFIG=`$EASY_RSA/whichopensslcnf $EASY_RSA`
export KEY_DIR="$EASY_RSA/keys"
echo NOTE: If you run ./clean-all, I will be doing a rm -rf on $KEY_DIR
export KEY_SIZE=2048
export KEY_EXPIRE=3650
export KEY_COUNTRY="FR"
export KEY_PROVINCE="Loire"
export KEY_CITY="Saint-Étienne"
export KEY_ORG="Falcot Corp"
export KEY_EMAIL="admin@falcot.com"
export KEY_OU="Certificate authority"
export KEY_NAME="Certificate authority for Falcot Corp"
# If you'd like to sign all keys with the same Common Name, uncomment the KEY_CN export below
# export KEY_CN="CommonName"
$ </computeroutput><userinput>. ./vars
</userinput><computeroutput>NOTE: If you run ./clean-all, I will be doing a rm -rf on /home/roland/pki-falcot/keys
$ </computeroutput><userinput>./clean-all
</userinput></screen>

	<para>Langkah berikutnya adalah penciptaan pasangan kunci CA (dua bagian dari pasangan kunci akan disimpan di bawah <filename>keys/ca.crt</filename> dan <filename>keys/ca.key</filename> selama langkah ini):</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>./build-ca</userinput>
<computeroutput>Generating a 2048 bit RSA private key
...................................................................+++
...+++
writing new private key to 'ca.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [Falcot Corp CA]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:
</computeroutput></screen>

	<para>Sertifikat untuk server VPN dapat sekarang dibuat, maupun parameter Diffie-Hellman yang diperlukan untuk koneksi SSL/TLS sisi server. Server VPN diidentifikasi oleh nama DNS <literal>vpn.falcot.com</literal>; nama ini digunakan kembali untuk berkas-berkas kunci yang dihasilkan (<filename>keys/vpn.falcot.com.crt</filename> bagi sertifikat publik, <filename>keys/vpn.falcot.com.key</filename> untuk kunci privat):</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>./build-key-server vpn.falcot.com
</userinput><computeroutput>Generating a 2048 bit RSA private key
.....................................................................................................................+++
...........+++
writing new private key to 'vpn.falcot.com.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [vpn.falcot.com]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
Using configuration from /home/roland/pki-falcot/openssl-1.0.0.cnf
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
countryName           :PRINTABLE:'FR'
stateOrProvinceName   :PRINTABLE:'Loire'
localityName          :T61STRING:'Saint-\0xFFFFFFC3\0xFFFFFF89tienne'
organizationName      :PRINTABLE:'Falcot Corp'
organizationalUnitName:PRINTABLE:'Certificate authority'
commonName            :PRINTABLE:'vpn.falcot.com'
name                  :PRINTABLE:'Certificate authority for Falcot Corp'
emailAddress          :IA5STRING:'admin@falcot.com'
Certificate is to be certified until Mar  6 14:54:56 2025 GMT (3650 days)
Sign the certificate? [y/n]:</computeroutput><userinput>y
</userinput><computeroutput>

1 out of 1 certificate requests certified, commit? [y/n]</computeroutput><userinput>y
</userinput><computeroutput>Write out database with 1 new entries
Data Base Updated
$ </computeroutput><userinput>./build-dh
</userinput><computeroutput>Generating DH parameters, 2048 bit long safe prime, generator 2
This is going to take a long time
[…]
</computeroutput></screen>

	<para>Langkah berikut menciptakan sertifikat untuk klien VPN; satu sertifikat diperlukan untuk setiap komputer atau orang yang diizinkan untuk menggunakan VPN:</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>./build-key JoeSmith
</userinput><computeroutput>Generating a 2048 bit RSA private key
................................+++
..............................................+++
writing new private key to 'JoeSmith.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:</computeroutput><userinput>Development unit
</userinput><computeroutput>Common Name (eg, your name or your server's hostname) [JoeSmith]:</computeroutput><userinput>Joe Smith
</userinput><computeroutput>[…]</computeroutput></screen>

	<para>Now all certificates have been created, they need to be
	copied where appropriate: the root certificate's public key
	(<filename>keys/ca.crt</filename>) will be stored on all machines
	(both server and clients) as
	<filename>/etc/ssl/certs/Falcot_CA.crt</filename>. The server's
	certificate is installed only on the server
	(<filename>keys/vpn.falcot.com.crt</filename> goes to
	<filename>/etc/ssl/vpn.falcot.com.crt</filename>, and
	<filename>keys/vpn.falcot.com.key</filename> goes to
	<filename>/etc/ssl/private/vpn.falcot.com.key</filename> with
	restricted permissions so that only the administrator can read it),
	with the corresponding Diffie-Hellman parameters
	(<filename>keys/dh2048.pem</filename>) installed to
	<filename>/etc/openvpn/dh2048.pem</filename>. Client certificates
	are installed on the corresponding VPN client in a similar
	fashion.</para>
      </section>
      <section>
        <title>Mengkonfigurasi Server OpenVPN</title>

	<para>By default, the OpenVPN initialization script tries starting
	all virtual private networks defined in
	<filename>/etc/openvpn/*.conf</filename>. Setting up a VPN server
	is therefore a matter of storing a corresponding configuration file
	in this directory. A good starting point is
	<filename>/usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz</filename>,
	which leads to a rather standard server. Of course, some parameters
	need to be adapted: <literal>ca</literal>, <literal>cert</literal>,
	<literal>key</literal> and <literal>dh</literal> need to describe
	the selected locations (respectively,
	<literal>/etc/ssl/certs/Falcot_CA.crt</literal>,
	<literal>/etc/ssl/vpn.falcot.com.crt</literal>,
	<literal>/etc/ssl/private/vpn.falcot.com.key</literal> and
	<literal>/etc/openvpn/dh2048.pem</literal>). The <literal>server
	10.8.0.0 255.255.255.0</literal> directive defines the subnet to be
	used by the VPN; the server uses the first IP address in that range
	(<literal>10.8.0.1</literal>) and the rest of the addresses are
	allocated to clients.</para>

	<para>With this configuration, starting OpenVPN creates the virtual
	network interface, usually under the <literal>tun0</literal> name.
	However, firewalls are often configured at the same time as the
	real network interfaces, which happens before OpenVPN starts. Good
	practice therefore recommends creating a persistent virtual network
	interface, and configuring OpenVPN to use this pre-existing
	interface. This further allows choosing the name for this
	interface. To this end, <command>openvpn --mktun --dev vpn
	--dev-type tun</command> creates a virtual network interface named
	<literal>vpn</literal> with type <literal>tun</literal>; this
	command can easily be integrated in the firewall configuration
	script, or in an <literal>up</literal> directive of the
	<filename>/etc/network/interfaces</filename> file. The OpenVPN
	configuration file must also be updated accordingly, with the
	<literal>dev vpn</literal> and <literal>dev-type tun</literal>
	directives.</para>

	<para>Barring further action, VPN clients can only access the VPN
	server itself by way of the <literal>10.8.0.1</literal> address.
	Granting the clients access to the local network (192.168.0.0/24),
	requires adding a <literal>push route 192.168.0.0
	255.255.255.0</literal> directive to the OpenVPN configuration so
	that VPN clients automatically get a network route telling them
	that this network is reachable by way of the VPN. Furthermore,
	machines on the local network also need to be informed that the
	route to the VPN goes through the VPN server (this automatically
	works when the VPN server is installed on the gateway).
	Alternatively, the VPN server can be configured to perform IP
	masquerading so that connections coming from VPN clients appear as
	if they are coming from the VPN server instead (see <xref linkend="sect.gateway" />).</para>
      </section>
      <section>
        <title>Mengkonfigurasi Klien OpenVPN</title>

	<para>Setting up an OpenVPN client also requires creating a
	configuration file in <filename>/etc/openvpn/</filename>. A
	standard configuration can be obtained by using
	<filename>/usr/share/doc/openvpn/examples/sample-config-files/client.conf</filename>
	as a starting point. The <literal>remote vpn.falcot.com
	1194</literal> directive describes the address and port of the
	OpenVPN server; the <literal>ca</literal>, <literal>cert</literal>
	and <literal>key</literal> also need to be adapted to describe the
	locations of the key files.</para>

	<para>If the VPN should not be started automatically on boot, set
	the <literal>AUTOSTART</literal> directive to
	<literal>none</literal> in the
	<filename>/etc/default/openvpn</filename> file. Starting or
	stopping a given VPN connection is always possible with the
        commands <command>service openvpn@<replaceable>name</replaceable> start</command> and
        <command>service openvpn@<replaceable>name</replaceable> stop</command> (where the connection
	<replaceable>name</replaceable> matches the one defined in
	<filename>/etc/openvpn/<replaceable>name</replaceable>.conf</filename>).</para>

	<para>Paket <emphasis role="pkg">network-manager-openvpn-gnome</emphasis> berisi sebuah ekstensi untuk Network Manager (Lihat <xref linkend="sect.roaming-network-config" />) yang memungkinkan mengelola virtual private network OpenVPN. Hal ini memungkinkan setiap pengguna untuk mengkonfigurasi koneksi OpenVPN secara grafis dan untuk mengendalikan mereka dari ikon manajemen jaringan. <indexterm><primary><emphasis role="pkg">network-manager-openvpn-gnome</emphasis></primary></indexterm></para>
      </section>
    </section>
    <section id="sect.ssh-vpn">
      <title>Virtual Private Network dengan SSH</title>
      <indexterm><primary>SSH</primary></indexterm>
      <indexterm><primary>PPP</primary></indexterm>

      <para>There are actually two ways of creating a virtual private
      network with SSH. The historic one involves establishing a PPP layer
      over the SSH link. This method is described in a HOWTO document:
      <ulink type="block" url="http://www.tldp.org/HOWTO/ppp-ssh/" /></para>

      <para>The second method is more recent, and was introduced with
      OpenSSH 4.3; it is now possible for OpenSSH to create virtual
      network interfaces (<literal>tun*</literal>) on both sides of an SSH
      connection, and these virtual interfaces can be configured exactly as
      if they were physical interfaces. The tunneling system must first be
      enabled by setting <literal>PermitTunnel</literal> to “yes” in
      the SSH server configuration file
      (<filename>/etc/ssh/sshd_config</filename>). When establishing the
      SSH connection, the creation of a tunnel must be explicitly requested
      with the <literal>-w any:any</literal> option (<literal>any</literal>
      can be replaced with the desired <literal>tun</literal> device
      number). This requires the user to have administrator privilege on
      both sides, so as to be able to create the network device (in other
      words, the connection must be established as root).</para>

      <para>Kedua metode untuk membuat sebuah virtual private network melalui SSH cukup sederhana. Namun, VPN yang mereka sediakan bukan yang paling efisien; khususnya, ia tidak menangani lalu lintas tingkat tinggi dengan sangat baik.</para>

      <para>The explanation is that when a TCP/IP stack is encapsulated
      within a TCP/IP connection (for SSH), the TCP protocol is used twice,
      once for the SSH connection and once within the tunnel. This
      leads to problems, especially due to the way TCP adapts to network
      conditions by altering timeout delays. The following site describes
      the problem in more detail: <ulink type="block" url="http://sites.inka.de/sites/bigred/devel/tcp-tcp.html" /> VPNs
      over SSH should therefore be restricted to one-off tunnels with no
      performance constraints.</para>
    </section>
    <section id="sect.ipsec">
      <title>IPsec</title>
      <indexterm><primary>IPsec</primary></indexterm>
      <indexterm><primary><command>strongswan</command></primary></indexterm>
      <indexterm><primary><command>racoon</command></primary></indexterm>

      <para>IPsec, despite being the standard in IP VPNs, is rather more
      involved in its implementation. The IPsec engine itself is integrated
      in the Linux kernel; the required user-space parts, the control and
      configuration tools, are provided by the <emphasis role="pkg">ipsec-tools</emphasis> package. In concrete terms, each
      host's <filename>/etc/ipsec-tools.conf</filename> contains the
      parameters for <emphasis>IPsec tunnels</emphasis> (or
      <emphasis>Security Associations</emphasis>, in the IPsec terminology)
      that the host is concerned with;
      the <command>/etc/init.d/setkey</command> script provides a way to start
      and stop a tunnel (each tunnel is a secure link to another host
      connected to the virtual private network). This file can be built by
      hand from the documentation provided by the
      <citerefentry><refentrytitle>setkey</refentrytitle>
      <manvolnum>8</manvolnum></citerefentry> manual page. However,
      explicitly writing the parameters for all hosts in a non-trivial set
      of machines quickly becomes an arduous task, since the number of
      tunnels grows fast. Installing an IKE daemon (for <emphasis>IPsec Key
      Exchange</emphasis>) such as <emphasis role="pkg">racoon</emphasis> or
      <emphasis role="pkg">strongswan</emphasis> makes the process much simpler by
      bringing administration together at a central point, and more secure
      by rotating the keys periodically.
      </para>
      <indexterm><primary>IKE</primary></indexterm>
      <indexterm><primary>IPsec</primary><secondary>IPsec Key Exchange</secondary></indexterm>
      <indexterm><primary>pasangan kunci</primary></indexterm>
      <indexterm><primary><command>setkey</command></primary></indexterm>

      <para>Meskipun statusnya sebagai referensi, kompleksitas menyiapkan IPsec membatasi penggunaannya dalam praktek. Solusi berbasis OpenVPN umumnya akan lebih disukai bila diperlukan tunnel yang tidak terlalu banyak atau dinamis.</para>

      <sidebar>
        <title><emphasis>HATI-HATI</emphasis> IPsec dan NAT</title>

	<para>NATing firewalls and IPsec do not work well together: since
	IPsec signs the packets, any change on these packets that the
	firewall might perform will void the signature, and the packets
	will be rejected at their destination. Various IPsec
	implementations now include the <emphasis>NAT-T</emphasis>
	technique (for <emphasis>NAT Traversal</emphasis>), which basically
	encapsulates the IPsec packet within a standard UDP packet.</para>
        <indexterm><primary>NAT-T</primary></indexterm>
        <indexterm><primary>NAT Traversal</primary></indexterm>
      </sidebar>

      <sidebar>
        <title><emphasis>KEAMANAN</emphasis> IPsec dan firewall</title>

	<para>Mode standar pengoperasian IPsec melibatkan pertukaran data di UDP port 500 untuk pertukaran kunci (juga dalam port UDP 4500 dalam kasus digunakannya NAT-T). Selain itu, paket-paket IPsec menggunakan dua protokol IP terdedikasi yang mesti dibiarkan lewat oleh firewall; penerimaan paket ini didasarkan pada nomor protokol mereka, 50 (ESP) dan 51 (AH).</para>
        <indexterm><primary>ESP, protokol</primary></indexterm>
        <indexterm><primary>AH, protokol</primary></indexterm>
        <indexterm><primary>protokol</primary><secondary>AH</secondary></indexterm>
        <indexterm><primary>protokol</primary><secondary>ESP</secondary></indexterm>
      </sidebar>
    </section>
    <section id="sect.pptp">
      <title>PPTP</title>

      <para>PPTP (untuk <emphasis>Point-to-Point Tunneling Protocol</emphasis>) menggunakan dua saluran komunikasi, satu untuk data kontrol dan satu untuk data muatan; yang terakhir menggunakan protokol GRE (<emphasis>Generik Routing enkapsulasi</emphasis>). Link PPP standar kemudian disiapkan di atas kanal pertukaran data.</para>
      <indexterm><primary>PPTP</primary></indexterm>
      <indexterm><primary>Point-to-Point Tunneling Protocol</primary></indexterm>
      <indexterm><primary>GRE, protokol</primary></indexterm>
      <indexterm><primary>protokol</primary><secondary>GRE</secondary></indexterm>
      <section id="sect.pptp-config-client">
        <title>Mengkonfigurasi Klien</title>

	<para>Paket <emphasis role="pkg">pptp-linux</emphasis> berisi klien PPTP yang mudah dikonfigurasi untuk Linux. Instruksi berikut mengambil inspirasi dari dokumentasi resmi: <ulink type="block" url="http://pptpclient.sourceforge.net/howto-debian.phtml" /></para>
        <indexterm><primary><emphasis role="pkg">pptp-linux</emphasis></primary></indexterm>

	<para>Administrator Falcot membuat beberapa berkas: <filename>/etc/ppp/options.pptp</filename>, <filename>/etc/ppp/peers/falcot</filename>, <filename>/etc/ppp/ip-up.d/falcot</filename>, dan <filename>/etc/ppp/ip-down.d/falcot</filename>.</para>

        <example id="example.ppp-options.pptp">
          <title>Berkas <filename>/etc/ppp/options.pptp</filename></title>

          <programlisting>
# PPP options used for a PPTP connection
lock
noauth
nobsdcomp
nodeflate</programlisting>
        </example>

        <example id="example.ppp-peers-falcot">
          <title>Berkas <filename>/etc/ppp/peers/falcot</filename></title>

          <programlisting>
# vpn.falcot.com is the PPTP server
pty "pptp vpn.falcot.com --nolaunchpppd"
# the connection will identify as the "vpn" user
user vpn
remotename pptp
# encryption is needed
require-mppe-128
file /etc/ppp/options.pptp
ipparam falcot</programlisting>
        </example>

        <example id="example.ppp-ip-up.d-falcot">
          <title>Berkas <filename>/etc/ppp/ip-up.d/falcot</filename></title>

          <programlisting>
# Create the route to the Falcot network
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 is the (remote) Falcot network
  route add -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi</programlisting>
        </example>

        <example id="example.ppp-ip-down.d-falcot">
          <title>Berkas <filename>/etc/ppp/ip-down.d/falcot</filename></title>

          <programlisting>
# Delete the route to the Falcot network
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 is the (remote) Falcot network
  route del -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi</programlisting>
        </example>

        <sidebar>
          <title><emphasis>KEAMANAN</emphasis> MPPE</title>

	  <para>Mengamankan PPTP melibatkan penggunaan fitur MPPE (<emphasis>Microsoft Point-to-Point Encryption</emphasis>), yang tersedia di kernel Debian resmi sebagai modul.</para>
          <indexterm><primary>MPPE</primary></indexterm>
          <indexterm><primary>Microsoft</primary><secondary>Point-to-Point Encryption</secondary></indexterm>
        </sidebar>
      </section>
      <section id="sect.pptp-config-serveur">
        <title>Menata Server</title>

        <sidebar>
          <title><emphasis>HATI-HATI</emphasis> PPTP dan firewall</title>

	  <para>Firewall intermediate perlu dikonfigurasi untuk membiarkan paket IP menggunakan protokol 47 (GRE). Selain itu, port server PPTP 1723 harus terbuka sehingga saluran komunikasi dapat terjadi.</para>
        </sidebar>

	<para><command>pptpd</command> is the PPTP server for Linux. Its
	main configuration file, <filename>/etc/pptpd.conf</filename>,
	requires very few changes: <emphasis>localip</emphasis> (local IP
	address) and <emphasis>remoteip</emphasis> (remote IP address). In
	the example below, the PPTP server always uses the
	<literal>192.168.0.199</literal> address, and PPTP clients receive
	IP addresses from <literal>192.168.0.200</literal> to
	<literal>192.168.0.250</literal>.</para>

        <example id="example.pptpd.conf">
          <title>Berkas <filename>/etc/pptpd.conf</filename></title>

          <programlisting>
# TAG: speed
#
#       Specifies the speed for the PPP daemon to talk at.
#
speed 115200

# TAG: option
#
#       Specifies the location of the PPP options file.
#       By default PPP looks in '/etc/ppp/options'
#
option /etc/ppp/pptpd-options

# TAG: debug
#
#       Turns on (more) debugging to syslog
#
# debug

# TAG: localip
# TAG: remoteip
#
#       Specifies the local and remote IP address ranges.
#
#       You can specify single IP addresses separated by commas or you can
#       specify ranges, or both. For example:
#
#               192.168.0.234,192.168.0.245-249,192.168.0.254
#
#       IMPORTANT RESTRICTIONS:
#
#       1. No spaces are permitted between commas or within addresses.
#
#       2. If you give more IP addresses than MAX_CONNECTIONS, it will
#          start at the beginning of the list and go until it gets
#          MAX_CONNECTIONS IPs. Others will be ignored.
#
#       3. No shortcuts in ranges! ie. 234-8 does not mean 234 to 238,
#          you must type 234-238 if you mean this.
#
#       4. If you give a single localIP, that's ok - all local IPs will
#          be set to the given one. You MUST still give at least one remote
#          IP for each simultaneous client.
#
#localip 192.168.0.234-238,192.168.0.245
#remoteip 192.168.1.234-238,192.168.1.245
#localip 10.0.1.1
#remoteip 10.0.1.2-100
localip 192.168.0.199
remoteip 192.168.0.200-250</programlisting>
        </example>

	<para>Konfigurasi PPP yang digunakan oleh server PPTP juga memerlukan beberapa perubahan kecil di <filename>/etc/ppp/pptpd-options</filename>. Parameter penting adalah nama server (<literal>pptp</literal>), nama domain (<literal>falcot.com</literal>), dan alamat IP untuk server DNS dan WINS.</para>

        <example id="example.ppp-pptpd-options">
          <title>Berkas <filename>/etc/ppp/pptpd-options</filename></title>

          <programlisting>
## turn pppd syslog debugging on
#debug

## change 'servername' to whatever you specify as your server name in chap-secrets
name pptp
## change the domainname to your local domain
domain falcot.com

## these are reasonable defaults for WinXXXX clients
## for the security related settings
# The Debian pppd package now supports both MSCHAP and MPPE, so enable them
# here. Please note that the kernel support for MPPE must also be present!
auth
require-chap
require-mschap
require-mschap-v2
require-mppe-128

## Fill in your addresses
ms-dns 192.168.0.1
ms-wins 192.168.0.1

## Fill in your netmask
netmask 255.255.255.0

## some defaults
nodefaultroute
proxyarp
lock</programlisting>
        </example>

	<para>The last step involves registering the <literal>vpn</literal>
	user (and the associated password) in the
	<filename>/etc/ppp/chap-secrets</filename> file. Contrary to other
	instances where an asterisk (<literal>*</literal>) would work, the
	server name must be filled explicitly here. Furthermore, Windows
	PPTP clients identify themselves under the
	<literal><replaceable>DOMAIN</replaceable>\\<replaceable>USER</replaceable></literal>
	form, instead of only providing a user name. This explains why the
	file also mentions the <literal>FALCOT\\vpn</literal> user. It is
	also possible to specify individual IP addresses for users; an
	asterisk in this field specifies that dynamic addressing should be
	used.</para>

        <example id="example.ppp-chap-secrets">
          <title>Berkas <filename>/etc/ppp/chap-secrets</filename></title>

          <programlisting>
# Secrets for authentication using CHAP
# client        server  secret      IP addresses
vpn             pptp    f@Lc3au     *
FALCOT\\vpn     pptp    f@Lc3au     *</programlisting>
        </example>

        <sidebar>
          <title><emphasis>KEAMANAN</emphasis> Kerentanan PPTP</title>

	  <para>Implementasi PPTP pertama Microsoft mengundang kritik keras karena memiliki banyak kerentanan keamanan; sebagian besar sejak saat itu telah diperbaiki dalam versi yang lebih baru. Konfigurasi yang didokumentasikan di bagian ini menggunakan versi terbaru dari protokol. Sadarilah bahwa menghapus beberapa opsi (seperti <literal>require-mppe-128</literal> dan <literal>require-mschap-v2</literal>) akan membuat layanan rentan lagi.</para>
        </sidebar>
      </section>
    </section>
  </section>
  <section id="sect.quality-of-service">
    <title>Kualitas Layanan</title>
    <section id="sect.qos-principe">
      <title>Prinsip dan Mekanisme</title>

      <para><emphasis>Quality of Service</emphasis> (or
      <emphasis>QoS</emphasis> for short) refers to a set of techniques
      that guarantee or improve the quality of the service provided to
      applications. The most popular such technique involves classifying
      the network traffic into categories, and differentiating the handling
      of traffic according to which category it belongs to. The main
      application of this differentiated services concept is
      <emphasis>traffic shaping</emphasis>, which limits the data
      transmission rates for connections related to some services and/or
      hosts so as not to saturate the available bandwidth and starve
      important other services. Traffic shaping is a particularly good fit
      for TCP traffic, since this protocol automatically adapts to
      available bandwidth.</para>
      <indexterm><primary>QoS</primary></indexterm>
      <indexterm><primary>kualitas layanan</primary></indexterm>
      <indexterm><primary>kualitas</primary><secondary>layanan</secondary></indexterm>
      <indexterm><primary>layanan</primary><secondary>kualitas</secondary></indexterm>

      <para>Mungkin juga untuk mengubah prioritas pada lalu lintas, yang memungkinkan memprioritaskan paket-paket yang berhubungan dengan layanan interaktif (seperti <command>ssh</command> dan <command>telnet</command>) atau ke layanan yang hanya berhubungan dengan blok-block kecil data.</para>

      <para>Kernel Debian menyertakan fitur-fitur yang diperlukan untuk QoS bersama dengan modul-modul terkait. Modul ini banyak, dan masing-masing menyediakan layanan berbeda, terutama skeduler khusus untuk antrian paket IP; berbagai macam perilaku skeduler tersedia mencakup seluruh kemungkinan persyaratan.</para>

      <sidebar>
        <title><emphasis>KULTUR</emphasis> LARTC — <emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis></title>

	<para>HOWTO <emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis> adalah dokumen referensi yang mencakup segala hal yang perlu diketahui tentang kualitas layanan jaringan. <ulink type="block" url="http://www.lartc.org/howto/" /></para>
        <indexterm><primary>routing</primary><secondary>tingkat lanjut</secondary></indexterm>
        <indexterm><primary>trafik</primary><secondary>kontrol</secondary></indexterm>
        <indexterm><primary>kontrol lalu lintas</primary></indexterm>
      </sidebar>
    </section>
    <section id="sect.qos-config">
      <title>Mengkonfigurasi dan Mengimplementasi</title>

      <para>Parameter QoS ditetapkan melalui perintah <command>tc</command> (yang disediakan oleh paket <emphasis role="pkg">iproute</emphasis> ). Karena antarmukanya cukup kompleks, dianjurkan menggunakan alat-alat dengan tingkat lebih tinggi.</para>
      <indexterm><primary><emphasis>iproute</emphasis></primary></indexterm>
      <indexterm><primary><command>tc</command></primary></indexterm>
      <section id="sect.qos-wondershaper">
        <title>Mengurangi Latensi: <command>wondershaper</command></title>

	<para>Tujuan utama dari <command>wondershaper</command> (dalam paket yang bernama sama) adalah untuk meminimalkan latensi independen dari beban jaringan. Hal ini dicapai dengan membatasi total lalu lintas ke nilai yang sedikit kurang dari nilai saturasi link.</para>
        <indexterm><primary><command>wondershaper</command></primary></indexterm>
        <indexterm><primary>pembatasan lalu lintas</primary></indexterm>
        <indexterm><primary>trafik</primary><secondary>limitasi</secondary></indexterm>

	<para>Once a network interface is configured, setting up this
	traffic limitation is achieved by running <command>wondershaper
	<replaceable>interface</replaceable>
	<replaceable>download_rate</replaceable>
	<replaceable>upload_rate</replaceable></command>. The interface can
	be <literal>eth0</literal> or <literal>ppp0</literal> for example,
	and both rates are expressed in kilobits per second. The
	<command>wondershaper remove
	<replaceable>interface</replaceable></command> command disables
	traffic control on the specified interface.</para>

	<para>Untuk sambungan Ethernet, skrip ini terbaik dipanggil tepat setelah antar muka dikonfigurasi. Hal ini dilakukan dengan menambahkan arahan <literal>up</literal> dan <literal>down</literal> ke berkas <filename>/etc/network/interfaces</filename> yang memungkinkan perintah-perintah yang dideklarasikan dijalankan, masing-masing, setelah antar muka dikonfigurasi dan sebelum itu di-dekonfigurasi. Sebagai contoh:</para>

        <example id="example.network-interfaces">
          <title>Perubahan dalam berkas <filename>/etc/network/interfaces</filename></title>

          <programlisting>
iface eth0 inet dhcp
    up /sbin/wondershaper eth0 500 100
    down /sbin/wondershaper remove eth0</programlisting>
        </example>

	<para>Dalam kasus PPP, menciptakan sebuah skrip yang panggilan <command>wondershaper</command> di <filename>/etc/ppp/ip-up.d/</filename> akan memungkinkan kontrol lalu lintas segera setelah sambungan hidup.</para>

        <sidebar>
          <title><emphasis>LEBIH LANJUT</emphasis> Konfigurasi optimal</title>

	  <para>Berkas <filename>/Usr/share/doc/wondershaper/README.Debian.gz</filename> menjelaskan, secara agak rinci, metode konfigurasi yang direkomendasikan oleh pengelola paket. Secara khusus, itu menyarankan mengukur kecepatan unduh dan unggah untuk mengevaluasi secara terbaik batas nyata.</para>
        </sidebar>
      </section>
      <section id="sect.qos-config-standard">
        <title>Konfigurasi Standar</title>

	<para>Barring a specific QoS configuration, the Linux kernel uses
	the <literal>pfifo_fast</literal> queue scheduler, which provides a
	few interesting features by itself. The priority of each processed
	IP packet is based on the ToS field (<emphasis>Type of
	Service</emphasis>) of this packet; modifying this field is enough
	to take advantage of the scheduling features. There are five
	possible values:</para>
        <itemizedlist>
          <listitem>
	    <para>Normal-Service (0);</para>
          </listitem>
          <listitem>
	    <para>Minimize-Cost (2);</para>
          </listitem>
          <listitem>
	    <para>Maximize-Reliability (4);</para>
          </listitem>
          <listitem>
	    <para>Maximize-Throughput (8);</para>
          </listitem>
          <listitem>
	    <para>Minimize-Delay (16).</para>
          </listitem>
        </itemizedlist>
        <indexterm><primary>ToS</primary></indexterm>
        <indexterm><primary>Tipe Layanan</primary></indexterm>

	<para>The ToS field can be set by applications that generate IP
	packets, or modified on the fly by <emphasis>netfilter</emphasis>.
	The following rules are sufficient to increase responsiveness for a
	server's SSH service:</para>

        <programlisting role="scale">
iptables -t mangle -A PREROUTING -p tcp --sport ssh -j TOS --set-tos Minimize-Delay
iptables -t mangle -A PREROUTING -p tcp --dport ssh -j TOS --set-tos Minimize-Delay</programlisting>
      </section>
    </section>
  </section>
  <section id="sect.dynamic-routing">
    <title>Routing Dinamis</title>
    <indexterm><primary>routing</primary><secondary>dinamis</secondary></indexterm>
    <indexterm><primary><command>quagga</command></primary></indexterm>
    <indexterm><primary><command>zebra</command></primary></indexterm>

    <para>Alat referensi untuk routing dinamis saat ini <command>quagga</command>, dari paket yang dinamai serupa; dulu <command>zebra</command> sampai pengembangan yang terakhir berhenti. Namun, <command>quagga</command> mempertahankan nama-nama program untuk alasan kompatibilitas yang menjelaskan perintah <command>zebra</command> di bawah ini.</para>

    <sidebar>
      <title><emphasis>KEMBALI KE DASAR</emphasis> Ruting dinamis</title>

      <para>Routing dinamis memungkinkan router untuk menyesuaikan, secara real time, jalur yang digunakan untuk transmisi paket IP. Setiap protokol melibatkan metode sendiri dalam mendefinisikan rute (jalur terpendek, menggunakan rute yang diiklankan oleh teman sebaya, dan sebagainya).</para>

      <para>Di kernel Linux, rute menghubungkan perangkat jaringan ke satu set mesin yang dapat dihubungi melalui perangkat ini. Perintah <command>route</command> mendefinisikan rute baru dan menampilkan yang sudah ada.</para>
      <indexterm><primary><command>route</command></primary></indexterm>
    </sidebar>

    <para>Quagga is a set of daemons cooperating to define the routing
    tables to be used by the Linux kernel; each routing protocol (most
    notably BGP, OSPF and RIP) provides its own daemon. The
    <command>zebra</command> daemon collects information from other daemons
    and handles static routing tables accordingly. The other daemons are
    known as <command>bgpd</command>, <command>ospfd</command>,
    <command>ospf6d</command>, <command>ripd</command>, 
    <command>ripngd</command>, <command>isisd</command>, and
    <command>babeld</command>.</para>
    <indexterm><primary>OSPF</primary></indexterm>
    <indexterm><primary>BGP</primary></indexterm>
    <indexterm><primary>RIP</primary></indexterm>
    <indexterm><primary>IS-IS</primary></indexterm>
    <indexterm><primary>BABEL wireless mesh routing</primary></indexterm>
    <indexterm><primary><command>bgpd</command></primary></indexterm>
    <indexterm><primary><command>ospfd</command></primary></indexterm>
    <indexterm><primary><command>ospf6d</command></primary></indexterm>
    <indexterm><primary><command>ripd</command></primary></indexterm>
    <indexterm><primary><command>ripngd</command></primary></indexterm>
    <indexterm><primary><command>isisd</command></primary></indexterm>
    <indexterm><primary><command>babeld</command></primary></indexterm>

    <para>Daemon diaktifkan dengan mengedit berkas <filename>/etc/quagga/daemons</filename> dan menciptakan berkas konfigurasi yang sesuai di <filename>/etc/quagga/</filename>; berkas konfigurasi ini harus dinamai sama dengan daemonnya, dengan ekstensi <filename>.conf</filename> , dan dimiliki oleh pengguna <literal>quagga</literal> dan kelompok <literal>quaggavty</literal>, agar skrip <filename>/etc/init.d/quagga</filename> menjalankan daemon.</para>

    <para>Konfigurasi masing-masing daemon ini membutuhkan pengetahuan tentang protokol routing yang bersangkutan. Protokol-protokol ini tidak dapat dijelaskan secara rinci di sini, tetapi <emphasis role="pkg">quagga-doc</emphasis> memberikan penjelasan yang cukup dalam bentuk sebuah berkas <command>info</command>. Isi yang sama mungkin lebih mudah dibaca dalam bentuk HTML pada situs web Quagga:<ulink type="block" url="http://www.nongnu.org/quagga/docs/docs-info.html" /></para>

    <para>Selain itu, sintaks ini sangat dekat dengan konfigurasi antarmuka router standar, dan administrator jaringan akan beradaptasi dengan cepat ke <command>quagga</command>.</para>

    <sidebar>
      <title><emphasis>DALAM PRAKTEK</emphasis> OSPF, BGP, atau RIP?</title>

      <para>OSPF umumnya adalah protokol yang terbaik untuk digunakan untuk routing dinamis pada jaringan privat, tetapi BGP lebih umum untuk routing seluruh Internet. RIP agak kuno, dan hampir tidak digunakan lagi.</para>
    </sidebar>
  </section>
  <section id="sect.ipv6">
    <title>IPv6</title>

    <para>IPv6, successor to IPv4, is a new version of the IP protocol
    designed to fix its flaws, most notably the scarcity of available IP
    addresses. This protocol handles the network layer; its purpose is to
    provide a way to address machines, to convey data to their intended
    destination, and to handle data fragmentation if needed (in other
    words, to split packets into chunks with a size that depends on the
    network links to be used on the path and to reassemble the chunks in
    their proper order on arrival).</para>

    <para>Kernel Debian termasuk penanganan IPv6 di kernel inti (dengan pengecualian beberapa arsitektur yang mengkompilasinya sebagai module bernama <literal>ipv6</literal>). Perkakas dasar seperti <command>ping</command> dan <command>traceroute</command> memiliki yang setara untuk IPv6 di <command>ping6</command> dan <command>traceroute6</command>, masing-masing tersedia dalam paket-paket <emphasis role="pkg">iputils-ping</emphasis> dan <emphasis role="pkg">iputils-tracepath</emphasis> .</para>
    <indexterm><primary>IPv6</primary></indexterm>
    <indexterm><primary><emphasis role="pkg">iputils-ping</emphasis></primary></indexterm>
    <indexterm><primary><emphasis role="pkg">iputils-tracepath</emphasis></primary></indexterm>

    <para>Jaringan IPv6 dikonfigurasi secara mirip dengan IPv4, di <filename>/etc/network/interfaces</filename>. Tetapi jika Anda ingin jaringan yang akan tersedia secara global, Anda harus memastikan bahwa Anda memiliki router mampu-IPv6 yang meneruskan lalu lintas ke jaringan IPv6 global.</para>

    <example id="example.network-interfaces-ipv6">
      <title>Contoh konfigurasi IPv6</title>

      <programlisting>
iface eth0 inet6 static
    address 2001:db8:1234:5::1:1
    netmask 64
    # Disabling auto-configuration
    # autoconf 0
    # The router is auto-configured and has no fixed address
    # (accept_ra 1). If it had:
    # gateway 2001:db8:1234:5::1</programlisting>
    </example>

    <para>Subnet IPv6 biasanya memiliki netmask dari 64 bit. Ini berarti bahwa 2<superscript>64</superscript> alamat yang berbeda ada dalam subnet. Hal ini memungkinkan Stateless Address Autoconfiguration (<acronym>SLAAC</acronym>) untuk memilih alamat berdasarkan alamat MAC antarmuka jaringan. Secara default, jika <acronym>SLAAC</acronym> diaktifkan dalam jaringan dan IPv6 di komputer Anda, kernel akan otomatis menemukan router IPv6 dan mengkonfigurasi antarmuka jaringan.</para>

    <para>This behavior may have privacy implications. If you switch
    networks frequently, e.g. with a laptop, you might not want your
    <acronym>MAC</acronym> address being a part of your public IPv6
    address. This makes it easy to identify the same device across
    networks. A solution to this are IPv6 privacy extensions (which Debian
    enables by default if IPv6 connectivity is detected during initial
    installation), which will assign an additional randomly generated
    address to the interface,
    periodically change them and prefer them for outgoing connections.
    Incoming connections can still use the address generated by SLAAC.
    The following example, for use in
    <filename>/etc/network/interfaces</filename>, activates these
    privacy extensions.</para>

    <example id="example.network-interface-ipv6-privext">
      <title>Ekstensi privasi IPv6</title>

      <programlisting>
iface eth0 inet6 auto
    # Prefer the randomly assigned addresses for outgoing connections.
    privext 2</programlisting>
    </example>

    <sidebar>
      <title><emphasis>TIP</emphasis> Program-program yang dibangun dengan IPv6</title>

      <para>Banyak potongan perangkat lunak yang perlu disesuaikan untuk menangani IPv6. Sebagian besar paket Debian telah usai disesuaikan, tetapi tidak semua. Jika paket favorit Anda belum bekerja dengan IPv6, Anda dapat meminta bantuan pada milis <emphasis>debian-ipv6</emphasis>. Mereka mungkin tahu tentang pengganti yang IPv6-aware dan dapat melaporkan bug agar masalah dilacak dengan benar. <ulink type="block" url="http://lists.debian.org/debian-ipv6/" /></para>
    </sidebar>

    <indexterm><primary>firewall IPv6</primary></indexterm>
    <indexterm><primary>firewall</primary><secondary>IPv6</secondary></indexterm>
    <indexterm><primary><command>ip6tables</command></primary></indexterm>
    <para>Koneksi IPv6 dapat dibatasi, dalam cara yang sama untuk IPv4: kernel Debian standar termasuk sebuah adaptasi dari <emphasis>netfilter</emphasis> untuk IPv6. <emphasis>netfilter</emphasis> yang mendukung IPv6 ini dikonfigurasi dengan cara yang serupa untuk mitra IPv4-nya, kecuali program yang dipakai adalah <command>ip6tables</command> bukan <command>iptables</command>.</para>

    <section id="sect.ipv6-tunneling">
      <title>Tunneling</title>

      <sidebar>
        <title><emphasis>HATI-HATI</emphasis> tunnel dan firewall IPv6</title>

        <para>Tunneling IPv6 di IPv4 (alih-alih IPv6 native) memerlukan firewall untuk menerima lalu lintas, yang menggunakan protokol IPv4 nomor 41.</para>
      </sidebar>

      <para>Jika koneksi IPv6 yang native tidak tersedia, metode alternatif adalah dengan menggunakan sebuah tunnel di atas IPv4. Gogo6 adalah salah satu penyedia (gratis) tunnel tersebut: <ulink type="block" url="http://www.gogo6.com/freenet6/tunnelbroker" /></para>
      <indexterm><primary>Freenet6</primary></indexterm>
      <indexterm><primary>Gogo6</primary></indexterm>

      <para>To use a Freenet6 tunnel, you need to register for a Freenet6
      Pro account on the website, then install the <emphasis role="pkg">gogoc</emphasis> package and configure the tunnel. This
      requires editing the <filename>/etc/gogoc/gogoc.conf</filename>
      file: <literal>userid</literal> and <literal>password</literal>
      lines received by e-mail should be added, and
      <literal>server</literal> should be replaced with
      <literal>authenticated.freenet6.net</literal>.</para>

      <para>Konektivitas IPv6 diusulkan untuk semua mesin di jaringan lokal dengan menambahkan tiga arahan berikut ke berkas <filename>/etc/gogoc/gogoc.conf</filename> (dengan asumsi jaringan lokal terhubung ke antarmuka eth0):</para>

      <programlisting>
host_type=router
prefixlen=56
if_prefix=eth0</programlisting>

      <para>Mesin ini kemudian menjadi akses router untuk subnet dengan prefiks 56-bit. Setelah tunnel menyadari perubahan ini, jaringan lokal harus diberitahu tentang hal itu; ini berarti memasang daemon <command>radvd</command> (dari paket yang bernama sama). Daemon konfigurasi IPv6 ini memiliki peran mirip <command>dhcpd</command> di dunia IPv4.</para>

      <para>Berkas konfigurasi <filename>/etc/radvd.conf</filename> harus kemudian dibuat (Lihat <filename>/usr/share/doc/radvd/examples/simple-radvd.conf</filename> sebagai titik awal). Dalam kasus kami, satu-satunya perubahan yang diperlukan adalah awalan, yang perlu diganti dengan yang disediakan oleh Freenet6; hal ini dapat ditemukan dalam keluaran perintah <command>ifconfig</command>, di blok mengenai antarmuka <literal>tun</literal> .</para>
      <indexterm><primary><command>radvd</command></primary></indexterm>

      <para>Then run <command>service gogoc restart</command> and
      <command>service radvd start</command>, and the IPv6 network should
      work.</para>
    </section>

  </section>
  <section id="sect.domain-name-servers">
    <title>Domain Name Servers (DNS)</title>
    <section id="sect.dns-principe">
      <title>Prinsip dan Mekanisme</title>
      <indexterm><primary>DNS</primary></indexterm>
      <indexterm><primary>server</primary><secondary>nama</secondary></indexterm>

      <para><emphasis>Layanan Nama Domain</emphasis> (Domain Name Service, DNS) adalah komponen fundamental dari Internet: itu memetakan nama host ke alamat IP (dan sebaliknya), yang memungkinkan penggunaan <literal>www.debian.org</literal> daripada <literal>5.153.231.4</literal> atau <literal>2001:41c8:1000:21::21:4</literal>.</para>

      <para>Record-record DNS disusun dalam zona; setiap zona cocok dengan suatu domain (atau subdomain) atau suatu rentang alamat IP (karena alamat IP umumnya dialokasikan dalam rentang berturutan). Sebuah server adalah otoritatif atas isi suatu zona; server sekunder, sering diwadahi pada mesin terpisah, menyediakan salinan zona utama yang diperbarui secara teratur.</para>
      <indexterm><primary>zona</primary><secondary>DNS</secondary></indexterm>
      <indexterm><primary>DNS</primary><secondary>zone</secondary></indexterm>

      <para>Setiap zona dapat berisi record dari berbagai jenis (<emphasis>Record Sumber Daya</emphasis>):</para>
      <itemizedlist>
        <listitem>
	  <para><literal>A</literal>: Alamat IPv4. <indexterm><primary>A, record DNS </primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>CNAME</literal>: alias (<emphasis>nama kanonis</emphasis>). <indexterm><primary>CNAME, record DNS</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>MX</literal>: <emphasis>pertukaran surat</emphasis>, server surel. Informasi ini digunakan oleh server surel lain untuk menemukan tempat mengirim surel yang ditujukan ke alamat yang diberikan. Setiap data MX memiliki prioritas. Server prioritas tertinggi (dengan angka terendah) dicoba terlebih dahulu (lihat bilah sisi <xref linkend="sidebar.smtp" /> ); server lain dihubungi dalam prioritas menurun jika yang pertama tidak membalas. <indexterm><primary>MX</primary><secondary>record DNS</secondary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>PTR</literal>: pemetaan alamat IP ke suatu nama. Record semacam itu disimpan dalam zona "reverse DNS" yang diberi nama sesuai dengan rentang alamat IP. Sebagai contoh, <literal>1.168.192.in-addr.arpa</literal> adalah zona yang berisi pemetaan balik untuk semua alamat di rentang <literal>192.168.1.0/24</literal>. <indexterm><primary>PTR, record DNS</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>AAAA</literal>: Alamat IPv6. <indexterm><primary>AAAA, record DNS</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>NS</literal>: maps a name to a name server. Each
	  domain must have at least one NS record. These records point at a
	  DNS server that can answer queries concerning this domain; they
	  usually point at the primary and secondary servers for the
	  domain. These records also allow DNS delegation; for instance,
	  the <literal>falcot.com</literal> zone can include an NS record
	  for <literal>internal.falcot.com</literal>, which means that the
	  <literal>internal.falcot.com</literal> zone is handled by another
	  server. Of course, this server must declare an
	  <literal>internal.falcot.com</literal> zone.
	  <indexterm><primary>NS, DNS record</primary></indexterm></para>
        </listitem>
      </itemizedlist>
      
      <indexterm><primary>record</primary><secondary>DNS</secondary></indexterm>
      <indexterm><primary>Record DNS</primary></indexterm>

      <para>Server nama referensi, Bind, dikembangkan dan dikelola oleh ISC (<emphasis>Internet Software Consortium</emphasis>). Disediakan di Debian oleh paket <emphasis role="pkg">bind9</emphasis>. Versi 9 membawa dua perubahan besar dibandingkan dengan versi sebelumnya. Pertama, server DNS sekarang dapat dijalankan di bawah pengguna tanpa hak khusus, sehingga kerentanan keamanan di server tidak memberikan hak akses root ke penyerang (seperti yang terlihat berkali-kali dengan versi 8.x).</para>

      <para>Selain itu, Bind mendukung standar DNSSEC untuk penandatanganan (dan karena itu otentikasi) record DNS, yang memungkinkan memblokir setiap spoofing data ini selama serangan man-in-the-middle.</para>
      <indexterm><primary><emphasis role="pkg">bind9</emphasis></primary></indexterm>
      <indexterm><primary>ISC</primary></indexterm>
      <indexterm><primary>Internet Software Consortium</primary></indexterm>

      <sidebar>
        <title><emphasis>KULTUR</emphasis> DNSSEC</title>
        <indexterm><primary>DNSSEC</primary></indexterm>

	<para>Norma DNSSEC cukup kompleks; ini menjelaskan sebagian mengapa DNSSEC belum digunakan secara luas (bahkan jika itu secara sempurna berdampingan dengan dengan server DNS yang tidak sadar-DNSSEC). Untuk memahami semua seluk-beluknya, Anda harus memeriksa artikel berikut. <ulink type="block" url="http://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions" />&gt;</para>
      </sidebar>
    </section>
    <section id="sect.dns-config">
      <title>Mengkonfigurasi</title>

      <para>Berkas konfigurasi untuk <command>bind</command>, terlepas dari versi, memiliki struktur yang sama.</para>

      <para>Para administrator Falcot menciptakan sebuah zona utama <literal>falcot.com</literal> untuk menyimpan informasi yang terkait dengan domain ini, dan zona <literal>168.192.in-addr.arpa</literal> untuk pemetaan balik alamat IP pada jaringan lokal.</para>

      <sidebar>
        <title><emphasis>HATI-HATI</emphasis> Nama-nama zone reverse</title>
        <indexterm><primary>zona</primary><secondary>reverse</secondary></indexterm>
        <indexterm><primary>reverse zone</primary></indexterm>
        <indexterm><primary><literal>in-addr.arpa</literal></primary></indexterm>
        <indexterm><primary><literal>ip6.arpa</literal></primary></indexterm>
	<indexterm><primary>format nibble</primary></indexterm>

	<para>Zona reverse memiliki nama khusus. Zona yang meliputi jaringan <literal>192.168.0.0/16</literal> perlu diberi nama <literal>168.192.in-addr.arpa</literal>: komponen alamat IP dibalik, dan diikuti oleh akhiran <literal>in-addr.arpa</literal>.</para>

	<para>Untuk jaringan IPv6, akhiran adalah <literal>ip6.arpa</literal> dan komponen alamat IP yang dibalik adalah setiap karakter pada perwakilan penuh heksadesimal alamat IP. Dengan demikian, jaringan <literal>2001:0bc8:31a0::/48</literal> akan menggunakan zona yang bernama <literal>0.a.1.3.8.c.b.0.1.0.0.2.ip6.arpa</literal>.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>TIP</emphasis> Pengujian DNS server</title>

	<para>Perintah <command>host</command> (dalam paket <emphasis role="pkg">bind9-host</emphasis>) mengkueri server DNS, dan dapat digunakan untuk menguji konfigurasi server. Sebagai contoh, <command>host machine.falcot.com localhost</command> memeriksa balasan server lokal untuk permintaan <literal>machine.falcot.com</literal>. <command>host <replaceable>alamatip</replaceable> localhost</command> menguji resolusi terbalik.</para>
	<indexterm><primary><command>host</command></primary></indexterm>
      </sidebar>

      <para>Kutipan-kutipan konfigurasi berikut, diambil dari berkas Falcot, dapat berfungsi sebagai titik awal untuk mengkonfigurasi sebuah server DNS:</para>
      <indexterm><primary><filename>named.conf</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/bind/named.conf</filename></primary></indexterm>

      <example id="example.bind-named.conf.local">
        <title>Kutipan dari <filename>/etc/bind/named.conf.local</filename></title>

        <programlisting>
zone "falcot.com" {
        type master;
        file "/etc/bind/db.falcot.com";
        allow-query { any; };
        allow-transfer {
                195.20.105.149/32 ; // ns0.xname.org
                193.23.158.13/32 ; // ns1.xname.org
        };
};

zone "internal.falcot.com" {
        type master;
        file "/etc/bind/db.internal.falcot.com";
        allow-query { 192.168.0.0/16; };
};

zone "168.192.in-addr.arpa" {
        type master;
        file "/etc/bind/db.192.168";
        allow-query { 192.168.0.0/16; };
};</programlisting>
      </example>

      <example id="example.bind-db.falcot.com">
        <title>Kutipan dari <filename>/etc/bind/db.falcot.com</filename></title>

        <programlisting>; falcot.com Zone 
; admin.falcot.com. =&gt; zone contact: admin@falcot.com
$TTL    604800
@       IN      SOA     falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
;
; The @ refers to the zone name ("falcot.com" here)
; or to $ORIGIN if that directive has been used
;
@       IN      NS      ns
@       IN      NS      ns0.xname.org.

internal IN      NS      192.168.0.2

@       IN      A       212.94.201.10
@       IN      MX      5 mail
@       IN      MX      10 mail2

ns      IN      A       212.94.201.10
mail    IN      A       212.94.201.10
mail2   IN      A       212.94.201.11
www     IN      A       212.94.201.11

dns     IN      CNAME   ns</programlisting>
      </example>

      <sidebar>
        <title><emphasis>HATI-HATI</emphasis> Sintaks nama</title>

	<para>The syntax of machine names follows strict rules. For
	instance, <literal>machine</literal> implies
	<literal>machine.<replaceable>domain</replaceable></literal>. If
	the domain name should not be appended to a name, said name must be
	written as <literal>machine.</literal> (with a dot as suffix).
	Indicating a DNS name outside the current domain therefore requires
	a syntax such as <literal>machine.otherdomain.com.</literal> (with
	the final dot).</para>
      </sidebar>

      <example id="example.bind-db.192.168">
        <title>Kutipan dari <filename> /etc/bind/db.192.168 </filename></title>

        <programlisting>; Reverse zone for 192.168.0.0/16
; admin.falcot.com. =&gt; zone contact: admin@falcot.com
$TTL    604800
@       IN      SOA     ns.internal.falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL

        IN      NS      ns.internal.falcot.com.

; 192.168.0.1 -&gt; arrakis
1.0     IN      PTR     arrakis.internal.falcot.com.
; 192.168.0.2 -&gt; neptune
2.0     IN      PTR     neptune.internal.falcot.com.

; 192.168.3.1 -&gt; pau
1.3     IN      PTR     pau.internal.falcot.com.</programlisting>
      </example>
    </section>
  </section>
  <section id="sect.dhcp">
    <title>DHCP</title>

    <para>DHCP (untuk <emphasis>Dynamic Host Configuration Protocol</emphasis>) adalah protokol yang dengannya suatu mesin dapat secara otomatis mendapatkan konfigurasi jaringannya ketika boot. Ini memungkinkan sentralisasi manajemen konfigurasi jaringan, dan memastikan bahwa semua mesin desktop mendapatkan pengaturan yang serupa.</para>
    <indexterm><primary>DHCP</primary></indexterm>
    <indexterm><primary>Dynamic Host Configuration Protocol</primary></indexterm>
    <indexterm><primary>jaringan</primary><secondary>konfigurasi DHCP</secondary></indexterm>

    <para>Sebuah server DHCP menyediakan banyak parameter terkait jaringan. Yang paling umum adalah alamat IP dan mesin masuk jaringan mana, tetapi juga bisa menyediakan informasi lainnya, seperti server DNS, server WINS, server NTP, dan sebagainya.</para>

    <para>Internet Software Consortium (juga terlibat dalam mengembangkan <command>bind</command>) adalah penulis utama dari server DHCP. Paket Debian yang cocok adalah <emphasis role="pkg">isc-dhcp-server</emphasis>.</para>

    <section id="sect.dhcp-config">
      <title>Mengkonfigurasi</title>

      <para>The first elements that need to be edited in the DHCP server
      configuration file (<filename>/etc/dhcp/dhcpd.conf</filename>) are
      the domain name and the DNS servers. If this server is alone on the
      local network (as defined by the broadcast propagation), the
      <literal>authoritative</literal> directive must also be enabled (or
      uncommented). One also needs to create a <literal>subnet</literal>
      section describing the local network and the configuration
      information to be provided. The following example fits a
      <literal>192.168.0.0/24</literal> local network with a router at
      <literal>192.168.0.1</literal> serving as the gateway. Available IP
      addresses are in the range <literal>192.168.0.128</literal> to
      <literal>192.168.0.254</literal>.</para>

      <example id="example.dhcp-dhcpd.conf">
        <title>Kutipan dari <filename>/etc/dhcp/dhcpd.conf</filename></title>

        <programlisting>
#
# Sample configuration file for ISC dhcpd for Debian
#

# The ddns-updates-style parameter controls whether or not the server will
# attempt to do a DNS update when a lease is confirmed. We default to the
# behavior of the version 2 packages ('none', since DHCP v2 didn't
# have support for DDNS.)
ddns-update-style interim;

# option definitions common to all supported networks...
option domain-name "internal.falcot.com";
option domain-name-servers ns.internal.falcot.com;

default-lease-time 600;
max-lease-time 7200;

# If this DHCP server is the official DHCP server for the local
# network, the authoritative directive should be uncommented.
authoritative;

# Use this to send dhcp log messages to a different log file (you also
# have to hack syslog.conf to complete the redirection).
log-facility local7;

# My subnet
subnet 192.168.0.0 netmask 255.255.255.0 {
    option routers 192.168.0.1;
    option broadcast-address 192.168.0.255;
    range 192.168.0.128 192.168.0.254;
    ddns-domainname "internal.falcot.com";
}</programlisting>
      </example>
    </section>
    <section id="sect.dhcp-dns">
      <title>DHCP dan DNS</title>
      <indexterm><primary>DNS</primary><secondary>pembaruan otomatis</secondary></indexterm>

      <para>Fitur bagus adalah pendaftaran otomatis klien DHCP di zona DNS, sehingga setiap mesin mendapat nama yang signifikan (daripada sesuatu yang impersonal seperti <literal>mesin-192-168-0-131.internal.falcot.com</literal>). Menggunakan fitur ini memerlukan konfigurasi server DNS untuk menerima update bagi zona DNS <literal>internal.falcot.com</literal> dari server DHCP, dan mengkonfigurasi yang terakhir untuk mengirimkan pambaruan bagi setiap pendaftaran.</para>

      <para>Dalam kasus <command>bind</command>, direktif <literal>allow-update</literal> perlu ditambahkan ke masing-masing zona yang akan disuting oleh server DHCP server (satu untuk domain <literal>internal.falcot.com</literal>, dan zona balik). Direktif ini memuat daftar alamat IP yang diizinkan untuk melakukan pembaruan ini; oleh karena itu harus mengandung alamat-alamat server DHCP yang mungkin (alamat lokal dan alamat publik, jika sesuai).</para>

      <programlisting>
allow-update { 127.0.0.1 192.168.0.1 212.94.201.10 !any };</programlisting>

      <para>Berhati-hatilah! Zona yang dapat diubah <emphasis>akan</emphasis> diganti oleh <command>bind</command>, dan yang kedua akan menimpa berkas-berkas konfigurasi secara berkala. Karena prosedur ini otomatis menghasilkan berkas yang kurang terbaca-manusia daripada ditulis secara manual, para administrator Falcot menangani domain <literal>internal.falcot.com</literal> dengan server DNS yang didelegasikan; ini berarti berkas zona <literal>falcot.com</literal> tetap tegas di bawah kontrol manual mereka.</para>

      <para>Kutipan konfigurasi server DHCP di atas sudah termasuk petunjuk yang diperlukan untuk pembaruan zona DNS: mereka adalah baris <literal>ddns-update-style interim;</literal> dan <literal>ddns-domain-name "internal.falcot.com";</literal> di blok yang menggambarkan subnet.</para>
    </section>
  </section>
  <section id="sect.network-diagnosis-tools">
    <title>Alat Diagnosis Jaringan</title>

    <para>When a network application does not run as expected, it is
    important to be able to look under the hood. Even when everything seems
    to run smoothly, running a network diagnosis can help ensure everything
    is working as it should. Several diagnosis tools exists for this
    purpose; each one operates on a different level.</para>
    <section id="sect.netstat">
      <title>Diagnosis Lokal: <command>netstat</command></title>
      <indexterm><primary><command>netstat</command></primary></indexterm>

      <para>Let's first mention the <command>netstat</command> command (in
      the <emphasis role="pkg">net-tools</emphasis> package); it displays
      an instant summary of a machine's network activity. When invoked with
      no argument, this command lists all open connections; this list can
      be very verbose since it includes many Unix-domain sockets (widely
      used by daemons) which do not involve the network at all (for
      example, <literal>dbus</literal> communication,
      <literal>X11</literal> traffic, and communications between virtual
      filesystems and the desktop).</para>

      <para>Invokasi yang umum karena itu menggunakan pilihan yang mengubah perilaku <command>netstat</command>. Pilihan yang paling sering digunakan antara lain:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>-t</literal>, yang menyaring hasil untuk hanya menyertakan koneksi TCP;</para>
        </listitem>
        <listitem>
	  <para><literal>-u</literal>, yang bekerja secara serupa untuk koneksi UDP; pilihan ini tidak saling eksklusif, dan salah satunya cukup untuk menghentikan menampilkan hubungan Unix-domain;</para>
        </listitem>
        <listitem>
	  <para><literal>-</literal>, juga menampilkan daftar soket yang mendengar (menunggu untuk koneksi masuk);</para>
        </listitem>
        <listitem>
	  <para><literal>-n</literal>, untuk menampilkan hasil secara numerik: alamat IP (tanpa resolusi DNS), nomor port (bukan alias sebagaimana didefinisikan dalam <filename>/etc/services</filename>) dan id pengguna (tidak ada nama login);</para>
        </listitem>
        <listitem>
	  <para><literal>-p</literal>, untuk daftar proses yang terlibat; pilihan ini hanya berguna ketika <command>netstat</command> dijalankan sebagai root, karena pengguna normal hanya akan melihat proses mereka sendiri;</para>
        </listitem>
        <listitem>
	  <para><literal>-c</literal>, untuk terus-menerus menyegarkan daftar koneksi.</para>
        </listitem>
      </itemizedlist>

      <para>Pilihan lain, didokumentasikan dalam halaman manual <citerefentry> <refentrytitle>netstat</refentrytitle> <manvolnum>8</manvolnum> </citerefentry>, menyediakan kontrol yang bahkan lebih halus atas hasil yang ditampilkan. Dalam prakteknya, lima pilihan pertama begitu sering digunakan bersama bahwa sistem dan administrator jaringan praktis mengakuisisi <command>netstat -tupan</command> sebagai refleks. Hasil yang khas, pada mesin bermuatan ringan, mungkin terlihat seperti berikut:</para>

      <screen role="scale">
<computeroutput># </computeroutput><userinput>netstat -tupan</userinput>
<computeroutput>Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      397/rpcbind     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      431/sshd        
tcp        0      0 0.0.0.0:36568           0.0.0.0:*               LISTEN      407/rpc.statd   
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      762/exim4       
tcp        0    272 192.168.1.242:22        192.168.1.129:44452     ESTABLISHED 1172/sshd: roland [
tcp6       0      0 :::111                  :::*                    LISTEN      397/rpcbind     
tcp6       0      0 :::22                   :::*                    LISTEN      431/sshd        
tcp6       0      0 ::1:25                  :::*                    LISTEN      762/exim4       
tcp6       0      0 :::35210                :::*                    LISTEN      407/rpc.statd   
udp        0      0 0.0.0.0:39376           0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:996             0.0.0.0:*                           397/rpcbind     
udp        0      0 127.0.0.1:1007          0.0.0.0:*                           407/rpc.statd   
udp        0      0 0.0.0.0:68              0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:48720           0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:111             0.0.0.0:*                           397/rpcbind     
udp        0      0 192.168.1.242:123       0.0.0.0:*                           539/ntpd        
udp        0      0 127.0.0.1:123           0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:123             0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:5353            0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:39172           0.0.0.0:*                           407/rpc.statd   
udp6       0      0 :::996                  :::*                                397/rpcbind     
udp6       0      0 :::34277                :::*                                407/rpc.statd   
udp6       0      0 :::54852                :::*                                916/dhclient    
udp6       0      0 :::111                  :::*                                397/rpcbind     
udp6       0      0 :::38007                :::*                                451/avahi-daemon: r
udp6       0      0 fe80::5054:ff:fe99::123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:a:123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:5:123 :::*                                539/ntpd        
udp6       0      0 ::1:123                 :::*                                539/ntpd        
udp6       0      0 :::123                  :::*                                539/ntpd        
udp6       0      0 :::5353                 :::*                                451/avahi-daemon: r
</computeroutput></screen>

      <para>Seperti yang diharapkan, daftar ini menampilkan koneksi yang terjalin, dua koneksi SSH dalam kasus ini, dan aplikasi yang menunggu koneksi masuk (terdaftar sebagai <literal>LISTEN</literal>), terutama server surel Exim4 yang mendengarkan di port 25.</para>
    </section>
    <section id="sect.nmap">
      <title>Diagnosis Jarak Jauh: <command>nmap</command></title>
      <indexterm><primary><command>nmap</command></primary></indexterm>

      <para><command>nmap</command> (in the similarly-named package) is, in
      a way, the remote equivalent for <command>netstat</command>. It can
      scan a set of “well-known” ports for one or several remote
      servers, and list the ports where an application is found to answer
      to incoming connections. Furthermore, <command>nmap</command> is able
      to identify some of these applications, sometimes even their version
      number. The counterpart of this tool is that, since it runs remotely,
      it cannot provide information on processes or users; however, it can
      operate on several targets at once.</para>

      <para>Pemanggilan tipikal <command>nmap</command> hanya menggunakan pilihan <literal>-A</literal> (sehingga <command>nmap</command> mencoba mengidentifikasi versi perangkat lunak server yang ditemukannya) diikuti oleh satu atau lebih alamat IP atau nama DNS mesin yang akan dipindai. Sekali lagi, lebih banyak opsi yang ada untuk mengendalikan perilaku <command>nmap</command>; silakan lihat dokumentasi di halaman manual <citerefentry><refentrytitle>nmap</refentrytitle><manvolnum>1</manvolnum></citerefentry>.</para>

      <screen role="scale" width="80">
<computeroutput># </computeroutput><userinput>nmap mirtuel</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET
Nmap scan report for mirtuel (192.168.1.242)
Host is up (0.000013s latency).
rDNS record for 192.168.1.242: mirtuel.internal.placard.fr.eu.org
Not shown: 998 closed ports
PORT    STATE SERVICE
22/tcp  open  ssh
111/tcp open  rpcbind

Nmap done: 1 IP address (1 host up) scanned in 2.41 seconds
# </computeroutput><userinput>nmap -A localhost</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000013s latency).
Other addresses for localhost (not scanned): 127.0.0.1
Not shown: 997 closed ports
PORT    STATE SERVICE VERSION
22/tcp  open  ssh     OpenSSH 6.7p1 Debian 3 (protocol 2.0)
|_ssh-hostkey: ERROR: Script execution failed (use -d to debug)
25/tcp  open  smtp    Exim smtpd 4.84
| smtp-commands: mirtuel Hello localhost [127.0.0.1], SIZE 52428800, 8BITMIME, PIPELINING, HELP, 
|_ Commands supported: AUTH HELO EHLO MAIL RCPT DATA NOOP QUIT RSET HELP 
111/tcp open  rpcbind 2-4 (RPC #100000)
| rpcinfo: 
|   program version   port/proto  service
|   100000  2,3,4        111/tcp  rpcbind
|   100000  2,3,4        111/udp  rpcbind
|   100024  1          36568/tcp  status
|_  100024  1          39172/udp  status
Device type: general purpose
Running: Linux 3.X
OS CPE: cpe:/o:linux:linux_kernel:3
OS details: Linux 3.7 - 3.15
Network Distance: 0 hops
Service Info: Host: mirtuel; OS: Linux; CPE: cpe:/o:linux:linux_kernel

OS and Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 11.54 seconds
</computeroutput></screen>

      <para>Seperti yang diharapkan, aplikasi SSH dan Exim4 tercantum. Perhatikan bahwa tidak semua aplikasi mendengarkan pada semua alamat IP; karena Exim4 ini hanya dapat diakses pada antarmuka loopback <literal>lo</literal>, itu hanya muncul selama analisis <literal>localhost</literal> dan tidak ketika pemindaian <literal>mirtuel</literal> (yang terpetakan ke antarmuka <literal>eth0</literal> di mesin yang sama).</para>
    </section>
    <section id="sect.sniffers">
      <title>Sniffer: <command>tcpdump</command> dan <command>wireshark</command></title>

      <para>Kadang-kadang, orang perlu untuk melihat apa yang sebenarnya terjadi pada kabel, paket per paket. Kasus ini panggilan untuk “penganalsis frame”, lebih dikenal sebagai <emphasis>niffer</emphasis>. Suatu alat yang mengamati semua paket yang mencapai antarmuka jaringan tertentu, dan menampilkan mereka dalam cara yang ramah pengguna.</para>
      <indexterm><primary><command>tcpdump</command></primary></indexterm>

      <para>The venerable tool in this domain is
      <command>tcpdump</command>, available as a standard tool on a wide
      range of platforms. It allows many kinds of network traffic capture,
      but the representation of this traffic stays rather obscure. We will
      therefore not describe it in further detail.</para>
      <indexterm><primary><command>wireshark</command></primary></indexterm>

      <para>A more recent (and more modern) tool,
      <command>wireshark</command> (in the <emphasis role="pkg">wireshark</emphasis> package), has become the new
      reference in network traffic analysis due to its many decoding
      modules that allow for a simplified analysis of the captured packets.
      The packets are displayed graphically with an organization based on
      the protocol layers. This allows a user to visualize all protocols
      involved in a packet. For example, given a packet containing an HTTP
      request, <command>wireshark</command> displays, separately, the
      information concerning the physical layer, the Ethernet layer, the IP
      packet information, the TCP connection parameters, and finally the
      HTTP request itself.</para>

      <figure id="figure.wireshark">
        <title>The <command>wireshark</command> network traffic analyzer</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/wireshark.png" scalefit="1" width="75%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>In our example, the packets traveling over SSH are filtered
      out (with the <literal>!tcp.port == 22</literal> filter). The packet
      currently displayed was developed at the HTTP layer.</para>

      <sidebar>
        <title><emphasis>TIP</emphasis> <command>wireshark</command> tanpa antar muka grafis: <command>tshark</command></title>
        <indexterm><primary><command>tshark</command></primary></indexterm>

	<para>When one cannot run a graphical interface, or does not wish
	to do so for whatever reason, a text-only version of
	<command>wireshark</command> also exists under the name
	<command>tshark</command> (in a separate <emphasis role="pkg">tshark</emphasis> package). Most of the capture and
	decoding features are still available, but the lack of a graphical
	interface necessarily limits the interactions with the program
	(filtering packets after they've been captured, tracking of a given
	TCP connection, and so on). It can still be used as a first
	approach. If further manipulations are intended and require the
	graphical interface, the packets can be saved to a file and this
	file can be loaded into a graphical <command>wireshark</command>
	running on another machine.</para>
      </sidebar>
    </section>
  </section>
</chapter>
