<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="unix-services" lang="id-ID">
	<chapterinfo>
		 <keywordset>
			<keyword>Boot sistem</keyword>
			 <keyword>Initscript</keyword>
			 <keyword>SSH</keyword>
			 <keyword>Telnet</keyword>
			 <keyword>Hak</keyword>
			 <keyword>Izin</keyword>
			 <keyword>Pengawasan</keyword>
			 <keyword>Inetd</keyword>
			 <keyword>Cron</keyword>
			 <keyword>Cadangan</keyword>
			 <keyword>Hotplug</keyword>
			 <keyword>PCMCIA</keyword>
			 <keyword>APM</keyword>
			 <keyword>ACPI</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Layanan Unix</title>
	 <highlights> <para>
		Bab ini membahas tentang layanan dasar yang biasa digunakan pada banyak sistem Unix. Semua administator seharusnya sudah terbiasa dengan mereka.
	</para>
	 </highlights> <section id="sect.system-boot">
		<title>Boot Sistem</title>
		 <indexterm>
			<primary>boot</primary>
			<secondary>sistem</secondary>
		</indexterm>
		 <para>
			Ketika Anda mem-boot komputer, banyak pesan bergulir pada layar konsol yang menampilkan banyak inisialisasi dan konfigurasi otomatis yang sedang dieksekusi. Kadang-kadang Anda mungkin ingin mengubah sedikit bagaimana tahap ini bekerja, yang berarti bahwa Anda perlu untuk memahaminya dengan baik. Itulah tujuan dari bagian ini.
		</para>
		 <para>
			Pertama, BIOS mengambil kendali komputer, mendeteksi disk, memuat <emphasis>Master Boot Record</emphasis>, dan mengeksekusi bootloader. Bootloader mengambil alih, menemukan kernel pada disk, memuat dan mengeksekusinya. Kernel kemudian diinisialisasi, dan mulai mencari dan me-mount partisi yang memuat sistem berkas root, dan akhirnya mengeksekusi program pertama — <command>init</command>. Seringkali, "partisi root partisi" ini dan =<command>init</command> ini, pada kenyataannya, terletak di sistem berkas virtual yang hanya ada dalam RAM (maka namanya, "initramfs", sebelumnya disebut "initrd" untuk "initialization RAM disk"). Sistem berkas ini dimuat ke dalam memori oleh bootloader, sering dari suatu berkas pada hard drive atau dari jaringan. Ini berisi minimal yang diperlukan oleh kernel untuk memuat sistem berkas root yang "benar": ini mungkin modul penggerak untuk hard drive, atau perangkat lain yang tanpanya sistem tidak bisa boot, atau, lebih sering, skrip inisialisasi dan modul untuk merakit larik RAID, membuka partisi yang dienkripsi, mengaktifkan volume LVM, dll. Setelah partisi root di-mount, initramfs menyerahkan kontrol untuk init nyata, dan mesin kembali ke proses boot standar.
		</para>
		 <figure id="figure.boot-process-systemd">
			<title>Urutan boot dari komputer yang menjalankan Linux dengan systemd</title>
			 <mediaobject>
				<imageobject>
					<imagedata fileref="images/startup-systemd.png" format="PNG" scalefit="1" width="80%" />
				</imageobject>

			</mediaobject>

		</figure>
		 <section id="sect.systemd">
			<title>Sistem init systemd</title>
			 <para>
				”init sejati” saat ini disediakan oleh <emphasis role="pkg">systemd</emphasis> dan seksi ini mendokumentasikan sistem init ini.
			</para>
			 <sidebar> <title><emphasis>KULTUR</emphasis> Sebelum <command>systemd</command></title>
			 <para>
				<command>systemd</command> adalah ”sistem init” yang relatif baru, dan walaupun sudah tersedia, sampai batas tertentu, dalam <emphasis role="distribution">Wheezy</emphasis>, itu hanya menjadi baku dalam Debian <emphasis role="distribution">Jessie</emphasis>. Rilis-rilis sebelumnya mengandalkan, secara baku, ”init System V” (dalam paket <emphasis role="pkg">sysv-rc</emphasis>), suatu sistem yang jauh lebih tradisional. Kami menjelaskan init System V belakangan.
			</para>
			 </sidebar> <sidebar> <title><emphasis>ALTERNATIF</emphasis> Sistem boot lain</title>
			 <para>
				Buku ini menjelaskan sistem boot yang dipakai secara baku dalam Debian <emphasis role="distribution">Jessie</emphasis> (yang diimplementasikan oleh paket <emphasis role="pkg">systemd</emphasis>), maupun baku sebelumnya, <emphasis role="pkg">sysvinit</emphasis>, yang diturunkan dan diwariskan dari sistem Unix <emphasis>System V</emphasis>; ada juga yang lain.
			</para>
			 <para>
				<emphasis role="pkg">file-rc</emphasis> adalah sistem boot dengan proses yang sangat sederhana. Mempertahankan prinsip runlevel, tapi menggantikan direktori dan taut simbolik dengan sebuah berkas konfigurasi, yang mengindikasikan ke <command>init</command> proses-proses yang mesti dimulai dan urutan peluncuran mereka.
			</para>
			 <para>
				Sistem <command>upstart</command> belum diuji secara sempurna pada Debian. Itu berbasis peristiwa: skrip-skrip init tidak lagi dijalankan berurutan tapi sebagai respon atas kejadian seperti misalnya selesai dijalankannya skrip lain yang menjadi ketergantungannya. Sistem ini, dimulai oleh Ubuntu, ada dalam Debian <emphasis role="distribution">Jessie</emphasis>, tapi tidak baku; itu hadir, faktanya, sebagai pengganti <emphasis role="pkg">sysvinit</emphasis>, dan satu dari tugas yang diluncurkan oleh <command>upstrart</command> adalah untuk meluncurkan skrip-skrip yang ditulis untuk sistem-sistem tradisional, khususnya yang dari paket <emphasis role="pkg">sysv-rc</emphasis>.
			</para>
			 <para>
				Ada juga sistem-sistem lain dan mode-mode operasi lain, seperti misalnya <command>runit</command> atau <command>minit</command>, tapi mereka relatif khusus dan tidak meluas.
			</para>
			 </sidebar> <sidebar> <title><emphasis>KASUS SPESIFIK</emphasis> Boot dari jaringan</title>
			 <para>
				Dalam beberapa konfigurasi, BIOS mungkin dikonfigurasi untuk tidak menjalankan MBR, tapi untuk mencari yang setara di jaringan, sehingga memungkinkan untuk membangun komputer tanpa hard drive, atau yang sepenuhnya diinstal ulang pada setiap boot. Opsi ini tidak tersedia pada semua perangkat keras dan umumnya memerlukan kombinasi kartu BIOS dan jaringan yang sesuai.
			</para>
			 <para>
				Boot dari jaringan dapat digunakan untuk meluncurkan <command>debian-installer</command> atau FAI (lihat <xref linkend="sect.installation-methods" />.
			</para>
			 </sidebar> <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Proses, suatu instansi program</title>
			 <indexterm>
				<primary>proses</primary>
			</indexterm>
			 <para>
				Sebuah proses adalah representasi dalam memori dari suau program yang sedang berjalan. Ini mencakup semua informasi yang diperlukan untuk menjalankan perangkat lunak dengan benar (kode itu sendiri, juga data yang dimilikinya dalam memori, daftar berkas yang telah dibukanya, koneksi jaringan yang telah dijalin, dll.). Satu program dapat diinstansikan ke beberapa proses, tidak perlu berjalan di bawah ID pengguna yang berbeda.
			</para>
			 </sidebar> <sidebar> <title><emphasis>KEAMANAN</emphasis> Memakai sebuah shell sebagai <command>init</command> untuk mendapatkan hak root</title>
			 <para>
				Menurut konvensi, proses pertama yang di-boot adalah program <command>init</command> (yang secara baku merupakan taut simbolik ke <filename>/lib/systemd/systemd</filename>). Namun, mungkin untuk melewatkan suatu opsi <literal>init</literal> ke kernel yang mengindikasikan suatu program lain.
			</para>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				Sebarang orang yang dapat mengakses komputer bisa menekan tombol <keycap>Reset</keycap>, dan sehingga me-reboot. Kemudian, pada prompt bootloader, mungkin untuk melewatkan opsi <literal>init=/bin/sh</literal> ke kernel untuk mendapatkan akses root tanpa mengetahui sandi administrator.
			</para>
			 <para>
				Untuk mencegah hal ini, Anda dapat melindungi bootloader sendiri dengan kata sandi. Anda juga mungkin berpikir tentang melindungi akses ke BIOS (mekanisme perlindungan sandi hampir selalu tersedia), yang tanpanya penyusup jahat masih bisa mem-boot mesin pada media lepas-pasang yang berisi sistem Linux sendiri, yang kemudian dapat digunakan untuk mengakses data pada hard drive komputer.
			</para>
			 <para>
				Akhirnya, sadarilah bahwa kebanyakan BIOS memiliki password generik. Awalnya dimaksudkan untuk pemecahan masalah bagi mereka yang telah lupa password, password ini sekarang umum dan tersedia di Internet (lihat sendiri dengan mencari "password BIOS generik" di mesin pencari). Semua perlindungan ini justru akan menghambat akses tidak sah ke mesin tanpa bisa sepenuhnya mencegah itu. Tidak ada cara yang handal untuk melindungi komputer jika penyerang dapat secara fisik mengakses mereka; mereka bisa melepas hard drive untuk menghubungkan mereka ke komputer di bawah kendali mereka sendiri, atau bahkan mencuri seluruh mesin, atau menghapus memori BIOS untuk me-reset password…
			</para>
			 </sidebar> <para>
				Systemd mengeksekusi beberapa proses, yang bertanggung jawab menyiapkan sistem: papan ketik, driver, sistem berkas, jaringan, layanan. Itu melakukan hal ini sambil menyimpan pandangan global sistem secara keseluruhan, serta kebutuhan komponen-komponen. Masing-masing komponen digambarkan oleh ”berkas unit” (kadang-kadang lebih); sintaks yang umum diturunkan dari sintaks ”berkas *.ini” yang banyak digunakan, dengan pasangan-pasangan <literal><replaceable>kunci</replaceable> = <replaceable>nilai</replaceable></literal> dikelompokkan antara header-header <literal>[<replaceable>bagian</replaceable>]</literal>. Berkas unit disimpan di bawah <filename>/lib/systemd/sistem/</filename> dan <filename>/etc/systemd/system/</filename>; mereka datang dalam beberapa rasa, tapi kami akan fokus pada ”layanan” dan ”target” di sini.
			</para>
			 <para>
				Suatu ”berkas layanan” systemd menggambarkan proses yang dikelola oleh systemd. Itu kurang lebih berisi informasi yang sama seperti init-script gaya lama, tetapi dinyatakan dalam cara yang deklaratif (dan jauh lebih ringkas). Systemd menangani sebagian besar tugas-tugas yang berulang (memulai dan menghentikan proses, memeriksa status, mencatat log, menurunkan hak, dan sebagainya), dan berkas layanan hanya perlu mengisi spesifik dari proses. Sebagai contoh, berikut adalah berkas layanan untuk SSH:
			</para>
			 
<programlisting>[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</programlisting>
			 <para>
				Seperti yang Anda lihat, ada sangat sedikit kode di sana, hanya deklarasi. Systemd mengurus penampilan laporan kemajuan, melacak proses, dan bahkan menjalankan ulang mereka bila diperlukan.
			</para>
			 <para>
				Suatu "berkas target" Systemd menggambarkan keadaan sistem, dimana satu set layanan diketahui beroperasi. Ini dapat dianggap sebagai setara runlevel gaya lama. Salah satu target adalah <literal>local-fs.target</literal>; ketika itu dicapai, sisa sistem bisa berasumsi bahwa seluruh sistem berkas lokal dikait dan dapat diakses. Target lain termasuk <literal>network-online.target</literal> dan <literal>sound.target</literal>. Dependensi target dapat dicantumkan baik dalam berkas target (di baris <literal>Requires</literal>), atau menggunakan symlink ke berkas layanan di direktori <literal>/lib/systemd/sistem/<replaceable>namatarget</replaceable>.target.wants/ </literal>. Sebagai contoh, <filename>/etc/systemd/system/printer.target.wants/</filename> berisi taut ke <filename>/lib/systemd/system/cups.service</filename>; systemd karena itu akan memastikan CUPS berjalan untuk mencapai <literal>printer.target</literal>.
			</para>
			 <para>
				Karena berkas unit deklaratif, bukan skrip atau program, mereka tidak dapat dijalankan secara langsung, dan mereka hanya ditafsirkan oleh systemd; beberapa utilitas karena itu memungkinkan administrator untuk berinteraksi dengan systemd dan mengendalikan keadaan sistem dan setiap komponen.
			</para>
			 <para>
				Utilitas pertama yang seperti itu adalah <command>systemctl</command>. Ketika dijalankan tanpa argumen, itu menampilkan semua berkas unit yang dikenal systemd (kecuali yang dinonaktifkan), maupun status mereka. <command>systemctl status</command> memberikan pandangan yang lebih baik atas layanan, maupun proses-proses terkait. Bila nama yang diberikan pada suatu layanan (seperti dalam <command>systemctl status ntp.service</command>), itu bahkan mengembalikan lebih banyak rincian, maupun beberapa baris log terakhir yang terkait dengan layanan (lebih jauh tentang ini nanti).
			</para>
			 <para>
				Memulai suatu layanan secara manual hanya sekedar masalah menjalankan <command>systemctl start <replaceable>namalayanan</replaceable>.service</command>. Seperti dapat diduga, menghentikan layanan dilakukan dengan <command>systemctl stop <replaceable>namalayanan</replaceable>.service</command>; sub perintah lain termasuk <command>reload</command> dan <command>restart</command>.
			</para>
			 <para>
				Untuk mengendalikan apakah suatu layanan aktif (yaitu apakah itu akan secara otomatis dijalankan saat boot), gunakan <command>systemctl enable <replaceable>namalayanan</replaceable>.service</command> (atau <command>disable</command>). <command>is-enabled</command> memungkinkan memeriksa status layanan.
			</para>
			 <para>
				Fitur menarik dari systemd adalah bahwa itu menyertakan komponen log bernama <command>journald</command>. Datang sebagai pelengkap untuk sistem log yang lebih tradisional seperti <command>syslogd</command>, tetapi itu menambahkan fitur-fitur menarik seperti kaitan formal antara suatu layanan dan pesan-pesan yang dihasilkannya, dan kemampuan untuk menangkap pesan kesalahan yang dihasilkan oleh urutan inisialisasi. Pesan dapat ditampilkan kemudian, dengan sedikit bantuan dari perintah <command>journalctl</command>. Tanpa argumen, itu hanya memunculkan semua pesan log yang terjadi sejak boot sistem; itu akan jarang digunakan dengan cara demikian. Kebanyakan, itu akan digunakan dengan suatu tanda pengenal layanan:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</computeroutput></screen>
			 <para>
				Bendera baris perintah lain yang berguna adalah <command>-f</command>, yang memerintahkan <command>journalctl</command> untuk tetap menampilkan pesan baru seperti saat mereka dikeluarkan (seperti gaya <command>tail -f <replaceable>berkas</replaceable></command>).
			</para>
			 <para>
				Jika suatu layanan tampaknya tidak bekerja seperti yang diharapkan, langkah pertama untuk memecahkan masalah adalah memeriksa apakah layanan memang sedang berjalan dengan <command>systemctl status</command>; jika tidak, dan pesan yang diberikan oleh perintah pertama tidak cukup untuk mendiagnosa masalah, periksa log yang dikumpulkan oleh journald tentang layanan tersebut. Sebagai contoh, asumsikan SSH server tidak bekerja:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>vi /etc/ssh/sshd_config
</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service
</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </computeroutput></screen>
			 <para>
				Setelah memeriksa status layanan (gagal), kita melanjutkan memeriksa log; mereka menunjukkan satu kesalahan di berkas konfigurasi. Setelah menyunting berkas konfigurasi dan memperbaiki kesalahan, kita jalankan ulang layanan, kemudian memastikan bahwa itu memang berjalan.
			</para>
			 <sidebar><title><emphasis>LEBIH LANJUT</emphasis> Berkas unit tipe lain</title>
			 <para>
				Kami hanya menggambarkan kapabilitas systemd yang paling dasar dalam bagian ini. Itu menawarkan banyak fitur menarik lainnya; kami hanya akan mencantumkan beberapa di sini:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						aktivasi soket: suatu berkas unit "socket" dapat digunakan untuk menggambarkan sebuah jaringan atau soket Unix yang dikelola oleh systemd; ini berarti bahwa soket akan diciptakan oleh systemd, dan layanan yang sebenarnya dapat dimulai saat diminta ketika datang upaya koneksi sebenarnya. Ini kurang lebih mereplikasi set fitur <command>inetd</command>. Lihat <citerefentry><refentrytitle>systemd.socket</refentrytitle>
						<manvolnum>5</manvolnum></citerefentry>.
					</para>
				</listitem>
				 <listitem>
					<para>
						timer: suatu berkas unit "timer" menggambarkan peristiwa yang terjadi dengan frekuensi tetap atau pada waktu tertentu; ketika suatu layanan dikaitkan dengan sebuah timer, tugas terkait akan dijalankan setiap kali timer menembak. Hal ini memungkinkan mereplikasi sebagian dari fitur <command>cron</command>. Lihat <citerefentry><refentrytitle>systemd.timer</refentrytitle>
						<manvolnum>5</manvolnum></citerefentry>.
					</para>
				</listitem>
				 <listitem>
					<para>
						jaringan: suatu berkas unit "network" menjelaskan sebuah antarmuka jaringan, yang memungkinkan konfigurasi antarmuka tersebut serta mengungkapkan bahwa suatu layanan bergantung kepada satu antarmuka tertentu yang hidup.
					</para>
				</listitem>

			</itemizedlist>
			</sidebar>
		</section>
		 <section id="sect.sysvinit">
			<title>Sistem init System V</title>
			 <para>
				Sistem init System V (yang akan kami namai init agar ringkas) mengeksekusi beberapa proses, mengikuti instruksi dari berkas <filename>/etc/inittab</filename>. Program pertama yang dijalankan (yang sesuai dengan langkah <emphasis>sysinit</emphasis>) adalah <command>/etc/init.d/rcS</command>, sebuah skrip yang menjalankan semua program di direktori <filename>/etc/rcS.d/</filename>. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm><indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm>
			</para>
			 <para>
				Di antara ini, Anda akan menemukan berturut-turut program-program yang bertanggung jawab atas:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						mengkonfigurasi papan ketik konsol;
					</para>

				</listitem>
				 <listitem>
					<para>
						memuat driver: sebagian besar modul kernel yang dimuat oleh kernel sendiri saat perangkat keras terdeteksi; driver tambahan kemudian dimuat secara otomatis ketika modul sesuai dicantumkan dalam <filename>/etc/modules</filename>;
					</para>

				</listitem>
				 <listitem>
					<para>
						memeriksa integritas sistem berkas;
					</para>

				</listitem>
				 <listitem>
					<para>
						mengait partisi lokal;
					</para>

				</listitem>
				 <listitem>
					<para>
						mengkonfigurasi jaringan;
					</para>

				</listitem>
				 <listitem>
					<para>
						mengait network filesystems (NFS).
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Modul dan opsi kernel</title>
			 <indexterm>
				<primary>modul</primary>
				<secondary>modul kernel</secondary>
			</indexterm>
			 <para>
				Modul kernel juga memiliki pilihan yang dapat dikonfigurasi dengan menempatkan beberapa berkas dalam <filename>/etc/modprobe.d/</filename>. Pilihan ini ditentukan dengan perintah seperti ini: <literal>options <replaceable>nama-modul</replaceable> <replaceable>nama-opsi</replaceable>=<replaceable>nilai-opsi</replaceable></literal>. Beberapa pilihan dapat dispesifikasikan dalam satu baris jika diperlukan.
			</para>
			 <para>
				Berkas konfigurasi ini ditujukan untuk <command>modprobe</command> — program yang memuat suatu modul kernel dengan dependensinya (modul memang dapat memanggil modul lain). Program ini disediakan oleh paket <emphasis role="pkg">kmod</emphasis>.
			</para>
			 <indexterm>
				<primary><command>modprobe</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">kmod</emphasis></primary>
			</indexterm>
			 </sidebar> <para>
				Setelah tahap ini, <command>init</command> mengambil alih dan memulai program-program yang diaktifkan pada runlevel default (yang biasanya runlevel 2). Itu mengeksekusi <command>/etc/init.d/rc 2</command>, skrip yang memulai semua layanan yang tercantum dalam <filename>/etc/rc2.d/</filename> dan nama-nama yang mulai dengan huruf "S". Nomor dua-angka yang mengikuti secara historis digunakan untuk menentukan urutan dimulainya layanan, tetapi saat ini sistem boot default menggunakan <command>insserv</command>, yang menjadwalkan semuanya secara otomatis berdasarkan dependensi skrip. Setiap skrip boot dengan demikian menyatakan kondisi yang harus dipenuhi untuk memulai atau menghentikan layanan (misalnya, jika itu harus dimulai sebelum atau setelah layanan lain); <command>init</command> kemudian meluncurkan mereka dalam urutan yang memenuhi kondisi ini. Penomoran statis skrip karena itu tidak lagi dipertimbangkan (tapi mereka selalu harus mempunyai awal nama dengan "S" diikuti oleh dua digit dan nama sebenarnya dari skrip yang digunakan untuk dependensi). Umumnya, layanan dasar (seperti log dengan <command>rsyslog</command>), atau penugasan port dengan <command>portmap</command> yang mulai pertama, diikuti oleh layanan-layanan standar dan antarmuka grafis (<command>gdm3</command>).
			</para>
			 <para>
				Sistem boot berbasis ketergantungan ini memungkinkan mengotomatisasi penomoran ulang, yang bisa menjadi membosankan jika itu harus dilakukan secara manual, dan itu jadi membatasi resiko kesalahan manusia, karena penjadwalan dilakukan berdasarkan parameter yang ditunjukkan. Manfaat lain adalah bahwa layanan dapat dimulai secara paralel ketika mereka independen dari yang lain, yang dapat mempercepat proses boot.
			</para>
			 <indexterm>
				<primary>runlevel</primary>
			</indexterm>
			 <indexterm>
				<primary>level, runlevel</primary>
			</indexterm>
			 <para>
				<command>init</command> membedakan beberapa runlevel, sehingga ia dapat beralih dari satu ke yang lain dengan perintah <command>telinit <replaceable>level-baru</replaceable></command>. Seketika, <command>init</command> mengeksekusi <command>/etc/init.d/rc</command> lagi dengan runlevel baru. Skrip ini kemudian akan memulai pelayanan yang kurang dan menghentikan yang tidak diinginkan. Untuk melakukan ini, mengacu pada isi <filename>/etc/rc <replaceable>X</replaceable> .d</filename> (dimana <replaceable>X</replaceable> mewakili runlevel baru). Skrip yang dimulai dengan "S" (seperti dalam "Start") adalah layanan yang akan dijalankan; yang dimulai dengan "K" (seperti "Kill") adalah layanan yang harus dihentikan. Skrip tidak memulai layanan apapun yang sudah aktif pada runlevel sebelumnya.
			</para>
			 <para>
				Secara default, init System V dalam Debian menggunakan empat runlevels yang berbeda:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						Level 0 hanya digunakan sementara, ketika komputer menuju mati. Dengan demikian, itu hanya berisi banyak skrip "K".
					</para>

				</listitem>
				 <listitem>
					<para>
						Level 1, juga dikenal sebagai mode pengguna tunggal, berkaitan dengan sistem dalam mode terdegradasi; itu termasuk hanya layanan dasar, dan ditujukan untuk operasi pemeliharaan dimana interaksi dengan pengguna biasa tidak diinginkan.
					</para>

				</listitem>
				 <listitem>
					<para>
						Level 2 adalah tingkat untuk operasi normal, yang mencakup layanan jaringan, antarmuka grafis, pengguna login, dll.
					</para>

				</listitem>
				 <listitem>
					<para>
						Level 6 ini mirip dengan tingkat 0, kecuali bahwa itu digunakan selama fase shutdown yang mendahului reboot.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Ada tingkat lain, terutama 3-5. Secara default mereka telah dikonfigurasi untuk beroperasi dengan cara yang sama sebagai tingkat 2, namun administrator dapat memodifikasi mereka (dengan menambahkan atau menghapus skrip di direktori <filename>/etc/rc<replaceable>X</replaceable>.d</filename> yang sesuai) untuk beradaptasi atas kebutuhan tertentu.
			</para>
			 <figure id="figure.boot-process-sysvinit">
				<title>Urutan boot dari komputer yang menjalankan Linux dengan init System V</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/startup-sysvinit.png" format="PNG" scalefit="1" width="80%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <indexterm>
				<primary>skrip inisialisasi</primary>
			</indexterm>
			 <para>
				Semua skrip yang terkandung dalam berbagai direktori <filename>/etc/rc<replaceable>X</replaceable>.d</filename> benar-benar hanya link simbolik — dibuat saat instalasi paket oleh program <command>update-rc.d</command> — menunjuk ke skrip sebenarnya yang disimpan dalam <filename>/etc/init.d/</filename>. Administrator dapat menala layanan yang tersedia pada masing-masing runlevel dengan kembali menjalankan <command>update-rc.d</command> dengan parameter yang disesuaikan. Halaman manual <citerefentry><refentrytitle>update-rc.d</refentrytitle>
				<manvolnum>1</manvolnum></citerefentry> menjelaskan sintaks secara rinci. Harap dicatat bahwa menghapus semua link simbolik (dengan parameter <literal>remove</literal>) bukanlah metode yang baik untuk menonaktifkan layanan yang ada. Sebaliknya Anda hanya harus mengkonfigurasi itu untuk tidak mulai berjalan pada runlevel yang diinginkan (sambil mempertahankan panggilan yang sesuai untuk menghentikannya apabila layanan berjalan pada runlevel sebelumnya). Karena <command>update-rc.d</command> memiliki antarmuka yang agak rumit, Anda mungkin lebih suka menggunakan <command>rcconf</command> (dari paket <emphasis role="pkg">rcconf</emphasis>) yang menyediakan antar muka yang lebih mudah dipakai.
			</para>
			 <indexterm>
				<primary><command>update-rc.d</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>KEBIJAKAN DEBIAN</emphasis> Restart layanan</title>
			 <indexterm>
				<primary><command>invoke-rc.d</command></primary>
			</indexterm>
			 <indexterm>
				<primary>service</primary>
				<secondary>restart</secondary>
			</indexterm>
			 <indexterm>
				<primary>menjalankan ulang layanan</primary>
			</indexterm>
			 <para>
				Skrip pengelola paket Debian kadang-kadang akan me-restart layanan tertentu untuk memastikan ketersediaan mereka atau membuat mereka memperhitungkan opsi tertentu. Perintah yang mengontrol layanan — <command>service <replaceable>layanan</replaceable> <replaceable>operasi</replaceable></command> — tidak mempertimbangkan runlevel, (salah) mengasumsikan bahwa layanan ini sedang digunakan, dan mungkin dengan demikian memulai operasi salah (memulai layanan yang sengaja dihentikan, atau menghentikan layanan yang sudah dihentikan, dll.). Maka Debian memperkenalkan program <command>invoke-rc.d</command>: program ini harus digunakan oleh pengelola skrip untuk menjalankan skrip inisialisasi layanan dan itu hanya akan menjalankan perintah yang diperlukan. Catat bahwa, bertentangan dengan penggunaan umum, akhiran <filename>.d</filename> yang digunakan di sini di dalam nama program, dan bukan dalam sebuah direktori.
			</para>
			 </sidebar> <para>
				Akhirnya, <command>init</command> memulai program kontrol untuk berbagai konsol virtual (<command>getty</command>). Menampilkan sebuah prompt, menunggu nama pengguna, kemudian mengeksekusi <command>login <replaceable>pengguna</replaceable></command> untuk memulai sesi.
			</para>
			 <indexterm>
				<primary><command>getty</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>KOSA KATA</emphasis> Konsol dan terminal</title>
			 <para>
				Komputer pertama biasanya dipisahkan menjadi beberapa bagian yang sangat besar: kandang penyimpanan dan unit pemroses sentral yang terpisah dari perangkat periferal yang digunakan oleh operator untuk mengendalikan mereka. Ini adalah bagian dari furnitur yang terpisah, "konsol". Istilah ini dipertahankan, tapi artinya berubah. Hal ini kurang lebih identik dengan "terminal", karena berupa sebuah papan ketik dan suatu layar.
			</para>
			 <para>
				Dengan perkembangan komputer, sistem operasi telah menawarkan beberapa konsol virtual untuk memungkinkan beberapa sesi independen pada saat yang sama, bahkan jika ada hanya satu papan ketik dan layar. Kebanyakan sistem GNU/Linux menawarkan enam virtual konsol (dalam modus teks), dapat diakses dengan mengetikkan kombinasi tombol <keycombo action="simul"><keycap>Control</keycap> <keycap>Alt</keycap><keycap>F1</keycap></keycombo> sampai <keycombo action="simul"><keycap>Control</keycap><keycap>Alt</keycap><keycap>F6</keycap></keycombo>.
			</para>
			 <para>
				Diperluas, istilah "konsol" dan "terminal" juga dapat merujuk ke emulator terminal dalam sesi X11 grafis (seperti misalnya <command>xterm</command>, <command>gnome-terminal</command>, atau <command>konsole</command>).
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.remote-login">
		<title>Log Masuk Jarak Jauh</title>
		 <para>
			Sangat penting bagi administrator untuk dapat menyambung ke suatu komputer dari jarak jauh. Server, dikurung dalam kamar mereka sendiri, jarang dilengkapi dengan papan ketik dan monitor permanen — tetapi mereka terhubung ke jaringan.
		</para>
		 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Klien, server</title>
		 <indexterm>
			<primary>klien</primary>
			<secondary>arsitektur klien/server</secondary>
		</indexterm>
		 <indexterm>
			<primary>server</primary>
			<secondary>arsitektur klien/server</secondary>
		</indexterm>
		 <para>
			Sebuah sistem yang beberapa prosesnya berkomunikasi satu sama lain sering digambarkan dengan metafora "klien/server". Server adalah program yang mengambil permintaan yang datang dari klien dan mengeksekusi mereka. Ini adalah klien yang mengendalikan operasi, server tidak mengambil setiap inisiatif sendiri.
		</para>
		 </sidebar> <indexterm>
			<primary>login</primary>
			<secondary>login jarak jauh</secondary>
		</indexterm>
		 <indexterm>
			<primary>login jarak jauh</primary>
		</indexterm>
		 <section id="sect.ssh">
			<title>Login Jarak Jauh Aman: SSH</title>
			 <indexterm>
				<primary>SSH</primary>
			</indexterm>
			 <indexterm>
				<primary>Secure Shell</primary>
			</indexterm>
			 <para>
				Protokol <emphasis>SSH</emphasis> (Secure SHell) dirancang dengan keamanan dan kehandalan. Koneksi yang menggunakan SSH aman: mitra diotentikasi dan semua pertukaran data dienkripsi.
			</para>
			 <sidebar> <title><emphasis>BUDAYA</emphasis> Telnet dan RSH itu usang</title>
			 <indexterm>
				<primary><command>telnet</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>rsh</command></primary>
			</indexterm>
			 <para>
				Sebelum SSH, <emphasis>Telnet</emphasis> dan <emphasis>RSH</emphasis> adalah alat utama yang digunakan untuk login jarak jauh. Mereka sekarang sebagian besar usang dan sebaiknya tidak lagi digunakan bahkan walaupun Debian masih menyediakan mereka.
			</para>
			 </sidebar> <sidebar> <title><emphasis>KOSAKATA</emphasis> Otentikasi, enkripsi</title>
			 <para>
				Ketika Anda perlu memberikan klien kemampuan untuk melakukan atau memicu tindakan pada server, keamanan penting. Anda harus memastikan identitas dari klien; ini adalah otentikasi. Identitas ini biasanya terdiri dari password yang harus dirahasiakan, atau klien lain jadi bisa mendapatkankan password tersebut. Ini adalah tujuan dari enkripsi, yang merupakan bentuk enkoding yang memungkinkan dua sistem untuk mengkomunikasikan informasi rahasia pada saluran umum sekaligus melindungi dari dapat dibaca oleh orang lain.
			</para>
			 <para>
				Otentikasi dan enkripsi sering disebut bersama, baik karena mereka sering digunakan bersama-sama, dan karena mereka biasanya diimplementasikan dengan konsep-konsep matematika yang serupa.
			</para>
			 </sidebar> <para>
				SSH juga menawarkan dua layanan transfer berkas. <command>SCP</command> adalah alat baris perintah yang dapat digunakan seperti <command>cp</command>, kecuali bahwa sebarang path ke mesin lain diawali dengan nama mesin, diikuti oleh titik dua.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>scp berkas mesin:/tmp/</userinput></screen>
			 <para>
				<command>sftp</command> adalah perintah yang interaktif, mirip dengan <command>ftp</command>. Dalam satu sesi, <command>sftp</command> dapat mentransfer beberapa berkas, dan mungkin untuk memanipulasi berkas remote dengannya (menghapus, mengubah nama, mengubah hak akses, dll).
			</para>
			 <indexterm>
				<primary><command>scp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sftp</command></primary>
			</indexterm>
			 <para>
				Debian menggunakan OpenSSH, sebuah SSH versi gratis yang dikelola oleh proyek <command>OpenBSD</command> (sistem operasi bebas berbasis pada kernel BSD, berfokus pada keamanan) dan fork dari perangkat lunak SSH asli yang dikembangkan oleh perusahaan SSH Communication Corp, dari Finlandia. Perusahaan ini awalnya mengembangkan SSH sebagai perangkat lunak bebas, tetapi akhirnya memutuskan untuk melanjutkan perkembangan di bawah lisensi tak bebas. Proyek OpenBSD kemudian menciptakan OpenSSH untuk mempertahankan versi gratis dari SSH.
			</para>
			 <indexterm>
				<primary>OpenSSH</primary>
			</indexterm>
			 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> <foreignphrase>Fork</foreignphrase></title>
			 <indexterm>
				<primary>fork</primary>
			</indexterm>
			 <para>
				"Fork", dalam bidang perangkat lunak, berarti sebuah proyek baru yang dimulai sebagai klon dari proyek yang sudah ada, dan akan bersaing dengannya. Dari sana, kedua perangkat lunak biasanya cepat akan menyimpang dalam hal perkembangan baru. Fork ini sering merupakan akibat dari perselisihan dalam tim pengembangan.
			</para>
			 <para>
				Pilihan untuk melakukan fork atas sebuah proyek adalah akibat langsung dari sifat perangkat lunak bebas; fork merupakan kejadian yang sehat saat itu memungkinkan keberlanjutan proyek sebagai perangkat lunak bebas (misalnya dalam kasus perubahan lisensi). Sebuah fork yang timbul dari perselisihan teknis atau pribadi sering membuang-buang sumber daya manusia; resolusi lain akan lebih baik. Merger dua proyek yang sebelumnya mengalami fork bukan tidak pernah terjadi.
			</para>
			 </sidebar> <para>
				OpenSSH dipecah menjadi dua paket: bagian klien dalam paket <emphasis role="pkg">openssh-client</emphasis>, dan server dalam paket <emphasis role="pkg">openssh-server</emphasis>. Meta-paket <emphasis role="pkg">ssh</emphasis> bergantung pada kedua bagian dan memfasilitasi instalasi keduanya (<command>apt install ssh</command>).
			</para>
			 <section id="sect.ssh-key-based-auth">
				<title>Otentikasi Berbasis Kunci</title>
				 <para>
					Setiap kali seseorang log masuk melalui SSH, server remote meminta password untuk mengotentikasi pengguna. Ini bisa menjadi bermasalah jika Anda ingin mengotomatisasi sambungan, atau jika Anda menggunakan alat yang membutuhkan koneksi sering melalui SSH. Inilah sebabnya mengapa SSH menawarkan sistem otentikasi berbasis kunci.
				</para>
				 <para>
					Pengguna membuat sepasang kunci pada mesin klien dengan <command>ssh-keygen-t rsa</command>; kunci publik disimpan dalam <filename>~/.ssh/id_rsa.pub</filename>, sementara kunci privat disimpan dalam <filename>~/.ssh/id_rsa</filename>. Pengguna kemudian menggunakan <command>ssh-copy-id <replaceable>server</replaceable></command> untuk menambahkan kunci publik mereka ke berkas <filename>~/.ssh/authorized_keys</filename> pada server. Jika kunci privat tidak dilindungi dengan "frasa sandi" pada saat penciptaan, semua login berikutnya pada server akan bekerja tanpa kata sandi. Sebaliknya, kunci pribadi harus didekripsi setiap kali dengan memasukkan kata sandi. Untungnya, <command>ssh-agent</command> memungkinkan kita untuk menjaga kunci privat dalam memori untuk tidak perlu secara teratur memasukkan kembali kata sandi. Untuk ini, Anda hanya menggunakan <command>ssh-add</command> (sekali per sesi) asalkan sesi sudah terkait dengan instansi fungsional <command>ssh-agent</command>. Debian mengaktifkannya secara default dalam sesi grafis, tapi ini dapat dinonaktifkan dengan mengubah <filename>/etc/X11/Xsession.options</filename>. Untuk sesi konsol, Anda dapat secara manual memulainya dengan <command>eval $(ssh-agent)</command>.
				</para>
				 <sidebar> <title><emphasis>KEAMANAN</emphasis> Perlindungan kunci privat</title>
				 <para>
					Barangsiapa memiliki kunci privat tersebut dapat login di akun yang dikonfigurasi. Inilah sebabnya mengapa akses ke kunci privat dilindungi oleh "frasa sandi". Seseorang yang memperoleh salinan berkas kunci pribvat (misalnya, <filename>~/.ssh/id_rsa</filename>) masih harus tahu frasa ini agar dapat menggunakannya. Perlindungan tambahan ini tidak anti tembus, dan jika Anda berpikir bahwa berkas ini telah dikompromikan, paling baik untuk menonaktifkan kunci tersebut pada komputer tempat itu telah diinstal (dengan menghapus dari berkas <filename>authorized_keys</filename>) dan menggantikannya dengan kunci baru yang dibuat.
				</para>
				 </sidebar> <sidebar> <title><emphasis>KULTUR</emphasis> Cacat OpenSSL dalam Debian <emphasis role="distribution">Etch</emphasis></title>
				 <para>
					Pustaka OpenSSL, sebagaimana awalnya disediakan di Debian <emphasis role="distribution">Etch</emphasis>, memiliki masalah yang serius dalam pembangkit angka acak (RNG). Memang, pengelola Debian telah membuat perubahan sehingga aplikasi yang menggunakan itu tidak lagi menghasilkan peringatan ketika dianalisis oleh alat pengujian memori seperti <command>valgrind</command>. Sayangnya, perubahan ini juga berarti bahwa RNG hanya mempekerjakan salah satu sumber entropi sesuai dengan nomor proses (PID) yang 32.000 kemungkinan nilainya tidak menawarkan cukup keacakan. <ulink type="block" url="http://www.debian.org/security/2008/dsa-1571" />
				</para>
				 <para>
					Secara khusus, setiap kali OpenSSL digunakan untuk menghasilkan sebuah kunci, itu selalu menghasilkan kunci dalam kumpulan ratusan ribu kunci yang dikenal (32.000 dikalikan dengan sejumlah kecil panjang kunci). Ini mempengaruhi kunci SSH, kunci SSL, dan sertifikat X.509 yang digunakan oleh banyak aplikasi, seperti misalnya OpenVPN. Seorang cracker hanya perlu mencoba semua kunci untuk mendapatkan akses yang tidak sah. Untuk mengurangi dampak dari masalah, SSH daemon diubah untuk menolak bermasalah kunci yang tercantum dalam paket <emphasis role="pkg">openssh-blacklist</emphasis> dan <emphasis role="pkg">openssh-blacklist-extra</emphasis>. Selain itu, perintah <command>ssh-vulnkey</command> memungkinkan identifikasi kunci yang mungkin terkompromikan dalam sistem.
				</para>
				 <para>
					Analisis lebih mendalam terhadap kejadian ini mengungkap bahwa itu adalah hasil dari beberapa masalah (kecil), baik dalam proyek OpenSSL dan dengan para pengelola paket Debian. Sebuah perpustakaan yang banyak digunakan seperti OpenSSL harus — tanpa modifikasi — tidak menghasilkan peringatan saat diuji oleh <command>valgrind</command>. Selain itu, kode (terutama bagian RNG yang sensitif) harus memuat komentar yang lebih baik untuk mencegah kesalahan tersebut. Di sisi Debian, pengelola ingin memvalidasi modifikasi dengan pengembang OpenSSL, tetapi hanya menjelaskan modifikasi tanpa memberikan patch yang sesuai untuk ditinjau dan gagal untuk menyebutkan perannya dalam Debian. Akhirnya, pilihan-pilihan perawatan sub-optimal: perubahan yang dibuat ke kode asli tidak didokumentasikan jelas; semua modifikasi secara efektif tersimpan dalam repositori Subversion, tapi mereka akhirnya semua digabung ke dalam satu patch selama penciptaan sumber paket.
				</para>
				 <para>
					It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <ulink type="block" url="http://sources.debian.org" />
				</para>
				 </sidebar>
			</section>
			 <section id="sect.ssh-x11">
				<title>Menggunakan Aplikasi-aplikasi X11 Jarak Jauh</title>
				 <para>
					Protokol SSH memungkinkan penerusan data grafis (sesi "X11", dari nama sistem grafis yang paling terkenal di Unix); server kemudian mempertahankan saluran khusus untuk data tersebut. Secara khusus, program grafis yang dijalankan dari jarak jauh dapat ditampilkan pada layar lokal server XFree86, dan seluruh sesi (masukan dan tampilan) akan aman. Karena fitur ini memungkinkan aplikasi remote untuk mengganggu sistem lokal, ini dinonaktifkan secara default. Anda dapat mengaktifkannya dengan menetapkan <literal>X11Forwarding yes</literal> di berkas konfigurasi server (<filename>/etc/ssh/sshd_config</filename>). Akhirnya, pengguna juga harus memintanya dengan menambahkan opsi <literal>-X</literal> untuk baris perintah <command>ssh</command>.
				</para>

			</section>
			 <section id="sect.ssh-port-forwarding">
				<title>Menciptakan Tunnel Terenkripsi dengan Penerusan Port</title>
				 <indexterm>
					<primary>penerusan port</primary>
				</indexterm>
				 <para>
					Opsi <literal>-R</literal> dan <literal>-L</literal> memungkinkan <command>ssh</command> untuk menciptakan "terowongan terenkripsi" antara dua mesin, secara aman meneruskan port TCP lokal (lihat sidebar <xref linkend="sidebar.tcp-udp" />) ke mesin remote atau sebaliknya.
				</para>
				 <sidebar> <title><emphasis>KOSAKATA</emphasis> Tunnel</title>
				 <indexterm>
					<primary>tunnel (SSH)</primary>
					<seealso>VPN</seealso>
				</indexterm>
				 <indexterm>
					<primary>SSH tunnel</primary>
					<seealso>VPN</seealso>
				</indexterm>
				 <para>
					Internet, dan kebanyakan LAN yang terhubung, beroperasi dalam mode paket dan tidak dalam modus yang terhubung, berarti bahwa paket yang diterbitkan dari satu komputer ke yang lain akan berhenti di beberapa router perantara untuk menemukan jalan ke tujuan. Anda masih dapat mensimulasikan operasi yang terhubung dimana stream dibungkus dalam paket-paket IP normal. Paket ini mengikuti rute biasa mereka, tapi stream ini direkonstruksi tidak berubah di tujuan. Kami menyebutnya "tunnel", analog dengan terowongan jalan tempat kendaraan langsung berjalan dari pintu masuk (masukan) ke tempat keluar (keluaran) tanpa menemui persimpangan apapun, dibandingkan dengan jalur pada permukaan yang akan melibatkan persimpangan dan mengubah arah.
				</para>
				 <para>
					Anda dapat menggunakan kesempatan ini untuk menambahkan enkripsi ke tunnel: stream yang mengalir melaluinya kemudian tidak dikenali dari luar, tapi dikembalikan ke dalam bentuk terdekripsi di pintu keluar tunnel.
				</para>
				 </sidebar> <para>
					<command>ssh -L 8000:server:25 perantara</command> menjalin suatu sesi SSH dengan host <replaceable>perantara</replaceable> dan mendengarkan port lokal 8000 (lihat <xref linkend="figure.ssh-L" />). Untuk sebarang koneksi yang terjalin pada port ini, <command>ssh</command> akan memulai koneksi dari komputer <replaceable>perantara</replaceable> ke port 25 pada <replaceable>server</replaceable>, dan akan mengikat kedua koneksi bersama-sama.
				</para>
				 <para>
					<command>ssh -R 8000:server:25 perantara</command> juga menjalin sesi SSH ke komputer <replaceable>perantara</replaceable>, tetapi pada mesin ini <command>ssh</command> mendengarkan port 8000 (lihat <xref linkend="figure.ssh-R" />). Sebarang koneksi yang dijalin pada port ini akan menyebabkan <command>ssh</command> membuka koneksi dari mesin lokal ke port 25 <replaceable>server</replaceable> dan mengikat kedua koneksi bersama-sama.
				</para>
				 <para>
					Dalam kedua kasus, sambungan dibuat ke port 25 pada host <replaceable>server</replaceable>, melewati tunnel SSH yang dijalin antara mesin lokal dan mesin <replaceable>perantara</replaceable>. Dalam kasus pertama, pintu masuk ke tunnel adalah port lokal 8000, dan data bergerak menuju mesin <replaceable>perantara</replaceable> sebelum diarahkan ke <replaceable>server</replaceable> pada jaringan "publik". Dalam kedua kasus, masukan dan keluaran di tunnel dibalik; pintu masuk adalah port 8000 pada mesin <replaceable>perantara</replaceable>, keluaran adalah pada host lokal, dan data diarahkan ke <replaceable>server</replaceable>. Dalam prakteknya, server ini biasanya mesin lokal atau perantara. Dengan cara itu SSH mengamankan koneksi dari satu ujung ke yang lain.
				</para>
				 <figure id="figure.ssh-L">
					<title>Penerusan suatu port lokal dengan SSH</title>
					 <mediaobject>
						<imageobject>
							<imagedata fileref="images/ssh-L.png" format="PNG" width="35%" />
						</imageobject>

					</mediaobject>

				</figure>
				 <figure id="figure.ssh-R">
					<title>Penerusan suatu port jauh dengan SSH</title>
					 <mediaobject>
						<imageobject>
							<imagedata fileref="images/ssh-R.png" format="PNG" width="35%" />
						</imageobject>

					</mediaobject>

				</figure>

			</section>

		</section>
		 <section id="sect.remote-desktops">
			<title>Memakai Desktop Grafis Jarak Jauh</title>
			 <para>
				VNC (Virtual Network Computing) memungkinkan akses remote ke desktop grafis.
			</para>
			 <indexterm>
				<primary>VNC</primary>
			</indexterm>
			 <indexterm>
				<primary>Virtual Network Computing</primary>
			</indexterm>
			 <indexterm>
				<primary>desktop grafis</primary>
				<secondary>remote</secondary>
			</indexterm>
			 <indexterm>
				<primary>remote desktop grafis</primary>
			</indexterm>
			 <indexterm>
				<primary>desktop, remote desktop grafis</primary>
			</indexterm>
			 <para>
				Alat ini banyak digunakan untuk bantuan teknis; administrator dapat melihat kesalahan yang dihadapi pengguna, dan menunjukkan kepada mereka tindakan yang benar tanpa harus berdiri di samping mereka.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vino</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">krfb</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">x11vnc</emphasis></primary>
			</indexterm>
			 <para>
				First, the user must authorize sharing their session. The GNOME graphical desktop environment in <emphasis role="distribution">Jessie</emphasis> includes that option in its configuration panel (contrary to previous versions of Debian, where the user had to install and run <command>vino</command>). KDE Plasma still requires using <command>krfb</command> to allow sharing an existing session over VNC. For other graphical desktop environments, the <command>x11vnc</command> command (from the Debian package of the same name) serves the same purpose; you can make it available to the user with an explicit icon.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vinagre</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">tsclient</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">krdc</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">xvnc4viewer</emphasis></primary>
			</indexterm>
			 <para>
				When the graphical session is made available by VNC, the administrator must connect to it with a VNC client. GNOME has <command>vinagre</command> and <command>remmina</command> for that, while the KDE project provides <command>krdc</command> (in the menu at <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). There are other VNC clients that use the command line, such as <command>xvnc4viewer</command> in the Debian package of the same name. Once connected, the administrator can see what is going on, work on the machine remotely, and show the user how to proceed.
			</para>
			 <sidebar> <title><emphasis>KEAMANAN</emphasis> VNC di atas SSH</title>
			 <indexterm>
				<primary>tunnel SSH</primary>
				<secondary>VNC</secondary>
			</indexterm>
			 <para>
				Jika Anda ingin terhubung oleh VNC, dan Anda tidak ingin data Anda dikirim dalam bentuk teks polos pada jaringan, mungkin untuk membungkus data dalam tunnel SSH (lihat <xref linkend="sect.ssh-port-forwarding" />). Anda hanya perlu tahu bahwa VNC menggunakan port 5900 secara default untuk layar pertama (disebut "localhost:0"), 5901 untuk kedua (disebut "localhost:1"), dll.
			</para>
			 <para>
				Perintah <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>mesin</replaceable></command> menciptakan sebuah tunnel antara port lokal 5901 di antarmuka localhost dan port 5900 host <replaceable>mesin</replaceable>. "localhost" pertama membatasi SSH untuk mendengarkan hanya pada antarmuka tersebut di komputer lokal. "localhost" kedua menunjukkan antarmuka pada mesin remote yang akan menerima lalu lintas jaringan masuk "localhost:5901". Dengan demikian <command>vncviewer localhost:1</command> akan menghubungkan klien VNC ke layar remote, meskipun Anda menunjukkan nama dari mesin lokal.
			</para>
			 <para>
				Ketika sesi VNC ditutup, ingatlah untuk menutup tunnel juga dengan menghentikan sesi SSH yang sesuai.
			</para>
			 </sidebar> <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Manajer tampilan</title>
			 <indexterm>
				<primary><command>gdm3</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>kdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>xdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>lightdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary>manajer</primary>
				<secondary>manajer tampilan</secondary>
			</indexterm>
			 <indexterm>
				<primary>manajer tampilan</primary>
			</indexterm>
			 <para>
				<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, dan <command>xdm</command> adalah Manajer Tampilan. Mereka mengambil kontrol antarmuka grafis tak lama setelah boot untuk menyediakan layar login ke pengguna. Setelah pengguna login, mereka menjalankan program-program yang dibutuhkan untuk memulai sesi grafis.
			</para>
			 </sidebar> <para>
				VNC juga bekerja untuk pengguna ponsel, atau eksekutif perusahaan, yang kadang-kadang perlu untuk login dari rumah mereka untuk mengakses desktop remote seperti yang mereka gunakan di tempat kerja. Konfigurasi layanan seperti itu lebih rumit: Anda pertama memasang paket <emphasis role="pkg">vnc4server</emphasis>, mengubah konfigurasi dari layar manajer untuk menerima permintaan <literal>XDMCP Query</literal> (untuk <command>gdm3 </command>, ini dapat dilakukan dengan menambahkan <literal>Enable=true</literal> di bagian "xdmcp" <filename>/etc/gdm3/daemon.conf</filename>), dan akhirnya, memulai server VNC dengan <command>inetd</command> sehingga sesi secara otomatis dimulai ketika pengguna mencoba untuk login. Misalnya, Anda dapat menambahkan baris ini untuk <filename>/etc/inetd.conf</filename>:
			</para>
			 
<programlisting>5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</programlisting>
			 <para>
				Mengarahkan koneksi masuk ke manajer tampilan memecahkan masalah otentikasi, karena hanya pengguna dengan akun lokal yang akan melewati layar login <command>gdm3</command> (atau yang setara <command>kdm</command>, <command>xdm</command>, dll). Karena operasi ini memungkinkan beberapa login simultan tanpa masalah (asal server cukup kuat), bahkan dapat digunakan untuk menyediakan desktop yang lengkap bagi pengguna ponsel (atau untuk sistem desktop yang kurang kuat, dikonfigurasi sebagai thin client). Pengguna cukup login ke layar server dengan <command>vncviewer <replaceable>server</replaceable>:50</command>, karena port yang digunakan adalah 5950.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vnc4server</emphasis></primary>
			</indexterm>

		</section>

	</section>
	 <section id="sect.rights-management">
		<title>Mengelola Hak</title>
		 <para>
			Linux tentu saja adalah sistem multi-pengguna, sehingga perlu untuk menyediakan sistem izin untuk mengontrol set operasi terotorisasi pada berkas dan direktori, yang mencakup semua sumber daya sistem dan perangkat (pada sebuah sistem Unix, setiap perangkat diwakili oleh sebuah berkas atau direktori). Prinsip ini umum untuk semua sistem Unix, tetapi pengingat selalu berguna, terutama karena ada beberapa penggunaan tingkat lanjut yang menarik dan relatif tidak dikenal.
		</para>
		 <indexterm>
			<primary>hak</primary>
		</indexterm>
		 <indexterm>
			<primary>izin</primary>
		</indexterm>
		 <indexterm>
			<primary>pengguna</primary>
			<secondary>pemilik</secondary>
		</indexterm>
		 <indexterm>
			<primary>kelompok</primary>
			<secondary>pemilik</secondary>
		</indexterm>
		 <indexterm>
			<primary>pemilik</primary>
			<secondary>pengguna</secondary>
		</indexterm>
		 <indexterm>
			<primary>pemilik</primary>
			<secondary>kelompok</secondary>
		</indexterm>
		 <para>
			Setiap berkas atau direktori memiliki izin khusus untuk tiga kategori pengguna:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					pemiliknya (dilambangkan oleh <literal>u</literal> seperti "user/pengguna");
				</para>

			</listitem>
			 <listitem>
				<para>
					grup pemilik (dilambangkan oleh <literal>g</literal> dalam "grup"), yang mewakili semua anggota kelompok;
				</para>

			</listitem>
			 <listitem>
				<para>
					yang lain (dilambangkan oleh <literal>o</literal> seperti "other/yang lain").
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Tiga jenis hak dapat digabungkan:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					membaca (symbolized oleh <literal>r</literal> seperti "read/baca");
				</para>

			</listitem>
			 <listitem>
				<para>
					menulis (atau memodifikasi, dilambangkan oleh <literal>w</literal> seperti "write/menulis");
				</para>

			</listitem>
			 <listitem>
				<para>
					mengeksekusi (dilambangkan oleh <literal>x</literal> seperti "eXecute/menjalankan").
				</para>

			</listitem>

		</itemizedlist>
		 <indexterm>
			<primary>baca, hak</primary>
		</indexterm>
		 <indexterm>
			<primary>tulis, hak</primary>
		</indexterm>
		 <indexterm>
			<primary>modifikasi, hak</primary>
		</indexterm>
		 <indexterm>
			<primary>eksekusi, hak</primary>
		</indexterm>
		 <para>
			Dalam kasus berkas, hak-hak ini yang mudah dipahami: akses baca memungkinkan membaca konten (termasuk menyalin), akses menulis memungkinkan mengubah, dan akses mengeksekusi memungkinkan Anda untuk menjalankannya (yang hanya akan bekerja jika itu adalah sebuah program).
		</para>
		 <sidebar> <title><emphasis>KEAMANAN</emphasis> executable dengan <literal>setuid</literal> dan <literal>setgid</literal></title>
		 <para>
			Dua hak khusus relevan ke berkas yang dapat dieksekusi: <literal>setuid</literal> dan <literal>setgid</literal> (dilambangkan dengan huruf "s"). Perhatikan bahwa kita sering berbicara tentang "bit", karena setiap nilai-nilai boolean ini dapat diwakili oleh 0 atau 1. Dua hak ini memungkinkan pengguna untuk mengeksekusi program dengan hak-hak pemilik atau kelompok. Mekanisme ini memberikan akses ke fitur yang memerlukan izin tingkat yang lebih tinggi daripada yang Anda biasa miliki.
		</para>
		 <indexterm>
			<primary><literal>setuid</literal>, hak</primary>
		</indexterm>
		 <indexterm>
			<primary><literal>setgid</literal>, hak</primary>
		</indexterm>
		 <para>
			Karena program dengan <literal>setuid</literal> root secara sistematis berjalan di bawah identitas pengguna super, sangat penting untuk memastikan itu aman dan handal. Memang, pengguna yang akan berhasil membelokkan itu untuk memanggil perintah pilihan mereka kemudian bisa menyaru sebagai pengguna root dan memiliki semua hak pada sistem.
		</para>
		 </sidebar> <para>
			Direktori ditangani secara berbeda. Akses baca memberikan hak untuk berkonsultasi ke daftar entri (berkas dan direktori), akses tulis mengizinkan membuat atau menghapus berkas, dan akses mengeksekusi memungkinkan melintasinya (terutama untuk pergi ke sana dengan perintah <command>cd</command>). Mampu untuk melintasi sebuah direktori tanpa bisa membacanya memberikan izin untuk mengakses entri di dalamnya yang dikenal dengan nama, tetapi tidak untuk menemukan mereka jika Anda tidak tahu keberadaan mereka atau nama yang tepat.
		</para>
		 <sidebar id="sidebar.setgid-dir"> <title><emphasis>KEAMANAN</emphasis> direktori <literal>setgid</literal> dan <emphasis>bit sticky</emphasis></title>
		 <indexterm>
			<primary>direktori <literal>setgid</literal></primary>
		</indexterm>
		 <para>
			Bit <literal>setgid</literal> juga berlaku untuk direktori. Objek yang baru dibuat dalam direktori tersebut secara otomatis dimasukkan ke grup pemilik direktori induk, bukan mewarisi grup utama pencipta seperti biasa. Konfigurasi ini menghindari pengguna harus mengubah grup utama (dengan perintah <command>newgrp</command>) ketika bekerja di pohon berkas yang dipakai bersama antara beberapa pengguna dari grup khusus yang sama.
		</para>
		 <indexterm>
			<primary>bit sticky</primary>
		</indexterm>
		 <para>
			Bit "sticky" (dilambangkan dengan huruf "t") adalah izin yang hanya berguna dalam direktori. Hal ini terutama digunakan untuk direktori sementara tempat setiap orang memiliki akses tulis (seperti <filename>/tmp/</filename>): membatasi penghapusan berkas sehingga hanya pemilik (atau pemilik direktori induk) yang dapat melakukannya. Tanpa ini, semua orang bisa menghapus berkas milik pengguna lain dalam <filename>/tmp/</filename>.
		</para>
		 </sidebar> <para>
			Tiga perintah mengontrol izin yang terkait dengan berkas:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					<command>chown <replaceable>pengguna</replaceable> <replaceable>berkas</replaceable></command> mengubah pemilik berkas;
				</para>

			</listitem>
			 <listitem>
				<para>
					<command>chgrp <replaceable>grup</replaceable> <replaceable>berkas</replaceable></command> mengubah kelompok pemilik;
				</para>

			</listitem>
			 <listitem>
				<para>
					<command>chmod <replaceable>hak</replaceable> <replaceable>berkas</replaceable></command> mengubah izin untuk berkas.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Ada dua cara untuk menyajikan hak. Di antara mereka, representasi simbolik adalah mungkin yang paling mudah untuk dipahami dan diingat. Ini melibatkan huruf simbol yang disebutkan di atas. Anda bisa mendefinisikan hak untuk setiap kategori pengguna (<literal>u</literal> <literal>g</literal>/<literal>o</literal>), dengan menetapkan mereka secara eksplisit (dengan <literal>=</literal>), dengan menambahkan (<literal>+</literal>), atau mengurangi (<literal>-</literal>). Dengan demikian rumus <literal>u=rwx,g+rw,o-r</literal> memberikan pemilik hak baca, tulis, dan eksekusi, menambahkan hak baca dan tulis untuk pemilik grup, dan menghilangkan hak-hak baca untuk pengguna lain. Hak-hak yang tidak diubah oleh penambahan atau pengurangan dalam perintah tersebut tetap tak berubah. Huruf <literal>a</literal>, untuk "all/semua", mencakup semua kategori pengguna, sehingga <literal>a=rx</literal> menghibahkan ke ketiga kategori hak yang sama (membaca dan mengeksekusi, tapi tidak menulis).
		</para>
		 <indexterm>
			<primary><command>chmod</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>chown</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>chgrp</command></primary>
		</indexterm>
		 <indexterm>
			<primary>representasi oktal hak</primary>
		</indexterm>
		 <indexterm>
			<primary>hak</primary>
			<secondary>representasi oktal</secondary>
		</indexterm>
		 <para>
			Representasi numerik (oktal) mengasosiasikan hak masing-masing dengan suatu nilai: 4 untuk baca, 2 untuk tulis, dan 1 untuk eksekusi. Kita menghubungkan setiap kombinasi hak dengan menjumlah angka-angka. Setiap nilai kemudian ditugaskan untuk berbagai kategori pengguna dengan meletakkan mereka dalam urutan biasa (pemilik, kelompok, lain-lain).
		</para>
		 <para>
			Misalnya, perintah <command>chmod 754<replaceable>berkas</replaceable></command> akan menetapkan hak-hak berikut: baca, tulis dan, jalankan untuk pemilik (karena 7 = 4 + 2 + 1); baca dan jalankan untuk group (karena 5 = 4 + 1); hanya-baca untuk orang lain. <literal>0</literal> berarti tidak ada hak; dengan demikian <command>chmod 600<replaceable>berkas</replaceable></command> memungkinkan hak baca/tulis untuk pemilik, dan tidak ada hak untuk orang lain. Kombinasi tepat yang paling sering adalah <literal>755</literal> untuk berkas yang dapat dieksekusi dan direktori, dan <literal>644</literal> untuk berkas data.
		</para>
		 <para>
			Untuk mewakili hak khusus, Anda dapat memberi awalan digit keempat ke nomor ini sesuai dengan prinsip yang sama, dengan bit <literal>setuid</literal>, <literal>setgid</literal>, dan <literal>sticky</literal> masing-masing adalah 4, 2, dan 1. <command>chmod 4754</command> akan mengasosiasikan bit <literal>setuid</literal> dengan hak-hak yang dijelaskan sebelumnya.
		</para>
		 <para>
			Perhatikan bahwa penggunaan notasi oktal hanya memungkinkan untuk mengatur semua hak sekaligus pada berkas; Anda tidak dapat menggunakannya untuk menambahkan hak baru, seperti akses baca untuk pemilik grup, karena Anda harus memperhitungkan hak-hak yang ada dan menghitung nilai numerik baru yang sesuai.
		</para>
		 <sidebar> <title><emphasis>TIP</emphasis> Operasi rekursif</title>
		 <para>
			Kadang-kadang kita harus mengubah hak untuk seluruh pohon berkas. Semua perintah di atas memiliki opsi <literal>-R</literal> untuk beroperasi secara rekursif di sub-direktori.
		</para>
		 <para>
			Perbedaan antara direktori dan berkas kadang-kadang menyebabkan masalah dengan operasi rekursif. Itu sebabnya huruf "X" telah diperkenalkan di representasi simbolik dari hak-hak. Ini mewakili hak untuk menjalankan yang berlaku hanya untuk direktori (dan tidak untuk berkas yang tidak memiliki hak ini). Dengan demikian, <command>chmod -R a+X<replaceable>direktori</replaceable></command> hanya akan menambah hak mengeksekusi bagi semua kategori pengguna (<literal>a</literal>) untuk semua sub direktori dan berkas yang setidaknya satu kategori pengguna (bahkan jika pemilik satu-satunya) sudah memiliki hak mengeksekusi.
		</para>
		 </sidebar> <sidebar> <title><emphasis>TIP</emphasis> Mengubah pengguna dan grup</title>
		 <para>
			Sering Anda ingin mengubah kelompok berkas pada waktu yang sama dengan Anda mengubah pemilik. Perintah <command>chown</command> memiliki sintaks yang khusus untuk itu: <command>chown <replaceable>pengguna</replaceable>:<replaceable>kelompok</replaceable> <replaceable>berkas</replaceable></command>
		</para>
		 </sidebar> <sidebar> <title><emphasis>LEBIH LANJUT</emphasis> <command>umask</command></title>
		 <para>
			Ketika sebuah aplikasi menciptakan sebuah berkas, itu menetapkan izin indikatif, mengetahui bahwa sistem secara otomatis menghapus hak tertentu, yang diberikan oleh perintah <command>umask</command>. Masukkan <command>umask</command> dalam shell; Anda akan melihat sebuah mask seperti <computeroutput>0022</computeroutput>. Ini adalah sekadar representasi oktal hak untuk yang secara sistematis dihapus (dalam kasus ini, hak tulis untuk grup dan pengguna lain).
		</para>
		 <indexterm>
			<primary>umask</primary>
		</indexterm>
		 <indexterm>
			<primary>hak</primary>
			<secondary>mask</secondary>
		</indexterm>
		 <indexterm>
			<primary>mask</primary>
			<secondary>mask hak</secondary>
		</indexterm>
		 <para>
			Jika Anda memberikan nilai oktal baru, perintah <command>umask</command> memodifikasi mask. Digunakan dalam berkas inisialisasi shell (misalnya, <filename>~/.bash_profile</filename>), ini akan secara efektif mengubah mask baku untuk sesi kerja Anda.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.administration-interfaces">
		<title>Antarmuka Administrasi</title>
		 <indexterm>
			<primary>antarmuka</primary>
			<secondary>antarmuka administrasi</secondary>
		</indexterm>
		 <indexterm>
			<primary>administrasi, antarmuka</primary>
		</indexterm>
		 <para>
			Menggunakan antarmuka grafis untuk administrasi menarik di berbagai keadaan. Administrator tidak perlu mengetahui semua rincian konfigurasi untuk semua layanan mereka, dan tidak selalu punya waktu untuk pergi mencari dokumentasi tentang masalah. Antarmuka grafis untuk administrasi karenanya dapat mempercepat penyebaran layanan baru. Itu juga dapat menyederhanakan penyiapan layanan yang sulit untuk dikonfigurasi.
		</para>
		 <para>
			Sebuah antarmuka adalah hanya bantuan, dan bukan tujuan itu sendiri. Dalam semua kasus, administrator harus menguasai perilakunya untuk memahami dan mengatasi masalah potensial.
		</para>
		 <para>
			Karena tidak ada antarmuka yang sempurna, Anda mungkin tergoda untuk mencoba beberapa solusi. Ini harus dihindari sebisa mungkin, karena alat yang berbeda kadang-kadang tidak kompatibel dalam metode kerja mereka. Bahkan jika mereka semua bertujuan untuk menjadi sangat fleksibel dan mencoba untuk mengadopsi berkas konfigurasi sebagai referensi tunggal, mereka tidak selalu mampu mengintegrasikan perubahan-perubahan eksternal.
		</para>
		 <section id="sect.webmin">
			<title>Pengadministrasian pada Antarmuka Web: <command>webmin</command></title>
			 <indexterm>
				<primary><emphasis>webmin</emphasis></primary>
			</indexterm>
			 <para>
				Ini, tak diragukan lagi, adalah salah satu antarmuka administrasi yang paling sukses. Ini adalah sebuah sistem modular yang dikelola melalui peramban web, meliputi area dan peralatan yang luas. Lebih jauh, itu diinternasionalisasi dan tersedia dalam banyak bahasa.
			</para>
			 <para>
				Sayangnya, <command>webmin</command> tidak lagi merupakan bagian dari Debian. Para pengelola Debian — Jaldhar H. Vyas — menghapus paket yang diciptakannya karena ia tidak lagi memiliki waktu yang dibutuhkan untuk mempertahankan mereka pada tingkat kualitas yang dapat diterima. Tak seorang pun telah secara resmi mengambil alih, sehingga <emphasis role="distribution">Jessie</emphasis> tidak memiliki paket <command>webmin</command>.
			</para>
			 <para>
				Namun, ada sebuah paket tidak resmi yang didistribusikan pada <literal>webmin.com</literal> website. Bertentangan dengan paket-paket Debian asli, paket ini monolitik; semua modul konfigurasinya dipasang dan diaktifkan secara default, bahkan jika layanan yang sesuai tidak dipasang pada mesin.
			</para>
			 <sidebar> <title><emphasis>KEAMANAN</emphasis> Mengubah password root</title>
			 <para>
				Saat login pertama, identifikasi dilakukan dengan nama pengguna root dan kata sandi yang biasa. Dianjurkan untuk mengubah sandi yang digunakan untuk <command>webmin</command> secepat mungkin, sehingga jika itu disusupi, kata sandi root untuk server tidak akan terlibat, bahkan jika ini menganugerahkan hak administratif yang penting untuk mesin.
			</para>
			 <para>
				Berhati-hatilah! Karena <command>webmin</command> memiliki begitu banyak fitur, pengguna jahat yang mengakses itu dapat membahayakan keamanan seluruh sistem. Secara umum, antarmuka semacam ini tidak dianjurkan untuk sistem penting dengan kendala-kendala keamanan yang kuat (firewall, server sensitif, dll.).
			</para>
			 </sidebar> <para>
				Webmin digunakan melalui antarmuka web, tetapi tidak memerlukan Apache untuk diinstal. Pada dasarnya, perangkat lunak ini memiliki server web mini terpadu sendiri. Server ini mendengarkan secara default pada port 10000 dan menerima koneksi HTTP aman.
			</para>
			 <para>
				Modul-modul yang disertakan mencakup berbagai macam layanan, diantaranya:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						semua layanan dasar: penciptaan pengguna dan kelompok, manajemen berkas <filename>crontab</filename>, init script, melihat log, dll.
					</para>

				</listitem>
				 <listitem>
					<para>
						bind: konfigurasi server DNS (layanan nama);
					</para>

				</listitem>
				 <listitem>
					<para>
						postfix: konfigurasi server SMTP (e-mail);
					</para>

				</listitem>
				 <listitem>
					<para>
						inetd: konfigurasi server super <command>inetd</command>;
					</para>

				</listitem>
				 <listitem>
					<para>
						kuota: manajemen kuota pengguna;
					</para>

				</listitem>
				 <listitem>
					<para>
						dhcpd: konfigurasi server DHCP;
					</para>

				</listitem>
				 <listitem>
					<para>
						proftpd: konfigurasi server FTP;
					</para>

				</listitem>
				 <listitem>
					<para>
						samba: konfigurasi server berkas Samba;
					</para>

				</listitem>
				 <listitem>
					<para>
						perangkat lunak: instalasi atau penghapusan perangkat lunak dari paket-paket Debian dan pembaruan sistem.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Antarmuka administrasi tersedia di peramban web di <literal>https://localhost:10000</literal>. Berhati-hatilah! Tidak semua modul secara langsung dapat digunakan. Kadang-kadang mereka harus dikonfigurasi dengan menentukan lokasi berkas-berkas konfigurasi yang sesuai dan beberapa berkas yang dapat dieksekusi (program). Sering sistem secara sopan akan meminta Anda ketika gagal untuk mengaktifkan sebuah modul yang diminta.
			</para>
			 <sidebar> <title><emphasis>ALTERNATIF</emphasis> Pusat kendali GNOME</title>
			 <indexterm>
				<primary><emphasis role="pkg">gnome-control-center</emphasis></primary>
			</indexterm>
			 <para>
				Proyek GNOME juga menyediakan beberapa antarmuka administrasi yang biasanya dapat diakses melalui entri "Pengaturan" di menu pengguna di kanan atas. <command>gnome-control-center</command> adalah program utama yang membawa mereka bersama-sama tetapi banyak dari alat konfigurasi seluruh sistem secara efektif disediakan oleh paket lainnya (<emphasis role="pkg">accountsservice</emphasis>, <emphasis role="pkg">system-config-printer</emphasis>, dll). Meskipun mereka mudah digunakan, aplikasi ini mencakup hanya sejumlah terbatas layanan dasar: manajemen pengguna, konfigurasi waktu, konfigurasi jaringan, konfigurasi pencetak, dan sebagainya.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.debconf">
			<title>Mengkonfigurasi Paket: <command>debconf</command></title>
			 <indexterm>
				<primary><command>debconf</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>dpkg-reconfigure</command></primary>
			</indexterm>
			 <para>
				Banyak paket secara otomatis dikonfigurasi setelah mengajukan beberapa pertanyaan selama instalasi melalui alat Debconf. Paket-paket ini dapat dikonfigurasi ulang dengan menjalankan <command>dpkg-reconfigure <replaceable>paket</replaceable></command>.
			</para>
			 <para>
				Untuk kebanyakan kasus, pengaturan ini sangat sederhana; hanya beberapa variabel penting di berkas konfigurasi diganti. Variabel ini sering dikelompokkan antara dua garis "demarkasi" sehingga konfigurasi ulang paket hanya berdampak ke daerah tertentu. Dalam kasus lain, konfigurasi ulang tidak akan mengubah apa-apa jika skrip mendeteksi modifikasi manual berkas konfigurasi, dalam rangka untuk mempertahankan intervensi manusia ini (karena skrip tidak dapat memastikan bahwa modifikasinya tidak akan mengganggu pengaturan yang ada).
			</para>
			 <sidebar> <title><emphasis>KEBIJAKAN DEBIAN</emphasis> Melestarikan perubahan</title>
			 <para>
				Kebijakan Debian secara tegas menyebutkan bahwa segala sesuatu harus dilakukan untuk melestarikan perubahan manual yang dibuat untuk berkaskonfigurasi, maka semakin banyak skrip yang mengambil tindakan pencegahan saat menyunting berkas konfigurasi. Prinsip umumnya sederhana: skrip hanya akan membuat perubahan jika itu tahu status berkas konfigurasi yang diverifikasi dengan membandingkan checksum berkas terhadap berkas yang terakhir dikonfigurasi secara otomatis. Jika mereka sama, skrip berwenang untuk mengubah berkaskonfigurasi. Jika tidak, itu menganggap bahwa berkas telah berubah dan bertanya apa tindakan yang diperlukan (menginstal berkas baru, menyimpan berkas lama, atau mencoba untuk mengintegrasikan perubahan baru dengan berkas yang sudah ada). Prinsip pencegahan ini telah lama unik untuk Debian, tetapi distro lain secara bertahap mulai menerimanya.
			</para>
			 <para>
				Program <command>ucf</command> (dari paket Debian dengan nama yang sama) dapat digunakan untuk menerapkan perilaku seperti itu.
			</para>
			 <indexterm>
				<primary><command>ucf</command></primary>
			</indexterm>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.syslog">
		<title><command>syslog</command> Kejadian Sistem</title>
		 <indexterm>
			<primary><command>rsyslogd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>berkas</primary>
			<secondary>berkas log</secondary>
		</indexterm>
		 <indexterm>
			<primary>log</primary>
			<secondary>pengiriman</secondary>
		</indexterm>
		 <section id="sect.syslog-principe">
			<title>Prinsip dan Mekanisme</title>
			 <para>
				Daemon <command>rsyslogd</command> bertanggung jawab untuk mengumpulkan pesan layanan yang berasal dari aplikasi dan kernel, lalu mengirim mereka ke dalam berkas log (biasanya disimpan dalam direktori <filename>/var/log/</filename>). Ini mematuhi berkas konfigurasi <filename>/etc/rsyslog.conf</filename>.
			</para>
			 <para>
				Setiap pesan log terkait dengan suatu subsistem aplikasi (disebut 'fasilitas' dalam dokumentasi):
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>auth</literal> dan <literal>authpriv</literal>: untuk otentikasi;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>cron</literal>: berasal dari layanan penjadwalan tugas, <command>cron</command> dan <command>atd</command>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>daemon</literal>: mempengaruhi daemon tanpa klasifikasi khusus apapun (DNS, NTP, dll);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ftp</literal>: menyangkut server FTP;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>kern</literal>: pesan yang datang dari kernel;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>lpr</literal>: berasal dari subsistem pencetakan;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>mail</literal>: berasal dari subsistem surel;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>news</literal>: pesan subsistem Usenet (terutama dari NNTP — Network News Transfer Protocol — server yang mengelola newsgroup);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>syslog</literal>: pesan-pesan dari server <command>syslogd</command> itu sendiri;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>user</literal>: pesan-pesan pengguna (generik);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uucp</literal>: pesan dari server UUCP (Unix to Unix Copy Program, protokol tua yang terutama digunakan untuk mendistribusikan pesan surel);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>local0</literal> sampai <literal>local7</literal>: disediakan untuk penggunaan lokal.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Setiap pesan ini juga dikaitkan dengan tingkat prioritas. Berikut adalah daftar yang terurut turun:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>emerg</literal>: "Tolong!" Ada keadaan darurat, sistem ini mungkin tidak dapat digunakan.
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>alert</literal>: buru-buru, penundaan bisa berbahaya, tindakan harus diambil segera;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>crit</literal>: kondisi kritis;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>err</literal>: kesalahan;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>warn</literal>: peringatan (potensi kesalahan);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>notice</literal>: kondisi normal, tapi pesan tersebut penting;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>info</literal>: pesan informatif;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>debug</literal>: pesan pengawakutuan (debug).
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section id="sect.syslog-config">
			<title>Berkas Konfigurasi</title>
			 <para>
				Sintaks berkas <filename>/etc/rsyslog.conf</filename> dirinci dalam halaman manual <citerefentry><refentrytitle>rsyslog.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>, tetapi ada juga dokumentasi HTML yang tersedia di paket <emphasis role="pkg">rsyslog-doc</emphasis> (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). Prinsip keseluruhan adalah untuk menulis pasangan "pemilih" dan "tindakan". Pemilih mendefinisikan semua pesan yang relevan, dan tindakan yang menjelaskan bagaimana menangani mereka.
			</para>
			 <section id="sect.syslog-selector-syntax">
				<title>Sintaks dari Pemilih</title>
				 <para>
					Pemilih adalah sebuah daftar pasangan yang dipisah titik koma <literal><replaceable>subsistem</replaceable>.<replaceable>prioritas</replaceable></literal> (contoh: <literal>auth.notice;mail.info</literal>). Bintang dapat mewakili semua subsistem atau semua prioritas (contoh: <literal>*.alert</literal> atau <literal>mail.*</literal>). Beberapa subsistem dapat dikelompokkan, dengan memisahkan mereka dengan tanda koma (contoh: <literal>auth,mail.info</literal>). Prioritas yang ditunjukkan juga mencakup pesan prioritas yang sama atau lebih tinggi; dengan demikian <literal>auth.alert</literal> menunjukkan subsistem pesan <literal>auth</literal> dengan prioritas <literal>alert</literal> atau <literal>emerg</literal>. Diawali dengan tanda seru (!), ini menunjukkan sebaliknya, dengan kata lain hanya prioritas yang lebih rendah; <literal>auth.!notice</literal>, dengan demikian, menunjukkan pesan yang dikeluarkan dari <literal>auth</literal>, dengan prioritas <literal>info</literal> atau <literal>debug</literal>. Diawali dengan tanda sama dengan (=), sesuai dengan hanya prioritas ditunjukkan (<literal>oauth.=notice</literal> pesan dari <literal>auth</literal> ini hanya berkenaan dengan prioritas <literal>notice</literal>).
				</para>
				 <para>
					Setiap elemen dalam daftar pada pemilih menimpa unsur-unsur sebelumnya. Dengan demikian dimungkinkan untuk membatasi satu set atau untuk mengecualikan unsur-unsur tertentu dari itu. Sebagai contoh, <literal>kern.info;kern.!err</literal> berarti pesan dari kernel dengan prioritas antara <literal>info</literal> dan <literal>warn</literal>. Prioritas <literal>none</literal> menunjukkan kumpulan kosong (tidak ada prioritas), dan dapat dipakai untuk mengecualikan subsistem dari serangkaian pesan. Dengan demikian, <literal>*. crit;kern.none</literal> menunjukkan semua pesan prioritas yang sama dengan atau lebih tinggi dari <literal>crit</literal> yang bukan berasal dari kernel.
				</para>

			</section>
			 <section id="sect.syslog-action-syntax">
				<title>Sintaks Tindakan</title>
				 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Pipa bernama (named pipe), pipa persisten</title>
				 <indexterm>
					<primary>named pipe</primary>
				</indexterm>
				 <indexterm>
					<primary>pipe, named pipe</primary>
				</indexterm>
				 <para>
					Pipa bernama adalah berkas jenis khusus yang beroperasi seperti pipa tradisional (pipa yang Anda buat dengan simbol "|" pada baris perintah), tetapi melalui berkas. Mekanisme ini memiliki keuntungan yang mampu menghubungkan dua proses yang tidak terkait. Apa pun yang ditulis ke pipa bernama memblokir proses yang menulis sampai proses lain berusaha untuk membaca data yang dituliskan. Proses kedua ini membaca data yang ditulis oleh yang pertama, yang kemudian dapat melanjutkan eksekusi.
				</para>
				 <para>
					Berkas seperti itu dibuat dengan perintah <command>mkfifo</command>.
				</para>
				 </sidebar> <para>
					Berbagai tindakan yang mungkin adalah:
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							menambahkan pesan ke berkas (contoh: <filename>/var/log/messages</filename>);
						</para>

					</listitem>
					 <listitem>
						<para>
							mengirim pesan ke server <command>syslog</command> remote (contoh: <literal>@log.falcot.com</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							mengirim pesan ke pipa bernama yang ada (contoh: <literal>|/dev/xconsole</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							mengirim pesan ke satu atau lebih pengguna, jika mereka login (contoh: <literal>root, rhertzog</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							mengirim pesan ke semua pengguna yang login (contoh: <literal>*</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							menulis pesan dalam konsol teks (contoh: <literal>/dev/tty8</literal>).
						</para>

					</listitem>

				</itemizedlist>
				 <sidebar> <title><emphasis>KEAMANAN</emphasis> Meneruskan log</title>
				 <indexterm>
					<primary>log</primary>
					<secondary>meneruskan</secondary>
				</indexterm>
				 <para>
					Ini adalah ide yang baik untuk merekam log-log yang paling penting pada mesin terpisah (mungkin didedikasikan untuk tujuan ini), karena ini akan mencegah penyusup apapun mungkin menghapus jejak-jejak intrusi mereka (kecuali, tentu saja, mereka juga mengkompromi server lain ini). Selanjutnya, dalam hal masalah besar (seperti kernel crash), Anda memiliki log yang tersedia pada mesin lain, yang akan meningkatkan kesempatan Anda untuk menentukan urutan peristiwa yang menyebabkan crash.
				</para>
				 <para>
					Untuk menerima log pesan yang dikirim oleh mesin lainnya, Anda harus mengkonfigurasi ulang <emphasis>rsyslog</emphasis>: dalam praktek, cukup untuk mengaktifkan entri siap pakai dalam <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> dan <literal>$UDPServerRun 514</literal>).
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.inetd">
		<title>Super Server <command>inetd</command></title>
		 <para>
			Inetd (sering disebut "Internet super-server") adalah sebuah server dari server. Itu mengeksekusi server yang jarang digunakan sesuai permintaan, sehingga mereka tidak perlu berjalan terus menerus.
		</para>
		 <indexterm>
			<primary><command>inetd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>super-server</primary>
		</indexterm>
		 <para>
			Berkas <filename>/etc/inetd.conf</filename> memuat daftar server tersebut dan nomor port biasa mereka. Perintah <command>inetd</command> mendengarkan semua dari mereka; ketika mendeteksi koneksi ke salah satu port tersebut, itu mengeksekusi program server yang sesuai.
		</para>
		 <sidebar> <title><emphasis>KEBIJAKAN DEBIAN</emphasis> Mendaftarkan suatu server di <filename>inetd.conf</filename></title>
		 <para>
			Paket seringkali ingin mendaftarkan server baru dalam berkas <filename>/etc/inetd.conf</filename>, tetapi Kebijakan Debian melarang setiap paket memodifikasi berkas konfigurasi yang bukan milik sendiri. Inilah sebabnya mengapa skrip <command>update-inetd</command> (dalam paket dengan nama yang sama) dibuat: mengelola berkas konfigurasi, maka paket lain dapat menggunakannya untuk mendaftarkan server baru ke konfigurasi super-server.
		</para>
		 </sidebar> <para>
			Setiap baris yang signifikan dari berkas <filename>/etc/inetd.conf</filename> menggambarkan sebuah server melalui tujuh ruas (yang dipisah dengan spasi):
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					Nomor port TCP atau UDP, atau nama layanan (yang dipetakan ke nomor port standar dengan informasi yang terkandung dalam berkas <filename>/etc/services</filename>).
				</para>

			</listitem>
			 <listitem>
				<para>
					Jenis soket: <literal>stream</literal> untuk koneksi TCP, <literal>dgram</literal> untuk datagram UDP.
				</para>

			</listitem>
			 <listitem>
				<para>
					Protokol: <literal>tcp</literal> atau <literal>udp</literal>.
				</para>

			</listitem>
			 <listitem>
				<para>
					Pilihan: dua nilai yang mungkin: <literal>wait</literal> atau <literal>nowait</literal>, untuk memberitahu <command>inetd</command> apakah itu harus menunggu atau tidak untuk akhir dari proses diluncurkan sebelum menerima koneksi lain. Untuk koneksi TCP, yang mudah dimultiplekskan, Anda dapat biasanya menggunakan <literal>nowait</literal>. Untuk program yang merespon melalui UDP, Anda harus menggunakan <literal>nowait</literal> hanya jika server mampu mengelola beberapa koneksi secara paralel. Anda dapat menambahkan akhiran pada ruas ini dengan titik dua, diikuti oleh jumlah maksimum koneksi resmi per menit (batas default adalah 256).
				</para>

			</listitem>
			 <listitem>
				<para>
					Nama pengguna yang di bawah identitasnya server akan berjalan.
				</para>

			</listitem>
			 <listitem>
				<para>
					Path lengkap ke program server yang akan dijalankan.
				</para>

			</listitem>
			 <listitem>
				<para>
					Argumen: ini adalah daftar lengkap dari argumen program, termasuk nama sendiri (<literal>argv[0]</literal> dalam C).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Contoh berikut menggambarkan kasus-kasus yang paling umum:
		</para>
		 <example id="example.inetd-conf">
			<title>Kutipan dari <filename>/etc/inetd.conf</filename></title>
			 
<programlisting>talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd
finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd
ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i</programlisting>

		</example>
		 <indexterm>
			<primary><command>tcpd</command></primary>
		</indexterm>
		 <para>
			Program <command>tcpd</command> sering digunakan dalam berkas <filename>/etc/inetd.conf</filename>. Hal ini memungkinkan membatasi koneksi masuk dengan menerapkan aturan kontrol akses, didokumentasikan di halaman manual <citerefentry><refentrytitle>hosts_access</refentrytitle>
			<manvolnum>5</manvolnum></citerefentry>, yang dikonfigurasi di berkas <filename>/etc/hosts.allow</filename> dan <filename>/etc/hosts.deny</filename>. Setelah ditentukan bahwa sambungan diizinkan, <command>tcpd</command> mengeksekusi server sebenarnya (seperti <command>in.fingerd</command> dalam contoh kita). Perlu dicatat bahwa <command>tcpd</command> mengandalkan nama apa dia dipanggil (yaitu argumen pertama, <literal>argv [0]</literal>) untuk mengidentifikasi program nyata yang akan dijalankan. Jadi Anda tidak harus memulai daftar argumen dengan <literal>tcpd</literal> tapi dengan program yang harus dibungkus.
		</para>
		 <sidebar> <title><emphasis>KOMUNITAS</emphasis> Wietse Venema</title>
		 <indexterm>
			<primary>Wietse Venema</primary>
		</indexterm>
		 <indexterm>
			<primary>Venema, Wietse</primary>
		</indexterm>
		 <para>
			Wietse Venema, yang keahliannya dalam keamanan telah membuatnya menjadi programmer yang terkenal, adalah penulis program <command>tcpd</command>. Ia adalah pencipta utama Postfix, server modular surel (SMTP, Simple Mail Transfer Protocol), yang dirancang untuk menjadi lebih aman dan lebih dapat diandalkan daripada <command>sendmail</command>, yang memiliki sejarah panjang kerentanan keamanan.
		</para>
		 </sidebar> <sidebar> <title><emphasis>ALTERNATIF</emphasis> Perintah <command>inetd</command> lain</title>
		 <para>
			Walaupun Debian menginstal <emphasis role="pkg">openbsd-inetd</emphasis> secara default, ada tidak ada kekurangan alternatif: kita dapat menyebutkan <emphasis role="pkg">inetutils-inetd</emphasis>, <emphasis role="pkg">micro-inetd</emphasis>, <emphasis role="pkg">rlinetd</emphasis>, dan <emphasis role="pkg">xinetd</emphasis>.
		</para>
		 <para>
			Inkarnasi ini terakhir server super menawarkan kemungkinan yang sangat menarik. Paling menonjol, konfigurasinya dapat dibagi menjadi beberapa berkas (disimpan, tentu saja, dalam direktori <filename>/etc/xinetd.d/</filename>), yang dapat membuat hidup seorang administrator lebih mudah.
		</para>
		 <para>
			Terakhir tetapi bukan tidak penting, bahkan mungkin untuk meniru perilaku <command>inetd</command> dengan mekanisme aktivasi soket <command>systemd</command> (Lihat <xref linkend="sect.systemd" />).
		</para>
		 </sidebar>
	</section>
	 <section id="sect.task-scheduling-cron-atd">
		<title>Menjadwalkan Tugas dengan <command>cron</command> dan <command>atd</command></title>
		 <indexterm>
			<primary><command>cron</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>atd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>perintah-perintah yang dijadwalkan</primary>
		</indexterm>
		 <indexterm>
			<primary>penjadwalan perintah</primary>
		</indexterm>
		 <para>
			<command>cron</command> adalah daemon yang bertanggung jawab untuk mengeksekusi perintah terjadwal dan berulang (setiap hari, setiap minggu, dll.); <command>atd</command> adalah yang berurusan dengan perintah yang akan dieksekusi sekali, tapi pada waktu tertentu di masa depan.
		</para>
		 <para>
			Dalam sistem Unix, banyak tugas yang dijadwalkan untuk dieksekusi berkala:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					merotasi log;
				</para>

			</listitem>
			 <listitem>
				<para>
					memperbarui basis data untuk program <command>locate</command>;
				</para>

			</listitem>
			 <listitem>
				<para>
					back-up;
				</para>

			</listitem>
			 <listitem>
				<para>
					skrip pemeliharaan (misalnya pembersihan berkas sementara).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Secara default, semua pengguna dapat menjadwalkan pelaksanaan tugas. Dengan demikian, setiap pengguna memiliki sendiri <emphasis>crontab</emphasis> di mana mereka dapat merekam perintah yang dijadwalkan. Ini dapat diedit dengan menjalankan <command>crontab -e</command> (isinya disimpan dalam berkas <filename>/var/spool/cron/crontabs/<replaceable>pengguna</replaceable></filename>).
		</para>
		 <sidebar> <title><emphasis>KEAMANAN</emphasis> Membatasi <command>cron</command> atau <command>atd</command></title>
		 <para>
			Anda dapat membatasi akses ke <command>cron</command> dengan membuat berkas otorisasi eksplisit (whitelist) di <filename>/etc/cron.allow</filename>, di mana Anda menunjukkan hanya pengguna yang berwenang untuk menjadwalkan perintah. Semua yang lain akan secara otomatis kehilangan fitur ini. Sebaliknya, hanya untuk memblokir satu atau dua pengacau, Anda bisa menulis nama mereka dalam file larangan eksplisit (blacklist), <filename>/etc/cron.deny</filename>. Fitur yang sama tersedia untuk <command>atd</command>, dengan berkas <filename>/etc/at.allow</filename> dan <filename>/etc/at.deny</filename>.
		</para>
		 </sidebar> <para>
			Pengguna root punya <emphasis>crontab</emphasis> mereka sendiri, tapi dapat juga menggunakan berkas <filename>/etc/crontab</filename>, atau menulis berkas <emphasis>crontab</emphasis> tambahan dalam direktori <filename>/etc/cron.d</filename>. Dua solusi terakhir ini memiliki keuntungan menjadi dapat menentukan identitas pengguna yang dimanfaatkan ketika mengeksekusi perintah.
		</para>
		 <para>
			Paket <emphasis>cron</emphasis> termasuk secara default beberapa perintah terjadwal yang mengeksekusi:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					program-program dalam direktori <filename>/etc/cron.hourly/</filename> sekali per jam;
				</para>

			</listitem>
			 <listitem>
				<para>
					program-program di <filename>/etc/cron.daily/</filename> sekali per hari;
				</para>

			</listitem>
			 <listitem>
				<para>
					program-program di <filename>/etc/cron.weekly/</filename> sekali per minggu;
				</para>

			</listitem>
			 <listitem>
				<para>
					program-program di <filename>/etc/cron.monthly/</filename> sekali per bulan.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Banyak paket Debian yang banyak bergantung pada layanan ini: dengan menempatkan skrip pemeliharaan dalam direktori ini, mereka memastikan pengoperasian yang optimal atas layanan mereka.
		</para>
		 <section id="sect.format-crontab">
			<title>Format dari sebuah Berkas <filename>crontab</filename></title>
			 <indexterm>
				<primary><filename>crontab</filename></primary>
			</indexterm>
			 <sidebar> <title><emphasis>TIP</emphasis> Pintasan teks untuk <command>cron</command></title>
			 <para>
				<command>cron</command> mengenali beberapa singkatan yang menggantikan lima ruas pertama dalam entri <filename>crontab</filename>. Mereka sesuai dengan pilihan penjadwalan yang paling klasik:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>@yearly</literal>: sekali per tahun (1 Januari, pukul 24:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@monthly</literal>: sekali per bulan (tanggal 1, pukul 24:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@weekly</literal>: sekali per minggu (hari Minggu pukul 24:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@daily</literal>: sekali per hari (pukul 24:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@hourly</literal>: sekali per jam (pada permulaan setiap jam).
					</para>

				</listitem>

			</itemizedlist>
			 </sidebar> <sidebar> <title><emphasis>KASUS KHUSUS</emphasis> <command>cron</command> dan daylight saving time</title>
			 <para>
				Di Debian, <command>cron</command> memperhitungkan perubahan waktu (Daylight Savings Time, atau bahkan untuk perubahan signifikan dalam waktu setempat) sebaik mungkin. Dengan demikian, perintah yang harus dilaksanakan selama satu jam yang tidak pernah ada (misalnya, tugas-tugas yang dijadwalkan di 2:30 selama musim semi waktu perubahan di Perancis, karena pada pukul 2:00 waktu melompat secara langsung ke 3:00) dijalankan tak lama setelah perubahan waktu (dengan demikian sekitar 3:00 am DST). Di sisi lain, di musim gugur, ketika perintah akan dijalankan beberapa kali (2:30 am DST, kemudian sejam kemudian di 2:30 am waktu standar, karena pada 3:00 am DST jam berubah kembali untuk 2:00 am) hanya dilakukan sekali.
			</para>
			 <para>
				Namun hati-hati, jika urutan antara tugas berbeda yang dijadwalkan dan penundaan antara eksekusi mereka masing-masing penting, Anda harus memeriksa kompatibilitas kendala dengan perilaku <command>cron</command>; jika perlu, Anda dapat mempersiapkan jadwal khusus untuk dua malam bermasalah per tahun.
			</para>
			 </sidebar> <para>
				Setiap baris yang signifikan dari <emphasis>crontab</emphasis> menggambarkan perintah yang dijadwalkan dengan enam (atau tujuh) ruas berikut:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						nilai untuk menit (angka dari 0-59);
					</para>

				</listitem>
				 <listitem>
					<para>
						nilai untuk jam (dari 0 sampai 23);
					</para>

				</listitem>
				 <listitem>
					<para>
						nilai untuk tanggal (dari 1 sampai 31);
					</para>

				</listitem>
				 <listitem>
					<para>
						nilai untuk bulan (dari 1 untuk 12);
					</para>

				</listitem>
				 <listitem>
					<para>
						nilai hari pada suatu minggu (dari 0 sampai 7, 1 berarti Senin, Minggu diwakili oleh 0 atau 7; juga dimungkinkan untuk menggunakan tiga huruf pertama dari nama hari dalam seminggu dalam bahasa Inggris, seperti <literal>Sun</literal>, <literal>Mon</literal>, dll.);
					</para>

				</listitem>
				 <listitem>
					<para>
						nama pengguna yang identitasnya akan dipakai untuk menjalankan perintah (di berkas <filename>/etc/crontab</filename> dan dalam fragmen yang terletak di <filename>/etc/cron.d/</filename>, tetapi tidak di berkas crontab pengguna sendiri);
					</para>

				</listitem>
				 <listitem>
					<para>
						perintah yang akan dilaksanakan (ketika kondisi yang didefinisikan oleh ke lima kolom pertama terpenuhi).
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Semua rincian ini didokumentasikan di halaman manual <citerefentry><refentrytitle>crontab</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry>.
			</para>
			 <para>
				Setiap nilai dapat dinyatakan dalam bentuk daftar nilai yang mungkin (dipisahkan dengan koma). Sintaks <literal>a-b</literal> menjelaskan interval semua nilai antara <literal>a</literal> dan <literal>b</literal>. Sintaks <literal>a-b/c</literal> menggambarkan interval dengan kenaikan <literal>c</literal> (contoh: <literal>0-10/2</literal> berarti <literal>0,2,4,6,8,10</literal>). Asterisk <literal>*</literal> adalah wildcard, mewakili semua nilai yang mungkin.
			</para>
			 <example id="example.crontab">
				<title>Sampel berkas <filename>crontab</filename></title>
				 
<programlisting>#Format
#men jam tgl bln hrmg  perintah

# Unduh data setiap malam pada pukul 19:25
 25  19   *   *   *    $HOME/bin/ambil.pl

# 8:00, pada hari kerja (Senin sampai Jumat)
 00  08   *   *   1-5  $HOME/bin/lakukansesuatu

# Jalankan ulang proksi IRC setiap setelah reboot
@reboot /usr/bin/dircproxy</programlisting>

			</example>
			 <sidebar> <title><emphasis>TIPS</emphasis> Mengeksekusi perintah saat boot</title>
			 <para>
				Untuk mengeksekusi perintah sekali saja, hanya setelah komputer boot, Anda dapat menggunakan makro <literal>@reboot</literal> (sekadar merestart <command>cron</command> tidak memicu perintah yang dijadwalkan dengan <literal>@reboot</literal>). Makro ini menggantikan lima ruas entri pertama di <emphasis>crontab</emphasis>.
			</para>
			 </sidebar> <sidebar> <title><emphasis>ALTERNATIF</emphasis> Mengemulasi <command>cron</command> dengan <command>systemd</command></title>
			 <para>
				Mungkin untuk meniru sebagian perilaku <command>cron</command> dengan mekanisme timer <command>systemd</command> (Lihat <xref linkend="sect.systemd" />).
			</para>
			 </sidebar>
		</section>
		 <section id="sect.at-command">
			<title>Menggunakan Perintah <command>at</command></title>
			 <indexterm>
				<primary><command>at</command></primary>
			</indexterm>
			 <para>
				<command>at</command> mengeksekusi perintah pada saat tertentu di masa depan. Ini membutuhkan masukan waktu dan tanggal sebagai parameter baris perintah, dan perintah akan dieksekusi di masukan standar. Perintah akan dieksekusi seolah-olah itu telah dimasukkan di shell saat ini. <command>at</command> bahkan mempertahankan lingkungan saat ini, untuk mereproduksi kondisi yang sama ketika itu mengeksekusi perintah. Waktu ditunjukkan dengan mengikuti konvensi biasa: <literal>16:12</literal> atau <literal>4:12 pm</literal> mewakili 4:12 pm. Tanggal dapat ditentukan dalam beberapa format Eropa dan Barat, termasuk <literal>DD. MM. YY</literal> (<literal>27.07.15</literal> dengan demikian mewakili 27 Juli 2015), <literal>YYYY-MM-DD</literal> (tanggal yang sama ini dinyatakan sebagai <literal>2015-07-27</literal>), <literal>MM/DD/ [CC]YY</literal> (yaitu, <literal>12/25/15</literal> atau <literal>12/25/2015</literal> akan menjadi 25 Desember 2015), atau sekadar <literal>MMDD[CC]YY</literal> (Jadi <literal>122515</literal> atau <literal>12252015</literal> akan juga mewakili 25 Desember 2015). Tanpa itu, perintah akan dilaksanakan segera setelah jam mencapai waktu yang ditunjukkan (hari yang sama, atau besok jika waktu itu telah melewati pada hari yang sama). Anda juga dapat menulis "today (hari ini)" atau "tomorrow (besok)", yang sudah cukup jelas.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>
<computeroutput>&gt; </computeroutput><userinput>echo "Don't forget to wish a Happy Birthday to Raphaël!" \</userinput>
<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>
<computeroutput>&gt; </computeroutput><userinput>END</userinput>
<computeroutput>warning: commands will be executed using /bin/sh
job 31 at Mon Jul 27 09:00:00 2015</computeroutput></screen>
			 <para>
				Suatu sintaks alternatif menunda eksekusi untuk durasi tertentu: <command>at now + <replaceable>angka</replaceable> <replaceable>periode</replaceable></command>. <replaceable>periode</replaceable> bisa berupa <literal>minutes</literal> (menit), <literal>hours</literal> (jam), <literal>days</literal> (hari), atau <literal>weeks</literal> (minggu). <replaceable>angka</replaceable> hanya menunjukkan banyaknya unit yang harus dilalui sebelum pelaksanaan perintah.
			</para>
			 <para>
				Untuk membatalkan tugas yang dijadwalkan oleh <command>cron</command>, cukup menjalankan <command>crontab -e</command> dan menghapus baris yang sesuai dalam berkas <emphasis>crontab</emphasis>. Untuk tugas <command>at</command>, hampir sama mudahnya: jalankan <command>atrm <replaceable>nomor-tugas</replaceable></command>. Nomor tugas ditunjukkan oleh perintah <command>at</command> saat Anda menjadwalkan itu, tetapi Anda dapat menemukannya lagi dengan perintah <command>atq</command>, yang memberikan daftar tugas terjadwal.
			</para>
			 <indexterm>
				<primary><command>atrm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>atq</command></primary>
			</indexterm>

		</section>

	</section>
	 <section id="sect.asynchronous-task-scheduling-anacron">
		<title>Menjadwalkan Tugas-tugas Asinkron: <command>anacron</command></title>
		 <para>
			<command>anacron</command> adalah daemon yang melengkapi <command>cron</command> untuk komputer yang tidak menyala setiap saat. Karena tugas-tugas rutin biasanya dijadwalkan untuk dieksekusi di tengah malam, mereka akan tidak pernah dijalankan jika komputer pada waktu itu. Tujuan <command>anacron</command> adalah untuk mengeksekusi mereka, mempertimbangkan periode saat komputer tidak bekerja.
		</para>
		 <indexterm>
			<primary><command>anacron</command></primary>
		</indexterm>
		 <para>
			Harap dicatat bahwa <command>anacron</command> sering akan melaksanakan kegiatan tersebut beberapa menit setelah komputer boot, yang dapat membuat komputer kurang responsif. Inilah sebabnya mengapa tugas-tugas di berkas <filename>/etc/anacrontab</filename> dimulai dengan perintah <command>nice</command>, yang mengurangi prioritas eksekusi mereka dan dengan demikian membatasi dampak mereka di seluruh sistem. Berhati-hatilah, format berkas ini tidak sama dengan <filename>/etc/crontab</filename>; jika Anda memiliki kebutuhan khusus untuk <command>anacron</command>, lihat halaman manual <citerefentry><refentrytitle>anacrontab</refentrytitle>
			<manvolnum>5</manvolnum></citerefentry>.
		</para>
		 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Prioritas dan <command>nice</command></title>
		 <para>
			Sistem Unix (dan dengan demikian Linux) adalah sistem multi-tasking dan multi-user. Memang, beberapa proses dapat berjalan secara paralel, dan dimiliki oleh pengguna yang berbeda: kernel menengahi akses ke sumber daya antara proses yang berbeda. Sebagai bagian dari tugas ini, ada konsep prioritas, yang memungkinkan untuk lebih mendukung proses tertentu daripada yang lain, sesuai kebutuhan. Ketika Anda tahu bahwa proses dapat berjalan dalam prioritas rendah, Anda dapat menunjukkannya dengan menjalankan <command>nice <replaceable>program</replaceable></command>. Program akan memiliki bagian lebih kecil dari CPU, dan akan memiliki dampak yang lebih kecil pada proses berjalan lainnya. Tentu saja, jika tidak ada proses lain yang perlu berjalan, program itu tidak akan dihambat.
		</para>
		 <para>
			<command>nice</command> bekerja dengan tingkat "niceness": tingkat positif (dari 1 sampai 19) semakin menurunkan prioritas, sementara tingkat negatif (dari -1 untuk-20) akan meningkatkan — tetapi hanya root yang dapat menggunakan tingkat negatif ini. Kecuali jika dinyatakan (lihat halaman manual <citerefentry><refentrytitle>nice</refentrytitle>
			 <manvolnum>1</manvolnum></citerefentry>), <command>nice</command> menaikkan tingkat saat ini sebanyak 10.
		</para>
		 <para>
			Jika Anda menemukan bahwa tugas yang sudah berjalan seharusnya dimulai dengan <command>nice</command> tidaklah terlalu terlambat untuk memperbaikinya; perintah <command>renice</command> mengubah prioritas proses yang sudah berjalan, di kedua arah (tapi mengurangi nilai "nice" proses hanya disediakan untuk pengguna root).
		</para>
		 </sidebar> <para>
			Instalasi paket <emphasis role="pkg">anacron</emphasis> menonaktifkan eksekusi oleh skrip <command>cron</command> di direktori <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename>, dan <filename>/etc/cron.monthly/</filename>. Ini menghindari eksekusinya ganda oleh <command>anacron</command> dan <command>cron</command>. Perintah <command>cron</command> tetap aktif dan akan terus menangani tugas terjadwal lain (terutama mereka yang dijadwalkan oleh pengguna).
		</para>

	</section>
	 <section id="sect.quotas">
		<title>Kuota</title>
		 <indexterm>
			<primary>kuota</primary>
		</indexterm>
		 <para>
			Sistem kuota memungkinkan membatasi ruang disk yang dialokasikan ke pengguna atau grup pengguna. Untuk mengatur itu, Anda harus memiliki sebuah kernel yang mendukung (dikompail dengan opsi <varname>CONFIG_QUOTA</varname>) — seperti halnya kernel Debian. Perangkat lunak manajemen kuota ada dalam paket Debian <emphasis role="pkg">quota</emphasis>.
		</para>
		 <para>
			Untuk mengaktifkan kuota di sebuah sistem berkas, Anda harus menyatakan pilihan <literal>usrquota</literal> dan <literal>grpquota</literal> di <filename>/etc/fstab</filename> masing-masing untuk kuota pengguna dan grup. Setelah reboot komputer kemudian akan memperbarui kuota ketika tidak ada kegiatan disk (kondisi yang diperlukan untuk akuntansi yang tepat dari ruang disk yang sudah digunakan).
		</para>
		 <para>
			Perintah <command>edquota <replaceable>pengguna</replaceable></command> (atau <command>edquota -g <replaceable>kelompok</replaceable></command>) memungkinkan Anda untuk mengubah batas ketika memeriksa penggunaan disk saat ini.
		</para>
		 <indexterm>
			<primary><command>edquota</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>LEBIH LANJUT</emphasis> Menentukan kuota dengan suatu skrip</title>
		 <indexterm>
			<primary><command>setquota</command></primary>
		</indexterm>
		 <para>
			Program <command>setquota</command> dapat digunakan dalam skrip untuk secara otomatis mengubah banyak kuota. Halaman manual <citerefentry><refentrytitle>setquota</refentrytitle>
			 <manvolnum>8</manvolnum></citerefentry> merinci sintaks yang digunakan.
		</para>
		 </sidebar> <para>
			Sistem kuota memungkinkan Anda untuk mengatur empat batas:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					dua batas (disebut "lunak" dan "keras") mengacu pada jumlah blok yang dikonsumsi. Jika sistem berkas diciptakan dengan ukuran blok 1 kibibyte, blok berisi 1024 byte dari berkas yang sama. Blok tak penuh akan menyebabkan kerugian ruang disk. Kuota 100 blok, yang secara teoritis memungkinkan penyimpanan 102,400 byte, akan jenuh dengan hanya 100 berkas yang masing-masing berukuran 500 byte, hanya mewakili 50.000 byte total.
				</para>

			</listitem>
			 <listitem>
				<para>
					dua batas (lembut dan keras) mengacu pada cacah inode yang digunakan. Setiap berkas menempati setidaknya satu inode untuk menyimpan informasi tentangnya (izin, pemilik, stempel waktu akses terakhir, dll). Karena itu, membatasi banyaknya berkas pengguna.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Batas "lunak" dapat dilewati sementara; pengguna hanya akan diperingatkan bahwa mereka melebihi kuota oleh perintah <command>warnquota</command>, yang biasanya dipanggil oleh <command>cron</command>. Batas "keras" tidak boleh dilampaui: sistem akan menolak setiap operasi yang akan menyebabkan kuota keras dilampaui.
		</para>
		 <sidebar> <title><emphasis>KOSAKATA</emphasis> Blok dan inode</title>
		 <indexterm>
			<primary>blok (disk)</primary>
		</indexterm>
		 <indexterm>
			<primary>inode</primary>
		</indexterm>
		 <para>
			Sistem berkas membagi hard disk menjadi blok-blok — daerah-daerah berurutan yang kecil. Ukuran blok-blok ini didefinisikan selama penciptaan sistem berkas, dan biasanya bervariasi antara 1 dan 8 kibibyte.
		</para>
		 <para>
			Suatu blok dapat digunakan baik untuk menyimpan data yang nyata dari sebuah berkas, atau untuk digunakan oleh meta-data sistem berkas. Diantara data meta ini, terutama Anda akan menemukan inode. Inode menggunakan blok pada hard disk (tapi blok ini tidak dihitung dalam kuota blok, hanya di kuota inode), dan berisi informasi tentang berkas yang sesuai (nama, pemilik, izin, dll) dan pointer ke blok data yang benar-benar digunakan. Untuk berkas yang sangat besar yang menempati blok lebih daripada yang mungkin untuk diacu dalam inode tunggal, ada sistem blok yang tidak langsung; inode mengacu daftar blok yang tidak langsung berisi data, tetapi daftar lain dari blok.
		</para>
		 </sidebar> <indexterm>
			<primary><command>warnquota</command></primary>
		</indexterm>
		 <para>
			Dengan perintah <command>edquota -t</command>, Anda dapat menetapkan "masa tenggang" maksimum yang diizinkan kapan suatu batas lembut boleh dilampaui. Setelah masa ini, batas lembut akan diperlakukan seperti batas keras, dan pengguna harus mengurangi penggunaan ruang disk mereka ke dalam batas ini agar dapat menulis apapun ke hard disk.
		</para>
		 <sidebar> <title><emphasis>LEBIH LANJUT</emphasis> Menetapkan kuota default untuk pengguna baru</title>
		 <para>
			Untuk secara otomatis mengkonfigurasi kuota bagi pengguna baru, Anda harus mengkonfigurasi templat pengguna (dengan <command>edquota</command> atau <command>setquota</command>) dan menunjukkan nama pengguna dalam variabel <varname>QUOTAUSER</varname> di berkas <filename>/etc/ adduser.conf</filename>. Konfigurasi kuota ini akan kemudian secara otomatis diterapkan untuk setiap pengguna baru yang dibuat dengan perintah <command>adduser</command>.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.backup">
		<title>Cadangan</title>
		 <para>
			Membuat cadangan adalah salah satu tanggung jawab utama administrator manapun, tetapi itu adalah subjek yang kompleks, yang melibatkan alat yang seringkali sulit untuk dikuasai.
		</para>
		 <indexterm>
			<primary>backup</primary>
		</indexterm>
		 <indexterm>
			<primary>pemulihan</primary>
		</indexterm>
		 <para>
			Banyak program yang ada, seperti <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. Mereka adalah sistem klien/server yang menampilkan banyak pilihan, yang konfigurasi yang agak sulit. Beberapa diantaranya menyediakan antarmuka web yang ramah pengguna untuk mengurangi ini. Tapi Debian berisi puluhan perangkat lunak cadangan lain yang meliputi semua kemungkinan penggunaan kasus, yang Anda dapat Anda konfirmasi dengan mudah memakai <command>apt-cache search backup</command>.
		</para>
		 <indexterm>
			<primary><command>amanda</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>bacula</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>BackupPC</command></primary>
		</indexterm>
		 <para>
			Daripada merinci beberapa dari mereka, artikel ini akan menyajikan pikiran para administrator Falcot Corp ketika mereka mendefinisikan strategi cadangan mereka.
		</para>
		 <para>
			Di Falcot Corp, cadangan memiliki dua tujuan: memulihkan berkas yang salah hapus, dan cepat memulihkan komputer (server atau desktop) yang hard disknya gagal.
		</para>
		 <section>
			<title>Back Up dengan <command>rsync</command></title>
			 <para>
				Cadangan pada tape telah dianggap terlalu lambat dan mahal, data akan disimpan pada hard drive dalam server terdedikasi, yang penggunaan RAID perangkat lunak (lihat <xref linkend="sect.raid-soft" />) akan melindungi data dari kegagalan hard drive. Komputer desktop tidak dibuat cadangannya secara individual, tetapi pengguna disarankan bahwa akun pribadi mereka pada server berkas departemen mereka yang akan dibackup. Perintah <command>rsync</command> (dari paket dengan nama yang sama) digunakan sehari-hari untuk membuat cadangan server-server yang berbeda ini.
			</para>
			 <indexterm>
				<primary><command>rsync</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Hard link, nama kedua untuk berkas</title>
			 <indexterm>
				<primary>link</primary>
				<secondary>hard link</secondary>
			</indexterm>
			 <indexterm>
				<primary>hard link</primary>
			</indexterm>
			 <para>
				Hard link, sebagai lawan dari link simbolik, tidak bisa dibedakan dari berkas tertautnya. Membuat hard link pada dasarnya adalah sama dengan memberikan nama kedua pada berkas yang ada. Inilah sebabnya mengapa penghapusan hard link hanya menghapus salah satu dari nama-nama yang terkait dengan berkas. Selama nama lain masih diberikan ke berkas, data di dalamnya tetap ada pada sistem berkas. Hal ini menarik untuk dicatat bahwa, tidak seperti salinan, hard link tidak mengambil tambahan ruang pada hard drive.
			</para>
			 <para>
				Hard link dibuat dengan perintah <command>ln <replaceable>target</replaceable> <replaceable>tautan</replaceable></command>. Berkas <replaceable>tautan</replaceable> ini adalah nama baru untuk berkas <replaceable>target</replaceable>. Hard link hanya dapat dibuat pada sistem berkas yang sama, sementara link simbolik tidak tunduk pada pembatasan ini.
			</para>
			 </sidebar> <para>
				Ruang hard drive yang tersedia melarang pelaksanaan pembuatan cadangan harian yang lengkap. Dengan demikian, perintah <command>rsync</command> didahului oleh duplikasi konten cadangan sebelumnya dengan hard link, yang mencegah penggunaan terlalu banyak ruang hard drive. Proses <command>rsync</command> kemudian hanya menggantikan berkas yang telah diubah sejak terakhir dibuat cadangan. Dengan mekanisme ini sejumlah besar cadangan akan disimpan dalam ruang yang kecil. Karena semua cadangan seketika tersedia dan dapat diakses (misalnya, di berbagai direktori bersama pada jaringan), Anda dapat dengan cepat membuat perbandingan antara dua tanggal yang diberikan.
			</para>
			 <indexterm>
				<primary>salinan, salinan cadangan</primary>
			</indexterm>
			 <indexterm>
				<primary>cadangan</primary>
				<secondary>salinan</secondary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">dirvish</emphasis></primary>
			</indexterm>
			 <para>
				Mekanisme pembuatan cadangan ini mudah diimplementasikan dengan program <command>dirvish</command>. Menggunakan ruang penyimpanan cadangan ("bank" dalam kosa katanya) untuk menempatkan salinan set berkas cadangan yang diberi stempel waktu (set ini yang disebut "vault" dalam dokumentasi dirvish).
			</para>
			 <para>
				Konfigurasi utama ada di berkas <filename>/etc/dirvish/master.conf</filename>. Itu mendefinisikan lokasi ruang penyimpanan cadangan, daftar "vault" yang dikelola, dan nilai default bagi kedaluwarsa cadangan. Sisa konfigurasi terletak di berkas <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> dan berisi konfigurasi spesifik untuk set berkas yang terkait.
			</para>
			 <example id="example.dirvish-master">
				<title>Berkas <filename>/etc/dirvish/master.conf</filename></title>
				 
<programlisting>bank:
    /backup
exclude:
    lost+found/
    core
    *~
Runall:
    root    22:00
expire-default: +15 days
expire-rule:
#   MIN HR    DOM MON       DOW  STRFTIME_FMT
    *   *     *   *         1    +3 months
    *   *     1-7 *         1    +1 year
    *   *     1-7 1,4,7,10  1</programlisting>

			</example>
			 <para>
				Pengaturan <literal>bank</literal> menunjukkan direktori di mana cadangan disimpan. Pengaturan <literal>exclude</literal> memungkinkan Anda untuk menunjukkan berkas (atau jenis berkas) yang dikecualikan dari cadangan. <literal>Runall</literal> adalah daftar set berkas yang akan dibuat cadangannya dengan sebuah stempel waktu untuk setiap set, yang memungkinkan Anda untuk menetapkan tanggal yang benar yang akan disalin, dalam kasus cadangan tidak dipicu pada tepat waktu yang ditetapkan. Anda harus menunjukkan waktu yang tepat sebelum waktu eksekusi yang sebenarnya (yang, secara default, 22:04 di Debian, menurut <filename>/etc/cron.d/dirvish</filename>). Akhirnya, pengaturan <literal>expire-default</literal> dan <literal>expire-rule</literal> menetapkan kebijakan kedaluwarsa untuk cadangan. Contoh di atas menyimpan selamanya cadangan yang dihasilkan pada hari Minggu pertama setiap kuartal, menghapus setelah satu tahun dari hari Minggu pertama setiap bulan, dan setelah 3 bulan dari hari Minggu lainnya. Cadangan harian lainnya disimpan selama 15 hari. Urutan aturan penting, Dirvish menggunakan aturan terakhir yang cocok, atau <literal>expire-default</literal> jika tidak ada <literal>expire-rule</literal> yang cocok.
			</para>
			 <sidebar> <title><emphasis>DALAM PRAKTEK</emphasis> Kedaluwarsa terjadwal</title>
			 <para>
				Aturan kedaluwarsa tidak digunakan oleh <command>dirvish-expire</command> untuk melakukan tugasnya. Pada kenyataannya, aturan kedaluwarsa diterapkan ketika membuat salinan cadangan baru untuk menentukan tanggal kedaluwarsa yang terkait dengan salinan itu. <command>dirvish-expire</command> cukup memeriksa salinan disimpan dan menghapus berkas yang tanggal kedaluwarsanya telah berlalu.
			</para>
			 </sidebar> <example id="example.dirvish-vault">
				<title>Berkas <filename>/backup/root/dirvish/default.conf</filename></title>
				 
<programlisting>client: rivendell.falcot.com
tree: /
xdev: 1
index: gzip
image-default: %Y%m%d
exclude:
    /var/cache/apt/archives/*.deb
    /var/cache/man/**
    /tmp/**
    /var/tmp/**
    *.bak</programlisting>

			</example>
			 <para>
				The above example specifies the set of files to back up: these are files on the machine <emphasis>rivendell.falcot.com</emphasis> (for local data backup, simply specify the name of the local machine as indicated by <command>hostname</command>), especially those in the root tree (<literal>tree: /</literal>), except those listed in <literal>exclude</literal>. The backup will be limited to the contents of one filesystem (<literal>xdev: 1</literal>). It will not include files from other mount points. An index of saved files will be generated (<literal>index: gzip</literal>), and the image will be named according to the current date (<literal>image-default: %Y%m%d</literal>).
			</para>
			 <para>
				Ada banyak pilihan yang tersedia, semua didokumentasikan di halaman manual <citerefentry><refentrytitle>dirvish.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>. Setelah berkas konfigurasi ini disiapkan, Anda mesti menginisialisasi setiap set berkas dengan perintah <command>dirvish --vault <replaceable>vault</replaceable>--init</command>. Selanjutnya dari sana eksekusi harian <command>dirvish-runall</command> akan secara otomatis membuat salinan cadangan baru setelah menghapus yang kedaluwarsa.
			</para>
			 <sidebar> <title><emphasis>DALAM PRAKTEK</emphasis> Cadangan remote melalui SSH</title>
			 <para>
				When dirvish needs to save data to a remote machine, it will use <command>ssh</command> to connect to it, and will start <command>rsync</command> as a server. This requires the root user to be able to automatically connect to it. The use of an SSH authentication key allows precisely that (see <xref linkend="sect.ssh-key-based-auth" />).
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>Memulihkan Mesin tanpa Cadangan</title>
			 <para>
				Desktop computers, which are not backed up, will be easy to reinstall from custom DVD-ROMs prepared with <emphasis>Simple-CDD</emphasis> (see <xref linkend="sect.simple-cdd" />). Since this performs an installation from scratch, it loses any customization that can have been made after the initial installation. This is fine since the systems are all hooked to a central LDAP directory for accounts and most desktop applications are preconfigured thanks to dconf (see <xref linkend="sect.gnome-desktop" /> for more information about this).
			</para>
			 <para>
				The Falcot Corp administrators are aware of the limits in their backup policy. Since they can't protect the backup server as well as a tape in a fireproof safe, they have installed it in a separate room so that a disaster such as a fire in the server room won't destroy backups along with everything else. Furthermore, they do an incremental backup on DVD-ROM once per week — only files that have been modified since the last backup are included.
			</para>
			 <sidebar> <title><emphasis>LEBIH LANJUT</emphasis> Membuat cadangan layanan LDAP dan SQL</title>
			 <para>
				Many services (such as SQL or LDAP databases) cannot be backed up by simply copying their files (unless they are properly interrupted during creation of the backups, which is frequently problematic, since they are intended to be available at all times). As such, it is necessary to use an “export” mechanism to create a “data dump” that can be safely backed up. These are often quite large, but they compress well. To reduce the storage space required, you will only store a complete text file per week, and a <command>diff</command> each day, which is created with a command of the type <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command>. The <command>xdelta</command> program produces incremental differences from binary dumps.
			</para>
			 <indexterm>
				<primary><command>xdelta</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>diff</command></primary>
			</indexterm>
			 <indexterm>
				<primary>dump</primary>
			</indexterm>
			 </sidebar> <sidebar> <title><emphasis>KULTUR</emphasis> <emphasis>TAR</emphasis>, standar untuk cadangan tape</title>
			 <indexterm>
				<primary>cadangan</primary>
				<secondary>pada tape</secondary>
			</indexterm>
			 <indexterm>
				<primary>tape, cadangan</primary>
			</indexterm>
			 <indexterm>
				<primary>TAR</primary>
			</indexterm>
			 <para>
				Historically, the simplest means of making a backup on Unix was to store a <emphasis>TAR</emphasis> archive on a tape. The <command>tar</command> command even got its name from “Tape ARchive”.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.hotplug">
		<title>Hot Plugging: <emphasis>hotplug</emphasis></title>
		 <section>
			<title>Pengenalan</title>
			 <para>
				The <emphasis>hotplug</emphasis> kernel subsystem dynamically handles the addition and removal of devices, by loading the appropriate drivers and by creating the corresponding device files (with the help of <command>udevd</command>). With modern hardware and virtualization, almost everything can be hotplugged: from the usual USB/PCMCIA/IEEE 1394 peripherals to SATA hard drives, but also the CPU and the memory.
			</para>
			 <para>
				The kernel has a database that associates each device ID with the required driver. This database is used during boot to load all the drivers for the peripheral devices detected on the different buses, but also when an additional hotplug device is connected. Once the device is ready for use, a message is sent to <command>udevd</command> so it will be able to create the corresponding entry in <filename>/dev/</filename>.
			</para>
			 <indexterm>
				<primary><emphasis>hotplug</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>hotplug</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>PCMCIA</primary>
			</indexterm>
			 <indexterm>
				<primary>SATA</primary>
			</indexterm>

		</section>
		 <section>
			<title>Masalah Penamaan</title>
			 <para>
				Before the appearance of hotplug connections, it was easy to assign a fixed name to a device. It was based simply on the position of the devices on their respective bus. But this is not possible when such devices can come and go on the bus. The typical case is the use of a digital camera and a USB key, both of which appear to the computer as disk drives. The first one connected may be <filename>/dev/sdb</filename> and the second <filename>/dev/sdc</filename> (with <filename>/dev/sda</filename> representing the computer's own hard drive). The device name is not fixed; it depends on the order in which devices are connected.
			</para>
			 <para>
				Additionally, more and more drivers use dynamic values for devices' major/minor numbers, which makes it impossible to have static entries for the given devices, since these essential characteristics may vary after a reboot.
			</para>
			 <para>
				<emphasis>udev</emphasis> was created precisely to solve this problem.
			</para>

		</section>
		 <section>
			<title>Bagaimana <emphasis>udev</emphasis> Bekerja</title>
			 <para>
				When <emphasis>udev</emphasis> is notified by the kernel of the appearance of a new device, it collects various information on the given device by consulting the corresponding entries in <filename>/sys/</filename>, especially those that uniquely identify it (MAC address for a network card, serial number for some USB devices, etc.).
			</para>
			 <para>
				Armed with all of this information, <emphasis>udev</emphasis> then consults all of the rules contained in <filename>/etc/udev/rules.d/</filename> and <filename>/lib/udev/rules.d/</filename>. In this process it decides how to name the device, what symbolic links to create (to give it alternative names), and what commands to execute. All of these files are consulted, and the rules are all evaluated sequentially (except when a file uses “GOTO” directives). Thus, there may be several rules that correspond to a given event.
			</para>
			 <para>
				The syntax of rules files is quite simple: each row contains selection criteria and variable assignments. The former are used to select events for which there is a need to react, and the latter defines the action to take. They are all simply separated with commas, and the operator implicitly differentiates between a selection criterion (with comparison operators, such as <literal>==</literal> or <literal>!=</literal>) or an assignment directive (with operators such as <literal>=</literal>, <literal>+=</literal> or <literal>:=</literal>).
			</para>
			 <para>
				Operator perbandingan yang digunakan pada variabel berikut:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>KERNEL</literal>: the name that the kernel assigns to the device;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>AKSI</literal>: tindakan yang sesuai untuk acara ("add" ketika perangkat telah ditambahkan, "remove" ketika dihapus);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>DEVPATH</literal>: path entri <filename>/sys/</filename> perangkat;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SUBSYSTEM</literal>: the kernel subsystem which generated the request (there are many, but a few examples are “usb”, “ide”, “net”, “firmware”, etc.);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ATTR{<replaceable>attribute</replaceable>}</literal>: file contents of the <replaceable>attribute</replaceable> file in the <filename>/sys/<replaceable>$devpath</replaceable>/</filename> directory of the device. This is where you find the MAC address and other bus specific identifiers;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> and <literal>ATTRS{<replaceable>attributes</replaceable>}</literal> are variations that will try to match the different options on one of the parent devices of the current device;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>PROGRAM</literal>: delegates the test to the indicated program (true if it returns 0, false if not). The content of the program's standard output is stored so that it can be reused by the <literal>RESULT</literal> test;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>RESULT</literal>: execute tests on the standard output stored during the last call to <literal>PROGRAM</literal>.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Operand kanan dapat menggunakan ekspresi pola untuk mencocokkan beberapa nilai pada waktu yang sama. Sebagai contoh, <literal>*</literal> cocok dengan string apapun (bahkan yang kosong); <literal>?</literal> cocok dengan sebarang karakter, dan <literal>[]</literal> sesuai set karakter yang tercantum antara kurung (atau lawan dari itu jika karakter pertama adalah tanda seru, dan rentang karakter berturutan dituliskan seperti <literal>a-z</literal>).
			</para>
			 <para>
				Regarding the assignment operators, <literal>=</literal> assigns a value (and replaces the current value); in the case of a list, it is emptied and contains only the value assigned. <literal>:=</literal> does the same, but prevents later changes to the same variable. As for <literal>+=</literal>, it adds an item to a list. The following variables can be changed:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>NAME</literal>: the device filename to be created in <filename>/dev/</filename>. Only the first assignment counts; the others are ignored;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SYMLINK</literal>: the list of symbolic links that will point to the same device;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>OWNER</literal>, <literal>GROUP</literal> and <literal>MODE</literal> define the user and group that owns the device, as well as the associated permission;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>RUN</literal>: the list of programs to execute in response to this event.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				The values assigned to these variables may use a number of substitutions:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>$kernel</literal> atau <literal>%k</literal>: setara dengan <literal>KERNEL</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$number</literal> atau <literal>%n</literal>: nomor urut perangkat, misalnya, untuk <literal>sda3</literal>, itu akan "3";
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$devpath</literal> atau <literal>%p</literal>: setara dengan <literal>DEVPATH</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$attr{<replaceable>attribute</replaceable>}</literal> or <literal>%s{<replaceable>attribute</replaceable>}</literal>: equivalent to <literal>ATTRS{<replaceable>attribute</replaceable>}</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$major</literal> atau <literal>%M</literal>: nomor mayor kernel dari perangkat;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$minor</literal> atau <literal>%m</literal>: nomor minor kernel dari perangkat;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$result</literal> or <literal>%c</literal>: the string output by the last program invoked by <literal>PROGRAM</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						and, finally, <literal>%%</literal> and <literal>$$</literal> for the percent and dollar sign, respectively.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				The above lists are not complete (they include only the most important parameters), but the <citerefentry><refentrytitle>udev</refentrytitle>
				<manvolnum>7</manvolnum></citerefentry> manual page should be exhaustive.
			</para>

		</section>
		 <section>
			<title>Contoh konkret</title>
			 <para>
				Let us consider the case of a simple USB key and try to assign it a fixed name. First, you must find the elements that will identify it in a unique manner. For this, plug it in and run <command>udevadm info -a -n /dev/sdc</command> (replacing <replaceable>/dev/sdc</replaceable> with the actual name assigned to the key).
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>
<computeroutput>[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</computeroutput></screen>
			 <para>
				To create a new rule, you can use tests on the device's variables, as well as those of one of the parent devices. The above case allows us to create two rules like these:
			</para>
			 
<programlisting>KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"</programlisting>
			 <para>
				Once these rules are set in a file, named for example <filename>/etc/udev/rules.d/010_local.rules</filename>, you can simply remove and reconnect the USB key. You can then see that <filename>/dev/usb_key/disk</filename> represents the disk associated with the USB key, and <filename>/dev/usb_key/part1</filename> is its first partition.
			</para>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> Debugging <emphasis>udev</emphasis>'s configuration</title>
			 <para>
				Like many daemons, <command>udevd</command> stores logs in <filename>/var/log/daemon.log</filename>. But it is not very verbose by default, and it is usually not enough to understand what is happening. The <command>udevadm control --log-priority=info</command> command increases the verbosity level and solves this problem. <command>udevadm control --log-priority=err</command> returns to the default verbosity level.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.power-management">
		<title>Manajemen Daya: Advanced Configuration and Power Interface (ACPI)</title>
		 <indexterm>
			<primary>manajemen daya</primary>
		</indexterm>
		 <indexterm>
			<primary>manajemen, manajemen daya</primary>
		</indexterm>
		 <para>
			The topic of power management is often problematic. Indeed, properly suspending the computer requires that all the computer's device drivers know how to put them to standby, and that they properly reconfigure the devices upon waking. Unfortunately, there are still a few devices unable to sleep well under Linux, because their manufacturers have not provided the required specifications.
		</para>
		 <para>
			Linux supports ACPI (Advanced Configuration and Power Interface) — the most recent standard in power management. The <emphasis role="pkg">acpid</emphasis> package provides a daemon that looks for power management related events (switching between AC and battery power on a laptop, etc.) and that can execute various commands in response.
		</para>
		 <indexterm>
			<primary>ACPI</primary>
		</indexterm>
		 <indexterm>
			<primary>Advanced Configuration and Power Interface</primary>
		</indexterm>
		 <indexterm>
			<primary><command>acpid</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>BEWARE</emphasis> Graphics card and standby</title>
		 <para>
			The graphics card driver is often the culprit when standby doesn't work properly. In that case, it is a good idea to test the latest version of the X.org graphics server.
		</para>
		 </sidebar> <para>
			After this overview of basic services common to many Unix systems, we will focus on the environment of the administered machines: the network. Many services are required for the network to work properly. They will be discussed in the next chapter.
		</para>

	</section>
</chapter>

