<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="basic-configuration" lang="id-ID">
	<chapterinfo>
		 <keywordset>
			<keyword>Konfigurasi</keyword>
			 <keyword>Lokalisasi</keyword>
			 <keyword>Locales</keyword>
			 <keyword>Jaringan</keyword>
			 <keyword>Resolusi nama</keyword>
			 <keyword>Pengguna</keyword>
			 <keyword>Kelompok</keyword>
			 <keyword>Akun</keyword>
			 <keyword>Interpreter baris-perintah</keyword>
			 <keyword>Shell</keyword>
			 <keyword>Pencetakan</keyword>
			 <keyword>Bootloader</keyword>
			 <keyword>Kompilasi kernel</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Konfigurasi Dasar: Jaringan, Akun, Pencetakan...</title>
	 <highlights> <para>
		Sebuah komputer dengan instalasi baru yang dibuat dengan <command>deban-installer</command> dimaksudkan untuk sefungsional mungkin, namun banyak layanan masih perlu dikonfigurasi. Lebih jauh, sebaiknya kita mengetahui bagaimana cara mengganti elemen konfigurasi tertentu selama proses instalasi awal.
	</para>
	 </highlights> <para>
		Bab ini mengulas semua yang disertakan dalam apa yang disebut “konfigurasi dasar”: jaringan, bahasa dan lokal, pengguna dan kelompok, pencetakan, titik kait, dll.
	</para>
	 <section id="sect.config-language-support">
		<title>Konfigurasi Sistem untuk Bahasa yang Berbeda</title>
		 <indexterm>
			<primary>Pelokalan Bahasa Indonesia</primary>
		</indexterm>
		 <para>
			Jika sistem terinstall menggunakan Bahasa Indonesia, mungkin mesin telah memiliki Bahasa Indonesia sebagai bahasa bawaan. Namun perlu diketahui bahwa installer mengatur bahasa, jadi di lain waktu, jika suatu saat diperlukan, Anda dapat mengubahnya.
		</para>
		 <sidebar> <title><emphasis>ALAT</emphasis> Perintah <command>locale</command> menampilkan konfigurasi saat ini</title>
		 <para>
			Perintah <command>locale</command> memanpilkan daftar ikhtisar konfigurasi saat ini berbagai parameter locale (format tanggal, format nomor, dll.), disajikan dalam bentuk kelompok variabel lingkungan standar dikhususkan pada modifikasi dinamis dari pengaturan ini.
		</para>
		 </sidebar> <section id="sect.default-language">
			<title>Mengatur Bahasa Standar</title>
			 <indexterm>
				<primary>locales</primary>
			</indexterm>
			 <indexterm>
				<primary>bahasa</primary>
			</indexterm>
			 <indexterm>
				<primary><command>locale-gen</command></primary>
			</indexterm>
			 <para>
				Sebuah locale ialah sekelompok pengaturan regional. Termasuk tidak hanya bahasa untuk teks, tetapi juga format untuk menampilkan angka, tanggal, waktu, dan penjumlahan keuangan, sebagaimana peraturan perbandingan alfabet (untuk menangani karakter beraksen dengan tepat). Meskipun setiap parameter ini dapat ditentukan secara independen satu sama lain, umumnya kita menggunakan sebuah locale, yang merupakan seperangkat nilai koheren untuk parameter ini sesuai dengan “region” dalam arti luas. Locale ini biasanya ditentukan dalam bentuk, <literal><replaceable>kode-bahasa</replaceable>_<replaceable>KODE-NEGARA</replaceable></literal>, terkadang dengan akhiran untuk menentukan set karakter dan encoding yang digunakan. Memungkinkan pertimbangan perbedaan idiomatik atau tipografi antara region yang berbeda dengan sebuah bahasa umum.
			</para>
			 <sidebar> <title><emphasis>KULTUR</emphasis> Set karakter</title>
			 <indexterm>
				<primary>set karakter</primary>
			</indexterm>
			 <indexterm>
				<primary>pengkodean</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-1</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-15</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 1</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 9</primary>
			</indexterm>
			 <para>
				Sejarahnya, setiap lokal memiliki “set karakter” yang sesuai (sekelompok karakter yang diketahui) dan disebut pula “encoding” (representasi internal untuk karakter dalam komputer).
			</para>
			 <para>
				Encoding yang paling populer untuk bahasa berbasis-latin terbatas pada 256 karakter karena mereka dibatasi untuk menggunakan byte tunggal untuk setiap karakter. Karena 256 karakter tidak cukup untuk mencakup seluruh bahasa Eropa, diperlukan banyak encoding, dan demikianlah kita akhirnya menggunakan <emphasis>ISO-8859-1</emphasis> (disebut juga “Latin 1”) hingga <emphasis>ISO-8859-15</emphasis> (disebut juga “Latin 9”), di antara lainnya.
			</para>
			 <para>
				Bekerja dengan bahasa asing seringkali mengakibatkan pergantian reguler antara berbagai encoding dan set karakter. Lebih jauh, menulis dokumen multi bahasa berakibat banyak, masalah yang hampir tak dapat dilacak. Unicode (sebuah katalog-super hampir seluruh penulisan sistem dari segala bahasa penjuru dunia) telah dibuat untuk mengatasi masalah ini. Salah satu encoding Unicode, UTF-8, mencakup seluruh 128 ASCII symbols (kode 7-bit), namun menangani karakter lain dengan cara berbeda. Diawali dengan sebuah urutan escape khusus beberapa bit, yang secara implisit menentukan panjang karakter. Hal ini memungkinkan encoding seluruh karakter Unicode dalam sebuah urutan dari satu atau beberapa byte. Penggunaannya telah dipopulerkan dengan kenyataan bahwa ini merupakan encoding standar dalam dokumen XML.
			</para>
			 <indexterm>
				<primary>ASCII</primary>
			</indexterm>
			 <indexterm>
				<primary>UTF-8</primary>
			</indexterm>
			 <indexterm>
				<primary>Unicode</primary>
			</indexterm>
			 <para>
				Encoding inilah yang secara umum digunakan, dan merupakan standar pada sistem Debian.
			</para>
			 </sidebar> <para>
				Paket <emphasis role="pkg">locales</emphasis> menyertakan semua elemen yang diperlukan agar “pelokalan” berbagai aplikasi dapat berjalan dengan baik. Ketika instalasi, paket ini akan meminta untuk memilih seperangkat bahasa yang didukung. Set ini dapat diubah kapan saja dengan menjalankan <command>dpkg-reconfigure locales</command> dengan hak akses root.
			</para>
			 <para>
				Pertanyaan pertama meminta Anda untuk memilih dukungan “locales”. Memilih seluruh lokal Bahasa Inggris (berarti yang diawali dengan “<literal>en_</literal>”) merupakan pilihan yang baik. Jangan ragu untuk memfungsikan juga locale lain jika mesin akan digunakan oleh pengguna asing. Daftar locale yang diaktifkan pada sistem disimpan di berkas <filename>/etc/locale.gen</filename>. Mungkin saja menyuntingnya secara manual, namun Anda harus menjalankan <command>locale-gen</command> setelah memodifikasinya. Ini akan menghasilkan berkas-berkas yang diperlukan oleh locale yang ditambahkan agar dapat bekerja, dan menghapus berkas-berkas yang usang.
			</para>
			 <para>
				Pertanyaan kedua, “Default locale untuk lingkungan sistem”, meminta locale standar. Pilihan yang direkomendasikan di U.S.A adalah “<literal>en_US.UTF-8</literal>”. Pengguna Bahasa Inggris Inggris akan lebih memilih “<literal>en_GB.UTF-8</literal>”, dan Orang Kanada akan memilih antara “<literal>en_CA.UTF-8</literal>” atau, untuk Prancis, “<literal>fr_CA.UTF-8</literal>”. Berkas <filename>/etc/default/locale</filename> kemudian akan termodifikasi untuk menyimpan pilihan ini. Dari sana, akan diambil oleh seluruh sesi pengguna karena PAM akan memasukkan kontennya ke dalam variabel lingkunran <varname>LANG</varname>.
			</para>
			 <indexterm>
				<primary>lingkungan</primary>
			</indexterm>
			 <indexterm>
				<primary>locale</primary>
			</indexterm>
			 <indexterm>
				<primary><varname>LANG</varname></primary>
			</indexterm>
			 <sidebar id="sidebar.intro-pam"> <title><emphasis>DI BALIK LAYAR</emphasis> <filename>/etc/environment</filename> dan <filename>/etc/default/locale</filename></title>
			 <para>
				Berkas <filename>/etc/environment</filename> menyediakan <command>login</command>, <command>gdm</command>, atau bahkan program <command>ssh</command> dengan variabel lingkungan yang akan dibuat secara tepat.
			</para>
			 <para>
				Aplikasi ini tidak membuat variabel ini secara langsung, namun melalui modul PAM (<filename>pam_env.so</filename>). PAM (Pluggable Authentication Module) merupakan pustaka modular pemusatan mekanisme otentikasi, inisialisasi sesi, dan manajemen kata sandi. Lihat <xref linkend="sect.config-pam" /> untuk sebuah contoh konfigurasi PAM.
			</para>
			 <para>
				Berkas <filename>/etc/default/locale</filename> bekerja dalam cara yang sama, namun hanya berisi variabel lingkungan <varname>LANG</varname>. Karena pemecahan inilah, beberapa pengguna PAM dapat menurunkan lingkungan lengkap tanpa pelokalan. Sebenarnya, umumnya dihindari untuk menjalankan program server dengan mengaktifkan pelokalan; dengan kata lain, pelokalan dan pengaturan regional direkomendasikan untuk program yang membuka sesi pengguna.
			</para>
			 <indexterm>
				<primary>PAM</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>pam_env.so</filename></primary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.keyboard-config">
			<title>Mengatur Papan ketik</title>
			 <indexterm>
				<primary>tata letak papan ketik</primary>
			</indexterm>
			 <indexterm>
				<primary>tata letak, papan ketik</primary>
			</indexterm>
			 <para>
				Bahkan jika tata letak papan ketik diatur dengan cara yang berbeda dalam konsol dan mode grafis, Debian menawarkan antarmuka konfigurasi tunggal yang bekerja untuk keduanya; ialah berbasis debconf dan diterapkan dalam paket <emphasis role="pkg">keyboard-configuration</emphasis>. Perintah <command>dpkg-reconfigure keyboard-configuration</command> dapat digunakan kapan saja untuk mengatur ulang tata letak papan ketik.
			</para>
			 <indexterm>
				<primary><emphasis>console-data</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>console-tools</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>keyboard-configuration</emphasis></primary>
			</indexterm>
			 <para>
				<indexterm><primary><literal>azerty</literal></primary></indexterm>Pertanyaannya sesuai dengan tata letak papan ketik fisik (papan ketik standar PC di US berupa “Generic 104 key”), kemudian tata letak yang dipilih (umumnya “US”), dan kemudian posisi tombol AltGr (Alt kanan). Akhirnya pertanyaan tombol yang digunakan untuk “Compose key”, yang memungkinkan untuk memasukkan karakter khusus dengan kombinasi penekanan tombol. Keberhasilan mengetik <keycombo action="seq"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> dan akan menghasilkan sebuah e-acute (“é”). Seluruh kombinasi ini dijelaskan dalam berkas <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> (atau berkas lain, ditentukan berdasarkan kondisi locale terkini ditunjukkan oleh <filename>/usr/share/X11/locale/compose.dir</filename>).
			</para>
			 <indexterm>
				<primary><literal>Compose</literal>, key</primary>
			</indexterm>
			 <indexterm>
				<primary><literal>Meta</literal>, key</primary>
			</indexterm>
			 <indexterm>
				<primary>key</primary>
				<secondary><literal>Meta</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary>key</primary>
				<secondary><literal>Compose</literal></secondary>
			</indexterm>
			 <para>
				Catat bahwa konfigurasi papan ketik untuk mode grafis yang dijelaskan di sini hanya berlaku untuk tata letak standar; lingkungan GNOME dan KDE, antara lain, menyediakan panel kontrol papan ketik dalam preferensi mereka yang memungkinkan setiap pengguna memiliki konfigurasi mereka sendiri. Beberapa pilihan tambahan terkait tingkah laku beberapa kunci juga tersedia di panel kontrol ini.
			</para>

		</section>
		 <section id="sect.utf8-migration">
			<title>Migrasi ke UTF-8</title>
			 <para>
				Generalisasi encoding UTF-8 telah lama menunggu solusi banyak kesulitan dengan interoperabilitasnya, karena dia memfasilitasi pertukaran internasional dan menghilangkan batasan sewenang-wenang pada karakter yang dapat digunakan di dalam sebuah dokumen. Salah satu kekurangannya ialah bahwa dia harus melalui fase transisi yang sulit. Karena dia tidak dapat transparan sepenuhnya (yakni, tidak terjadi pada saat yang sama di seluruh dunia), diperlukan dua operasi konversi: satu pada konten berkas, dan lainnya pada namaberkas. Untungnya, migrasi masal ini telah sempurna dan kita membahasnya secara lengkap untuk referensi.
			</para>
			 <sidebar> <title><emphasis>KULTUR</emphasis> <foreignphrase>Mojibake</foreignphrase> dan kesalahan interpretasi</title>
			 <para>
				Ketika teks terkirim (atau tersimpan) tanpa informasi encoding, tidak selalu mungkn untuk penerima mengetahui dengan pasti konvensi apa yang digunakan untuk menentukan makna seperangkat byte. Anda biasanya mendapatkan sebuah ide dengan mengambil statistik pada distribusi nilai yang disajikan dalam teks, namun hal tersebut tak selalu memberikan jawaban pasti. Ketika sistem encoding dipilih untuk membaca pembeda dari yang digunakan dalam menulis berkas, byte salah diinterpretasikan, dan Anda dapat, yang terbaik, kesalahan pada beberapa karakter, atau, yang terburuk, sesuatu sama sekali tak terbaca.
			</para>
			 <para>
				Jadi, jika teks Bahasa Prancis nampak normal dengan pengecualian huruf beraksen dan simbol tertentu yang nampak diganti dengan urutan karakter seperti “Ã©” atau Ã¨” atau “Ã§”, ini mungkin sebuah berkas ber-encode sebagai UTF-8 namun ditafsirkan sebagai ISO-8859-1 atau ISO-8859-15. Ini merupakan tanda sebuah instalasi lokal yang belum dimigrasikan ke UTF-8. Jika, sebaliknya, Anda melihat tanda tanya alih-alih huruf beraksen - bahkan jika tanda tanya ini nampak mengganti sebuah karakter yang harus diikuti huruf beraksen - nampaknya instalasi Anda telah terkonfigurasi untuk UTF-8 dan bahwa Anda telah dikirimi sebuah dokumen di-encode dalam Western ISO.
			</para>
			 <para>
				Banyak kasus “sederhana”. Kasus ini hanya muncul di kultur Western, karena Unicode (dan UTF-8) telah didesain untuk memaksimalkan poin umum dengan sejarah encoding untuk bahasa Barat berdasarkan alfabet Latin, yang memungkinkan pengenalan bagian teks bahkan ketika beberapa karakter hilang.
			</para>
			 <para>
				Dalam konfigurasi yang lebih kompleks, yang, sebagai contoh, melibatkan dua lingkungan masing-masing dua bahasa berbeda yang tidak menggunakan alfabet yang sama, Anda sering mendapatkan hasil yang tak terbaca - serangkaian simbol abstrak yang tidak diketahui satu sama lain. Ini khususnya umum dengan bahasa Asia disebabkan oleh berbagai bahasa dan sistem penulisan mereka. Istilah Jepang <foreignphrase>mojibake</foreignphrase> telah diadopsi untuk menjelaskan fenomena ini. Ketika hal ini muncul, diagnosa lebih kompleks dan solusi paling sederhana seringkali dengan memigrasikan keduanya ke UTF-8.
			</para>
			 </sidebar> <para>
				Sejauh nama berkas diperhatikan, migrasi dapat relatif sederhana. Alat <command>convmv</command> (dalam paket dengan nama yang sama) dibuat secara khusus untuk tujuan ini; ini memungkinkan mengganti nama berkas dari satu encoding ke lainnya. Penggunaan alat ini relatif sederhana, namun kami merekomendasikan melakukannya dalam dua langkah untuk menghindari kejutan. Contoh berikut mengilustrasikan lingkungan UTF-8 berisi nama direktori ter-encode dalam ISO-8859-15, dan menggunakan <command>convmv</command> untuk mengganti namanya.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Ic?nes  ?l?ments graphiques  Textes
$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>Starting a dry run without changes...
mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
No changes to your files done. Use --notest to finally rename the files.
$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
Ready!
$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput></screen>
			 <para>
				Untuk konten berkasnya, prosedur konversinya lebih kompleks disebabkan oleh banyak varian format berkas yang ada. Beberapa format berkas menyertakan informasi encoding yang memfasilitasi tugas perangkat lunak yang digunakan untuk menanganinya; ini cukup, kemudian, buka berkas tersebut dan simpan-ulang dengan menentukan encoding UTF-8. Dalam kasus lain, Anda harus menentukan encoding asli (ISO-8859-1 atau “Western”, atau ISO-8859-15 atau “Western (Euro)”, berdasarkan formulasinya) ketika membuka berkas.
			</para>
			 <para>
				Untuk berkas teks sederhana, Anda dapat menggunakan <command>recode</command> (dalam paket dengan nama sama) yang memungkinkan recoding otomatis. Alat ini memiliki banyak pilihan jadi Anda dapat bermain dengan tabiatnya. Kami merekomendasikan Anda memeriksa dokumentasi, man page <citerefentry> <refentrytitle>recode</refentrytitle>
				 <manvolnum>1</manvolnum> </citerefentry>, atau info page <citerefentry> <refentrytitle>recode</refentrytitle>
				 </citerefentry> (lebih lengkap).
			</para>

		</section>

	</section>
	 <section id="sect.network-config">
		<title>Mengonfigurasi Jaringan</title>
		 <sidebar id="sidebar.networking-basics"> <title><emphasis>KEMBALI KE DASAR</emphasis> Konsep penting jaringan (Ethernet, alamat IP, subnet, broadcast)</title>
		 <indexterm>
			<primary>Ethernet</primary>
		</indexterm>
		 <indexterm>
			<primary>10BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>100BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>1000BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>10GBASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>konektor, RJ45</primary>
		</indexterm>
		 <indexterm>
			<primary>konektor RJ45</primary>
		</indexterm>
		 <para>
			Kebanyakan jaringan lokal modern menggunakan protokol Ethernet, dimana data dibagi ke dalam blok-blok kecil yang disebut bingkai dan ditransmisikan pada kabel satu bingkai sekali transmisi. Kecepatan data bervariasi dari 10 Mb/s untuk kartu Ethernet tua ke 10 Gb/s pada kartu terbaru (dengan kecepatan paling umum sedang berkembang dari 100 Mb/s ke 1 Gb/s). Kabel yang paling sering digunakan adalah 10BASE-T, 100BASE-T, 1000BASE-T or 10GBASE-T tergantung pada kapasitas yang dapat mereka tampung (T berarti “twisted pair”); kabel tersebut berujung pada konektor RJ45. Ada tipe kabel lain, paling banyak digunakan untuk kecepatan 1 Gb/s dan yang lebih tinggi.
		</para>
		 <indexterm>
			<primary>alamat, alamat IP</primary>
		</indexterm>
		 <indexterm>
			<primary>alamat IP</primary>
		</indexterm>
		 <para>
			Alamat IP adalah sebuah angka yang digunakan untuk mengidentifikasi antarmuka jaringan pada sebuah komputer dalam jaringan lokal atau Internet. Saat ini versi IP (IPv4) yang paling banyak digunakan, nomor ini di-encode dalam 32 bit, dan biasanya direpresentasikan sebagai 4 nomor dipisahkan oleh titik (mis. <literal>192.168.0.1</literal>), setiap nomor dapat diisi antara 0 dan 255 (inklusif, yang sama dengan data 8 bit). Protokol versi berikutnya, IPv6, memerluas ruang pengalamatan ke 128 bit, dan alamat umumnya direpresentasikan sebagai serangkaian nomor heksadesimal dipisahkan oleh titik dua (mis., 2001:0db8:13bb:0002:0000:0000:0000:0020, atau 2001:db8:13bb:2::20 pendeknya).
		</para>
		 <indexterm>
			<primary>subnet</primary>
		</indexterm>
		 <indexterm>
			<primary>mask</primary>
			<secondary>subnet mask</secondary>
		</indexterm>
		 <indexterm>
			<primary>jaringan</primary>
			<secondary>alamat</secondary>
		</indexterm>
		 <para>
			Sebuah subnet mask (netmask) menentukan kode binernya yang merupakan bagian dari alamat IP berhubungan dengan jaringan, pengingatnya menentukan mesin. Dalam contoh konfigurasi alamat IPv4 statis yang diberikan di sini, subnet mask, <literal>255.255.255.0</literal> (24-nya “1” diikuti oleh 8-nya “0” dalam representasi biner) menunjukkan bahwa 24 bit yang pertama dari alamat IP berupa alamat jaringan, dan 8 lainnya spesifik ke mesin. Dalam IPv6, agar terbaca, hanya angka “1” yang dinyatakan; netmask untuk jaringan IPv6 berupa <literal>64</literal>.
		</para>
		 <para>
			Alamat jaringan merupakan alamat IP yang bagian yang menjelaskan nomor mesinnya berupa 0. Range alamat IPv4 dalam jaringan lengkap seringkali ditentukan oleh sintaks, <emphasis>a.b.c.d/e</emphasis>, di mana <emphasis>a.b.c.d</emphasis> merupakan alamat jaringan dan <emphasis>e</emphasis> adalah jumlah bit berpengaruh terhadap bagian jaringan dalam alamat IP. Contoh jaringan tersebut tertulis: <literal>192.168.0.0/24</literal>. Sintaks yang mirip dalam IPv6: <literal>2001:db8:13bb:2::/64</literal>.
		</para>
		 <indexterm>
			<primary>router</primary>
		</indexterm>
		 <indexterm>
			<primary>bridge</primary>
		</indexterm>
		 <para>
			Router adalah mesin yang menghubungkan beberapa jaringan satu sama lain. Seluruh trafik yang melalui router diarahkan ke jaringan yang tepat. Untuk melakukan ini, router menganalisa paket datang dan meneruskannya berdasarkan alamat IP tujuannya. Router seringkali disebut juga gateway; dalam konfigurasi ini, dia bekerja sebagai sebuah mesin yang membantu menjangkau jaringan lokal (menuju jaringan lainnya, seperti Internet).
		</para>
		 <indexterm>
			<primary>broadcast</primary>
		</indexterm>
		 <para>
			Alamat broadcast khusus menghubungkan seluruh stasiun dalam sebuah jaringan. Hampir tak pernah “diroute”, dia hanya berfungsi pada jaringan tersebut. Secara spesifik, berarti bahwa paket data yang dialamatkan ke broadcast tidak pernah dilewatkan ke router.
		</para>
		 <para>
			Bab ini fokus pada alamat IPv4, karena saat ini mereka yang paling umum digunakan. Rincian tentang protokol IPv6 pendekatannya ada di <xref linkend="sect.ipv6" />, namun konsepnya sama saja.
		</para>
		 </sidebar> <para>
			Karena jaringan secara otomatis dikonfigurasi selama instalasi awal, berkas <filename>/etc/network/interfaces</filename> telah berisi konfigurasi yang tepat. Sebuah baris yang dimulai dengan <literal>auto</literal> merupakan antarmuka yang dikonfigurasi secara otomatis ketika booting oleh <emphasis role="pkg">ifupdown</emphasis> dan skrip init-nya <filename>/etc/init.d/networking</filename>. Ini seringkali berupa <literal>eth0</literal>, yang mengacu pada kartu jaringan pertama.
		</para>
		 <indexterm>
			<primary>jaringan</primary>
			<secondary>konfigurasi</secondary>
		</indexterm>
		 <indexterm>
			<primary>konfigurasi</primary>
			<secondary>jaringan</secondary>
		</indexterm>
		 <indexterm>
			<primary>antar muka</primary>
			<secondary>antar muka jaringan</secondary>
		</indexterm>
		 <indexterm>
			<primary><literal>eth0</literal></primary>
		</indexterm>
		 <sidebar> <title><emphasis>ALTERNATIF</emphasis> NetworkManager</title>
		 <indexterm>
			<primary><emphasis role="pkg">network-manager</emphasis></primary>
		</indexterm>
		 <para>
			Jika Network Manager direkomendasikan dalam pengaturan roaming (lihat <xref linkend="sect.roaming-network-config" />), dia juga sangat berguna sebagai pengatur jaringan standar. Anda dapat membuat “Koneksi sistem” yang digunakan sesegera setelah komputer boot entah itu secara manual dengan berkas mirip <filename>.ini</filename> dalam <filename>/etc/NetworkManager/system-connections/</filename> atau melalui tool grafis (<command>nm-connection-editor</command>). Ingatlah untuk menonaktifkan seluruh entri dalam <filename>/etc/network/interfaces</filename> jika Anda ingin Network Manager menanganinya. <ulink type="block" url="https://wiki.gnome.org/Projects/NetworkManager/SystemSettings/jessie" /> <ulink type="block" url="https://developer.gnome.org/NetworkManager/09/ref-settings.html" />
		</para>
		 </sidebar> <section id="sect.interface-ethernet">
			<title>Antarmuka Ethernet</title>
			 <para>
				Jika komputer memiliki sebuah kartu Ethernet, jaringan IP yang bersesuaian dengannya harus dikonfigurasi dengan memilih salah satu metode. Metode yang paling sederhana adalah konfigurasi dinamis dengan DHCP, dan dia memerlukan server DHCP pada jaringan lokal. Ini mungkin menunjukkan hostname yang diinginkan, berhubungan dengan pengaturan <literal>hostname</literal> dalam contoh berikut. Server DHCP kemudian mengirimkan pengaturan konfigurasi untuk jaringan yang sesuai.
			</para>
			 <indexterm>
				<primary>Ethernet</primary>
			</indexterm>
			 <indexterm>
				<primary>DHCP</primary>
			</indexterm>
			 <example id="example.config-dhcp">
				<title>Konfigurasi DHCP</title>
				 
<programlisting>
auto eth0
iface eth0 inet dhcp
  hostname arrakis</programlisting>

			</example>
			 <para>
				Konfigurasi “statis” harus menunjukkan pengaturan jaringan secara tetap. Termasuk setidaknya alamat IP dan subnet mask; jaringan dan alamat broadcast kadang juga termasuk. Sebuah router menghubungkan ke jaringan luar akan disebut gateway.
			</para>
			 <example id="example.static-network">
				<title>Konfigurasi statis</title>
				 
<programlisting>
auto eth0
iface eth0 inet static
  address 192.168.0.3
  netmask 255.255.255.0
  broadcast 192.168.0.255
  network 192.168.0.0
  gateway 192.168.0.1</programlisting>

			</example>
			 <sidebar> <title><emphasis>CATATAN</emphasis> Banyak alamat</title>
			 <para>
				Mungkin saja tidak hanya mengasosiasikan beberapa antarmuka ke kartu jaringan tunggal, namun juga beberapa alamat IP ke satu antarmuka. Ingat juga bahwa alamat IP dapat bersesuaian ke beberapa nama melalui DNS, dan bahwa sebuah nama dapat pula bersesuaian ke beberapa alamat IP numerik.
			</para>
			 <para>
				Seperti yang dapat Anda kira, konfigurasi dapat menjadi agak kompleks, namun pilihan ini hanya digunakan dalam kasus yang sangat khusus. Contoh yang dikutip di sini berupa konfigurasi yang tak biasa.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.ppp-rtc">
			<title>Terhubung dengan PPP melalui modem PSTN</title>
			 <indexterm>
				<primary>PPP</primary>
			</indexterm>
			 <indexterm>
				<primary>point to point</primary>
			</indexterm>
			 <indexterm>
				<primary>koneksi</primary>
				<secondary>dengan modem PSTN</secondary>
			</indexterm>
			 <indexterm>
				<primary>modem</primary>
				<secondary>PSTN</secondary>
			</indexterm>
			 <para>
				Koneksi point to pont (PPP) berlangsung sebuah koneksi yang berselang-seling; ini adalah solusi umum untuk koneksi yang dibuat dengan modem telepon (“PSTN modem”, karena koneksi melalui kabel jaringan telepon publik).
			</para>
			 <para>
				Koneksi dengan modem telepon memerlukan sebuah akun dengan akses provider, termasuk nomor telepon, nama pengguna, dan kata sandi, dan, terkadang protokol otentikasi yang digunakan. Koneksi dikonfigurasi menggunakan peralatan <command>pppconfig</command> dalam paket Debian dengan nama yang sama. Secara standar, dia mengatur nama koneksi <literal>provider</literal> (sebagai penyedia layanan Internet). Ketika ragu tentang protokol otentikasi, pilih <emphasis>PAP</emphasis>: ini ditawarkan oleh kebanyakan penyedia layanan Internet.
			</para>
			 <indexterm>
				<primary><command>pppconfig</command></primary>
			</indexterm>
			 <indexterm>
				<primary>PAP</primary>
			</indexterm>
			 <para>
				Setelah konfigurasi, adalah mungkin untuk menghubungkan dengan perintah <command>pon</command> (berikan nama koneksi sebagai parameter, ketika nilai standar dari <literal>provider</literal> tidak cocok). Link diputus dengan perintah <command>poff</command>. Kedua perintah ini dapat dieksekusi oleh root, atau pengguna lain, yang ada dalam group <literal>dip</literal>.
			</para>
			 <indexterm>
				<primary><command>pon</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>poff</command></primary>
			</indexterm>

		</section>
		 <section id="sect.adsl">
			<title>Menghubungkan melalui modem ADSL</title>
			 <indexterm>
				<primary>koneksi</primary>
				<secondary>dengan modem ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>modem</primary>
				<secondary>ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>ADSL, modem</primary>
			</indexterm>
			 <para>
				Istilah generik “ADSL modem” mencakup berbagai perangkat dengan fungsi yang sangat berbeda. Modem yang paling sederhana untuk digunakan dengan Linux adalah yang memiliki antarmuka Ethernet (dan tak hanya antarmuka USB). Ini menjadi populer; kebanyakan penyedia layanan meminjamkan (atau sewa) sebuah “box” ADSL dengan antarmuka Ethernet. Tergantung pada tipe modem, konfigurasi yang diperlukan dapat bermacam-macam.
			</para>
			 <section id="sect.adsl-pppoe">
				<title>Modem Mendukung PPPOE</title>
				 <indexterm>
					<primary>PPPOE</primary>
				</indexterm>
				 <indexterm>
					<primary><command>pppoeconf</command></primary>
				</indexterm>
				 <para>
					Beberapa modem Ethernet bekerja dengan protokol PPPOE (Point to Point Protocol over Ethernet). Alat <command>pppoeconf</command> (dari paket dengan nama yang sama) akan mengonfigurasi koneksi. Untuk melakukannya, dia memodifikasi berkas <filename>/etc/ppp/peers/dsl-provider</filename> dengan pengaturan yang disediakan dan merekam informasi login di berkas <filename>/etc/ppp/pap-secrets</filename> dan <filename>/etc/ppp/chap-secrets</filename>. Disarankan untuk menerima seluruh modifikasi yang ditawarkan.
				</para>
				 <para>
					Setelah konfigurasinya lengkap, Anda dapat membuka koneksi ADSL dengan perintah, <command>pon dsl-provider</command> dan memutuskannya dengan <command>poff dsl-provider</command>.
				</para>
				 <indexterm>
					<primary><literal>dsl-provider</literal></primary>
				</indexterm>
				 <sidebar> <title><emphasis>TIP</emphasis> Memulai <command>ppp</command> saat boot</title>
				 <indexterm>
					<primary><command>systemd</command></primary>
				</indexterm>
				 <indexterm>
					<primary><command>init</command></primary>
				</indexterm>
				 <para>
					Koneksi PPP melalui ADSL, secara definisi, terputus-putus. Karena mereka biasanya tidak ditagih berdasarkan waktu, ada beberapa dorongan untuk menjaganya tetap terbuka. Cara standar untuk melakukannya adalah dengan menggunakan sistem init.
				</para>
				 <para>
					Sistem init baku pada <emphasis role="distribution">Jessie</emphasis> adalah <command>systemd</command>. Menambahkan suatu tugas yang secara otomatis dimulai lagi bagi koneksi ADSL cukup dengan membuat suatu "berkas unit" seperti <filename>/etc/systemd/system/adsl-connection-service</filename>, dengan isi sebagai berikut:
				</para>
				 
<programlisting>[Unit]
Description=ADSL connection

[Service]
Type=forking
ExecStart=/usr/sbin/pppd call dsl-provider
Restart=always

[Install]
WantedBy=multi-user.target</programlisting>
				 <para>
					Sekali berkas unit ini didefiniskan, itu perlu diaktifkan dengan <command>systemctl enable adsl-connection</command>. Lalu pengulangan dapat diawali secara manual memakai <command>systemctl start adsl-connection</command>; itu juga akan dimulai secara otomatis saat boot.
				</para>
				 <para>
					Pada sistem yang tidak memakai <command>systemd</command> (termasuk <emphasis role="distribution">Wheezy</emphasis> dan versi Debian yang lebih lama), init SystemV standar bekerja secara berbeda. Pada sistem seperti itu, yang diperlukan adalah menambahkan baris berikut pada akhir berkas <filename>/etc/inittab</filename>; kemudian, kapan pun koneksi terputus, <command>init</command> akan menyambungkannya lagi.
				</para>
				 
<programlisting>
adsl:2345:respawn:/usr/sbin/pppd call dsl-provider</programlisting>
				 <para>
					Untuk koneksi ADSL yang memutus otomatis setiap hari, metode ini mengurangi durasi interupsi.
				</para>
				 </sidebar>
			</section>
			 <section id="sect.adsl-pptp">
				<title>Modem Mendukung PPTP</title>
				 <indexterm>
					<primary>PPTP</primary>
				</indexterm>
				 <para>
					Protokol PPTP (Point-to-Point Tunneling Protocol) dibuat oleh Microsoft. Digelar pada permulaan ADSL, ini telah digantikan secara cepat oleh PPPOE. Jika protokol ini dipaksakan pada Anda, lihat <xref linkend="sect.pptp" />.
				</para>

			</section>
			 <section id="sect.adsl-dhcp">
				<title>Modem Mendukung DHCP</title>
				 <para>
					Ketika sebuah modem terhubung ke komputer dengan sebuah kabel Ethernet (kabel crossover) Anda secara khusus mengonfigurasi koneksi jaringan dengan DHCP pada komputer; modem secara otomatis bertindak sebagai gateway secara default dan menangani routing (berarti dia mengatur traffik jaringan antara komputer dan Internet).
				</para>
				 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Kabel crossover untuk koneksi Ethernet langsung</title>
				 <indexterm>
					<primary>kabel crossover</primary>
				</indexterm>
				 <para>
					Kartu jaringan komputer berharap menerima data pada kawat khusus dalam kabel, dan mengirim datanya ke yang lainnya. Ketika menghubungkan komputer ke jaringan lokal, Anda biasanya menghubungkan sebuah kabel (straight atau crossover) antara kartu jaringan dan sebuah repeater atau switch. Akan tetapi, jika Anda ingin menghubungkan dua komputer secara langsung (tanpa perantara switch atau repeater), Anda harus me-route sinyal terkirim oleh satu kartu ke sisi penerima kartu lain, dan sebaliknya. Ini adalah tujuan kabel crossover, dan alasannya dipergunakan.
				</para>
				 <para>
					Perhatikan bahwa perbedaan ini menjadi hampir tidak relevan seiring berjalannya waktu, kartu jaringan modern dapat mendeteksi tipe kabel yang ada dan mengadaptasi yang sesuai dengannya, jadi tidak akan menjadi tak biasa bahwa kedua jenis kabel akan bekerja pada suatu lokasi tertentu.
				</para>
				 </sidebar> <para>
					Kebanyakan “ADSL routers” di pasaran dapat digunakan seperti ini, sebagaimana kebanyakan modem ADSL disediakan oleh penyedia layanan Internet.
				</para>

			</section>

		</section>
		 <section id="sect.roaming-network-config">
			<title>Konfigurasi Jaringan Otomatis untuk Pengguna Luar</title>
			 <indexterm>
				<primary><emphasis role="pkg">network-manager</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>jaringan</primary>
				<secondary>konfigurasi roaming</secondary>
			</indexterm>
			 <para>
				Banyak insinyur Falcot memiliki komputer laptop yang, untuk tujuan profesional, mereka gunakan juga di rumah. Konfigurasi jaringan yang digunakan berbeda berdasarkan lokasinya. Di rumah, mungkin berupa jaringan wifi (dilindungi oleh sebuah kunci WPA), ketika di tempat kerja menggunakan jaringan kabel untuk alasan keamanan dan bandwidth yang lebih.
			</para>
			 <para>
				Untuk menghindari penghubungan dan pemutusan masing-masing antarmuka jaringan, administrator menginstall paket <emphasis role="pkg">network-manager</emphasis> pada mesin roaming tersebut. Perangkat lunak ini memungkinkan pengguna unguk secara mudah berganti dari satu jaringan ke yang lainnya menggunakan sebuah ikon kecil yang ditampilkan pada area notifikasi dari desktop grafis mereka. Melakukan klik pada ikon ini menampilkan daftar jaringan tersedia (kabel dan wireless), agar mereka dapat memilih jaringan yang ingin mereka gunakan dengan mudah. Program menyimpan konfigurasi untuk jaringan yang telah dihubungkan oleh pengguna, dan secara otomatis berganti ke jaringan terbaik yang tersedia ketika koneksi terkini lenyap.
			</para>
			 <para>
				Untuk melakukan ini, struktur program diatur dalam dua bagian: sebuah daemon dijalankan sebagai root menangani aktivasi dan konfigurasi antarmuka jaringan dan antarmuka pengguna mengontrol daemon ini. PoricyKit menangani otorisasi yang diperlukan untuk mengontrol program ini dan Debian mengonfigurasi PolicyKit sedemikian rupa sehingga anggota group netdev dapat menambahkan atau mengubah koneksi Network Manager.
			</para>
			 <para>
				Network Manager mengetahui bagaimana menangani berbagai tipe koneksi (DHCP, konfigurasi manual, jaringan lokal), namun hanya jika konfigurasi diatur dengan program itu sendiri. Oleh karena itu, dia akan mengabaikan seluruh antarmuka jaringan secara sistematis di <filename>/etc/network/interfaces</filename> untuk yang tidak cocok. Karena Network Manager tidak memberikan rincian ketika tidak ada jaringan yang muncul, cara termudahnya adalah dengan menghapusnya dari <filename>/etc/network/interfaces</filename> beberapa konfigurasi untuk seluruh antarmuka yang harus diatur oleh Network Manager.
			</para>
			 <para>
				Catat bahwa program ini diinstall secara standar ketika “Desktop Environment” dipilih ketika instalasi awal.
			</para>
			 <sidebar> <title><emphasis>ALTERNATIF</emphasis> Konfigurasi dengan “profil jaringan”</title>
			 <indexterm>
				<primary><emphasis role="pkg">guessnet</emphasis></primary>
			</indexterm>
			 <para>
				Pengguna yang lebih mahir mungkin ingin mencoba paket <emphasis role="pkg">guessnet</emphasis> untuk konfigurasi jaringan otomatis. Sekelompok skrip test menentukan profil jaringan mana yang akan diaktifkan dan mengonfigurasinya dengan cepat.
			</para>
			 <para>
				Pengguna yang lebih memilih secara manual profil jaringan akan lebih memilih program <emphasis role="pkg">netenv</emphasis>, ditemukan pada paket dengan nama yang sama.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.hostname-name-service">
		<title>Mengatur Hostname dan Mengonfigurasi Name Service</title>
		 <indexterm>
			<primary>nama</primary>
			<secondary>atribusi dan resolusi</secondary>
		</indexterm>
		 <indexterm>
			<primary>penetapan nama</primary>
		</indexterm>
		 <para>
			Tujuan penetapan nama ke nomor IP adalah untuk membuatnya lebih mudah diingat oleh orang. Kenyataannya, sebuah alamat IP merupakan antarmuka jaringan yang diasosiasikan dengan sebuah perangkat seperti kartu jaringan. Karena setiap mesin dapat memiliki beberapa kartu jaringan, dan beberapa antarmuka pada setiap kartu, satu komputer dapat memiliki beberapa nama dalam sistem nama domain.
		</para>
		 <para>
			Setiap mesin, akan tetapi, diidentifikasi dengan sebuah nama utama (atau “canonical”), tersimpan di berkas <filename>/etc/hostname</filename> dan dikomunikaskan ke kernel Linux dengan skrip inisiasi melalui perintah <command>hostname</command>. Nilai terkini tersedia dalam sistem berkas virtual, dan Anda dapat mengambilnya dengan perintah <command>cat /proc/sys/kernel/hostname</command>.
		</para>
		 <indexterm>
			<primary><command>hostname</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> <filename>/proc/</filename> dan <filename>/sys/</filename>, sistem berkas virtual</title>
		 <indexterm>
			<primary><filename>/proc/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>proc</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/sys/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>sys</filename></primary>
		</indexterm>
		 <para>
			Pohon berkas <filename>/proc/</filename> dan <filename>/sys/</filename> dihasilkan oleh sistem berkas “virtual”. Ini merupakan cara praktis merekoveri informasi dari kernel (dengan mendaftar berkas virtual) dan berkomunikasi dengannya (dengan menulis ke berkas virtual).
		</para>
		 <para>
			<filename>/sys/</filename> khususnya didesain untuk menyediakan akses ke objek internal kernel, khususnya yang menggambarkan berbagai perangkan pada sistem. Oleh sebab itu, kernel dapat berbagi berbagai keping informasi: status tiap perangkat (misalnya, jika dia dalam mode hemat energi), apakah merupakan perangkat mudah lepas, dll. Catat bahwa <filename>/sys/</filename> hanya ada sejak kernel versi 2.6.
		</para>
		 </sidebar> <para>
			Herannya, nama domain tidak diatur dengan cara yang sama, namun datang dari nama lengkap dari mesin, didapatkan melalui resolusi nama. Anda dapat mengubahnya dalam berkas <filename>/etc/hosts</filename>; caranya tulis nama lengkap untuk mesin di sana di awal daftar nama yang sesuai dengan alamat mesin, sebagaimana contoh berikut:
		</para>
		 <informalexample> 
<programlisting>
127.0.0.1     localhost
192.168.0.1   arrakis.falcot.com arrakis</programlisting>
		 </informalexample> <indexterm>
			<primary><filename>hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/etc/hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary>domain</primary>
			<secondary>nama</secondary>
		</indexterm>
		 <indexterm>
			<primary>nama</primary>
			<secondary>domain</secondary>
		</indexterm>
		 <indexterm>
			<primary>NSS</primary>
		</indexterm>
		 <section id="sect.name-resolution">
			<title>Resolusi Nama</title>
			 <indexterm>
				<primary>resolusi</primary>
				<secondary>nama</secondary>
			</indexterm>
			 <indexterm>
				<primary>nama</primary>
				<secondary>resolusi</secondary>
			</indexterm>
			 <para>
				Mekanisme resolusi nama di Linux modular dan dapat menggunakan berbagai sumber informasi yang dideklarasikan di berkas <filename>/etc/nsswitch.conf</filename>. Entri yang melibatkan resolusi nama host ialah <literal>hosts</literal>. Secara default, berisi <literal>files dns</literal>, yang berarti sistem membaca berkas <filename>/etc/hosts</filename> terlebih dahulu, kemudian server DNS. NIS/NIS+ atau server LDAP merupakan kemungkinan sumber lain.
			</para>
			 <sidebar> <title><emphasis>CATATAN</emphasis> NSS dan DNS</title>
			 <para>
				Berhati-hatilah bahwa perintah khususnya dimaksudkan untuk membaca DNS (khususnya <command>host</command>) jangan menggunakan mekanisme resolusi nama standar (NSS). Konsekuensinya, mereka tidak memertimbangkan <filename>/etc/nsswitch.conf</filename>, dan demikian pula, <filename>/etc/hosts</filename> juga tidak.
			</para>
			 </sidebar> <section id="sect.dns-server-configuration">
				<title>Mengonfigurasi Server DNS</title>
				 <indexterm>
					<primary>DNS</primary>
				</indexterm>
				 <indexterm>
					<primary>Domain Name Service</primary>
				</indexterm>
				 <para>
					DNS (Layanan Nama Domain) merupakan layanan terdistribusi dn hirarkis pemetaan nama ke alamat IP, dan sebaliknya. Khususnya, dapat mengubah nama yang mudah dikenali manusia seperti <literal>www.eyrolles.com</literal> menjadi alamat IP aslinya, <literal>213.244.11.247</literal>.
				</para>
				 <para>
					Untuk mengakses informasi DNS, sebuah server DNS harus tersedia untuk merelay permintaan. Falcot Corp memilikinya, namun pengguna tunggal nampaknya perlu menggunakan server DNS yang disediakan oleh ISP mereka.
				</para>
				 <indexterm>
					<primary><filename>resolv.conf</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><literal>nameserver</literal></primary>
				</indexterm>
				 <para>
					Server DNS yang digunakan ditunjukkan dalam <filename>/etc/resolv.conf</filename>, satu per baris, dengan katakunci <literal>nameserver</literal> diikuti sebuah alamat IP, sebagaimana contoh berikut:
				</para>
				 
<programlisting>
nameserver 212.27.32.176
nameserver 212.27.32.177
nameserver 8.8.8.8</programlisting>
				 <para>
					Perhatikan bahwa berkas <filename>/etc/resolv.conf</filename> mungkin ditangani secara otomatis (dan ditimpa) ketika jaringan dikelola oleh NetworkManager atau dikonfigurasi melalui DHCP.
				</para>

			</section>
			 <section id="sect.etc-hosts">
				<title>Berkas <filename>/etc/hosts</filename></title>
				 <indexterm>
					<primary><filename>hosts</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/hosts</filename></primary>
				</indexterm>
				 <para>
					Jika dalam jaringan lokal tidak tersedia server nama, masih memungkinkan untuk membuat pemetaan kecil alamat IP dan hostname mesin dalam berkas <filename>/etc/hosts</filename>, biasanya disediakan untuk stasiun jaringan lokal. Sintaks berkas ini sangat sederhana: setiap baris menunjukkan alamat IP spesifik diikuti daftar nama yang sesuai (yang pertama “completely qualified”, artinya menyertakan nama domain).
				</para>
				 <para>
					Berkas ini tersedia bahkan selama di luar jaringan atau ketika server DNS tidak terjangkau, namun hanya benar-benar bermanfaat ketika terduplikasi pada seluruh mesin dalam jaringan. Perubahan sekecil apapun dalam korespondensi akan perlu memerbarui berkas di mana-mana. Oleh karena itu, <filename>/etc/hosts</filename> umumnya hanya berisi entri yang paling penting.
				</para>
				 <para>
					Berkas ini akan cukup untuk sebuah jaringan kecil yang tidak terhubung ke Internet, tapi dengan 5 mesin atau lebih, direkomendasikan untuk menginstall server DNS yang tepat.
				</para>
				 <sidebar> <title><emphasis>TIP</emphasis> Melompati DNS</title>
				 <para>
					Karena aplikasi memeriksa berkas <filename>/etc/hosts</filename> sebelum membaca DNS, memungkinkan untuk menyertakan informasi di dalamnya yang berbeda dari apa yang ditampilkan DNS, dan oleh karenanya, untuk melompati resolusi nama berbasis-DNS.
				</para>
				 <para>
					Hal ini mengizinkan, ketika perubahan DNS belum terpropagansi, untuk mencoba akses ke website dengan nama yang diharapkan bahkan jika namanya tidak terpetakan dengan baik ke alamat IP yang tepat.
				</para>
				 <para>
					Kemungkinan penggunaan lain untuk mengarahkan trafik yang diharapkan ke host tertentu ke localhost, mencegah komunikasi dengan host yang diberikan. Misalnya, hostname server yang didedikasikan untuk menyajikan iklan harus dialihkan yang akan membypass iklan ini hasilnya lebih tak pasti, kurang mengganggu, navigasi.
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.user-group-databases">
		<title>Pengguna dan Basisdata Kelompok</title>
		 <indexterm>
			<primary>pengguna</primary>
			<secondary>basisdata</secondary>
		</indexterm>
		 <indexterm>
			<primary>kelompok</primary>
			<secondary>basisdata</secondary>
		</indexterm>
		 <indexterm>
			<primary>basisdata</primary>
			<secondary>pengguna</secondary>
		</indexterm>
		 <indexterm>
			<primary>basisdata</primary>
			<secondary>kelompok</secondary>
		</indexterm>
		 <para>
			Daftar pengguna biasanya disimpan di berkas <filename>/etc/passwd</filename>, ketika berkas <filename>/etc/shadow</filename> menyimpan kata sandi terenkripsi. Keduanya berupa berkas teks, dalam format yang relatif sederhana, yang dapat dibaca dan dimodifikasi dengan teks editor. Setiap pengguna terdaftar di sana dalam sebuah baris dengan beberapa field dipisahkan dengan titik dua (“<literal>:</literal>”).
		</para>
		 <sidebar> <title><emphasis>CATATAN</emphasis> Menyunting berkas sistem</title>
		 <para>
			Berkas sistem yang disebutkan di bab ini seluruhnya berupa berkas teks polos, dan dapat disunting dengan teks editor. Memertimbangkan betapa penting fungsionalitasnya ke sistem inti, sebaiknya lebih berhati-hati ketika menyunting berkas sistem. Pertama, selalu buat salinan atau backup dari berkas sistem sebelum membuka atau menyuntingnya. Kedua, pada server atau mesin di mana lebih dari satu orang yang mungkin mengakses berkas yang sama, lakukan beberapa langkah untuk melindungi dari korupsi berkas.
		</para>
		 <para>
			Untuk tujuan ini, cukup gunakan perintah <command>vipw</command> untuk menyunting berkas <filename>/etc/passwd</filename>, atau <command>vigr</command> untuk menyunting <filename>/etc/group</filename>. Perintah ini mengunci berkas yang dimaksud setelah menjalankan teks editor, (secara default <command>vi</command>, kecuali variabel lingkungan <varname>EDITOR</varname> telah diubah). Pilihan <literal>-s</literal> pada perintah ini mengizinkan penyuntingan berkas <foreignphrase>shadow</foreignphrase> yang sesuai.
		</para>
		 </sidebar> <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Crypt, fungsi searah</title>
		 <indexterm>
			<primary>crypt</primary>
		</indexterm>
		 <para>
			<command>crypt</command> merupakan fungsi searah yang mengubah string (<varname>A</varname>) ke string lain (<varname>B</varname>) di mana <varname>A</varname> tidak dapat diturunkan dari <varname>B</varname>. Satu-satunya cara mengidentifikasi <varname>A</varname> ialah dengan mengetes semua variabel yang mungkin, memeriksa satu per satu apakah perubahan fungsi akan menghasilkan <varname>B</varname> atau tidak. Menggunakan hingga 8 karakter sebagai masukan (string <varname>A</varname>) dan menghasilkan satu dari 13 string, dapat tercetak, karakter ASCII (string <varname>B</varname>).
		</para>
		 </sidebar> <section id="sect.etc-passwd">
			<title>Daftar Pengguna: <filename>/etc/passwd</filename></title>
			 <para>
				Berikut ini daftar field dalam berkas <filename>/etc/passwd</filename>:
			</para>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/passwd</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>uid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>gid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>GECOS</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>login</literal></primary>
			</indexterm>
			 <itemizedlist>
				<listitem>
					<para>
						login, contohnya <literal>rhertzog</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						password: kata sandi ini terenkripsi oleh fungsi searah (<command>crypt</command>), menggunakan <literal>DES</literal>, <literal>MD5</literal>, <literal>SHA-256</literal> atau <literal>SHA-512</literal>. Nilai khusus “<literal>x</literal>” menandakan bahwa kata sandi terenkripsi disimpan di <filename>/etc/shadow</filename>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uid</literal>: nomor identifikasi unik tiap pengguna;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: nomor unik untuk kelompok utama pengguna (secara default Debian membuat kelompok khusus untuk tiap pengguna);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>GECOS</literal>: field data biasanya berisi nama lengkap pengguna;
					</para>

				</listitem>
				 <listitem>
					<para>
						direktori login, diberikan ke pengguna ruang untuk berkas pribadi mereka (variabel lingkungan <varname>$HOME</varname> umumnya mengarah ke sini);
					</para>

				</listitem>
				 <listitem>
					<para>
						program yang dieksekusi ketika login. Ini biasanya berupa perintah interpreter (shell), memberikan kebebasan pada pengguna. Jika Anda menentukan <command>/bin/false</command> (yang tak melakukan apapun dan mengembalikan kontrol seketika), pengguna tidak dapat login.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Kelompok unix</title>
			 <indexterm>
				<primary>kelompok</primary>
			</indexterm>
			 <para>
				Sebuah kelompok Unix merupakan sebuah entitas termasuk beberapa pengguna jadi mereka dapat berbagi secara mudah menggunakan sistem hak akses terintegrasi (dengan memanfaatkan hak yang sama). Anda dapat juga menghalangi penggunaan beberapa program ke kelompok tertentu.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-shadow">
			<title>Berkas Kata Sandi Tersembunyi dan Terenkripsi: <filename>/etc/shadow</filename></title>
			 <indexterm>
				<primary><filename>shadow</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/shadow</filename></primary>
			</indexterm>
			 <para>
				Berkas <filename>/etc/shadow</filename> berisi field-field berikut:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						login;
					</para>

				</listitem>
				 <listitem>
					<para>
						kata sandi terenkripsi;
					</para>

				</listitem>
				 <listitem>
					<para>
						beberapa field mengelola masa kadaluarsa kata sandi.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>DOKUMENTASI</emphasis> Format berkas <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> dan <filename>/etc/group</filename></title>
			 <para>
				Format berikut didokumentasikan dalam man pages berikut: <citerefentry><refentrytitle>passwd</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>shadow</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>, and <citerefentry><refentrytitle>group</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>.
			</para>
			 </sidebar> <sidebar> <title><emphasis>KEAMANAN</emphasis> Keamanan berkas <filename>/etc/shadow</filename></title>
			 <para>
				<filename>/etc/shadow</filename>, tak seperti rivalnya, <filename>/etc/passwd</filename>, tidak dapat dibaca oleh pengguna biasa. Katasandi terenkripsi yang tersimpan di <filename>/etc/passwd</filename> dapat dibaca oleh siapa saja; seorang cracker dapat mencoba untuk “merusak” (atau mengambil) password dengan salah satu metode “brute force” yang, mencoba menebak kombinasi karakter yang biasa digunakan. Serangan ini — disebut "dictionary attack" — tak lagi mungkin pada sistem yang menggunakan <filename>/etc/shadow</filename>.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.account-modification">
			<title>Memodifikasi Akun atau Password yang Ada</title>
			 <indexterm>
				<primary><command>chsh</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chfn</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chage</command></primary>
			</indexterm>
			 <indexterm>
				<primary>password</primary>
			</indexterm>
			 <para>
				Perintah berikut memungkinkan modifikasi informasi tersimpan pada field spesifik pada basisdata pengguna: <command>passwd</command> mengizinkan pengguna mengganti password mereka, di mana ketika dijalankan, memerbarui berkas <filename>/etc/shadow</filename>; <command>chfn</command> (CHange Full Name), milik pengguna-super (root), memodifikasi field <literal>GECOS</literal>. <command>chsh</command> (CHange SHell) mengizinkan pengguna untuk mengubah shell login mereka, akan tetapi pilihan yang tersedia terbatas yang terdaftar pada <filename>/etc/shells</filename>; di samping itu, administrator tidak terikat pada batasan ini dan dapat mengatur shell ke program pilihan mereka.
			</para>
			 <para>
				Akhirnya, perintah <command>chage</command> (CHange AGE) mengizinkan administrator mengubah pengaturan masa kadaluarsa password (pilihan <literal>-l <replaceable>pengguna</replaceable></literal> akan menampilkan pengaturan kini). Anda dapat pula memaksa masa kadaluarsa password menggunakan perintah <command>passwd -e <replaceable>pengguna</replaceable></command>, di mana pengguna perlu mengganti password mereka ketika login berikutnya.
			</para>

		</section>
		 <section id="sect.disabling-account">
			<title>Menonaktifkan sebuah Akun</title>
			 <indexterm>
				<primary>Nonaktifkan sebuah akun</primary>
			</indexterm>
			 <indexterm>
				<primary>akun</primary>
				<secondary>nonaktif</secondary>
			</indexterm>
			 <para>
				Anda mungkin perlu “menonaktifkan sebuah akun” (mengunci seorang pengguna), sebagai tindakan disipliner, untuk tujuan investigasi, atau ketika saat berkepanjangan atau ketidakpastian kehadiran penguna. Akun dinonaktifkan berarti pengguna tidak dapat login atau mendapatkan akses ke mesin. Akun tetap ada pada mesin dan tidak ada berkas atau data yang dihapus; hanya tidak dapat diakses. Hal ini dapat dilakukan dengan perintah <command>passwd -l <replaceable>pengguna</replaceable></command> (lock). Mengaktifkan kembali akun diaktifkan dengan cara yang mirip, dengan pilihan (unlock) <literal>-u</literal>.
			</para>
			 <sidebar id="sidebar.intro-nss"> <title><emphasis>LEBIH JAUH</emphasis> NSS dan basisdata sistem</title>
			 <indexterm>
				<primary>NSS</primary>
			</indexterm>
			 <indexterm>
				<primary>Name Service Switch</primary>
			</indexterm>
			 <para>
				Daripada menggunakan berkas yang biasanya untuk mengelola daftar pengguna dan kelompok, Anda dapat menggunakan tipe basisdata lain, seperti LDAP atau <command>db</command>, dengan menggunakan modul NSS (Name Service Switch) yang cocok. Modul yang diguankan terdaftar di berkas <filename>/etc/nsswitch.conf</filename>, di bawah entri <literal>passwd</literal>, <literal>shadow</literal> dan <literal>group</literal>. Lihat <xref linkend="sect.config-nss" /> untuk sebuah contoh spesifik penggunaan modul NSS dengan LDAP.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-group">
			<title>Daftar Kelompok: <filename>/etc/group</filename></title>
			 <para>
				Kelompok terdaftar di berkas <filename>/etc/group</filename>, basisdata tekstuan sederhana dalam format mirip berkas <filename>/etc/passwd</filename>, dengan field sebagai berikut:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						group name;
					</para>

				</listitem>
				 <listitem>
					<para>
						password (pilihan): Ini hanya digunakan untuk menggabungkan kelompok ketika seseorang bukan anggota yang biasa (dengan perintah <command>newgrp</command> atau <command>sg</command>, lihat bilah tepi <xref linkend="sidebar.working-with-several-groups" />);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: nomor identifikasi unik kelompok;
					</para>

				</listitem>
				 <listitem>
					<para>
						daftar anggota: daftar nama penggua yang merupakan anggota kelompok, dipisahkan dengan koma.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
			</para>
			 <sidebar id="sidebar.working-with-several-groups"> <title><emphasis>KEMBALI KE DASAR</emphasis> Bekerja dengan beberapa kelompok</title>
			 <indexterm>
				<primary><command>newgrp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sg</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>id</command></primary>
			</indexterm>
			 <indexterm>
				<primary>group</primary>
				<secondary>change</secondary>
			</indexterm>
			 <para>
				Setiap pengguna mungkin anggota dari beberapa kelompok; salah satunya “kelompok utama” mereka. Kelompok utama pengguna secara standar, dibuat ketika konfigurasi awal pengguna. Secara standar, setiap berkas yang dibuat pengguna adalah milik mereka, sebagaimana kelompok utama mereka. Hal ini tidak selalu diinginkan; contohnya, ketika penggua bekerja pada direktori yang dibagi dengan kelompok selain kelompok utama mereka. Dalam hal ini, pengguna perlu mengubah kelompok utama mereka menggunakan perintah berikut; <command>newgrp</command>, yang memulai shell baru, atau <command>sg</command>, yang mengeksekusi perintah menggunakan kelompok alternatif yang diberikan. Perintah ini juga mengizinkan pengguna ke kelompok yang bukan miliknya. Jika kelompok diproteksi password, mereka perlu memasukkan password yang sesuai sebelum perintah dieksekusi.
			</para>
			 <para>
				Alternatifnya, pengguna dapat mengatur bit <literal>setgid</literal> pada direktori, akibatnya berkas yang dibuat dalam direktori tersebut secara otomatis dimilik oleh kelompok yang tepat. Untuk lebih rincinya, lihat bilah tepi <xref linkend="sidebar.setgid-dir" />.
			</para>
			 <para>
				Perintah <command>id</command> menampilkan kondisi terkini pengguna, dengan indentifier personal mereka (variabel <varname>uid</varname>), kelompok utama saat ini (variabel <varname>gid</varname>), dan daftar kelompok milik mereka (variabel <varname>groups</varname>).
			</para>
			 </sidebar> <indexterm>
				<primary><filename>group</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/group</filename></primary>
			</indexterm>
			 <para>
				Perintah <command>addgroup</command> dan <command>delgroup</command> menambah dan menghapus kelompok, masing-masing. Perintah <command>groupmod</command> memodifikasi informasi kelompok (<literal>gid</literal>-nya atau identifier). Perintah <command>passwd -g <replaceable>kelompok</replaceable></command> mengubah password untuk kelompok, sedangkan perintah <command>passwd -r -g <replaceable>kelompok</replaceable></command> menghapusnya.
			</para>
			 <indexterm>
				<primary><command>addgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>delgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>groupmod</command></primary>
			</indexterm>
			 <indexterm>
				<primary>kelompok</primary>
				<secondary>pembuatan</secondary>
			</indexterm>
			 <indexterm>
				<primary>pembuatan</primary>
				<secondary>kelompok</secondary>
			</indexterm>
			 <indexterm>
				<primary>kelompok</primary>
				<secondary>penghapusan</secondary>
			</indexterm>
			 <indexterm>
				<primary>penghapusan sebuah kelompok</primary>
			</indexterm>
			 <sidebar> <title><emphasis>TIP</emphasis> <command>getent</command></title>
			 <indexterm>
				<primary><command>getent</command></primary>
			</indexterm>
			 <para>
				Perintah <command>getent</command> (get entries) memeriksa basisdata sistem dengan cara standar, menggunakan fungsi pustaka yang sesuai, di mana akan memanggil modul NSS yang dikonfigurasi di berkas <filename>/etc/nsswitch.conf</filename>. Perintah mengambil satu atau dua argumen: nama basisdata untuk diperiksa, dan kata kunci yang mungkin. Nah, perintah <command>getent passwd rhertzog</command> akan memberikan informasi dari basisdata pengguna terkait pengguna <literal>rhertzog</literal>.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.creating-accounts">
		<title>Membuat Akun</title>
		 <indexterm>
			<primary>akun</primary>
			<secondary>pembuatan</secondary>
		</indexterm>
		 <indexterm>
			<primary>pembuatan</primary>
			<secondary>akun pengguna</secondary>
		</indexterm>
		 <para>
			Salah satu aksi pertama yang perlu administrator lakukan ketika mengatur mesin baru ialah membuat akun pengguna. Hal ini dapat dilakukan dengan perintah <command>adduser</command> di mana nama-pengguna untuk pengguna baru akan dibuat, sebagai sebuah argumen.
		</para>
		 <indexterm>
			<primary><command>adduser</command></primary>
		</indexterm>
		 <para>
			Perintah <command>adduser</command> menanyakan beberapa hal sebelum membuat akun, namun penggunaannya cukup mudah. Berkas konfigurasinya, <filename>/etc/adduser.conf</filename>, menyertakan pengaturan yang menarik: dia dapat digunakan untuk secara otomatis mengatur quota untuk setiap pengguna dengna membuat template pengguna, atau mengganti lokasi akun pengguna; yang berikutnya jarang digunakan, namun akan memudahkan ketika Anda memiliki banyak pengguna dan ingin membagi akun mereka pada beberapa cakram, misalnya. Anda juga dapat memilih shell standar yang berbeda.
		</para>
		 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Quota</title>
		 <indexterm>
			<primary>kuota</primary>
		</indexterm>
		 <para>
			Istilah “quota” mengacu pada batasan pada sumberdaya mesin yang diperbolehkan digunakan oleh pengguna. Hal ini sering kali mengacu pada ruang diska.
		</para>
		 </sidebar> <para>
			Pembuatan sebuah akun mengumpulkan direktori home pengguna dengan konten berkas templat <filename>/etc/skel/</filename>. Menyediakan pengguna dengan set direktori standar dan berkas konfigurasinya.
		</para>
		 <indexterm>
			<primary>kelompok</primary>
			<secondary>menambahkan pengguna</secondary>
		</indexterm>
		 <indexterm>
			<primary>menambahkan pengguna ke kelompok</primary>
		</indexterm>
		 <para>
			Dalam beberapa kasus, hal ini akan berguna untuk menambahkan pengguna ke sebuah kelompok (di samping kelompok “utama” mereka) agar dapat memberi mereka hak akses tambahan. Misalnya, seorang pengguna yang disertakan dalam kelompok <emphasis>audio</emphasis> dapat mengakses perangkat audio (lihat bilah tepi <xref linkend="sidebar.special-files" />). Hal ini dapat dilakukan dengan perintah seperti <command>adduser <replaceable>pengguna</replaceable> <replaceable>kelompok</replaceable></command>.
		</para>
		 <sidebar id="sidebar.special-files"> <title><emphasis>KEMBALI KE DASAR</emphasis> Hak akses perangkat</title>
		 <indexterm>
			<primary>perangkat</primary>
			<secondary>hak akses</secondary>
		</indexterm>
		 <indexterm>
			<primary>berkas</primary>
			<secondary>khusus</secondary>
		</indexterm>
		 <indexterm>
			<primary>mode</primary>
			<secondary>karakter</secondary>
		</indexterm>
		 <indexterm>
			<primary>mode</primary>
			<secondary>blok</secondary>
		</indexterm>
		 <indexterm>
			<primary>blok, mode</primary>
		</indexterm>
		 <indexterm>
			<primary>karakter, mode</primary>
		</indexterm>
		 <indexterm>
			<primary>khusus, berkas</primary>
		</indexterm>
		 <indexterm>
			<primary><command>mknod</command></primary>
		</indexterm>
		 <para>
			Setiap perangkat periferal hardware direpresentasikan di Unix dengan berkas khusus, biasanya disimpan dalam pohon berkas di bawah <filename>/dev/</filename> (DEVices). Dua tipe berkas khusus ada berdasarkan sifat alami perangkat: berkas “mode karakter” dan “mode blok”, setiap mode terbatas hanya pada beberapa operasi. Mode karakter membatasi interaksi dengan operasi membaca/menulis, mode blok juga dapat mencari dalam data yang tersedia. Akhirnya, setiap berkas khusus diasosiasikan dengan dua nomor (“major” dan “minor”) yang mengidentifikasi perangkat ke kernel dengan cara yang unik. Seperti berkas, dibuat oleh perintah <command>mknod</command>, berisi nama simbolik (dan lebih mudah dikenali manusia).
		</para>
		 <para>
			Hak akses berkas khusus dipetakan ke hak akses yang diperlukan untuk mengakses perangkat itu sendiri. Nah, sebuah berkas seperti <filename>/dev/mixer</filename>, merepresentasikan audio mixer, hanya root yang memiliki hak akses baca/tulis dan anggota kelompok <literal>audio</literal>. Hanya pengguna ini yang dapat mengoperasikan audio mixer.
		</para>
		 <para>
			Perlu dicatat bahwa kombinasi <emphasis role="pkg">udev</emphasis>, <emphasis role="pkg">consolekit</emphasis> dan <emphasis role="pkg">policykit</emphasis> dapat menambahkan hak akses tambahan yang mengizinkan pengguna yang secara fisik terhubung ke konsol (dan tidak melalui jaringan) untuk mengakses perangkat tertentu.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.shell-environment">
		<title>Lingkungan Shell</title>
		 <para>
			Perintah interpreter (atau shell) bisa menjadi kontak pertama pengguna dengan komputer, dan mereka haruslan lebih bersahabat. Kebanyakan dari mereka menggunakan skrip inisiasi yang memungkinkan konfigurasi kebiasaan mereka (pelengkapan otomatis, teks sapaan, dll.).
		</para>
		 <indexterm>
			<primary>antarmuka baris perintah</primary>
		</indexterm>
		 <indexterm>
			<primary>interpreter perintah</primary>
		</indexterm>
		 <indexterm>
			<primary>shell</primary>
		</indexterm>
		 <indexterm>
			<primary><command>bash</command></primary>
		</indexterm>
		 <para>
			<command>bash</command>, standar shell, gunakan skrip inisiasi <filename>/etc/bash.bashrc</filename> untuk shell “interactif”, dan <filename>/etc/profile</filename> untuk shell “login”.
		</para>
		 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Shell login dan shell (non) interaktif</title>
		 <para>
			Dalam istilah yang sederhana, shell login dipanggil ketika Anda login ke konsol entah itu secara lokal atau remote melalui <command>ssh</command>, atau ketika Anda menjalankan perintah <command>bash --login</command> secara eksplisit. Tak peduli apakah berupa shell login atau bukan, sebuah shell dapat menjadi interaktif (dalam sebuah terminal bertipe <command>xterm</command> misalnya); atau non-interaktif (ketika mengeksekusi sebuah skrip).
		</para>
		 </sidebar> <sidebar> <title><emphasis>PENEMUAN</emphasis> Shell lain, skrip lain</title>
		 <para>
			Setiap perintah interpreter memiliki sintaks spesifik dan berkas konfigurasinya. Nah, <command>zsh</command> menggunakan <filename>/etc/zshrc</filename> dan <filename>/etc/zshenv</filename>; <command>csh</command> menggunakan <filename>/etc/csh.cshrc</filename>, <filename>/etc/csh.login</filename> dan <filename>/etc/csh.logout</filename>. Laman man untuk program ini mencatat berkas mana yang mereka gunakan.
		</para>
		 <indexterm>
			<primary><command>zsh</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>csh</command></primary>
		</indexterm>
		 </sidebar> <para>
			Untuk <command>bash</command>, sebaiknya aktifkan “pelengkapan otomatis” dalam berkas <filename>/etc/bash.bashrc</filename> (dengan menghapus komentar beberapa baris).
		</para>
		 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Pelengkapan otomatis</title>
		 <indexterm>
			<primary>pelengkapan otomatis</primary>
		</indexterm>
		 <para>
			Beberapa perintah interpreter menyediakan fitur pelengkapan otomatis, yang memungkinkan shell secara otomatis melengkapi sebagian nama perintah yang diketik atau argumen ketika pengguna menekan tombol <keycap>Tab</keycap>. Hal ini memudahkan pengguna bekerja lebih efisien dan tidak lagi rawan-kesalahan.
		</para>
		 <para>
			Fungsi ini sangat powerful dan fleksibel. Memungkinkan pula untuk mengonfigurasi tingkah-lakunya berdasarkan setiap perintah. Nah, argumen pertama yang mengikuti <command>apt-get</command> akan diajukan berdasarkan sintaks perintah ini, bahkan jika tidak cocok dengan beberapa berkas (dalam hal ini, kemungkinan pilihan ialah <literal>install</literal>, <literal>remove</literal>, <literal>upgrade</literal>, dll.).
		</para>
		 </sidebar> <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Tilde, pintasan ke HOME</title>
		 <indexterm>
			<primary>~</primary>
		</indexterm>
		 <indexterm>
			<primary>tilde</primary>
		</indexterm>
		 <para>
			Tilde biasanya digunakan untuk menunjukkan direktori di mana variabel lingkungan, <varname>HOME</varname>, mengarah (menjadi direktori home pengguna, seperti <filename>/home/rhertzog/</filename>). Perintah interpreter secara otomatis mengganti: <filename>~/hello.txt</filename> menjadi <filename>/home/rhertzog/hello.txt</filename>.
		</para>
		 <para>
			Tilde juga mengizinkan akses ke direktori home pengguna lain. Nah, <filename>~rmas/bonjour.txt</filename> sinonim dengan <filename>/home/rmas/bonjour.txt</filename>.
		</para>
		 </sidebar> <para>
			Sebagai tambahan skrip umum ini, setiap pengguna dapat membuat <filename>~/.bashrc</filename> dan <filename>~/.bash_profile</filename> mereka sendiri untuk mengonfigurasi shell mereka. Perubahan paling umum ialah penambahan alias; merupakan kata yang secara otomatis diganti dengan eksekusi sebuah perintah, membuatnya lebih cepat menjalankan perintah tersebut. Misalnya, Anda dapat membuat alias <literal>la</literal> untuk perintah <command>ls -la | less</command>; kemudian Anda hanya perlu mengetik <command>la</command> untuk melihat isi direktori secara rinci.
		</para>
		 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Variabel lingkungan</title>
		 <indexterm>
			<primary>lingkungan</primary>
			<secondary>variabel lingkungan</secondary>
		</indexterm>
		 <indexterm>
			<primary>variabel, lingkungan</primary>
		</indexterm>
		 <para>
			Variabel lingkungan mengizinkan penyimpanan pengaturan global untuk shell atau berbagai program yang dipanggil. Mereka kontekstual (setiap proses memiliki set lingkungan variabel mereka sendiri) namun dapat diturunkan. Karakteristik terakhir menawarkan kemungkinan untuk shell login untuk menyatakan variabel yang akan dilalui semua program yang dieksekusi.
		</para>
		 </sidebar> <para>
			Pengaturan variabel lingkungan standar merupakan elemen penting dari konfigurasi shell. Membiarkan variabel spesifik ke sebuah shell, sebaiknya disimpan dalam berkas <filename>/etc/environment</filename>, karena dia digunakan oleh berbagai program untuk menginisiasi sesi shell. Variabel khususnya ditentukan di sana termasuk <varname>ORGANIZATION</varname>, di mana biasanya berisi nama perusahaan atau organisasi, dan <varname>HTTP_PROXY</varname>, di mana menunjukkan ada tidaknya dan lokasi sebuah proxy HTTP.
		</para>
		 <sidebar> <title><emphasis>TIP</emphasis> Semua shell terkonfigurasi identik</title>
		 <para>
			Pengguna seringkali ingin mengonfigurasi shell login dan interaktifnya dalam cara yang sama. Untuk melakukannya, mereka memilih untuk meng-interpret (atau “source”) konten dari <filename>~/.bashrc</filename> dalam berkas <filename>~/.bash_profile</filename>. Memungkinkan pula dilakukan hal yang sama dengan berkas umum untuk semua pengguna (dengan memanggil <filename>/etc/bash.bashrc</filename> dari <filename>/etc/profile</filename>).
		</para>
		 </sidebar>
	</section>
	 <section id="sect.config-printing">
		<title>Konfigurasi Pencetak</title>
		 <indexterm>
			<primary>konfigurasi</primary>
			<secondary>pencetak</secondary>
		</indexterm>
		 <indexterm>
			<primary>pencetak</primary>
			<secondary>konfigurasi</secondary>
		</indexterm>
		 <para>
			Konfigurasi pencetak memang mengakibatkan banyak masalah untuk administrator dan pengguna pula. Masalah tersebut kini hanya merupakan masa lalu, terima kasiih <emphasis role="pkg">cups</emphasis>, server pencetak bebas menggunakan protokol IPP (Internet Printing Protocol).
		</para>
		 <indexterm>
			<primary>IPP</primary>
		</indexterm>
		 <indexterm>
			<primary>Internet Printing Protocol</primary>
		</indexterm>
		 <indexterm>
			<primary><command>cups</command></primary>
		</indexterm>
		 <para>
			Program ini dibagi dalam beberapa paket Debian: <emphasis role="pkg">cups</emphasis> merupakan sentral server pencetak; <emphasis role="pkg">cups-bsd</emphasis> adalah lapisan kompabilitas yang mengizinkan penggunaan perintah dari sistem pencetak BSD tradisional (daemon <command>lpd</command>, perintah <command>lpr</command> dan <command>lpq</command>, dll.); <emphasis role="pkg">cups-client</emphasis> berisi sekelompok program untuk berinteraksi dengan server (blok atau izinkan sebuah printer, tampilkan atau hapus tugas pencetakan yang sedang diproses, dll.); dan akhirnya, <emphasis role="pkg">cups-driver-gutenprint</emphasis> berisi koleksi driver pencetak tambahan untuk <command>cups</command>.
		</para>
		 <indexterm>
			<primary><command>lpr</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpq</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>KOMUNITAS</emphasis> CUPS</title>
		 <indexterm>
			<primary>CUPS</primary>
		</indexterm>
		 <indexterm>
			<primary>Common Unix Printing System</primary>
		</indexterm>
		 <para>
			CUPS (Common Unix Printing System) merupakan proyek (dan sebuah merk dagang) dikelola oleh Apple, Inc. <ulink type="block" url="http://www.cups.org/" />
		</para>
		 </sidebar> <para>
			Setelah instalasi paket-paket berbeda ini, <command>cups</command> dikelola dengan mudah melalui antarmuka web yang dapat diakses pada alamat lokal: <literal>http://localhost:631/</literal>. Di sana Anda dapat menambahkan pencetak (termasuk pencetak jaringan), menghapus, dan mengelolanya. Anda dapat pula mengelola <command>cups</command> dengan antarmuka grafis yang disediakan oleh lingkungan desktop. Terakhir, ada juga antarmuka grafis <command>system-config-printer</command> (dari paket Debian dengan nama yang sama).
		</para>
		 <indexterm>
			<primary><command>cups</command></primary>
			<secondary>administrasi</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>CATATAN</emphasis> Keusangan <filename>/etc/printcap</filename></title>
		 <para>
			<emphasis>cups</emphasis> tidak lagi menggunakan berkas <filename>/etc/printcap</filename>, yang mana sekarang telah usang. Program yang mengandalkan berkas ini untuk mengapatkan daftar pencetak yang tersedia, akan gagal. Untuk menghindari hal ini, hapus berkas ini dan buat tautan simbolis (lihat bilah tepi <xref linkend="sidebar.symbolic-link" />) ke <filename>/var/run/cups/printcap</filename>, yang dikelola oleh <emphasis>cups</emphasis> untuk memastikan kompabilitasnya.
		</para>
		 <indexterm>
			<primary><filename>printcap</filename></primary>
		</indexterm>
		 </sidebar>
	</section>
	 <section id="sect.config-bootloader">
		<title>Mengonfigurasi Bootloader</title>
		 <indexterm>
			<primary>loader</primary>
			<secondary>bootloader</secondary>
		</indexterm>
		 <indexterm>
			<primary>bootloader</primary>
		</indexterm>
		 <para>
			Mungkin ini telah berfungsi, namun akan lebih baik jika mengetahui bagaimana mengonfigurasi dan menginstall bootloader jika dia menghilang dari Master Boot Record. Hal ini dapat terjadi setelah instalasi sistem operasi lainnya, seperti Windows. Informasi berikut dapat pula membantu Anda untuk memodifikasi konfigurasi bootloader jika diperlukan.
		</para>
		 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Master boot record</title>
		 <indexterm>
			<primary>MBR</primary>
		</indexterm>
		 <indexterm>
			<primary>Master Boot Record</primary>
		</indexterm>
		 <para>
			Master Boot Record (MBR) menempati 512 byte pertama pada hard disk pertama, dan merupakan yang pertama dimuat oleh BIOS untuk mengambil alih kontrol ke sebuah program yang dapat mem-boot sistem operasi yang diinginkan. Umumnya, sebuah bootloader terinstall di MBR, menghapus konten sebelumnya.
		</para>
		 </sidebar> <section id="sect.identify-disks">
			<title>Mengidentifikasi Cakram</title>
			 <sidebar> <title><emphasis>KULTUR</emphasis> <emphasis>udev</emphasis> dan <filename>/dev/</filename></title>
			 <para>
				Direktori <filename>/dev/</filename> secara tradisional menyimpan berkas yang disebut berkas “khusus”, dimaksudkan untuk merepresentasikan peripheral sistem (lihat bilah tepi <xref linkend="sidebar.special-files" />). Suatu ketika, dia seharusnya berisi berkas yang kemungkinan akan digunakan. Pendekatan ini memiliki beberapa latarbelakang yang kenyataannya membatasi beberapa perangkat yang mungkin digunakan (karena daftar nama yang sulit dikodekan), dan tidak mungkin untuk mengetahui berkas khusus yang mana yang sedang digunakan.
			</para>
			 <para>
				Dewasa ini, pengelolaan berkas khusus seluruhnya bersifat dinamis dan sesuai lebih baik dengan sifat komputer yang dapat digonta-ganti, perangkat. Kernel berkerja sama dengan <emphasis>udev</emphasis> untuk membuat dan menghapusnya jika diperlukan ketika perangkat tertentu muncul dan menghilang. Untuk alasan ini, <filename>/dev/</filename> tidak pelu bersifat persistent dan merupakan sistem berkas berbasis-RAM yang dimulai kosong dan hanya berisi masukan yang sesuai.
			</para>
			 <para>
				Kernal mengomunikasikan banyak informasi tentang perangkat-perangkat baru yang ditambahkan dan menyediakan pasangan nomor major/minor untuk mengidentifikasinya. Dengan ini <command>udevd</command> dapat membuat berkas khusus di bawah nama dan dengan hak akses yang dimintanya. Dapat pula membuat alias dan melakukan tindakan lain (tugas pendaftaran atau inisialisasi misalnya). Tingkah laku <command>udevd</command> didorong oleh kumpulan besar aturan (yang dapat dikustomisasi).
			</para>
			 <para>
				Dengan penamaan dinamis, Anda dapat menetapkan nama yang sama untuk perangkat terterntu, tergantung penghubung atau urutan hubungan, yang khususnya berguna ketika Anda menggunakan berbagai peripheral USB. Partisi pertama pada hard drive pertama kemudian dapat disebut <filename>/dev/sda1</filename> untuk kompabilitas, atau jika Anda lebih memilih <filename>/dev/root-partition</filename>, atau bahkan keduanya pada saat yang sama karena <command>udevd</command> dapat dikonfigurasi secara otomatis untuk membuat tautan simbolis.
			</para>
			 <para>
				Jaman dahulu, beberapa modul kernel secara otomatis dimuat ketika Anda mencoba mengakses berkas perangkat terkait. Ini tidak lagi terjadi, dan berkas khusus periferal tidak lagi ada sebelum memuat modul; ini bukan masalah besar, karena kebanyakan modul dimuat saat boot terimakasih untuk deteksi otomatis perangkat keras. Namun untuk periferal yang tidak dapat terdeteksi (seperti perangkat keras jadul atau tetikus PS/2), hal ini tidak bekerja. Pertimbangkan menambahkan modul, <literal>floppy</literal>, <literal>psmouse</literal>, dan <literal>mousedev</literal> ke <filename>/etc/modules</filename> agar memaksa memuatnya pada saat boot.
			</para>
			 </sidebar> <indexterm>
				<primary>perangkat keras, nama</primary>
			</indexterm>
			 <indexterm>
				<primary>nama</primary>
				<secondary>perangkat keras</secondary>
			</indexterm>
			 <para>
				Konfigurasi bootloader harus mengidentifikasi perangkat keras yang berbeda dan partisinya. Linux menggunakan berkas khusus “block” yang tersimpan dalam direktori <filename>/dev/</filename>, untuk tujuan ini. Sejak Debian <emphasis role="distribution">Squeeze</emphasis>, pola penamaan untuk hard drive telah disatukan oleh kernel Linux, dan semua hard drive (IDE/PATA, SATA, SCSI, USB, IEEE 1394) sekarang direpresentasikan oleh <filename>/dev/sd*</filename>.
			</para>
			 <para>
				Setiap partisi direpresentasikan oleh nomornya pada disk di mana dia berasa: misalnya, <filename>/dev/sda1</filename> merupakan partisi pertama pada disk pertama, dan <filename>/dev/sdb3</filename> adalah partisi ketiga pada disk kedua.
			</para>
			 <indexterm>
				<primary>partisi</primary>
				<secondary>primer</secondary>
			</indexterm>
			 <indexterm>
				<primary>partisi</primary>
				<secondary>perluasan</secondary>
			</indexterm>
			 <indexterm>
				<primary>partisi</primary>
				<secondary>sekunder</secondary>
			</indexterm>
			 <indexterm>
				<primary>tabel partisi</primary>
				<secondary>format MS-DOS</secondary>
			</indexterm>
			 <para>
				Arsitektur PC (atau "i386", termasuk saudara sepupunya "amd64" yang lebih muda) telah lama terbatas untuk menggunakan format tabel partisi "MS-DOS", yang hanya mengizinkan empat partisi "primer" per disk. Untuk melalui batasan ini, salah satunya harus dibuat sebagai partisi "perluasan", dan kemudian dapat memuat partisi tambahan "sekunder". Partisi sekunder ini harus bernomor dari 5. Maka partisi sekunder pertama dapat berupa <filename>/dev/sda5</filename>, diikuti oleh <filename>/dev/sda6</filename>, dst.
			</para>
			 <para>
				Keterbatasan lain dari format tabel partisi MS-DOS adalah itu hanya mengizinkan disk berukuran sampai dengan 2 TiB, yang menjadi masalah nyata dengan disk-disk terkini.
			</para>
			 <indexterm>
				<primary>GPT</primary>
				<secondary>format tabel partisi</secondary>
			</indexterm>
			 <indexterm>
				<primary>tabel partisi</primary>
				<secondary>format GPT</secondary>
			</indexterm>
			 <para>
				Suatu format tabel partisi baru bernama GPT melonggarkan kendala ini pada banyaknya partisi (itu mengizinkan sampai dengan 128 partisi ketika memakai setelan standar) dan atas ukuran disk (sampai dengan 8 ZiB, yang lebih dari 8 miliar terabita). Bila Anda hendak membuat banyak partisi fisik pada disk yang sama, maka Anda mesti memastikan bahwa Anda membuat tabel partisi dalam format GPT ketika mempartisi disk Anda.
			</para>
			 <para>
				Tidak mudah untuk mengingat cakram apa yang terhubung dengan SATA controller, atau pada posisi ketiga dalam chain SCSI, khususnya sejak penamaan hard drive yang tertancap (termasuk di antaranya kebanyakan disk SATA dan disk eksternal) dapat berubah dari satu boot ke lainnya. Untungnya, <command>udev</command> membuat tambahannya pada <filename>/dev/sd*</filename>, tautan simbolis dengan nama tetap, yang dapat Anda gunakan kemudian jika Anda ingin mengidentifikasi hard drive dengan cara yang tidak membingungkan. Tautan simbolis ini tersimpan di <filename>/dev/disk/by-id</filename>. Pada mesin dengan dua cakram fisik, misalnya, dapat ditemukan sebagai berikut:
			</para>
			 
<screen><computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l
</userinput><computeroutput>total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </computeroutput></screen>
			 <para>
				Catat bahwa beberapa disk terdaftar beberapa kali (karena secara simultan berlaku sebagai disk ATA dan disk SCSI), namun informasi yang relevan utamanya dalam model dan nomor seri disk, yang dapat Anda temukan berkas peripheralnya.
			</para>
			 <para>
				Contoh berkas konfigurasi pada bagian ini berdasarkan pengaturan yang sama: sebuah disk SATA, di mana parsiti pertama merupakan instalasi Windows lama dan yang kedua berisi Debian GNU/Linux.
			</para>

		</section>
		 <section id="sect.config-lilo">
			<title>Mengonfigurasi LILO</title>
			 <indexterm>
				<primary>LILO</primary>
			</indexterm>
			 <indexterm>
				<primary>Linux Loader</primary>
			</indexterm>
			 <para>
				<emphasis>LILO</emphasis> (LInux LOader) merupakan bootloader tertua - solid namun karatan. Dia menulis alamat fisik kernel untuk di-boot pada MBR, karenanya setiap pembaruan LILO (atau berkas konfigurasinya) harus diikuti oleh perintah <command>lilo</command>. Lupa melakukannya akan mengakibatkan sistem tidak dapat diboot jika kernel lama dihapus atau diganti karena yang baru tidak akan berada di lokasi yang sama pada cakram (disk).
			</para>
			 <para>
				Berkas konfigurasi LILO ialah <filename>/etc/lilo.conf</filename>; sebuah berkas sederhana untuk konfigurasi standar di ilustrasikan pada contoh berikut.
			</para>
			 <example id="example.lilo.conf">
				<title>Berkas konfigurasi LILO</title>
				 
<programlisting>
# The disk on which LILO should be installed.
# By indicating the disk and not a partition.
# you order LILO to be installed on the MBR.
boot=/dev/sda
# the partition that contains Debian
root=/dev/sda2
# the item to be loaded by default
default=Linux

# the most recent kernel image
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Old kernel (if the newly installed kernel doesn't boot)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# only for Linux/Windows dual boot
other=/dev/sda1
  label=Windows</programlisting>

			</example>

		</section>
		 <section id="sect.config-grub">
			<title>Konfigurasi GRUB 2</title>
			 <indexterm>
				<primary>GRUB</primary>
			</indexterm>
			 <indexterm>
				<primary>GRUB 2</primary>
			</indexterm>
			 <para>
				<emphasis>GRUB</emphasis> (GRand Unified Bootloader) lebih baru. Tidak perlu menjalankannya setiap pembaruan kernel; <emphasis>GRUB</emphasis> tau bagaimana cara membaca sistemberkas dan menemukan lokasi kernel pada cakram dengan sendirinya. Untuk menginstallnya pada MBR pada cakram pertama, ketikkan <command>grub-install /dev/sda</command>. <indexterm><primary><command>grub-install</command></primary></indexterm>
			</para>
			 <sidebar> <title><emphasis>CATATAN</emphasis> Nama cakram untuk GRUB</title>
			 <para>
				GRUB hanya dapat mengidentifikasi hard drive berdasarkan informasi yang disediakan oleh BIOS. <literal>(hd0)</literal> merupakan cakram pertama yang terdeteksi, <literal>(hd1)</literal> yang kedua, dll. Dalam kebanyakan kasus, urutan ini biasanya tepat sesuai dengan urutan cakram di Linux, namun masalah dapat timbul ketika Anda mengasosiasikan cakram SCSI dan IDE. GRUB menyimpan korespondensi apa yang dideteksinya pada berkas <filename>/boot/grub/device.map</filename>. Jika Anda menemukan kesalahan di sana (karena Anda tahu bahwa BIOS mendeteksi cakram pada urutan yang berbeda), koreksilah secara manual dan jalankan <command>grub-install</command> lagi. <command>grub-mkdevicemap</command> dapat membantu membuat suatu berkas <filename>device.map</filename> sebagai awalan.
			</para>
			 <para>
				Partisi juga memiliki nama spesifik dalam GRUB. Ketika Anda menggunakan partsisi “klasikal” dalam format MS-DOS, partisi pertama pada cakram pertama dilabeli, <literal>(hd0,msdos1)</literal>, yang kedua <literal>(hd0,msdos1)</literal>, dll.
			</para>
			 </sidebar> <para>
				Konfigurasi GRUB 2 disimpan dalam <filename>/boot/grub/grub.cfg</filename>, namun berkas ini (di Debian) dibuat oleh lainnya. Berhati-hatilah untuk tidak memodifikasinya secara manual, karena modifikasi lokal akan hilang ketika dijalankan <command>update-grub</command> (yang dapat terjadi ketika memerbarui berbagai paket). Modifikasi paling umum berkas <filename>/boot/grub/grub.cfg</filename> (untuk menambahkan parameter baris perintah ke kernel atau mengganti durasi menu ditampilkan, misalnya) dibuat melalui variabel dalam <filename>/etc/default/grub</filename>. Untuk menambahkan masukan ke menu, Anda dapat membuat berkas <filename>/boot/grub/custom.cfg</filename> atau memodifikasi berkas <filename>/etc/grub.d/50_custom</filename>. Untuk konfigurasi yang lebih kompleks, Anda dapat mengubah berkas-berkas lain dalam <filename>/etc/grub.d</filename>, atau menambahkan ke mereka; skrip-skrip ini mesti mengembalikan snippet konfigurasi, mungkin dengan menggunakan program eksternal. Skrip ini yang akan memerbarui daftar kernel untuk di-boot: <filename>10_linux</filename> menangani kernel Linux yang terinstall; <filename>20_linux_xen</filename> menangani sistem virtual Xen, dan <filename>30_os-prober</filename> mendaftar sistem operasi lain (Windows, OS X, Hurd).
			</para>

		</section>
		 <section id="sect.config-yaboot">
			<title>Untuk Komputer Macintosh (PowerPC): Mengonfigurasi Yaboot</title>
			 <indexterm>
				<primary><command>yaboot</command></primary>
			</indexterm>
			 <para>
				Yaboot merupakan bootloader yang digunakan oleh komputer Macintosh lama menggunakan prosesor PowerPC. Mereka tidak mem-boot seperti PC, namun memercayakan pada partisi “bootstrap”, di mana BIOS (atau OpenFirmware) mengeksekusi loader, dan program <command>ybin</command> menginstall <command>yaboot</command> dan berkas konfigurasinya. Anda hanya perlu menjalankan perintah ini lagi jika <filename>/etc/yaboot.conf</filename> dimodifikasi (berkas ini terduplikasi pada partisi bootstrap, dan <command>yaboot</command> tahu bagaimana cara menemukan posisi kernel pada cakram).
			</para>
			 <para>
				Sebelum mengeksekusi <command>ybin</command>, pertama Anda harus memiliki <filename>/etc/yaboot.conf</filename> yang valid. Berikut merupakan contoh konfigurasi minimal. <indexterm><primary><command>ybin</command></primary></indexterm>
			</para>
			 <example id="example.yaboot.conf">
				<title>Berkas konfigurasi Yaboot</title>
				 
<programlisting>
# bootstrap partition
boot=/dev/sda2
# the disk
device=hd:
# the Linux partition
partition=3
root=/dev/sda3
# boot after 3 seconds of inactivity
# (timeout is in tenths of seconds)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# last kernel installed
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# old kernel
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# only for Linux/Mac OSX dual-boot
macosx=/dev/sda5

# bsd=/dev/sdaX and macos=/dev/sdaX
# are also possible</programlisting>

			</example>

		</section>

	</section>
	 <section id="sect.config-misc">
		<title>Konfigurasi Lain: Sinkronisasi Waktu, Log, Berbagi Akses…</title>
		 <para>
			Beberapa elemen yang ada pada bagian ini cukup baik untuk diketahui oleh siapa saja yang ingin menguasai seluruh aspek konfigurasi sistem GNU/Linux. Akan tetapi, mereka diperlakukan secara ringkat dan seringkali menacu ke dokumentasi.
		</para>
		 <section id="sect.timezone">
			<title>Zonawaktu</title>
			 <indexterm>
				<primary>zonawaktu</primary>
			</indexterm>
			 <sidebar id="sidebar.symbolic-link"> <title><emphasis>KEMBALI KE DASAR</emphasis> Tautan simbolis</title>
			 <indexterm>
				<primary>tautan</primary>
				<secondary>simbolis</secondary>
			</indexterm>
			 <indexterm>
				<primary>tautan simbolis</primary>
			</indexterm>
			 <indexterm>
				<primary><command>ln</command></primary>
			</indexterm>
			 <para>
				Tautan simbolis adalah penunjuk ke berkas lain. Ketika Anda mengaksesnya, berkas yang ditunjuk dibuka. Penghapusan tautan tidak akan menyebabkan penghapusan berkas yang ditunjuk. Sebaliknya, dia tidak memiliki set hak aksesnya sendiri, namun menggunakan hak akses targetnya. Akhirnya, dia dapat menunjuk ke berbagai tipe berkas: direktori, berkas khusus (socket, named pipes, berkas perangkat, dll.), bahkan tautan simbolis lain.
			</para>
			 <para>
				Perintah <command>ln -s <replaceable>target</replaceable> <replaceable>nama-tautan</replaceable></command> membuat tautan simbolis, bernama <replaceable>nama-tautan</replaceable>, menunjuk ke <replaceable>target</replaceable>.
			</para>
			 <para>
				Jika target tidak ada, maka tautannya “rusak” dan mengaksesnya akan menyebabkan kesalahan menunjukkan bahwa berkas target tidak ada. Jika tautan menunjuk tautan lain, Anda akan memiliki “rantai” tautan yang menjadi “lingkaran” jika salah satu targetnya menunjuk salah satu pendahulunya. Dalam kasus ini, mengakses salah satu tautan dalam lingkaran akan menghasilkan kesalahan tertentu (“terlalu banyak level tautan simbolis”); ini artinya kernel menyerah setelah beberapa ronde putaran.
			</para>
			 </sidebar> <para>
				Zona waktu, dikonfigurasi ketika instalasi awal, adalah sebuah butir konfigurasi untuk paket <emphasis role="pkg">tzdata</emphasis>. Untuk memodifikasinya, gunakan perintah <command>dpkg-reconfigure tzdata</command>, yang memungkinkan Anda untuk memilih zona waktu yang akan digunakan dengan cara yang interaktif. Konfigurasinya disimpan di dalam berkas <filename>/etc/timezone</filename>. Selanjutnya, berkas yang sesuai dalam direktori <filename>/usr/share/zoneinfo</filename> akan disalin ke dalam <filename>/etc/localtime</filename>; berkas ini berisi aturan tentang tanggal dimana daylight saving time aktif, untuk negara-negara yang menggunakannya.
			</para>
			 <indexterm>
				<primary><filename>timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>zoneinfo</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/usr/share/zoneinfo/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>DST</primary>
			</indexterm>
			 <indexterm>
				<primary>daylight saving time</primary>
			</indexterm>
			 <para>
				Ketika Anda perlu mengubah zonawaktu sementara, gunakan variabel lingkungan <varname>TZ</varname>, yang mana diprioritaskan daripada sistem standar yang terkonfigurasi:
			</para>
			 <indexterm>
				<primary><varname>TZ</varname></primary>
			</indexterm>
			 
<screen id="screen.tz">
<computeroutput>$ </computeroutput><userinput>date</userinput>
<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>
<computeroutput>$ </computeroutput><userinput>TZ="Pacific/Honolulu" date</userinput>
<computeroutput>Thu Feb 19 00:25:21 HST 2015</computeroutput></screen>
			 <sidebar> <title><emphasis>CATATAN</emphasis> Jam sistem, jam perangkat keras</title>
			 <para>
				Ada dua sumber waktu dalam sebuah komputer. Motherboard komputer memiliki jam perangkat keras, disebut “CMOS clock”. Jam ini tidak cukup tepat, dan menyediakan waktu akses yang agak lambat. Kernel sistem operasi juga punya, jam perangkat lunak, yang selalu diperbaharui dengan caranya sendiri (mungkin dengan bantuan server waktu, lihat <xref linkend="sect.time-synchronization" />). Jam sistem ini umumnya lebih akurat, khususnya karena dia tidak memerlukan akses ke variabel perangkat keras. Akan tetapi, karena hanya ada di memori hidup, ini dinolkan setiap kali mesin boot, berbeda dengan jam CMOS, yang memiliki baterai sehingga “bertahan hidup” tatkala reboot atau mesin dimatikan. Jam sistem, diatur dari jam CMOS selama boot, dan jam CMOS diperbaharui ketika dimatikan (untuk menangani perubahan atau perbaikan jika tidak diatur dengan benar).
			</para>
			 <para>
				Pada prakteknya, ada sebuah masalah, karena jam CMOS tidak lebih dari sekedar penghitung dan tidak berisi informasi terkait zona waktu. Ada pilihan untuk membuat interpretasi yang terkait: apakah sistem diputuskan dijalankan pada waktu universal (UTC, dulunya GMT), atau dalam waktu lokal. Pilihan ini dapat menjadi sederhana, namun sesuatu sebenarnya lebih rumit: sebagai dampak dari daylight saving time, hal ini tidaklah tetap. Hasilnya bahwa sistem tidak mungkin menentukan apakah offset tepat, khsusnya periode seputar perubahan waktu. Karena selalu mungkin untuk merekonstruksi waktu lokal dari waktu universal dan informasi zonawaktu, kami sangat menyarankan menggunakan jam CMOS dalam waktu universal.
			</para>
			 <para>
				Sayangnya, sistem Windows dalam konfigurasi standar mereka mengabaikan rekomendasi ini; jam CMOS mereka tetap dalam waktu lokal, menerapkan perubahan ketika booting komputer dengan mencoba menebak selama perubahan waktu apakah perubahan telah diterapkan atau belum. Pekerjaan ini baik secara relatif, selama sistem hanya memiliki Windows dijalankan. Namun ketika sebuah komputer memiliki beberapa sistem (entah itu berupa konfigurasi “dual-boot” atau menjalankan sistem lain melalui mesin virtual), kesemrawutan terjadi, tanpa bermaksud menentukan apakan waktunya benar. Jika Anda sangat perlu Windows pada sebuah komputer, Anda perlu mengonfigurasinya agar jam CMOS dengan UTC (mengatur kunci registry <literal>HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</literal> ke “1” sebagai DWORD), atau gunakan <command>hwclock --localtime --set</command> pada sistem Debian untuk mengatur jam perangkat keras (hardware clock) dan menandainya sebagai pelacak waktu lokal (dan pastikan secara manual periksa jam Anda dalam musim semi dan musim gugur).
			</para>
			 </sidebar>
		</section>
		 <section id="sect.time-synchronization">
			<title>Sinkronisasi Waktu</title>
			 <indexterm>
				<primary>sinkronisasi waktu</primary>
			</indexterm>
			 <indexterm>
				<primary>jam</primary>
				<secondary>sinkronisasi</secondary>
			</indexterm>
			 <para>
				Sinkronisasi waktu, yang mungkin nampak mubadzir pada sebuah komputer, sangat penting dalam sebuah jaringan. Karena pengguna tidak memiliki hak akses yang mengizinkan mereka mengubah tanggal dan waktu, hal ini penting agar informasi ini jelas untuk mencegah kebingunan. Lebih jauh, jika seluruh komputer dalam sebuah jaringan tersinkronisasi memungkinkan referensi-silang informasi yang lebih baik dari log pada mesin yang berbeda. Nah, pada saat terjadi serangan, akan mudah untuk merekonstruksi kronologi urutan aksi pada berbagai mesin yang terlibat kompromi. Data yang dikumpulkan beberapa mesin untuk tujuan statistik tidak akan bermanfaat jika mereka tidak tersinkronisasi.
			</para>
			 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> NTP</title>
			 <indexterm>
				<primary>NTP</primary>
			</indexterm>
			 <indexterm>
				<primary>Network</primary>
				<secondary>Time Protocol</secondary>
			</indexterm>
			 <para>
				NTP (Protokol Waktu Jaringan) memungkinkan sebuah mesin tersinkronisasi dengan lainnya secara akurat, memertimbangkan penundaan yang disebabkan oleh transfer informasi melalui jaringan dan offset lain yang mungkin.
			</para>
			 <para>
				Ada banyak server NTP di internet, yang paling populer mungkin overload. Oleh karena itu, kami menyarankan menggunakan server NTP <emphasis>pool.ntp.org</emphasis>, yang mana, kenyataannya, sekelompok mesin yang telah setuju untuk melayani sebagai server NTP publik. Anda bahkan dapat menggunakan sub-group yang spesifik ke sebuah negara, misalnya dengan, <emphasis>us.pool.ntp.org</emphasis> untuk Amerika Serikat, atau <emphasis>ca.pool.ntp.org</emphasis> untuk Kanada, dll.
			</para>
			 <para>
				Akan tetapi, jika Anda mengelola jaringan yang besar, anda direkomendasikan menginstall server NTP Anda sendiri, yang akan menyinkronkan dengan server publik. Dalam kasus ini, seluruh mesin dalam jaringan Anda dapat menggunakan server NTP internal daripada meningkatkan load pada server publik. Anda akan meningkatkan kehomogenan dengan jam Anda, karena seluruh mesin akan disinkronkan ke sumber yang sama, dan sumber ini sangat dekat dalam hal waktu transfer jaringan.
			</para>
			 </sidebar> <section id="sect.ntp-on-workstations">
				<title>Untuk Workstation</title>
				 <para>
					Karena stasiun kerja direboot secara reguler (bahkan jika hanya untuk menghemat energi), mensinkronisasinya dengan NTP saat booting sudah cukup. Untuk melakukannya, install paket <emphasis role="pkg">ntpdate</emphasis>. Anda dapat mengubah server NTP yang digunakan jika diperlukan dengan memodifikasi berkas <filename>/etc/default/ntpdate</filename>.
				</para>
				 <indexterm>
					<primary><filename>ntpdate</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/default/ntpdate</filename></primary>
				</indexterm>

			</section>
			 <section id="sect.ntp-on-servers">
				<title>Untuk Server</title>
				 <para>
					Server jarang sekali direboot, dan sangat penting untuk waktu sistemnya agar benar. Untuk mengelola waktu yang benar secara permanen, Anda boleh menginstall server NTP lokal, sebuah layanan yang ditawarkan dalam paket <emphasis role="pkg">ntp</emphasis>. Dalam konfigurasi standarnya, server akan menyinkronkan dengan <emphasis>pool.ntp.org</emphasis> dan menyediakan waktu sebagai respon dari permintaan yang datang dari jaringan lokal. Anda dapat mengonfigurasinya dengan menyunting berkas <filename>/etc/ntp.conf</filename>, alternatif yang paling signifikan menjadi server NTP untuk yang mengacunya. Jika jaringan memilik banyak server, ini mungkin akan menarik jika memiliki satu server waktu lokal yang tersinkronisasi dengan server publik dan digunakan sebagai sumber waktu dengan server lain dalam jaringan.
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">ntp</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary>server</primary>
					<secondary>NTP</secondary>
				</indexterm>
				 <indexterm>
					<primary>NTP</primary>
					<secondary>server</secondary>
				</indexterm>
				 <sidebar> <title><emphasis>LEBIH JAUH</emphasis> Modul GPS dan sumber waktu lain</title>
				 <indexterm>
					<primary>GPS</primary>
				</indexterm>
				 <indexterm>
					<primary>DCF-77</primary>
				</indexterm>
				 <para>
					Jika sinkronisasi waktu seringkali krusial pada jaringan Anda, sangat mungkin untuk melengkapi sebuah server dengan modul GPS (yang akan menggunakan waktu dari satelit GPS) atau modul DCF-77 (yang akan menyinkronkan waktu dengan jam atomik di dekat frankfurt, Jerman). Dalam kasus ini, konfigurasi srver NTP menjadi lebih rumit, dan setelah mengacu ke dokumentasi sangat diperlukan.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.rotation-logs">
			<title>Rotasi Berkas Log</title>
			 <indexterm>
				<primary>berkas</primary>
				<secondary>log, rotasi</secondary>
			</indexterm>
			 <indexterm>
				<primary>log</primary>
				<secondary>berkas, rotasi</secondary>
			</indexterm>
			 <indexterm>
				<primary>rotasi berkas log</primary>
			</indexterm>
			 <indexterm>
				<primary><command>logrotate</command></primary>
			</indexterm>
			 <para>
				Berkas log dapat tumbuh, cepat, dan perlu untuk mengarsipnya. Skema yang paling umum adalah merotasi arsip: berkas log diarsipkan secara reguler, dan hanya arsip <replaceable>X</replaceable> terkini yang dibiarkan. <command>logrotate</command>, program yang bertanggung jawab untuk rotasi ini, mengikuti arahan yang diberikan berkas <filename>/etc/logrotate.conf</filename> dan seluruh berkas dalam direktori <filename>/etc/logrotate.d/</filename>. Administrator boleh memodifikasi berkas ini, jika mereka ingin mengadaptasi kebijakan rotasi log yang ditentukan oleh Debian. Man page <citerefentry><refentrytitle>logrotate</refentrytitle>
				 <manvolnum>1</manvolnum></citerefentry> menjelaskan seluruh pilihan yang tersedia dalam berkas konfigurasi ini. Anda mungkin ingin menambah jumlah berkas yang dipertahankan dalam rotasi log, atau memindah berkas log ke direktori tertentu yang didedikasikan untuk mengarsip daripada menghapusnya. Anda dapat pula mengirimkannya melalui email untuk diarsipkan di manapun.
			</para>
			 <para>
				Program <command>logrotate</command> dieksekusi per hari oleh penjadwal program <command>cron</command> (dijelaskan di <xref linkend="sect.task-scheduling-cron-atd" />).
			</para>

		</section>
		 <section id="sect.sharing-admin-rights">
			<title>Berbagi Hak Akses Administrator</title>
			 <indexterm>
				<primary>akun</primary>
				<secondary>akun administrator</secondary>
			</indexterm>
			 <indexterm>
				<primary>root</primary>
			</indexterm>
			 <indexterm>
				<primary><command>sudo</command></primary>
			</indexterm>
			 <para>
				Seringkali, beberapa administrator bekerja pada jaringan yang sama. Berbagi password root sangatlah tidak elegan, dan membuka kran fitnah karena anonimitas pembuat yang dibagi. Solusi untuk masalah ini adalah program <command>sudo</command>, yang mengizinkan pengguna tertentu untuk mengeksekusi program tertentu dengan hak akses khusus. Pada kasus yang umum, <command>sudo</command> mengizinkan pengguna yang dipercaya untuk mengeksekusi program sebagai root. Untuk melakukannya, pengguna mengeksekusi <command>sudo <replaceable>perintah</replaceable></command> dan diotentikasi menggunakan password personal mereka.
			</para>
			 <para>
				Ketika terinstall, paket <emphasis role="pkg">sudo</emphasis> memberikan hak root penuh ke anggota kelompok Unix <literal>sudo</literal>. Untuk mendelegasikan hak lainnya, administrator harus menggunakan perintah <command>visudo</command>, yang mengizinkan modifikasi berkas konfigurasi <filename>/etc/sudoers</filename> (di sini, ini akan menjalankan editor <command>vi</command>, atau editor lain yang ditunjukkan oleh variabel lingkungan <varname>EDITOR</varname>). Menambahkan sebuah baris dengan <literal><replaceable>namapengguna</replaceable> ALL=(ALL) ALL</literal> mengizinkan pengguna yang dimaksud menjalankan perintah sebagai root.
			</para>
			 <indexterm>
				<primary><command>visudo</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>sudoers</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/sudoers</filename></primary>
			</indexterm>
			 <para>
				Konfigurasi yang lebih canggih mengizinkan otorisasi hanya pada perintah tertentu ke pengguna tertentu. Seluruh rincian berbagai kemungkinan diberikan pada man page <citerefentry><refentrytitle>sudoers</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry>.
			</para>

		</section>
		 <section id="sect.fstab-mount-points">
			<title>Daftar Titik Kait</title>
			 <indexterm>
				<primary>titik, kait</primary>
			</indexterm>
			 <indexterm>
				<primary>titik kait</primary>
			</indexterm>
			 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> Pengaitan dan pelepasan</title>
			 <para>
				Dalam sistem mirip-Unix seperti Debian, berkas diorganisasi sebagai satu hirarki seperti-pohon direktori. Direktori <filename>/</filename> disebut “root directory”; seluruh direktori berikutnya merupakan sub-direktori dalam root ini. “Mounting” (mengaitkan) merupakan tindakan menyertakan isi perangkat pheriperal (seringkali berupa hard drive) ke dalam pohon berkas umum sistem. Sebagai konsekuensinya, jika Anda menggunakan hard drive terpisah untuk menyimpan data personal pengguna, cakram ini akan “dimount” dalam direktori <filename>/home/</filename>. Sistemberkas root selalu dimount ketika boot oleh kernel; perangkat lain seringkali dimout kemudian selama proses startup atau secara manual dengan perintah <command>mount</command>.
			</para>
			 <indexterm>
				<primary><command>mount</command></primary>
			</indexterm>
			 <para>
				Beberapa perangkat mudahlepas dimount secara otomatis ketika terhubung, khususnya ketika menggunakan GNOME, KDE atau lingkungan desktop lain. Lainnya harus dimount secara manual oleh pengguna. Begitupula, mereka harus meng-unmount (hapus dari pohon berkas). Pengguna biasa biasanya tidak memiliki hak akses untuk mengeksekusi perintah <command>mount</command> dan <command>umount</command>. Akan tetapi, administrator dapat mengotorisasi operasi ini (tiap titik kait secara independen) dengan menyertakan pilihan <literal>user</literal> dalam berkas <filename>/etc/fstab</filename>.
			</para>
			 <para>
				Perintah <command>mount</command> dapat digunakan tanpa argumen (kemudian akan mendaftar seluruh sistemberkas yang dikaitkan). Parameter berikut diperlukan untuk me-mount atau unmount sebuah perangkat. Untuk daftar lengkapnya, seilahkan merujuk ke man page yang sesuai, <citerefentry><refentrytitle>mount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> dan <citerefentry><refentrytitle>umount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry>. Untuk kasus sederhana, sintaknya juga sederhana: misalnya, untuk me-mount partisi <filename>/dev/sdc1</filename>, yang memiliki sebuah sistemberkas ext3, ke dalam direktori <filename>/mnt/tmp/</filename>, Anda dapat menjalankan <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command>.
			</para>
			 </sidebar> <para>
				Berkas <filename>/etc/fstab</filename> memberikan daftar seluruh kaitan yang mungkin terjadi entah itu secara otomatis ketika booting atau secara manual untuk perangkat storage mudahlepas. Setiap titik kait dideskripsikan dengan beberapa field yang dipisahkan oleh spasi: <indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						perangkat untuk dikaitkan: dapat berupa partisi logikal (hard drive, CD-ROM) atau sistemberkas remote (seperti NFS).
					</para>
					 <para>
						Field ini seringkali digantikan dengan unique ID sistemberkas (yang dapat Anda temukan dengan <command>blkid <userinput>device</userinput></command>) diawali dengan <literal>UUID=</literal>. Hal ini melindungi dari perubahan nama perangkat ketika penambahan atau pelepasan cakram, atau jika cakram terdeteksi dalam urutan yang berbeda.
					</para>

				</listitem>
				 <listitem>
					<para>
						titik kait: ini merupakan lokasi pada sistemberkas lokal di mana perangkat, sistem remote, atau partisi akan dikaitkan.
					</para>

				</listitem>
				 <listitem>
					<para>
						tipe: filed ini menentukan sistemberkas yang digunakan pada perangkat yang dikait. <literal>ext4</literal>, <literal>ext3</literal>, <literal>vfat</literal>, <literal>ntfs</literal>, <literal>btrfs</literal>, <literal>xfs</literal> merupakan beberapa contoh.
					</para>
					 <sidebar> <title><emphasis>KEMBALI KE DASAR</emphasis> NFS, sistem berkas jaringan</title>
					 <para>
						NFS ialah sistemberkas jaringan; di Linux, memungkinkan akses berkas remote secara transparan dengan menyertakannya dalam sistem berkas lokal.
					</para>
					 </sidebar> <para>
						Daftar lengkap daftar sistemberkas yang diketahui tersedia dalam man page <citerefentry><refentrytitle>mount</refentrytitle>
						 <manvolnum>8</manvolnum></citerefentry>. Nilai khusus <literal>swap</literal> adalah untuk partisi swap; nilai khusus <literal>auto</literal> memberitahukan program <command>mount</command> secara otomatis mendeteksi sistemberkas (yang khususnya berguna untuk pembaca cakram dan kunci USB, karena setiapnya bisa jadi memiliki sistemberkas yang berbeda);
					</para>

				</listitem>
				 <listitem>
					<para>
						pilihan: ada banyak, tergantung pada sistemberkas, dan mereka terdokumentasi dalam man page <command>mount</command>. Umumnya adalah
					</para>
					 <itemizedlist>
						<listitem>
							<para>
								<literal>rw</literal> atau <literal>ro</literal>, artinya, masing-masing, bahwa perangkat akan dikait dengan akses baca/tulis (read/write) atau hanya-baca (read-only).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>noauto</literal> nonaktifkan pengaitan otomatis saat booting.
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>nofail</literal> mengizinkan boot berlanjut bahkan ketika peranti tidak ada. Pastikan untuk memakai opsi ini bagi drive eksternal yang mungkin dicopot saat Anda boot, karena <command>systemd</command> benar-benar memastikan bahwa semua titik kait yang mesti dikait secara otomatis benar-benar dikait sebelum membiarkan proses boot berlanjut sampai akhir. Perhatikan bahwa Anda dapat menggabung ini dengan <literal>x-systemd.device-timeout=5s</literal> untuk memberitahu <command>systemd</command> untuk tidak menunggu lebih dari 5 detik bagi peranti untuk muncul (lihat <citerefentry><refentrytitle>systemd.mount</refentrytitle>
								<manvolnum>5</manvolnum></citerefentry>).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>user</literal> mengizinkan semua pengguna untuk mengait sistemberkas ini (sebuah operasi yang hanya dapat dilakukan oleh pengguna root).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>defaults</literal> artinya kelompok pilihan standar: <literal>rw</literal>, <literal>suid</literal>, <literal>dev</literal>, <literal>exec</literal>, <literal>auto</literal>, <literal>nouser</literal> dan <literal>async</literal>, masing-masign dapat dinonaktifkan secara idividual setelah <literal>defaults</literal> dengan menambahkan <literal>nosuid</literal>, <literal>nodev</literal> dan seterusnya ke blok <literal>suid</literal>, <literal>dev</literal> dan seterusnya. Menambahkan pilihan <literal>user</literal> mengaktifkannya lagi, karena <literal>defaults</literal> menyertakan <literal>nouser</literal>.
							</para>

						</listitem>

					</itemizedlist>

				</listitem>
				 <listitem>
					<para>
						backup: field ini hampir selalu bernilai <literal>0</literal>. Ketika bernilai <literal>1</literal>, dia memerintahkan alat <command>dump</command> untuk membackup partisi yang berisi data.
					</para>

				</listitem>
				 <listitem>
					<para>
						check order: field terakhir ini menunjukkan apakah akan memeriksa integritas sistemberkas saat booting, dan dalam urutan yang bagaimana pemeriksaan ini dieksekusi. Jika bernilai <literal>0</literal>, tidak ada pemeriksaan yang dilakukan. Sistemberkas root harus bernilai <literal>1</literal>, sedangkan sistemberkas permanen lainnya memiliki nilai <literal>2</literal>.
					</para>

				</listitem>

			</itemizedlist>
			 <example id="example.fstab">
				<title>Contoh berkas<filename>/etc/fstab</filename></title>
				 
<programlisting>
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
# swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0</programlisting>

			</example>
			 <para>
				Entri terakhir dalam contoh ini berupa sebuah sistemberkas jaringan (NFS): direktori <filename>/shared/</filename> pada server <emphasis>arrakis</emphasis> dikaitkan pada <filename>/shared/</filename> di mesin lokal. Format berkas <filename>/etc/fstab</filename> didokumentasikan pada man page <citerefentry><refentrytitle>fstab</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>.
			</para>
			 <sidebar> <title><emphasis>LEBIH JAUH</emphasis> Mount-otomatis</title>
			 <para>
				Paket <emphasis>am-utils</emphasis> menyediakan utilitas mount-otomatis <command>amd</command>, dapat mengait media mudahlepas secara on demand ketika seorang pengguna hendak mengakses titik kait biasanya. Utilitas ini akan meng-unmount perangkat ini ketika tidak ada proses yang mengaksesnya lagi.
			</para>
			 <indexterm>
				<primary><emphasis>am-utils</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><command>amd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>automount</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>autofs</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>automounter</primary>
			</indexterm>
			 <para>
				Utilitas mount-otomatis lain jugaada, seperti <command>automount</command> dalam paket <emphasis>autofs</emphasis>.
			</para>
			 <para>
				Catat juga bahwa GNOME, KDE, dan lingkungan desktop grafis lainnya bekerja bersama dengan <emphasis>udisks</emphasis>, dan dapat secara otomatis mengait media mudahlepas ketika mereka terhubung.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.locate-updatedb">
			<title><command>locate</command> dan <command>updatedb</command></title>
			 <indexterm>
				<primary><command>locate</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>updatedb</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>mlocate</command></primary>
			</indexterm>
			 <para>
				Perintah <command>locate</command> dapat menemukan lokasi sebuah berkas ketika Anda hanya tahu bagian namanya. Mengirimkan hasilnya hampir secara instant, karena dia menggunakan basisdata yang menyimpan lokasi seluruh berkas pada sistem; basisdata ini diperbaharui tiap hari oleh perintah <command>updatedb</command>. Ada banyak implementasi dari perintah <command>locate</command> dan Debian mengambil <emphasis role="pkg">mlocate</emphasis> untuk standar sistemnya.
			</para>
			 <para>
				<command>mlocate</command> cukup pintar, hanya menampilkan berkas yang dapat diakses oleh pengguna yang menjalankan perintah meskipun dia menggunakan basisdata yang mengetahui seluruh berkas pada sistem (implementasi <command>updatedb</command> dijalankan dengan hak akses root). Untuk keamanan ekstra, administrator dapat menggunakan <varname>PRUNEDPATHS</varname> dalam <filename>/etc/updatedb.conf</filename> untuk mengecualikan beberapa direktori untuk diindeks.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-compilation">
		<title>Mengompilasi sebuah Kernel</title>
		 <indexterm>
			<primary>kompilasi</primary>
			<secondary>sebuah kernel</secondary>
		</indexterm>
		 <indexterm>
			<primary>kernel</primary>
			<secondary>kompilasi</secondary>
		</indexterm>
		 <para>
			Kernel yang disediakan oleh Debian menyertakan banyak fitur, sebagaimana penggerak (driver) penuh, agar dapat menangani spektrum yang luas konfigurasi perangkat keras. Oleh karena itu, beberapa pengguna lebih memilih mengompilasi ulang kernel agar hanya menyertakan beberapa yang mereka butuhkan saja. Ada dua alasan untuk pilihan ini. Pertama, mungkin untuk mengoptimalisasi konsumsi memori, karena kode kernel, bahkan jika tak pernah digunakan, memakan memori yang tidak berguna (dan tak pernah “hilang” pada ruang swap, karena dia menggunakan RAM sebenarnya), di mana dapat mengurangi performa sistem. Kernel lokal yang dikompilasi dapat membatasi resiko masalah keamanan karena hanya sebagian kode kernel yang dikompilasi dan dijalankan.
		</para>
		 <sidebar> <title><emphasis>CATATAN</emphasis> Pembaharuan keamanan</title>
		 <para>
			Jika Anda memilih untuk mengompilasi kernel Anda sendiri, Anda harus menerima konsekuensinya: Debian tidak dapat memastikan pembaruan keamanan untuk kernel buatan Anda. Menggunakan kernel yang disediakan oleh Debian, Anda mendapat kenuntungan dari pembaruan yang disiapkan oleh tim keamanan Proyek Debian.
		</para>
		 </sidebar> <para>
			Kompilasi ulang kernel juga diperlukan jika Anda ingin menggunakan fitur tertentu yang hanya tersedia sebagai patch (dan tidak disertakan dalam versi kernel standar).
		</para>
		 <sidebar> <title><emphasis>LEBIH JAUH</emphasis> Buku Pegangan Kernel Debian</title>
		 <indexterm>
			<primary><emphasis role="pkg">debian-kernel-handbook</emphasis></primary>
		</indexterm>
		 <para>
			Tim kernel Debian mengelola “Buku Pegangan Kernel Debian” (juga tersedia dalam paket <emphasis role="pkg">debian-kernel-handbook</emphasis>) dengan dokumentasi yang komprehensif tentang banyak tugas yang berkaitan dengan kernel dan tentang bagaimana kernel resmi Debian ditangani. Ini merupakan tempat pertama yang harus Anda lihat jika Anda memerlukan informasi yang lebih banyak daripada apa yang tersedia di bagian ini. <ulink type="block" url="http://kernel-handbook.alioth.debian.org" />
		</para>
		 </sidebar> <section id="sect.kernel-compilation-prerequisites">
			<title>Perkenalan dan Prasyarat</title>
			 <para>
				Tidak mengejutkan Debian mengelola kernel dalam bentuk paket, yang mana tidak secara tradisional kernel dikompilasi dan diinstall. Selama kernel berada dalam kontrol sistem paket, dia dapat dicopot bersih, atau disebarkan pada beberapa mesin. Lagipula, skrip yang berhubungan dengan paket ini secara mengotomatisasi interaksi dengan bootloader dan pembuat initrd.
			</para>
			 <para>
				Sumber Linux hulu berisi apapunt yang diperlukan untuk membangun sebuah kernel paket Debian. Namun Anda masih perlu menginstall <emphasis role="pkg">build-essential</emphasis> untuk memastikan bahwa Anda memiliki peralatan yang diperlukan untuk membangun sebuah paket Debian. Lagipula, langkah konfigurasi untuk kernel memerlukan paket <emphasis role="pkg">libncurses5-dev</emphasis>. Akhirnya, paket <emphasis role="pkg">fakeroot</emphasis> akan memungkinkan pembuatan paket Debian tanpa menggunakan hak akses administrator.
			</para>
			 <sidebar> <title><emphasis>KULTUR</emphasis> Hari tua yang baik dari <emphasis role="pkg">kernel-package</emphasis></title>
			 <indexterm>
				<primary><emphasis role="pkg">kernel-package</emphasis></primary>
			</indexterm>
			 <para>
				Sebelum sistem pembangun Linux mendapatkan kemampuan untuk membangun paket Debian, cara yang direkomendasikan untuk membangun paket adalah dengan menggunakan <command>make-kpkg</command> dari paket <emphasis role="pkg">kernel-package</emphasis>.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-sources">
			<title>Mendapatkan Sumber</title>
			 <indexterm>
				<primary>Sumber kernel Linux</primary>
			</indexterm>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>sumber</secondary>
			</indexterm>
			 <indexterm>
				<primary>sumber</primary>
				<secondary>kernel Linux</secondary>
			</indexterm>
			 <para>
				Seperti apapun yang dapat berguna pada sebuah sistem Debian, sumber kernel Linux tersedia dalam sebuah paket. Untuk mendapatkannya, install saja paket <emphasis role="pkg">linux-source-<replaceable>versi</replaceable></emphasis>. Perintah <command>apt-cache search ^linux-source</command> menampilkan berbagai variasi versi paket kernel oleh Debian. Versi terkini tersedia dalam distribusi <emphasis role="distribution">Unstable</emphasis>: Anda dapat mengunduhnya tanpa banyak resiko (khususnya jika APT Anda dikonfigurasi berdasarkan instruksi <xref linkend="sect.apt-mix-distros" />). Catat bahwa kode sumber yang ada dalam paket ini tidak secara persis sama dengan yang dipublikasikan oleh Linus Torvalds dan pengembang kernel; seperti seluruh distribusi, Debian menerapkan berbagai patch, yang mungkin (mungkin tidak) ditemukan pada versi hulu Linux. Modifikasi ini termasuk backport perbaikan/fitur/penggerak (driver) dari versi kernel terbaru, fitur baru yang belum (sepenuhnya) digabungkan dalam upstream Linux tree, dan terkadang bahkan perubahan spesifik Debian.
			</para>
			 <para>
				Pengingat bagian ini difokuskan pada kernel Linux versi 3.16, namun contohnya tentu saja dapat diadaptasi ke beberapa versi kernel yang Anda inginkan.
			</para>
			 <para>
				Kita asumsikan paket <emphasis role="pkg">linux-source-3.16</emphasis> telah terpasang. Ini berisi <filename>/usr/src/linux-source-3.16.tar.xz</filename>, sebuah arsip sumber kernel yang dimampatkan. Anda harus mengekstrak berkas ini dalam sebuah direktori baru (tidak langsung di bawah <filename>/usr/src/</filename>, sebab untuk mengompilasi kernel Linux tidak memerlukan hak akses khusus): <filename>~/kernel/</filename> cocok.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>
<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-3.16.tar.xz</userinput></screen>
			 <sidebar> <title><emphasis>KULTUR</emphasis> Lokasi sumber kernel</title>
			 <para>
				Secara tradisional, sumber kernel Linux akan diletakkan di <filename>/usr/src/linux/</filename> yang memerlukan hak akses root untuk kompilasi. Akan tetapi, bekerja dengan hak akses administrator harus dihindari ketika tidak diperlukan. Ada sebuah kelompok <literal>src</literal> yang memungkinkan anggota bekerja dalam direktori ini, namun bekerja dalam <filename>/usr/src/</filename> harus tetap dihindari. Dengan menyimpan sumber kernel dalam sebuah direktori personal, Anda aman dari segala hal: tidak ada berkas dalam <filename>/usr/</filename> yang tidak diketahui oleh sistem pemaketan, dan tak ada resiko program jahat yang membaca <filename>/usr/src/linux</filename> ketika mencoba mengumpulkan informasi pada kernel yang digunakan.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.config-kernel">
			<title>Mengonfigurasi Kernel</title>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>konfigurasi</secondary>
			</indexterm>
			 <indexterm>
				<primary>konfigurasi</primary>
				<secondary>kernel</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>.config</filename></primary>
			</indexterm>
			 <para>
				Langkah selanjutnya mengonfigurasi kernel berdasarkan kebutuhan Anda. Prosedur tepatnya tergantung pada tujuannya.
			</para>
			 <para>
				Ketika mengompilasi versi kernel lebih baru (mungkin dengan patch tambahan), konfigurasinya sebaiknya akan sedekat mungkin dengan yang ditawarkan oleh Debian. Dalam hal ini, dan daripada mengonfigurasi segalanya dari scratch, cukup menyalin berkas <filename>/boot/config-<replaceable>versi</replaceable></filename> (versi kernel yang sedang digunakan, yang dapat ditemukan dengan perintah <command>uname -r</command>) ke sebuah berkas <filename>.config</filename> dalam direktori yang berisi sumber kernel.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cp /boot/config-3.16.0-4-amd64 ~/kernel/linux-source-3.16/.config</userinput></screen>
			 <para>
				Kecuali Anda perlu mengubah konfigurasi, Anda dapat berhenti di sini dan melompat ke <xref linkend="sect.kernel-build" />. Namun jika Anda perlu mengubahnya, atau jika Anda memutuskan untuk mengonfigurasi semuanya dari awal, Anda perlu meluangkan waktu untuk mengonfigurasi kernel Anda. Ada berbagai antarmuka terdedikasi dalam direktori sumber kernel yang dapat digunakan dengan memanggil perintah <command>make <replaceable>target</replaceable></command>, dimana <replaceable>target</replaceable> merupakan salah satu dari nilai-nilai yang dijelaskan di bawah.
			</para>
			 <para>
				<command>make menuconfig</command> mengkompilasi dan mengeksekusi sebuah antarmuka mode teks (inilah di mana paket <emphasis role="pkg">libncurses5-dev</emphasis> diperlukan) yang memungkinkan navigasi pilihan yang tersedia dalam sebuah struktur hirarkis. Menekan tombol <keycap>Spasi</keycap> megubah nilai opsi yang dipilih, dan <keycap>Enter</keycap> memvalidasi tombol yang dipilih di layar bagian bawah; <guibutton>Select</guibutton> mengembalikan ke sub-menu yang dipilih; <guibutton>Exit</guibutton> menutup layar saat ini dan kembali ke hirarki sebelumnya; <guibutton>Help</guibutton> akan menampilkan informasi yang lebih rinci atas peran dari opsi yang sedang dipilih. Tombol panah memungkinkan perpindahan pada daftar pilihan dan tombol. Untuk keluar dari program konfigurasi, pilih <guibutton>Exit</guibutton> dari menu utama. Program kemudian menawarkan untuk menyimpan perubahan yang telah Anda buat; terima jika Anda merasa puas dengan pilihan Anda.
			</para>
			 <para>
				Antarmuka lain memiliki fitur yang mirip, namun mereka bekerja dengan antarmuka grafis yang lebih modern; serperti <command>make xconfig</command> yang menggunakan antarmuka grafis Qt, dan <command>make gconfig</command> yang menggunakan GTK+. Yang pertama memerlukan <emphasis role="pkg">libqt4-dev</emphasis>, sedangkan yang berikutnya memerlukan <emphasis role="pkg">libglade2-dev</emphasis> dan <emphasis role="pkg">libgtk2.0-dev</emphasis>.
			</para>
			 <para>
				Ketika menggunakan salah satu antarmuka konfigurasi tersebut, sebaiknya dimulai dengan konfigurasi standar. Kernel menyediakan konfigurasi tersebut dalam <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename> dan Anda dapat menaruh konfigurasi pilihan dengan perintah seperti <command>make x86_64_defconfig</command> (dalam hal ini PC 64-bit) atau <command>make i386_defconfig</command> (dalam hal ini PC 32-bit).
			</para>
			 <sidebar> <title><emphasis>TIP</emphasis> Menangani berkas <filename>.config</filename> usang</title>
			 <para>
				Ketika Anda menyediakan sebuah berkas <filename>.config</filename> yang telah dibuat oleh versi kernel lain (biasanya lebih tua), Anda perlu memerbaruinya. Anda dapat melakukannya dengan <command>make oldconfig</command>, ini akan menanyai Anda secara interaktif pilihan konfigurasi baru yang sesuai. Jika Anda ingin menggunakan jawaban standar untuk seluruh pertanyaan tersebut Anda dapat menggunakan <command>make olddefconfig</command>. Dengan <command>make oldnoconfig</command>, akan mengasumsikan jawaban negatif untuk seluruh pertanyaan.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-build">
			<title>Kompilasi dan Membangun Paket</title>
			 <indexterm>
				<primary><command>make deb-pkg</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>CATATAN</emphasis> Pembersihan sebelum membangun ulang</title>
			 <para>
				Jika Anda pernah mengompilasi dalam direktori itu dan ingin membangun ulang segalanya dari awal (misalnya karena Anda mengubah konfigurasi kernel yang penting), Anda harus menjalankan <command>make clean</command> untuk menghapus berkas terkompilasi. <command>make distclean</command> menghapus lebih banyak berkas yang dibuat, termasuk berkas <filename>.config</filename> juga, jadi pastikan dibackup terlebih dahulu.
			</para>
			 </sidebar> <para>
				Ketika konfigurasi kernel telah siap, perintah sederhana <command>make deb-pkg</command> akan menghasilkan hingga 5 paket Debian: <emphasis role="pkg">linux-image-<replaceable>versi</replaceable></emphasis> yang berisi image kernel dan modul yang sesuai, <emphasis role="pkg">linux-headers-<replaceable>versi</replaceable></emphasis> yang berisi berkas header yang diperlukan untuk membangun modul eksternal, <emphasis role="pkg">linux-firmware-image-<replaceable>versi</replaceable></emphasis> yang berisi berkas firmware yang diperlukan oleh beberapa penggerak, <emphasis role="pkg">linux-image-<replaceable>versi</replaceable>-dbg</emphasis> yang berisi simbol debugging untuk image kernel dan modulnya, dan <emphasis role="pkg">linux-libc-dev</emphasis> yang berisi header yang sesuai dengan pustaka tingkat pengguna seperti GNU glibc.
			</para>
			 <para>
				<replaceable>version</replaceable> didefinisikan dengan rentetan versi hulu (sebagaimana didefinisikan oleh variabel <literal>VERSION</literal>, <literal>PATCHLEVEL</literal>, <literal>SUBLEVEL</literal> dan <literal>EXTRAVERSION</literal> dalam <filename>Makefile</filename>), dari parameter konfigurasi <literal>LOCALVERSION</literal>, dan variabel lingkungan <literal>LOCALVERSION</literal>. Versi paket menggunakan string versi yang sama dengan revisi ditambahkan yang umumnya ditingkatkan (dan diurutkan dalam <filename>.version</filename>), kecuali jika Anda meng-override-nya dengan variabel lingkungan <literal>KDEB_PKGVERSION</literal>.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1
</userinput><computeroutput>[...]
$ </computeroutput><userinput>ls ../*.deb
</userinput><computeroutput>../linux-headers-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb
../linux-image-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb
../linux-image-3.16.7-ckt4-falcot-dbg_3.16.7-1_amd64.deb
../linux-libc-dev_3.16.7-1_amd64.deb
</computeroutput></screen>

		</section>
		 <section id="sect.modules-build">
			<title>Kompilasi Modul Eksternal</title>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>modul eksternal</secondary>
			</indexterm>
			 <indexterm>
				<primary>modul</primary>
				<secondary>modul kernel eksternal</secondary>
			</indexterm>
			 <indexterm>
				<primary><command>dkms</command></primary>
			</indexterm>
			 <para>
				Beberapa modul dikelola di luar kernel Linux resmi. Untuk menggunakannya, mereka harus dikompilasi bersama dengan kernel yang tepat. Beberapa modul pihak ketiga yang umum disediakan oleh Debian dalam paket khusus, serperti <emphasis role="pkg">xtables-addons-source</emphasis> (modul-modul ekstra untuk iptables) atau <emphasis role="pkg">oss4-source</emphasis> (Open Sound System, beberapa alternatif driver audio).
			</para>
			 <para>
				Paket eksternal ini ada banyak variasinya dan kami tidak akan menampilkan seluruh daftarnya di sini; perintah <command>apt-cache search source$</command> dapat memersempit kolom pencarian. Akan tetapi, daftar yang lengkap terkadang tidak berguna karena ada alasan khusus untuk mengompilasi modul eksternal kecuali ketika Anda tahu Anda memerlukannya. Dalam kasus tertentu, dokumentasi perangkat keras akan secara khas merinci modul spesifik yang diperlukannya agar berfungsi di Linux.
			</para>
			 <para>
				Misalnya, mari lihat pada paket <emphasis role="pkg">xtables-addons-source</emphasis>: setelah instalasi, sebuah sumber modul <filename>.tar.bz2</filename> tersimpan di <filename>/usr/src/</filename>. Kita dapat mengekstraknya secara manual berkas tarball tersebut dan membangun modul, dalam prakteknya kita lebih memilih untuk mengotomatisasi seluruh menggunakan DKMS. Kebanyakan modul menawarkan integrasi DKMS yang diperlukan dalam sebuah paket yang diakhiri dengan akhiran <literal>-dkms</literal>. Dalam kasus kita, hanya perlu menginstall <emphasis role="pkg">xtables-addons-dkms</emphasis> untuk mengompilasi modul kernel bagi kernel saat ini asal telah tersedia paket <emphasis role="pkg">linux-headers-*</emphasis> yang cocok dengan kernel yang terinstall. Umpamanya, Jika Anda menggunakan <emphasis role="pkg">linux-image-amd64</emphasis>, Anda juga perlu menginstall <emphasis role="pkg">linux-headers-amd64</emphasis>.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>
<computeroutput>
[...]
Setting up xtables-addons-dkms (2.6-1) ...
Loading new xtables-addons-2.6 DKMS files...
First Installation: checking all kernels...
Building only for 3.16.0-4-amd64
Building initial module for 3.16.0-4-amd64
Done.

xt_ACCOUNT:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/3.16.0-4-amd64/updates/dkms/
[...]
DKMS: install completed.
$ </computeroutput><userinput>sudo dkms status</userinput>
<computeroutput>xtables-addons, 2.6, 3.16.0-4-amd64, x86_64: installed
$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>
<computeroutput>filename:       /lib/modules/3.16.0-4-amd64/updates/dkms/xt_ACCOUNT.ko
license:        GPL
alias:          ipt_ACCOUNT
author:         Intra2net AG &lt;opensource@intra2net.com&gt;
description:    Xtables: per-IP accounting for large prefixes
[...]
</computeroutput></screen>
			 <sidebar> <title><emphasis>ALTERNATIF</emphasis> module-assistant</title>
			 <indexterm>
				<primary><emphasis role="pkg">module-assistant</emphasis></primary>
			</indexterm>
			 <para>
				Sebelum DKMS, <emphasis role="pkg">module-assistant</emphasis> merupakan solusi paling sederhana untuk membangun dan menyebar modul kernel. Ini masih dapat digunakan, khususnya untuk paket yang tidak memiliki integrasi DKMS: dengan sebuah perintah sederhana seperti <command>module-assistant auto-install xtables-addons</command> (atau <command>m-a a-i xtables-addons</command> singkatnya), modul dikompilasi untuk kernel saat ini, menaruh dalam sebuah paket Debian baru, dan paket tersebut diinstall sambil jalan.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-patch">
			<title>Menerapkan Patch Kernel</title>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>patch</secondary>
			</indexterm>
			 <indexterm>
				<primary>patch untuk kernel</primary>
			</indexterm>
			 <para>
				Beberapa fitur tidak disertakan dalam kernel standar karena belum maksimalnya atau ketidaksepakatan dengan maintainer kernel. Beberapa fitur mungkin didistribusikan sebagai patch di mana setiap orang bebas untuk menerapkan ke sumber kernel.
			</para>
			 <para>
				Debian mendistribusikan beberapa patch ini dalam paket <emphasis role="pkg">linux-patch-*</emphasis> atau <emphasis role="pkg">kernel-patch-*</emphasis> (misalnya, <emphasis role="pkg">linux-patch-grsecurity2</emphasis>, yang menyempitkan beberapa peraturan keamanan kernel). Paket ini menginstall berkas dalam direktori <filename>/usr/src/kernel-patches/</filename>.
			</para>
			 <para>
				Untuk menerapkan satu atau lebih patch ini yang terinstall, gunakan perintah <command>patch</command> dalam direktori sumber kemudian mulai kompilasi kernel sebagaimana dijelaskan di atas.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-3.16</userinput>
<computeroutput>$ </computeroutput><userinput>make clean</userinput>
<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.0-3.17.1-201410250027.patch.gz | patch -p1</userinput></screen>
			 <para>
				Catat bahwa patch yang diberikan mungkin tidak bekerja dengan setiap versi kernel; mungkin saja sebuah <command>patch</command> gagal ketika diterapkan ke sumber kernel. Sebuah pesan error akan ditampilkan dan memberikan beberapa rincian tentang kesalahan; dalam kasus ini, mengacu ke dokumentasi yang tersedia dalam paket Debian dari patch tersebut (dalam direktori <filename>/usr/share/doc/linux-patch-*/</filename>). Dalam banyak kasus, maintainer menunjukkan versi kernel mana patch mereka ditujukan.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-installation">
		<title>Menginstall sebuah Kernel</title>
		 <indexterm>
			<primary>installasi</primary>
			<secondary>sebuah kernel</secondary>
		</indexterm>
		 <indexterm>
			<primary>kernel</primary>
			<secondary>installasi</secondary>
		</indexterm>
		 <section id="sect.kernel-package">
			<title>Fitur sebuah Paket Kernel Debian</title>
			 <indexterm>
				<primary><filename>vmlinuz</filename></primary>
			</indexterm>
			 <para>
				Paket kernel Debian menginstall image kernel (<filename>vmlinuz-<replaceable>versi</replaceable></filename>), konfigurasinya (<filename>config-<replaceable>versi</replaceable></filename>) dan tabel simbolnya (<filename>System.map-<replaceable>versi</replaceable></filename>) dalam <filename>/boot/</filename>. Tabel simbol membantu pengembang untuk memahami makna pesan kesalahan kernel; tanpanya, kernel “oopses” (sebuah “oops” adalah sama dengan kegagalan segmentasi untuk program level pengguna, dengan kata lain pesan yang dihasilkan menyusul pointer dereference tidak valid) hanya berisi alamat numerik memori, yang merupakan informasi yang tidak berguna tanpa pemetaan tabel alamat ini ke simbol dan nama fungsi. Modul diinstall dalam direktori <filename>/lib/modules/<replaceable>version</replaceable>/</filename>.
			</para>
			 <para>
				Skrip konfigurasi paket secara otomatis menghasilkan sebuah image initrd, yang merupakan sebuah sistem mini didesain untuk dimuat dalam memori (selanjutnya namanya, adalah singkatan untuk “init ramdisk”) oleh bootloader, dan digunakan oleh kernel Linux sendiri untuk memuat modul yang diperlukan untuk mengakses perangkat berisi sistem Debian lengkap (misalnya, penggerak untuk cakram SATA). Akhirnya, skrip post-instalasi memerbarui tautan simbolis <filename>/vmlinuz</filename>, <filename>/vmlinuz.old</filename>, <filename>/initrd.img</filename> dan <filename>/initrd.img.old</filename> agar mereka menunjuk ke dua kernel terbaru yang terinstall, masing-masing, sebagaimana image initrd yang sesuai.
			</para>
			 <para>
				Kebanyakan tugas tersebut diturunkan ke skrip pengait dalam direktori <filename>/etc/kernel/*.d/</filename>. Misalnya, integrasi dengan <command>grub</command> bergantung pada <filename>/etc/kernel/postinst.d/zz-update-grub</filename> dan <filename>/etc/kernel/postrm.d/zz-update-grub</filename> memanggil <command>update-grub</command> ketika kernel diinstall atau dicopot.
			</para>

		</section>
		 <section id="sect.kernel-installation-with-dpkg">
			<title>Menginstall dengan <command>dpkg</command></title>
			 <para>
				Menggunakan <command>apt</command> juga tidak menyusahkan yang membuat mudah untuk melupakan alat level-rendah, namun cara termudah untuk menginstall kernel terkompilasi ialah dengan menggunakan perintah seperti <command>dpkg -i <replaceable>package</replaceable>.deb</command>, di mana <literal><replaceable>package</replaceable>.deb</literal> merupakan nama paket <emphasis role="pkg">linux-image</emphasis> seperti <filename>linux-image-3.16.7-ckt4-falcot_1_amd64.deb</filename>.
			</para>
			 <para>
				Langkah konfigurasinya dijelaskan dalam bab ini adalah dasar dan dapat digunakan dalam sebuah sistem server atau jaringan-kerja, dan dapat dapat diduplikasi secara masif dalam cara yang agak-terotomasi, tidak cukup menyediakan konfigurasi sistem lengkap. Beberapa kepingan masih perlu konfigurasi, dimulai dengan program level-rendah yang disebut “layanan Unix”.
			</para>

		</section>

	</section>
</chapter>

