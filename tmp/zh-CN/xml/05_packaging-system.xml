<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="packaging-system" lang="zh-CN">
	<chapterinfo>
		 <keywordset>
			<keyword>二进制包</keyword>
			 <keyword>源码包</keyword>
			 <keyword>dpkg</keyword>
			 <keyword>依赖</keyword>
			 <keyword>冲突</keyword>

		</keywordset>

	</chapterinfo>
	 <title>包管理系统：工具和基本原则</title>
	 <highlights> <para>
		作为 Debian 系统管理员，你经常地要处理 <filename>.deb</filename> 包，因为它们包含一致的功能单元（应用程序、文档等），使得安装和维护更容易。所以了解它们是什么及如何使用它们是个好主意。
	</para>
	 </highlights> <para>
		本章介绍了“二进制”和“源码”包的结构和内容。前者是 <filename>.deb</filename> 文件，可以用 <command>dpkg</command> 命令直接处理；而后者则包含程序的源代码，以及创建二进制包的说明。
	</para>
	 <section id="sect.binary-package-structure">
		<title>二进制包的结构</title>
		 <indexterm>
			<primary>包</primary>
			<secondary>二进制包</secondary>
		</indexterm>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <para>
			Debian 软件包格式的设计满足这样的目的，在任何有如下命令：<command>ar</command>、<command>tar</command> 和 <command>gzip</command> （有些系统会有<command>xz</command>或者<command>bzip2</command>）的 Unix 系统上均能顺利解压。这是个看起来非常简单，却又对可移植性和灾难恢复非常重要的特性。
		</para>
		 <para>
			Imagine, for example, that you mistakenly deleted the <command>dpkg</command> program, and that you could thus no longer install Debian packages. <command>dpkg</command> being a Debian package itself, it would seem your system would be done for... Fortunately, you know the format of a package and can therefore download the <filename>.deb</filename> file of the <emphasis role="pkg">dpkg</emphasis> package and install it manually (see sidebar <xref linkend="sidebar.dpkg-apt-ar" />). If by some misfortune one or more of the programs <command>ar</command>, <command>tar</command> or <command>gzip</command>/<command>xz</command>/<command>bzip2</command> have disappeared, you will only need to copy the missing program from another system (since each of these operates in a completely autonomous manner, without dependencies, a simple copy will suffice). If your system suffered some even more outrageous fortune, and even these don't work (maybe the deepest system libraries are missing?), you should try the static version of <command>busybox</command> (provided in the <emphasis role="pkg">busybox-static</emphasis> package), which is even more self-contained, and provides subcommands such as <command>busybox ar</command>, <command>busybox tar</command> and <command>busybox gunzip</command>.
		</para>
		 <sidebar id="sidebar.dpkg-apt-ar"> <title><emphasis>工具</emphasis> <command>dpkg</command>、<command>APT</command> 和 <command>ar</command></title>
		 <indexterm>
			<primary><command>dpkg</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <indexterm>
			<primary>APT</primary>
		</indexterm>
		 <para>
			<command>dpkg</command> 是处理 <filename>.deb</filename> 文件的命令，尤其是解压、分析和解包它们。
		</para>
		 <para>
			<command>APT</command> 是一组允许对系统进行高级的修改的程序：安装或者删除一个软件包（并且保持依赖关系满足），更新系统，列出可用的软件包等。
		</para>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <para>
			对于 <command>ar</command> 程序，它允许处理同名的文件：<command>ar t <replaceable>archive</replaceable></command>会显示包含在这样一个归档中的文件列表；<command>ar x <replaceable>archive</replaceable></command> 将文件从归档中提取至当前工作目录， <command>ar d <replaceable>archive</replaceable> <replaceable>file</replaceable></command> 从归档中删除一个文件，等。它的手册页 (<citerefentry><refentrytitle>ar</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry>) 记录了它的其他全部特性。<command>ar</command> 是一个非常初步的工具，Unix 管理员仅在极少数情况下使用它，而是通常使用<command>tar</command>，一个更先进的归档和文件管理程序。这是在误删情况下容易恢复 <command>dpkg</command> 的原因。您仅需要下载 Debian 包，并在系统 root (<filename>/</filename>)下从 <filename>data.tar.gz</filename> 归档中提取内容：
		</para>
		 
<screen>
<computeroutput># </computeroutput><userinput>ar x dpkg_1.17.23_amd64.deb</userinput>
<computeroutput># </computeroutput><userinput>tar -C / -p -xzf data.tar.gz</userinput></screen>
		 </sidebar> <sidebar> <title><emphasis>基础知识</emphasis> Man 手册注记</title>
		 <para>
			初学者可能会在看到“<citerefentry><refentrytitle>ar</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry>”这样的文字注记时感到疑惑。这通常是个简写，它表示指向 man 手册第一类中标题是 <literal>ar</literal> 的页面。
		</para>
		 <para>
			有时这种注记也用来避免歧义，比如要区分清楚是 <command>printf</command> 命令，可以用 <citerefentry><refentrytitle>printf</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry> 来指明，如果是 C 语言里的 <function>printf</function> 函数，就可以用 <citerefentry><refentrytitle>printf</refentrytitle>
			<manvolnum>3</manvolnum></citerefentry> 来引用。
		</para>
		 <para>
			<xref linkend="solving-problems" /> 更详细地讨论手册页 (参见 <xref linkend="sect.manual-pages" />)。
		</para>
		 </sidebar> <para>
			来看看 <filename>.deb</filename> 文件的内容：
		</para>
		 
<screen><computeroutput>$ </computeroutput><userinput>ar t dpkg_1.17.23_amd64.deb</userinput>
<computeroutput>debian-binary
control.tar.gz
data.tar.gz
$ </computeroutput><userinput>ar x dpkg_1.17.23_amd64.deb</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>control.tar.gz  data.tar.gz  debian-binary  dpkg_1.17.23_amd64.deb
$ </computeroutput><userinput>tar tzf data.tar.gz | head -n 15</userinput>
<computeroutput>./
./var/
./var/lib/
./var/lib/dpkg/
./var/lib/dpkg/parts/
./var/lib/dpkg/info/
./var/lib/dpkg/alternatives/
./var/lib/dpkg/updates/
./etc/
./etc/logrotate.d/
./etc/logrotate.d/dpkg
./etc/dpkg/
./etc/dpkg/dpkg.cfg.d/
./etc/dpkg/dpkg.cfg
./etc/alternatives/
$ </computeroutput><userinput>tar tzf control.tar.gz</userinput>
<computeroutput>./
./conffiles
./postinst
./md5sums
./prerm
./preinst
./control
./postrm
$ </computeroutput><userinput>cat debian-binary</userinput>
<computeroutput>2.0</computeroutput></screen>
		 <para>
			如你所见， Debian 包的 <command>ar</command> 存档格式由三个文件组成：
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					<filename>debian-binary</filename>. This is a text file which simply indicates the version of the <filename>.deb</filename> file used (in 2015: version 2.0).
				</para>

			</listitem>
			 <listitem>
				<para>
					<filename>control.tar.gz</filename>. This archive file contains all of the available meta-information, like the name and version of the package. Some of this meta-information allows package management tools to determine if it is possible to install or uninstall it, for example according to the list of packages already on the machine.
				</para>

			</listitem>
			 <listitem>
				<para>
					<filename>data.tar.gz</filename>. This archive contains all of the files to be extracted from the package; this is where the executable files, documentation, etc., are all stored. Some packages may use other compression formats, in which case the file will be named differently (<filename>data.tar.bz2</filename> for bzip2, <filename>data.tar.xz</filename> for XZ).
				</para>

			</listitem>

		</itemizedlist>

	</section>
	 <section id="sect.package-meta-information">
		<title>软件包元信息</title>
		 <indexterm>
			<primary>软件包元信息</primary>
		</indexterm>
		 <indexterm>
			<primary>package</primary>
			<secondary>元信息</secondary>
		</indexterm>
		 <para>
			The Debian package is not only an archive of files intended for installation. It is part of a larger whole, and it describes its relationship with other Debian packages (dependencies, conflicts, suggestions). It also provides scripts that enable the execution of commands at different stages in the package's lifecycle (installation, removal, upgrades). These data are used by the package management tools but are not part of the packaged software; they are, within the package, what is called its “meta-information” (information about other information).
		</para>
		 <section id="sect.control">
			<title>描述：<filename>control</filename> 文件</title>
			 <indexterm>
				<primary>软件包元信息</primary>
			</indexterm>
			 <indexterm>
				<primary>package</primary>
				<secondary>元信息</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>control</filename></primary>
			</indexterm>
			 <para>
				This file uses a structure similar to email headers (as defined by RFC 2822). For example, for <emphasis role="pkg">apt</emphasis>, the <filename>control</filename> file looks like the following:
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>apt-cache show apt</userinput>
<computeroutput>Package: apt
Version: 1.0.9.6
Installed-Size: 3788
Maintainer: APT Development Team &lt;deity@lists.debian.org&gt;
Architecture: amd64
Replaces: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0)
Depends: libapt-pkg4.12 (&gt;= 1.0.9.6), libc6 (&gt;= 2.15), libgcc1 (&gt;= 1:4.1.1), libstdc++6 (&gt;= 4.9), debian-archive-keyring, gnupg
Suggests: aptitude | synaptic | wajig, dpkg-dev (&gt;= 1.17.2), apt-doc, python-apt
Conflicts: python-apt (&lt;&lt; 0.7.93.2~)
Breaks: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0)
Description-en: commandline package manager
 该软件包提供了用于
 搜索、管理以及以低层次访问
 libapt-pkg 库的全部功能来查询
 软件包信息的命令行工具。
 .
 它包括：
  * apt-get，用于从已验证的源获取软件包
 和相关信息并对软件包及其依赖进行安
 装、升级和删除
  * apt-cache，用于查询已安装和可安
 装软件包的可用信息
  * apt-cdrom，用于将可移除式介质作为软件包的源
  * apt-config，作为设置配置的一个界面
  * apt-key，作为管理验证密钥的一个界面
Description-md5: 9fb97a88cb7383934ef963352b53b4a7
Tag: admin::package-management, devel::lang:ruby, hardware::storage,
 hardware::storage:cd, implemented-in::c++, implemented-in::perl,
 implemented-in::ruby, interface::commandline, network::client,
 protocol::ftp, protocol::http, protocol::ipv6, role::program,
 role::shared-lib, scope::application, scope::utility, sound::player,
 suite::debian, use::downloading, use::organizing, use::searching,
 works-with::audio, works-with::software:package, works-with::text
Section: admin
Priority: important
Filename: pool/main/a/apt/apt_1.0.9.6_amd64.deb
Size: 1107560
MD5sum: a325ccb14e69fef2c50da54e035a4df4
SHA1: 635d09fcb600ec12810e3136d51e696bcfa636a6
SHA256: 371a559ce741394b59dbc6460470a9399be5245356a9183bbeea0f89ecaabb03</computeroutput></screen>
			 <sidebar> <title><emphasis>基础知识</emphasis> RFC －－ 互联网标准</title>
			 <indexterm>
				<primary>RFC</primary>
			</indexterm>
			 <indexterm>
				<primary>Request For Comments</primary>
			</indexterm>
			 <para>
				RFC 是 “征求建议”的缩写。RFC通常是一份描述将要成为互联网的标准的技术文档。在成为标准并被冻结之前，这些标准被提交给大众评估（这就是名字的由来）。 IETF（互联网工程专家组）决定这些文档的演进更新（建议标准、草案或标准）。
			</para>
			 <para>
				RFC 2026 定义了互联网协议标准化的程序。<ulink type="block" url="http://www.faqs.org/rfcs/rfc2026.html" />
			</para>
			 </sidebar> <section>
				<title>依赖：<literal>Depends</literal> 域</title>
				 <indexterm>
					<primary>依赖</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Depends</literal>, 头部的域</primary>
				</indexterm>
				 <indexterm>
					<primary>软件包</primary>
					<secondary>依赖</secondary>
				</indexterm>
				 <para>
					The dependencies are defined in the <literal>Depends</literal> field in the package header. This is a list of conditions to be met for the package to work correctly — this information is used by tools such as <command>apt</command> in order to install the required libraries, in appropriate versions fulfilling the dependencies of the package to be installed. For each dependency, it is possible to restrict the range of versions that meet that condition. In other words, it is possible to express the fact that we need the package <emphasis role="pkg">libc6</emphasis> in a version equal to or greater than “2.15” (written “<command>libc6 (&gt;= 2.15)</command>”). Version comparison operators are as follows:
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							<command>&lt;&lt;</command>：小于；
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&lt;=</command>：小于或等于；
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>=</command>: equal to (note that “<literal>2.6.1</literal>” is not equal to “<literal>2.6.1-1</literal>”);
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&gt;=</command>：大于或等于；
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&gt;&gt;</command>：大于。
						</para>

					</listitem>

				</itemizedlist>
				 <para>
					In a list of conditions to be met, the comma serves as a separator. It must be interpreted as a logical “and”. In conditions, the vertical bar (“|”) expresses a logical “or” (it is an inclusive “or”, not an exclusive “either/or”). Carrying greater priority than “and”, it can be used as many times as necessary. Thus, the dependency “(A or B) and C” is written <command>A | B, C</command>. In contrast, the expression “A or (B and C)” should be written as “(A or B) and (A or C)”, since the <literal>Depends</literal> field does not tolerate parentheses that change the order of priorities between the logical operators “or” and “and”. It would thus be written <command>A | B, A | C</command>. <ulink type="block" url="http://www.debian.org/doc/debian-policy/ch-relationships.html" />
				</para>
				 <indexterm>
					<primary>元-软件包</primary>
				</indexterm>
				 <para>
					The dependencies system is a good mechanism for guaranteeing the operation of a program, but it has another use with “meta-packages”. These are empty packages that only describe dependencies. They facilitate the installation of a consistent group of programs preselected by the meta-package maintainer; as such, <command>apt install <replaceable>meta-package</replaceable></command> will automatically install all of these programs using the meta-package's dependencies. The <emphasis role="pkg">gnome</emphasis>, <emphasis role="pkg">kde-full</emphasis> and <emphasis role="pkg">linux-image-amd64</emphasis> packages are examples of meta-packages.
				</para>
				 <sidebar> <title><emphasis>DEBIAN 政策</emphasis> <literal>预依赖</literal>, 一个更苛刻的 <literal>取决于</literal></title>
				 <indexterm>
					<primary><literal>预依赖</literal>, 头失败</primary>
				</indexterm>
				 <indexterm>
					<primary>预依赖</primary>
				</indexterm>
				 <para>
					“Pre-dependencies”, which are listed in the “<literal>Pre-Depends</literal>” field in the package headers, complete the normal dependencies; their syntax is identical. A normal dependency indicates that the package in question must be unpacked and configured before configuration of the package declaring the dependency. A pre-dependency stipulates that the package in question must be unpacked and configured before execution of the pre-installation script of the package declaring the pre-dependency, that is before its installation.
				</para>
				 <para>
					<command>apt</command>对预依赖的要求非常严格，因为它在安装软件包的时候增加了严格约束。因此，预依赖关系的安装软件的时候不鼓励,除非绝对需要。它甚至建议在加入预依赖前直接咨询开发人员<email>debian-devel@lists.dibian.org</email>。这也是一个通用的解决办法。
				</para>
				 </sidebar> <sidebar> <title><emphasis>DEBIAN 政策</emphasis> <literal>推荐</literal>，<literal>建议</literal>，<literal>提高</literal>水平</title>
				 <indexterm>
					<primary><literal>推荐</literal>，头字段</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>建议</literal>，头字段</primary>
				</indexterm>
				 <para>
					<literal>推荐</literal>和<literal>建议</literal>字段描述的依赖关系不是强制性的。“推荐”的依赖,是最重要的，能显著改善由软件包提供的功能，但这并非是必不可少的操作。“建议”的依赖，是次要的，表明某些软件包可以补充或者增加其各自的效果，有充分的理由去单独安装它而不是其它的软件包。
				</para>
				 <para>
					你应该总是安装“推荐”的软件包，除非你知道究竟为什么你不需要它们。相反，“建议”的软件包是不必要安装的，除非你知道为什么你需要它们。
				</para>
				 <indexterm>
					<primary><literal>增强</literal>，头字段</primary>
				</indexterm>
				 <para>
					The <literal>Enhances</literal> field also describes a suggestion, but in a different context. It is indeed located in the suggested package, and not in the package that benefits from the suggestion. Its interest lies in that it is possible to add a suggestion without having to modify the package that is concerned. Thus, all add-ons, plug-ins, and other extensions of a program can then appear in the list of suggestions related to the software. Although it has existed for several years, this last field is still largely ignored by programs such as <command>apt</command> or <command>synaptic</command>. Its purpose is for a suggestion made by the <literal>Enhances</literal> field to appear to the user in addition to the traditional suggestions — found in the <literal>Suggests</literal> field.
				</para>
				 </sidebar>
			</section>
			 <section>
				<title>冲突：<literal>冲突</literal>字段</title>
				 <indexterm>
					<primary>冲突</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>冲突</literal>，头字段</primary>
				</indexterm>
				 <indexterm>
					<primary>包</primary>
					<secondary>冲突</secondary>
				</indexterm>
				 <para>
					The <literal>Conflicts</literal> field indicates when a package cannot be installed simultaneously with another. The most common reasons for this are that both packages include a file of the same name, or provide the same service on the same TCP port, or would hinder each other's operation.
				</para>
				 <para>
					<command>dpkg</command> will refuse to install a package if it triggers a conflict with an already installed package, except if the new package specifies that it will “replace” the installed package, in which case <command>dpkg</command> will choose to replace the old package with the new one. <command>apt</command> always follows your instructions: if you choose to install a new package, it will automatically offer to uninstall the package that poses a problem.
				</para>

			</section>
			 <section>
				<title>不相容性:<literal>中断</literal>字段</title>
				 <indexterm>
					<primary>不相容性</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>中断</literal>，头字段</primary>
				</indexterm>
				 <indexterm>
					<primary>包</primary>
					<secondary>不相容性</secondary>
				</indexterm>
				 <para>
					<literal>中断</literal>字段有一个影响和<literal>冲突</literal>字段类似，但它具有特殊的意义。它标志着一个包的安装会将另外一个包（或者是特定版本）中断掉。通常而言，两个包之间的不兼容是短暂的，<literal>中断</literal>关系会特别指出那些不兼容的版本。
				</para>
				 <para>
					<command>dpkg</command> will refuse to install a package that breaks an already installed package, and <command>apt</command> will try to resolve the problem by updating the package that would be broken to a newer version (which is assumed to be fixed and, thus, compatible again).
				</para>
				 <para>
					不向后兼容的更新可能会发生这种情况：如果新版本与旧版本的功能不在另一个程序中做特别规定，这将导致故障。<literal>中断</literal>字段会防止用户继续运行从而遇到这些问题。
				</para>

			</section>
			 <section>
				<title>预备好的条目：<literal>预备</literal>字段</title>
				 <indexterm>
					<primary><literal>预备</literal>，头字段</primary>
				</indexterm>
				 <para>
					这个字段引入了一个很有意思的“虚拟包”的概念。它有很多的角色，但有两个特别重要。第一个是由使用虚拟包关联到的一个通用的服务（包“预备”了这些服务）。第二个表示一个包完全取代了另外一个，所以它也能满足依赖性要求。因此，可以创建一个替换而不必使用相同的包名称的包。
				</para>
				 <sidebar> <title><emphasis>VOCABULARY</emphasis>元软件包和虚拟包</title>
				 <indexterm>
					<primary>元-软件包</primary>
				</indexterm>
				 <indexterm>
					<primary>软件包</primary>
					<secondary>虚拟软件包</secondary>
				</indexterm>
				 <indexterm>
					<primary>虚拟软件包</primary>
				</indexterm>
				 <para>
					这里必须明确的从虚拟软件包里面区分出元软件包。元软件包是真实的元件包（包含真实的<filename>.deb</filename>文件），其唯一目的是用来表示依赖性关系。
				</para>
				 <para>
					Virtual packages, however, do not exist physically; they are only a means of identifying real packages based on common, logical criteria (service provided, compatibility with a standard program or a pre-existing package, etc.).
				</para>
				 </sidebar> <section>
					<title>提供一个“服务”</title>
					 <para>
						Let us discuss the first case in greater detail with an example: all mail servers, such as <emphasis role="pkg">postfix</emphasis> or <emphasis role="pkg">sendmail</emphasis> are said to “provide” the <emphasis role="pkg">mail-transport-agent</emphasis> virtual package. Thus, any package that needs this service to be functional (e.g. a mailing list manager, such as <emphasis role="pkg">smartlist</emphasis> or <emphasis role="pkg">sympa</emphasis>) simply states in its dependencies that it requires a <emphasis role="pkg">mail-transport-agent</emphasis> instead of specifying a large yet incomplete list of possible solutions (e.g. <command>postfix | sendmail | exim4 | …</command>). Furthermore, it is useless to install two mail servers on the same machine, which is why each of these packages declares a conflict with the <emphasis role="pkg">mail-transport-agent</emphasis> virtual package. A conflict between a package and itself is ignored by the system, but this technique will prohibit the installation of two mail servers side by side.
					</para>
					 <sidebar> <title><emphasis>DEBIAN 政策</emphasis> 虚拟软件包列表</title>
					 <indexterm>
						<primary>软件包</primary>
						<secondary>虚拟软件包</secondary>
					</indexterm>
					 <para>
						For virtual packages to be useful, everyone must agree on their name. This is why they are standardized in the Debian Policy. The list includes among others <emphasis role="pkg">mail-transport-agent</emphasis> for mail servers, <emphasis role="pkg">c-compiler</emphasis> for C programming language compilers, <emphasis role="pkg">www-browser</emphasis> for web browsers, <emphasis role="pkg">httpd</emphasis> for web servers, <emphasis role="pkg">ftp-server</emphasis> for FTP servers, <emphasis role="pkg">x-terminal-emulator</emphasis> for terminal emulators in graphical mode (<command>xterm</command>), and <emphasis role="pkg">x-window-manager</emphasis> for window managers.
					</para>
					 <para>
						The full list can be found on the Web. <ulink type="block" url="http://www.debian.org/doc/packaging-manuals/virtual-package-names-list.txt" />
					</para>
					 </sidebar>
				</section>
				 <section>
					<title>和另一个软件包的可交互性</title>
					 <para>
						The <literal>Provides</literal> field is also interesting when the content of a package is included in a larger package. For example, the <emphasis role="pkg">libdigest-md5-perl</emphasis> Perl module was an optional module in Perl 5.6, and has been integrated as standard in Perl 5.8 (and later versions, such as 5.20 present in <emphasis role="distribution">Jessie</emphasis>). As such, the package <emphasis role="pkg">perl</emphasis> has since version 5.8 declared <literal>Provides: libdigest-md5-perl</literal> so that the dependencies on this package are met if the user has Perl 5.8 (or newer). The <emphasis role="pkg">libdigest-md5-perl</emphasis> package itself has eventually been deleted, since it no longer had any purpose when old Perl versions were removed.
					</para>
					 <figure>
						<title>使用了<literal>预备</literal>字段来避免中断依赖性关系</title>
						 <mediaobject>
							<imageobject>
								<imagedata fileref="images/virtual-package.png" format="PNG" width="50%" />
							</imageobject>

						</mediaobject>

					</figure>
					 <para>
						这个功能非常有用，因为它是永远不可能预料到变化莫测的发展，它不能够调整重命名，或者其他自动替换过的软件，所以它是必要的。
					</para>
					 <sidebar> <title><emphasis>回到基本</emphasis>Perl，一种编程语言</title>
					 <indexterm>
						<primary>Perl</primary>
					</indexterm>
					 <indexterm>
						<primary>CPAN</primary>
					</indexterm>
					 <para>
						Perl（实用报表提取语言）是非常受欢迎的编程语言。它有许多现成的模块，涵盖了广阔的应用，这些都是由CPAN（Perl综合架构网络）提供服务的，cpan是一个详尽的网络Perl软件包。<ulink type="block" url="http://www.perl.org/" /> <ulink type="block" url="http://www.cpan.org/" />
					</para>
					 <para>
						由于它是一种解释型语言，Perl 语言编写的程序并不需要在执行之前进行编译。这就是大家称其为“Perl 脚本”的原因。
					</para>
					 </sidebar>
				</section>
				 <section>
					<title>Past Limitations</title>
					 <para>
						Virtual packages used to suffer from some limitations, the most significant of which was the absence of a version number. To return to the previous example, a dependency such as <literal>Depends: libdigest-md5-perl (&gt;= 1.6)</literal>, despite the presence of Perl 5.10, would never be considered as satisfied by the packaging system — while in fact it most likely is satisfied. Unaware of this, the package system chose the least risky option, assuming that the versions do not match.
					</para>
					 <para>
						该限制已经在 <emphasis role="pkg">dpkg</emphasis> 1.17.11 中解除，在 Jessie 中不再相关。软件包可以给提供依赖的虚拟包指定一个版本，如 <literal>Provides: libdigest-md5-perl (= 1.8)</literal>。
					</para>

				</section>

			</section>
			 <section>
				<title>替换文件：<literal>替换</literal>字段</title>
				 <indexterm>
					<primary>替换</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>替换</literal>,头字段</primary>
				</indexterm>
				 <indexterm>
					<primary>软件包</primary>
					<secondary>替换</secondary>
				</indexterm>
				 <para>
					The <literal>Replaces</literal> field indicates that the package contains files that are also present in another package, but that the package is legitimately entitled to replace them. Without this specification, <command>dpkg</command> fails, stating that it can not overwrite the files of another package (technically, it is possible to force it to do so with the <literal>--force-overwrite</literal> option, but that is not considered standard operation). This allows identification of potential problems and requires the maintainer to study the matter prior to choosing whether to add such a field.
				</para>
				 <para>
					当软件包名称变更时，或者当一个软件包包含在另外一个的时候，此字段的使用是合理的。这也发生在维护者决定从来自相同的源码包的大量二进制包里分发出文件：一个替换的文件不再属于旧的软件包，只有新的才属于。
				</para>
				 <para>
					如果已安装软件包的所有文件都被替换了，那么该软件包将认为将被删除掉。最后，这个字段会鼓励<command>dpkg</command>命令去删除替换掉有冲突的包。
				</para>
				 <sidebar id="sidebar.debtags"> <title><emphasis>更进一步</emphasis><literal>标签</literal>字段</title>
				 <para>
					In the <emphasis role="pkg">apt</emphasis> example above, we can see the presence of a field that we have not yet described, the <literal>Tag</literal> field. This field does not describe a relationship between packages, but is simply a way of categorizing a package in a thematic taxonomy. This classification of packages according to several criteria (type of interface, programming language, domain of application, etc.) has been available for a long time. Despite this, not all packages have accurate tags and it is not yet integrated in all Debian tools; <command>aptitude</command> displays these tags, and allows them to be used as search criteria. For those who are repelled by <command>aptitude</command>'s search criteria, the following website allows navigation of the tag database: <ulink type="block" url="http://debtags.alioth.debian.org/" />
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.configuration-scripts">
			<title>配置脚本</title>
			 <indexterm>
				<primary><filename>postinst</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>preinst</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>postrm</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>prerm</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>control.tar.gz</filename></primary>
			</indexterm>
			 <para>
				除了<filename>控制</filename>文件之外，每个Debian软件包可能在<filename>control.tar.gz</filename>的存档中包含了一些脚本，这些脚本在软件包处理的不同的阶段被<command>dpkg</command>调用。Debian政策描述了一些可能的细节，在可能的情况下，指定脚本调用它们所收到的参数。这些顺序可能比较复杂，因为如果脚本中任何一步出现问题的时候，<command>dpkg</command>进程会通过取消安装或者卸载来尝试恢复到一个令人满意的状态（只要是可能的）。
			</para>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> <command>dpkg</command>'s database</title>
			 <indexterm>
				<primary><filename>/var/lib/dpkg</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>dpkg</primary>
				<secondary>database</secondary>
			</indexterm>
			 <para>
				所有已安装的软件包的配置脚本都存在<filename>/var/lib/dpkg/info/</filename>目录，在软件包的名字前会有一个文件名的前缀。此目录的每个软件包还包括一个叫<filename>.list</filename>的文件扩展，包括列表的文件字段属于哪些包。
			</para>
			 <para>
				<filename>/var/lib/dpkg/status</filename>文件包含了一些数据块（著名的邮件标题的格式，RFC2822）描述了每个软件包的状态。从<filename>control</filename>文件中已经安装的软件包的信息也会被复制。
			</para>
			 </sidebar> <para>
				在一般情况下，<filename>preinst</filename>脚本会在安装软件包前执行，而<filename>postinst</filename>会稍候执行。同样，<filename>prerm</filename>会在移除一个软件包的前和<filename>postrm</filename>之后。更新软件包相当于是清除掉以前的旧版本并且安装新的软件包。所以在这里我们不可能来详细描述所有的可能的方案，但我们将讨论最常见的两种：安装/更新和移除。
			</para>
			 <sidebar> <title><emphasis>小心</emphasis> 脚本的符号名称</title>
			 <para>
				本节中使用特定的名称序列命名配置脚本，例如 <command>old-prerm</command> 或 <command>new-postinst</command>。它们分别是旧版本软件包（ 在更新前已安装）中包含的 <command>prerm</command>脚本和新版本软件包（由本次更新所安装）中包含的 <command>postinst</command> 脚本。
			</para>
			 </sidebar> <sidebar> <title><emphasis>提示</emphasis>状态图</title>
			 <para>
				Manoj Srivastava made these diagrams explaining how the configuration scripts are called by <command>dpkg</command>. Similar diagrams have also been developed by the Debian Women project; they are a bit simpler to understand, but less complete. <ulink type="block" url="https://people.debian.org/~srivasta/MaintainerScripts.html" /> <ulink type="block" url="https://wiki.debian.org/MaintainerScripts" />
			</para>
			 </sidebar> <section>
				<title>安装和升级</title>
				 <indexterm>
					<primary><command>dpkg</command></primary>
					<secondary>internal operation</secondary>
				</indexterm>
				 <para>
					这里告诉你，安装的时候发生了什么（或者是更新）
				</para>
				 <orderedlist>
					<listitem>
						<para>
							对于升级，<command>dpkg</command>会调用<command>old-prerm 升级新版本 <replaceable></replaceable></command>。
						</para>

					</listitem>
					 <listitem>
						<para>
							还是对于升级，<command>dpkg</command>执行<command>new-preinst 升级<replaceable>旧版本</replaceable></command>；对于第一个安装，它会执行<command>new-preinst 安装</command>。它可能会增加旧版本的最后一个参数，如果软件包已经被安装或者是删除了（但没有清除合并掉旧版本，那么这个配置文件会被保留）。
						</para>

					</listitem>
					 <listitem>
						<para>
							新的软件包文件被解压。如果文件已经存在，就被会替换，同时会产生一个临时的备份副本。
						</para>

					</listitem>
					 <listitem>
						<para>
							对于更新，<command>dpkg</command>执行<command>old-postrm 升级<replaceable>新版本</replaceable></command>。
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command>更新所有的内部数据（文件爱女列表，配置脚本等），并删除被替换文件的备份。这是一条不归路： ） <command>dpkg</command>将不再具有访问所有元素的需要以此来返回以前的状态。
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> will update the configuration files, asking the user to decide if it is unable to automatically manage this task. The details of this procedure are discussed in <xref linkend="sect.conffiles" />.
						</para>

					</listitem>
					 <listitem>
						<para>
							最后，<command>dpkg</command> 通过执行 <command>new-postinst configure <replaceable>最近一次配置的版本号</replaceable></command> 对软件包进行配置。
						</para>

					</listitem>

				</orderedlist>

			</section>
			 <section>
				<title>软件包移除</title>
				 <para>
					这里是当移除一个软件包的时候发生了什么：
				</para>
				 <orderedlist>
					<listitem>
						<para>
							<command>dpkg</command> 回调<command>prerm 移除</command>。
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> 移除了所有的软件包文件，只剩下了配置文件和配置的脚本。
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> executes <command>postrm remove</command>. All of the configuration scripts, except <filename>postrm</filename>, are removed. If the user has not used the “purge” option, the process stops here.
						</para>

					</listitem>
					 <listitem>
						<para>
							对于一个完整的清除包（由<command>dpkg --purge</command>或<command>dpkg -P</command>发出的），配置文件也将会被删除，同时一些副本（<filename>*.dpkg-tmp</filename>,<filename>*.dpkg-old</filename>,<filename>*.dpkg-new</filename>）和缓存文件也会被删除掉；<command>dpkg</command>这时会执行<command>postrm purge</command>。
						</para>

					</listitem>

				</orderedlist>
				 <sidebar> <title><emphasis>VOCABULARY</emphasis> Purge, a complete removal</title>
				 <indexterm>
					<primary>清除软件包</primary>
				</indexterm>
				 <para>
					当Debian的软件包被移除掉的时候，该软件包的配置文件会被保留下来以便重新安装。同样，守护程序产生的数据（比如LDAP的服务器目录内容，或者是SQL服务器的数据库内容）也常常会被保留。
				</para>
				 <para>
					移除掉软件包所关联的所有数据，必须使用“purge”命令，<command>dpkg -P<replaceable>软件包</replaceable></command>，<command>apt-get remove --purge <replaceable>软件包</replaceable></command> 或者是<command>aptitude purge <replaceable>软件包</replaceable></command>。
				</para>
				 <para>
					Given the definitive nature of such data removals, a purge should not be taken lightly.
				</para>
				 </sidebar> <indexterm>
					<primary><filename>config</filename>, <command>debconf</command> script</primary>
				</indexterm>
				 <para>
					The four scripts detailed above are complemented by a <filename>config</filename> script, provided by packages using <command>debconf</command> to acquire information from the user for configuration. During installation, this script defines in detail the questions asked by <command>debconf</command>. The responses are recorded in the <command>debconf</command> database for future reference. The script is generally executed by <command>apt</command> prior to installing packages one by one in order to group all the questions and ask them all to the user at the beginning of the process. The pre- and post-installation scripts can then use this information to operate according to the user's wishes.
				</para>
				 <sidebar> <title><emphasis>工具</emphasis> <command>debconf</command></title>
				 <indexterm>
					<primary><command>debconf</command></primary>
				</indexterm>
				 <para>
					<command>debconf</command> was created to resolve a recurring problem in Debian. All Debian packages unable to function without a minimum of configuration used to ask questions with calls to the <command>echo</command> and <command>read</command> commands in <filename>postinst</filename> shell scripts (and other similar scripts). But this also means that during a large installation or update the user must stay with their computer to respond to various questions that may arise at any time. These manual interactions have now been almost entirely dispensed with, thanks to the <command>debconf</command> tool.
				</para>
				 <para>
					<command>debconf</command> has many interesting features: it requires the developer to specify user interaction; it allows localization of all the strings displayed to users (all translations are stored in the <filename>templates</filename> file describing the interactions); it has different frontends to display the questions to the user (text mode, graphical mode, non-interactive); and it allows creation of a central database of responses to share the same configuration with several computers... but the most important is that it is now possible to present all of the questions in a row to the user, prior to starting a long installation or update process. The user can go about their business while the system handles the installation on its own, without having to stay there staring at the screen waiting for questions.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.conffiles">
			<title>校验，配置文件列表</title>
			 <indexterm>
				<primary><filename>md5sums</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>冲突文件</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>checksums</primary>
			</indexterm>
			 <indexterm>
				<primary>文件</primary>
				<secondary>配置文件</secondary>
			</indexterm>
			 <indexterm>
				<primary>配置</primary>
				<secondary>文件</secondary>
			</indexterm>
			 <para>
				In addition to the maintainer scripts and control data already mentioned in the previous sections, the <filename>control.tar.gz</filename> archive of a Debian package may contain other interesting files. The first, <filename>md5sums</filename>, contains the MD5 checksums for all of the package's files. Its main advantage is that it allows <command>dpkg --verify</command> (which we will study in <xref linkend="sect.dpkg-verify" />) to check if these files have been modified since their installation. Note that when this file doesn't exist, <command>dpkg</command> will generate it dynamically at installation time (and store it in the dpkg database just like other control files).
			</para>
			 <para>
				<filename>conffiles</filename> lists package files that must be handled as configuration files. Configuration files can be modified by the administrator, and <command>dpkg</command> will try to preserve those changes during a package update.
			</para>
			 <para>
				实际上，在这种情况下，<command>dpkg</command>的行为会尽可能地智能：如果两个版本之间并没有改变标准的配置文件，那么<command>dpkg</command>就什么也不会作。但是，如果文件已经被修改，它会尝试更新此文件。这会产生两种可能的情况：一是管理员没有碰配置文件，在这种情况下<command>dpkg</command>会自动安装新版本；二是文件已经被修改了，在这种情况下<command>dpkg</command>会询问管理员希望使用哪个版本（旧版本或者新的）。为了帮助用户作出选择，<command>dpkg</command>会提供“<command>差异</command>”，这会显示两个版本之间的差异。如果用户选择保留旧的版本，新的将被存储在文件夹的同一个位置并以<filename>.dpkg-dist</filename>为后缀名的文件中。另外一个可能的操作是由暂时中断的<command>dpkg</command>来编辑该文件，并试图重新恢复相关的修改（之前被验证的<command>差异</command>）。
			</para>
			 <sidebar id="sidebar.questions-conffiles"> <title><emphasis>更进一步</emphasis> 避免配置文件问题</title>
			 <para>
				<command>dpkg</command> handles configuration file updates, but, while doing so, regularly interrupts its work to ask for input from the administrator. This makes it less than enjoyable for those who wish to run updates in a non-interactive manner. This is why this program offers options that allow the system to respond automatically according to the same logic: <command>--force-confold</command> retains the old version of the file; <command>--force-confnew</command> will use the new version of the file (these choices are respected, even if the file has not been changed by the administrator, which only rarely has the desired effect). Adding the <command>--force-confdef</command> option tells <command>dpkg</command> to decide by itself when possible (in other words, when the original configuration file has not been touched), and only uses <command>--force-confnew</command> or <command>--force-confold</command> for other cases.
			</para>
			 <para>
				这些选项使用<command>dpkg</command>，但是大多数时间管理员会直接用<command>aptitude</command> 或<command>apt-get</command>。实际上，有必要知道dpkg的语法参数来使用<command>dpkg</command>命令（命令行的界面是非常相似的）。
			</para>
			 
<screen>
<computeroutput># </computeroutput><userinput>apt -o DPkg::options::="--force-confdef" -o DPkg::options::="--force-confold" full-upgrade</userinput></screen>
			 <para>
				These options can be stored directly in <command>apt</command>'s configuration. To do so, simply write the following line in the <filename>/etc/apt/apt.conf.d/local</filename> file:
			</para>
			 <informalexample> 
<programlisting>
DPkg::options { "--force-confdef"; "--force-confold"; }
</programlisting>
			 </informalexample> <para>
				Including this option in the configuration file means that it will also be used in a graphical interface such as <command>aptitude</command>.
			</para>
			 </sidebar> <sidebar id="sidebar.questions-conffiles-bis"> <title><emphasis>更进一步</emphasis> 强制dpkg询问配置文件问题</title>
			 <para>
				The <command>--force-confask</command> option requires <command>dpkg</command> to display the questions about the configuration files, even in cases where they would not normally be necessary. Thus, when reinstalling a package with this option, <command>dpkg</command> will ask the questions again for all of the configuration files modified by the administrator. This is very convenient, especially for reinstalling the original configuration file if it has been deleted and no other copy is available: a normal re-installation won't work, because <command>dpkg</command> considers removal as a form of legitimate modification, and, thus, doesn't install the desired configuration file.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.source-package-structure">
		<title>源软件包的结构</title>
		 <indexterm>
			<primary>包</primary>
			<secondary>源码包</secondary>
		</indexterm>
		 <indexterm>
			<primary>源码</primary>
			<secondary>包</secondary>
		</indexterm>
		 <section>
			<title>格式</title>
			 <indexterm>
				<primary>DSC 文件</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>diff.gz</filename> 文件</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>debian.tar.gz</filename> file</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>orig.tar.gz</filename> file</primary>
			</indexterm>
			 <para>
				A source package is usually comprised of three files, a <filename>.dsc</filename>, a <filename>.orig.tar.gz</filename>, and a <filename>.debian.tar.gz</filename> (or <filename>.diff.gz</filename>). They allow creation of binary packages (<filename>.deb</filename> files described above) from the source code files of the program, which are written in a programming language.
			</para>
			 <para>
				The <filename>.dsc</filename> (Debian Source Control) file is a short text file containing an RFC 2822 header (just like the <filename>control</filename> file studied in <xref linkend="sect.control" />) which describes the source package and indicates which other files are part thereof. It is signed by its maintainer, which guarantees authenticity. See <xref linkend="sect.package-authentication" /> for further details on this subject.
			</para>
			 <example>
				<title>一个<filename>.dsc</filename> 文件</title>
				 
<programlisting>
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Format: 3.0 (quilt)
Source: zim
Binary: zim
Architecture: all
Version: 0.62-3
Maintainer: Emfox Zhou &lt;emfox@debian.org&gt;
Uploaders: Raphaël Hertzog &lt;hertzog@debian.org&gt;
Homepage: http://zim-wiki.org
Standards-Version: 3.9.6
Vcs-Browser: http://anonscm.debian.org/gitweb/?p=collab-maint/zim.git
Vcs-Git: git://anonscm.debian.org/collab-maint/zim.git
Build-Depends: debhelper (&gt;= 9), xdg-utils, python (&gt;= 2.6.6-3~), libgtk2.0-0 (&gt;= 2.6), python-gtk2, python-xdg
Package-List:
 zim deb x11 optional arch=all
Checksums-Sha1:
 ad8de170826682323c10195b65b9f1243fd75637 1772246 zim_0.62.orig.tar.gz
 a4f70d6f7fb404022c9cc4870a4e62ea3ca08388 14768 zim_0.62-3.debian.tar.xz
Checksums-Sha256:
 19d62aebd2c1a92d84d80720c6c1dcdb779c39a2120468fed01b7f252511bdc2 1772246 zim_0.62.orig.tar.gz
 fc2e827e83897d5e33f152f124802c46c3c01c5158b75a8275a27833f1f6f1de 14768 zim_0.62-3.debian.tar.xz
Files:
 43419efba07f7086168442e3d698287a 1772246 zim_0.62.orig.tar.gz
 725a69663a6c2961f07673ae541298e4 14768 zim_0.62-3.debian.tar.xz

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2
Comment: Signed by Raphael Hertzog

iQEcBAEBCAAGBQJUR2jqAAoJEAOIHavrwpq5WFcH/RsdzCHc1oXXxHitU23hEqMj
T6ok29M1UFDJDowMXW75jQ1nT4WPUtvEGygkCHeoO/PvjEvB0sjU8GQlX+N9ddSB
aHfqfAYmVhADNGxrXQT5inZXUa8qGeeq2Sqf6YcWtsnuD56lDbvxkyf/XYopoIEl
oltfl05z/AI+vYsW482YrCz0fxNAKAvkyuPhDebYI8jnKWeAANoqmKpsNc/HYyvT
+ZiA5o57OiGdOKT6XGy3/FiF3dkHiRY8lXW7xdr1BbIgulwl9UmiUNwuxwOYbQO7
edtjiTJqOaFUA0x1zB/XGv5tHr1MjP8naT+kfVoVHTOox51CDbeu5D3DZY4imcY=
=Wtoa
-----END PGP SIGNATURE-----</programlisting>

			</example>
			 <indexterm>
				<primary><literal>编译-依赖</literal>，头字段</primary>
			</indexterm>
			 <para>
				需要注意的是从二进制包编译出来的源码包也完全不同，它也有依赖关系（<literal>编译-依赖</literal>），因为它们需要编译器来编译和构建它们的源码包。
			</para>
			 <sidebar> <title><emphasis>当心</emphasis> 不同的命名空间</title>
			 <para>
				It is important to note here that there is no required correspondence between the name of the source package and that of the binary package(s) that it generates. It is easy enough to understand if you know that each source package may generate several binary packages. This is why the <filename>.dsc</filename> file has the <literal>Source</literal> and <literal>Binary</literal> fields to explicitly name the source package and store the list of binary packages that it generates.
			</para>
			 </sidebar> <sidebar> <title><emphasis>文化</emphasis> 为什么要分成几个软件包</title>
			 <para>
				Quite frequently, a source package (for a given software) can generate several binary packages. The split is justified by the possibility to use (parts of) the software in different contexts. Consider a shared library, it may be installed to make an application work (for example, <emphasis role="pkg">libc6</emphasis>), or it can be installed to develop a new program (<emphasis role="pkg">libc6-dev</emphasis> will then be the correct package). We find the same logic for client/server services where we want to install the server part on one machine and the client part on others (this is the case, for example, of <emphasis role="pkg">openssh-server</emphasis> and <emphasis role="pkg">openssh-client</emphasis>).
			</para>
			 <para>
				一样频繁的是，在一个专用的软件包提供的文档中：用户可以安装独立的软件，并且可以在任何时候选择删除掉以节省磁盘空间。此外，这也节省了Debian镜像的磁盘空间，因为在所有的节点中（而不是在每个节点的都用一样的文档软件包）将共享这个文档软件包。
			</para>
			 </sidebar> <sidebar> <title><emphasis>洞察</emphasis>不同格式的源码包</title>
			 <para>
				本来只有一个原始的软件包格式，像<literal>1.0</literal>这样的格式，它关联了<filename>.orig.tar.gz</filename>和<filename>.diff.gz</filename>“Debian化”的补丁（还有一个变种，由一个单一的<filename>.tar.gz</filename>归档，当<filename>.orig.tar.gz</filename>不可用时它会自动使用。）
			</para>
			 <para>
				Since Debian <emphasis role="distribution">Squeeze</emphasis>, Debian developers have the option to use new formats that correct many problems of the historical format. Format <literal>3.0 (quilt)</literal> can combine multiple upstream archives in the same source package: in addition to the usual <filename>.orig.tar.gz</filename>, supplementary <filename>.orig-<replaceable>component</replaceable>.tar.gz</filename> archives can be included. This is useful with software that is distributed in several upstream components but for which a single source package is desired. These archives can also be compressed with <command>bzip2</command> or <command>xz</command> rather than <command>gzip</command>, which saves disk space and network resources. Finally, the monolithic patch, <filename>.diff.gz</filename> is replaced by a <filename>.debian.tar.gz</filename> archive containing the compiling instructions and a set of upstream patches contributed by the package maintainer. These last are recorded in a format compatible with <command>quilt</command> — a tool that facilitates the management of a series of patches.
			</para>
			 </sidebar> <para>
				The <filename>.orig.tar.gz</filename> file is an archive containing the source code as provided by the original developer. Debian package maintainers are asked to not modify this archive in order to be able to easily check the origin and integrity of the file (by simple comparison with a checksum) and to respect the wishes of some authors.
			</para>
			 <para>
				The <filename>.debian.tar.gz</filename> contains all of the modifications made by the Debian maintainer, especially the addition of a <filename>debian</filename> directory containing the instructions to execute to construct a Debian package.
			</para>
			 <sidebar> <title><emphasis>工具</emphasis> 解压缩源码包</title>
			 <indexterm>
				<primary><command>dpkg-source</command></primary>
			</indexterm>
			 <indexterm>
				<primary>decompressing, source package</primary>
			</indexterm>
			 <indexterm>
				<primary>uncompressing, source package</primary>
			</indexterm>
			 <indexterm>
				<primary>unpacking</primary>
				<secondary>source package</secondary>
			</indexterm>
			 <para>
				If you have a source package, you can use the <command>dpkg-source</command> command (from the <emphasis role="pkg">dpkg-dev</emphasis> package) to decompress it:
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>dpkg-source -x package_0.7-1.dsc</userinput></screen>
			 <para>
				You can also use <command>apt-get</command> to download a source package and unpack it right away. It requires that the appropriate <literal>deb-src</literal> lines be present in the <filename>/etc/apt/sources.list</filename> file, however (for further details, see <xref linkend="sect.apt-sources.list" />). These are used to list the “sources” of source packages (meaning the servers on which a group of source packages are hosted).
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>apt-get source <replaceable>package</replaceable></userinput></screen>
			 </sidebar>
		</section>
		 <section>
			<title>Debian中的使用</title>
			 <para>
				The source package is the foundation of everything in Debian. All Debian packages come from a source package, and each modification in a Debian package is the consequence of a modification made to the source package. The Debian maintainers work with the source package, knowing, however, the consequences of their actions on the binary packages. The fruits of their labors are thus found in the source packages available from Debian: you can easily go back to them and everything stems from them.
			</para>
			 <para>
				When a new version of a package (source package and one or more binary packages) arrives on the Debian server, the source package is the most important. Indeed, it will then be used by a network of machines of different architectures for compilation on the various architectures supported by Debian. The fact that the developer also sends one or more binary packages for a given architecture (usually i386 or amd64) is relatively unimportant, since these could just as well have been automatically generated.
			</para>

		</section>

	</section>
	 <section id="sect.manipulating-packages-with-dpkg">
		<title>通过<command>dpkg</command>来操作软件包</title>
		 <indexterm>
			<primary><command>dpkg</command></primary>
		</indexterm>
		 <para>
			<command>dpkg</command> is the base command for handling Debian packages on the system. If you have <filename>.deb</filename> packages, it is <command>dpkg</command> that allows installation or analysis of their contents. But this program only has a partial view of the Debian universe: it knows what is installed on the system, and whatever it is given on the command line, but knows nothing of the other available packages. As such, it will fail if a dependency is not met. Tools such as <command>apt</command>, on the contrary, will create a list of dependencies to install everything as automatically as possible.
		</para>
		 <sidebar> <title><emphasis>NOTE</emphasis> <command>dpkg</command> or <command>apt</command>?</title>
		 <para>
			<command>dpkg</command> should be seen as a system tool (backend), and <command>apt</command> as a tool closer to the user, which overcomes the limitations of the former. These tools work together, each one with its particularities, suited to specific tasks.
		</para>
		 </sidebar> <section>
			<title>安装软件包</title>
			 <indexterm>
				<primary>安装</primary>
				<secondary>软件包安装</secondary>
			</indexterm>
			 <indexterm>
				<primary>软件包</primary>
				<secondary>安装</secondary>
			</indexterm>
			 <para>
				<command>dpkg</command> is, above all, the tool for installing an already available Debian package (because it does not download anything). To do this, we use its <literal>-i</literal> or <literal>--install</literal> option.
			</para>
			 <example>
				<title>通过<command>dpkg</command>来安装一个软件包</title>
				 
<screen role="scale">
<computeroutput># </computeroutput><userinput>dpkg -i man-db_2.7.0.2-5_amd64.deb</userinput>
<computeroutput>(Reading database ... 86425 files and directories currently installed.)
Preparing to unpack man-db_2.7.0.2-5_amd64.deb ...
Unpacking man-db (2.7.0.2-5) over (2.7.0.2-4) ...
Setting up man-db (2.7.0.2-5) ...
Updating database of manual pages ...
Processing triggers for mime-support (3.58) ...</computeroutput></screen>

			</example>
			 <para>
				通过<command>dpkg</command>我们可以看到安装时的不同步骤；因此我们会知道在什么时候可能会发生错误。安装也被分为两个阶段：首先解压包，然后配置它。<command>apt-get</command>会利用这一点，然后有限的调用<command>dpkg</command>（因为每次调用都要把数据加载到内存中，特别是那些在名单中已经被安装的文件）。
			</para>
			 <example>
				<title>分开解压和配置</title>
				 
<screen role="scale">
<computeroutput># </computeroutput><userinput>dpkg --unpack man-db_2.7.0.2-5_amd64.deb</userinput>
<computeroutput>(Reading database ... 86425 files and directories currently installed.)
Preparing to unpack man-db_2.7.0.2-5_amd64.deb ...
Unpacking man-db (2.7.0.2-5) over (2.7.0.2-5) ...
Processing triggers for mime-support (3.58) ...
# </computeroutput><userinput>dpkg --configure man-db</userinput>
<computeroutput>Setting up man-db (2.7.0.2-5) ...
Updating database of manual pages ...
</computeroutput></screen>

			</example>
			 <indexterm>
				<primary>软件包</primary>
				<secondary>解压</secondary>
			</indexterm>
			 <indexterm>
				<primary>unpacking</primary>
				<secondary>binary package</secondary>
			</indexterm>
			 <para>
				有时<command>dpkg</command>在安装软件包的时候会失败并且返回一个错误；如果用户命令dpkg忽略掉这个错误，那么它仅仅会提示一个警告；这也就是我们有一个不同的<literal>--force--*</literal>选项。<command>dpkg --force-help</command>，或者是dpkg的帮助文档，有一个这些选项的详细清单。最常见的错误是，你迟到会遇到这样一个文件冲突，当一个软件包包含的文件中已经安装了另外一个软件包。
			</para>
			 
<screen>
<computeroutput>Unpacking libgdm (from .../libgdm_3.8.3-2_amd64.deb) ...
dpkg: error processing /var/cache/apt/archives/libgdm_3.8.3-2_amd64.deb (--unpack):
 trying to overwrite '/usr/bin/gdmflexiserver', which is also in package gdm3 3.4.1-9</computeroutput></screen>
			 <para>
				在这种情况下，如果你认为文件替换该文件可能不会对系统的稳定性造成重大的风险（通常情况下），你可以使用<literal>--force-overwrite</literal>选项来告诉<command>dpkg</command>去忽略这个错误并且覆盖该文件。
			</para>
			 <para>
				当然这里有非常多的<literal>--force-*</literal>选项，只是<literal>--force-overwrite</literal>使用的非常频繁。这些选项仅存在特殊的情况下，所以最好是不去使用它们以便遵守软件包的管理机制。不要忘了，这些管理规则可以确保你的系统的稳定性和一致性。
			</para>
			 <sidebar> <title><emphasis>注意</emphasis> 使用<literal>--force-*</literal>的影响</title>
			 <indexterm>
				<primary>破坏依赖性</primary>
			</indexterm>
			 <para>
				If you are not careful, the use of an option <literal>--force-*</literal> can lead to a system where the APT family of commands will refuse to function. In effect, some of these options allow installation of a package when a dependency is not met, or when there is a conflict. The result is an inconsistent system from the point of view of dependencies, and the APT commands will refuse to execute any action except those that will bring the system back to a consistent state (this often consists of installing the missing dependency or removing a problematic package). This often results in a message like this one, obtained after installing a new version of <emphasis role="pkg">rdesktop</emphasis> while ignoring its dependency on a newer version of the <emphasis role="pkg">libc6</emphasis>:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>apt full-upgrade
</userinput><computeroutput>[...]
You might want to run 'apt-get -f install' to correct these.
The following packages have unmet dependencies:
  rdesktop: Depends: libc6 (&gt;= 2.5) but 2.3.6.ds1-13etch7 is installed
E: Unmet dependencies. Try using -f.</computeroutput></screen>
			 <para>
				A courageous administrator who is certain of the correctness of their analysis may choose to ignore a dependency or conflict and use the corresponding <literal>--force-*</literal> option. In this case, if they want to be able to continue to use <command>apt</command> or <command>aptitude</command>, they must edit <filename>/var/lib/dpkg/status</filename> to delete/modify the dependency, or conflict, that they chose to override.
			</para>
			 <para>
				This manipulation is an ugly hack, and should never be used, except in the most extreme case of necessity. Quite frequently, a more fitting solution is to recompile the package that's causing the problem (see <xref linkend="sect.rebuilding-package" />) or use a new version (potentially corrected) from a repository such as the <literal>stable-backports</literal> one (see <xref linkend="sect.backports" />).
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>软件包移除</title>
			 <indexterm>
				<primary>删除掉一个软件包</primary>
			</indexterm>
			 <indexterm>
				<primary>purging a package</primary>
			</indexterm>
			 <indexterm>
				<primary>软件包</primary>
				<secondary>卸载</secondary>
			</indexterm>
			 <indexterm>
				<primary>软件包</primary>
				<secondary>清除</secondary>
			</indexterm>
			 <para>
				Invoking <command>dpkg</command> with the <literal>-r</literal> or <literal>--remove</literal> option, followed by the name of a package, removes that package. This removal is, however, not complete: all of the configuration files, maintainer scripts, log files (system logs) and other user data handled by the package remain. That way disabling the program is easily done by uninstalling it, and it's still possible to quickly reinstall it with the same configuration. To completely remove everything associated with a package, use the <literal>-P</literal> or <literal>--purge</literal> option, followed by the package name.
			</para>
			 <example>
				<title>Removal and purge of the <emphasis role="pkg">debian-cd</emphasis> package</title>
				 
<screen><computeroutput># </computeroutput><userinput>dpkg -r debian-cd</userinput>
<computeroutput>(Reading database ... 97747 files and directories currently installed.)
Removing debian-cd (3.1.17) ...
# </computeroutput><userinput>dpkg -P debian-cd</userinput>
<computeroutput>(Reading database ... 97401 files and directories currently installed.)
Removing debian-cd (3.1.17) ...
Purging configuration files for debian-cd (3.1.17) ...</computeroutput></screen>

			</example>

		</section>
		 <section>
			<title>查询 <command>dpkg</command> 的数据库，并检查 <filename>.deb</filename> 文件</title>
			 <indexterm>
				<primary>软件包</primary>
				<secondary>状态</secondary>
			</indexterm>
			 <indexterm>
				<primary>软件包</primary>
				<secondary>文件列表</secondary>
			</indexterm>
			 <indexterm>
				<primary>软件包</primary>
				<secondary>内容检查</secondary>
			</indexterm>
			 <sidebar> <title><emphasis>回到基础</emphasis> 选项的语法</title>
			 <para>
				Most options are available in a “long” version (one or more relevant words, preceded by a double dash) and a “short” version (a single letter, often the initial of one word from the long version, and preceded by a single dash). This convention is so common that it is a POSIX standard.
			</para>
			 </sidebar> <para>
				Before concluding this section, we will study <command>dpkg</command> options that query the internal database in order to obtain information. Giving first the long options and then corresponding short options (that will evidently take the same possible arguments) we cite <literal>--listfiles <replaceable>package</replaceable></literal> (or <literal>-L</literal>), which lists the files installed by this package; <literal>--search <replaceable>file</replaceable></literal> (or <literal>-S</literal>), which finds the package(s) containing the file; <literal>--status <replaceable>package</replaceable></literal> (or <literal>-s</literal>), which displays the headers of an installed package; <literal>--list</literal> (or <literal>-l</literal>), which displays the list of packages known to the system and their installation status; <literal>--contents <replaceable>file.deb</replaceable></literal> (or <literal>-c</literal>), which lists the files in the Debian package specified; <literal>--info<replaceable> file.deb </replaceable></literal> (or <literal>-I</literal>), which displays the headers of this Debian package.
			</para>
			 <example>
				<title><command>dpkg</command>的各种查询</title>
				 
<screen role="scale" width="80">
<computeroutput>$ </computeroutput><userinput>dpkg -L base-passwd</userinput>
<computeroutput>/.
/usr
/usr/sbin
/usr/sbin/update-passwd
/usr/share
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/base-passwd
/usr/share/doc-base
/usr/share/doc-base/users-and-groups
/usr/share/base-passwd
/usr/share/base-passwd/group.master
/usr/share/base-passwd/passwd.master
/usr/share/man
/usr/share/man/pl
/usr/share/man/pl/man8
/usr/share/man/pl/man8/update-passwd.8.gz
/usr/share/man/ru
/usr/share/man/ru/man8
/usr/share/man/ru/man8/update-passwd.8.gz
/usr/share/man/ja
/usr/share/man/ja/man8
/usr/share/man/ja/man8/update-passwd.8.gz
/usr/share/man/fr
/usr/share/man/fr/man8
/usr/share/man/fr/man8/update-passwd.8.gz
/usr/share/man/es
/usr/share/man/es/man8
/usr/share/man/es/man8/update-passwd.8.gz
/usr/share/man/de
/usr/share/man/de/man8
/usr/share/man/de/man8/update-passwd.8.gz
/usr/share/man/man8
/usr/share/man/man8/update-passwd.8.gz
/usr/share/doc
/usr/share/doc/base-passwd
/usr/share/doc/base-passwd/users-and-groups.txt.gz
/usr/share/doc/base-passwd/changelog.gz
/usr/share/doc/base-passwd/copyright
/usr/share/doc/base-passwd/README
/usr/share/doc/base-passwd/users-and-groups.html
$ </computeroutput><userinput>dpkg -S /bin/date</userinput>
<computeroutput>coreutils: /bin/date
$ </computeroutput><userinput>dpkg -s coreutils</userinput>
<computeroutput>Package: coreutils
Essential: yes
Status: install ok installed
Priority: required
Section: utils
Installed-Size: 13855
Maintainer: Michael Stone &lt;mstone@debian.org&gt;
Architecture: amd64
Multi-Arch: foreign
Version: 8.23-3
Replaces: mktemp, realpath, timeout
Pre-Depends: libacl1 (&gt;= 2.2.51-8), libattr1 (&gt;= 1:2.4.46-8), libc6 (&gt;= 2.17), libselinux1 (&gt;= 2.1.13)
Conflicts: timeout
Description: GNU core utilities
 This package contains the basic file, shell and text manipulation
 utilities which are expected to exist on every operating system.
 .
 Specifically, this package includes:
 arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp
 csplit cut date dd df dir dircolors dirname du echo env expand expr
 factor false flock fmt fold groups head hostid id install join link ln
 logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt
 od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm
 rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac
 tail tee test timeout touch tr true truncate tsort tty uname unexpand
 uniq unlink users vdir wc who whoami yes
Homepage: http://gnu.org/software/coreutils
$ </computeroutput><userinput>dpkg -l 'b*'</userinput>
<computeroutput>Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                    Version          Architecture     Description
+++-=======================-================-================-====================================================
un  backupninja             &lt;none&gt;           &lt;none&gt;           (no description available)
ii  backuppc                3.3.0-2          amd64            high-performance, enterprise-grade system for backin
un  base                    &lt;none&gt;           &lt;none&gt;           (no description available)
un  base-config             &lt;none&gt;           &lt;none&gt;           (no description available)
ii  base-files              8                amd64            Debian base system miscellaneous files
ii  base-passwd             3.5.37           amd64            Debian base system master password and group files
[...]
$ </computeroutput><userinput>dpkg -c /var/cache/apt/archives/gnupg_1.4.18-6_amd64.deb</userinput>
<computeroutput>drwxr-xr-x root/root         0 2014-12-04 23:03 ./
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/udev/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/udev/rules.d/
-rw-r--r-- root/root      2711 2014-12-04 23:03 ./lib/udev/rules.d/60-gnupg.rules
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/lib/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/lib/gnupg/
-rwxr-xr-x root/root     39328 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_ldap
-rwxr-xr-x root/root     92872 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_hkp
-rwxr-xr-x root/root     47576 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_finger
-rwxr-xr-x root/root     84648 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_curl
-rwxr-xr-x root/root      3499 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_mailto
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/bin/
-rwxr-xr-x root/root     60128 2014-12-04 23:03 ./usr/bin/gpgsplit
-rwxr-xr-x root/root   1012688 2014-12-04 23:03 ./usr/bin/gpg
[...]
$ </computeroutput><userinput>dpkg -I /var/cache/apt/archives/gnupg_1.4.18-6_amd64.deb</userinput>
<computeroutput> new debian package, version 2.0.
 size 1148362 bytes: control archive=3422 bytes.
    1264 bytes,    26 lines      control              
    4521 bytes,    65 lines      md5sums              
     479 bytes,    13 lines   *  postinst             #!/bin/sh
     473 bytes,    13 lines   *  preinst              #!/bin/sh
 Package: gnupg
 Version: 1.4.18-6
 Architecture: amd64
 Maintainer: Debian GnuPG-Maintainers &lt;pkg-gnupg-maint@lists.alioth.debian.org&gt;
 Installed-Size: 4888
 Depends: gpgv, libbz2-1.0, libc6 (&gt;= 2.15), libreadline6 (&gt;= 6.0), libusb-0.1-4 (&gt;= 2:0.1.12), zlib1g (&gt;= 1:1.1.4)
 Recommends: gnupg-curl, libldap-2.4-2 (&gt;= 2.4.7)
 Suggests: gnupg-doc, libpcsclite1, parcimonie, xloadimage | imagemagick | eog
 Section: utils
 Priority: important
 Multi-Arch: foreign
 Homepage: http://www.gnupg.org
 Description: GNU privacy guard - a free PGP replacement
  GnuPG is GNU's tool for secure communication and data storage.
  It can be used to encrypt data and to create digital signatures.
  It includes an advanced key management facility and is compliant
  with the proposed OpenPGP Internet standard as described in RFC 4880.
[...]</computeroutput></screen>

			</example>
			 <sidebar> <title><emphasis>更进一步</emphasis> 版本的对比</title>
			 <indexterm>
				<primary>版本，对比</primary>
			</indexterm>
			 <indexterm>
				<primary>对比版本</primary>
			</indexterm>
			 <para>
				Since <command>dpkg</command> is the program for handling Debian packages, it also provides the reference implementation of the logic of comparing version numbers. This is why it has a <literal>--compare-versions</literal> option, usable by external programs (especially configuration scripts executed by <command>dpkg</command> itself). This option requires three parameters: a version number, a comparison operator, and a second version number. The different possible operators are <literal>lt</literal> (strictly less than), <literal>le</literal> (less than or equal to), <literal>eq</literal> (equal), <literal>ne</literal> (not equal), <literal>ge</literal> (greater than or equal to), and <literal>gt</literal> (strictly greater than). If the comparison is correct, <command>dpkg</command> returns 0 (success); if not, it gives a non-zero return value (indicating failure).
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>dpkg --compare-versions 1.2-3 gt 1.1-4</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>0
$ </computeroutput><userinput>dpkg --compare-versions 1.2-3 lt 1.1-4</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>1
$ </computeroutput><userinput>dpkg --compare-versions 2.6.0pre3-1 lt 2.6.0-1</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>1</computeroutput></screen>
			 <para>
				Note the unexpected failure of the last comparison: for <command>dpkg</command>, <literal>pre</literal>, usually denoting a pre-release, has no particular meaning, and this program compares the alphabetic characters in the same way as the numbers (a &lt; b &lt; c ...), in alphabetical order. This is why it considers “<literal>0pre3</literal>” to be greater than “<literal>0</literal>”. When we want a package's version number to indicate that it is a pre-release, we use the tilde character, “<literal>~</literal>”:
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>dpkg --compare-versions 2.6.0~pre3-1 lt 2.6.0-1</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>0</computeroutput></screen>
			 </sidebar>
		</section>
		 <section>
			<title><command>dpkg</command>的日志文件</title>
			 <para>
				<command>dpkg</command> keeps a log of all of its actions in <filename>/var/log/dpkg.log</filename>. This log is extremely verbose, since it details every one of the stages through which packages handled by <command>dpkg</command> go. In addition to offering a way to track dpkg's behavior, it helps, above all, to keep a history of the development of the system: one can find the exact moment when each package has been installed or updated, and this information can be extremely useful in understanding a recent change in behavior. Additionally, all versions being recorded, it is easy to cross-check the information with the <filename>changelog.Debian.gz</filename> for packages in question, or even with online bug reports.
			</para>

		</section>
		 <section id="sect.multi-arch">
			<title>多架构支持</title>
			 <indexterm>
				<primary>多架构</primary>
			</indexterm>
			 <indexterm>
				<primary>架构</primary>
				<secondary>多架构支持</secondary>
			</indexterm>
			 <para>
				所有的 Debian 包在它们的管控信息中都有一个<literal>架构</literal> 字段。该字段可包含：“<literal>全部</literal>“（对与架构无关的包），或者它的目标架构名称（如“amd64”， “armhf”，…）。对于后者，默认情况下，<command>dpkg</command>将只能接受安装与主机架构匹配的软件包，主机架构可通过<command>dpkg --print-architecture</command>来获得。
			</para>
			 <para>
				该限制确保用户不会因为错误架构编译的二进制文件而挂掉。一切都很完美，除了（某些）计算机可以运行多架构的二进制文件，或者以本地方式（“amd64“系统可运行”i386“二进制文件）运行，或者以模拟器运行。
			</para>
			 <section>
				<title>启用多架构</title>
				 <para>
					<command>dpkg</command>'的多架构支持允许用户定义可安装于当前系统的“异质架构” 。这可以方便的通过 <command>dpkg --add-architecture</command>完成，如下例。有一相应的 <command>dpkg --remove-architecture</command> 以放弃对异质架构的支持，但仅可用于未余留该架构软件包的情况。
				</para>
				 
<screen>
<computeroutput># </computeroutput><userinput>dpkg --print-architecture</userinput>
<computeroutput>amd64
# </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput># </computeroutput><userinput>dpkg -i gcc-4.9-base_4.9.1-19_armhf.deb</userinput>
<computeroutput>dpkg: error processing archive gcc-4.9-base_4.9.1-19_armhf.deb (--install):
 package architecture (armhf) does not match system (amd64)
Errors were encountered while processing:
 gcc-4.9-base_4.9.1-19_armhf.deb
# </computeroutput><userinput>dpkg --add-architecture armhf</userinput>
<computeroutput># </computeroutput><userinput>dpkg --add-architecture armel</userinput>
<computeroutput># </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput>armhf
armel
# </computeroutput><userinput>dpkg -i gcc-4.9-base_4.9.1-19_armhf.deb</userinput>
<computeroutput>Selecting previously unselected package gcc-4.9-base:armhf.
(Reading database ... 86425 files and directories currently installed.)
Preparing to unpack gcc-4.9-base_4.9.1-19_armhf.deb ...
Unpacking gcc-4.9-base:armhf (4.9.1-19) ...
Setting up gcc-4.9-base:armhf (4.9.1-19) ...
# </computeroutput><userinput>dpkg --remove-architecture armhf</userinput>
<computeroutput>dpkg: error: cannot remove architecture 'armhf' currently in use by the database
# </computeroutput><userinput>dpkg --remove-architecture armel</userinput>
<computeroutput># </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput>armhf</computeroutput></screen>
				 <sidebar> <title><emphasis>备注</emphasis> APT 的多架构支持</title>
				 <para>
					当 dpkg 已配置为支持异质架构时，APT将会自动检测，并在更新过程中开始下载相应的<filename>软件包</filename>文件。
				</para>
				 <para>
					异质软件包可通过 <command>apt install <replaceable>软件包</replaceable>: <replaceable>架构</replaceable></command>安装。
				</para>
				 </sidebar> <sidebar> <title><emphasis>实例</emphasis> 在 amd64 架构上使用专有 i386 二进制文件</title>
				 <para>
					对于多架构，有多种使用案例，但最常见的是在 64 位系统（amd64）上执行 32 位二进制文件（i386）的可能性，特别是因为一些流行的专有应用（如 Skype）仅提供 32 位版本。
				</para>
				 </sidebar>
			</section>
			 <section>
				<title>多架构相关的变更</title>
				 <para>
					要让多架构真正实用和可用，库文件需要重新打包，并移动到一个用于特定架构的文件夹以便可以并存安装多重副本（针对不同架构）。这样的更新包中包含“<literal>Multi-Arch: same</literal>“头字段，以告诉打包系统此软件包的不同架构可以安全地并存安装（而且这些包仅能满足同架构软件包的依赖）。由于多架构在 Debian <emphasis role="distribution">Wheezy</emphasis> 中为初次引入，因而尚未完成所有库文件的转换。
				</para>
				 
<screen><computeroutput>$ </computeroutput><userinput>dpkg -s gcc-4.9-base
</userinput><computeroutput>dpkg-query: error: --status needs a valid package name but 'gcc-4.9-base' is not: ambiguous package name 'gcc-4.9-base' with more than one installed instance

Use --help for help about querying packages.
$ </computeroutput><userinput>dpkg -s gcc-4.9-base:amd64 gcc-4.9-base:armhf | grep ^Multi
</userinput><computeroutput>Multi-Arch: same
Multi-Arch: same
$ </computeroutput><userinput>dpkg -L libgcc1:amd64 |grep .so
</userinput><computeroutput>/lib/x86_64-linux-gnu/libgcc_s.so.1
$ </computeroutput><userinput>dpkg -S /usr/share/doc/gcc-4.9-base/copyright
</userinput><computeroutput>gcc-4.9-base:amd64, gcc-4.9-base:armhf: /usr/share/doc/gcc-4.9-base/copyright
</computeroutput></screen>
				 <para>
					值得注意的是，<literal>Multi-Arch: same</literal>软件包需具备能够明晰识别架构的名称。它们也能够与相同包的其他实例共享文件；<command>dpkg</command>确保所有的包在共享时具有逐位对应识别的文件。最后但并非最不重要的，一个包的所有实例必须为相同版本。它们必须同时升级。
				</para>
				 <para>
					多架构支持也带来了在依赖处理方式上的一些有趣的挑战。要满足依赖，需要：或者有<literal>Multi-Arch: foreign</literal>标识的软件包，或者架构上能匹配已声明依赖的软件包（在该依赖方案处理中，架构无关包假定为同样架构，而非主机架构）。通过<literal><replaceable> 软件包</replaceable> :any</literal>语法，依赖可以被弱化，以便允许任意架构能够满足依赖，但异质软件包仅能满足如下依赖：有“<literal> Multi-Arch: allowed</literal> ”标识的依赖。
				</para>

			</section>

		</section>

	</section>
	 <section id="sect.coexistence-with-other-packaging-systems">
		<title>与其它软件包共存</title>
		 <indexterm>
			<primary>RPM</primary>
		</indexterm>
		 <indexterm>
			<primary>红帽的软件包管理</primary>
		</indexterm>
		 <indexterm>
			<primary><command>alien</command></primary>
		</indexterm>
		 <para>
			Debian 包格式并非唯一用于自由软件领域的软件包格式。主要竞争者是红帽 Linux 发行版的 RPM 格式以及其衍生格式。红帽是一个非常流行的商业化发行版。对于来自第三方的软件，常以 RPM 格式软件包提供，而非 Debian 格式。
		</para>
		 <para>
			这个情况下，你应该知道<command>rpm</command>程序是如何处理RPM软件包的，这种格式在Debian软件包中也可用。需要谨慎的使用，尽管如何，这些操作会限制从一个软件包中解压并且提取出信息以验证其完整性。实际上，不应该在Debian系统中使用<command>rpm</command>来安装一个RPM软件包；RPM使用了它自己的数据库以便和Debian的软件中分离（比如<command>dpkg</command>）。这也就是为什么不可能确保两个包管理系统共存在一个系统中，而这个系统还能保持稳定。
		</para>
		 <para>
			另一方面，<emphasis role="pkg">alien</emphasis> 可以把RPM软件包转换成Debian软件包，反之亦然。
		</para>
		 <sidebar> <title><emphasis>社区</emphasis> 鼓励<filename>.deb</filename>的使用</title>
		 <para>
			If you regularly use the <command>alien</command> program to install RPM packages coming from one of your providers, do not hesitate to write to them and amicably express your strong preference for the <filename>.deb</filename> format. Note that the format of the package is not everything: a <filename>.deb</filename> package built with <command>alien</command> or prepared for a version of Debian different than that which you use, or even for a derivative distribution like Ubuntu, would probably not offer the same level of quality and integration as a package specifically developed for Debian <emphasis role="distribution">Jessie</emphasis>.
		</para>
		 </sidebar> 
<screen>
<computeroutput>$ </computeroutput><userinput>fakeroot alien --to-deb phpMyAdmin-2.0.5-2.noarch.rpm</userinput> 
<computeroutput>phpmyadmin_2.0.5-2_all.deb generated
$ </computeroutput><userinput>ls -s phpmyadmin_2.0.5-2_all.deb</userinput>
<computeroutput>  64 phpmyadmin_2.0.5-2_all.deb</computeroutput></screen>
		 <para>
			You will find that this process is extremely simple. You must know, however, that the package generated does not have any dependency information, since the dependencies in the two packaging formats don't have systematic correspondence. The administrator must thus manually ensure that the converted package will function correctly, and this is why Debian packages thus generated should be avoided as much as possible. Fortunately, Debian has the largest collection of software packages of all distributions, and it is likely that whatever you seek is already in there.
		</para>
		 <para>
			翻看<command>alien</command>命令的帮助页面，您会注意到该程序也可处理其他的包格式，特别是使用 Slackware 发行版所用的格式（它使用简单的<filename>tar.gz</filename>归档格式）。
		</para>
		 <para>
			<command>dpkg</command>作为一个稳定的工具有助于提高Debian的名字。APT套件工具，在下面的章节中会告诉我们，它不但保留了这一优势，同时减轻了管理员管理软件包这一必须但是艰难得任务的负担。
		</para>

	</section>
</chapter>

