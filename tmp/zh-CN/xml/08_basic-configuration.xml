<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="basic-configuration" lang="zh-CN">
	<chapterinfo>
		 <keywordset>
			<keyword>配置</keyword>
			 <keyword>本地化</keyword>
			 <keyword>地区设置</keyword>
			 <keyword>网络</keyword>
			 <keyword>名称解析</keyword>
			 <keyword>用户</keyword>
			 <keyword>用户组</keyword>
			 <keyword>账户</keyword>
			 <keyword>命令行解释器</keyword>
			 <keyword>Shell</keyword>
			 <keyword>打印</keyword>
			 <keyword>Bootloader</keyword>
			 <keyword>内核编译</keyword>

		</keywordset>

	</chapterinfo>
	 <title>基础配置：网络，账户，打印……</title>
	 <highlights> <para>
		以 <command>debian-installer</command> 命令安装的电脑是尽可能的可用，但仍有若干服务需要配置。而且，了解修改初始安装进程的配置是件好事。
	</para>
	 </highlights> <para>
		这章综述我们称之为“基础配置”所包括的任何事项：网络、语言、地区、用户、用户组、打印、挂载点等。
	</para>
	 <section id="sect.config-language-support">
		<title>用其他语言进行配置</title>
		 <indexterm>
			<primary>法语环境</primary>
		</indexterm>
		 <para>
			如果你在法语环境下安装了系统，那么默认语言可能会被设置为法语。所以你最好知道你的安装器使用的是什么语言。如果对语言有要求而又设置错误了，你可以自己进行修改。
		</para>
		 <sidebar> <title><emphasis>工具</emphasis> <command>locale</command> 命令显示当前配置</title>
		 <para>
			<command>locale</command> 命令行出地区设置参数的当前语系配置 (日期格式、数字格式等)，以一组标准的环境变量表示这些设置的动态修改。
		</para>
		 </sidebar> <section id="sect.default-language">
			<title>设置默认语言</title>
			 <indexterm>
				<primary>地区</primary>
			</indexterm>
			 <indexterm>
				<primary>语言</primary>
			</indexterm>
			 <indexterm>
				<primary><command>locale-gen</command></primary>
			</indexterm>
			 <para>
				一个 locale 指一系列的区域设置。它不仅包括对文字语言的设置，也包括数字格式显示、日期、时间和货币，以及“按字母顺序排列规则”（正确地处理重音字符）。虽然这些参数可以被独立配置，我们仍建议您使用 locale 这个从地区形式最大化匹配一连贯参数的工具。这些 locales 一般以以下格式 <literal><replaceable>语言代码</replaceable>_<replaceable>城市代码</replaceable></literal>，有时后缀也在指定字符集和编码中被使用。这是考虑到同一语言在不同区域之间使用习惯和印刷差异。
			</para>
			 <sidebar> <title><emphasis>文化</emphasis> 字符集</title>
			 <indexterm>
				<primary>字符设置</primary>
			</indexterm>
			 <indexterm>
				<primary>编码</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-1</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-15</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 1</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 9</primary>
			</indexterm>
			 <para>
				过去，每个地区都对应一组 “字符集” (已知字符的集合) 与偏好的 “编码” (电脑内表示字符的方法)。
			</para>
			 <para>
				最广泛使用的字符编码是基于拉丁字母、使用单个 byte 表达一个字符，被限制为最多256个字符。256个字符不足以覆盖所有欧洲语言，因此多编码系统非常有必要，这就是为何我们将 <emphasis>ISO-8859-1</emphasis> （即“Latin 1”）升级为 <emphasis>ISO-8859-15</emphasis> （即“Latin 9”），等等。
			</para>
			 <para>
				在英文以外的语系工作，经常需要切换编码与字符集。尤有甚者，撰写多语系文档还会碰到极为顽固的问题。Unicode (几乎包括全世界所有书写系统的编码) 就是用来解决此等问题。UTF-8 是 Unicode 的编码之一，仍是 128 ASCII 符号 (7-比特代码)，但以不同方式处理其他字符。以逸出字符为首的数个比特带头，设置字符的长度。此种方法允许 Unicode 字符以一个或多个字节呈现。已是 XML 文档的缺省编码方式。
			</para>
			 <indexterm>
				<primary>ASCII</primary>
			</indexterm>
			 <indexterm>
				<primary>UTF-8</primary>
			</indexterm>
			 <indexterm>
				<primary>Unicode</primary>
			</indexterm>
			 <para>
				它是最广泛使用的编码，也是 Debian 发行版系统的默认选项。
			</para>
			 </sidebar> <para>
				<emphasis role="pkg">locales</emphasis> 包括所有应用“本土化”所需要的所有元素。安装过程中，该包将要求使用者选择一系列支持语言。该选择能在使用root帐号运行 <command>dpkg-reconfigure locales</command> 改变。
			</para>
			 <para>
				第一个让您回答的问题是选哪些“ locales ”来支持。选择所有英语国家（所有以<literal>en_</literal>开始的环境）是一种可能。如果主机上有外国用户，打开对应的语言环境支持不要犹豫。所有在本系统被打开支持的语言环境存储在 <filename>/etc/locale.gen</filename> 。它可以被手动编辑，但需要在你做任何改动后运行 <command>locale-gen</command> 使改动生效。该命令将创建新添加的语言环境及其关联文件并移除过期的文件。
			</para>
			 <para>
				第二个问题，标题 “系统环境的默认字符环境”请求设置默认的字符系统。该选择在美国是 <literal>en_US.UTF-8</literal>，英式发音者更习惯于 <literal>en_GB.UTF-8</literal> ，加拿大人喜欢 <literal>en_CA.UTF-8</literal> 或者对于法国人来说 <literal>fr_CA.UTF-8</literal>。<filename>/etc/default/locale</filename> 文件会保存这个变更。该设置将由 PAM 系统写入到所有登录用户会话的 <varname>LANG</varname> 环境变量。
			</para>
			 <indexterm>
				<primary>环境</primary>
			</indexterm>
			 <indexterm>
				<primary>locale</primary>
			</indexterm>
			 <indexterm>
				<primary><varname>LANG</varname></primary>
			</indexterm>
			 <sidebar id="sidebar.intro-pam"> <title><emphasis>后台</emphasis> <filename>/etc/environment</filename> 与 <filename>/etc/default/locale</filename></title>
			 <para>
				<filename>/etc/environment</filename> 文件为 <command>login</command> 、 <command>gdm</command>、 <command>ssh</command> 程序提供正确的环境变量。
			</para>
			 <para>
				90这些应用不直接创建这些变量，而通过 PAM 系统的 <filename>pam_env.so</filename> 模块。PAM（插入式验证模块）是一个提供身份验证、会话初始化和密码管理的模块库。<xref linkend="sect.config-pam" /> 是一个 PAM 配置样式。
			</para>
			 <para>
				<filename>/etc/default/locale</filename> 文件以类似的方式运作，但只有 <varname>LANG</varname> 环境变量。感谢此种区隔，某些 PAM 用户可以在地区设置之外承袭完整的环境。事实上，不鼓励在服务器软件运行地区设置；比较建议在用户端的程序设置地区及区域。
			</para>
			 <indexterm>
				<primary>PAM</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>pam_env.so</filename></primary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.keyboard-config">
			<title>键盘配置</title>
			 <indexterm>
				<primary>键盘布局</primary>
			</indexterm>
			 <indexterm>
				<primary> 布局，键盘</primary>
			</indexterm>
			 <para>
				甚至如果键盘布局在终端和图形模式中被设置成不同， Debian 也提供了一个简单的配置让它们两个工作：它基于 debconf 并由<emphasis role="pkg">keyboard-configuration</emphasis> 包实现。使用 <command>dpkg-reconfigure keyboard-configuration</command> 命令来重新设置键盘布局。
			</para>
			 <indexterm>
				<primary><emphasis>console-data</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>console-tools</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>键盘配置</emphasis></primary>
			</indexterm>
			 <para>
				<indexterm><primary><literal>azerty</literal></primary></indexterm>问题与键盘的实体配置 (美式标准键盘为 “通用 104 键”)有关，选择配置 (通常是 “US”)，然后选取 AltGr键 (即右侧的 Alt 键)。最后是 “组合键”，以多个键同时按下组合成特殊字符。连续键入 <keycombo action="seq"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> 就能产生带读音符号的 e (“é”)。这些组合键列在 <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> 文件 (或其他文件，视 <filename>/usr/share/X11/locale/compose.dir</filename> 指示的当前在地设置)。
			</para>
			 <indexterm>
				<primary><literal>Compose</literal> 键</primary>
			</indexterm>
			 <indexterm>
				<primary><literal> Meta </literal>键</primary>
			</indexterm>
			 <indexterm>
				<primary>key</primary>
				<secondary><literal>Meta</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary>key</primary>
				<secondary><literal>Compose</literal></secondary>
			</indexterm>
			 <para>
				注意，该处说明的是默认键盘布局下图形模式的键盘设定； GNOME 和 KDE 等环境，为每一个用户提供一个键位控制面板去设置他们的喜好键位。面板中也能提供一些特殊键位的扩展选项。
			</para>

		</section>
		 <section id="sect.utf8-migration">
			<title>迁移到 UTF-8</title>
			 <para>
				期待已久的 UTF-8 一般化编码是解决互通性的方案之一，可解决文档中字符的国际交换与误值的限制。其中一个限制是必须经由相当困难的转换阶段。它可以完全透通 (就是，不会同时在全世界发生)，需要两个转换作业：文件内容，以及文件名称。幸运的是，该等移殖已经完成且讨论甚多。
			</para>
			 <sidebar> <title><emphasis>文化</emphasis><foreignphrase> 乱码</foreignphrase>以及谬误</title>
			 <para>
				当一个文本发送（或者接收）但是却没有携带编码信息，接收者并不是常常能确切地知道如何去确定一组字节的含义。你通常能通过对文本进行统计获得一些帮助，但是并不是总得到一个确切的答案。当编码系统选择了不同于写入文件时使用的编码时，字节就被曲解了，当你获取它时，最好的结果是一些字符错了，最坏的结果，一些变得完全无法识别了。
			</para>
			 <para>
				因此，法文的内容看起来正常，祗是无法显示 “Ã©” 或 Ã¨” 或 “Ã§” 等重音字母与符号，很可能以 UTF-8 编码保存但被解读成 ISO-8859-1 或 ISO-8859-15。在地的安装尚未移殖至 UTF-8。如果，看到问号取代重音字母 — 即使这些问号取代重音字母后的字符 — 很可能已安装并配置为 UTF-8 不过送出的文档仍以 Western ISO 编码。
			</para>
			 <para>
				这些都是 “简单的” 个案。这些个案祗出现在西方文化里，因为 Unicode (与 UTF-8) 是扩充拉丁字母为基础的西方语系编码，即使失漏部份字符仍可辨识其他内容。
			</para>
			 <para>
				在较复杂的环境里，诸如，使用不同字母的两种语文，通常得到完全不同的结果 — 彼此完全无意义的抽象符号。特别是语言与文本完全不同的亚洲语文。日文的 <foreignphrase>mojibake</foreignphrase>，即乱码，用来说明此现象。出现时，诊断极为困难，最简单的方法就是两端都移殖至 UTF-8。
			</para>
			 </sidebar> <para>
				转换文件名编码，移殖工作还算简单。<command>convmv</command> 工具 (以同名存在套件内) 是专门移殖用的；可以把文件名重命名于不同的编码。此工具还很简单，但需要两个步骤。下例说明在 UTF-8 环境下采用 ISO-8859-15 编码的文件夹，以 <command>convmv</command> 重命名。
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Ic?nes  ?l?ments graphiques  Textes
$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>Starting a dry run without changes...
mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
No changes to your files done. Use --notest to finally rename the files.
$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
Ready!
$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput></screen>
			 <para>
				以文件内容来说，因为文件格式的多样性，增加转换工作的复杂度。有些文件格式本身包括编码信息协助软件使用它们；就可以直接打开它们，并指明以 UTF-8 编码再保存之。其他的情况下，则必须以原始的编码格式 (ISO-8859-1 或 “Western”、或 ISO-8859-15 或 “Western (Euro)”，视其规则而定) 开启它们。
			</para>
			 <para>
				简单的文本档，可以使用 <command>recode</command> (以同名存在于套件中) 自动重新编码。此工具有很多选项。建议参加相关的文档， <citerefentry> <refentrytitle>recode</refentrytitle>
				 <manvolnum>1</manvolnum> </citerefentry> man 页面，或 <citerefentry> <refentrytitle>recode</refentrytitle>
				 </citerefentry> info 页面 (较为完整)。
			</para>

		</section>

	</section>
	 <section id="sect.network-config">
		<title>配置网络</title>
		 <sidebar id="sidebar.networking-basics"> <title><emphasis>基本知识</emphasis>必要的网络概念（以太网、IP地址、子网、广播）</title>
		 <indexterm>
			<primary>以太网</primary>
		</indexterm>
		 <indexterm>
			<primary>10BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>100BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>1000BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>10GBASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>链接器，RJ45</primary>
		</indexterm>
		 <indexterm>
			<primary>RJ45 连接器</primary>
		</indexterm>
		 <para>
			当代的网络多半使用 Ethernet 协定，数据分为小小的区块称为框并且一次发送一个框。发送的速度从旧型 Ethernet 卡的 10 Mb/s 至最新卡的 10 Gb/s (最常见的速度为 100 Mb/s 至 1 Gb/s)。最常见的缆线是 10BASE-T、100BASE-T、1000BASE-T 或 10GBASE-T，视需求而定 (T 是双绞线英文名称的第一个字母 “twisted pair”)；这些缆线以 RJ45 链接器相接。当然还有其他类型的缆线，通常供速度超过 1 Gb/s 以上的环境使用。
		</para>
		 <indexterm>
			<primary>地址，IP 地址</primary>
		</indexterm>
		 <indexterm>
			<primary>IP 地址</primary>
		</indexterm>
		 <para>
			IP 地址是一组数字用于辨识电脑在地区网络或互联网的接口。最常用的是 IP 版本是 (IPv4)，此组数字由 32 比特编成，通常以句点区隔的 4 个数字表示 (如 <literal>192.168.0.1</literal>)，使用 0 至 255 之间的数字 (含在内，对应于 8 比特的数据)。通信协定的下个版本是 IPv6，采用 128 比特表示一个地址，其地址以 16 进位表示，用冒号区隔 (如，2001:0db8:13bb:0002:0000:0000:0000:0020，或 2001:db8:13bb:2::20 简版表示)。
		</para>
		 <indexterm>
			<primary>次网络</primary>
		</indexterm>
		 <indexterm>
			<primary>遮罩</primary>
			<secondary>次网络遮罩</secondary>
		</indexterm>
		 <indexterm>
			<primary>网络</primary>
			<secondary>地址</secondary>
		</indexterm>
		 <para>
			次网络遮罩 (网络遮罩) 设置对应于网络的 IP 地址二进位代码，其余的则有机器指定。在前述的固定 IPv4 地址中，次网络遮罩，<literal>255.255.255.0</literal> (以 2 进位表示，就是 24 个 “1” 之后接着 8 个 “0”) 表示 IP 地址前 24 比特对应至网络地址，且其余 8 个则指向机器。在 IPv6 里，为了方便阅读，祗表示数字 “1”；IPv6 网络的网络遮罩可以是 <literal>64</literal>。
		</para>
		 <para>
			网络地址是一个 IP 地址，描述机器的号码是 0。IPv4 地址的范围是完成的网络以此语法表示，<emphasis>a.b.c.d/e</emphasis>，<emphasis>a.b.c.d</emphasis> 是网络地址，而 <emphasis>e</emphasis> 是被影响的比特数。因此，此网络可写成：<literal>192.168.0.0/24</literal>。在 IPv6 的类似语法为：<literal>2001:db8:13bb:2::/64</literal>。
		</para>
		 <indexterm>
			<primary>路由器</primary>
		</indexterm>
		 <indexterm>
			<primary>桥接器</primary>
		</indexterm>
		 <para>
			路由器用于链接多个网络。进入路由器的信息被引导至正确的网络。所以，路由器分析进来的封包，根据其目的地址转送至其他地方。路由器通常称为网关；协助进入在地网络以外的地方 (互联网之类的外部网络)。
		</para>
		 <indexterm>
			<primary>广播</primary>
		</indexterm>
		 <para>
			特定的广播地址链接网络内所有的站台。几乎不曾 “发送”，祗在网络内发送问题。就是说，经由广播发送的数据封包不会通常路由器。
		</para>
		 <para>
			本章祗讨论 IPv4 地址，现在最常见的。IPv6 协定的详情在 <xref linkend="sect.ipv6" />，其概念是一样的。
		</para>
		 </sidebar> <para>
			初始安装时会自动配置网络，<filename>/etc/network/interfaces</filename> 文件内已有完备的配置。以 <literal>auto</literal> 起头的数据在开机时自动被 <emphasis role="pkg">ifupdown</emphasis> 配置，且配置它的 <filename>/etc/init.d/networking</filename> init 脚本。通常是 <literal>eth0</literal>，指向第一个 Ethernet 网卡。
		</para>
		 <indexterm>
			<primary>网络</primary>
			<secondary>配置</secondary>
		</indexterm>
		 <indexterm>
			<primary>配置</primary>
			<secondary>网络</secondary>
		</indexterm>
		 <indexterm>
			<primary>接口</primary>
			<secondary>网络接口</secondary>
		</indexterm>
		 <indexterm>
			<primary><literal>eth0</literal></primary>
		</indexterm>
		 <sidebar> <title><emphasis>其他</emphasis> NetworkManager</title>
		 <indexterm>
			<primary><emphasis role="pkg">网络管理器</emphasis></primary>
		</indexterm>
		 <para>
			漫游设置推荐使用的网络管理器 (见 <xref linkend="sect.roaming-network-config" />)，同样适用于缺省的网络管理工具。启动电脑时以人工启用 <filename>.ini</filename> 之类的文件在 <filename>/etc/NetworkManager/system-connections/</filename> 之内或经由图形工具 (<command>nm-connection-editor</command>)，可以同时添加 “系统链接”。想要网络管理器处理它们时，记得关闭 <filename>/etc/network/interfaces</filename> 内的所有条目。<ulink type="block" url="https://wiki.gnome.org/Projects/NetworkManager/SystemSettings/jessie" /> <ulink type="block" url="https://developer.gnome.org/NetworkManager/0.9/ref-settings.html" />
		</para>
		 </sidebar> <section id="sect.interface-ethernet">
			<title>Ethernet 接口</title>
			 <para>
				电脑使用 Ethernet 网络卡时，必须以下列的方法之一配置 IP 网络。最简单的方式是以 DHCP 动态配置，需要在地网络的 DHCP 服务器。可以使用与下例 <literal>hostname</literal> 设置的主机名称。DHCP 服务器就会送出配置设置给适当的网络。
			</para>
			 <indexterm>
				<primary>以太网</primary>
			</indexterm>
			 <indexterm>
				<primary>DHCP</primary>
			</indexterm>
			 <example id="example.config-dhcp">
				<title>DHCP 配置</title>
				 
<programlisting>
auto eth0
iface eth0 inet dhcp
  hostname arrakis</programlisting>

			</example>
			 <para>
				“静态” 配置必须以固定方式指明网络设置。至少包括 IP 网址及次网络遮罩；有时也列出网络及广播地址。必须以闸道指出链接外部的路由器。
			</para>
			 <example id="example.static-network">
				<title>静态配置</title>
				 
<programlisting>
auto eth0
iface eth0 inet static
  address 192.168.0.3
  netmask 255.255.255.0
  broadcast 192.168.0.255
  network 192.168.0.0
  gateway 192.168.0.1</programlisting>

			</example>
			 <sidebar> <title><emphasis>说明</emphasis> 多地址</title>
			 <para>
				在一个实体网络卡上可以链接多个接口，而且可以设置多个 IP 地址。IP 地址本身可以经由 DNS 对应至多个网域名称，名称本身可以对应至多个 IP 地址。
			</para>
			 <para>
				如您所想，配置可以极为复杂，不过祗限于极为特殊的例子。此处引用的例子都是一般常见的配置。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.ppp-rtc">
			<title>经由 PSTN 调制解调器的 PPP 链接</title>
			 <indexterm>
				<primary>PPP</primary>
			</indexterm>
			 <indexterm>
				<primary>点对点</primary>
			</indexterm>
			 <indexterm>
				<primary>链接</primary>
				<secondary>经由 PSTN 调制解调器</secondary>
			</indexterm>
			 <indexterm>
				<primary>调制解调器</primary>
				<secondary>PSTN</secondary>
			</indexterm>
			 <para>
				点对点 (PPP) 链接创建断续的链接；这是电话调制解调器最常见的链接方式 (“PSTN 调制解调器”，经由公共交换电话网络)。
			</para>
			 <para>
				电话调制解调器需要帐号才能链接，包括电话号码、用户名、密码、以及认证协定。这种链接 Debian 同名套件内的使用 <command>pppconfig</command> 工具。缺省使用的名称是 <literal>提供者</literal> (做为互联网服务提供者)。对认证协定有疑义时，选择 <emphasis>PAP</emphasis>：大多数互联网服务提供者使用它。
			</para>
			 <indexterm>
				<primary><command>pppconfig</command></primary>
			</indexterm>
			 <indexterm>
				<primary>PAP</primary>
			</indexterm>
			 <para>
				配置之后，就可以使用 <command>pon</command> 命令 (<literal>提供者</literal> 的默认值不适用时，将链接的名称当成参数)。以 <command>poff</command> 命令断线。这两个令可以被根用户运行，或位在 <literal>dip</literal> 群组的其他用户。
			</para>
			 <indexterm>
				<primary><command>pon</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>poff</command></primary>
			</indexterm>

		</section>
		 <section id="sect.adsl">
			<title>以 ADSL 数据链接</title>
			 <indexterm>
				<primary>链接</primary>
				<secondary>经由 ADSL 调制解调器</secondary>
			</indexterm>
			 <indexterm>
				<primary>调制解调器</primary>
				<secondary>ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>ADSL，调制解调器</primary>
			</indexterm>
			 <para>
				“ADSL 调制解调器” 一辞包括不同功能的多种设备。使用 Linux 的调制解调器有 Ethernet 接口 (不祗是 USB 接口)。这是极为普遍的调制解调器；大部份的 ADSL 互联网服务商出借 (或出租) 一个含 Ethernet 接口的 “盒子”。视其类型而有不同的设置。
			</para>
			 <section id="sect.adsl-pppoe">
				<title>支持 PPPOE 的调制解调器</title>
				 <indexterm>
					<primary>PPPOE</primary>
				</indexterm>
				 <indexterm>
					<primary><command>pppoeconf</command></primary>
				</indexterm>
				 <para>
					部份 Ethernet 调制解调器使用 PPPOE 协定 (以太网上的对等协定，Point to Point Protocol over Ethernet)。<command>pppoeconf</command> 工具 (位于同名套件内) 将配置其链接。修改 <filename>/etc/ppp/peers/dsl-provider</filename> 文件内容时，采用 <filename>/etc/ppp/pap-secrets</filename> 与 <filename>/etc/ppp/chap-secrets</filename> 文件的内容。建议全盘接纳所有的提议。
				</para>
				 <para>
					配置完成之后，以命令 <command>pon dsl-provider</command> 开启 ADSL 链接，并以命令 <command>poff dsl-provider</command> 断线。
				</para>
				 <indexterm>
					<primary><literal>dsl-provider</literal></primary>
				</indexterm>
				 <sidebar> <title><emphasis>秘诀</emphasis>启动 <command>ppp</command> 于开机时</title>
				 <indexterm>
					<primary><command>systemd</command></primary>
				</indexterm>
				 <indexterm>
					<primary><command>init</command></primary>
				</indexterm>
				 <para>
					PPP 在 ADSL 上的链接，其本意是断断续续的。因为不是依照连接时间收费，所以不必随时打开它。标准的方法是使用 init 系统。
				</para>
				 <para>
					在 <emphasis role="distribution">Jessie</emphasis> 缺省的 init 系统是 <command>systemd</command>。在 ADSL 链接自动重新启动很简单，添加一个像 <filename>/etc/systemd/system/adsl-connection.service</filename> 之类的 “unit file” 就可以了，其内容类似以下的：
				</para>
				 
<programlisting>[Unit]
Description=ADSL connection

[Service]
Type=forking
ExecStart=/usr/sbin/pppd call dsl-provider
Restart=always

[Install]
WantedBy=multi-user.target</programlisting>
				 <para>
					设置这个 unit file 之后，还需以 <command>systemctl enable adsl-connection</command> 命令启动它。然后以手动方式，启动此命令 <command>systemctl start adsl-connection</command> 循环；然后就可在开机时自动启动。
				</para>
				 <para>
					未使用 <command>systemd</command> 命令的系统 (包括 <emphasis role="distribution">Wheezy</emphasis> 及更早的 Debian 版本)，可使用标准的 SystemV init。在这种系统里，祗需在 <filename>/etc/inittab</filename> 文件加入一行字；然后，在断线之后，运行 <command>init</command> 就可重新连接。
				</para>
				 
<programlisting>
adsl:2345:respawn:/usr/sbin/pppd call dsl-provider</programlisting>
				 <para>
					拨接后自动断线的 ADSL，这种方法减少中断的次数。
				</para>
				 </sidebar>
			</section>
			 <section id="sect.adsl-pptp">
				<title>支持 PPTP 的调制解调器</title>
				 <indexterm>
					<primary>PPTP</primary>
				</indexterm>
				 <para>
					PPTP (点对点隧道协议，Point-to-Point Tunneling Protocol) 协定由微软创制。在 ADSL 的初期就已布置，取代 PPPOE。若被强迫使用此协定，参见 <xref linkend="sect.pptp" />。
				</para>

			</section>
			 <section id="sect.adsl-dhcp">
				<title>支持 DHCP 调制解调器</title>
				 <para>
					以 Ethernet 缆线 (跳线) 连接电脑的调制解调器，可以在电脑以 DHCP 配置网络链接；调制解调器自动成为闸道且运行路由的功能 (就是管理电脑与互联网的流量)。
				</para>
				 <sidebar> <title><emphasis>基本</emphasis> 直接链接 Ethernet 的跳线</title>
				 <indexterm>
					<primary>跳线</primary>
				</indexterm>
				 <para>
					电脑网络卡经由特定缆线接收数据，也从同样的管道送出数据。电脑连上地区网络后，通常以缆线 (直接连接或跳线) 链接网络上与中继器或交换器。若想直接链接两部电脑 (不经过交换器或中继器)，必须经由网络卡送出数据至接收端的另个网络卡，反之亦然。这就是跳线的作用，以及使用它的原因。
				</para>
				 <para>
					此区别在现在的环境没有作用，现代的网络卡可以自动侦测缆线的类型并据以配合它，所以两种缆线都可运用自如。
				</para>
				 </sidebar> <para>
					大部份的 “ADSL 路由器” 也能这么做，互联网服务供应商提供的 ADSL 调制解调器也具有此功能。
				</para>

			</section>

		</section>
		 <section id="sect.roaming-network-config">
			<title>网络自动配置漫游用户</title>
			 <indexterm>
				<primary><emphasis role="pkg">网络管理器</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>网络</primary>
				<secondary>漫游配置</secondary>
			</indexterm>
			 <para>
				Falcot 公司的工程师拥有专业用的笔电，同时也在家里使用它。根据使用场所的不同，网络有不同的配置方式。在家里，可能使用 WiFi 网络 (以 WPA 钥保护)，在工作场合则使用较安全与带宽更充足的固接网络。
			</para>
			 <para>
				为了避免人工链接与断线对应的网络接口，管理者在漫游机器安装 <emphasis role="pkg">network-manager</emphasis> 套件。此软件可以让用户从图形桌面的小图标，在多个网络间切换。按下此图标即显示可用的网络 (固接与无线)，借以选择其中之一。此程序保存曾链接网络的配置，断线时自动选择最佳的网络。
			</para>
			 <para>
				为了达到这个目的，程序分为两个部份：在根部运行后台进程并配置网络接口与用户接口控制该后台进程。PolicyKit 处理必要的权限以控制此程序，然后由 Debian 配置 PolicyKit 让 netdev 群组成员可以添加或修改 Network Manager 的链接。
			</para>
			 <para>
				程序自身已配置后，网络管理器就能够处理多种类型的连接 (DHCP、手动配置、地区网络)。所以能够系统地忽略在 <filename>/etc/network/interfaces</filename> 里面不合适的网络接口。网络管理器无法提供未显示网络连接的详情，最简单的方法是删除 <filename>/etc/network/interfaces</filename> 内必须由网络管理器配置的所有接口。
			</para>
			 <para>
				在初始安装阶段选择 “桌面环境”的工作，就能够缺省安装此程序。
			</para>
			 <sidebar> <title><emphasis>其他</emphasis> 由“网络设置档”配置</title>
			 <indexterm>
				<primary><emphasis role="pkg">guessnet</emphasis></primary>
			</indexterm>
			 <para>
				更高端的用户可能布望试用 <emphasis role="pkg">guessnet</emphasis> 套件做为网络自动配置的工具。以一组测试脚本决定启用与配置的网络设置档。
			</para>
			 <para>
				以人工选定网络设置的用户，将偏向使用在同名套件内找到的 <emphasis role="pkg">netenv</emphasis> 程序。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.hostname-name-service">
		<title>设置主机名称与配置名称服务</title>
		 <indexterm>
			<primary>名称</primary>
			<secondary>属性与解析</secondary>
		</indexterm>
		 <indexterm>
			<primary>指定名称</primary>
		</indexterm>
		 <para>
			将 IP 数字转换为名称系方便记忆。实务上，IP 地址系用于辨识网络卡之类的网络接口设备。机器可能有多个网络卡，每个网络卡可能有多个接口，所以在网域名称系统里，一部电脑就可能有多个名称。
		</para>
		 <para>
			然而，每部机器都有个辨识用的主要 (如 “canonical”) 名称，保存在 <filename>/etc/hostname</filename> 文件内并以初始脚本经由 <command>hostname</command> 命令与 Linux 核心沟通。现在的值保存在虚拟文件系统，可经由 <command>cat /proc/sys/kernel/hostname</command> 命令取得。
		</para>
		 <indexterm>
			<primary><command>主机名称</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>基本</emphasis> <filename>/proc/</filename> 与 <filename>/sys/</filename>，虚拟文件系统</title>
		 <indexterm>
			<primary><filename>/proc/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>proc</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/sys/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>sys</filename></primary>
		</indexterm>
		 <para>
			<filename>/proc/</filename> 与 <filename>/sys/</filename> 文件树系由 “虚拟” 文件系统产生。从核心 (以列出虚拟文件方式) 取得信息并与其沟通 (写入虚拟文件) 的实务。
		</para>
		 <para>
			<filename>/sys/</filename> 系供近用内部核心对象之用，尤其是代表系统的各种设备。核心本身可以共享资源：每个设备的状态 (如，处于省电模式)、移动状置等。<filename>/sys/</filename> 祗存于于核心版本 2.6 及更新的版本。
		</para>
		 </sidebar> <para>
			意外的是，网域名称的管理方式不同，来自机器的完整名称，经由名称解析取得。可以在 <filename>/etc/hosts</filename> 文件内更改它；在名称清单前写入完整的名称，如下例：
		</para>
		 <informalexample> 
<programlisting>
127.0.0.1     localhost
192.168.0.1   arrakis.falcot.com arrakis</programlisting>
		 </informalexample> <indexterm>
			<primary><filename>hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/etc/hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary>domain</primary>
			<secondary>name</secondary>
		</indexterm>
		 <indexterm>
			<primary>name</primary>
			<secondary>domain</secondary>
		</indexterm>
		 <indexterm>
			<primary>NSS</primary>
		</indexterm>
		 <section id="sect.name-resolution">
			<title>Name Resolution</title>
			 <indexterm>
				<primary>resolution</primary>
				<secondary>name</secondary>
			</indexterm>
			 <indexterm>
				<primary>name</primary>
				<secondary>resolution</secondary>
			</indexterm>
			 <para>
				The mechanism for name resolution in Linux is modular and can use various sources of information declared in the <filename>/etc/nsswitch.conf</filename> file. The entry that involves host name resolution is <literal>hosts</literal>. By default, it contains <literal>files dns</literal>, which means that the system consults the <filename>/etc/hosts</filename> file first, then DNS servers. NIS/NIS+ or LDAP servers are other possible sources.
			</para>
			 <sidebar> <title><emphasis>NOTE</emphasis> NSS and DNS</title>
			 <para>
				Be aware that the commands specifically intended to query DNS (especially <command>host</command>) do not use the standard name resolution mechanism (NSS). As a consequence, they do not take into consideration <filename>/etc/nsswitch.conf</filename>, and thus, not <filename>/etc/hosts</filename> either.
			</para>
			 </sidebar> <section id="sect.dns-server-configuration">
				<title>Configuring DNS Servers</title>
				 <indexterm>
					<primary>DNS</primary>
				</indexterm>
				 <indexterm>
					<primary>Domain Name Service</primary>
				</indexterm>
				 <para>
					DNS (Domain Name Service) is a distributed and hierarchical service mapping names to IP addresses, and vice-versa. Specifically, it can turn a human-friendly name such as <literal>www.eyrolles.com</literal> into the actual IP address, <literal>213.244.11.247</literal>.
				</para>
				 <para>
					To access DNS information, a DNS server must be available to relay requests. Falcot Corp has its own, but an individual user is more likely to use the DNS servers provided by their ISP.
				</para>
				 <indexterm>
					<primary><filename>resolv.conf</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><literal>nameserver</literal></primary>
				</indexterm>
				 <para>
					The DNS servers to be used are indicated in the <filename>/etc/resolv.conf</filename>, one per line, with the <literal>nameserver</literal> keyword preceding an IP address, as in the following example:
				</para>
				 
<programlisting>
nameserver 212.27.32.176
nameserver 212.27.32.177
nameserver 8.8.8.8
</programlisting>
				 <para>
					Note that the <filename>/etc/resolv.conf</filename> file may be handled automatically (and overwritten) when the network is managed by NetworkManager or configured via DHCP.
				</para>

			</section>
			 <section id="sect.etc-hosts">
				<title>The <filename>/etc/hosts</filename> file</title>
				 <indexterm>
					<primary><filename>hosts</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/hosts</filename></primary>
				</indexterm>
				 <para>
					If there is no name server on the local network, it is still possible to establish a small table mapping IP addresses and machine hostnames in the <filename>/etc/hosts</filename> file, usually reserved for local network stations. The syntax of this file is very simple: each line indicates a specific IP address followed by the list of any associated names (the first being “completely qualified”, meaning it includes the domain name).
				</para>
				 <para>
					This file is available even during network outages or when DNS servers are unreachable, but will only really be useful when duplicated on all the machines on the network. The slightest alteration in correspondence will require the file to be updated everywhere. This is why <filename>/etc/hosts</filename> generally only contains the most important entries.
				</para>
				 <para>
					This file will be sufficient for a small network not connected to the Internet, but with 5 machines or more, it is recommended to install a proper DNS server.
				</para>
				 <sidebar> <title><emphasis>TIP</emphasis> Bypassing DNS</title>
				 <para>
					Since applications check the <filename>/etc/hosts</filename> file before querying DNS, it is possible to include information in there that is different from what the DNS would return, and therefore to bypass normal DNS-based name resolution.
				</para>
				 <para>
					This allows, in the event of DNS changes not yet propagated, to test access to a website with the intended name even if this name is not properly mapped to the correct IP address yet.
				</para>
				 <para>
					Another possible use is to redirect traffic intended for a specific host to the localhost, thus preventing any communication with the given host. For example, hostnames of servers dedicated to serving ads could be diverted which would bypass these ads resulting in more fluid, less distracting, navigation.
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.user-group-databases">
		<title>User and Group Databases</title>
		 <indexterm>
			<primary>user</primary>
			<secondary>database</secondary>
		</indexterm>
		 <indexterm>
			<primary>group</primary>
			<secondary>database</secondary>
		</indexterm>
		 <indexterm>
			<primary>database</primary>
			<secondary>of users</secondary>
		</indexterm>
		 <indexterm>
			<primary>database</primary>
			<secondary>of groups</secondary>
		</indexterm>
		 <para>
			The list of users is usually stored in the <filename>/etc/passwd</filename> file, while the <filename>/etc/shadow</filename> file stores encrypted passwords. Both are text files, in a relatively simple format, which can be read and modified with a text editor. Each user is listed there on a line with several fields separated with a colon (“<literal>:</literal>”).
		</para>
		 <sidebar> <title><emphasis>NOTE</emphasis> Editing system files</title>
		 <para>
			The system files mentioned in this chapter are all plain text files, and can be edited with a text editor. Considering their importance to core system functionality, it is always a good idea to take extra precautions when editing system files. First, always make a copy or backup of a system file before opening or altering it. Second, on servers or machines where more than one person could potentially access the same file at the same time, take extra steps to guard against file corruption.
		</para>
		 <para>
			For this purpose, it is enough to use the <command>vipw</command> command to edit the <filename>/etc/passwd</filename> file, or <command>vigr</command> to edit <filename>/etc/group</filename>. These commands lock the file in question prior to running the text editor, (<command>vi</command> by default, unless the <varname>EDITOR</varname> environment variable has been altered). The <literal>-s</literal> option in these commands allows editing the corresponding <foreignphrase>shadow</foreignphrase> file.
		</para>
		 </sidebar> <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Crypt, a one-way function</title>
		 <indexterm>
			<primary>crypt</primary>
		</indexterm>
		 <para>
			<command>crypt</command> is a one-way function that transforms a string (<varname>A</varname>) into another string (<varname>B</varname>) in a way that <varname>A</varname> cannot be derived from <varname>B</varname>. The only way to identify <varname>A</varname> is to test all possible values, checking each one to determine if transformation by the function will produce <varname>B</varname> or not. It uses up to 8 characters as input (string <varname>A</varname>) and generates a string of 13, printable, ASCII characters (string <varname>B</varname>).
		</para>
		 </sidebar> <section id="sect.etc-passwd">
			<title>User List: <filename>/etc/passwd</filename></title>
			 <para>
				Here is the list of fields in the <filename>/etc/passwd</filename> file:
			</para>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/passwd</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>uid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>gid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>GECOS</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>login</literal></primary>
			</indexterm>
			 <itemizedlist>
				<listitem>
					<para>
						login, for example <literal>rhertzog</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						password: this is a password encrypted by a one-way function (<command>crypt</command>), relying on <literal>DES</literal>, <literal>MD5</literal>, <literal>SHA-256</literal> or <literal>SHA-512</literal>. The special value “<literal>x</literal>” indicates that the encrypted password is stored in <filename>/etc/shadow</filename>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uid</literal>: unique number identifying each user;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: unique number for the user's main group (Debian creates a specific group for each user by default);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>GECOS</literal>: data field usually containing the user's full name;
					</para>

				</listitem>
				 <listitem>
					<para>
						login directory, assigned to the user for storage of their personal files (the environment variable <varname>$HOME</varname> generally points here);
					</para>

				</listitem>
				 <listitem>
					<para>
						program to execute upon login. This is usually a command interpreter (shell), giving the user free rein. If you specify <command>/bin/false</command> (which does nothing and returns control immediately), the user cannot login.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Unix group</title>
			 <indexterm>
				<primary>group</primary>
			</indexterm>
			 <para>
				A Unix group is an entity including several users so that they can easily share files using the integrated permission system (by benefiting from the same rights). You can also restrict use of certain programs to a specific group.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-shadow">
			<title>The Hidden and Encrypted Password File: <filename>/etc/shadow</filename></title>
			 <indexterm>
				<primary><filename>shadow</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/shadow</filename></primary>
			</indexterm>
			 <para>
				The <filename>/etc/shadow</filename> file contains the following fields:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						login;
					</para>

				</listitem>
				 <listitem>
					<para>
						encrypted password;
					</para>

				</listitem>
				 <listitem>
					<para>
						several fields managing password expiration.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>DOCUMENTATION</emphasis> <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> and <filename>/etc/group</filename> file formats</title>
			 <para>
				These formats are documented in the following man pages: <citerefentry><refentrytitle>passwd</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>shadow</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>, and <citerefentry><refentrytitle>group</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>.
			</para>
			 </sidebar> <sidebar> <title><emphasis>SECURITY</emphasis> <filename>/etc/shadow</filename> file security</title>
			 <para>
				<filename>/etc/shadow</filename>, unlike its alter-ego, <filename>/etc/passwd</filename>, cannot be read by regular users. Any encrypted password stored in <filename>/etc/passwd</filename> is readable by anybody; a cracker could try to “break” (or reveal) a password by one of several “brute force” methods which, simply put, guess at commonly used combinations of characters. This attack — called a "dictionary attack" — is no longer possible on systems using <filename>/etc/shadow</filename>.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.account-modification">
			<title>Modifying an Existing Account or Password</title>
			 <indexterm>
				<primary><command>chsh</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chfn</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chage</command></primary>
			</indexterm>
			 <indexterm>
				<primary>password</primary>
			</indexterm>
			 <para>
				The following commands allow modification of the information stored in specific fields of the user databases: <command>passwd</command> permits a regular user to change their password, which in turn, updates the <filename>/etc/shadow</filename> file; <command>chfn</command> (CHange Full Name), reserved for the super-user (root), modifies the <literal>GECOS</literal> field. <command>chsh</command> (CHange SHell) allows the user to change their login shell, however available choices will be limited to those listed in <filename>/etc/shells</filename>; the administrator, on the other hand, is not bound by this restriction and can set the shell to any program of their choosing.
			</para>
			 <para>
				Finally, the <command>chage</command> (CHange AGE) command allows the administrator to change the password expiration settings (the <literal>-l <replaceable>user</replaceable></literal> option will list the current settings). You can also force the expiration of a password using the <command>passwd -e <replaceable>user</replaceable></command> command, which will require the user to change their password the next time they log in.
			</para>

		</section>
		 <section id="sect.disabling-account">
			<title>Disabling an Account</title>
			 <indexterm>
				<primary>Disable an account</primary>
			</indexterm>
			 <indexterm>
				<primary>account</primary>
				<secondary>disable</secondary>
			</indexterm>
			 <para>
				You may find yourself needing to “disable an account” (lock out a user), as a disciplinary measure, for the purposes of an investigation, or simply in the event of a prolonged or definitive absence of a user. A disabled account means the user cannot login or gain access to the machine. The account remains intact on the machine and no files or data are deleted; it is simply inaccessible. This is accomplished by using the command <command>passwd -l <replaceable>user</replaceable></command> (lock). Re-enabling the account is done in similar fashion, with the <literal>-u</literal> option (unlock).
			</para>
			 <sidebar id="sidebar.intro-nss"> <title><emphasis>GOING FURTHER</emphasis> NSS and system databases</title>
			 <indexterm>
				<primary>NSS</primary>
			</indexterm>
			 <indexterm>
				<primary>Name Service Switch</primary>
			</indexterm>
			 <para>
				Instead of using the usual files to manage lists of users and groups, you could use other types of databases, such as LDAP or <command>db</command>, by using an appropriate NSS (Name Service Switch) module. The modules used are listed in the <filename>/etc/nsswitch.conf</filename> file, under the <literal>passwd</literal>, <literal>shadow</literal> and <literal>group</literal> entries. See <xref linkend="sect.config-nss" /> for a specific example of the use of an NSS module by LDAP.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-group">
			<title>Group List: <filename>/etc/group</filename></title>
			 <para>
				Groups are listed in the <filename>/etc/group</filename> file, a simple textual database in a format similar to that of the <filename>/etc/passwd</filename> file, with the following fields:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						group name;
					</para>

				</listitem>
				 <listitem>
					<para>
						password (optional): This is only used to join a group when one is not a usual member (with the <command>newgrp</command> or <command>sg</command> commands, see sidebar <xref linkend="sidebar.working-with-several-groups" />);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: unique group identification number;
					</para>

				</listitem>
				 <listitem>
					<para>
						list of members: list of names of users who are members of the group, separated by commas.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
			</para>
			 <sidebar id="sidebar.working-with-several-groups"> <title><emphasis>BACK TO BASICS</emphasis> Working with several groups</title>
			 <indexterm>
				<primary><command>newgrp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sg</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>id</command></primary>
			</indexterm>
			 <indexterm>
				<primary>group</primary>
				<secondary>change</secondary>
			</indexterm>
			 <para>
				Each user may be a member of many groups; one of them is their “main group”. A user's main group is, by default, created during initial user configuration. By default, each file that a user creates belongs to them, as well as to their main group. This is not always desirable; for example, when the user needs to work in a directory shared by a group other than their main group. In this case, the user needs to change their main group using one of the following commands: <command>newgrp</command>, which starts a new shell, or <command>sg</command>, which simply executes a command using the supplied alternate group. These commands also allow the user to join a group to which they do not belong. If the group is password protected, they will need to supply the appropriate password before the command is executed.
			</para>
			 <para>
				Alternatively, the user can set the <literal>setgid</literal> bit on the directory, which causes files created in that directory to automatically belong to the correct group. For more details, see sidebar <xref linkend="sidebar.setgid-dir" />.
			</para>
			 <para>
				The <command>id</command> command displays the current state of a user, with their personal identifier (<varname>uid</varname> variable), current main group (<varname>gid</varname> variable), and the list of groups to which they belong (<varname>groups</varname> variable).
			</para>
			 </sidebar> <indexterm>
				<primary><filename>group</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/group</filename></primary>
			</indexterm>
			 <para>
				The <command>addgroup</command> and <command>delgroup</command> commands add or delete a group, respectively. The <command>groupmod</command> command modifies a group's information (its <literal>gid</literal> or identifier). The command <command>passwd -g <replaceable>group</replaceable></command> changes the password for the group, while the <command>passwd -r -g <replaceable>group</replaceable></command> command deletes it.
			</para>
			 <indexterm>
				<primary><command>addgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>delgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>groupmod</command></primary>
			</indexterm>
			 <indexterm>
				<primary>group</primary>
				<secondary>creation</secondary>
			</indexterm>
			 <indexterm>
				<primary>creation</primary>
				<secondary>of groups</secondary>
			</indexterm>
			 <indexterm>
				<primary>group</primary>
				<secondary>deletion</secondary>
			</indexterm>
			 <indexterm>
				<primary>deletion of a group</primary>
			</indexterm>
			 <sidebar> <title><emphasis>TIP</emphasis> <command>getent</command></title>
			 <indexterm>
				<primary><command>getent</command></primary>
			</indexterm>
			 <para>
				The <command>getent</command> (get entries) command checks the system databases the standard way, using the appropriate library functions, which in turn call the NSS modules configured in the <filename>/etc/nsswitch.conf</filename> file. The command takes one or two arguments: the name of the database to check, and a possible search key. Thus, the command <command>getent passwd rhertzog</command> will give the information from the user database regarding the user <literal>rhertzog</literal>.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.creating-accounts">
		<title>Creating Accounts</title>
		 <indexterm>
			<primary>account</primary>
			<secondary>creation</secondary>
		</indexterm>
		 <indexterm>
			<primary>creation</primary>
			<secondary>of user accounts</secondary>
		</indexterm>
		 <para>
			One of the first actions an administrator needs to do when setting up a new machine is to create user accounts. This is typically done using the <command>adduser</command> command which takes a user-name for the new user to be created, as an argument.
		</para>
		 <indexterm>
			<primary><command>adduser</command></primary>
		</indexterm>
		 <para>
			The <command>adduser</command> command asks a few questions before creating the account, but its usage is fairly straightforward. Its configuration file, <filename>/etc/adduser.conf</filename>, includes all the interesting settings: it can be used to automatically set a quota for each new user by creating a user template, or to change the location of user accounts; the latter is rarely useful, but it comes in handy when you have a large number of users and want to divide their accounts over several disks, for instance. You can also choose a different default shell.
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Quota</title>
		 <indexterm>
			<primary>quota</primary>
		</indexterm>
		 <para>
			The term “quota” refers to a limit on machine resources that a user is allowed to use. This frequently refers to disk space.
		</para>
		 </sidebar> <para>
			The creation of an account populates the user's home directory with the contents of the <filename>/etc/skel/</filename> template. This provides the user with a set of standard directories and configuration files.
		</para>
		 <indexterm>
			<primary>group</primary>
			<secondary>add a user</secondary>
		</indexterm>
		 <indexterm>
			<primary>add a user to a group</primary>
		</indexterm>
		 <para>
			In some cases, it will be useful to add a user to a group (other than their default “main” group) in order to grant them additional permissions. For example, a user who is included in the <emphasis>audio</emphasis> group can access audio devices (see sidebar <xref linkend="sidebar.special-files" />). This can be achieved with a command such as <command>adduser <replaceable>user</replaceable> <replaceable>group</replaceable></command>.
		</para>
		 <sidebar id="sidebar.special-files"> <title><emphasis>BACK TO BASICS</emphasis> Device access permissions</title>
		 <indexterm>
			<primary>device</primary>
			<secondary>access permissions</secondary>
		</indexterm>
		 <indexterm>
			<primary>file</primary>
			<secondary>special</secondary>
		</indexterm>
		 <indexterm>
			<primary>mode</primary>
			<secondary>character</secondary>
		</indexterm>
		 <indexterm>
			<primary>mode</primary>
			<secondary>block</secondary>
		</indexterm>
		 <indexterm>
			<primary>block, mode</primary>
		</indexterm>
		 <indexterm>
			<primary>character, mode</primary>
		</indexterm>
		 <indexterm>
			<primary>special, file</primary>
		</indexterm>
		 <indexterm>
			<primary><command>mknod</command></primary>
		</indexterm>
		 <para>
			Each hardware peripheral device is represented under Unix with a special file, usually stored in the file tree under <filename>/dev/</filename> (DEVices). Two types of special files exist according to the nature of the device: “character mode” and “block mode” files, each mode allowing for only a limited number of operations. While character mode limits interaction with read/write operations, block mode also allows seeking within the available data. Finally, each special file is associated with two numbers (“major” and “minor”) that identify the device to the kernel in a unique manner. Such a file, created by the <command>mknod</command> command, simply contains a symbolic (and more human-friendly) name.
		</para>
		 <para>
			The permissions of a special file map to the permissions necessary to access the device itself. Thus, a file such as <filename>/dev/mixer</filename>, representing the audio mixer, only has read/write permissions for the root user and members of the <literal>audio</literal> group. Only these users can operate the audio mixer.
		</para>
		 <para>
			It should be noted that the combination of <emphasis role="pkg">udev</emphasis>, <emphasis role="pkg">consolekit</emphasis> and <emphasis role="pkg">policykit</emphasis> can add additional permissions to allow users physically connected to the console (and not through the network) to access to certain devices.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.shell-environment">
		<title>Shell Environment</title>
		 <para>
			Command interpreters (or shells) can be a user's first point of contact with the computer, and they must therefore be rather friendly. Most of them use initialization scripts that allow configuration of their behavior (automatic completion, prompt text, etc.).
		</para>
		 <indexterm>
			<primary>command line interface</primary>
		</indexterm>
		 <indexterm>
			<primary>command interpreter</primary>
		</indexterm>
		 <indexterm>
			<primary>shell介绍</primary>
		</indexterm>
		 <indexterm>
			<primary><command>bash</command></primary>
		</indexterm>
		 <para>
			<command>bash</command>, the standard shell, uses the <filename>/etc/bash.bashrc</filename> initialization script for “interactive” shells, and <filename>/etc/profile</filename> for “login” shells.
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Login shell and (non) interactive shell</title>
		 <para>
			In simple terms, a login shell is invoked when you login to the console either locally or remotely via <command>ssh</command>, or when you run an explicit <command>bash --login</command> command. Regardless of whether it is a login shell or not, a shell can be interactive (in an <command>xterm</command>-type terminal for instance); or non-interactive (when executing a script).
		</para>
		 </sidebar> <sidebar> <title><emphasis>DISCOVERY</emphasis> Other shells, other scripts</title>
		 <para>
			Each command interpreter has a specific syntax and its own configuration files. Thus, <command>zsh</command> uses <filename>/etc/zshrc</filename> and <filename>/etc/zshenv</filename>; <command>csh</command> uses <filename>/etc/csh.cshrc</filename>, <filename>/etc/csh.login</filename> and <filename>/etc/csh.logout</filename>. The man pages for these programs document which files they use.
		</para>
		 <indexterm>
			<primary><command>zsh</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>csh</command></primary>
		</indexterm>
		 </sidebar> <para>
			For <command>bash</command>, it is useful to activate “automatic completion” in the <filename>/etc/bash.bashrc</filename> file (simply uncomment a few lines).
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Automatic completion</title>
		 <indexterm>
			<primary>automatic completion</primary>
		</indexterm>
		 <para>
			Many command interpreters provide a completion feature, which allows the shell to automatically complete a partially typed command name or argument when the user hits the <keycap>Tab</keycap> key. This lets users work more efficiently and be less error-prone.
		</para>
		 <para>
			This function is very powerful and flexible. It is possible to configure its behavior according to each command. Thus, the first argument following <command>apt-get</command> will be proposed according to the syntax of this command, even if it does not match any file (in this case, the possible choices are <literal>install</literal>, <literal>remove</literal>, <literal>upgrade</literal>, etc.).
		</para>
		 </sidebar> <sidebar> <title><emphasis>BACK TO BASICS</emphasis> The tilde, a shortcut to HOME</title>
		 <indexterm>
			<primary>~</primary>
		</indexterm>
		 <indexterm>
			<primary>tilde</primary>
		</indexterm>
		 <para>
			The tilde is often used to indicate the directory to which the environment variable, <varname>HOME</varname>, points (being the user's home directory, such as <filename>/home/rhertzog/</filename>). Command interpreters automatically make the substitution: <filename>~/hello.txt</filename> becomes <filename>/home/rhertzog/hello.txt</filename>.
		</para>
		 <para>
			The tilde also allows access to another user's home directory. Thus, <filename>~rmas/bonjour.txt</filename> is synonymous with <filename>/home/rmas/bonjour.txt</filename>.
		</para>
		 </sidebar> <para>
			In addition to these common scripts, each user can create their own <filename>~/.bashrc</filename> and <filename>~/.bash_profile</filename> to configure their shell. The most common changes are the addition of aliases; these are words that are automatically replaced with the execution of a command, which makes it faster to invoke that command. For instance, you could create the <literal>la</literal> alias for the command <command>ls -la | less</command> command; then you only have to type <command>la</command> to inspect the contents of a directory in detail.
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Environment variables</title>
		 <indexterm>
			<primary>environment</primary>
			<secondary>environment variable</secondary>
		</indexterm>
		 <indexterm>
			<primary>variable, environment</primary>
		</indexterm>
		 <para>
			Environment variables allow storage of global settings for the shell or various other programs called. They are contextual (each process has its own set of environment variables) but inheritable. This last characteristic offers the possibility for a login shell to declare variables which will be passed down to all programs it executes.
		</para>
		 </sidebar> <para>
			Setting default environment variables is an important element of shell configuration. Leaving aside the variables specific to a shell, it is preferable to place them in the <filename>/etc/environment</filename> file, since it is used by the various programs likely to initiate a shell session. Variables typically defined there include <varname>ORGANIZATION</varname>, which usually contains the name of the company or organization, and <varname>HTTP_PROXY</varname>, which indicates the existence and location of an HTTP proxy.
		</para>
		 <sidebar> <title><emphasis>TIP</emphasis> All shells configured identically</title>
		 <para>
			Users often want to configure their login and interactive shells in the same way. To do this, they choose to interpret (or “source”) the content from <filename>~/.bashrc</filename> in the <filename>~/.bash_profile</filename> file. It is possible to do the same with files common to all users (by calling <filename>/etc/bash.bashrc</filename> from <filename>/etc/profile</filename>).
		</para>
		 </sidebar>
	</section>
	 <section id="sect.config-printing">
		<title>Printer Configuration</title>
		 <indexterm>
			<primary>configuration</primary>
			<secondary>printing</secondary>
		</indexterm>
		 <indexterm>
			<primary>printing</primary>
			<secondary>configuration</secondary>
		</indexterm>
		 <para>
			Printer configuration used to cause a great many headaches for administrators and users alike. These headaches are now mostly a thing of the past, thanks to <emphasis role="pkg">cups</emphasis>, the free print server using the IPP protocol (Internet Printing Protocol).
		</para>
		 <indexterm>
			<primary>IPP</primary>
		</indexterm>
		 <indexterm>
			<primary>Internet Printing Protocol</primary>
		</indexterm>
		 <indexterm>
			<primary><command>cups</command></primary>
		</indexterm>
		 <para>
			This program is divided over several Debian packages: <emphasis role="pkg">cups</emphasis> is the central print server; <emphasis role="pkg">cups-bsd</emphasis> is a compatibility layer allowing use of commands from the traditional BSD printing system (<command>lpd</command> daemon, <command>lpr</command> and <command>lpq</command> commands, etc.); <emphasis role="pkg">cups-client</emphasis> contains a group of programs to interact with the server (block or unblock a printer, view or delete print jobs in progress, etc.); and finally, <emphasis role="pkg">cups-driver-gutenprint</emphasis> contains a collection of additional printer drivers for <command>cups</command>.
		</para>
		 <indexterm>
			<primary><command>lpr</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpq</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>COMMUNITY</emphasis> CUPS</title>
		 <indexterm>
			<primary>CUPS</primary>
		</indexterm>
		 <indexterm>
			<primary>Common Unix Printing System</primary>
		</indexterm>
		 <para>
			CUPS (Common Unix Printing System) is a project (and a trademark) managed by Apple, Inc. <ulink type="block" url="http://www.cups.org/" />
		</para>
		 </sidebar> <para>
			After installation of these different packages, <command>cups</command> is administered easily through a web interface accessible at the local address: <literal>http://localhost:631/</literal>. There you can add printers (including network printers), remove, and administer them. You can also administer <command>cups</command> with the graphical interface provided by the desktop environment. Finally, there is also the <command>system-config-printer</command> graphical interface (from the Debian package of the same name).
		</para>
		 <indexterm>
			<primary><command>cups</command></primary>
			<secondary>administration</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>NOTE</emphasis> Obsolescence of <filename>/etc/printcap</filename></title>
		 <para>
			<emphasis>cups</emphasis> no longer uses the <filename>/etc/printcap</filename> file, which is now obsolete. Programs that rely upon this file to get a list of available printers will, thus, fail. To avoid this problem, delete this file and make it a symbolic link (see sidebar <xref linkend="sidebar.symbolic-link" />) to <filename>/var/run/cups/printcap</filename>, which is maintained by <emphasis>cups</emphasis> to ensure compatibility.
		</para>
		 <indexterm>
			<primary><filename>printcap</filename></primary>
		</indexterm>
		 </sidebar>
	</section>
	 <section id="sect.config-bootloader">
		<title>Configuring the Bootloader</title>
		 <indexterm>
			<primary>加载器</primary>
			<secondary>引导程序</secondary>
		</indexterm>
		 <indexterm>
			<primary>引导程序</primary>
		</indexterm>
		 <para>
			It is probably already functional, but it is always good to know how to configure and install the bootloader in case it disappears from the Master Boot Record. This can occur after installation of another operating system, such as Windows. The following information can also help you to modify the bootloader configuration if needed.
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Master boot record</title>
		 <indexterm>
			<primary>MBR</primary>
		</indexterm>
		 <indexterm>
			<primary>Master Boot Record</primary>
		</indexterm>
		 <para>
			The Master Boot Record (MBR) occupies the first 512 bytes of the first hard disk, and is the first thing loaded by the BIOS to hand over control to a program capable of booting the desired operating system. In general, a bootloader gets installed in the MBR, removing its previous content.
		</para>
		 </sidebar> <section id="sect.identify-disks">
			<title>Identifying the Disks</title>
			 <sidebar> <title><emphasis>CULTURE</emphasis> <emphasis>udev</emphasis> and <filename>/dev/</filename></title>
			 <para>
				The <filename>/dev/</filename> directory traditionally houses so-called “special” files, intended to represent system peripherals (see sidebar <xref linkend="sidebar.special-files" />). Once upon a time, it used to contain all special files that could potentially be used. This approach had a number of drawbacks among which the fact that it restricted the number of devices that one could use (due to the hardcoded list of names), and that it was impossible to know which special files were actually useful.
			</para>
			 <para>
				Nowadays, the management of special files is entirely dynamic and matches better the nature of hot-swappable computer devices. The kernel cooperates with <emphasis>udev</emphasis> to create and delete them as needed when the corresponding devices appear and disappear. For this reason, <filename>/dev/</filename> doesn't need to be persistent and is thus a RAM-based filesystem that starts empty and contains only the relevant entries.
			</para>
			 <para>
				The kernel communicates lots of information about any newly added device and hands out a pair of major/minor numbers to identify it. With this <command>udevd</command> can create the special file under the name and with the permissions that it wants. It can also create aliases and perform additional actions (such as initialization or registration tasks). <command>udevd</command>'s behavior is driven by a large set of (customizable) rules.
			</para>
			 <para>
				With dynamically assigned names, you can thus keep the same name for a given device, regardless of the connector used or the connection order, which is especially useful when you use various USB peripherals. The first partition on the first hard drive can then be called <filename>/dev/sda1</filename> for backwards compatibility, or <filename>/dev/root-partition</filename> if you prefer, or even both at the same time since <command>udevd</command> can be configured to automatically create a symbolic link.
			</para>
			 <para>
				In ancient times, some kernel modules did automatically load when you tried to access the corresponding device file. This is no longer the case, and the peripheral's special file no longer exists prior to loading the module; this is no big deal, since most modules are loaded on boot thanks to automatic hardware detection. But for undetectable peripherals (such as very old disk drives or PS/2 mice), this doesn't work. Consider adding the modules, <literal>floppy</literal>, <literal>psmouse</literal> and <literal>mousedev</literal> to <filename>/etc/modules</filename> in order to force loading them on boot.
			</para>
			 </sidebar> <indexterm>
				<primary>hard drive, names</primary>
			</indexterm>
			 <indexterm>
				<primary>names</primary>
				<secondary>of hard drives</secondary>
			</indexterm>
			 <para>
				Configuration of the bootloader must identify the different hard drives and their partitions. Linux uses “block” special files stored in the <filename>/dev/</filename> directory, for this purpose. Since Debian <emphasis role="distribution">Squeeze</emphasis>, the naming scheme for hard drives has been unified by the Linux kernel, and all hard drives (IDE/PATA, SATA, SCSI, USB, IEEE 1394) are now represented by <filename>/dev/sd*</filename>.
			</para>
			 <para>
				Each partition is represented by its number on the disk on which it resides: for instance, <filename>/dev/sda1</filename> is the first partition on the first disk, and <filename>/dev/sdb3</filename> is the third partition on the second disk.
			</para>
			 <indexterm>
				<primary>partition</primary>
				<secondary>primary</secondary>
			</indexterm>
			 <indexterm>
				<primary>partition</primary>
				<secondary>extended</secondary>
			</indexterm>
			 <indexterm>
				<primary>partition</primary>
				<secondary>secondary</secondary>
			</indexterm>
			 <indexterm>
				<primary>partition table</primary>
				<secondary>MS-DOS format</secondary>
			</indexterm>
			 <para>
				The PC architecture (or “i386”, including its younger cousin “amd64”) has long been limited to using the “MS-DOS” partition table format, which only allows four “primary” partitions per disk. To go beyond this limitation under this scheme, one of them has to be created as an “extended” partition, and it can then contain additional “secondary” partitions. These secondary partitions are numbered from 5. Thus the first secondary partition could be <filename>/dev/sda5</filename>, followed by <filename>/dev/sda6</filename>, etc.
			</para>
			 <para>
				Another restriction of the MS-DOS partition table format is that it only allows disks up to 2 TiB in size, which is becoming a real problem with recent disks.
			</para>
			 <indexterm>
				<primary>GPT</primary>
				<secondary>partition table format</secondary>
			</indexterm>
			 <indexterm>
				<primary>partition table</primary>
				<secondary>GPT format</secondary>
			</indexterm>
			 <para>
				A new partition table format called GPT loosens these constraints on the number of partitions (it allows up to 128 partitions when using standard settings) and on the size of the disks (up to 8 ZiB, which is more than 8 billion terabytes). If you intend to create many physical partitions on the same disk, you should therefore ensure that you are creating the partition table in the GPT format when partitioning your disk.
			</para>
			 <para>
				It is not always easy to remember what disk is connected to which SATA controller, or in third position in the SCSI chain, especially since the naming of hotplugged hard drives (which includes among others most SATA disks and external disks) can change from one boot to another. Fortunately, <command>udev</command> creates, in addition to <filename>/dev/sd*</filename>, symbolic links with a fixed name, which you could then use if you wished to identify a hard drive in a non-ambiguous manner. These symbolic links are stored in <filename>/dev/disk/by-id</filename>. On a machine with two physical disks, for example, one could find the following:
			</para>
			 
<screen><computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l
</userinput><computeroutput>total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </computeroutput></screen>
			 <para>
				Note that some disks are listed several times (because they behave simultaneously as ATA disks and SCSI disks), but the relevant information is mainly in the model and serial numbers of the disks, from which you can find the peripheral file.
			</para>
			 <para>
				The example configuration files given in the following sections are based on the same setup: a single SATA disk, where the first partition is an old Windows installation and the second contains Debian GNU/Linux.
			</para>

		</section>
		 <section id="sect.config-lilo">
			<title>Configuring LILO</title>
			 <indexterm>
				<primary>LILO</primary>
			</indexterm>
			 <indexterm>
				<primary>Linux Loader</primary>
			</indexterm>
			 <para>
				<emphasis>LILO</emphasis> (LInux LOader) is the oldest bootloader — solid but rustic. It writes the physical address of the kernel to boot on the MBR, which is why each update to LILO (or its configuration file) must be followed by the command <command>lilo</command>. Forgetting to do so will render a system unable to boot if the old kernel was removed or replaced as the new one will not be in the same location on the disk.
			</para>
			 <para>
				LILO's configuration file is <filename>/etc/lilo.conf</filename>; a simple file for standard configuration is illustrated in the example below.
			</para>
			 <example id="example.lilo.conf">
				<title>LILO configuration file</title>
				 
<programlisting>
# The disk on which LILO should be installed.
# By indicating the disk and not a partition.
# you order LILO to be installed on the MBR.
boot=/dev/sda
# the partition that contains Debian
root=/dev/sda2
# the item to be loaded by default
default=Linux

# the most recent kernel image
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Old kernel (if the newly installed kernel doesn't boot)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# only for Linux/Windows dual boot
other=/dev/sda1
  label=Windows
</programlisting>

			</example>

		</section>
		 <section id="sect.config-grub">
			<title>GRUB 2 Configuration</title>
			 <indexterm>
				<primary>GRUB</primary>
			</indexterm>
			 <indexterm>
				<primary>GRUB 2</primary>
			</indexterm>
			 <para>
				<emphasis>GRUB</emphasis> (GRand Unified Bootloader) is more recent. It is not necessary to invoke it after each update of the kernel; <emphasis>GRUB</emphasis> knows how to read the filesystems and find the position of the kernel on the disk by itself. To install it on the MBR of the first disk, simply type <command>grub-install /dev/sda</command>. <indexterm><primary><command>grub-install</command></primary></indexterm>
			</para>
			 <sidebar> <title><emphasis>NOTE</emphasis> Disk names for GRUB</title>
			 <para>
				GRUB can only identify hard drives based on information provided by the BIOS. <literal>(hd0)</literal> corresponds to the first disk thus detected, <literal>(hd1)</literal> the second, etc. In most cases, this order corresponds exactly to the usual order of disks under Linux, but problems can occur when you associate SCSI and IDE disks. GRUB stores correspondences that it detects in the file <filename>/boot/grub/device.map</filename>. If you find errors there (because you know that your BIOS detects drives in a different order), correct them manually and run <command>grub-install</command> again. <command>grub-mkdevicemap</command> can help creating a <filename>device.map</filename> file from which to start.
			</para>
			 <para>
				Partitions also have a specific name in GRUB. When you use “classical” partitions in MS-DOS format, the first partition on the first disk is labeled, <literal>(hd0,msdos1)</literal>, the second <literal>(hd0,msdos2)</literal>, etc.
			</para>
			 </sidebar> <para>
				GRUB 2 configuration is stored in <filename>/boot/grub/grub.cfg</filename>, but this file (in Debian) is generated from others. Be careful not to modify it by hand, since such local modifications will be lost the next time <command>update-grub</command> is run (which may occur upon update of various packages). The most common modifications of the <filename>/boot/grub/grub.cfg</filename> file (to add command line parameters to the kernel or change the duration that the menu is displayed, for example) are made through the variables in <filename>/etc/default/grub</filename>. To add entries to the menu, you can either create a <filename>/boot/grub/custom.cfg</filename> file or modify the <filename>/etc/grub.d/50_custom</filename> file. For more complex configurations, you can modify other files in <filename>/etc/grub.d</filename>, or add to them; these scripts should return configuration snippets, possibly by making use of external programs. These scripts are the ones that will update the list of kernels to boot: <filename>10_linux</filename> takes into consideration the installed Linux kernels; <filename>20_linux_xen</filename> takes into account Xen virtual systems, and <filename>30_os-prober</filename> lists other operating systems (Windows, OS X, Hurd).
			</para>

		</section>
		 <section id="sect.config-yaboot">
			<title>For Macintosh Computers (PowerPC): Configuring Yaboot</title>
			 <indexterm>
				<primary><command>yaboot</command></primary>
			</indexterm>
			 <para>
				Yaboot is the bootloader used by old Macintosh computers using PowerPC processors. They do not boot like PCs, but rely on a “bootstrap” partition, from which the BIOS (or OpenFirmware) executes the loader, and on which the <command>ybin</command> program installs <command>yaboot</command> and its configuration file. You will only need to run this command again if the <filename>/etc/yaboot.conf</filename> is modified (it is duplicated on the bootstrap partition, and <command>yaboot</command> knows how to find the position of the kernels on the disks).
			</para>
			 <para>
				Before executing <command>ybin</command>, you must first have a valid <filename>/etc/yaboot.conf</filename>. The following is an example of a minimal configuration. <indexterm><primary><command>ybin</command></primary></indexterm>
			</para>
			 <example id="example.yaboot.conf">
				<title>Yaboot configuration file</title>
				 
<programlisting>
# bootstrap partition
boot=/dev/sda2
# the disk
device=hd:
# the Linux partition
partition=3
root=/dev/sda3
# boot after 3 seconds of inactivity
# (timeout is in tenths of seconds)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# last kernel installed
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# old kernel
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# only for Linux/Mac OSX dual-boot
macosx=/dev/sda5

# bsd=/dev/sdaX and macos=/dev/sdaX
# are also possible
</programlisting>

			</example>

		</section>

	</section>
	 <section id="sect.config-misc">
		<title>Other Configurations: Time Synchronization, Logs, Sharing Access…</title>
		 <para>
			The many elements listed in this section are good to know for anyone who wants to master all aspects of configuration of the GNU/Linux system. They are, however, treated briefly and frequently refer to the documentation.
		</para>
		 <section id="sect.timezone">
			<title>Timezone</title>
			 <indexterm>
				<primary>timezone</primary>
			</indexterm>
			 <sidebar id="sidebar.symbolic-link"> <title><emphasis>BACK TO BASICS</emphasis> Symbolic links</title>
			 <indexterm>
				<primary>link</primary>
				<secondary>symbolic</secondary>
			</indexterm>
			 <indexterm>
				<primary>symbolic link</primary>
			</indexterm>
			 <indexterm>
				<primary><command>ln</command></primary>
			</indexterm>
			 <para>
				A symbolic link is a pointer to another file. When you access it, the file to which it points is opened. Removal of the link will not cause deletion of the file to which it points. Likewise, it does not have its own set of permissions, but rather retains the permissions of its target. Finally, it can point to any type of file: directories, special files (sockets, named pipes, device files, etc.), even other symbolic links.
			</para>
			 <para>
				The <command>ln -s <replaceable>target</replaceable> <replaceable>link-name</replaceable></command> command creates a symbolic link, named <replaceable>link-name</replaceable>, pointing to <replaceable>target</replaceable>.
			</para>
			 <para>
				If the target does not exist, then the link is “broken” and accessing it will result in an error indicating that the target file does not exist. If the link points to another link, you will have a “chain” of links that turns into a “cycle” if one of the targets points to one of its predecessors. In this case, accessing one of the links in the cycle will result in a specific error (“too many levels of symbolic links”); this means the kernel gave up after several rounds of the cycle.
			</para>
			 </sidebar> <para>
				The timezone, configured during initial installation, is a configuration item for the <emphasis role="pkg">tzdata</emphasis> package. To modify it, use the <command>dpkg-reconfigure tzdata</command> command, which allows you to choose the timezone to be used in an interactive manner. Its configuration is stored in the <filename>/etc/timezone</filename> file. Additionally, the corresponding file in the <filename>/usr/share/zoneinfo</filename> directory is copied into <filename>/etc/localtime</filename>; this file contains the rules governing the dates where daylight saving time is active, for countries that use it.
			</para>
			 <indexterm>
				<primary><filename>timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>zoneinfo</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/usr/share/zoneinfo/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>DST</primary>
			</indexterm>
			 <indexterm>
				<primary>daylight saving time</primary>
			</indexterm>
			 <para>
				When you need to temporarily change the timezone, use the <varname>TZ</varname> environment variable, which takes priority over the configured system default:
			</para>
			 <indexterm>
				<primary><varname>TZ</varname></primary>
			</indexterm>
			 
<screen id="screen.tz">
<computeroutput>$ </computeroutput><userinput>date</userinput>
<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>
<computeroutput>$ </computeroutput><userinput>TZ="Pacific/Honolulu" date</userinput>
<computeroutput>Thu Feb 19 00:25:21 HST 2015</computeroutput></screen>
			 <sidebar> <title><emphasis>NOTE</emphasis> System clock, hardware clock</title>
			 <para>
				There are two time sources in a computer. A computer's motherboard has a hardware clock, called the “CMOS clock”. This clock is not very precise, and provides rather slow access times. The operating system kernel has its own, the software clock, which it keeps up to date with its own means (possibly with the help of time servers, see <xref linkend="sect.time-synchronization" />). This system clock is generally more accurate, especially since it doesn't need access to hardware variables. However, since it only exists in live memory, it is zeroed out every time the machine is booted, contrary to the CMOS clock, which has a battery and therefore “survives” rebooting or halting of the machine. The system clock is, thus, set from the CMOS clock during boot, and the CMOS clock is updated on shutdown (to take into account possible changes or corrections if it has been improperly adjusted).
			</para>
			 <para>
				In practice, there is a problem, since the CMOS clock is nothing more than a counter and contains no information regarding the time zone. There is a choice to make regarding its interpretation: either the system considers it runs in universal time (UTC, formerly GMT), or in local time. This choice could be a simple shift, but things are actually more complicated: as a result of daylight saving time, this offset is not constant. The result is that the system has no way to determine whether the offset is correct, especially around periods of time change. Since it is always possible to reconstruct local time from universal time and the timezone information, we strongly recommend using the CMOS clock in universal time.
			</para>
			 <para>
				Unfortunately, Windows systems in their default configuration ignore this recommendation; they keep the CMOS clock on local time, applying time changes when booting the computer by trying to guess during time changes if the change has already been applied or not. This works relatively well, as long as the system has only Windows running on it. But when a computer has several systems (whether it be a “dual-boot” configuration or running other systems via virtual machine), chaos ensues, with no means to determine if the time is correct. If you absolutely must retain Windows on a computer, you should either configure it to keep the CMOS clock as UTC (setting the registry key <literal>HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</literal> to “1” as a DWORD), or use <command>hwclock --localtime --set</command> on the Debian system to set the hardware clock and mark it as tracking the local time (and make sure to manually check your clock in spring and autumn).
			</para>
			 </sidebar>
		</section>
		 <section id="sect.time-synchronization">
			<title>Time Synchronization</title>
			 <indexterm>
				<primary>time synchronization</primary>
			</indexterm>
			 <indexterm>
				<primary>clock</primary>
				<secondary>synchronization</secondary>
			</indexterm>
			 <para>
				Time synchronization, which may seem superfluous on a computer, is very important on a network. Since users do not have permissions allowing them to modify the date and time, it is important for this information to be precise to prevent confusion. Furthermore, having all of the computers on a network synchronized allows better cross-referencing of information from logs on different machines. Thus, in the event of an attack, it is easier to reconstruct the chronological sequence of actions on the various machines involved in the compromise. Data collected on several machines for statistical purposes won't make a great deal of sense if they are not synchronized.
			</para>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> NTP</title>
			 <indexterm>
				<primary>NTP</primary>
			</indexterm>
			 <indexterm>
				<primary>Network</primary>
				<secondary>Time Protocol</secondary>
			</indexterm>
			 <para>
				NTP (Network Time Protocol) allows a machine to synchronize with others fairly accurately, taking into consideration the delays induced by the transfer of information over the network and other possible offsets.
			</para>
			 <para>
				While there are numerous NTP servers on the Internet, the more popular ones may be overloaded. This is why we recommend using the <emphasis>pool.ntp.org</emphasis> NTP server, which is, in reality, a group of machines that have agreed to serve as public NTP servers. You could even limit use to a sub-group specific to a country, with, for example, <emphasis>us.pool.ntp.org</emphasis> for the United States, or <emphasis>ca.pool.ntp.org</emphasis> for Canada, etc.
			</para>
			 <para>
				However, if you manage a large network, it is recommended that you install your own NTP server, which will synchronize with the public servers. In this case, all the other machines on your network can use your internal NTP server instead of increasing the load on the public servers. You will also increase homogeneity with your clocks, since all the machines will be synchronized on the same source, and this source is very close in terms of network transfer times.
			</para>
			 </sidebar> <section id="sect.ntp-on-workstations">
				<title>For Workstations</title>
				 <para>
					Since work stations are regularly rebooted (even if only to save energy), synchronizing them by NTP at boot is enough. To do so, simply install the <emphasis role="pkg">ntpdate</emphasis> package. You can change the NTP server used if needed by modifying the <filename>/etc/default/ntpdate</filename> file.
				</para>
				 <indexterm>
					<primary><filename>ntpdate</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/default/ntpdate</filename></primary>
				</indexterm>

			</section>
			 <section id="sect.ntp-on-servers">
				<title>For Servers</title>
				 <para>
					Servers are only rarely rebooted, and it is very important for their system time to be correct. To permanently maintain correct time, you would install a local NTP server, a service offered in the <emphasis role="pkg">ntp</emphasis> package. In its default configuration, the server will synchronize with <emphasis>pool.ntp.org</emphasis> and provide time in response to requests coming from the local network. You can configure it by editing the <filename>/etc/ntp.conf</filename> file, the most significant alteration being the NTP server to which it refers. If the network has a lot of servers, it may be interesting to have one local time server which synchronizes with the public servers and is used as a time source by the other servers of the network.
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">ntp</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary>server</primary>
					<secondary>NTP</secondary>
				</indexterm>
				 <indexterm>
					<primary>NTP</primary>
					<secondary>server</secondary>
				</indexterm>
				 <sidebar> <title><emphasis>GOING FURTHER</emphasis> GPS modules and other time sources</title>
				 <indexterm>
					<primary>GPS</primary>
				</indexterm>
				 <indexterm>
					<primary>DCF-77</primary>
				</indexterm>
				 <para>
					If time synchronization is particularly crucial to your network, it is possible to equip a server with a GPS module (which will use the time from GPS satellites) or a DCF-77 module (which will sync time with the atomic clock near Frankfurt, Germany). In this case, the configuration of the NTP server is a little more complicated, and prior consultation of the documentation is an absolute necessity.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.rotation-logs">
			<title>Rotating Log Files</title>
			 <indexterm>
				<primary>file</primary>
				<secondary>logs, rotation</secondary>
			</indexterm>
			 <indexterm>
				<primary>logs</primary>
				<secondary>files, rotation</secondary>
			</indexterm>
			 <indexterm>
				<primary>rotation of log files</primary>
			</indexterm>
			 <indexterm>
				<primary><command>logrotate</command></primary>
			</indexterm>
			 <para>
				Log files can grow, fast, and it is necessary to archive them. The most common scheme is a rotating archive: the log file is regularly archived, and only the latest <replaceable>X</replaceable> archives are retained. <command>logrotate</command>, the program responsible for these rotations, follows directives given in the <filename>/etc/logrotate.conf</filename> file and all of the files in the <filename>/etc/logrotate.d/</filename> directory. The administrator may modify these files, if they wish to adapt the log rotation policy defined by Debian. The <citerefentry><refentrytitle>logrotate</refentrytitle>
				 <manvolnum>1</manvolnum></citerefentry> man page describes all of the options available in these configuration files. You may want to increase the number of files retained in log rotation, or move the log files to a specific directory dedicated to archiving them rather than delete them. You could also send them by e-mail to archive them elsewhere.
			</para>
			 <para>
				The <command>logrotate</command> program is executed daily by the <command>cron</command> scheduling program (described in <xref linkend="sect.task-scheduling-cron-atd" />).
			</para>

		</section>
		 <section id="sect.sharing-admin-rights">
			<title>Sharing Administrator Rights</title>
			 <indexterm>
				<primary>帐户</primary>
				<secondary>管理员帐户</secondary>
			</indexterm>
			 <indexterm>
				<primary>root</primary>
			</indexterm>
			 <indexterm>
				<primary><command>sudo</command></primary>
			</indexterm>
			 <para>
				Frequently, several administrators work on the same network. Sharing the root passwords is not very elegant, and opens the door for abuse due to the anonymity such sharing creates. The solution to this problem is the <command>sudo</command> program, which allows certain users to execute certain commands with special rights. In the most common use case, <command>sudo</command> allows a trusted user to execute any command as root. To do so, the user simply executes <command>sudo <replaceable>command</replaceable></command> and authenticates using their personal password.
			</para>
			 <para>
				When installed, the <emphasis role="pkg">sudo</emphasis> package gives full root rights to members of the <literal>sudo</literal> Unix group. To delegate other rights, the administrator must use the <command>visudo</command> command, which allows them to modify the <filename>/etc/sudoers</filename> configuration file (here again, this will invoke the <command>vi</command> editor, or any other editor indicated in the <varname>EDITOR</varname> environment variable). Adding a line with <literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal> allows the user in question to execute any command as root.
			</para>
			 <indexterm>
				<primary><command>visudo</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>sudoers</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/sudoers</filename></primary>
			</indexterm>
			 <para>
				More sophisticated configurations allow authorization of only specific commands to specific users. All the details of the various possibilities are given in the <citerefentry><refentrytitle>sudoers</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry> man page.
			</para>

		</section>
		 <section id="sect.fstab-mount-points">
			<title>List of Mount Points</title>
			 <indexterm>
				<primary>point, mount</primary>
			</indexterm>
			 <indexterm>
				<primary>挂载点</primary>
			</indexterm>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Mounting and unmounting</title>
			 <para>
				In a Unix-like system such as Debian, files are organized in a single tree-like hierarchy of directories. The <filename>/</filename> directory is called the “root directory”; all additional directories are sub-directories within this root. “Mounting” is the action of including the content of a peripheral device (often a hard drive) into the system's general file tree. As a consequence, if you use a separate hard drive to store users' personal data, this disk will have to be “mounted” in the <filename>/home/</filename> directory. The root filesystem is always mounted at boot by the kernel; other devices are often mounted later during the startup sequence or manually with the <command>mount</command> command.
			</para>
			 <indexterm>
				<primary><command>mount</command></primary>
			</indexterm>
			 <para>
				Some removable devices are automatically mounted when connected, especially when using the GNOME, KDE or other graphical desktop environments. Others have to be mounted manually by the user. Likewise, they must be unmounted (removed from the file tree). Normal users do not usually have permission to execute the <command>mount</command> and <command>umount</command> commands. The administrator can, however, authorize these operations (independently for each mount point) by including the <literal>user</literal> option in the <filename>/etc/fstab</filename> file.
			</para>
			 <para>
				The <command>mount</command> command can be used without arguments (it then lists all mounted filesystems). The following parameters are required to mount or unmount a device. For the complete list, please refer to the corresponding man pages, <citerefentry><refentrytitle>mount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> and <citerefentry><refentrytitle>umount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry>. For simple cases, the syntax is simple too: for example, to mount the <filename>/dev/sdc1</filename> partition, which has an ext3 filesystem, into the <filename>/mnt/tmp/</filename> directory, you would simply run <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command>.
			</para>
			 </sidebar> <para>
				The <filename>/etc/fstab</filename> file gives a list of all possible mounts that happen either automatically on boot or manually for removable storage devices. Each mount point is described by a line with several space-separated fields: <indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						device to mount: this can be a local partition (hard drive, CD-ROM) or a remote filesystem (such as NFS).
					</para>
					 <para>
						This field is frequently replaced with the unique ID of the filesystem (which you can determine with <command>blkid <userinput>device</userinput></command>) prefixed with <literal>UUID=</literal>. This guards against a change in the name of the device in the event of addition or removal of disks, or if disks are detected in a different order.
					</para>

				</listitem>
				 <listitem>
					<para>
						mount point: this is the location on the local filesystem where the device, remote system, or partition will be mounted.
					</para>

				</listitem>
				 <listitem>
					<para>
						type: this field defines the filesystem used on the mounted device. <literal>ext4</literal>, <literal>ext3</literal>, <literal>vfat</literal>, <literal>ntfs</literal>, <literal>btrfs</literal>, <literal>xfs</literal> are a few examples.
					</para>
					 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> NFS, a network filesystem</title>
					 <para>
						NFS is a network filesystem; under Linux, it allows transparent access to remote files by including them in the local filesystem.
					</para>
					 </sidebar> <para>
						A complete list of known filesystems is available in the <citerefentry><refentrytitle>mount</refentrytitle>
						 <manvolnum>8</manvolnum></citerefentry> man page. The <literal>swap</literal> special value is for swap partitions; the <literal>auto</literal> special value tells the <command>mount</command> program to automatically detect the filesystem (which is especially useful for disk readers and USB keys, since each one might have a different filesystem);
					</para>

				</listitem>
				 <listitem>
					<para>
						options: there are many of them, depending on the filesystem, and they are documented in the <command>mount</command> man page. The most common are
					</para>
					 <itemizedlist>
						<listitem>
							<para>
								<literal>rw</literal> or <literal>ro</literal>, meaning, respectively, that the device will be mounted with read/write or read-only permissions.
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>noauto</literal> deactivates automatic mounting on boot.
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>nofail</literal> allows the boot to proceed even when the device is not present. Make sure to put this option for external drives that might be unplugged when you boot, because <command>systemd</command> really ensures that all mount points that must be automatically mounted are actually mounted before letting the boot process continue to its end. Note that you can combine this with <literal>x-systemd.device-timeout=5s</literal> to tell <command>systemd</command> to not wait more than 5 seconds for the device to appear (see <citerefentry><refentrytitle>systemd.mount</refentrytitle>
								<manvolnum>5</manvolnum></citerefentry>).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>user</literal> authorizes all users to mount this filesystem (an operation which would otherwise be restricted to the root user).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>defaults</literal> means the group of default options: <literal>rw</literal>, <literal>suid</literal>, <literal>dev</literal>, <literal>exec</literal>, <literal>auto</literal>, <literal>nouser</literal> and <literal>async</literal>, each of which can be individually disabled after <literal>defaults</literal> by adding <literal>nosuid</literal>, <literal>nodev</literal> and so on to block <literal>suid</literal>, <literal>dev</literal> and so on. Adding the <literal>user</literal> option reactivates it, since <literal>defaults</literal> includes <literal>nouser</literal>.
							</para>

						</listitem>

					</itemizedlist>

				</listitem>
				 <listitem>
					<para>
						backup: this field is almost always set to <literal>0</literal>. When it is <literal>1</literal>, it tells the <command>dump</command> tool that the partition contains data that is to be backed up.
					</para>

				</listitem>
				 <listitem>
					<para>
						check order: this last field indicates whether the integrity of the filesystem should be checked on boot, and in which order this check should be executed. If it is <literal>0</literal>, no check is conducted. The root filesystem should have the value <literal>1</literal>, while other permanent filesystems get the value <literal>2</literal>.
					</para>

				</listitem>

			</itemizedlist>
			 <example id="example.fstab">
				<title>Example <filename>/etc/fstab</filename> file</title>
				 
<programlisting>
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
# swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0
</programlisting>

			</example>
			 <para>
				The last entry in this example corresponds to a network filesystem (NFS): the <filename>/shared/</filename> directory on the <emphasis>arrakis</emphasis> server is mounted at <filename>/shared/</filename> on the local machine. The format of the <filename>/etc/fstab</filename> file is documented on the <citerefentry><refentrytitle>fstab</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> man page.
			</para>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> Auto-mounting</title>
			 <para>
				The <emphasis>am-utils</emphasis> package provides the <command>amd</command> auto-mounting utility, able to mount removable media on demand when a user attempts to access their usual mount point. It will unmount these devices when no process is accessing them any longer.
			</para>
			 <indexterm>
				<primary><emphasis>am-utils</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><command>amd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>automount</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>autofs</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>automounter</primary>
			</indexterm>
			 <para>
				Other auto-mounting utilities exist, such as <command>automount</command> in the <emphasis>autofs</emphasis> package.
			</para>
			 <para>
				Note also that GNOME, KDE, and other graphical desktop environments work together with <emphasis>udisks</emphasis>, and can automatically mount removable media when they are connected.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.locate-updatedb">
			<title><command>locate</command> and <command>updatedb</command></title>
			 <indexterm>
				<primary><command>locate</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>updatedb</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>mlocate</command></primary>
			</indexterm>
			 <para>
				The <command>locate</command> command can find the location of a file when you only know part of the name. It sends a result almost instantaneously, since it consults a database that stores the location of all the files on the system; this database is updated daily by the <command>updatedb</command> command. There are multiple implementations of the <command>locate</command> command and Debian picked <emphasis role="pkg">mlocate</emphasis> for its standard system.
			</para>
			 <para>
				<command>mlocate</command> is smart enough to only return files which are accessible to the user running the command even though it uses a database that knows about all files on the system (since its <command>updatedb</command> implementation runs with root rights). For extra safety, the administrator can use <varname>PRUNEDPATHS</varname> in <filename>/etc/updatedb.conf</filename> to exclude some directories from being indexed.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-compilation">
		<title>Compiling a Kernel</title>
		 <indexterm>
			<primary>compilation</primary>
			<secondary>of a kernel</secondary>
		</indexterm>
		 <indexterm>
			<primary>kernel</primary>
			<secondary>compilation</secondary>
		</indexterm>
		 <para>
			The kernels provided by Debian include the largest possible number of features, as well as the maximum of drivers, in order to cover the broadest spectrum of existing hardware configurations. This is why some users prefer to recompile the kernel in order to only include what they specifically need. There are two reasons for this choice. First, it may be to optimize memory consumption, since the kernel code, even if it is never used, occupies memory for nothing (and never “goes down” on the swap space, since it is actual RAM that it uses), which can decrease overall system performance. A locally compiled kernel can also limit the risk of security problems since only a fraction of the kernel code is compiled and run.
		</para>
		 <sidebar> <title><emphasis>NOTE</emphasis> Security updates</title>
		 <para>
			If you choose to compile your own kernel, you must accept the consequences: Debian cannot ensure security updates for your custom kernel. By keeping the kernel provided by Debian, you benefit from updates prepared by the Debian Project's security team.
		</para>
		 </sidebar> <para>
			Recompilation of the kernel is also necessary if you want to use certain features that are only available as patches (and not included in the standard kernel version).
		</para>
		 <sidebar> <title><emphasis>GOING FURTHER</emphasis> The Debian Kernel Handbook</title>
		 <indexterm>
			<primary><emphasis role="pkg">debian-kernel-handbook</emphasis></primary>
		</indexterm>
		 <para>
			The Debian kernel teams maintains the “Debian Kernel Handbook” (also available in the <emphasis role="pkg">debian-kernel-handbook</emphasis> package) with comprehensive documentation about most kernel related tasks and about how official Debian kernel packages are handled. This is the first place you should look into if you need more information than what is provided in this section. <ulink type="block" url="http://kernel-handbook.alioth.debian.org" />
		</para>
		 </sidebar> <section id="sect.kernel-compilation-prerequisites">
			<title>Introduction and Prerequisites</title>
			 <para>
				Unsurprisingly Debian manages the kernel in the form of a package, which is not how kernels have traditionally been compiled and installed. Since the kernel remains under the control of the packaging system, it can then be removed cleanly, or deployed on several machines. Furthermore, the scripts associated with these packages automate the interaction with the bootloader and the initrd generator.
			</para>
			 <para>
				The upstream Linux sources contain everything needed to build a Debian package of the kernel. But you still need to install <emphasis role="pkg">build-essential</emphasis> to ensure that you have the tools required to build a Debian package. Furthermore, the configuration step for the kernel requires the <emphasis role="pkg">libncurses5-dev</emphasis> package. Finally, the <emphasis role="pkg">fakeroot</emphasis> package will enable creation of the Debian package without using administrator's rights.
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> The good old days of <emphasis role="pkg">kernel-package</emphasis></title>
			 <indexterm>
				<primary><emphasis role="pkg">kernel-package</emphasis></primary>
			</indexterm>
			 <para>
				Before the Linux build system gained the ability to build proper Debian packages, the recommended way to build such packages was to use <command>make-kpkg</command> from the <emphasis role="pkg">kernel-package</emphasis> package.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-sources">
			<title>获取源代码</title>
			 <indexterm>
				<primary>Linux kernel sources</primary>
			</indexterm>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>sources</secondary>
			</indexterm>
			 <indexterm>
				<primary>source</primary>
				<secondary>of the Linux kernel</secondary>
			</indexterm>
			 <para>
				Like anything that can be useful on a Debian system, the Linux kernel sources are available in a package. To retrieve them, just install the <emphasis role="pkg">linux-source-<replaceable>version</replaceable></emphasis> package. The <command>apt-cache search ^linux-source</command> command lists the various kernel versions packaged by Debian. The latest version is available in the <emphasis role="distribution">Unstable</emphasis> distribution: you can retrieve them without much risk (especially if your APT is configured according to the instructions of <xref linkend="sect.apt-mix-distros" />). Note that the source code contained in these packages does not correspond precisely with that published by Linus Torvalds and the kernel developers; like all distributions, Debian applies a number of patches, which might (or might not) find their way into the upstream version of Linux. These modifications include backports of fixes/features/drivers from newer kernel versions, new features not yet (entirely) merged in the upstream Linux tree, and sometimes even Debian specific changes.
			</para>
			 <para>
				The remainder of this section focuses on the 3.16 version of the Linux kernel, but the examples can, of course, be adapted to the particular version of the kernel that you want.
			</para>
			 <para>
				We assume the <emphasis role="pkg">linux-source-3.16</emphasis> package has been installed. It contains <filename>/usr/src/linux-source-3.16.tar.xz</filename>, a compressed archive of the kernel sources. You must extract these files in a new directory (not directly under <filename>/usr/src/</filename>, since there is no need for special permissions to compile a Linux kernel): <filename>~/kernel/</filename> is appropriate.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>
<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-3.16.tar.xz</userinput></screen>
			 <sidebar> <title><emphasis>CULTURE</emphasis> Location of kernel sources</title>
			 <para>
				Traditionally, Linux kernel sources would be placed in <filename>/usr/src/linux/</filename> thus requiring root permissions for compilation. However, working with administrator rights should be avoided when not needed. There is a <literal>src</literal> group that allows members to work in this directory, but working in <filename>/usr/src/</filename> should be avoided nevertheless. By keeping the kernel sources in a personal directory, you get security on all counts: no files in <filename>/usr/</filename> unknown to the packaging system, and no risk of misleading programs that read <filename>/usr/src/linux</filename> when trying to gather information on the used kernel.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.config-kernel">
			<title>Configuring the Kernel</title>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>configuration</secondary>
			</indexterm>
			 <indexterm>
				<primary>configuration</primary>
				<secondary>of the kernel</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>.config</filename></primary>
			</indexterm>
			 <para>
				The next step consists of configuring the kernel according to your needs. The exact procedure depends on the goals.
			</para>
			 <para>
				When recompiling a more recent version of the kernel (possibly with an additional patch), the configuration will most likely be kept as close as possible to that proposed by Debian. In this case, and rather than reconfiguring everything from scratch, it is sufficient to copy the <filename>/boot/config-<replaceable>version</replaceable></filename> file (the version is that of the kernel currently used, which can be found with the <command>uname -r</command> command) into a <filename>.config</filename> file in the directory containing the kernel sources.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cp /boot/config-3.16.0-4-amd64 ~/kernel/linux-source-3.16/.config</userinput></screen>
			 <para>
				Unless you need to change the configuration, you can stop here and skip to <xref linkend="sect.kernel-build" />. If you need to change it, on the other hand, or if you decide to reconfigure everything from scratch, you must take the time to configure your kernel. There are various dedicated interfaces in the kernel source directory that can be used by calling the <command>make <replaceable>target</replaceable></command> command, where <replaceable>target</replaceable> is one of the values described below.
			</para>
			 <para>
				<command>make menuconfig</command> compiles and executes a text-mode interface (this is where the <emphasis role="pkg">libncurses5-dev</emphasis> package is required) which allows navigating the options available in a hierarchical structure. Pressing the <keycap>Space</keycap> key changes the value of the selected option, and <keycap>Enter</keycap> validates the button selected at the bottom of the screen; <guibutton>Select</guibutton> returns to the selected sub-menu; <guibutton>Exit</guibutton> closes the current screen and moves back up in the hierarchy; <guibutton>Help</guibutton> will display more detailed information on the role of the selected option. The arrow keys allow moving within the list of options and buttons. To exit the configuration program, choose <guibutton>Exit</guibutton> from the main menu. The program then offers to save the changes you've made; accept if you are satisfied with your choices.
			</para>
			 <para>
				Other interfaces have similar features, but they work within more modern graphical interfaces; such as <command>make xconfig</command> which uses a Qt graphical interface, and <command>make gconfig</command> which uses GTK+. The former requires <emphasis role="pkg">libqt4-dev</emphasis>, while the latter depends on <emphasis role="pkg">libglade2-dev</emphasis> and <emphasis role="pkg">libgtk2.0-dev</emphasis>.
			</para>
			 <para>
				When using one of those configuration interfaces, it is always a good idea to start from a reasonable default configuration. The kernel provides such configurations in <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename> and you can put your selected configuration in place with a command like <command>make x86_64_defconfig</command> (in the case of a 64-bit PC) or <command>make i386_defconfig</command> (in the case of a 32-bit PC).
			</para>
			 <sidebar> <title><emphasis>TIP</emphasis> Dealing with outdated <filename>.config</filename> files</title>
			 <para>
				When you provide a <filename>.config</filename> file that has been generated with another (usually older) kernel version, you will have to update it. You can do so with <command>make oldconfig</command>, it will interactively ask you the questions corresponding to the new configuration options. If you want to use the default answer to all those questions you can use <command>make olddefconfig</command>. With <command>make oldnoconfig</command>, it will assume a negative answer to all questions.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-build">
			<title>Compiling and Building the Package</title>
			 <indexterm>
				<primary><command>make deb-pkg</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>NOTE</emphasis> Clean up before rebuilding</title>
			 <para>
				If you have already compiled once in the directory and wish to rebuild everything from scratch (for example because you substantially changed the kernel configuration), you will have to run <command>make clean</command> to remove the compiled files. <command>make distclean</command> removes even more generated files, including your <filename>.config</filename> file too, so make sure to backup it first.
			</para>
			 </sidebar> <para>
				Once the kernel configuration is ready, a simple <command>make deb-pkg</command> will generate up to 5 Debian packages: <emphasis role="pkg">linux-image-<replaceable>version</replaceable></emphasis> that contains the kernel image and the associated modules, <emphasis role="pkg">linux-headers-<replaceable>version</replaceable></emphasis> which contains the header files required to build external modules, <emphasis role="pkg">linux-firmware-image-<replaceable>version</replaceable></emphasis> which contains the firmware files needed by some drivers (this package might be missing when you build from the kernel sources provided by Debian), <emphasis role="pkg">linux-image-<replaceable>version</replaceable>-dbg</emphasis> which contains the debugging symbols for the kernel image and its modules, and <emphasis role="pkg">linux-libc-dev</emphasis> which contains headers relevant to some user-space libraries like GNU glibc.
			</para>
			 <para>
				The <replaceable>version</replaceable> is defined by the concatenation of the upstream version (as defined by the variables <literal>VERSION</literal>, <literal>PATCHLEVEL</literal>, <literal>SUBLEVEL</literal> and <literal>EXTRAVERSION</literal> in the <filename>Makefile</filename>), of the <literal>LOCALVERSION</literal> configuration parameter, and of the <literal>LOCALVERSION</literal> environment variable. The package version reuses the same version string with an appended revision that is regularly incremented (and stored in <filename>.version</filename>), except if you override it with the <literal>KDEB_PKGVERSION</literal> environment variable.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1
</userinput><computeroutput>[...]
$ </computeroutput><userinput>ls ../*.deb
</userinput><computeroutput>../linux-headers-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb
../linux-image-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb
../linux-image-3.16.7-ckt4-falcot-dbg_3.16.7-1_amd64.deb
../linux-libc-dev_3.16.7-1_amd64.deb
</computeroutput></screen>

		</section>
		 <section id="sect.modules-build">
			<title>Compiling External Modules</title>
			 <indexterm>
				<primary>kernel</primary>
				<secondary>external modules</secondary>
			</indexterm>
			 <indexterm>
				<primary>modules</primary>
				<secondary>external kernel modules</secondary>
			</indexterm>
			 <indexterm>
				<primary><command>dkms</command></primary>
			</indexterm>
			 <para>
				Some modules are maintained outside of the official Linux kernel. To use them, they must be compiled alongside the matching kernel. A number of common third party modules are provided by Debian in dedicated packages, such as <emphasis role="pkg">xtables-addons-source</emphasis> (extra modules for iptables) or <emphasis role="pkg">oss4-source</emphasis> (Open Sound System, some alternative audio drivers).
			</para>
			 <para>
				These external packages are many and varied and we won't list them all here; the <command>apt-cache search source$</command> command can narrow down the search field. However, a complete list isn't particularly useful since there is no particular reason for compiling external modules except when you know you need it. In such cases, the device's documentation will typically detail the specific module(s) it needs to function under Linux.
			</para>
			 <para>
				For example, let's look at the <emphasis role="pkg">xtables-addons-source</emphasis> package: after installation, a <filename>.tar.bz2</filename> of the module's sources is stored in <filename>/usr/src/</filename>. While we could manually extract the tarball and build the module, in practice we prefer to automate all this using DKMS. Most modules offer the required DKMS integration in a package ending with a <literal>-dkms</literal> suffix. In our case, installing <emphasis role="pkg">xtables-addons-dkms</emphasis> is all that is needed to compile the kernel module for the current kernel provided that we have the <emphasis role="pkg">linux-headers-*</emphasis> package matching the installed kernel. For instance, if you use <emphasis role="pkg">linux-image-amd64</emphasis>, you would also install <emphasis role="pkg">linux-headers-amd64</emphasis>.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>
<computeroutput>
[...]
Setting up xtables-addons-dkms (2.6-1) ...
Loading new xtables-addons-2.6 DKMS files...
First Installation: checking all kernels...
Building only for 3.16.0-4-amd64
Building initial module for 3.16.0-4-amd64
Done.

xt_ACCOUNT:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/3.16.0-4-amd64/updates/dkms/
[...]
DKMS: install completed.
$ </computeroutput><userinput>sudo dkms status</userinput>
<computeroutput>xtables-addons, 2.6, 3.16.0-4-amd64, x86_64: installed
$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>
<computeroutput>filename:       /lib/modules/3.16.0-4-amd64/updates/dkms/xt_ACCOUNT.ko
license:        GPL
alias:          ipt_ACCOUNT
author:         Intra2net AG &lt;opensource@intra2net.com&gt;
description:    Xtables: per-IP accounting for large prefixes
[...]
</computeroutput></screen>
			 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> module-assistant</title>
			 <indexterm>
				<primary><emphasis role="pkg">module-assistant</emphasis></primary>
			</indexterm>
			 <para>
				Before DKMS, <emphasis role="pkg">module-assistant</emphasis> was the simplest solution to build and deploy kernel modules. It can still be used, in particular for packages lacking DKMS integration: with a simple command like <command>module-assistant auto-install xtables-addons</command> (or <command>m-a a-i xtables-addons</command> for short), the modules are compiled for the current kernel, put in a new Debian package, and that package gets installed on the fly.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-patch">
			<title>选择内核补丁</title>
			 <indexterm>
				<primary>内核</primary>
				<secondary>补丁</secondary>
			</indexterm>
			 <indexterm>
				<primary>内核补丁</primary>
			</indexterm>
			 <para>
				Some features are not included in the standard kernel due to a lack of maturity or to some disagreement with the kernel maintainers. Such features may be distributed as patches that anyone is then free to apply to the kernel sources.
			</para>
			 <para>
				Debian distributes some of these patches in <emphasis role="pkg">linux-patch-*</emphasis> or <emphasis role="pkg">kernel-patch-*</emphasis> packages (for instance, <emphasis role="pkg">linux-patch-grsecurity2</emphasis>, which tightens some of the kernel's security policies). These packages install files in the <filename>/usr/src/kernel-patches/</filename> directory.
			</para>
			 <para>
				To apply one or more of these installed patches, use the <command>patch</command> command in the sources directory then start compilation of the kernel as described above.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-3.16</userinput>
<computeroutput>$ </computeroutput><userinput>make clean</userinput>
<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.0-3.17.1-201410250027.patch.gz | patch -p1</userinput></screen>
			 <para>
				Note that a given patch may not necessarily work with every version of the kernel; it is possible for <command>patch</command> to fail when applying them to kernel sources. An error message will be displayed and give some details about the failure; in this case, refer to the documentation available in the Debian package of the patch (in the <filename>/usr/share/doc/linux-patch-*/</filename> directory). In most cases, the maintainer indicates for which kernel versions their patch is intended.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-installation">
		<title>安装内核</title>
		 <indexterm>
			<primary>installation</primary>
			<secondary>of a kernel</secondary>
		</indexterm>
		 <indexterm>
			<primary>kernel</primary>
			<secondary>installation</secondary>
		</indexterm>
		 <section id="sect.kernel-package">
			<title>Debian 内核包特性</title>
			 <indexterm>
				<primary><filename>vmlinuz</filename></primary>
			</indexterm>
			 <para>
				A Debian kernel package installs the kernel image (<filename>vmlinuz-<replaceable>version</replaceable></filename>), its configuration (<filename>config-<replaceable>version</replaceable></filename>) and its symbols table (<filename>System.map-<replaceable>version</replaceable></filename>) in <filename>/boot/</filename>. The symbols table helps developers understand the meaning of a kernel error message; without it, kernel “oopses” (an “oops” is the kernel equivalent of a segmentation fault for user-space programs, in other words messages generated following an invalid pointer dereference) only contain numeric memory addresses, which is useless information without the table mapping these addresses to symbols and function names. The modules are installed in the <filename>/lib/modules/<replaceable>version</replaceable>/</filename> directory.
			</para>
			 <para>
				The package's configuration scripts automatically generate an initrd image, which is a mini-system designed to be loaded in memory (hence the name, which stands for “init ramdisk”) by the bootloader, and used by the Linux kernel solely for loading the modules needed to access the devices containing the complete Debian system (for example, the driver for SATA disks). Finally, the post-installation scripts update the symbolic links <filename>/vmlinuz</filename>, <filename>/vmlinuz.old</filename>, <filename>/initrd.img</filename> and <filename>/initrd.img.old</filename> so that they point to the latest two kernels installed, respectively, as well as the corresponding initrd images.
			</para>
			 <para>
				Most of those tasks are offloaded to hook scripts in the <filename>/etc/kernel/*.d/</filename> directories. For instance, the integration with <command>grub</command> relies on <filename>/etc/kernel/postinst.d/zz-update-grub</filename> and <filename>/etc/kernel/postrm.d/zz-update-grub</filename> to call <command>update-grub</command> when kernels are installed or removed.
			</para>

		</section>
		 <section id="sect.kernel-installation-with-dpkg">
			<title>Installing with <command>dpkg</command></title>
			 <para>
				Using <command>apt</command> is so convenient that it makes it easy to forget about the lower-level tools, but the easiest way of installing a compiled kernel is to use a command such as <command>dpkg -i <replaceable>package</replaceable>.deb</command>, where <literal><replaceable>package</replaceable>.deb</literal> is the name of a <emphasis role="pkg">linux-image</emphasis> package such as <filename>linux-image-3.16.7-ckt4-falcot_1_amd64.deb</filename>.
			</para>
			 <para>
				The configuration steps described in this chapter are basic and can lead both to a server system or a workstation, and it can be massively duplicated in semi-automated ways. However, it is not enough by itself to provide a fully configured system. A few pieces are still in need of configuration, starting with low-level programs known as the “Unix services”.
			</para>

		</section>

	</section>
</chapter>

