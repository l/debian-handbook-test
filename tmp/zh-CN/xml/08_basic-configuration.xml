<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="basic-configuration" lang="zh-CN">
	<chapterinfo>
		 <keywordset>
			<keyword>配置</keyword>
			 <keyword>本地化</keyword>
			 <keyword>地区设置</keyword>
			 <keyword>网络</keyword>
			 <keyword>名称解析</keyword>
			 <keyword>用户</keyword>
			 <keyword>用户组</keyword>
			 <keyword>账户</keyword>
			 <keyword>命令行解释器</keyword>
			 <keyword>Shell</keyword>
			 <keyword>打印</keyword>
			 <keyword>Bootloader</keyword>
			 <keyword>内核编译</keyword>

		</keywordset>

	</chapterinfo>
	 <title>基础配置：网络，账户，打印……</title>
	 <highlights> <para>
		以 <command>debian-installer</command> 命令安装的电脑是尽可能的可用，但仍有若干服务需要配置。而且，了解修改初始安装进程的配置是件好事。
	</para>
	 </highlights> <para>
		这章综述我们称之为“基础配置”所包括的任何事项：网络、语言、地区、用户、用户组、打印、挂载点等。
	</para>
	 <section id="sect.config-language-support">
		<title>用其他语言进行配置</title>
		 <indexterm>
			<primary>法语环境</primary>
		</indexterm>
		 <para>
			如果你在法语环境下安装了系统，那么默认语言可能会被设置为法语。所以你最好知道你的安装器使用的是什么语言。如果对语言有要求而又设置错误了，你可以自己进行修改。
		</para>
		 <sidebar> <title><emphasis>工具</emphasis> <command>locale</command> 命令显示当前配置</title>
		 <para>
			<command> locale</command> 命令会列出当前配置的语言环境参数（比如日期格式，数字格式），以一组标准环境变量表格的形式呈现当前的语言环境变量配置。
		</para>
		 </sidebar> <section id="sect.default-language">
			<title>设置默认语言</title>
			 <indexterm>
				<primary>地区</primary>
			</indexterm>
			 <indexterm>
				<primary>语言</primary>
			</indexterm>
			 <indexterm>
				<primary><command>locale-gen</command></primary>
			</indexterm>
			 <para>
				一个 locale 指一系列的区域设置。它不仅包括对文字语言的设置，也包括数字格式显示、日期、时间和货币，以及“按字母顺序排列规则”（正确地处理重音字符）。虽然这些参数可以被独立配置，我们仍建议您使用 locale 这个从地区形式最大化匹配一连贯参数的工具。这些 locales 一般以以下格式 <literal><replaceable>语言代码</replaceable>_<replaceable>城市代码</replaceable></literal>，有时后缀也在指定字符集和编码中被使用。这是考虑到同一语言在不同区域之间使用习惯和印刷差异。
			</para>
			 <sidebar> <title><emphasis>文化</emphasis> 字符集</title>
			 <indexterm>
				<primary>字符设置</primary>
			</indexterm>
			 <indexterm>
				<primary>编码</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-1</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-15</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 1</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 9</primary>
			</indexterm>
			 <para>
				历史上看，每一个 locale 都有一个相关联的字符集（一组已知的字符集）和一个特定的编码（为计算机内部的字符表达）。
			</para>
			 <para>
				最广泛使用的字符编码是基于拉丁字母、使用单个 byte 表达一个字符，被限制为最多256个字符。256个字符不足以覆盖所有欧洲语言，因此多编码系统非常有必要，这就是为何我们将 <emphasis>ISO-8859-1</emphasis> （即“Latin 1”）升级为 <emphasis>ISO-8859-15</emphasis> （即“Latin 9”），等等。
			</para>
			 <para>
				Working with foreign languages often implied regular switches between various encodings and character sets. Furthermore, writing multilingual documents led to further, almost intractable problems. Unicode (a super-catalog of nearly all writing systems from all of the world's languages) was created to work around this problem. One of Unicode's encodings, UTF-8, retains all 128 ASCII symbols (7-bit codes), but handles other characters differently. Those are preceded by a specific escape sequence of a few bits, which implicitly defines the length of the character. This allows encoding all Unicode characters on a sequence of one or more bytes. Its use has been popularized by the fact that it is the default encoding in XML documents.
			</para>
			 <indexterm>
				<primary>ASCII</primary>
			</indexterm>
			 <indexterm>
				<primary>UTF-8</primary>
			</indexterm>
			 <indexterm>
				<primary>Unicode</primary>
			</indexterm>
			 <para>
				它是最广泛使用的编码，也是 Debian 发行版系统的默认选项。
			</para>
			 </sidebar> <para>
				<emphasis role="pkg">locales</emphasis> 包括所有应用“本土化”所需要的所有元素。安装过程中，该包将要求使用者选择一系列支持语言。该选择能在使用root帐号运行 <command>dpkg-reconfigure locales</command> 改变。
			</para>
			 <para>
				第一个让您回答的问题是选哪些“ locales ”来支持。选择所有英语国家（所有以<literal>en_</literal>开始的环境）是一种可能。如果主机上有外国用户，打开对应的语言环境支持不要犹豫。所有在本系统被打开支持的语言环境存储在 <filename>/etc/locale.gen</filename> 。它可以被手动编辑，但需要在你做任何改动后运行 <command>locale-gen</command> 使改动生效。该命令将创建新添加的语言环境及其关联文件并移除过期的文件。
			</para>
			 <para>
				第二个问题，标题 “系统环境的默认字符环境”请求设置默认的字符系统。该选择在美国是 <literal>en_US.UTF-8</literal>，英式发音者更习惯于 <literal>en_GB.UTF-8</literal> ，加拿大人喜欢 <literal>en_CA.UTF-8</literal> 或者对于法国人来说 <literal>fr_CA.UTF-8</literal>。<filename>/etc/default/locale</filename> 文件会保存这个变更。该设置将由 PAM 系统写入到所有登录用户会话的 <varname>LANG</varname> 环境变量。
			</para>
			 <indexterm>
				<primary>环境</primary>
			</indexterm>
			 <indexterm>
				<primary>locale</primary>
			</indexterm>
			 <indexterm>
				<primary><varname>LANG</varname></primary>
			</indexterm>
			 <sidebar id="sidebar.intro-pam"> <title><emphasis>幕后</emphasis><filename>/etc/environment</filename> 和 <filename>/etc/default/locale</filename></title>
			 <para>
				<filename>/etc/environment</filename> 文件为 <command>login</command> 、 <command>gdm</command>、 <command>ssh</command> 程序提供正确的环境变量。
			</para>
			 <para>
				90这些应用不直接创建这些变量，而通过 PAM 系统的 <filename>pam_env.so</filename> 模块。PAM（插入式验证模块）是一个提供身份验证、会话初始化和密码管理的模块库。<xref linkend="sect.config-pam" /> 是一个 PAM 配置样式。
			</para>
			 <para>
				The <filename>/etc/default/locale</filename> file works in a similar manner, but contains only the <varname>LANG</varname> environment variable. Thanks to this split, some PAM users can inherit a complete environment without localization. Indeed, it is generally discouraged to run server programs with localization enabled; on the other hand, localization and regional settings are recommended for programs that open user sessions.
			</para>
			 <indexterm>
				<primary>PAM</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>pam_env.so</filename></primary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.keyboard-config">
			<title>键盘配置</title>
			 <indexterm>
				<primary>键盘布局</primary>
			</indexterm>
			 <indexterm>
				<primary> 布局，键盘</primary>
			</indexterm>
			 <para>
				甚至如果键盘布局在终端和图形模式中被设置成不同， Debian 也提供了一个简单的配置让它们两个工作：它基于 debconf 并由<emphasis role="pkg">keyboard-configuration</emphasis> 包实现。使用 <command>dpkg-reconfigure keyboard-configuration</command> 命令来重新设置键盘布局。
			</para>
			 <indexterm>
				<primary><emphasis>终端数据</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>终端工具</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>键盘配置</emphasis></primary>
			</indexterm>
			 <para>
				<indexterm><primary><literal>azerty</literal></primary></indexterm>The questions are relevant to the physical keyboard layout (a standard PC keyboard in the US will be a “Generic 104 key”), then the layout to choose (generally “US”), and then the position of the AltGr key (right Alt). Finally comes the question of the key to use for the “Compose key”, which allows for entering special characters by combining keystrokes. Type successively <keycombo action="seq"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> and produce an e-acute (“é”). All these combinations are described in the <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> file (or another file, determined according to the current locale indicated by <filename>/usr/share/X11/locale/compose.dir</filename>).
			</para>
			 <indexterm>
				<primary><literal>Compose</literal> 键</primary>
			</indexterm>
			 <indexterm>
				<primary><literal> Meta </literal>键</primary>
			</indexterm>
			 <indexterm>
				<primary>key</primary>
				<secondary><literal>Meta</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary>key</primary>
				<secondary><literal>Compose</literal></secondary>
			</indexterm>
			 <para>
				注意，该处说明的是默认键盘布局下图形模式的键盘设定； GNOME 和 KDE 等环境，为每一个用户提供一个键位控制面板去设置他们的喜好键位。面板中也能提供一些特殊键位的扩展选项。
			</para>

		</section>
		 <section id="sect.utf8-migration">
			<title>迁移到 UTF-8</title>
			 <para>
				The generalization of UTF-8 encoding has been a long awaited solution to numerous difficulties with interoperability, since it facilitates international exchange and removes the arbitrary limits on characters that can be used in a document. The one drawback is that it had to go through a rather difficult transition phase. Since it could not be completely transparent (that is, it could not happen at the same time all over the world), two conversion operations were required: one on file contents, and the other on filenames. Fortunately, the bulk of this migration has been completed and we discuss it largely for reference.
			</para>
			 <sidebar> <title><emphasis>文化</emphasis><foreignphrase> 乱码</foreignphrase>以及谬误</title>
			 <para>
				当一个文本发送（或者接收）但是却没有携带编码信息，接收者并不是常常能确切地知道如何去确定一组字节的含义。你通常能通过对文本进行统计获得一些帮助，但是并不是总得到一个确切的答案。当编码系统选择了不同于写入文件时使用的编码时，字节就被曲解了，当你获取它时，最好的结果是一些字符错了，最坏的结果，一些变得完全无法识别了。
			</para>
			 <para>
				Thus, if a French text appears normal with the exception of accented letters and certain symbols which appear to be replaced with sequences of characters like “Ã©” or Ã¨” or “Ã§”, it is probably a file encoded as UTF-8 but interpreted as ISO-8859-1 or ISO-8859-15. This is a sign of a local installation that has not yet been migrated to UTF-8. If, instead, you see question marks instead of accented letters — even if these question marks seem to also replace a character that should have followed the accented letter — it is likely that your installation is already configured for UTF-8 and that you have been sent a document encoded in Western ISO.
			</para>
			 <para>
				一些“简单”的例子。这些例子限定在西方文化下，Unicode（以及 UTF-8）的设计最大兼容基于拉丁语系西方语言的历史编码，允许在部分字符缺失的情况下识别部分文本。
			</para>
			 <para>
				In more complex configurations, which, for example, involve two environments corresponding to two different languages that do not use the same alphabet, you often get completely illegible results — a series of abstract symbols that have nothing to do with each other. This is especially common with Asian languages due to their numerous languages and writing systems. The Japanese word <foreignphrase>mojibake</foreignphrase> has been adopted to describe this phenomenon. When it appears, diagnosis is more complex and the simplest solution is often to simply migrate to UTF-8 on both sides.
			</para>
			 </sidebar> <para>
				As far as file names are concerned, the migration can be relatively simple. The <command>convmv</command> tool (in the package with the same name) was created specifically for this purpose; it allows renaming files from one encoding to another. The use of this tool is relatively simple, but we recommend doing it in two steps to avoid surprises. The following example illustrates a UTF-8 environment containing directory names encoded in ISO-8859-15, and the use of <command>convmv</command> to rename them.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Ic?nes  ?l?ments graphiques  Textes
$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>Starting a dry run without changes...
mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
No changes to your files done. Use --notest to finally rename the files.
$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
Ready!
$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput></screen>
			 <para>
				For the file content, conversion procedures are more complex due to the vast variety of existing file formats. Some file formats include encoding information that facilitates the tasks of the software used to treat them; it is sufficient, then, to open these files and re-save them specifying UTF-8 encoding. In other cases, you have to specify the original encoding (ISO-8859-1 or “Western”, or ISO-8859-15 or “Western (Euro)”, according to the formulations) when opening the file.
			</para>
			 <para>
				For simple text files, you can use <command>recode</command> (in the package of the same name) which allows automatic recoding. This tool has numerous options so you can play with its behavior. We recommend you consult the documentation, the <citerefentry> <refentrytitle>recode</refentrytitle>
				 <manvolnum>1</manvolnum> </citerefentry> man page, or the <citerefentry> <refentrytitle>recode</refentrytitle>
				 </citerefentry> info page (more complete).
			</para>

		</section>

	</section>
	 <section id="sect.network-config">
		<title>配置网络</title>
		 <sidebar id="sidebar.networking-basics"> <title><emphasis>基本知识</emphasis>必要的网络概念（以太网、IP地址、子网、广播）</title>
		 <indexterm>
			<primary>以太网</primary>
		</indexterm>
		 <indexterm>
			<primary>10BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>100BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>1000BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>10GBASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>connector, RJ45</primary>
		</indexterm>
		 <indexterm>
			<primary>RJ45 connector</primary>
		</indexterm>
		 <para>
			Most modern local networks use the Ethernet protocol, where data is split into small blocks called frames and transmitted on the wire one frame at a time. Data speeds vary from 10 Mb/s for older Ethernet cards to 10 Gb/s in the newest cards (with the most common rate currently growing from 100 Mb/s to 1 Gb/s). The most widely used cables are called 10BASE-T, 100BASE-T, 1000BASE-T or 10GBASE-T depending on the throughput they can reliably provide (the T stands for “twisted pair”); those cables end in an RJ45 connector. There are other cable types, used mostly for speeds of 1 Gb/s and above.
		</para>
		 <indexterm>
			<primary>address, IP address</primary>
		</indexterm>
		 <indexterm>
			<primary>IP address</primary>
		</indexterm>
		 <para>
			An IP address is a number used to identify a network interface on a computer on a local network or the Internet. In the currently most widespread version of IP (IPv4), this number is encoded in 32 bits, and is usually represented as 4 numbers separated by periods (e.g. <literal>192.168.0.1</literal>), each number being between 0 and 255 (inclusive, which corresponds to 8 bits of data). The next version of the protocol, IPv6, extends this addressing space to 128 bits, and the addresses are generally represented as a series of hexadecimal numbers separated by colons (e.g., 2001:0db8:13bb:0002:0000:0000:0000:0020, or 2001:db8:13bb:2::20 for short).
		</para>
		 <indexterm>
			<primary>subnet</primary>
		</indexterm>
		 <indexterm>
			<primary>mask</primary>
			<secondary>subnet mask</secondary>
		</indexterm>
		 <indexterm>
			<primary>network</primary>
			<secondary>address</secondary>
		</indexterm>
		 <para>
			A subnet mask (netmask) defines in its binary code which portion of an IP address corresponds to the network, the remainder specifying the machine. In the example of configuring a static IPv4 address given here, the subnet mask, <literal>255.255.255.0</literal> (24 “1”s followed by 8 “0”s in binary representation) indicates that the first 24 bits of the IP address correspond to the network address, and the other 8 are specific to the machine. In IPv6, for readability, only the number of “1”s is expressed; the netmask for an IPv6 network could, thus, be <literal>64</literal>.
		</para>
		 <para>
			The network address is an IP address in which the part describing the machine's number is 0. The range of IPv4 addresses in a complete network is often indicated by the syntax, <emphasis>a.b.c.d/e</emphasis>, in which <emphasis>a.b.c.d</emphasis> is the network address and <emphasis>e</emphasis> is the number of bits affected to the network part in an IP address. The example network would thus be written: <literal>192.168.0.0/24</literal>. The syntax is similar in IPv6: <literal>2001:db8:13bb:2::/64</literal>.
		</para>
		 <indexterm>
			<primary>路由器</primary>
		</indexterm>
		 <indexterm>
			<primary>bridge</primary>
		</indexterm>
		 <para>
			A router is a machine that connects several networks to each other. All traffic coming through a router is guided to the correct network. To do this, the router analyzes incoming packets and redirects them according to the IP address of their destination. The router is often known as a gateway; in this configuration, it works as a machine that helps reach out beyond a local network (towards an extended network, such as the Internet).
		</para>
		 <indexterm>
			<primary>广播</primary>
		</indexterm>
		 <para>
			The special broadcast address connects all the stations in a network. Almost never “routed”, it only functions on the network in question. Specifically, it means that a data packet addressed to the broadcast never passes through the router.
		</para>
		 <para>
			This chapter focuses on IPv4 addresses, since they are currently the most commonly used. The details of the IPv6 protocol are approached in <xref linkend="sect.ipv6" />, but the concepts remain the same.
		</para>
		 </sidebar> <para>
			Since the network is automatically configured during the initial installation, the <filename>/etc/network/interfaces</filename> file already contains a valid configuration. A line starting with <literal>auto</literal> gives a list of interfaces to be automatically configured on boot by <emphasis role="pkg">ifupdown</emphasis> and its <filename>/etc/init.d/networking</filename> init script. This will often be <literal>eth0</literal>, which refers to the first Ethernet card.
		</para>
		 <indexterm>
			<primary>network</primary>
			<secondary>configuration</secondary>
		</indexterm>
		 <indexterm>
			<primary>configuration</primary>
			<secondary>of the network</secondary>
		</indexterm>
		 <indexterm>
			<primary>interface</primary>
			<secondary>network interface</secondary>
		</indexterm>
		 <indexterm>
			<primary><literal>eth0</literal></primary>
		</indexterm>
		 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> NetworkManager</title>
		 <indexterm>
			<primary><emphasis role="pkg">network-manager</emphasis></primary>
		</indexterm>
		 <para>
			If Network Manager is particularly recommended in roaming setups (see <xref linkend="sect.roaming-network-config" />), it is also perfectly usable as the default network management tool. You can create “System connections” that are used as soon as the computer boots either manually with a <filename>.ini</filename>-like file in <filename>/etc/NetworkManager/system-connections/</filename> or through a graphical tool (<command>nm-connection-editor</command>). Just remember to deactivate all entries in <filename>/etc/network/interfaces</filename> if you want Network Manager to handle them. <ulink type="block" url="https://wiki.gnome.org/Projects/NetworkManager/SystemSettings/jessie" /> <ulink type="block" url="https://developer.gnome.org/NetworkManager/0.9/ref-settings.html" />
		</para>
		 </sidebar> <section id="sect.interface-ethernet">
			<title>Ethernet Interface</title>
			 <para>
				If the computer has an Ethernet card, the IP network that is associated with it must be configured by choosing from one of two methods. The simplest method is dynamic configuration with DHCP, and it requires a DHCP server on the local network. It may indicate a desired hostname, corresponding to the <literal>hostname</literal> setting in the example below. The DHCP server then sends configuration settings for the appropriate network.
			</para>
			 <indexterm>
				<primary>以太网</primary>
			</indexterm>
			 <indexterm>
				<primary>DHCP</primary>
			</indexterm>
			 <example id="example.config-dhcp">
				<title>DHCP configuration</title>
				 
<programlisting>
auto eth0
iface eth0 inet dhcp
  hostname arrakis
</programlisting>

			</example>
			 <para>
				A “static” configuration must indicate network settings in a fixed manner. This includes at least the IP address and subnet mask; network and broadcast addresses are also sometimes listed. A router connecting to the exterior will be specified as a gateway.
			</para>
			 <example id="example.static-network">
				<title>Static configuration</title>
				 
<programlisting>
auto eth0
iface eth0 inet static
  address 192.168.0.3
  netmask 255.255.255.0
  broadcast 192.168.0.255
  network 192.168.0.0
  gateway 192.168.0.1
</programlisting>

			</example>
			 <sidebar> <title><emphasis>NOTE</emphasis> Multiple addresses</title>
			 <para>
				It is possible not only to associate several interfaces to a single, physical network card, but also several IP addresses to a single interface. Remember also that an IP address may correspond to any number of names via DNS, and that a name may also correspond to any number of numerical IP addresses.
			</para>
			 <para>
				As you can guess, the configurations can be rather complex, but these options are only used in very special cases. The examples cited here are typical of the usual configurations.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.ppp-rtc">
			<title>Connecting with PPP through a PSTN Modem</title>
			 <indexterm>
				<primary>PPP</primary>
			</indexterm>
			 <indexterm>
				<primary>point to point</primary>
			</indexterm>
			 <indexterm>
				<primary>connection</primary>
				<secondary>by PSTN modem</secondary>
			</indexterm>
			 <indexterm>
				<primary>modem</primary>
				<secondary>PSTN</secondary>
			</indexterm>
			 <para>
				A point to point (PPP) connection establishes an intermittent connection; this is the most common solution for connections made with a telephone modem (“PSTN modem”, since the connection goes over the public switched telephone network).
			</para>
			 <para>
				A connection by telephone modem requires an account with an access provider, including a telephone number, username, password, and, sometimes the authentication protocol to be used. Such a connection is configured using the <command>pppconfig</command> tool in the Debian package of the same name. By default, it sets up a connection named <literal>provider</literal> (as in Internet service provider). When in doubt about the authentication protocol, choose <emphasis>PAP</emphasis>: it is offered by the majority of Internet service providers.
			</para>
			 <indexterm>
				<primary><command>pppconfig</command></primary>
			</indexterm>
			 <indexterm>
				<primary>PAP</primary>
			</indexterm>
			 <para>
				After configuration, it is possible to connect using the <command>pon</command> command (giving it the name of the connection as a parameter, when the default value of <literal>provider</literal> is not appropriate). The link is disconnected with the <command>poff</command> command. These two commands can be executed by the root user, or by any other user, provided they are in the <literal>dip</literal> group.
			</para>
			 <indexterm>
				<primary><command>pon</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>poff</command></primary>
			</indexterm>

		</section>
		 <section id="sect.adsl">
			<title>Connecting through an ADSL Modem</title>
			 <indexterm>
				<primary>connection</primary>
				<secondary>by ADSL modem</secondary>
			</indexterm>
			 <indexterm>
				<primary>modem</primary>
				<secondary>ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>ADSL, modem</primary>
			</indexterm>
			 <para>
				The generic term “ADSL modem” covers a multitude of devices with very different functions. The modems that are simplest to use with Linux are those that have an Ethernet interface (and not only a USB interface). These tend to be popular; most ADSL Internet service providers lend (or lease) a “box” with Ethernet interfaces. Depending on the type of modem, the configuration required can vary widely.
			</para>
			 <section id="sect.adsl-pppoe">
				<title>Modems Supporting PPPOE</title>
				 <indexterm>
					<primary>PPPOE</primary>
				</indexterm>
				 <indexterm>
					<primary><command>pppoeconf</command></primary>
				</indexterm>
				 <para>
					Some Ethernet modems work with the PPPOE protocol (Point to Point Protocol over Ethernet). The <command>pppoeconf</command> tool (from the package with the same name) will configure the connection. To do so, it modifies the <filename>/etc/ppp/peers/dsl-provider</filename> file with the settings provided and records the login information in the <filename>/etc/ppp/pap-secrets</filename> and <filename>/etc/ppp/chap-secrets</filename> files. It is recommended to accept all modifications that it proposes.
				</para>
				 <para>
					Once this configuration is complete, you can open the ADSL connection with the command, <command>pon dsl-provider</command> and disconnect with <command>poff dsl-provider</command>.
				</para>
				 <indexterm>
					<primary><literal>dsl-provider</literal></primary>
				</indexterm>
				 <sidebar> <title><emphasis>TIP</emphasis> Starting <command>ppp</command> at boot</title>
				 <indexterm>
					<primary><command>systemd</command></primary>
				</indexterm>
				 <indexterm>
					<primary><command>init</command></primary>
				</indexterm>
				 <para>
					PPP connections over ADSL are, by definition, intermittent. Since they are usually not billed according to time, there are few downsides to the temptation of keeping them always open. The standard means to do so is to use the init system.
				</para>
				 <para>
					The default init system on <emphasis role="distribution">Jessie</emphasis> is <command>systemd</command>. Adding an automatically restarting task for the ADSL connection is a simple matter of creating a “unit file” such as <filename>/etc/systemd/system/adsl-connection.service</filename>, with contents such as the following:
				</para>
				 
<programlisting>[Unit]
Description=ADSL connection

[Service]
Type=forking
ExecStart=/usr/sbin/pppd call dsl-provider
Restart=always

[Install]
WantedBy=multi-user.target</programlisting>
				 <para>
					Once this unit file has been defined, it needs to be enabled with <command>systemctl enable adsl-connection</command>. Then the loop can be started manually with <command>systemctl start adsl-connection</command>; it will also be started automatically on boot.
				</para>
				 <para>
					On systems not using <command>systemd</command> (including <emphasis role="distribution">Wheezy</emphasis> and earlier versions of Debian), the standard SystemV init works differently. On such systems, all that is needed is to add a line such as the following at the end of the <filename>/etc/inittab</filename> file; then, any time the connection is disconnected, <command>init</command> will reconnect it.
				</para>
				 
<programlisting>
adsl:2345:respawn:/usr/sbin/pppd call dsl-provider
</programlisting>
				 <para>
					For ADSL connections that auto-disconnect on a daily basis, this method reduces the duration of the interruption.
				</para>
				 </sidebar>
			</section>
			 <section id="sect.adsl-pptp">
				<title>Modems Supporting PPTP</title>
				 <indexterm>
					<primary>PPTP</primary>
				</indexterm>
				 <para>
					The PPTP (Point-to-Point Tunneling Protocol) protocol was created by Microsoft. Deployed at the beginning of ADSL, it was quickly replaced by PPPOE. If this protocol is forced on you, see <xref linkend="sect.pptp" />.
				</para>

			</section>
			 <section id="sect.adsl-dhcp">
				<title>Modems Supporting DHCP</title>
				 <para>
					When a modem is connected to the computer by an Ethernet cable (crossover cable) you typically configure a network connection by DHCP on the computer; the modem automatically acts as a gateway by default and takes care of routing (meaning that it manages the network traffic between the computer and the Internet).
				</para>
				 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Crossover cable for a direct Ethernet connection</title>
				 <indexterm>
					<primary>crossover cable</primary>
				</indexterm>
				 <para>
					Computer network cards expect to receive data on specific wires in the cable, and send their data on others. When you connect a computer to a local network, you usually connect a cable (straight or crossover) between the network card and a repeater or switch. However, if you want to connect two computers directly (without an intermediary switch or repeater), you must route the signal sent by one card to the receiving side of the other card, and vice-versa. This is the purpose of a crossover cable, and the reason it is used.
				</para>
				 <para>
					Note that this distinction has become almost irrelevant over time, as modern network cards are able do detect the type of cable present and adapt accordingly, so it won't be unusual that both kinds of cable will work in a given location.
				</para>
				 </sidebar> <para>
					Most “ADSL routers” on the market can be used like this, as do most of the ADSL modems provided by Internet services providers.
				</para>

			</section>

		</section>
		 <section id="sect.roaming-network-config">
			<title>Automatic Network Configuration for Roaming Users</title>
			 <indexterm>
				<primary><emphasis role="pkg">network-manager</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>network</primary>
				<secondary>roaming configuration</secondary>
			</indexterm>
			 <para>
				Many Falcot engineers have a laptop computer that, for professional purposes, they also use at home. The network configuration to use differs according to location. At home, it may be a wifi network (protected by a WPA key), while the workplace uses a wired network for greater security and more bandwidth.
			</para>
			 <para>
				To avoid having to manually connect or disconnect the corresponding network interfaces, administrators installed the <emphasis role="pkg">network-manager</emphasis> package on these roaming machines. This software enables a user to easily switch from one network to another using a small icon displayed in the notification area of their graphical desktop. Clicking on this icon displays a list of available networks (both wired and wireless), so they can simply choose the network they wish to use. The program saves the configuration for the networks to which the user has already connected, and automatically switches to the best available network when the current connection drops.
			</para>
			 <para>
				In order to do this, the program is structured in two parts: a daemon running as root handles activation and configuration of network interfaces and a user interface controls this daemon. PolicyKit handles the required authorizations to control this program and Debian configured PolicyKit in such a way so that members of the netdev group can add or change Network Manager connections.
			</para>
			 <para>
				Network Manager knows how to handle various types of connections (DHCP, manual configuration, local network), but only if the configuration is set with the program itself. This is why it will systematically ignore all network interfaces in <filename>/etc/network/interfaces</filename> for which it is not suited. Since Network Manager doesn't give details when no network connections are shown, the easy way is to delete from <filename>/etc/network/interfaces</filename> any configuration for all interfaces that must be managed by Network Manager.
			</para>
			 <para>
				Note that this program is installed by default when the “Desktop Environment” task is chosen during initial installation.
			</para>
			 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> Configuration by “network profile”</title>
			 <indexterm>
				<primary><emphasis role="pkg">guessnet</emphasis></primary>
			</indexterm>
			 <para>
				More advanced users may want to try the <emphasis role="pkg">guessnet</emphasis> package for automatic network configuration. A group of test scripts determine which network profile should be activated and configure it on the fly.
			</para>
			 <para>
				Users who prefer to manually select a network profile will prefer the <emphasis role="pkg">netenv</emphasis> program, found in the package of the same name.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.hostname-name-service">
		<title>Setting the Hostname and Configuring the Name Service</title>
		 <indexterm>
			<primary>name</primary>
			<secondary>attribution and resolution</secondary>
		</indexterm>
		 <indexterm>
			<primary>assignment of names</primary>
		</indexterm>
		 <para>
			The purpose of assigning names to IP numbers is to make them easier for people to remember. In reality, an IP address identifies a network interface associated with a device such as a network card. Since each machine can have several network cards, and several interfaces on each card, one single computer can have several names in the domain name system.
		</para>
		 <para>
			Each machine is, however, identified by a main (or “canonical”) name, stored in the <filename>/etc/hostname</filename> file and communicated to the Linux kernel by initialization scripts through the <command>hostname</command> command. The current value is available in a virtual filesystem, and you can get it with the <command>cat /proc/sys/kernel/hostname</command> command.
		</para>
		 <indexterm>
			<primary><command>hostname</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> <filename>/proc/</filename> and <filename>/sys/</filename>, virtual filesystems</title>
		 <indexterm>
			<primary><filename>/proc/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>proc</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/sys/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>sys</filename></primary>
		</indexterm>
		 <para>
			The <filename>/proc/</filename> and <filename>/sys/</filename> file trees are generated by “virtual” filesystems. This is a practical means of recovering information from the kernel (by listing virtual files) and communicating them to it (by writing to virtual files).
		</para>
		 <para>
			<filename>/sys/</filename> in particular is designed to provide access to internal kernel objects, especially those representing the various devices in the system. The kernel can, thus, share various pieces of information: the status of each device (for example, if it is in energy saving mode), whether it is a removable device, etc. Note that <filename>/sys/</filename> has only existed since kernel version 2.6.
		</para>
		 </sidebar> <para>
			Surprisingly, the domain name is not managed in the same way, but comes from the complete name of the machine, acquired through name resolution. You can change it in the <filename>/etc/hosts</filename> file; simply write a complete name for the machine there at the beginning of the list of names associated with the address of the machine, as in the following example:
		</para>
		 <informalexample> 
<programlisting>
127.0.0.1     localhost
192.168.0.1   arrakis.falcot.com arrakis
</programlisting>
		 </informalexample> <indexterm>
			<primary><filename>主机</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/etc/hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary>网域</primary>
			<secondary>名称</secondary>
		</indexterm>
		 <indexterm>
			<primary>名称</primary>
			<secondary>网域</secondary>
		</indexterm>
		 <indexterm>
			<primary>NSS</primary>
		</indexterm>
		 <section id="sect.name-resolution">
			<title>名称解析</title>
			 <indexterm>
				<primary>解析</primary>
				<secondary>名称</secondary>
			</indexterm>
			 <indexterm>
				<primary>名称</primary>
				<secondary>解析</secondary>
			</indexterm>
			 <para>
				Linux 的名称解析机制是模块化的且可使用 <filename>/etc/nsswitch.conf</filename> 宣称的数据源。涉及主机名称解析的款目是 <literal>hosts</literal>。缺省，它包括 <literal>files dns</literal>，表示系统先参照 <filename>/etc/hosts</filename> 文件，再参照 DNS 服务器。NIS/NIS+ 或 LDAP 服务器是另个来源选择。
			</para>
			 <sidebar> <title><emphasis>说明</emphasis> NSS 与 DNS</title>
			 <para>
				专门用于查找 DNS (特别是 <command>host</command>) 的命令未使用标准的名称解析机制 (NSS)。也就是，完全未考虑 <filename>/etc/nsswitch.conf</filename>，也不使用 <filename>/etc/hosts</filename>。
			</para>
			 </sidebar> <section id="sect.dns-server-configuration">
				<title>配置 DNS 服务器</title>
				 <indexterm>
					<primary>DNS</primary>
				</indexterm>
				 <indexterm>
					<primary>网域名称服务</primary>
				</indexterm>
				 <para>
					DNS (网域名称服务) 是映射名称至 IP 地址的分布式阶层服务，同时也反向映射。尤其是，把人可阅读的名称，如 <literal>www.eyrolles.com</literal> 映射至实际的 IP 地址 <literal>213.244.11.247</literal>。
				</para>
				 <para>
					必须先设置 DNS 服务器，才能用到 DNS 信息。Falcot 公司自设该服务器，但个人用户可能使用 ISP 提供的 DNS 服务器。
				</para>
				 <indexterm>
					<primary><filename>resolv.conf</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><literal>nameserver</literal></primary>
				</indexterm>
				 <para>
					DNS 服务器的用法在 <filename>/etc/resolv.conf</filename> 内，每个一列，在 IP 地址前有 <literal>nameserver</literal> 键词，如下：
				</para>
				 
<programlisting>
nameserver 212.27.32.176
nameserver 212.27.32.177
nameserver 8.8.8.8</programlisting>
				 <para>
					网络由 NetworkManager 管理或经由 DHCP 配置时，可以自动处理 (与覆写) <filename>/etc/resolv.conf</filename> 文件。
				</para>

			</section>
			 <section id="sect.etc-hosts">
				<title><filename>/etc/hosts</filename> 文件</title>
				 <indexterm>
					<primary><filename>主机</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/hosts</filename></primary>
				</indexterm>
				 <para>
					地区网络没洧名称服务器时，仍可以在保留给地区网络的 <filename>/etc/hosts</filename> 文件内，创建 IP 地址与主机名称的小型对照表。此文件的语法极简单：每列一个固定 IP 地址，然后是相关的名称 (第一个是 “完全合格”，表示包括网域名称)。
				</para>
				 <para>
					即使网络停摆或 DNS 服务器不通仍可近用此文件，但祗适用于在地区网络所有机器重制的内容。即使是极微小的变动，都需要更新各地所有的文件。所以， <filename>/etc/hosts</filename> 通常祗包括最重要的款目。
				</para>
				 <para>
					这个文件对未连上互联网的小型网络是够用的，5 部以内的机器，建议安装一个 DNS 服务器较佳。
				</para>
				 <sidebar> <title><emphasis>秘诀</emphasis> 绕过 DNS</title>
				 <para>
					某些应用程序先检查 <filename>/etc/hosts</filename> 文件才查找 DNS，与 DNS 送回数据不同的部份，可以先保存在这里，并略过 DNS 的名称解析。
				</para>
				 <para>
					修改 DNS 但尚未布署前，这种做法可以测试网站名称与 IP 地址的对应性。
				</para>
				 <para>
					另一个可能用法是把流量转移至指定的区域主机，避免大流量进入指定的主机。例如，可以绕过专供广告使用的服务器主机名称，让结果更顺畅、少些干扰。
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.user-group-databases">
		<title>用户与群组数据库</title>
		 <indexterm>
			<primary>用户</primary>
			<secondary>数据库</secondary>
		</indexterm>
		 <indexterm>
			<primary>群组</primary>
			<secondary>数据库</secondary>
		</indexterm>
		 <indexterm>
			<primary>数据库</primary>
			<secondary>用户</secondary>
		</indexterm>
		 <indexterm>
			<primary>数据库</primary>
			<secondary>群组</secondary>
		</indexterm>
		 <para>
			用户清单通常保存在 <filename>/etc/passwd</filename> 文件内，把编码后的密码保存在 <filename>/etc/shadow</filename> 文件内。这两个文件都是纯文本档，以简单的格式保存，可以用文本编辑器读取与修改。每个用户占一列，其字段以冒号区隔 (“<literal>:</literal>”)。
		</para>
		 <sidebar> <title><emphasis>说明</emphasis> 编辑系统文件</title>
		 <para>
			本章讨论的系统文件都是纯文本档，可以用文本编辑器处理。这些文件对核心系统的运作极为重要，编辑该等文件时多加慎重不会错的。首先，先复制或备份原文件。第二，在服务器或多人可同时近用该等文件的机器上，多费心以防止文件损坏。
		</para>
		 <para>
			为了达成此目标，最好使用 <command>vipw</command> 命令编辑 <filename>/etc/passwd</filename> 文件，或使用 <command>vigr</command> 命令编辑 <filename>/etc/group</filename> 文件。这些命令会先锁住该等文件再运行文本编辑器， (缺省使用 <command>vi</command> 命令，除非 <varname>EDITOR</varname> 环境变量有其他的设置)。加上 <literal>-s</literal> 选项可同时编辑对应的 <foreignphrase>shadow</foreignphrase> 文件。
		</para>
		 </sidebar> <sidebar> <title><emphasis>基本</emphasis> Crypt，单向的函数</title>
		 <indexterm>
			<primary>crypt</primary>
		</indexterm>
		 <para>
			<command>crypt</command> 是单向函数以特别的方法把字符串 (<varname>A</varname>) 转换成另个字符串 (<varname>B</varname>)，转换后无法回复成 <varname>A</varname> 经由 <varname>B</varname>。辨识 <varname>A</varname> 的唯一方法是逐一测试所有可能的值，查验等同于 <varname>B</varname> 的结果。最多可输入 8 个字符 (字符串 <varname>A</varname>) 然后产生 13 个字符的可打印 ASCII 字符 (字符串 <varname>B</varname>)。
		</para>
		 </sidebar> <section id="sect.etc-passwd">
			<title>用户清单：<filename>/etc/passwd</filename></title>
			 <para>
				在 <filename>/etc/passwd</filename> 文件内的字段清单：
			</para>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/passwd</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>uid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>gid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>GECOS</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>login</literal></primary>
			</indexterm>
			 <itemizedlist>
				<listitem>
					<para>
						登录，例如 <literal>rhertzog</literal>；
					</para>

				</listitem>
				 <listitem>
					<para>
						password：就是密码加密的单向函数 (<command>crypt</command>)，使用 <literal>DES</literal>、<literal>MD5</literal>、<literal>SHA-256</literal> 或 <literal>SHA-512</literal>。以特别符号 “<literal>x</literal>” 表示加密后的密码保存在<filename>/etc/shadow</filename>；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uid</literal>：用于辨识个别用户的不重复数字；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>：用户主要群组 (Debian 的默认值系为每个用户创建一个群组) 的不重复号码；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>GECOS</literal>：通常保存用户全名的数据栏；
					</para>

				</listitem>
				 <listitem>
					<para>
						登录文件夹，用于保存用户的个人文件 (环境变量 <varname>$HOME</varname> 通常指向此处)；
					</para>

				</listitem>
				 <listitem>
					<para>
						登录时运行的程序。通常是命令解译器 (shell)，若指定为 <command>/bin/false</command> (不做任何事并立即回到控制)，则用户无法登录。
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>基本</emphasis> Unix 群组</title>
			 <indexterm>
				<primary>群组</primary>
			</indexterm>
			 <para>
				Unix 群组是包括多个用户的实体，以集成授权系统可以共享文件 (具有同样的权限)。可以限定程序供指定的群组使用。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-shadow">
			<title>隐藏与加密的密码档：<filename>/etc/shadow</filename></title>
			 <indexterm>
				<primary><filename>shadow</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/shadow</filename></primary>
			</indexterm>
			 <para>
				The <filename>/etc/shadow</filename> 文件含以下的字段：
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						登录；
					</para>

				</listitem>
				 <listitem>
					<para>
						加密的密码；
					</para>

				</listitem>
				 <listitem>
					<para>
						管理密码期限的字段。
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>文档</emphasis> <filename>/etc/passwd</filename>、<filename>/etc/shadow</filename> 与 <filename>/etc/group</filename> 文件格式</title>
			 <para>
				这些格式记录在下列的手册页面：<citerefentry><refentrytitle>passwd</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>、<citerefentry><refentrytitle>shadow</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>、与 <citerefentry><refentrytitle>group</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>。
			</para>
			 </sidebar> <sidebar> <title><emphasis>安全</emphasis> <filename>/etc/shadow</filename> 文件安全</title>
			 <para>
				<filename>/etc/shadow</filename>，不同于它的分身，<filename>/etc/passwd</filename>，不能被一般用户读取。保存在 <filename>/etc/passwd</filename> 内的加密后密码可被任何人读取；破坏者可以用 “暴力” 法破坏它们，以常见的编码字符破解。这种攻击方式 — 称为 "字典攻击" — 对于使用 <filename>/etc/shadow</filename> 的系统是无效的。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.account-modification">
			<title>修改既有的帐号或密码</title>
			 <indexterm>
				<primary><command>chsh</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chfn</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chage</command></primary>
			</indexterm>
			 <indexterm>
				<primary>密码</primary>
			</indexterm>
			 <para>
				以下的命令允许修改用户数据库内的特定字段数据：<command>passwd</command> 允许用户更改自己的密码，并更新 <filename>/etc/shadow</filename> 文件；<command>chfn</command> (CHange Full Name)，保留给超级用户 (root) 专用，修改 <literal>GECOS</literal> 字段。<command>chsh</command> (CHange SHell) 允许用户变更自己的登录 shell，但祗限列名在 <filename>/etc/shells</filename> 之内；另一方面，管理者不受此限，且可设置任何 shell。
			</para>
			 <para>
				最后，<command>chage</command> (CHange AGE) 命令允许管理者变更密码的有效期 (<literal>-l <replaceable>用户</replaceable></literal> 选项列出现在的设置)。以 <command>passwd -e <replaceable>用户</replaceable></command> 命令强迫密码失效，要求用户登录时变更密码才能继续使用。
			</para>

		</section>
		 <section id="sect.disabling-account">
			<title>帐号禁用</title>
			 <indexterm>
				<primary>禁用帐号</primary>
			</indexterm>
			 <indexterm>
				<primary>帐号</primary>
				<secondary>禁用</secondary>
			</indexterm>
			 <para>
				有时需要 “禁用一个帐号” (关闭某用户)，基于纪律考量、调查、或用户太久未登录。被禁用的帐号表示该用户不能登录或近用该机器。帐号还在机器内且文件与数据都未被删除木；祗是不能使用。以 <command>passwd -l <replaceable>用户</replaceable></command> (锁定) 命令就能够达成。以同样的方式另个选项 <literal>-u</literal> (解锁) 就可恢复该帐号。
			</para>
			 <sidebar id="sidebar.intro-nss"> <title><emphasis>下一步</emphasis> NSS 与系统数据库</title>
			 <indexterm>
				<primary>NSS</primary>
			</indexterm>
			 <indexterm>
				<primary>姓名服务切换</primary>
			</indexterm>
			 <para>
				与其使用文件管理用户与群组清单，还可使用其他数据库类型，诸如 LDAP 或 <command>db</command>，借由适当的 NSS (Name Service Switch 姓名服务切换) 模块。可用的模块列在 <filename>/etc/nsswitch.conf</filename> 文件内，在 <literal>passwd</literal>、<literal>shadow</literal> 与 <literal>group</literal> 款目下。LDAP 下的 NSS 模块使用法，见 <xref linkend="sect.config-nss" />。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-group">
			<title>群组清单：<filename>/etc/group</filename></title>
			 <para>
				群组列在 <filename>/etc/group</filename> 文件内，单纯的文本数据库类似 <filename>/etc/passwd</filename> 文件，包括以下的字段：
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						群组名称；
					</para>

				</listitem>
				 <listitem>
					<para>
						密码 (选项)：加入群组会用到 (以 <command>newgrp</command> 或 <command>sg</command> 命令，见专栏 <xref linkend="sidebar.working-with-several-groups" />)；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>：不重复的群组辨识码；
					</para>

				</listitem>
				 <listitem>
					<para>
						成员清单：属于此群组的用户名清单，以逗点区隔。
					</para>

				</listitem>

			</itemizedlist>
			 <para>
			</para>
			 <sidebar id="sidebar.working-with-several-groups"> <title><emphasis>基本</emphasis> 在多个群组工作</title>
			 <indexterm>
				<primary><command>newgrp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sg</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>id</command></primary>
			</indexterm>
			 <indexterm>
				<primary>群组</primary>
				<secondary>改变</secondary>
			</indexterm>
			 <para>
				最终用户可能参加多个群组；其中一个是自己的 “主要群组”。用户自己的主要群组，用户初始配置时自动产生的默认值。用户添加的文件自动属于该读者，以及其主要群组。这种方式并不完全合意；例如，用户需要在自己主要群组之外的文件夹工作，与其他群组共享其文件。在这种情况下，用户需以命令：<command>newgrp</command> 变更其主要群组，产生新的 shell，或以 <command>sg</command> 命令，使用其他群组。这些命令也允许用户加入其他群组。若该等群组受密码保护，则需先取得密码才能运行该等命令。
			</para>
			 <para>
				用户还可以设置文件夹的 <literal>setgid</literal> 位，让该文件夹内的文件自动属于特定群组。详情见专栏 <xref linkend="sidebar.setgid-dir" />。
			</para>
			 <para>
				<command>id</command> 命令显示用户现在的状态，包括个人辨识码 (<varname>uid</varname> 变量)、现在的主要群组 (<varname>gid</varname> variable)、以及其所属群组的清单 (<varname>groups</varname> 变量)。
			</para>
			 </sidebar> <indexterm>
				<primary><filename>group</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/group</filename></primary>
			</indexterm>
			 <para>
				<command>addgroup</command> 与 <command>delgroup</command> 命令可以添加或删除群组。<command>groupmod</command> 命令修改群组的信息 (其 <literal>gid</literal> 或辨识码)。命令 <command>passwd -g <replaceable>group</replaceable></command> 可变更群组的密码，<command>passwd -r -g <replaceable>group</replaceable></command> 命令可删除群组的密码。
			</para>
			 <indexterm>
				<primary><command>addgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>delgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>groupmod</command></primary>
			</indexterm>
			 <indexterm>
				<primary>群组</primary>
				<secondary>添加</secondary>
			</indexterm>
			 <indexterm>
				<primary>添加</primary>
				<secondary>群组</secondary>
			</indexterm>
			 <indexterm>
				<primary>群组</primary>
				<secondary>删除</secondary>
			</indexterm>
			 <indexterm>
				<primary>删除群组</primary>
			</indexterm>
			 <sidebar> <title><emphasis>秘诀</emphasis> <command>getent</command></title>
			 <indexterm>
				<primary><command>getent</command></primary>
			</indexterm>
			 <para>
				<command>getent</command> (取得款目的意思 get entries) 命令使用适当的程序库函数，调用配置于 <filename>/etc/nsswitch.conf</filename> 文件的 NSS 模块，以标准方式检查系统数据库。此命令需要一个或两个参数：被检查的数据库名称、以及可能的搜索键词。因此，<command>getent passwd rhertzog</command> 命令将从用户 <literal>rhertzog</literal> 中给予用户数据库。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.creating-accounts">
		<title>添加帐号</title>
		 <indexterm>
			<primary>帐号</primary>
			<secondary>添加</secondary>
		</indexterm>
		 <indexterm>
			<primary>添加</primary>
			<secondary>用户帐号</secondary>
		</indexterm>
		 <para>
			设置新机器后管理者需做的第一件事就是添加用户帐号。以 <command>adduser</command> 命令添加用户的名称，做为其参数。
		</para>
		 <indexterm>
			<primary><command>adduser</command></primary>
		</indexterm>
		 <para>
			<command>adduser</command> 命令在添加帐号前先询问若干问题，但其使用方式相当直觉。 <filename>/etc/adduser.conf</filename> 是它的配置档，包括有趣的设置：可用于自动设置用户的额度、或改变用户帐号的位置；后者较少使用，但有多个用户且需区隔该等帐号于若干硬盘时，就是很好用的工具。也可选择不同的 shell 为默认值。
		</para>
		 <sidebar> <title><emphasis>基本</emphasis> 额度</title>
		 <indexterm>
			<primary>额度</primary>
		</indexterm>
		 <para>
			“额度” 指的是用户在此机器可使用的资源上限。通常指的是磁盘空间。
		</para>
		 </sidebar> <para>
			添加帐号时，把用户的家目录置于 <filename>/etc/skel/</filename> 模皮。提供用户一组标准的文件夹与配置文件。
		</para>
		 <indexterm>
			<primary>群组</primary>
			<secondary>添加用户</secondary>
		</indexterm>
		 <indexterm>
			<primary>添加群组的用户</primary>
		</indexterm>
		 <para>
			有的时候，把用户加入群组 (除了自己缺省的 “主要” 群组) 以取得额外的权限。例如，在 <emphasis>audio</emphasis> 群组内的用户可以近用该群组内的音效设备 (见专栏 <xref linkend="sidebar.special-files" />)。以 <command>adduser <replaceable>user</replaceable> <replaceable>group</replaceable></command> 命令就能把用户加入该群组。
		</para>
		 <sidebar id="sidebar.special-files"> <title><emphasis>基本</emphasis> 近用设备的权限</title>
		 <indexterm>
			<primary>设备</primary>
			<secondary>近用权限</secondary>
		</indexterm>
		 <indexterm>
			<primary>文件</primary>
			<secondary>特别</secondary>
		</indexterm>
		 <indexterm>
			<primary>模式</primary>
			<secondary>字符</secondary>
		</indexterm>
		 <indexterm>
			<primary>模式</primary>
			<secondary>区块</secondary>
		</indexterm>
		 <indexterm>
			<primary>区块，模块</primary>
		</indexterm>
		 <indexterm>
			<primary>字符，模块</primary>
		</indexterm>
		 <indexterm>
			<primary>特别，文件</primary>
		</indexterm>
		 <indexterm>
			<primary><command>mknod</command></primary>
		</indexterm>
		 <para>
			每个周边硬件设备在 Unix 之下，都是一个保存在 <filename>/dev/</filename> (DEVices) 的特别文件。根据设备的特性有两种特别文件：“字符模式” 与 “区块模式” 文件，每个模式都只有固定数量的操作数。字符模式限制读/写运算，区块模式还允许搜索可得的数据。最后，每个特别文件有两个数字 (“主要” 与 “次要”) 供核心辨识该设备。这种文件以 <command>mknod</command> 命令添加，包括符号名称 (人类可以理解的符号)。
		</para>
		 <para>
			特别文件的权限映射至近用设备本身的权限。因此，<filename>/dev/mixer</filename> 这个文件代表混音器，只有根用户与 <literal>audio</literal> 群组的用户拥有读/取权限。且只有该等用户才能操作混音器。
		</para>
		 <para>
			经由 <emphasis role="pkg">udev</emphasis>、<emphasis role="pkg">consolekit</emphasis> 与 <emphasis role="pkg">policykit</emphasis> 指令，用户就可以直接操作 (不经由网络) 这些设备。
		</para>
		 </sidebar>
	</section>
	 <section id="sect.shell-environment">
		<title>Shell 环境</title>
		 <para>
			命令解译器 (或 shells) 是用户接触电脑的第一个点，必须足够友善。大部份的人使用初始设置的脚本配置其行为 (自动完成、提示字符等)。
		</para>
		 <indexterm>
			<primary>命令行接口</primary>
		</indexterm>
		 <indexterm>
			<primary>命令解译器</primary>
		</indexterm>
		 <indexterm>
			<primary>shell介绍</primary>
		</indexterm>
		 <indexterm>
			<primary><command>bash</command></primary>
		</indexterm>
		 <para>
			<command>bash</command> 是标准的 shell，使用 <filename>/etc/bash.bashrc</filename> 初始脚本做为 “交互” shells，并以 <filename>/etc/profile</filename> 做为 “登录” shells。
		</para>
		 <sidebar> <title><emphasis>基本</emphasis> 登录 shell 与 (非) 交互 shell</title>
		 <para>
			简单说，不论在地登录或使用 <command>ssh</command> 远程登录，或以 <command>bash --login</command> 命令登录，都启用登录 shell。在 登录或非登录 shell 里，该 shell 必须是交互的 (例如在 <command>xterm</command>-type 终端机内)；或非交互式 (使用运行式脚本)。
		</para>
		 </sidebar> <sidebar> <title><emphasis>发现</emphasis> 其他 shells、其他脚本</title>
		 <para>
			命令解译器有自己的语法及其配置文件。因此，<command>zsh</command> 使用 <filename>/etc/zshrc</filename> 与 <filename>/etc/zshenv</filename>；<command>csh</command> 使用 <filename>/etc/csh.cshrc</filename>、<filename>/etc/csh.login</filename> 与 <filename>/etc/csh.logout</filename>。这些程序的手册页面详述其用法。
		</para>
		 <indexterm>
			<primary><command>zsh</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>csh</command></primary>
		</indexterm>
		 </sidebar> <para>
			<command>bash</command> 启用 <filename>/etc/bash.bashrc</filename> 文件 (未评论的几列) 内的 “自动完成”。
		</para>
		 <sidebar> <title><emphasis>基本</emphasis> 自动补完</title>
		 <indexterm>
			<primary>自动补完</primary>
		</indexterm>
		 <para>
			若干命令解译器提供补完功能，即键入命令前几个字后，用户按 <keycap>Tab</keycap> 后，shell 自动补完命令名称或参数。用户的工作更有效率且更少错误。
		</para>
		 <para>
			此函数极有用并富弹性。可根据每个命令分别配置。因此，<command>apt-get</command> 之后的第一个参数，可根据此命令的语法布建，即使未映射任何文件 (在本例中，可能的选择为 <literal>install</literal>、<literal>remove</literal>、<literal>upgrade</literal>等)。
		</para>
		 </sidebar> <sidebar> <title><emphasis>基本</emphasis> 波浪号，回到家文件夹的捷径</title>
		 <indexterm>
			<primary>~</primary>
		</indexterm>
		 <indexterm>
			<primary>波浪号</primary>
		</indexterm>
		 <para>
			波浪号通常用于表示环境变量 <varname>HOME</varname> 指向 (就是用户的家文件夹，如 <filename>/home/rhertzog/</filename>) 的文件夹。命令解译器自动取代：<filename>~/hello.txt</filename> 就是 <filename>/home/rhertzog/hello.txt</filename>。
		</para>
		 <para>
			波浪号也可近用至另个用户的家文件夹。因此，<filename>~rmas/bonjour.txt</filename> 等于 <filename>/home/rmas/bonjour.txt</filename>。
		</para>
		 </sidebar> <para>
			除了这些常见的脚本，用户还可以创建自己的 <filename>~/.bashrc</filename> 与 <filename>~/.bash_profile</filename> 来配置其 shell。常见的改变是添加别名；即自动取代运行的命令，以加速命令的效率。例如，添加 <literal>la</literal> 别名取代 <command>ls -la | less</command> 命令后，祗需键入 <command>la</command> 就能查看文件夹内容的详情。
		</para>
		 <sidebar> <title><emphasis>基本</emphasis> 环境变量</title>
		 <indexterm>
			<primary>环境</primary>
			<secondary>环境变量</secondary>
		</indexterm>
		 <indexterm>
			<primary>变量，环境</primary>
		</indexterm>
		 <para>
			环境变量保存供 shell 或其他程序使用的全域设置。它们是与环境相关的 (每个进程都有自己的环境变量) 但可继承的。最后这个特性让登录 shell 时可以声明继承所有程序的变量。
		</para>
		 </sidebar> <para>
			设置缺省的环境变量是 shell 配置的重要工作。除了把变量指定给 shell 之外，还可以放在 <filename>/etc/environment</filename> 文件内，以备供启始 shell 的其他程序使用。设置的变量通常包括 <varname>ORGANIZATION</varname>，包括公司或组织的名称；以及 <varname>HTTP_PROXY</varname>，指示 HTTP 代理服务器的位置。
		</para>
		 <sidebar> <title><emphasis>秘诀</emphasis> 所有的 shells 拥有相同的配置</title>
		 <para>
			用户通常以相同的方式登录与交互 shell。所以，从 <filename>~/.bashrc</filename> 里的 <filename>~/.bash_profile</filename> 文件选择解译器 (或 “来源”) 的内容。也可使用适用于所有用户的文件 (调用 <filename>/etc/bash.bashrc</filename> 源自 <filename>/etc/profile</filename>)。
		</para>
		 </sidebar>
	</section>
	 <section id="sect.config-printing">
		<title>列表机配置</title>
		 <indexterm>
			<primary>配置</primary>
			<secondary>打印</secondary>
		</indexterm>
		 <indexterm>
			<primary>打印</primary>
			<secondary>配置</secondary>
		</indexterm>
		 <para>
			配置打印机是管理者与用户头痛的项目之一。感谢 IPP 协定 (Internet Printing Protocol) 的自由打印机服务器 <emphasis role="pkg">cups</emphasis>，这些头痛已过去了。
		</para>
		 <indexterm>
			<primary>IPP</primary>
		</indexterm>
		 <indexterm>
			<primary>Internet Printing Protocol</primary>
		</indexterm>
		 <indexterm>
			<primary><command>cups</command></primary>
		</indexterm>
		 <para>
			此程序分散在若干 Debian 套件中：<emphasis role="pkg">cups</emphasis> 是中央印表服务器；<emphasis role="pkg">cups-bsd</emphasis> 是使用传统 BSD 打印系统 (<command>lpd</command> 后台进程、<command>lpr</command> 与 <command>lpq</command> 等命令) 命令的兼容层；<emphasis role="pkg">cups-client</emphasis> 包括一群与服务器交互 (拦阻或放行打印机、查看或删除进行中的印表工作等) 的程序；最后，<emphasis role="pkg">cups-driver-gutenprint</emphasis> 包括给 <command>cups</command> 使用的其他打印机驱动程序集。
		</para>
		 <indexterm>
			<primary><command>lpr</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpq</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>社区</emphasis> CUPS</title>
		 <indexterm>
			<primary>CUPS</primary>
		</indexterm>
		 <indexterm>
			<primary>通用 Unix 打印系统</primary>
		</indexterm>
		 <para>
			CUPS (通用 Unix 打印系统, Common Unix Printing System) 是苹果公司管理的计划 (与商标)。<ulink type="block" url="http://www.cups.org/" />
		</para>
		 </sidebar> <para>
			配置这些套件后，可经由网页接口进入本地地址就能管理 <command>cups</command>：<literal>http://localhost:631/</literal>。可以添加、移除与管理打印机 (包括网络打印机)。也可以在桌面环境以图形接口管理 <command>cups</command>。最后，还有 <command>system-config-printer</command> 图形接口 (来自同名的 Debian 套件) 可用。
		</para>
		 <indexterm>
			<primary><command>cups</command></primary>
			<secondary>管理</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>说明</emphasis> 过时的 <filename>/etc/printcap</filename></title>
		 <para>
			<emphasis>cups</emphasis> 不再使用已经过时的 <filename>/etc/printcap</filename> 文件。从此文件取得的可用打印机已过时不合用。为了避免此麻燸，应删除此文件并链接 (见专栏 <xref linkend="sidebar.symbolic-link" />) 至 <filename>/var/run/cups/printcap</filename>，由 <emphasis>cups</emphasis> 维护该文件以确保其兼容性。
		</para>
		 <indexterm>
			<primary><filename>printcap</filename></primary>
		</indexterm>
		 </sidebar>
	</section>
	 <section id="sect.config-bootloader">
		<title>配置 Bootloader</title>
		 <indexterm>
			<primary>加载器</primary>
			<secondary>引导程序</secondary>
		</indexterm>
		 <indexterm>
			<primary>引导程序</primary>
		</indexterm>
		 <para>
			或许已经运作了，但最好知道如何配置与安装加载启动器，万一它不在 Master Boot Record 中。安装 Windows 等其他操作系统后，很可能出现这种情况。以下的信息在必要时可协助修改加载启动器配置。
		</para>
		 <sidebar> <title><emphasis>基本</emphasis> Master boot record</title>
		 <indexterm>
			<primary>MBR</primary>
		</indexterm>
		 <indexterm>
			<primary>Master Boot Record</primary>
		</indexterm>
		 <para>
			主引导记录 (Master Boot Record, MBR) 位于第一颗磁盘的最前方 512 字节，首先被 BIOS 加载，再启动操作系统。一般来说，由主引导记录安装启动程序，移除稍早的内容。
		</para>
		 </sidebar> <section id="sect.identify-disks">
			<title>辨识磁盘</title>
			 <sidebar> <title><emphasis>文化</emphasis> <emphasis>udev</emphasis> 与 <filename>/dev/</filename></title>
			 <para>
				<filename>/dev/</filename> 文件夹习惯保存被称为 “特殊的” 文件，用于代表系统的周边设备 (见专栏 <xref linkend="sidebar.special-files" />)。曾经纳入所有可能用到的特殊文件。这种处理方式有若干缺点，限制设备数量是其中之一，每种设备祗能有一个 (因为清单名称被限制)，且不可能知道实际上该用那个特殊文件。
			</para>
			 <para>
				如今，以动态方式管理特殊的文件，并且更适合热切换的电脑设备。核心与 <emphasis>udev</emphasis> 合作在需要的时候添加与删除文件以映射出现或消失的设备。所以，<filename>/dev/</filename> 不需要维持不变，反而采用 RAM 保存的文件系统清除或纳入相关的款目。
			</para>
			 <para>
				核心与添加的设备沟通，并发给主要/次要号码以供辨识。以 <command>udevd</command> 命令可以添加特殊的文件并授权使用它。也可添加别名运行其他的工作 (诸如初始化或登录工作)。<command>udevd</command> 命令的行为由一组 (可客制化) 的规则驱动。
			</para>
			 <para>
				动态给予名称，就能够让同名称永远指向特定设备，不必在意链接的设备或顺序，尤其在使用 USB 周边时更为便利。第一个磁盘的第一个区块称为 <filename>/dev/sda1</filename> 可供向后兼容，喜欢的话也可称为 <filename>/dev/root-partition</filename>，或两者共用，因为 <command>udevd</command> 可以配置成自动添加符号链接。
			</para>
			 <para>
				过去在需要进入特定设备文件时，部份的核心模块无法自动加载。现在情况已变了，周边设备的特殊文件于加载模块时才会存在；所以问题不大，受惠于自动侦测硬件，大部份模块都可于启动时加载。但对于侦测不到的周边 (诸如极旧的磁盘机或 PS/2 鼠标)，则无效。在此情况下，就需添加 <literal>floppy</literal>、<literal>psmouse</literal> 与 <literal>mousedev</literal> 等模块至 <filename>/etc/modules</filename> 才能于启动时强迫加载。
			</para>
			 </sidebar> <indexterm>
				<primary>硬盘，名称</primary>
			</indexterm>
			 <indexterm>
				<primary>名称</primary>
				<secondary>硬式磁盘机</secondary>
			</indexterm>
			 <para>
				配置启动程序必须辨认硬盘及其分区。Linux 使用 “block” 特殊文件保存在 <filename>/dev/</filename> 文件夹内。因为 Debian <emphasis role="distribution">Squeeze</emphasis> 版本使用源自 Linux 核心的硬盘命名架构，所有的硬盘 (IDE/PATA、SATA、SCSI、USB、IEEE 1394) 都以 <filename>/dev/sd*</filename> 表示。
			</para>
			 <para>
				每个分区由其磁盘代号表示：如，<filename>/dev/sda1</filename> 是第一个磁盘的第一个分区，而 <filename>/dev/sdb3</filename> 是第二个磁盘的第三个分区。
			</para>
			 <indexterm>
				<primary>分区</primary>
				<secondary>主要</secondary>
			</indexterm>
			 <indexterm>
				<primary>分区</primary>
				<secondary>延伸</secondary>
			</indexterm>
			 <indexterm>
				<primary>分区</primary>
				<secondary>次要</secondary>
			</indexterm>
			 <indexterm>
				<primary>分区表</primary>
				<secondary>MS-DOS 格式</secondary>
			</indexterm>
			 <para>
				PC 架构 (或 “i386”，包括新出现的 “amd64”) 不再受限于使用 “MS-DOS” 分区表格式，每个磁盘可以拥有超过 4 个 “主要” 分区。在此架构下要超过此限制，必须添加 “延伸” 分区，然后就能使用添加的 “次要” 分区。这些次要分区由 5 开始编号。所以，第一个磁盘的次要分区可以是 <filename>/dev/sda5</filename>，然后是 <filename>/dev/sda6</filename>，余此类推。
			</para>
			 <para>
				MS-DOS 分区表格式的另个限制是磁盘的容量不能超过 2 TiB，成为当代磁盘的真正问题。
			</para>
			 <indexterm>
				<primary>GPT</primary>
				<secondary>分区表格式</secondary>
			</indexterm>
			 <indexterm>
				<primary>分区表</primary>
				<secondary>GPT 格式</secondary>
			</indexterm>
			 <para>
				GPT 是新的分区表格式，解放对区分数的限制 (标准方式最多可以设置 128 个区分) 以及磁盘容量的限制 (最多达 8 ZiB，超过 8 百万兆字节)。若想在一个磁盘切出多个实体区分，必须以 GPT 格式添加分区表。
			</para>
			 <para>
				不容易记得磁盘挂在 SATA 控制卡的位置，或在 SCSI 链的第三个位置，尤其是热插拔硬式磁盘机 (包括 SATA 磁盘与插件磁盘) 可改变开机的位置。还好，<command>udev</command> 以固定的名称，添加 <filename>/dev/sd*</filename> 以外的符号链接，就能够轻易的辨识硬式磁盘机。这种符号链接保存在 <filename>/dev/disk/by-id</filename> 之内。例如，在两个实体磁盘的机器，可以找到如下的消息：
			</para>
			 
<screen><computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l
</userinput><computeroutput>total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </computeroutput></screen>
			 <para>
				同颗磁盘出现多次 (因为它们同时做为 ATA 磁盘与 SCSI 磁盘)，但是根据磁盘的型号与序号等相关信息，就可找到对应的周边设备文件。
			</para>
			 <para>
				下节的配置档根据同样的设置而来：一个 SATA 磁盘，第一个区分是安装旧型的窗口、第二个分区安装 Debian GNU/Linux。
			</para>

		</section>
		 <section id="sect.config-lilo">
			<title>配置 LILO</title>
			 <indexterm>
				<primary>LILO</primary>
			</indexterm>
			 <indexterm>
				<primary>Linux 加载器</primary>
			</indexterm>
			 <para>
				<emphasis>LILO</emphasis> (Linux 启动程序, LInux LOader) 是最旧的启动程序 — 稳定但粗糙。把核心的实体地址写入 MBR 的启动，所以每次更新至 LILO (或其配置文件) 都必须再运行命令 <command>lilo</command>。忘记的话，移除或更新核心后，新的核心就不会在磁盘的原来位置，以致系统无法启动。
			</para>
			 <para>
				LILO 的配置档是 <filename>/etc/lilo.conf</filename>；一个简单的文件供标准配置之用，如下例。
			</para>
			 <example id="example.lilo.conf">
				<title>LILO 配置文件</title>
				 
<programlisting>
# The disk on which LILO should be installed.
# By indicating the disk and not a partition.
# you order LILO to be installed on the MBR.
boot=/dev/sda
# the partition that contains Debian
root=/dev/sda2
# the item to be loaded by default
default=Linux

# the most recent kernel image
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Old kernel (if the newly installed kernel doesn't boot)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# only for Linux/Windows dual boot
other=/dev/sda1
  label=Windows</programlisting>

			</example>

		</section>
		 <section id="sect.config-grub">
			<title>GRUB 2 配置</title>
			 <indexterm>
				<primary>GRUB</primary>
			</indexterm>
			 <indexterm>
				<primary>GRUB 2</primary>
			</indexterm>
			 <para>
				<emphasis>GRUB</emphasis> (GRand Unified Bootloader) 是最近的事。更新核心后不必再启动它；<emphasis>GRUB</emphasis> 知道如何读取文件系统并找到核心在磁盘的位置。键入 <command>grub-install /dev/sda</command> 命令就能够把它安装在第一个磁盘的 MBR。<indexterm><primary><command>grub-install</command></primary></indexterm>
			</para>
			 <sidebar> <title><emphasis>说明</emphasis> GRUB 的磁盘名称</title>
			 <para>
				GRUB 祗能根据 BIOS 提供的信息辨识硬式磁盘机。<literal>(hd0)</literal> 对应侦测到的第一个磁盘、<literal>(hd1)</literal> 第二个磁盘等。大部份的情况下，此顺序刚好是 Linux 的磁盘顺序，同时使用 SCSI 与 IDE 磁盘时就出问题。GRUB 把侦测到的信息保存在 <filename>/boot/grub/device.map</filename> 文件内。若在此发现错误 (因为已知 BIOS 以不同的顺序侦测到磁盘)，再次运行 <command>grub-install</command> 命令。<command>grub-mkdevicemap</command> 命令可添加 <filename>device.map</filename> 文件。
			</para>
			 <para>
				区分表在 GRUB 内也有特定的名称。通常使用 MS-DOS 格式的 “经典” 区分，第一个磁盘的第一个分区标记为 <literal>(hd0,msdos1)</literal>、第二个分区标记为 <literal>(hd0,msdos2)</literal>，余此类推。
			</para>
			 </sidebar> <para>
				GRUB 2 的配置存在 <filename>/boot/grub/grub.cfg</filename> 内，但该文件 (在 Debian 环境下) 以其他方式产生。不可以人工方式修改它，否则在下次运行 <command>update-grub</command> 时 (更新多个套件时需运行它)，将失去该等修改的内容。修改 <filename>/boot/grub/grub.cfg</filename> 文件 (添加给核心使用的参数或改变显示菜单的时间，举例而已) 通常经由 <filename>/etc/default/grub</filename> 的变量。添加款目至菜单时，可以新建 <filename>/boot/grub/custom.cfg</filename> 文件或修改 <filename>/etc/grub.d/50_custom</filename> 文件。更复杂的配置，可以修改 <filename>/etc/grub.d</filename> 内的其他文件，或添加之；这些脚本应送回配置的片断，很可能是外部程序做的修改。这些脚本将更新启动的核心：<filename>10_linux</filename> 考量安装 Linux 核心；<filename>20_linux_xen</filename> 考量 Xen 虚拟系统，而 <filename>30_os-prober</filename> 则列出其他的操作系统 (Windows、OS X、Hurd)。
			</para>

		</section>
		 <section id="sect.config-yaboot">
			<title>Macintosh 电脑 (PowerPC)：配置 Yaboot</title>
			 <indexterm>
				<primary><command>yaboot</command></primary>
			</indexterm>
			 <para>
				Yaboot 是使用 PowerPC 芯片的旧型 Macintosh 电脑用到的启动程序。它的启动方式不同于 PC，采用 “引导” 分区法，从 BIOS (或 OpenFirmware) 运行启动程序，然后由 <command>ybin</command> 程序安装 <command>yaboot</command> 及其配置档。修改 <filename>/etc/yaboot.conf</filename> 文件后 (在启动程序分区复制，且 <command>yaboot</command> 知道如何到磁盘找寻核心的位置)，需再次运行此命令。
			</para>
			 <para>
				运行 <command>ybin</command> 之前，应有合法的 <filename>/etc/yaboot.conf</filename> 程序。以下的最小配置的范例。<indexterm><primary><command>ybin</command></primary></indexterm>
			</para>
			 <example id="example.yaboot.conf">
				<title>Yaboot 配置文件</title>
				 
<programlisting>
# bootstrap partition
boot=/dev/sda2
# the disk
device=hd:
# the Linux partition
partition=3
root=/dev/sda3
# boot after 3 seconds of inactivity
# (timeout is in tenths of seconds)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# last kernel installed
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# old kernel
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# only for Linux/Mac OSX dual-boot
macosx=/dev/sda5

# bsd=/dev/sdaX and macos=/dev/sdaX
# are also possible</programlisting>

			</example>

		</section>

	</section>
	 <section id="sect.config-misc">
		<title>其他配置：时间同步、记录、共享近用…</title>
		 <para>
			本节列出的细目对希望精通 GNU/Linux 系统配置极有帮助。这里祗列出简要的内容，详情仍需参阅文档。
		</para>
		 <section id="sect.timezone">
			<title>时区</title>
			 <indexterm>
				<primary>时区</primary>
			</indexterm>
			 <sidebar id="sidebar.symbolic-link"> <title><emphasis>基本</emphasis> 符号链接</title>
			 <indexterm>
				<primary>链接</primary>
				<secondary>符号</secondary>
			</indexterm>
			 <indexterm>
				<primary>符号链接</primary>
			</indexterm>
			 <indexterm>
				<primary><command>ln</command></primary>
			</indexterm>
			 <para>
				符号链接是一种指向另个文件的指针。近用时，被指向的文件就被打开。移除链接不会删除指向的文件。同样的，没有自的授权，而是使用目标本身的授权。最后，可以用于任何类型的文件：文件夹、特殊文件 (网络插座、具名管道、设备文件等)、甚至另个符号链接。
			</para>
			 <para>
				<command>ln -s <replaceable>target</replaceable> <replaceable>link-name</replaceable></command> 命令添加一个符号链接，命名为 <replaceable>link-name</replaceable>，指向 <replaceable>target</replaceable>。
			</para>
			 <para>
				若目标不存在，则链接算是 “破损” 且其近用送回错误消息指示目标文件不存在。若链接指向另个链接，该链接又指向其前任链接，则该等链接的 “链” 形成 “循环”。在这种情况下，近用循环内的任一链接也会得到特定的错误 (“过多层的符号链接”)；经过若干循环后核心放弃它。
			</para>
			 </sidebar> <para>
				初始安装时经由 <emphasis role="pkg">tzdata</emphasis> 套件配置时区。<command>dpkg-reconfigure tzdata</command> 命令以交互方式修改时区。其配置内容保存在 <filename>/etc/timezone</filename> 文件。在 <filename>/usr/share/zoneinfo</filename> 文件夹内映射的文件复制在 <filename>/etc/localtime</filename> 文件内；此文件包括使用日光节约时间的国家。
			</para>
			 <indexterm>
				<primary><filename>timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>zoneinfo</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/usr/share/zoneinfo/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>DST</primary>
			</indexterm>
			 <indexterm>
				<primary>日光节约时间</primary>
			</indexterm>
			 <para>
				暂时变更时区，可使用 <varname>TZ</varname> 环境变量，它的优先次序在缺省的配置档之前：
			</para>
			 <indexterm>
				<primary><varname>TZ</varname></primary>
			</indexterm>
			 
<screen id="screen.tz">
<computeroutput>$ </computeroutput><userinput>date</userinput>
<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>
<computeroutput>$ </computeroutput><userinput>TZ="Pacific/Honolulu" date</userinput>
<computeroutput>Thu Feb 19 00:25:21 HST 2015</computeroutput></screen>
			 <sidebar> <title><emphasis>说明</emphasis> 系统时钟，硬件时钟</title>
			 <para>
				电脑内有两个时间来源。主板有个硬件时钟，称为 “CMOS 时钟”。这个时钟不准，近用的速度慢。操作系统核心有自己的系统时钟，以自己的方式 (可能由时间服务器协助，见 <xref linkend="sect.time-synchronization" />) 保持时间的正确。此系统时钟较为准确，尤其是不需经由硬件变量就能近用。然而，系统时钟祗存在于内存，开机就归零，不像 CMOS 时间钟，有电池支持，不受重新开机或暂停下仍能 “存活”。因此，开机时，由 CMOS 时钟设置系统时钟，关机时更新 CMOS 时钟 (若被不当调整就能修正它)。
			</para>
			 <para>
				实务上有个问题，因为 CMOS 时钟祗是个计数器，未含时区信息。有几个方式选择其解释方式：系统以世界标准时间 (UTC，旧称 GMT)，或当地时间看待。虽然可以简单切换，但却颇为复杂：它的偏移值不是常数。系统无法判断偏移值的正确性，尤其在时区交接。总是在世界标准时间与时区信息之间重组在地时间，建议使用 CMOS 时间为世界标准时间。
			</para>
			 <para>
				不幸的是，窗口系统缺省的配置忽视此建议；仍以 CMOS 时钟为在地时间，启动时猜测时区的变动。祗要运行单一的窗口系统，就没有问题。可是，电脑经常安装多个系统 (“双重开机” 配置或在虚拟机运行其他系统)，混乱就免不了，无法决定正确的时间。必须保留窗口系统的前提下，应把 CMOS 时钟配置成 UTC (把机码 <literal>HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</literal> 设置为 “1” 做为 DWORD)，或使用 Debian 系统的 <command>hwclock --localtime --set</command> 设置硬件时钟并标记追踪其为在地时间 (并且在春秋两季手段检查时钟的正确性)。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.time-synchronization">
			<title>时间同步</title>
			 <indexterm>
				<primary>时间同步</primary>
			</indexterm>
			 <indexterm>
				<primary>时间</primary>
				<secondary>同步</secondary>
			</indexterm>
			 <para>
				时间同步，在单机时代是多余，但在网络时代却很重要。用户无权修改日期与时间，所以需要精准的时间以免混乱。尤有甚者，网络上的电脑时间同步后，有助于安排社区工作者透过网络全球串联。受到攻击时，容易依序恢复原来的运作。由多部机器收集来的统计数据，必须有同步的时间，才能发挥作用。
			</para>
			 <sidebar> <title><emphasis>基本</emphasis> NTP</title>
			 <indexterm>
				<primary>NTP</primary>
			</indexterm>
			 <indexterm>
				<primary>Network</primary>
				<secondary>Time Protocol</secondary>
			</indexterm>
			 <para>
				网络时间协定 (Network Time Protocol, NTP) 可以让机器间相当精准的同步，甚至把网络延迟及其他偏移值列入考量。
			</para>
			 <para>
				互联网上很多 NTP 服务器可用，受欢迎的其工作量可能负荷过重。所以建议使用 <emphasis>pool.ntp.org</emphasis> NTP 服务器，它是一组公开的 NTP 服务器。也可使用针对特定地区的次群组服务器，如 <emphasis>us.pool.ntp.org</emphasis> 系供美国使用、<emphasis>ca.pool.ntp.org</emphasis> 供加拿大使用。
			</para>
			 <para>
				然而，管理大型网络时，还是应安装与公共服务器同步的自己 NTP 服务器。同个网络上自己的机器，就能使用内部的 NTP 服务器不必增加外部公共服务器的负担。以自己的时钟增加网络内机器的同质化，同步截取与共用资源，使用共同的网络交换时间。
			</para>
			 </sidebar> <section id="sect.ntp-on-workstations">
				<title>给工作站</title>
				 <para>
					工作经常需要重新开机 (虽然祗是节省能源)，开机时以 NTP 同步就够了。安装 <emphasis role="pkg">ntpdate</emphasis> 套件就可以。需要更换 NTP 服务器时，再修改 <filename>/etc/default/ntpdate</filename> 文件即可。
				</para>
				 <indexterm>
					<primary><filename>ntpdate</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/default/ntpdate</filename></primary>
				</indexterm>

			</section>
			 <section id="sect.ntp-on-servers">
				<title>供服务器</title>
				 <para>
					服务器很少重开机，系统时间必须绝对精准。为了永久维持时间的正确性，必须安装由 <emphasis role="pkg">ntp</emphasis> 套件提供的 NPT 服务器。缺省的配置方式系与 <emphasis>pool.ntp.org</emphasis> 同步，且回应在地网络的请求。可以编辑 <filename>/etc/ntp.conf</filename> 文件改变原来的配置，NTP 服务器依照该文件的内容而变更。若有多个服务器，最好有一个在地时间服务器与公共的服务器同步，并做为在地网络其他服务器的同步的依据。
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">ntp</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary>服务器</primary>
					<secondary>NTP</secondary>
				</indexterm>
				 <indexterm>
					<primary>NTP</primary>
					<secondary>服务器</secondary>
				</indexterm>
				 <sidebar> <title><emphasis>进一步</emphasis> GPS 模块与其他时间来源</title>
				 <indexterm>
					<primary>GPS</primary>
				</indexterm>
				 <indexterm>
					<primary>DCF-77</primary>
				</indexterm>
				 <para>
					如果网络对时间同步极为敏感，最好在服务器安装 GPS 模块 (which will use the time from GPS satellites) 或 DCF-77 模块 (which will sync time with the atomic clock near Frankfurt, Germany)。在这种情况下，NTP 服务器的配置就有点复杂，必须参照文档办理。
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.rotation-logs">
			<title>轮转日志档</title>
			 <indexterm>
				<primary>文件</primary>
				<secondary>日志，轮转</secondary>
			</indexterm>
			 <indexterm>
				<primary>日志</primary>
				<secondary>文件，轮转</secondary>
			</indexterm>
			 <indexterm>
				<primary>轮转日志文件</primary>
			</indexterm>
			 <indexterm>
				<primary><command>logrotate</command></primary>
			</indexterm>
			 <para>
				日志档成长的速度很快，需要典藏它。最常的做法是循环典藏：祗保留最新的 <replaceable>X</replaceable> 部份。<command>logrotate</command> 是负责循环的程序，根据 <filename>/etc/logrotate.conf</filename> 文件内的配置，把日志档保存在 <filename>/etc/logrotate.d/</filename> 文件夹内。管理者可以修改该等文件，修改 Debian 缺省的循环政策。<citerefentry><refentrytitle>logrotate</refentrytitle>
				 <manvolnum>1</manvolnum></citerefentry> 手册页面描述该配置可用的选项。可以在循环的过程中，增加典藏的文件数，或把文件移至指定的文件夹而不是删除它们。也可以电子邮件方式寄到别的地方。
			</para>
			 <para>
				<command>logrotate</command> 程序每日运行 <command>cron</command> 调度的要求 (详情见 <xref linkend="sect.task-scheduling-cron-atd" />)。
			</para>

		</section>
		 <section id="sect.sharing-admin-rights">
			<title>共享管理员权限</title>
			 <indexterm>
				<primary>帐户</primary>
				<secondary>管理员帐户</secondary>
			</indexterm>
			 <indexterm>
				<primary>根</primary>
			</indexterm>
			 <indexterm>
				<primary><command>sudo</command></primary>
			</indexterm>
			 <para>
				数个管理者共同在同个服务器工作。共用同个根用户密码不是好主意，匿名引发的误用很麻烦。解决方案是使用 <command>sudo</command> 程序，允许用户对特定命令拥有专门的权力。在多数情况下，<command>sudo</command> 允许受信任的用户以根的权限运行命令。用户祗需运行 <command>sudo <replaceable>command</replaceable></command> 并以个人的密码通过认证。
			</para>
			 <para>
				安装的时候，<emphasis role="pkg">sudo</emphasis> 套件把完整的 root 权限授权给 <literal>sudo</literal> Unix 群组。管理者必须使用 <command>visudo</command> 命令授予其他权利，该命令允许用户修改 <filename>/etc/sudoers</filename> 配置档 (当然，必须启用 <command>vi</command> 编辑器，或在 <varname>EDITOR</varname> 环境变量指定的编辑器)。添加一列 <literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal> 就能允许该用户以 root 的授权运行命令。
			</para>
			 <indexterm>
				<primary><command>visudo</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>sudoers</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/sudoers</filename></primary>
			</indexterm>
			 <para>
				还有较复杂的配置，祗允许特定用户运行部份命令。详情在 <citerefentry><refentrytitle>sudoers</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry> 手册页面。
			</para>

		</section>
		 <section id="sect.fstab-mount-points">
			<title>挂载点清单</title>
			 <indexterm>
				<primary>点，挂载</primary>
			</indexterm>
			 <indexterm>
				<primary>挂载点</primary>
			</indexterm>
			 <sidebar> <title><emphasis>基本</emphasis> 挂载与卸载</title>
			 <para>
				在 Debian 这类的 Unix-like 系统里，文件以树状的文件夹阶层组织。<filename>/</filename> 文件夹称为 “根文件夹”；其他的文件夹都是此根文件夹的次文件夹。“挂载” 是把周边设备 (通常是磁盘) 纳入系统文件树的作业。如果以其他磁盘保存用户个人的数据，将 “挂载” 于 <filename>/home/</filename> 文件夹。根文件系统由核心永远挂载于根；其他设备则稍后再透过启动顺序或以 <command>mount</command> 命令挂载进来。
			</para>
			 <indexterm>
				<primary><command>mount</command></primary>
			</indexterm>
			 <para>
				有些移动式设备在链接时系统自动挂载，尤其在 GNOME、KDE 或其他图形桌面环境。有些情况就需要用户手动挂载。同样的，也需要卸载 (从文件树移除)。标准的用户权限不允许运行挂载 <command>mount</command> 与卸载 <command>umount</command> 命令。只有管理者才能够设置 <literal>user</literal> 选项于 <filename>/etc/fstab</filename> 文件内，授权用户运行该等命令 (独立于每个挂载点)。
			</para>
			 <para>
				<command>mount</command> 命令可以直接使用不需参数 (列出所有已挂载的文件系统)。以下参数为挂载或卸载设备所必需。完整的参数，请参见对应的手册页面，<citerefentry><refentrytitle>mount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> 与 <citerefentry><refentrytitle>umount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry>。单纯个案的语法也简单：例如，挂载使用 ex3 文件系统的 <filename>/dev/sdc1</filename> 分区入 <filename>/mnt/tmp/</filename> 文件夹时，需运行 <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command> 命令。
			</para>
			 </sidebar> <para>
				<filename>/etc/fstab</filename> 文件列出所有开机自动挂载或手动挂载的移动保存设备。每个挂载点由一列文本描述，包括若干空格区隔的字段：<indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						待挂载的设备：可以是在地分区 (硬盘、CD-ROM) 或远程的文件系统 (如 NFS)。
					</para>
					 <para>
						此字段通常以文件系统的 ID 取代 (可以用 <command>blkid <userinput>device</userinput></command>) 前置及 <literal>UUID=</literal>。此种方式可以应付添加或移除磁盘设备名称的情况，或者以其他顺序侦测到的磁盘。
					</para>

				</listitem>
				 <listitem>
					<para>
						挂载点：这是把设备、远程系统，或分区挂载于在地文件系统的位置。
					</para>

				</listitem>
				 <listitem>
					<para>
						类型：这个字段定义挂载设备使用的文件系统。<literal>ext4</literal>、<literal>ext3</literal>、<literal>vfat</literal>、<literal>ntfs</literal>、<literal>btrfs</literal>、<literal>xfs</literal> 等。
					</para>
					 <sidebar> <title><emphasis>基本</emphasis> NFS，网络文件系统</title>
					 <para>
						NFS 是一种 Linux 环境下的网络文件系统，把远程的文件以透明方式纳入在地的文件系统内。
					</para>
					 </sidebar> <para>
						知名的文件系统清单在 <citerefentry><refentrytitle>mount</refentrytitle>
						 <manvolnum>8</manvolnum></citerefentry> 手册页面。特殊值 <literal>swap</literal> 系供交换分区使用；特殊值 <literal>auto</literal> 告诉<command>mount</command> 程序自动侦测文件系统 (对读卡机与 USB 磁盘机特别有用，因为它们可能使用不同的文件系统)；
					</para>

				</listitem>
				 <listitem>
					<para>
						选项：依文件系统的不同，而有多种选项，详情见 <command>mount</command> 手册页面。最常用的是
					</para>
					 <itemizedlist>
						<listitem>
							<para>
								<literal>rw</literal> 或 <literal>ro</literal>，表示该设备挂载后可以读/写，或只有读取的权限。
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>noauto</literal> 开机时关闭自动挂载。
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>nofail</literal> 允许在启动时处理设备，即使该设备不存在。确认启动时，该外置磁盘机可能未插入，因为 <command>systemd</command> 将确认所有挂载点在启动完成前必须自动挂载。可将此与 <literal>x-systemd.device-timeout=5s</literal> 并用，告诉 <command>systemd</command> 不必等 5 秒以上的时间，直接进入下个作业阶段 (见 <citerefentry><refentrytitle>systemd.mount</refentrytitle>
								<manvolnum>5</manvolnum></citerefentry>)。
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>user</literal> 授权所有的用户均可挂载此文件系统 (若无此选项，则只有根用户才有此权限)。
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>defaults</literal> 表示缺省的选项群组为：<literal>rw</literal>、<literal>suid</literal>、<literal>dev</literal>、<literal>exec</literal>、<literal>auto</literal>、<literal>nouser</literal> 与 <literal>async</literal>，使用了 <literal>defaults</literal> 之后，还可以用 <literal>nosuid</literal> 命令、<literal>nodev</literal> 及其他类似的命令，中止 <literal>suid</literal>、<literal>dev</literal> 等作用。加入 <literal>user</literal> 选项可再启用它，因为 <literal>defaults</literal> 包括 <literal>nouser</literal>。
							</para>

						</listitem>

					</itemizedlist>

				</listitem>
				 <listitem>
					<para>
						备份：此字段几乎都设为 <literal>0</literal>。当它是 <literal>1</literal> 时，告诉 <command>dump</command> 工具将备份有数据的分区。
					</para>

				</listitem>
				 <listitem>
					<para>
						检查顺序：最后一个字段告知系统在启动时，或其他时机，检查文件系统的完整性。若设为 <literal>0</literal>，则不检查。根文件系统的值为 <literal>1</literal>，其他固定文件系统的值为 <literal>2</literal>。
					</para>

				</listitem>

			</itemizedlist>
			 <example id="example.fstab">
				<title>范例 <filename>/etc/fstab</filename> 文件</title>
				 
<programlisting>
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
# swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0</programlisting>

			</example>
			 <para>
				此例的最后一个款目对应于网络文件系统 (NFS)：<filename>/shared/</filename> 文件夹位于 <emphasis>arrakis</emphasis> 服务器挂载于本地机器的 <filename>/shared/</filename>。<filename>/etc/fstab</filename> 文件格式位于 <citerefentry><refentrytitle>fstab</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> 手册页面。
			</para>
			 <sidebar> <title><emphasis>下一步</emphasis> 自动挂载</title>
			 <para>
				<emphasis>am-utils</emphasis> 套件提供 <command>amd</command> 自动加载公用程序，使月手者近用其惯用的挂载点时，可在需要时挂载移动式媒体。无法在不用时自动卸载该等设备。
			</para>
			 <indexterm>
				<primary><emphasis>am-utils</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><command>amd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>automount</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>autofs</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>automounter</primary>
			</indexterm>
			 <para>
				还有其他自动挂载公用程序，诸如 <command>automount</command> 位在 <emphasis>autofs</emphasis> 套件中。
			</para>
			 <para>
				与 GNOME、KDE 及其他图形桌面环境一起工作的 <emphasis>udisks</emphasis>，在链接移动媒体时，也可自动挂载。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.locate-updatedb">
			<title><command>locate</command> 与 <command>updatedb</command></title>
			 <indexterm>
				<primary><command>locate</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>updatedb</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>mlocate</command></primary>
			</indexterm>
			 <para>
				可以用 <command>locate</command> 命令找寻已知名称的文件。几乎即时送回结果，因为它搜索的数据库保存系统内所有文件的位置；此数据库由 <command>updatedb</command> 命令每日更新。<command>locate</command> 命令还有其他用途，Debian 选择 <emphasis role="pkg">mlocate</emphasis> 做为其标准系统。
			</para>
			 <para>
				<command>mlocate</command> 很聪明，祗送回该命令用户能够近用的文件，不会显示系统内其他符合条件的文件 (因为它以根权限运行 <command>updatedb</command> 命令)。为了提供额外的安全保护，管理者可以使用 <varname>PRUNEDPATHS</varname> 位于 <filename>/etc/updatedb.conf</filename>，排除已经索引的其他文件夹。
			</para>

		</section>

	</section>
	 <section id="sect.kernel-compilation">
		<title>编译核心</title>
		 <indexterm>
			<primary>编译</primary>
			<secondary>核心</secondary>
		</indexterm>
		 <indexterm>
			<primary>核心</primary>
			<secondary>编译</secondary>
		</indexterm>
		 <para>
			Debian 的核心尽量纳入所有的功能，以及最多的驱动程序，以便涵盖现在的硬件配置。所以，有些用户宁愿自行编译祗包括所需的核心。这么做有两个理由。第一，内存用量较小，核心代码，即使未用到，也占有内存的空间 (而且永远不 “离开” 置换内存，因为它用到实际的 RAM)，降低系统的整体性能。在地自行编译的核心也限制了安全问题的范围，因为祗编译与运行部份核心码。
		</para>
		 <sidebar> <title><emphasis>说明</emphasis> 安全更新</title>
		 <para>
			决定编译自己的核心后，必须接受一个事实：Debian 不能确认客制化核心的安全更新。使用 Debian 的核心，可以使用 Debian 计划提供的更新。
		</para>
		 </sidebar> <para>
			使用祗在补丁内的功能 (不在标准的核心内) 时，就必须重新编译核心。
		</para>
		 <sidebar> <title><emphasis>进一步</emphasis> The Debian Kernel Handbook</title>
		 <indexterm>
			<primary><emphasis role="pkg">debian-kernel-handbook</emphasis></primary>
		</indexterm>
		 <para>
			Debian 核心团队维护的 “Debian Kernel Handbook” (全文见 <emphasis role="pkg">debian-kernel-handbook</emphasis> 套件) 详述核心相关的工作与 Debian 核心套件的处理方式。欲知可节所述事宜的详情，请参见此网址。<ulink type="block" url="http://kernel-handbook.alioth.debian.org" />
		</para>
		 </sidebar> <section id="sect.kernel-compilation-prerequisites">
			<title>简介和先决条件</title>
			 <para>
				Debian 以套件方式管理核心，与传统的编译安装不同调。核心还是在套件系统的控制下，可以被完整移除，或布建在多个机器上。与该等套件有关的脚本自动与启动程序和 initrd 产生器交互。
			</para>
			 <para>
				上游的 Linux 源代码包括建置 Debian 核心套件所需的一切。但是仍可再安装 <emphasis role="pkg">build-essential</emphasis> 以确保拥有创建 Debian 套件所需的所有工具。而且，配置核心时需要 <emphasis role="pkg">libncurses5-dev</emphasis> 套件。最后，<emphasis role="pkg">fakeroot</emphasis> 套件将在不使用管理者权限的前提下，启用添加 Debian 套件。
			</para>
			 <sidebar> <title><emphasis>文化</emphasis> <emphasis role="pkg">kernel-package</emphasis> 的美好岁月</title>
			 <indexterm>
				<primary><emphasis role="pkg">kernel-package</emphasis></primary>
			</indexterm>
			 <para>
				以 Linux 布建系统能够创建适当的 Debian 套件前，使用 <command>make-kpkg</command>，来自 <emphasis role="pkg">kernel-package</emphasis> 套件。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-sources">
			<title>获取源代码</title>
			 <indexterm>
				<primary>Linux 核心源代码</primary>
			</indexterm>
			 <indexterm>
				<primary>核心</primary>
				<secondary>源代码</secondary>
			</indexterm>
			 <indexterm>
				<primary>源代码</primary>
				<secondary> Linux 核心</secondary>
			</indexterm>
			 <para>
				就像 Debian 系统内其他有用的东西，Linux 核心源代码也位在套件内。祗要安装 <emphasis role="pkg">linux-source-<replaceable>version</replaceable></emphasis> 套件，就能取得全部的源代码。<command>apt-cache search ^linux-source</command> 命令行出 Debian 内各种版本的核心套件。最新的版本在 <emphasis role="distribution">Unstable</emphasis> 发行版内：可以毫不费力的取得 (尤其是把 APT 根据 <xref linkend="sect.apt-mix-distros" /> 的指示配置后)。这些套件内的源代码并未完全吻合 Linus Torvalds 与其他核心发展者发布的内容；如同其他的发行版，Debian 以一系列的补丁搭配，这些补丁可能 (或不可能) 以自己的方法纳入 Linux 上游的版本。包括从较新核心版本的 fixes/features/drivers 反向移殖，功能较新但尚未 (全部) 合并入上游的Linux 树，甚至 Debian 特别的改变。
			</para>
			 <para>
				本节其他内容以 Linux 核心 3.16 版为准，范例则不以此为限，可以调整为特定的核心版本。
			</para>
			 <para>
				假设 <emphasis role="pkg">linux-source-3.16</emphasis> 套件已安装好了。包括 <filename>/usr/src/linux-source-3.16.tar.xz</filename>，核心源代码的压缩档。在另个文件夹解缩 (不能直接在 <filename>/usr/src/</filename> 之下，因为不需特别的授权就可以重新编译 Linux 核心)：<filename>~/kernel/</filename> 是个不错的选择。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>
<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-3.16.tar.xz</userinput></screen>
			 <sidebar> <title><emphasis>文化</emphasis> 核心源代码的位置</title>
			 <para>
				传统上，Linux 核心源代码置于 <filename>/usr/src/linux/</filename>，需要根权限才能编译。然而，管理者的权限就够了。<literal>src</literal> 群组的成员也可以使用该文件夹，但是应避免使用 <filename>/usr/src/</filename>。把核心源代码置于个人文件夹时，应把安全置于第一位：在 <filename>/usr/</filename> 内的文件都应明确其在套件系统内的作用，试图聚集使用核心的信息时，不能在读取 <filename>/usr/src/linux</filename> 时误导程序。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.config-kernel">
			<title>配置核心</title>
			 <indexterm>
				<primary>核心</primary>
				<secondary>配置</secondary>
			</indexterm>
			 <indexterm>
				<primary>配置</primary>
				<secondary>核心</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>.config</filename></primary>
			</indexterm>
			 <para>
				下个步骤是根据需要配置核心。确切的进程视需要而订。
			</para>
			 <para>
				重新编译较新版本的核心 (可能连同其补丁) 时，应尽量采用 Debian 建议的配置。在此情况下，与其从最基本开始重新编译，不妨复制 <filename>/boot/config-<replaceable>version</replaceable></filename> 文件 (核心正在使用的版本，可以 <command>uname -r</command> 命令查看) 进入核心原始所在文件夹内的 <filename>.config</filename> 文件。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cp /boot/config-3.16.0-4-amd64 ~/kernel/linux-source-3.16/.config</userinput></screen>
			 <para>
				需要改变配置的话，就跳至 <xref linkend="sect.kernel-build" />。或者从基本开始重新配置，就需花时间配置核心。在核心源代码的文件夹内有很多专属接口，供调用 <command>make <replaceable>target</replaceable></command> 命令，让 <replaceable>target</replaceable> 是下列的其中一个值。
			</para>
			 <para>
				<command>make menuconfig</command> 编译并运行文本模式接口 (即 <emphasis role="pkg">libncurses5-dev</emphasis> 套件必备) 以阶层结构浏览可用的选项。按 <keycap>空格</keycap> 键改变选定的值，并按屏幕下方的 <keycap>Enter</keycap> 钮；<guibutton>Select</guibutton> 送回选定的次菜单；<guibutton>Exit</guibutton> 关闭当前的屏幕并回到上个阶层；<guibutton>Help</guibutton> 显示选项的详细信息。箭头键在选项及按钮清单内动。按主菜单的 <guibutton>Exit</guibutton> 钮，就可离开配置程序。此程序可保存改变的配置；接受改变后的配置。
			</para>
			 <para>
				其他的接口也有类似的功能，但在现代化的图形接口运作；诸如 <command>make xconfig</command> 使用 Qt 图形接口，而 <command>make gconfig</command> 使手 GTK+。前者用到 <emphasis role="pkg">libqt4-dev</emphasis>，后者依赖 <emphasis role="pkg">libglade2-dev</emphasis> 与 <emphasis role="pkg">libgtk2.0-dev</emphasis>。
			</para>
			 <para>
				使用这些配置接口时，建议从合理的缺省配置开始。提供该等配置的核心在 <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename>，然后可将选定的配置置于像 <command>make x86_64_defconfig</command> (64 位电脑) 或 <command>make i386_defconfig</command> (32 位电脑) 这样的命令。
			</para>
			 <sidebar> <title><emphasis>秘诀</emphasis> 处理过时的 <filename>.config</filename> 文件</title>
			 <para>
				使用其他 (通常是较旧的) 核心版本的 <filename>.config</filename> 文件时，需要先更新它。可以使用 <command>make oldconfig</command> 命令，以交互方式询问对新配置的选择。可以用 <command>make olddefconfig</command> 命令使用问题缺省的答案。以 <command>make oldnoconfig</command> 命令，可以对问题提供缺省的负面答案。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-build">
			<title>编译与创建套件</title>
			 <indexterm>
				<primary><command>make deb-pkg</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>说明</emphasis> 创建前先清除</title>
			 <para>
				若已在文件夹内编译过，希望从基础重新创建 (或许更换核心配置)，需运行 <command>make clean</command> 命令移除已编译的文件。<command>make distclean</command> 命令可移除更多的文件，包括客制的 <filename>.config</filename> 文件，别忘了先备份。
			</para>
			 </sidebar> <para>
				核心配置完成后，<command>make deb-pkg</command> 命令可产生至多 5 个 Debian 套件：<emphasis role="pkg">linux-image-<replaceable>version</replaceable></emphasis> 包括核心映像与相关的模块，<emphasis role="pkg">linux-headers-<replaceable>version</replaceable></emphasis> 包括创建外部模块所需的头文件，<emphasis role="pkg">linux-firmware-image-<replaceable>version</replaceable></emphasis> 包括某些驱动程序所需的固件 (由 Debian 提供的核心源文件创建时，可能没有该套件)，<emphasis role="pkg">linux-image-<replaceable>version</replaceable>-dbg</emphasis> 包括供套件映像及其模块的调试符号，以及<emphasis role="pkg">linux-libc-dev</emphasis> 包括 GNU glibc 之类与用户程序库相关的标头。
			</para>
			 <para>
				<replaceable>version</replaceable> 由并列的上游版本决定 (如同变量 <literal>VERSION</literal>、<literal>PATCHLEVEL</literal>、<literal>SUBLEVEL</literal> 与 <literal>EXTRAVERSION</literal> 在 <filename>Makefile</filename> 内所定)、并列的 <literal>LOCALVERSION</literal> 配置参数、以及并列的 <literal>LOCALVERSION</literal> 环境变量。套件版本使用同版本字符串以及添加的附加版本 (并保存在 <filename>.version</filename>)，除非以 <literal>KDEB_PKGVERSION</literal> 环境变量覆写它们。
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1
</userinput><computeroutput>[...]
$ </computeroutput><userinput>ls ../*.deb
</userinput><computeroutput>../linux-headers-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb
../linux-image-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb
../linux-image-3.16.7-ckt4-falcot-dbg_3.16.7-1_amd64.deb
../linux-libc-dev_3.16.7-1_amd64.deb
</computeroutput></screen>

		</section>
		 <section id="sect.modules-build">
			<title>编译外部模块</title>
			 <indexterm>
				<primary>核心</primary>
				<secondary>外部模块</secondary>
			</indexterm>
			 <indexterm>
				<primary>模块</primary>
				<secondary>外部核心模块</secondary>
			</indexterm>
			 <indexterm>
				<primary><command>dkms</command></primary>
			</indexterm>
			 <para>
				部份模块由 Linux 官方核心之外维护。使用时，必须与匹配的核心一起编译。若干常见的第三方模块由 Debian 指定套件提供，诸如 <emphasis role="pkg">xtables-addons-source</emphasis> (iptables 的外部模块) 或 <emphasis role="pkg">oss4-source</emphasis> (Open Sound System，某些额外的音效驱动程序)。
			</para>
			 <para>
				这些外部套件极多且杂，在此无法全部枚举；<command>apt-cache search source$</command> 命令可缩小搜索的范围。然而，完整的清单没什么用处，只有明确知道需要时，才会编译特定的外部模块。在这个情况下，设备的文档会详述 Linux 环境所需的模块。
			</para>
			 <para>
				以 <emphasis role="pkg">xtables-addons-source</emphasis> 套件为例：安装之后，模块源文件 <filename>.tar.bz2</filename> 保存在 <filename>/usr/src/</filename>。可以手动解开该压缩档并创建模块，也可用 DKMS 自动做它。大部份模块提供必要的 DKMS 以 <literal>-dkms</literal> 后置文本集成入套件。在本例中，安装 <emphasis role="pkg">xtables-addons-dkms</emphasis> 就是为当前核心编译核心模块，前提是有匹配已安装核心的 <emphasis role="pkg">linux-headers-*</emphasis> 套件。例如，使用 <emphasis role="pkg">linux-image-amd64</emphasis>，则应同时安装 <emphasis role="pkg">linux-headers-amd64</emphasis>。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>
<computeroutput>
[...]
Setting up xtables-addons-dkms (2.6-1) ...
Loading new xtables-addons-2.6 DKMS files...
First Installation: checking all kernels...
Building only for 3.16.0-4-amd64
Building initial module for 3.16.0-4-amd64
Done.

xt_ACCOUNT:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/3.16.0-4-amd64/updates/dkms/
[...]
DKMS: install completed.
$ </computeroutput><userinput>sudo dkms status</userinput>
<computeroutput>xtables-addons, 2.6, 3.16.0-4-amd64, x86_64: installed
$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>
<computeroutput>filename:       /lib/modules/3.16.0-4-amd64/updates/dkms/xt_ACCOUNT.ko
license:        GPL
alias:          ipt_ACCOUNT
author:         Intra2net AG &lt;opensource@intra2net.com&gt;
description:    Xtables: per-IP accounting for large prefixes
[...]
</computeroutput></screen>
			 <sidebar> <title><emphasis>其他</emphasis> module-assistant</title>
			 <indexterm>
				<primary><emphasis role="pkg">module-assistant</emphasis></primary>
			</indexterm>
			 <para>
				DKMS 出现以前，<emphasis role="pkg">module-assistant</emphasis> 是创建与布署核心模块的最简单解决方案。目前还能用，特别是缺少 DKMS 集成的情况：以 <command>module-assistant auto-install xtables-addons</command> (或较短的 <command>m-a a-i xtables-addons</command>) 命令，就能编译出给当前核心使用的模𦈡，置于新的 Debian 套件，让该套件可以即时安装。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-patch">
			<title>选择内核补丁</title>
			 <indexterm>
				<primary>内核</primary>
				<secondary>补丁</secondary>
			</indexterm>
			 <indexterm>
				<primary>内核补丁</primary>
			</indexterm>
			 <para>
				因为不够成熟或核心维护者意见不一致，很多功能未列入标准的核心。这种功能就以补丁的型式发行，任何人都可以自由地把它维入核心源代码。
			</para>
			 <para>
				Debian 以 <emphasis role="pkg">linux-patch-*</emphasis> 或 <emphasis role="pkg">kernel-patch-*</emphasis> 方式散布这些套件 (例如，<emphasis role="pkg">linux-patch-grsecurity2</emphasis>，可以紧缩核心的安全政策)。这些套件安装的文件在 <filename>/usr/src/kernel-patches/</filename> 文件夹内。
			</para>
			 <para>
				在源文件文件夹内，以 <command>patch</command> 命令编译核心，就能够纳入前述安装的补丁。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-3.16</userinput>
<computeroutput>$ </computeroutput><userinput>make clean</userinput>
<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.0-3.17.1-201410250027.patch.gz | patch -p1</userinput></screen>
			 <para>
				有些补丁不见得适用于每个核心版本；以 <command>patch</command> 可能无法应用于核心源代码。将出现错误消息且提示错误的原因；在此情况下，参照 Debian 补丁套件的文档 (位于 <filename>/usr/share/doc/linux-patch-*/</filename> 文件夹)。大部份的情况下，维护者会指出其补丁适用的核心版本。
			</para>

		</section>

	</section>
	 <section id="sect.kernel-installation">
		<title>安装内核</title>
		 <indexterm>
			<primary>安装</primary>
			<secondary>核心</secondary>
		</indexterm>
		 <indexterm>
			<primary>核心</primary>
			<secondary>安装</secondary>
		</indexterm>
		 <section id="sect.kernel-package">
			<title>Debian 内核包特性</title>
			 <indexterm>
				<primary><filename>vmlinuz</filename></primary>
			</indexterm>
			 <para>
				Debian 核心套件安装核心映像 (<filename>vmlinuz-<replaceable>version</replaceable></filename>)、其配置 (<filename>config-<replaceable>version</replaceable></filename>) 与符号表 (<filename>System.map-<replaceable>version</replaceable></filename>) 于 <filename>/boot/</filename> 内。符号表协助发展者了解核心错误消息的意义；少了心，核心 “oopses” (“oops” 是相当于给用户程序的核心区段错误，换句话说，消息加上错误指针) 只有数字内存地址，没有符号表映射该等地址至符号与功能的话，本身是无意义的。该等模块安装在 <filename>/lib/modules/<replaceable>version</replaceable>/</filename> 文件夹。
			</para>
			 <para>
				套件的配置脚本自动产生 initrd 映像，此为由启动程序加载内存的迷你系统 (其名称源自于此，表示为 “init ramdisk”)，被 Linux 核心专用于加载包括完整 Debian 系统设备的模块 (例如，SATA 磁盘机的驱动程序)。最后，安装后脚本更新符号链接 <filename>/vmlinuz</filename>、<filename>/vmlinuz.old</filename>、<filename>/initrd.img</filename> 与 <filename>/initrd.img.old</filename>，让它们分别指向最新的两个核心， 以及映射的 initrd 映像。
			</para>
			 <para>
				大部份的这些工作卸载至 <filename>/etc/kernel/*.d/</filename> 文件夹内的脚本。例如，当已安装或移除核心时，集成 <command>grub</command> 于 <filename>/etc/kernel/postinst.d/zz-update-grub</filename> 和 <filename>/etc/kernel/postrm.d/zz-update-grub</filename> 调用 <command>update-grub</command>。
			</para>

		</section>
		 <section id="sect.kernel-installation-with-dpkg">
			<title>与 <command>dpkg</command> 集成</title>
			 <para>
				使用 <command>apt</command> 极为便利，以致常忘记它是极为低级的工具，但是安装被编译的核心可使用更简单的工具，诸如 <command>dpkg -i <replaceable>package</replaceable>.deb</command>，<literal><replaceable>package</replaceable>.deb</literal> 是 <emphasis role="pkg">linux-image</emphasis> 套件的名称，例如 <filename>linux-image-3.16.7-ckt4-falcot_1_amd64.deb</filename>。
			</para>
			 <para>
				本章描述供服务器系统或工作站的基本配置，可以用半自动的方式大量复制。然而，本身还不足以提供完整的配置系统。还有若干部份需要进一步的配置，从 “Unix 服务” 之类的低级程序开始。
			</para>

		</section>

	</section>
</chapter>

