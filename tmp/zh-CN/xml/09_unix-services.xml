<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="unix-services" lang="zh-CN">
	<chapterinfo>
		 <keywordset>
			<keyword>系统启动</keyword>
			 <keyword>启动脚本</keyword>
			 <keyword>SSH</keyword>
			 <keyword>Telnet</keyword>
			 <keyword>权限</keyword>
			 <keyword>许可</keyword>
			 <keyword>管理</keyword>
			 <keyword>Inetd</keyword>
			 <keyword>Cron</keyword>
			 <keyword>备份</keyword>
			 <keyword>热插拔</keyword>
			 <keyword>PCMCIA接口</keyword>
			 <keyword>APM</keyword>
			 <keyword>ACPI</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Unix 服务</title>
	 <highlights> <para>
		本章涵盖一些Unix系统共通的服务。管理员应当熟悉他们。
	</para>
	 </highlights> <section id="sect.system-boot">
		<title>系统启动</title>
		 <indexterm>
			<primary>启动</primary>
			<secondary>系统</secondary>
		</indexterm>
		 <para>
			当启动计算机时，控制台上滚动的大量信息显示许多初始化和配置工作自动正在执行。有时候你可能稍稍的改变这一阶段的操作，就要求你需要很好的理解他们。这正是本章节的目的所在。
		</para>
		 <para>
			首先，BIOS 控制电脑，探测磁盘，加载<emphasis>Master Boot Record</emphasis>，并执行启动加载器。启动程序接手后，找到磁盘上的内核，加载并执行。然后，内核被初始化，并开始寻找和挂载包含根文件系统的分区，最后执行第一个程序－<command>init</command>。根分区和启动程序<command>init</command>常常驻留在仅存在于 RAM 中的虚拟文件系统（正如它的名字，“initramfs”，一般称之为“initrd”初始内存磁盘）。启动加载器将文件系统加载到内存中，文件通常位于硬盘或者源于网络。它包含了内核需要的最少裸信息，以便用来加载“真正”的根文件系统：可能是硬盘上的驱动模块，或者其他系统启动必须的设备，或者更常见的是初始化脚本和模块以组建 RAID 阵列，打开加密分区，激活 LVM ，等等。一旦根分区挂载，initramfs 就会把控制权交到真正的启动程序，机器则回到标准的启动过程。
		</para>
		 <figure id="figure.boot-process-systemd">
			<title>运行 sytemd 的 Linux 计算机的启动顺序</title>
			 <mediaobject>
				<imageobject>
					<imagedata fileref="images/startup-systemd.png" format="PNG" scalefit="1" width="80%" />
				</imageobject>

			</mediaobject>

		</figure>
		 <section id="sect.systemd">
			<title>Systemd 启动系统</title>
			 <para>
				“真正的启动器”当前是由<emphasis role="pkg">systemd</emphasis> 提供的，本章节讲述该启动系统。
			</para>
			 <sidebar> <title><emphasis>文化</emphasis> 在 <command>systemd</command> 之前</title>
			 <para>
				<command>systemd</command> 是相当新的 “启动系统”，虽然在 <emphasis role="distribution">Wheezy</emphasis> 里已经可以使用到某个程度，直到 Debian <emphasis role="distribution">Jessie</emphasis> 才纳入默认值。稍最的版本，缺省是 “System V init” (在 <emphasis role="pkg">sysv-rc</emphasis> 软件包内)，算是传统的系统。以下描述的是 System V init。
			</para>
			 </sidebar> <sidebar> <title><emphasis>选择</emphasis> 其它启动系统</title>
			 <para>
				本书描述的是 Debian <emphasis role="distribution">Jessie</emphasis> (如 <emphasis role="pkg">systemd</emphasis> 软件包所应用的) 缺省的启动系统，以及更早的默认值，<emphasis role="pkg">sysvinit</emphasis>，源自于 <emphasis>System V</emphasis> Unix 系统；还有若干其他的。
			</para>
			 <para>
				<emphasis role="pkg">file-rc</emphasis> 是一个过程很简单的启动系统。它保留运行等级的原则，但是用配置文件取代了目录和符号链接，来告诉<command>init</command>哪些进程必须启动及其顺序。
			</para>
			 <para>
				此 <command>upstart</command> 系统在 Debian 上仍未完整测试。它以事件为基础：不再依序运行 init 脚本，但以回应另个依附的脚本。由 Ubuntu 开始的这个系统，列在 Debian <emphasis role="distribution">Jessie</emphasis> 内，但还不是缺省；事实上，做为 <emphasis role="pkg">sysvinit</emphasis> 的替代品，由 <command>upstart</command> 启动的工作，系用来启动为传统系统而设的，特别是来自 <emphasis role="pkg">sysv-rc</emphasis> 软件包的脚本。
			</para>
			 <para>
				也有其他的系统和操作模式，例如：<command>runit</command> 或者 <command>minit</command>，但是他们相对专门且没有那么普遍。
			</para>
			 </sidebar> <sidebar> <title><emphasis>特例</emphasis> 从网络启动</title>
			 <para>
				在某些配置中，BIOS 可以配置为不执行 MBR，而是在网络上寻找类似的东西，这样就可以制作不需要硬盘的电脑，在每次启动后可以完全重装。不是所有的硬件都支持该选项，它需要 BIOS 和网卡很好的配合。
			</para>
			 <para>
				从网络启动可以用于执行 <command>debian-installer</command> or FAI （参考 <xref linkend="sect.installation-methods" />）。
			</para>
			 </sidebar> <sidebar> <title><emphasis>回到基础</emphasis>进程，一个程序实例</title>
			 <indexterm>
				<primary>进程</primary>
			</indexterm>
			 <para>
				一个进程代表一个在内存中运行的程序。它包含了需要正确执行软件的所有必要信息（代码本身，内存数据，打开的文件清单，建立的网络连接，等等）。一个程序可能初始化为几个进程，而没必要使用不同的用户 ID 。
			</para>
			 </sidebar> <sidebar> <title><emphasis>安全</emphasis> 使用 shell 作为 <command>init</command> 获取超级用户权限</title>
			 <para>
				通常，第一个启动的进程是 <command>init</command> 程序（默认是到 <filename>/lib/systemd/systemd</filename> 的符号链接）。然而，也可以通过传递 <literal>init</literal> 选项告诉内核使用其他的程序。
			</para>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				任何可以接近电脑的人都能按下<keycap>复位</keycap> 按，并重新启动。然后，在启动提示下，传递<literal>init=/bin/sh</literal>选项给内核，无需知道密码而获取超级用户权限。
			</para>
			 <para>
				为了防止此类事件，可以给加载器设定密码。你也许会考虑保护 BIOS （密码保护总是可行的），这样可以防止侵入者使用包含自己的 Linux 系统的移动介质启动电脑，使用该系统他们可以读取硬盘上的数据。
			</para>
			 <para>
				最后，应该知道大多数 BIOS 有一个通用的密码。最初用于让那些忘记自己密码的人解决问题，这些密码现在是公开的并且可以在网上找到（通过搜索引擎搜索“通用 BIOS 密码”）。所有这些保护措施都不太可能完全阻止非授权用户操作机器。如果攻击者能直接接触电脑，就没有可靠的方法保护电脑；他们可以拆下硬盘连到自己的电脑上，甚至是偷走整个机器，或者擦除 BIOS 来重置密码…
			</para>
			 </sidebar> <para>
				Systemd 运行多个进程，设置系统：键盘、驱动程序、文件系统、网络、服务等。同时全面查看系统，以及必要的配件。每个配件都视为一个 “单元文件” (有时为多个)；通用的语法源自于常用的 “*.ini files“ 语法，包括配对的 <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> 列在 <literal>[<replaceable>section</replaceable>]</literal> 标头内。单元文件保存在 <filename>/lib/systemd/system/</filename> 与 <filename>/etc/systemd/system/</filename> 内；以多种风貌呈现，目前专注在 “服务” 与 “目标”。
			</para>
			 <para>
				systemd “服务文件” 描述被 systemd 管理的进程。包括与旧型的 init-scripts 相同的数据，但以声明 (同时较为简洁) 的方式表述。Systemd 处理大量重复的工作 (启动与终止进程、检查其状态、日注记录、去除特权等)，以及只供特定进程使用的服务文件。例如，以下是 SSH 用到的服务档：
			</para>
			 
<programlisting>[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</programlisting>
			 <para>
				如上文所示，代码极少，只有声明。Systemd 管理显示进度报表、追踪进程、以及必要的重启。
			</para>
			 <para>
				systemd 的 “目标文件” 描述系统的现状，包括可操作的服务。不妨视为相当于旧型的运行阶段作业。其中一个目标是 <literal>local-fs.target</literal>；进入之后，系统的其他部分假设所有的本地文件系统均己挂载并可近用。其他的目标包括 <literal>network-online.target</literal> 与 <literal>sound.target</literal>。目标的相依性可以列在目标文件内 (于 <literal>Requires=</literal> 列) 或使用符号链接至在 <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal> 文件夹内的服务文件。例如，<filename>/etc/systemd/system/printer.target.wants/</filename> 包括一个链接至 <filename>/lib/systemd/system/cups.service</filename>；systemd 将确保 CUPS 已运行至 <literal>printer.target</literal>。
			</para>
			 <para>
				单元文件是声明性的而不是脚本或程序，不能直接运行，只能被 systemd 解译；因些有些工具允许管理者与 systemd 交互且控制系统的状态与其组件。
			</para>
			 <para>
				第一种这类工具是 <command>systemctl</command>。未使用参数运行时，它列出 systemd 已知的所有单元档 (除了已经停用的)，及其现况。<command>systemctl status</command> 则以更佳的角度查看服务，以及相关的进程。若提供服务的名称 (如 <command>systemctl status ntp.service</command>)，则送回更多详细的数据，以及与该服务有关的最后几个日志档 (还有更多的)。
			</para>
			 <para>
				运行 <command>systemctl start <replaceable>servicename</replaceable>.service</command> 就能以人工方式启动服务。同样的，运行 <command>systemctl stop <replaceable>servicename</replaceable>.service</command> 就能停止已完成的服务；其他的次命令包括 <command>reload</command> 与 <command>restart</command>。
			</para>
			 <para>
				以 <command>systemctl enable <replaceable>servicename</replaceable>.service</command> (或 <command>disable</command>) 控制启动服务 (即开机后自动启动)。<command>is-enabled</command> 可以检查服务的状态。
			</para>
			 <para>
				systemd 重要的功能之一是包括登录的组件 <command>journald</command>。做为补充 <command>syslogd</command> 之类传统登录系统的组件，但加入额外的功能包括在服务与其产生消息间的正式链接，以及补捉由初始过程产生的错误消息。在 <command>journalctl</command> 命令的协助下，稍后可显示该等消息。不需任何参数，它溢出系统启动后发生的所有日志消息；不过很少用到它。多数时间，把它做为服务的辨识器：
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</computeroutput></screen>
			 <para>
				另个有用的命令行旗标是 <command>-f</command>，用于指示 <command>journalctl</command> 继续显示溢出的添加消息 (大部分是在 <command>tail -f <replaceable>file</replaceable></command> 之内)。
			</para>
			 <para>
				若服务状况不如预共，第一个步骤是以 <command>systemctl status</command> 检查该服务是否真的已启动；若没有，则第一个命令给的消息就不足以诊断问题之所在，检查 journald 产生的日志档。例如，假设 SSH 服务器未启动时：
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>vi /etc/ssh/sshd_config
</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service
</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </computeroutput></screen>
			 <para>
				检查服务的状态 (失败) 后，再检查日志档；它们会指出配置的错误。编辑配置档并修正错误后，重启服务，确认运行中。
			</para>
			 <sidebar><title><emphasis>下一步</emphasis> 其他类型的单元档</title>
			 <para>
				本区只描述 systemd 最基本的功能。其他的功能只能在此列出若干：
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						启用插口：“插口” 单元文件可用于描述 systemd 管理的网络或 Unix 插口；也就是由 systemd 创建的插口，可以在需要的时候再启动实际的服务。通常重制 <command>inetd</command> 的功能。见 <citerefentry><refentrytitle>systemd.socket</refentrytitle>
						<manvolnum>5</manvolnum></citerefentry>。
					</para>
				</listitem>
				 <listitem>
					<para>
						定时器：“定时器” 单元文件描述定时或在指定时间发生的事件；与定时器链接的服务，其映射的工作将在定时器的要求下才运行。 允许重制 <command>cron</command> 的部分功能。见 <citerefentry><refentrytitle>systemd.timer</refentrytitle>
						<manvolnum>5</manvolnum></citerefentry>。
					</para>
				</listitem>
				 <listitem>
					<para>
						网络：“网络“ 单元文件描述网络接口，允许配置该等接口以及表述在特定接口的服务。
					</para>
				</listitem>

			</itemizedlist>
			</sidebar>
		</section>
		 <section id="sect.sysvinit">
			<title>System V 初始系统</title>
			 <para>
				System V 初始系统 (简称初始) 运行若干进程，根据 <filename>/etc/inittab</filename> 文件的指令做事。第一个运行的程序 (映射于 <emphasis>sysinit</emphasis> 步骤) 是 <command>/etc/init.d/rcS</command>，一个运行在 <filename>/etc/rcS.d/</filename> 文件夹内所有程序的脚本。<indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm>
			</para>
			 <para>
				其中，你会发现相继的程序会负责：
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						配置控制台键盘；
					</para>

				</listitem>
				 <listitem>
					<para>
						加载驱动：当探测到硬件，大部分内核模块通过内核自身加载；然后，自动加载 <filename>/etc/modules</filename> 中列出的模块；
					</para>

				</listitem>
				 <listitem>
					<para>
						检查文件系统的完整性；
					</para>

				</listitem>
				 <listitem>
					<para>
						挂载本地分区；
					</para>

				</listitem>
				 <listitem>
					<para>
						配置网络；
					</para>

				</listitem>
				 <listitem>
					<para>
						挂载网络文件系统（NFS）。
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>回到基础</emphasis> 内核模块和选项</title>
			 <indexterm>
				<primary>模块</primary>
				<secondary>内核模块</secondary>
			</indexterm>
			 <para>
				内核模块也有一些选项，可以通过在 <filename>/etc/modprobe.d/</filename> 中放置一些文件配置。这些选项通过诸如此类的语法定义：<literal>选项 <replaceable>模块名字</replaceable> <replaceable>选项名字</replaceable>=<replaceable>选项值</replaceable></literal>。如果有必要，一些选项可以通过单独的定向命令指示。
			</para>
			 <para>
				这些配置档系供 <command>modprobe</command> 使用 — 这个程序加载核心模块及其相依者 (才能直正的调用其他模块)。这个程序由 <emphasis role="pkg">kmod</emphasis> 软件包提供。
			</para>
			 <indexterm>
				<primary><command>modprobe</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">kmod</emphasis></primary>
			</indexterm>
			 </sidebar> <para>
				到了这个地步，<command>init</command> 接手并启动运行阶段缺省的程序 (通常是运行阶段 2)。它运行 <command>/etc/init.d/rc 2</command>，一个启动列在 <filename>/etc/rc2.d/</filename> 之内的所有服务并命名为 “S” 字母开头。接着的两位数，曾经做为服务启动的顺序，不过现在的缺省启动系统使用 <command>insserv</command>，根据脚本的相依性自动决定其先后顺序。每个启动脚本声明的情况必须符合启动或停止服务 (例如，必须在另个服务之前或之后启动)；<command>init</command> 再依此情况启动它们。不再考虑静态的脚本编号 (但仍需按相依性使用 “S” 及两个数字与实际的脚本名称)。通常，基本的服务 (诸如以 <command>rsyslog</command> 登录，或以 <command>portmap</command> 指定端口口) 先列出来，然后才是标准服务与图形接口 (<command>gdm3</command>)。
			</para>
			 <para>
				这种以依赖为基础的启动系统使自动排序成为可能，这样的排序如果要手工完成则显得冗长乏味。由于调度根据明确给出的参数进行，这样就避免了人为错误。另一个好处是，如果两个服务彼此独立，则可以并行启动，进而加速启动过程。
			</para>
			 <indexterm>
				<primary>运行等级</primary>
			</indexterm>
			 <indexterm>
				<primary>等级，运行等级</primary>
			</indexterm>
			 <para>
				<command>init</command>分几个运行等级，它可以通过<command>telinit <replaceable>new-level</replaceable></command> 命令，从一个等级切换到另一个等级。马上就会在新等级下重新执行<command>init</command> executes <command>/etc/init.d/rc</command>。这个脚本会启动漏掉的服务并中止不再需要的服务。为了做到这一点，它读取<filename>/etc/rc<replaceable>X</replaceable>.d</filename> 文件的内容（此处 <replaceable>X</replaceable> 代表新的运行等级）。以“S"（Start的首字母）开头的服务脚本要启动；以“K"（Kill的首字母）开头的服务要停止。脚本不会启动在之前运行等级已经生效的服务。
			</para>
			 <para>
				缺省，Debian 的 System V init 使用四个不同的运行阶层：
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						等级０仅作电脑关机时的临时应用。这样，它只包含许多“K”脚本。
					</para>

				</listitem>
				 <listitem>
					<para>
						等级１，也被称为单用户模式，对应于降级的系统模式；它仅包含基本服务，用于维护，此时不需要与一般用户交互。
					</para>

				</listitem>
				 <listitem>
					<para>
						等级２用于正常运行，包含网络服务，图形界面，用户登陆，等等。
					</para>

				</listitem>
				 <listitem>
					<para>
						等级６和等级０类似，不同在于它用于系统重启之前的关机。
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				也存在其他等级，从３到５。默认情况，他们配置为和等级２相同，但是管理员可以修改（通过添加和删除对应<filename>/etc/rc<replaceable>X</replaceable>.d</filename>目录下的脚本）它们来适应不同的需求。
			</para>
			 <figure id="figure.boot-process-sysvinit">
				<title>以 System V init 运行 Linux 的启动进程</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/startup-sysvinit.png" format="PNG" scalefit="1" width="80%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <indexterm>
				<primary>初始化脚本</primary>
			</indexterm>
			 <para>
				所有包含在<filename>/etc/rc<replaceable>X</replaceable>.d</filename>目录下的脚本都只是符号联接－有<command>update-rc.d</command>程序在安装时创建－指向存储在<filename>/etc/init.d/</filename>中的实际脚本。管理员可以使用调整后的参数重新运行 <command>update-rc.d</command> 来微调每个运行等级的服务。<citerefentry><refentrytitle>update-rc.d</refentrytitle>
				<manvolnum>1</manvolnum></citerefentry>手册详细介绍了语法。请注意，使用<literal>remove</literal> 参数移除所有的符号连接不是停用服务的好办法。取而代之的方法是，你可以在特定的运行等级将其配置为不启动（而保留先前等级对应事件的停止调用）。由于<command>update-rc.d</command>的接口有些绕，可以考虑使用<command>rcconf</command>（出自<emphasis role="pkg">rcconf</emphasis> 软件包），它提供了更加友好的界面。
			</para>
			 <indexterm>
				<primary><command>update-rc.d</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>DEBIAN 策略</emphasis> 重启服务</title>
			 <indexterm>
				<primary><command>invoke-rc.d</command></primary>
			</indexterm>
			 <indexterm>
				<primary>服务</primary>
				<secondary>重启</secondary>
			</indexterm>
			 <indexterm>
				<primary>重新启动服务</primary>
			</indexterm>
			 <para>
				Debian 软件包的维护者脚本将不时重新启动特定服务以确保其有效性或取得特定的选项。控制服务的命令 — <command>service <replaceable>service</replaceable> <replaceable>operation</replaceable></command> — 未考量运行阶层，假设 (错误地) 该服务仍在使用中，且可能启动错误的作业 (启动应该停止的服务，或停止已经停止的服务等)。因此，Debian 有个 <command>invoke-rc.d</command> 程序：必须由维护者的脚本启动，运行服务的初启脚本且只运行必要的命令。注意，不同于常见的用法，在程序名之前使用 <filename>.d</filename> 前置，且不能在文件夹内。
			</para>
			 </sidebar> <para>
				最后，<command>init</command>启动各种虚拟控制台的控制程序（<command>getty</command>）。显示提示符，等待输入用户名，然后执行<command>login <replaceable>user</replaceable></command>发起会话。
			</para>
			 <indexterm>
				<primary><command>getty</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>词汇</emphasis> 控制台和终端</title>
			 <para>
				早期的计算机通常被分成几个很大的部分：存储箱和中央处理单元与外围操作员的控制设备相分离。这些部件是单独的装置，即“控制台”。该术语被保留下来，但是其意义改变了。或多或少它已经和“终端”同义，代表键盘和屏幕。
			</para>
			 <para>
				随着计算机的发展，操作系统提供了许多虚拟终端，从而允许同时存在几个独立的会话，即使是只有一套键盘和屏幕。大部分 GNU/Linux 系统提供六个虚拟终端（在文本模式），通过组合键 <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> 到 <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo> 开启。
			</para>
			 <para>
				推而广之，术语“控制台”和“终端”也代表在X11图形会话中的终端模拟器（类似<command>xterm</command>，<command>gnome-terminal</command> 或者 <command>konsole</command>）。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.remote-login">
		<title>远程登录</title>
		 <para>
			对于管理员来说有必要远程连接电脑。位于单独房间的服务器，很少配置固定的键盘和显示器－但是他们都会接到网络。
		</para>
		 <sidebar> <title><emphasis>回到基础</emphasis> 客户，服务器</title>
		 <indexterm>
			<primary>客户</primary>
			<secondary>主从架构</secondary>
		</indexterm>
		 <indexterm>
			<primary>服务器</primary>
			<secondary>客户/服务器　架构</secondary>
		</indexterm>
		 <para>
			拥有多个相互通信进程的系统常常被比作“客户／服务器”。服务器是获取客户请求并执行的程序。由客户来控制操作，服务器自身不会发起任何行动。
		</para>
		 </sidebar> <indexterm>
			<primary>登录</primary>
			<secondary>远程登录</secondary>
		</indexterm>
		 <indexterm>
			<primary>远程登录</primary>
		</indexterm>
		 <section id="sect.ssh">
			<title>安全远程登录：SSH</title>
			 <indexterm>
				<primary>SSH</primary>
			</indexterm>
			 <indexterm>
				<primary>Secure Shell</primary>
			</indexterm>
			 <para>
				<emphasis>SSH</emphasis> (Secure SHell) 通信协议系以安全与可靠考量。以 SSH 连接是安全的：伙伴需认证且数据交换经过加密。
			</para>
			 <sidebar> <title><emphasis>文化</emphasis> Telnet 与 RSH 已过时</title>
			 <indexterm>
				<primary><command>telnet</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>rsh</command></primary>
			</indexterm>
			 <para>
				SSH 问世前，<emphasis>Telnet</emphasis> 与 <emphasis>RSH</emphasis> 是远程登录的主要工具。目前已过时，即使 Debian 仍提供此等命令，但已没有人使用它们。
			</para>
			 </sidebar> <sidebar> <title><emphasis>词汇</emphasis> 授权，加密</title>
			 <para>
				当你需要赋给客户在服务器执行或发起行动的能力时，安全是很重要的。必须确定客户的身份；这就是授权。授权通常包含隐秘的口令，否则其他客户很容易获得口令。这是加密的主要目的，这种编码形式可以让两个系统通过公共渠道传递机密信息而不被其他人读到。
			</para>
			 <para>
				授权和加密经常被同时提及，而且也频频同时使用，因为他们通常使用相似的数学算法概念实现。
			</para>
			 </sidebar> <para>
				SSH 还涉及两个文件传输服务。 <command>scp</command> 是一个可以像<command>cp</command>命令一样使用的命令行工具，除了指向其他机器的路径需要加机器名冒号前缀。
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput></screen>
			 <para>
				<command>sftp</command> 是一个交互命令，类似于 <command>ftp</command>。在一个单独会话中， <command>sftp</command> 可以传输多个文件，并且可以远程操作文件（删除，重命名，更改许可，等等）。
			</para>
			 <indexterm>
				<primary><command>scp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sftp</command></primary>
			</indexterm>
			 <para>
				Debian 使用 OpenSSH，一个由 <command>OpenBSD</command> 项目（注重安全，基于 BSD 内核的自由操作系统）维护的自由版本，它效仿了芬兰 SSH Communications Security Corp 公司开发的原始 SSH 软件。该公司最初将 SSH 作为自由软件开发，但是最终决定在专有许可下继续开发。然后，OpenBSD 项目创建了 OpenSSH 维护 SSH 的自由版本。
			</para>
			 <indexterm>
				<primary>OpenSSH</primary>
			</indexterm>
			 <sidebar> <title><emphasis>回到基础</emphasis> <foreignphrase>岔（Fork）</foreignphrase></title>
			 <indexterm>
				<primary>fork</primary>
			</indexterm>
			 <para>
				一个“岔”，在软件领域，意味着克隆已有项目的新项目，并将与之竞争。从此，两个软件通常会迅速发散开发。岔通常由开发团队内部的分歧产生。
			</para>
			 <para>
				项目分岔也是自由软件本身特性产生的结果；如果能使自由软件继续发展，那么分岔也是一种好事（例如万一软件许可证变化）。源自技术或者个人意见不统一的分岔常常是浪费资源；推荐其他的解决方案。之前分岔的项目再次合并也不是未曾听说。
			</para>
			 </sidebar> <para>
				OpenSSH 分裂为两个软件包：客户端是 <emphasis role="pkg">openssh-client</emphasis> 软件包，服务器端是 <emphasis role="pkg">openssh-server</emphasis> 软件包。<emphasis role="pkg">ssh</emphasis> 超软件包依赖这两个部分且需安装它们 (<command>apt install ssh</command>)。
			</para>
			 <section id="sect.ssh-key-based-auth">
				<title>基于密钥的认证</title>
				 <para>
					每次有人通过 SSH 登入，远程服务器询问密码来授权用户。如果想要自动连接或者使用需要频繁通过 SSH 连接的工具，这就会产生问题。这就是为什么 SSH 提供一种基于密钥的认证系统。
				</para>
				 <para>
					户在客户机上用 <command>ssh-keygen -t rsa</command> 产生密钥对；公共密钥存储在<filename>~/.ssh/id_rsa.pub</filename>中，而对应的私有密钥存储在<filename>~/.ssh/id_rsa</filename>中。然后，用户使用<command>ssh-copy-id <replaceable>server</replaceable></command> 将他们的公共密钥添加到服务器上的 <filename>~/.ssh/authorized_keys</filename> 文件中。如果私有密钥在创建的时候没有“口令密语”保护，随后所有在服务器上的登录将不需要口令。然而，私有密钥在每次输入口令时都必须被解密。幸运的是， <command>ssh-agent</command> 允许我们把私有密钥放在内存中而不必频繁重新输入口令。为此，可以简单的使用 <command>ssh-add</command> （每个工作会话一次）来指明该会话已经和 <command>ssh-agent</command>功能实例相关联。Debian 在图形界面会话中默认激活这一特性，也可以通过改变 <filename>/etc/X11/Xsession.options</filename>来停用。对于控制台会话，可以使用 <command>eval $(ssh-agent)</command>手动启动。
				</para>
				 <sidebar> <title><emphasis>安全</emphasis> 保护私有密钥</title>
				 <para>
					任何拥有私有密钥的人都可以登录已经配置的账户。这是私有密钥要使用“口令密码”保护的原因。某些获得了私有密钥文件（例如 <filename>~/.ssh/id_rsa</filename>）副本的人，要使用这个文件仍然需要密码。然而，这种额外的保护措施并不是万全的，如果觉得文件被破解，最好在所安装的计算机上禁用该密钥（通过从文件 <filename>authorized_keys</filename> 移除）并使用新生成的密钥取代它。
				</para>
				 </sidebar> <sidebar> <title><emphasis>文化</emphasis> OpenSSL 在 Debian <emphasis role="distribution">Etch</emphasis>上的缺陷</title>
				 <para>
					OpenSSL 程序库，首先由 Debian <emphasis role="distribution">Etch</emphasis> 提供，在其随机数值产生器 (random number generator, RNG) 里有重大缺陷。所以，Debian 维护者修改它，使用 <command>valgrind</command> 之类的内存测试工具时，不再产生警示消息。不幸的是，此种改变让 RNG 套用一个熵值对应 32,000 个可能的处理编号 (PID)，不足以称为乱数。<ulink type="block" url="http://www.debian.org/security/2008/dsa-1571" />
				</para>
				 <para>
					特别是当OpenSSL 用于产生密钥，它总是生成一个在已知几百万值集合范围内的密钥（32000乘上密钥长度中的小数字）。这会影响SSH 密钥，SSL 密钥，和X.509认证，他们被大量程序使用，例如OpenVPN。骇客只能尝试所有的密钥来取得未授权的读取。为了减小问题的影响，SSH 守护进程会拒绝使用 <emphasis role="pkg">openssh-blacklist</emphasis> 和 <emphasis role="pkg">openssh-blacklist-extra</emphasis> 软件包中列出的有问题密钥。另外， <command>ssh-vulnkey</command> 命令允许在系统中使用某些折中密钥。
				</para>
				 <para>
					进一步分析这个事件，发现影响多个 (小) 问题，包括 OpenSSL 计划内与 Debian 软件包维护者。像 OpenSSL 这种被广泛使用程序库，被 <command>valgrind</command> 测试时，应该 — 未经修改 — 不能产生警示。尤有甚者，其代码 (尤其是像 RNG 这么敏感的部分) 应该有更好的说明以避免这种错误。从 Debian 的角度来看，维护者要向 OpenSSL 开发者认证其修改的部分，但单纯的解说修改而未提供对应的补丁供查看，以致 Debian 发生前述的错误。最后，维护者的选择是次要的选项：源代码的修改没有清楚的文档；所有的修改都保存在典藏所的次版本内，但是把所有的修改总结在一个补丁内纳入原始软件包中。
				</para>
				 <para>
					It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <ulink type="block" url="http://sources.debian.org" />
				</para>
				 </sidebar>
			</section>
			 <section id="sect.ssh-x11">
				<title>使用远程 X11 应用程序</title>
				 <para>
					SSH 协议允许转发图形数据（“X11”会话，源于最广泛传播Unix图形系统的名字）；然后，服务器为这些数据保留固定通道。特别地，远程执行的图形程序可以在本地系统X.org服务器屏幕上显示，并且整个会话（输入和显示）都是安全的。由于该特性允许远程应用与本地系统交互，因此默认是关闭的。您可以指明<literal>X11Forwarding yes</literal>参数，将其写入服务器配置文件（<filename>/etc/ssh/sshd_config</filename>）以启用该功能。最后，用户必须通过添加 <literal>-X</literal> 选项到 <command>ssh</command> 命令行中以提出功能请求。
				</para>

			</section>
			 <section id="sect.ssh-port-forwarding">
				<title>通过端口转发建立加密通道</title>
				 <indexterm>
					<primary>端口转发</primary>
				</indexterm>
				 <para>
					它的 <literal>-R</literal> 和 <literal>-L</literal> 选项允许 <command>ssh</command> 在两个机器间添加 “加密信道”，把本地 TCP 端口 (见专栏 <xref linkend="sidebar.tcp-udp" />) 映射至远程机器或反之。
				</para>
				 <sidebar> <title><emphasis>词汇</emphasis> 隧道</title>
				 <indexterm>
					<primary>信道 (SSH)</primary>
					<seealso>VPN</seealso>
				</indexterm>
				 <indexterm>
					<primary>SSH 信道</primary>
					<seealso>VPN</seealso>
				</indexterm>
				 <para>
					大多数局域网通过数据包模式而不是连接模式接入互联网，意味着：由一个计算机发送到另一个计算机的数据包要找到目的地会在几个间歇路由之间停顿。仍然可以通过数据流IP 数据包封装模拟连接操作。这些数据包流过路由，但是数据流在目的地不加改变重新构造。我们称之为“隧道”，类比为机动车从入口（输入）直接开向出口（输出）的公路通道，期间不会碰到任何交汇，与在表面可能交叉和变向的路径相对。
				</para>
				 <para>
					可以利用这个机会给隧道加密：流过的数据在外面不能被辨认，但是在隧道的出口解密恢复。
				</para>
				 </sidebar> <para>
					运行<command>ssh -L 8000:server:25 intermediary</command> 命令，将会建立同服务器主机<replaceable>intermediary</replaceable> 的SSH 会话，并侦听本地端口8000 ¼参考see <xref linkend="figure.ssh-L" />）。对于任何建立在该端口的连接， <command>ssh</command> 将会发起从电脑<replaceable>intermediary</replaceable> 到 <replaceable>server</replaceable> 端口25 的连接，并将两个连接绑定。
				</para>
				 <para>
					命令<command>ssh -R 8000:server:25 intermediary</command>也会建立电脑 <replaceable>intermediary</replaceable> 的SSH 会话，但是在本机 <command>ssh</command> 侦听端口8000 （参考 <xref linkend="figure.ssh-R" />）。在该端口建立的连接将<command>ssh</command> 打开本机到 <replaceable>server</replaceable>25 端口的连接，并将两个连接绑定。
				</para>
				 <para>
					两种情况下，连接建立在<replaceable>server</replaceable> 主机的25 端口，它会透过SSH 隧道建立本地机器和中介机器的连接。在头一种情况下，到该隧道的入口是本地端口8000，数据在定向到公共网络的<replaceable>server</replaceable> 之前，流向 <replaceable>intermediary</replaceable> 。在第二种情况下，隧道输入输出被保留；入口是 <replaceable>intermediary</replaceable> 的8000 端口，输出在本地主机，然后数据被定向到 <replaceable>server</replaceable>。实际上，服务器不是本地机器就是中介机器。这样SSH 保护了一端到另一端的连接。
				</para>
				 <figure id="figure.ssh-L">
					<title>使用SSH转发本地端口</title>
					 <mediaobject>
						<imageobject>
							<imagedata fileref="images/ssh-L.png" format="PNG" width="35%" />
						</imageobject>

					</mediaobject>

				</figure>
				 <figure id="figure.ssh-R">
					<title>使用SSH转发远程端口</title>
					 <mediaobject>
						<imageobject>
							<imagedata fileref="images/ssh-R.png" format="PNG" width="35%" />
						</imageobject>

					</mediaobject>

				</figure>

			</section>

		</section>
		 <section id="sect.remote-desktops">
			<title>使用远程图形桌面</title>
			 <para>
				VNC （Virtual Network Computing）允许远程接入图形桌面。
			</para>
			 <indexterm>
				<primary>VNC</primary>
			</indexterm>
			 <indexterm>
				<primary>Virtual Network Computing 虚拟网络处理</primary>
			</indexterm>
			 <indexterm>
				<primary>图形桌面</primary>
				<secondary>远程</secondary>
			</indexterm>
			 <indexterm>
				<primary>远程图形桌面</primary>
			</indexterm>
			 <indexterm>
				<primary>桌面，远程图形桌面</primary>
			</indexterm>
			 <para>
				该工具主要用于技术支持；管理员可以看到用户面临的错误，并演示正确的操作而不必待在他们旁边。
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vino</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">krfb</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">x11vnc</emphasis></primary>
			</indexterm>
			 <para>
				首先，用户必须授权共享其进程。在 <emphasis role="distribution">Jessie</emphasis> 配置面版 (不同于稍早的 Debian 版本，用户必须安装并运行 <command>vino</command>) 的GNOME 图形桌面环境已有此选项。KDE 桌面环境仍需使用 <command>krfb</command> 才能经由 VNC 共享既有的进程。其他皂图形桌面环境，<command>x11vnc</command> 命令 (在同名的 Debian 软件包内) 也能达到同样的结果；以明确的图标标明。
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vinagre</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">tsclient</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">krdc</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">xvnc4viewer</emphasis></primary>
			</indexterm>
			 <para>
				从 VNC 取得图形进程时，管理者必须链接至 VNC 客户端。GNOME 有 <command>vinagre</command> 和 <command>remmina</command> 命令链接，而 KDE 使用 <command>krdc</command> (在 <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice> 菜单内)。还有使用命令行的其他 VNC 客户端，诸如 <command>xvnc4viewer</command> 在 Debian 的同名软件包内。链接后，管理者可以看到远程的桌面、操控远程桌面、并让远程用户知道运作的方式。
			</para>
			 <sidebar> <title><emphasis>安全</emphasis> VNC 使用 SSH</title>
			 <indexterm>
				<primary>SSH 隧道</primary>
				<secondary>VNC</secondary>
			</indexterm>
			 <para>
				想要经由 VNC 链接，但不想在网络传输纯文本数据，可以把数据打包在 SSH 信道内 (见 <xref linkend="sect.ssh-port-forwarding" />)。只需知道 VNC 缺省在第一个屏幕使用端口号 5900 (称为 “localhost:0”)，端口号 5901 用在第二个端口号 (称为 “localhost:1”)，等等。
			</para>
			 <para>
				<command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command>命令创建本地端口5901 和 <replaceable>machine</replaceable> 5900 端口的隧道。第一个“localhost”要求SSH 仅侦听本地机器接口。第二个“localhost”指示远程机器上的接口接收进入“localhost:5901”的网络数据。因此， <command>vncviewer localhost:1</command> 会把VNC 客户连到远程屏幕。
			</para>
			 <para>
				当VNC 会话关闭时，记得退出相应的SSH 会话来关闭隧道。
			</para>
			 </sidebar> <sidebar> <title><emphasis>回到基础</emphasis> 显示管理器</title>
			 <indexterm>
				<primary><command>gdm3</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>kdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>xdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>lightdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary>管理器</primary>
				<secondary>显示管理器</secondary>
			</indexterm>
			 <indexterm>
				<primary>显示管理器</primary>
			</indexterm>
			 <para>
				<command>gdm3</command>、<command>kdm</command>、<command>lightdm</command>、和 <command>xdm</command> 都是显示管理者。他们在启动后不久就控制图形接口担供登录画面。用户登录后，再运行启动图形工作进程所需的程序。
			</para>
			 </sidebar> <para>
				VNC 也可供移动用户、或公司运行者使用，这些人偶而需要从家中的电脑远程登录办公室的桌面电脑。这种配置稍为复杂些：首先安装 <emphasis role="pkg">vnc4server</emphasis> 软件包，改变显示管理者的配置，以便接受 <literal>XDMCP Query</literal> 请求 (给 <command>gdm3</command>，添加 <literal>Enable=true</literal> 于 <filename>/etc/gdm3/daemon.conf</filename> 的 “xdmcp” 区块)，然后以 <command>inetd</command> 启动 VNC 服务器，接着在用户试图登录时，自动开启进程。例如，可以在 <filename>/etc/inetd.conf</filename> 内加入这一列：
			</para>
			 
<programlisting>5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</programlisting>
			 <para>
				重新定向输入链接至显示管理者，解决认证的问题，因为只有本地帐号的用户才能通过 <command>gdm3</command> 登录画面 (或同级的 <command>kdm</command>、<command>xdm</command>等)。当此作业允许同时登录多个用户 (服务器够力是前提)，就能够提供完整的桌面给远程用户 (或稍为不够力的桌面系统，则需要配置为精简客户)。使用只需以 <command>vncviewer <replaceable>server</replaceable>:50</command> 登录服务器画面，因为用到的端口号是 5950。
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vnc4server</emphasis></primary>
			</indexterm>

		</section>

	</section>
	 <section id="sect.rights-management">
		<title>管理权限</title>
		 <para>
			Linux 是一个典型的多用户系统，这就有必要提供许可制度来控制对文件和目录的操作，其中包含了所有的系统资源和设备（在Unix 系统中，任何设备都由文件或目录来表示）。这一原则对所有Unix 系统通用，这里再提醒一下，特别是对一些有趣的相对高级应用。
		</para>
		 <indexterm>
			<primary>权限</primary>
		</indexterm>
		 <indexterm>
			<primary>许可</primary>
		</indexterm>
		 <indexterm>
			<primary>用户</primary>
			<secondary>所有者</secondary>
		</indexterm>
		 <indexterm>
			<primary>组</primary>
			<secondary>所有者</secondary>
		</indexterm>
		 <indexterm>
			<primary>所有者</primary>
			<secondary>用户</secondary>
		</indexterm>
		 <indexterm>
			<primary>所有者</primary>
			<secondary>组</secondary>
		</indexterm>
		 <para>
			每个文件和文件夹有三种用户许可类型：
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					所有者 （使用符号 <literal>u</literal> “user”首字母）；
				</para>

			</listitem>
			 <listitem>
				<para>
					所有者组（使用符号 <literal>g</literal> “group”首字母），代表组中的所有成员；
				</para>

			</listitem>
			 <listitem>
				<para>
					其他（使用符号 <literal>o</literal> “other”的首字母）。
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			有三种可以相互结合的权限类型：
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					读取（使用符号 <literal>r</literal> “read”的首字母）；
				</para>

			</listitem>
			 <listitem>
				<para>
					写（使用符号 <literal>w</literal> “write”的首字母）；
				</para>

			</listitem>
			 <listitem>
				<para>
					执行（使用“eXecute”中的符号 <literal>x</literal> ）。
				</para>

			</listitem>

		</itemizedlist>
		 <indexterm>
			<primary>读取权限</primary>
		</indexterm>
		 <indexterm>
			<primary>写权限</primary>
		</indexterm>
		 <indexterm>
			<primary>修改权限</primary>
		</indexterm>
		 <indexterm>
			<primary>运行、权限</primary>
		</indexterm>
		 <para>
			以文件来说，其权利较容易理解：读取就是允许读取其内容 (包括复制)、写入就是允许改变它、而运行就是跑它 (文件本身必须是程序)。
		</para>
		 <sidebar> <title><emphasis>安全</emphasis> <literal>setgid</literal> 目录和 <emphasis>粘着位</emphasis></title>
		 <para>
			两个特殊权限和可执行文件相关：<literal>setuid</literal> 和 <literal>setgid</literal>（使用字符“s”表示）。请注意，我们常常称之为“位”，因为这些布尔值可以用一个0或者一个1表示。这两种权限允许任何用户以相应文件的所有者或组的身份执行程序。这种机制可以允许用户使用那些需要更高级别的授权才能工作的特性，即使普通用户原本不具备其使用权限。
		</para>
		 <indexterm>
			<primary><literal>setuid</literal>，权限</primary>
		</indexterm>
		 <indexterm>
			<primary><literal>setgid</literal>，权限</primary>
		</indexterm>
		 <para>
			由于 <literal>setuid</literal> 根程序在系统层以超级用户的身份运行，有必要确定其安全性和可靠性。实际上，如果用户可以侵入该程序并调用自己设定的命令，就有可能伪装成超级用户并获取系统的所有权限。
		</para>
		 </sidebar> <para>
			文件夹的处理方式略有不同。读取其条目 (文件及文件夹)、写入包括添加与删除文件、而运行则是进入它 (尤其是使用 <command>cd</command> 命令)。进入文件夹而不必有读取权限，运行已知的文件名，若不知其正确的名称，则无法运行。
		</para>
		 <sidebar id="sidebar.setgid-dir"> <title><emphasis>安全</emphasis> <literal>setgid</literal> 目录和 <emphasis>粘着位</emphasis></title>
		 <indexterm>
			<primary><literal>setgid</literal> 文件夹</primary>
		</indexterm>
		 <para>
			<literal>setgid</literal> 位也适用于目录。在这种目录中新创建的条目会被自动赋予其父目录的所有组，而不是通常情况下那样继承创建者的主用户组。这种设置可以避免几个同组用户在共享文件树中协同工作时（为保持所创建文件的所有组的一致性）而不得不改变自身主用户组的额外工作（使用 <command>newgrp</command> 命令）。
		</para>
		 <indexterm>
			<primary>粘着位</primary>
		</indexterm>
		 <para>
			“粘着”位（使用符号“t”）是仅用于目录的许可位。专门用于所有人都有写权限的临时目录（例如 <filename>/tmp/</filename>）：它严格限制删除操作，只有所有者（或者父目录的所有者）可以删除。少了它，所有人都能删除其他用户在 <filename>/tmp/</filename>中的文件。
		</para>
		 </sidebar> <para>
			有三个控制文件许可权限的命令：
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					<command>chown <replaceable>用户</replaceable> <replaceable>文件</replaceable></command> 命令更改文件的所有者；
				</para>

			</listitem>
			 <listitem>
				<para>
					<command>chgrp <replaceable>组</replaceable> <replaceable>文件</replaceable></command> 改变所有组
				</para>

			</listitem>
			 <listitem>
				<para>
					<command>chmod <replaceable>权限</replaceable> <replaceable>文件</replaceable></command> 改变文件许可权限。
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			有两种方法表示权限。其中，符号表示是最易于理解和记忆的。它使用前述的符号链接。可以通过显示的设置（<literal>u</literal>/<literal>g</literal>/<literal>o</literal>），通过加（<literal>+</literal>），或者减（<literal>-</literal>）定义每种用户的权限类型。一个 <literal>u=rwx,g+rw,o-r</literal> 格式的命令会赋予所有者读，写和执行权限，给所有组添加读写权限，移除其他用户的读权限。其他命令中未通过加或者减列出的权限保持不变。字母 <literal>a</literal>是指“所有”，涵盖三种类型的用户，因此 <literal>a=rx</literal> 命令会赋予三种用户相同的权限（读和执行，没有写）。
		</para>
		 <indexterm>
			<primary><command>chmod</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>chown</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>chgrp</command></primary>
		</indexterm>
		 <indexterm>
			<primary>权限的八进制表示</primary>
		</indexterm>
		 <indexterm>
			<primary>权限</primary>
			<secondary>八进位表示法</secondary>
		</indexterm>
		 <para>
			与权限相关的（八进制）数字表示：4是读，2是写，1是执行。各种权限组合通过代表的数字求和得到。通过把每个值置于端到端序列不同位置关联不同的用户类型（所有者，所有组，其他用户）。
		</para>
		 <para>
			比如， <command>chmod 754 <replaceable>file</replaceable></command> 会设置如下的权限：所有者读，写和执行（由于7 = 4 + 2 + 1）；所有组读和执行（由于 5 = 4 + 1）；其他用户只读。 <literal>0</literal> 意味着没有任何权限；因此 <command>chmod 600 <replaceable>file</replaceable></command> 允许所有者读写，而其他人没有任何权限。对可执行文件和目录，最常用的权限组合是 <literal>755</literal> ，对数据文件是 <literal>644</literal> 。
		</para>
		 <para>
			要表示特殊权限，可以根据同样的原则在数字上加入第四个前缀位，位 <literal>setuid</literal>， <literal>setgid</literal> 和 <literal>sticky</literal> 分别对应4，2，和1。<command>chmod 4754</command> 会设置前面描述的 <literal>setuid</literal> 位权限。
		</para>
		 <para>
			八进位标记只适用于对文件的一次性设置所有权限；不能以它加入新的权限，如群组拥有者的读取，因为必须把现在的权限与计算新的数值。
		</para>
		 <sidebar> <title><emphasis>提示</emphasis> 递归操作</title>
		 <para>
			有时需要更改整个文件树的权限。以上所有的命令都有 <literal>-R</literal> 选项来递归操作子目录。
		</para>
		 <para>
			文件夹与文件的不同，有时造成递归运算的问题。所以，在符号式权限里加入 “X” 字母。它代表只对文件夹 (不是文件) 的运行权。因此，<command>chmod -R a+X <replaceable>directory</replaceable></command> 对至少一个范畴用户 (即使只有一个拥有者) 已经有运行权的所有次文件夹与文件，只对所有范畴用户加入运行权 (<literal>a</literal>)。
		</para>
		 </sidebar> <sidebar> <title><emphasis>提示</emphasis> 改变组和用户</title>
		 <para>
			通常在改变拥有者的时候，也要改变文件的群组。<command>chown</command> 命令有个特别的语法，用在这个时机：<command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command>
		</para>
		 </sidebar> <sidebar> <title><emphasis>进阶</emphasis> <command>umask</command></title>
		 <para>
			当应用程序创建文件的时候，它指定许可权限，而系统则会根据 <command>umask</command>命令的内容，自动地移除某些权限。在命令界面输入 <command>umask</command> ：会看到类似 <computeroutput>0022</computeroutput>的掩码。这是一个八进制数代表了会被系统移除的权限（在本例中，是指对所有组和其他用户的写权限）。
		</para>
		 <indexterm>
			<primary>umask</primary>
		</indexterm>
		 <indexterm>
			<primary>权限</primary>
			<secondary>掩码</secondary>
		</indexterm>
		 <indexterm>
			<primary>掩码</primary>
			<secondary>权限掩码</secondary>
		</indexterm>
		 <para>
			如果指定新的八进制数值， <command>umask</command> 命令会修改掩码。在命令行界面初始化文件中使用 （例如<filename>~/.bash_profile</filename>），它会改变会话默认的掩码。
		</para>
		 </sidebar>
	</section>
	 <section id="sect.administration-interfaces">
		<title>管理员界面</title>
		 <indexterm>
			<primary>界面</primary>
			<secondary>管理员界面</secondary>
		</indexterm>
		 <indexterm>
			<primary>管理，界面</primary>
		</indexterm>
		 <para>
			在各种情况下，使用图形界面进行管理都很有趣。管理员不必了解所有服务的配置信息，不用翻阅文档。因此，用于图形界面进行管理可以加速服务的部署过程。也能简化那些比较难的服务设置过程。
		</para>
		 <para>
			此类界面只是辅助，它自身并不解决问题。在各种情况下，管理员必须控制它，以便理解并处理各种潜在的问题。
		</para>
		 <para>
			接口不会完美的，总有其他的解决方案。不过，应尽量避免使用多种解决方案，因为不同的工具彼此间不见得兼容。即使宣称极有弹性且以单一模式使用配置档，不见得能够集成所有的外部改变。
		</para>
		 <section id="sect.webmin">
			<title>管理网页接口：<command>webmin</command></title>
			 <indexterm>
				<primary><emphasis>webmin</emphasis></primary>
			</indexterm>
			 <para>
				毋庸置疑，这是最成功的管理界面。它是透过网络浏览器的模块化系统，覆盖了广泛的领域和工具。而且，它是国际化的并且可以在多种语言中使用。
			</para>
			 <para>
				不幸的是，<command>webmin</command> 不是 Debian 的一部分。Debian 维护者 — Jaldhar H. Vyas — 移除他自建的软件包，因为他没有时间把该程序维护至相当水准。没有人正式接手，所以 <emphasis role="distribution">Jessie</emphasis> 没有 <command>webmin</command> 软件包。
			</para>
			 <para>
				然而，非官方的软件包可在 <literal>webmin.com</literal> 网站找到。不同于原自于 Debian 的软件包，此软件包有点古老；即使没有安装对应的服务，仍缺省安装与启用其配置模块。
			</para>
			 <sidebar> <title><emphasis>安全</emphasis> 更改超级用户密码</title>
			 <para>
				第一次登录时，先辨识 root 的用户名与密码。建议立即以 <command>webmin</command> 变更密码，则不会用到服务器缺省的 root 密码，不再使用该机器缺省的密码。
			</para>
			 <para>
				小心！由于 <command>webmin</command> 有如此多特性，恶意用户对其进行访问，则有可能危及整个系统的安全性。通常，在安全性能要求较高的重要系统（防火墙，敏感数据服务器，等）上应尽量不使用此类界面。
			</para>
			 </sidebar> <para>
				Webmin 通过 web 界面访问，不需要安装 Apache 网络服务器。该软件集成了它自己的微型网络服务器。默认监听10000 端口，等待安全 HTTP 连接。
			</para>
			 <para>
				包括大量多样化的服务模块，其中包括：
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						所有的基础服务：创建用户和组，管理 <filename>crontab</filename> 文件，初始 init 脚本，查看记录文件，等。
					</para>

				</listitem>
				 <listitem>
					<para>
						bind：DNS 服务配置（域名服务）；
					</para>

				</listitem>
				 <listitem>
					<para>
						postfix：SMTP 服务配置（电子邮件）；
					</para>

				</listitem>
				 <listitem>
					<para>
						inetd：配置 <command>inetd</command> 服务；
					</para>

				</listitem>
				 <listitem>
					<para>
						quota：用户配额管理；
					</para>

				</listitem>
				 <listitem>
					<para>
						dhcpd：DHCP 服务配置；
					</para>

				</listitem>
				 <listitem>
					<para>
						proftpd：FTP 服务配置；
					</para>

				</listitem>
				 <listitem>
					<para>
						samba：Samba 文件服务配置
					</para>

				</listitem>
				 <listitem>
					<para>
						软件：从Debian 软件包安装或者移除软件和系统更新。
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				管理界面可以通过在网络浏览器中输入地址 <literal>https://localhost:10000</literal>。注意！不是所有的模块都是直接可用的。有些必须通过指定相应的配置文件和可执行文件（程序）。如果没能启动请求的模块，系统往往会给出提示。
			</para>
			 <sidebar> <title><emphasis>其他</emphasis> GNOME 控制中心</title>
			 <indexterm>
				<primary><emphasis role="pkg">gnome-control-center</emphasis></primary>
			</indexterm>
			 <para>
				GNOME 计划也提供经由右上角用户菜单 “设置” 的多管理接口。<command>gnome-control-center</command> 是主计划，还有其他软件包提供的配置工具 (<emphasis role="pkg">accountsservice</emphasis>、<emphasis role="pkg">system-config-printer</emphasis>等)。虽然使用简易，不过只包括有限的基本服务：用户管理、时间配置、网络配置、打印机配置等。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.debconf">
			<title>用于管理配置的软件包： <command>debconf</command></title>
			 <indexterm>
				<primary><command>debconf</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>dpkg-reconfigure</command></primary>
			</indexterm>
			 <para>
				使用Debconf 工具，许多软件包在安装过程中问过少许问题后能自动配置。这些软件包可以通过运行 <command>dpkg-reconfigure <replaceable>软件包</replaceable></command>来重新配置。
			</para>
			 <para>
				对于大多数情况，设置很简单；只改变配置文件中的几个重要变量。常常把这些变量放在两个分隔行内，重新配置只会影响其内的数据。其他情况下，如果脚本探测到手动更改了配置文件，为了保留这些人为编辑，重新配置什么也不做（因为脚本不能确定它的修改不会弄乱已有的设置）。
			</para>
			 <sidebar> <title><emphasis>DEBIAN 政策</emphasis> 保留更改</title>
			 <para>
				Debian 政策明确规定应尽量保留对配置文件的手动更改，这样越来越多的脚本在编辑配置文件时会采取措施。一般原则很简单：只有在理解配置文件的状态下，脚本才会做出更改，通过对比现在的文件和上次自动产生的文件校验和就可以验证文件是否经过人为修改。如果两个校验和相同，授权脚本更改配置文件。否则，文件被改过，询问采取什么行动（安装新文件，保存旧文件，或者尝试把新更改集成到已有文件内）。这种预警原则长久以来是Debian的特性，但是现在其他的发行版也开始渐渐采取这种做法。
			</para>
			 <para>
				<command>ucf</command> 程序（在Debian 中拥有同名的软件包）能用于实施这种行为。
			</para>
			 <indexterm>
				<primary><command>ucf</command></primary>
			</indexterm>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.syslog">
		<title><command>syslog</command> 系统事件</title>
		 <indexterm>
			<primary><command>rsyslogd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>文件</primary>
			<secondary>日志文件</secondary>
		</indexterm>
		 <indexterm>
			<primary>日志档</primary>
			<secondary>差遣</secondary>
		</indexterm>
		 <section id="sect.syslog-principe">
			<title>原则与机制</title>
			 <para>
				此 <command>rsyslogd</command> 后台进程负责搜集来自应用程序与核心的服务消息，然后送至日志档内 (通常保存在 <filename>/var/log/</filename> 文件夹内)。遵守 <filename>/etc/rsyslog.conf</filename> 配置文件的要求。
			</para>
			 <para>
				每个日志信息都和应用子系统相关联（文档中称为“facility”）：
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>auth</literal> 和 <literal>authpriv</literal>：用于授权；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>cron</literal>：源于任务调度服务， <command>cron</command> 和 <command>atd</command>；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>daemon</literal>：影响未分类的守护进程（DNS， NTP，等）；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ftp</literal>：涉及FTP 服务器；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>kern</literal>：源于内核的消息
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>lpr</literal>：源于打印子系统；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>mail</literal>：源于电子邮件子系统；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>news</literal>：Usenet 子系统消息（主要源自NNTP －网络消息传输协议－管理新闻组的服务器）；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>syslog</literal>：源于 <command>syslogd</command> 服务自身的消息；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>user</literal>：用户消息；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uucp</literal>：源于UUCP（Unix to Unix Copy Program，一种老式的分发电子邮件消息的协议）服务的消息；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>local0</literal> 到 <literal>local7</literal>：保留本地使用。
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				每种消息都有其优先级。下面按降序列出：
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>emerg</literal>：“救命！” 紧急状态，系统可能已挂了。
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>alert</literal>赶快，任何推迟都是危险的，必须马上采取行动；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>crit</literal>：情况很严苛；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>err</literal>：错误；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>warn</literal>：警告（潜在的错误）；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>notice</literal>：正常情况，但是该消息很重要；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>info</literal>：提供信息；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>debug</literal>：调试消息。
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section id="sect.syslog-config">
			<title>配置文件</title>
			 <para>
				<filename>/etc/rsyslog.conf</filename> 文件的详细语法在 <citerefentry><refentrytitle>rsyslog.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> 手册中，在 <emphasis role="pkg">rsyslog-doc</emphasis> 软件包中也有一份 HTML 文档（<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>）。总的原则是要写“选择器（selector）”和“行为（action）”配对。选择器定义所有相关消息，行为描述如何处理。
			</para>
			 <section id="sect.syslog-selector-syntax">
				<title>选择器语法</title>
				 <para>
					选择器是由分号分隔的 <literal><replaceable>子系统</replaceable>清单。<replaceable>优先级</replaceable></literal> 配对（例如： <literal>auth.notice;mail.info</literal>）。星号代表所有的子系统和优先级（例如： <literal>*.alert</literal> 或者 <literal>mail.*</literal>）。几个子系统可以通过逗号合并成组（例如： <literal>auth,mail.info</literal>）。优先级指明相同或更高优先级的消息；因此 <literal>auth.alert</literal> 指具有 <literal>alert</literal> 和 <literal>emerg</literal> 优先级的<literal>auth</literal> 子系统消息。惊叹号（！）前缀表示求反，换句话说指低等级的优先级；因此 <literal>auth.!notice</literal>指有 <literal>auth</literal>产生的具有 <literal>info</literal> 或 <literal>debug</literal> 优先级的消息。等号（＝）前缀表示精确指定某种优先级（<literal>auth.=notice</literal> 只关心具有 <literal>notice</literal> 优先级的 <literal>auth</literal> 消息）。优先级依次为：debug, info, notice, warning/warn, err/error , crit, alert, emerg/panic。
				</para>
				 <para>
					列在选择器中的元素会覆盖先前的元素。因此可以限定一个集合或者排除一些元素。例如， <literal>kern.info;kern.!err</literal> 表示源于内核优先级在 <literal>info</literal> 和 <literal>warn</literal>之间的消息。 <literal>none</literal> 优先级指示空集（无优先级），可用于从集合中排除一个子系统消息。于是， <literal>*.crit;kern.none</literal> 指所有优先级等于或高于 <literal>crit</literal> 但不是来自内核的消息。
				</para>

			</section>
			 <section id="sect.syslog-action-syntax">
				<title>行为的语法</title>
				 <sidebar> <title><emphasis>回到基础</emphasis> 命名管道，持续管道</title>
				 <indexterm>
					<primary>命名管道</primary>
				</indexterm>
				 <indexterm>
					<primary>管道，命名管道</primary>
				</indexterm>
				 <para>
					命名管道是一种特殊类型的文件，可以像传统管道一样操作（通过在命令行中使用“｜”符号），但是命名管道通过文件。这种机制的优点是可以关联两个不相干的进程。任何对命名管道的写操作会阻塞该进程直到另一个进程试图读数据。第二个进程读出第一个进程写的数据，第一个进程恢复执行。
				</para>
				 <para>
					这种文件由 <command>mkfifo</command> 命令创建。
				</para>
				 </sidebar> <para>
					各种可能的行为包括：
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							添加信息到文件（例如： <filename>/var/log/messages</filename>）；
						</para>

					</listitem>
					 <listitem>
						<para>
							将消息发送到 <command>syslog</command> 远程服务器（例如： <literal>@log.falcot.com</literal>）；
						</para>

					</listitem>
					 <listitem>
						<para>
							将消息发送至已有的命名管道（例如： <literal>|/dev/xconsole</literal>）；
						</para>

					</listitem>
					 <listitem>
						<para>
							将消息发给一个或多个已经登录的用户（如： <literal>root,rhertzog</literal>）；
						</para>

					</listitem>
					 <listitem>
						<para>
							将消息发给所有登录用户（如： <literal>*</literal>）；
						</para>

					</listitem>
					 <listitem>
						<para>
							将消息写入文本控制台（如： <literal>/dev/tty8</literal>）。
						</para>

					</listitem>

				</itemizedlist>
				 <sidebar> <title><emphasis>安全</emphasis> 转发日志</title>
				 <indexterm>
					<primary>日志</primary>
					<secondary>转发</secondary>
				</indexterm>
				 <para>
					将一些重要日志保存在单独的机器（可能是日志专用）是很好的主意，这样可以防止侵入者移除他们的入侵痕迹（除非，他们也入侵了该日志服务器）。另外，碰到一些重要问题（像内核崩溃），日志变量都在另外的机器上，就更有机会确定导致崩溃的事件顺序。
				</para>
				 <para>
					要接受其他机器发来的消息，必须配置 <emphasis>rsyslog</emphasis>：实际上，只要激活 <filename>/etc/rsyslog.conf</filename> 中已有的选项就足够了（<literal>$ModLoad imudp</literal> and <literal>$UDPServerRun 514</literal>）。
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.inetd">
		<title>The <command>inetd</command> 超级服务器</title>
		 <para>
			Inetd（常被称为“网络超级服务”）是一个服务器服务。它按需求运行一些不常用的服务，而且不需要连续运行。
		</para>
		 <indexterm>
			<primary><command>inetd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>超级服务</primary>
		</indexterm>
		 <para>
			<filename>/etc/inetd.conf</filename> 文件列出服务器及其通用的端口号。<command>inetd</command> 命令侦测它们；若发现任何端口号已被链接，则运行对应的程序。
		</para>
		 <sidebar> <title><emphasis>DEBIAN 政策</emphasis> 在<filename>inetd.conf</filename>中注册服务</title>
		 <para>
			软件包经常需要在 <filename>/etc/inetd.conf</filename> 文件登录新的服务器，但 Debian 政策禁止任何软件包不属于自身的配置档。所以有 <command>update-inetd</command> 脚本 (在同名软件包内)：管理配置文件以及其他软件包，使其在超级服务器的配置中登录新的服务器。
		</para>
		 </sidebar> <para>
			<filename>/etc/inetd.conf</filename> 文件中的每列条目以 7 个字段 (以空格区分) 描述服务器：
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					TCP 或者UDP 端口号，或者服务名称（用<filename>/etc/services</filename> 文件中包含的信息映射到标准端口号）。
				</para>

			</listitem>
			 <listitem>
				<para>
					套接字类型： <literal>stream</literal> 用于TCP 连接， <literal>dgram</literal> 用于UDP 数据包。
				</para>

			</listitem>
			 <listitem>
				<para>
					协议： <literal>tcp</literal> 或 <literal>udp</literal>。
				</para>

			</listitem>
			 <listitem>
				<para>
					选项：两个可能值：<literal>wait</literal> 或 <literal>nowait</literal>，告诉 <command>inetd</command> 在接受另个链接时，是否该等待或终止已启用的进程。对 TCP 链接而言，可使用 <literal>nowait</literal>，进入多任务。对回应 UDP 的程序而言，只在服务器可平行管理多个链接时，才使用 <literal>nowait</literal>。可在这个字段前加上圆点，以及每分钟可以开启的最大链接量 (缺省为 256)。
				</para>

			</listitem>
			 <listitem>
				<para>
					用户名，服务将以哪个用户的身份运行。
				</para>

			</listitem>
			 <listitem>
				<para>
					要执行程序的完整路径。
				</para>

			</listitem>
			 <listitem>
				<para>
					参数：此处是程序的完整参数列表，包括程序名（C中的<literal>argv[0]</literal> ）。
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			下面的例子阐释最常见的情况：
		</para>
		 <example id="example.inetd-conf">
			<title>摘自 <filename>/etc/inetd.conf</filename></title>
			 
<programlisting>talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd
finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd
ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i</programlisting>

		</example>
		 <indexterm>
			<primary><command>tcpd</command></primary>
		</indexterm>
		 <para>
			<command>tcpd</command> 程序常用于 <filename>/etc/inetd.conf</filename> 文件中。以近用控制规则的方式限制送来的链接数，相关文档在 <citerefentry><refentrytitle>hosts_access</refentrytitle>
			<manvolnum>5</manvolnum></citerefentry> 手册页面，并在 <filename>/etc/hosts.allow</filename> 与 <filename>/etc/hosts.deny</filename> 文件中配置。授权链接后，<command>tcpd</command> 运行真实的服务器 (在此例中是 <command>in.fingerd</command>)。值得注意的是 <command>tcpd</command> 依靠启用的名称 (即第一个参数，<literal>argv[0]</literal>) 辨识真实运行的程序。所以不该启用 <literal>tcpd</literal> 内的参数清单，应先与程序包装在一起。
		</para>
		 <sidebar> <title><emphasis>社区</emphasis> Wietse Venema</title>
		 <indexterm>
			<primary>Wietse Venema</primary>
		</indexterm>
		 <indexterm>
			<primary>Venema, Wietse</primary>
		</indexterm>
		 <para>
			Wietse Venema由于在安全方面的专业使他成了一位很有名望的程序员，他是 <command>tcpd</command> 程序的作者。他也是Postfix，模块电子邮件服务器（SMTP）的主要创建者，该服务要设计的比 <command>sendmail</command>更安全和可靠。
		</para>
		 </sidebar> <sidebar> <title><emphasis>另外的选择</emphasis> 其他 <command>inetd</command> 命令</title>
		 <para>
			当 Debian 缺省安装 <emphasis role="pkg">openbsd-inetd</emphasis> 后，就有很多选项：可用 <emphasis role="pkg">inetutils-inetd</emphasis>、<emphasis role="pkg">micro-inetd</emphasis>、<emphasis role="pkg">rlinetd</emphasis> 和 <emphasis role="pkg">xinetd</emphasis>。
		</para>
		 <para>
			最后的这个超级服务载体提供了很有趣的特性。最引人注目的是，它的配置文件可以分割成几个不同文件（存储在 <filename>/etc/xinetd.d/</filename> 目录），让管理员更容易管理。
		</para>
		 <para>
			最后但不是最不重要，甚至可以仿真 <command>inetd</command> 的行为，以 <command>systemd</command> 的插座启用模式运作 (见 <xref linkend="sect.systemd" />)。
		</para>
		 </sidebar>
	</section>
	 <section id="sect.task-scheduling-cron-atd">
		<title>使用 <command>cron</command> 和 <command>atd</command>运行计划任务</title>
		 <indexterm>
			<primary><command>cron</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>atd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>调度命令</primary>
		</indexterm>
		 <indexterm>
			<primary>命令调度</primary>
		</indexterm>
		 <para>
			<command>cron</command> 是负责调度和运行周期命令（每天，每周，等）的守护进程； <command>atd</command> 用于处理单次执行命令，命令将在未来某个指定时刻运行。
		</para>
		 <para>
			在Unix 系统，许多任务都被周期性的调度：
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					更新日志；
				</para>

			</listitem>
			 <listitem>
				<para>
					更新 <command>locate</command> 程序数据库；
				</para>

			</listitem>
			 <listitem>
				<para>
					备份；
				</para>

			</listitem>
			 <listitem>
				<para>
					维护脚本（例如清理临时文件）。
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			默认情况下，所有用户都可以运行计划任务。每个用户有他们自己的 <emphasis>crontab</emphasis> 其中记录了要调度的命令。可以运行 <command>crontab -e</command> 编辑（其内容存储在 <filename>/var/spool/cron/crontabs/<replaceable>user</replaceable></filename> 文件中）。
		</para>
		 <sidebar> <title><emphasis>安全</emphasis> 限制 <command>cron</command> 或者 <command>atd</command></title>
		 <para>
			可以通过创建排他性的授权文件 <filename>/etc/cron.allow</filename>来限制对 <command>cron</command> 的访问，其中指明仅那些用户有权调度。而其他用户则自动被剥夺权限。相反，想仅阻止一两个问题用户，可以将其写入禁止文件（黑名单），<filename>/etc/cron.deny</filename>。 <command>atd</command>也具有相同的特性，对应文件 <filename>/etc/at.allow</filename> 和 <filename>/etc/at.deny</filename> 。
		</para>
		 </sidebar> <para>
			超级用户有自己的 <emphasis>crontab</emphasis>，但是也可以使用 <filename>/etc/crontab</filename> 文件，或者在 <filename>/etc/cron.d</filename> 目录中写入另外的<emphasis>crontab</emphasis> 文件。这两种方法可以用来指明执行命令时的用户身份。
		</para>
		 <para>
			<emphasis>cron</emphasis> 软件包默认包含一些可执行的调度命令：
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					每小时运行在 <filename>/etc/cron.hourly/</filename> 文件夹内的程序;
				</para>

			</listitem>
			 <listitem>
				<para>
					每天运行在 <filename>/etc/cron.daily/</filename> 文件夹内的程序;
				</para>

			</listitem>
			 <listitem>
				<para>
					每周运行在 <filename>/etc/cron.weekly/</filename> 文件夹内的程序;
				</para>

			</listitem>
			 <listitem>
				<para>
					每月运行在 <filename>/etc/cron.monthly/</filename> 文件夹内的程序。
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			很多 Debian 软件包依赖此服务：把维护脚本置于此文件夹，确保其服务的最佳运作。
		</para>
		 <section id="sect.format-crontab">
			<title><filename>crontab</filename> 文件的格式</title>
			 <indexterm>
				<primary><filename>crontab</filename></primary>
			</indexterm>
			 <sidebar> <title><emphasis>提示</emphasis> <command>cron</command>中的快捷方式</title>
			 <para>
				<command>cron</command> 可以识别一些简写名称用以表示在 <filename>crontab</filename> 中开头的五个时间区段。他们对应最常用的调度选项：
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>@yearly</literal>：每年一次（一月一号，００:００）；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@monthly</literal>：每月一次（每月一号，００:００）；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@weekly</literal>：每周一次（周日００:００）；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@daily</literal>：每天一次（在００:００）；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@hourly</literal>：每小时一次（在每小时开始）。
					</para>

				</listitem>

			</itemizedlist>
			 </sidebar> <sidebar> <title><emphasis>特例</emphasis> <command>cron</command> 和日光节约时间</title>
			 <para>
				在Debian中， <command>cron</command> 尽量考虑时间变更（夏令时，或者本地时间的重大变化）。因此，被安排到不存在时间（例如，安排在法国春季时间２:３０执行的任务，而时钟在凌晨２:００之后会直接跳到凌晨３:００）的命令会在时间改变后马上执行（大概在夏令时３:００）。另一方面，在秋天，需要多次执行的命令（夏令时凌晨２:３０，标准时间凌晨２:３０之后一个小时，由于凌晨在３:００，时钟被回调至凌晨２:００）只会执行一次。
			</para>
			 <para>
				要当心了，如果不同任务的调度顺序和延迟相互关联，就需要检查使用 <command>cron</command>时，是否兼容一致；如果有必要，为每年可能发生问题的夜晚准备专门的调度程序。
			</para>
			 </sidebar> <para>
				<emphasis>crontab</emphasis> 每列以六个 (或七个) 字段描述排定的命令：
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						分钟值（从０到５９）；
					</para>

				</listitem>
				 <listitem>
					<para>
						小时（从０到２３）；
					</para>

				</listitem>
				 <listitem>
					<para>
						每月的日期值（从１到３１）；
					</para>

				</listitem>
				 <listitem>
					<para>
						月份值（从１到１２）；
					</para>

				</listitem>
				 <listitem>
					<para>
						星期值（从０到７,１对应星期一，０和７都代表星期日；也可以使用星期英文表示单次的前三个字母，例如 <literal>Sun</literal>， <literal>Mon</literal>，等）；
					</para>

				</listitem>
				 <listitem>
					<para>
						命令将以哪个用户的名义执行（在文件 <filename>/etc/crontab</filename>和 <filename>/etc/cron.d/</filename>中，而不是在用户自己的调度文件中）；
					</para>

				</listitem>
				 <listitem>
					<para>
						要执行的命令（当满足前面５栏定义的条件时）。
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				全部的细节记录在 <citerefentry><refentrytitle>crontab</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry> 手册中。
			</para>
			 <para>
				每个值可以表示为所有可能值的列表（使用逗号分隔）。语法<literal>a-b</literal> 描述介于 <literal>a</literal> 和 <literal>b</literal>中间的所有值。语法 <literal>a-b/c</literal> 描述以<literal>c</literal> 为增量间隔（例如： <literal>0-10/2</literal> 代表 <literal>0,2,4,6,8,10</literal>）。星号 <literal>*</literal> 是通配符，代表所有可能值。
			</para>
			 <example id="example.crontab">
				<title>示例 <filename>crontab</filename> 文件</title>
				 
<programlisting>#格式
#分钟 小时 天 月份 星期 命令

# 每天晚上七点二十五分下载数据
 25  19   *   *   *    $HOME/bin/get.pl

# 周内每天早上八点（周一至周五）
 00  08   *   *   1-5  $HOME/bin/dosomething

# 每次重启后启动 IRC 代理
@reboot /usr/bin/dircproxy</programlisting>

			</example>
			 <sidebar> <title><emphasis>提示</emphasis> 在启动时运行命令</title>
			 <para>
				只是在系统启动后，单次执行一个命令，可以使用 <literal>@reboot</literal> 宏（仅仅重启 <command>cron</command> 命令不会触发使用<literal>@reboot</literal>调度的命令）。该宏表示了 <emphasis>crontab</emphasis>条目的前五个区段。
			</para>
			 </sidebar> <sidebar> <title><emphasis>其他</emphasis> 仿真 <command>cron</command> 用 <command>systemd</command></title>
			 <para>
				部分 <command>cron</command> 的行为，可以用 <command>systemd</command> 的时间机制仿真 (见 <xref linkend="sect.systemd" />)。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.at-command">
			<title>使用 <command>at</command> 命令</title>
			 <indexterm>
				<primary><command>at</command></primary>
			</indexterm>
			 <para>
				<command>at</command> 在未来的特定时间运行某个命令。以命令行参数的模式在指定的时间与日期运行，并把结果以标准方式键入。键入当前的 shell 就可以运行该命令。<command>at</command> 甚至保留当前的环境，以便重现运行该命令的情境。以惯例显示时间：<literal>16:12</literal> 或 <literal>4:12pm</literal> 代表下午 4 点 12 分。日期可以使用欧洲或西方的格式，包括 <literal>DD.MM.YY</literal> (<literal>27.07.15</literal> 表示27日7月2015年)，<literal>YYYY-MM-DD</literal> (等同于 <literal>2015-07-27</literal>)，<literal>MM/DD/[CC]YY</literal> (就是，<literal>12/25/15</literal> 或 <literal>12/25/2015</literal> 指的是12月25日，2015)，或 <literal>MMDD[CC]YY</literal> (即 <literal>122515</literal> 或 <literal>12252015</literal> 代表12月25日，2015)。少了它，则在时间到就运行 (同一天、或若时间已过则是隔天)。也可写成 “today” 或 “tomorrow”，就是今天或明天。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>
<computeroutput>&gt; </computeroutput><userinput>echo "Don't forget to wish a Happy Birthday to Raphaël!" \</userinput>
<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>
<computeroutput>&gt; </computeroutput><userinput>END</userinput>
<computeroutput>warning: commands will be executed using /bin/sh
job 31 at Mon Jul 27 09:00:00 2015</computeroutput></screen>
			 <para>
				另外一种方法可以向后推迟一段时间执行命令：<command>at now + <replaceable>数字</replaceable> <replaceable>间隔</replaceable></command>。 <replaceable>间隔</replaceable> 可以是 <literal>分钟</literal>, <literal>小时</literal>, <literal>天</literal>, 或者 <literal>星期</literal>。 <replaceable>数字</replaceable> 指明在命令执行之前消逝时间的单位数量。
			</para>
			 <para>
				要取消 <command>cron</command>中的计划任务，运行 <command>crontab -e</command> 删除 <emphasis>crontab</emphasis> 文件中的对应行。对于使用 <command>at</command> 命令的任务，同样简单：运行 <command>atrm <replaceable>任务编号</replaceable></command>。任务编号在调度时有 <command>at</command> 命令指定，可以通过 <command>atq</command> 命令查询找到，该命令给出当前计划任务清单。
			</para>
			 <indexterm>
				<primary><command>atrm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>atq</command></primary>
			</indexterm>

		</section>

	</section>
	 <section id="sect.asynchronous-task-scheduling-anacron">
		<title>调度异步任务：<command>anacron</command></title>
		 <para>
			<command>anacron</command> 用于不能全天候开机的电脑，替代完成 <command>cron</command> 命令的守护进程。由于常规的计划任务通常被安排在午夜执行，如果计算机当时没有开机就不会运行这些任务。 <command>anacron</command> 的目的就在于运行这些计划任务，并考虑计算机关机时间。
		</para>
		 <indexterm>
			<primary><command>anacron</command></primary>
		</indexterm>
		 <para>
			请注意 <command>anacron</command> 会在启动机器之后，频频执行此类活动，有可能导致计算机反应迟缓。这也正是<filename>/etc/anacrontab</filename> 文件中的任务以 <command>nice</command> 命令开头的原因，这样可以减小它们执行优先级进而限制它们对系统的影响。注意，该文件的格式和 <filename>/etc/crontab</filename>不完全相同；如果对 <command>anacron</command>有特殊需求设定，可参看 <citerefentry><refentrytitle>anacrontab</refentrytitle>
			 <manvolnum>5</manvolnum></citerefentry> 手册。
		</para>
		 <sidebar> <title><emphasis>回到基础</emphasis> 优先级和 <command>nice</command></title>
		 <para>
			Unix 系统（包括Linux）都是多任务，多用户系统。实际上，几个进程可以并行执行，而且属于不同的用户：内核隔离并管理不同进程对资源的访问。作为完成该任务的一部分，就产生了优先级的概念，它允许按需求将某些进程排在其他进程前面。如果已知一个进程可以在低优先级运行，可以通过 <command>nice <replaceable>程序</replaceable></command>来指定。该程序会享有很少的CPU时间，对其他正在运行的进程影响也更小。当然，如果没有其他进程在运行，程序也不会被人为停住。
		</para>
		 <para>
			<command>nice</command> 会给优先级添加“niceness”：正值优先级（从１到１９）逐渐降低优先级，而负值（从－１到－２０）增加优先级－但是仅有超级用户可以使用负值优先级。除非特别指明（参看 <citerefentry><refentrytitle>nice</refentrytitle>
			 <manvolnum>1</manvolnum></citerefentry> 手册）， <command>nice</command> 将当前优先级加１０。
		</para>
		 <para>
			若发现已运行的工作应以 <command>nice</command> 启动，修正它并不算太迟；<command>renice</command> 命令可改变运行中进程的优先序，增加或减少均可 (但减少 “niceness” 是超级用户的权限)。
		</para>
		 </sidebar> <para>
			安装 <emphasis role="pkg">anacron</emphasis> 软件包会禁用 <command>cron</command> 在 <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename>, 和 <filename>/etc/cron.monthly/</filename>目录中的脚本。避免 <command>anacron</command> 和 <command>cron</command>重复运行这些脚本。 <command>cron</command> 命令仍然可用并处理其他计划任务（特别是用户安排的计划任务）。
		</para>

	</section>
	 <section id="sect.quotas">
		<title>配额</title>
		 <indexterm>
			<primary>额度</primary>
		</indexterm>
		 <para>
			配额系统可以限制对用户与群组可用的磁盘空间。设置时，必须有核心支持它 (以 <varname>CONFIG_QUOTA</varname> 选项编译) — 使用 Debian 核心时。配额管理软件在 <emphasis role="pkg">quota</emphasis> Debian 软件包内。
		</para>
		 <para>
			在文件系统内启用配额时，必须指明e <literal>usrquota</literal> 与 <literal>grpquota</literal> 选项于 <filename>/etc/fstab</filename> 中，分别供用户与群组使用。重新启动电脑后，就能在未使用的磁盘空间中更新配额 (必须如此，才能重新计算已使用的磁盘空间)。
		</para>
		 <para>
			<command>edquota <replaceable>user</replaceable></command> (或 <command>edquota -g <replaceable>group</replaceable></command>) 命令允许在仍有磁盘空间的前提下，改变配额。
		</para>
		 <indexterm>
			<primary><command>edquota</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>进阶</emphasis> 使用脚本定义配额</title>
		 <indexterm>
			<primary><command>设置配额</command></primary>
		</indexterm>
		 <para>
			可以在脚本中使用 <command>setquota</command> 程序自动更改配额。<citerefentry><refentrytitle>setquota</refentrytitle>
			 <manvolnum>8</manvolnum></citerefentry> 手册列出了详细的使用语法。
		</para>
		 </sidebar> <para>
			配额系统允许设置四个限制：
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					两种限制（称为“软的”和“硬的”）使用消耗的块数表示。如果文件系统使用１Ｋ的块创建，相同文件的每个块包含１０２４字节。不饱和的块会减少磁盘空间。１００个块的配额，理论上允许存储１０２４００字节，然而，它们有可能被１００个每个包含５００字节的文件填充，总数仅仅是５００００字节。
				</para>

			</listitem>
			 <listitem>
				<para>
					两种限制（软的和硬的）使用的节点（inode）数限制。每个文件至少需要一个包含存储信息（许可权限，所有者，最后读取时间，等）的节点。因此，它实际上是限制了用户文件的数量。
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			“软”限制可以被临时超越；当用户超过 <command>warnquota</command> 命令指定的配额，只是给出警告，通常有 <command>cron</command>唤起该命令。“硬”限制不允许被超出：系统将会拒绝任何超出硬配额的操作。
		</para>
		 <sidebar> <title><emphasis>词汇</emphasis> 块和节点（inodes）</title>
		 <indexterm>
			<primary>块（磁盘）</primary>
		</indexterm>
		 <indexterm>
			<primary>节点</primary>
		</indexterm>
		 <para>
			文件系统将硬盘分成块－一些连续的小区域。这些块的大小在创建文件系统时定义，一般在１Ｋ到８Ｋ字节之间。
		</para>
		 <para>
			块可用来存储文件中的真实数据，也可用于文件系统的元数据。在元数据中，就会找到节点。一个节点使用硬盘上的一个块（但是该块并不会计入块配额，只用于节点配额），包含了节点对应哪个文件（名称，所有者，许可权限，等）和实际使用数据块的指针。对于那些大文件，占用的块数已经超出单个指针的索引范围，还存在一个间接块系统；其中的节点参考一个块列表，该列表中的块不直接包含数据而是包含另一个块列表。
		</para>
		 </sidebar> <indexterm>
			<primary><command>warnquota</command></primary>
		</indexterm>
		 <para>
			使用命令 <command>edquota -t</command> ，可以设定超过软限制的“宽限期”时长。宽限期之后，软限制将作为硬限制处理，要将数据写入硬盘，用户必须减少磁盘使用量至配额之内。
		</para>
		 <sidebar> <title><emphasis>进阶</emphasis> 给新用户设定默认配额</title>
		 <para>
			要给新用户自动设定配额，需要配置用户模板（使用 <command>edquota</command> 或者 <command>setquota</command>）并在 <filename>/etc/adduser.conf</filename> 文件的 <varname>QUOTAUSER</varname> 变量中指明用户名。该配额配置会自动应用于 <command>adduser</command> 命令创建的新用户。
		</para>
		 </sidebar>
	</section>
	 <section id="sect.backup">
		<title>备份</title>
		 <para>
			制作备份是管理员的主要责任之一，但它是个相对复杂的课题，并包含一些很难掌握的强大工具。
		</para>
		 <indexterm>
			<primary>备份</primary>
		</indexterm>
		 <indexterm>
			<primary>恢复</primary>
		</indexterm>
		 <para>
			很多程序系供备份之用，如 <command>amanda</command>、<command>bacula</command>、<command>BackupPC</command>。主从架构程序有很多选项，其配置相当困难。部分有亲和力强的网页接口减轻其负担。但 Debian 还有十多种备份软件可用，以 <command>apt-cache search backup</command> 命令可搜索它们。
		</para>
		 <indexterm>
			<primary><command>amanda</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>bacula</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>BackupPC</command></primary>
		</indexterm>
		 <para>
			本章节并没有详细介绍这些工具，而是介绍 Falcot Corp （本书中虚构的公司）管理员们确定备份策略时的思路。
		</para>
		 <para>
			在 Falcot Corp公司，备份有两个目的：恢复被误删的文件，迅速恢复硬盘损坏的电脑。
		</para>
		 <section>
			<title>使用 <command>rsync</command>备份</title>
			 <para>
				以磁带备份太慢且太贵，现在采用备份在专属服务器的硬盘策略，以 RAID (见 <xref linkend="sect.raid-soft" />) 软件保护数据在硬盘毁损时不致遗失。桌面电脑没有个别备份的策略，用户应在部分的文件服务器备份其数据。<command>rsync</command> 命令 (取自同名的软件包) 用于逐日备份这些服务器。
			</para>
			 <indexterm>
				<primary><command>rsync</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>回到基础</emphasis> 硬链接，文件的第二个名字</title>
			 <indexterm>
				<primary>链接</primary>
				<secondary>硬链接</secondary>
			</indexterm>
			 <indexterm>
				<primary>硬链接</primary>
			</indexterm>
			 <para>
				相对于符号链接，硬链接不能自外于被链接文件。添加的硬链接等于给文件另个名称。删除硬链接等于删除该文件的另个名称。只要还有另个名称指定给文件，则数据仍在文件系统内。不同于复制，硬链接并未在硬盘里复制另个空间。
			</para>
			 <para>
				硬链接使用 <command>ln <replaceable>target</replaceable> <replaceable>link</replaceable></command> 命令创建。 然后<replaceable>link</replaceable> 文件是<replaceable>target</replaceable> 文件另外的新名字。硬链接只能在相同的文件系统上创建，而符号链接不受此限制。
			</para>
			 </sidebar> <para>
				有限的硬盘空间限制了每天完全备份数据。由此，<command>rsync</command> 命令对之前备份的内容使用硬链接，这样可以避免使用过多的硬盘空间。 然后<command>rsync</command> 进程只覆盖上次备份后修改过的文件。通过这种机制，大量的备份只占用小的磁盘空间。所有的备份会立即生效并且可以读写（例如，在共享网络上的不同目录），可以迅速比较两个不同日期的文件。
			</para>
			 <indexterm>
				<primary>拷贝, 备份拷贝</primary>
			</indexterm>
			 <indexterm>
				<primary>备份</primary>
				<secondary>拷贝</secondary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">dirvish</emphasis></primary>
			</indexterm>
			 <para>
				这种备份机制可以通过 <command>dirvish</command> 程序执行。使用备份存储空间（“空”的），放置有时间戳的备份文件集（这些文件集在dirvish 文档中被成为“vaults”）。
			</para>
			 <para>
				主要配置在 <filename>/etc/dirvish/master.conf</filename> 文件中。它定义了备份存储空间的位置，要管理的“vaults”，和备份超期的默认值。配置的其他部分在 <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> 文件中，包含对应文件集的特殊配置。
			</para>
			 <example id="example.dirvish-master">
				<title><filename>/etc/dirvish/master.conf</filename> 文件</title>
				 
<programlisting>bank:
    /backup
exclude:
    lost+found/
    core
    *~
Runall:
    root    22:00
expire-default: +15 days
expire-rule:
# MIN HR    DOM MON       DOW  STRFTIME_FMT
    *   *     *   *         1    +3 months
    *   *     1-7 *         1    +1 year
    *   *     1-7 1,4,7,10  1</programlisting>

			</example>
			 <para>
				<literal>bank</literal> 设置保存备份的文件夹。<literal>exclude</literal> 设置不列入备份的文件 (或文件类型)。<literal>Runall</literal> 是做为备份时间戳记的文件清单，若未在指定的时间备份时，还可以其指定的时间复制文件。可以指定在实际运行时间前 (也就是，缺省在 10:04 pm，根据 <filename>/etc/cron.d/dirvish</filename>)。最后，<literal>expire-default</literal> 和 <literal>expire-rule</literal> 设置备份失效政策。以上的范例永远在每季的第一个星期日运行备份，并在一年后的每月第一个星期日删除它，以及在三个月后的另个星期日删除它。其他的逐日备份则保留 15 天。运行的顺序有关系，Dirvish 使用最后符合的规则，或 <literal>expire-default</literal> 若无其他的 <literal>expire-rule</literal> 符合。
			</para>
			 <sidebar> <title><emphasis>实践</emphasis>　使用SSH远程备份</title>
			 <para>
				失效规则未被 <command>dirvish-expire</command> 使用。实际上，在添加备份副本时，设置该复本失效的日期。<command>dirvish-expire</command> 细读保存的复本并删除也达失效日期的文件。
			</para>
			 </sidebar> <example id="example.dirvish-vault">
				<title><filename>/backup/root/dirvish/default.conf</filename> 文件</title>
				 
<programlisting>client: rivendell.falcot.com
tree: /
xdev: 1
index: gzip
image-default: %Y%m%d
exclude:
    /var/cache/apt/archives/*.deb
    /var/cache/man/**
    /tmp/**
    /var/tmp/**
    *.bak</programlisting>

			</example>
			 <para>
				上面的例子中指明了要备份的文件集：这些文件在机器 <emphasis>rivendell.falcot.com</emphasis> 上（对本地数据备份，只需指明本地机器 <command>hostname</command>），主要是在根目录下（<literal>tree: /</literal>），除了在 <literal>exclude</literal>中列出的文件。备份仅限于一个文件系统中的内容（<literal>xdev: 1</literal>）。不包含其他挂载点的文件。产生保存文件的索引（<literal>index: gzip</literal>），镜像根据当前日期进行命名（<literal>image-default: %Y%m%d</literal>）。
			</para>
			 <para>
				有许多可用选项，都记录在 <citerefentry><refentrytitle>dirvish.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> 手册中。一旦这些配置文件设定好后，必须要使用<command>dirvish --vault <replaceable>vault</replaceable> --init</command> 命令来初始化每个文件集。此后每天在删除过期备份之后，就会自动唤起 <command>dirvish-runall</command> 进行备份。
			</para>
			 <sidebar> <title><emphasis>实践</emphasis>　使用SSH远程备份</title>
			 <para>
				把数据保存在远程机器时，需用 <command>ssh</command> 命令链接它，并启用 <command>rsync</command> 做为服务器。需以超级使者的权限才能自动链接。以 SSH 认证码精确链接 (见 <xref linkend="sect.ssh-key-based-auth" />)。
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>不使用备份恢复系统</title>
			 <para>
				桌面电脑不需要备份，以 <emphasis>Simple-CDD</emphasis> (见 <xref linkend="sect.simple-cdd" />) 刻录的 DVD-ROM 就能简单地重新安装。回到原始的状态，旧有的设置全部消失。通常链接至中央的 LDAP 文件夹，大部分桌面的设置存在 dconf (见 <xref linkend="sect.gnome-desktop" /> 的详细数据)。
			</para>
			 <para>
				Falcot Corp 的管理者知道该公司备份政策的限制。未以防火墙保护备份服务器，而是把它放在另个房间，以免在灾难来临时与主服务器同归一烬。而且，每周以 DVD-ROM 做增量备份 — 只备份修改过的文件。
			</para>
			 <sidebar> <title><emphasis>进阶 </emphasis> 备份SQL 和LDAP 服务</title>
			 <para>
				很多服务 (诸如 SQL 或 LDAP 数据库) 不能以复制文件的方式备份其系统 (unless they are properly interrupted during creation of the backups, which is frequently problematic, since they are intended to be available at all times)。因此，必须以 “导出” 机制生成 “倒出数据” 才能安全地备份。量很大，妥善地压缩。为了减少保存空间，每周只保存完成的文本档，以及每天的 <command>diff</command>，以 <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command> 命令创建。<command>xdelta</command> 程序从二进位倒出增量的不同数据。
			</para>
			 <indexterm>
				<primary><command>xdelta</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>diff</command></primary>
			</indexterm>
			 <indexterm>
				<primary>dump</primary>
			</indexterm>
			 </sidebar> <sidebar> <title><emphasis>文化</emphasis> <emphasis>TAR</emphasis>，磁带备份标准</title>
			 <indexterm>
				<primary>备份</primary>
				<secondary>磁带</secondary>
			</indexterm>
			 <indexterm>
				<primary>磁带，备份</primary>
			</indexterm>
			 <indexterm>
				<primary>TAR</primary>
			</indexterm>
			 <para>
				历史上，在Unix 上制作备份最简单的方法是将一个 <emphasis>TAR</emphasis> 档案存到磁带上。 <command>tar</command> 甚至得名于“Tape ARchive”。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.hotplug">
		<title>热插拔： <emphasis>热插拔</emphasis></title>
		 <section>
			<title>介绍</title>
			 <para>
				<emphasis>hotplug</emphasis> 次系统核心，以动态方式加载适当的驱动程且 (在 <command>udevd</command> 的协助下)添加对应的设备文件，处理加入与移除设备的作业。当代的硬件与虚拟化，几乎每个对象都是热插拔：从常见的 USB/PCMCIA/IEEE 1394 周边到 SATA 硬盘，以及 CPU 与内存。
			</para>
			 <para>
				核心内的数据库有每个设备的 ID 及其驱动程序。在启动阶段加载此数据库，侦测各接口的周边设备，并在运行中侦测热插入的设备。接收到插入的设备后，送出消息给 <command>udevd</command>，让其添加对应的条目于 <filename>/dev/</filename> 内。
			</para>
			 <indexterm>
				<primary><emphasis>热插拔</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>热插拔</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>PCMCIA</primary>
			</indexterm>
			 <indexterm>
				<primary>SATA</primary>
			</indexterm>

		</section>
		 <section>
			<title>命名问题</title>
			 <para>
				在热插拔连接出现之前，很容易给设备赋予一个固定的名字。可以通过设备在总线上的位置简单命名。但是，如果设备能够在总线上来去自如，这就行不通了。典型的例子是数码相机和U 盘，两者都表现为磁盘驱动器。前者可能链接为 <filename>/dev/sdb</filename> ，后者可能是 <filename>/dev/sdc</filename> （假设<filename>/dev/sda</filename> 代表计算机自身的硬盘）。设备名是不固定的；它取决于设备连接的顺序。
			</para>
			 <para>
				另外，越来越多的驱动使用动态值作为设备的主、次设备号，这样就更不可能给设备赋予静态入口，而重启之后这些基本的特性也随之变化。
			</para>
			 <para>
				<emphasis>udev</emphasis> 正是为了解决该问题而创立的。
			</para>

		</section>
		 <section>
			<title><emphasis>udev</emphasis> 如何工作</title>
			 <para>
				当 <emphasis>udev</emphasis> 被核心告知有个新的设备，它参考 <filename>/sys/</filename> 里对应的条目，搜集该设备的信息，尤其是那些足辨别的独特信息 (网卡的 MAC 地址、某些 USB 设备的序号)。
			</para>
			 <para>
				有了这些信息之后，然后 <emphasis>udev</emphasis> 会查阅<filename>/etc/udev/rules.d/</filename> 和 <filename>/lib/udev/rules.d/</filename>中包含的所有规则。在这个过程中，它会决定如何命名设备，创建什么样的符号连接（赋予设备另外的名字），执行什么命令。查询所有的文件，顺序（除非文件中使用“GOTO”指令）检查所有的规则。这样，有可能一个事件（event）对应多个规则。
			</para>
			 <para>
				规则文件的语法很简单：每行包含选择规则和变量赋值。前者用于需要对那些事件作出相应，后者定义采取何种行动。它们通过逗号分隔，用运算符区分选择规则（使用比较运算符，例如<literal>==</literal> or <literal>!=</literal>）或赋值指令（使用 <literal>=</literal>, <literal>+=</literal> 或 <literal>:=</literal>运算符）。
			</para>
			 <para>
				比较运算符用于如下变量：
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>内核</literal>：内核赋予设备的名字；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>行动</literal>：与事件相对应的行动（“add”当设备被添加，“remove”当设备被移除）；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>DEVPATH</literal>：设备在 <filename>/sys/</filename> 记录中的路径；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SUBSYSTEM</literal>：产生请求的内核子系统（有很多这样的子系统，少数的例子是“usb”，“usb”，“net”，“firmware”，等）；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ATTR{<replaceable>属性</replaceable>}</literal>：<replaceable>属性</replaceable> 文件的内容在设备的 <filename>/sys/<replaceable>$devpath</replaceable>/</filename> 文件夹内。可在此找到 MAC 地址及其他辨识用的总线;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>KERNELS</literal>， <literal>SUBSYSTEMS</literal> 和 <literal>ATTRS{<replaceable>attributes</replaceable>}</literal> 是用来匹配当前设备父设备的选项变量；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>PROGRAM</literal>：指明要运行的测试程序（真则返回０）。程序的输出内容会被储存以便 <literal>RESULT</literal> 测试重用；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>RESULT</literal>：对最后一次调用 <literal>PROGRAM</literal>产生的结果进行检查。
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				右操作数可以使用模式表达式来同时匹配几个值。比如， <literal>*</literal> 匹配任何字符串（甚至是空字符串）； <literal>?</literal> 匹配任何一个字符， <literal>[]</literal> 匹配方括号中间的字符集（如果首字符是惊叹号标示求反集，连续的字符集可表示为如 <literal>a-z</literal>）。
			</para>
			 <para>
				关于赋值操作符， <literal>=</literal>用来赋值（并取代当前值）；如果用在列表上，列表被清空并只包含赋予的新值。 <literal>:=</literal> 做同样工作，但是它会阻止随后对该变量的更改。至于 <literal>+=</literal>，则是给列表添加新项目。如下的变量可以被更改：
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>NAME</literal>：将在 <filename>/dev/</filename>中创建的设备文件名。只有第一次赋值起作用；其它的会被忽略；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SYMLINK</literal>：指向同一个设备的符号列表清单；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>OWNER</literal>, <literal>GROUP</literal> 和 <literal>MODE</literal> 指示拥有该设备的用户和组，还有相关的访问许可；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>RUN</literal>：响应事件时执行的程序清单。
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				赋予这些变量的值可以使用一系列的替代表示：
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>$kernel</literal> 或者 <literal>%k</literal>：等价于 <literal>KERNEL</literal>；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$number</literal> 或者 <literal>%n</literal>：设备的顺序号码，例如，对 <literal>sda3</literal>，它就是“３”；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$devpath</literal> 或 <literal>%p</literal>：等价于 <literal>DEVPATH</literal>；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$attr{<replaceable>attribute</replaceable>}</literal> 或 <literal>%s{<replaceable>attribute</replaceable>}</literal>: 等价于 <literal>ATTRS{<replaceable>attribute</replaceable>}</literal>；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$major</literal> 或 <literal>%M</literal>：设备的内核主设备号；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$minor</literal> 或 <literal>%m</literal>：内核次设备号码；
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$result</literal> 或 <literal>%c</literal>：<literal>PROGRAM</literal>设定的最后一个程序输出的字符串；
					</para>

				</listitem>
				 <listitem>
					<para>
						最后， <literal>%%</literal> 和 <literal>$$</literal> 相应代表百分号和美元符号。
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				以上的清单仍不完备 (只包括最重要的参数)，详细的数据在 <citerefentry><refentrytitle>udev</refentrytitle>
				<manvolnum>7</manvolnum></citerefentry> 手册页面。
			</para>

		</section>
		 <section>
			<title>一个具体例子</title>
			 <para>
				我们来考虑一个Ｕ盘并给它指派固定名字的例子。首先，必须要找到能唯一识别它的元素。可以插入并运行 <command>udevadm info -a -n /dev/sdc</command> （ 用指派给Ｕ盘的名字代替<replaceable>/dev/sdc</replaceable> ）。
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>
<computeroutput>[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</computeroutput></screen>
			 <para>
				可以通过检测设备变量，还有父设备变量创建新的规则。上面的例子运行我们创建两个这样的规则：
			</para>
			 
<programlisting>KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"</programlisting>
			 <para>
				这些规则在文件中设定，例如该文件名为 <filename>/etc/udev/rules.d/010_local.rules</filename>，就可以移除和重新插入Ｕ盘了。可以看到文件<filename>/dev/usb_key/disk</filename> 代表和Ｕ盘相关联的磁盘，<filename>/dev/usb_key/part1</filename> 是它的第一个扇区。
			</para>
			 <sidebar> <title><emphasis>进阶</emphasis> 调试<emphasis>udev</emphasis>配置</title>
			 <para>
				如同其他的后台进程，<command>udevd</command> 把日志保存在 <filename>/var/log/daemon.log</filename>。但是缺省是不啰唆的，且不足以了解发生的事。<command>udevadm control --log-priority=info</command> 命令增加其详细的内容并可解决此问题。<command>udevadm control --log-priority=err</command> 则回到缺省的层次。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.power-management">
		<title>电源管理：高端配置与电源接口 (ACPI)</title>
		 <indexterm>
			<primary>电源管理</primary>
		</indexterm>
		 <indexterm>
			<primary>管理，电源管理</primary>
		</indexterm>
		 <para>
			电源管理很麻烦。是的，适度的暂停电脑时，需让其设备的驱动程序知道如何进入待机状态，而且在唤醒时分，可以适当的配置。不幸的是，在 Linux 之下，还有少数设备无法好好的休眠，因为制造商未提供必要的规格。
		</para>
		 <para>
			Linux 支持 ACPI (高端配置与电源接口) — 电源管理的最新标准。<emphasis role="pkg">acpid</emphasis> 软件包提供的后台进程，照顾电源管理的相关事件 (在笔电的交流电与电池电源之间的切换等事宜) 和运行相关的命令。
		</para>
		 <indexterm>
			<primary>ACPI</primary>
		</indexterm>
		 <indexterm>
			<primary>高级配置与电源管理</primary>
		</indexterm>
		 <indexterm>
			<primary><command>acpid</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>小心</emphasis>显卡与待机</title>
		 <para>
			无法顺利待机时，罪魁祸首多半是显卡的驱动程序。碰到这种情况，先测试最新的 X.org 图形服务器的最新版本。
		</para>
		 </sidebar> <para>
			在介绍了这么多Unix 系统上通用的基本服务之后，接下来关注管理机器的运行环境：网络。许多服务都需要网络的支持。这些会在下一章讨论。
		</para>

	</section>
</chapter>

