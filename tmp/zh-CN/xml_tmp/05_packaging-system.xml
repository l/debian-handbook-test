<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="packaging-system">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-packaging-system.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>二进制包</keyword>
      <keyword>源码包</keyword>
      <keyword>dpkg</keyword>
      <keyword>依赖</keyword>
      <keyword>冲突</keyword>
    </keywordset>
  </chapterinfo>
  <title>包管理系统：工具和基本原则</title>
  <highlights>
    <para>作为 Debian 系统管理员，你经常地要处理 <filename>.deb</filename> 包，因为它们包含一致的功能单元（应用程序、文档等），使得安装和维护更容易。所以了解它们是什么及如何使用它们是个好主意。</para>
  </highlights>

  <para>本章介绍了“二进制”和“源码”包的结构和内容。前者是 <filename>.deb</filename> 文件，可以用 <command>dpkg</command> 命令直接处理；而后者则包含程序的源代码，以及创建二进制包的说明。</para>
  <section id="sect.binary-package-structure">
    <title>二进制包的结构</title>
    <indexterm><primary>包</primary><secondary>二进制包</secondary></indexterm>
    <indexterm><primary><command>ar</command></primary></indexterm>

    <para>Debian 软件包格式的设计满足这样的目的，在任何有如下命令：<command>ar</command>、<command>tar</command> 和 <command>gzip</command> （有些系统会有<command>xz</command>或者<command>bzip2</command>）的 Unix 系统上均能顺利解压。这是个看起来非常简单，却又对可移植性和灾难恢复非常重要的特性。</para>

    <para>想象一下，比如您误删了<command>dpkg</command> 程序，您因此不能再安装 Debian 软件包了。 <command>dpkg</command> 本身作为一个 Debian 软件包，它看起来像是系统应该做的... 幸运的是，您知晓软件包的格式，并下载<emphasis role="pkg">dpkg</emphasis>包   <filename>.deb</filename>文件，并手动安装（参见侧边栏<xref linkend="sidebar.dpkg-apt-ar" />）。如在某些不幸的情况下，一个或多个程序 <command>ar</command>、 <command>tar</command> 或者 <command>gzip</command>/<command>xz</command>/<command>bzip2</command> 失踪了，您只能从其他系统复制丢失的程序（因为它们中的任一个都以全自动方式工作，没有依赖问题，简单复制即可）。如果您的系统出现了更加不幸的问题，甚至以上手段无法奏效（可能是深处的系统库文件丢失？），您应当试一下 <command>busybox</command>的静态版本 （在 <emphasis role="pkg">busybox-static</emphasis> 包中提供），它更加独立化，并能提供如下子命令：<command>busybox ar</command>、<command>busybox tar</command> 、<command>busybox gunzip</command>。</para>

    <sidebar id="sidebar.dpkg-apt-ar">
      <title><emphasis>工具</emphasis> <command>dpkg</command>、<command>APT</command> 和 <command>ar</command></title>
      <indexterm><primary><command>dpkg</command></primary></indexterm>
      <indexterm><primary><command>ar</command></primary></indexterm>
      <indexterm><primary>APT</primary></indexterm>

      <para><command>dpkg</command> 是处理 <filename>.deb</filename> 文件的命令，尤其是解压、分析和解包它们。</para>

      <para><command>APT</command> 是一组允许对系统进行高级的修改的程序：安装或者删除一个软件包（并且保持依赖关系满足），更新系统，列出可用的软件包等。</para>
    
      <indexterm><primary><command>ar</command></primary></indexterm>
      <para>对于 <command>ar</command> 程序，它允许处理同名的文件：<command>ar t <replaceable>archive</replaceable></command>会显示包含在这样一个归档中的文件列表；<command>ar x <replaceable>archive</replaceable></command> 将文件从归档中提取至当前工作目录， <command>ar d <replaceable>archive</replaceable> <replaceable>file</replaceable></command> 从归档中删除一个文件，等。它的手册页 (<citerefentry><refentrytitle>ar</refentrytitle><manvolnum>1</manvolnum></citerefentry>) 记录了它的其他全部特性。<command>ar</command> 是一个非常初步的工具，Unix 管理员仅在极少数情况下使用它，而是通常使用<command>tar</command>，一个更先进的归档和文件管理程序。这是在误删情况下容易恢复 <command>dpkg</command> 的原因。您仅需要下载 Debian 包，并在系统 root (<filename>/</filename>)下从 <filename>data.tar.gz</filename> 归档中提取内容：</para>

      <screen>
<computeroutput># </computeroutput><userinput>ar x dpkg_1.17.23_amd64.deb</userinput>
<computeroutput># </computeroutput><userinput>tar -C / -p -xzf data.tar.gz</userinput></screen>
    </sidebar>

    <sidebar>
      <title><emphasis>基础知识</emphasis> Man 手册注记</title>

      <para>初学者可能会在看到“<citerefentry><refentrytitle>ar</refentrytitle><manvolnum>1</manvolnum></citerefentry>”这样的文字注记时感到疑惑。这通常是个简写，它表示指向 man 手册第一类中标题是 <literal>ar</literal> 的页面。</para>

      <para>有时这种注记也用来避免歧义，比如要区分清楚是 <command>printf</command> 命令，可以用 <citerefentry><refentrytitle>printf</refentrytitle><manvolnum>1</manvolnum></citerefentry> 来指明，如果是 C 语言里的 <function>printf</function> 函数，就可以用 <citerefentry><refentrytitle>printf</refentrytitle><manvolnum>3</manvolnum></citerefentry> 来引用。</para>

      <para><xref linkend="solving-problems" /> 更详细地讨论手册页 (参见 <xref linkend="sect.manual-pages" />)。</para>
    </sidebar>

    <para>来看看 <filename>.deb</filename> 文件的内容：</para>

    <screen><computeroutput>$ </computeroutput><userinput>ar t dpkg_1.17.23_amd64.deb</userinput>
<computeroutput>debian-binary
control.tar.gz
data.tar.gz
$ </computeroutput><userinput>ar x dpkg_1.17.23_amd64.deb</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>control.tar.gz  data.tar.gz  debian-binary  dpkg_1.17.23_amd64.deb
$ </computeroutput><userinput>tar tzf data.tar.gz | head -n 15</userinput>
<computeroutput>./
./var/
./var/lib/
./var/lib/dpkg/
./var/lib/dpkg/parts/
./var/lib/dpkg/info/
./var/lib/dpkg/alternatives/
./var/lib/dpkg/updates/
./etc/
./etc/logrotate.d/
./etc/logrotate.d/dpkg
./etc/dpkg/
./etc/dpkg/dpkg.cfg.d/
./etc/dpkg/dpkg.cfg
./etc/alternatives/
$ </computeroutput><userinput>tar tzf control.tar.gz</userinput>
<computeroutput>./
./conffiles
./postinst
./md5sums
./prerm
./preinst
./control
./postrm
$ </computeroutput><userinput>cat debian-binary</userinput>
<computeroutput>2.0</computeroutput></screen>

    <para>如你所见， Debian 包的 <command>ar</command> 存档格式由三个文件组成：</para>
    <itemizedlist>
      <listitem>
	<para><filename>debian-binary</filename>。这是一个文本文件，简单写明了该 <filename>.deb</filename> 文件使用的版本（in 2015: version 2.0）。</para>
      </listitem>
      <listitem>
	<para><filename>control.tar.gz</filename>。这个归档文件包含所有可用的元信息，如软件包的名称和版本。有些包的元信息允许包管理工具决定能否安装或卸载它，例如按照机器上已有的软件包列表。</para>
      </listitem>
      <listitem>
	<para><filename>data.tar.gz</filename>。这个归档文件包含软件包中所有要解压的文件；这是可执行文件、文档等的存储位置。有些软件包可能会使用其它压缩格式，那样的话文件名会有所不同（bzip2 格式为 <filename>data.tar.bz2</filename>，XZ 格式是 <filename>data.tar.xz</filename>）。</para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="sect.package-meta-information">
    <title>软件包元信息</title>
    <indexterm><primary>软件包元信息</primary></indexterm>
    <indexterm><primary>package</primary><secondary>元信息</secondary></indexterm>

    <para>Debian 软件包不仅是一个待安装文件的归档。它是一个更大结构的一部分，它描述与其它 Debian 软件包的关系（依赖、冲突、建议）。在软件包生命周期的不同阶段（安装、删除、升级），它还提供执行命令的脚本。软件包中的这些数据供包管理工具使用，但不是打包软件的一部分，称为“元信息”（关于其它信息的信息）。</para>

    <section id="sect.control">
      <title>描述：<filename>control</filename> 文件</title>
      <indexterm><primary>软件包元信息</primary></indexterm>
      <indexterm><primary>package</primary><secondary>元信息</secondary></indexterm>
      <indexterm><primary><filename>control</filename></primary></indexterm>

      <para>该文件使用一个类似电子邮件头（由 RFC_2822 定义）的结构。例如，<emphasis role="pkg">apt</emphasis> 包的 <filename>control</filename> 文件看起来是这样的：</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>apt-cache show apt</userinput>
<computeroutput>Package: apt
Version: 1.0.9.6
Installed-Size: 3788
Maintainer: APT Development Team &lt;deity@lists.debian.org&gt;
Architecture: amd64
Replaces: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0)
Depends: libapt-pkg4.12 (&gt;= 1.0.9.6), libc6 (&gt;= 2.15), libgcc1 (&gt;= 1:4.1.1), libstdc++6 (&gt;= 4.9), debian-archive-keyring, gnupg
Suggests: aptitude | synaptic | wajig, dpkg-dev (&gt;= 1.17.2), apt-doc, python-apt
Conflicts: python-apt (&lt;&lt; 0.7.93.2~)
Breaks: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0)
Description-en: commandline package manager
 该软件包提供了用于
 搜索、管理以及以低层次访问
 libapt-pkg 库的全部功能来查询
 软件包信息的命令行工具。
 .
 它包括：
  * apt-get，用于从已验证的源获取软件包
 和相关信息并对软件包及其依赖进行安
 装、升级和删除
  * apt-cache，用于查询已安装和可安
 装软件包的可用信息
  * apt-cdrom，用于将可移除式介质作为软件包的源
  * apt-config，作为设置配置的一个界面
  * apt-key，作为管理验证密钥的一个界面
Description-md5: 9fb97a88cb7383934ef963352b53b4a7
Tag: admin::package-management, devel::lang:ruby, hardware::storage,
 hardware::storage:cd, implemented-in::c++, implemented-in::perl,
 implemented-in::ruby, interface::commandline, network::client,
 protocol::ftp, protocol::http, protocol::ipv6, role::program,
 role::shared-lib, scope::application, scope::utility, sound::player,
 suite::debian, use::downloading, use::organizing, use::searching,
 works-with::audio, works-with::software:package, works-with::text
Section: admin
Priority: important
Filename: pool/main/a/apt/apt_1.0.9.6_amd64.deb
Size: 1107560
MD5sum: a325ccb14e69fef2c50da54e035a4df4
SHA1: 635d09fcb600ec12810e3136d51e696bcfa636a6
SHA256: 371a559ce741394b59dbc6460470a9399be5245356a9183bbeea0f89ecaabb03</computeroutput></screen>

      <sidebar>
        <title><emphasis>基础知识</emphasis> RFC －－ 互联网标准</title>
        <indexterm><primary>RFC</primary></indexterm>
        <indexterm><primary>Request For Comments</primary></indexterm>

	<para>RFC 是 “征求建议”的缩写。RFC通常是一份描述将要成为互联网的标准的技术文档。在成为标准并被冻结之前，这些标准被提交给大众评估（这就是名字的由来）。 IETF（互联网工程专家组）决定这些文档的演进更新（建议标准、草案或标准）。</para>

	<para>RFC 2026 定义了互联网协议标准化的程序。<ulink type="block" url="http://www.faqs.org/rfcs/rfc2026.html" /></para>
      </sidebar>
      <section>
        <title>依赖：<literal>Depends</literal> 域</title>
        <indexterm><primary>依赖</primary></indexterm>
        <indexterm><primary><literal>Depends</literal>, 头部的域</primary></indexterm>
        <indexterm><primary>软件包</primary><secondary>依赖</secondary></indexterm>

	<para>依赖关系是在软件包头部的 <literal>Depends</literal> 域中定义的，它是软件包能够正常运行所需要满足的一系列条件。包管理工具诸如 <command>apt</command> 依靠这个信息来安装该软件所依赖的恰当版本的库。对于每一项依赖，可以限定依赖的版本范围来满足条件。换句话说，可以这样表达：我们需要版本号等于或者大于“2.15”的 <emphasis role="pkg">libc6</emphasis> 软件包（写作 “<command>libc6 (&gt;= 2.15)</command>”）。版本比较操作符使用如下：</para>
        <itemizedlist>
          <listitem>
	    <para><command>&lt;&lt;</command>：小于；</para>
          </listitem>
          <listitem>
	    <para><command>&lt;=</command>：小于或等于；</para>
          </listitem>
          <listitem>
	    <para><command>=</command>：等于（注意， “<literal>2.6.1</literal>” 不等于 “<literal>2.6.1-1</literal>”）；</para>
          </listitem>
          <listitem>
	    <para><command>&gt;=</command>：大于或等于；</para>
          </listitem>
          <listitem>
	    <para><command>&gt;&gt;</command>：大于。</para>
          </listitem>
        </itemizedlist>

	<para>碰到条件时，以逗点做为交集 “and” 符号。以直线 (“|”) 为联集 “or” 符号 (它是包容性的或 “or”、不是排它性的非此即彼 “either/or”)。优先级比 “and” 高，可以无限次使用。因此，相依性 “(A or B) and C” 可写成 <command>A | B, C</command>。另个例子，“A or (B and C)” 应写成 “(A or B) and (A or C)”，因为 <literal>Depends</literal> 字段不接受以括号改变逻辑操作数 “or” 与 “and”的优先次序。所以须写成 <command>A | B, A | C</command>。<ulink type="block" url="http://www.debian.org/doc/debian-policy/ch-relationships.html" /></para>

        <indexterm><primary>元-软件包</primary></indexterm>
	<para>相依性系统是保证程序顺利运作的良好机制，但它也有另个用法 「中介软件包」。这些空的软件软件包内容只有相依性的说明。由中介软件包维护者把一群程序的相依性描述在其中；例如，<command>apt install <replaceable>meta-package</replaceable></command> 将自动安装所有用到中介软件包相依的文件。<emphasis role="pkg">gnome</emphasis>、<emphasis role="pkg">kde-full</emphasis> 与 <emphasis role="pkg">linux-image-amd64</emphasis> 软件包就是中介软件包之一。</para>

        <sidebar>
          <title><emphasis>DEBIAN 政策</emphasis> <literal>预依赖</literal>, 一个更苛刻的 <literal>取决于</literal></title>
          <indexterm><primary><literal>预依赖</literal>, 头失败</primary></indexterm>
          <indexterm><primary>预依赖</primary></indexterm>

	  <para>“预相依性”，列在软件包标头的 “<literal>Pre-Depends</literal>” 字段，满足完整的正常相依性；它的语法是相同的。正常相依性系指必须在声明相依性前先解开并配置的问题软件包。预相依性规定在运行软件包的预安装脚本前，必须先解开并配置软件包，就是在安装之前。</para>

	  <para><command>apt</command>对预依赖的要求非常严格，因为它在安装软件包的时候增加了严格约束。因此，预依赖关系的安装软件的时候不鼓励,除非绝对需要。它甚至建议在加入预依赖前直接咨询开发人员<email>debian-devel@lists.dibian.org</email>。这也是一个通用的解决办法。</para>
        </sidebar>

        <sidebar>
          <title><emphasis>DEBIAN 政策</emphasis> <literal>推荐</literal>，<literal>建议</literal>，<literal>提高</literal>水平</title>
          <indexterm><primary><literal>推荐</literal>，头字段</primary></indexterm>
          <indexterm><primary><literal>建议</literal>，头字段</primary></indexterm>

	  <para><literal>推荐</literal>和<literal>建议</literal>字段描述的依赖关系不是强制性的。“推荐”的依赖,是最重要的，能显著改善由软件包提供的功能，但这并非是必不可少的操作。“建议”的依赖，是次要的，表明某些软件包可以补充或者增加其各自的效果，有充分的理由去单独安装它而不是其它的软件包。</para>

	  <para>你应该总是安装“推荐”的软件包，除非你知道究竟为什么你不需要它们。相反，“建议”的软件包是不必要安装的，除非你知道为什么你需要它们。</para>

          <indexterm><primary><literal>增强</literal>，头字段</primary></indexterm>

	  <para><literal>Enhances</literal> 字段也描述建议，但是位于不同的内文。实际上位于建议软件包内，而不是受益于建议的软件包内。有可能在不修改软件包的前提下添加建议。因此所有插件、插件与其他的程序延伸可以显示在与软件相关的建议清单内。虽然已存在多年，但是 <command>apt</command> 或 <command>synaptic</command> 等程序依然忽略此字段的存在。<literal>Enhances</literal> 字段提出的建议系在传统建议 — <literal>Suggests</literal> 字段供用户参考。</para>
        </sidebar>
      </section>
      <section>
        <title>冲突：<literal>冲突</literal>字段</title>
        <indexterm><primary>冲突</primary></indexterm>
        <indexterm><primary><literal>冲突</literal>，头字段</primary></indexterm>
        <indexterm><primary>包</primary><secondary>冲突</secondary></indexterm>

	<para><literal>Conflicts</literal> 字段指示不能与其共存的其他软件包。最常见的理由是两个软件包使用相同的名称，或在同个 TCP 端口提供相同的服务，或会隐藏彼此的运作。</para>

	<para><command>dpkg</command> 不会安装冲突的软件包，除非新软件包指明 “取代” 被冲突的软件包，<command>dpkg</command> 才会以新的软件包取代旧的软件包。<command>apt</command> 总是遵循您的指示：若选择安装新软件包，则自动移除造成问题的旧软件包。</para>
      </section>
      <section>
        <title>不相容性:<literal>中断</literal>字段</title>
        <indexterm><primary>不相容性</primary></indexterm>
        <indexterm><primary><literal>中断</literal>，头字段</primary></indexterm>
        <indexterm><primary>包</primary><secondary>不相容性</secondary></indexterm>

	<para><literal>中断</literal>字段有一个影响和<literal>冲突</literal>字段类似，但它具有特殊的意义。它标志着一个包的安装会将另外一个包（或者是特定版本）中断掉。通常而言，两个包之间的不兼容是短暂的，<literal>中断</literal>关系会特别指出那些不兼容的版本。</para>

	<para>已经中断现有软件包时，<command>dpkg</command> 将拒绝安装并且 <command>apt</command> 将更新软件包至新的版本试图解决此问题 (通常可解决此问题，并再度兼容)。</para>

	<para>不向后兼容的更新可能会发生这种情况：如果新版本与旧版本的功能不在另一个程序中做特别规定，这将导致故障。<literal>中断</literal>字段会防止用户继续运行从而遇到这些问题。</para>
      </section>
      <section>
        <title>预备好的条目：<literal>预备</literal>字段</title>
        <indexterm><primary><literal>预备</literal>，头字段</primary></indexterm>

	<para>这个字段引入了一个很有意思的“虚拟包”的概念。它有很多的角色，但有两个特别重要。第一个是由使用虚拟包关联到的一个通用的服务（包“预备”了这些服务）。第二个表示一个包完全取代了另外一个，所以它也能满足依赖性要求。因此，可以创建一个替换而不必使用相同的包名称的包。</para>

        <sidebar>
          <title><emphasis>VOCABULARY</emphasis>元软件包和虚拟包</title>
          <indexterm><primary>元-软件包</primary></indexterm>
          <indexterm><primary>软件包</primary><secondary>虚拟软件包</secondary></indexterm>
          <indexterm><primary>虚拟软件包</primary></indexterm>

	  <para>这里必须明确的从虚拟软件包里面区分出元软件包。元软件包是真实的元件包（包含真实的<filename>.deb</filename>文件），其唯一目的是用来表示依赖性关系。</para>

	  <para>然而，虚拟软件包并未真实的存在；只是依照通用、逻辑范围 (提供的服务、兼容于标准程序或已存在的软件包等) 辨认真实软件包的手段。</para>
        </sidebar>
        <section>
          <title>提供一个“服务”</title>

	  <para>让我们以范例详述第一个案子：<emphasis role="pkg">postfix</emphasis> 或 <emphasis role="pkg">sendmail</emphasis> 之类的邮件服务器都 “提供” <emphasis role="pkg">mail-transport-agent</emphasis> 虚拟软件包。因此需要启用该等服务的软件包 (如：<emphasis role="pkg">smartlist</emphasis> 或 <emphasis role="pkg">sympa</emphasis> 之类的邮件列表管理器) 只要在其相依性里叙明需要 <emphasis role="pkg">mail-transport-agent</emphasis> 而不是指明还不兼容的可能解决方案清单 (如 <command>postfix | sendmail | exim4 | …</command>)。更进一步来说，在同个机器安装两个邮件服务器是没有用的，因此每个软件包都声明与 <emphasis role="pkg">mail-transport-agent</emphasis> 虚拟软件包冲突。系统忽略冲突的两个软件包，但技术上可以禁止同时安装两个邮件服务器。</para>

          <sidebar>
            <title><emphasis>DEBIAN 政策</emphasis> 虚拟软件包列表</title>
            <indexterm><primary>软件包</primary><secondary>虚拟软件包</secondary></indexterm>

	    <para>使用虚拟软件包时，每个人都必须同意其名称。这就是在 Debian 政策内把他们标准化的原因。此清单包括邮件服务器 <emphasis role="pkg">mail-transport-agent</emphasis>、C 语言编译器 <emphasis role="pkg">c-compiler</emphasis>、网页浏览器 <emphasis role="pkg">www-browser</emphasis>、网页服务器 <emphasis role="pkg">httpd</emphasis>、FTP 服务器 <emphasis role="pkg">ftp-server</emphasis>、图形模式终端机仿真器 <emphasis role="pkg">x-terminal-emulator</emphasis> (<command>xterm</command>)、以及窗口管理器 <emphasis role="pkg">x-window-manager</emphasis>。</para>

	    <para>完整清单参见网站。<ulink type="block" url="http://www.debian.org/doc/packaging-manuals/virtual-package-names-list.txt" /></para>
          </sidebar>
        </section>
        <section>
          <title>和另一个软件包的可交互性</title>

	  <para>软件包内容被置于另个较大的软件包内时，<literal>Provides</literal> 字段就很有意思。例如，<emphasis role="pkg">libdigest-md5-perl</emphasis> Perl 模块是 Perl 5.6 的选项之一，已被集成入标准的 Perl 5.8 (及其以后的版本，如 5.20 并纳入 <emphasis role="distribution">Jessie</emphasis>)。所以，软件包 <emphasis role="pkg">perl</emphasis> 5.8 版之后已被声明 <literal>Provides: libdigest-md5-perl</literal> 所以只要使用 Perl 5.8 (或更新版) 就已满足其相依性。<emphasis role="pkg">libdigest-md5-perl</emphasis> 软件包本身早就被删除，因为移除 Perl 旧版之后就没有任何意义。</para>

          <figure>
            <title>使用了<literal>预备</literal>字段来避免中断依赖性关系</title>
            <mediaobject>
              <imageobject>
                <imagedata fileref="images/virtual-package.png" width="50%" />
              </imageobject>
            </mediaobject>
          </figure>

	  <para>这个功能非常有用，因为它是永远不可能预料到变化莫测的发展，它不能够调整重命名，或者其他自动替换过的软件，所以它是必要的。</para>

          <sidebar>
            <title><emphasis>回到基本</emphasis>Perl，一种编程语言</title>
            <indexterm><primary>Perl</primary></indexterm>
            <indexterm><primary>CPAN</primary></indexterm>

	    <para>Perl（实用报表提取语言）是非常受欢迎的编程语言。它有许多现成的模块，涵盖了广阔的应用，这些都是由CPAN（Perl综合架构网络）提供服务的，cpan是一个详尽的网络Perl软件包。<ulink type="block" url="http://www.perl.org/" /> <ulink type="block" url="http://www.cpan.org/" /></para>

	    <para>由于它是一种解释型语言，Perl 语言编写的程序并不需要在执行之前进行编译。这就是大家称其为“Perl 脚本”的原因。</para>
          </sidebar>
        </section>
        <section>
          <title>过去的限制</title>

	  <para>虚拟软件包曾有很多限制，最麻烦的是没有版本编号。从上例可知，这种 <literal>Depends: libdigest-md5-perl (&gt;= 1.6)</literal> 相依性，在 Perl 5.10 没问题，但在包装系统时仍不会满足其相依性 — 虽然实际上已满足了。但是包装不知道相依性没问题，只好选择风险最小的做法，假设其版本未相依。</para>

          <para>该限制已经在 <emphasis role="pkg">dpkg</emphasis> 1.17.11 中解除，在 Jessie 中不再相关。软件包可以给提供依赖的虚拟包指定一个版本，如 <literal>Provides: libdigest-md5-perl (= 1.8)</literal>。</para>
        </section>
      </section>

      <section>
        <title>替换文件：<literal>替换</literal>字段</title>
        <indexterm><primary>替换</primary></indexterm>
        <indexterm><primary><literal>替换</literal>,头字段</primary></indexterm>
        <indexterm><primary>软件包</primary><secondary>替换</secondary></indexterm>

	<para><literal>Replaces</literal> 字段指出在其他软件包的文件，但该软件包也合理地取代他们。没有指名，<command>dpkg</command> 失败，说明它不能覆写另个软件包的文件 (技术上来说，虽不能强迫使用 <literal>--force-overwrite</literal> 选项，但可视为标准选项)。因此在加入该字段之前，先办认可能的问题并要求维护者研究它。</para>

	<para>当软件包名称变更时，或者当一个软件包包含在另外一个的时候，此字段的使用是合理的。这也发生在维护者决定从来自相同的源码包的大量二进制包里分发出文件：一个替换的文件不再属于旧的软件包，只有新的才属于。</para>

	<para>如果已安装软件包的所有文件都被替换了，那么该软件包将认为将被删除掉。最后，这个字段会鼓励<command>dpkg</command>命令去删除替换掉有冲突的包。</para>

        <sidebar id="sidebar.debtags">
          <title><emphasis>更进一步</emphasis><literal>标签</literal>字段</title>

	  <para>以上述的 <emphasis role="pkg">apt</emphasis> 为例，还有一个字段未说明，<literal>Tag</literal> 字段。此字段不是说明软件包的关系，而是把软件包分类。根据若干属性 (接口类型、编程语言、应用范围等) 来分类。仅管如此，并非每个软件包都有精准的标签且未融入所有的 Debian 工具；<command>aptitude</command> 显示该等标签，且可以被搜索。未被 <command>aptitude</command> 搜索的范围，可使用以下的网站浏览标签数据库：<ulink type="block" url="http://debtags.alioth.debian.org/" /></para>
        </sidebar>
      </section>
    </section>
    <section id="sect.configuration-scripts">
      <title>配置脚本</title>
      <indexterm><primary><filename>postinst</filename></primary></indexterm>
      <indexterm><primary><filename>preinst</filename></primary></indexterm>
      <indexterm><primary><filename>postrm</filename></primary></indexterm>
      <indexterm><primary><filename>prerm</filename></primary></indexterm>
      <indexterm><primary><filename>control.tar.gz</filename></primary></indexterm>

      <para>除了<filename>控制</filename>文件之外，每个Debian软件包可能在<filename>control.tar.gz</filename>的存档中包含了一些脚本，这些脚本在软件包处理的不同的阶段被<command>dpkg</command>调用。Debian政策描述了一些可能的细节，在可能的情况下，指定脚本调用它们所收到的参数。这些顺序可能比较复杂，因为如果脚本中任何一步出现问题的时候，<command>dpkg</command>进程会通过取消安装或者卸载来尝试恢复到一个令人满意的状态（只要是可能的）。</para>

      <sidebar>
        <title><emphasis>进一步</emphasis> <command>dpkg</command> 的数据库</title>
        <indexterm><primary><filename>/var/lib/dpkg</filename></primary></indexterm>
	<indexterm><primary>dpkg</primary><secondary>数据库</secondary></indexterm>

	<para>所有已安装的软件包的配置脚本都存在<filename>/var/lib/dpkg/info/</filename>目录，在软件包的名字前会有一个文件名的前缀。此目录的每个软件包还包括一个叫<filename>.list</filename>的文件扩展，包括列表的文件字段属于哪些包。</para>

	<para><filename>/var/lib/dpkg/status</filename>文件包含了一些数据块（著名的邮件标题的格式，RFC2822）描述了每个软件包的状态。从<filename>control</filename>文件中已经安装的软件包的信息也会被复制。</para>
      </sidebar>

      <para>在一般情况下，<filename>preinst</filename>脚本会在安装软件包前执行，而<filename>postinst</filename>会稍候执行。同样，<filename>prerm</filename>会在移除一个软件包的前和<filename>postrm</filename>之后。更新软件包相当于是清除掉以前的旧版本并且安装新的软件包。所以在这里我们不可能来详细描述所有的可能的方案，但我们将讨论最常见的两种：安装/更新和移除。</para>

      <sidebar>
        <title><emphasis>小心</emphasis> 脚本的符号名称</title>

	<para>本节中使用特定的名称序列命名配置脚本，例如 <command>old-prerm</command> 或 <command>new-postinst</command>。它们分别是旧版本软件包（ 在更新前已安装）中包含的 <command>prerm</command>脚本和新版本软件包（由本次更新所安装）中包含的 <command>postinst</command> 脚本。</para>
      </sidebar>

      <sidebar>
        <title><emphasis>提示</emphasis>状态图</title>

	<para>Manoj Srivastava 以图解释这些配置脚本被 <command>dpkg</command> 调用的情况。Debian 女子计划也有类似的图；容易了解，略为不够完整。<ulink type="block" url="https://people.debian.org/~srivasta/MaintainerScripts.html" /> <ulink type="block" url="https://wiki.debian.org/MaintainerScripts" /></para>
      </sidebar>
      <section>
        <title>安装和升级</title>
        <indexterm><primary><command>dpkg</command></primary><secondary>内部运作</secondary></indexterm>

	<para>这里告诉你，安装的时候发生了什么（或者是更新）</para>
        <orderedlist>
          <listitem>
	    <para>对于升级，<command>dpkg</command>会调用<command>old-prerm 升级新版本 <replaceable></replaceable></command>。</para>
          </listitem>
          <listitem>
	    <para>还是对于升级，<command>dpkg</command>执行<command>new-preinst 升级<replaceable>旧版本</replaceable></command>；对于第一个安装，它会执行<command>new-preinst 安装</command>。它可能会增加旧版本的最后一个参数，如果软件包已经被安装或者是删除了（但没有清除合并掉旧版本，那么这个配置文件会被保留）。</para>
          </listitem>
          <listitem>
	    <para>新的软件包文件被解压。如果文件已经存在，就被会替换，同时会产生一个临时的备份副本。</para>
          </listitem>
          <listitem>
	    <para>对于更新，<command>dpkg</command>执行<command>old-postrm 升级<replaceable>新版本</replaceable></command>。</para>
          </listitem>
          <listitem>
	    <para><command>dpkg</command>更新所有的内部数据（文件列表，配置脚本等），并删除被替换文件的备份。这是一条不归路： ） <command>dpkg</command>将不再具有访问所有元素的需要以此来返回以前的状态。</para>
          </listitem>
          <listitem>
	    <para><command>dpkg</command> 将更新配置文件，无法自动管理此工作时，要求用户做决定。详情在此 <xref linkend="sect.conffiles" />。</para>
          </listitem>
          <listitem>
	    <para>最后，<command>dpkg</command> 通过执行 <command>new-postinst configure <replaceable>最近一次配置的版本号</replaceable></command> 对软件包进行配置。</para>
          </listitem>
        </orderedlist>
      </section>
      <section>
        <title>软件包移除</title>

	<para>这里是当移除一个软件包的时候发生了什么：</para>
        <orderedlist>
          <listitem>
	    <para><command>dpkg</command> 回调<command>prerm 移除</command>。</para>
          </listitem>
          <listitem>
	    <para><command>dpkg</command> 移除了所有的软件包文件，只剩下了配置文件和配置的脚本。</para>
          </listitem>
          <listitem>
	    <para><command>dpkg</command> 运行 <command>postrm remove</command>。移除所有配置脚本，保留 <filename>postrm</filename>。若用户未选择 “清除” 选项，则工作完成。</para>
          </listitem>
          <listitem>
	    <para>对于一个完整的清除包（由<command>dpkg --purge</command>或<command>dpkg -P</command>发出的），配置文件也将会被删除，同时一些副本（<filename>*.dpkg-tmp</filename>,<filename>*.dpkg-old</filename>,<filename>*.dpkg-new</filename>）和缓存文件也会被删除掉；<command>dpkg</command>这时会执行<command>postrm purge</command>。</para>
          </listitem>
        </orderedlist>

        <sidebar>
          <title><emphasis>术语</emphasis> Purge，完全移除</title>
          <indexterm><primary>清除软件包</primary></indexterm>

	  <para>当Debian的软件包被移除掉的时候，该软件包的配置文件会被保留下来以便重新安装。同样，守护程序产生的数据（比如LDAP的服务器目录内容，或者是SQL服务器的数据库内容）也常常会被保留。</para>

	  <para>移除掉软件包所关联的所有数据，必须使用“purge”命令，<command>dpkg -P<replaceable>软件包</replaceable></command>，<command>apt-get remove --purge <replaceable>软件包</replaceable></command> 或者是<command>aptitude purge <replaceable>软件包</replaceable></command>。</para>

	  <para>移除该等数据，不能掉以轻心去清除。</para>
        </sidebar>

        <indexterm><primary><filename>config</filename>、<command>debconf</command> 脚本</primary></indexterm>

	<para><filename>config</filename> 脚本补充前述的 4 个脚本，软件包以 <command>debconf</command> 取得配置用的信息。安装过程中，此脚本以 <command>debconf</command> 指令询问用户详细的问题。把回应记录在 <command>debconf</command> 数据库供未来的参考。在安装之前先由 <command>apt</command> 逐一运行该等脚本，归纳问题与回答。事前与事后安装脚本可使用该等信息回应用户的期望。</para>

        <sidebar>
          <title><emphasis>工具</emphasis> <command>debconf</command></title>
          <indexterm><primary><command>debconf</command></primary></indexterm>

	  <para><command>debconf</command> 系用于解决重复出现于 Debian 的问题。Debian 所有的软件包都需要 <command>echo</command> 与 <command>read</command> 命令于 <filename>postinst</filename> 壳脚本 (及其他类似脚本) 的最低配置才能提出问题。也就是说在大型安装或升级过程里，用户必须在电脑旁回应这些随时出现的问题。感谢 <command>debconf</command> 工具的出现，这些人工交互几乎全部免除了。</para>

	  <para><command>debconf</command> 包括很多有趣的功能：要求开发者指明用户的交互；允许本地化显示给用户的字符串 (描述交互的所有翻译保存在 <filename>templates</filename> 文件)；显示给用户的前端问题 (文本模式、图形模式、非交互式)；把回应集中在数据库供其他电脑使用 ... 但最重要的已可把所有问题，在安装或升级之前，以一列的模式显示给用户。用户可以放任系统自行安装，不必待在电脑旁，紧盯屏幕等待问题。</para>
        </sidebar>
      </section>
    </section>
    <section id="sect.conffiles">
      <title>校验，配置文件列表</title>
      <indexterm><primary><filename>md5sums</filename></primary></indexterm>
      <indexterm><primary><filename>冲突文件</filename></primary></indexterm>
      <indexterm><primary>校验</primary></indexterm>
      <indexterm><primary>文件</primary><secondary>配置文件</secondary></indexterm>
      <indexterm><primary>配置</primary><secondary>文件</secondary></indexterm>

      <para>除了稍早提过的维护者脚本与控制数据外，在 Debian 软件包内的 <filename>control.tar.gz</filename> 可能包括若干有趣的文件。首先，<filename>md5sums</filename>，包括软件包内所有文件的 MD5 校验。它的优点是允许 <command>dpkg --verify</command> (详情见 <xref linkend="sect.dpkg-verify" />) 检查该等文件在安装后是否被修改。若此文件不存在，<command>dpkg</command> 将在安装时动态产生一个 (并且如同其他控制文件般保存在 dpkg 数据库)。</para>

      <para><filename>conffiles</filename> 列出必须当成配置文件处理的软件包。管理员可修改配置文件，升级软件包时 <command>dpkg</command> 将保留这些变动。</para>

      <para>实际上，在这种情况下，<command>dpkg</command>的行为会尽可能地智能：如果两个版本之间并没有改变标准的配置文件，那么<command>dpkg</command>就什么也不会作。但是，如果文件已经被修改，它会尝试更新此文件。这会产生两种可能的情况：一是管理员没有碰配置文件，在这种情况下<command>dpkg</command>会自动安装新版本；二是文件已经被修改了，在这种情况下<command>dpkg</command>会询问管理员希望使用哪个版本（旧版本或者新的）。为了帮助用户作出选择，<command>dpkg</command>会提供“<command>差异</command>”，这会显示两个版本之间的差异。如果用户选择保留旧的版本，新的将被存储在文件夹的同一个位置并以<filename>.dpkg-dist</filename>为后缀名的文件中。另外一个可能的操作是由暂时中断的<command>dpkg</command>来编辑该文件，并试图重新恢复相关的修改（之前被验证的<command>差异</command>）。</para>

      <sidebar id="sidebar.questions-conffiles">
        <title><emphasis>更进一步</emphasis> 避免配置文件问题</title>

	<para><command>dpkg</command>  处理配置文件升级，但经常中断作业，要求管理者键入数据。如此一来，就不能以无中断方式一气呵成升级作业。此指令提供选项让系统依同样的逻辑自动回应：<command>--force-confold</command> 保留该文件的旧版本；<command>--force-confnew</command> 使用该文件的新版本 (即使该文件未被管理者修改，仍使用指定的选择，极少发生问题)。加入 <command>--force-confdef</command> 选项告诉 <command>dpkg</command> 在可能情况下自行决定 (换句话说，不改变原配置档)，只在其他的情况下，才使用 <command>--force-confnew</command> 或 <command>--force-confold</command>。</para>

	<para>这些选项使用<command>dpkg</command>，但是大多数时间管理员会直接用<command>aptitude</command> 或<command>apt-get</command>。实际上，有必要知道dpkg的语法参数来使用<command>dpkg</command>命令（命令行的界面是非常相似的）。</para>

        <screen>
<computeroutput># </computeroutput><userinput>apt -o DPkg::options::="--force-confdef" -o DPkg::options::="--force-confold" full-upgrade</userinput></screen>

	<para>此选项可直接保存在 <command>apt</command> 的配置内。只需把下列这行字写入 <filename>/etc/apt/apt.conf.d/local</filename> 文件内：</para>
        <informalexample>
          <programlisting>
DPkg::options { "--force-confdef"; "--force-confold"; }</programlisting>
        </informalexample>

	<para>把此选项纳入配置档的意思是，将使用 <command>aptitude</command> 之类的图形接口。</para>
      </sidebar>

      <sidebar id="sidebar.questions-conffiles-bis">
        <title><emphasis>更进一步</emphasis> 强制dpkg询问配置文件问题</title>

	<para><command>--force-confask</command> 选项要求 <command>dpkg</command> 显示有关配置文件的问题，即使不是必要的问题也需显示。因此，以此选项重新安装软件包时，<command>dpkg</command> 将再询管理者修改过的配置文件问题。这种方式极为便利，尤其是重新安装已经被删除且无可用复本的原始配置档：标准的重新安装无效，因为 <command>dpkg</command> 认为移除为合法的修改，且不会安装预期的配置档。</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.source-package-structure">
    <title>源软件包的结构</title>
    <indexterm><primary>包</primary><secondary>源码包</secondary></indexterm>
    <indexterm><primary>源码</primary><secondary>包</secondary></indexterm>
    <section>
      <title>格式</title>
      <indexterm><primary>DSC 文件</primary></indexterm>
      <indexterm><primary><filename>diff.gz</filename> 文件</primary></indexterm>
      <indexterm><primary><filename>debian.tar.gz</filename> 文件</primary></indexterm>
      <indexterm><primary><filename>orig.tar.gz</filename> 文件</primary></indexterm>

      <para>源文件案通常包括三个文件，<filename>.dsc</filename>、<filename>.orig.tar.gz</filename>、与 <filename>.debian.tar.gz</filename> (或 <filename>.diff.gz</filename>)。它们允许从以编程语言撰写的程序源代码文件，添加可运行软件包 (如前所述的 <filename>.deb</filename> 文件)。</para>

      <para><filename>.dsc</filename> (Debian Source Control) 文件是包括 RFC 2822 标头 (如同 <filename>control</filename> 文件于 <xref linkend="sect.control" />) 的简短文本档，描述原始软件包及包括的其他文件。由维护者签署，保证其真实性。详情见 <xref linkend="sect.package-authentication" />。</para>

      <example>
        <title>一个<filename>.dsc</filename> 文件</title>

        <programlisting>
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Format: 3.0 (quilt)
Source: zim
Binary: zim
Architecture: all
Version: 0.62-3
Maintainer: Emfox Zhou &lt;emfox@debian.org&gt;
Uploaders: Raphaël Hertzog &lt;hertzog@debian.org&gt;
Homepage: http://zim-wiki.org
Standards-Version: 3.9.6
Vcs-Browser: http://anonscm.debian.org/gitweb/?p=collab-maint/zim.git
Vcs-Git: git://anonscm.debian.org/collab-maint/zim.git
Build-Depends: debhelper (&gt;= 9), xdg-utils, python (&gt;= 2.6.6-3~), libgtk2.0-0 (&gt;= 2.6), python-gtk2, python-xdg
Package-List:
 zim deb x11 optional arch=all
Checksums-Sha1:
 ad8de170826682323c10195b65b9f1243fd75637 1772246 zim_0.62.orig.tar.gz
 a4f70d6f7fb404022c9cc4870a4e62ea3ca08388 14768 zim_0.62-3.debian.tar.xz
Checksums-Sha256:
 19d62aebd2c1a92d84d80720c6c1dcdb779c39a2120468fed01b7f252511bdc2 1772246 zim_0.62.orig.tar.gz
 fc2e827e83897d5e33f152f124802c46c3c01c5158b75a8275a27833f1f6f1de 14768 zim_0.62-3.debian.tar.xz
Files:
 43419efba07f7086168442e3d698287a 1772246 zim_0.62.orig.tar.gz
 725a69663a6c2961f07673ae541298e4 14768 zim_0.62-3.debian.tar.xz

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2
Comment: Signed by Raphael Hertzog

iQEcBAEBCAAGBQJUR2jqAAoJEAOIHavrwpq5WFcH/RsdzCHc1oXXxHitU23hEqMj
T6ok29M1UFDJDowMXW75jQ1nT4WPUtvEGygkCHeoO/PvjEvB0sjU8GQlX+N9ddSB
aHfqfAYmVhADNGxrXQT5inZXUa8qGeeq2Sqf6YcWtsnuD56lDbvxkyf/XYopoIEl
oltfl05z/AI+vYsW482YrCz0fxNAKAvkyuPhDebYI8jnKWeAANoqmKpsNc/HYyvT
+ZiA5o57OiGdOKT6XGy3/FiF3dkHiRY8lXW7xdr1BbIgulwl9UmiUNwuxwOYbQO7
edtjiTJqOaFUA0x1zB/XGv5tHr1MjP8naT+kfVoVHTOox51CDbeu5D3DZY4imcY=
=Wtoa
-----END PGP SIGNATURE-----</programlisting>
      </example>

      <indexterm><primary><literal>编译-依赖</literal>，头字段</primary></indexterm>

      <para>需要注意的是从二进制包编译出来的源码包也完全不同，它也有依赖关系（<literal>编译-依赖</literal>），因为它们需要编译器来编译和构建它们的源码包。</para>

      <sidebar>
        <title><emphasis>当心</emphasis> 不同的命名空间</title>

	<para>需注意，原始软件包与其产生的可运行软件包间，不需使用对应的名称。每个原始软件包可能产生多个可运行软件包。所以 <filename>.dsc</filename> 文件有 <literal>Source</literal> 与 <literal>Binary</literal> 字段记录原始软件包的名称与其产生的可运行软件包清单。</para>
      </sidebar>

      <sidebar>
        <title><emphasis>文化</emphasis> 为什么要分成几个软件包</title>

	<para>通常，一个原始软件包 (供指定软件使用) 可产生多个可运行档。因为可以在不同的环境使用 (部分) 软件。在共享程序库里，可以安装于构成应用作用 (如，<emphasis role="pkg">libc6</emphasis>)、或可以安装以构成新的程序 (<emphasis role="pkg">libc6-dev</emphasis> 然后形成正确的软件包)。在主从服务里发现同样的逻辑，在一部机器安装服务器的内容同时在另部机器安装客户端的内容 (在此情况下，是 <emphasis role="pkg">openssh-server</emphasis> 与 <emphasis role="pkg">openssh-client</emphasis>)。</para>

	<para>一样频繁的是，在一个专用的软件包提供的文档中：用户可以安装独立的软件，并且可以在任何时候选择删除掉以节省磁盘空间。此外，这也节省了Debian镜像的磁盘空间，因为在所有的节点中（而不是在每个节点的都用一样的文档软件包）将共享这个文档软件包。</para>
      </sidebar>

      <sidebar>
        <title><emphasis>洞察</emphasis>不同格式的源码包</title>

	<para>本来只有一个原始的软件包格式，像<literal>1.0</literal>这样的格式，它关联了<filename>.orig.tar.gz</filename>和<filename>.diff.gz</filename>“Debian化”的补丁（还有一个变种，由一个单一的<filename>.tar.gz</filename>归档，当<filename>.orig.tar.gz</filename>不可用时它会自动使用。）</para>

	<para>因为 Debian <emphasis role="distribution">Squeeze</emphasis>、及其开发者可以选择新的格式以校正旧格式的问题。格式 <literal>3.0 (quilt)</literal> 在同个原始软件包里纳入多个上游文件：除了使用 <filename>.orig.tar.gz</filename>，还可纳入 <filename>.orig-<replaceable>component</replaceable>.tar.gz</filename> 文件。这种做法有助于散布在多个上游组件的软件，只需准备一个原始软件包。通常把这些文件压缩成 <command>bzip2</command> 或 <command>xz</command> 格式而不是 <command>gzip</command>，以节省磁盘空间与网络资源。最后，在单件补丁的情况下，<filename>.diff.gz</filename> 被 <filename>.debian.tar.gz</filename> 取代，包括编译指令与软件包维护者奉献的上传软件包补丁。最后的这些部分记录于格式兼容的 <command>quilt</command> — 它是强化补丁管理的工具。</para>
      </sidebar>

      <para><filename>.orig.tar.gz</filename> 文件包括原开发者提供的源代码。要求 Debian 的软件包维护者不要修改它，以便检查原来的文件与集成后的文件 (比较校验码就知道) 并且尊重其他著者的意愿。</para>

      <para><filename>.debian.tar.gz</filename> 包括 Debian 维护者做的所有修订，特别是添加至 <filename>debian</filename> 目录运行 Debian 软件包的指令。</para>

      <sidebar>
        <title><emphasis>工具</emphasis> 解压缩源码包</title>
        <indexterm><primary><command>dpkg-source</command></primary></indexterm>
	<indexterm><primary>解压缩，原始软件包</primary></indexterm>
	<indexterm><primary>解压缩，原始软件包</primary></indexterm>
	<indexterm><primary>拆包</primary><secondary>原始软件包</secondary></indexterm>

	<para>使用原始软件包时，您可使用 <command>dpkg-source</command> 指令 (从 <emphasis role="pkg">dpkg-dev</emphasis> 软件包取得) 解压缩它：</para>

        <screen><computeroutput>$ </computeroutput><userinput>dpkg-source -x package_0.7-1.dsc</userinput></screen>

	<para>可以使用 <command>apt-get</command> 下载原始软件包并立即拆包它。需使用适当的 <literal>deb-src</literal> 位于 <filename>/etc/apt/sources.list</filename> 文件内，然而 (详情见 <xref linkend="sect.apt-sources.list" />)。用于列出原始软件包的 “来源” (就是收藏原始软件包的服务器)。</para>

        <screen><computeroutput>$ </computeroutput><userinput>apt-get source <replaceable>package</replaceable></userinput></screen>
      </sidebar>
    </section>
    <section>
      <title>Debian中的使用</title>

      <para>Debian 的基础是原始软件包。Debian 所有的软件包都从原始软件包而来，对软件包的修改也是针对原始软件包。运行软件包出了问题后，Debian 维护者修改原始软件包后，再编译为运行软件包。维护者的工作成果都在 Debian 的原始软件包内：您可轻易地回到原始软件包找出源头。</para>

      <para>Debian 服务器收到新版软件包 (原始软件包或运行软件包) 时，原始软件包是最重要的。原始软件包被支持 Debian 的多种架构机器编译。开发者同时送出指定架构 (通常是 i386 或 amd64) 的多个运行软件包，其实一点都不重要，因为可以自动生成该等运行软件包。</para>
    </section>
  </section>
  <section id="sect.manipulating-packages-with-dpkg">
    <title>通过<command>dpkg</command>来操作软件包</title>
    <indexterm><primary><command>dpkg</command></primary></indexterm>

    <para><command>dpkg</command> 是系统层面处理 Debian 软件包的基础指令。若您有 <filename>.deb</filename> 软件包，可以用 <command>dpkg</command> 安装及分析其内容。但此指令只能看到 Debian 世界的部分内容：它知道系统安装那些软件包、指令列给了那些参数，但不知道还有那些可用的软件包。因此，没有相依性就完了。<command>apt</command> 之类的工具，则可产生相依性清单，尽量自动安装软件包。</para>

    <sidebar>
      <title><emphasis>说明</emphasis> <command>dpkg</command> 或 <command>apt</command>?</title>

      <para><command>dpkg</command> 应视为系统工具 (背景) 之一，而 <command>apt</command> 则是较倾向用户的工具，可克服前者的限制。这些工具各有其限制，共同解决特定的作业。</para>
    </sidebar>
    <section>
      <title>安装软件包</title>
      <indexterm><primary>安装</primary><secondary>软件包安装</secondary></indexterm>
      <indexterm><primary>软件包</primary><secondary>安装</secondary></indexterm>

      <para>首先，<command>dpkg</command> 是安装 Debian 已经可用软件包的工具 (因为不需下载任何东西)。我们使用它的 <literal>-i</literal> 或 <literal>--install</literal> 选项。</para>

      <example>
        <title>通过<command>dpkg</command>来安装一个软件包</title>

        <screen role="scale">
<computeroutput># </computeroutput><userinput>dpkg -i man-db_2.7.0.2-5_amd64.deb</userinput>
<computeroutput>(读取数据库安装的 ... 86425 文件与文件夹。)
准备打开 man-db_2.7.0.2-5_amd64.deb ...
打开 man-db (2.7.0.2-5) over (2.7.0.2-4) ...
设置 man-db (2.7.0.2-5) ...
更新使用页面的数据库 ...
Processing triggers for mime-support (3.58) ...</computeroutput></screen>
      </example>

      <para>通过<command>dpkg</command>我们可以看到安装时的不同步骤；因此我们会知道在什么时候可能会发生错误。安装也被分为两个阶段：首先解压包，然后配置它。<command>apt-get</command>会利用这一点，然后有限的调用<command>dpkg</command>（因为每次调用都要把数据加载到内存中，特别是那些在名单中已经被安装的文件）。</para>

      <example>
        <title>分开解压和配置</title>

        <screen role="scale">
<computeroutput># </computeroutput><userinput>dpkg --unpack man-db_2.7.0.2-5_amd64.deb</userinput>
<computeroutput>(Reading database ... 86425 files and directories currently installed.)
Preparing to unpack man-db_2.7.0.2-5_amd64.deb ...
Unpacking man-db (2.7.0.2-5) over (2.7.0.2-5) ...
Processing triggers for mime-support (3.58) ...
# </computeroutput><userinput>dpkg --configure man-db</userinput>
<computeroutput>Setting up man-db (2.7.0.2-5) ...
Updating database of manual pages ...
</computeroutput></screen>
      </example>
      <indexterm><primary>软件包</primary><secondary>解压</secondary></indexterm>
      <indexterm><primary>解压</primary><secondary>运行软件包</secondary></indexterm>

      <para>有时<command>dpkg</command>在安装软件包的时候会失败并且返回一个错误；如果用户命令dpkg忽略掉这个错误，那么它仅仅会提示一个警告；这也就是我们有一个不同的<literal>--force--*</literal>选项。<command>dpkg --force-help</command>，或者是dpkg的帮助文档，有一个这些选项的详细清单。最常见的错误是，你迟到会遇到这样一个文件冲突，当一个软件包包含的文件中已经安装了另外一个软件包。</para>

      <screen>
<computeroutput>Unpacking libgdm (from .../libgdm_3.8.3-2_amd64.deb) ...
dpkg: 处理 /var/cache/apt/archives/libgdm_3.8.3-2_amd64.deb (--unpack) 时发生错误:
 试图覆写 '/usr/bin/gdmflexiserver'，也同时在软件包 gdm3 3.4.1-9 内</computeroutput></screen>

      <para>在这种情况下，如果你认为文件替换该文件可能不会对系统的稳定性造成重大的风险（通常情况下），你可以使用<literal>--force-overwrite</literal>选项来告诉<command>dpkg</command>去忽略这个错误并且覆盖该文件。</para>

      <para>当然这里有非常多的<literal>--force-*</literal>选项，只是<literal>--force-overwrite</literal>使用的非常频繁。这些选项仅存在特殊的情况下，所以最好是不去使用它们以便遵守软件包的管理机制。不要忘了，这些管理规则可以确保你的系统的稳定性和一致性。</para>

      <sidebar>
        <title><emphasis>注意</emphasis> 使用<literal>--force-*</literal>的影响</title>
        <indexterm><primary>破坏依赖性</primary></indexterm>

	<para>若不小心使用 <literal>--force-*</literal> 的选项，可能造成 APT 命令家族拒绝运作的困境。在相依性不足或冲突的情况下，使用部分选项后，仍可安装该等软件包。结果就是相依性不足的不一致系统，APT 命令将拒绝运行任何工作，直到系统恢复一致 (通常包括安装遗失的相依软件包或移除问题软件包)。通常出现以下的消息，安装新版 <emphasis role="pkg">rdesktop</emphasis> 时忽略其对新版 <emphasis role="pkg">libc6</emphasis> 的相依性：</para>

        <screen><computeroutput># </computeroutput><userinput>apt full-upgrade
</userinput><computeroutput>[...]
You might want to run 'apt-get -f install' to correct these.
The following packages have unmet dependencies:
  rdesktop: Depends: libc6 (&gt;= 2.5) but 2.3.6.ds1-13etch7 is installed
E: Unmet dependencies. Try using -f.</computeroutput></screen>

	<para>确信其分析结果的勇敢管理者，可能选择忽略使用 <literal>--force-*</literal> 选项时发生的相依性问题与冲突。结果是，想要继续使用 <command>apt</command> 或 <command>aptitude</command> 的话，他们必须先编辑 <filename>/var/lib/dpkg/status</filename> 以删除/修改相依性问题或冲突。</para>

	<para>这是一种丑陋的黑客行为，除了极为必要的情况，否则不该发生。比较常见的手法是，重新编译有问题的软件包 (见 <xref linkend="sect.rebuilding-package" />) 或从 <literal>stable-backports</literal> 里 (see <xref linkend="sect.backports" />)，使用新版本 (可能已修复该问题) 的软件包。</para>
      </sidebar>
    </section>
    <section>
      <title>软件包移除</title>
      <indexterm><primary>删除掉一个软件包</primary></indexterm>
      <indexterm><primary>清除软件包</primary></indexterm>
      <indexterm><primary>软件包</primary><secondary>卸载</secondary></indexterm>
      <indexterm><primary>软件包</primary><secondary>清除</secondary></indexterm>

      <para>使用 <command>dpkg</command> 加上 <literal>-r</literal> 或 <literal>--remove</literal> 选项，再加上软件包名称，就可移除该软件包。然而，这种方式的移除并不完整：仍保留所有的配置档、维护脚本、记录文件 (系统记录档) 及该软件包的其他用户数据。这种方式是停用程序，仍可以相同的配置快速地再安装回来。完全移除该软件包的所有相关文件，应使用 <literal>-P</literal> 或 <literal>--purge</literal> 选项，再加上软件包名称。</para>

      <example>
        <title>移除与清除 <emphasis role="pkg">debian-cd</emphasis> 软件包</title>

        <screen><computeroutput># </computeroutput><userinput>dpkg -r debian-cd</userinput>
<computeroutput>(Reading database ... 97747 files and directories currently installed.)
Removing debian-cd (3.1.17) ...
# </computeroutput><userinput>dpkg -P debian-cd</userinput>
<computeroutput>(Reading database ... 97401 files and directories currently installed.)
Removing debian-cd (3.1.17) ...
Purging configuration files for debian-cd (3.1.17) ...</computeroutput></screen>
      </example>
    </section>
    <section>
      <title>查询 <command>dpkg</command> 的数据库，并检查 <filename>.deb</filename> 文件</title>
      <indexterm><primary>软件包</primary><secondary>状态</secondary></indexterm>
      <indexterm><primary>软件包</primary><secondary>文件列表</secondary></indexterm>
      <indexterm><primary>软件包</primary><secondary>内容检查</secondary></indexterm>

      <sidebar>
        <title><emphasis>回到基础</emphasis> 选项的语法</title>

	<para>“长” 版 (一个或多个字，前置两个链接号) 与 “短” 版 (一个字母，通常是长版字的第一个字母，前置一个链接号) 软件包都有该等选项。这是 POSIX 标准常见的用法。</para>
      </sidebar>

      <para>做结论前，我们将学习查找内部数据库以获取信息的 <command>dpkg</command> 选项。先给长版的选项再给对应的短版选项 (其参数是一样的) 以 <literal>--listfiles <replaceable>软件包</replaceable></literal> (或 <literal>-L</literal>) 为例，列出该软件包安装的文件清单；<literal>--search <replaceable>文件</replaceable></literal> (或 <literal>-S</literal>)，寻找包括该文件的套性；<literal>--status <replaceable>软件包</replaceable></literal> (或 <literal>-s</literal>)，显示该软件包的标头；<literal>--list</literal> (或 <literal>-l</literal>)，显示该系统内软件包清单与安装状态；<literal>--contents <replaceable>file.deb</replaceable></literal> (或 <literal>-c</literal>)，列出 Debian 指定软件包清单；<literal>--info<replaceable> file.deb </replaceable></literal> (或 <literal>-I</literal>)，列出该软件包的标头。</para>

      <example>
        <title><command>dpkg</command>的各种查询</title>

        <screen role="scale" width="80">
<computeroutput>$ </computeroutput><userinput>dpkg -L base-passwd</userinput>
<computeroutput>/.
/usr
/usr/sbin
/usr/sbin/update-passwd
/usr/share
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/base-passwd
/usr/share/doc-base
/usr/share/doc-base/users-and-groups
/usr/share/base-passwd
/usr/share/base-passwd/group.master
/usr/share/base-passwd/passwd.master
/usr/share/man
/usr/share/man/pl
/usr/share/man/pl/man8
/usr/share/man/pl/man8/update-passwd.8.gz
/usr/share/man/ru
/usr/share/man/ru/man8
/usr/share/man/ru/man8/update-passwd.8.gz
/usr/share/man/ja
/usr/share/man/ja/man8
/usr/share/man/ja/man8/update-passwd.8.gz
/usr/share/man/fr
/usr/share/man/fr/man8
/usr/share/man/fr/man8/update-passwd.8.gz
/usr/share/man/es
/usr/share/man/es/man8
/usr/share/man/es/man8/update-passwd.8.gz
/usr/share/man/de
/usr/share/man/de/man8
/usr/share/man/de/man8/update-passwd.8.gz
/usr/share/man/man8
/usr/share/man/man8/update-passwd.8.gz
/usr/share/doc
/usr/share/doc/base-passwd
/usr/share/doc/base-passwd/users-and-groups.txt.gz
/usr/share/doc/base-passwd/changelog.gz
/usr/share/doc/base-passwd/copyright
/usr/share/doc/base-passwd/README
/usr/share/doc/base-passwd/users-and-groups.html
$ </computeroutput><userinput>dpkg -S /bin/date</userinput>
<computeroutput>coreutils: /bin/date
$ </computeroutput><userinput>dpkg -s coreutils</userinput>
<computeroutput>Package: coreutils
Essential: yes
Status: install ok installed
Priority: required
Section: utils
Installed-Size: 13855
Maintainer: Michael Stone &lt;mstone@debian.org&gt;
Architecture: amd64
Multi-Arch: foreign
Version: 8.23-3
Replaces: mktemp, realpath, timeout
Pre-Depends: libacl1 (&gt;= 2.2.51-8), libattr1 (&gt;= 1:2.4.46-8), libc6 (&gt;= 2.17), libselinux1 (&gt;= 2.1.13)
Conflicts: timeout
Description: GNU core utilities
 This package contains the basic file, shell and text manipulation
 utilities which are expected to exist on every operating system.
 .
 Specifically, this package includes:
 arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp
 csplit cut date dd df dir dircolors dirname du echo env expand expr
 factor false flock fmt fold groups head hostid id install join link ln
 logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt
 od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm
 rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac
 tail tee test timeout touch tr true truncate tsort tty uname unexpand
 uniq unlink users vdir wc who whoami yes
Homepage: http://gnu.org/software/coreutils
$ </computeroutput><userinput>dpkg -l 'b*'</userinput>
<computeroutput>Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                    Version          Architecture     Description
+++-=======================-================-================-====================================================
un  backupninja             &lt;none&gt;           &lt;none&gt;           (no description available)
ii  backuppc                3.3.0-2          amd64            high-performance, enterprise-grade system for backin
un  base                    &lt;none&gt;           &lt;none&gt;           (no description available)
un  base-config             &lt;none&gt;           &lt;none&gt;           (no description available)
ii  base-files              8                amd64            Debian base system miscellaneous files
ii  base-passwd             3.5.37           amd64            Debian base system master password and group files
[...]
$ </computeroutput><userinput>dpkg -c /var/cache/apt/archives/gnupg_1.4.18-6_amd64.deb</userinput>
<computeroutput>drwxr-xr-x root/root         0 2014-12-04 23:03 ./
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/udev/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/udev/rules.d/
-rw-r--r-- root/root      2711 2014-12-04 23:03 ./lib/udev/rules.d/60-gnupg.rules
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/lib/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/lib/gnupg/
-rwxr-xr-x root/root     39328 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_ldap
-rwxr-xr-x root/root     92872 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_hkp
-rwxr-xr-x root/root     47576 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_finger
-rwxr-xr-x root/root     84648 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_curl
-rwxr-xr-x root/root      3499 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_mailto
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/bin/
-rwxr-xr-x root/root     60128 2014-12-04 23:03 ./usr/bin/gpgsplit
-rwxr-xr-x root/root   1012688 2014-12-04 23:03 ./usr/bin/gpg
[...]
$ </computeroutput><userinput>dpkg -I /var/cache/apt/archives/gnupg_1.4.18-6_amd64.deb</userinput>
<computeroutput> new debian package, version 2.0.
 size 1148362 bytes: control archive=3422 bytes.
    1264 bytes,    26 lines      control              
    4521 bytes,    65 lines      md5sums              
     479 bytes,    13 lines   *  postinst             #!/bin/sh
     473 bytes,    13 lines   *  preinst              #!/bin/sh
 Package: gnupg
 Version: 1.4.18-6
 Architecture: amd64
 Maintainer: Debian GnuPG-Maintainers &lt;pkg-gnupg-maint@lists.alioth.debian.org&gt;
 Installed-Size: 4888
 Depends: gpgv, libbz2-1.0, libc6 (&gt;= 2.15), libreadline6 (&gt;= 6.0), libusb-0.1-4 (&gt;= 2:0.1.12), zlib1g (&gt;= 1:1.1.4)
 Recommends: gnupg-curl, libldap-2.4-2 (&gt;= 2.4.7)
 Suggests: gnupg-doc, libpcsclite1, parcimonie, xloadimage | imagemagick | eog
 Section: utils
 Priority: important
 Multi-Arch: foreign
 Homepage: http://www.gnupg.org
 Description: GNU privacy guard - a free PGP replacement
  GnuPG is GNU's tool for secure communication and data storage.
  It can be used to encrypt data and to create digital signatures.
  It includes an advanced key management facility and is compliant
  with the proposed OpenPGP Internet standard as described in RFC 4880.
[...]</computeroutput></screen>
      </example>

      <sidebar>
        <title><emphasis>更进一步</emphasis> 版本的对比</title>
        <indexterm><primary>版本，对比</primary></indexterm>
        <indexterm><primary>对比版本</primary></indexterm>

	<para>因为 <command>dpkg</command> 是处理 Debian 软件包的程序，它也能够逻辑地比较版本编号。所以有 <literal>--compare-versions</literal> 选项，以外部程序使用它 (尤其是被 <command>dpkg</command> 本身运行的配置脚本)。这个选项需要三个参数：版本编号、比较操作数、以及第二个版本编号。可能的操作数为 <literal>lt</literal> (小于)、<literal>le</literal> (大于或等于)、<literal>eq</literal> (等于)、<literal>ne</literal> (不等于)、<literal>ge</literal> (大于或等于)、以及 <literal>gt</literal> (大于)。若比较结果正确，<command>dpkg</command> 送回 0 (成功)；若不正确，则送回 0 以外的数值 (表示失败)。</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>dpkg --compare-versions 1.2-3 gt 1.1-4</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>0
$ </computeroutput><userinput>dpkg --compare-versions 1.2-3 lt 1.1-4</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>1
$ </computeroutput><userinput>dpkg --compare-versions 2.6.0pre3-1 lt 2.6.0-1</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>1</computeroutput></screen>

	<para>注意前例最后一个比较的失败：<command>dpkg</command>、<literal>pre</literal>，表示为预发布版，没有特别的意义，此程序以比较数字版本 (a &lt; b &lt; c ...) 相同的方式比较字顺版本。所以，“<literal>0pre3</literal>” 大于 “<literal>0</literal>”。我们以毛毛虫 “<literal>~</literal>” 表示该软件包的预发布版：</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>dpkg --compare-versions 2.6.0~pre3-1 lt 2.6.0-1</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>0</computeroutput></screen>
      </sidebar>
    </section>
    <section>
      <title><command>dpkg</command>的日志文件</title>

      <para><command>dpkg</command> 把所有的交易记录存在名为 <filename>/var/log/dpkg.log</filename> 的日志档。这个日志档的内容颇为详尽且啰唆，记录软件包被 <command>dpkg</command> 处理的每个进程。追踪 dpkg 的每个作为之外，日志档还保留系统发展的记录：可以覆查每个软件包的安装与移除步骤，对于了解最近的变动极有帮助。此外，还记录所有的版本，可以交互检查 <filename>changelog.Debian.gz</filename> 的内容，查看有问题的软件包或在线的错误报告。</para>
    </section>
    <section id="sect.multi-arch">
      <title>多架构支持</title>
      <indexterm><primary>多架构</primary></indexterm>
      <indexterm><primary>架构</primary><secondary>多架构支持</secondary></indexterm>

      <para>所有的 Debian 包在它们的管控信息中都有一个<literal>架构</literal> 字段。该字段可包含：“<literal>全部</literal>“（对与架构无关的包），或者它的目标架构名称（如“amd64”， “armhf”，…）。对于后者，默认情况下，<command>dpkg</command>将只能接受安装与主机架构匹配的软件包，主机架构可通过<command>dpkg --print-architecture</command>来获得。</para>

      <para>该限制确保用户不会因为错误架构编译的二进制文件而挂掉。一切都很完美，除了（某些）计算机可以运行多架构的二进制文件，或者以本地方式（“amd64“系统可运行”i386“二进制文件）运行，或者以模拟器运行。</para>
      
      <section>
        <title>启用多架构</title>
	<para><command>dpkg</command>的多架构支持允许用户定义可安装于当前系统的“异质架构” 。这可以方便的通过 <command>dpkg --add-architecture</command>完成，如下例。有一相应的 <command>dpkg --remove-architecture</command> 以放弃对异质架构的支持，但仅可用于未余留该架构软件包的情况。</para>

	<screen>
<computeroutput># </computeroutput><userinput>dpkg --print-architecture</userinput>
<computeroutput>amd64
# </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput># </computeroutput><userinput>dpkg -i gcc-4.9-base_4.9.1-19_armhf.deb</userinput>
<computeroutput>dpkg: error processing archive gcc-4.9-base_4.9.1-19_armhf.deb (--install):
 package architecture (armhf) does not match system (amd64)
Errors were encountered while processing:
 gcc-4.9-base_4.9.1-19_armhf.deb
# </computeroutput><userinput>dpkg --add-architecture armhf</userinput>
<computeroutput># </computeroutput><userinput>dpkg --add-architecture armel</userinput>
<computeroutput># </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput>armhf
armel
# </computeroutput><userinput>dpkg -i gcc-4.9-base_4.9.1-19_armhf.deb</userinput>
<computeroutput>Selecting previously unselected package gcc-4.9-base:armhf.
(Reading database ... 86425 files and directories currently installed.)
Preparing to unpack gcc-4.9-base_4.9.1-19_armhf.deb ...
Unpacking gcc-4.9-base:armhf (4.9.1-19) ...
Setting up gcc-4.9-base:armhf (4.9.1-19) ...
# </computeroutput><userinput>dpkg --remove-architecture armhf</userinput>
<computeroutput>dpkg: error: cannot remove architecture 'armhf' currently in use by the database
# </computeroutput><userinput>dpkg --remove-architecture armel</userinput>
<computeroutput># </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput>armhf</computeroutput></screen>

	<sidebar>
	  <title><emphasis>备注</emphasis> APT 的多架构支持</title>
	  <para>当 dpkg 已配置为支持异质架构时，APT将会自动检测，并在更新过程中开始下载相应的<filename>软件包</filename>文件。</para>
	  <para>异质软件包可通过 <command>apt install <replaceable>软件包</replaceable>: <replaceable>架构</replaceable></command>安装。</para>
	</sidebar>

	<sidebar>
	  <title><emphasis>实例</emphasis> 在 amd64 架构上使用专有 i386 二进制文件</title>
	  <para>对于多架构，有多种使用案例，但最常见的是在 64 位系统（amd64）上执行 32 位二进制文件（i386）的可能性，特别是因为一些流行的专有应用（如 Skype）仅提供 32 位版本。</para>
	</sidebar>
      </section>
      <section>
	<title>多架构相关的变更</title>

	<para>要让多架构真正实用和可用，库文件需要重新打包，并移动到一个用于特定架构的文件夹以便可以并存安装多重副本（针对不同架构）。这样的更新包中包含“<literal>Multi-Arch: same</literal>“头字段，以告诉打包系统此软件包的不同架构可以安全地并存安装（而且这些包仅能满足同架构软件包的依赖）。由于多架构在 Debian <emphasis role="distribution">Wheezy</emphasis> 中为初次引入，因而尚未完成所有库文件的转换。</para>

	<screen><computeroutput>$ </computeroutput><userinput>dpkg -s gcc-4.9-base
</userinput><computeroutput>dpkg-query: error: --status needs a valid package name but 'gcc-4.9-base' is not: ambiguous package name 'gcc-4.9-base' with more than one installed instance

Use --help for help about querying packages.
$ </computeroutput><userinput>dpkg -s gcc-4.9-base:amd64 gcc-4.9-base:armhf | grep ^Multi
</userinput><computeroutput>Multi-Arch: same
Multi-Arch: same
$ </computeroutput><userinput>dpkg -L libgcc1:amd64 |grep .so
</userinput><computeroutput>/lib/x86_64-linux-gnu/libgcc_s.so.1
$ </computeroutput><userinput>dpkg -S /usr/share/doc/gcc-4.9-base/copyright
</userinput><computeroutput>gcc-4.9-base:amd64, gcc-4.9-base:armhf: /usr/share/doc/gcc-4.9-base/copyright
</computeroutput></screen>

	<para>值得注意的是，<literal>Multi-Arch: same</literal>软件包需具备能够明晰识别架构的名称。它们也能够与相同包的其他实例共享文件；<command>dpkg</command>确保所有的包在共享时具有逐位对应识别的文件。最后但并非最不重要的，一个包的所有实例必须为相同版本。它们必须同时升级。</para>

	<para>多架构支持也带来了在依赖处理方式上的一些有趣的挑战。要满足依赖，需要：或者有<literal>Multi-Arch: foreign</literal>标识的软件包，或者架构上能匹配已声明依赖的软件包（在该依赖方案处理中，架构无关包假定为同样架构，而非主机架构）。通过<literal><replaceable> 软件包</replaceable> :any</literal>语法，依赖可以被弱化，以便允许任意架构能够满足依赖，但异质软件包仅能满足如下依赖：有“<literal> Multi-Arch: allowed</literal> ”标识的依赖。</para>
      </section>
    </section>
  </section>
  <section id="sect.coexistence-with-other-packaging-systems">
    <title>与其它软件包共存</title>
    <indexterm><primary>RPM</primary></indexterm>
    <indexterm><primary>红帽的软件包管理</primary></indexterm>
    <indexterm><primary><command>alien</command></primary></indexterm>

    <para>Debian 包格式并非唯一用于自由软件领域的软件包格式。主要竞争者是红帽 Linux 发行版的 RPM 格式以及其衍生格式。红帽是一个非常流行的商业化发行版。对于来自第三方的软件，常以 RPM 格式软件包提供，而非 Debian 格式。</para>

    <para>这个情况下，你应该知道<command>rpm</command>程序是如何处理RPM软件包的，这种格式在Debian软件包中也可用。需要谨慎的使用，尽管如何，这些操作会限制从一个软件包中解压并且提取出信息以验证其完整性。实际上，不应该在Debian系统中使用<command>rpm</command>来安装一个RPM软件包；RPM使用了它自己的数据库以便和Debian的软件中分离（比如<command>dpkg</command>）。这也就是为什么不可能确保两个包管理系统共存在一个系统中，而这个系统还能保持稳定。</para>

    <para>另一方面，<emphasis role="pkg">alien</emphasis> 可以把RPM软件包转换成Debian软件包，反之亦然。</para>

    <sidebar>
      <title><emphasis>社区</emphasis> 鼓励<filename>.deb</filename>的使用</title>

      <para>若经常使用 <command>alien</command> 程序安装 RPM 软件包，应告诉该等软件包的提供者，和蔼地表达您希望能有 <filename>.deb</filename> 格式的愿望。软件包的格式不是全部：<filename>.deb</filename> 软件包以 <command>alien</command> 创建或专为 Debian 创建，或由 Ubuntu 之类衍生版取得，其品质与集成性，可能不如来自专为 Debian <emphasis role="distribution">Jessie</emphasis> 所做的软件包。</para>
    </sidebar>

    <screen>
<computeroutput>$ </computeroutput><userinput>fakeroot alien --to-deb phpMyAdmin-2.0.5-2.noarch.rpm</userinput> 
<computeroutput>phpmyadmin_2.0.5-2_all.deb generated
$ </computeroutput><userinput>ls -s phpmyadmin_2.0.5-2_all.deb</userinput>
<computeroutput>  64 phpmyadmin_2.0.5-2_all.deb</computeroutput></screen>

    <para>此例极为简单。然而，您必须知道不需任何相依性信息就能产生软件包，两种软件包格式并不必然有系统性的关系。管理者必须以手动方式确保转换过的软件包能够正确运作，这就是 Debian 产生的软件包能够避免此种可能。幸运的是，Debian 拥有软件软件包各种版本的数据库，想要的都能找到。</para>

    <para>翻看<command>alien</command>命令的帮助页面，您会注意到该程序也可处理其他的包格式，特别是使用 Slackware 发行版所用的格式（它使用简单的<filename>tar.gz</filename>归档格式）。</para>

    <para><command>dpkg</command>作为一个稳定的工具有助于提高Debian的名字。APT软件包工具，在下面的章节中会告诉我们，它不但保留了这一优势，同时减轻了管理员管理软件包这一必须但是艰难得任务的负担。</para>
  </section>
</chapter>
