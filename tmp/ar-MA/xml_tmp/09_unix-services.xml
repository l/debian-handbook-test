<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="unix-services">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-unix-services.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>إقلاع النظام</keyword>
      <keyword>سكربتات Init</keyword>
      <keyword>SSH</keyword>
      <keyword>Telnet</keyword>
      <keyword>حقوق</keyword>
      <keyword>صلاحيات</keyword>
      <keyword>إشراف</keyword>
      <keyword>Inetd</keyword>
      <keyword>Cron</keyword>
      <keyword>النسخ الاحتياطي</keyword>
      <keyword>توصيل ساخن</keyword>
      <keyword>PCMCIA</keyword>
      <keyword>APM</keyword>
      <keyword>ACPI</keyword>
    </keywordset>
  </chapterinfo>
  <title>خدمات يونكس</title>
  <highlights>
    <para>يغطي هذا الفصل عدداً من الخدمات الأساسية المشتركة بين العديد من أنظمة يونكس التي يجب أن يعرفها كل مدير نظام.</para>
  </highlights>
  <section id="sect.system-boot">
    <title>إقلاع النظام</title>
    <indexterm><primary>إقلاع</primary><secondary>النظام</secondary></indexterm>

    <para>عند إقلاع الحاسب، تعرض الرسائل العديدة التي تمر على الشاشة العديد من الإعدادات وعمليات التهيئة الجارية. قد ترغب أحياناً بتعديل هذه المرحلة قليلاً، مما يعني أنك تحتاج فهمها جيداً. هذا هو الهدف من هذا القسم.</para>

    
    <para>أولاً، يتولى BIOS التحكم بالحاسوب، ويتعرف على الأقراص، ويحمل <emphasis>سجل الإقلاع الرئيسي Master Boot Record</emphasis>، وينفذ محمّل الإقلاع. ثم يتولى محمل الإقلاع التحكم، ويبحث عن النواة على القرص، ثم يحملها وينفذها. بعدها تُهيَّأ النواة، وتبدأ النواة البحث عن القسم الذي يحوي نظام الملفات الجذر وتربطه (mount)، وأخيراً تستدعي النواة البرنامج الأول: <command>init</command>. عادةً، يقع هذا ”القسم الجذر“ وبرنامج <command>init</command> هذا في نظام ملفات ظاهري ليس له وجود إلا في الذاكرة RAM في الحقيقة (ومن هنا أتى اسمه initramfs، وسابقاً كان يدعى ”initrd“ اختصاراً للعبارة ”initialization RAM disk“). يُحمَّل نظام الملفات هذا إلى الذاكرة بوساطة محمل الإقلاع، وغالباً يتم تحميله من ملف على القرص الصلب أو من الشبكة. يحوي نظام الملفات هذا الحد الأدنى من المتطلبات التي تحتاجها االنواة لتحميل نظام الملفات الجذر ”الحقيقي“: قد تكون هذه المتطلبات وحدات تعريف للسواقة الصلبة، أو أجهزة أخرى لا يستطيع النظام الإقلاع دونها، أو غالباً ما تكون سكربتات تهيئة ووحدات لتجميع مصفوفات RAID، أو لفتح الأقسام المشفرة، أو تفعيل حيزات LVM، الخ. بعد ربط القسم الجذر، يسلم initramfs التحكم إلى init الحقيقي. وينتقل الجهاز إلى عملية الإقلاع النظامية.</para>

    <figure id="figure.boot-process-systemd">
      <title>تسلسل الإقلاع في حاسب يعمل بنظام لينكس يستخدم systemd</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/startup-systemd.png" scalefit="1" width="80%" />
        </imageobject>
      </mediaobject>
    </figure>

    <section id="sect.systemd"><title>نظام إقلاع systemd</title>

    <para>حالياً، يُقدِّم <emphasis role="pkg">systemd</emphasis> عملية ”init الحقيقية“، ويشرح هذا القسم نظام الإقلاع هذا.</para>

    <sidebar>
      <title><emphasis>ثقافة</emphasis> ما قبل <command>systemd</command></title>

      <para><command>systemd</command> هو ”نظام إقلاع init system“ حديث نسبياً، ورغم أنه كان متاحاً، نوعاً ما، في <emphasis role="distribution">ويزي</emphasis> لكنه لم يصبح النظام الافتراضي إلا في دبيان <emphasis role="distribution">جيسي</emphasis>. اعتمدت الإصدارات السابقة، افتراضياً، على ”System V init“ (من الحزمة <emphasis role="pkg">sysv-rc</emphasis>)، وهو نظام إقلاع أقدم. سوف نتحدث عن System V init بعد قليل.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>بدائل</emphasis> نظم إقلاعية أخرى</title>

      <para>يشرح هذا الكتاب النظام الإقلاعي المستخدم افتراضياً في دبيان <emphasis role="distribution">جيسي</emphasis> (كما تقدمه حزمة <emphasis role="pkg">systemd</emphasis>)، كما يشرح أيضاً النظام الافتراضي السابق، <emphasis role="pkg">sysvinit</emphasis>، وهو نظام مشتق وموروث من نظم يونكس من نمط <emphasis>System V</emphasis>؛ لكن هناك نظم إقلاعية أخرى.</para>

      <para><emphasis role="pkg">file-rc</emphasis> هو نظام إقلاعي بتصميم بسيط جداً. يحافظ هذا النظام على مبدأ مستويات التشغيل، لكنه يستبدل الأوامر التوجيهية والروابط الرمزية بملف إعداد، الذي يشير إلى عمليات <command>init</command> التي يجب استدعاؤها كما يحدد ترتيب تشغيلها.</para>

      <para>نظام <command>upstart</command> غير مختبر بشكل كامل بعد على دبيان. يعتمد هذا النظام على الأحداث: لا تنفذ فيه سكربتات التهيئة بترتيب تسلسلي بل استجابةً لأحداث معينة مثل اكتمال سكربت آخر تعتمد عليه. هذا النظام، الذي بدأته أوبنتو، متوفر في دبيان <emphasis role="distribution">جيسي</emphasis>، لكنه ليس الافتراضي؛ بل هو في الواقع بديل عن <emphasis role="pkg">sysvinit</emphasis>، وإحدى المهام التي يطلقها <command>upstart</command> تعمل على تشغيل السكربتات المكتوبة للنظم التقليدية، خصوصاً سكربتات الحزمة <emphasis role="pkg">sysv-rc</emphasis>.</para>

      <para>هناك نظم إقلاع أخرى وأوضاع عمل أخرى، مثل <command>runit</command>،‏أو <command>minit</command>، لكنها جميعاً متخصصة نسبياً وغير منتشرة على نطاق واسع.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>حالة خاصة</emphasis> الإقلاع من الشبكة</title>

      <para>في بعض الحالات، قد يتم ضبط BIOS بحيث لا ينفذ MBR، بل يبحث عن مكافئه على الشبكة، وهذا يسمح بتجميع حواسيب بدون أقراص صلبة، أو تجهيز حواسيب يعاد تثبيت النظام عليها عند كل إقلاع. هذا الخيار غير متوفر في جميع الأجهزة وهو يحتاج توافقاً مناسباً بين BIOS وبطاقة الشبكة عموماً.</para>

      <para>يمكن استخدام الإقلاع من الشبكة لتشغيل <command>debian-installer</command> أو FAI (انظر <xref linkend="sect.installation-methods" />).</para>
    </sidebar>

    <sidebar>
      <title><emphasis>أساسيات</emphasis> العملية، نسخة من البرنامج</title>
      <indexterm><primary>عملية</primary></indexterm>

      <para>العملية process هي التمثيل الذاكري للبرنامج، وهي تحوي كل المعلومات اللازمة للتنفيذ السليم للبرمجية (تحوي الشفرة البرمجية نفسها، بالإضافة إلى البيانات التي تخزنها في الذاكرة، ولائحة الملفات التي فتحتها، والاتصالات الشبكية التي أنشأتها، الخ). يمكن إنشاء عدد من العمليات من برنامج واحد، ولا يشترط أن تعمل تحت مستخدمين مختلفين.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>أمن</emphasis> استخدام الصدفة بدل <command>init</command> للحصول على صلاحيات الجذر</title>

      <para>تقليدياً، أول عملية في سلسلة الإقلاع هي برنامج <command>init</command> (وهذا عبارة عن رابط رمزي يشير إلى <filename dir="ltr">/lib/systemd/systemd</filename> افتراضياً). لكن من الممكن تمرير خيار <literal>init</literal> للنواة للإشارة إلى برنامج آخر.</para>
      <indexterm><primary><command>init</command></primary></indexterm>

      <para>بوسع أي شخص يستطيع الوصول للحاسوب الضغط على زر <keycap>Reset</keycap>، وبالتالي إعادة إقلاع الجهاز. بعدها، من الممكن، عند الوصول إلى شاشة محمل الإقلاع، تمرير الخيار <literal>init=/bin/sh</literal> للنواة للحصول على صلاحيات الجذر دون معرفة كلمة سر مدير النظام.</para>

      <para>لمنع هذا يمكنك حماية محمل الإقلاع نفسه بكلمة سر. يمكنك أيضاً الأخذ بعين الاعتبار حماية الوصول إلى BIOS (ميزة حماية BIOS بكلمة سر متوفرة دائماً تقريباً)، إذ بدونها يستطيع أي متطفل خبيث إقلاع الجهاز من وسيط تخزين نقال عليه نسخة لينكس يستطيع استخدامها للوصول إلى المعلومات على الأقراص الصلبة للحاسب.</para>

      <para>أخيراً، عليك الحذر من أن معظم نظم BIOS لها كلمات سر عامة. القصد الأساسي وراء هذه الكلمات هو مساعدة الذين ينسون كلمات مرورهم، لكن كلمات السر هذه أصبحت علنية الآن ومتاحة على الإنترنت (تأكد بنفسك بالبحث عن ”generic BIOS passwords“ في أي محرك بحث). إذن سوف تعيق جميع وسائل الحماية هذه الوصول غير المصرح به للحواسيب لكن لن تمنعه بشكل كامل. لا توجد طريقة موثوقة لحماية حاسب ما إذا كان المخترق يستطيع الوصول إليه فيزيائياً؛ إذ يمكنه فصل الأقراص الصلبة وتوصيلها بحاسب آخر على أي حال، أو يسرق الجهاز كله، أو يمحو ذاكرة BIOS لإزالة كلمة السر…</para>
    </sidebar>


<para>ينفذ systemd عدة عمليات مسؤولة عن إعداد النظام: لوحة المفاتيح، التعريفات، نظم الملفات، الشبكة، الخدمات. يحافظ systemd على الرؤية العامة للنظام ككل، ولمتطلبات المكونات أيضاً. كل مكون معرف باستخدام ”ملف وحدة unit file“ (وأحياناً أكثر من ملف)؛ الصيغة العامة لهذه الملفات مشتقة من صيغة ملفات ”‎*.ini“ الشائع استخدامها، حيث تُجمع أزواج <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> ضمن ترويسات <literal>[<replaceable>section</replaceable>]</literal>. تُخزَّنُ ملفات الواحدات في <filename>/lib/systemd/system/</filename> و<filename>/etc/systemd/system/</filename>؛ ولها أنواع عديدة، لكننا سنركز على ”الخدمات services“ و”الأهداف targets“ هنا.</para>

<para>يعرف ”ملف الخدمة“ في systemd عملية يديرها systemd. يحوي هذا الملف نفس المعلومات التي كانت تحويها سكربتات init القديمة تقريباً، لكنها معرفة بطريقة تصريحية (وأكثر اختصاراً بكثير). يتولى systemd غالبية المهام المتكررة (بدء العملية وإيقافها، فحص حالتها، السجلات logging، سحب الصلاحيات، وغيرها)، أما ملف الخدمة فيذكر فقط خصوصيات العملية. على سبيل المثال، هذا ملف الخدمة الخاص بعملية SSH:</para>

<programlisting>[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</programlisting>

<para>كما ترى، ليس هناك إلا القليل من الكود في هذا الملف، وكلها تصريحات. يتولى systemd مهمة عرض تقارير عن مستوى التقدم progress reports، ومتابعة العمليات، وإعادة تشغيلها عند الحاجة.</para>

<para>يعرف ”ملف الهدف“ في systemd إحدى حالات النظام، حيث تعمل فيها مجموعة محددة من الخدمات. يمكنك اعتبارها كمكافئ للمستوى التشغيلي قديماً. أحد الأهداف هو <literal>local-fs.target</literal>؛ وعند تحقيقه تستطيع أجزاء النظام الأخرى أن تفترض أن كافة نظم الملفات المحلية مربوطة وقابلة للوصول. من الأهداف الأخرى هناك <literal>network-online.target</literal> و<literal>sound.target</literal>. يمكن ذكر اعتماديات الهدف في ملف الهدف نفسه (في سطر <literal dir="ltr">Requires=</literal>)، أو باستخدام رابط رمزي في المجلد <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal> يشير إلى ملف خدمة ما. مثلاً، يحوي المجلد <filename>/etc/systemd/system/printer.target.wants/</filename> رابطاً يشير إلى <filename dir="ltr">/lib/systemd/system/cups.service</filename>؛ بالتالي سيحرص systemd على ضمان عمل CUPS في سبيل الوصول إلى <literal>printer.target</literal>.</para>

<para>بما أن ملفات الوحدات ملفات تصريحية وليست سكربتات أو برامج، فلا يمكن تنفيذها مباشرة، ولا يمكن تفسيرها إلا عن طريق systemd؛ ولهذا قُدّمت عدة أدوات تسمح لمدير النظام بالتفاعل مع systemd والتحكم في حالة النظام وحالة كل مكون من مكوناته.</para>

<para>أولى هذه الأدوات هي <command>systemctl</command>. عند استدعائها دون أي متغيرات، سوف تعرض لائحة بكل ملفات الوحدات التي يعرفها systemd (عدا الوحدات المعطلة)، بالإضافة إلى حالاتها. تعطي أداة <command>systemctl status</command> رؤية أفضل عن الخدمات، وعن العمليات المتعلقة بها. وإذا أعطيت اسم إحدى الخدمات (مثلاً <command>systemctl status ntp.service</command>)، ستعيد تفاصيل أكثر، مثل آخر السطور من السجلات المتعلقة بهذه الخدمة (سنعود لهذه الفكرة لاحقاً).</para>

<para>لبدء تشغيل خدمة ما يدوياً يكفي استدعاء <command>systemctl start <replaceable>servicename</replaceable>.service</command>. ولإيقاف الخدمة يكفيك استدعاء <command>systemctl stop <replaceable>servicename</replaceable>.service</command>؛ من الأوامر الفرعية الأخرى هناك <command>reload</command> و<command>restart</command>.</para>

<para>للتحكم في تفعيل الخدمة (أي هل سيتم تشغيلها تلقائياً عند الإقلاع أم لا)، استخدم الأمر <command>systemctl enable <replaceable>servicename</replaceable>.service</command> (أو <command>disable</command> لتعطيلها). يسمح لك الأمر الفرعي <command>is-enabled</command> بالتحقق من حالة الخدمة.</para>

<para>من الميزات المثيرة للاهتمام في systemd هي أنه يتضمن مكون للتسجيل (logging) يدعى <command>journald</command>. يعمل هذا المكون كمكمل  لنظم السجلات التقليدية مثل <command>syslogd</command>، ولكنه يضيف مزايا مثيرة للاهتمام مثل الربط بين الخدمة والرسائل التي تولدها، وإمكانية التقاط رسائل الأخطاء التي تنتج عن تهيئة الخدمة. يمكن عرض الرسائل لاحقاً بمساعدة الأمر <command>journalctl</command>. إذا لم تمرر له أي متغيرات، سوف يفرغ ببساطة كل الرسائل التي سُجِّلت منذ إقلاع النظام؛ من النادر أن تستفيد من استخدامه بهذا الشكل. في معظم الأوقات، سوف تستخدمه مع تحديد اسم خدمة ما:</para>

<screen><computeroutput># </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</computeroutput></screen>

<para>هناك خيار مفيد آخر وهو خيار <command dir="ltr">-f</command>، الذي يطلب من <command>journalctl</command> الاستمرار في عرض الرسائل الجديدة فور بثها (بشكل مشابه كثيراً لاستخدام <command>tail -f <replaceable>file</replaceable></command>).</para>

<para>إذا بدا أن إحدى الخدمات لا تعمل كما يجب، فأولى الخطوات لحل المشكلة هي التحقق من أن الخدمة تعمل فعلاً عن طريق <command>systemctl status</command>؛ إذا لم تكن تعمل، وكانت الرسائل التي يعطيها الأمر الأول غير كافية لتشخيص المشكلة، تحقق من السجلات التي جمعها journald عن الخدمة. مثلاً، لنفترض أن مخدم SSH لا يعمل:</para>

<screen><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>vi /etc/ssh/sshd_config
</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service
</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </computeroutput></screen>

<para>بعد التحقق من حالة الخدمة (فشل failed)، انتقلنا إلى التحقق من السجلات؛ التي أشارت إلى خطأ في ملف الإعدادات. بعد تحرير ملف الإعدادات وإصلاح الخطأ، أعدنا تشغيل الخدمة، ثم تحققنا أنها تعمل فعلاً.</para>

<sidebar><title><emphasis>التعمق أكثر</emphasis> الأنواع الأخرى لملفات الوحدات</title>

<para>لقد شرحنا أبسط قدرات systemd في هذا القسم. لكن هناك ميزات كثيرة أخرى مفيدة؛ سنذكرها سريعاً هنا:</para>

<itemizedlist>

<listitem><para>تفعيل المقابس socket activation: يمكن استخدام ملف وحدة من نوع ”socket“ لتعريف مقبس شبكة أو مقبس يونكس يديره systemd؛ هذا يعني أن systemd سينشئ المقبس، ويمكن تشغيل الخدمة الفعلية حسب الطلب عند ورود محاولة اتصال فعلية. هذه الميزة تشبه تقريباً مزايا <command>inetd</command>. انظر <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry>‎.</para></listitem>

<listitem><para>المؤقتات timers: ملف الوحدة من نوع المؤقت ”timer“ لتعريف أحداث تنفذ بمعدل تكرار ثابت أو في أوقات معينة؛ عندما تربط إحدى الخدمات بمؤقت من هذا النوع، سوف تُنفّذ المهمة المحددة لحظة قدح المؤقت. هذا يسمح بتقليد جزء من مزايا <command>cron</command>. انظر <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry>‎.</para></listitem>

<listitem><para>شبكة network: يعرف ملف الوحدة من نوع الشبكة “network unit file“ واجهة شبكية، وهذا يسمح بإعداد هذه الواجهات بالإضافة إلى السماح بتعريف اعتماد الخدمات على جاهزية واجهة شبكية معينة.</para></listitem>

</itemizedlist>
</sidebar>

</section>

<section id="sect.sysvinit"><title>نظام إقلاع System V</title>
    <para>ينفذ نظام System V init (الذي سنكتفي بتسميته init اختصاراً) عدة عمليات، وفقاً للتعليمات في الملف <filename dir="ltr">/etc/inittab</filename>. أول برنامج ينفذ هو <command dir="ltr">/etc/init.d/rcS</command> (التابع لمرحلة <emphasis>sysinit</emphasis>)، وهو سكربت ينفذ جميع البرامج في المجلد <filename>/etc/rcS.d/</filename>. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm></para>

    <para>من ضمن هذه البرامج سوف تجد –على التعاقب– برامجاً مسؤولة عن:</para>
    <itemizedlist>
      <listitem>
	<para>إعداد لوحة مفاتيح الطرفية؛</para>
      </listitem>
      <listitem>
	<para>تحميل التعاريف: تحمّل النواة معظم التعاريف عند اكتشاف العتاد؛ بعدها تحمل التعاريف الإضافية آلياً إذا كانت الوحدات الموافقة لها مذكورة في <filename dir="ltr">/etc/modules</filename>؛</para>
      </listitem>
      <listitem>
	<para>التحقق من سلامة نظام الملفات؛</para>
      </listitem>
      <listitem>
	<para>ربط الأقسام المحلية؛</para>
      </listitem>
      <listitem>
	<para>إعداد الشبكة؛</para>
      </listitem>
      <listitem>
	<para>ربط نظم الملفات الشبكية (NFS).</para>
      </listitem>
    </itemizedlist>

    <sidebar>
      <title><emphasis>أساسيات</emphasis> وحدات النواة والخيارات</title>
      <indexterm><primary>وحدات</primary><secondary>وحدات النواة</secondary></indexterm>

      <para>هناك خيارات لوحدات النواة أيضاً يمكن ضبطها بوضع بعض الملفات في <filename>/etc/modprobe.d/</filename>. تعرف هذه الخيارات بتعليمات توجيهية تشبه هذه: <literal>options <replaceable>module-name</replaceable> <replaceable>option-name</replaceable>=<replaceable>option-value</replaceable></literal>. يمكن تحديد عدة خيارات بتعليمة توجيهية واحدة إذا اقتضى الأمر.</para>

      <para>ملفات الضبط هذه تابعة لبرنامج <command>modprobe</command> – وهو البرنامج الذي يحمل وحدات النواة مع اعتمادياتها (تستطيع وحدات النواة بالفعل استدعاء وحدات أخرى). هذا البرنامج متوفر في الحزمة <emphasis role="pkg">kmod</emphasis>.</para>
      <indexterm><primary><command>modprobe</command></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">kmod</emphasis></primary></indexterm>
    </sidebar>

    <para>بعد هذه المرحلة، تتولى <command>init</command> التحكم وتبدأ تشغيل البرامج المفعلة في مستوى التشغيل الافتراضي (وهو عادة المستوى 2)، حيث تنفذ <command dir="ltr">/etc/init.d/rc 2</command>، وهو سكربت يشغل جميع الخدمات المذكورة في المجلد <filename>/etc/rc2.d/</filename> والتي تبدأ أسماؤها بالحرف ”S“. كان يستخدم العدد المؤلف من خانتين الذي يتلو الحرف قديماً لتحديد ترتيب تشغيل الخدمات، لكن حالياً أصبح نظام الإقلاع الافتراضي يعتمد على <command>insserv</command>، الذي يجدول كل شيء آلياً حسب اعتماديات السكربتات. بالتالي على كل سكربت إقلاعي أن يصرح عن الشروط التي يجب تلبيتها عند تشغيل أو إيقاف الخدمة (إذا كان يجب تشغيل الخدمة قبل أو بعد خدمة أخرى مثلاً)؛ بعدها تشغلهم <command>init</command> بالترتيب الذي يحقق هذه الشروط. لم يعد الترقيم الثابت يؤخذ بعين الاعتبار إذن (لكن أسماء السكربتات يجب أن تبدأ دائمًا بحرف ”S“ يتبعه خانتين من الأرقام ثم الاسم الفعلي للسكربت الذي يستخدم مع الاعتماديات). عموماً، يبدأ تشغيل الخدمات الأساسية (مثل خدمة <command>rsyslog</command> التي تجمع السجلات، أو خدمة تعيين المنافذ <command>portmap</command>) أولاً، تليها الخدمات القياسية والواجهة الرسومية (<command>gdm3</command>).</para>

    <para>يسمح نظام الإقلاع الاعتمادي هذا بأتمتة عملية إعادة الترقيم، وهذه عملية متعبة جداً لو كانت ستتم يدوياً، كما يحد من الأخطاء البشرية، بما أن الجدولة تجري وفقاً للقيود المفروضة. هناك أيضاً ميزة أخرى، وهي أن تشغيل الخدمات يمكن أن يتم على التوازي إذا كانت مستقلة عن بعضها، وهذا يسرع عملية الإقلاع.</para>

    <indexterm><primary>مستوى تشغيلي</primary></indexterm>
    <indexterm><primary>مستوى، مستوى تشغيلي</primary></indexterm>

    <para>تفرق <command>init</command> بين عدة مستويات تشغيلية، بحيث يمكن التبديل من أحد هذه المستويات إلى الآخر بالأمر <command>telinit <replaceable>new-level</replaceable></command>. تبدأ <command>init</command> فوراً تنفيذ <command dir="ltr">/etc/init.d/rc</command> مرة ثانية ولكن في المستوى التشغيلي الجديد. بعدها يبدأ هذا السكربت تشغيل الخدمات الناقصة وإيقاف الخدمات التي لم تعد مرغوبة. لإتمام هذه المهمة، يستند هذا السكربت على محتويات <filename dir="ltr">/etc/rc<replaceable>X</replaceable>.d</filename> (حيث <replaceable>X</replaceable> تمثل المستوى الجديد). السكربتات التي تبدأ بالحرف ”S“ (من كلمة ”Start“) هي الخدمات التي يجب تشغيلها؛ أما التي تبدأ بالحرف ”K“ (من كلمة ”Kill“) فهي الخدمات التي يجب إيقافها. لا يشغل السكربت أي خدمة كانت فعالة مسبقاً في المستوى التشغيلي السابق.</para>

    <para>افتراضياً، يستخدم نظام إقلاع System V في دبيان أربعة مستويات تشغيلية:</para>
    <itemizedlist>
      <listitem>
	<para>المستوى 0 يستخدم مؤقتاً فقط أثناء إيقاف تشغيل الحاسب. ولذلك فهو لا يحوي إلا عدة سكربتات ”K“ فقط.</para>
      </listitem>
      <listitem>
	<para>المستوى 1، ويعرف أيضاً بوضع المستخدم الوحيد single-user mode، وهو يمثل النظام في وضع الأداء المنخفض؛ فهو يُحَمِّل الخدمات الأساسية فقط، وهو يستخدم لأغراض الصيانة بعيداً عن تفاعل المستخدمين.</para>
      </listitem>
      <listitem>
	<para>المستوى 2 هو مستوى العمل الطبيعي، الذي يتضمن خدمات الشبكة، والواجهة الرسومية، واتصالات المستخدمين، الخ.</para>
      </listitem>
      <listitem>
	<para>المستوى 6 يشبه المستوى 0، عدا أنه يستخدم في طور إيقاف التشغيل الذي يسبق إعادة الإقلاع.</para>
      </listitem>
    </itemizedlist>

    <para>هناك مستويات تشغيل أخرى، بالأخص المستويات من 3 إلى 5. افتراضياً تعمل هذه المستويات مثل المستوى 2 تماماً، لكن يستطيع مدير النظام تعديلها (بإضافة أو حذف سكربتات في مجلد <filename dir="ltr">/etc/rc<replaceable>X</replaceable>.d</filename> الموافق) لتكييفها مع حاجاته الخاصة.</para>

    <figure id="figure.boot-process-sysvinit">
      <title>تسلسل الإقلاع في حاسب يعمل بنظام لينكس يستخدم systemd</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/startup-sysvinit.png" scalefit="1" width="80%" />
        </imageobject>
      </mediaobject>
    </figure>
    <indexterm><primary>سكربت إقلاع</primary></indexterm>

    <para>كافة السكربتات المخزنة في مجلدات <filename dir="ltr">/etc/rc<replaceable>X</replaceable>.d</filename> المختلفة هي في الحقيقة روابط رمزية فقط —يُنشِئها البرنامج <command>update-rc.d</command> عند تثبيت الحزمة— تشير إلى السكربتات الفعلية المخزنة في <filename>/etc/init.d/</filename>. يستطيع مدير النظام ضبط الخدمات المتاحة في كل مستوى تشغيلي من خلال إعادة استدعاء <command>update-rc.d</command> مع البارامترات المعدلة. تشرح صفحة الدليل <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry>‎ صيغة استخدامها بالتفصيل. نرجو أن تلاحظ أن إزالة جميع الروابط الرمزية (باستخدام البارامتر <literal>remove</literal>) ليست طريقة جيدة لتعطيل الخدمة. بل عليك إعدادها بحيث لا تعمل في المستوى التشغيلي المطلوب بكل بساطة (مع الحفاظ على الاستدعاءات الموافقة لإيقافها في حال كانت الخدمة تعمل في المستوى التشغيلي السابق). بما أن واجهة <command>update-rc.d</command> متشابكة نوعاً ما، فقد تفضل استخدام <command>rcconf</command> (من الحزمة <emphasis role="pkg">rcconf</emphasis>) الذي يوفر واجهة أليفة للمستخدم.</para>
    <indexterm><primary><command>update-rc.d</command></primary></indexterm>

    <sidebar>
      <title><emphasis>سياسة دبيان</emphasis> إعادة تشغيل الخدمات</title>
      <indexterm><primary><command>invoke-rc.d</command></primary></indexterm>
      <indexterm><primary>خدمة</primary><secondary>إعادة تشغيل</secondary></indexterm>
      <indexterm><primary>إعادة تشغيل الخدمات</primary></indexterm>

      <para>أحياناً تعيد سكربتات الصيانة لبعض حزم دبيان تشغيل خدمات معينة لضمان توافرها أو لجعلها تأخذ بعض الخيارات بعين الاعتبار. لا يأخذ الأمر الذي يتحكم بالخدمات —<command dir="ltr">service <replaceable>service</replaceable> <replaceable>operation</replaceable></command>— المستويات التشغيلية بعين الاعتبار، ويفترض (مخطئاً) أن الخدمة تستخدم حالياً، لذلك قد يجري عمليات غير صحيحة (بدء خدمة كانت موقفة عمداً، أو إيقاف خدمة متوقفة أصلاً، الخ). لهذا قدمت دبيان البرنامج <command>invoke-rc.d</command>: يجب أن تستخدم سكربتات الصيانة هذا البرنامج لتشغيل سكربتات تهيئة الخدمات، وسوف ينفذ هذا البرنامج الأوامر الضرورية فقط. لاحظ أن اللاحقة <filename dir="ltr">.d</filename> استخدمت هنا في اسم البرنامج، وليس اسم مجلد، بخلاف الاستعمال الشائع.</para>
    </sidebar>

    <para>أخيراً، تبدأ <command>init</command> تشغيل البرامج لمختلف الطرفيات الظاهرية (<command>getty</command>). بعدها تعرض سطر أوامر، الذي ينتظر إدخال اسم المستخدم، ثم تنفذ <command>login <replaceable>user</replaceable></command> لبدء جلسة عمل.</para>
    <indexterm><primary><command>getty</command></primary></indexterm>

    <sidebar>
      <title><emphasis>مصطلحات</emphasis> Console وTerminal</title>

      <para>كانت الحواسيب الأولى تفصل عادة إلى العديد من الأجزاء الكبيرة: كانت حظيرة التخزين ووحدة المعالجة المركزية مفصولتين عن الأجهزة الملحقة التي يستخدمها عمال التشغيل للتحكم بهما. كانت هذه الملحقات جزءاً من قطعة مستقلة، وهي الـ ”console – لوحة المراقبة أو التحكم“. لقد بقي المصطلح، لكن معناه تغير. لقد أصبح –بصورة أو بأخرى– مرادفاً للمصطلح ”terminal – طرفية“، وهي شاشة مع لوحة مفاتيح.</para>

      <para>مع تطور الحواسيب، قدمت نظم التشغيل العديد من الـconsoles الظاهرية لتسمح بفتح عدة جلسات مستقلة في الوقت نفسه، حتى لو كان هناك شاشة واحدة ولوحة مفاتيح واحدة. توفر معظم نظم GNU/Linux ست consoles ظاهرية (في الوضع النصي)، يمكن الوصول إليها بالضغط على المفاتيح <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> وحتى <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo>.</para>

      <para>يمكن أن يشير المصطلحان ”console“ و ”terminal“ أيضًا لمحاكيات الطرفيات التي تعمل في جلسات X11 الرسومية (مثل <command>xterm</command>، أو <command>gnome-terminal</command> أو <command>konsole</command>).</para>
    </sidebar>
</section>
  </section>
  <section id="sect.remote-login">
    <title>تسجيل الدخول عن بعد</title>

    <para>الاتصال بالحاسوب عن بعد أمر أساسي لأي مدير نظام. فالمخدمات، المحتجزة في غرفها الخاصة، نادراً ما تزود بلوحة مفاتيح وشاشة دائمتين — بل توصل بالشبكة.</para>

    <sidebar>
      <title><emphasis>أساسيات</emphasis> مخدم، عميل</title>
      <indexterm><primary>عميل</primary><secondary>بنية مخدم/عميل</secondary></indexterm>
      <indexterm><primary>مخدم</primary><secondary>بنية مخدم/عميل</secondary></indexterm>

      <para>يوصف النظام الذي تتواصل فيه عدة مهام بين بعضها بالتعبير ”مخدم/عميل“ غالباً. المخدم هو البرنامج الذي يستلم الطلبات من العميل وينفذها. يتحكم العميل بهذه العمليات، أما المخدم فلا يتخذ أي مبادرات من نفسه.</para>
    </sidebar>

    <indexterm><primary>دخول</primary><secondary>الدخول عن بعد</secondary></indexterm>
    <indexterm><primary>تسجيل الدخول البعيد</primary></indexterm>

    <section id="sect.ssh">
      <title>الدخول البعيد الآمن: SSH</title>
      <indexterm><primary>SSH</primary></indexterm>
      <indexterm><primary>Secure Shell</primary></indexterm>

      <para>صمم بروتوكول <emphasis>SSH</emphasis>‏ (Secure SHell) مع التركيز على الأمان والوثوقية. الاتصالات عبر SSH آمنة: حيث يستوثق من الشخص الآخر، وتشفر جميع تبادلات البيانات.</para>

      <sidebar>
        <title><emphasis>ثقافة</emphasis> Telnet و RSH أدوات مهجورة</title>
	<indexterm><primary><command>telnet</command></primary></indexterm>
	<indexterm><primary><command>rsh</command></primary></indexterm>

	<para>قبل SSH، كانت <emphasis>Telnet</emphasis> و<emphasis>RSH</emphasis> هي الأدوات الرئيسية المستخدمة للدخول عن بعد. لكنها الآن بائدة تماماً ويجب عدم استعمالها حتى لو أنها بقيت متوفرة في دبيان.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>مصطلحات</emphasis> المصادقة/الاستيثاق، التشفير</title>

	<para>الحماية ضرورية عندما تحتاج إعطاء عميل ما إمكانية إجراء عمل ما أو بدء نشاط على المخدم. يجب أن تتأكد من هوية العميل؛ هذه هي المصادقة. تتكون هذه الهوية عادة من كلمة مرور يجب أن تبقى سرية، وإلا استطاع أي عميل آخر الحصول عليها. هذا هو الهدف من التشفير، وهو نوع من الترميز الذي يسمح لنظامين بتبادل المعلومات السرية عبر قناة عامة مع حمايتها بمنع الآخرين من فهمها.</para>

	<para>غالباً ما تذكر المصادقة مع التشفير سوياً، أولاً لأنهما يستخدمان معاً بكثرة، وثانياً لأنهما يطبقان عادة باستخدام مفاهيم رياضية متشابهة.</para>
      </sidebar>

      <para>يقدم SSH خدمتين لنقل الملفات. الأمر <command>scp</command> هو أداة نصية يمكن استخدامها كما يستخدم <command>cp</command>، إلا أن أي مسار إلى جهاز آخر يُسبَق باسم الجهاز، متبوعاً بنقطتين رأسيتين (<literal>:</literal>).</para>

      <screen><computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput>
</screen>

      <para>أما <command>sftp</command> فهو أمر تفاعلي، شبيه بالأمر <command>ftp</command>. يستطيع <command>sftp</command> نقل عدة ملفات في جلسة واحدة، كما يمكن التحكم بالملفات البعيدة باستخدامه (حذف، إعادة تسمية، تغيير الصلاحيات، الخ).</para>
      <indexterm><primary><command>scp</command></primary></indexterm>
      <indexterm><primary><command>sftp</command></primary></indexterm>

      <para>تستخدم دبيان OpenSSH، وهو نسخة حرة من SSH يشرف عليها مشروع <command>OpenBSD</command> (نظام تشغيل حر يعتمد على النواة BSD، ويركز على الأمن) مشتقة من برنامج SSH الأصلي الذي طورته شركة SSH Communication Security Corp الفنلندية. لقد طورت هذه الشركة SSH بشكل برنامج حر في البداية، لكن قررت لاحقاً متابعة تطويره تحت رخصة احتكارية. بعد ذلك أنشأ مشروع OpenBSD المشتق OpenSSH لمتابعة صيانة نسخة حرة من SSH.</para>
      <indexterm><primary>OpenSSH</primary></indexterm>

      <sidebar>
        <title><emphasis>أساسيات</emphasis> <foreignphrase>مشتق</foreignphrase></title>
        <indexterm><primary>مشتق</primary></indexterm>

	<para>”المشتق“ (fork)، في مجال البرمجيات، هو مشروع جديد يبدأ كنسخة عن مشروع سابق، وينافسه. بعد الاشتقاق، يتباعد المشروعان عادة من ناحية التطويرات الجديدة. غالباً ما يكون الاشتقاق نتيجة خلاف بين أعضاء فريق التطوير.</para>

	<para>إمكانية اشتقاق البرمجيات هذه هي نتيجة مباشرة لطبيعة البرمجيات الحرة؛ الاشتقاق حدث جيد عندما يسمح بمتابعة تطوير المشروع بشكل حر (في حال تغيير الرخصة على سبيل المثال). لكن الاشتقاق الناتج عن خلافات شخصية أو تقنية هو مضيعة للموارد البشرية غالباً؛ ويفضل حل هذه النزاعات بأسلوب آخر. لكن ليس من النادر أن يعاد دمج مشروعين انشقا عن بعضهما سابقاً.</para>
      </sidebar>

      <para>يقسم OpenSSH إلى حزمتين: قسم العميل في الحزمة <emphasis role="pkg">openssh-client</emphasis>، وقسم المخدم في الحزمة <emphasis role="pkg">openssh-server</emphasis>. تعتمد الحزمة <emphasis role="pkg">ssh</emphasis> على القسمين وتسهل تثبيتهما معاً (<command>apt install ssh</command>).</para>

      <section id="sect.ssh-key-based-auth">
        <title>المصادقة بالمفاتيح</title>

	<para>في كل مرة يسجل فيها أحد دخوله عبر SSH، يطلب المخدم البعيد كلمة سر للتحقق من هوية المستخدم. هذا قد يسبب المشاكل إذا كنت تريد أتمتة الاتصال، أو كنت تستخدم أداة تتطلب الاتصال عبرSSH كثيراً. لذلك يقدم SSH نظام المصادقة بالمفاتيح.</para>

	<para>يُولِّد المستخدم زوجاً من المفاتيح على الجهاز العميل باستخدام <command>ssh-keygen -t rsa</command>؛ يوضع المفتاح العام في <filename dir="ltr">~/.ssh/id_rsa.pub</filename>، بينما يوضع المفتاح الخاص في <filename dir="ltr">~/.ssh/id_rsa</filename> ثم يستدعي المستخدم الأمر <command>ssh-copy-id <replaceable>server</replaceable></command> لإضافة مفتاحه العام إلى <filename dir="ltr">~/.ssh/authorized_keys</filename> على المخدم. إذا لم تتم حماية المفتاح الخاص ”بعبارة مرور passphrase“ عند إنشائه، فسوف تتم جميع عمليات تسجيل الدخول اللاحقة على المخدم دون كلمة سر. وإلا يجب فك تشفير المفتاح الخاص في كل مرة بإدخال عبارة المرور. لحسن الحظ، يسمح لنا <command>ssh-agent</command> بالاحتفاظ بالمفتاح الخاص في الذاكرة دون الحاجة لإدخال كلمة السر بشكل متكرر. لتحقيق ذلك، عليك استخدام <command>ssh-add</command> ببساطة (مرة واحدة في كل جلسة عمل) شرط أن تكون جلسة العمل مرتبطة سلفاً بنسخة فعالة من <command>ssh-agent</command>. تُفعِّل دبيان <command>ssh-agent</command> افتراضياً في الجلسات الرسومية، لكن يمكن تعطيل ذلك بتحرير <filename dir="ltr">/etc/X11/Xsession.options</filename>. بالنسبة للجلسات النصية، عليك تفعيل ssh-agent يدوياً باستخدام <command dir="ltr">eval $(ssh-agent)</command>.</para>

        <sidebar>
          <title><emphasis>أمن</emphasis> حماية المفتاح الخاص</title>

	  <para>كل من يملك المفتاح الخاص يستطيع الدخول على الحسابات المُعدَّة بهذه الطريقة. لذلك تتم حماية الوصول إلى المفتاح الخاص ”بعبارة مرور“. من يحصل على نسخة من ملف المفتاح الخاص عند ذلك (مثلاً، <filename dir="ltr">~/.ssh/id_rsa</filename>) يبقى عليه معرفة هذه العبارة حتى يتمكن من استخدامه. لكن هذه الحماية الإضافية ليست منيعة، وإذا كنت تعتقد أن هذا الملف قد فُضِح، فمن الأفضل تعطيل ذلك المفتاح على الحواسيب المثبت عليها (بإزالته من ملفات <filename>authorized_keys</filename>) واستبداله بمفتاح مولد حديثاً.</para>
        </sidebar>

        <sidebar>
          <title><emphasis>ثقافة</emphasis> ثغرة OpenSSL في دبيان <emphasis role="distribution">إيتش</emphasis></title>

	  <para>لقد احتوت مكتبة OpenSSL، في النسخ الأولية في دبيان <emphasis role="distribution">إيتش</emphasis>، على مشكلة خطيرة في مولد الأرقام العشوائية (RNG). بالفعل، لقد عدل المشرف على الحزمة في مشروع دبيان عليها بحيث لا تصدر التطبيقات التي تعتمد عليها إنذارات عند تحليلها بأدوات فحص الذاكرة مثل <command>valgrind</command>. لسوء الحظ، أدى هذا التعديل إلى استخدام مولد الأرقام العشوائية مصدراً واحداً للمعلومات (entropy source) هو رقم العملية (PID) الذي لا تعطي احتمالات قيمه القليلة (32,000 احتمال) عشوائية كافية. <ulink type="block" url="http://www.debian.org/security/2008/dsa-1571" /></para>

	  <para>بالأخص، كلما استُخدِمَت OpenSSL لتوليد مفتاح، كانت تولد دوماً مفتاحاً ينتمي لمجموعة معروفة من بضعة مئات آلاف المفاتيح (32,000 مضروبة بعدد صغير من أطوال المفاتيح). أثر هذا على مفاتيح SSH، ومفاتيح SSL، وشهادات X.509 التي تستخدمها العديد من التطبيقات، مثل OpenVPN. كان كل ما يحتاجه المخترق هو تجربة جميع المفاتيح حتى يتمكن من الدخول غير المصرح به. لتخفيف ضرر المشكلة، تم تعديل خدمة SSH بحيث ترفض المفاتيح المشكوك بها المذكورة في الحزمتين <emphasis role="pkg">openssh-blacklist</emphasis> و<emphasis role="pkg">openssh-blacklist-extra</emphasis>. بالإضافة لذلك، يسمح الأمر <command>ssh-vulnkey</command> بالتعرف على المفاتيح في النظام التي يحتمل أنها مفضوحة.</para>

	  <para>بيّنت التحليلات الأكثر تعمقاً أن هذه الحادثة كانت نتيجة عدة مشاكل (صغيرة)، جزء منها يقع على عاتق مشروع OpenSSH، والجزء الآخر على عاتق مشرف الحزمة في مشروع دبيان. يجب ألا تولد مكتبة منتشرة الاستخدام مثل OpenSSL أية إنذارات –وبدون أي تعديل عليها– عند فحصها باستخدام <command>valgrind</command>. بالإضافة لذلك، يجب إضافة تعليقات أفضل على الكود (خصوصاً الأجزاء الحساسة مثل RNG) لمنع حدوث هكذا أخطاء. أما من جهة مشروع دبيان، فقد أراد مشرف الحزمة إقرار مطوري OpenSSL على التعديلات، لكنه اكتفى بشرح التعديلات دون تقديم الترقيع لهم حتى يراجعوه ولم يصرح عن دوره في مشروع دبيان. أخيراً، كان أسلوب العمل غير مناسب، فالتعديلات التي أجريت على الكود الأصلي لم توثق بوضوح؛ ومع أن جميع التعديلات مخزنة فعلياً في مستودع Subversion، إلا أنها انتهت مجتمعة مع بعضها في رقعة واحدة أثناء إنشاء الحزمة المصدرية.</para>

	  <para>من الصعب في ظل ظروف كهذه إيجاد الإجراءات الإصلاحية التي تمنع مثل هذه الحوادث من التكرار. الدرس الذي تعلمناه من هذه الحادثة هو أن كل تعديل تجريه دبيان على البرمجيات يجب أن يكون مبرراً، وموثقاً، وأن يرسل إلى المشروع المنبعي ما دام ذلك ممكناً، وأن ينشر علناً على نطاق واسع. ونتيجة لهذه الرؤية تم تطوير صيغة جديدة للحزم المصدرية (”‎3.0 (quilt)‎“) بالإضافة إلى خدمة Debian sources.‏ <ulink type="block" url="http://sources.debian.net" /></para>
        </sidebar>
      </section>
      <section id="sect.ssh-x11">
        <title>استخدام تطبيقات X11 عن بعد</title>

	<para>يسمح بروتوكول SSH بتوجيه البيانات الرسومية (جلسات ”X11“، نسبةً لاسم النظام الرسومي الأكثر انتشاراً في يونكس)؛ يحافظ المخدم عند ذلك على قناة مخصصة لهذه البيانات. على وجه الخصوص، يمكن عرض برنامج رسومي يُنَفَّذ عن بعد على مخدم X.org على الشاشة المحلية، وسوف تُؤمَّن الجلسة بالكامل (الدخل والعرض). هذه الميزة معطلة افتراضياً لأنها تسمح للتطبيقات البعيدة بالتداخل مع النظام المحلي. يمكنك تفعليها بتحديد <literal>X11Forwarding yes</literal> في ملف ضبط المخدم (<filename dir="ltr">/etc/ssh/sshd_config</filename>). أخيراً، يجب أن يطلبها المستخدم أيضاً بإضافة الخيار <literal dir="ltr">-X</literal> إلى الأمر <command>ssh</command>.</para>
      </section>
      <section id="sect.ssh-port-forwarding">
        <title>إنشاء الأنفاق المشفرة باستخدام توجيه المنافذ</title>
        <indexterm><primary>توجيه المنافذ</primary></indexterm>

	<para>يسمح الخياران <literal dir="ltr">-R</literal> و<literal dir="ltr">-L</literal> للأمر <command>ssh</command> بإنشاء ”أنفاق مشفرة“ بين جهازين، باستخدام التوجيه الآمن لمنفذ TCP محلي (انظر الملاحظة الجانبية <xref linkend="sidebar.tcp-udp" />) إلى جهاز بعيد أو العكس.</para>

        <sidebar>
          <title><emphasis>مصطلحات</emphasis> نفق</title>
          <indexterm><primary>نفق (SSH)</primary><seealso>VPN</seealso></indexterm>
          <indexterm><primary>SSH (نفق)</primary><seealso>VPN</seealso></indexterm>

	  <para>تعمل شبكة الإنترنت، ومعظم الشبكات المحلية المتصلة بها، في وضع الرزم (packet mode) وليس وضع الاتصال (connected mode)، وهذا يعني أن الرزمة التي تنطلق من حاسوب إلى آخر سوف تتوقف عند العديد من الموجهات الوسيطة حتى تعثر على الطريق إلى وجهتها. لا تزال محاكاة وضع العمل المتصل ممكنة حيث يُغلَّف تيار المعلومات (stream) في رزم IP عادية. تتبع هذه الرزم طريقها المعتاد، لكن يعاد بناء التيار كما هو عند الوجهة. يدعى هذا ”بالنفق“، مثل نفق السيارات حيث تسير فيه المركبات مباشرة من المدخل (input) إلى المخرج (output) دون المرور بأي تقاطعات، بخلاف الطرقات على سطح الأرض التي تحوي العديد من التقاطعات وتغييرات الاتجاه.</para>

	  <para>يمكنك الاستفادة من هذه الفرصة لتشفير النفق: عندئذ لن يمكن التعرف على التيار الذي يجري عبره من الخارج، لكن يعاد التيار إلى الشكل غير المشفر عند الخروج من النفق.</para>
        </sidebar>

	<para>ينشئ الأمر <command>ssh -L 8000:server:25 intermediary</command> جلسة SSH مع المضيف <replaceable>intermediary</replaceable> وينصت للمنفذ المحلي 8000 (انظر <xref linkend="figure.ssh-L" />). في كل مرة ينشأ فيها اتصالاً مع هذا المنفذ، سيفتح <command>ssh</command> اتصالاً من الحاسوب <replaceable>intermediary</replaceable> إلى المنفذ 25 على <replaceable>server</replaceable>، وسيربط الاتصالين معاً.</para>

	<para>أما الأمر <command>ssh -R 8000:server:25 intermediary</command> فهو ينشئ جلسة SSH أيضاً مع الحاسوب <replaceable>intermediary</replaceable>، لكن سوف ينصت <command>ssh</command> للمنفذ 8000 على ذلك الجهاز (انظر <xref linkend="figure.ssh-R" />). أي اتصال يرد إلى إلى هذا المنفذ سيجعل <command>ssh</command> يفتح اتصالاً من الجهاز المحلي إلى المنفذ 25 على <replaceable>server</replaceable>، ويربط الاتصالين معاً.</para>

	<para>في كلا الحالتين، يكون الاتصال مع المنفذ 25 على المضيف <replaceable>server</replaceable>، بعد أن يمر خلال نفق SSH الواصل بين الجهاز المحلي والجهاز <replaceable>intermediary</replaceable>. في الحالة الأولى، مدخل النفق هو المنفذ المحلي 8000، وتتحرك البيانات باتجاه الجهاز <replaceable>intermediary</replaceable> قبل أن تتوجه إلى <replaceable>server</replaceable> عبر الشبكة ”العامة“. أما في الحالة الثانية، فقد تبدل موقعي الدخل والخرج في النفق؛ فقد أصبح المدخل هو المنفذ 8000 على الجهاز <replaceable>intermediary</replaceable>، أما المخرج فهو على الجهاز المحلي، الذي يوجه البيانات بعدها إلى <replaceable>server</replaceable>. عملياً، إما أن يكون server هو الجهاز المحلي أو الجهاز الوسيط. في تلك الحالة سيحمي SSH الاتصال بين الطرفين.</para>

        <figure id="figure.ssh-L">
          <title>توجيه منفذ محلي باستخدام SSH</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ssh-L.png" width="35%" />
            </imageobject>
          </mediaobject>
        </figure>

        <figure id="figure.ssh-R">
          <title>توجيه منفذ بعيد باستخدام SSH</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ssh-R.png" width="35%" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>
    <section id="sect.remote-desktops">
      <title>استخدام سطوح المكتب الرسومية البعيدة</title>

      <para>تسمح VNC ‏(Virtual Network Computing – حوسبة الشبكات الظاهرية) بالوصول البعيد لسطوح المكتب الرسومية.</para>
      <indexterm><primary>VNC</primary></indexterm>
      <indexterm><primary>Virtual Network Computing</primary></indexterm>
      <indexterm><primary>سطح مكتب رسومي</primary><secondary>بعيد</secondary></indexterm>
      <indexterm><primary>بعيد (سطح مكتب رسومي)‏</primary></indexterm>
      <indexterm><primary>رسومي، سطح مكتب رسومي بعيد</primary></indexterm>

      <para>أكثر ما تستخدم هذه الأداة في الدعم الفني؛ حيث يرى مدير النظام الأخطاء التي يواجهها المستخدمون، ويبين لهم الطريق الصحيح لمعالجتها دون الاضطرار للوقوف جانبهم.</para>
      <indexterm><primary><emphasis role="pkg">vino</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">krfb</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">x11vnc</emphasis></primary></indexterm>

      <para>لكن أولاً، يجب أن يسمح المستخدم بمشاركة جلسة العمل. يمكن تقعيل هذا الخيار في بيئة سطح المكتب GNOME في <emphasis role="distribution">جيسي</emphasis> من لوحة التحكم (بخلاف الإصدارات السابقة من دبيان، حيث كان المستخدم يحتاج لتثبيت وتشغيل البرنامج <command>vino</command>). لا تزال بيئة KDE تحتاج <command>krfb</command>، للسماح بمشاركة جلسة العمل الحالية عبر VNC. أما بالنسبة لسطوح المكتب الرسومية الأخرى، يقدم الأمر <command>x11vnc</command> (من الحزمة ذات الاسم نفسه) الوظيفة ذاتها؛ يمكنك توفيره للمستخدم باستخدام أيقونة واضحة.</para>

      <indexterm><primary><emphasis role="pkg">vinagre</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">tsclient</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">krdc</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">xvnc4viewer</emphasis></primary></indexterm>

      <para>عندما يوفر VNC الجلسة الرسومية، على مدير النظام أن يتصل بها باستخدام عميل VNC. في GNOME هناك <command>vinagre</command> و<command>remmina</command> لهذا الغرض، بينما KDE تحوي <command>krdc</command> (في القائمة <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). هناك عملاء VNC غير هذه تعتمد على الواجهة النصية، مثل <command>xvnc4viewer</command> في الحزمة الدبيانية ذات الاسم نفسه. بعد الاتصال، يستطيع مدير النظام أن يرى ما يجري، وأن يعمل على الجهاز المتصل به عن بعد، وأن يظهر للمستخدم كيف يتابع.</para>

      <sidebar>
        <title><emphasis>أمن</emphasis> VNC عبر SSH</title>
        <indexterm><primary>نفق SSH</primary><secondary>VNC</secondary></indexterm>

	<para>إذا أردت الاتصال عبر VNC، ولم تكن تريد أن ترسل بياناتك عبر الشبكة بدون تشفير، يمكنك تغليف البيانات المرسلة في نفق SSH (انظر <xref linkend="sect.ssh-port-forwarding" />). عليك فقط أن تعرف أن VNC يستخدم المنفذ 5900 افتراضياً للشاشة الأولى (التي تدعى ”localhost:0“)، و 5901 للشاشة الثانية (وتدعى ”localhost:1“)، الخ.</para>

	<para>ينشئ الأمر <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command> نفقاً بين المنفذ المحلي 5901 في الواجهة الشبكية المحلية والمنفذ 5900 على المستضيف <replaceable>machine</replaceable>. كلمة ”localhost“ الأولى تقيّد SSH حتى ينصت فقط إلى تلك الواجهة على الجهاز المحلي. أما كلمة ”localhost“ الثانية فهي تشير إلى الواجهة على الجهاز البعيد التي ستستقبل بيانات الشبكة الداخلة إلى ”localhost:5901“. وهكذا سوف يصل الأمر <command>vncviewer localhost:1</command> عميل VNC مع الشاشة البعيدة، رغم أن الأمر يشير إلى اسم الجهاز المحلي.</para>

	<para>لا تنسَ إغلاق النفق عند إغلاق جلسة VNC، عبر الخروج من جلسة SSH المفتوحة من هذا الطرف.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>أساسيات</emphasis> مدير العرض</title>
        <indexterm><primary><command>gdm3</command></primary></indexterm>
        <indexterm><primary><command>kdm</command></primary></indexterm>
        <indexterm><primary><command>xdm</command></primary></indexterm>
        <indexterm><primary><command>lightdm</command></primary></indexterm>
        <indexterm><primary>مدير</primary><secondary>مدير عرض</secondary></indexterm>
        <indexterm><primary>برنامج إدارة العرض</primary></indexterm>

	<para><command>gdm3</command>، ‏<command>kdm</command>، ‏<command>lightdm</command>، و<command>xdm</command> كلها برامج إدارة عرض (Display Managers). تتولى هذه البرامج التحكم بالواجهة الرسومية بُعَيْد تهيئتها حتى تَعرُضَ للمستخدم شاشة تسجيل الدخول. بعدما يسجل المستخدم دخوله، ينفذ مدير العرض البرامج المطلوبة لبدء جلسة العمل الرسومية.</para>
      </sidebar>

      <para>يخدم VNC المستخدمين المتنقلين، أو مديري الشركات، الذين يحتاجون أحياناً الدخول من منزلهم إلى سطح مكتب بعيد يشبه الذي يستخدمونه في العمل. إعداد مثل هذه الخدمة أعقد: عليك أولاً تثبيت الحزمة <emphasis role="pkg">vnc4server</emphasis>، وتعديل إعدادات مدير العرض حتى يقبل طلبات <literal>XDMCP Query</literal> (بالنسبة للمدير <command>gdm3</command>، يمكن تنفيذ هذا من خلال إضافة <literal>Enable=true</literal> في قسم ”xdmcp“ من الملف <filename dir="ltr">/etc/gdm3/daemon.conf</filename>)، وأخيراً، تشغيل مخدم VNC باستخدام <command>inetd</command> بحيث يتم تشغيل جلسة عمل تلقائياً عندما يحاول المستخدم تسجيل الدخول. مثلاً، يمكنك إضافة السطر التالي إلى <filename dir="ltr">/etc/inetd.conf</filename>:</para>

      <programlisting>5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none
</programlisting>

      <para>إعادة توجيه الاتصالات الواردة إلى مدير العرض تحل مشكلة المصادقة، لأن المستخدمين الذين يملكون حسابات محلية هم فقط من سيمر عبر شاشة دخول <command>gdm3</command> (أو مكافئه <command>kdm</command>، أو <command>xdm</command>، الخ). بما أن هذه العملية تسمح بتسجيل دخول عدة مستخدمين في الوقت نفسه دون أي مشاكل (شرط أن يكون المخدم قوياً بما يكفي)، فمن الممكن استخدامها أيضاً لتوفير سطوح مكتب كاملة للمستخدمين الجوالين (أو لنظم سطح المكتب الأضعف، المستخدمة بشكل thin clients). يسجل المستخدمون دخولهم ببساطة إلى شاشة المخدم باستخدام <command>vncviewer <replaceable>server</replaceable>:50</command>، لأن المنفذ المستخدم هو 5950.</para>
      <indexterm><primary><emphasis role="pkg">vnc4server</emphasis></primary></indexterm>
    </section>
  </section>
  <section id="sect.rights-management">
    <title>إدارة الصلاحيات</title>

    <para>لينكس هو نظام متعدد المستخدمين قطعاً، ولذلك يجب توفير نظام إدارة صلاحيات للتحكم بالعمليات المسموحة على الملفات والمجلدات، التي تشمل جميع موارد وأجهزة النظام (في نظام يونكس، كل جهاز يمثل بملف أو مجلد). هذا المبدأ مشترك بين جميع نظم يونكس، لكن التذكرة بالشيء مفيدة دوماً، خصوصاً أن هناك بعض الاستخدامات المتقدمة المهمة ولكن غير معروفة نسبياً.</para>
    <indexterm><primary>حقوق</primary></indexterm>
    <indexterm><primary>صلاحيات</primary></indexterm>
    <indexterm><primary>مستخدم</primary><secondary>مالك</secondary></indexterm>
    <indexterm><primary>مجموعة</primary><secondary>مالكة</secondary></indexterm>
    <indexterm><primary>مالك</primary><secondary>مستخدم</secondary></indexterm>
    <indexterm><primary>مالك</primary><secondary>مجموعة</secondary></indexterm>

    <para>كل ملف أو مجلد له صلاحيات خاصة لكل فئة من الفئات الثلاث للمستخدمين:</para>
    <itemizedlist>
      <listitem>
	<para>المالك (يرمز له بالحرف <literal>u</literal> من كلمة ”user“)؛</para>
      </listitem>
      <listitem>
	<para>المجموعة المالكة (يرمز لها بالحرف <literal>g</literal> من كلمة ”group“)، وهي تمثل جميع أعضاء المجموعة؛</para>
      </listitem>
      <listitem>
	<para>الآخرون (يرمز لهم بالحرف <literal>o</literal> من كلمة ”other“).</para>
      </listitem>
    </itemizedlist>

    <para>هناك ثلاثة أنواع من الصلاحيات يمكن جمعها:</para>
    <itemizedlist>
      <listitem>
	<para>القراءة (يرمز لها بالحرف <literal>r</literal> من كلمة ”read“)؛</para>
      </listitem>
      <listitem>
	<para>الكتابة (يرمز لها بالحرف <literal>w</literal> من كلمة ”write“)؛</para>
      </listitem>
      <listitem>
	<para>التنفيذ (يرمز له بالحرف <literal>x</literal> من كلمة ”eXecute“).</para>
      </listitem>
    </itemizedlist>
    <indexterm><primary>قراءة، صلاحية</primary></indexterm>
    <indexterm><primary>كتابة، صلاحية</primary></indexterm>
    <indexterm><primary>تعديل، صلاحية</primary></indexterm>
    <indexterm><primary>تنفيذ، صلاحية</primary></indexterm>

    <para>بالنسبة للملفات، فيمكن فهم هذه الصلاحيات بسهولة: تسمح صلاحية القراءة بقراءة المحتوى (ونسخه أيضاً)، وتسمح صلاحية الكتابة بتعديله، أما صلاحية التنفيذ فتسمح لك بتشغيله (وهذا سيعمل فقط إذا كان برنامجاً).</para>

    <sidebar>
      <title><emphasis>أمن</emphasis> الملفات التنفيذية ذات صلاحيات <literal>setuid</literal> و<literal>setgid</literal></title>

      <para>هناك صلاحيتين محددتين ترتبطان بالملفات التنفيذية: <literal>setuid</literal> و<literal>setgid</literal> (يرمز لهما بالحرف ”s“). لاحظ أننا نتحدث عادة عن ”بت“، لأنه يمكن تمثيل كل من هذه القيم البوليانية ببت واحد. تسمح هاتان الصلاحيتان للمستخدم بتنفيذ البرنامج بصلاحيات مالكه أو صلاحيات مجموعته. تتيح هذه الآلية إمكانية الوصول إلى مزايا تحتاج صلاحيات ذات مستوى أعلى من المستوى العادي للمستخدم.</para>
      <indexterm><primary><literal>setuid</literal>، صلاحية</primary></indexterm>
      <indexterm><primary><literal>setgid</literal>، صلاحية</primary></indexterm>

      <para>بما أن برامج الجذر التي تتمتع بصلاحية <literal>setuid</literal> ستعمل تلقائياً تحت صلاحيات مدير النظام، فمن المهم جداً ضمان أن هذه البرامج آمنة وموثوقة. فالمستخدم الذي قد يتمكن من السيطرة على أحد هذه البرامج وجعله يستدعي أمراً من اختياره يستطيع عندها انتحال شخصية المستخدم الجذر وامتلاك جميع الصلاحيات على النظام.</para>
    </sidebar>

    <para>أما المجلدات فالتعامل معها مختلف. تمنح صلاحية القراءة إمكانية الاستعلام عن محتويات المجلد (من ملفات ومجلدات)، أما صلاحية الكتابة فتسمح بإنشاء الملفات فيه أو حذفها، وصلاحية التنفيذ تسمح بالمرور عبره (خصوصاً الدخول إليه بالأمر <command>cd</command>). إن امتلاك حق العبور خلال المجلد دون امتلاك حق قراءته يسمح لك بالوصول إلى الملفات أو المجلدات داخله التي تعرفها بالاسم، لكن لا يسمح لك بالبحث عنها إذا لم تكن تعرف بوجودها أو لم تعرف اسمها بالضبط.</para>

    <sidebar id="sidebar.setgid-dir">
      <title><emphasis>أمن</emphasis> مجلدات <literal>setgid</literal> و ”<emphasis>البت اللاصق</emphasis>“</title>
      <indexterm><primary><literal>setgid</literal> في المجلدات</primary></indexterm>

      <para>يطبّق بت <literal>setgid</literal> على المجلدات أيضاً. أي عنصر جديد ينشأ في هذه المجلدات تُعيَّن له المجموعة المالكة للمجلد الأب، بدلاً من وراثة المجموعة الرئيسية للمستخدم الذي أنشأ الملف كما هي العادة. هذا الوضع يسمح للمستخدم بتفادي تغيير مجموعته الرئيسية (باستخدام الأمر <command>newgrp</command>) عندما يعمل في شجرة ملفات مشتركة بين عدة مستخدمين ينتمون لنفس المجموعة الخاصة.</para>
      <indexterm><primary>بت لاصق</primary></indexterm>

      <para>أما البت ”اللاصق“ (<emphasis>sticky bit</emphasis> – يرمز له بالحرف ”t“) فهي صلاحية تفيد فقط مع المجلدات. تستخدم هذه الصلاحية خصوصاً مع المجلدات المؤقتة التي يملك الجميع صلاحية الكتابة عليها (مثل المجلد <filename>/tmp/</filename>): تقيّد هذه الصلاحية حذف الملفات بحيث يسمح لمالك الملف (أو مالك المجلد الأب) حذفه فقط. بدون هذا القيد، سوف يتمكن أي شخص من حذف ملفات المستخدمين الآخرين في المجلد <filename>/tmp/</filename>.</para>
    </sidebar>

    <para>تتحكم ثلاثة أوامر بصلاحيات الملفات:</para>
    <itemizedlist>
      <listitem>
	<para><command>chown <replaceable>user</replaceable> <replaceable>file</replaceable></command> يغير مالك الملف؛</para>
      </listitem>
      <listitem>
	<para><command>chgrp <replaceable>group</replaceable> <replaceable>file</replaceable></command> يغير المجموعة المالكة؛</para>
      </listitem>
      <listitem>
	<para><command>chmod <replaceable>rights</replaceable> <replaceable>file</replaceable></command> يغير صلاحيات الملف.</para>
      </listitem>
    </itemizedlist>

    <para>هناك طريقتين لتمثيل الصلاحيات. لعل التمثيل الرمزي هو الأبسط فهماً والأسهل تذكراً بينهما. تستخدم الحروف الرمزية المذكورة سابقاً في هذا التمثيل. يمكنك تعريف صلاحيات كل فئة من المستخدمين (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>) إما بتحديدها صراحة (باستخدام <literal>=</literal>) أو بالإضافة (<literal>+</literal>) أو الطرح (<literal>-</literal>). بالتالي ستمنح العلاقة <literal>u=rwx,g+rw,o-r</literal> مالك الملف صلاحيات القراءة والكتابة والتنفيذ، وتضيف صلاحيتي القراءة والكتابة للمجموعة المالكة، وتزيل صلاحية القراءة من المستخدمين الآخرين. تبقى الصلاحيات الأخرى التي لا تعدل بالإضافة أو الطرح في مثل هذه الأوامر كما هي. يغطي الحرف <literal>a</literal>، من الكلمة ”all“، فئات المستخدمين الثلاث، بالتالي تمنح العلاقة <literal>a=rx</literal> جميع الفئات الثلاث الصلاحيات نفسها (القراءة والتنفيذ، لكن دون الكتابة).</para>
    <indexterm><primary><command>chmod</command></primary></indexterm>
    <indexterm><primary><command>chown</command></primary></indexterm>
    <indexterm><primary><command>chgrp</command></primary></indexterm>
    <indexterm><primary>تمثيل الصلاحيات بالتدوين الثماني</primary></indexterm>
    <indexterm><primary>صلاحيات</primary><secondary>التمثيل الثماني</secondary></indexterm>

    <para>يربط التمثيل العددي (الثُماني) كل صلاحية مع رقم: 4 للقراءة، و2 للكتابة، و1 للتنفيذ. تُحدَّد كل مجموعة من الصلاحيات بمجموع الأرقام المقابلة لها. ثم تُسنَد كل قيمة لفئة مختلفة من المستخدمين بوضع هذه المجاميع جنباً إلى جنب بنفس الترتيب المعتاد لفئات المستخدمين (المالك، ثم المجموعة، ثم الآخرون).</para>

    <para>على سبيل المثال، سوف يعطي الأمر <command>chmod 754 <replaceable>file</replaceable></command> الصلاحيات التالية: القراءة والكتابة والتنفيذ للمالك (بما أن 7 = 4 + 2 +1)؛ القراءة والتنفيذ للمجموعة (بما أن 5 = 4 + 1)؛ والقراءة فقط للآخرين. الرقم <literal>0</literal> يعني عدم وجود صلاحيات؛ بالتالي يسمح الأمر <command>chmod 600 <replaceable>file</replaceable></command> للمالك بالقراءة والكتابة، ولا يمنح أي صلاحيات لأي شخص آخر. أكثر مجموعات الصلاحيات انتشاراً هي <literal>755</literal> للملفات التنفيذية والمجلدات، و <literal>644</literal> لملفات البيانات.</para>

    <para>لتمثيل الصلاحيات الخاصة، يمكنك إضافة خانة رابعة قبل هذا العدد وفقاً لنفس المبدأ، حيث يقابل بت <literal>setuid</literal> القيمة 4، وبت <literal>setgid</literal> القيمة 2، أما البت اللاصق (<literal>sticky</literal>) فيقابل 1. وبذلك سيضيف الأمر <command>chmod 4754</command> خانة <literal>setuid</literal> إلى الصلاحيات المذكورة آنفاً.</para>

    <para>لاحظ أن استخدام التدوين الثماني لا يسمح إلا بضبط كافة صلاحيات الملف دفعة واحدة؛ فلا يمكنك استخدامه لإضافة صلاحية جديدة فقط، مثل صلاحية القراءة للمجموعة المالكة، لأنه يجب أن تأخذ الصلاحيات السابقة بعين الاعتبار وتحسب القيمة العددية الجديدة الموافقة.</para>

    <sidebar>
      <title><emphasis>تلميح</emphasis> التطبيق التعاودي</title>

      <para>نضطر أحياناً لتغيير الصلاحيات لشجرة ملفات كاملة. كل الأوامر السابقة لها خيار <literal dir="ltr">-R</literal> حتى تعمل تعاودياً على المجلدات الفرعية.</para>

      <para>إن الاختلاف بين الملفات والمجلدات يسبب المشاكل أحياناً مع العمليات التعاودية. لهذا أضيف الحرف ”X“ إلى التمثيل الرمزي للصلاحيات. يمثل هذا الحرف صلاحية التنفيذ التي تطبق على المجلدات فقط (وليس الملفات التي تفتقر إلى هذه الصلاحية من قبل). بالتالي، سيضيف الأمر <command>chmod -R a+X <replaceable>directory</replaceable></command> صلاحية التنفيذ لجميع فئات المستخدمين (<literal>a</literal>)، فقط للمجلدات الفرعية وللملفات التي تملك إحدى فئات المستخدمين على الأقل (حتى ولو كان مالكها وحده) صلاحية تنفيذها من قبل.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>تلميح</emphasis> تغيير المستخدم والمجموعة</title>

      <para>قد ترغب أحياناً بتغيير مجموعة الملف في نفس الوقت الذي تغير فيه مالكه. هناك صيغة خاصة للأمر <command>chown</command> لهذا الغرض: <command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command></para>
    </sidebar>

    <sidebar>
      <title><emphasis>التعمق أكثر</emphasis> <command>umask</command></title>

      <para>عندما ينشئ أحد التطبيقات ملفاً، يخصص له صلاحيات دلالية، مع معرفة أن نظام الملفات يزيل بعض الصلاحيات تلقائياً، وهي الصلاحيات المحددة بالأمر <command>umask</command>. أدخِل <command>umask</command> في الصدفة؛ سترى قناعاً مثل <computeroutput>0022</computeroutput>. هذا القناع هو ببساطة تمثيل ثماني للصلاحيات التي ستزال آلياً (في هذا المثال، صلاحية الكتابة للمجموعة وللمستخدمين الآخرين).</para>
      <indexterm><primary>umask</primary></indexterm>
      <indexterm><primary>صلاحيات</primary><secondary>قناع</secondary></indexterm>
      <indexterm><primary>قناع</primary><secondary>قناع الصلاحيات</secondary></indexterm>

      <para>إذا أعطيت الأمر <command>umask</command> قيمة ثمانية جديدة، فسوف يعدل القناع. وإذا استخدمته في ملف تهيئة الصدفة (مثلاً، <filename dir="ltr">~/.bash_profile</filename>)، فسوف يعدل عملياً القناع الافتراضي لجميع جلسات العمل.</para>
    </sidebar>
  </section>
  <section id="sect.administration-interfaces">
    <title>واجهات الإدارة</title>
    <indexterm><primary>واجهة</primary><secondary>واجهات إدارة</secondary></indexterm>
    <indexterm><primary>إدارة، واجهات إدارة</primary></indexterm>

    <para>يفيد استخدام الواجهات الرسومية لإدارة النظام في حالات متنوعة. لا يشترط أن يعرف مدير النظام جميع تفاصيل الإعداد لجميع الخدمات التي يديرها، ولا يملك دائماً الوقت الكافي للبحث عن وثائق الموضوع. تستطيع إذن واجهات الإدارة الرسومية تسريع إطلاق خدمة جديدة. كما يمكنها أيضاً أن تبسط ضبط الخدمات صعبة الإعداد.</para>

    <para>هذه الواجهات مساعدة فقط، وليست نهاية في حد ذاتها. في جميع الحالات، على مدير النظام أن يدرس سلوكها بشكل كامل حتى يفهم أي مشكلة محتملة ويتفاداها.</para>

    <para>بما أنه لا توجد واجهة إدارة مثالية، فقد تميل إلى تجربة عدة حلول. عليك تفادي هذا قدر المستطاع، لأن الأدوات المختلفة لا تتوافق أساليب عملها أحياناً. حتى لو كانت كلها تسعى لأن تكون مرنة جداً وتحاول تبني مرجعية واحدة في التعامل مع ملفات الإعداد، إلا أنها لا تنجح دائماً في توحيد التعديلات الخارجية.</para>
    <section id="sect.webmin">
      <title>الإدارة على واجهة وب: <command>webmin</command></title>
      <indexterm><primary><emphasis>webmin</emphasis></primary></indexterm>

      <para>هذه –بلا شك– إحدى أنجح واجهات الإدارة. هي عبارة عن نظام تجزيئي يدار من خلال متصفح وب، يغطي طيفاً واسعاً من المجالات والأدوات. بالإضافة لذلك، هذه الواجهة مُدوَّلة (internationalized) ومتوفرة في العديد من اللغات.</para>

      <para>للأسف، لم تعد <command>webmin</command> جزءاً من دبيان. لقد أزال مشرفها –Jaldhar H. Vyas– الحزم التي أنشأها لأنه لم يعد لديه الوقت اللازم لإبقائها في مستوى جودة مقبول. لم يتولى أحد آخر العمل عليها رسمياً، لذلك لا تحوي <emphasis role="distribution">جيسي</emphasis> حزمة <command>webmin</command>.</para>

      <para>هناك، على أي حال، حزمة غير رسمية متوفرة على الموقع <literal>webmin.com</literal>. هذه الحزمة أحادية، بخلاف حزمة دبيان الأصلية؛ أي أن جميع وحدات الضبط فيها سوف تُثَـبَّت وتُفَعَّل افتراضياً، حتى لو كانت الخدمة الموافقة لها غير مثبتة على الجهاز.</para>

      <sidebar>
        <title><emphasis>أمن</emphasis> تغيير كلمة سر الجذر</title>

	<para>عند تسجيل الدخول أول مرة، يتم الدخول باسم المستخدم root وكلمة سره العادية. يُفضَّل تغيير كلمة السر المستخدمة في <command>webmin</command> بأسرع ما يمكن، حتى إذا اكتُشِفَت الكلمة، لم تتأثر كلمة سر حساب الجذر للمخدم، ولو أن هذه الكلمة تعطي صلاحيات إدارية على الجهاز.</para>

	<para>كن حذراً! بما أن <command>webmin</command> لها مزايا كثيرة جداً، يستطيع المستخدم الخبيث الذي يصل إليها أن يهدد أمان النظام كله. عموماً، لا ينصح باستخدام هذا النوع من الواجهات على النظم المهمة ذات القيود الأمنية الشديدة (الجدران النارية، المخدمات الحساسة، الخ).</para>
      </sidebar>

      <para>يُستخدَم Webmin عبر واجهة وب، لكنه لا يحتاج تثبيت أباتشي. أساساً، هذا البرنامج فيه مخدم وب صغير مدمج خاص به. ينصت هذا المخدم افتراضياً للمنفذ 10000 ويقبل اتصالات HTTP المؤمنة.</para>

      <para>تغطي الوحدات المضمنة طيفاً واسعاً من الخدمات، منها:</para>
      <itemizedlist>
        <listitem>
	  <para>جميع الخدمات الأساسية: إنشاء المستخدمين والمجموعات، إدارة ملفات <filename>crontab</filename>، سكربتات التهيئة، عرض السجلات، الخ.</para>
        </listitem>
        <listitem>
	  <para>bind: إعدادات مخدم DNS (خدمة الأسماء)؛</para>
        </listitem>
        <listitem>
	  <para>postfix: إعدادات مخدم SMTP (البريد الإلكتروني)؛</para>
        </listitem>
        <listitem>
	  <para>inetd: إعدادات المخدم الفائق <command>inetd</command>؛</para>
        </listitem>
        <listitem>
	  <para>quota: إدارة الحصص التخزينية للمستخدمين؛</para>
        </listitem>
        <listitem>
	  <para>dhcpd: إعدادات مخدم DHCP؛</para>
        </listitem>
        <listitem>
	  <para>proftpd: إعدادات مخدم FTP؛</para>
        </listitem>
        <listitem>
	  <para>samba: إعدادات مخدم الملفات Samba؛</para>
        </listitem>
        <listitem>
	  <para>software: تثبيت البرمجيات من حزم دبيان أو إزالتها وتحديث النظام.</para>
        </listitem>
      </itemizedlist>

      <para>تتوفر واجهة الإدارة من متصفح الوب على العنوان <literal>https://localhost:10000</literal>. لكن احذر! ليست جميع الوحدات جاهزة للاستخدام مباشرة. أحياناً يجب ضبطها عبر تحديد مواقع ملفات الإعداد الموافقة وبعض الملفات التنفيذية (البرامج). غالباً سوف ينبهك النظام بأدب عندما يفشل في تفعيل الوحدة المطلوبة.</para>

      <sidebar>
        <title><emphasis>بدائل</emphasis> مركز تحكم GNOME</title>
        <indexterm><primary><emphasis role="pkg">gnome-control-center</emphasis></primary></indexterm>

	<para>يقدم مشروع GNOME أيضاً عدة واجهات إدارة يمكن الوصول إليها عادة عبر مدخلة ”Settings“ من قائمة المستخدم في الزاوية اليمنى العليا. البرنامج <command>gnome-control-center</command> هو البرنامج الرئيسي الذي يجمع هذه الواجهات معاً لكن معظم أدوات الضبط التي تعمل على مستوى النظام متوفرة فعلياً في حزم أخرى (<emphasis role="pkg">accountsservice</emphasis>،‏ <emphasis role="pkg">system-config-printer</emphasis>، الخ). مع أن هذه البرامج سهلة الاستخدام، لكنها لا تغطي إلا عدداً محدوداً من الخدمات الأساسية: إدارة المستخدمين، ضبط الوقت، إعداد الشبكة، إعداد الطابعات، الخ.</para>
      </sidebar>
    </section>
    <section id="sect.debconf">
      <title>ضبط الحزم: <command>debconf</command></title>
      <indexterm><primary><command>debconf</command></primary></indexterm>
      <indexterm><primary><command>dpkg-reconfigure</command></primary></indexterm>

      <para>تُضبَطُ العديد من الحزم آلياً بعد طرح بضعة أسئلة أثناء التثبيت من خلال الأداة Debconf. يمكن إعادة ضبط هذه الحزم باستدعاء <command>dpkg-reconfigure <replaceable>package</replaceable></command>.</para>

      <para>في معظم الحالات، هذه الإعدادات بسيطة جداً؛ حيث تُعَدَّل فقط بضعة متغيرات مهمة في ملفات الإعداد. غالباً ما تجمع هذه المتغيرات بين سطري ”تمييز – demarcation“ بحيث لا تؤثر عملية إعادة ضبط الحزمة إلا على هذه المنطقة المحدودة. في حالات أخرى، إعادة الضبط لن تغير أي شيء إذا اكتشف السكربت تعديلات يدوية على ملف الإعداد، وذلك للحفاظ على هذه التدخلات البشرية (لأن السكربت لا يستطيع ضمان أن تعديلاته لن تضر بالإعدادات السابقة).</para>

      <sidebar>
        <title><emphasis>سياسة دبيان</emphasis> الحفاظ على التغييرات</title>

	<para>تشترط سياسة دبيان صراحة وجوب اتخاذ جميع الإجراءات اللازمة للحفاظ على التعديلات اليدوية على ملفات الإعداد، لذلك يتزايد عدد السكربتات التي تتخذ الاحتياطات عند تحرير ملفات الإعداد. المبدأ العام بسيط: يُجري السكربت تعديلاته فقط إذا كان يعرف الحالة السابقة لملف الإعداد، ويتم التأكد من هذا بمقارنة checksum الملف مع checksum آخِر ملف مولد تلقائياً. إذا تطابقا، يُسمَح للسكربت بتعديل ملف الإعداد. وإلا، فإن السكربت يقرر أن الملف قد تعدّل ويسأل عما يجب فعله (تثبيت الملف الجديد، حفظ الملف القديم، أو محاولة دمج التغييرات الجديدة في الملف الحالي). لطالما تميزت دبيان بهذا المبدأ الوقائي، لكن التوزيعات الأخرى بدأت تتبناه تدريجياً.</para>

	<para>يمكن استخدام البرنامج <command>ucf</command> (من حزمة دبيان ذات الاسم نفسه) لتطبيق مثل هذا السلوك.</para>
        <indexterm><primary><command>ucf</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.syslog">
    <title>أحداث <command>syslog</command></title>
    <indexterm><primary><command>rsyslogd</command></primary></indexterm>
    <indexterm><primary>ملفات</primary><secondary>ملفات السجلات</secondary></indexterm>
    <indexterm><primary>سجلات</primary><secondary>إرسال</secondary></indexterm>
    <section id="sect.syslog-principe">
      <title>المبدأ والآلية</title>

      <para>خدمة <command>rsyslogd</command> مسؤولة عن جمع رسائل الخدمات الواردة من التطبيقات ومن النواة، ثم إرسالها إلى ملفات السجلات (التي تخزن عادة في المجلد <filename>/var/log/</filename>). تطيع هذه الخدمة التعليمات في ملف الضبط <filename dir="ltr">/etc/rsyslog.conf</filename>.</para>

      <para>كل رسالة سجل ترتبط مع نظام فرعي لتطبيق ما (يدعى ”facility“ في الوثائق):</para>
      <itemizedlist>
        <listitem>
	  <para><literal>auth</literal> و<literal>authpriv</literal>: للمصادقة؛</para>
        </listitem>
        <listitem>
	  <para><literal>cron</literal>: تأتي من خدمات الجدولة، <command>cron</command> و<command>atd</command>؛</para>
        </listitem>
        <listitem>
	  <para><literal>daemon</literal>: تتعلق بخدمة ليس لها تصنيف خاص (DNS، ‏NTP، الخ)؛</para>
        </listitem>
        <listitem>
	  <para><literal>ftp</literal>: تتعلق بمخدم FTP؛</para>
        </listitem>
        <listitem>
	  <para><literal>kern</literal>: رسائل واردة من النواة؛</para>
        </listitem>
        <listitem>
	  <para><literal>lpr</literal>: تأتي من النظام الفرعي الخاص بالطباعة؛</para>
        </listitem>
        <listitem>
	  <para><literal>mail</literal>: تأتي من النظام الفرعي الخاص بالبريد الإلكتروني؛</para>
        </listitem>
        <listitem>
	  <para><literal>news</literal>: رسائل النظام الفرعي Usenet (خصوصاً من مخدم NNTP‏ –Network News Transfer Protocol، أو بروتوكول نقل الأخبار عبر الشبكة– الذي يدير المجموعات الإخبارية)؛</para>
        </listitem>
        <listitem>
	  <para><literal>syslog</literal>: رسائل من المخدم <command>syslogd</command> نفسه؛</para>
        </listitem>
        <listitem>
	  <para><literal>user</literal>: رسائل المستخدم (عامة)؛</para>
        </listitem>
        <listitem>
	  <para><literal>uucp</literal>: رسائل من مخدم UUCP ‏(Unix to Unix Copy Program، أو برنامج النسخ من يونكس إلى يونكس، بروتوكول قديم كان يستخدم لتوزيع رسائل البريد الإلكتروني)؛</para>
        </listitem>
        <listitem>
	  <para><literal>local0</literal> حتى <literal>local7</literal>: محجوزة للاستخدامات المحلية.</para>
        </listitem>
      </itemizedlist>

      <para>تعطى كل رسالة أولوية أيضاً. هذه قائمة الأولويات مرتبة تنازلياً:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>emerg</literal>: ”النجدة!“ هناك حالة طارئة، النظام غير قابل للاستخدام على الأرجح.</para>
        </listitem>
        <listitem>
	  <para><literal>alert</literal>: أسرِع، أي تأخير قد يكون خطيراً، يجب اتخاذ إجراء فوراً؛</para>
        </listitem>
        <listitem>
	  <para><literal>crit</literal>: الحالة حرجة؛</para>
        </listitem>
        <listitem>
	  <para><literal>err</literal>: خطأ؛</para>
        </listitem>
        <listitem>
	  <para><literal>warn</literal>: تحذير (يحتمل أن يكون خطأ)؛</para>
        </listitem>
        <listitem>
	  <para><literal>notice</literal>: الحالة طبيعية، لكن الرسالة مهمة؛</para>
        </listitem>
        <listitem>
	  <para><literal>info</literal>: رسالة إعلامية؛</para>
        </listitem>
        <listitem>
	  <para><literal>debug</literal>: رسالة تستخدم في التنقيح.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="sect.syslog-config">
      <title>ملف الإعداد</title>

      <para>صيغة الملف <filename>/etc/rsyslog.conf</filename> مفصلة في صفحة الدليل <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>‎، لكن هناك أيضاً توثيق بصيغة HTML متوفر في الحزمة <emphasis role="pkg">rsyslog-doc</emphasis> ‏(<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). المبدأ العام هو كتابة زوج يتألف من ”مُنتخِب selector“ و ”فعل action“. يعرف المنتخب جميع الرسائل المطلوبة، أما الفعل فيصف طريقة التعامل معها.</para>
      <section id="sect.syslog-selector-syntax">
        <title>صيغة المنتخب</title>

	<para>المُنتخِب هو لائحة تُفصَل عناصرها بفواصل منقوطة تتألف من أزواج من <literal><replaceable>subsystem</replaceable>.<replaceable>priority</replaceable></literal> (أزواج من نظام فرعي.أولوية، مثال: <literal>auth.notice;mail.info</literal>). يمكن استخدام النجمة لتعبر عن جميع النظم الفرعية أو جميع مستويات الأولوية (مثال: <literal dir="ltr">*.alert</literal> أو <literal dir="ltr">mail.*</literal>). يمكن جمع عدة نظم فرعية، عبر استخدام الفاصلة (مثال: <literal>auth,mail.info</literal>). كما أن الأولوية المذكورة تغطي الرسائل ذات الأولوية نفسها أو الأولويات أعلى؛ أي أن <literal>auth.alert</literal> يشير إلى رسائل النظام الفرعي <literal>auth</literal> ذات الأولوية <literal>alert</literal> أو <literal>emerg</literal>. إذا سبقت الأولوية بعلامة التعجب (!)، فسوف تشير إلى نقيضها، أي إلى الأولويات الأقل منها حصراً؛ أي أن <literal>auth.!notice</literal> يشير إلى الرسائل الصادرة عن <literal>auth</literal>، بأولوية <literal>info</literal> أو <literal>debug</literal>. وإذا سبقت بإشارة المساواة (=)، فسوف تقابل الأولوية المحددة وحدها فقط (<literal>auth.=notice</literal> يشير إلى رسائل <literal>auth</literal> ذات الأولوية <literal>notice</literal> فقط).</para>

	<para>كل عنصر في لائحة المنتخب أقوى من العناصر السابقة له. لذلك يمكن حصر مجموعة من الأولويات أو استثناء عناصر محددة منها. مثلاً، <literal>kern.info;kern.!err</literal> يعني الرسائل من النواة التي تتراوح أولويتها بين <literal>info</literal> و <literal>warn</literal>. تشير الأولوية <literal>none</literal> إلى المجموعة الخالية (لا تشير لأي أولوية)، ويمكن استخدامها لاستثناء نظام فرعي من مجموعة من الرسائل. بالتالي، <literal dir="ltr">*.crit;kern.none</literal> يشير إلى جميع الرسائل ذات الأولوية <literal>crit</literal> أو أعلى عدا التي ترد من النواة.</para>
      </section>
      <section id="sect.syslog-action-syntax">
        <title>صيغة الأفعال</title>

        <sidebar>
          <title><emphasis>أساسيات</emphasis> الأنبوب المسمّى، أنبوب دائم</title>
          <indexterm><primary>مسمّى، أنبوب مسمّى</primary></indexterm>
          <indexterm><primary>أنبوب مسمّى</primary></indexterm>

	  <para>الأنبوب المسمّى هو نوع خاص من الملفات يعمل مثل الأنابيب التقليدية (الأنابيب التي تنشأ بكتابة الرمز ”|“ في سطر الأوامر)، ولكن باستخدام ملف. تتميز هذه الآلية بقدرتها على ربط عمليتين غير متعلقتين ببعضهما. أي شيء يُكتَب إلى أنبوب مسمى يُوقِف تنفيذ العملية التي تكتب حتى تحاول عملية أخرى قراءة البيانات المكتوبة. تقرأ العملية الثانية البيانات التي كتبتها الأولى، التي تستطيع بعد ذلك متابعة التنفيذ.</para>

	  <para>يُنشَأ هذا النوع من الملفات باستخدام الأمر <command>mkfifo</command>.</para>
        </sidebar>

	<para>الأفعال المختلفة المتوفرة هي:</para>
        <itemizedlist>
          <listitem>
	    <para>إضافة الرسالة إلى ملف (مثال: <filename dir="ltr">/var/log/messages</filename>)؛</para>
          </listitem>
          <listitem>
	    <para>إرسال الرسالة إلى مخدم <command>syslog</command> بعيد (مثال: <literal dir="ltr">@log.falcot.com</literal>)؛</para>
          </listitem>
          <listitem>
	    <para>إرسال الرسالة إلى أنبوب مسمّى سابق (مثال: <literal dir="ltr">|/dev/xconsole</literal>)؛</para>
          </listitem>
          <listitem>
	    <para>إرسال الرسالة إلى مستخدم واحد أو أكثر، إذا كانوا مسجلي دخولهم (مثال: <literal>root,rhertzog</literal>)؛</para>
          </listitem>
          <listitem>
	    <para>إرسال الرسالة إلى جميع المستخدمين المسجلي دخولهم (مثال: <literal>*</literal>)؛</para>
          </listitem>
          <listitem>
	    <para>كتابة الرسالة في طرفية نصية (مثال: <literal dir="ltr">/dev/tty8</literal>).</para>
          </listitem>
        </itemizedlist>

        <sidebar>
          <title><emphasis>أمن</emphasis> توجيه السجلات</title>
          <indexterm><primary>سجل</primary><secondary>توجيه</secondary></indexterm>

	  <para>إن تسجيل أهم الرسائل على جهاز منفصل (ربما كان جهازاً مخصصاً لهذا الغرض) فكرة سديدة، بما أن هذا سيمنع أي متطفل محتمل من إزالة آثار تطفله (ما لم يخترق الجهاز الآخر أيضاً، طبعاً). بالإضافة لذلك، في حال حدوث مشكلة كبيرة (مثل انهيار النواة)، ستبقى السجلات متاحة على الجهاز الآخر، وهذا يزيد فرص التعرف على سلسلة الأحداث التي سببت الخلل.</para>

	  <para>لقبول الرسائل السجلية التي ترسلها الأجهزة الأخرى، عليك إعادة ضبط <emphasis>rsyslog</emphasis>: عملياً، يكفي تفعيل المدخلات الجاهزة للاستخدام في الملف <filename dir="ltr">/etc/rsyslog.conf</filename> ‏(<literal dir="ltr">$ModLoad imudp</literal> و<literal dir="ltr">$UDPServerRun 514</literal>).</para>
        </sidebar>
      </section>
    </section>
  </section>
  <section id="sect.inetd">
    <title>المخدم الفائق <command>inetd</command></title>

    <para>Inetd (الذي يدعى غالباً ”مخدم الإنترنت الفائق“) هو مخدم المخدمات. يعمل Inetd على تنفيذ المخدمات التي يندر استخدامها حسب الطلب، بحيث لا تضطر هذه المخدمات للعمل بشكل مستمر.</para>
    <indexterm><primary><command>inetd</command></primary></indexterm>
    <indexterm><primary>مخدم فائق</primary></indexterm>

    <para>يسرد الملف <filename dir="ltr">/etc/inetd.conf</filename> هذه المخدمات بالإضافة لمنافذها المعتادة. ينصت الأمر <command>inetd</command> على جميع هذه المنافذ؛ وعندما يستشعر اتصالاً على أي منها، يستدعي المخدم المناسب.</para>

    <sidebar>
      <title><emphasis>سياسة دبيان</emphasis> تسجيل مخدم في <filename>inetd.conf</filename></title>

      <para>غالباً ما ترغب الحزم بتسجيل مخدم جديد في الملف <filename dir="ltr">/etc/inetd.conf</filename>، ولكن سياسة دبيان تمنع أي حزمة من تعديل أي ملف إعدادات لا ينتمي لها. لذلك كان سكربت <command>update-inetd</command> (في الحزمة ذات الاسم نفسه): يدير هذا السكربت ملف الضبط المذكور، وهكذا تستطيع الحزم الأخرى استخدامه لتسجيل مخدم جديد في إعدادات المخدم الفائق.</para>
    </sidebar>

    <para>يصف كل سطر فعلي من ملف <filename dir="ltr">/etc/inetd.conf</filename> مخدماً من خلال سبعة حقول (تفصلها فراغات):</para>
    <itemizedlist>
      <listitem>
	<para>رقم منفذ TCP أو UDP، أو اسم الخدمة (الذي يقابل مع رقم منفذ معياري حسب المعلومات في الملف <filename dir="ltr">/etc/services</filename>).</para>
      </listitem>
      <listitem>
	<para>نوع المقبس (socket)‏: <literal>stream</literal> لاتصالات TCP، و<literal>dgram</literal> لبيانات UDP.</para>
      </listitem>
      <listitem>
	<para>البروتوكول: <literal>tcp</literal> أو <literal>udp</literal>.</para>
      </listitem>
      <listitem>
	<para>الخيارات: هناك قيميتن محتملتين: <literal>wait</literal> أو <literal>nowait</literal>، لإعلام <command>inetd</command> هل ينتظر انتهاء العملية المستدعاة قبل قبول اتصالات أخرى أم لا. بالنسبة لاتصالات TCP، التي يمكن جمعها (multiplex) بسهولة، يمكنك عادة استخدام <literal>nowait</literal>. أما للبرامج التي تستجيب عبر UDP، عليك استخدام <literal>nowait</literal> فقط إذا كان المخدم قادراً على إدارة عدة اتصالات على التوازي. يمكنك أن تسبق هذا الحقل بنقطة، وتلحقها بعدد الاتصالات الأعظمي المسموح كل دقيقة (الحد الافتراضي 256).</para>
      </listitem>
      <listitem>
	<para>اسم المستخدم الذي سيعمل المخدم باسمه.</para>
      </listitem>
      <listitem>
	<para>المسار الكامل للبرنامج المخدم الذي سيستدعى.</para>
      </listitem>
      <listitem>
	<para>المتغيرات: قائمة كاملة بمتغيرات البرنامج، بما فيها اسمه (<literal dir="ltr">argv[0]</literal> في لغة C).</para>
      </listitem>
    </itemizedlist>

    <para>يشرح المثال التالي أكثر الحالات شيوعاً:</para>

    <example id="example.inetd-conf">
      <title>مقتطفات من <filename dir="ltr">/etc/inetd.conf</filename></title>

      <programlisting>talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd
finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd
ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i
</programlisting>
    </example>
    <indexterm><primary><command>tcpd</command></primary></indexterm>

    <para>يستخدم البرنامج <command>tcpd</command> كثيراً في الملف <filename dir="ltr">/etc/inetd.conf</filename>. يسمح هذا البرنامج بتحديد عدد الاتصالات الواردة بتطبيق قواعد تحكم بالوصول، وهي موثقة في صفحة الدليل <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry>‎، ويتم ضبطها في الملفين <filename dir="ltr">/etc/hosts.allow</filename> و<filename dir="ltr">/etc/hosts.deny</filename>. بمجرد تحديد أن الاتصال مسموح، يستدعي <command>tcpd</command> المخدم الحقيقي (مثل <command>in.fingerd</command> في مثالنا). من المهم أن نذكر أن <command>tcpd</command> يعتمد على الاسم الذي استدعي به (وهو المتغير الأول الذي استقبله، <literal dir="ltr">argv[0]</literal>) للتعرف على البرنامج الحقيقي الذي يجب تشغيله. عليك إذن ألا تبدأ قائمة المتغيرات بالاسم <literal>tcpd</literal> بل باسم البرنامج الذي تريد تغليفه.</para>

    <sidebar>
      <title><emphasis>مجتمع</emphasis> Wietse Venema</title>
      <indexterm><primary>Wietse Venema</primary></indexterm>
      <indexterm><primary>Venema, Wietse</primary></indexterm>

      <para>Wietse Venema (فيتس فينما)، الذي جعلت منه خبرته في أمن المعلومات مبرمجاً ذائع الصيت، هو مؤلف برنامج <command>tcpd</command>. كما أنه المؤلف الرئيسي لمخدم البريد الإلكتروني التجزيئي Postfix‏ (مخدم SMTP ‏– Simple Mail Transfer Protocol، أو البروتوكول البسيط للبريد الإلكتروني)، الذي صُمّم ليكون آمَنُ وأكثر وثوقية من <command>sendmail</command>، صاحب التاريخ الطويل في الثغرات الأمنية.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>بدائل</emphasis> أوامر <command>inetd</command> أخرى</title>

      <para>في حين أن دبيان تثبت <emphasis role="pkg">openbsd-inetd</emphasis> افتراضياً، إلا أن هناك العديد من البدائل الأخرى: يمكن أن نذكر منها <emphasis role="pkg">inetutils-inetd</emphasis>،‏ <emphasis role="pkg">micro-inetd</emphasis>،‏ <emphasis role="pkg">rlinetd</emphasis> و<emphasis role="pkg">xinetd</emphasis>.</para>

      <para>يقدم تطبيق المخدم الفائق الأخير إمكانيات جذابة جداً. أهمها أنه يمكن فصل إعداداته إلى عدة ملفات (مخزنة طبعاً في المجلد <filename>/etc/xinetd.d/</filename>)، الأمر الذي يمكن أن يجعل حياة مدير النظام أسهل.</para>

      <para>أخيراً وليس آخراً، من الممكن أيضاً محاكاة سلوك <command>inetd</command> باستخدام آلية تفعيل المقابس التي يقدمها <command>systemd</command> (انظر <xref linkend="sect.systemd" />).</para>
    </sidebar>
  </section>
  <section id="sect.task-scheduling-cron-atd">
    <title>جدولة المهام باستخدام <command>cron</command> و<command>atd</command></title>
    <indexterm><primary><command>cron</command></primary></indexterm>
    <indexterm><primary><command>atd</command></primary></indexterm>
    <indexterm><primary>أوامر مُجَدْوَلَة</primary></indexterm>
    <indexterm><primary>جَدْوَلَة الأوامر</primary></indexterm>

    <para><command>cron</command> هي الخدمة المسؤولة عن تنفيذ الأوامر المجدولة والمتكررة (يومياً، أسبوعياً، الخ)؛ أما <command>atd</command> فهي الخدمة التي تعالج الأوامر التي تنفذ مرة واحدة، لكن في لحظة محددة من المستقبل.</para>

    <para>في نظام يونكس، هناك العديد من المهام التي تستدعى بانتظام:</para>
    <itemizedlist>
      <listitem>
	<para>تدوير (rotating) السجلات؛</para>
      </listitem>
      <listitem>
	<para>تحديث قاعدة بيانات البرنامج <command>locate</command>؛</para>
      </listitem>
      <listitem>
	<para>النسخ الاحتياطي؛</para>
      </listitem>
      <listitem>
	<para>سكربتات الصيانة (مثل تنظيف الملفات المؤقتة).</para>
      </listitem>
    </itemizedlist>

    <para>افتراضياً، يستطيع جميع المستخدمون جدولة تنفيذ المهام. لكل مستخدم إذن <emphasis>crontab</emphasis> خاص به يستطيع فيه تسجيل الأوامر المجدولة. يمكن تحريره بالأمر <command>crontab -e</command> (تخزن محتوياته في الملف <filename dir="ltr">/var/spool/cron/crontabs/<replaceable>user</replaceable></filename>).</para>

    <sidebar>
      <title><emphasis>أمن</emphasis> تقييد <command>cron</command> أو <command>atd</command></title>

      <para>يمكنك تقييد الوصول إلى <command>cron</command> عبر إنشاء ملف سماح صريح (القائمة البيضاء) في <filename dir="ltr">/etc/cron.allow</filename>، تشير فيه فقط إلى المستخدمين الذين يسمح لهم بجدولة الأوامر. أما بقية المستخدمين فسوف يحرمون من هذه الميزة آلياً. وبالعكس، إذا كنت تريد حجب واحد أو اثنين من مثيري المتاعب، فيمكنك كتابة أسماء الدخول الخاصة بهم في ملف الحظر الصريح (القائمة السوداء)، <filename dir="ltr">/etc/cron.deny</filename>. هذه الميزة نفسها متوفرة في <command>atd</command>، باستخدام الملفين <filename dir="ltr">/etc/at.allow</filename> و<filename dir="ltr">/etc/at.deny</filename>.</para>
    </sidebar>

    <para>يملك المستخدم الجذر <emphasis>crontab</emphasis> خاص به، لكنه يستطيع أيضاً استخدام الملف <filename dir="ltr">/etc/crontab</filename>، أو كتابة ملفات <emphasis>crontab</emphasis> إضافية في المجلد <filename dir="ltr">/etc/cron.d</filename>. يمتاز الحلان الأخيران بأنه يمكن فيهما تحديد هوية المستخدم التي سوف تستخدم عند تنفيذ الأوامر.</para>

    <para>تتضمن الحزمة <emphasis>cron</emphasis> افتراضياً بعض الأوامر المجدولة التي يتم تنفيذها:</para>
    <itemizedlist>
      <listitem>
	<para>البرامج في المجلد <filename>/etc/cron.hourly/</filename> تنفذ مرة كل ساعة؛</para>
      </listitem>
      <listitem>
	<para>البرامج في <filename>/etc/cron.daily/</filename> مرة كل يوم؛</para>
      </listitem>
      <listitem>
	<para>البرامج في <filename>/etc/cron.weekly/</filename> مرة كل أسبوع؛</para>
      </listitem>
      <listitem>
	<para>البرامج في <filename>/etc/cron.monthly/</filename> مرة كل شهر؛</para>
      </listitem>
    </itemizedlist>

    <para>تعتمد العديد من حزم دبيان على هذه الخدمة: حيث تضمن من خلال وضع سكربتات الصيانة في هذه المجلدات العمل الأمثل لخدماتها.</para>
    <section id="sect.format-crontab">
      <title>صيغة ملف <filename>crontab</filename></title>
      <indexterm><primary><filename>crontab</filename></primary></indexterm>

      <sidebar>
        <title><emphasis>تلميح</emphasis> الاختصارات النصية في <command>cron</command></title>

	<para>يتعرف <command>cron</command> على بعض الاختصارات التي تستبدل الحقول الخمسة الأولى في مدخلات <filename>crontab</filename>. تتفق هذه الاختصارات مع أكثر الخيارات التقليدية للجدولة:</para>
        <itemizedlist>
          <listitem>
	    <para><literal dir="ltr">@yearly</literal>: مرة كل سنة (1 يناير، الساعة 00:00)؛</para>
          </listitem>
          <listitem>
	    <para><literal dir="ltr">@monthly</literal>: مرة كل شهر (اليوم الأول من الشهر، الساعة 00:00)؛</para>
          </listitem>
          <listitem>
	    <para><literal dir="ltr">@weekly</literal>: مرة كل أسبوع (الأحد 00:00)؛</para>
          </listitem>
          <listitem>
	    <para><literal dir="ltr">@daily</literal>: مرة كل يوم (الساعة 00:00)؛</para>
          </listitem>
          <listitem>
	    <para><literal dir="ltr">@hourly</literal>: مرة كل ساعة (على رأس كل ساعة).</para>
          </listitem>
        </itemizedlist>
      </sidebar>

      <sidebar>
        <title><emphasis>حالة خاصة</emphasis> <command>cron</command> والتوقيت الصيفي</title>

	<para>في دبيان، يأخذ <command>cron</command> تغير التوقيت (عند الانتقال للتوقيت الصيفي، أو في الحقيقة عند أي تغير هام في التوقيت المحلي) بعين الاعتبار بأفضل ما يستطيع. بالتالي، الأوامر التي كان يفترض بها أن تنفذ في ساعة غير موجودة (مثلاً، المهام المجدولة الساعة 2:30 فجراً أثناء تغيير التوقيت الربيعي في فرنسا، لأنه عند الساعة 2:00 فجراً تقفز الساعة مباشرة إلى 3:00 فجراً) تنفذ بعد تغير الوقت بفترة وجيزة (أي حوالي 3:00 فجراً حسب التوقيت الصيفي). من جهة أخرى، في الخريف، عندما يفترض تنفيذ الأوامر عدة مرات (2:30 فجراً حسب التوقيت الصيفي، وبعدها بساعة تنفذ عند 2:30 فجراً حسب التوقيت النظامي، لأنه عند الساعة 3:00 فجراً حسب التوقيت الصيفي ترجع الساعة إلى 2:00 فجراً) تنفذ الأوامر مرة واحدة فقط.</para>

	<para>لكن حذار، إذا كان ترتيب المهام المجدولة المختلفة والتأخير بين تنفيذ هذه المهام يحدث فرقاً، فعليك التحقق من التوافق بين هذه الشروط وبين سلوك <command>cron</command>؛ يمكنك تحضير جدول خاص لليلتين من السنة اللتين تسببان المشاكل إذا دعت الحاجة.</para>
      </sidebar>

      <para>كل سطر فعلي من ملف <emphasis>crontab</emphasis> يصف أمراً مجدولاً باستخدام الحقول الستة (أو السبعة) التالية:</para>
      <itemizedlist>
        <listitem>
	  <para>قيمة للدقائق (عدد يتراوح بين 0 و 59)؛</para>
        </listitem>
        <listitem>
	  <para>قيمة للساعات (عدد يتراوح بين 0 و 23)؛</para>
        </listitem>
        <listitem>
	  <para>قيمة لتاريخ اليوم من الشهر (من 1 إلى 31)؛</para>
        </listitem>
        <listitem>
	  <para>قيمة للشهر (من 1 حتى 12)؛</para>
        </listitem>
        <listitem>
	  <para>قيمة للنهار من الأسبوع (من 0 إلى 7، 1 يرمز لنهار الإثنين، ويرمز لنهار الأحد بالرقم 0 والرقم 7؛ من الممكن أيضاً استخدام الحروف الثلاثة الأولى من اسم اليوم بالإنكليزية، مثل <literal>Sun</literal>، أو <literal>Mon</literal>، الخ)؛</para>
        </listitem>
        <listitem>
	  <para>اسم المستخدم الذي ستنفذ الأوامر تحت هويته (في الملف <filename dir="ltr">/etc/crontab</filename> وفي الملفات المجزئة في المجلد <filename>/etc/cron.d/</filename>، لكن ليس في ملفات crontab الخاصة بالمستخدمين)؛</para>
        </listitem>
        <listitem>
	  <para>الأمر المراد تنفيذه (عند تحقق الشروط المعرفة في الحقول الخمسة الأولى).</para>
        </listitem>
      </itemizedlist>

      <para>كل هذه التفاصيل موثقة في صفحة الدليل <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry>‎.</para>

      <para>يمكن تمثيل كل قيمة بشكل قائمة من  القيم الممكنة (تفصل عن بعضها بفواصل). الصيغة <literal>a-b</literal> تمثل كل القيم الممكنة في المجال بين <literal>a</literal> و<literal>b</literal>. والصيغة <literal>a-b/c</literal> فتمثل المجال نفسه ولكن بزيادة قدرها <literal>c</literal> بين القيم (مثال: <literal dir="ltr">0-10/2</literal> يعني <literal>0,2,4,6,8,10</literal>). أما النجمة <literal>*</literal> فهي محرف بديل، يمثل جميع القيم الممكنة.</para>

      <example id="example.crontab">
        <title>عينة عن ملف <filename>crontab</filename></title>

        <programlisting>#Format
#min hour day mon dow  command

# Download data every night at 7:25 pm
 25  19   *   *   *    $HOME/bin/get.pl

# 8:00 am, on weekdays (Monday through Friday)
 00  08   *   *   1-5  $HOME/bin/dosomething

# Restart the IRC proxy after each reboot
@reboot /usr/bin/dircproxy
</programlisting>
      </example>

      <sidebar>
        <title><emphasis>تلميح</emphasis> تنفيذ أمر عند الإقلاع</title>

	<para>لتنفيذ أمر مرة واحدة، مباشرة بعد إقلاع الحاسوب، يمكنك استخدام الماكرو <literal dir="ltr">@reboot</literal> ببساطة (إعادة تشغيل <command>cron</command> وحده لا يُنشِّط أمراً مجدولاً باستخدام <literal dir="ltr">@reboot</literal>). يستبدل هذا الماكرو الحقول الخمسة الأولى من المدخلة في <emphasis>crontab</emphasis>.</para>
      </sidebar>

    <sidebar>
      <title><emphasis>بدائل</emphasis> محاكاة <command>cron</command> باستخدام <command>systemd</command></title>

      <para>يمكن محاكاة سلوك <command>cron</command> باستخدام آلية المؤقتات التي يوفرها <command>systemd</command> (انظر <xref linkend="sect.systemd" />).</para>
    </sidebar>

    </section>
    <section id="sect.at-command">
      <title>استخدام الأمر <command>at</command></title>
      <indexterm><primary><command>at</command></primary></indexterm>

      <para>ينفذ <command>at</command> أمراً في لحظة محددة من المستقبل. يأخذ at التاريخ والوقت المرغوبين كمتغيرات في سطر الأوامر، ويأخذ الأمر الذي يجب تنفيذه من الدخل القياسي. سوف يُنفَّذ الأمر كما لو أنه أدخل في الصدفة الحالية. حتى أن <command>at</command> يهتم بالحفاظ على البيئة الحالية، لإعادة توليد الشروط نفسها عند تنفيذ الأمر. يُكتَب الوقت وفق الأشكال المعتادة: يمثل كلاً من <literal>16:12</literal> أو <literal>4:12pm</literal> الساعة 4:12 عصراً. يمكن تعريف التاريخ حسب عدة صيغ أوربية وغربية، منها <literal>DD.MM.YY</literal> (أي أن <literal>27.07.15</literal> تمثل 27 يوليو 2015)، <literal>YYYY-MM-DD</literal> (التاريخ السابق سيكتب بالشكل <literal dir="ltr">2015-07-27</literal>)، <literal>MM/DD/[CC]YY</literal> (مثال، <literal>12/25/15</literal> أو <literal>12/25/2015</literal> سوف تمثل 25 ديسمبر 2015)، أو ببساطة <literal>MMDD[CC]YY</literal> (بحيث يمثل <literal>122515</literal> أو <literal>12252015</literal> التاريخ 25 ديسمبر 2015 أيضاً). إذا لم يحدد التاريخ، سوف يُنفّذ الأمر فور وصول الساعة إلى الوقت المحدد (من اليوم نفسه، أو اليوم التالي إذا كانت الساعة المحددة قد مضت من ذلك اليوم). يمكنك أيضاً كتابة ”today“ أو ”tomorrow“ ببساطة.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>
<computeroutput>&gt; </computeroutput><userinput>echo "Don't forget to wish a Happy Birthday to Raphaël!" \</userinput>
<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>
<computeroutput>&gt; </computeroutput><userinput>END</userinput>
<computeroutput>warning: commands will be executed using /bin/sh
job 31 at Mon Jul 27 09:00:00 2015</computeroutput></screen>

      <para>هناك صيغة بديلة تستخدم لتأجيل التنفيذ لفترة محددة: <command>at now + <replaceable>number</replaceable> <replaceable>period</replaceable></command>. يمكن أن تكون الفترة <replaceable>period</replaceable> دقائق (<literal>minutes</literal>)، أو ساعاتٍ (<literal>hours</literal>)، أو أياماً (<literal>days</literal>)، أو أسابيعاً (<literal>weeks</literal>). يبين العدد <replaceable>number</replaceable> ببساطة عدد الوحدات المذكورة التي يجب أن تنقضي قبل تنفيذ الأمر.</para>

      <para>لإلغاء مهمة مجدولة باستخدام <command>cron</command>، استدع <command>crontab -e</command> ببساطة واحذف السطر الموافق في ملف <emphasis>crontab</emphasis>. أما بالنسبة لمهام <command>at</command>، فالعملية بنفس السهولة تقريباً: فقط استدع <command>atrm <replaceable>task-number</replaceable></command>. يعطيك <command>at</command> رقم المهمة عند جدولتها، لكن يمكنك الحصول عليه ثانية باستخدام الأمر <command>atq</command>، الذي يعطي لائحة محدّثة بالمهام المجدولة.</para>
      <indexterm><primary><command>atrm</command></primary></indexterm>
      <indexterm><primary><command>atq</command></primary></indexterm>
    </section>
  </section>
  <section id="sect.asynchronous-task-scheduling-anacron">
    <title>جدولة المهام غير المتزامنة: <command>anacron</command></title>

    <para><command>anacron</command> هي خدمة تكمل عمل <command>cron</command> للحواسيب التي لا تعمل طوال الوقت. بما أن المهام المنتظمة تجدول عادة منتصفَ الليل، فلن تُنفَّذ أبداً إذا كان الحاسوب مطفأ في ذلك الوقت. الغرض من <command>anacron</command> هو تنفيذ هذه المهام، مع الأخذ بعين الاعتبار الفترات التي لا يعمل فيها الحاسوب.</para>
    <indexterm><primary><command>anacron</command></primary></indexterm>

    <para>نرجو أن تلاحظ أن <command>anacron</command> غالباً سينفذ هذه النشاطات بعد إقلاع الجهاز ببضع دقائق، وهذا قد يخفض من استجابة الحاسوب. لذلك يبدأ تشغيل المهام المذكورة في الملف <filename dir="ltr">/etc/anacrontab</filename> باستخدام الأمر <command>nice</command>، الذي يخفض أولوية تنفيذها وبالتالي يحدُّ من عبئها على النظام. انتبه إلى أن صيغة هذا الملف ليست مطابقة لصيغة <filename dir="ltr">/etc/crontab</filename>؛ إذا كان هناك حاجة خاصة لاستخدام <command>anacron</command>، فاطلع على صفحة الدليل <citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry>‎.</para>

    <sidebar>
      <title><emphasis>أساسيات</emphasis> الأولويات و<command>nice</command></title>

      <para>نظم يونكس (وبالتالي لينكس) متعددة المهام ومتعددة المستخدمين. يمكن تشغيل عدة عمليات على التوازي فعلاً، ويمكن أن تنتمي لمستخدمين مختلفين: حيث تتولى النواة توزيع الموارد بين العمليات المختلفة. وكجزء من هذه الوظيفة، تتمتع النواة بمفهوم الأولوية، الذي يسمح لها بتفضيل عمليات معينة على أخرى، حسب الحاجة. يمكنك عندما تعلم أن إحدى العمليات يمكن أن تعمل بأولوية منخفضة أن تشير لذلك بتشغيلها باستخدام الأمر <command>nice <replaceable>program</replaceable></command>‏ (nice تعني ”مهذب“). سيحصل البرنامج عندها على حصة أقل من المعالج، وسيكون أثره على العمليات الجارية الأخرى أخف. طبعاً، إذا لم يكن هناك عمليات أخرى تحتاج أن تعمل، فلن تُعرقَلَ حركة البرنامج بشكل مفتعل.</para>

      <para>يعمل <command>nice</command> بعدة مستويات من ”التهذيب“: تخفض المستويات الموجبة (من 1 إلى 19) الأولوية تدريجياً، بينما ترفعها المستويات السالبة (من 1- حتى 20-) — لكن يسمح فقط للمستخدم الجذر بأن يستخدم هذه المستويات السالبة. يزيد <command>nice</command> المستوى الحالي بقيمة 10 إذا لم تحدد له قيمة أخرى (انظر صفحة الدليل <citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry>‎).</para>

      <para>إذا اكتشفت مهمة تعمل من قبل كان يجب تشغيلها باستخدام <command>nice</command> فيمكنك إصلاح ذلك؛ فالأمر <command>renice</command> يعدل أولوية العمليات الجارية، بكلا الاتجاهين (لكن تقليل ”تهذيب“ العمليات ممنوع إلا على المستخدم الجذر).</para>
    </sidebar>

    <para>يعطل تثبيت الحزمة <emphasis role="pkg">anacron</emphasis> تنفيذ <command>cron</command> للسكربتات في المجلدات  <filename>/etc/cron.hourly/</filename>،‏ <filename>/etc/cron.daily/</filename>،‏ <filename>/etc/cron.weekly/</filename>،‏ و <filename>/etc/cron.monthly/</filename>. وذلك لتفادي تنفيذها مرتين، مرة مع <command>anacron</command> ومرة مع <command>cron</command>. إلا أن الأمر <command>cron</command> يبقى فعّالاً ويتابع معالجة المهام المجدولة الأخرى (خصوصاً المهام التي يجدولها المستخدمون).</para>
  </section>
  <section id="sect.quotas">
    <title>الحصص التخزينية</title>
    <indexterm><primary>حصة تخزينية</primary></indexterm>

    <para>يسمح نظام الحصص التخزينية (Quotas) بتحديد مساحة القرص المخصصة لمستخدم ما أو لمجموعة من المستخدمين. لإعداد هذا النظام، يجب أن تملك نواة تدعمه (تمت ترجمتها مع الخيار <varname>CONFIG_QUOTA</varname>) — كما هي حال نوى دبيان. أما برمجيات إدارة الحصص التخزينية فتجدها في الحزمة <emphasis role="pkg">quota</emphasis>.</para>

    <para>لتفعيل الحصص التخزينية على نظام ملفات معين، عليك أن تضيف الخيارين <literal>usrquota</literal> و<literal>grpquota</literal> في <filename dir="ltr">/etc/fstab</filename> لتفعيل حصص المستخدمين والمجموعات، على الترتيب. بعدها سوف تُحَدِّث عملية إعادة إقلاع الحاسوب الحصص التخزينية في حال غياب نشاط القرص (شرط ضروري لحساب المساحة المستهلكة مسبقاً بشكل صحيح).</para>

    <para>يسمح لك الأمر <command>edquota <replaceable>user</replaceable></command> (أو <command>edquota -g <replaceable>group</replaceable></command>) بتعديل الحد التخزيني للمستخدم (أو المجموعة) أثناء عملية فحص الاستهلاك الحالي لمساحة القرص.</para>
    <indexterm><primary><command>edquota</command></primary></indexterm>

    <sidebar>
      <title><emphasis>التعمق أكثر</emphasis> تحديد الحصص التخزينية باستخدام سكربت</title>
      <indexterm><primary><command>setquota</command></primary></indexterm>

      <para>يمكن استخدام البرنامج <command>setquota</command> ضمن سكربت لتعديل عدة حصص تخزينية آلياً. تشرح صفحة الدليل <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry>‎ صيغة استعماله.</para>
    </sidebar>

    <para>يسمح لك نظام الحصص بتحديد أربعة حدود:</para>
    <itemizedlist>
      <listitem>
	<para>اثنان (يسميان ”مرن – soft“ و ”قاس – hard“) يشيران إلى عدد الكتل التخزينية المستهلكة. إذا أُنشِئ نظام الملفات بكتل حجمها 1 كيبي بايت، فإن كل كتلة ستحوي 1024 بايت من ملف وحيد. لذلك تسبّب الكتل غير المشبعة خسارة في مساحة القرص. فالحصة التي تحوي 100 كتلة، والتي تسمح نظرياً بتخزين 102,400 بايت، سوف تمتلئ عند تخزين 100 ملف فقط حجم كل منها 500 بايت، أي 50,000 بايت في المجمل.</para>
      </listitem>
      <listitem>
	<para>واثنان (soft و hard) يشيران لعدد عقد inode المستخدمة. يشغل كل ملف عقدة inode واحدة على الأقل لتخزين معلومات عنه (الصلاحيات، المالك، تاريخ ووقت آخر وصول، الخ). أي أنهما يقيدان عدد ملفات المستخدم.</para>
      </listitem>
    </itemizedlist>

    <para>يمكن تجاوز الحدود ”المرنة“ بشكل مؤقت؛ حيث ينبه المستخدمون فقط إلى أنهم يتجاوزون الحصة التخزينية وذلك عبر الأمر <command>warnquota</command>، الذي يستدعى عادة باستخدام <command>cron</command>. أما الحدود ”القاسية“ فلا يمكن تجاوزها أبداً: إذ يرفض النظام أي عملية تسبب تجاوز الحصة التخزينية القاسية.</para>

    <sidebar>
      <title><emphasis>مصطلحات</emphasis> الكتل وعقد inode</title>
      <indexterm><primary>كتلة (قرص)</primary></indexterm>
      <indexterm><primary>inode</primary></indexterm>

      <para>يقسم نظام الملفات القرص الصلب إلى كتل blocks — وهي مساحات صغيرة متجاورة. يحدد حجم هذه الكتل أثناء إنشاء نظام الملفات، ويتراوح عموماً بين 1 و8 كيبي بايت.</para>

      <para>يمكن استخدام الكتلة إما لتخزين البيانات الفعلية للملف، أو البيانات الفوقية meta-data الخاصة بنظام الملفات. من هذه البيانات الفوقية، ستجد عقد inode. تستهلك كل inode كتلة على القرص الصلب (لكن هذه الكتلة لا تؤخذ بعين الاعتبار عند حساب الحصص التخزينية التي تقيّد عدد الكتل التخزينية، بل الحصص التي تقيّد عدد inode فقط)، وتُخزِّن كلاً من المعلومات التي تعرف الملف الموافق لها (اسمه، مالكه، صلاحياته، الخ) والمؤشرات إلى كتل البيانات التي تحوي الملف فعلياً. للملفات الكبيرة جداً التي تحجز كتلاً كثيرة لا يمكن الإشارة إليها في inode واحدة، هناك نظام الكتل غير المباشرة؛ حيث تشير inode إلى لائحة من الكتل التي لا تحوي البيانات مباشرة، وإنما تشير إلى لائحة أخرى من الكتل.</para>
    </sidebar>
    <indexterm><primary><command>warnquota</command></primary></indexterm>

    <para>يمكنك باستخدام الأمر <command>edquota -t</command>، تعريف ”فترة سماح“ أعظمية يسمح خلالها تجاوز القيود المرنة. بعد انقضاء هذه المهلة، سوف تعامل قيود المرنة على أنها قيود قاسية، وسيضطر المستخدمون لتقليص استهلاكهم للمساحة التخزينية إلى ما دون الحد المفروض قبل أن يتمكنوا من كتابة أي شيء على القرص الصلب.</para>

    <sidebar>
      <title><emphasis>التعمق أكثر</emphasis> تحديد حصة تخزينية افتراضية للمستخدمين الجدد</title>

      <para>لتحديد حصة تخزينة للمستخدمين الجدد آلياً، عليك إعداد مستخدم ليخدم كنموذج للمستخدمين الجدد (بالأمر<command>edquota</command> أو <command>setquota</command>) ثم تحديد اسمه في المتغير <varname>QUOTAUSER</varname> في الملف <filename dir="ltr">/etc/adduser.conf</filename>. بعد ذلك، سوف تُطبَّقُ هذه الإعدادات تلقائياً كلما أنشأت مستخدماً جديداً بالأمر <command>adduser</command>.</para>
    </sidebar>
  </section>
  <section id="sect.backup">
    <title>النسخ الاحتياطي</title>

    <para>النسخ الاحتياطي هو أحد المهام الرئيسية لأي مدير نظم، لكنه موضوع معقد، ويحتاج لأدوات قوية يصعب إتقانها أغلب الأحيان.</para>
    <indexterm><primary>نسخ احتياطي</primary></indexterm>
    <indexterm><primary>استعادة</primary></indexterm>

    <para>هناك العديد من البرامج، مثل <command>amanda</command>، و <command>bacula</command>، و <command>BackupPC</command>. هذه نظم مخدم/عميل تقدم خيارات عديدة، لكن إعدادها صعب نوعاً ما. توفر بعضها واجهات وب صديقة للمستخدم لتسهيل ذلك. لكن دبيان تحوي عشرات برمجيات النسخ الاحتياطي الأخرى التي تغطي جميع حالات الاستخدام الممكنة، ويمكنك التحقق من ذلك بسهولة عبر الأمر <command>apt-cache search backup</command>.</para>
    <indexterm><primary><command>amanda</command></primary></indexterm>
    <indexterm><primary><command>bacula</command></primary></indexterm>
    <indexterm><primary><command>BackupPC</command></primary></indexterm>

    <para>بدلاً من تفصيل استخدام بعض هذه البرمجيات، سوف يستعرض هذا القسم أفكار مديري النظم في شركة فلكوت عندما حددوا استراتيجية النسخ الاحتياطي الخاصة بهم.</para>

    <para>في شركة فلكوت، للنسخ الاحتياطي هدفان: استعادة الملفات المحذوفة خطأً، واستعادة أي حاسوب بسرعة (مكتبي أو مخدم) إذا تعطل قرصه الصلب.</para>
    <section>
      <title>النسخ الاحتياطي باستخدام <command>rsync</command></title>

      <para>يعتبر النسخ الاحتياطي على الشرائط المغناطيسية بطيئاً جداً ومكلفاً، لذلك ستخزن النسخ الاحتياطية من البيانات على مخدم خاص، حيث يحمي استخدام RAID برمجي (انظر <xref linkend="sect.raid-soft" />) البيانات من أعطال الأقراص الصلبة. لن تؤخذ نسخ احتياطية عن الحواسيب المكتبية بشكل منفرد، لكن يتم إعلام المستخدمين أن حساباتهم الشخصية على مخدم الملفات في قسمهم في الشركة ستؤخذ عنها نسخ احتياطية. يُستخدَم الأمر <command>rsync</command> (من الحزمة ذات الاسم نفسه) يومياً لأخذ نسخ احتياطية عن هذه المخدمات المختلفة.</para>
      <indexterm><primary><command>rsync</command></primary></indexterm>

      <sidebar>
        <title><emphasis>أساسيات</emphasis> الروابط الصلبة، أسماء أخرى للملف نفسه</title>
        <indexterm><primary>رابط</primary><secondary>رابط صلب</secondary></indexterm>
        <indexterm><primary>صلب، رابط</primary></indexterm>

	<para>لا يمكن تمييز الرابط الصلب (hard link) عن الملف الأصلي، بخلاف الروابط الرمزية (symbolic links). إنشاء الرابط الصلب هو أساساً نفس عملية إعطاء الملف اسماً إضافياً. لذلك فإن حذف الرابط الصلب يزيل الاسم المرتبط مع الملف فقط. وطالما أن هناك اسماً آخر مرتبط مع الملف، ستبقى البيانات داخله مخزنة في نظام الملفات. من المهم ملاحظة أن الروابط الصلبة، وبعكس النسخ عن الملف، لا تحجز مساحة إضافية على القرص الصلب.</para>

	<para>تنشئ الروابط الصلبة بالأمر <command>ln <replaceable>target</replaceable> <replaceable>link</replaceable></command>. عندئذ يصبح الملف <replaceable>link</replaceable> اسماً جديداً للملف <replaceable>target</replaceable>. يمكن إنشاء الروابط الصلبة ضمن نظام الملفات نفسه فقط، بينما لا تخضع الروابط الرمزية لهذا القيد.</para>
      </sidebar>

      <para>تمنع محدودية المساحة التخزينية المتاحة على الأقراص الصلبة تطبيق نسخة احتياطية كاملة يومياً. لذلك، يُسبَقُ الأمر <command>rsync</command> بعملية تكرار لمحتويات النسخة الاحتياطية السابقة باستخدام روابط حقيقية تحول دون استهلاك الكثير من مساحة القرص الصلب. بعدها تستبدل عملية <command>rsync</command> الملفات التي طرأت عليها تعديلات منذ آخر عملية نسخ احتياطي فقط. باستخدام هذه الآلية يمكن الاحتفاظ بعدد أكبر من النسخ الاحتياطية في كمية قليلة من المساحة. بما أن جميع النسخ الاحتياطية متوفرة ومتاحة للوصول آنياً (مثلاً، في مجلدات مختلفة مشاركة على الشبكة)، يمكنك المقارنة فوراً بين تاريخين محددين.</para>
      <indexterm><primary>نسخ، نسخ احتياطي</primary></indexterm>
      <indexterm><primary>نسخ احتياطي</primary><secondary>نسخة</secondary></indexterm>
      <indexterm><primary><emphasis role="pkg">dirvish</emphasis></primary></indexterm>

      <para>يمكن تطبيق آلية النسخ الاحتياطي هذه بسهولة باستخدام البرنامج <command>dirvish</command>. يستخدم البرنامج مساحة تخزينية للنسخ الاحتياطي (”bank“ بحسب مصطلحاته) يخزن فيها نسخاً مؤرخة من مجموعات من الملفات الاحتياطية (هذه المجموعات تدعى ”vaults“ في وثائق dirvish).</para>

      <para>الإعدادات الرئيسية هي في الملف <filename dir="ltr">/etc/dirvish/master.conf</filename>. تعرف هذه الإعدادات موقع المساحة التخزينية للنسخ الاحتياطي، ولائحة ال ”vaults“ التي ستتم إدارتها، والقيم الافتراضية لانتهاء صلاحية النسخ الاحتياطية. بقية الإعدادات تقع في الملفات <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> وهي تحوي الإعدادات الخاصة بكل مجموعة من الملفات.</para>

      <example id="example.dirvish-master">
        <title>الملف <filename dir="ltr">/etc/dirvish/master.conf</filename></title>

        <programlisting>bank:
    /backup
exclude:
    lost+found/
    core
    *~
Runall:
    root    22:00
expire-default: +15 days
expire-rule:
#   MIN HR    DOM MON       DOW  STRFTIME_FMT
    *   *     *   *         1    +3 months
    *   *     1-7 *         1    +1 year
    *   *     1-7 1,4,7,10  1
</programlisting>
      </example>

      <para>يشير خيار <literal>bank</literal> إلى المجلد الذي ستخزن النسخ الاحتياطية فيه. يسمح لك الخيار <literal>exclude</literal> بتحديد الملفات (أو أنواع الملفات) التي لا تريد تضمينها في النسخ الاحتياطية. أما <literal>Runall</literal> فهو لائحة بمجموعات الملفات التي ستنسخ احتياطياً مع تاريخ كل منها، وهذا يسمح لك بتعيين التاريخ الصحيح للنسخة، في حال لم يعمل النسخ الاحتياطي في الوقت المحدد بدقة. عليك تحديد وقت يسبق وقت التنفيذ الفعلي قليلاً (وهو، افتراضياً، 10:04 مساء في دبيان، وفقاً للملف <filename dir="ltr">/etc/cron.d/dirvish</filename>). أخيراً، يحدد الخياران <literal>expire-default</literal> و<literal>expire-rule</literal> سياسة انتهاء الصلاحية للنسخ الاحتياطية. المثال السابق يبقي النسخ التي أخذت في الأحد الأول من كل ربع سنة للأبد، ويحذف النسخ المأخوذة في الأحد الأول من كل شهر بعد سنة، ويحذف النسخ المأخوذة في أيام الأحد الأخرى بعد ثلاثة أشهر. أما النسخ الاحتياطية اليومية الأخرى فيحتفظ بها لمدة 15 يوماً. ترتيب القواعد مهم جداً، لأن Dirvish يستخدم آخر قاعدة مناسبة، أو يستخدم قاعدة <literal>expire-default</literal> إذا لم يجد أي <literal>expire-rule</literal> مناسبة.</para>

      <sidebar>
        <title><emphasis>ممارسة عملية</emphasis> انتهاء الصلاحية المُجدوَل</title>

	<para>لا يستخدم <command>dirvish-expire</command> قواعد انتهاء الصلاحية لإتمام عمله. في الواقع، تطبق قواعد انتهاء الصلاحية عند إنشاء نسخة احتياطية جديدة لتحديد تاريخ انتهاء صلاحية تلك النسخة. حيث يطلع <command>dirvish-expire</command> ببساطة على النسخ المخزنة ويحذف النسخ التي انقضى تاريخ صلاحيتها.</para>
      </sidebar>

      <example id="example.dirvish-vault">
        <title>الملف <filename dir="ltr">/backup/root/dirvish/default.conf</filename></title>

        <programlisting>client: rivendell.falcot.com
tree: /
xdev: 1
index: gzip
image-default: %Y%m%d
exclude:
    /var/cache/apt/archives/*.deb
    /var/cache/man/**
    /tmp/**
    /var/tmp/**
    *.bak
</programlisting>
      </example>

      <para>يحدد المثال أعلاه مجموعات الملفات التي يجب أخذ نسخة احتياطية عنها: وهي الملفات على الجهاز <emphasis>rivendell.falcot.com</emphasis> (أما لأخذ نسخة احتياطية عن البيانات المحلية، فقط حدد اسم الجهاز المحلي كما هو محدد بالأمر <command>hostname</command>)، وبالأخص الملفات في الشجرة الجذر (<literal dir="ltr">tree: /</literal>)؛ ما عدا تلك المذكورة في <literal>exclude</literal>. النسخة الاحتياطية ستقتصر على محتويات نظام ملفات واحد (<literal dir="ltr">xdev: 1</literal>)، ولن  تتضمن أية ملفات من نقاط الربط الأخرى. سوف يُولَّد فهرس للملفات المحفوظة (<literal>index: gzip</literal>)، وستسمّى الصورة تبعاً للتاريخ الحالي (<literal>image-default: %Y%m%d</literal>).</para>

      <para>هناك العديد من الخيارات المتوفرة، وكلها موثقة في صفحة الدليل <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>‎. بمجرد تجهيز ملفات الضبط هذه، عليك تهيئة كل مجموعة ملفات بالأمر <command>dirvish --vault <replaceable>vault</replaceable> --init</command>. ومن بعد ذلك سيعمل الاستدعاء اليومي للأمر <command>dirvish-runall</command> آلياً على إنشاء نسخة احتياطية جديدة مباشرة بعد حذف النسخ التي انتهت صلاحيتها.</para>

      <sidebar>
        <title><emphasis>ممارسة عملية</emphasis> النسخ الاحتياطي البعيد عبر SSH</title>

	<para>عندما يحتاج dirvish لحفظ البيانات على جهاز بعيد، سوف يستخدم <command>ssh</command> للاتصال به، وسوف يشغل <command>rsync</command> كمخدم. هذا يتطلب أن يمتلك المستخدم الجذر إمكانية الاتصال بذلك الجهاز آلياً. يسمح استخدام مفتاح للمصادقة عبر SSH بهذا الأمر بالضبط (انظر <xref linkend="sect.ssh-key-based-auth" />).</para>
      </sidebar>
    </section>
    <section>
      <title>استعادة الأجهزة دون نسخ احتياطي</title>

      <para>يمكن استعادة الأجهزة المكتبية، التي لا تؤخذ عنها نسخ احتياطية، بسهولة من قرص DVD-ROM مخصص تم تجهيزه باستخدام <emphasis>Simple-CDD</emphasis> (انظر <xref linkend="sect.simple-cdd" />). بما أن هذه الطريقة تنفذ عملية تثبيت من الصفر، فسوف تسبب ضياع أي تخصيص تم بعد التثبيت الأولي. لا بأس بهذا بما أن جميع الأنظمة متصلة بمجلد LDAP مركزي للحسابات كما أن معظم التطبيقات المكتبية مضبوطة مسبقاً بفضل dconf (انظر <xref linkend="sect.gnome-desktop" /> لمزيد من المعلومات عن هذا).</para>

      <para>يدرك مديرو النظم في شركة فلكوت القصور في سياسة النسخ الاحتياطي التي اعتمدوها. فبما أنهم لا يستطيعون حماية مخدم النسخ الاحتياطي في خزانة مضادة للحرائق كما هي حال الشرائط المغناطيسية، فقد ركبوه في غرفة منفصلة بحيث لا تدمر كارثة، كحريق في غرفة المخدمات، النسخ الاحتياطية مع الأشياء الأخرى. بالإضافة لذلك، فإنهم يجرون نسخاً احتياطياً تصاعدياً (incremental) على DVD-ROM أسبوعياً — حيث تُنسَخ الملفات التي تغيرت منذ آخر عملية نسخ احتياطي فقط.</para>

      <sidebar>
        <title><emphasis>التعمق أكثر</emphasis> النسخ الاحتياطي لخدمات SQL و LDAP</title>

	<para>معظم الخدمات (مثل قواعد بيانات SQL أو LDAP) لا يمكن نسخها احتياطياً بنسخ ملفاتها فقط (إلا إذا تمت مقاطعتها بشكل سليم أثناء إنشاء النسخة الاحتياطية، وهذا يسبب المشاكل عادة، لأن المفروض أن تبقى هذه الخدمات متوفرة طوال الوقت). لذلك، كان لزاماً استخدام آلية ”تصدير“ لإنشاء ”خلاصة بيانات – data dump“ يمكن نسخها بأمان. خلاصات البيانات هذه كبيرة جداً غالباً، لكن ضغطها له مردود جيد. لتقليل المساحة التخزينية المطلوبة، سوف تُخزَّن نسخة كاملة مرة واحدة في الأسبوع فقط، ونسخة <command>diff</command> في كل يوم، التي يمكن إنشاؤها بالأمر <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command>. ينتج البرنامج <command>xdelta</command> فروقات تصاعدية من الخلاصات الثنائية (binary dumps).</para>
        <indexterm><primary><command>xdelta</command></primary></indexterm>
        <indexterm><primary><command>diff</command></primary></indexterm>
        <indexterm><primary>dump</primary></indexterm>
      </sidebar>

      <sidebar>
        <title><emphasis>ثقافة</emphasis> <emphasis>TAR</emphasis>، المعيار في النسخ الاحتياطي على الشرائط</title>
        <indexterm><primary>نسخ احتياطي</primary><secondary>على شريط</secondary></indexterm>
        <indexterm><primary>شريط، نسخ احتياطي</primary></indexterm>
        <indexterm><primary>TAR</primary></indexterm>

	<para>تاريخياً، كانت أبسط وسيلة لأخذ النسخ الاحتياطية في يونكس هي تخزين أرشيف <emphasis>TAR</emphasis> على شريط مغنطيسي. بل إن الأمر <command>tar</command> قد أخذ اسمه من ”Tape ARchive“.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.hotplug">
    <title>التوصيل الساخن: <emphasis>hotplug</emphasis></title>
    <section>
      <title>مقدمة</title>

      <para>يعالج نظام النواة الفرعي <emphasis>hotplug</emphasis> إضافة وإزالة الأجهزة ديناميكياً، عبر تحميل التعاريف المناسبة وعبر إنشاء ملفات الأجهزة الموافقة (بمساعدة <command>udevd</command>). في الأجهزة الحديثة والحوسبة الظاهرية، يمكن توصيل أي شيء تقريباً بشكل ساخن: من ملحقات USB/PCMCIA/IEEE 1394 الشائعة إلى أقراص SATA الصلبة، وصولاً إلى المعالجات والذواكر أيضاً.</para>

      <para>لدى النواة قاعدة بيانات تربط رقم تعريف (ID) كل جهاز مع برنامج التعريف المطلوب. تستخدم قاعدة البيانات هذه أثناء الإقلاع لتحميل جميع تعاريف الأجهزة الملحقة التي تكتشف على النواقل المختلفة، وأيضاً عند توصيل جهاز إضافي يدعم التوصيل الساخن. ترسل رسالة إلى <command>udevd</command> فور جاهزية القطعة للاستعمال، حتى يتمكن من إنشاء المدخلة الموافقة في <filename>/dev/</filename>.</para>

      <indexterm><primary><emphasis>hotplug</emphasis></primary></indexterm>
      <indexterm><primary>hotplug</primary></indexterm>
      <indexterm><primary>USB</primary></indexterm>
      <indexterm><primary>IEEE 1394</primary></indexterm>
      <indexterm><primary>PCMCIA</primary></indexterm>
      <indexterm><primary>SATA</primary></indexterm>
    </section>
    <section>
      <title>مشكلة التسمية</title>

      <para>قبل ظهور الاتصالات الساخنة، كان من السهل تعيين أسماء ثابتة للأجهزة. كانت تعتمد تسميتها ببساطة على موقع الجهاز على الناقل الخاص به. لكن هذا غير ممكن عندما تتحرك هذه الأجهزة على النواقل. من الحالات النموذجية استخدام الكاميرا الرقمية أو مفتاح USB، حيث يظهر كل منهما للحاسوب على أنه قرص تخزيني. ربما كان اسم الجهاز المتصل أولاً <filename dir="ltr">/dev/sdb</filename> والمتصل ثانياً <filename dir="ltr">/dev/sdc</filename> (حيث يمثل <filename dir="ltr">/dev/sda</filename> القرص الصلب للحاسوب). أسماء الأجهزة غير ثابتة؛ بل تعتمد على ترتيب توصيل الأجهزة.</para>

      <para>بالإضافة لذلك، يزداد عدد التعاريف التي تستخدم قيماً ديناميكية لأرقام major/minor للأجهزة، ما يحول دون إمكانية تعيين مدخلات ثابتة للأجهزة المعنية، بما أن هذه الخصائص الأساسية قد تختلف بعد إعادة الإقلاع.</para>

      <para>لقد أنشئ <emphasis>udev</emphasis> لحل هذه المشكلة تحديداً.</para>

      <sidebar>
        <title><emphasis>ممارسة عملية</emphasis> إدارة بطاقات الشبكة</title>

	<para>معظم الحواسيب لها عدة بطاقات شبكة (أحياناً واجهتين سلكيتين وواجهة wifi)، وبسبب دعم <emphasis>hotplug</emphasis> على معظم أنواع النواقل لا تضمن النواة لينكس إعطاء أسماء ثابتة للواجهات الشبكية. لكن المستخدمين الذين يريدون ضبط شبكاتهم في <filename dir="ltr">/etc/network/interfaces</filename> يحتاجون أسماءً ثابتة!</para>

	<para>من الصعب أن تطلب من كل مستخدم أن ينشئ قواعد <emphasis>udev</emphasis> خاصة به لحل هذه المشكلة. لذلك كان إعداد <emphasis>udev</emphasis> منفرداً نوعاً ما؛ عند الإقلاع الأول (وبشكل أعم، عند كل مرة تظهر فيها بطاقة شبكية جديدة) يستخدم udev اسم الواجهة الشبكية وعنوان MAC الخاص بها لإنشاء قواعد جديدة لإعادة تعيين الاسم نفسه عند عمليات الإقلاع التالية. تخزن هذه القواعد في <filename dir="ltr">/etc/udev/rules.d/70-persistent-net.rules</filename>.</para>

        
	<para>لهذه الآلية بعض الآثار الجانبية التي يجب أن تعرفها. دعنا نأخذ حالة الحاسوب الذي يملك بطاقة PCI شبكية واحدة فقط. منطقياً ستسمى الواجهة الشبكية <literal>eth0</literal>. لنفترض الآن أن البطاقة تعطلت، وأن مدير النظام استبدلها؛ ستملك البطاقة الجديدة عنوان MAC جديد. بما أن البطاقة القديمة أخذت الاسم <literal>eth0</literal>، فسوف تأخذ البطاقة الجديدة الاسم <literal>eth1</literal>، رغم أن البطاقة <literal>eth0</literal> قد ذهبت بلا رجعة (ولن تعمل الشبكة لأن الملف <filename dir="ltr">/etc/network/interfaces</filename> يحوي إعدادات تستخدم اسم الواجهة <literal>eth0</literal> غالباً). في هذه الحالة، يكفي حذف الملف <filename dir="ltr">/etc/udev/rules.d/70-persistent-net.rules</filename> قبل إعادة إقلاع الحاسوب. عند ذلك ستعطى البطاقة الجديدة الاسم المتوقع <literal>eth0</literal>.</para>
      </sidebar>
    </section>
    <section>
      <title>طريقة عمل <emphasis>udev</emphasis></title>

      <para>عندما تُـنَـبِّه النواةُ <emphasis>udev</emphasis> إلى ظهور جهاز جديد، يجمع udev المعلومات المختلفة عن الجهاز المعني باستطلاع المدخلات المناسبة في <filename>/sys/</filename>، خصوصاً المدخلات التي تعرف الجهاز بشكل فريد (عنوان MAC للبطاقات الشبكية، الأرقام التسلسلية لبعض أجهزة USB، الخ).</para>

      <para>بعد جمع كل هذه المعلومات، يتحقق <emphasis>udev</emphasis> من القواعد المخزنة في <filename>/etc/udev/rules.d/</filename> و<filename>/lib/udev/rules.d/</filename>. من خلال هذه العملية يقرر كيفية تسمية الجهاز، والروابط الرمزية التي سينشئها له (لإعطائه أسماء بديلة)، والأوامر التي يجب تنفيذها. يتم استطلاع جميع الملفات، و تقيَّم جميع القواعد تسلسلياً (إلا عندما يحوي الملف توجيهات ”GOTO“). لذلك قد ترتبط عدة قواعد بحدث معين.</para>

      <para>صيغة ملفات القواعد بسيطة جداً: كل سطر يحوي معايير اختيار وقيم متغيرات. تستخدم الأولى لتحديد الأحداث التي يجب الاستجابة لها، وتُعرِّف الأخيرة الأفعال التي يجب اتخاذها. تفصل كافة المكونات عن بعضها بفواصل، وتُفَرِّق المعاملات ضمنياً بين معايير الاختيار (التي تحوي معاملات مقارنة، مثل <literal>==</literal> أو <literal dir="ltr">!=</literal>) وبين توجيهات الإسناد (التي تستخدم معاملات مثل <literal>=</literal> أو <literal dir="ltr">+=</literal> أو <literal dir="ltr">:=</literal>).</para>

      <para>تستخدم معاملات المقارنة على المتغيرات التالية:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>KERNEL</literal>: الاسم الذي تعينه النواة للجهاز؛</para>
        </listitem>
        <listitem>
	  <para><literal>ACTION</literal>: الفعل الموافق للحدث (”add“ عندما تضاف القطعة، ”remove“ عند إزالتها)؛</para>
        </listitem>
        <listitem>
	  <para><literal>DEVPATH</literal>: مسار مدخلة القطعة في <filename>/sys/</filename>؛</para>
        </listitem>
        <listitem>
	  <para><literal>SUBSYSTEM</literal>: نظام النواة الفرعي الذي وَلَّدَ الطلب (هناك العديد من هذه الأنظمة، لكن من بعض الأمثلة عليها ”usb“،‏ ”ide“،‏ ”net“،‏ ”firmware“، الخ)؛</para>
        </listitem>
        <listitem>
	  <para><literal dir="ltr">ATTR{<replaceable>attribute</replaceable>}</literal>: محتويات الملف <replaceable>attribute</replaceable> في المجلد <filename>/sys/<replaceable>$devpath</replaceable>/</filename> الخاص بالجهاز. هنا تجد عنوان MAC وغيره من المعرفات الخاصة بالناقل؛</para>
        </listitem>
        <listitem>
	  <para><literal>KERNELS</literal> و<literal>SUBSYSTEMS</literal> و<literal dir="ltr">ATTRS{<replaceable>attributes</replaceable>}</literal> هي صيغ أخرى تُستَخدَمُ لمطابقة الخيارات المختلفة لأحد الأجهزة الآباء للجهاز الحالي؛</para>
        </listitem>
        <listitem>
	  <para><literal>PROGRAM</literal>: يوكل الاختبار إلى البرنامج المشار إليه (true إذا أعاد القيمة 0، false فيما عدا ذلك). تخزن محتويات خرج البرنامج القياسي بحيث يستطيع اختبار <literal>RESULT</literal> إعادة استخدامها؛</para>
        </listitem>
        <listitem>
	  <para><literal>RESULT</literal>: يجري اختبارات على الخرج القياسي المخزن أثناء آخر استدعاء لـ <literal>PROGRAM</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>يمكن أن تستخدم التعابير المنتظمة لمطابقة عدة قيم في الوقت نفسه في المعاملات على اليمين. مثلاً، تطابق النجمة <literal>*</literal> أيَّ سلسلة (وحتى السلسلة الفارغة)؛ وتطابق علامة الاستفهام <literal>?</literal> أي محرف، وتطابق الأقواس المربعة <literal dir="ltr">[]</literal> مجموعة من المحارف المذكورة بين القوسين المربعين (أو عكس تلك المحارف إذا كان المحرف الأول علامة تعجب، وتكتب المجالات المستمرة بالشكل <literal>a-z</literal>).</para>

      <para>أما بخصوص معاملات الإسناد، فيسند المعامل <literal>=</literal> قيمة جديدة (ويستبدل القيمة الحالية)؛ في حال تطبيقه على لائحة، سوف يفرغها ويسند لها القيمة المعطاة فقط. المعامل <literal dir="ltr">:=</literal> له نفس الأثر، لكنه يمنع التعديلات اللاحقة على المتغير نفسه. أما بالنسبة للمعامل <literal dir="ltr">+=</literal>، فهو يضيف عنصراً إلى اللائحة. يمكن تعديل المتغيرات التالية:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>NAME</literal>: اسم ملف الجهاز الذي سينشأ في <filename>/dev/</filename>. تؤخذ عملية الإسناد الأولى بعين الاعتبار فقط؛ وتهمل الإسنادات الأخرى؛</para>
        </listitem>
        <listitem>
	  <para><literal>SYMLINK</literal>: لائحة بالروابط الرمزية التي تشير إلى الجهاز نفسه؛</para>
        </listitem>
        <listitem>
	  <para>تعرف المتغيرات <literal>OWNER</literal> و<literal>GROUP</literal> و<literal>MODE</literal> المستخدم المالك والمجموعة المالكة للجهاز، بالإضافة إلى الصلاحيات المتعلقة به؛</para>
        </listitem>
        <listitem>
	  <para><literal>RUN</literal>: لائحة بالبرامج التي يجب تنفيذها استجابة لهذا الحدث.</para>
        </listitem>
      </itemizedlist>

      <para>يمكن استخدام عدد من البدائل في القيم التي تسند إلى هذه المتغيرات:</para>
      <itemizedlist>
        <listitem>
	  <para><literal dir="ltr">$kernel</literal> أو <literal dir="ltr">%k</literal>: تكافئ <literal>KERNEL</literal>؛</para>
        </listitem>
        <listitem>
	  <para><literal dir="ltr">$number</literal> أو <literal dir="ltr">%n</literal>: لترقيم الجهاز، مثلاً، بالنسبة للجهاز <literal>sda3</literal>، ستكون قيمته ”3“؛</para>
        </listitem>
        <listitem>
	  <para><literal dir="ltr">$devpath</literal> أو <literal dir="ltr">%p</literal>: تكافئ <literal>DEVPATH</literal>؛</para>
        </listitem>
        <listitem>
	 
	  <para><literal dir="ltr">$attr{<replaceable>attribute</replaceable>}</literal> أو <literal dir="ltr">%s{<replaceable>attribute</replaceable>}</literal>: تكافئ <literal dir="ltr">ATTRS{<replaceable>attribute</replaceable>}</literal>؛</para>
        </listitem>
        <listitem>
	  <para><literal dir="ltr">$major</literal> أو <literal dir="ltr">%M</literal>: رقم النواة الكبير للجهاز؛</para>
        </listitem>
        <listitem>
	  <para><literal dir="ltr">$minor</literal> أو <literal dir="ltr">%m</literal>: رقم النواة الصغير للجهاز؛</para>
        </listitem>
        <listitem>
	  <para><literal dir="ltr">$result</literal> أو <literal dir="ltr">%c</literal>: الخرج النصي لآخر برنامج استدعي عبر <literal>PROGRAM</literal>؛</para>
        </listitem>
        <listitem>
	  <para>وأخيراً، <literal>%%</literal> للعلامة المئوية و<literal>$$</literal> لعلامة الدولار.</para>
        </listitem>
      </itemizedlist>

      <para>هذه القوائم غير كاملة (بل تحوي المتغيرات الأهم فقط)، لكن يجب أن تكون صفحة الدليل <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry>‎ شاملة.</para>
    </section>
    <section>
      <title>مثال واقعي</title>

      <para>دعنا ندرس حالة مفتاح USB بسيط ونحاول تعيين اسم ثابت له. أولاً، يجب أن تعثر على العناصر التي تعرف المفتاح بشكل فريد. للحصول عليها، وصّل المفتاح ثم استدع <command>udevadm info -a -n /dev/sdc</command> مع استبدال <replaceable dir="ltr">/dev/sdc</replaceable> بالاسم الفعلي الذي أعطي للمفتاح).</para>

      <screen><computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>
<computeroutput>[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</computeroutput>
</screen>

      <para>لإنشاء قاعدة جديدة، يمكنك عمل اختبارات على متغيرات الجهاز، وعلى متغيرات الأجهزة الآباء. يسمح لنا المثال السابق بإنشاء قاعدتين كما يلي:</para>

      <programlisting>KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"
</programlisting>

      <para>بعد تخزين هذه القواعد في ملف، اسمه <filename dir="ltr">/etc/udev/rules.d/010_local.rules</filename> على سبيل المثال، يمكنك ببساطة إزالة مفتاح USB وتوصيله من جديد. عندئذ سترى أن <filename dir="ltr">/dev/usb_key/disk</filename> يمثل القرص التخزيني المرتبط بمفتاح USB، وأن <filename dir="ltr">/dev/usb_key/part1</filename> يمثل القسم الأول منه.</para>

      <sidebar>
        <title><emphasis>التعمق أكثر</emphasis> تنقيح إعدادات <emphasis>udev</emphasis></title>

	<para>يخزن <command>udevd</command>، مثل العديد من الخدمات، سجلات في <filename dir="ltr">/var/log/daemon.log</filename>. لكنها غير مفصلة كثيراً افتراضياً، وهي عادة غير كافية لفهم ما يجري. يزيد الأمر <command>udevadm control --log-priority=info</command> مستوى التفصيل ويحل هذه المشكلة. يعود الأمر <command>udevadm control --log-priority=err</command> إلى مستوى التفصيل الافتراضي.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.power-management">
    <title>إدارة الطاقة: Advanced Configuration and Power Interface ‏(ACPI)</title>
    <indexterm><primary>إدارة الطاقة</primary></indexterm>
    <indexterm><primary>إدارة، إدارة الطاقة</primary></indexterm>

    <para>موضوع إدارة الطاقة غالباً ما يثير المشاكل. فوضع الحاسوب في حالة الاستعداد بشكل سليم يتطلب من جميع تعاريف قطع الحاسوب أن تعرف كيفية وضع القطع في حالة الاستعداد، وأن تعيد ضبط القطعة بشكل سليم عند استئناف العمل. لسوء الحظ، هناك بضعة أجهزة غير قادرة على الدخول في حالة الاستعداد بشكل جيد في بيئة لينكس، لأن مصنعي هذه الأجهزة لم يوفروا التوصيفات المطلوبة.</para>

    <para>لينكس تدعم ACPI‏ (Advanced Configuration and Power Interface) — وهي أحدث معيار في مجال إدارة الطاقة. توفر الحزمة <emphasis role="pkg">acpid</emphasis> خدمة تبحث عن الأحداث المتعلقة بإدارة الطاقة (كالتبديل بين طاقة AC والبطارية على الحاسوب المحمول، الخ) وتستطيع الاستجابة لها عبر تنفيذ أوامر مختلفة.</para>

    <indexterm><primary>ACPI</primary></indexterm>
    <indexterm><primary>Advanced Configuration and Power Interface</primary></indexterm>
    <indexterm><primary><command>acpid</command></primary></indexterm>
    
    <sidebar>
      <title><emphasis>تنبيه</emphasis> بطاقات الرسوميات ووضع الاستعداد</title>

      <para>تعريف بطاقة الرسوميات هو غالباً من يسبب المشاكل عندما لا يعمل وضع الاستعداد بشكل سليم. في تلك الحالة، قد يناسبك اختبار أحدث نسخة من مخدم الرسوميات X.org.</para>
    </sidebar>

    <para>بعد هذه الجولة بين الخدمات الأساسية المتوفرة في العديد من نظم يونكس، سوف نركز على بيئة الأجهزة المدارة: الشبكات. تحتاج الشبكات العديد من الخدمات حتى تعمل بشكل صحيح. سوف نناقش هذه الخدمات في الفصل التالي.</para>
  </section>
</chapter>
