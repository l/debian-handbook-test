<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course" lang="ar-MA">
	<appendixinfo>
		 <keywordset>
			<keyword>بيوس</keyword>
			 <keyword>نواة</keyword>
			 <keyword>يونكس</keyword>
			 <keyword>عملية</keyword>
			 <keyword>بنية شجرية</keyword>
			 <keyword>الأوامر الأساسية</keyword>

		</keywordset>

	</appendixinfo>
	 <title>دورة تذكيرية قصيرة</title>
	 <highlights> <para>
		بالرغم من أن هذا الكتاب يستهدف مديري النظم و ”المستخدمين المتقدمين“، إلا أننا لم نرغب باستبعاد المبتدئين المتحفزين. وبالتالي فإن هذا الملحق بمثابة حلقة دراسية مكثفة تصف المفاهيم الأساسية المرتبطة بالتحكم في حواسيب يونـِكس.
	</para>
	 </highlights> <section id="sect.shell-and-basic-commands">
		<title>الصَدَفة (shell) والأوامر الأساسية</title>
		 <para>
			في عالم يونِكس، يضطر كل مدير نظم إلى استخدام سطر الأوامر عاجلاً أو آجلاً؛ مثلاً، عندما يخفق النظام في الإقلاع بشكل صحيح ويكون وضع الإنقاذ النصي متوفرًا فقط. وبالتالي، فإن القدرة على التحكم بمثل هذه الواجهة هي مهارة إنقاذ أساسية في مثل هذه الحالات.
		</para>
		 <sidebar> <title><emphasis>نظرة سريعة</emphasis> بدء مُفسِّر الأوامر</title>
		 <para>
			A command-line environment can be run from the graphical desktop, by an application known as a “terminal”. In GNOME, you can start it from the “Activities” overview (that you get when you move the mouse in the top-left corner of the screen) by typing the first letters of the application name. In Plasma, you will find it in the <menuchoice><guimenu>K</guimenu> <guisubmenu>Applications</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice> menu.
		</para>
		 </sidebar> <para>
			يلقي هذا القسم نظرة سريعة على الأوامر فقط. كل هذه الأوامر لها العديد من الخيارات التي لم نذكرها هنا، لذلك نرجو أن تتطلع على الوثائق الوافرة في صفحات الدليل (manual pages) الخاصة بها.
		</para>
		 <section>
			<title>استعراض شجرة المجلدات وإدارة الملفات</title>
			 <para>
				بمجرد فتح جلسة جديدة، يعرض الأمر <command>pwd</command> (اختصاراً للعبارة <emphasis>print working directory</emphasis> أو طباعة مجلد العمل) الموقع الحالي في نظام الملفات. يتم تغيير المجلد الحالي باستخدام الأمر <command>cd <replaceable>directory</replaceable></command> (الأمر <command>cd</command> يعني <emphasis>change directory</emphasis> أي تغيير المجلد). يرمز للمجلد الأب بنقطتين دائماً ( <literal>..</literal> )، في حين يرمز للمجلد الحالي بنقطة واحدة ( <literal>.</literal> ). يسمح الأمر <command>ls</command> بسرد (<emphasis>listing</emphasis>) محتويات المجلد. إذا لم يُعطَى أية متغيرات، فسيَعرضُ محتويات المجلد الحالي.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>cd Desktop</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd .</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates
Documents  Music      Public    Videos</computeroutput>
</screen>
			 <para>
				يمكن إنشاء مجلد جديد باستخدام الأمر <command>mkdir <replaceable>directory</replaceable></command>، ويمكن إزالة مجلد (فارغ) موجود سابقًا بالأمر <command>rmdir <replaceable>directory</replaceable></command>. يسمح الأمر <command>mv</command> بنقل <emphasis>move</emphasis> و/أو إعادة تسمية الملفات والمجلدات؛ ولإزالة الملفات <emphasis>remove</emphasis> استخدم الأمر <command>rm <replaceable>file</replaceable></command>.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public    test
$ </computeroutput><userinput>mv test new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  new       Public     Videos
Documents  Music      Pictures  Templates
$ </computeroutput><userinput>rmdir new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public</computeroutput>
</screen>

		</section>
		 <section>
			<title>استعراض وتعديل الملفات النصية</title>
			 <para>
				يقرأ الأمر <command>cat <replaceable>file</replaceable></command> (يعني <emphasis>concatenate</emphasis> ملف إلى جهاز الإخراج القياسي أي ربطه معه) ملفاً ويعرض محتوياته على الطرفية. إذا كان الملف أكبر من أن يتسع في الشاشة، استعمل أمرَ تصفّحٍ مثل <command>less</command> (أو <command>more</command>) لعرضه صفحة بعد أخرى.
			</para>
			 <para>
				يشغل الأمر <command>editor</command> محرر نصوص (مثل <command>vi</command> أو <command>nano</command>) ويسمح بإنشاء، وتعديل وقراءة الملفات النصية. يمكن إنشاء الملفات البسيطة أحيانًا من مفسِّر الأوامر مباشرة بفضل خاصية إعادة التوجيه: ينشئ الأمر <command>echo "<replaceable>text</replaceable>" &gt;<replaceable>file</replaceable></command> ملفاً باسم <replaceable>file</replaceable> يحتوي على ”<replaceable>text</replaceable>“. من الممكن إضافة سطر إلى آخر هذا الملف أيضًا، باستخدام الأمر <command>echo "<replaceable>moretext</replaceable>" &gt;&gt;<replaceable>file</replaceable></command>. لاحظ استخدام <literal>&gt;&gt;</literal> في هذا المثال.
			</para>

		</section>
		 <section>
			<title>البحث عن الملفات، والبحث ضمن الملفات</title>
			 <para>
				يبحث الأمر <command>find <replaceable>directory</replaceable> <replaceable>criteria</replaceable></command> عن ملفات تحت المجلد <replaceable>directory</replaceable> وفقاً لعدة معايير. المعيار الأكثر استخداماً هو <literal>-name <replaceable>name</replaceable></literal>: الذي يسمح بالبحث عن ملف حسب الاسم.
			</para>
			 <para>
				يبحث الأمر <command>grep <replaceable>expression</replaceable> <replaceable>files</replaceable></command> في محتويات الملفات ويستخلص السطور التي تطابق التعبير النظامي. (انظر الملاحظة الجانبية <xref linkend="sidebar.regexp" />). تمكّن إضافة الخيار <literal>‎-r</literal> البحث التعاودي على جميع الملفات المحتواة في المجلد المعطى كمتغير. هذا يسمح بالعثور على ملف عندما نعلم جزءًا من محتوياته فقط.
			</para>

		</section>
		 <section>
			<title>إدارة العمليات</title>
			 <para>
				يسرد الأمر <command>ps aux</command> العمليات التي تعمل حالياً ويساعد على التعرف عليها من خلال عرض رقم <emphasis>pid</emphasis> الخاص بها (process id أي معرِّف العملية). بمجرد معرفة <emphasis>pid</emphasis> إحدى العمليات، يسمح الأمر <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> بإرسال إشارة إليها (إذا كانت العملية خاصة بالمستخدم الحالي). توجد عدة إشارات؛ أكثرها استخداماً <literal>TERM</literal> (طلب إنهاء العملية بلطف) و <literal>KILL</literal> (إنهاء قسري).
			</para>
			 <para>
				يسمح مفسر الأوامر أيضاً بتشغيل البرامج في الخلفية إذا اتبعت الأمر بعلامة ”&amp;“. باستخدام هذه العلامة (ampersand)، يتابع المستخدم تحكمه بالصدفة مباشرة بالرغم من أن الأمر لا يزال يعمل (وهو مخفي عن المستخدم؛ كعملية في الخلفية). يسرد الأمر <command>jobs</command> العمليات التي تعمل في الخلفية حالياً؛ إن تشغيل الأمر <command>fg %<replaceable>job-number</replaceable></command> (اختصاراً لكلمة <emphasis>foreground</emphasis> أي الواجهة) يستعيد البرنامج إلى الواجهة. عندما يعمل البرنامج في الواجهة (سواء لأن تشغيله كان عادياً، أو تمت إعادته إلى الواجهة باستخدام <command>fg</command>)، يوقف المفتاحان <keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo> العملية مؤقتاً ويسمحان بمتابعة التحكم بسطر الأوامر. يمكن بعدها إعادة تشغيل العملية في الخلفية باستخدام <command>bg %<replaceable>job-number</replaceable></command> (اختصاراً لكلمة <foreignphrase>background</foreignphrase> أي الخلفية).
			</para>

		</section>
		 <section>
			<title>معلومات النظام: الذاكرة، مساحة الأقراص، الهوية</title>
			 <para>
				يعرض الأمر <command>free</command> معلومات عن الذاكرة؛ يعطي الأمر <command>df</command> ‏(<emphasis>disk free</emphasis>) تقاريراً عن المساحة المتوفرة على كل واحد من الأقراص المركبة على نظام الملفات. يحوّل خيار <literal>‎-h</literal> (اختصاراً للعبارة <emphasis>human readable</emphasis>) الخاص به الأحجام إلى وحدة أكثر وضوحاً (عادة ميبي بايت أو غيبي بايت). وبنفس الأسلوب، يدعم الأمر <command>free</command> الخيار <literal>‎-m</literal> والخيار <literal>‎-g</literal>، ويعرض بياناته إما بالميبي بايت أو بالغيبي بايت، على التوالي.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       used       free     shared    buffers     cached
Mem:       1028420    1009624      18796          0      47404     391804
-/+ buffers/cache:     570416     458004
Swap:      2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda2              9614084   4737916   4387796  52% /
tmpfs                   514208         0    514208   0% /lib/init/rw
udev                     10240       100     10140   1% /dev
tmpfs                   514208    269136    245072  53% /dev/shm
/dev/sda5             44552904  36315896   7784380  83% /home
</computeroutput></screen>
			 <para>
				يعرض الأمر <command>id</command> هوية المستخدم الذي يشغل الجلسة، بالإضافة إلى قائمة بالمجموعات التي ينتمي إليها. بما أن الوصول إلى بعض الملفات أو الأجهزة قد يكون محدوداً بأعضاء مجموعة ما، فقد يكون التحقق من عضوية المجموعات مفيداً.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
</screen>

		</section>

	</section>
	 <section id="sect.filesystem-hierarchy">
		<title>تنظيم البنية الشجرية لنظام الملفات</title>
		 <indexterm>
			<primary>البنية الشجرية لنظام الملفات</primary>
		</indexterm>
		 <section>
			<title>المجلد الجذر (Root)</title>
			 <para>
				نظام دبيان منظم وفق <emphasis>معيار البنية الشجرية لنظام الملفات File Hierarchy Standard</emphasis>‏ (FHS). يحدد هذا المعيار الغرض من كل مجلد. مثلا، المجلدات في المستوى الأعلى موصوفة كما يلي:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<filename>/bin/</filename>: البرامج الأساسية؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/boot/</filename>: النواة لينكس وملفات أخرى تحتاجها أثناء عملية الإقلاع المبكرة؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/dev/</filename>: ملفات الأجهزة؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/etc/</filename>: ملفات الإعدادات؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/home/</filename>: ملفات المستخدمين الشخصية؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/lib/</filename>: المكتبات الأساسية؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/media/*</filename>: نقاط ربط للأجهزة النقالة (الأقراص الليزرية، مفاتيح USB وغيرها)؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/mnt/</filename>: نقاط ربط مؤقتة؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/opt/</filename>: تطبيقات إضافية تقدمها أطراف ثالثة؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/root/</filename>: ملفات مدير النظام (المستخدم الجذر) الشخصية؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/run/</filename>: بيانات تشغيلية متطايرة لا يحتفظ النظام بها بعد إعادة الإقلاع (غير مضمن بعد في معيار FHS)؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/bin/</filename>: برمجيات النظام؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/srv/</filename>: بيانات تستخدمها المخدّمات التي يستضيفها النظام؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/tmp/</filename>: ملفات مؤقتة؛ غالبًا ما يُفرَّغ هذا المجلد عند الإقلاع؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/usr/</filename>: التطبيقات؛ هذا المجلد مقسَّم إلى <filename>bin</filename>، ‏<filename>sbin</filename>،‏ <filename>lib</filename> (وفقاً للأسلوب نفسه المتَّبع في المجلد الجذر نفسه). بالإضافة لذلك، يحوي المجلد <filename>/usr/share/</filename> بيانات مستقلة عن المعمارية. والمجلد <filename>/usr/local/</filename> مخصص ليستخدمه مدير النظام لتثبيت البرامج يدويًا دون الكتابة فوق الملفات التي يديرها نظام الحزم (<command>dpkg</command>).
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/var/</filename>: بيانات متغيرة تتحكم بها الخدمات. منها ملفات السجلات (log files)، والأرتال (queues)، و spools، والمخابئ (caches) وهكذا.
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/proc/</filename> و <filename>/sys/</filename> مخصصة للنواة لينكس (وليست جزءاً من معيار FHS). تستخدم النواة هذين المجلدين لتصدير البيانات إلى فضاء المستخدم (انظر التوضيحات حول هذا المفهوم في <xref linkend="sect.userspace-presentation" /> و<xref linkend="sect.user-space" />).
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section>
			<title>مجلد بيت المستخدم (Home)</title>
			 <para>
				إن محتويات مجلد بيت المستخدم غير مقيدة بمعيار، لكن توجد بعض العادات الجديرة بالذكر. أحدها أن مجلد بيت المستخدم غالباً ما يرمز له بالتيلدا (”~“). من المفيد أن تعلم ذلك لأن مفسرات الأوامر تستبدل التيلدا أوتوماتيكيًا بالمجلد الصحيح (عادة <filename>/home/<replaceable>user</replaceable>/</filename>).
			</para>
			 <para>
				تقليديًا، تُخزَّن ملفات إعدادات التطبيقات داخل مجلد بيت المستخدم مباشرة، لكن عادة ما تبدأ أسماؤها بنقطة (مثلاً، عميل البريد <command>mutt</command> يخزن إعداداته في <filename>‎~/.muttrc</filename>). الملفات التي يبدأ اسمها بنقطة مخفية افتراضيًا؛ ولا يسردها الأمر <command>ls</command> إلا عند استخدام الخيار <literal>-a</literal>، أما برامج إدارة الملفات الرسومية فيجب أن تطلب منها عرض الملفات المخفية.
			</para>
			 <para>
				بعض البرامج تَستخدِم عدة ملفات إعداد منظمة في مجلد واحد (مثلا، <filename>‎~/.ssh/‎</filename>). بعض التطبيقات (مثل متصفح الوب آيس ويزل) تستخدم مجلدها أيضًا لتخزين نسخة مخبئية (كاش) من الملفات المنزَّلة من الإنترنت. هذا يعني أن الأمر قد ينتهي بهذه المجلدات إلى استخدام الكثير من المساحة التخزينية.
			</para>
			 <para>
				تُخزَّن ملفات الإعداد هذه مباشرة في مجلد بيت المستخدم، ويُشار لها بالإنكليزية غالباً باسم <emphasis>dotfiles</emphasis>، وقد تكاثرت على المدى الطويل حتى ازدحمت بها هذه المجلدات كثيرًا. لحسن الحظ، هناك محاولة جماعية تحت مظلة FreeDesktop.org أفضت إلى معيار جديد يعرف باسم ”XDG Base Directory Specification“، يهدف إلى تنظيم هذه الملفات والمجلدات. ينص هذا المعيار على أن ملفات الإعداد يجب أن تُخزَّن في المجلد <filename>‎~/.config</filename>، والملفات المخبئية في <filename>‎~/.cache</filename>، وملفات البيانات في <filename>‎~/.local</filename> (أو مجلداتها الفرعية). بدأ تبني هذا المعيار ببطئ، وتسعى الكثر من التطبيقات (خصوصًا الرسومية) للالتزام به.
			</para>
			 <para>
				تعرض سطوح المكتب الرسومية محتويات المجلد <filename dir="ltr">‎~/Desktop/‎</filename> (أو <filename>~/سطح المكتب/</filename> أو مهما تكن الترجمة المناسبة للأنظمة المعدّة بلغة غير الإنكليزية) على سطح المكتب (ما يظهر على الشاشة عند إغلاق كل التطبيقات أو تصغيرها).
			</para>
			 <para>
				أخيرًا، أحيانا يخزن نظام البريد الإلكتروني البريد الوارد في مجلد <filename>‎~/Mail/‎</filename>.
			</para>

		</section>

	</section>
	 <section id="sect.computer-layers">
		<title>آلية العمل الداخلية للحاسوب: طبقات الحاسوب المختلفة</title>
		 <para>
			يتم التعامل مع الحواسيب بأسلوب تجريدي غالبًا، وتكون الطبقة الظاهرة منه أبسط بكثير من التعقيد الداخلي للحاسوب. ينتج هذا التعقيد جزئياً عن عدد القطع المكونة للحاسوب. إلا أننا نستطيع تصنيف هذه المكونات في طبقات، حيث تتعامل كل طبقة مع الطبقة التي تليها أو تسبقها فقط.
		</para>
		 <para>
			يمكن للمستخدم العادي أن يتدبر أمره دون معرفة هذه التفاصيل… طالما أن كل شيء يعمل على ما يرام. لكن عند مواجهة مشكلة مثل ”الإنترنت لا يعمل!“، فالخطوة الأولى هي تحديد الطبقة التي تسبب المشكلة. هل تعمل بطاقة الشبكة (عتاد)؟ هل تعرَّف عليها الحاسوب؟ هل تستطيع النواة لينكس رؤيتها؟ هل إعدادات الشبكة مضبوطة بشكل صحيح؟ يعزل كل واحد من هذه الأسئلة طبقة مناسبة ويركز على مصدر محتمل للمشكلة.
		</para>
		 <section id="sect.hardware">
			<title>أعمق طبقة: العتاد</title>
			 <indexterm>
				<primary>IDE</primary>
			</indexterm>
			 <indexterm>
				<primary>SCSI</primary>
			</indexterm>
			 <indexterm>
				<primary>Serial ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>Parallel ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>فاير واير</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <para>
				دعنا نبدأ بتذكرة بسيطة بأن الحاسوب هو، أولاً وقبل كل شيء، مجموعة من المكونات المادية. يوجد فيه عموما لوحة رئيسية (تعرف باسم <emphasis>اللوحة الأم</emphasis>)، عليها معالج واحد (أو أكثر)، بعض الذاكرة RAM، متحكمات الأجهزة، ومنافذ توسعة لتركيب البطاقات الإضافية (لمزيد من متحكمات الأجهزة). من أكثر هذه المتحكمات أهمية نذكر IDE (Parallel ATA)‎، وSCSI وSerial ATA، لتوصيل الأجهزة التخزينية مثل الأقراص الصلبة. من المتحكمات الأخرى USB، الذي يستطيع استضافة مجموعة متنوعة جدًا من الأجهزة (من كاميرات الوب إلى موازين الحرارة، ومن لوحات المفاتيح إلى نظم أتمتة المنازل) و IEEE 1394 (فاير واير). غالباً ما تسمح هذه المتحكمات بتوصيل عدة أجهزة ولذلك عادة ما يطلق اسم ”ناقل“ على النظام الفرعي الكامل الذي يديره المتحكم. من البطاقات الإضافية بطاقات الرسوميات (التي توصل شاشة الحاسوب إليها)، بطاقات الصوت، بطاقات الشبكات، وغيرها. في بعض اللوحات الرئيسية تكون هذه المزايا مبيتة فيها، ولا تحتاج إلى بطاقات إضافية.
			</para>
			 <sidebar> <title><emphasis>ممارسة عملية</emphasis> تحقق أن العتاد يعمل</title>
			 <para>
				قد يكون التحقق من أن قطعة عتاد تعمل بشكل صحيح معقدًا. من ناحية أخرى، فإن إثبات أن تلك القطعة لا تعمل بالغ البساطة أحيانا.
			</para>
			 <para>
				يتألف القرص الصلب من أطباق دائرة ورؤوس مغناطيسية متحركة. عند توصيل الطاقة للقرص الصلب، يعطي محرك الأطباق أزيزا مميزا. كما أنه يبدد الطاقة بشكل حرارة. بالتالي، فإن سواقة الأقراص الصلبة التي تبقى باردة وهادئة عند تشغيلها معطوبة.
			</para>
			 <para>
				تحوي بطاقات الشبكة عادة أضواء LED تبين حالة الوصلة. إذا وصِل بها سلك وكان يؤدي إلى موزع (hub) أو تحويلة (switch) شبكة فعالة، سيضيء LED واحد على الأقل. إذا لم يعمل أي LED، فإما البطاقة ذاتها، أو جهاز الشبكة، أو السلك بينهما سبب المشكلة. الخطوة التالية إذن اختبار كل مكون من هذه على حدة.
			</para>
			 <para>
				بعض البطاقات الإضافية — خصوصاً بطاقات الفيديو ثلاثي الأبعاد — تحوي أجهزة تبريد، مثل مبرِّدات معدنية أو مراوح. إذا لم تدر المروحة بالرغم من تشغيل البطاقة، فقد يكون تفسير ذلك أن البطاقة ساخنة أكثر من اللازم. هذا ينطبق أيضاً على المعالجات الأساسية الموضوعة على اللوحة الرئيسية.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.bios">
			<title>مفتاح التشغيل: BIOS أو UEFI</title>
			 <indexterm>
				<primary>BIOS</primary>
			</indexterm>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>سجل الإقلاع الرئيسي Master Boot Record (MBR)</primary>
			</indexterm>
			 <para>
				العتاد وحده غير قادر على تنفيذ مهام مفيدة دون البرمجية المناسبة التي تقوده. إن التحكم والتفاعل مع العتاد هو هدف نظام التشغيل والتطبيقات. وهذه بدورها تحتاج إلى عتاد سليم لتعمل.
			</para>
			 <para>
				هذا التضامن بين العتاد والبرمجيات لا يكون هكذا وحده. عند بدء تشغيل الحاسوب، توجد حاجة لبعض الإعداد الأولي. يقوم بيوس (BIOS) أو UEFI (في الأجهزة الأحدث) بهذا الدور، وهي برمجية مضمّنة في اللوحة الرئيسية تعمل تلقائياً عند التشغيل. مهمتها الأساسية هي البحث عن برمجيات يمكن أن تسلمها التحكم بالجهاز. في الحواسيب التي تستخدم BIOS، يشمل هذا عادة البحث عن القرص الصلب الأول الذي يحوي قطاع إقلاعي (يُعرف أيضا باسم <emphasis>سجل الإقلاع الرئيسي Master Boot Record</emphasis> أو <acronym>MBR</acronym>)، وتحميل ذلك القطاع، وتشغيله. بعد ذلك، لا يتدخل بيوس في شيء (حتى الإقلاع التالي). أما في UEFI، فالعملية تشمل فحص الأقراص بحثاًَ عن قسم EFI محدد يحوي تطبيقات EFI إضافية لتنفيذها.
			</para>
			 <sidebar> <title><emphasis>أدوات</emphasis> Setup، أداة إعداد بيوس أو UEFI</title>
			 <indexterm>
				<primary><emphasis>Setup</emphasis></primary>
			</indexterm>
			 <para>
				يحتوي بيوس (أو UEFI) أيضاً على برمجية تدعى Setup، مصممة لتسمح بإعداد النواحي المختلفة للحاسوب. تحديداً، تسمح هذه البرمجية باختيار الجهاز الإقلاعي المفضل (مثلا، القرص المرن أو سواقة الأقراص الليزرية)، ضبط ساعة النظام، وغيرها. لبدء تشغيل Setup تحتاج عادة لضغط مفتاح بُعَيْد تشغيل الحاسوب. غالباً ما يكون مفتاح <keycap>Del</keycap> أو <keycap>Esc</keycap>، وأحياناً <keycap>F2</keycap> أو <keycap>F10</keycap>. أغلب الأوقات، يتم عرض المفتاح الواجب ضغطه على الشاشة أثناء الإقلاع.
			</para>
			 </sidebar> <para>
				يحتوي القطاع الإقلاعي (أو قسم EFI) بدوره على برمجية أخرى، تدعى مُحمِّل الإقلاع (bootloader)، غرضها العثور على نظام التشغيل وبدء تشغيله. نظراً لأن محمل الإقلاع هذا ليس مضمَّناً في اللوحة الرئيسية بل يتم تحميله من القرص، يمكن أن يكون متطوراً أكثر من بيوس، ما يفسر عدم تحميل نظام التشغيل بوساطة بيوس نفسه. مثلا، يمكن لمحمَّل الإقلاع (غالباً ما يكون GRUB على نظم لينكس) أن يسرد نظم التشغيل المتوفرة وأن يطلب من المستخدم اختيار واحد منها. عادة، يتم توفير خَيَار إفتراضي يتم اختياره تلقائياً بعد انقضاء فترة زمنية معينة. يمكن أحياناً أن يختار المستخدم أيضاً إضافة خيارات لتمريرها للنواة، وهكذا. في النهاية سيُعثَر على نواة ما، وسَتُحمَّل إلى الذاكرة، ويبدأ تنفيذها.
			</para>
			 <sidebar> <title><emphasis>ملاحظة</emphasis> UEFI، بديل عصري لنظام BIOS</title>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>Secure Boot</primary>
			</indexterm>
			 <para>
				UEFI هو تطور حديث نسبياً. تدعم معظم الحواسيب الحديثة إقلاع UEFI، لكنها عادة تدعم أيضاً إقلاع BIOS على التوازي لتحقيق التوافقية الخلفية مع نظم التشغيل التي لم تجهز للاستفادة من UEFI.
			</para>
			 <para>
				يزيل هذا النظام الجديد بعض نواحي القصور في إقلاع BIOS: فباستخدام قسم مخصص، لم تعد هناك حاجة لخدع خاصة لتوسعة مُحمِّلات الإقلاع في <emphasis>سجل الإقلاع الرئيسي</emphasis> الصغير وبعد ذلك اكتشاف النواة التي ستقلع. بل الأفضل من ذلك، يستطيع UEFI الإقلاع بنواة لينكس مباشرة دون أي محمل إقلاع وسيط، إذا كانت النواة مبنية بشكل مناسب. كما أن UEFI هو الركيزة الأساسية في تقديم تقنية <emphasis>الإقلاع الآمن Secure Boot</emphasis>، وهي التقنية التي تضمن أنك لا تستخدم إلا البرمجيات التي صادق عليها صانع نظام تشغيلك.
			</para>
			 </sidebar> <para>
				بيوس (أو UEFI) مسؤول أيضاً عن التعرف على عدد من الأجهزة وتهيئتها. من الواضح أن هذا يتضمن أجهزة IDE/SATA (عادة الأقراص الصلبة وسواقات الأقراص الليزرية)، وأيضًا أجهزة PCI. غالبًا ما تُسرَد الأجهزة التي تم التعرف عليها على الشاشة أثناء عملية الإقلاع. إذا كانت هذه القائمة تختفي بسرعة، استعمل مفتاح <keycap>Pause</keycap> لتجميدها فترة تكفيك لقراءتها. أجهزة PCI التي لا تظهر هي نذير شؤم. في أسوأ الحالات، الجهاز معطوب. وفي أفضلها، الجهاز غير متوافق مع إصدارة بيوس الحالية أو غير متوافق مع اللوحة الرئيسية. فمواصفات PCI في تطور، ولا أحد يضمن أن اللوحات الرئيسية القديمة ستتوافق مع أجهزة PCI الأحدث منها.
			</para>

		</section>
		 <section id="sect.kernel">
			<title>النواة</title>
			 <para>
				يعمل كلُّ من بيوس أو UEFI ومحمّل الإقلاع لثوان قليلة فقط لكل منهما؛ لقد وصلنا الآن إلى البرمجية الأولى التي تعمل لفترة أطول، ألا وهي نواة نظام التشغيل. تتولى النواة مهمة المايسترو في الأوركسترا، وتكفل التناغم بين العتاد والبرمجيات. هذا الدور يتضمن عدة مهام منها: قيادة العتاد، إدارة العمليات، والمستخدمين والصلاحيات، ونظام الملفات، وغيرها. تقدم النواة قاعدة مشتركة لجميع البرامج الأخرى في النظام.
			</para>

		</section>
		 <section id="sect.userspace-presentation">
			<title>فضاء المستخدم</title>
			 <para>
				بالرغم من أننا نستطيع جمع كل ما يحدث خارج النواة معًا تحت اسم ”فضاء المستخدم user space“، إلا أنه يمكن تقسيم هذه الأحداث إلى طبقات برمجية. على أية حال، فإن التفاعلات بين هذه الطبقات أعقد من سابقتها، وقد لا تكون تصنيفات هذه الطبقات بالسهولة نفسها. من الشائع أن تستفيد التطبيقات من المكتبات، والتي بدورها تستعين بالنواة، وقد تدخل برامج أخرى في هذه الاتصالات، أو يمكن أن تستدعي عدة مكتبات بعضها البعض.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-role-and-tasks">
		<title>بعض المهام التي تتحكم بها النواة</title>
		 <section id="sect.hardware-drivers">
			<title>إدارة العتاد</title>
			 <para>
				النواة تهتم، أولاً وقبل كل شيء، بالتحكم بقطع العتاد، والتعرف عليها، تشغيلها عند تشغيل الحاسوب، وهكذا. كما أنها توفر واجهة برمجية مبسطة للعتاد تستفيد منها البرمجيات عالية المستوى، حتى تستثمر التطبيقات مزايا العتاد دون الحاجة للاهتمام بالتفاصيل مثل أي منفذ توسعة تم تركيب البطاقة الإضافية عليه. تُقدّم الواجهة البرمجية أيضًا طبقة عزل؛ تسمح هذه لبرمجيات الاجتماعات المرئية مثلاً، باستخدام كاميرا الوب بغض النظر عن الشركة الصانعة وطرازها. يستطيع البرنامج استخدام واجهة <emphasis>Video for Linux</emphasis>‏ (V4L) ببساطة، وسوف تترجم النواة استدعاءات دوال هذه الواجهة إلى أوامر العتاد الفعلية التي تحتاجها كاميرا الوب الخاصة المستعملة.
			</para>
			 <para>
				<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> تُصدِّر النواة العديد من التفاصيل عن العتاد الذي تعرفت عليه من خلال نظامي الملفات الوهميين <filename>/proc/</filename> و <filename>/sys/</filename>. تُلَخِّص العديد من الأدوات هذه التفاصيل. من بينها، <command>lspci</command> (في الحزمة <emphasis role="pkg">pciutils</emphasis>) التي تسرد أجهزة PCI، والأداة <command>lsusb</command> (في الحزمة <emphasis role="pkg">usbutils</emphasis>) التي تسرد أجهزة USB، وأيضًا <command>lspcmcia</command> (في الحزمة <emphasis role="pkg">pcmciautils</emphasis>) التي تسرد بطاقات PCMCIA. هذه الأدوات مفيدة جداً للتعرف على الطراز الدقيق للجهاز. بعد ذلك يمكن البحث في الوب بدقة أعلى، وبالتالي، الحصول على وثائق ذات صلة أكثر.
			</para>
			 <example>
				<title>مثال عن المعلومات التي يقدمها الأمر <command>lspci</command> والأمر <command>lsusb</command></title>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>

			</example>
			 <para>
				لهذه البرامج خيار <literal>-v</literal>، الذي يعرض معلومات مفصلة أكثر بكثير (لكن غير ضرورية عادة). أخيراً، يسرد الأمر <command>lsdev</command> (في الحزمة <emphasis role="pkg">procinfo</emphasis>) موارد التواصل التي تستهلكها الأجهزة.
			</para>
			 <para>
				تصل التطبيقات إلى الأجهزة غالباً عبر ملفات خاصة منشأة ضمن المجلد <filename>/dev/</filename> (انظر الملاحظة الجانبية <xref linkend="sidebar.special-files" />). هذه الملفات هي ملفات خاصة تمثّل سواقات الأقراص الصلبة (مثلاً، <filename>/dev/hda</filename> و <filename>/dev/sdc</filename>)، أو أقسام الأقراص (مثلاً، <filename>/dev/hda1</filename> أو <filename>/dev/sdc3</filename>)، الفأرات (<filename>/dev/input/mouse0</filename>)، لوحات المفاتيح (<filename>/dev/input/event0</filename>)، بطاقات الصوت (<filename>‎/dev/snd/*‎</filename>)، المنافذ التسلسلية (<filename>‎/dev/ttyS*‎</filename>)، وغيرها.
			</para>

		</section>
		 <section id="sect.filesystems">
			<title>نظم الملفات</title>
			 <indexterm>
				<primary>نظام ملفات</primary>
			</indexterm>
			 <indexterm>
				<primary>نظام، نظام ملفات</primary>
			</indexterm>
			 <para>
				نظم الملفات هي إحدى أهم مظاهر النواة. تدمج النظم المشابهة لنظام يونكس جميع أجهزة تخزين الملفات في شجرة واحدة، والتي تسمح للمستخدمين (والتطبيقات) بالوصول إلى البيانات ببساطة بمعرفة مكانها ضمن تلك الشجرة.
			</para>
			 <para>
				تدعى نقطة البداية لهذه الشجرة الهرمية بالجذر root، ويرمز لها بالرمز <filename>/</filename>. يستطيع هذا المجلد أن يحوي مجلدات فرعية مسماة. مثلا، يدعى مجلد <literal>home</literal> (البيت) المتفرع عن <filename>/</filename> باسم <filename>/home/</filename>. يمكن لهذا المجلد الفرعي، بدوره، أن يحوي مجلدات فرعية أخرى، وهكذا. يمكن لكل مجلد أيضًا أن يحوي ملفات، حيث يتم تخزين البيانات الفعلية. بالتالي، يشير الاسم <filename dir="ltr">/home/rmas/Desktop/hello.txt</filename> إلى الملف المسمى <literal>hello.txt</literal> المخزن في المجلد <literal>Desktop</literal> المتفرع عن المجلد <literal>rmas</literal> المتفرع عن المجلد <literal>home</literal> الموجود في الجذر. تترجم النواة بين نظام التسمية هذا وبين نظام التخزين الفعلي الفيزيائي على القرص.
			</para>
			 <para>
				بعكس نظم التشغيل الأخرى، توجد شجرة ملفات واحدة فقط، ويمكن لها أن تضم بيانات من أقراص متعددة. يستخدم أحد هذه الأقراص كجذر، والبقية ”تُربط mount“ بمجلدات في الشجرة (اسم الأمر في يونكس هو <command>mount</command>)؛ تتوفر هذه الأقراص الأخرى بعدئذ تحت ”نقاط الربط mount points“ هذه. يسمح هذا بتخزين مجلدات بيوت المستخدمين (المخزنة ضمن مجلد <filename>/home/</filename> تقليديًا) على قرص ثان، الذي سيحوي مجلدات <literal>rhertzog</literal> و <literal>rmas</literal>. بمجرد ربط القرص مع <filename>/home/</filename>، تصبح هذه المجلدات متاحة للوصول من أماكنها المعتادة، وتبقى المسارات مثل <filename dir="ltr">/home/rmas/Desktop/hello.txt</filename> صالحة.
			</para>
			 <indexterm>
				<primary><command>mkfs</command></primary>
			</indexterm>
			 <para>
				هناك صيغ عديدة لنظم الملفات، توافق الطرق العديدة التي يمكن بها تخزين البيانات فيزيائياً على الأقراص. أكثر نظم الملفات شهرة هي <emphasis>ext2</emphasis> ،<emphasis>ext3</emphasis> و <emphasis>ext4</emphasis>، لكن يوجد غيرها. مثلاً، <emphasis>vfat</emphasis> هو النظام الذي استخدمه دوس قديمًا ونظام التشغيل ويندوز، ما يسمح باستخدام الأقراص الصلبة في دبيان كما في ويندوز. على أية حال، يجب تجهيز نظام ملفات على القرص قبل أن نتمكن من ربطه مع شجرة الملفات وتعرف هذه العملية باسم ”التهيئة“. تعالج الأوامر مثل <command>mkfs.ext3</command> (حيث <command>mkfs</command> تعني <emphasis>MaKe FileSystem</emphasis> أي اصنع نظام ملفات) عملية التهيئة. تتطلب هذه الأوامر، كمتغير، ملف جهاز يمثل القسم المراد تهيئته (مثلاً، <filename dir="ltr">/dev/sda1</filename>). هذه العملية مدمرة ويجب تشغيلها مرة واحدة فقط، إلا إذا أراد المرء مسح نظام الملفات والبدء من جديد عمدًا.
			</para>
			 <para>
				بل هناك نظم ملفات شبكية أيضاً، مثل <acronym>NFS</acronym>، حيث لا تخزن البيانات على قرص محلي. بل ترسل البيانات عبر الشبكة إلى مخدم يخزنها ويسترجعها حسب الطلب. إن تجريد نظم الملفات يحمي المستخدمين من الحاجة للاهتمام بذلك: تبقى الملفات متوفرة للوصول بالطريقة الشجرية المعتادة.
			</para>

		</section>
		 <section id="sect.shared-functions">
			<title>الوظائف المشتركة</title>
			 <para>
				نظرًا لوجود عدد من الوظائف (functions) المتشابهة التي تستخدمها جميع البرمجيات، فمن المنطق تجميعها في النواة. مثلاً، تسمح الإدارة المشتركة لنظام الملفات لأي تطبيق بفتح أي ملف عبر استخدام اسمه ببساطة، دون الحاجة للاهتمام بمكان تخزين الملف فيزيائيًا. يمكن أن يخزَّن الملف في عدة شرائح مختلفة على قرص صلب، أو ينقسم بين عدة أقراص، أو حتى يخزَّن على مخدم ملفات بعيد. تستخدم التطبيقات دوال التواصل المشتركة لتبادل البيانات بغض النظر عن طريقة نقلها. مثلاً، يمكن أن تُنقَل عبر أية تركيبة من الشبكات المحلية أو اللاسلكية، أو عبر خط الهاتف الثابت.
			</para>

		</section>
		 <section id="sect.process-management">
			<title>إدارة العمليات</title>
			 <indexterm>
				<primary><emphasis>pid</emphasis></primary>
			</indexterm>
			 <para>
				العملية هي نسخة فعالة من البرنامج. تحتاج كل عملية إلى ذاكرة لتخزين كُلٍّ من البرنامج نفسه والبيانات التي يعمل عليها. النواة مسؤولة عن إنشاء وتتبع العمليات. عند تشغيل برنامج، تخصص له النواة جزءًا من الذاكرة، ثم تُحمِّل الشفرة التنفيذية من نظام الملفات إليه، بعدها تبدأ تشغيل الشِّفرة. تحتفظ النواة بمعلومات عن هذه العملية، أكثر هذه المعلومات بيانًا للعيان هو رقم تعريف العملية الذي يعرف بالرمز <emphasis>pid</emphasis> (<emphasis>مُعرِّف العملية process identifier</emphasis>).
			</para>
			 <para>
				نوى نظم التشغيل المشابهة لنظام يونكس (بما فيها لينكس)، ومعظم نظم التشغيل الحديثة الأخرى، تدعم ”تعدد المهام“. بكلمات أخرى، تسمح هذه النوى بتشغيل العديد من العمليات ”في الوقت نفسه“. في الحقيقة توجد مهمة واحدة تعمل في الوقت الواحد، لكن النواة تقسم الوقت إلى شرائح قصيرة وتشغل كل عملية بالدور. ونظراً لقصر هذه الشرائح الزمنية الشديد (من رتبة الميللي ثانية)، يتولد سراب العمليات التي تعمل على التوازي، بالرغم من أنها في الواقع فعالة فقط خلال بعض الفترات الزمنية وخاملة بقية الوقت. مهمة النواة هي ضبط آلية جدولة هذه الفترات للإبقاء على هذا الوهم، مع رفع أداء النظام الكلي إلى أعظم ما يمكن. إذا كانت الشرائح الزمنية طويلة جداً، فقد يفقد التطبيق قدرته على التجاوب بالشكل المقبول. وإذا كانت قصيرة جداً، سيضيّع النظام الوقت في التبديل بين المهام بشكل متكرر. يمكن إحكام هذه القرارات باستخدام أولويات العمليات. العمليات ذات الأولوية العالية ستعمل في شرائح زمنية أطول ولها تواتر أعلى من شرائح العمليات ذات الأولوية المنخفضة.
			</para>
			 <sidebar> <title><emphasis>ملاحظة</emphasis> الأنظمة متعددة المعالجات (ومشتقاتها)</title>
			 <para>
				هذا القيد الذي ذكرناه عن أنه لا يمكن تشغيل إلا عملية واحدة في الوقت نفسه لا ينطبق على كافة الحالات. القيد الحقيقي هو أنه يمكن أن توجد عملية واحدة <emphasis>لكل نواة معالج</emphasis> تعمل في الوقت الواحد. النظم ذات المعالجات المتعددة، أو معالجات بنوى متعددة أو ”متعددة قنوات المعالجة hyper-threaded“ تسمح لعدة عمليات بالعمل على التوازي. ومع ذلك فإن نظام تقسيم الوقت نفسه لا يزال مستخدماً، حتى يدير الحالات التي يكون فيها عدد العمليات النشطة أكبر من عدد نوى المعالجات المتوفرة. هذه هي الحالة المعتادة: فنظام التشغيل البسيط، حتى لو كان خاملاً معظم الأوقات، يكون فيه عشرات العمليات الفعالة دائماً تقريباً.
			</para>
			 </sidebar> <para>
				طبعاً، تسمح النواة بتشغيل أكثر من نسخة مستقلة من البرنامج نفسه. لكن كل واحدة منها تستطيع استخدام ذاكرتها وشرائحها الزمنية الخاصة فقط. وبذلك تبقى بياناتها مستقلة.
			</para>

		</section>
		 <section id="sect.permissions">
			<title>إدارة الصلاحيات</title>
			 <para>
				نظم التشغيل المشابهة لنظام يونكس متعددة المستخدمين أيضاً. فهي تقدم نظام إدارة صلاحيات يدعم وجود مستخدمين ومجموعات منفصلة؛ كما يسمح أيضاً بالتحكم بالأعمال الجارية اعتماداً على الصلاحيات. تدير النواة بيانات لكل عملية على حدة تسمح لها بالتحكم بالصلاحيات. في معظم الأوقات، تُعرَّفُ العملية بهوية المستخدم الذي بدأ تنفيذها. يُسْمَح لتلك العملية بتنفيذ الأفعال نفسها المتاحة لمالكها فقط. مثلاً، تحتاج محاولة فتح ملف من النواة التحقق من هوية العملية استناداً لصلاحيات الوصول (لمزيد من التفاصيل عن هذا المثال بالذات، انظر <xref linkend="sect.rights-management" />).
			</para>

		</section>

	</section>
	 <section id="sect.user-space">
		<title>فضاء المستخدم</title>
		 <indexterm>
			<primary>فضاء المستخدم</primary>
		</indexterm>
		 <indexterm>
			<primary>فضاء النواة</primary>
		</indexterm>
		 <para>
			يشير ”فضاء المستخدم user space“ إلى بيئة تشغيل العمليات العادية (مقارنة بعمليات النواة). لا يعني هذا بالضرورة أن المستخدم يُشَغِّل هذه العمليات لأن النظام القياسي يحوي في الحالة الطبيعية عدة عمليات خدمية (تعمل في الخلفية) تعمل قبل أن يفتح المستخدم أي جلسة عمل أصلاً. تعتبر العمليات الخدمية تابعة لفضاء المستخدم أيضاً.
		</para>
		 <section id="sect.process-basics">
			<title>عملية</title>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				عندما تنهي النواة طور تهيئتها، تبدأ العملية الأولى، <command>init</command>. العملية #1 وحدها نادراً ما تكون مفيدة بحد ذاتها، ونظم التشغيل المشابهة لنظام يونكس تحوي عمليات إضافية عديدة.
			</para>
			 <indexterm>
				<primary><emphasis>مشتق</emphasis></primary>
			</indexterm>
			 <para>
				أولاً، يمكن للعملية استنساخ نفسها (تعرف هذه العملية <emphasis>بالاشتقاق fork</emphasis>). تخصص النواة مساحة ذاكرة جديدة للعملية (لكن مطابقة للقديمة)، وعملية أخرى لاستخدامها. عند هذه اللحظة، الاختلاف الوحيد بين العمليتين هو رقم التعريف <emphasis>pid</emphasis>. تدعى العملية الجديدة بالعملية الابن عادة، والعملية الأصل التي لم يتغير رقم تعريفها، بالعملية الأم.
			</para>
			 <para>
				أحياناً تتابع العملية الابن قيادة حياتها الخاصة مستقلة عن الأم، باستخدام بياناتها الخاصة المنسوخة عن العملية الأم.لكن في حالات عديدة تنفذ هذه العملية الابن برنامجاً آخر، حيث تُستَبدل ذاكرتها ببساطة بذاكرة البرنامج الجديد، ويبدأ تنفيذ هذا البرنامج إلا في بعض الاستثناءات القليلة. هذه هي الآلية التي تعتمدها عملية init (العملية رقم 1) لبدء الخدمات الإضافية وتنفيذ سلسلة الإقلاع كلها. وفي لحظة ما، تبدأ إحدى العمليات من ذرية <command>init</command> واجهة رسومية حتى يسجل المستخدمون دخولهم (التسلسل الحقيقي للأحداث مشروح بمزيد من التفصيل في <xref linkend="sect.system-boot" />).
			</para>
			 <para>
				عندما تنهي العملية المهمة التي بدأت لأجلها، تنتهي العملية. بعدها تستعيد النواة الذاكرة المخصصة لهذه العملية، وتقطع عنها شرائح التشغيل الزمنية. يتم إعلام العملية الأم عن انتهاء عمليتها الابن، ما يسمح لعملية ما أن تنتظر إنهاء مهمة فوضت أحد أبنائها بها. هذا السلوك واضح للعين المجردة في مفسرات سطر الأوامر (تعرف باسم <emphasis>الأصداف shells</emphasis>). عند كتابة أمر في الصَدَفَة، لا تعود إشارة الإدخال قبل انتهاء تنفيذ الأمر. تسمح معظم الأصداف بتشغيل الأوامر في الخلفية، يكون ذلك بسهولة بإضافة <userinput>&amp;</userinput> إلى نهاية الأمر. بعدها تظهر إشارة الإدخال مجددًا مباشرة، وهذا قد يسبب مشاكل إذا كان الأمر يحتاج لإظهار بيانات خاصة به.
			</para>

		</section>
		 <section id="sect.daemons">
			<title>الجن</title>
			 <indexterm>
				<primary>جني</primary>
			</indexterm>
			 <indexterm>
				<primary>جني</primary>
			</indexterm>
			 <para>
				”الجني daemon“ هو عملية تُشغِّلها متتالية الإقلاع آلياً. يبقى نشطاً (في الخلفية) لتنفيذ مهام صيانة أو تقديم خدمات للعمليات الأخرى. هذه ”المهمة في الخلفية“ عشوائية في الحقيقة، ولا تقابل أي شيء محدد من وجهة نظر النظام. هي مجرد عمليات، شبيهة بالعمليات الأخرى تماماً، التي تعمل بدورها عندما تحين حصتها من الوقت. هذا التمييز موجود في لغة البشر فقط: أية عملية تعمل بدون أي تفاعل مع المستخدم (على الأخص، بدون واجهة رسومية) يقال أنها تعمل ”في الخلفية“ أو أنها ”جني“.
			</para>
			 <sidebar> <title><emphasis>مصطلحات</emphasis> جني، شيطان، مصطلح ازدرائي؟</title>
			 <para>
				بالرغم من أن مصطلح <emphasis>daemon</emphasis> (جني) يتشاطر أصله اليوناني مع <emphasis>demon</emphasis> (شيطان)، إلا أن الأول لا يتضمن شراً شيطانياً، بالعكس، يجب التفكير به على أنه نوع من الأرواح المساعدة. هذا التفريق معقّد بما يكفي في الإنكليزية، بل هو أسوأ في لغات أخرى حيث تستخدم الكلمة نفسها للدلالة على المعنيين.
			</para>
			 </sidebar> <para>
				هناك شرح مفصل لمجموعة من الجن أمثال هؤلاء في <xref linkend="unix-services" />.
			</para>

		</section>
		 <section id="sect.ipc">
			<title>التواصل بين العمليات</title>
			 <indexterm>
				<primary>IPC</primary>
			</indexterm>
			 <indexterm>
				<primary>التواصل بين العمليات</primary>
			</indexterm>
			 <para>
				إن العملية المعزولة، سواء كانت خدمة أو تطبيقًا تفاعليًا، نادراً ما تكون مفيدة بحد ذاتها، وهو السبب وراء وجود العديد من أساليب التواصل بين العمليات المنفصلة، سواء لتبادل البيانات أو لتتحكم واحدتها بالأخرى. المصطلح العام للتعبير عن هذا المفهوم هو <emphasis>التواصل بين العمليات inter-process communication</emphasis>، أو IPC اختصاراً.
			</para>
			 <para>
				أبسط نظام IPC هو استخدام الملفات. تكتب العملية التي ترغب بإرسال البيانات بياناتها في ملف (له اسم معروف مسبقًا)، في حين تحتاج العملية المتلقية إلى فتح الملف وقراءة محتوياته فقط.
			</para>
			 <indexterm>
				<primary><emphasis>أنبوب</emphasis></primary>
			</indexterm>
			 <para>
				في الحالات التي لا ترغب فيها بتخزين البيانات على القرص، يمكنك استخدام <emphasis>أنبوب</emphasis>، وهو ببساطة عنصر له نهايتان؛ البايتات المكتوبة في إحداهما، تكون مقروءة عند النهاية الأخرى. إذا تَحكَّمَت بالنهايتين عمليتين منفصلتين، يصبح الأنبوب بمثابة قناة تواصل بين العمليات بسيطة وسهلة الاستعمال. يمكن تصنيف الأنابيب في زمرتين: الأنابيب المسمّاة، والأنابيب المجهولة. يُمثَّل الأنبوب المسمى بمدخلة في نظام الملفات (مع أن البيانات المرسلة لا تُخزَّن هناك)، بحيث يمكن لكلا العمليتين فتحه بشكل مستقل إذا كان موقع الأنبوب المسمى معروفًا من قبل. في الحالات التي تكون فيها العمليات التي تتواصل فيما بينها مرتبطة ببعضها (مثلاً، عملية أم مع ابنها)، يمكن للعملية الأم أيضًا إنشاء أنبوب مجهول قبل الاشتقاق، وسيرثه الابن. ستتمكن كلا العمليتان عندئذ من تبدل البيانات فيما بينهما باستخدام الأنبوب دون الحاجة لنظام الملفات.
			</para>
			 <sidebar> <title><emphasis>ممارسة عملية</emphasis> مثال شامل</title>
			 <para>
				دعنا نناقش ما يحدث عند تنفيذ أمر معقد (<emphasis>خط أنابيب</emphasis>) من الصَدَفة بشيء من التفصيل. نحن نفترض أن لدينا عملية <command>bash</command> (صَدَفة المستخدم القياسية على دبيان)، لها <emphasis>pid</emphasis> يساوي4374؛ وفي هذه الصدفة، سنكتب الأمر : <command>ls | sort</command> .
			</para>
			 <para>
				تُفَسِّر الصدفة أولاً الأمر المكتوب فيها. في حالتنا، ستفهم أن هناك برنامجين (<command>ls</command> و <command>sort</command>)، مع مجرى بيانات يتدفق من أحدهما إلى الآخر (ممثل بالمحرف <userinput>|</userinput>، الذي يدعى <emphasis>بالأنبوب</emphasis>). تنشئ <command>bash</command> أولاً أنبوبًا مجهولاً (الذي يكون مبدئيًا ضمن عملية <command>bash</command> نفسها).
			</para>
			 <para>
				تستنسخ الصدفة نفسها؛ هذا يؤدي إلى عملية <command>bash</command> جديدة، لها <emphasis>pid</emphasis> رقمه 4521 (<emphasis>pid</emphasis> هي مجرد أرقام، وعادة لا يكون لها أي معنى محدد). ترث العملية #4521 الأنبوب، ما يعني أنها قادرة على الكتابة في نهاية ”الإدخال“ الخاصة به؛ تُعيد <command>bash</command> توجيه مجرى خرجها القياسي إلى دخل هذا الأنبوب. بعدها تنفذ البرنامج <command>ls</command> (وتستبدل نفسها به)، الذي يسرد محتويات المجلد الحالي. نظراً لأن <command>ls</command> يكتب على مجرى خرجه القياسي، وقد أعيد توجيه هذا المجرى مسبقًا، سيتم إرسال النتائج عمليًا إلى الأنبوب.
			</para>
			 <para>
				تحدث عملية مشابهة للأمر الثاني حيث تستنسخ <command>bash</command> نفسها ثانية، منتجة عملية <command>bash</command> جديدة لها pid يساوي 4522. ولأنها أيضًا ابنة للعملية #4374، فسوف ترث الأنبوب؛ بعدها تربط <command>bash</command> دخلها القياسي إلى خرج الأنبوب، بعدها تنفذ الأمر <command>sort</command> (وتستبدل نفسها به)، الذي يرتب دخله ويعرض النتائج.
			</para>
			 <para>
				الآن اكتملت قطع الأحجية كلها: يكتب <command>ls</command> قائمة الملفات الموجودة في المجلد الحالي في الأنبوب؛ يقرأ <command>sort</command> هذه القائمة، يرتبها أبجديًا، ويعرض النتائج. تنتهي العمليات ذات الأرقام #4521 و #4522 بعدها، والعملية #4374 (التي كانت تنتظرهم أثناء الحدث)، تتابع التحكم وتعرض إشارة الإدخال للسماح للمستخدم بكتابة أمر جديد.
			</para>
			 </sidebar> <para>
				لا تستخدم جميع الاتصالات بين العمليات لنقل البيانات بينها مع ذلك. في العديد من الحالات، المعلومات التي نحتاج إرسالها رسائل تحكم مثل ”أوقف التنفيذ مؤقتاً“ أو ”تابع التنفيذ“. يقدم يونكس (ولينكس) آلية تُعرَف باسم <emphasis>الإشارات signals</emphasis>، تستطيع العملية من خلالها إرسال إشارة محددة ببساطة (تختارها من قائمة من الإشارات المعرفة مسبقاً) إلى عملية أخرى. المتطلب الوحيد هو معرفة <emphasis>pid</emphasis> العملية الهدف.
			</para>
			 <para>
				هناك آليات أخرى للاتصالات الأكثر تعقيدًا، تسمح للعملية بالسماح لفتح الوصول إلى الذاكرة المخصصة لها، أو مشاركة جزء منها مع العمليات الأخرى. عندئذ يمكن استخدام ذلك الجزء المشترك من الذاكرة المشتركة لنقل البيانات بين العمليات المشتركة عليه.
			</para>
			 <para>
				أخيرًا، يمكن أن تساعد الاتصالات الشبكية بالتواصل بين العمليات؛ يمكن أن توجد هذه العمليات على حواسيب مختلفة، وقد تبعد عن بعضها آلاف الكيلومترات.
			</para>
			 <para>
				من العادي جداً لأي نظام نموذجي مشابه لنظام يونكس أن يستخدم جميع هذه الآليات بدرجات متفاوتة.
			</para>

		</section>
		 <section id="sect.libraries">
			<title>المكتبات</title>
			 <indexterm>
				<primary>مكتبة (للدوال)</primary>
			</indexterm>
			 <para>
				تلعب مكتبات الدوال دوراً حيويًا في نظم التشغيل المشابه لنظام يونكس. ليست هذه المكتبات برامج تامة، نظرًا لعدم إمكانية تنفيذها منفردة، لكنها مجموعة من فتات الكود التي يمكن للبرامج القياسية استخدامه. من المكتبات الشائعة، نذكر ما يلي:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						مكتبة C القياسية (<emphasis>glibc</emphasis>)، التي تحوي الوظائف الأساسية مثل دوال فتح الملفات أو الاتصالات الشبكية، وغيرها مما يسهل التفاعل مع النواة؛
					</para>

				</listitem>
				 <listitem>
					<para>
						المكتبات الرسومية، Gtk+‎ وQt، تسمح للعديد من البرامج بإعادة استخدام العناصر الرسومية التي توفرها؛
					</para>

				</listitem>
				 <listitem>
					<para>
						مكتبة <emphasis>libpng</emphasis>، التي تسمح بتحميل، وتفسير وحفظ الصور بصيغة PNG.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				بفضل هذه المكتبات، تستطيع البرامج إعادة استخدام الكود. يصبح تطوير البرامج أبسط، لأن عدة تطبيقات تستطيع استخدام الدوال نفسها. بما أن تطوير المكتبات يتم بأيد أشخاص مختلفين عادة، فإن التطوير الكلي للنظام أقرب إلى فلسفة يونكس التاريخية.
			</para>
			 <sidebar> <title><emphasis>ثقافة</emphasis> أسلوب يونكس: مهمة واحدة في الوقت الواحد</title>
			 <para>
				أحد المفاهيم الأساسية التي تحدد عائلة نظم تشغيل يونكس هو أن كل أداة يجب أن تفعل شيئا واحدا فقط، وأن تتمه بشكل جيد؛ يمكن للتطبيقات بعد ذلك إعادة استخدام هذه الأدوات لبناء منطق أكثر تقدّما فوقها. يمكن أن نرى هذه الفلسفة في العديد من النظم الشبيهة بنظام يونكس. قد تكون سكربتات الصدفة أفضل مثال: فهي تجمع متتاليات معقدة لأدوات بسيطة جدًا (مثل <command>grep</command> و<command>wc</command> و<command>sort</command> و<command>uniq</command> وهكذا). يمكن أن نرى تطبيقاً آخر لهذه الفلسفة في مكتبات الكود: تسمح مكتبة <emphasis>libpng</emphasis> بقراءة وكتابة صور PNG، بخيارات مختلفة وبأساليب متنوعة، لكنها لا تفعل غير ذلك؛ لا توجد إمكانية لتضمين دوال تعرض الصور أو تحررها.
			</para>
			 </sidebar> <para>
				بالإضافة إلى ذلك، غالباً ما يُشَار إلى هذه المكتبات على أنها ”مكتبات مشتركة“، لأن النواة تستطيع تحميلها إلى الذاكرة مرة واحدة فقط، حتى لو كانت عدة عمليات تستخدم المكتبة نفسها في الوقت ذاته. يسمح هذا بتوفير الذاكرة، مقارنة مع الحالة (النظرية) النقيضة لها حيث يتم تحميل كود المكتبة بعدد العمليات التي تستخدمها.
			</para>

		</section>

	</section>
</appendix>

