<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.5. فضاء المستخدم</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-ar-MA-1.0-1" /><meta
        name="keywords"
        content="بيوس, نواة, يونكس, عملية, بنية شجرية, الأوامر الأساسية" /><link
        rel="home"
        href="index.html"
        title="دفتر مدير دبيان" /><link
        rel="up"
        href="short-remedial-course.html"
        title="ملحق B. دورة تذكيرية قصيرة" /><link
        rel="prev"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. بعض المهام التي تتحكم بها النواة" /><link
        rel="next"
        href="backcover.html"
        title="ملحق C. دفتر مدير دبيان" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/ar-MA/stable/sect.user-space.html" /></head><body
      dir="rtl"><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>السابق</strong></a></li><li
          class="home">دفتر مدير دبيان</li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>التالي</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.user-space"></a>B.5. فضاء المستخدم</h2></div></div></div><a
          id="id-1.21.8.2"
          class="indexterm"></a><a
          id="id-1.21.8.3"
          class="indexterm"></a><div
          class="para">
			يشير ”فضاء المستخدم user space“ إلى بيئة تشغيل العمليات العادية (مقارنة بعمليات النواة). لا يعني هذا بالضرورة أن المستخدم يُشَغِّل هذه العمليات لأن النظام القياسي يحوي في الحالة الطبيعية عدة عمليات خدمية (تعمل في الخلفية) تعمل قبل أن يفتح المستخدم أي جلسة عمل أصلاً. تعتبر العمليات الخدمية تابعة لفضاء المستخدم أيضاً.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.process-basics"></a>B.5.1. عملية</h3></div></div></div><a
            id="id-1.21.8.5.2"
            class="indexterm"></a><div
            class="para">
				عندما تنهي النواة طور تهيئتها، تبدأ العملية الأولى، <code
              class="command">init</code>. العملية #1 وحدها نادراً ما تكون مفيدة بحد ذاتها، ونظم التشغيل المشابهة لنظام يونكس تحوي عمليات إضافية عديدة.
			</div><a
            id="id-1.21.8.5.4"
            class="indexterm"></a><div
            class="para">
				أولاً، يمكن للعملية استنساخ نفسها (تعرف هذه العملية <span
              class="emphasis"><em>بالاشتقاق fork</em></span>). تخصص النواة مساحة ذاكرة جديدة للعملية (لكن مطابقة للقديمة)، وعملية أخرى لاستخدامها. عند هذه اللحظة، الاختلاف الوحيد بين العمليتين هو رقم التعريف <span
              class="emphasis"><em>pid</em></span>. تدعى العملية الجديدة بالعملية الابن عادة، والعملية الأصل التي لم يتغير رقم تعريفها، بالعملية الأم.
			</div><div
            class="para">
				أحياناً تتابع العملية الابن قيادة حياتها الخاصة مستقلة عن الأم، باستخدام بياناتها الخاصة المنسوخة عن العملية الأم.لكن في حالات عديدة تنفذ هذه العملية الابن برنامجاً آخر، حيث تُستَبدل ذاكرتها ببساطة بذاكرة البرنامج الجديد، ويبدأ تنفيذ هذا البرنامج إلا في بعض الاستثناءات القليلة. هذه هي الآلية التي تعتمدها عملية init (العملية رقم 1) لبدء الخدمات الإضافية وتنفيذ سلسلة الإقلاع كلها. وفي لحظة ما، تبدأ إحدى العمليات من ذرية <code
              class="command">init</code> واجهة رسومية حتى يسجل المستخدمون دخولهم (التسلسل الحقيقي للأحداث مشروح بمزيد من التفصيل في <a
              class="xref"
              href="unix-services.html#sect.system-boot">قسم 9.1, “إقلاع النظام”</a>).
			</div><div
            class="para">
				عندما تنهي العملية المهمة التي بدأت لأجلها، تنتهي العملية. بعدها تستعيد النواة الذاكرة المخصصة لهذه العملية، وتقطع عنها شرائح التشغيل الزمنية. يتم إعلام العملية الأم عن انتهاء عمليتها الابن، ما يسمح لعملية ما أن تنتظر إنهاء مهمة فوضت أحد أبنائها بها. هذا السلوك واضح للعين المجردة في مفسرات سطر الأوامر (تعرف باسم <span
              class="emphasis"><em>الأصداف shells</em></span>). عند كتابة أمر في الصَدَفَة، لا تعود إشارة الإدخال قبل انتهاء تنفيذ الأمر. تسمح معظم الأصداف بتشغيل الأوامر في الخلفية، يكون ذلك بسهولة بإضافة <strong
              class="userinput"><code>&amp;</code></strong> إلى نهاية الأمر. بعدها تظهر إشارة الإدخال مجددًا مباشرة، وهذا قد يسبب مشاكل إذا كان الأمر يحتاج لإظهار بيانات خاصة به.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.daemons"></a>B.5.2. الجن</h3></div></div></div><a
            id="id-1.21.8.6.2"
            class="indexterm"></a><a
            id="id-1.21.8.6.3"
            class="indexterm"></a><div
            class="para">
				”الجني daemon“ هو عملية تُشغِّلها متتالية الإقلاع آلياً. يبقى نشطاً (في الخلفية) لتنفيذ مهام صيانة أو تقديم خدمات للعمليات الأخرى. هذه ”المهمة في الخلفية“ عشوائية في الحقيقة، ولا تقابل أي شيء محدد من وجهة نظر النظام. هي مجرد عمليات، شبيهة بالعمليات الأخرى تماماً، التي تعمل بدورها عندما تحين حصتها من الوقت. هذا التمييز موجود في لغة البشر فقط: أية عملية تعمل بدون أي تفاعل مع المستخدم (على الأخص، بدون واجهة رسومية) يقال أنها تعمل ”في الخلفية“ أو أنها ”جني“.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>مصطلحات</em></span> جني، شيطان، مصطلح ازدرائي؟</strong></p></div></div></div><div
              class="para">
				بالرغم من أن مصطلح <span
                class="emphasis"><em>daemon</em></span> (جني) يتشاطر أصله اليوناني مع <span
                class="emphasis"><em>demon</em></span> (شيطان)، إلا أن الأول لا يتضمن شراً شيطانياً، بالعكس، يجب التفكير به على أنه نوع من الأرواح المساعدة. هذا التفريق معقّد بما يكفي في الإنكليزية، بل هو أسوأ في لغات أخرى حيث تستخدم الكلمة نفسها للدلالة على المعنيين.
			</div></div><div
            class="para">
				هناك شرح مفصل لمجموعة من الجن أمثال هؤلاء في <a
              class="xref"
              href="unix-services.html">فصل 9, <em>خدمات يونكس</em></a>.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ipc"></a>B.5.3. التواصل بين العمليات</h3></div></div></div><a
            id="id-1.21.8.7.2"
            class="indexterm"></a><a
            id="id-1.21.8.7.3"
            class="indexterm"></a><div
            class="para">
				إن العملية المعزولة، سواء كانت خدمة أو تطبيقًا تفاعليًا، نادراً ما تكون مفيدة بحد ذاتها، وهو السبب وراء وجود العديد من أساليب التواصل بين العمليات المنفصلة، سواء لتبادل البيانات أو لتتحكم واحدتها بالأخرى. المصطلح العام للتعبير عن هذا المفهوم هو <span
              class="emphasis"><em>التواصل بين العمليات inter-process communication</em></span>، أو IPC اختصاراً.
			</div><div
            class="para">
				أبسط نظام IPC هو استخدام الملفات. تكتب العملية التي ترغب بإرسال البيانات بياناتها في ملف (له اسم معروف مسبقًا)، في حين تحتاج العملية المتلقية إلى فتح الملف وقراءة محتوياته فقط.
			</div><a
            id="id-1.21.8.7.6"
            class="indexterm"></a><div
            class="para">
				في الحالات التي لا ترغب فيها بتخزين البيانات على القرص، يمكنك استخدام <span
              class="emphasis"><em>أنبوب</em></span>، وهو ببساطة عنصر له نهايتان؛ البايتات المكتوبة في إحداهما، تكون مقروءة عند النهاية الأخرى. إذا تَحكَّمَت بالنهايتين عمليتين منفصلتين، يصبح الأنبوب بمثابة قناة تواصل بين العمليات بسيطة وسهلة الاستعمال. يمكن تصنيف الأنابيب في زمرتين: الأنابيب المسمّاة، والأنابيب المجهولة. يُمثَّل الأنبوب المسمى بمدخلة في نظام الملفات (مع أن البيانات المرسلة لا تُخزَّن هناك)، بحيث يمكن لكلا العمليتين فتحه بشكل مستقل إذا كان موقع الأنبوب المسمى معروفًا من قبل. في الحالات التي تكون فيها العمليات التي تتواصل فيما بينها مرتبطة ببعضها (مثلاً، عملية أم مع ابنها)، يمكن للعملية الأم أيضًا إنشاء أنبوب مجهول قبل الاشتقاق، وسيرثه الابن. ستتمكن كلا العمليتان عندئذ من تبدل البيانات فيما بينهما باستخدام الأنبوب دون الحاجة لنظام الملفات.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ممارسة عملية</em></span> مثال شامل</strong></p></div></div></div><div
              class="para">
				دعنا نناقش ما يحدث عند تنفيذ أمر معقد (<span
                class="emphasis"><em>خط أنابيب</em></span>) من الصَدَفة بشيء من التفصيل. نحن نفترض أن لدينا عملية <code
                class="command">bash</code> (صَدَفة المستخدم القياسية على دبيان)، لها <span
                class="emphasis"><em>pid</em></span> يساوي4374؛ وفي هذه الصدفة، سنكتب الأمر : <code
                class="command">ls | sort</code> .
			</div><div
              class="para">
				تُفَسِّر الصدفة أولاً الأمر المكتوب فيها. في حالتنا، ستفهم أن هناك برنامجين (<code
                class="command">ls</code> و <code
                class="command">sort</code>)، مع مجرى بيانات يتدفق من أحدهما إلى الآخر (ممثل بالمحرف <strong
                class="userinput"><code>|</code></strong>، الذي يدعى <span
                class="emphasis"><em>بالأنبوب</em></span>). تنشئ <code
                class="command">bash</code> أولاً أنبوبًا مجهولاً (الذي يكون مبدئيًا ضمن عملية <code
                class="command">bash</code> نفسها).
			</div><div
              class="para">
				تستنسخ الصدفة نفسها؛ هذا يؤدي إلى عملية <code
                class="command">bash</code> جديدة، لها <span
                class="emphasis"><em>pid</em></span> رقمه 4521 (<span
                class="emphasis"><em>pid</em></span> هي مجرد أرقام، وعادة لا يكون لها أي معنى محدد). ترث العملية #4521 الأنبوب، ما يعني أنها قادرة على الكتابة في نهاية ”الإدخال“ الخاصة به؛ تُعيد <code
                class="command">bash</code> توجيه مجرى خرجها القياسي إلى دخل هذا الأنبوب. بعدها تنفذ البرنامج <code
                class="command">ls</code> (وتستبدل نفسها به)، الذي يسرد محتويات المجلد الحالي. نظراً لأن <code
                class="command">ls</code> يكتب على مجرى خرجه القياسي، وقد أعيد توجيه هذا المجرى مسبقًا، سيتم إرسال النتائج عمليًا إلى الأنبوب.
			</div><div
              class="para">
				تحدث عملية مشابهة للأمر الثاني حيث تستنسخ <code
                class="command">bash</code> نفسها ثانية، منتجة عملية <code
                class="command">bash</code> جديدة لها pid يساوي 4522. ولأنها أيضًا ابنة للعملية #4374، فسوف ترث الأنبوب؛ بعدها تربط <code
                class="command">bash</code> دخلها القياسي إلى خرج الأنبوب، بعدها تنفذ الأمر <code
                class="command">sort</code> (وتستبدل نفسها به)، الذي يرتب دخله ويعرض النتائج.
			</div><div
              class="para">
				الآن اكتملت قطع الأحجية كلها: يكتب <code
                class="command">ls</code> قائمة الملفات الموجودة في المجلد الحالي في الأنبوب؛ يقرأ <code
                class="command">sort</code> هذه القائمة، يرتبها أبجديًا، ويعرض النتائج. تنتهي العمليات ذات الأرقام #4521 و #4522 بعدها، والعملية #4374 (التي كانت تنتظرهم أثناء الحدث)، تتابع التحكم وتعرض إشارة الإدخال للسماح للمستخدم بكتابة أمر جديد.
			</div></div><div
            class="para">
				لا تستخدم جميع الاتصالات بين العمليات لنقل البيانات بينها مع ذلك. في العديد من الحالات، المعلومات التي نحتاج إرسالها رسائل تحكم مثل ”أوقف التنفيذ مؤقتاً“ أو ”تابع التنفيذ“. يقدم يونكس (ولينكس) آلية تُعرَف باسم <span
              class="emphasis"><em>الإشارات signals</em></span>، تستطيع العملية من خلالها إرسال إشارة محددة ببساطة (تختارها من قائمة من الإشارات المعرفة مسبقاً) إلى عملية أخرى. المتطلب الوحيد هو معرفة <span
              class="emphasis"><em>pid</em></span> العملية الهدف.
			</div><div
            class="para">
				هناك آليات أخرى للاتصالات الأكثر تعقيدًا، تسمح للعملية بالسماح لفتح الوصول إلى الذاكرة المخصصة لها، أو مشاركة جزء منها مع العمليات الأخرى. عندئذ يمكن استخدام ذلك الجزء المشترك من الذاكرة المشتركة لنقل البيانات بين العمليات المشتركة عليه.
			</div><div
            class="para">
				أخيرًا، يمكن أن تساعد الاتصالات الشبكية بالتواصل بين العمليات؛ يمكن أن توجد هذه العمليات على حواسيب مختلفة، وقد تبعد عن بعضها آلاف الكيلومترات.
			</div><div
            class="para">
				من العادي جداً لأي نظام نموذجي مشابه لنظام يونكس أن يستخدم جميع هذه الآليات بدرجات متفاوتة.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.libraries"></a>B.5.4. المكتبات</h3></div></div></div><a
            id="id-1.21.8.8.2"
            class="indexterm"></a><div
            class="para">
				تلعب مكتبات الدوال دوراً حيويًا في نظم التشغيل المشابه لنظام يونكس. ليست هذه المكتبات برامج تامة، نظرًا لعدم إمكانية تنفيذها منفردة، لكنها مجموعة من فتات الكود التي يمكن للبرامج القياسية استخدامه. من المكتبات الشائعة، نذكر ما يلي:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						مكتبة C القياسية (<span
                    class="emphasis"><em>glibc</em></span>)، التي تحوي الوظائف الأساسية مثل دوال فتح الملفات أو الاتصالات الشبكية، وغيرها مما يسهل التفاعل مع النواة؛
					</div></li><li
                class="listitem"><div
                  class="para">
						المكتبات الرسومية، Gtk+‎ وQt، تسمح للعديد من البرامج بإعادة استخدام العناصر الرسومية التي توفرها؛
					</div></li><li
                class="listitem"><div
                  class="para">
						مكتبة <span
                    class="emphasis"><em>libpng</em></span>، التي تسمح بتحميل، وتفسير وحفظ الصور بصيغة PNG.
					</div></li></ul></div><div
            class="para">
				بفضل هذه المكتبات، تستطيع البرامج إعادة استخدام الكود. يصبح تطوير البرامج أبسط، لأن عدة تطبيقات تستطيع استخدام الدوال نفسها. بما أن تطوير المكتبات يتم بأيد أشخاص مختلفين عادة، فإن التطوير الكلي للنظام أقرب إلى فلسفة يونكس التاريخية.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ثقافة</em></span> أسلوب يونكس: مهمة واحدة في الوقت الواحد</strong></p></div></div></div><div
              class="para">
				أحد المفاهيم الأساسية التي تحدد عائلة نظم تشغيل يونكس هو أن كل أداة يجب أن تفعل شيئا واحدا فقط، وأن تتمه بشكل جيد؛ يمكن للتطبيقات بعد ذلك إعادة استخدام هذه الأدوات لبناء منطق أكثر تقدّما فوقها. يمكن أن نرى هذه الفلسفة في العديد من النظم الشبيهة بنظام يونكس. قد تكون سكربتات الصدفة أفضل مثال: فهي تجمع متتاليات معقدة لأدوات بسيطة جدًا (مثل <code
                class="command">grep</code> و<code
                class="command">wc</code> و<code
                class="command">sort</code> و<code
                class="command">uniq</code> وهكذا). يمكن أن نرى تطبيقاً آخر لهذه الفلسفة في مكتبات الكود: تسمح مكتبة <span
                class="emphasis"><em>libpng</em></span> بقراءة وكتابة صور PNG، بخيارات مختلفة وبأساليب متنوعة، لكنها لا تفعل غير ذلك؛ لا توجد إمكانية لتضمين دوال تعرض الصور أو تحررها.
			</div></div><div
            class="para">
				بالإضافة إلى ذلك، غالباً ما يُشَار إلى هذه المكتبات على أنها ”مكتبات مشتركة“، لأن النواة تستطيع تحميلها إلى الذاكرة مرة واحدة فقط، حتى لو كانت عدة عمليات تستخدم المكتبة نفسها في الوقت ذاته. يسمح هذا بتوفير الذاكرة، مقارنة مع الحالة (النظرية) النقيضة لها حيث يتم تحميل كود المكتبة بعدد العمليات التي تستخدمها.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>السابق</strong>B.4. بعض المهام التي تتحكم بها النواة</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>أعلى</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>البداية</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>التالي</strong>ملحق C. دفتر مدير دبيان</a></li></ul></body></html>
