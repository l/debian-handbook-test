<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="packaging-system" lang="es-ES">
	<chapterinfo>
		 <keywordset>
			<keyword>Paquete binario</keyword>
			 <keyword>Paquete fuente</keyword>
			 <keyword>dpkg</keyword>
			 <keyword>dependencias</keyword>
			 <keyword>conflicto</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Sistema de paquetes: herramientas y principios fundamentales</title>
	 <highlights> <para>
		Como un administrador de un sistema Debian generalmente manejará paquetes <filename>.deb</filename> ya que contienen unidades funcionales consistentes (aplicaciones, documentación, etc.) facilitando su instalación y mantenimiento. Por lo tanto, es buena idea saber qué son y cómo utilizarlos.
	</para>
	 </highlights> <para>
		Este capítulo describe la estructura y los contenidos de paquetes «binarios» y «fuente». Los primeros son archivos <filename>.deb</filename> para utilizar directamente con <command>dpkg</command> mientras que los últimos contienen el código fuente así como las instrucciones para crear los paquetes binarios.
	</para>
	 <section id="sect.binary-package-structure">
		<title>Estructura de un paquete binario</title>
		 <indexterm>
			<primary>paquete</primary>
			<secondary>binario</secondary>
		</indexterm>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <para>
			El formato del paquete Debian fue diseñado para que su contenido pueda ser extraído en cualquier sistema Unix que tenga los programas clásicos <command>ar</command>, <command>tar</command> y <command>gzip</command> (a veces <command>xz</command> o <command>bzip2</command>). Esta propiedad aparentemente trivial es importante para portabilidad y recuperación en caso de desastres.
		</para>
		 <para>
			Imagine por ejemplo que eliminó por error el programa <command>dpkg</command> y que, por lo tanto, ya no puede instalar paquetes Debian. Siendo <command>dpkg</command> un paquete en sí mismo pareciera como que su sistema estuviese condenado... afortunadamente conoce el formato de un paquete y puede descargar el archivo <filename>.deb</filename> para el paquete <emphasis role="pkg">dpkg</emphasis> e instalarlo manualmente (revise el recuadro <xref linkend="sidebar.dpkg-apt-ar" />). Si por cualquier motivo o problema uno o más de los programas <command>ar</command>, <command>tar</command> o <command>gzip</command>/<command>xz</command>/<command>bzip2</command> desaparecieron sólo necesitará copiar el programa faltante de otro sistema (ya que cada uno de ellos funciona de forma completamente autónoma una simple copia bastará). Si su sistema sufre algun evento de peor fortuna e incluso esto no funciona (¿quizás a su sistema le falten bibliotecas a más bajo nivel?), debería intentar la versión estática del programa <command>busybox</command> (incluido en el paquete <emphasis role="pkg">busybox-static</emphasis>), el cual es inclusive más autocontenido y proporciona órdenes como <command>busybox ar</command>, <command>busybox tar</command> y <command>busybox gunzip</command>.
		</para>
		 <sidebar id="sidebar.dpkg-apt-ar"> <title><emphasis>HERRAMIENTAS</emphasis> <command>dpkg</command>, <command>APT</command> y <command>ar</command></title>
		 <indexterm>
			<primary><command>dpkg</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <indexterm>
			<primary>APT</primary>
		</indexterm>
		 <para>
			<command>dpkg</command> es el programa que maneja los archivos <filename>.deb</filename>, en particular los extrae, analiza y descomprime.
		</para>
		 <para>
			<command>APT</command> es un grupo de programas que permite la ejecución de modificaciones de más alto nivel al sistema: instalar o eliminar un paquete (mientras mantiene dependencias satisfechas), actualizar el sistema, listar los paquetes disponibles, etc.
		</para>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <para>
			En cuanto al programa <command>ar</command>, permite manejar los archivos del mismo nombre: <command>ar t <replaceable>compendio</replaceable></command> muestra la lista de archivos contenidos en el compendio, <command>ar x <replaceable>compendio</replaceable></command> extrae dichos archivos al directorio actual, <command>ar d <replaceable>compendio</replaceable> <replaceable>archivo</replaceable></command> elimina un archivo del compendio, etc. Su página de manual (<citerefentry><refentrytitle>ar</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry>) documenta todas sus funcionalidades. <command>ar</command> es una herramienta muy rudimentaria que un administrador Unix sólo utilizaría en raras ocasiones, pero utilizarían rutinariamente <command>tar</command>, un programa de manejo de archivos y compendios más evolucionado. Es por eso que es sencillo restaurar <command>dpkg</command> en el caso de que sea eliminado por error. Sólo necesita descargar el paquete Debian y extraer el contenido del archivo <filename>data.tar.gz</filename> en la raíz del sistema (<filename>/</filename>):
		</para>
		 
<screen>
<computeroutput># </computeroutput><userinput>ar x dpkg_1.17.23_amd64.deb</userinput>
<computeroutput># </computeroutput><userinput>tar -C / -p -xzf data.tar.gz</userinput></screen>
		 </sidebar> <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Notación de páginas de manual</title>
		 <para>
			Los principiantes pueden encontrar confusas las referencias como «<citerefentry><refentrytitle>ar</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry>» en la literatura. Generalmente esta es una forma conveniente de referirse a la página de manual titulada <literal>ar</literal> en la sección 1.
		</para>
		 <para>
			Algunas veces se utiliza esta notación para eliminar ambigüedades, por ejemplo para distinguir entre el programa <command>printf</command>, que también puede indicarse como <citerefentry><refentrytitle>printf</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry>, y la función <function>printf</function> del lenguaje de programación C, que también puede indicarse como <citerefentry><refentrytitle>printf</refentrytitle>
			<manvolnum>3</manvolnum></citerefentry>.
		</para>
		 <para>
			El <xref linkend="solving-problems" /> discute las páginas de manual con más detalles (revise la <xref linkend="sect.manual-pages" />).
		</para>
		 </sidebar> <para>
			Estos son los contenidos de un archivo <filename>.deb</filename>:
		</para>
		 
<screen><computeroutput>$ </computeroutput><userinput>ar t dpkg_1.17.23_amd64.deb</userinput>
<computeroutput>debian-binary
control.tar.gz
data.tar.gz
$ </computeroutput><userinput>ar x dpkg_1.17.23_amd64.deb</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>control.tar.gz  data.tar.gz  debian-binary  dpkg_1.17.23_amd64.deb
$ </computeroutput><userinput>tar tzf data.tar.gz | head -n 15</userinput>
<computeroutput>./
./var/
./var/lib/
./var/lib/dpkg/
./var/lib/dpkg/parts/
./var/lib/dpkg/info/
./var/lib/dpkg/alternatives/
./var/lib/dpkg/updates/
./etc/
./etc/logrotate.d/
./etc/logrotate.d/dpkg
./etc/dpkg/
./etc/dpkg/dpkg.cfg.d/
./etc/dpkg/dpkg.cfg
./etc/alternatives/
$ </computeroutput><userinput>tar tzf control.tar.gz</userinput>
<computeroutput>./
./conffiles
./postinst
./md5sums
./prerm
./preinst
./control
./postrm
$ </computeroutput><userinput>cat debian-binary</userinput>
<computeroutput>2.0</computeroutput></screen>
		 <para>
			Como puede ver, el compendio <command>ar</command> de un paquete Debian contiene tres archivos:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					<filename>debian-binary</filename>. Es un archivo de texto que indica simplemente la versión del archivo <filename>.deb</filename> utilizado (en 2015: versión 2.0).
				</para>

			</listitem>
			 <listitem>
				<para>
					<filename>control.tar.gz</filename>. Este compendio contiene toda la metainformación disponible, como el nombre y la versión del paquete. Alguna de esta metainformación le permite a las herramientas de gestión de paquetes determinar si es posible instalar o desinstalarlo, por ejemplo según la lista de paquetes que ya se encuentran en el equipo.
				</para>

			</listitem>
			 <listitem>
				<para>
					<filename>data.tar.gz</filename>. Este compendio contiene todos los archivos a extraerse del paquete; aquí es donde están almacenados los archivos ejecutables, la documentación etc. Algunos paquetes pueden utilizar otros formatos de compresión, en los que el archivo tendrá otro nombre (<filename>data.tar.bz2</filename> para bzip2m <filename>data.tar.xz</filename> para XZ).
				</para>

			</listitem>

		</itemizedlist>

	</section>
	 <section id="sect.package-meta-information">
		<title>Metainformación de un paquete</title>
		 <indexterm>
			<primary>metainformación de un paquete</primary>
		</indexterm>
		 <indexterm>
			<primary>paquete</primary>
			<secondary>metainformación</secondary>
		</indexterm>
		 <para>
			Un paquete Debian no es sólo un compendio de archivos a instalar. Es parte de un todo más grande y describe su relación con otros paquetes Debian (dependencias, conflictos, sugerencias). También provee scripts que permiten la ejecución de órdenes en diferentes etapas del ciclo de vida del paquete (instalación, eliminación, actualización). Estos datos utilizados por las herramientas de gestión de paquetes no son parte del software empaquetado, son lo que se denomina «metainformación» (información sobre otra información) dentro del paquete.
		</para>
		 <section id="sect.control">
			<title>Descripción: el archivo <filename>control</filename></title>
			 <indexterm>
				<primary>metainformación de un paquete</primary>
			</indexterm>
			 <indexterm>
				<primary>paquete</primary>
				<secondary>metainformación</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>control</filename></primary>
			</indexterm>
			 <para>
				Este archivo utiliza una estructura similar a las cabeceras de email (definidas en RFC 2822). Por ejemplo el archivo <filename>control</filename> de <emphasis role="pkg">apt</emphasis> se ve de la siguiente forma:
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>apt-cache show apt</userinput>
<computeroutput>Package: apt
Version: 1.0.9.6
Installed-Size: 3788
Maintainer: APT Development Team &lt;deity@lists.debian.org&gt;
Architecture: amd64
Replaces: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0)
Depends: libapt-pkg4.12 (&gt;= 1.0.9.6), libc6 (&gt;= 2.15), libgcc1 (&gt;= 1:4.1.1), libstdc++6 (&gt;= 4.9), debian-archive-keyring, gnupg
Suggests: aptitude | synaptic | wajig, dpkg-dev (&gt;= 1.17.2), apt-doc, python-apt
Conflicts: python-apt (&lt;&lt; 0.7.93.2~)
Breaks: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0)
Description-en: commandline package manager
 This package provides commandline tools for searching and
 managing as well as querying information about packages
 as a low-level access to all features of the libapt-pkg library.
 .
 These include:
  * apt-get for retrieval of packages and information about them
    from authenticated sources and for installation, upgrade and
    removal of packages together with their dependencies
  * apt-cache for querying available information about installed
    as well as installable packages
  * apt-cdrom to use removable media as a source for packages
  * apt-config as an interface to the configuration settings
  * apt-key as an interface to manage authentication keys
Description-md5: 9fb97a88cb7383934ef963352b53b4a7
Tag: admin::package-management, devel::lang:ruby, hardware::storage,
 hardware::storage:cd, implemented-in::c++, implemented-in::perl,
 implemented-in::ruby, interface::commandline, network::client,
 protocol::ftp, protocol::http, protocol::ipv6, role::program,
 role::shared-lib, scope::application, scope::utility, sound::player,
 suite::debian, use::downloading, use::organizing, use::searching,
 works-with::audio, works-with::software:package, works-with::text
Section: admin
Priority: important
Filename: pool/main/a/apt/apt_1.0.9.6_amd64.deb
Size: 1107560
MD5sum: a325ccb14e69fef2c50da54e035a4df4
SHA1: 635d09fcb600ec12810e3136d51e696bcfa636a6
SHA256: 371a559ce741394b59dbc6460470a9399be5245356a9183bbeea0f89ecaabb03</computeroutput></screen>
			 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> RFC — estándares de internet</title>
			 <indexterm>
				<primary>RFC</primary>
			</indexterm>
			 <indexterm>
				<primary>Request For Comments</primary>
			</indexterm>
			 <para>
				RFC son las siglas de «pedido de comentarios» («Request For Comments»). Un RFC es generalmente un documento técnico que describe lo que se convertirá en un estándar de internet. Antes de convertirse en estándar y congelarse, éstos estándares son enviados para revisión pública (de ahí su nombre). La IETF («Internet Engineering Task Force»: grupo de trabajo de ingeniería de internet) decide sobre la evolución del estado de estos documentos (estándares propuestos, borradores de estándar o estándar).
			</para>
			 <para>
				RFC 2026 define el proceso de estadarización de protocolos de internet. <ulink type="block" url="http://www.faqs.org/rfcs/rfc2026.html" />
			</para>
			 </sidebar> <section>
				<title>Dependencias: el campo <literal>Depends</literal></title>
				 <indexterm>
					<primary>dependencia</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Depends</literal>, campo de cabecera</primary>
				</indexterm>
				 <indexterm>
					<primary>paquete</primary>
					<secondary>dependencia</secondary>
				</indexterm>
				 <para>
					Las dependencias están definidas en el campo <literal>Depends</literal> en la cabecera del paquete. Esta es una lista de condiciones a cumplir para que el paquete funcione correctamente — las herramientas como <command>apt</command> utilizan esta información para instalar las bibliotecas necesarias, las versiones apropiadas, para satisfacer las dependencias del paquete a instalar. Para cada dependencia es posible restringir el rango de versiones que cumplen dicha condición. En otras palabras, es posible expresar el hecho de que necesitamos el paquete <emphasis role="pkg">libc6</emphasis> en una versión igual o mayor a «2.15» (escrito como «<command>libc6 (&gt;= 2.15)</command>». Los operadores de comparación de versiones son los siguientes:
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							<command>&lt;&lt;</command>: menor que;
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&lt;=</command>: menor o igual que;
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>=</command>: igual a (note que «<literal>2.6.1</literal>» no es igual a «<literal>2.6.1-1</literal>»);
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&gt;=</command>: mayor o igual que;
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&gt;&gt;</command>: mayor que.
						</para>

					</listitem>

				</itemizedlist>
				 <para>
					En una lista de condiciones a cumplir, la coma sirve como separador. Debe interpretársela como un «y» lógico. En las condiciones una barra vertical («|») expresa un «o» lógico (es un «o» inclusivo, no uno exclusivo que significa «o uno o el otro»). Tiene más prioridad que «y» y puede ser utilizado tantas veces como sea necesario. Por lo tanto, la dependencia «(A o B) y C» se escribe <command>A | B, C</command>. Por otro lado, la expresión «A o (B y C)» debe escribirse «(A o B) y (A o C)» ya que el campo <literal>Depends</literal> no permite paréntesis que cambien el orden de las prioridades entre los operadores lógicos «o» e «y». Por lo tanto, se lo escribiría <command>A | B, A | C</command>. <ulink type="block" url="http://www.debian.org/doc/debian-policy/ch-relationships.html" />
				</para>
				 <indexterm>
					<primary>metapaquete</primary>
				</indexterm>
				 <para>
					El sistema de dependencias es un buen mecanismo para garantizar el funcionamiento de un programa, pero tiene otro uso con los «metapaquetes». Éstos son paquetes vacíos que sólo describen dependencias. Facilitan la instalación de un grupo consistente de programas preseleccionados por el desarrollador del metapaquete; como tal <command>apt install <replaceable>metapaquete</replaceable></command> instalará automáticamente todos estos programas utilizando las dependencias del metapaquete. Los paquetes <emphasis role="pkg">gnome</emphasis>, <emphasis role="pkg">kde-full</emphasis> y <emphasis role="pkg">linux-image-amd64</emphasis>, por ejemplo, son metapaquetes.
				</para>
				 <sidebar> <title><emphasis>NORMA DEBIAN</emphasis> <literal>Pre-Depends</literal>, un <literal>Depends</literal> más exigentes</title>
				 <indexterm>
					<primary><literal>Pre-Depends</literal> campo de cabecera</primary>
				</indexterm>
				 <indexterm>
					<primary>predependencia</primary>
				</indexterm>
				 <para>
					Las «predependencias», listadas en el campo «<literal>Pre-Depends</literal>» de las cabeceras de un paquete, completan las dependencias normales; la sintaxis es idéntica. Una dependencia normal indica que el paquete en cuestión debe ser desempaquetado y configurado antes de la configuración del paquete que declara la dependencia. Una predependencia estipula que el paquete en cuestión debe ser desempaquetado y configurado antes de la ejecución del script de preinstalación del paquete que declara la predependencia, es decir antes de su instalación.
				</para>
				 <para>
					Una predependencia es muy exigente para <command>apt</command> porque agrega una restricción estricta en el orden de instalación de los paquetes. Por lo tanto se intenta evitar predependencias a menos que sea absolutamente necesario. Es recomendable aún consultar a otros desarrolladores en <email>debian-devel@lists.debian.org</email> antes de agregar una predependencia. Generalmente es posible encontrar otra solución para evitarlo.
				</para>
				 </sidebar> <sidebar> <title><emphasis>NORMA DEBIAN</emphasis> Campos <literal>Recommends</literal>, <literal>Suggests</literal> y <literal>Enhances</literal></title>
				 <indexterm>
					<primary><literal>Recommend</literal>, campo de cabecera</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Suggests</literal>, campo de cabecera</primary>
				</indexterm>
				 <para>
					Los campos <literal>Recommends</literal> y <literal>Suggests</literal> describen dependencias que no son obligatorias. Las dependencias «recomendadas», las más importantes, mejoran considerablemente la funcionalidad ofrecida por el paquete pero no son indispensables para su funcionamiento. Las dependencias «sugeridas», de importancia secundaria, indica que ciertos paquetes complementarían y aumentarían su utilidad pero es perfectamente razonable instalar uno sin los otros.
				</para>
				 <para>
					Siempre debería instalar los paquetes «recomendados» a menos que sepa exactamente que no los necesita. Por el contrario, no es necesario instalar paquetes «sugeridos» a menos que sepa porqué los necesita.
				</para>
				 <indexterm>
					<primary><literal>Enhances</literal>, campo de cabecera</primary>
				</indexterm>
				 <para>
					El campo <literal>Enhances</literal> también describe una sugerencia pero en un contexto diferente. Está ubicado en el paquete sugerido, no en el paquete que se beneficia de la sugerencia. Por lo tanto, todos los agregados, plugins y otras extensiones de un programa pueden aparecer en la lista de sugerencias relacionadas al software. Si bien existe desde hace varios años, este último campo es generalmente ignorado por programas como <command>apt</command> o <command>synaptic</command>. Su propósito es que una sugerencia en el campo <literal>Enhances</literal> aparezca ante el usuario además de las sugerencias tradicionales — que se encuentran en el campo <literal>Suggests</literal>.
				</para>
				 </sidebar>
			</section>
			 <section>
				<title>Conflictos: el campo <literal>Conflicts</literal></title>
				 <indexterm>
					<primary>conflictos</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Conflicts</literal>, campo de cabecera</primary>
				</indexterm>
				 <indexterm>
					<primary>paquete</primary>
					<secondary>conflicto</secondary>
				</indexterm>
				 <para>
					El campo <literal>Conflicts</literal> indica que un paquete no puede instalarse simultáneamente con otro. La razón más común es que ambos paquetes contienen un archivo con el mismo nombre, proveen el mismo servicio en el mismo puerto TCP o estorban el funcionamiento del otro.
				</para>
				 <para>
					<command>dpkg</command> se negará a instalar un paquete si genera un conflicto con un paquete ya instalado, excepto si el nuevo paquete especifica que «reemplazará» al paquete instalado en cuyo caso <command>dpkg</command> elegirá reemplazar el paquete existente con el nuevo. <command>apt</command> siempre seguirá sus instrucciones: si desea instalar un nuevo paquete ofrecerá automáticamente desinstalar el paquete que genera problemas.
				</para>

			</section>
			 <section>
				<title>Incompatibilidades: el campo <literal>Breaks</literal></title>
				 <indexterm>
					<primary>incompatibilidades</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Breaks</literal>, campo de cabecera</primary>
				</indexterm>
				 <indexterm>
					<primary>paquete</primary>
					<secondary>incompatibilidad</secondary>
				</indexterm>
				 <para>
					El campo <literal>Breaks</literal> tiene un efecto similar al del campo <literal>Conflicts</literal> pero con un significado especial. Indica que la instalación de un paquete «romperá» otro paquete (o versiones particulares del mismo). En general, esta incompatibilidad entre dos paquetes es temporal y la relación <literal>Breaks</literal> se refiere específicamente a las versiones incompatibles.
				</para>
				 <para>
					<command>dpkg</command> se negará a instalar un paquete que rompe un paquete ya instalado y <command>apt</command> intentará resolver el problema actualizando a una nueva versión el paquete que se rompería (que se asume estaría arreglado y, por lo tanto, sería compatible nuevamente).
				</para>
				 <para>
					Este tipo de situaciones pueden ocurrir en casos de actualizaciones que no sean compatibles con versiones anteriores: este es el caso si una nueva versión ya no funciona con la versión anterior y causa un mal funcionamiento en otros programas si no se toman medidas especiales. El campo <literal>Breaks</literal> previene que el usuario se tope con estos problemas.
				</para>

			</section>
			 <section>
				<title>Elementos provistos: el campo <literal>Provides</literal></title>
				 <indexterm>
					<primary><literal>Provides</literal>, campo de cabecera</primary>
				</indexterm>
				 <para>
					Este campo introduce el concepto interesante de un «paquete virtual». Tiene muchos roles pero hay dos particularmente importantes. El primero consiste en utilizar un paquete virtual para asociar un servicio genérico con él (el paquete «provee» el servicio). El segundo indica que un paquete reemplaza completamente a otro y, para esos propósitos, también puede satisfacer las dependencias que otros satisfacen. Es posible, entonces, crear un paquete substituto sin tener que utilizar el mismo nombre de paquete.
				</para>
				 <sidebar> <title><emphasis>VOCABULARIO</emphasis> Metapaquete y paquete virtual</title>
				 <indexterm>
					<primary>metapaquete</primary>
				</indexterm>
				 <indexterm>
					<primary>virtual</primary>
					<secondary>paquete virtual</secondary>
				</indexterm>
				 <indexterm>
					<primary>paquete virtual</primary>
				</indexterm>
				 <para>
					Es esencial distinguir los metapaquetes de los paquetes virtuales. Los primeros son paquetes reales (incluyendo archivos <filename>.deb</filename>) cuyo único propósito es expresar dependencias.
				</para>
				 <para>
					Los paquetes virtuales, por el otro lado, no existen físicamente; sólo son un modo de identificar paquetes reales basados en criterios lógicos y comunes (servicios provistos, compatibilidades con un programa estándar o un paquete preexistentes, etc.).
				</para>
				 </sidebar> <section>
					<title>Proveyendo un «servicio»</title>
					 <para>
						Discutamos con más detalles el primer caso con un ejemplo: se dice que todos los servicios de correo, como <emphasis role="pkg">postfix</emphasis> o <emphasis role="pkg">sendmail</emphasis> «proveen» el paquete virtual <emphasis role="pkg">mail-transport-agent</emphasis>. Por lo tanto, cualquier paquete que necesite este servicio para funcionar (por ejemplo, un gestor de listas de correo como <emphasis role="pkg">smartlist</emphasis> o <emphasis role="pkg">sympa</emphasis>) simplemente indican en sus dependencias que requieren de <emphasis role="pkg">mail-transport-agent</emphasis> en lugar de especificar una lista larga y aún incompleta de posibles soluciones (por ejemplo <command>postfix | sendmail | exim4 | ...</command>). Lo que es más, es inútil instalar dos servidores de correo en el mismo equipo, por lo que cada uno de estos paquetes declara un conflicto con el paquete virtual <emphasis role="pkg">mail-transport-agent</emphasis>. Un conflicto de un paquete con sí mismo es ignorado por el sistema, pero esta técnica prohibirá la instalación de dos servidores de correo simultáneamente.
					</para>
					 <sidebar> <title><emphasis>NORMA DEBIAN</emphasis> Lista de paquetes virtuales</title>
					 <indexterm>
						<primary>virtual</primary>
						<secondary>paquete virtual</secondary>
					</indexterm>
					 <para>
						Para que un paquete virtual sea útil, todos deben estar de acuerdo en su nombre. Es porque eso que están estandarizados en la Normativa Debian. Esta lista incluye, entre otros, <emphasis role="pkg">mail-transport-agent</emphasis> para servidores de correo, <emphasis role="pkg">c-compiler</emphasis> para compiladores del lenguaje de programación C, <emphasis role="pkg">www-browser</emphasis> para navegadores web, <emphasis role="pkg">httpd</emphasis> para servidores web, <emphasis role="pkg">ftp-server</emphasis> para servidores FTP, <emphasis role="pkg">x-terminal-emulator</emphasis> para emuladores de terminal en modo gráfico (<command>xterm</command>) y <emphasis role="pkg">x-window-manager</emphasis> para gestores de ventanas.
					</para>
					 <para>
						Puede encontrar la lista completa en la web. <ulink type="block" url="http://www.debian.org/doc/packaging-manuals/virtual-package-names-list.txt" />
					</para>
					 </sidebar>
				</section>
				 <section>
					<title>Intercambio con otro paquete</title>
					 <para>
						El campo <literal>Provides</literal> es tambien interesante cuando se incluye el contenido del paquete en un paquete más grande. Por ejemplo, el módulo Perl <emphasis role="pkg">libdigest-md5-perl</emphasis> era un módulo opcional en Perl 5.6 y fue integrado como estándar en Perl 5.8 (y versiones siguientes, como 5.20 que está presente en <emphasis role="distribution">Jessie</emphasis>). Como tal, el paquete <emphasis role="pkg">perl</emphasis> desde su versión 5.8 declara <literal>Provides: libdigest-md5-perl</literal> para que se cumplan las dependencias de este paquete si el usuario tiene Perl 5.8 (o una versión más reciente). El paquete <emphasis role="pkg">libdigest-md5-perl</emphasis> en sí fue eventualmente eliminado ya que no tenía propósito cuando las versiones antiguas de Perl fueron retiradas.
					</para>
					 <figure>
						<title>Utilización del campo <literal>Provides</literal> para no romper dependencias</title>
						 <mediaobject>
							<imageobject>
								<imagedata fileref="images/virtual-package.png" format="PNG" width="50%" />
							</imageobject>

						</mediaobject>

					</figure>
					 <para>
						Esta funcionalidad es muy útil ya que nunca es posible anticipar los caprichos del desarrollo y es necesario que sea posible adaptarse a cambios de nombre y otros reemplazos automáticos de software obsoleto.
					</para>
					 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Perl, un lenguaje de programación</title>
					 <indexterm>
						<primary>Perl</primary>
					</indexterm>
					 <indexterm>
						<primary>CPAN</primary>
					</indexterm>
					 <para>
						Perl (lenguaje práctico de extración y reportes — «Practical Extraction and Report Language») es un lenguaje de programación muy popular. Tiene muchos módulos listos para utilizar que cubren un vasto espectro de aplicaciones y que son distribuidos por los servidores CPAN (red exhaustiva de compendios Perl — «Comprehensive Perl Archive Network»), una amplia red de paquetes Perl. <ulink type="block" url="http://www.perl.org/" /> <ulink type="block" url="http://www.cpan.org/" />
					</para>
					 <para>
						Dado que es un lenguaje interpretado, un programa escrito en Perl no requiere compilación antes de su ejecución. Por esto se los llama «scripts Perl».
					</para>
					 </sidebar>
				</section>
				 <section>
					<title>Limitaciones anteriores</title>
					 <para>
						Los paquetes virtuales solían sufrir algunas limitaciones, la más importante de ellas era la ausencia de un número de versión. Volviendo al ejemplo anterior, una dependencia como <literal>Depends: libdigest-md5-perl (&gt;= 1.6)</literal> nunca será considerada como satisfecha aún en presencia de Perl 5.10 — cuando de hecho es altamente probable que esté satisfecha. Sin conocimientos de esto el sistema de paquetes selecciona la opción menos riesgosa y asume que las versiones no coinciden.
					</para>
					 <para>
						Esta limitación ha sido levantada <emphasis role="pkg">dpkg</emphasis> 1.17.11 y ya no es más relevante en Jessie. Los paquetes pueden asignar una una versión a los paquetes virtuales que proveen con una dependencia como <literal>Provides: libdigest-md5-perl (= 1.8)</literal>.
					</para>

				</section>

			</section>
			 <section>
				<title>Reemplazo de archivos: el campo <literal>Replaces</literal></title>
				 <indexterm>
					<primary>reemplazo</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Replaes</literal>, campo de cabecera</primary>
				</indexterm>
				 <indexterm>
					<primary>paquete</primary>
					<secondary>reemplazo</secondary>
				</indexterm>
				 <para>
					El campo <literal>Replaces</literal> indica que el paquete contiene archivos que también están presentes en otro paquete, pero que el paquete tiene el derecho legítimo de reemplazarlo. Sin esta especificación, <command>dpkg</command> fallará indicando que no puede sobreescribir los archivos de otro paquete (técnicamente es posible forzar que lo haga con la opción <literal>--force-overwrite</literal>, pero no se considera una operación estándar). Esto permite identificar problemas potenciales y requiere que el desarrollador estudie el hecho antes de decidir agregar dicho campo.
				</para>
				 <para>
					El uso de este campo está justificado cuando cambian los nombres de los paquetes o cuando un paquete está incluido en otro. Esto sucede cuando el desarrollador decide distribuir los archivos de otra forma entre los varios paquetes binarios producidos del mismo paquete fuente: un archivo reemplazado no le corresponde al paquete antiguo, sólo al nuevo.
				</para>
				 <para>
					Si todos los archivos de un paquete instalado fueron reemplazados, se considera que se eliminó el paquete. Finalmente, este campo incita que <command>dpkg</command> elimie los paquetes reemplazados en casos de conflictos.
				</para>
				 <sidebar id="sidebar.debtags"> <title><emphasis>YENDO MÁS ALLÁ</emphasis> El campo <literal>Tag</literal></title>
				 <para>
					En el ejemplo anterior de <emphasis role="pkg">apt</emphasis> podemos ver la presencia de un campo que no hemos descripto todavía, el campo <literal>Tag</literal>. Este campo no describe la relación entre paquetes sino que es una forma simple de categorizar un paquete en una taxonomía temática. Esta clasificación de paquetes según varios criterios (tipos de interfaz, lenguaje de programación, dominio de la aplicación, etc.) ha estado disponible en Debian por mucho tiempo. Sin embargo, no todos los paquetes tienen etiquetas («tag») precisas y no está integrado aún en todas las herramientas de Debian; <command>aptitude</command> muestra estas etiquetas y permite utilizarlas como criterio de búsqueda. Para aquellos que evitan los criterios de búsqueda de <command>aptitude</command>, el siguiente sitio web le permite navegar por la base de datos de etiquetas: <ulink type="block" url="http://debtags.alioth.debian.org/" />
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.configuration-scripts">
			<title>Scripts de configuración</title>
			 <indexterm>
				<primary><filename>postinst</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>preinst</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>postrm</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>prerm</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>control.tar.gz</filename></primary>
			</indexterm>
			 <para>
				Además del archivo <filename>control</filename>, el compendio <filename>control.tar.gz</filename> de cada paquete Debian puede contener una cantidad de scripts que serán ejecutados por <command>dpkg</command> en diferentes etapas del procesamiento de un paquete. La Normativa Debian describe los casos posibles en detalle, especificando los scripts que serán llamados y los argumentos que recibirán. Estas secuencias pueden ser complicadas ya que si falla uno de los scripts <command>dpkg</command> intentará volver a un estado satisfactorio cancelando la instalación o eliminación en curso (siempre que sea posible).
			</para>
			 <sidebar> <title><emphasis>YENDO MÁS ALLÁ</emphasis> Base de datos de <command>dpkg</command></title>
			 <indexterm>
				<primary><filename>/var/lib/dpkg/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>dpkg</primary>
				<secondary>base de datos</secondary>
			</indexterm>
			 <para>
				Todos los scripts de configuración para los paquetes instalados se almacenan en el directorio <filename>/var/lib/dpkg/info/</filename> en forma de un archivo con el nombre del paquete como prefijo. Este directorio también incluye un archivo con la extensión <filename>.list</filename> para cada paquete que contiene una lista de los archivos que pertenecen a dicho paquete.
			</para>
			 <para>
				El archivo <filename>/var/lib/dpkg/status</filename> contiene una serie de bloques de datos (en el famoso formato de cabeceras de correo, RFC 2822) que describen el estado de cada paquete. La información del archivo <filename>control</filename> también es duplicada allí.
			</para>
			 </sidebar> <para>
				En general, se ejecuta el script <filename>preinst</filename> antes de la instalación del paquete, y <filename>postinst</filename> luego. De la misma forma, se invoca <filename>prerm</filename> antes de la eliminación de un paquete y <filename>postrm</filename> luego. Actualizar un paquete es equivalente a eliminar la versión anterior e instalar la nueva. No es posible describir en detalle todos los escenarios posibles aquí, pero discutiremos los dos más comunes: instalación/actualización y eliminación.
			</para>
			 <sidebar> <title><emphasis>PRECAUCIÓN</emphasis> Nombres simbólicos de los scripts</title>
			 <para>
				Las secuencias descriptas en esta sección llaman scripts de configuración por sus nombres específicos, como <command>old-prerm</command> o <command>new-postinst</command>. Ellos son, respectivamente, el script <command>prerm</command> en la versión antigua del paquete (instalada antes de la actualización) y el script <command>postinst</command> en la nueva versión (instalada en la actualización).
			</para>
			 </sidebar> <sidebar> <title><emphasis>SUGERENCIA</emphasis> Diagramas de estado</title>
			 <para>
				Manoj Srivastava realizó estos diagramas explicando cómo <command>dpkg</command> llama a estos scripts de configuración. El proyecto Debian Women («Mujeres Debian») también desarrolló diagramas similares; más simples de entender pero menos completos. <ulink type="block" url="https://people.debian.org/~srivasta/MaintainerScripts.html" /> <ulink type="block" url="https://wiki.debian.org/MaintainerScripts" />
			</para>
			 </sidebar> <section>
				<title>Instalación y actualización</title>
				 <indexterm>
					<primary><command>dpkg</command></primary>
					<secondary>operación interna</secondary>
				</indexterm>
				 <para>
					Esto es lo que ocurre durante una instalación (o actualización):
				</para>
				 <orderedlist>
					<listitem>
						<para>
							En una actualización, <command>dpkg</command> ejecuta <command>old-prerm upgrade <replaceable>nueva-versión</replaceable></command>.
						</para>

					</listitem>
					 <listitem>
						<para>
							En una actualización <command>dpkg</command> ejecuta luego <command>new-preinst upgrade <replaceable>antigua-versión</replaceable></command>; para una primera instalación ejecuta <command>new-preinst install</command>. También puede agregar la versión anterior en el último parámetro si el paquete ya ha sido instalada y eliminada desde entonces (pero no purgada, se mantuvieron los archivos de configuración).
						</para>

					</listitem>
					 <listitem>
						<para>
							Se descomprimen los archivos del nuevo paquete. Si un archivo ya existe, es reemplazado pero se guarda una copia de respaldo de forma temporal.
						</para>

					</listitem>
					 <listitem>
						<para>
							En una actualización, <command>dpkg</command> ejecuta <command>old-postrm upgrade <replaceable>nueva-versión</replaceable></command>.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> actualiza toda su información interna (lista de archivos, scripts de configuración, etc.) y elimina los respaldos de los archivos reemplazados. Este es el punto sin retorno: <command>dpkg</command> ya no tiene acceso a todos los elementos necesarios para volver al estado anterior.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> actualizará los archivos de configuración, pidiéndole al usuario que decida si no es capaz de administrar esta tarea automáticamente. Los detalles de este proceso son discutidos en la <xref linkend="sect.conffiles" />.
						</para>

					</listitem>
					 <listitem>
						<para>
							Finalmente, <command>dpkg</command> configura el paquete ejecutando <command>new-postinst configure <replaceable>última-versión-configurada</replaceable></command>.
						</para>

					</listitem>

				</orderedlist>

			</section>
			 <section>
				<title>Eliminación de un paquete</title>
				 <para>
					Esto es lo que sucede durante la eliminación de un paquete:
				</para>
				 <orderedlist>
					<listitem>
						<para>
							<command>dpkg</command> ejecuta <command>prerm remove</command>.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> elimina todos los archivos del paquete, con la excepción de los archivos de configuración y scripts de configuración.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> ejecuta <command>postrm remove</command>. Se eliminan todos los scripts de configuración excepto <filename>postrm</filename>. Si el usuario no utilizó la opción «purgar» («purge»), el proceso termina aquí.
						</para>

					</listitem>
					 <listitem>
						<para>
							Para eliminar completamente un paquete (con la orden <command>dpkg --purge</command> o <command>dpkg -P</command>), los archivos de configuración también son eliminados junto con una cantidad de copias (<filename>*.dpkg-tmp</filename>, <filename>*.dpkg-old</filename>, <filename>*.dpkg-new</filename>) y archivos temporales; luego <command>dpkg</command> ejecuta <command>postrm purge</command>.
						</para>

					</listitem>

				</orderedlist>
				 <sidebar> <title><emphasis>VOCABULARIO</emphasis> Purgar, una eliminación completa</title>
				 <indexterm>
					<primary>purga de un paquete</primary>
				</indexterm>
				 <para>
					Cuando un paquete de Debian es eliminado, se mantienen los archivos de configuración para facilitar una posible reinstalación. De la misma forma, se mantienen normalmente los datos generados por un demonio (como el contenido de un servidor de directorio LDAP o el contenido de una base de datos de un servidor SQL).
				</para>
				 <para>
					Para eliminar todos los datos asociados con un paquete es necesario «purgar» el paquete con la orden <command>dpkg -P <replaceable>paquete</replaceable></command>, <command>apt-get remove --purge <replaceable>paquete</replaceable></command> o <command>aptitude purge <replaceable>paquete</replaceable></command>.
				</para>
				 <para>
					Dada la naturaleza definitiva de tal eliminación de datos, un purgado no se debe tomar a la ligera.
				</para>
				 </sidebar> <indexterm>
					<primary><filename>config</filename>, script <command>debconf</command></primary>
				</indexterm>
				 <para>
					Los cuatro scripts que aparecen detallados anteriormente se complementan con un script <filename>config</filename> provisto por los paquetes que utilizan <command>debconf</command> para adquirir información de configuración del usuario. Durante la instalación este script define en detalle las preguntas realizadas por <command>debconf</command>. Se graban las respuestas en la base de datos de <command>debconf</command> para futuras referencias. Generalmente <command>apt</command> ejecuta el script antes de instalar los paquetes uno por uno para agrupar las preguntas y realizarlas todas al usuario al comienzo del proceso. Los scripts de pre y postinstalación pueden utilizar esta información para operar según los deseos del usuario.
				</para>
				 <sidebar> <title><emphasis>HERRAMIENTA</emphasis> <command>debconf</command></title>
				 <indexterm>
					<primary><command>debconf</command></primary>
				</indexterm>
				 <para>
					Se creó <command>debconf</command> para resolver un problema recurrente en Debian. Todos los paquetes Debian que no pueden funcionar sin un mínimo de configuración solían hacer preguntas ejecutando <command>echo</command> y <command>read</command> en scripts <filename>postinst</filename> (y otros scripts similares). Pero esto también resultaba que durante una instalación o actualización grande el usuario debía mantenerse frente al equipo para responder a las varias preguntas que podían surgir en cualquier momento. Se han evitado la mayoría de todas estas interacciones manuales gracias a la herramienta <command>debconf</command>.
				</para>
				 <para>
					<command>debconf</command> tiene muchas funcionalidades interesantes: requiere que el desarrollador especifique la interacción con el usuario, permite localización de todas las cadenas mostradas a los usuarios (se guardan todas las traducciones en el archivo <filename>templates</filename> describiendo las interacciones), tiene diferentes interfaces para presentar las preguntas al usuario (modo texto, modo gráfico, no interactivo) y permite la creación de una base de datos central de respuestas para compartir la misma configuración entre varios equipos... pero la más importante es que ahora es posible presentar al usuario todas las preguntas juntas antes de comenzar un largo proceso de instalación o actualización. Mientras el sistema se encarga de la instalación por sí mismo, el usuario puede ocuparse de otras tareas sin necesidad de quedarse mirando la pantalla esperando preguntas.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.conffiles">
			<title>Sumas de verificación («checksum»), lista de archivos de configuración</title>
			 <indexterm>
				<primary><filename>md5sums</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>conffiles</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>sumas de verificación</primary>
			</indexterm>
			 <indexterm>
				<primary>configuración</primary>
				<secondary>archivos de configuración</secondary>
			</indexterm>
			 <indexterm>
				<primary>archivo</primary>
				<secondary>de configuración</secondary>
			</indexterm>
			 <para>
				Además de los scripts de gestión y los datos de control mencionados en las secciones anteriores, el compendio <filename>control.tar.gz</filename> en un paquete Debian puede contener otros archivos interesantes. El primero, <filename>md5sums</filename> contiene una lista sumas de verificación MD5 de todos los archivos del paquete. Su principal ventaja es que permite que <command>dpkg-verify</command> (que estudiaremos en la <xref linkend="sect.dpkg-verify" />) chequee si estos archivos fueron modificados desde su instalación. Sepa que cuando este archivo no existe, <command>dpkg</command> lo generará dinámicamente en el momento de la instalación (y lo almacenará en la base de datos de dpkg al igual que cualquier otro archivo de control).
			</para>
			 <para>
				<filename>conffiles</filename> enumera los archivos del paquete que tienen que administrarse como archivos de configuración. El administrador puede modificar los archivos de configuración y <command>dpkg</command> intentará preservar estos cambios durante la actualización de un paquete.
			</para>
			 <para>
				De hecho, en esta situación, <command>dpkg</command> se comporta tan inteligentemente como le es posible: si el archivo de configuración estándar no fue modificado entre dos versiones, no hace nada. Si, sin embargo, el archivo cambió intentará actualizar este archivo. Son posibles dos casos: o bien el administrador no modificó el archivo, en cuyo caso <command>dpkg</command> automáticamente instalará la nueva versión; o el archivo fue modificado, en cuyo caso <command>dpkg</command> le preguntará al administrador qué versión desea utilizar (la antigua con modificaciones o la nueva provista con el paquete). Para asistirlo en esta decisión <command>dpkg</command> ofrece mostrar las diferencias entre las dos versiones («<command>diff</command>»). Si el usuario decide mantener la versión anterior, la nueva será almacenada en la misma ubicación con el sufijo <filename>.dpkg-dist</filename>. Si el usuario selecciona la nueva versión, se mantiene la versión anterior en la misma ubicación con el sufijo <filename>.dpkg-old</filename>. Otra acción posible consiste en interrumpir momentáneamente <command>dpkg</command> para editar el archivo e intentar rehacer las modificaciones relevantes (identificadas previamente con <command>diff</command>).
			</para>
			 <sidebar id="sidebar.questions-conffiles"> <title><emphasis>YENDO MÁS ALLÁ</emphasis> Evitando preguntas sobre los archivos de configuración</title>
			 <para>
				<command>dpkg</command> administra la actualización de los archivos de configuración pero interrumpe estas operaciones frecuentemente mientras trabaja para pedir información al administrador. Esto lo hace menos placentero para aquellos que desean ejecutar actualizaciones de forma no interactiva. Es por esto que éste programa ofrece opciones que le permiten al sistema responder automáticamente según la misma lógica: <command>--force-confold</command> mantiene los archivos de configuración anteriores; <command>--force-confnew</command> utilizará la nueva versión del archivo (se respetan estas opciones aún cuando el archivo no fue modificado por el administrador, que rara vez tienen el efecto deseado). Agregar la opción <command>--force-confdef</command> le indica a <command>dpkg</command> que decida por su cuenta cuando sea posible (en otras palabras, cuando el archivo de configuración original no fue modificado) y sólo utilice <command>--force-confnew</command> o <command>--force-confold</command> para los otros casos.
			</para>
			 <para>
				Estas opciones sólo son válidas para <command>dpkg</command>, pero la mayor parte del tiempo el administrador trabajará directamente con los programas <command>aptitude</command> o <command>apt-get</command>. Es, por lo tanto, necesario saber la sintaxis necesaria para indicar las opciones a pasar a <command>dpkg</command> (sus opciones son muy similares).
			</para>
			 
<screen>
<computeroutput># </computeroutput><userinput>apt -o DPkg::options::="--force-confdef" -o DPkg::options::="--force-confold" full-upgrade</userinput></screen>
			 <para>
				Puede almacenar estas opciones directamente en la configuración de <command>apt</command>. Para esto, simplemente escriba la siguiente línea en el archivo <filename>/etc/apt/apt.conf.d/local</filename>:
			</para>
			 <informalexample> 
<programlisting>
DPkg::options { "--force-confdef"; "--force-confold"; }</programlisting>
			 </informalexample> <para>
				Incluir esta opción en el archivo de configuración singifica que también será utilizada en una interfaz gráfica como <command>aptitude</command>.
			</para>
			 </sidebar> <sidebar id="sidebar.questions-conffiles-bis"> <title><emphasis>YENDO MÁS ALLÁ</emphasis> Obligando a dpkg a preguntar sobre los archivos de configuración</title>
			 <para>
				La opción <command>--force-confask</command> obliga a <command>dpkg</command> a mostrar las preguntas sobre archivos de configuración aún en los casos en los que no serían necesarias normalmente. Por lo tanto, al reinstalar un paquete con esta opción <command>dpkg</command> preguntará nuevamente sobre todos los archivos de configuración modificados por el administrador. Esto es muy conveniente, especialmente para reinstalar el archivo de configuración original si éste fue borrado y no posee otra copia disponible: una reinstalación normal no funcionará porque <command>dpkg</command> considera la eliminación como una forma legítima de modificación del archivo por lo que no lo instalará nuevamente.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.source-package-structure">
		<title>Estructura de un paquete fuente</title>
		 <indexterm>
			<primary>paquete</primary>
			<secondary>fuente</secondary>
		</indexterm>
		 <indexterm>
			<primary>fuente</primary>
			<secondary>paquete</secondary>
		</indexterm>
		 <section>
			<title>Formato</title>
			 <indexterm>
				<primary>DSC, archivo</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>diff.gz</filename>, archivo</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>debian.tar.gz</filename>, archivo</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>orig.tar.gz</filename>, archivo</primary>
			</indexterm>
			 <para>
				Un paquete fuente generalmente consiste de tres archivos: uno <filename>.dsc</filename>, uno <filename>.orig.tar.gz</filename> y uno <filename>.debian.tar.gz</filename> (o <filename>.diff.gz</filename>). Ellos permiten la creación de paquetes binarios (<filename>.deb</filename> descriptos anteriormente) a partir de los archivos de código fuente del programa, escritos en un lenguaje de programación.
			</para>
			 <para>
				El archivo <filename>.dsc</filename> («Debian Source Control»: control de fuente Debian) es un archivo de texto corto que contiene una cabecera RFC 2822 (de la misma forma que el archivo <filename>control</filename> estudiado en la <xref linkend="sect.control" />) que describe el paquete fuente e indica qué otros archivos forman parte del mismo. Está firmado por su encargado, lo que garantiza su autenticidad. Revise la <xref linkend="sect.package-authentication" /> para más detalles sobre este tema.
			</para>
			 <example>
				<title>Un archivo <filename>.dsc</filename></title>
				 
<programlisting>
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Format: 3.0 (quilt)
Source: zim
Binary: zim
Architecture: all
Version: 0.62-3
Maintainer: Emfox Zhou &lt;emfox@debian.org&gt;
Uploaders: Raphaël Hertzog &lt;hertzog@debian.org&gt;
Homepage: http://zim-wiki.org
Standards-Version: 3.9.6
Vcs-Browser: http://anonscm.debian.org/gitweb/?p=collab-maint/zim.git
Vcs-Git: git://anonscm.debian.org/collab-maint/zim.git
Build-Depends: debhelper (&gt;= 9), xdg-utils, python (&gt;= 2.6.6-3~), libgtk2.0-0 (&gt;= 2.6), python-gtk2, python-xdg
Package-List:
 zim deb x11 optional arch=all
Checksums-Sha1:
 ad8de170826682323c10195b65b9f1243fd75637 1772246 zim_0.62.orig.tar.gz
 a4f70d6f7fb404022c9cc4870a4e62ea3ca08388 14768 zim_0.62-3.debian.tar.xz
Checksums-Sha256:
 19d62aebd2c1a92d84d80720c6c1dcdb779c39a2120468fed01b7f252511bdc2 1772246 zim_0.62.orig.tar.gz
 fc2e827e83897d5e33f152f124802c46c3c01c5158b75a8275a27833f1f6f1de 14768 zim_0.62-3.debian.tar.xz
Files:
 43419efba07f7086168442e3d698287a 1772246 zim_0.62.orig.tar.gz
 725a69663a6c2961f07673ae541298e4 14768 zim_0.62-3.debian.tar.xz

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2
Comment: Signed by Raphael Hertzog

iQEcBAEBCAAGBQJUR2jqAAoJEAOIHavrwpq5WFcH/RsdzCHc1oXXxHitU23hEqMj
T6ok29M1UFDJDowMXW75jQ1nT4WPUtvEGygkCHeoO/PvjEvB0sjU8GQlX+N9ddSB
aHfqfAYmVhADNGxrXQT5inZXUa8qGeeq2Sqf6YcWtsnuD56lDbvxkyf/XYopoIEl
oltfl05z/AI+vYsW482YrCz0fxNAKAvkyuPhDebYI8jnKWeAANoqmKpsNc/HYyvT
+ZiA5o57OiGdOKT6XGy3/FiF3dkHiRY8lXW7xdr1BbIgulwl9UmiUNwuxwOYbQO7
edtjiTJqOaFUA0x1zB/XGv5tHr1MjP8naT+kfVoVHTOox51CDbeu5D3DZY4imcY=
=Wtoa
-----END PGP SIGNATURE-----</programlisting>

			</example>
			 <indexterm>
				<primary><literal>Build-Depends</literal>, campo de cabecera</primary>
			</indexterm>
			 <para>
				Note que el paquete fuente también tiene dependencias (<literal>Build-Depends</literal>) completamente distintas de aquellas del paquete binario ya que indican las herramientas necesarias para compilar el software en cuestión y construir su paquete binario.
			</para>
			 <sidebar> <title><emphasis>PRECAUCIÓN</emphasis> Espacios de nombres distintos</title>
			 <para>
				Es importante saber que no hay una correspondencia necesaria entre el nombre de un paquete fuente y el de el o los paquetes binarios que genera. Es suficientemente fácil de entender si sabe que cada paquete fuente puede generar varios paquetes binarios. Es por esto que el archivo <filename>.dsc</filename> tiene los campos <literal>Source</literal> y <literal>Binary</literal> para nombrar explícitamente el paquete fuente y almacenar la lista de paquetes binarios que genera, respectivamente.
			</para>
			 </sidebar> <sidebar> <title><emphasis>CULTURA</emphasis> Porqué dividir en varios paquetes</title>
			 <para>
				Frecuentemente un paquete fuente (para un programa dado) puede generar varios paquetes binarios. La división es justificada por la posibilidad de utilizar (partes de) el mismo en varios contextos. Si consideramos una biblioteca compartida, ésta puede ser instalada para hacer funcionar una aplicación (por ejemplo, <emphasis role="pkg">libc6</emphasis>) o para desarrollar un nuevo programa (<emphasis role="pkg">libc6-dev</emphasis> sería el paquete correcto). Encontramos la misma lógica para servicios cliente/servidor donde deseamos instalar el servidor en una máquina y la parte cliente en otras (este es el caso, por ejemplo, de <emphasis role="pkg">openssh-server</emphasis> y <emphasis role="pkg">openssh-client</emphasis>).
			</para>
			 <para>
				Tan frecuentemente también se provee la documentación en un paquete dedicado: el usuario puede instalarla independientemente del software y puede elegir eliminarla en cualquier momento para ahorrar espacio en disco. Adicionalmente, esto también ahorra espacio en disco en las réplicas Debian ya que todas las arquitecturas comparten los paquetes de documentación (en lugar de tener la documentación duplicada en los paquetes para cada arquitectura).
			</para>
			 </sidebar> <sidebar> <title><emphasis>PERSPECTIVA</emphasis> Diferentes formatos de paquetes fuente</title>
			 <para>
				Originalmente sólo existía un formato de paquete fuente. Este es el formato <literal>1.0</literal> que asocia un compendio <filename>.orig.tar.gz</filename> con un parche de «debianización» <filename>.diff.gz</filename> (también hay una variante que consiste de un simple compendio <filename>.tar.gz</filename>, utilizada automáticamente si hay disponible un archivo <filename>.orig.tar.gz</filename>).
			</para>
			 <para>
				Desde Debian <emphasis role="distribution">Squeeze</emphasis>, los desarrolladores Debian tienen la opción de utilizar nuevos formatos que corrigen varios problemas del formato histórico. El formato <literal>3.0 (quilt)</literal> puede combinar varios compendios de origen en el mismo paquete fuente: puede incluir compendios <filename>.orig-<replaceable>componente</replaceable>.tar.gz</filename> además del <filename>.orig.tar.gz</filename> usual. Esto es útil con el software distribuido desde origen en varios componentes pero para el que se desea sólo un paquete fuente. Estos compendios también puede comprimirse con <command>bzip2</command> o <command>xz</command> en lugar de <command>gzip</command>, lo que ahorra espacio en disco y recursos de red. Finalmente, se reemplaza el parche monolítico <filename>.diff.gz</filename> por un compendio <filename>.debian.tar.gz</filename> que contiene las instrucciones de compilación y un conjunto de parches al origen contribuidos por el desarrollador del paquete. Estos últimos son registrados en un formato compatible con <command>quilt</command> — una herramienta que facilita la gestión de una serie de parches.
			</para>
			 </sidebar> <para>
				El archivo <filename>.orig.tar.gz</filename> es un compendio que contiene el código fuente como es provisto por el desarrollador original. Se le pide a los encargados de paquetes Debian que no modifiquen este compendio para poder verificar fácilmente el origen e integridad del archivo (comparándolo simplemente con una suma de verificación) y para respetar los deseos de algunos autores.
			</para>
			 <para>
				El archivo <filename>.debian.tar.gz</filename> contiene todas las modificaciones realizadas por el desarrollador Debian, especialmente el agregado de un directorio <filename>debian</filename> que contiene las instrucciones para construir un paquete Debian.
			</para>
			 <sidebar> <title><emphasis>HERRAMIENTA</emphasis> Descomprimiendo un paquete fuente</title>
			 <indexterm>
				<primary><command>dpkg-source</command></primary>
			</indexterm>
			 <indexterm>
				<primary>descompresión, paquete fuente</primary>
			</indexterm>
			 <indexterm>
				<primary>descompresión, paquete fuente</primary>
			</indexterm>
			 <indexterm>
				<primary>desempaquetado</primary>
				<secondary>paquete fuente</secondary>
			</indexterm>
			 <para>
				Si tiene un paquete fuente, puede utilizar <command>dpkg-source</command> (del paquete <emphasis>role="pkg"</emphasis>) para descomprimirlo:
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>dpkg-source -x package_0.7-1.dsc</userinput></screen>
			 <para>
				También puede utilizar <command>apt-get</command> para descargar un paquete fuente y descomprimirlo inmediatamente. Necesita, sin embargo, que las líneas <literal>deb-src</literal> apropiadas estén presentes en el archivo <filename>/etc/apt/sources.list</filename> (para maś detalles, revise la <xref linkend="sect.apt-sources.list" />). Éstas son utilizadas para listar los orígenes de los paquetes fuente (los servidores en los que se encuentran un grupo de paquetes fuente).
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>apt-get source <replaceable>package</replaceable></userinput></screen>
			 </sidebar>
		</section>
		 <section>
			<title>Utilización dentro de Debian</title>
			 <para>
				El paquete fuente es la base de todo en Debian. Todos los paquetes Debian provienen de un paquete fuente y cada modificación en un paquete Debian es la consecuencia de una modificación realizada al paquete fuente. Los desarrolladores Debian trabajan con el paquete fuente sabiendo, sin embargo, las consecuencias de sus acciones en los paquetes binarios. Los frutos de su labor se encuentran, entonces, en los paquetes fuentes disponibles desde Debian: puede volver a ellos y todo lo que generan.
			</para>
			 <para>
				Cuando llega una nueva versión de un paquete (paquete fuente y uno o más paquetes binarios) al servidor Debian, el paquete fuente es el más importante. Será utilizado luego por una red de equipos de diferentes arquitecturas para compilar las diferentes arquitecturas con las que Debian es compatible. El hecho de que los desarrolladores también envíen uno o más paquetes binarios para una arquitectura dada (generalmente i386 o amd64) es de relativamente poca importancia ya que los mismos bien podrían haberse generado automáticamente.
			</para>

		</section>

	</section>
	 <section id="sect.manipulating-packages-with-dpkg">
		<title>Manipulación de paquetes con <command>dpkg</command></title>
		 <indexterm>
			<primary><command>dpkg</command></primary>
		</indexterm>
		 <para>
			<command>dpkg</command> es el programa base para manejar paquetes Debian en el sistema. Si tiene paquetes <filename>.deb</filename>, <command>dpkg</command> es lo que permite instalar o analizar sus contenidos. Pero este programa sólo tiene una visión parcial del universo Debian: sabe lo que está instalado en el sistema y lo que sea que se le provee en la línea de órdenes, pero no sabe nada más de otros paquetes disponibles. Como tal, fallará si no se satisface una dependencia. Por el contrario, herramientas como <command>apt</command> crearán una lista de dependencias para instalar todo tan automáticamente como sea posible.
		</para>
		 <sidebar> <title><emphasis>NOTA</emphasis> ¿<command>dpkg</command> o <command>apt</command>?</title>
		 <para>
			Se debe ver a <command>dpkg</command> como una herramienta de sistema (tras bambalinas) y <command>apt</command> como una herramienta más cerca del usuario que evita las limitaciones del primero. Estas herramientas trabajan juntas, cada una con sus particularidades, adecuadas para tareas específicas.
		</para>
		 </sidebar> <section>
			<title>Instalación de paquetes</title>
			 <indexterm>
				<primary>instalación</primary>
				<secondary>de paquetes</secondary>
			</indexterm>
			 <indexterm>
				<primary>instalación de</primary>
				<secondary>paquete</secondary>
			</indexterm>
			 <para>
				<command>dpkg</command> es, sobre todo, la herramienta para instalar un paquete Debian ya disponible (porque no descarga nada). Para hacer esto utilizamos su opción <literal>-i</literal> o <literal>--install</literal>.
			</para>
			 <example>
				<title>Instalación de un paquete con <command>dpkg</command></title>
				 
<screen role="scale">
<computeroutput># </computeroutput><userinput>dpkg -i man-db_2.7.0.2-5_amd64.deb</userinput>
<computeroutput>(Reading database ... 86425 files and directories currently installed.)
Preparing to unpack man-db_2.7.0.2-5_amd64.deb ...
Unpacking man-db (2.7.0.2-5) over (2.7.0.2-4) ...
Setting up man-db (2.7.0.2-5) ...
Updating database of manual pages ...
Processing triggers for mime-support (3.58) ...</computeroutput></screen>

			</example>
			 <para>
				Podemos ver los diferentes pasos que realiza <command>dpkg</command>; sabemos, por lo tanto, en qué punto podría haber ocurrido un error. La instalación también puede realizarse en dos etapas: primero desempaquetado, luego configuración. <command>apt-get</command> lo aprovecha limitando la cantidad de invocaciones de <command>dpkg</command> (ya que cada llamada es costosa debido a la carga de la base de datos en memoria, especialmente la lista de archivos ya instalados).
			</para>
			 <example>
				<title>Desempaquetado y configuración separados</title>
				 
<screen role="scale">
<computeroutput># </computeroutput><userinput>dpkg --unpack man-db_2.7.0.2-5_amd64.deb</userinput>
<computeroutput>(Reading database ... 86425 files and directories currently installed.)
Preparing to unpack man-db_2.7.0.2-5_amd64.deb ...
Unpacking man-db (2.7.0.2-5) over (2.7.0.2-5) ...
Processing triggers for mime-support (3.58) ...
# </computeroutput><userinput>dpkg --configure man-db</userinput>
<computeroutput>Setting up man-db (2.7.0.2-5) ...
Updating database of manual pages ...
</computeroutput></screen>

			</example>
			 <indexterm>
				<primary>paquete</primary>
				<secondary>desempaquetado</secondary>
			</indexterm>
			 <indexterm>
				<primary>desempaquetado</primary>
				<secondary>paquete binario</secondary>
			</indexterm>
			 <para>
				A veces <command>dpkg</command> fallará intentando instalar un paquete y devolverá un error; si el usuario le ordena ignorarlo sólo generará una advertencia; es por esta razón que tenemos las diferentes opciones <literal>--force-*</literal>. La orden <command>dpkg --force-help</command>, o su documentación, proveerá una lista completa de estas opciones. El error más frecuente, con el que seguramente se encontrará tarde o temprano, es una colisión de archivos. Cuando un paquete contiene un archivo que ya está instalado por otro paquete, <command>dpkg</command> se negará a instalarlo. Aparecerá el siguiente mensaje:
			</para>
			 
<screen>
<computeroutput>Unpacking libgdm (from .../libgdm_3.8.3-2_amd64.deb) ...
dpkg: error processing /var/cache/apt/archives/libgdm_3.8.3-2_amd64.deb (--unpack):
 trying to overwrite '/usr/bin/gdmflexiserver', which is also in package gdm3 3.4.1-9</computeroutput></screen>
			 <para>
				En este caso, si piensa que reemplazar este archivo no es un riesgo significativo para la estabilidad de su sistema (que es el caso frecuentemente), puede utilizar la opción <literal>--force-overwrite</literal> que le indica a <command>dpkg</command> que ignore dicho error y sobreescriba el archivo.
			</para>
			 <para>
				Si bien hay muchas opciones <literal>--force-*</literal> disponibles, probablemente sólo utilice regularmente <literal>--force-overwrite</literal>. Estas opciones sólo existen para situaciones excepcionales y es mejor evitarlas siempre que sea posible para respetar las reglas impuestas por el mecanismo de empaquetado. No olvide que estas reglas aseguran la consistencia y estabilidad de su sistema.
			</para>
			 <sidebar> <title><emphasis>PRECAUCIÓN</emphasis> Uso efectivo de <literal>--force-*</literal></title>
			 <indexterm>
				<primary>dependencia rota</primary>
			</indexterm>
			 <para>
				Si no es cuidadoso, utilizar una opción <literal>--force-*</literal> puede llevar a un sistema en el que la familia de programas APT se negarán a funcionar. De hecho, algunas de estas opciones permitirán instalar un paquete cuando no se cumple una de sus dependencias o cuando existe un conflicto. El resultado será un sistema inconsistente desde el punto de vista de dependencias y los programas APT se negarán a efectuar cualquier acción excepto aquellas que le permitan devolver el sistema a un estado consistente (que generalmente consiste en instalar la dependencia faltante o eliminar un paquete problemático). Esto resulta en mensajes como el siguiente, obtenido luego de instalar una nueva versión de <emphasis role="pjg">rdesktop</emphasis> ignorando su dependencia en una nueva versión de <emphasis role="pkg">libc6</emphasis>:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>apt full-upgrade
</userinput><computeroutput>[...]
You might want to run 'apt-get -f install' to correct these.
The following packages have unmet dependencies:
  rdesktop: Depends: libc6 (&gt;= 2.5) but 2.3.6.ds1-13etch7 is installed
E: Unmet dependencies. Try using -f.</computeroutput></screen>
			 <para>
				Un administrador valiente que está seguro de la correctitud de su análisis podría elegir ignorar una dependencia o conflicto y utilizar la opción <literal>--force-*</literal> correspondiente. En este caso, si desea poder continuar utilizando <command>apt</command> o <command>aptitude</command>, deberá editar <filename>/var/lib/dpkg/status</filename> para borrar o modificar la dependencia o conflicto que desea invalidar.
			</para>
			 <para>
				Esta manipulación es un atajo desagradable y no debería ser utilizado nunca excepto en los casos de más extrema necesidad. Muy frecuentemente, recompilar el paquete que está causando el problema (revise la <xref linkend="sect.rebuilding-package" />) o utilizar una nueva verión (potencialmente corregida) de un repositorio como <literal>stable-backports</literal> (revise la <xref linkend="sect.backports" />) son soluciones más adecuadas.
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>Eliminación de un paquete</title>
			 <indexterm>
				<primary>eliminación de un paquete</primary>
			</indexterm>
			 <indexterm>
				<primary>purgar un paquete</primary>
			</indexterm>
			 <indexterm>
				<primary>paquete</primary>
				<secondary>eliminación</secondary>
			</indexterm>
			 <indexterm>
				<primary>paquete</primary>
				<secondary>purgado</secondary>
			</indexterm>
			 <para>
				Ejecutar <command>dpkg</command> con la opción <literal>-r</literal> o <literal>--remove</literal> seguida del nombre de un paquete eliminará dicho paquete. Esta eliminación, sin embargo, no es completa: se mantendrán todos los archivos de configuración, scripts del encargado, archivos de registros (registros de sistema) y otros datos de usuarios que gestiona el paquete. De esta forma, puede desactivar el programa fácilmente al desinstalarlo pero es posible reinstalarlo rápidamente con la misma configuración. Para eliminar completamente todo lo asociado con un paquete, utilice la opción <literal>-P</literal> o <literal>--purge</literal> seguida del nombre del paquete.
			</para>
			 <example>
				<title>Eliminación y purgado del paquete <emphasis role="pkg">debian-cd</emphasis></title>
				 
<screen><computeroutput># </computeroutput><userinput>dpkg -r debian-cd</userinput>
<computeroutput>(Reading database ... 97747 files and directories currently installed.)
Removing debian-cd (3.1.17) ...
# </computeroutput><userinput>dpkg -P debian-cd</userinput>
<computeroutput>(Reading database ... 97401 files and directories currently installed.)
Removing debian-cd (3.1.17) ...
Purging configuration files for debian-cd (3.1.17) ...</computeroutput></screen>

			</example>

		</section>
		 <section>
			<title>Consulta de la base de datos de <command>dpkg</command> e inspección de archivos <filename>.deb</filename></title>
			 <indexterm>
				<primary>paquete</primary>
				<secondary>estado</secondary>
			</indexterm>
			 <indexterm>
				<primary>paquete</primary>
				<secondary>lista de archivos</secondary>
			</indexterm>
			 <indexterm>
				<primary>paquete</primary>
				<secondary>inspección de contenido</secondary>
			</indexterm>
			 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Sintaxis de opciones</title>
			 <para>
				La mayoría de las opciones se encuentran disponibles en una versión «larga» (una o más palabras relevantes precedidas por doble guión) y en una versión «corta» (una única letra, normalmente la primera de las letras de la versión larga, y precedida por un único guión). Esta convención es tan común que constituye un estándar POSIX.
			</para>
			 </sidebar> <para>
				Antes de finalizar esta sección, estudiaremos algunas opciones de <command>dpkg</command> que consultan la base de datos interna para obtener información. Daremos primero las opciones en su versión larga y luego la versión corta correspondiente (que evidentemente aceptarán los mismos parámetros posibles) de las opciones: <literal>--listfiles <replaceable>paquete</replaceable></literal> (o <literal>-L</literal>), que listará los archivos instalados por este paquete; <literal>--search <replaceable>archivo</replaceable></literal> (o <literal>-S</literal>), que encontrará el o los paquetes que contienen el archivo; <literal>--status <replaceable>paquete</replaceable></literal> (o <literal>-s</literal>), que mostrará las cabeceras de un paquete instalado; <literal>--list</literal> (o <literal>-l</literal>), que mostrará la lista de paquetes conocidos por el sistema y su estado de instalación; <literal>--contents <replaceable>archivo.deb</replaceable></literal> (o <literal>-c</literal>), que listará los archivos en el paquete Debian especificado; <literal>--info <replaceable>archivo.deb</replaceable></literal> (o <literal>-I</literal>), que mostrará las cabeceras de este paquete Debian.
			</para>
			 <example>
				<title>Varias consultas con <command>dpkg</command></title>
				 
<screen role="scale" width="80">
<computeroutput>$ </computeroutput><userinput>dpkg -L base-passwd</userinput>
<computeroutput>/.
/usr
/usr/sbin
/usr/sbin/update-passwd
/usr/share
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/base-passwd
/usr/share/doc-base
/usr/share/doc-base/users-and-groups
/usr/share/base-passwd
/usr/share/base-passwd/group.master
/usr/share/base-passwd/passwd.master
/usr/share/man
/usr/share/man/pl
/usr/share/man/pl/man8
/usr/share/man/pl/man8/update-passwd.8.gz
/usr/share/man/ru
/usr/share/man/ru/man8
/usr/share/man/ru/man8/update-passwd.8.gz
/usr/share/man/ja
/usr/share/man/ja/man8
/usr/share/man/ja/man8/update-passwd.8.gz
/usr/share/man/fr
/usr/share/man/fr/man8
/usr/share/man/fr/man8/update-passwd.8.gz
/usr/share/man/es
/usr/share/man/es/man8
/usr/share/man/es/man8/update-passwd.8.gz
/usr/share/man/de
/usr/share/man/de/man8
/usr/share/man/de/man8/update-passwd.8.gz
/usr/share/man/man8
/usr/share/man/man8/update-passwd.8.gz
/usr/share/doc
/usr/share/doc/base-passwd
/usr/share/doc/base-passwd/users-and-groups.txt.gz
/usr/share/doc/base-passwd/changelog.gz
/usr/share/doc/base-passwd/copyright
/usr/share/doc/base-passwd/README
/usr/share/doc/base-passwd/users-and-groups.html
$ </computeroutput><userinput>dpkg -S /bin/date</userinput>
<computeroutput>coreutils: /bin/date
$ </computeroutput><userinput>dpkg -s coreutils</userinput>
<computeroutput>Package: coreutils
Essential: yes
Status: install ok installed
Priority: required
Section: utils
Installed-Size: 13855
Maintainer: Michael Stone &lt;mstone@debian.org&gt;
Architecture: amd64
Multi-Arch: foreign
Version: 8.23-3
Replaces: mktemp, realpath, timeout
Pre-Depends: libacl1 (&gt;= 2.2.51-8), libattr1 (&gt;= 1:2.4.46-8), libc6 (&gt;= 2.17), libselinux1 (&gt;= 2.1.13)
Conflicts: timeout
Description: GNU core utilities
 This package contains the basic file, shell and text manipulation
 utilities which are expected to exist on every operating system.
 .
 Specifically, this package includes:
 arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp
 csplit cut date dd df dir dircolors dirname du echo env expand expr
 factor false flock fmt fold groups head hostid id install join link ln
 logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt
 od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm
 rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac
 tail tee test timeout touch tr true truncate tsort tty uname unexpand
 uniq unlink users vdir wc who whoami yes
Homepage: http://gnu.org/software/coreutils
$ </computeroutput><userinput>dpkg -l 'b*'</userinput>
<computeroutput>Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                    Version          Architecture     Description
+++-=======================-================-================-====================================================
un  backupninja             &lt;none&gt;           &lt;none&gt;           (no description available)
ii  backuppc                3.3.0-2          amd64            high-performance, enterprise-grade system for backin
un  base                    &lt;none&gt;           &lt;none&gt;           (no description available)
un  base-config             &lt;none&gt;           &lt;none&gt;           (no description available)
ii  base-files              8                amd64            Debian base system miscellaneous files
ii  base-passwd             3.5.37           amd64            Debian base system master password and group files
[...]
$ </computeroutput><userinput>dpkg -c /var/cache/apt/archives/gnupg_1.4.18-6_amd64.deb</userinput>
<computeroutput>drwxr-xr-x root/root         0 2014-12-04 23:03 ./
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/udev/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/udev/rules.d/
-rw-r--r-- root/root      2711 2014-12-04 23:03 ./lib/udev/rules.d/60-gnupg.rules
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/lib/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/lib/gnupg/
-rwxr-xr-x root/root     39328 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_ldap
-rwxr-xr-x root/root     92872 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_hkp
-rwxr-xr-x root/root     47576 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_finger
-rwxr-xr-x root/root     84648 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_curl
-rwxr-xr-x root/root      3499 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_mailto
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/bin/
-rwxr-xr-x root/root     60128 2014-12-04 23:03 ./usr/bin/gpgsplit
-rwxr-xr-x root/root   1012688 2014-12-04 23:03 ./usr/bin/gpg
[...]
$ </computeroutput><userinput>dpkg -I /var/cache/apt/archives/gnupg_1.4.18-6_amd64.deb</userinput>
<computeroutput> new debian package, version 2.0.
 size 1148362 bytes: control archive=3422 bytes.
    1264 bytes,    26 lines      control              
    4521 bytes,    65 lines      md5sums              
     479 bytes,    13 lines   *  postinst             #!/bin/sh
     473 bytes,    13 lines   *  preinst              #!/bin/sh
 Package: gnupg
 Version: 1.4.18-6
 Architecture: amd64
 Maintainer: Debian GnuPG-Maintainers &lt;pkg-gnupg-maint@lists.alioth.debian.org&gt;
 Installed-Size: 4888
 Depends: gpgv, libbz2-1.0, libc6 (&gt;= 2.15), libreadline6 (&gt;= 6.0), libusb-0.1-4 (&gt;= 2:0.1.12), zlib1g (&gt;= 1:1.1.4)
 Recommends: gnupg-curl, libldap-2.4-2 (&gt;= 2.4.7)
 Suggests: gnupg-doc, libpcsclite1, parcimonie, xloadimage | imagemagick | eog
 Section: utils
 Priority: important
 Multi-Arch: foreign
 Homepage: http://www.gnupg.org
 Description: GNU privacy guard - a free PGP replacement
  GnuPG is GNU's tool for secure communication and data storage.
  It can be used to encrypt data and to create digital signatures.
  It includes an advanced key management facility and is compliant
  with the proposed OpenPGP Internet standard as described in RFC 4880.
[...]</computeroutput></screen>

			</example>
			 <sidebar> <title><emphasis>YENDO MÁS ALLÁ</emphasis> Comparación de versiones</title>
			 <indexterm>
				<primary>versión, comparación</primary>
			</indexterm>
			 <indexterm>
				<primary>comparación de versiones</primary>
			</indexterm>
			 <para>
				Dado que <command>dpkg</command> es el programa para gestionar paquetes Debian, también provee la implementación de referencia para la lógica de comparación de números de versión. Es por esto que tiene una opción <literal>--compare-versions</literal>, que puede ser utilizada por programas externos (especialmente scripts de configuración ejecutados por <command>dpkg</command> mismo). Esta opción necesita tres parámetros: un número de versión, un operador de comparación y un segundo número de versión. Los diferentes operadores posibles son: <literal>lt</literal> (estrictamente menor), <literal>le</literal> (menor o igual), <literal>eq</literal> (igual), <literal>ne</literal> (distinto), <literal>ge</literal> (mayor o igual) y <literal>gt</literal> (estrictamente mayor). Si la comparación es correcta, <command>dpkg</command> devuelve 0 (éxito); de lo contrario devolverá un valor distinto de cero (indicado un fallo).
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>dpkg --compare-versions 1.2-3 gt 1.1-4</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>0
$ </computeroutput><userinput>dpkg --compare-versions 1.2-3 lt 1.1-4</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>1
$ </computeroutput><userinput>dpkg --compare-versions 2.6.0pre3-1 lt 2.6.0-1</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>1</computeroutput></screen>
			 <para>
				Note el fallo inesperado de la última comparación: <literal>pre</literal>, que generalmente denota una prepublicación, no tiene un significado especial para <command>dpkg</command> y éste compara los caracteres alfabéticos de la misma forma que los números (a &lt; b &lt; c ...): en orden alfabético. Es por esto que considera «<literal>0pre3</literal>» mayor que «<literal>0</literal>». Si deseamos que el número de versión de un paquete indique que es una prepublicación, utilizamos el carácter virgulilla: «<literal>~</literal>»:
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>dpkg --compare-versions 2.6.0~pre3-1 lt 2.6.0-1</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>0</computeroutput></screen>
			 </sidebar>
		</section>
		 <section>
			<title>Archivo de registro de <command>dpkg</command></title>
			 <para>
				<command>dpkg</command> mantiene un registro de todas sus acciones en <filename>/var/log/dpkg.log</filename>. Este registro es extremadamente detallado ya que incluye cada una de las etapas por las que pasa un paquete gestionado por <command>dpkg</command>. Además de ofrecer una forma de rastrear el funcionamiento de dpkg, sobre todo ayuda a mantener un historial del desarrollo del sistema: uno puede encontrar el momento exacto en el que se instaló o actualizó un paquete, y esta información puede ser extremadamente útil cuando se intenta entender un cambio de comportamiento reciente. Además, como se registran todas las versiones, es sencillo verificar y referenciar información con el archivo <filename>changelog.Debian.gz</filename> del paquete en cuestión o inclusive con reportes de error online.
			</para>

		</section>
		 <section id="sect.multi-arch">
			<title>Compatibilidad multiarquitectura</title>
			 <indexterm>
				<primary>multiarquitectura</primary>
			</indexterm>
			 <indexterm>
				<primary>arquitectura</primary>
				<secondary>compatibilidad multiarquitectura</secondary>
			</indexterm>
			 <para>
				Todos los paquetes Debian poseen un campo «<literal>Architecture</literal>» (arquitectura) en su información de control. El valor de este campo puede ser «<literal>all</literal>» (para los paquetes que son independientes de la arquitectura) o el nombre de la arquitectura al que está destinado (como «amd64», «armhf», …). En el último caso, de forma predeterminada, <command>dpkg</command> sólo aceptara instalar el paquete si su arquitectura coincide con la arquitectura del equipo según es informada por <command>dpkg --print-architecture</command>.
			</para>
			 <para>
				Esta restricción asegura que el usuario no termine con binarios compilados para la arquitectura incorrecta. Todo sería perfecto si no fuese que (algunos) equipos puede ejecutar binarios para más de una arquitectura, ya sea de forma nativa (un sistema «amd64» puede ejecutar binarios «i386») o a través de emuladores.
			</para>
			 <section>
				<title>Activación de multiarquitectura</title>
				 <para>
					La compatibilidad multiarquitectura de <command>dpkg</command> le permite al usuario definir «arquitecturas extranjeras» que pueden ser instaladas en el sistema actual. Puede hacer esto simplemente ejecutando <command>dpkg --add-architecture</command> como en el ejemplo a continuación. Existe también el correspondiente <command>dpkg --remove-architecture</command> para eliminar la compatibilidad de una arquitectura extranjera, pero sólo puede utilizarlo cuando ya no existan paquetes instalados de dicha arquitectura.
				</para>
				 
<screen>
<computeroutput># </computeroutput><userinput>dpkg --print-architecture</userinput>
<computeroutput>amd64
# </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput># </computeroutput><userinput>dpkg -i gcc-4.9-base_4.9.1-19_armhf.deb</userinput>
<computeroutput>dpkg: error processing archive gcc-4.9-base_4.9.1-19_armhf.deb (--install):
 package architecture (armhf) does not match system (amd64)
Errors were encountered while processing:
 gcc-4.9-base_4.9.1-19_armhf.deb
# </computeroutput><userinput>dpkg --add-architecture armhf</userinput>
<computeroutput># </computeroutput><userinput>dpkg --add-architecture armel</userinput>
<computeroutput># </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput>armhf
armel
# </computeroutput><userinput>dpkg -i gcc-4.9-base_4.9.1-19_armhf.deb</userinput>
<computeroutput>Selecting previously unselected package gcc-4.9-base:armhf.
(Reading database ... 86425 files and directories currently installed.)
Preparing to unpack gcc-4.9-base_4.9.1-19_armhf.deb ...
Unpacking gcc-4.9-base:armhf (4.9.1-19) ...
Setting up gcc-4.9-base:armhf (4.9.1-19) ...
# </computeroutput><userinput>dpkg --remove-architecture armhf</userinput>
<computeroutput>dpkg: error: cannot remove architecture 'armhf' currently in use by the database
# </computeroutput><userinput>dpkg --remove-architecture armel</userinput>
<computeroutput># </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput>armhf</computeroutput></screen>
				 <sidebar> <title><emphasis>NOTA</emphasis> Compatibilidad multiarquitectura de APT</title>
				 <para>
					APT detectará automáticamente cuando se haya configurado a dpkg para que sea compatible con arquitecturas extranejeras y descargará los archivos <filename>Packages</filename> correspondientes durante su proceso de actualización.
				</para>
				 <para>
					Luego podrá instalar paquetes extranejros con <command>apt install <replaceable>paquete</replaceable>:<replaceable>arquitectura</replaceable></command>.
				</para>
				 </sidebar> <sidebar> <title><emphasis>EN LA PRÁCTICA</emphasis> Utilización de binarios i386 privativos en amd64</title>
				 <para>
					Hay muchos casos de uso para multiarquitectura, pero el más popular es la capacidad de instalar binarios de 32 bits (i386) en sistemas de 64 bits (amd64), en particular debido a que varias aplicaciones privativas populares (como Skype) sólo proveen versiones de 32 bits.
				</para>
				 </sidebar>
			</section>
			 <section>
				<title>Cambios relacionados con multiarquitectura</title>
				 <para>
					Para poder hacer que multiarquitectura fuese útil y usable, se debieron reempaquetar bibliotecas y moverlas a un directorio específico de la arquitectura para que se pudieran instalar simultáneamete varias copias (para diferentes arquitecturas). Estos paquetes actualizados contienen el campo de cabecera «<literal>Multi-Arch: same</literal>» para indicarle al sistema de paquetes que se pueden instalar simultáneamente y sin problemas varias arquitecturas del mismo (y que dichos paquetes sólo satisfacen dependencias de los paquetes de la misma arquitectura). Desde el debut de multiarquitectura en Debian <emphasis role="distribution">Wheezy</emphasis>, aun no todas las bibliotecas fueron convertidas.
				</para>
				 
<screen><computeroutput>$ </computeroutput><userinput>dpkg -s gcc-4.9-base
</userinput><computeroutput>dpkg-query: error: --status needs a valid package name but 'gcc-4.9-base' is not: ambiguous package name 'gcc-4.9-base' with more than one installed instance

Use --help for help about querying packages.
$ </computeroutput><userinput>dpkg -s gcc-4.9-base:amd64 gcc-4.9-base:armhf | grep ^Multi
</userinput><computeroutput>Multi-Arch: same
Multi-Arch: same
$ </computeroutput><userinput>dpkg -L libgcc1:amd64 |grep .so
</userinput><computeroutput>/lib/x86_64-linux-gnu/libgcc_s.so.1
$ </computeroutput><userinput>dpkg -S /usr/share/doc/gcc-4.9-base/copyright
</userinput><computeroutput>gcc-4.9-base:amd64, gcc-4.9-base:armhf: /usr/share/doc/gcc-4.9-base/copyright
</computeroutput></screen>
				 <para>
					Vale la pena aclarar que los paquetes que contengan <literal>Multi-Arch: same</literal> deben poseer nombres que inlcuyan su arquitectura para poder identificarlos unívocamente. También tienen la posibilidad de compartir archivos con otras instancias del mismo paquete; <command>dpkg</command> se asegura que todos los paquetes tengan archivos idénticos bit a bit cuando son compartidos. Por último, todas las instancias de un paquete deben tener la misma versión. Por lo tanto, deben actualizarse simultáneamente.
				</para>
				 <para>
					La compatibilidad multiarquitectura también viene aparejada con algunos retos interesantes sobre la forma en la que se gestionan las dependencias. Para satisfacer una dependencia se necesita un paquete marcado con «<literal>Multi-Arch: foreign</literal>» o bien un paquete cuya arquitectura coincida con la del paquete que declara la dependencia (en este proceso de resolución de dependencias, se asume que los paquetes independientes de la arquitectura son de la misma arquitectura que el sistema). También se puede debilitar una dependencia para permitir que cualquier arquitectura la satisfaga con la sintaxis <literal><replaceable>paquete</replaceable>:any</literal>, pero los paquetes extranjeros sólo pueden satisfacer dicha dependencia si están marcados con «<literal>Multi-Arch: allowed</literal>».
				</para>

			</section>

		</section>

	</section>
	 <section id="sect.coexistence-with-other-packaging-systems">
		<title>Coexistencia con otros sistemas paquetes</title>
		 <indexterm>
			<primary>RPM</primary>
		</indexterm>
		 <indexterm>
			<primary>Gestor de paquetes de Red Hat</primary>
		</indexterm>
		 <indexterm>
			<primary><command>alien</command></primary>
		</indexterm>
		 <para>
			Los paquetes Debian no son los únicos paquetes de software utilizados en el mundo del software libre. El principal competidor es el formato RPM de la distribución Red Hat Linux y sus muchos derivados. Red Hat es una distribución comercial muy popular. Por lo tanto, es muy común que el software provisto por terceros sea ofrecido como paquetes RPM en lugar de paquetes Debian.
		</para>
		 <para>
			En este caso debe saber que el programa <command>rpm</command>, que gestiona los paquetes RPM, está disponible como un paquete Debian; por lo que es posible utilizar este formato de paquetes en Debian. Debe tener cuidado sin embargo, y limitar estas manipulaciones a extraer la información de un paquete o verificar su integridad. No es, en realidad, razonable utilizar <command>rpm</command> para instalar un paquete RPM en un sistema Debian; RPM utiliza su propia base de datos, separada de aquella del software nativo (como <command>dpkg</command>. Es por esto que no es posible asegurar una coexistencia estable de dos sistemas de paquetes.
		</para>
		 <para>
			Por el otro lado, la herramienta <emphasis role="pkg">alien</emphasis> puede convertir paquetes RPM en paquetes Debian y viceversa.
		</para>
		 <sidebar> <title><emphasis>COMUNIDAD</emphasis> Fomentando la adopción de <filename>.deb</filename></title>
		 <para>
			Si utiliza el programa <command>alien</command> frecuentemente para instalar paquetes RPM de alguno de sus proveedores, no dude en escribirle y expresar su fuerte preferencia por el formato <filename>.deb</filename>. Note que el formato del paquete no es todo: un paquete <filename>.deb</filename> construido con <command>alien</command>, preparado para una versión de Debian diferente a la que utiliza, o inclusive para una distribución derivada como Ubuntu, probablemente no ofrezca el mismo nivel de calidad e integración que un paquete desarrollado específicamente para Debian <emphasis role="distribution">Jessie</emphasis>.
		</para>
		 </sidebar> 
<screen>
<computeroutput>$ </computeroutput><userinput>fakeroot alien --to-deb phpMyAdmin-2.0.5-2.noarch.rpm</userinput> 
<computeroutput>phpmyadmin_2.0.5-2_all.deb generated
$ </computeroutput><userinput>ls -s phpmyadmin_2.0.5-2_all.deb</userinput>
<computeroutput>  64 phpmyadmin_2.0.5-2_all.deb</computeroutput></screen>
		 <para>
			Encontrará que el proceso es extremadamente simple. Debe saber, sin embargo, que el paquete generado no tiene información sobre dependencias ya que las dependencias de los dos formatos de paquetes no tienen una correspondencia sistemática. El administrador debe, por lo tanto, asegurarse manualmente que el paquete convertido funcionará correctamente y esta es la razón por la que se deben evitar los paquetes Debian así generados tanto como sea posible. Afortunadamente, Debian tiene la colección más grande de paquetes de software entre todas las distribuciones y es probable que lo que sea que busque ya esté allí.
		</para>
		 <para>
			Revisando la página de manual del programa <command>alien</command> también notará que este programa es compatible con otros formatos de paquetes, en especial el utilizado por la distribución Slackware (que está compuesto de un simple compendio <filename>tar.gz</filename>).
		</para>
		 <para>
			La estabilidad del software desplegado con la herramienta <command>dpkg</command> contribuye a la fama de Debian. La suite de herramientas APT descrita en el próximo capítulo preserva esta ventaja al mismo tiempo que liberan al administrador de la carga de gestionar el estado de los paquetes, una tarea difícil pero necesaria.
		</para>

	</section>
</chapter>

