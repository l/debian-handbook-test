<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="basic-configuration" lang="es-ES">
	<chapterinfo>
		 <keywordset>
			<keyword>Configuración</keyword>
			 <keyword>Localización</keyword>
			 <keyword>Locales</keyword>
			 <keyword>Red</keyword>
			 <keyword>Resolución de nombres</keyword>
			 <keyword>Usuarios</keyword>
			 <keyword>Grupos</keyword>
			 <keyword>Cuentas</keyword>
			 <keyword>Intérprete de línea de órdenes</keyword>
			 <keyword>Consola</keyword>
			 <keyword>Impresión</keyword>
			 <keyword>Gestor de arranque</keyword>
			 <keyword>Compilación de núcleo</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Configuración básica: red, cuentas, impresión...</title>
	 <highlights> <para>
		El propósito de un equipo con una instalación nueva creada con <command>debian-installer</command> es que sea tan funcional como sea posible, pero aún necesita configurar muchos servicios. Lo que es más, es bueno saber cómo modificar ciertos elementos de configuración definidos durante el proceso de instalación inicial.
	</para>
	 </highlights> <para>
		Este capítulo revisa todo lo incluido en lo que llamaríamos «configuración básica»: red, idioma y locales, usuarios y grupos, impresión, puntos de montaje, etc.
	</para>
	 <section id="sect.config-language-support">
		<title>Configuración del sistema en otro idioma</title>
		 <indexterm>
			<primary>Localización francesa</primary>
		</indexterm>
		 <para>
			Si instaló el sistema utilizando el idioma francés, el equipo probablemente ya tenga configurado al francés como idioma predeterminado. Pero es bueno saber lo que realiza el instalador al configurar el idioma para que, luego si lo necesita, pueda cambiarlo.
		</para>
		 <sidebar> <title><emphasis>HERRAMIENTA</emphasis> El programa <command>locale</command> para mostrar la configuración actual</title>
		 <para>
			El programa <command>locale</command> mostrará un resumen de la configuración actual de varios parámetros de la locale (formato de fecha, formato de números, etc.) presentados en forma de un grupo de variables de entorno estándar dedicadas a la modificación dinámica de éstas configuraciones.
		</para>
		 </sidebar> <section id="sect.default-language">
			<title>Configuración del idioma predeterminado</title>
			 <indexterm>
				<primary>locales</primary>
			</indexterm>
			 <indexterm>
				<primary>idioma</primary>
			</indexterm>
			 <indexterm>
				<primary><command>locale-gen</command></primary>
			</indexterm>
			 <para>
				Un <foreignphrase>locale</foreignphrase> es un grupo de configuraciones regionales. Incluyen no sólo el idioma para el texto, también el formato para mostrar números, fechas, marcas temporales y cantidades de dinero así como también reglas de comparación alfabética (para considerar caracteres acentuados correctamente). Aunque puede especificar cada uno de estos parámetros independientemente de los demás, generalmente utilizaremos un locale que es un conjunto coherente de valores para estos parámetros que corresponde con una «región» en el sentido amplio de la palabra. Generalmente se indican los locales en la forma <literal><replaceable>código-idioma</replaceable>_<replaceable>CÓDIGO-PAÍS</replaceable></literal>, a veces con un sufijo que indica un conjunto de caracteres y codificación a utilizar. Esto permite considerar diferencias idiomáticas o tipográficas entre diferentes regiones con un idioma en común.
			</para>
			 <sidebar> <title><emphasis>CULTURA</emphasis> Juegos de caracteres</title>
			 <indexterm>
				<primary>conjunto de caracteres</primary>
			</indexterm>
			 <indexterm>
				<primary>codificación</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-1</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-15</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 1</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 9</primary>
			</indexterm>
			 <para>
				Históricamente, cada locale tiene asociado un «conjunto de caracteres» (grupo de caracteres conocidos) y una «codificación» preferida (representación interna de los caracteres para el equipo).
			</para>
			 <para>
				Las codificaciones más populares para idiomas derivados del latín estaban limitadas a 256 caracteres porque decidieron utilizar sólo un byte por carácter. Debido a que 256 caracteres no son suficientes para cubrir todos los idiomas europeos fueron necesarias múltiples codificaciones, y así es como tenemos desde <emphasis>ISO-8859-1</emphasis> (también conocida como «Latin 1») hasta <emphasis>ISO-8859-15</emphasis> (también conocida como «Latin 9»), entre otras.
			</para>
			 <para>
				Trabajar con idiomas extranjeros generalmente implica cambios frecuentes entre varias codificaciones y conjuntos de caracteres. Lo que es más, escribir documentos en varios idiomas causó problemas más grandes y casi intratables. Se creó Unicode (un supercatálogo de casi todos los sistemas de escritura de todos los idiomas del mundo) para evitar este problema. Una de las codificaciones de Unicode, UTF-8, mantiene todos los 128 símbolos ASCII (códigos de 7 bits), pero maneja los demás caracteres de forma diferente. Éstos son precedidos por una secuencia «escape» de unos pocos bits, que define implícitamente la longitud del carácter. Esto permite codificar todos los caracteres Unicode en una secuencia de uno o más bytes. Se popularizó su uso debido a que es la codificación predeterminada en documentos XML.
			</para>
			 <indexterm>
				<primary>ASCII</primary>
			</indexterm>
			 <indexterm>
				<primary>UTF-8</primary>
			</indexterm>
			 <indexterm>
				<primary>Unicode</primary>
			</indexterm>
			 <para>
				Generalmente esta es la codificación que debería utilizar y es, por lo tanto, la predeterminada en sistemas Debian.
			</para>
			 </sidebar> <para>
				El paquete <emphasis role="pkg">locales</emphasis> incluye todos los elementos necesarios para que la «localización» de las aplicaciones funcione correctamente. Durante su instalación, este paquete le pedirá que seleccione un conjunto de idiomas compatibles. Puede cambiar este conjunto en cualquier momento ejecutando como root <command>dpkg-reconfigure locales</command>.
			</para>
			 <para>
				La primer pregunta le pedirá que seleccione las «locales» a incluir. Seleccionar todas las locales de inglés (es decir todas las que comiencen con «<literal>en_</literal>») es una elección razonable. No dude en habilitar otras locales si la máquina va a ser utilizada por usuarios extranjeros. Se almacenará la lista de locales activadas para el sistema en el archivo <filename>/etc/locale.gen</filename>. Es posible editar este archivo a mano pero debería ejecutar <command>locale-gen</command> luego de cualquier modificación. Generará los archivos necesarios para que funcionen las locales agregadas y eliminará archivos obsoletos.
			</para>
			 <para>
				La segunda pregunta, titulada «Locale predeterminada para el entorno del sistema», pedirá un locale predeterminado. La opción recomendada en Estados Unidos es «<literal>en_US.UTF-8</literal>». Los angloparlantes británicos preferirán «<literal>en_GB.UTF-8</literal>» y los canadienses preferirán «<literal>en_CA.UTF-8</literal>» o el francés «<literal>fr_CA.UTF-8</literal>». Se modificará el archivo <filename>/etc/default/locale</filename> para almacenar esta elección. Desde ese momento, todas las sesiones de usuario estáran al tanto del cambio ya que PAM agregará su contenido en la variable de entorno <varname>LANG</varname>. (N.T. los castellanoparlantes seguramente preferirán «<literal>es_XX.UTF-8</literal>», donde XX representa el código ISO del pais, como es_ES para España o es_AR para Argentina).
			</para>
			 <indexterm>
				<primary>entorno</primary>
			</indexterm>
			 <indexterm>
				<primary>locale</primary>
			</indexterm>
			 <indexterm>
				<primary><varname>LANG</varname></primary>
			</indexterm>
			 <sidebar id="sidebar.intro-pam"> <title><emphasis>TRAS BAMBALINAS</emphasis> <filename>/etc/environment</filename> y <filename>/etc/default/locale</filename></title>
			 <para>
				El archivo <filename>/etc/environment</filename> provee a los programas <command>login</command>, <command>gdm</command> o inclusive <command>ssh</command> las variables de entorno correctas a crear.
			</para>
			 <para>
				Estas aplicaciones no crean estas variables directamente sino que lo hacen a través de un módulo PAM (<filename>pam_env.so</filename>). PAM (siglas de «módulo de autenticación conectable»: «Pluggable Authentication Module») es una biblioteca modular que centraliza los mecanismos de autenticación, inicialización de la sesión y gestión de contraseñas. Revise la <xref linkend="sect.config-pam" /> para encontrar un ejemplo de configuración de PAM.
			</para>
			 <para>
				El archivo <filename>/etc/default/locale</filename> funciona de manera similar pero sólo contiene la variable de entorno <varname>LANG</varname>. Gracias a esta división, algunos usuarios PAM pueden heredar un entorno completo sin localización. De hecho, generalmente no se recomienda ejecutar programas de servidor con localización activada; por el contrario, se recomienda utilizar las configuraciones regionales y de localización para los programas que abren sesiones de usuario.
			</para>
			 <indexterm>
				<primary>PAM</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>pam_env.so</filename></primary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.keyboard-config">
			<title>Configuración del teclado</title>
			 <indexterm>
				<primary>distribución del teclado</primary>
			</indexterm>
			 <indexterm>
				<primary>distribución del teclado</primary>
			</indexterm>
			 <para>
				Aún cuando se gestiona la distribución del teclado de formas diferentes en una consola y en el modo gráfico, Debian ofrece una interfaz de configuración única que funciona para ambos: está basada en debconf y la implementa el paquete <emphasis role="pkg">keyboard-configuration</emphasis>. Por lo tanto, puede ejecutar <command>dpkg-reconfigure keyboard-configuration</command> para establecer la distribución de teclado.
			</para>
			 <indexterm>
				<primary><emphasis>console-data</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>console-tools</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>keyboard-configuration</emphasis></primary>
			</indexterm>
			 <para>
				<indexterm><primary><literal>azerty</literal></primary></indexterm> Las preguntas son relevantes para la distribución física del teclado (un teclado de PC estándar en los Estados Unidos sería «Genérico 104 Teclas»), luego la distribución a utilizar (generalmente «US»), y luego la posición de la tecla AltGr (Alt derecho). Finalmente pregunta por la tecla a utilizar para «Compose» que permite ingresar caracteres especiales combinando teclas. Presionar sucesivamente <keycombo action="seq"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> creará una e acentuada («é»). Se describen todas estas combinaciones en el archivo <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> (u otro archivo según el locale actual indicado por <filename>/usr/share/X11/locale/compose.dir</filename>).
			</para>
			 <indexterm>
				<primary><literal>Compose</literal>, tecla</primary>
			</indexterm>
			 <indexterm>
				<primary><literal>Meta</literal>, tecla</primary>
			</indexterm>
			 <indexterm>
				<primary>tecla</primary>
				<secondary><literal>Meta</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary>tecla</primary>
				<secondary><literal>Compose</literal></secondary>
			</indexterm>
			 <para>
				Note that the keyboard configuration for graphical mode described here only affects the default layout; the GNOME and KDE Plasma environments, among others, provide a keyboard control panel in their preferences allowing each user to have their own configuration. Some additional options regarding the behavior of some particular keys are also available in these control panels.
			</para>

		</section>
		 <section id="sect.utf8-migration">
			<title>Migración a UTF-8</title>
			 <para>
				La generalización de la codificación UTF-8 es una solución muy esperada a varias dificultades de interoperabilidad ya que facilita intercambios internacionales y elimina los límites arbitrarios de los caracteres que pueden ser utilizados en un documento. La única desventaja es que ha tenido que pasar por una etapa de transición difícil. Como no puede ser completamente transparente (es decir, no puede suceder al mismo tiempo en todo el mundo), se necesitaron dos operaciones de conversión: una en el contenido de los archivos y otra en los nombres de archivos. Afortunadamente, ya se completó la mayor parte de esta migración y la discutimos mayormente por cuestiones de referencia.
			</para>
			 <sidebar> <title><emphasis>CULTURA</emphasis> <foreignphrase>Mojibake</foreignphrase> y los errores de interpretación</title>
			 <para>
				Cuando se envía (o almacena) un texto sin información de codificación el receptor no siempre puede estar seguro de saber qué convención utilizar para determinar el significado de un conjunto de bytes. Usualmente puede tener una idea obteniendo estadísticas en la distribución de los valores presentes en el texto pero esto no siempre da una respuesta definitiva. Cuando el sistema de codificación elegido para la lectura es diferente al utilizado para escribir el archivo se interpretan incorrectamente los bytes y se obtienen, en el mejor caso, errores en algunos caracteres o, en el peor caso, algo completamente ilegible.
			</para>
			 <para>
				Por lo tanto, si un texto en francés aparece normal con la excepción de letras acentuadas y algunos símbolos que aparecerán reemplazados con secuencias de caracteres como «Ã©» o «Ã¨» o «Ã§» probablemente sea un archivo codificado con UTF-8 interpretado como ISO-8859-1 o ISO-8859-15. Este es signo de una instalación local que no migró a UTF-8 aún. Si, en cambio, observa sígnos de interrogación en lugar de letras acentuadas — aún si dichos símbolos parecen reemplazar el carácter que seguiría a la letra acentuada — es probable que su instalación ya esté configurada para UTF-8 y que le enviaron un documento codificado con Western ISO.
			</para>
			 <para>
				Esos son todos los casos «simples». Estos casos sólo aparecen en la cultura occidental ya que se diseñó Unicode (y UTF-8) para maximizar los puntos comunes con codificaciones históricas de idiomas occidentales basados en el alfabeto latino que permite reconocer partes del texto aún cuando faltan algunos caracteres.
			</para>
			 <para>
				En configuraciones más complejas que, por ejemplo, involucran dos entornos que corresponden a dos idiomas diferentes que no utilizan el mismo alfabeto generalmente obtendrá resultados completamente ilegibles — una serie de símbolos abstractos que no tienen nada que ver unos con otros. Esto es especialmente frecuente con idiomas asiáticos debido a sus numerosos idiomas y sistemas de escritura. Se adoptó la palabra japonesa <foreignphrase>mojibake</foreignphrase> para describir este fenómeno. Cuando ocurre, el diagnóstico es más complejo y la solución más simple generalmente es migrar a UTF-8 en ambos lados.
			</para>
			 </sidebar> <para>
				En cuanto a los nombres de archivos, la migración puede ser relativamente simple. Se creó la herramienta <command>convmv</command> (en el paquete del mismo nombre) específicamente con este propósito; permite cambiar el nombre de los archivos de una codificación a otra. El uso de esta herramienta es relativamente simple pero recomendamos realizarlo en dos pasos para evitar sorpresas. El próximo ejemplo muestra un entorno UTF-8 que contiene nombres de directorio codificados en ISO-8859-15 y utiliza <command>convmv</command> para cambiarlos.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>ls trabajo/</userinput>
<computeroutput>?conos  Elementos gr?ficos  Textos
$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 trabajo/</userinput>
<computeroutput>Starting a dry run without changes...
mv "trabajo/Elementos gr�ficos"        "trabajo/Elementos gráficos"
mv "trabajo/�conos"     "trabajo/Íconos"
No changes to your files done. Use --notest to finally rename the files.
$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 trabajo/</userinput>
<computeroutput>mv "trabajo/Elementos gr�ficos"        "trabajo/Elementos gráficos"
mv "trabajo/�conos"     "trabajo/Íconos"
Ready!
$ </computeroutput><userinput>ls trabajo/</userinput>
<computeroutput>Elementos gráficos  Íconos  Textos</computeroutput></screen>
			 <para>
				Para el contenido de los archivos, los procedimientos de conversión son más complejos debido a la cantidad de formatos de archivo existentes. Algunos formatos de archivos incluyen información de codificación que facilita las tareas al software con el que se los trata; es suficiente entonces abrir estos archivos y volver a guardarlos especificando la condificación UTF-8. En otros casos, debe especificar la codificación original al abrir el archivo (ISO-8859-1 o «Western», o ISO-8859-15 o «Western (Euro)» según el caso).
			</para>
			 <para>
				Para archivos de texto simples puede utilizar <command>recode</command> (en el paquete del mismo nombre) que permite recodificación automática. Esta herramienta tiene numerosas opciones que le permiten alterar su comportamiento. Le recomendamos consultar la documentación, la página de manual <citerefentry><refentrytitle>recode</refentrytitle>
				<manvolnum>1</manvolnum></citerefentry> o la página info <citerefentry><refentrytitle>recode</refentrytitle>
				</citerefentry> (más completa).
			</para>

		</section>

	</section>
	 <section id="sect.network-config">
		<title>Configuración de red</title>
		 <sidebar id="sidebar.networking-basics"> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Conceptos de red esenciales (Ethernet, dirección IP, subred, difusión)</title>
		 <indexterm>
			<primary>Ethernet</primary>
		</indexterm>
		 <indexterm>
			<primary>10BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>100BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>1000BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>10GBASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>conector RJ45</primary>
		</indexterm>
		 <indexterm>
			<primary>conector RJ45</primary>
		</indexterm>
		 <para>
			La mayoría de las redes modernas locales utilizan el protocolo Ethernet, en el que se dividen los datos en pequeños bloques llamados tramas («frames») y se transmite en el cable una trama a la vez. La velocidad de datos varía desde 10 Mb/s en tarjetas Ethernet antiguas hasta 10 Gb/s en las tarjetas más recientes (la tasa más común está creciendo actualmente de 100 Mb/s a 1 Gb/s). Los cables más utilizados son llamados 10BASE-T, 100BASE-T, 1000BASE-T o 10GBASE-T según el rendimiento que pueden proveer de forma confiable (la letra T es por «par trenzado», «twisted pair» en inglés); éstos cables finalizan en un conector RJ45. Hay otros tipos de cables, generalmente utilizados para velocidades de 1 Gb/s en adelante.
		</para>
		 <indexterm>
			<primary>dirección IP</primary>
		</indexterm>
		 <indexterm>
			<primary>dirección IP</primary>
		</indexterm>
		 <para>
			Una dirección IP es un número utilizado para identificar una interfaz de red de un equipo en una red local o Internet. En la versión de IP más utilizada actualmente (IPv4) se codifica este número en 32 bits y generalmente se lo representa por 4 números separados por puntos (por ejemplo: <literal>192.168.0.1</literal>), cada número entre 0 y 255 (inclusive, correspondiendo a 8 bits de datos). La siguiente versión del protocolo, IPv6, extiende este espacio de direcciones a 128 bits y las direcciones se representan generalmente por una serie de números hexadecimales separados por dos puntos (por ejemplo: 2001:0db8:13bb:0002:0000:0000:0000:0020 o su versión corta 2001:db8:13bb:2::20).
		</para>
		 <indexterm>
			<primary>subred</primary>
		</indexterm>
		 <indexterm>
			<primary>máscara</primary>
			<secondary>de subred</secondary>
		</indexterm>
		 <indexterm>
			<primary>red</primary>
			<secondary>dirección</secondary>
		</indexterm>
		 <para>
			Una máscara de subred (máscara de red) define en su código binario qué porción de una dirección IP corresponde a la red, el resto especifica el equipo. En el ejemplo de configuración de una dirección IPv4 estática dado, la máscara de red <literal>255.255.255.0</literal> (24 «1»s seguidos de 8 «0»s en su representación binaria) indica que los primeros 24 bits de la dirección IP corresponden a la dirección de red y los otros 8 son específicos a la máquina. En IPv6, para facilitar la lectura, sólo se expresa la cantidad de «1»s; la máscara de red para una red IPv6 podría ser entonces <literal>64</literal>.
		</para>
		 <para>
			La dirección de red es una dirección IP en la que la parte que describe el número de equipo es 0. Generalmente se indica el rango de direcciones IPv4 en una red completa con la sintaxis <emphasis>a.b.c.d/e</emphasis> en el que <emphasis>a.b.c.d</emphasis> es la dirección de red y <emphasis>e</emphasis> es la cantidad de bits afectados por la parte de red en una dirección IP. La red de ejemplo entonces podría escribirse: <literal>192.168.0.0/24</literal>. La sintaxis es similar en IPv6: <literal>2001:db8:13bb:2::/64</literal>.
		</para>
		 <indexterm>
			<primary>router</primary>
		</indexterm>
		 <indexterm>
			<primary>puente</primary>
		</indexterm>
		 <para>
			Un enrutador («router») es una máquina que conecta varias redes entre sí. Se guía todo el tráfico a través de un enrutador a la red correcta. Para hacerlo, el enrutador analiza los paquetes entrantes y los redirecciona según su dirección IP de destino. Generalmente se conoce al enrutador como puerta de enlace («gateway»); en esta configuración trabaja como una máquina que ayuda a alcanzar el exterior de la red local (hacia una red extendida, como Internet).
		</para>
		 <indexterm>
			<primary>difusión</primary>
		</indexterm>
		 <para>
			La dirección especial de difusión conecta todas las estaciones en una red. Casi nunca es «enrutada», sólo funciona en la red en cuestión. Específicamente, significa que un paquete de datos direccionado a difusión nunca pasará a través del enrutador.
		</para>
		 <para>
			Este capítulo se enfocará en direcciones IPv4 ya que son las utilizadas más comunmente en la actualidad. Se estudiarán los detalles del protocolo IPv6 en la <xref linkend="sect.ipv6" /> pero los conceptos se mantienen.
		</para>
		 </sidebar> <para>
			The network is automatically configured during the initial installation. If Network Manager gets installed (which is generally the case for full desktop installations), then it might be that no configuration is actually required (for example, if you rely on DHCP on a wired connection and have no specific requirements). If a configuration is required (for example for a WiFi interface), then it will create the appropriate file in <filename>/etc/NetworkManager/system-connections/</filename>.
		</para>
		 <para>
			If Network Manager is not installed, then the installer will configure <emphasis role="pkg">ifupdown</emphasis> by creating the <filename>/etc/network/interfaces</filename> file. A line starting with <literal>auto</literal> gives a list of interfaces to be automatically configured on boot by the <literal>networking</literal> service.
		</para>
		 <para>
			In a server context, <emphasis role="pkg">ifupdown</emphasis> is thus the network configuration tool that you usually get. That is why we will cover it in the next sections.
		</para>
		 <indexterm>
			<primary>red</primary>
			<secondary>configuración</secondary>
		</indexterm>
		 <indexterm>
			<primary>configuración</primary>
			<secondary>de la red</secondary>
		</indexterm>
		 <indexterm>
			<primary>interfaz</primary>
			<secondary>de red</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>ALTERNATIVA</emphasis> NetworkManager</title>
		 <indexterm>
			<primary><emphasis role="pkg">network-manager</emphasis></primary>
		</indexterm>
		 <para>
			If Network Manager is particularly recommended in roaming setups (see <xref linkend="sect.roaming-network-config" />), it is also perfectly usable as the default network management tool. You can create “System connections” that are used as soon as the computer boots either manually with a <filename>.ini</filename>-like file in <filename>/etc/NetworkManager/system-connections/</filename> or through a graphical tool (<command>nm-connection-editor</command>). Just remember to deactivate all entries in <filename>/etc/network/interfaces</filename> if you want Network Manager to handle them. <ulink type="block" url="https://wiki.gnome.org/Projects/NetworkManager/SystemSettings" /> <ulink type="block" url="https://developer.gnome.org/NetworkManager/1.6/ref-settings.html" />
		</para>
		 </sidebar> <section id="sect.interface-ethernet">
			<title>Interfaz Ethernet</title>
			 <para>
				Si el equipo tienen una tarjeta Ethernet, se debe configurar la red IP a la que está asociada eligiendo uno de dos métodos posibles. El método más simple es utilizar una configuración dinámica con DHCP, lo que necesita un servidor DHCP en la red local. Puede indicar un nombre de equipo deseado que corresponde a la configuración <literal>hostname</literal> en el ejemplo a continuación. El servidor DHCP luego envía la configuración para la red apropiada.
			</para>
			 <indexterm>
				<primary>Ethernet</primary>
			</indexterm>
			 <indexterm>
				<primary>DHCP</primary>
			</indexterm>
			 <example id="example.config-dhcp">
				<title>Configuración DHCP</title>
				 
<programlisting>
auto enp0s31f6
iface enp0s31f6 inet dhcp
  hostname arrakis
</programlisting>

			</example>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> Names of network interfaces</title>
			 <indexterm>
				<primary><literal>eth0</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>en*</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>wlan0</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>wl*</literal></primary>
			</indexterm>
			 <para>
				By default, the kernel attributes generic names such a <literal>eth0</literal> (for wired Ethernet) or <literal>wlan0</literal> (for WiFi) to the network interfaces. The number in those names is a simple incremental counter representing the order in which they have been detected. With modern hardware, that order might change for each reboot and thus the default names are not reliable.
			</para>
			 <para>
				Fortunately, systemd and udev are able to rename the interfaces as soon as they appear. The default name policy is defined by <filename>/lib/systemd/network/99-default.link</filename> (see <citerefentry><refentrytitle>systemd.link</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> for an explanation of the <literal>NamePolicy</literal> entry in that file). In practice, the names are often based on the device's physical location (as guessed by where they are connected) and you will see names starting with <literal>en</literal> for wired ethernet and <literal>wl</literal> for WiFi. In the example above, the rest of the name indicates, in abbreviated form, a PCI (<literal>p</literal>) bus number (<literal>0</literal>), a slot number (<literal>s31</literal>), a function number (<literal>f6</literal>).
			</para>
			 <para>
				Obviously, you are free to override this policy and/or to complement it to customize the names of some specific interfaces. You can find out the names of the network interfaces in the output of <command>ip addr</command> (or as filenames in <filename>/sys/class/net/</filename>).
			</para>
			 </sidebar> <para>
				Una configuración «estática» debe indicar específicamente los parámetros de red. Esto incluye al menos la dirección IP y máscara de subred; a veces también se indican las direcciones de red y de difusión. Se especificará un router conectado al exterior como puerta de enlace.
			</para>
			 <example id="example.static-network">
				<title>Configuración estática</title>
				 
<programlisting>
auto enp0s31f6
iface enp0s31f6 inet static
  address 192.168.0.3
  netmask 255.255.255.0
  broadcast 192.168.0.255
  network 192.168.0.0
  gateway 192.168.0.1
</programlisting>

			</example>
			 <sidebar> <title><emphasis>NOTA</emphasis> Direcciones múltiples</title>
			 <para>
				No sólo es posible asociar diferentes interfaces a una misma tarjeta de red física sino que también es posible asignar varias direcciones IP a una interfaz. Recuerde además que una dirección IP puede corresponder a cualquier cantidad de nombres a través de DNS y que dicho nombre también puede corresponde a cualquier cantidad de direcciones IP numéricas.
			</para>
			 <para>
				Como puede adivinar, las configuraciones pueden ser bastante complejas; pero se utilizan estas opciones sólo en casos muy especiales. Los ejemplos citados son típicos de las configuraciones usuales.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.interface-wireless">
			<title>Wireless Interface</title>
			 <indexterm>
				<primary>wireless</primary>
			</indexterm>
			 <para>
				Getting wireless network cards to work can be a bit more challenging. First of all, they often require the installation of proprietary firmwares which are not installed by default in Debian. Then wireless networks rely on cryptography to restrict access to authorized users only, this implies storing some secret key in the network configuration. Let's tackle those topics one by one.
			</para>
			 <section>
				<title>Installing the required firmwares</title>
				 <indexterm>
					<primary>firmware</primary>
				</indexterm>
				 <indexterm>
					<primary>isenkram</primary>
				</indexterm>
				 <para>
					First you have to enable the non-free repository in APT's sources.list file: see <xref linkend="sect.apt-sources.list" /> for details about this file. Many firmware are proprietary and are thus located in this repository. You can try to skip this step if you want, but if the next step doesn't find the required firmware, retry after having enabled the non-free section.
				</para>
				 <para>
					Then you have to install the appropriate <literal>firmware-*</literal> packages. If you don't know which package you need, you can install the <emphasis role="pkg">isenkram</emphasis> package and run its <command>isenkram-autoinstall-firmware</command> command. The packages are often named after the hardware manufacturer or the corresponding kernel module: <emphasis role="pkg">firmware-iwlwifi</emphasis> for Intel wireless cards, <emphasis role="pkg">firmware-atheros</emphasis> for Qualcomm Atheros, <emphasis role="pkg">firmware-ralink</emphasis> for Ralink, etc. A reboot is then recommended because the kernel driver usually looks for the firmware files when it is first loaded and no longer afterwards.
				</para>

			</section>
			 <section>
				<title>Wireless specific entries in <filename>/etc/network/interfaces</filename></title>
				 <indexterm>
					<primary>WPA</primary>
				</indexterm>
				 <para>
					<emphasis>ifupdown</emphasis> is able to manage wireless interfaces but it needs the help of the <emphasis role="pkg">wpasupplicant</emphasis> package which provides the required integration between <emphasis>ifupdown</emphasis> and the <command>wpa_supplicant</command> command used to configure the wireless interfaces (when using WPA/WPA2 encryption). The usual entry in <filename>/etc/network/interfaces</filename> needs to be extended with two supplementary parameters to specify the name of the wireless network (aka its SSID) and the <emphasis>Pre-Shared Key</emphasis> (PSK).
				</para>
				 <example id="example.config-wireless">
					<title>DHCP configuration for a wireless interface</title>
					 
<programlisting>
auto wlp4s0
iface wlp4s0 inet dhcp
  wpa-ssid Falcot
  wpa-psk ccb290fd4fe6b22935cbae31449e050edd02ad44627b16ce0151668f5f53c01b
</programlisting>
				</example>
				 <para>
					The <literal>wpa-psk</literal> parameter can contain either the plain text passphrase or its hashed version generated with <command>wpa_passphrase <replaceable>SSID</replaceable> <replaceable>passphrase</replaceable></command>. If you use an unencrypted wireless connection, then you should put a <literal>wpa-key-mgmt NONE</literal> and no <literal>wpa-psk</literal> entry. For more information about the possible configuration options, have a look at <filename>/usr/share/doc/wpasupplicant/README.Debian.gz</filename>.
				</para>
				 <para>
					At this point, you should consider restricting the read permissions on <filename>/etc/network/interfaces</filename> to the root user only since the file contains a private key that not all users should have access to.
				</para>
				 <sidebar> <title><emphasis>HISTORY</emphasis> WEP encryption</title>
				 <indexterm>
					<primary>WEP</primary>
				</indexterm>
				 <para>
					Usage of the deprecated WEP encryption protocol is possible with the <emphasis role="pkg">wireless-tools</emphasis> package. See <filename>/usr/share/doc/wireless-tools/README.Debian</filename> for instructions.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.ppp-rtc">
			<title>Conexión con PPP a través de un módem PSTN</title>
			 <indexterm>
				<primary>PPP</primary>
			</indexterm>
			 <indexterm>
				<primary>punto a punto</primary>
			</indexterm>
			 <indexterm>
				<primary>conexión</primary>
				<secondary>por módem PSTN</secondary>
			</indexterm>
			 <indexterm>
				<primary>módem</primary>
				<secondary>PSTN</secondary>
			</indexterm>
			 <para>
				Una conexión punto a punto (PPP) establece una conexión intermitente; esta es la solución más común para conexiones realizadas con un teléfono módem («módem PSTN» ya que se realiza la conexión a través de la red pública conmutada de teléfonos: «Public Switched Telephone Network»).
			</para>
			 <para>
				Una conexión por teléfono módem necesita una cuenta con un proveedor de acceso, lo que incluye un número de teléfono, nombre de usuario, contraseña y a veces el protocolo de autenticación a utilizar. Se configura dicha conexión utilizando la herramienta <command>pppconfig</command> en el paquete Debian del mismo nombre. De forma predeterminada, configura una conexión llamada <literal>provider</literal> («proveedor» en inglés). En caso de dudas sobre el protocolo de autenticación, utilice <emphasis>PAP</emphasis>: la mayoría de los proveedores de servicios de Internet lo ofrecen.
			</para>
			 <indexterm>
				<primary><command>pppconfig</command></primary>
			</indexterm>
			 <indexterm>
				<primary>PAP</primary>
			</indexterm>
			 <para>
				Después de la configuración, es posible conectarse utilizando la orden <command>pon</command> (pasándole como parámetro el nombre de la conexión cuando el valor predeterminado <literal>provider</literal> no sea apropiado). Se desconecta el enlace con la orden <command>poff</command>. Ambos puede ser ejecutados por el usuario root o cualquier otro usuario siempre que pertenezcan al grupo <literal>dip</literal>.
			</para>
			 <indexterm>
				<primary><command>pon</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>poff</command></primary>
			</indexterm>

		</section>
		 <section id="sect.adsl">
			<title>Conexión a través de un módem ADSL</title>
			 <indexterm>
				<primary>conexión</primary>
				<secondary>a través de un módem ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>módem</primary>
				<secondary>ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>ADSL, módem</primary>
			</indexterm>
			 <para>
				El término genérico «módem ADSL» cubre una multitud de dispositivos con funcionalidades muy diferentes. Los módems más sencillos de utilizar con Linux son aquellos con una interfaz Ethernet (y no sólo una interfaz USB). Tienden a ser populares, la mayoría de los proveedores de servicios de Internet ADSL prestan (o alquilan) una «caja» con interfaces Ethernet. La configuración puede variar enormemente dependiendo del tipo de módem.
			</para>
			 <section id="sect.adsl-pppoe">
				<title>Módems compatibles con PPPOE</title>
				 <indexterm>
					<primary>PPPOE</primary>
				</indexterm>
				 <indexterm>
					<primary><command>pppoeconf</command></primary>
				</indexterm>
				 <para>
					Algunos módems Ethernet funcionan con el protocolo PPPOE (punto a punto sobre Ethernet: «Point to Point Protocol Over Ethernet»). La herramienta <command>pppoeconf</command> (del paquete con el mismo nombre) configurará la conexión. Para hacerlo, modifica el archivo <filename>/etc/ppp/peers/dsl-provider</filename> con las configuraciones provistas y almacena la información de inicio de sesión en los archivos <filename>/etc/ppp/pap-secrets</filename> y <filename>/etc/ppp/chap-secrets</filename>. Se recomienda aceptar todas las modificaciones que proponga.
				</para>
				 <para>
					Una vez que se completa esta configuración puede abrir la conexión ADSL con la orden <command>pon dsl-provider</command> y desconectarla con <command>poff dsl-provider</command>.
				</para>
				 <indexterm>
					<primary><literal>dsl-provider</literal></primary>
				</indexterm>
				 <sidebar> <title><emphasis>SUGERENCIA</emphasis> Iniciando <command>ppp</command> en el arranque</title>
				 <indexterm>
					<primary><command>systemd</command></primary>
				</indexterm>
				 <indexterm>
					<primary><command>init</command></primary>
				</indexterm>
				 <para>
					Las conexiones PPP sobre ADSL son, por definición, intermitentes. Ya que generalmente no son cobradas por tiempo existen pocas desventajas a la tentación de mantenerlas siempre encendidas. El modo estándar de hacerlo es utilizar el sistema init.
				</para>
				 <para>
					With systemd, adding an automatically restarting task for the ADSL connection is a simple matter of creating a “unit file” such as <filename>/etc/systemd/system/adsl-connection.service</filename>, with contents such as the following:
				</para>
				 
<programlisting>[Unit]
Description=ADSL connection

[Service]
Type=forking
ExecStart=/usr/sbin/pppd call dsl-provider
Restart=always

[Install]
WantedBy=multi-user.target</programlisting>
				 <para>
					Una vez que el «unit file» ha sido definido, es necesario habilitarlo con <command>systemctl enable adsl-connection</command>. El ciclo sera iniciado manualmente con <command>systemctl start adsl-connection</command>; ademas de ser iniciado automáticamente en el arranque.
				</para>
				 <para>
					En sistemas que no usan <command>systemd</command> (incluyendo <emphasis role="distribution">Wheezy</emphasis> y versiones anteriores de Debian), el estándar System V init funciona de forma distinta. En dichos sistemas, todo lo que necesita es añadir una linea como las siguientes al final del archivo <filename>/etc/inittab</filename>; entonces, en cualquier momento que se pierda la conexión, <command>init</command> se reconectará.
				</para>
				 
<programlisting>
adsl:2345:respawn:/usr/sbin/pppd call dsl-provider</programlisting>
				 <para>
					Para las conexiones ADSL que se desconectan diariamente, este método reduce la duración de la interrupción.
				</para>
				 </sidebar>
			</section>
			 <section id="sect.adsl-pptp">
				<title>Módems compatibles con PPTP</title>
				 <indexterm>
					<primary>PPTP</primary>
				</indexterm>
				 <para>
					El protocolo PPTP (protocolo de túnel punto a punto: «Point-to-Point Tunneling Protocol») fue creado por Microsoft. Desplegado al principio de ADSL fue reemplazado rápidamente por PPPOE. Si le fuerzan a utilizar este protocolo, revise el <xref linkend="sect.pptp" />.
				</para>

			</section>
			 <section id="sect.adsl-dhcp">
				<title>Módems compatibles con DHCP</title>
				 <para>
					Cuando se conecta un módem al equipo a través de un cable Ethernet (cable cruzado), generalmente configurará la conexión de red con DHCP en el equipo; el módem automáticamente actuará como puerta de enlace predeterminada y se encargará del ruteo (lo que quiere decir que gestionará el tráfico de red entre el equipo e Internet).
				</para>
				 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Cable cruzado para una conexión Ethernet directa</title>
				 <indexterm>
					<primary>cable cruzado</primary>
				</indexterm>
				 <para>
					Las tarjetas de red esperan recibir datos en hilos específicos del cable y enviar sus datos en otros. Cuando conecta un equipo a una red local generalmente conecta un cable (recto o cruzado) entre la tarjeta de red y un repetidor o conmutador. Sin embargo, si desea conectar dos equipos directamente (sin un conmutador o repetidor intermedio) debe enrutar la señal enviada por una tarjeta al lado receptor de la otra tarjeta y viceversa. Éste es el propósito de un cable cruzado y la razón por la que se lo utiliza.
				</para>
				 <para>
					Tenga en cuenta que esta distinción se ha vuelto casi irrelevante con el tiempo ya que las tarjetas de red modernas pueden detectar el tipo de cable conectado y adaptarse de forma acorde, por lo que no seria usual que ambos tipos de cable funcionen en una ubicación dada.
				</para>
				 </sidebar> <para>
					Se pueden utilizar de esta forma la mayoría de los «enrutadores ADSL» en el mercado así como también los módem ADLS que entregan los proveedores de servicios de Internet.
				</para>

			</section>

		</section>
		 <section id="sect.roaming-network-config">
			<title>Configuración de red automática para usuarios itinerantes</title>
			 <indexterm>
				<primary><emphasis role="pkg">network-manager</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>red</primary>
				<secondary>configuración errante</secondary>
			</indexterm>
			 <para>
				Muchos ingenieros de Falcot tienen un equipo portátil que, con propósitos profesionales, también utilizan en sus casas. La configuración de red a utilizar varía según la ubicación. En casa puede ser una red inalámbrica (protegida con una clave WPA) mientras que en el trabajo utiliza una red cableada para más seguridad y ancho de banda.
			</para>
			 <para>
				Para evitar tener que conectar y desconectar manualmente las interfaces de red correspondientes, los administradores instalan el paquete <emphasis role="pkg">network-manager</emphasis> en estos equipos errantes. Este software le permite al usuario cambiar fácilmente de una red a otra utilizando un pequeño ícono mostrado en el área de notificación de su entorno gráfico. Pulsar en este ícono muestra una lista de redes disponibles (tanto cableadas como inalámbricas) para que pueda elegir una a utilizar. El programa guarda la configuración para las redes a las que el usuario ya se ha conectado y automáticamente selecciona la mejor red disponible cuando pierde la conexión actual.
			</para>
			 <para>
				Para poder hacerlo el programa está estructurado en dos partes: un demonio ejecutando como root maneja la activación y configuración de las interfaces de red y una interfaz de usuario controla este demonio. PolicyKit gestiona las autorizaciones necesarias para controlar este programa, y Debian configuró PolicyKit de forma que todos los miembros del grupo «netdev» pueden agregar o modificar conexiones con Network Manager.
			</para>
			 <para>
				Network Manager sabe cómo administrar varios tipos de conexión (DHCP, configuración manual, red local), pero sólo si se realiza la configuración desde dentro del mismo programa. Es por eso que ignorará sistemáticamente todas las interfaces de red en el archivo <filename>/etc/network/interfaces</filename> que desconozca. Debido a que Network Manager no provee detalles cuando no se muestran conexiones de red, lo más sencillo es eliminar cualquier configuración del archivo <filename>/etc/network/interfaces</filename> sobre las interfaces que Network Manager debe administrar.
			</para>
			 <para>
				Note que se instalará este programa de forma predeterminada si selecciona la tarea «Entorno de escritorio» durante la instalación inicial.
			</para>

		</section>

	</section>
	 <section id="sect.hostname-name-service">
		<title>Definición del nombre de equipo y configuración del servicio de nombres</title>
		 <indexterm>
			<primary>nombre</primary>
			<secondary>atribución y resolución</secondary>
		</indexterm>
		 <indexterm>
			<primary>asignación de nombres</primary>
		</indexterm>
		 <para>
			El propósito de asignar nombres a números IP es hacerlos fáciles de recordar para la gente. En realidad, una dirección IP identifica una interfaz de red asociada con un dispositivo como una tarjeta de red. Como cada equipo puede tener varias tarjetas de red y varias interfaces en cada tarjeta, un solo equipo puede tener varios nombres en el sistema de nombres de dominio.
		</para>
		 <para>
			Se identifica a cada equipo, sin embargo, por un nombre principal (o «canónico») que se almacena en el archivo <filename>/etc/hostname</filename> y se le comunica al núcleo Linux a través de la orden <command>hostname</command>. El valor actual está disponible en un sistema de archivos virtual y lo puede conseguir con la orden <command>cat /proc/sys/kernel/hostname</command>.
		</para>
		 <indexterm>
			<primary><command>hostname</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> <filename>/proc/</filename> y <filename>/sys/</filename>, sistemas de archivos virtuales</title>
		 <indexterm>
			<primary><filename>/proc/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>proc</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/sys/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>sys</filename></primary>
		</indexterm>
		 <para>
			Se generan los árboles de archivos <filename>/proc/</filename> y <filename>/sys/</filename> a través de sistemas de archivos «virtuales». Este es un método práctico para obtener información del núcleo (mostrando archivos virtuales) y comunicarle información (escribiendo en archivos virtuales).
		</para>
		 <para>
			Se diseñó <filename>/sys/</filename> en particular para proveer acceso a los objetos internos del núcleo, especialmente aquellos que representan los distintos dispositivos en el sistema. El núcleo puede, entonces, compartir mucha información: el estado de cada dispositivo (por ejemplo, si está en modo de ahorro de energía), si es un dispositivo removible, etc. Es importante saber que <filename>/sys/</filename> sólo existe desde la versión de núcleo 2.6.
		</para>
		 </sidebar> <para>
			Sorprendentemente, no se administra el nombre de dominio de la misma forma sino que proviene del nombre completo del equipo, obtenido a través de resolución de nombres. Puede cambiarlo en el archivo <filename>/etc/hosts</filename>; simplemente escriba un nombre completo para el equipo al principio de la lista de nombres asociados con las direcciones del equipo como en el siguiente ejemplo:
		</para>
		 <informalexample> 
<programlisting>
127.0.0.1     localhost
192.168.0.1   arrakis.falcot.com arrakis</programlisting>
		 </informalexample> <indexterm>
			<primary><filename>hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/etc/hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary>dominio</primary>
			<secondary>nombre</secondary>
		</indexterm>
		 <indexterm>
			<primary>nombre</primary>
			<secondary>de dominio</secondary>
		</indexterm>
		 <indexterm>
			<primary>NSS</primary>
		</indexterm>
		 <section id="sect.name-resolution">
			<title>Resolución de nombres</title>
			 <indexterm>
				<primary>resolución</primary>
				<secondary>de nombres</secondary>
			</indexterm>
			 <indexterm>
				<primary>nombre</primary>
				<secondary>resolución</secondary>
			</indexterm>
			 <para>
				El mecanismo de resolución de nombres en Linux es modular y puede utilizar varias fuentes de información declaradas en el archivo <filename>/etc/nsswitch.conf</filename>. La instrucción que determina la resolución de nombres es <literal>hosts</literal>. De forma predeterminada contiene <literal>files dns</literal> que significa que el sistema consultará primero el archivo <filename>/etc/hosts</filename>, luego los servidores DNS. Otras fuentes posibles son los servidores NIS/NIS+ o LDAP.
			</para>
			 <sidebar> <title><emphasis>NOTA</emphasis> NSS y DNS</title>
			 <para>
				Sepa que los programas específicos para realizar consultas de DNS (especialmente <command>host</command>) no utilizan el mecanismo de resolución de nombres estándar (NSS). Como consecuencia no tienen en cuenta <filename>/etc/nsswitch.conf</filename> y, por lo tanto, tampoco <filename>/etc/hosts</filename>.
			</para>
			 </sidebar> <section id="sect.dns-server-configuration">
				<title>Configuración de servidores DNS</title>
				 <indexterm>
					<primary>DNS</primary>
				</indexterm>
				 <indexterm>
					<primary>Servicio de nombres de dominio</primary>
				</indexterm>
				 <para>
					DNS (servicio de nombres de dominio: «Domain Name Service») es un servicio distribuido y jerárquico que asocia nombres a direcciones IP y viceversa. Específicamente puede transformar un nombre amigable para las personas como <literal>www.eyrolles.com</literal> en una dirección IP real, <literal>213.244.11.247</literal>.
				</para>
				 <para>
					Para acceder a la información de DNS, debe tener disponible un servidor DNS para retransmitir sus pedidos. Falcot Corp tiene uno propio, pero es más probable que un usuario particular utilice los servidores de DNS provistos por su ISP.
				</para>
				 <indexterm>
					<primary><filename>resolv.conf</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><literal>nameserver</literal></primary>
				</indexterm>
				 <para>
					Se indican los servidores DNS a utilizar en el archivo <filename>/etc/resolv.conf</filename>, uno por línea, precediendo la dirección IP con la palabra clave <literal>nameserver</literal> como en el ejemplo a continuación:
				</para>
				 
<programlisting>
nameserver 212.27.32.176
nameserver 212.27.32.177
nameserver 8.8.8.8</programlisting>
				 <para>
					Note que el archivo <filename>/etc/resolv.conf</filename> podría ser gestionado automáticamente (y sobreescrito) si la red es gestionada por NetworkManager o configurada vía DHCP.
				</para>

			</section>
			 <section id="sect.etc-hosts">
				<title>El archivo <filename>/etc/hosts</filename></title>
				 <indexterm>
					<primary><filename>hosts</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/hosts</filename></primary>
				</indexterm>
				 <para>
					Si no existe un servidor de nombres en la red local aún es posible definir una pequeña tabla que asocie direcciones IP y nombres de equipos en el archivo <filename>/etc/hosts</filename>, generalmente reservado para estaciones de redes locales. La sintaxis de este archivo es muy simple: cada línea indica una dirección IP específica seguida de una lista de los nombres asociados (el primero debe ser «completamente calificado», lo que significa que debe incluir el nombre de dominio).
				</para>
				 <para>
					Este archivo está disponible aún durante problemas de red o cuando no se puedan alcanzar los servidores de DNS, pero sólo será realmente útil cuando esté en todos los equipos en la red. La menor alteración de asociaciones necesitará que se actualice el archivo en todos lados. Es por esto que el archivo <filename>/etc/hosts</filename> generalmente sólo contiene los más importantes.
				</para>
				 <para>
					Este archivo será suficiente para un red pequeña que no esté conectada a Internet, pero con 5 o más máquinas se recomienda instalar un servidor de DNS propio.
				</para>
				 <sidebar> <title><emphasis>SUGERENCIA</emphasis> Evitando DNS</title>
				 <para>
					Debido a que las aplicaciones revisan el archivo <filename>/etc/hosts</filename> antes de realizar pedidos DNS, es posible incluir información allí que sea diferente a lo que devolvería DNS, por lo tanto evitando la resolución de nombres normal basada en DNS.
				</para>
				 <para>
					Esto permite, en el caso de cambios a DNS que no se hayan propagado aún, probar el acceso a un sitio web con el nombre planeado aún cuando dicho nombre todavía no esté asociado a la IP correcta.
				</para>
				 <para>
					Otro posible uso es redirigir tráfico destinado a un equipo particular a la máquina local, evitando de esta forma cualquier comunicación con dicho equipo. Por ejemplo, puede desviar los nombres de aquellos servidores dedicados a proveer publicidades, evitándolas, lo que resultará en una navegación más fluida y con menos distracciones.
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.user-group-databases">
		<title>Bases de datos de usuarios y grupos</title>
		 <indexterm>
			<primary>usuario</primary>
			<secondary>base de datos</secondary>
		</indexterm>
		 <indexterm>
			<primary>grupo</primary>
			<secondary>base de datos</secondary>
		</indexterm>
		 <indexterm>
			<primary>base de datos</primary>
			<secondary>de usuarios</secondary>
		</indexterm>
		 <indexterm>
			<primary>base de datos</primary>
			<secondary>de grupos</secondary>
		</indexterm>
		 <para>
			Generalmente se almacena la lista de usuarios en el archivo <filename>/etc/passwd</filename> y el archivo <filename>/etc/shadow</filename> almacena las contraseñas cifradas. Ambos son archivos de texto en un formato relativamente simple que pueden leerse y modificarse con un editor de texto. Se muestra cada usuario en una línea con varios campos separados por dos puntos («<literal>:</literal>»).
		</para>
		 <sidebar> <title><emphasis>NOTA</emphasis> Editando archivos de sistema</title>
		 <para>
			Los archivos de sistema mencionados en este capítulo generalmente son archivos en texto plano y pueden editarse con un editor de texto. Dada su importancia para el funcionamiento intrínseco del sistema siempre es buena idea tomar precauciones extras al editar archivos de sistema. Primero, siempre haga una copia o respaldo de un archivo de sistema antes de abrirlo o modificarlo. Segundo, en servidores o equipos en los que más de una persona puedan acceder al mismo archivo al mismo tiempo, tome las medidas adecuadas para evitar corrupción de archivos.
		</para>
		 <para>
			Para este propósito basta utilizar la orden <command>vipw</command> para editar el archivo <filename>/etc/passwd</filename> o <command>vigr</command> para editar <filename>/etc/group</filename>. Éstos programas bloquean el archivo en cuestión antes de ejecutar el editor de texto, (<command>vi</command> de forma predeterminada a menos que se haya modificado la variable de entorno <varname>EDITOR</varname>). La opción <literal>-s</literal> permitirá editar el archivo <foreignphrase>shadow</foreignphrase> correspondiente.
		</para>
		 </sidebar> <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Crypt, una función unidireccional</title>
		 <indexterm>
			<primary>crypt</primary>
		</indexterm>
		 <para>
			<command>crypt</command> es una función unidireccional que transforma una cadena (<varname>A</varname>) a otra cadena (<varname>B</varname>) de forma que no se pueda obtener <varname>A</varname> desde <varname>B</varname>. La única forma de identificar <varname>A</varname> es probar todos sus posibles valores, revisando uno por uno para verificar si la transformación utilizando dicha función produce <varname>B</varname> o no. Utiliza hasta 8 caracteres como entrada (la cadena <varname>A</varname>) y genera una cadena de 13 caracteres imprimibles ASCII (la cadena <varname>B</varname>).
		</para>
		 </sidebar> <section id="sect.etc-passwd">
			<title>Lista de usuarios: <filename>/etc/passwd</filename></title>
			 <para>
				Esta es una lista de los campos en el archivo <filename>/etc/passwd</filename>:
			</para>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/passwd</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>uid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>gid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>GECOS</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>login</literal></primary>
			</indexterm>
			 <itemizedlist>
				<listitem>
					<para>
						nombre de usuario, por ejemplo <literal>rhertzog</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						contraseña: esta es una contraseña cifrada por una función unidireccional (<command>crypt</command>), que utiliza <literal>DES</literal>, <literal>MD5</literal>, <literal>SHA-256</literal> o <literal>SHA-512</literal>. El valor especial «<literal>x</literal>» indica que la contraseña cifrada está almacenada en <filename>/etc/shadow</filename>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uid</literal>: número único que identifica a cada usuario;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: número único del grupo principal del usuario (de forma predeterminada, Debian crea un grupo específico para cada usuario);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>GECOS</literal>: campo de datos que generalmente contiene el nombre completo del usuario;
					</para>

				</listitem>
				 <listitem>
					<para>
						directorio de inicio de sesión, asignado al usuario para almacenar sus archivos personales (al que generalmente apunta la variable de entorno <varname>$HOME</varname>);
					</para>

				</listitem>
				 <listitem>
					<para>
						programa a ejecutar al iniciar sesión. Generalmente es un intérprete de órdenes (consola) que le da libertad al usuario. Si especifica <command>/bin/false</command> (que no hace nada y vuelve el control inmediatamente), el usuario no podrá iniciar sesión.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Grupo Unix</title>
			 <indexterm>
				<primary>grupo</primary>
			</indexterm>
			 <para>
				Un grupo Unix es una entidad que incluye varios usuarios para que puedan compartir archivos fácilmente utilizando el sistema de permisos integrado (obteniendo los mismos permisos). También puede restringir el uso de ciertos programas a un grupo específico.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-shadow">
			<title>El archivo de contraseñas ocultas y cifradas: <filename>/etc/shadow</filename></title>
			 <indexterm>
				<primary><filename>shadow</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/shadow</filename></primary>
			</indexterm>
			 <para>
				El archivo <filename>/etc/shadow</filename> contiene los siguientes campos:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						nombre de usuario;
					</para>

				</listitem>
				 <listitem>
					<para>
						contraseña cifrada;
					</para>

				</listitem>
				 <listitem>
					<para>
						varios campos que administran el vencimiento de la contraseña.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>DOCUMENTACIÓN</emphasis> El formato de los archivos <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> y <filename>/etc/group</filename></title>
			 <para>
				Éstos formatos están documentados en las siguientes páginas de manual: <citerefentry><refentrytitle>passwd</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>shadow</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> y <citerefentry><refentrytitle>group</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>.
			</para>
			 </sidebar> <sidebar> <title><emphasis>SEGURIDAD</emphasis> Seguridad del archivo <filename>/etc/shadow</filename></title>
			 <para>
				A diferencia de su contraparte <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> no puede ser leído por usuarios normales. Cualquiera puede leer cualquier contraseña cifrada en <filename>/etc/password</filename>; un «cracker» podría intentar «romper» (o revelar) una contraseña a través de alguno de los métodos de «fuerza bruta» que, de forma simplificada, adivinan las combinaciones de caracteres utilizadas frecuentemente. Este ataque — llamado «ataque de diccionario» — ya no es posible en sistemas que utilizan <filename>/etc/shadow</filename>.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.account-modification">
			<title>Modificación de una cuenta o contraseña existente</title>
			 <indexterm>
				<primary><command>chsh</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chfn</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chage</command></primary>
			</indexterm>
			 <indexterm>
				<primary>contraseña</primary>
			</indexterm>
			 <para>
				Los siguientes programas permiten modificar la información almacenada en campos específicos de la base de datos de usuarios: <command>passwd</command> le permite a un usuario normal cambiar su contraseña que, a su vez, actualiza el archivo <filename>/etc/shadow</filename>; <command>chfn</command> (cambiar el nombre completo: «CHange Full Name»), reservado para el superusuario (root), modifica el campo <literal>GECOS</literal>. <command>chsh</command> (cambiar consola: «CHange SHell») le permite a un usuario cambiar su consola de inicio de sesión, sin embargo las opciones disponibles estarán limitadas a aquellas mencionadas en <filename>/etc/shells</filename>; el administrador, por el otro lado, no está limitado por esta restricción y puede configurar la consola a cualquier programa de su elección.
			</para>
			 <para>
				Finalmente <command>chage</command> (cambiar edad: «CHange AGE») permite al administrador cambiar la configuración de expiración de la contraseña (la opción <literal>-l <replaceable>usuario</replaceable></literal> mostrará la configuración actual). También puede forzar la expiración de una contraseña utilizando la orden <command>passwd -e <replaceable>usuario</replaceable></command>, que obligará al usuario a cambiar su contraseña la próxima vez que inicie sesión.
			</para>

		</section>
		 <section id="sect.disabling-account">
			<title>Desactivación de una cuenta</title>
			 <indexterm>
				<primary>Desactivación de una cuenta</primary>
			</indexterm>
			 <indexterm>
				<primary>cuenta</primary>
				<secondary>desactivación</secondary>
			</indexterm>
			 <para>
				Puede llegar a necesitar «desactivar una cuenta» (bloquear el acceso a un usuario) como castigo, para una investigación o simplemente en caso de una ausencia prolongada o definitiva de un usuario. Una cuenta desactivada significa que el usuario no podrá iniciar sesión y obtener acceso a la máquina. La cuenta se mantiene intacta en el equipo y no se eliminarán archivos o datos; simplemente es inaccesible. Puede lograr esto utilizando <command>passwd -l <replaceable>usuario</replaceable></command> (bloquear: «lock»). Puede reactivar la cuenta de forma similar, utilizando la opción <literal>-u</literal> (desbloquear: «unlock»).
			</para>
			 <sidebar id="sidebar.intro-nss"> <title><emphasis>YENDO MÁS ALLÁ</emphasis> NSS y bases de datos de sistema</title>
			 <indexterm>
				<primary>NSS</primary>
			</indexterm>
			 <indexterm>
				<primary>Name Service Switch</primary>
			</indexterm>
			 <para>
				En lugar de utilizar los archivos usuales para administrar la lista de usuarios y grupos puede utilizar otros tipos de bases de datos como LDAP o <command>db</command> utilizando el módulo NSS (cambio de servicio de nombres: «Name Service Switch»). Puede encontrar una lista de los módulos utilizados en el archivo <filename>/etc/nsswitch.conf</filename> bajo los elementos <literal>passwd</literal>, <literal>shadow</literal> y <literal>group</literal>. Revise la <xref linkend="sect.config-nss" /> para un ejemplo específico sobre el uso de un módulo NSS para LDAP.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-group">
			<title>Lista de grupos: <filename>/etc/group</filename></title>
			 <para>
				Se enumeran los grupos en el archivo <filename>/etc/group</filename>, una simple base de datos de texto en un formato similar al del archivo <filename>/etc/passwd</filename> con los siguientes campos:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						nombre del grupo;
					</para>

				</listitem>
				 <listitem>
					<para>
						contraseña (opcional): sólo es utilizada para unirse a un grupo cuando no es un miembro normal (con <command>newgrp</command> o <command>sg</command>, revise el recuadro <xref linkend="sidebar.working-with-several-groups" />);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: número único de identificación del grupo;
					</para>

				</listitem>
				 <listitem>
					<para>
						lista de miembros: lista separados por comas de nombres de usuario que son miembros del grupo.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
			</para>
			 <sidebar id="sidebar.working-with-several-groups"> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Trabajar con varios grupos</title>
			 <indexterm>
				<primary><command>newgrp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sg</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>id</command></primary>
			</indexterm>
			 <indexterm>
				<primary>grupo</primary>
				<secondary>modificación</secondary>
			</indexterm>
			 <para>
				Cada usuario puede ser miembro de varios grupos, uno de los cuales es su «grupo principal». El grupo principal de un usuario se crea de forma predeterminada durante la configuración inicial del usuario. De forma predeterminada, cada archivo que cree el usuario pertenece a él así como también a su grupo principal. Esto no es siempre el comportamiento deseado; por ejemplo, cuando el usuario necesita trabajar en un directorio compartido por un grupo distinto a su grupo principal. En este caso, el usuario necesita cambiar el grupo principal utilizando una de las siguientes órdenes: <command>newgrp</command> que inicia una nueva consola, o <command>sg</command> que simplemente ejecuta una orden utilizando un grupo alternativo que se provea. Estas órdenes le permiten al usuario unirse a un grupo al que no pertenecen. Si el grupo está protegido por una contraseña necesitarán proveerla antes de ejecutar la orden.
			</para>
			 <para>
				De forma alternativa, el usuario puede activar el bit <literal>setgid</literal> en el directorio, que causa que los archivos creados en él pertenezcan al grupo correcto automáticamente. Para más detalles revise el recuadro <xref linkend="sidebar.setgid-dir" />.
			</para>
			 <para>
				La orden <command>id</command> muestra el estado actual del usuario, con su identificador personal (la variable <varname>uid</varname>), su grupo principal actual (la variable <varname>gid</varname>) y la lista de grupos a los que pertenece (la variable <varname>groups</varname>).
			</para>
			 </sidebar> <indexterm>
				<primary><filename>group</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/group</filename></primary>
			</indexterm>
			 <para>
				The <command>addgroup</command> and <command>delgroup</command> commands add or delete a group, respectively. The <command>groupmod</command> command modifies a group's information (its <literal>gid</literal> or identifier). The command <command>gpasswd <replaceable>group</replaceable></command> changes the password for the group, while the <command>gpasswd -r <replaceable>group</replaceable></command> command deletes it.
			</para>
			 <indexterm>
				<primary><command>addgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>delgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>groupmod</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>gpasswd</command></primary>
			</indexterm>
			 <indexterm>
				<primary>grupo</primary>
				<secondary>creación</secondary>
			</indexterm>
			 <indexterm>
				<primary>creación</primary>
				<secondary>de grupos</secondary>
			</indexterm>
			 <indexterm>
				<primary>grupo</primary>
				<secondary>eliminación</secondary>
			</indexterm>
			 <indexterm>
				<primary>eliminar un grupo</primary>
			</indexterm>
			 <sidebar> <title><emphasis>SUGERENCIA</emphasis> <command>getent</command></title>
			 <indexterm>
				<primary><command>getent</command></primary>
			</indexterm>
			 <para>
				El programa <command>getent</command> (obtener elementos: «get entries») revisa las bases de datos de sistema de la forma estándar, utilizando las funciones de la biblioteca apropiada que, a su vez, llaman a los módulos NSS configurados en el archivo <filename>/etc/nsswitch.conf</filename>. El programa acepta uno o dos parámetros: el nombre de la base de datos a revisar y una posible clave de búsqueda. Por lo tanto, la orden <command>getent passwd rhertzog</command> proveerá la información de la base de datos de usuarios sobre el usuario <literal>rhertzog</literal>.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.creating-accounts">
		<title>Creación de cuentas</title>
		 <indexterm>
			<primary>cuenta</primary>
			<secondary>creación</secondary>
		</indexterm>
		 <indexterm>
			<primary>creación</primary>
			<secondary>de cuentas de usuario</secondary>
		</indexterm>
		 <para>
			Una de las primeras acciones que un administrador necesita completar al configurar un nuevo equipo es crear cuentas de usuario. Esto se realiza generalmente con el programa <command>adduser</command> que acepta como parámetro un nombre de usuario para el nuevo usuario a crear.
		</para>
		 <indexterm>
			<primary><command>adduser</command></primary>
		</indexterm>
		 <para>
			El programa <command>adduser</command> realiza unas pocas preguntas antes de crear la cuenta, pero su uso es bastante directo. Su archivo de configuración, <filename>/etc/adduser.conf</filename>, incluye todas las configuraciones interesantes: puede utilizarse para definir automáticamente una cuota para cada nuevo usuario mediante una plantilla de usuario o para cambiar la ubicación de las cuentas de usuario; esto último rara vez es útil pero puede servir cuando posea una gran cantidad de usuarios y desee, por ejemplo, dividir sus cuentas entre varios discos. También puede seleccionar un intérprete de órdenes predeterminada diferente.
		</para>
		 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Cuota</title>
		 <indexterm>
			<primary>cuota</primary>
		</indexterm>
		 <para>
			El término «cuota» («quota») se refiere a un límite en los recursos del equipo que puede utilizar un usuario. Generalmente se refiere a espacio en disco.
		</para>
		 </sidebar> <para>
			El crear una cuenta rellena el directorio personal de un usuario con el contenido de la plantilla <filename>/etc/skel/</filename>. Esto le provee al usuario un conjunto de directorios y archivos de configuración estándar.
		</para>
		 <indexterm>
			<primary>grupo</primary>
			<secondary>agregar un usuario</secondary>
		</indexterm>
		 <indexterm>
			<primary>agregar un usuario a un grupo</primary>
		</indexterm>
		 <para>
			En algunos casos, será útil agregar un usuario a un grupo (diferente a su grupo «principal») para proveerle permisos adicionales. Por ejemplo, un usuario que pertenece al grupo <emphasis>audio</emphasis> puede acceder dispositivos de audio (revise el recuadro <xref linkend="sidebar.special-files" />). Puede conseguirlo ejecutando <command>adduser <replaceable>usuario</replaceable> <replaceable>grupo</replaceable></command>.
		</para>
		 <sidebar id="sidebar.special-files"> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Permisos de acceso a dispositivos</title>
		 <indexterm>
			<primary>dispositivo</primary>
			<secondary>permisos de acceso</secondary>
		</indexterm>
		 <indexterm>
			<primary>archivo</primary>
			<secondary>especial</secondary>
		</indexterm>
		 <indexterm>
			<primary>modo</primary>
			<secondary>carácter</secondary>
		</indexterm>
		 <indexterm>
			<primary>modo</primary>
			<secondary>bloque</secondary>
		</indexterm>
		 <indexterm>
			<primary>bloque, modo</primary>
		</indexterm>
		 <indexterm>
			<primary>carácter, modo</primary>
		</indexterm>
		 <indexterm>
			<primary>especial, archivo</primary>
		</indexterm>
		 <indexterm>
			<primary><command>mknod</command></primary>
		</indexterm>
		 <para>
			En Unix se representa cada dispositivo de hardware periférico con un archivo especial generalmente almacenado en el árbol de archivos bajo <filename>/dev/</filename> (dispositivos: «DEVices»). Existen dos tipos especiales de archivos según la naturaleza del dispositivo: archivos «modo carácter» y «modo bloque», cada modo sólo permite un conjunto limitado de operaciones. Mientras que el modo carácter limita la interacción a operaciones de lectura y escritura, el modo bloque también permite búsquedas entre los datos disponibles. Finalmente, cada archivo especial tiene asociado dos números («mayor» y «menor») que identifica para el núcleo al dispositivo de forma única. Tal archivo, creado con el programa <command>mknod</command> simplemente contiene un nombre simbólico (y más amigable para las personas).
		</para>
		 <para>
			Los permisos de un archivo especial están asociados a los permisos necesarios para acceder al dispositivo en sí mismo. Por lo tanto, un archivo como <filename>/dev/mixer</filename> que representa un mezclador de audio sólo tiene permisos de lectura y escritura para el usuario root y los miembros del grupo <literal>audio</literal>. Sólo éstos usuarios pueden trabajar con el mezclador de audio.
		</para>
		 <para>
			Es importante saber que la combinación de <emphasis role="pkg">udev</emphasis>, <emphasis role="pkg">consolekit</emphasis> y <emphasis role="pkg">policykit</emphasis> pueden agregar permisos adicionales que le permite a usuarios conectados físicamente a una consola (no a través de la red) acceder a ciertos dispositivos.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.shell-environment">
		<title>Entorno de consola</title>
		 <para>
			Los intérpretes de órdenes (o consolas) pueden ser el primer punto de contacto de un usuario con el equipo y, por lo tanto, deben ser suficientemente amigables. La mayoría utiliza scripts de inicialización que permiten configurar su comportamiento (completado automático, texto del prompt, etc.).
		</para>
		 <indexterm>
			<primary>interfaz de línea de órdenes</primary>
		</indexterm>
		 <indexterm>
			<primary>orden, intérprete</primary>
		</indexterm>
		 <indexterm>
			<primary>consola</primary>
		</indexterm>
		 <indexterm>
			<primary><command>bash</command></primary>
		</indexterm>
		 <para>
			<command>bash</command>, la consola estándar, utiliza el script de inicialización <filename>/etc/bash.bashrc</filename> para consolas interactivas y <filename>/etc/profile</filename> para consolas de «inicio de sesión».
		</para>
		 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Consola de inicio de sesión y consola (no) interactiva</title>
		 <para>
			En términos simples, se invoca una consola de inicio de sesión al iniciar sesión en una consola local o remotamente utilizando <command>ssh</command> o explícitamente cuando ejecuta <command>bash --login</command>. Independientemente de si es una consola de inicio de sesión o no, ésta puede ser interactiva (por ejemplo en un terminal de tipo <command>xterm</command>) o no interactiva (como cuando se ejecuta un script).
		</para>
		 </sidebar> <sidebar> <title><emphasis>DESCUBRIMIENTO</emphasis> Otras consolas, otros scripts</title>
		 <para>
			Each command interpreter has a specific syntax and its own configuration files. Thus, <command>zsh</command> uses <filename>/etc/zshrc</filename> and <filename>/etc/zshenv</filename>; <command>tcsh</command> uses <filename>/etc/csh.cshrc</filename>, <filename>/etc/csh.login</filename> and <filename>/etc/csh.logout</filename>. The man pages for these programs document which files they use.
		</para>
		 <indexterm>
			<primary><command>zsh</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>tcsh</command></primary>
		</indexterm>
		 </sidebar> <para>
			En <command>bash</command> es útil activar el «completado automático» en el archivo <filename>/etc/bash.bashrc</filename> (simplemente descomente unas pocas líneas).
		</para>
		 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Completado automático</title>
		 <indexterm>
			<primary>completado automático</primary>
		</indexterm>
		 <para>
			Muchos intérpretes de órdenes proveen funcionalidad de completado que le permite a la consola completar automáticamente el nombre de una orden ingresada parcialmente cuando el usuario pulsa la tecla <keycap>Tab</keycap>. Esto le permite al usuario trabajar más eficientemente y evitar errores.
		</para>
		 <para>
			This function is very powerful and flexible. It is possible to configure its behavior according to each command. Thus, the first argument following <command>apt</command> will be proposed according to the syntax of this command, even if it does not match any file (in this case, the possible choices are <literal>install</literal>, <literal>remove</literal>, <literal>upgrade</literal>, etc.).
		</para>
		 </sidebar> <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> La virgulilla, un atajo a HOME</title>
		 <indexterm>
			<primary>~</primary>
		</indexterm>
		 <indexterm>
			<primary>virgulilla</primary>
		</indexterm>
		 <para>
			La virgulilla se utiliza generalmente para indicar el directorio al que apunta la variable de entorno <varname>HOME</varname> (este es, el directorio personal del usuario, como <filename>/home/rhertzog/</filename>). Los intérpretes de órdenes realizan la substitución automáticamente: <filename>~/hello.txt</filename> se convertirá en <filename>/home/rhertzog/hello.txt</filename>.
		</para>
		 <para>
			La virgulilla también permite acceder al directorio personal de otro usuario. <filename>~rmas/hola.txt</filename> es sinónimo de <filename>/home/rmas/hola.txt</filename>.
		</para>
		 </sidebar> <para>
			Además de éstos scripts comunes, cada usuario puede crear <filename>~/.bashrc</filename> y <filename>~/.bash_profile</filename> para configurar su consola. Los cambios más comunes son el agregado de alias, palabras que son reemplazadas automáticamente con la ejecución de una orden haciendo más fácil su ejecución. Por ejemplo, podría crear el alias <literal>la</literal> para la orden <command>ls -la | less</command>; entonces sólo tendrá que ejecutar <command>la</command> para inspeccionar en detalle el contenido de un directorio.
		</para>
		 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Variables de entorno</title>
		 <indexterm>
			<primary>entorno</primary>
			<secondary>variable de entorno</secondary>
		</indexterm>
		 <indexterm>
			<primary>variable de entorno</primary>
		</indexterm>
		 <para>
			Las variables de entorno permiten almacenar configuraciones globales para la consola u otros programas ejecutados. Son contextuales (cada proceso tiene su propio conjunto de variables de entorno) pero heredables. Esta última característica ofrece la posibilidad a una consola de inicio de sesión de declarar variables que serán pasadas a todos los programas que ejecute.
		</para>
		 </sidebar> <para>
			Definir las variables de entorno predeterminadas es un elemento importante en la configuración de una consola. Dejando de lado las variables específicas a cada consola, es preferible definirlas en el archivo <filename>/etc/environment</filename> ya que es utilizado por los varios programas que podrían iniciar una sesión en consola. Las variables allí definidas usualmente incluyen <varname>ORGANIZATION</varname> que generalmente contiene el nombre de la empresa u organización y <varname>HTTP_PROXY</varname> que indica la existencia y ubicación de un proxy HTTP.
		</para>
		 <sidebar> <title><emphasis>SUGERENCIA</emphasis> Configuración idéntica en todas las consolas</title>
		 <para>
			Los usuarios generalmente desean configurar sus consolas de sesión e interactivas de la misma forma. Para lograrlo, eligen interpretar (utilizando la orden «source») el contenido del archivo <filename>~/.bashrc</filename> desde el archivo <filename>~/.bash_profile</filename>. Es posible hacer lo mismo con archivos comunes a todos los usuarios (ejecutando <filename>/etc/bash.bashrc</filename> desde <filename>/etc/profile</filename>).
		</para>
		 </sidebar>
	</section>
	 <section id="sect.config-printing">
		<title>Configuración de impresoras</title>
		 <indexterm>
			<primary>configuración</primary>
			<secondary>impresión</secondary>
		</indexterm>
		 <indexterm>
			<primary>impresión</primary>
			<secondary>configuración</secondary>
		</indexterm>
		 <para>
			La configuración de impresión solía causar dolores de cabeza tanto a administradores como a usuarios. Estos problemas son ahora algo del pasado gracias a <emphasis role="pkg">cups</emphasis>, el servidor de impresión libre que utiliza el protocolo IPP (protocolo de impresión de internet: «Internet Printing Protocol»).
		</para>
		 <indexterm>
			<primary>IPP</primary>
		</indexterm>
		 <indexterm>
			<primary>Internet Printing Protocol</primary>
		</indexterm>
		 <indexterm>
			<primary><command>cups</command></primary>
		</indexterm>
		 <para>
			This program is divided over several Debian packages: <emphasis role="pkg">cups</emphasis> is the central print server; <emphasis role="pkg">cups-bsd</emphasis> is a compatibility layer allowing use of commands from the traditional BSD printing system (<command>lpd</command> daemon, <command>lpr</command> and <command>lpq</command> commands, etc.); <emphasis role="pkg">cups-client</emphasis> contains a group of programs to interact with the server (block or unblock a printer, view or delete print jobs in progress, etc.); and finally, <emphasis role="pkg">printer-driver-gutenprint</emphasis> contains a collection of additional printer drivers for <command>cups</command>.
		</para>
		 <indexterm>
			<primary><command>lpr</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpq</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>COMUNIDAD</emphasis> CUPS</title>
		 <indexterm>
			<primary>CUPS</primary>
		</indexterm>
		 <indexterm>
			<primary>Common Unix Printing System</primary>
		</indexterm>
		 <para>
			CUPS (sistema Unix común de impresión: «Common Unix Printing System») es un proyecto (y una marca registrada) gestionado por Apple, Inc. <ulink type="block" url="http://www.cups.org/" />
		</para>
		 </sidebar> <para>
			Luego de instalar estos paquetes, puede administrar <command>cups</command> fácilmente a través de una interfaz web en la dirección local: <literal>http://localhost:631/</literal>. Allí podrá agregar impresoras (incluyendo impresoras de red), eliminarlas y administrarlas. También puede administrar <command>cups</command> con la interfaz gráfica proporcionada por el entorno de escritorio. Por útltimo existe tambien la orden de intérprete gráfica <command>system-config-printer</command> (en el paquete de Debian homónimo).
		</para>
		 <indexterm>
			<primary><command>cups</command></primary>
			<secondary>administración</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>NOTA</emphasis> Obsolescencia de <filename>/etc/printcap</filename></title>
		 <para>
			<emphasis>cups</emphasis> no longer uses the <filename>/etc/printcap</filename> file, which is now obsolete. Programs that rely upon this file to get a list of available printers will, thus, fail. To avoid this problem, delete this file and make it a symbolic link (see sidebar <xref linkend="sidebar.symbolic-link" />) to <filename>/run/cups/printcap</filename>, which is maintained by <emphasis>cups</emphasis> to ensure compatibility.
		</para>
		 <indexterm>
			<primary><filename>printcap</filename></primary>
		</indexterm>
		 </sidebar>
	</section>
	 <section id="sect.config-bootloader">
		<title>Configuración del gestor de arranque</title>
		 <indexterm>
			<primary>arranque</primary>
			<secondary>gestor de</secondary>
		</indexterm>
		 <indexterm>
			<primary>gestor de arranque</primary>
		</indexterm>
		 <para>
			Probablemente ya esté funcionando, pero siempre es bueno saber cómo configurar e instalar el gestor de arranque en caso que desaparezca del registro maestro de arranque («Master Boot Record»). Esto puede ocurrir luego de la instalación de otro sistema operativo como Windows. La información a continuación también puede ayudarle a modificar la configuración del gestor de arranque si lo necesita.
		</para>
		 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Registro maestro de arranque («Master boot record»)</title>
		 <indexterm>
			<primary>MBR</primary>
		</indexterm>
		 <indexterm>
			<primary>Master Boot Record</primary>
		</indexterm>
		 <para>
			El registro maestro de arranque (MBR: «Master Boot Record») ocupa los primeros 512 bytes del primer disco duro y es lo primero que carga el BIOS para otorgar el control a un programa capaz de iniciar el sistema operativo deseado. En general, se instala el gestor de arranque en el MBR eliminando su contenido anterior.
		</para>
		 </sidebar> <section id="sect.identify-disks">
			<title>Identificación de discos</title>
			 <sidebar> <title><emphasis>CULTURA</emphasis> <emphasis>udev</emphasis> y <filename>/dev/</filename></title>
			 <para>
				El directorio <filename>/dev/</filename> tradicionalmente almacena los llamados archivos «especiales» con el objetivo de representar los periféricos del sistema (revise el recuadro <xref linkend="sidebar.special-files" />). Originalmente, solía contener todos los archivos especiales que podrían llegar a utilizarse. Este enfoque acarreaba algunas desventajas, entre las que se encontraba el hecho que restringía la cantidad de dispositivos que podíamos utilizar (debido a la lista estática de nombres) y era imposible saber cuáles archivos especiales eran realmente útiles.
			</para>
			 <para>
				Hoy en día, la gestión de archivos especiales es completamente dinámica y más acorde a la naturaleza de los dispositivos electrónicos que pueden conectarse y desconectarse en caliente. El núcleo coopera con <emphasis>udev</emphasis> para crearlos y eliminarlos según sea necesario cuando aparecen y desaparecen los dispositivos correspondientes. Por esta razón, <filename>/dev/</filename> no necesita ser persistente y es un sistema de archivos basado en RAM que comienza vacío y sólo contiene los elementos relevantes.
			</para>
			 <para>
				El núcleo comunica mucha información sobre los dispositivos agregados recientemente y provee un par de números mayor/menor para identificarlo. Con esta información, <command>udevd</command> puede crear un archivo especial con el nombre y los permisos que desee. También puede crear alias y llevar a cabo acciones adicionales (por ejemplo las tareas de inicialización o registro). El comportamiento de <command>udevd</command> es controlado por un gran conjunto de reglas (personalizables).
			</para>
			 <para>
				Utilizando nombres asignados dinámicamente, puede mantener el mismo nombre para un dispositivo dado sin importar el conector que utilice o el orden en que lo haga, algo particularmente útil cuando utiliza varios periféricos USB. Puede llamar la primera partición del primer disco dura <filename>/dev/sda1</filename> por cuestiones de compatibilidad, <filename>/dev/root-partition</filename> si lo prefiere o inclusive ambos simultáneamente ya que puede configurar <command>udevd</command> para que cree un enlace simbólico automáticamente.
			</para>
			 <para>
				Antiguamente se cargaban automáticamente algúnos módulos del núcleo cuando intentaba acceder al archivo de dispositivo correspondiente. Ahora no es el caso y el archivo especial del dispositivo ya no existe antes de cargar el módulo; no representa ningún problema ya que la mayoría de los módulos se cargan durante el arranque gracias a la detección automática de hardware. Sin embargo esto no funciona para periféricos no detectables (como discos antiguos o periféricos PS/2). Considere agregar los módulos <literal>floppy</literal>, <literal>psmouse</literal> y <literal>mousedev</literal> al archivo <filename>/etc/modules</filename> para forzar que se carguen dichos módulos durante el arranque.
			</para>
			 </sidebar> <indexterm>
				<primary>disco duro, nombre</primary>
			</indexterm>
			 <indexterm>
				<primary>nombres</primary>
				<secondary>de discos duros</secondary>
			</indexterm>
			 <para>
				La configuración del gestor de arranque debe identificar los diferentes discos duros y sus particiones. Linux utiliza archivos especiales de «bloque» almacenados en el directorio <filename>/dev/</filename>. A partir de Debian <emphasis role="distribution">Squeeze</emphasis> se ha unificado el esquema de nombres para los discos duros en el núcleo Linux y todos los discos duros (IDE/PATA, SATA, SCSI, USB, IEEE 1394) son representados con <filename>/dev/sd*</filename>.
			</para>
			 <para>
				Se representa cada partición por su número en el disco en el que existe: por ejemplo, <filename>/dev/sda1</filename> es la primera partición del primer disco y <filename>/dev/sdb3</filename> es la tercera partición del segundo disco.
			</para>
			 <indexterm>
				<primary>partición</primary>
				<secondary>primaria</secondary>
			</indexterm>
			 <indexterm>
				<primary>partición</primary>
				<secondary>extendida</secondary>
			</indexterm>
			 <indexterm>
				<primary>partición</primary>
				<secondary>secundaria</secondary>
			</indexterm>
			 <indexterm>
				<primary>tabla de particiones</primary>
				<secondary>formato MS-DOS</secondary>
			</indexterm>
			 <para>
				La arquitectura de PC (o «i386», incluyendo también la "amd64" ) ha venido estando limitada a utilizar el formato de tabla de particiones "MS-DOS", que sólo permite cuatro particiones «primarias» por disco. Para superar esta limitación, bajo este esquema una de ellas debe ser creada como una partición «extendida» y ésta luego puede contener varias particiones «secundarias» (N.T. la denominación tradicional, al menos en España es «unidades lógicas») adicionales. Estas particiones secundarias se numeran a partir del 5. Por lo tanto, la primera partición secundaria sería <filename>/dev/sda5</filename> seguida de <filename>/dev/sda6</filename>, etc.
			</para>
			 <para>
				Otra restricción del formato de la tabla de particiones de MS-DOS es que sólo permite discos de hasta 2 TiB de tamaño, lo cual está comenzando a ser un problema real con los discos recientes.
			</para>
			 <indexterm>
				<primary>GPT</primary>
				<secondary>formato de la tabla de particiones</secondary>
			</indexterm>
			 <indexterm>
				<primary>partición</primary>
				<secondary>primaria</secondary>
			</indexterm>
			 <para>
				Un nuevo formato de tabla de particiones, llamado GPT relaja estas restricciones sobre el número de particiones (permite hasta 128 particiones utilizando los ajustes predeterminados) y sobre el tamaño de los discos (hasta 8 ZiB, que es más de 8 billones de terabytes). Si se pretenden crear muchas particiones físicas en el mismo disco debería utilizarse el formato GPT para particionar el disco.
			</para>
			 <para>
				No siempre es sencillo recordar qué disco está conectado a qué controlador SATA o está en la tercera posición de la cadena SCSI, especialmente desde que el nombre de los discos duros removibles (que incluye, entre otros, la mayoría de los discos SATA y discos externos) puede cambiar de un inicio a otro. Afortunadamente <command>udev</command> crea, además de <filename>/dev/sd*</filename>, enlaces simbólicos con nombres fijos que puede utilizar si lo desea para identificar un disco duro de forma unívoca. Estos enlaces simbólicos son almacenados en <filename>/dev/disk/by-id</filename>. En un equipo con dos discos físicos, por ejemplo, uno podría encontrar lo siguiente:
			</para>
			 
<screen><computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l
</userinput><computeroutput>total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </computeroutput></screen>
			 <para>
				Es importante notar que algunos discos aparecen varias veces (porque se comportan como discos ATA así también como discos SCSI), pero la información relevante es principalmente en el modelo y número serie del disco con los que puede encontrar el archivo del periférico.
			</para>
			 <para>
				Los archivos de configuración de ejemplo provistos en las próximas secciones están basados en la misma instalación: un único disco SATA donde la primera partición es una antigua instalación de Windows y la segunda contiene Debian GNU/Linux.
			</para>

		</section>
		 <section id="sect.config-lilo">
			<title>Configuración de LILO</title>
			 <indexterm>
				<primary>LILO</primary>
			</indexterm>
			 <indexterm>
				<primary>Linux Loader</primary>
			</indexterm>
			 <para>
				<emphasis>LILO</emphasis> (cargador de Linux: «LInux LOader») es el gestor de arranque más antiguo — sólido pero rústico. Escribe la dirección física del núcleo a inciar en el MBR, razón por la que debe seguir cada actualización de LILO (o su archivo de configuración) con una ejecución de <command>lilo</command>. Olvidarlo hará que el sistema no pueda iniciar si se eliminó o reemplazó el núcleo antiguo ya que el nuevo no estará en la misma ubicación en el disco.
			</para>
			 <para>
				El archivo de configuración de LILO es <filename>/etc/lilo.conf</filename>; se muestra en el ejemplo a continuación un archivo simple con la configuración estándar.
			</para>
			 <example id="example.lilo.conf">
				<title>Archivo de configuración de LILO</title>
				 
<programlisting>
# El disco en el que instalar LILO
# Indicar un disco en lugar de una partición
# instalará LILO en el MBR.
boot=/dev/sda
# la partición que contiene Debian
root=/dev/sda2
# el elemento a cargar de forma predeterminada
default=Linux

# la imagen de núcleo más reciente
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Núcleo antiguo (si el recientemente instalado no inicia)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# sólo para inicio dual Linux/Windows
other=/dev/sda1
  label=Windows</programlisting>

			</example>

		</section>
		 <section id="sect.config-grub">
			<title>Configuración de GRUB 2</title>
			 <indexterm>
				<primary>GRUB</primary>
			</indexterm>
			 <indexterm>
				<primary>GRUB 2</primary>
			</indexterm>
			 <para>
				<emphasis>GRUB</emphasis> (gran gestor de arranque unificado: «GRand Unified Bootloader») es más reciente. No es necesario ejecutarlo luego de cada actualización del núcleo, <emphasis>GRUB</emphasis> sabe cómo leer los sistemas de archivos y encontrar la ubicación del núcleo en el disco por su cuenta. Para instalarlo en el MBR del primer disco simplemente ejecute <command>grub-install /dev/sda</command>. <indexterm><primary><command>grub-install</command></primary></indexterm>
			</para>
			 <sidebar> <title><emphasis>NOTA</emphasis> Nombres de disco para GRUB</title>
			 <para>
				GRUB sólo puede identificar discos duros basándose en la información provista por el BIOS. <literal>(hd0)</literal> corresponde al primer disco detectado, <literal>(hd1)</literal> al segundo, etc. En la mayoría de los casos este orden se corresponde exactamente con el orden usual de discos bajo Linux, pero puede ocurrir problemas cuando asocie discos IDE y SCSI. GRUB almacena las correspondencias que detecta en el archivo <filename>/boot/grub/device.map</filename>. Si encuentra errores allí (porque sabe que su BIOS detecta dispositivos en un orden diferente), corríjalo manualmente y ejecute <command>grub-install</command> nuevamente. <command>grub-mkdevicemap</command> puede ayudar a crear un archivo <filename>device.map</filename> a partir del cual comenzar.
			</para>
			 <para>
				Las particiones también tienen nombres específicos en GRUB. Cuando utilice particiones «clásicas» en el formato MS-DOS, la primera partición en el primer disco corresponderá con la etiqueta <literal>(hd0, msdos1)</literal>, la segunda con <literal>(hd0,msdos2)</literal>, etc.
			</para>
			 </sidebar> <para>
				GRUB 2 configuration is stored in <filename>/boot/grub/grub.cfg</filename>, but this file (in Debian) is generated from others. Be careful not to modify it by hand, since such local modifications will be lost the next time <command>update-grub</command> is run (which may occur upon update of various packages). The most common modifications of the <filename>/boot/grub/grub.cfg</filename> file (to add command line parameters to the kernel or change the duration that the menu is displayed, for example) are made through the variables in <filename>/etc/default/grub</filename>. To add entries to the menu, you can either create a <filename>/boot/grub/custom.cfg</filename> file or modify the <filename>/etc/grub.d/40_custom</filename> file. For more complex configurations, you can modify other files in <filename>/etc/grub.d</filename>, or add to them; these scripts should return configuration snippets, possibly by making use of external programs. These scripts are the ones that will update the list of kernels to boot: <filename>10_linux</filename> takes into consideration the installed Linux kernels; <filename>20_linux_xen</filename> takes into account Xen virtual systems, and <filename>30_os-prober</filename> lists other operating systems (Windows, OS X, Hurd).
			</para>

		</section>
		 <section id="sect.config-yaboot">
			<title>Para equipos Macintosh (PowerPC): configuración de Yaboot</title>
			 <indexterm>
				<primary><command>yaboot</command></primary>
			</indexterm>
			 <para>
				Yaboot es el gestor de arranque utilizado por equipos Macintosh antiguos que utilizan procesadores PowerPC. No arrancan como PCs sino que necesitan una partición de arranque desde la que el BIOS (u OpenFirmware) ejecuta el gestor y en la que el programa <command>ybin</command> instala <command>yaboot</command> y su achivo de configuración. Sólo necesitará ejecutar este programa nuevamente si se modifica <filename>/etc/yaboot.conf</filename> (se lo duplica en la partición de arranque y <command>yaboot</command> sabe cómo encontrar la posición de los núcleos en el disco).
			</para>
			 <para>
				Antes de ejecutar <command>ybin</command> primero debe tener un archivo <filename>/etc/yaboot.conf</filename> válido. Lo que sigue es un ejemplo de configuración mínimo. <indexterm><primary><command>ybin</command></primary></indexterm>
			</para>
			 <example id="example.yaboot.conf">
				<title>Archivo de configuración de Yaboot</title>
				 
<programlisting>
# partición de arranque
boot=/dev/sda2
# el disco
device=hd:
# la partición Linux
partition=3
root=/dev/sda3
# arrancar luego de 3 segundos de inactividad
# (timeout es en décimas de segundo)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# último núcleo instalado
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# núcleo antiguo
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# sólo para arranque dual Linux/Mac OSX
macosx=/dev/sda5

# también son válidos
# bsd=/dev/sdaX y macos=/dev/sdaX</programlisting>

			</example>

		</section>

	</section>
	 <section id="sect.config-misc">
		<title>Otras configuraciones: sincronización de tiempo, registros, acceso compartido…</title>
		 <para>
			Es recomendable que cualquiera que quiera dominar todos los aspectos de configuración de un sistema GNU/Linux conozca los muchos elementos incluidos en esta sección. Se los trata, sin embargo, brevemente y generalmente lo dirigirán a la documentación.
		</para>
		 <section id="sect.timezone">
			<title>Zona horaria</title>
			 <indexterm>
				<primary>zona horaria</primary>
			</indexterm>
			 <sidebar id="sidebar.symbolic-link"> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Enlaces simbólicos</title>
			 <indexterm>
				<primary>enlace</primary>
				<secondary>simbólico</secondary>
			</indexterm>
			 <indexterm>
				<primary>simbólico, enlace</primary>
			</indexterm>
			 <indexterm>
				<primary><command>ln</command></primary>
			</indexterm>
			 <para>
				Un enlace simbólico es un puntero a otro archivo. Cuando accede al mismo, abre el archivo al que apunta. Eliminar el enlace no causará la eliminación del archivo al que apunta. Así mismo, no tiene su propio conjunto de permisos sino que retiene los permisos del archivo al que apunta. Finalmente, puede apuntar a cualquier tipo de archivo: directorios, archivos especiales (zócalos, tuberías con nombres, archivos de dispositivo, etc.), inclusive otros enlaces simbólicos.
			</para>
			 <para>
				La orden <command>ln -s <replaceable>objetivo</replaceable> <replaceable>nombre_del_enlace</replaceable></command> crea un enlace simbólico llamado <replaceable>nombre_del_enlace</replaceable> y que apunta a <replaceable>objetivo</replaceable>.
			</para>
			 <para>
				Si el objetivo no existe entonces el enlace está «roto» y accederlo resultará en un error indicando que el archivo objetivo no existe. Si el enlace apunta a otro enlace, tendrá una «cadena» de enlaces que se convertirá en un «ciclo» si alguno de ellos apunta a uno de sus predecesores. En este caso, acceder a uno de los enlaces en el ciclo resultará en un error específico (demasiados niveles de enlaces simbólicos: «too many levels of symbolic links»); esto significa que el núcleo se rindió luego de varias vueltas en el ciclo.
			</para>
			 </sidebar> <para>
				La zona horaria, configurada durante la instalación inicial, es un elemento de configuración del paquete <emphasis role="pkg">tzdata</emphasis>. Para modificarla ejecute <command>dpkg-reconfigure tzdata</command>, lo que le permitirá seleccionar de forma interactiva la zona horaria a utiliza. Se almacena su configuración en el archivo <filename>/etc/timezone</filename>. Además, se copiará el archivo correspondiente en el directorio <filename>/usr/share/zoneinfo</filename> a <filename>/etc/localtime</filename>; este archivo contiene las reglas sobre las fechas a las que corresponde el horario de verano en los países que lo utilizan.
			</para>
			 <indexterm>
				<primary><filename>timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>zoneinfo</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/usr/share/zoneinfo/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>DST</primary>
			</indexterm>
			 <indexterm>
				<primary>horario de verano</primary>
			</indexterm>
			 <para>
				Cuando necesite cambiar la zona horaria temporalmente utilice la variable de entorno <varname>TZ</varname> que tiene más prioridad que la configurada en el sistema:
			</para>
			 <indexterm>
				<primary><varname>TZ</varname></primary>
			</indexterm>
			 
<screen id="screen.tz">
<computeroutput>$ </computeroutput><userinput>date</userinput>
<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>
<computeroutput>$ </computeroutput><userinput>TZ="Pacific/Honolulu" date</userinput>
<computeroutput>Thu Feb 19 00:25:21 HST 2015</computeroutput></screen>
			 <sidebar> <title><emphasis>NOTA</emphasis> Reloj de sistema, reloj de hardware</title>
			 <para>
				Existen dos fuentes de tiempo en un equipo. La placa madre tiene un reloj de hardware llamado «reloj CMOS». Este reloj no es muy preciso y provee tiempos de acceso bastante lentos. El núcleo del sistema operativo tiene el suyo propio, el reloj de software, que mantiene actualizado a su manera (posiblemente con ayuda de servidores de tiempo, revise la sección <xref linkend="sect.time-synchronization" />). El reloj del sistema generalmente es más preciso, especialmente debido a que no necesita acceso a variables de hardware. Sin embargo, como sólo existe en memoria, es eliminado cada vez que inicia la máquina a diferencia del reloj CMOS que tiene una batería y, por lo tanto, «sobrevive» reinicios de la máquina o cuando está apagada. Por lo tanto, el reloj de sistema es configurado desde el reloj CMOS durante el inicio y el reloj CMOS es actualizado al apagar (para tener en cuenta posibles cambios o correcciones si no se ajustó correctamente).
			</para>
			 <para>
				En la práctica hay un problema, ya que el reloj CMOS no es nada más que un contador no contiene información sobre la zona horaria. Hay una elección a realizar sobre su interpretación: o bien el sistema considera que está en tiempo universal (UTC, anteriormente GMT) o en horario local. Esta elección podría ser un cambio simple pero las cosas son en realidad un poco más complicadas: como resultado del horario de verano, el desfasaje puede no ser constante. El resultado es que el sistema no tiene forma de saber si éste es correcto, especialmente alrededor de períodos de cambios de hora. Debido a que siempre es posible reconstruir la hora local desde tiempo universal y la información de zona horaria recomendamos fuertemente utilizar el reloj CMOS en tiempo universal.
			</para>
			 <para>
				Desafortunadamente, los sistemas Windows en su configuración predeterminada ignoran esta recomendación; mantienen el reloj CMOS en tiempo local aplicando cambios al iniciar el equipo intentando adivinar durante los tiempos de cambio si el cambio ya fue aplicado o no. Esto funciona relativamente bien siempre y cuando el sistema sólo ejecute Windows. Pero cuando un equipo tiene varios sistemas (ya sea una configuración de «inicio dual» o la ejecución de los mismos en máquinas virtuales), se desata el caos siendo imposible determinar la hora correcta. Si debe mantener obligatoriamente Windows en un equipo o bien debería configurarlo para mantener el reloj CMOS en UTC (definiendo la clave de registro DWORD <literal>HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</literal> como «1») o ejecutar <command>hwclock --localtime --set</command> para modificar la hora del reloj en hardware e indicarle que se encuentra en hora local (deberá asegurarse de revisar manualmente su reloj en primavera y otoño).
			</para>
			 </sidebar>
		</section>
		 <section id="sect.time-synchronization">
			<title>Sincronización de tiempo</title>
			 <indexterm>
				<primary>sincronización de tiempo</primary>
			</indexterm>
			 <indexterm>
				<primary>reloj</primary>
				<secondary>sincronización</secondary>
			</indexterm>
			 <para>
				La sincronización de tiempo, que puede parecer superfluo en un equipo, es muy importante en una red. Debido a que los usuarios no tienen permisos para modificar la fecha y hora es importante que esta información sea precisa para evitar confusión. Lo que es más, tener sincronizados todos los equipos de una red permite cruzar referencias de información en registros de diferentes máquinas. Por lo tanto, en caso de un ataque, es más sencillo reconstruir la secuencia cronológica de acciones en todos los equipos involucrados en el mismo. Los datos recolectados en varios equipos por motivos estadísticos no tendrán demasiado sentido si no están sincronizados.
			</para>
			 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> NTP</title>
			 <indexterm>
				<primary>NTP</primary>
			</indexterm>
			 <indexterm>
				<primary>Red</primary>
				<secondary>protocolo de tiempo</secondary>
			</indexterm>
			 <para>
				NTP (protocolo de tiempo de red: «Network Time Protocol») le permite a una máquina sincronizarse con otras muy precisamente teniendo en cuenta las demoras inducidas por la transferencia de información sobre la red y otras desviaciones posibles.
			</para>
			 <para>
				Si bien hay numerosos servidores NTP en Internet, los más populares tienden a estar sobrecargados. Es por eso que recomendamos utilizar el servidor NTP <emphasis>pool.ntp.org</emphasis> que es, en realidad, un grupo de máquinas que acordaron servir como servidores NTP públicos. Inclusive puede limitar el uso a un subgrupo específico de un país con, por ejemplo, <emphasis>us.pool.ntp.org</emphasis> para Estados Unidos o <emphasis>ca.pool.ntp.org</emphasis> para Canadá, etc.
			</para>
			 <para>
				Sin embargo, si administra una red grande, se recomienda que instale su propio servidor NTP que sincroniza con servidores públicos. En este caso, todos los otros equipos en su red pueden utilizar su servidor NTP interno en lugar de aumentar la carga en los servidores públicos. También aumentará la homogeneidad de sus relojes ya que todos los equipos estarán sincronizados desde la misma fuente y esta fuente se encuentra muy cerca en cuestiones de tiempos de tranferencia en la red.
			</para>
			 </sidebar> <section id="sect.ntp-on-workstations">
				<title>Para estaciones de trabajo</title>
				 <para>
					Debido a que las estaciones de trabajo son reiniciadas frecuentemente (aunque sólo sea para ahorrar energía), sincronizarlas por NTP al inicio es suficiente. Para hacerlo, simplemente instale el paquete <emphasis role="pkg">ntpdate</emphasis>. Puede cambiar el servidor NTP utilizado modificando el archivo <filename>/etc/default/ntpdate</filename>.
				</para>
				 <indexterm>
					<primary><filename>ntpdate</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/default/ntpdate</filename></primary>
				</indexterm>

			</section>
			 <section id="sect.ntp-on-servers">
				<title>Para servidores</title>
				 <para>
					Los servidores rara vez son reiniciados y es muy importante que la hora de estos sistemas sea correcta. Para mantener la hora correcta debe instalar un servidor NTP local, un servicio ofrecido en el paquete <emphasis role="pkg">ntp</emphasis>. En su configuración predeterminada el servidor se sincronizará con <emphasis>pool.ntp.org</emphasis> y proveerá la hora como respuesta a pedidos que provengan de la red local. Puede configurarlo editando el archivo <filename>/etc/ntp.conf</filename>, siendo la alteración más importante el servidor NTP al que se refiere. Si la red tiene muchos servidores podría ser interesante tener un servidor de tiempo local que sincroniza con los servidores públicos y es utilizado como fuente de tiempo por los demás servidores de la red.
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">ntp</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary>servidor</primary>
					<secondary>NTP</secondary>
				</indexterm>
				 <indexterm>
					<primary>NTP</primary>
					<secondary>servidor</secondary>
				</indexterm>
				 <sidebar> <title><emphasis>YENDO MÁS ALLÁ</emphasis> Módulos GPS y otras fuentes de tiempo</title>
				 <indexterm>
					<primary>GPS</primary>
				</indexterm>
				 <indexterm>
					<primary>DCF-77</primary>
				</indexterm>
				 <para>
					Si la sincronización de tiempo es particularmente crucial en su red es posible equipar un servidor con un módulo GPS (que utilizará la hora de satélites GPS) o un módulo DCF-77 (que sincronizará la hora con el reloj atómico cerca de Frankfurt, Alemania). en este caso, la configuración del servidor NTP es un poco más complicada y necesitará consultar la documentación.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.rotation-logs">
			<title>Rotación de archivos de registro</title>
			 <indexterm>
				<primary>archivo</primary>
				<secondary>registro, rotación</secondary>
			</indexterm>
			 <indexterm>
				<primary>registros</primary>
				<secondary>archivos, rotación</secondary>
			</indexterm>
			 <indexterm>
				<primary>rotación de archivos de registro</primary>
			</indexterm>
			 <indexterm>
				<primary><command>logrotate</command></primary>
			</indexterm>
			 <para>
				Los archivos de registro pueden crecer, rápido, y es necesario archivarlos. El esquema más común es un archivado rotativo: el archivo de registro es almacenado regularmente y sólo se mantienen los últimos <replaceable>X</replaceable> archivos. <command>logrotate</command>, el programa responsable de estas rotaciones, responde a las directivas presentes en el archivo <filename>/etc/logrotate</filename> y todos los archivos en el directorio <filename>/etc/logrotate.d/</filename>. El administrador puede modificar estos archivos si desean adaptar la política de rotación de registros definida por Debian. La página de manual <citerefentry><refentrytitle>logrotate</refentrytitle>
				 <manvolnum>1</manvolnum></citerefentry> describe todas las opciones disponibles en estos archivos de configuración. Podría desear aumentar la cantidad de archivos mantenidos en la rotación o mover los archivos de registros a un directorio específico dedicado a su archivado en lugar de eliminarlos. También puede enviarlo por email para archivarlos en otro lado.
			</para>
			 <para>
				El programa <command>logrotate</command> es ejecutado diariamente por la aplicación <command>cron</command> (descripta en la <xref linkend="sect.task-scheduling-cron-atd" />).
			</para>

		</section>
		 <section id="sect.sharing-admin-rights">
			<title>Compartición de permisos de administración</title>
			 <indexterm>
				<primary>cuenta</primary>
				<secondary>de administrador</secondary>
			</indexterm>
			 <indexterm>
				<primary>root</primary>
			</indexterm>
			 <indexterm>
				<primary><command>sudo</command></primary>
			</indexterm>
			 <para>
				Frecuentemente, muchos administradores trabajan en la misma red. Compartir contraseñas de root no es muy elegante y abre la puerta al abuso debido al anonimato generado. La solución a este problema es el programa <command>sudo</command> que permite a ciertos usuarios ejecutar ciertas órdenes con permisos especiales. En el caso de uso más común, <command>sudo</command> permite a un usuario confiable ejecutar cualquier orden como root. Para hacerlo, el usuario simplemente ejecuta <command>sudo <replaceable>programa</replaceable></command> y provee su contraseña personal como autenticación.
			</para>
			 <para>
				Al instarlarlo, el paquete <emphasis role="pkg">sudo</emphasis> le provee permisos de root completos a los miembros del grupo Unix <literal>sudo</literal>. Para delegar otros permisos el administrador debe utilizar el programa <command>visudo</command> que le permitirá modificar el archivo de configuración <filename>/etc/sudoers</filename> (aquí nuevamente se invocará el editor <command>vi</command> o cualquier editor indicado en la variable de entorno <varname>EDITOR</varname>). Agregar una línea con <literal><replaceable>usuario</replaceable> ALL=(ALL) ALL</literal> permite al usuario en cuestión ejecutar cualquier programa como root.
			</para>
			 <indexterm>
				<primary><command>visudo</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>sudoers</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/sudoers</filename></primary>
			</indexterm>
			 <para>
				Configuraciones más sofisticadas permiten autorizar sólo órdenes específicas a usuarios específicos. La página de manual <citerefentry><refentrytitle>sudoers</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry> provee todos los detalles de las varias posibilidades.
			</para>

		</section>
		 <section id="sect.fstab-mount-points">
			<title>Lista de puntos de montaje</title>
			 <indexterm>
				<primary>montaje, punto</primary>
			</indexterm>
			 <indexterm>
				<primary>punto de montaje</primary>
			</indexterm>
			 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Montado y desmontado</title>
			 <para>
				En un sistema similar a Unix como Debian, los archivos están organizados en sólo una jerarquía de directorios similar a un árbol. El directorio <filename>/</filename> se llama «directorio raíz»; todos los directorios adicionales son subdirectorios en esta raíz. «Montar» es la acción de incluir el contenido de un dispositivo periférico (generalmente un disco duro) en el árbol de archivos general del sistema. Como consecuencia, si utiliza discos duros diferentes para almacenar los datos personales de los usuarios estos discos tendrán que «montarse» en el directorio <filename>/home/</filename>. El sistema de archivos raíz siempre es montado durante el arranque por el núcleo; los demás dispositivos generalmente son montados durante la secuencia de inicio o manualmente con el programa <command>mount</command>.
			</para>
			 <indexterm>
				<primary><command>mount</command></primary>
			</indexterm>
			 <para>
				Some removable devices are automatically mounted when connected, especially when using the GNOME, Plasma or other graphical desktop environments. Others have to be mounted manually by the user. Likewise, they must be unmounted (removed from the file tree). Normal users do not usually have permission to execute the <command>mount</command> and <command>umount</command> commands. The administrator can, however, authorize these operations (independently for each mount point) by including the <literal>user</literal> option in the <filename>/etc/fstab</filename> file.
			</para>
			 <para>
				Puede utilizar el programa <command>mount</command> sin parámetros (enumerará todos los sistemas de archivos montados). Si desea montar o desmontar un dispositivo necesitará añadirle algunos parámetros. Para la lista completa, revise las siguientes páginas de manual: <citerefentry><refentrytitle>mount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> y <citerefentry><refentrytitle>umount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry>. Para casos simples, la sintaxis también es simple: por ejemplo, para montar la partición <filename>/dev/sdc1</filename>, que tiene un sistema de archivos ext3, en el directorio <filename>/mnt/tmp/</filename> ejecute <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command>.
			</para>
			 </sidebar> <para>
				El archivo <filename>/etc/fstab</filename> tiene una lista de todos los montajes posibles que pueden ocurrir automáticamente durante el inicio o manualmente para dispositivos de almacenamiento removibles. Se describe cada punto de montaje en una línea con varios campos separados por espacios: <indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						file system: this indicates where the filesystem to be mounted can be found, it can be a local device (hard drive partition, CD-ROM) or a remote filesystem (such as NFS).
					</para>
					 <para>
						Generalmente se reemplaza este campo con el ID único del sistema de archivos (que puede encontrar con <command>blkid <userinput>dispositivo</userinput></command>) con el prefijo <literal>UUID=</literal>. Esto previene problemas con cambios en el nombre del dispositivo en caso de agregar o eliminar discos o si se detectan los discos en un orden diferente.
					</para>

				</listitem>
				 <listitem>
					<para>
						punto de montaje: esta es la ubicación del sistema de archivos local donde se montará el dispositivo, sistema remoto o partición.
					</para>

				</listitem>
				 <listitem>
					<para>
						tipo: este campo define el sistema de archivos utilizado en el dispositivo montado. Algunos ejemplos son <literal>ext4</literal>, <literal>ext3</literal>, <literal>vfat</literal>, <literal>ntfs</literal>, <literal>btrfs</literal> y <literal>xfs</literal>.
					</para>
					 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> NFS, un sistema de archivos de red</title>
					 <para>
						NFS es un sistema de archivos de red; en Linux permite acceso transparente a sistemas de archivos remotos incluyéndolos en el sistema de archivos local.
					</para>
					 </sidebar> <para>
						Puede encontrar una lista de todos los sistemas de archivos conocidos en la página de manual <citerefentry><refentrytitle>mount</refentrytitle>
						 <manvolnum>8</manvolnum></citerefentry>. El valor especial <literal>swap</literal> es para particiones swap; el valor especial <literal>auto</literal> le dice al programa <command>mount</command> que detecte automáticamente el sistema de archivos (que es especialmente útil para lectores de discos y llaves USB ya que cada una puede tener diferentes sistemas de archivos);
					</para>

				</listitem>
				 <listitem>
					<para>
						opciones: hay muchas, dependiendo del sistema de archivos, y están documentadas en la página de manual de <command>mount</command>. Las más comunes son
					</para>
					 <itemizedlist>
						<listitem>
							<para>
								<literal>rw</literal> o <literal>ro</literal> que significan que se montará el dispositivo con permisos de lectura y escritura o sólo lectura, respectivamente.
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>noauto</literal> desactiva el montaje automático durante el arranque.
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>nofail</literal> permite continuar al proceso de arranque incluso aunque un dispositivo no esté presente. Aseguresé de poner esta opción para los discos externos que puedan estar desconectados durante el arranque, porque <command>systemd</command> se asegura de que todos los puntos de montaje que deban montarse automáticamente están realmente montados antes de permitir que continúe el proceso. Puede combinar esto con <literal>x-systemd.device-timeout=5s</literal> para instruir a <command>systemd</command> para que no espere más de 5 segundos para que aparezca el dispositivo (vease <citerefentry><refentrytitle>systemd.mount</refentrytitle>
								<manvolnum>5</manvolnum></citerefentry>).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>user</literal> autoriza a todos los usuarios a montar este sistema de archivos (una operación que de otra forma estaría restringida sólo al usuario root).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>defaults</literal> es un sinónimo de la lista de opciones predeterminada: <literal>rw</literal>, <literal>suid</literal>, <literal>dev</literal>, <literal>exec</literal>, <literal>auto</literal>, <literal>nouser</literal> y <literal>async</literal>, cada una de las cuales puede ser desactivada luego de <literal>defaults</literal> agregando <literal>nosuid</literal>, <literal>nodev</literal>, etc. para bloquear <literal>suid</literal>, <literal>dev</literal>, etc. respectivamente. Agregar la opción <literal>user</literal> lo reactiva ya que <literal>defaults</literal> incluye <literal>nouser</literal>.
							</para>

						</listitem>

					</itemizedlist>

				</listitem>
				 <listitem>
					<para>
						dump: this field is almost always set to <literal>0</literal>. When it is <literal>1</literal>, it tells the <command>dump</command> tool that the partition contains data that is to be backed up.
					</para>

				</listitem>
				 <listitem>
					<para>
						pass: this last field indicates whether the integrity of the filesystem should be checked on boot, and in which order this check should be executed. If it is <literal>0</literal>, no check is conducted. The root filesystem should have the value <literal>1</literal>, while other permanent filesystems get the value <literal>2</literal>.
					</para>

				</listitem>

			</itemizedlist>
			 <example id="example.fstab">
				<title>Ejemplo del archivo <filename>/etc/fstab</filename></title>
				 
<programlisting>
# /etc/fstab: información de sistemas de archivos estáticos
#
# &lt;sistema de archivos&gt; &lt;punto de montaje&gt;   &lt;tipo&gt;  &lt;opciones&gt;       &lt;respaldo&gt;  &lt;revisión&gt;
proc            /proc           proc    defaults        0       0
# / era /dev/sda1 durante la instalación
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
# swap se encontraba en /dev/sda5 durante la instalación
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0</programlisting>

			</example>
			 <para>
				El último elemento en este ejemplo corresponde a un sistema de archivos de red (NFS): se montará el directorio <filename>/shared/</filename> en el servidor <emphasis>arrakis</emphasis> en <filename>/shared/</filename> en la máquina local. El formato del archivo <filename>/etc/fstab</filename> está documentado en la página de manual <citerefentry><refentrytitle>fstab</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>.
			</para>
			 <sidebar> <title><emphasis>YENDO MÁS ALLÁ</emphasis> Automontaje</title>
			 <para>
				systemd is able to manage automount points: those are filesystems that are mounted on-demand when a user attempts to access their target mount points. It can also unmount these filesystems when no process is accessing them any longer.
			</para>
			 <para>
				Like most concepts in systemd, automount points are managed with dedicated units (using the <literal>.automount</literal> suffix). See <citerefentry><refentrytitle>systemd.automount</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> for their precise syntax.
			</para>
			 <indexterm>
				<primary><emphasis>am-utils</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><command>amd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>automount</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>autofs</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>montado automático</primary>
			</indexterm>
			 <para>
				Other auto-mounting utilities exist, such as <command>automount</command> in the <emphasis role="pkg">autofs</emphasis> package or <command>amd</command> in the <emphasis role="pkg">am-utils</emphasis>.
			</para>
			 <para>
				Note also that GNOME, Plasma, and other graphical desktop environments work together with <emphasis>udisks</emphasis>, and can automatically mount removable media when they are connected.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.locate-updatedb">
			<title><command>locate</command> y <command>updatedb</command></title>
			 <indexterm>
				<primary><command>locate</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>updatedb</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>mlocate</command></primary>
			</indexterm>
			 <para>
				El programa <command>locate</command> puede encontrar la ubicación de un archivo cuando sólo conozca parte del nombre. Devuelve un resultado casi instantáneamente ya que consulta una base de datos que almacena la ubicación de todos los archivos del sistema; se actualiza esta base de datos diariamente con <command>updatedb</command>. Existen varias implementaciones de <command>locate</command> y Debian eligió <emphasis role="pkg">mlocate</emphasis> para su sistema estándar.
			</para>
			 <para>
				<command>mlocate</command> es suficientemente inteligente y sólo devolverá archivos a los que el usuario que lo ejecutó puede acceder a pesar de que utiliza una base de datos que conoce sobre todos los archivos en el sistema (ya que su implementación de <command>updatedb</command> ejecuta con permisos de root). El administrador puede utilizar <varname>PRUNEDPATHS</varname> en <filename>/etc/updatedb.conf</filename> para excluir la indexación de algunos directorios y lograr seguridad adicional.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-compilation">
		<title>Compilación de un núcleo</title>
		 <indexterm>
			<primary>compilación</primary>
			<secondary>de un núcleo</secondary>
		</indexterm>
		 <indexterm>
			<primary>núcleo</primary>
			<secondary>compilación</secondary>
		</indexterm>
		 <para>
			El núcleo que provee Debian incluye la mayor cantidad de funcionalidad posible así como también la mayor cantidad de controladores para cubrir el espectro más amplio de configuraciones de hardware. Es por esto que algunos usuarios prefieren compilar el núcleo para incluir sólamente lo que necesiten específicamente. Hay dos razones para esta elección. Primero, podría optimizar el consumo de memoria ya que el código del núcleo, aún cuando no sea utilizado, ocupa memoria por nada (y nunca es «bajado» al espacio de swap ya que utiliza RAM real) lo que puede disminuir el rendimiento general del sistema. Un núcleo compilado localmente también puede limitar el riesgo de problemas de seguridad ya que sólo se compila y ejecuta una fracción del código del núcleo.
		</para>
		 <sidebar> <title><emphasis>NOTA</emphasis> Actualizaciones de seguridad</title>
		 <para>
			Si decide compilar su propio núcleo, debe aceptar las consecuencias: Debian no puede asegurar actualizaciones de seguridad para su núcleo personalizado. Al matener el núcleo que provee Debian se beneficia de las actualizaciones preparadas por el equipo de seguridad del Proyecto Debian.
		</para>
		 </sidebar> <para>
			Necesita además recompilar el núcleo si desea utilizar ciertas funcionalidades que sólo están disponibles como parches (y no están incluidas en la versión estándar del núcleo).
		</para>
		 <sidebar> <title><emphasis>YENDO MÁS ALLÁ</emphasis> El libro del núcleo de Debian («Debian Kernel Handbook»)</title>
		 <indexterm>
			<primary><emphasis role="pkg">debian-kernel-handbook</emphasis></primary>
		</indexterm>
		 <para>
			El equipo del núcleo de Debian administra el «Libro del núcleo de Debian» («Debian Kernel Handbook», disponible también en el paquete <emphasis role="pkg">debian-kernel-handbook</emphasis>) que contiene documentación exhaustiva sobre la mayoría de las tareas relacionadas con el núcleo y cómo se gestionan los paquetes Debian oficiales del núcleo. Este es el primer lugar en el que debería buscar si necesita más información que la que provee esta sección. <ulink type="block" url="http://kernel-handbook.alioth.debian.org" />
		</para>
		 </sidebar> <section id="sect.kernel-compilation-prerequisites">
			<title>Introducción y prerequisitos</title>
			 <para>
				No es sorprendete que Debian administre el núcleo como un paquete, que no es la forma tradicional en la que se compilan e instalan núcleos. Debido a que el núcleo se mantiene bajo el control del sistema de paquetes puede ser eliminado limpiamente o desplegado en varias máquinas. Lo que es más, los scripts asociados con estos paquetes automatizan la interacción con el gestor de arranque y el generador de initrd.
			</para>
			 <para>
				Las fuenes de Linux en origen contienen todo lo necesario para crear el paquete Debian del núcleo. Sin embargo, necesitará instalar <emphasis role="pkg">build-essential</emphasis> para asegurarse que posee las herramientas necesarias para crear un paquete Debian. Lo que es más, el paso de configuración para el núcleo necesita el paquete <emphasis>libncurses5-dev</emphasis>. Finalmente, el paquete <emphasis>fakeroot</emphasis> le permitirá crear el paquete Debian sin utilizar permisos de administrador.
			</para>
			 <sidebar> <title><emphasis>CULTURA</emphasis> Los días de <emphasis role="pkg">kernel-package</emphasis></title>
			 <indexterm>
				<primary><emphasis role="pkg">kernel-package</emphasis></primary>
			</indexterm>
			 <para>
				Antes que el sistema de compilación de Linux tuviera la capacidad de crear paquetes Debian apropiados, la forma recomendada de crear dichos paquetes era utilizar <command>make-kpkg</command>, incluído en el paquete <emphasis role="pkg">kernel-package</emphasis>.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-sources">
			<title>Obtención de las fuentes</title>
			 <indexterm>
				<primary>fuentes del núcleo Linux</primary>
			</indexterm>
			 <indexterm>
				<primary>núcleo</primary>
				<secondary>fuentes</secondary>
			</indexterm>
			 <indexterm>
				<primary>fuente</primary>
				<secondary>del núcleo Linux</secondary>
			</indexterm>
			 <para>
				Like anything that can be useful on a Debian system, the Linux kernel sources are available in a package. To retrieve them, just install the <emphasis role="pkg">linux-source-<replaceable>version</replaceable></emphasis> package. The <command>apt search ^linux-source</command> command lists the various kernel versions packaged by Debian. The latest version is available in the <emphasis role="distribution">Unstable</emphasis> distribution: you can retrieve them without much risk (especially if your APT is configured according to the instructions of <xref linkend="sect.apt-mix-distros" />). Note that the source code contained in these packages does not correspond precisely with that published by Linus Torvalds and the kernel developers; like all distributions, Debian applies a number of patches, which might (or might not) find their way into the upstream version of Linux. These modifications include backports of fixes/features/drivers from newer kernel versions, new features not yet (entirely) merged in the upstream Linux tree, and sometimes even Debian specific changes.
			</para>
			 <para>
				The remainder of this section focuses on the 4.9 version of the Linux kernel, but the examples can, of course, be adapted to the particular version of the kernel that you want.
			</para>
			 <para>
				We assume the <emphasis role="pkg">linux-source-4.9</emphasis> package has been installed. It contains <filename>/usr/src/linux-source-4.9.tar.xz</filename>, a compressed archive of the kernel sources. You must extract these files in a new directory (not directly under <filename>/usr/src/</filename>, since there is no need for special permissions to compile a Linux kernel): <filename>~/kernel/</filename> is appropriate.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>
<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-4.9.tar.xz</userinput></screen>
			 <sidebar> <title><emphasis>CULTURA</emphasis> Ubicación de las fuentes del núcleo</title>
			 <para>
				Tradicionalmente, las fuentes del núcleo Linux estarían ubicadas en <filename>/usr/src/linux/</filename> lo que necesitaría permisos de root para compilarlo. Sin embargo, se debe evitar trabajar con permisos de administración cuando no es necesario. Existe un grupo <literal>src</literal> que permite a sus miembros trabajar en este directorio, pero debe evitar trabajar en <filename>/usr/src/</filename> de todas formas. Al mantener las fuentes del núcleo en un directorio personal obtiene seguridad en todos lados: no existirán archivos en <filename>/usr/</filename> ajenos al sistema de paquetes y no hay riesgos de despistar a los programas que leen <filename>/usr/src/linux</filename> al intentar conseguir información sobre el núcleo utilizado.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.config-kernel">
			<title>Configuración del núcleo</title>
			 <indexterm>
				<primary>núcleo</primary>
				<secondary>configuración</secondary>
			</indexterm>
			 <indexterm>
				<primary>configuración</primary>
				<secondary>del núcleo</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>.config</filename></primary>
			</indexterm>
			 <para>
				El siguiente paso consiste en configurar el núcleo según sus necesidades. El procedimiento exacto depende de los objetivos.
			</para>
			 <para>
				Al recompilar una versión más reciente del núcleo (posiblemente con un parche adicional), probablemente mantenga la configuración tan parecida a la propuesta por Debian como le sea posible. En este caso, y en lugar de reconfigurar todo desde cero, es suficiente copiar el archivo <filename>/boot/config-<replaceable>versión</replaceable></filename> (la versión es la del núcleo utilizado actualmente, que puede encontrarse con <command>uname -r</command>) en un archivo <filename>.config</filename> en el directorio que contenga las fuentes del núcleo.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cp /boot/config-4.9.0-3-amd64 ~/kernel/linux-source-4.9/.config</userinput></screen>
			 <para>
				A menos que necesite cambiar la configuración, puede parar aquí y continua en <xref linkend="sect.kernel-build" />. Si, por el otro lado, necesita cambiarla o si decide reconfigurar todo desde cero, debe tomarse el tiempo de configurar su núcleo. Hay varias interfaces dedicadas en el directorio de fuentes del núcleo que puede utilizar ejecutando <command>make <replaceable>objetivo</replaceable></command> donde <replaceable>objetivo</replaceable> es uno de los valores descriptos a continuación.
			</para>
			 <para>
				<command>make menuconfig</command> compila y ejecuta una interfaz en modo texto (aquí es donde necesita el paquete <emphasis role="pkg">libncurses5-dev</emphasis>) que permite navegar entre las opciones disponibles en una estructura jerárquica. Pulsar la tecla <keycap>Espacio</keycap> cambia el valor de la opción seleccionada y <keycap>Enter</keycap> valida el botón seleccionado al pie de la pantalla; <guibutton>Seleccionar</guibutton> vuelve al submenú seleccionado; <guibutton>Salir</guibutton> cierra la pantalla actual y vuelve un paso atrás en la jerarquía; <guibutton>Ayuda</guibutton> mostrará información más detallada sobre el comportamiento de la opción seleccionada. Las teclas de flecha le permiten moverse en la lista de opciones y botones. Para salir del programa de configuración, seleccione <guibutton>Salir</guibutton> del menú principal. El programa luego ofrece guardar los cambios que realizó; acéptelos si está satisfecho con sus selecciones.
			</para>
			 <para>
				Otras interfaces tienen funcionalidades similares pero trabajan con interfaces gráficas más modernas; como <command>make xconfig</command> que utiliza una interfaz gráfica Qt y <command>make gconfig</command> que utiliza GTK+. La primera necesita el paquete <emphasis role="pkg">libqt4-dev</emphasis> mientras que la última depende de los paquetes <emphasis role="pkg">libglade2-dev</emphasis> y <emphasis role="pkg">libgtk2.0-dev</emphasis>.
			</para>
			 <para>
				Cuando utiliza una de las interfaces de configuración, siempre es buena idea comenzar desde una configuración predeterminada razonable. El núcleo provee tales configuraciones en <filename>arch/<replaceable>arquitectura</replaceable>/configs/*_defconfig</filename> y puede mover la configuración que desee si ejecuta algo similar a <command>make x86_64_defconfig</command> (en el caso de un equipo de 64 bits) o <command>make i386_defconfig</command> (en el caso de un equipo de 32 bits).
			</para>
			 <sidebar> <title><emphasis>SEGURIDAD</emphasis> Gestión de archivos <filename>.config</filename> desactualizados</title>
			 <para>
				Cuando provee un archivo <filename>.config</filename> que fue generado con otra versión del núcleo (generalmente anterior), tendrá que actualizarlo. Puede hacerlo ejecutando <command>make oldconfig</command>, que le preguntará interactivamente las preguntas que corresponden a las nuevas opciones de configuración. Si desea utilizar una respuesta predeterminada a todas estas preguntas, puede ejecutar <command>make olddefconfig</command>. Con <command>make oldnoconfig</command>, se asumirá una respuesta negativa a todas las preguntas.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-build">
			<title>Compilación y creación del paquete</title>
			 <indexterm>
				<primary><command>make deb-pkg</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>NOTA</emphasis> Limpieza antes de recompilar</title>
			 <para>
				Si ya realizó una compilación en el directorio y desea reconstruir todo desde cero (por ejemplo: porque realizó cambios importantes a la configuración del núcleo), tendrá que ejecutar <command>make clean</command> para eliminar los archivos compilados. <command>make distclean</command> elimina todavía más archivos generados, incluyendo también su archivo <filename>.config</filename>, por lo que deberá asegurarse de respaldarlo primero.
			</para>
			 </sidebar> <para>
				Una vez que está lista la configuración del núcleo, simplemente ejecutar <command>make deb-pkg</command> generará hasta 5 paquetes Debian: <emphasis role="pkg">linux-image-<replaceable>versión</replaceable></emphasis> que contiene la imagen del núcleo y los módulos asociados, <emphasis role="pkg">linux-headers-<replaceable>versión</replaceable></emphasis> que contiene los archivos de cabecera necesarios para crear módulos externos, <emphasis role="pkg">linux-firmware-image-<replaceable>versión</replaceable></emphasis> que contiene los archivos de firmware necesarios para algunos controladores (este paquete puede no estar presente cuando se compila el kernel a partir de las fuentes proporcionadas por Debian), <emphasis role="pkg">linux-image-<replaceable>versión</replaceable>-dbg</emphasis> que contiene los símbolos de depuración para la imagen del núcleo y sus módulos y <emphasis role="pkg">linux-libc-dev</emphasis> que contiene las cabeceras relevantes a algunas bibliotecas de espacio de usuario como glibc de GNU.
			</para>
			 <para>
				La cadena <replaceable>versión</replaceable> es la concatenación de la versión de origen (definida por las variables <literal>VERSION</literal>, <literal>PATCHLEVEL</literal>, <literal>SUBLEVEL</literal> y <literal>EXTRAVERSION</literal> en el archivo <filename>Makefile</filename>), el parámetro de configuración <literal>LOCALVERSION</literal> y la variable de entorno <literal>LOCALVERSION</literal>. La versión del paquete reutiliza la misma cadena de versión con una revisión adicional que generalmente aumenta (y es almacenada en <filename>.version</filename>), excepto si lo previene con la variable de entorno <literal>KDEB_PKGVERSION</literal>.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1
</userinput><computeroutput>[...]
$ </computeroutput><userinput>ls ../*.deb
</userinput><computeroutput>../linux-headers-4.9.30-ckt4-falcot_4.9.30-1_amd64.deb
../linux-image-4.9.30-ckt4-falcot_4.9.30-1_amd64.deb
../linux-image-4.9.30-ckt4-falcot-dbg_4.9.30-1_amd64.deb
../linux-libc-dev_4.9.30-1_amd64.deb
</computeroutput></screen>

		</section>
		 <section id="sect.modules-build">
			<title>Compilación de módulos externos</title>
			 <indexterm>
				<primary>núcleo</primary>
				<secondary>módulos externos</secondary>
			</indexterm>
			 <indexterm>
				<primary>módulos</primary>
				<secondary>externos del núcleo</secondary>
			</indexterm>
			 <indexterm>
				<primary><command>dkms</command></primary>
			</indexterm>
			 <para>
				Se mantienen algunos módulos fuera del núcleo Linux oficial. Para utilizarlos debe compilarlos junto al núcleo correspondiente. Debian provee algunos módulos de terceros comunes en paquetes dedicados, como <emphasis role="pkg">xtables-addons-source</emphasis> (módulos adicionales para iptables) o <emphasis role="pkg">oss4-source</emphasis> («Open Sound System», algunos controladores de audio alternativos).
			</para>
			 <para>
				Estos paquetes externos son muchos y variados y no los enumeraremos todos aquí; puede limitar el campo de búsqueda con <command>apt-cache search source$</command>. Sin embargo, una lista completa no es muy útil ya que no hay una razón particular para compilar módulos externos a menos que sepa que los necesita. En estos casos, la documentación del dispositivo típicamente detallará el o los módulos específicos que necesita para funcionar bajo Linux.
			</para>
			 <para>
				Veamos, por ejemplo, el paquete <emphasis role="pkg">virtualbox-source</emphasis>: luego de instalarlo podrá encontrar un compendio <filename>.tar.bz2</filename> de las fuentes del módulo en <filename>/usr/src/</filename>. Si bien podríamos extraer manualmente el archivo y compilar el módulo, en la práctica preferimos automatizarlo con DKMS. La mayoría de los módulos ofrecen la integración necesaria con DKMS en un paquete que finaliza con el sufijo <literal>-dkms</literal>. En nuestro caso, sólo necesitamos instalar el paquete <emphasis role="pkg">xtables-addons-dkms</emphasis> para compilar el módulo del núcleo para el núcleo actual, siempre que esté instalado el paquete <emphasis role="pkg">linux-headers-*</emphasis> que coincida con el núcleo instalado. Por ejemplo, si utiliza <emphasis role="pkg">linux-image-amd64</emphasis> debería instalar también <emphasis role="pkg">linux-headers-amd64</emphasis>.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>
<computeroutput>
[...]
Setting up xtables-addons-dkms (2.12-0.1) ...
Loading new xtables-addons-2.12 DKMS files...
Building for 4.9.0-3-amd64
Building initial module for 4.9.0-3-amd64
Done.

xt_ACCOUNT:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/4.9.0-3-amd64/updates/dkms/
[...]
DKMS: install completed.
$ </computeroutput><userinput>sudo dkms status</userinput>
<computeroutput>xtables-addons, 2.12, 4.9.0-3-amd64, x86_64: installed
$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>
<computeroutput>filename:       /lib/modules/4.9.0-3-amd64/updates/dkms/xt_ACCOUNT.ko
license:        GPL
alias:          ipt_ACCOUNT
author:         Intra2net AG &lt;opensource@intra2net.com&gt;
description:    Xtables: per-IP accounting for large prefixes
[...]
</computeroutput></screen>
			 <sidebar> <title><emphasis>ALTERNATIVA</emphasis> module-assistant</title>
			 <indexterm>
				<primary><emphasis role="pkg">module-assistant</emphasis></primary>
			</indexterm>
			 <para>
				Antes de DKMS, <emphasis role="pkg">module-assistant</emphasis> era la solución más simple para compilar y desplegar módulos del núcleo. Todavía puede utilizarlo, especialmente con paquetes que no poseen integración con DKMS: simplemente ejecutando <command>module-assistant auto-install xtables-addons</command> (o su versión corta: <command>m-a a-i xtables-addons</command>) se compilará el módulo para el núcleo actual, se creará un nuevo paquete Debian que lo contiene y se lo instalará automáticamente.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-patch">
			<title>Aplicación de un parche al núcleo</title>
			 <indexterm>
				<primary>núcleo</primary>
				<secondary>parche</secondary>
			</indexterm>
			 <indexterm>
				<primary>parche de núcleo</primary>
			</indexterm>
			 <para>
				Algunas funcionalidades no están incluidas en el núcleo estándar debido a falta de madurez o algún desacuerdo con los encargados del núcleo. Dichas funcionalidades pueden ser distribuidas como parches que cualquiera puede aplicar a las fuentes del núcleo.
			</para>
			 <para>
				Debian sometimes provides some of these patches in <emphasis role="pkg">linux-patch-*</emphasis> packages but they often don't make it into stable releases (sometimes for the very same reasons that they are not merged into the official upstream kernel). These packages install files in the <filename>/usr/src/kernel-patches/</filename> directory.
			</para>
			 <para>
				Para aplicar uno o más de estos parches instalados, utilice el programa <command>patch</command> en el directorio con las fuentes y luego inicie la compilación del núcleo como ya describimos.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-4.9</userinput>
<computeroutput>$ </computeroutput><userinput>make clean</userinput>
<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.1-4.9.11-201702181444.patch.gz | patch -p1</userinput></screen>
			 <para>
				Sepa que un parche dado no necesariamente funcionará con toda versión del núcleo; es posible que <command>patch</command> falle al aplicarlo en las fuentes del núcleo. Se mostrará un mensaje de error que provee algunos detalles del fallo; en este caso, revise la documentación disponible en el paquete Debian del parche (en el directorio <filename>/usr/share/doc/linux-patch-*/</filename>). En la mayoría de los casos, el desarrollador indica para qué versiones del núcleo está creado el parche.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-installation">
		<title>Instalación de un núcleo</title>
		 <indexterm>
			<primary>instalación</primary>
			<secondary>de un núcleo</secondary>
		</indexterm>
		 <indexterm>
			<primary>núcleo</primary>
			<secondary>instalación</secondary>
		</indexterm>
		 <section id="sect.kernel-package">
			<title>Características de un paquete Debian del núcleo</title>
			 <indexterm>
				<primary><filename>vmlinuz</filename></primary>
			</indexterm>
			 <para>
				Un paquete Debian del núcleo instala la imagen del núcleo (<filename>vmlinuz-<replaceable>versión</replaceable></filename>), su configuración (<filename>config-<replaceable>versión</replaceable></filename>) y su tabla de símbolos (<filename>System.map-<replaceable>versión</replaceable></filename>) en <filename>/boot/</filename>. La tabla de símbolos ayuda a los desarrolladores a entender el significado de un mensaje de error del núcleo; sin ella, los «oops» del núcleo (un «oops» es el equivalente del núcleo a un fallo de segmento en programas en espacio de usuario, en otras palabras, los mensajes generados luego de desreferenciar un puntero de forma inválida) sólo contienen direcciones de memoria numéricas, que es información inútil sin la tabla que enlaza estas direcciones con símbolos y nombres de función. Se instalan los módulos en el directorio <filename>/lib/modules/<replaceable>versión</replaceable>/</filename>.
			</para>
			 <para>
				Los scripts de configuración del paquete generan automáticamente una imagen initrd, que es un minisistema diseñado para ser cargado en memoria (de allí el nombre, que significa «disco ram de inicio»: «init ramdisk») por el gestor de arranque y utilizado por el núcleo Linux sólo para cargar los módulos necesarios para acceder a los dispositivos que contienen el sistema Debian completo (por ejemplo, los controladores de discos SATA). Finalmente, los scripts postinstalación actualizan los enlaces simbólicos <filename>/vmlinuz</filename>, <filename>/vmlinux.old</filename>, <filename>/initrd.img</filename> y <filename>/initrd.img.old</filename> para que apunten a los dos últimos núcleos instalados, respectivamente, así como también a las imágenes initrd correspondientes.
			</para>
			 <para>
				Se encargan la mayoría de estas tareas a scripts de activación en los directorios <filename>/etc/kernel/*.d/</filename>. Por ejemplo, la integración con <command>grub</command> está basada en <filename>/etc/kernel/postinst.d/zz-update-grub</filename> y <filename>/etc/kernel/postrm.d/zz-update-grub</filename> para ejecutar <command>update-grub</command> cuando se instalan o eliminan núcleos.
			</para>

		</section>
		 <section id="sect.kernel-installation-with-dpkg">
			<title>Instalación con <command>dpkg</command></title>
			 <para>
				Using <command>apt</command> is so convenient that it makes it easy to forget about the lower-level tools, but the easiest way of installing a compiled kernel is to use a command such as <command>dpkg -i <replaceable>package</replaceable>.deb</command>, where <literal><replaceable>package</replaceable>.deb</literal> is the name of a <emphasis role="pkg">linux-image</emphasis> package such as <filename>linux-image-4.9.30-ckt4-falcot_1_amd64.deb</filename>.
			</para>
			 <para>
				Los pasos de configuración descriptos en este capítulos son básicos y sirven tanto para un servidor como para una estación de trabajo y pueden ser duplicados masivamente de formas semiautomáticas. Sin embargo, no son suficientes por sí mismas para proveer un sistema completamente configurado. Todavía necesita algunas piezas de configuración, comenzando con programas de bajo nivel conocidas como «servicios Unix».
			</para>

		</section>

	</section>
</chapter>

