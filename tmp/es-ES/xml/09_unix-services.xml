<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="unix-services" lang="es-ES">
	<chapterinfo>
		 <keywordset>
			<keyword>Arranque del sistema</keyword>
			 <keyword>Scripts de inicio</keyword>
			 <keyword>SSH</keyword>
			 <keyword>Telnet</keyword>
			 <keyword>Derechos</keyword>
			 <keyword>Permisos</keyword>
			 <keyword>Supervisión</keyword>
			 <keyword>Inetd</keyword>
			 <keyword>Cron</keyword>
			 <keyword>Respaldo</keyword>
			 <keyword>Conexión en caliente («hotplug»)</keyword>
			 <keyword>PCMCIA</keyword>
			 <keyword>APM</keyword>
			 <keyword>ACPI</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Servicios Unix</title>
	 <highlights> <para>
		Este capítulo cubre un número básico de servicios que son comunes a varios sistemas Unix. Todos los administradores deberían estar familiarizados con ellos.
	</para>
	 </highlights> <section id="sect.system-boot">
		<title>Arranque del sistema</title>
		 <indexterm>
			<primary>inicio</primary>
			<secondary>del sistema</secondary>
		</indexterm>
		 <para>
			Cuando inicia el equipo, los muchos mensajes que aparecen en la pantalla muestran varias inicializaciones y configuraciones automáticas que se están ejecutando. Algunas veces deseará alterar ligeramente cómo funciona esta etapa, lo que significa que necesitará entenderlas bien. Éste es el propósito de esta sección.
		</para>
		 <para>
			Primero el BIOS toma el control del equipo, detecta los discos, carga el <emphasis>registro maestro de arranque</emphasis> («MBR») y ejecuta el gestor de arranque. Éste toma el control, busca el núcleo en el disco, lo carga y lo ejecuta. Luego se inicializa el núcleo y empieza la búsqueda y montaje de la partición que contiene el sistema de archivos raíz y finalmente ejecuta el primer programa — <command>init</command>. Frecuentemente esta «partición raíz» y su <command>init</command> están, de hecho, ubicados en un archivo virtual del sistema que sólo existe en RAM (de aquí el nombre «initramfs», anteriormente llamado «initrd» por «disco RAM de inicialización»: «initialization RAM disk»). El gestor de arranque carga este sistema de archivos en memoria, muchas veces desde un archivo en el disco duro o desde la red. Contiene sólo lo mínimo requerido por el núcleo para cargar el «verdadero» sistema de archivos raíz: estos pueden ser módulos de controladores para el disco duro u otros dispositivos sin los cuales el sistema no puede iniciar o, más frecuentemente, scripts de inicialización y módulos para ensamblar arreglos RAID, abrir particiones cifradas, activar volúmenes LVM, etc. Una vez que se monta la partición raíz, el initramfs entrega el control al verdadero init y la máquina regresa al proceso de inicio estándar.
		</para>
		 <figure id="figure.boot-process-systemd">
			<title>Secuencia de inicio de un equipo ejecutando Linux con systemd</title>
			 <mediaobject>
				<imageobject>
					<imagedata fileref="images/startup-systemd.png" format="PNG" scalefit="1" width="80%" />
				</imageobject>

			</mediaobject>

		</figure>
		 <section id="sect.systemd">
			<title>El sistema de inicio systemd</title>
			 <para>
				Actualmente <emphasis role="pkg">systemd</emphasis> proporciona el «init real» y esta sección documenta este sistema de inicio.
			</para>
			 <sidebar> <title><emphasis>CULTURA</emphasis> Antes de <command>systemd</command></title>
			 <para>
				<command>systemd</command> es un "sistema de inicio" relativamente reciente. Aunque ya estaba disponible parcialmente en <emphasis role="distribution">Wheezy</emphasis>, se ha convertido en el sistema de arranque estándar en Debian a partir de <emphasis role="distribution">Jessie</emphasis>. Las versiones anteriores utilizaban de forma predeterminada el sistema de inico "System V” (del paquete <emphasis role="pkg">sysv-rc</emphasis>), un sistema mucho más tradicional. Se describirá el sistema de inicio System V más adelante.
			</para>
			 </sidebar> <sidebar> <title><emphasis>ALTERNATIVA</emphasis> Otros sistemas de inicio</title>
			 <para>
				Este libro describe el sistema de inicio utilizado de forma predeterminada en Debian <emphasis role="distribution">Jessie</emphasis> (implementado en el paquete <emphasis role="pkg">systemd</emphasis>), así como el estándar anterior, <emphasis role="pkg">sysvinit</emphasis>, el cual se deriva y hereda de los sistemas Unix «<emphasis>System V</emphasis>»; existen otros sistemas de inicio.
			</para>
			 <para>
				<emphasis role="pkg">file-rc</emphasis> es un sistema de inicio con un proceso muy simple. Mantiene el principio de niveles de ejecución pero reemplaza los directorios y enlaces simbólicos con un archivo de configuración que le indica a <command>init</command> los procesos a iniciar y el orden en el que hacerlo.
			</para>
			 <para>
				El sistema <command>upstart</command> todavía no ha sido probado perfectamente en Debian. Está basado en eventos: los scripts de inicio no se ejecutan en un orden secuencial sino en respuesta a eventos como la finalización de otro script del que depende. Este sistema, creado por Ubuntu, está presente en Debian <emphasis role="distribution">Jessie</emphasis> pero no es el predeterminado; sólo viene como reemplazo para <emphasis role="pkg">sysvinit</emphasis> y una de las tareas ejecutadas por <command>upstart</command> es ejecutar los scripts escritos para sistemas tradicionales, especialmente aquellos del paquete <emphasis role="pkg">sysv-rc</emphasis>.
			</para>
			 <para>
				También existen otros sistemas y otros modos de operación, como por ejemplo <command>runit</command> o <command>minit</command> pero estos son bastante especializados y están poco difundidos.
			</para>
			 </sidebar> <sidebar> <title><emphasis>CASO ESPECÍFICO</emphasis> Arranque desde la red</title>
			 <para>
				En algunas situaciones, se puede configurar el BIOS para que no ejecute el MBR sino que busque su equivalente en la red, haciendo posible construir equipos sin disco duro o que son completamente reinstalados en cada arranque. Esta opción no está disponible en todo el hardware y generalmente necesita una combinación apropiada de BIOS y placa de red.
			</para>
			 <para>
				El arranque desde la red puede utilizarse para ejecutar <command>debian-installer</command> o FAI (revise la <xref linkend="sect.installation-methods" />).
			</para>
			 </sidebar> <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> El proceso, una instancia de un programa</title>
			 <indexterm>
				<primary>proceso</primary>
			</indexterm>
			 <para>
				Un proceso es la representación en memoria de un programa en ejecución. Incluye toda la información necesaria para la ejecución apropiada del programa (el código en sí pero también los datos que tiene en memoria, la lista de archivos que ha abierto, las conexiones de red que ha establecido, etc.). Un único programa puede ser instanciado en varios procesos inclusive bajo el mismo ID de usuario.
			</para>
			 </sidebar> <sidebar> <title><emphasis>SEGURIDAD</emphasis> Usar una consola como <command>init</command> para obtener derechos de root</title>
			 <para>
				Por convención el primer proceso que se inicia es el programa <command>init</command> (que por omisión es un enlace simbóico a <filename>/lib/systemd/systemd</filename>). Sin embargo, es posible proveer una opción <literal>init</literal> al núcleo indicando un programa diferente.
			</para>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				Cualquier persona con acceso al equipo puede presionar el botón <keycap>Reset</keycap> y así reiniciarla. Entonces es posible, en el prompt del gestor de arranque, pasar la opción <literal>init=/bin/sh</literal> al núcleo para obtener acceso root sin conocer la contraseña del administrador.
			</para>
			 <para>
				Para prevenirlo puede proteger el gestor de arranque con una contraseña. También podría pensar en proteger el acceso al BIOS (casi siempre tiene disponible un mecanismo de protección por contraseña) sin el cual un intruso malicioso podría iniciar la máquina desde un medio removible que contiene su propio sistema Linux, el cual podría utilizar para tener acceso a los datos del disco duro del equipo.
			</para>
			 <para>
				Finalmente, tenga en cuenta que la mayoría de los BIOS implementan una contraseña genérica. Inicialmente destinado a resolver los problemas de quienes han olvidado su contraseña, éstas ahora son públicas y están disponibles en Internet (puede comprobarlo Vd. mismo buscando «contraseñas genéricas de BIOS» en algún motor de búsqueda). Todas estas protecciones impedirán el acceso no autorizado a la máquina sin poder evitarlo por completo. No existe una forma segura de proteger un equipo si el atacante puede acceder a él físicamente; podría quitar el disco duro para conectarlo a un equipo bajo su control de cualquier manera, o incluso robar la máquina completa o borrar la memoria del BIOS para eliminar la contraseña…
			</para>
			 </sidebar> <para>
				Systemd ejecuta varios procesos que se encargan de configurar el sistema: teclado, controladores, sistemas de archivos, redes, servicios. Hace esto a la vez que mantiene una visión global del sistema como un todo y de los requerimientos de los componentes. Cada componente se describe en un fichero unidad o "unit file" (a veces más de uno). La sintaxis de los mismos se deriva de la de los muy extendidos archivos ".ini". Es decir que utiliza pares <literal><replaceable>clave</replaceable> = <replaceable>valor</replaceable></literal> agrupados entre cabeceras de <literal>[<replaceable>sección</replaceable>]</literal>. Los archivos unit se guardan en <filename>/lib/systemd/system/</filename> y <filename>/etc/systemd/system/</filename>. Aunque hay varios tipos, aquí nos vamos a concentrar en los servicios ("services") y metas ("targets").
			</para>
			 <para>
				Un archivo de servicio ("service file") de systemd describe un proceso gestionado por systemd. Contiene más o menos la misma información que los antiguos scripts de inicio, pero expresada en de forma declarativa (y mucho más concisa). Systemd se ocupa de la mayoría de las tareas repetitivas (arrancar y parar el proceso, comprobar su estado, registrar los errores, soltar privilegios, etc) y el archivo de servico únicamente tiene que proporcionar los parámetros especificos de cada servicio. Por ejemplo aquí se muestra el fichero de servicio para SSH:
			</para>
			 
<programlisting>[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</programlisting>
			 <para>
				Como se puede comprobar no hay apenas código, únicamente declaraciones. Systemd se ocupa de mostrar los informes de progreso, de controlar los procesos e incluso de reiniciarlos cuando sea necesario.
			</para>
			 <para>
				Un fichero de meta ("target file") describe un estado del sistema en el cual se sabe que está operativo un conjunto de servicios. Se puede hacer una analogía los antiguos niveles de ejecución ("runlevels"). Una de las metas es <literal>local-fs.target</literal>; cuando se alcanza, el resto del sistema puede asumir que todos los sistemas de archivos locales están montados y son accesibles. Otros ejemplos de metas pueden ser <literal>network-online.target</literal> o <literal>sound.target</literal>. Las dependencias de una meta se pueden establecer directamente en su archivo de configuración o "target file" (en la línea <literal>Requires=</literal>) o bien utilizando un enlace simbólico a un archivo de servicio ("service file") en el directorio <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal>. Por ejemplo <filename>/etc/systemd/system/printer.target.wants/</filename> contiene un enlace a <filename>/lib/systemd/system/cups.service</filename>; systemd se asegurará de que CUPS esté en ejecución para poder alcanzar la meta <literal>printer.target</literal>.
			</para>
			 <para>
				Puesto que los archivos de unidad son declarativos en lugar de scripts o programas, no se pueden ejecutar directamente; tienen que ser interpretados por systemd. Existen varias utilidades que permiten al administrador interactuar con systemd y controlar el estado del sistema y de cada componente.
			</para>
			 <para>
				La primera de estas utilidades es <command>systemctl</command>. Cuando se ejecuta sin argumentos lista todos los archivos de unidad conocidos por systemd (excepto los que han sido deshabilitados), así como su estado. <command>systemctl status</command> muestra una visión mejor de los servicios y sus procesos relacionados. Si se proporciona el nombre de un servico (como p.ej. <command>systemctl status ntp.service</command>) muestra aún más detealles, así como las últimas líneas del registro relacionadas con el servicio (más información más adelante).
			</para>
			 <para>
				Para arrancar un servicio manualmente basta ejecutar <command>systemctl start <replaceable>nombredelservicio</replaceable>.service</command>. Como se puede suponer, para parar un servicio se hace con <command>systemctl stop <replaceable>nombredelservicio</replaceable>.service</command>; otros subcomandos disponibles son <command>reload</command> y <command>restart</command>.
			</para>
			 <para>
				Para establecer si un servicio está activo (es decir, si se debe arrancar automáticamente al inicio o no) utilce el comando <command>systemctl enable <replaceable>nombredelservicio</replaceable>.service</command> (o <command>disable</command>). <command>is-enabled</command> permite saber si está activo o no.
			</para>
			 <para>
				Una característica interesante de systemd es que incluye un componente de registro llamado <command>journald</command>. Viene como complemento a los sistemas de registro tradicionales como <command>syslogd</command>, pero añade características interesantes como un enlace formal entre un servicio y los mensajes que genera, así como la posibilidad de capturar los mensajes de error generados por su secuencia de inicialización. Los mensajes se pueden mostrar con la ayuda del comando <command>journalctl</command>. Sin argumentos símplemente vuelca todos los mensajes que han ocurrido desde el arranque del sistema, aunque no se suele utilizar de esa forma. Normalmente se utiliza con un identificador de servicio:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</computeroutput></screen>
			 <para>
				Otra opción útil es <command>-f</command>, que hace que <command>journalctl</command> siga mostrando los nuevos mensajes a medida que se van emitiendo (semejante a lo que ocurre con <command>tail -f <replaceable>file</replaceable></command>).
			</para>
			 <para>
				Si un servicio parece que no está funcionando como debiera, el primer paso para resolver el problema es comprobar si el servicio está ejecutándose realmente mediante <command>systemctl status</command>. Si no es así y los mensajes que se muestran no son suficientes para diagnosticar el problema se pueden comprobar los registros que ha recogido journald relacionados con es servicio. Por ejemplo, suponiendo que el servidor SSH no funciona:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>vi /etc/ssh/sshd_config
</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service
</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </computeroutput></screen>
			 <para>
				Después de comprobar el estado del servicio (fallido) comprobamos los registros; indican un error en el archivo de configuración. Después de editar el archivo de configuración y corregir el error reiniciamos el servicio y comprobamos que efectivamente está funcionando.
			</para>
			 <sidebar><title><emphasis>YENDO MÁS ALLÁ</emphasis> Otros tipos de archivos de unidades</title>
			 <para>
				Sólo hemos descrito las funciones más básicas de systemd en esta sección, pero ofrece otras muchas características interesantes; a continuación mecionamos algunas:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						activación de zócalos ("sockets"): se puede usar un archivo de unidad de zócalo ("socket unit file") para describir un zócalo de red o Unix gestionado por systemd. Esto significa que systemd creará este zócalo y que se ejecutará el servicio correspondiente cuando exista un intento de conexión al mismo. Con esto se duplica aproximadamente la funcionalidad de <command>inetd</command>. Ver <citerefentry><refentrytitle>systemd.socket</refentrytitle>
						<manvolnum>5</manvolnum></citerefentry>.
					</para>
				</listitem>
				 <listitem>
					<para>
						temporizadores: un archivo de unidad de temporizador ("timer unit file") describe eventos que se ejecutan periodicamente o en determinados instantes. Cuando un servicio está enlazado con un temporizador la tarea correspondiente se ejecuta cada vez que se dispare el temporizador. Eso permite replicar parte de la funcionalidad de <command>cron</command>. Ver <citerefentry><refentrytitle>systemd.timer</refentrytitle>
						<manvolnum>5</manvolnum></citerefentry>.
					</para>
				</listitem>
				 <listitem>
					<para>
						red: un archivo de unidad de red ("network unit file") describe una interfaz de red y permite su configurarla, así como expresar que un servicio depende de que una interfaz de red determinada esté levantada.
					</para>
				</listitem>

			</itemizedlist>
			</sidebar>
		</section>
		 <section id="sect.sysvinit">
			<title>El sistema de inicio System V</title>
			 <para>
				El sistema de incio System V (al cual llamaremos init por brevedad) ejecuta varios procesos siguiendo instrucciones del archivo <filename>/etc/inittab</filename>. El primer programa que ejecuta (que se corresponde con el paso <emphasis>sysinit</emphasis>) es <command>/etc/init.d/rcS</command>, un script que ejecuta todos los programas del directorio <filename>/etc/rcS.d/</filename>. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm>
			</para>
			 <para>
				Entre estos encontrará sucesivamente programas a cargo de:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						configurar el teclado de la consola;
					</para>

				</listitem>
				 <listitem>
					<para>
						cargar controladores: el núcleo carga por sí mismo la mayoría de los módulos a medida que el hardware es detectado; los controladores extras se cargan automáticamente cuando los módulos correspondientes son listados en <filename>/etc/modules</filename>;
					</para>

				</listitem>
				 <listitem>
					<para>
						verificar la integridad de los sistemas de archivos;
					</para>

				</listitem>
				 <listitem>
					<para>
						montar particiones locales;
					</para>

				</listitem>
				 <listitem>
					<para>
						configurar la red;
					</para>

				</listitem>
				 <listitem>
					<para>
						montar sistemas de archivos de red (NFS).
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Módulos y opciones del núcleo</title>
			 <indexterm>
				<primary>módulos</primary>
				<secondary>del núcleo</secondary>
			</indexterm>
			 <para>
				Los módulos del núcleo también tienen opciones que puede configurar agregando algunos archivos en <filename>/etc/modprobe.d/</filename>. Estas opciones se definen con directivas como: <literal>options <replaceable>nombre-del-módulo</replaceable> <replaceable>nombre-opción</replaceable>=<replaceable>valor-opción</replaceable></literal>. Puede especficar varias opciones con una sola directiva si es necesario.
			</para>
			 <para>
				Estos archivos de configuración están destinados a <command>modprobe</command> — el programa que carga un módulo de núcleo con sus dependencias (los módulos también pueden llamar otros módulos). El paquete <emphasis role="pkg">kmod</emphasis> provee este programa.
			</para>
			 <indexterm>
				<primary><command>modprobe</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">kmod</emphasis></primary>
			</indexterm>
			 </sidebar> <para>
				Despues de esta etapa, <command>init</command> toma el control e inicia los programas activados en el nivel de ejecución («runlevel») predeterminado (generalmente el nivel 2). Ejecuta <command>/etc/init.d/rc 2</command>, un script que inicia todos los servicios enumerados en <filename>/etc/rc2.d/</filename> y aquellos cuyos nombres comiencen con la letra «S». Los números de dos cifras que le sigue fueron utilizados históricamente para definir el orden en el que se iniciarán los servicios, pero actualmente el sistema de inicio predeterminado utiliza <command>insserv</command>, que programa todo automáticamente basándose en las dependencias de los scripts. Cada script de inicio, por lo tanto, declara las condiciones a cumplir para iniciar o detener el servicio (por ejemplo, si debe iniciar antes o después de otro servicio); <command>init</command> luego los ejecuta en un orden que satisfaga estas condiciones. El enumerado estático de los scripts ya no se tiene en cuenta (pero sus nombres siempre deben comenzar con «S» seguidos de dos números y el nombre real del script utilizado para dependencias). Generalmente, se inician primero los servicios de base (como los registros con <command>rsyslogd</command> o la asociación de puertos con <command>portmap</command>) seguidos de los servicios estándar y la interfaz gráfica (<command>gdm</command>).
			</para>
			 <para>
				Este sistema de inicio basado en dependencias hace posible renumerar automáticamente los scripts, lo que sería tediososo de hacer manualmente y limita el riesgo de error humano ya que se realiza la programación según los parámetros indicados. Otro beneficio es que se pueden iniciar los servicios en paralelo cuando son independientes entre ellos, lo cual puede acelerar el proceso de inicio.
			</para>
			 <indexterm>
				<primary>nivel de ejecución</primary>
			</indexterm>
			 <indexterm>
				<primary>runlevel, nivel de ejecución</primary>
			</indexterm>
			 <para>
				<command>init</command> distingue varios niveles de ejecución («runlevel») y puede cambiar de uno a otro ejecutando <command>telinit <replaceable>nuevo-nivel</replaceable></command>. Inmediatamente, <command>init</command> ejecuta nuevamente <command>/etc/init.d/rc</command> con el nuevo nivel de ejecución. Luego, este script ejecutará los servicios faltantes y detendrá aquellos que ya no se desean. Para hacerlo, se refiere al contenido del archivo <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (donde <replaceable>X</replaceable> representa el nuevo nivel de ejecución). Los scripts cuyos nombres comienzan con «S» (por «start», iniciar) son los servicios a iniciar; aquellos cuyos nombres comienzan con «K» (por «kill», matar) son los servicios a detener. El script no inicia ningún servicio que ya haya estado activo en el nivel de ejecución anterior.
			</para>
			 <para>
				De forma predeterminada, el inicio System V en Debian utiliza cuatro niveles de ejecución diferentes:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						Nivel 0: sólo se lo utiliza temporalmente mientras se apaga el equipo. Como tal, sólo contiene scripts «K».
					</para>

				</listitem>
				 <listitem>
					<para>
						Nivel 1: también conocido como modo de usuario único, corresponde al sistema en modo degradado; sólo incluye servicios básicos y está destinado a operaciones de mantenimiento donde no se desea la interacción con usuarios normales.
					</para>

				</listitem>
				 <listitem>
					<para>
						Nivel 2: es el nivel para operaciones normales, lo que incluye servicios de red, una interfaz gráfica, sesiones de usuario, etc.
					</para>

				</listitem>
				 <listitem>
					<para>
						Nivel 6: similar a nivel 0, excepto a que es utilizada durante la fase de cierre que precede a un reinicio.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Existe otros niveles, especialmente del 3 al 5. De forma predeterminara están configurados para operar de la misma forma que el nivel 2, pero el administrador puede modificarlos (agregando o eliminando scripts en los directorios <filename>/etc/rc<replaceable>X</replaceable>.d</filename> correspondientes) para adaptarlos a necesidades particulares.
			</para>
			 <figure id="figure.boot-process-sysvinit">
				<title>Secuencia de inicio de un equipo ejecutando Linux con inicio System V</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/startup-sysvinit.png" format="PNG" scalefit="1" width="80%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <indexterm>
				<primary>script de inicialización</primary>
			</indexterm>
			 <para>
				Todos los scripts en los varios directorios <filename>/etc/rc<replaceable>X</replaceable>.d</filename> son sólo enlaces simbólicos — creados durante la instalación del paquete por el programa <command>update-rc.d</command> — que apuntan a los scripts reales que están almacenados en <filename>/etc/init.d/</filename>. El administrador puede ajustar los servicios disponibles en cada nivel de ejecución ejecutando <command>update-rc.d</command> nuevamente con los parámetros correctos. La página de manual <citerefentry><refentrytitle>update-rc.d</refentrytitle>
				<manvolnum>1</manvolnum></citerefentry> describe la sintaxis en detalle. Sepa que eliminar todos los enlaces simbólicos (con el parámetro <literal>remove</literal>) no es un buen método de desactivar un servicio. En su lugar, simplemente debería configurar para que el mismo no se ejecute en el nivel de ejecución deseado (preservando las llamadas para detenerlo en caso que el servicio esté ejecutando en el nivel de ejecución anterior). Debido a que <command>update-rc.d</command> tiene una interfaz bastante compleja, puede preferir utilizar <command>rcconf</command> (en el paquete <emphasis role="pkg">rcconf</emphasis>) que provee una interfaz mucho más amigable.
			</para>
			 <indexterm>
				<primary><command>update-rc.d</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>NORMATIVA DEBIAN</emphasis> Reinicialización de servicios</title>
			 <indexterm>
				<primary><command>invoke-rc.d</command></primary>
			</indexterm>
			 <indexterm>
				<primary>servicio</primary>
				<secondary>reinicialización</secondary>
			</indexterm>
			 <indexterm>
				<primary>reinicialización de servicios</primary>
			</indexterm>
			 <para>
				Los scripts de mantenimiento para paquetes Debian a veces reinician algunos servicios para asegurar su disponibilidad o conseguir que tengan en cuenta algunas opciones. El script que controla un servicio — <command>service <replaceable>servicio</replaceable> <replaceable>operación</replaceable></command> — no tiene en cuenta el nivel de ejecución, asume (incorrectamente) que el servicio está siendo utilizado actualmente y, por lo tanto, puede iniciar operaciones incorrectas (iniciar un servicio que fue detenido deliberadamente o detener un servicio que no está ejecutando, etc.). Por lo tanto, Debian introdujo el programa <command>invoke-rc.d</command>: los scripts de mantenimiento deben utilizar este programa para ejecutar scripts de inicialización de servicios que sólo ejecutarán las órdenes necesarias. Sepa que, contrario al uso común, aquí se utiliza el sufijo <filename>.d</filename> en el nombre de un programa y no en un directorio.
			</para>
			 </sidebar> <para>
				Finalmente, <command>init</command> inicia los programas de control para varias consolas virtuales (<command>getty</command>). Muestra un prompt esperando por un nombre de usuario y luego ejecuta <command>login <replaceable>usuario</replaceable></command> para iniciar una sesión.
			</para>
			 <indexterm>
				<primary><command>getty</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>VOCABULARIO</emphasis> Consola y terminal</title>
			 <para>
				Los primeros equipos generalmente estaban separados en varias partes muy grandes: el compartimiento de almacenamiento y la unidad de procesamiento central estaban separados de los dispositivos periféricos que los operadores utilizaban para controlarlos. Éstos eran parte de un mobiliario separado: la «consola». Se mantuvo este término pero cambió su significado. Se convirtió, de cierta forma, en sinónimo de «terminal» (un teclado y una pantalla).
			</para>
			 <para>
				Con el desarrollo de la tecnología, los sistemas operativos han ofrecido varias consolas virtuales que permiten varias sesiones independientes al mismo tiempo, aún si sólo hay un teclado y pantalla. La mayoría de los sistemas GNU/Linux ofrecen seis consolas virtuales (en modo texto) a las que puede acceder presionando las combinaciones de teclas <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> a <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo>.
			</para>
			 <para>
				Por extensión, los términos «consola» y «terminal» también pueden hacer referencia a emuladores de terminales en una sesión gráfica X11 (como <command>xterm</command>, <command>gnome-terminal</command> o <command>konsole</command>).
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.remote-login">
		<title>Inicio de sesión remoto</title>
		 <para>
			Es esencial para el administrador poder conectarse a un equipo de forma remota. Los servidores, aislados en su propia habitación, rara vez están equipados con monitores y teclados permanentes — pero están conectados a la red.
		</para>
		 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Cliente, servidor</title>
		 <indexterm>
			<primary>cliente</primary>
			<secondary>arquitectura cliente/servidor</secondary>
		</indexterm>
		 <indexterm>
			<primary>servidor</primary>
			<secondary>arquitectura cliente/servidor</secondary>
		</indexterm>
		 <para>
			Generalmente se describe a un sistema en el que varios procesos se comunican entre ellos con la metáfora «cliente/servidor». El servidor es el programa que toma y ejecuta los pedidos que provienen de un cliente. Es el cliente el que controla la operación, el servidor no tiene iniciativa propia.
		</para>
		 </sidebar> <indexterm>
			<primary>inicio de sesión</primary>
			<secondary>remoto</secondary>
		</indexterm>
		 <indexterm>
			<primary>remoto, inicio de sesión</primary>
		</indexterm>
		 <section id="sect.ssh">
			<title>Inicio seguro de sesión remota: SSH</title>
			 <indexterm>
				<primary>SSH</primary>
			</indexterm>
			 <indexterm>
				<primary>Secure Shell</primary>
			</indexterm>
			 <para>
				El protocolo <emphasis>SSH</emphasis> (interprete de órdenes seguro: «Secure SHell») fue diseñado pensando en la seguridad y la confiabilidad. Las conexiones que utilizan SSH son seguras: la otra parte es autenticada y se cifran todos los datos intercambiados.
			</para>
			 <sidebar> <title><emphasis>CULTURA</emphasis> Telnet y RSH son obsoletos</title>
			 <indexterm>
				<primary><command>telnet</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>rsh</command></primary>
			</indexterm>
			 <para>
				Antes de SSH, <emphasis>Telnet</emphasis> y <emphasis>RSH</emphasis> eran las principales herramientas para sesiones remotas. Actualmente son generalmente obsoletas y no debería utilizarlas aún cuando Debian todavía las provee.
			</para>
			 </sidebar> <sidebar> <title><emphasis>VOCABULARIO</emphasis> Autenticación, cifrado</title>
			 <para>
				Cuando necesita proveerle a un cliente la capacidad de realizar o desencadenar acciones en un servidor, la seguridad es importante. Debe asegurar la identidad del cliente; esto es autenticación. Esta identidad generalmente consisten en una constraseña que debe mantenerse en secreto o cualquier otro cliente podría obtener la contraseña. Este es el propósito del cifrado, que es una forma de codificación que permite a dos sistemas intercambiar información confidencial en un canal público al mismo tiempo que la protege de que otros la puedan leer.
			</para>
			 <para>
				Frecuentemente se nombran a la autenticación y al cifrado en conjunto, tanto porque se los utiliza a ambos como porque generalmente son implementados con conceptos matemáticos similares.
			</para>
			 </sidebar> <para>
				SSH también ofrece dos servicios de transferencia de archivos. <command>scp</command> es una herramienta para la terminal que puede utilizar como <command>cp</command> excepto que cualquier ruta a otro equipo utilizará un prefijo con el nombre de la máquina seguido de dos puntos («:»).
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>scp archivo equipo:/tmp/</userinput></screen>
			 <para>
				<command>sftp</command> es un programa interactivo similar a <command>ftp</command>. En una sola sesión <command>sftp</command> puede transferir varios archivos y es posible manipular archivos remotos con él (eliminar, renombrar, cambiar permisos, etc.).
			</para>
			 <indexterm>
				<primary><command>scp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sftp</command></primary>
			</indexterm>
			 <para>
				Debian utiliza OpenSSH, una versión libre de SSH mantenida por el proyecto <command>OpenBSD</command> (un sistema operativo libre basado en el núcleo BSD enfocado en seguridad) que es una bifurcación («fork») del software SSH original desarrollado por la empresa SSH Communications Security Corp de Finlandia. Esta empresa inicialmente desarrolló SSH como software libre pero eventualmente decidió continuar su desarrollo bajo una licencia privativa. El proyecto OpenBSD luego creó OpenSSH para mentener una versión libre de SSH.
			</para>
			 <indexterm>
				<primary>OpenSSH</primary>
			</indexterm>
			 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Bifurcación: «<foreignphrase>fork</foreignphrase>»</title>
			 <indexterm>
				<primary>fork</primary>
			</indexterm>
			 <para>
				Una bifurcación («fork»), en el campo de software, significa que comienza un nuevo proyecto como clon de un proyecto existente y que competirá con él. Desde allí, ambos programas generalmente divergirán rápidamente en términos de nuevos desarrollos. Por lo general son un resultado de desacuerdos dentro del equipo de desarrollo.
			</para>
			 <para>
				La opción de bifurcar un proyecto es un resultado directo de la naturaleza misma del software libre; es un evento saludable cuando permite la continuación de un proyecto como software libre (por ejemplo, en el caso de cambios de licencia). Una bifurcación generada por desacuerdos técnicos o personales usualmente es un desperdicio de recursos; se prefiere otra solución. También ocurren fusiones de dos proyectos que anteriormente habían bifurcado.
			</para>
			 </sidebar> <para>
				OpenSSH está dividido en dos paquetes: la parte del cliente se encuentra en el paquete <emphasis role="pkg">openssh-client</emphasis> y el servidor en el paquete <emphasis role="pkg">openssh-server</emphasis>. El metapaquete <emphasis role="pkg">ssh</emphasis> depende de ambas partes y facilita la instalación conjunta (<command>apt install ssh</command>).
			</para>
			 <section id="sect.ssh-key-based-auth">
				<title>Autenticación basada en llaves</title>
				 <para>
					Cada vez que alguien inicia sesión a través de SSH, el servidor remoto pide una contraseña para autenticar al usuario. Esto puede ser problemático si desea automatizar la conexión o si utiliza una herramienta que necesita conexiones frecuentes sobre SSH. Es por esto que SSH ofrece un sistema de autenticación basada en llaves.
				</para>
				 <para>
					El usuario genera un par de llaves en la máquina cliente con <command>ssh-keygen -t rsa</command>; la llave pública se almacena en <filename>~/.ssh/id_rsa.pub</filename> mientras que la llave privada correspondiente estará almacenada en <filename>~/.ssh/id_rsa</filename>. Luego, el usuario utiliza <command>ssh-copy-id <replaceable>servidor</replaceable></command> para agregar su llave pública al archivo <filename>~/.ssh/authorized_keys</filename> en el servidor. Si no se protegió la llave privada con una «frase de contraseña» al momento de crearla, todos los inicios de sesión siguientes al servidor funcionarán sin contraseña. De lo contrario, debe descifrar la llave privada cada vez ingresando la frase de contraseña. Afortunadamente, <command>ssh-agent</command> permite mantener llaves privadas en memoria para no tener que ingresar la frase de contraseña regularmente. Para ello, simplemente utilizaría <command>ssh-add</command> (una vez por sesión de trabajo) siempre que la sesión ya esté asociada con una instancia funcional de <command>ssh-agent</command>. De forma predeterminada, Debian activa este comportamiento en sesiones gráficas pero lo puede desactivar cambiando el archivo <filename>/etc/X11/Xsession.options</filename>. Para una sesión en consola, puede iniciarlo manualmente con <command>eval $(ssh-agent)</command>.
				</para>
				 <sidebar> <title><emphasis>SEGURIDAD</emphasis> Protección de la llave privada</title>
				 <para>
					Quien posea la llave privada puede iniciar sesión con la cuenta configurada. Es por esto que se protege la llave privada con una «frase de contraseña». Quien obtenga una copia del archivo de la llave privada (por ejemplo, <filename>~/.ssh/id_rsa</filename>) todavía tendrá que saber dicha frase para poder intentar utilizarla. Sin embargo, esta protección adicional no es infalible y es mejor deshabilitar la llave en aquellos equipos en las que la instaló (eliminándola de los archivos <filename>authorized_keys</filename>) y reemplazándola con una nueva llave que haya generado.
				</para>
				 </sidebar> <sidebar> <title><emphasis>CULTURA</emphasis> Falla OpenSSL en Debian <emphasis role="distribution">Etch</emphasis></title>
				 <para>
					La biblioteca OpenSSL, como fue provista inicialmente en Debian <emphasis role="distribution">Etch</emphasis>, tenía un serio problema en su generador de números aleatorios (RNG: «Random Number Generator»). El desarrollador Debian había realizado una modificación para que los programas que la utilizan no generaran advertencias mientras eran objetivo de análisis por herramientas de pruebas de memoria como <command>valgrind</command>. Desafortunadamente, este cambio también significaba que el RNG sólo utilizaba una fuente de entropía que correspondía al número de proceso (PID); pero los 32000 valores posibles del mismo no ofrecen suficiente aleatoriedad. <ulink type="block" url="http://www.debian.org/security/2008/dsa-1571" />
				</para>
				 <para>
					Específicamente, cuando utilizaba OpenSSL para generar una llave, siempre producía una llave dentro de un conjunto conocido de cientos de miles de llaves (32000 multiplicado por una pequeña cantidad de longitudes de llaves). Esto afectaba llaves SSH, llaves SSL y certificados X.509 utilizados por numerosas aplicaciones, como OpenVPN. Un «cracker» sólo debía intentar todas estas llaves para obtener un acceso no autorizado. Para reducir el impacto del problema, se modificó el demonio SSH para rechazar las llaves problemáticas incluidas en los paquetes <emphasis role="pkg">openssh-blacklist</emphasis> y <emphasis role="pkg">openssh-blacklist-extra</emphasis>. Además, el programa <command>ssh-vulnkey</command> permite identificar posibles llaves comprometidas en el sistema.
				</para>
				 <para>
					Un análisis más detallado de este problema resaltó que era el resultado de múltiples problemas (pequeños) del proyecto OpenSSL y del encargado del paquete Debian. Una biblioteca tan utilizada como OpenSSL no debería — sin modificaciones — generar advertencias cuando es probada con <command>valgrind</command>. Lo que es más, el código (especialmente las partes tan sensibles como el RNG) deberían tener mejores comentarios para evitar estos errores. Por parte de Debian, el encargado quería validar las modificaciones con los desarrolladores de OpenSSL, pero simplemente explicó las modificaciones sin proporcionar el parche correspondiente para su revisión y se olvidó de mencionar su papel en Debian. Por último, las decisiones de mantenimiento no fueron las óptimas: los cambios en el código original no estaban comentados de forma clara; todas las modificaciones fueron almacenadas en un repositorio Subversion, pero terminaron agrupadas en un sólo parche durante la creación del paquete fuente.
				</para>
				 <para>
					It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <ulink type="block" url="http://sources.debian.org" />
				</para>
				 </sidebar>
			</section>
			 <section id="sect.ssh-x11">
				<title>Utilización aplicaciones X11 remotas</title>
				 <para>
					El protocolo SSH permite redirigir datos gráficos (sesión «X11» por el nombre del sistema gráfico más utilizado en Unix); el servidor luego mantiene un canal dedicado para estos datos. Específicamente, el programa gráfico ejecutado remotamente puede mostrarse en el servidor X.org de la pantalla local y toda la sesión (datos ingresados y lo que sea mostrado) será segura. De forma predeterminada, esta funcionalidad está desactivada porque permite que aplicaciones remotas interfieran con el sistema local. Puede activarla especificando <literal>X11Forwarding yes</literal> en el archivo de configuración del servidor (<filename>/etc/ssh/sshd_config</filename>). Finalmente, el usuario también debe solicitarlo agregando la opción <literal>-X</literal> al ejecutar <command>ssh</command>.
				</para>

			</section>
			 <section id="sect.ssh-port-forwarding">
				<title>Creación de túneles cifrados con redirección de puertos</title>
				 <indexterm>
					<primary>redirección de puertos</primary>
				</indexterm>
				 <para>
					Las opciones <literal>-R</literal> y <literal>-L</literal> le permiten a <command>ssh</command> crear «túneles cifrados» entre dos equipos, redirigiendo de forma segura un puerto TCP local (revise el recuadro <xref linkend="sidebar.tcp-udp" />) a un equipo remoto o viceversa.
				</para>
				 <sidebar> <title><emphasis>VOCABULARIO</emphasis> Túnel</title>
				 <indexterm>
					<primary>túnel (SSH)</primary>
					<seealso>VPN</seealso>
				</indexterm>
				 <indexterm>
					<primary>SSH, túnel SSH</primary>
					<seealso>VPN</seealso>
				</indexterm>
				 <para>
					Internet, y la mayoría de las redes de área local conectadas a ella, funcionan bajo conmutación de paquetes y no bajo conmutación de circuitos, lo que significa que un paquete enviado de un equipo a otro será detenido en varios routers intermedios para encontrar su ruta al destino. Todavía puede simular el modo de conexión en el que el flujo esté encapsulado en paquetes IP normales. Estos paquetes siguen su ruta usual pero se reconstruye el flujo sin cambios en el destino. A esto le llamamos un «túnel», el análogo a un túnel vial en el que los vehículos conducen directamente desde la entrada a la salida sin encontrase con intersección alguna a diferencia de una ruta en la superficie que involucraría intersecciones y cambios de dirección.
				</para>
				 <para>
					Puede utilizar esta oportunidad para agregar cifrado al túnel: así el flujo del mismo no puede ser reconocido desde el exterior, pero al salir del túnel se encuentra descifrado.
				</para>
				 </sidebar> <para>
					<command>ssh -L 8000:servidor:25 intermediario</command> establece una sesión SSH con el equipo <replaceable>intermediario</replaceable> y escucha en el puerto local 8000 (revise la <xref linkend="figure.ssh-L" />). Para cualquier conexión en este puerto, <command>ssh</command> iniciará una conexión desde el equipo <replaceable>intermediario</replaceable> al puerto 25 de <replaceable>servidor</replaceable> y unirá ambas conexiones.
				</para>
				 <para>
					<command>ssh -R 8000:servidor:25 intermediario</command> también establece una sesión SSH al equipo <replaceable>intermediario</replaceable>, pero es en este equipo que <command>ssh</command> escuchará en el puerto 8000 (revise la <xref linkend="figure.ssh-R" />). Cualquier conexión establecida en este puerto causará que <command>ssh</command> abra una conexión desde el equipo local al puerto 25 de <replaceable>servidor</replaceable> y unirá ambas conexiones.
				</para>
				 <para>
					En ambos casos, se realizan las conexiones en el puerto 25 del equipo <replaceable>servidor</replaceable>, que pasarán a través del túnel SSH establecido entre la máquina local y la máquina <replaceable>intermediario</replaceable>. En el primer caso, la entrada al túnel es el puerto local 8000 y los datos se mueven hacia la máquina <replaceable>intermediario</replaceable> antes de dirigirse a <replaceable>servidor</replaceable> en la red «pública». En el segundo caso, la entrada y la salida del túnel son invertidos; la entrada es en el puerto 8000 de la máquina <replaceable>intermediario</replaceable>, la salida es en el equipo local y los datos son dirigidos a <replaceable>servidor</replaceable>. En la práctica, el servidor generalmente está en la máquina local o el intermediario. De esa forma SSH asegura la conexión un extremo a otro.
				</para>
				 <figure id="figure.ssh-L">
					<title>Redirección de un puerto local con SSH</title>
					 <mediaobject>
						<imageobject>
							<imagedata fileref="images/ssh-L.png" format="PNG" width="35%" />
						</imageobject>

					</mediaobject>

				</figure>
				 <figure id="figure.ssh-R">
					<title>Redirección de un puerto remoto con SSH</title>
					 <mediaobject>
						<imageobject>
							<imagedata fileref="images/ssh-R.png" format="PNG" width="35%" />
						</imageobject>

					</mediaobject>

				</figure>

			</section>

		</section>
		 <section id="sect.remote-desktops">
			<title>Utilización de escritorios gráficos remotos</title>
			 <para>
				VNC (computación en redes virtuales: «Virtual Network Computing») permite el acceso remoto a escritorios gráficos.
			</para>
			 <indexterm>
				<primary>VNC</primary>
			</indexterm>
			 <indexterm>
				<primary>Virtual Network Computing</primary>
			</indexterm>
			 <indexterm>
				<primary>escritorio gráfico</primary>
				<secondary>remoto</secondary>
			</indexterm>
			 <indexterm>
				<primary>escritorio gráfico remoto</primary>
			</indexterm>
			 <indexterm>
				<primary>remoto, escritorio gráfico</primary>
			</indexterm>
			 <para>
				Esta herramienta se utiliza más que nada para asistencia técnica; el administrador puede ver los errores con los que se enfrenta el usuario y mostrarle el curso de acción correcto sin tener que estar a su lado.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vino</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">krfb</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">x11vnc</emphasis></primary>
			</indexterm>
			 <para>
				Primero, el usuario debe autorizar compartir su sesión.El entornos gráficos de escritorio GNOME en <emphasis role="distribution">Jessie</emphasis> incluye esa opción en su panel de configuración (al contrario que en versiones anteriores de Debian, donde el usuario tenía que instalar y ejecutar la orden <command>vino</command>). KDE aún requiere utilizar <command>krfb</command> para permitir compartir una sesión existente sobre VNC. Para otros entornos gráficos de escritorio, el programa <command>x11vnc</command> (en el paquete Debian del mismo nombre) cumple el mismo propósito; puede ponerlo a disposición del usuario con un ícono explícito.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vinagre</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">tsclient</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">krdc</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">xvnc4viewer</emphasis></primary>
			</indexterm>
			 <para>
				Cuando la sesión gráfica está disponible a través de VNC, el administrador debe conectarse a ella con un cliente VNC. Para ello GNOME posee <command>vinagre</command> y <command>remmina</command>, mientras que KDE incluye <command>krdc</command> (en el menú <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Cliente de Escritorio Remoto</guimenuitem></menuchoice>). Existen otros clientes VNC para utilizar en una terminal como <command>xvnc4viewer</command> en el paquete Debian del mismo nombre. Una vez conectado, el administrador puede ver lo que sucede, trabajar en el equipo remotamente y mostrarle al usuario cómo proceder.
			</para>
			 <sidebar> <title><emphasis>SEGURIDAD</emphasis> VNC sobre SSH</title>
			 <indexterm>
				<primary>túnel SSH</primary>
				<secondary>VNC</secondary>
			</indexterm>
			 <para>
				Si desea conectarse con VNC y no desea que se envíen sus datos en texto plano a través de la red, es posible encapsular los datos en un túnel SSH (revise la <xref linkend="sect.ssh-port-forwarding" />). Simplemente tiene que saber que, de forma predeterminada, VNC utiliza el puerto 5900 para la primera pantalla (llamada «localhost:0»), 5901 para la segunda (llamada «localhost:1»), etc.
			</para>
			 <para>
				La orden <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>equipo</replaceable></command> crea un túnel entre el puerto local 5901 en la interfaz de «localhost» y el puerto 5900 de <replaceable>equipo</replaceable>. La primera ocurrencia de «localhost» restringe a SSH para que sólo escuche en dicha interfaz en la máquina local. El segundo «localhost» indica que la interfaz en la máquina remota que recibirá el tráfico de red que ingrese en «localhost:5901». Por lo tanto, <command>vncviewer localhost:1</command> conectará el cliente VNC a la pantalla remota aún cuando indique el nombre de la máquina local.
			</para>
			 <para>
				Cuando cierre la sesión VNC, recuerde también cerrar el túnel saliendo de la sesión SSH correspondiente.
			</para>
			 </sidebar> <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Gestor de pantallas</title>
			 <indexterm>
				<primary><command>gdm3</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>kdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>xdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>lightdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary>gestor</primary>
				<secondary>de pantalla</secondary>
			</indexterm>
			 <indexterm>
				<primary>pantalla, gestor</primary>
			</indexterm>
			 <para>
				<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command> y <command>xdm</command> son gestores de pantalla. Toman el control de la interfaz gráfica poco después del inicio para proveer al usuario una pantalla de inicio de sesión. Una vez que el usuario inició sesión, ejecutan los programas necesarios para iniciar una sesión gráfica de trabajo.
			</para>
			 </sidebar> <para>
				VNC también funciona para usuarios móviles o ejecutivos de empresas que ocasionalmente necesitan iniciar sesión desde sus casas para acceder a un escritorio remoto similar al que utilizan en la oficina. La configuración de tal servicio es más complicada: primero instale el paquete <emphasis role="pkg">vnc4server</emphasis>, modifique la configuración del gestor de pantalla para aceptar pedidos <literal>XDMCP Query</literal> (en <command>gdm3</command> puede hacerlo agregando <literal>Enable=true</literal> en la sección «xdmcp» del archivo <filename>/etc/gdm3/daemon.conf</filename>). Finalmente, inicie el servidor VNC con <command>inetd</command> para que se inicie una sesión automáticamente cuando el usuario intente hacerlo. Por ejemplo, puede agregar la siguiente línea al archivo <filename>/etc/inetd.conf</filename>:
			</para>
			 
<programlisting>5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</programlisting>
			 <para>
				Redireccionar las conexiones entrantes al gestor de pantallas soluciona el problema de la autenticación ya que sólo los usuarios con cuentas locales pasarán la pantalla de inicio de sesión de <command>gdm3</command> (o su equivalente <command>kdm</command>, <command>xdm</command>, etc.). Como esta operación permite múltiples sesiones simultáneamente sin problemas (siempre que el servidor sea suficientemente poderoso), incluso puede ser utilizada para proveer escritorios completos para usuarios móviles (o sistemas de escritorios menos potentes configurados como clientes ligeros). Los usuarios simplemente iniciarán sesión en la pantalla del servidor con <command>vncviewer <replaceable>servidor</replaceable>:50</command> ya que utiliza el puerto 5950.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vnc4server</emphasis></primary>
			</indexterm>

		</section>

	</section>
	 <section id="sect.rights-management">
		<title>Administración de permisos</title>
		 <para>
			Linux es definitivamente un sistema multiusuario por lo que necesita proveer un sistema de permisos para controlar el conjunto de operaciones autorizadas sobre archivos y directorios, lo que incluye todos los recursos del sistema y los dispositivos (en un sistema Unix cualquier dispositivo es representado por un archivo o un directorio). Este principio es común a todos los sistemas Unix pero siempre es útil recordarlo, especialmente porque existen algunos usos avanzados interesantes y relativamente desconocidos.
		</para>
		 <indexterm>
			<primary>permisos</primary>
		</indexterm>
		 <indexterm>
			<primary>permisos</primary>
		</indexterm>
		 <indexterm>
			<primary>usuario</primary>
			<secondary>dueño</secondary>
		</indexterm>
		 <indexterm>
			<primary>grupo</primary>
			<secondary>dueño</secondary>
		</indexterm>
		 <indexterm>
			<primary>dueño</primary>
			<secondary>usuario</secondary>
		</indexterm>
		 <indexterm>
			<primary>dueño</primary>
			<secondary>grupo</secondary>
		</indexterm>
		 <para>
			Cada archivo o directorio tiene permisos específicos para tres categorías de usuarios:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					su dueño (representado con <literal>u</literal> por «usuario»);
				</para>

			</listitem>
			 <listitem>
				<para>
					su grupo dueño (representado con <literal>g</literal> por «grupo»), que incluye a todos los miembros del grupo;
				</para>

			</listitem>
			 <listitem>
				<para>
					y los demás (representado con <literal>o</literal> por «otros»).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Puede combinar tres tipos de permisos:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					lectura (representado por <literal>r</literal> por «read»: leer);
				</para>

			</listitem>
			 <listitem>
				<para>
					escritura (o modificación, representado con <literal>w</literal> por «write»: escribir);
				</para>

			</listitem>
			 <listitem>
				<para>
					ejecución (representado con <literal>x</literal> por «eXecute»: ejecutar).
				</para>

			</listitem>

		</itemizedlist>
		 <indexterm>
			<primary>lectura, permiso</primary>
		</indexterm>
		 <indexterm>
			<primary>escritura, permiso</primary>
		</indexterm>
		 <indexterm>
			<primary>modificación, permiso</primary>
		</indexterm>
		 <indexterm>
			<primary>ejecución, permiso</primary>
		</indexterm>
		 <para>
			En el caso de un archivo, estos permisos se entienden fácilmente: la lectura permite acceder al contenido (inclusive copiarlo), la escritura permite cambiarlo y la ejecución permite ejecutarlo (lo cual sólo funcionará si es un programa).
		</para>
		 <sidebar> <title><emphasis>SEGURIDAD</emphasis> Ejecutables <literal>setuid</literal> y <literal>setgid</literal></title>
		 <para>
			Dos permisos particulares son relevantes para archivos ejecutables: <literal>setuid</literal> y <literal>setgid</literal> (representados con la letra «s»). Sepa que frecuentemente haremos referencias a «bits» ya que cada uno de estos valores booleanos pueden representarse con un 0 o un 1. Estos dos permisos le permiten a cualquier usuario ejecutar el programa con los permisos del dueño o del grupo respectivamente. Este mecanismo provee acceso a funcionalidades que necesitan más permisos de los que tendría normalmente.
		</para>
		 <indexterm>
			<primary><literal>setuid</literal>, permiso</primary>
		</indexterm>
		 <indexterm>
			<primary><literal>setgid</literal>, permiso</primary>
		</indexterm>
		 <para>
			Dado que un programa cuyo dueño es root con <literal>setuid</literal> activado ejecutará sistemáticamente con la identidad del súperusuario, es muy importante asegurar que es seguro y confiable. De hecho, un usuario que pueda comprometerlo para ejecutar otro programa de su elección podría hacerse pasar por el usuario root y obtener todos los permisos sobre el sistema.
		</para>
		 </sidebar> <para>
			Los directorios se manejan diferente. El permiso de lectura provee acceso para consultar su lista de elementos (archivos y directorios), el permiso de escritura permite crear o borrar archivos y el permiso de ejecución permite atravesarlo (especialmente para llegar a él con <command>cd</command>). Poder atravesar un directorio sin leerlo permite acceder a los elementos que contenga siempre que se conozca su nombre, pero no le permitirá encontrarlos si no sabe que existen o conoce sus nombres exactos.
		</para>
		 <sidebar id="sidebar.setgid-dir"> <title><emphasis>SEGURIDAD</emphasis> Directorios <literal>setgid</literal> y el <emphasis>bit «sticky»</emphasis> (pegajoso)</title>
		 <indexterm>
			<primary><literal>setgid</literal>, directorio</primary>
		</indexterm>
		 <para>
			El bit <literal>setgid</literal> también funciona en directorios. Cualquier elemento creado en tales directorios serán asignados automáticamente al grupo dueño del directorio padre en lugar de heredar el grupo principal de su creador como es usual. Esta configuración evita que el usuario tenga que cambiar su grupo principal (con el programa <command>newgrp</command>) cuando trabaje en un árbol de archivos compartidos entre varios usuarios del mismo grupo dedicado.
		</para>
		 <indexterm>
			<primary>bit «sticky»</primary>
		</indexterm>
		 <para>
			El bit «sticky» (representado por la letra «t») es un permiso que sólo es util en directorios. Es utilizado especialmente en directorios temporales a los que todos tienen permisos de escritura (como <filename>/tmp/</filename>): restringe la eliminación de archivos para que sólo pueda hacerlo el dueño del mismo (o el dueño del directorio padre). Sin esto, cualquier podría eliminar los archivos de otros usuarios en <filename>/tmp/</filename>.
		</para>
		 </sidebar> <para>
			Tres programas controlan los permisos asociados a un archivo:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					<command>chown <replaceable>usuario</replaceable> <replaceable>archivo</replaceable></command> cambia el dueño de un archivo;
				</para>

			</listitem>
			 <listitem>
				<para>
					<command>chgrp <replaceable>group</replaceable> <replaceable>archivo</replaceable></command> modifica el grupo dueño;
				</para>

			</listitem>
			 <listitem>
				<para>
					<command>chmod <replaceable>permisos</replaceable> <replaceable>archivo</replaceable></command> cambia los permisos del archivo.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Hay dos formas de representar permisos. Entre ellas, la representación simbólica es probablemente la más sencilla de entender y recordar. Involucra las letras mencionadas anteriormente. Puede definir permisos para cada categoría de usuarios (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>) definiéndolos explícitamente (con <literal>=</literal>, agregar permisos (<literal>+</literal>) o eliminar (<literal>-</literal>) permisos. Por lo tanto, la fórmula <literal>u=rwx,g+rw,o-r</literal> provee al dueño permisos de lectura, escritura y ejecución, agrega permisos de lectura y escritura al grupo dueño y elimina el permiso de lectura para los otros usuarios. Los permisos que no son modificados cuando se agreguen o eliminen permisos en estas fórmulas se mantienen intactos. La letra <literal>a</literal> (por «all», todos) incluye las tres categorías de usuarios, por lo que <literal>a=rx</literal> otorga los mismos permisos (lecutra y ejecución, pero no escritura) a las tres categorías de usuario.
		</para>
		 <indexterm>
			<primary><command>chmod</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>chown</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>chgrp</command></primary>
		</indexterm>
		 <indexterm>
			<primary>representación octal de permisos</primary>
		</indexterm>
		 <indexterm>
			<primary>permisos</primary>
			<secondary>representación octal</secondary>
		</indexterm>
		 <para>
			La representación numérica (octal) asocia cada permiso con un valor: 4 para lectura, 2 para escritura y 1 para ejecución. Asociamos cada combinación de permisos con la suma de dichos valores. Se asigna cada valor a las diferentes categorías de usuarios uniéndolos en el orden usual (dueño, grupo, otros).
		</para>
		 <para>
			Por ejemplo, <command>chmod 754 <replaceable>archivo</replaceable></command> configurará los siguientes permisos: lectura, escritura y ejecución para el dueño (ya que 7 = 4 + 2 + 1); lectura y ejecución para el grupo (ya que 5 = 4 +1); sólo lectura para los otros usuarios. <literal>0</literal> significa ningún permiso; por lo tanto <command>chmod 600 <replaceable>archivo</replaceable></command> provee permisos de lectura y escritura al dueño y ningún permiso para todos los demás. La combinación de permisos más frecuente es <literal>755</literal> para archivos ejecutables y directorios y <literal>644</literal> para archivos de datos.
		</para>
		 <para>
			Para representar permisos especiales, puede agregar un cuarto dígito antes que los demás según el mismo principio, donde los bits <literal>setuid</literal>, <literal>setgid</literal> y «<literal>sticky</literal>» son, respectivamente, 4, 2 y 1. <command>chmod 4754</command> asociará el bit <literal>setuid</literal> con los permisos descriptos anteriormente.
		</para>
		 <para>
			El uso de notación octal sólo permite definir todos los permisos en un archivo de forma simultanea; no puede utilizarse para agregar un nuevo permiso a un conjunto anterior, como p.ej. agregar el permiso de lectura al grupo dueño, ya que deben tenerse en cuenta los permisos existentes y hay que calcular el nuevo valor numérico correspondiente.
		</para>
		 <sidebar> <title><emphasis>SUGERENCIA</emphasis> Operación recursiva</title>
		 <para>
			A veces debemos cambiar los permisos a un árbol de archivos completo. Todos los programas mencionados aceptan la opción <literal>-R</literal> para trabajar recursivamente en subdirectorios.
		</para>
		 <para>
			La distinción entre archivos y directorios a veces causa problemas con operaciones recursivas. Por eso se introdujo la letra «X» en la representación simbólica de permisos. Representa el permiso de ejecución sólo para directorios (y no para archivos que no tengan este permiso). Por lo tanto, <command>chmod -R a+X <replaceable>directorio</replaceable></command> sólo agregará permisos de ejecución para todas las categorías de usuarios (<literal>a</literal>) en todos los subdirectorios y aquellos archivos en los que al menos una de las categorías de usuario (aún si sólo es el usuario dueño) ya posea permisos de ejecución.
		</para>
		 </sidebar> <sidebar> <title><emphasis>SUGERENCIA</emphasis> Modificación de usuario y grupo</title>
		 <para>
			Frecuentemente deseará cambiar el grupo de un archivo al mismo tiempo que cambia su dueño. El programa <command>chown</command> tiene una sintaxis especial para esto: <command>chown <replaceable>usuario</replaceable>:<replaceable>grupo</replaceable> <replaceable>archivo</replaceable></command>
		</para>
		 </sidebar> <sidebar> <title><emphasis>YENDO MÁS ALLÁ</emphasis> <command>umask</command></title>
		 <para>
			Cuando una aplicación crea un archivo asigna permisos indicativos, sabiendo que el sistema automáticamente elimina algunos permisos, dados por el programa <command>umask</command>. Ejecuta <command>umask</command> en una consola; verá una máscara como <computeroutput>0022</computeroutput>. Ésta es simplemente una representación octal de los permisos que serán eliminados sitemáticamente (en este caso, el permiso de escritura para el grupo y otros usuarios).
		</para>
		 <indexterm>
			<primary>umask</primary>
		</indexterm>
		 <indexterm>
			<primary>permisos</primary>
			<secondary>máscara</secondary>
		</indexterm>
		 <indexterm>
			<primary>máscara</primary>
			<secondary>de permisos</secondary>
		</indexterm>
		 <para>
			Si provee un nuevo valor octal, el programa <command>umask</command> modificará la máscara. Si lo utiliza en un script de inicialización de consola (por ejemplo <filename>~/.bash_profile</filename>) efectivamente cambiará la máscara predeterminada en sus sesiones de trabajo.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.administration-interfaces">
		<title>Interfaces de administración</title>
		 <indexterm>
			<primary>interfaz</primary>
			<secondary>de administración</secondary>
		</indexterm>
		 <indexterm>
			<primary>administración, interfaz de</primary>
		</indexterm>
		 <para>
			Utilizar una interfaz gráfica para administración es interesante en varias circunstancias. Un administrador no conoce, necesariamente, todos los detalles de la configuración de todos los servicios, y no siempre tendrá tiempo de revisar la documentación correspondiente. Una interfaz gráfica para administración puede, entonces, acelerar el despliegue de un nuevo servicio. También puede simplificar la instalación de servicios que son difíciles de configurar.
		</para>
		 <para>
			Estas interfaces son sólo ayudas y no un fin en sí mismo. En todos los casos el administrador debe dominar su comportamiento para entender y evitar cualquier problema potencial.
		</para>
		 <para>
			Debido a que ninguna interfaz es perfecta, puede estar tentado de probar varias soluciones. Debe evitar esto tanto como sea posible ya que, a veces, el método funcionamiento de las diferentes herramientas es incompatible. Aunque todas intentan ser muy flexibles e intentan adoptar el archivo de configuración como única referencia, no siempre pueden integrar cambios externos.
		</para>
		 <section id="sect.webmin">
			<title>Administración en una interfaz web: <command>webmin</command></title>
			 <indexterm>
				<primary><emphasis>webmin</emphasis></primary>
			</indexterm>
			 <para>
				Esta es, sin lugar a dudas, una de las interfaces de administración más existosas. Es un sistema modular administrador a través de un servidor web, que incluye un amplio rango de áreas y herramientas. Lo que es más, está internacionalizada y está diponible en muchos idiomas.
			</para>
			 <para>
				Lamentablemente <command>webmin</command> ya no es parte de Debian. Su encargado en Debian — Jaldhar H. Vyas — eliminó los paquetes que creó porque ya no tenía el tiempo necesario para mantenerlos en un nivel de calidad aceptable. Nadie asumió ese trabajo oficialmente, por lo que <emphasis role="distribution">Jessie</emphasis> no tiene el paquete <command>webmin</command>.
			</para>
			 <para>
				Existe, sin embargo, un paquete no oficial distribuido en el sitio web <literal>webmin.com</literal>. A diferencia de los paquetes Debian originales, este paquete es monolítico; de forma predeterminada se instalan y activan todos sus módulos de configuración, aún si el servicio correspondiente no está instalado en el equipo.
			</para>
			 <sidebar> <title><emphasis>SEGURIDAD</emphasis> Modificación de la contraseña de root</title>
			 <para>
				Durante el primer inicio de sesión debe identificarse con el usuario root y su contraseña habitual. Es recomendable cambiar la contraseña que utiliza para <command>webmin</command> tan pronto como sea posible, de forma que aunque ésta pueda ser comprometida, y a pesar de que el propio webmin proporciona permisos administrativos importantes en el equipo, no se consiga a la vez la contraseña de root del servidor.
			</para>
			 <para>
				¡Cuidado! Dado que <command>webmin</command> posee tanta funcionalidad, un usuario malicioso que acceda a él puede comprometer la seguridad de todo el sistema. En general, no se recomiendan este tipo de interfaces para sistemas importantes con fuertes limitaciones de seguridad (firewall, servidores sensibles, etc.).
			</para>
			 </sidebar> <para>
				Webmin se utiliza a través de una interfaz web, pero no necesita instalar Apache. Esencialmente, este software tiene su propio miniservidor web integrado. De forma predeterminada, este servidor escucha en el puerto 10000 y acepta conexiones HTTP seguras.
			</para>
			 <para>
				Los módulos incluidos cubren una amplia variedad de servicios, entre ellos:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						todos los servicios base: creación de usuarios y grupos, administración de archivos <filename>crontab</filename>, scripts de inicio, visualización de registros, etc.
					</para>

				</listitem>
				 <listitem>
					<para>
						bind: configuración del servidor DNS (servicio de nombres);
					</para>

				</listitem>
				 <listitem>
					<para>
						postfix: configuración del servidor SMTP (correo electrónico);
					</para>

				</listitem>
				 <listitem>
					<para>
						inetd: configuración del superservidor <command>inetd</command>;
					</para>

				</listitem>
				 <listitem>
					<para>
						quota: administración de cuotas de usuario;
					</para>

				</listitem>
				 <listitem>
					<para>
						dhcpd: configuración del servidor DHCP;
					</para>

				</listitem>
				 <listitem>
					<para>
						prpftpd: configuración del servidor FTP;
					</para>

				</listitem>
				 <listitem>
					<para>
						samba: configuración del servidor de archivos Samba;
					</para>

				</listitem>
				 <listitem>
					<para>
						software: instalación o eliminación de software desde paquetes Debian y actualizaciones de sistema.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				La interfaz de administración está disponible a través de un navegador en <literal>https://localhost:10000</literal>. ¡Cuidado! No podrá utilizar directamente todos los módulos. Deberá configurar algunos especificando la ubicación de los archivos de configuración correspondiente y algunos archivos ejecutables (programas). Frecuentemente el sistema le pedirá esa información cuando no pueda activar un módulo que solicite.
			</para>
			 <sidebar> <title><emphasis>ALTERNATIVA</emphasis> Centro de control de GNOME («Control Center»)</title>
			 <indexterm>
				<primary><emphasis role="pkg">gnome-control-center</emphasis></primary>
			</indexterm>
			 <para>
				El proyecto GNOME también provee varias interfaces de administración, a las que generalmente puede acceder a través del elemento «Preferencias» en el menú del usuario en la esquina superior derecha. <command>gnome-control-center</command> es el programa principal que las unifica, pero muchas de las herramientas de configuración del sistema en general son provistas efectivamente por otros paquetes (<emphasis role="pkg">accountsservice</emphasis>, <emphasis role="pkg">system-config-printer</emphasis>, etc.). Aunque son fáciles de utilizar, sólo cubren una cantidad limitada de servicios básicos: gestión de usuarios, configuración de fecha y hora, configuración de red, configuración de impresión, etc..
			</para>
			 </sidebar>
		</section>
		 <section id="sect.debconf">
			<title>Configuración de paquetes: <command>debconf</command></title>
			 <indexterm>
				<primary><command>debconf</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>dpkg-reconfigure</command></primary>
			</indexterm>
			 <para>
				Después de realizar unas pocas preguntas durante la instalación a través de Debconf, muchos paquetes son configurados automáticamente. Puede reconfigurar estos paquetes ejecutando <command>dpkg-reconfigure <replaceable>paquete</replaceable></command>.
			</para>
			 <para>
				En la mayoría de los casos, estas configuraciones son muy simples; sólo modifican unas pocas variables importantes en el archivo de configuración. Generalmente se agrupan estas variables entre dos líneas de «demarcación» para que la reconfiguración del paquete sólo afecte el área entre ellas. En otros casos, la reconfiguración no realizará cambios si el script detecta una modificación manual del archivo de configuración para preservar estas intervenciones humanas (debido a que el script no puede asegurar que sus propias modificaciones no afectarán la configuración existente).
			</para>
			 <sidebar> <title><emphasis>NORMATIVA DEBIAN</emphasis> Preservación de cambios</title>
			 <para>
				La Normativa Debian estipula expresamente que se debe hacer todo para preservar los cambios manuales en los archivos de configuración, por lo que más y más scripts toman precauciones al editar archivos de configuración. El principio general es simple: el script sólo realizará cambios si conoce el estado del archivo de configuración, lo que controla comparando la suma de verificación del archivo con la del último archivo generado automáticamente. Si son iguales, el script está autorizado a realizar cambios en el archivo de configuración. De lo contrario, determina que el archivo fue modificado y pregunta por la acción a tomar (instalar el nuevo archivo, guardar el archivo existente o intentar integrar los nuevos cambios en el archivo actual). Este principio de precaución es, desde hace tiempo, exclusivo de Debian pero otras distribuciones gradualmente comenzaron a aceptarlo.
			</para>
			 <para>
				Puede utilizar el programa <command>ucf</command> (en el paquete Debian del mismo nombre) para implementar este comportamiento.
			</para>
			 <indexterm>
				<primary><command>ucf</command></primary>
			</indexterm>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.syslog">
		<title><command>syslog</command> Eventos de sistema</title>
		 <indexterm>
			<primary><command>rsyslogd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>archivos</primary>
			<secondary>de registro</secondary>
		</indexterm>
		 <indexterm>
			<primary>registros</primary>
			<secondary>distribución</secondary>
		</indexterm>
		 <section id="sect.syslog-principe">
			<title>Principio y mecanismo</title>
			 <para>
				El demonio <command>rsyslogd</command> es responsable de recolectar los mensajes de servicio que provienen de aplicaciones y el núcleo para luego distribuirlos en archivos de registros (usualmente almacenados en el directorio <filename>/var/log/</filename>). Obedece a su archivo de configuración: <filename>/etc/rsyslog.conf</filename>.
			</para>
			 <para>
				Cada mensaje de registro es asociado con un subsistema de aplicaciones (llamados «facility» en la documentación):
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>auth</literal> y <literal>authpriv</literal>: para autenticación;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>cron</literal>: proviene servicios de programación de tareas, <command>cron</command> y <command>atd</command>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>daemon</literal>: afecta un demonio sin clasificación especial (DNS, NTP, etc.);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ftp</literal>: el servidor FTP;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>kern</literal>: mensaje que proviene del núcleo;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>lpr</literal>: proviene del subsistema de impresión;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>mail</literal>: proviene del subsistema de correo electrónico;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>news</literal>: mensaje del subsistema Usenet (especialmente de un servidor NNTP — protocolo de transferencia de noticias en red, «Network News Transfer Protocol» — que administra grupos de noticias);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>syslog</literal>: mensajes del servidor <command>syslogd</command> en sí;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>user</literal>: mensajes de usuario (genéricos);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uucp</literal>: mensajes del servidor UUCP (programa de copia Unix a Unix, «Unix to Unix Copy Program», un protocolo antiguo utilizado notablemente para distribuir correo electrónico);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>local0</literal> a <literal>local7</literal>: reservados para uso local.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Cada mensaje tiene asociado también un nivel de prioridad. Aquí está la lista en orden decreciente:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>emerg</literal>: «¡Ayuda!» Hay una emergencia y el sistema probablemente está inutilizado.
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>alerta</literal>: apúrese, cualquier demora puede ser peligrosa, debe reaccionar inmediatamente;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>crit</literal>: las condiciones son críticas;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>err</literal>: error;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>warn</literal>: advertencia (error potencial);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>notice</literal>: las condiciones son normales pero el mensaje es importante;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>info</literal>: mensaje informativo;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>debug</literal>: mensaje de depuración.
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section id="sect.syslog-config">
			<title>El archivo de configuración</title>
			 <para>
				La sintaxis del archivo <filename>/etc/rsyslog.conf</filename> está detallada en la página de manual <citerefentry><refentrytitle>rsyslog.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>, pero también hay disponible documentación HTML en el paquete <emphasis role="pkg">rsyslog-doc</emphasis> (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). El principio general es escribir pares de «selector» y «acción». El selector define los mensajes relevantes y la acción describe qué hacer con ellos.
			</para>
			 <section id="sect.syslog-selector-syntax">
				<title>Sintaxis del selector</title>
				 <para>
					El selector es una lista separada por punto y coma de pares <literal><replaceable>subsistema</replaceable>.<replaceable>prioridad</replaceable></literal> (por ejemplo: <literal>auth.notice;mail.info</literal>). Un asterisco puede representar todos los subsistemas o todas las prioridades (por ejemplo: <literal>*.alert</literal> o <literal>mail.*</literal>). Puede agrupar varios subsistemas separándolos con una coma (por ejemplo: <literal>auth,mail.info</literal>). La prioridad indicada también incluye los mensajes de prioridad igual o mayor; por lo tanto, <literal>auth.alert</literal> indica los mensajes del subsistema <literal>auth</literal> de prioridad <literal>alert</literal> o <literal>emerg</literal>. Si se agrega un signo de exclamación (!) como prefijo, indica lo contrario; en otras palabras, prioridades estrictamente menores. Por lo tanto, <literal>auth.!notice</literal> sólo incluye los mensajes del subsistema <literal>auth</literal> con prioridades <literal>info</literal> o <literal>debug</literal>. Si se agrega un signo igual (=) como prefijo corresponde única y exactamente con la prioridad indicada (<literal>auth.=notice</literal> sólo incluye los mensajes del subsistema <literal>auth</literal> con prioridad <literal>notice</literal>).
				</para>
				 <para>
					Cada elemento en la lista del selector reemplaza elementos anteriores. Así es posible restringir un conjunto o excluir ciertos elementos del mismo. Por ejemplo, <literal>kern.info;kern.!err</literal> significa los mensajes del núcleo con prioridades entre <literal>info</literal> y <literal>warn</literal>. La prioridad <literal>none</literal> indica el conjunto vacío (ninguna prioridad) y puede servir para excluir un subsistema de un conjunto de mensajes. Por lo tanto <literal>*.crit;kern.none</literal> indica todos los mensajes con prioridad igual o mayor a <literal>crit</literal> que no provengan del núcleo.
				</para>

			</section>
			 <section id="sect.syslog-action-syntax">
				<title>Sintaxis de las acciones</title>
				 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> La tubería («pipe») con nombre, una tubería persistente</title>
				 <indexterm>
					<primary>tubería con nombre</primary>
				</indexterm>
				 <indexterm>
					<primary>nombre, tubería con nombre</primary>
				</indexterm>
				 <para>
					Una tubería con nombre es un tipo particular de archivo que funciona como una tubería tradicional (la tubería que crea con el símbolo «|» en una consola), pero a través de un archivo. Este mecanismo tiene la ventaja de poder relacionar dos procesos que no están relacionados. Todo lo que se escriba en una tubería con nombre bloquea el proceso que escribe hasta que un proceso intente leer los datos escritos. Este segundo proceso lee los datos escritos por el primero, que puede luego continuar ejecutando.
				</para>
				 <para>
					Puede crear estos archivos con el programa <command>mkfifo</command>.
				</para>
				 </sidebar> <para>
					Las acciones posibles son:
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							agregar el mensaje a un archivo (ejemplo: <filename>/var/log/messages</filename>);
						</para>

					</listitem>
					 <listitem>
						<para>
							enviar el mensaje a un servidor <command>syslog</command> remoto (ejemplo: <literal>@log.falcot.com</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							enviar el mensaje a una tubería con nombre existente (ejemplo: <literal>|/dev/xconsole</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							enviar el mensaje a uno o más usuarios si tienen una sesión iniciada (ejemplo: <literal>root,rhertzog</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							enviar el mensaje a todos los usuarios con sesiones activas (ejemplo: <literal>*</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							escribir el mensaje en una consola de texto (ejemplo: <literal>/dev/tty8</literal>).
						</para>

					</listitem>

				</itemizedlist>
				 <sidebar> <title><emphasis>SEGURIDAD</emphasis> Reenvío de registros</title>
				 <indexterm>
					<primary>registro</primary>
					<secondary>reenvío</secondary>
				</indexterm>
				 <para>
					Es buena idea grabar los registros más importantes en una máquina separada (tal vez dedicada a este propósito), ya que evitará que cualquier intruso elimine los rastros de su intromisión (a menos, por supuesto, que también comprometa este otro servidor). Lo que es más, en el caso de un problema mayor (como un fallo abrupto del núcleo) tendrá disponible los registros en otro equipo, lo que aumenta sus probabilidades de determinar la secuencia de eventos que llevó al fallo.
				</para>
				 <para>
					Para aceptar mensajes de registro enviados por otras máquinas debe reconfigurar <emphasis>rsyslog</emphasis>: en la práctica es suficiente activar las líneas ya preparadas en el archivo <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> y <literal>$UDPServerRun 514</literal>).
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.inetd">
		<title>El superservidor <command>inetd</command></title>
		 <para>
			Inetd (frecuentemente llamado «superservidor de internet») es un servidor de servidores. Ejecuta a pedido servidores rara vez utilizados para que no tengan que ejecutar continuamente.
		</para>
		 <indexterm>
			<primary><command>inetd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>superservidor</primary>
		</indexterm>
		 <para>
			El archivo <filename>/etc/inetd.conf</filename> enumera estos servidores y sus puertos usuales. El programa <command>inetd</command> escucha en todos estos puertos y cuando detecta una conexión a uno de ellos ejecuta el programa servidor correspondiente.
		</para>
		 <sidebar> <title><emphasis>NORMATIVA DEBIAN</emphasis> Registro de un servidor en <filename>inetd.conf</filename></title>
		 <para>
			Frecuentemente los paquetes desean registrar un nuevo servidor en el archivo <filename>/etc/inetd.conf</filename>, pero la Normativa Debian prohíbe que un paquete modifique un archivo de configuración que no le pertenece. Es por esto que se creó el script <command>updated-inetd</command> (en el paquete del mismo nombre): este script administra el archivo de configuración y otros paquetes pueden utilizarlo para registrar un nuevo servidor en la configuración del superservidor.
		</para>
		 </sidebar> <para>
			Cada línea significativa del archivo <filename>/etc/inetd.conf</filename> describe un servidor con siete campos (separados con espacios):
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					El número de puerto TCP o UDP o el nombre del servicio (asociado con un número de puerto estándar con la información en el archivo <filename>/etc/services</filename>).
				</para>

			</listitem>
			 <listitem>
				<para>
					El tipo de zócalo: <literal>stream</literal> para una conexión TCP, <literal>dgram</literal> para datagramas UDP.
				</para>

			</listitem>
			 <listitem>
				<para>
					El protocolo: <literal>tcp</literal> o <literal>udp</literal>.
				</para>

			</listitem>
			 <listitem>
				<para>
					Las opciones: dos valores posibles, <literal>wait</literal> o <literal>nowait</literal> para indicarle a <command>inetd</command> si debe esperar o no a que el proceso ejecutado finalice antes de aceptar una nueva conexión. Para conexiones TCP, fáciles de gestionar simultáneamente, utilizará generalmente <literal>nowait</literal>. Para programas que respondan sobre UDP debería utilizar <literal>nowait</literal> sólo si el servidor es capaz de gestionar varias conexiones en paralelo. Puede agregar un punto al final de este campo seguido de la cantidad máxima de conexiones autorizadas por minuto (el límite predeterminado es 256).
				</para>

			</listitem>
			 <listitem>
				<para>
					El nombre del usuario bajo el que ejecutará el servidor.
				</para>

			</listitem>
			 <listitem>
				<para>
					La ruta completa al programa del servidor a ejecutar.
				</para>

			</listitem>
			 <listitem>
				<para>
					Los parámetros: esta es una lista completa de los parámetros del programa, incluyendo su propio nombre (<literal>argv[0]</literal> en C).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			El ejemplo a continuación ilustra los casos más comunes:
		</para>
		 <example id="example.inetd-conf">
			<title>Extracto de <filename>/etc/inetd.conf</filename></title>
			 
<programlisting>talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd
finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd
ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i</programlisting>

		</example>
		 <indexterm>
			<primary><command>tcpd</command></primary>
		</indexterm>
		 <para>
			Frecuentemente se utiliza el programa <command>tcpd</command> en el archivo <filename>/etc/inetd.conf</filename>. Permite limitar las conexiones entrantes aplicando reglas de control de acceso, documentadas en la página de manual <citerefentry><refentrytitle>hosts_access</refentrytitle>
			<manvolnum>5</manvolnum></citerefentry>, y que puede configurar en los archivos <filename>/etc/hosts.allow</filename> y <filename>/etc/hosts.deny</filename>. Una vez que se determinó que la conexión está autorizada, <command>tcpd</command> ejecuta el servidor real (en el ejemplo: <command>in.fingerd</command>). Vale la pena aclarar que <command>tcpd</command> necesita el nombre con el que se lo invoca (que es el primer parámetro: <literal>argv[0]</literal>) para identificar el programa real a ejecutar. No debería iniciar la lista de parámetros con <literal>tcpd</literal> sino con el programa subyacente.
		</para>
		 <sidebar> <title><emphasis>COMUNIDAD</emphasis> Wietse Venema</title>
		 <indexterm>
			<primary>Wietse Venema</primary>
		</indexterm>
		 <indexterm>
			<primary>Venema, Wietse</primary>
		</indexterm>
		 <para>
			Wietse Venema, programador reconocido por su experiencia sobre seguridad, es el autor del programa <command>tcpd</command>. También es el creador principal de Postfix, el servidor de correo modular (SMTP, protocolo simple de transferencia de correo: «Simple Mail Transfer Protocol»), diseñado para ser más seguro y confiable que <command>sendmail</command> que tiene una larga historia de vulnerabilidades de seguridad.
		</para>
		 </sidebar> <sidebar> <title><emphasis>ALTERNATIVA</emphasis> Otros programas <command>inetd</command></title>
		 <para>
			Si bien Debian instala <emphasis role="pkg">openbsd-inetd</emphasis> de forma predeterminada, no faltan alternativas: podemos mencionar <emphasis role="pkg">inetutils-inetd</emphasis>, <emphasis role="pkg">micro-inetd</emphasis>, <emphasis role="pkg">rlinetd</emphasis> y <emphasis role="pkg">xinetd</emphasis>.
		</para>
		 <para>
			Esta última encarnación de superservidor ofrece posibilidades muy interesantes. Notablemente, se puede dividir su configuración en varios archivos (almacenados, por supuesto, en el directorio <filename>/etc/xinetd.d/</filename>), lo que puede hacer más sencilla la vida del administrador.
		</para>
		 <para>
			Por último, pero no menos importante, es posible emular el comportamiento de <command>inetd</command> con el mecanismo de activación de zócalos de <command>systemd</command> (ver <xref linkend="sect.systemd" />).
		</para>
		 </sidebar>
	</section>
	 <section id="sect.task-scheduling-cron-atd">
		<title>Programación de tareas con <command>cron</command> y <command>atd</command></title>
		 <indexterm>
			<primary><command>cron</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>atd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>tareas programadas</primary>
		</indexterm>
		 <indexterm>
			<primary>programación de tareas</primary>
		</indexterm>
		 <para>
			<command>cron</command> es el demonio responsable de ejecutar tareas programadas y recurrentes (todos los días, todas las semanas, etc.); <command>atd</command> está encargado de los programas a ejecutar una sola vez pero en un momento específico en el futuro.
		</para>
		 <para>
			En un sistema Unix, muchas tareas están programadas para ejecutarse regularmente:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					rotar los archivos de registro;
				</para>

			</listitem>
			 <listitem>
				<para>
					actualizar la base de datos del programa <command>locate</command>;
				</para>

			</listitem>
			 <listitem>
				<para>
					respaldos;
				</para>

			</listitem>
			 <listitem>
				<para>
					scripts de mantenimiento (como limpiar los archivos temporales).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			De forma predeterminada, todos los usuarios pueden programar tareas para ejecutar. Cada usuario tiene su propio «<emphasis>crontab</emphasis>» en el que pueden almacenarlas. Puede editarlo ejecutando <command>crontab -e</command> (el contenido del mismo es almacenado en el archivo <filename>/var/spool/cron/crontabs/<replaceable>usuario</replaceable></filename>).
		</para>
		 <sidebar> <title><emphasis>SEGURIDAD</emphasis> Restricción de <command>cron</command> o <command>atd</command></title>
		 <para>
			Puede restringir el acceso a <command>cron</command> si crea un archivo de autorización explícita (una lista blanca) en <filename>/etc/cron.allow</filename> donde indique sólo los usuarios autorizados a programar tareas. Todos los demás usuarios automáticamente quedarán excluidos de dicha funcionalidad. A la inversa, si sólo desea bloquear unos pocos usuarios problemáticos, podría agregar su nombres de usuario en el archivo de prohibición explícita <filename>/etc/cron.deny</filename>. Esta misma funcionalidad está disponible para <command>atd</command> con los archivos <filename>/etc/at.allow</filename> y <filename>/etc/at.deny</filename>.
		</para>
		 </sidebar> <para>
			El usuario root tiene su propio «<emphasis>crontab</emphasis>», pero también puede utilizar el archivo <filename>/etc/crontab</filename> o escribir archivos «<emphasis>crontab</emphasis>» adicionales en el directorio <filename>/etc/cron.d</filename>. Estas dos últimas soluciones tienen la ventaja de poder especificar el usuario bajo el que se ejecutará el programa.
		</para>
		 <para>
			De forma predeterminada, el paquete <emphasis>cron</emphasis> incluye algunas tareas programadas que ejecutan:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					programas en el directorio <filename>/etc/cron.hourly/</filename> una vez por hora;
				</para>

			</listitem>
			 <listitem>
				<para>
					programas en el directorio <filename>/etc/cron.daily/</filename> una vez por día;
				</para>

			</listitem>
			 <listitem>
				<para>
					programas en el directorio <filename>/etc/cron.weekly/</filename> una vez por semana;
				</para>

			</listitem>
			 <listitem>
				<para>
					programas en el directorio <filename>/etc/cron.monthly/</filename> una vez por mes.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Muchos paquetes Debian dependen de este servicio: agregan sus scripts de mantenimiento en estos directorios, los cuales garantizan un funcionamiento óptimo de sus servicios.
		</para>
		 <section id="sect.format-crontab">
			<title>Formato de un archivo <filename>crontab</filename></title>
			 <indexterm>
				<primary><filename>crontab</filename></primary>
			</indexterm>
			 <sidebar> <title><emphasis>SUGERENCIA</emphasis> Atajos de texto para <command>cron</command></title>
			 <para>
				<command>cron</command> reconoce algunas abreviaciones que reemplazan los primeros cinco campos de un elemento de <filename>crontab</filename>. Corresponden a las opciones de programación más comunes:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>@yearly</literal>: una vez por año (1 de Enero a las 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@monthly</literal>: una vez por mes (el 1ro de mes a las 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@weekly</literal>: una vez por semana (Domingo a las 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@daily</literal>: una vez por día (a las 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@hourly</literal>: una vez por hora (al principio de cada hora).
					</para>

				</listitem>

			</itemizedlist>
			 </sidebar> <sidebar> <title><emphasis>CASO ESPECIAL</emphasis> <command>cron</command> y horarios de verano</title>
			 <para>
				En Debian, <command>cron</command> tiene en cuenta los cambios de hora (para horarios de verano o, de hecho, cualquier cambio importante en la hora local) de la mejor forma que le es posible. Por lo tanto, las tareas que deben ejecutarse durante una hora que nunca existió (por ejemplo: aquellas programadas para las 02:30 durante el cambio de horario de verano en Francia, ya que el reloj salta de las 02:00 a las 03:00 directamente) se ejecutarán poco después del cambio de hora (por lo tanto, alrededor de las 03:00 DST). Por otro lado, en otoño, las tareas serán ejecutadas sólo una vez cuando podrían ser ejecutadas varias veces (a las 02:30 DST y luego a las 02:30 en horario estándar ya que a las 03:00 DST el reloj vuelve a las 02:00).
			</para>
			 <para>
				Tenga cuidado, sin embargo, si el orden y el tiempo entre ejecuciones de tareas programadas importa. Debe revisar la compatibilidad de estas limitaciones con el comportamiento de <command>cron</command>; si es necesario, puede preparar una programación especial para las dos noches problemáticas del año.
			</para>
			 </sidebar> <para>
				Cada línea significativa de un archivo <emphasis>crontab</emphasis> describe una tarea programada con los siguientes seis (o siete) campos:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						el valor del minuto (número de 0 a 59);
					</para>

				</listitem>
				 <listitem>
					<para>
						el valor de la hora (de 0 a 23);
					</para>

				</listitem>
				 <listitem>
					<para>
						el valor del día del mes (de 1 a 31);
					</para>

				</listitem>
				 <listitem>
					<para>
						el valor del mes (de 1 a 12);
					</para>

				</listitem>
				 <listitem>
					<para>
						el valor de los días de la semana (de 0 a 7, donde 1 es el lunes y el domingo es tanto el 0 como el 7; también es posible utilizar las tres primeras letras del nombre del día en inglés, como <literal>Sun</literal>, <literal>Mon</literal>, etc.);
					</para>

				</listitem>
				 <listitem>
					<para>
						el nombre de usuario bajo el que se ejecutará el programa (en el archivo <filename>/etc/crontab</filename> y en los fragmentos ubicados en <filename>/etc/cron.d/</filename>, pero no en los archivos de cada usuario);
					</para>

				</listitem>
				 <listitem>
					<para>
						el programa a ejecutar (cuando se cumpla la condición definida por los primeros cinco campos).
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Todos estos detalles están documentados en la página de manual <citerefentry><refentrytitle>crontab</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry>.
			</para>
			 <para>
				Puede expresar cada valor como una lista de valores posibles (separados por coma). La sintaxis <literal>a-b</literal> describe el intervalo de todos los valores entre <literal>a</literal> y <literal>b</literal>. La sintaxis <literal>a-b/c</literal> describe el intervalo con un incremento de <literal>c</literal> (por ejemplo: <literal>0-10/2</literal> es lo mismo que <literal>0,2,4,6,8,10</literal>. Un asterisco «<literal>*</literal>» es un comodín y representa todos los valores posibles.
			</para>
			 <example id="example.crontab">
				<title>Ejemplo de archivo <filename>crontab</filename></title>
				 
<programlisting>#Formato
#min hora dia mes dds  programa

# Descargar los datos todas las noches a las 19:25
 25  19   *   *   *    $HOME/bin/descargar.pl

# 08:00 en días de semana (Lunes a Viernes)
 00  08   *   *   1-5  $HOME/bin/haceralgo

# Reiniciar el proxy IRC luego de cada reinicio
@reboot /usr/bin/dircproxy</programlisting>

			</example>
			 <sidebar> <title><emphasis>SUGERENCIA</emphasis> Ejecución de un programa durante el inicio</title>
			 <para>
				Para ejecutar un programa sólo una vez, justo después de iniciar el equipo, puede utilizar el macro <literal>@reboot</literal> (reiniciar <command>cron</command> no disparará aquello programado con <literal>@reboot</literal>). Este macro reemplaza los primeros cinco campos de un elemento en el archivo «<emphasis>crontab</emphasis>».
			</para>
			 </sidebar> <sidebar> <title><emphasis>ALTERNATIVA</emphasis> Emulación de <command>cron</command> mediante <command>systemd</command></title>
			 <para>
				Es posible emular parte del comportamiento de <command>cron</command> mediante el mecanismo de temporizadores de <command>systemd</command> (ver <xref linkend="sect.systemd" />).
			</para>
			 </sidebar>
		</section>
		 <section id="sect.at-command">
			<title>Utilización del programa <command>at</command></title>
			 <indexterm>
				<primary><command>at</command></primary>
			</indexterm>
			 <para>
				La orden <command>at</command> ejecuta un programa en un momento específico en el futuro. Obtiene la fecha y hora deseada como parámetros y el programa a ejecutar en su entrada estándar. Ejecutará el programa como si hubiese sido ingresado en la consola actual. <command>at</command> incluso se encarga de mantener el entorno para poder reproducir las mismas condiciones al ejecutar el programa. Puede indicar la hora con las convenciones usuales: <literal>16:12</literal> o <literal>4:12pm</literal> representan 12 minutos pasadas las 4 de la tarde. También puede especificar la fecha en varios formatos europeos u occidentales, incluyendo <literal>DD.MM.AA</literal> (<literal>27.07.15</literal> representaría el 27 de Julio de 2015), <literal>AAAA-MM-DD</literal> (la misma fecha se representaría como <literal>2015-07-27</literal>), <literal>MM/DD/[CC]AA</literal> (es decir: <literal>12/25/15</literal> o <literal>12/25/2015</literal> representan, ambas, el 25 de Diciembre de 2015) o simplemente <literal>MMDDCCAA</literal> (de forma que <literal>122515</literal> o <literal>12252015</literal> también representaría el 25 de Diciembre de 2015). Sin fecha, ejecutará el programa tan pronto como el reloj indique la hora especificada (el mismo día o el siguiente si ya pasó dicha hora ese día). También puede ingresar simplemente «today» o «tomorrow» representando el día actual o el día siguiente, respectivamente.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>
<computeroutput>&gt; </computeroutput><userinput>echo "¡No olvides desearle un feliz cumpleaños a Raphaël!" \</userinput>
<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>
<computeroutput>&gt; </computeroutput><userinput>END</userinput>
<computeroutput>warning: commands will be executed using /bin/sh
job 31 at Mon Jul 27 09:00:00 2015</computeroutput></screen>
			 <para>
				Una sintaxis alternativa posterga la ejecución por un tiempo determinado: <command>at now + <replaceable>número</replaceable> <replaceable>período</replaceable></command>. El <replaceable>período</replaceable> puede ser <literal>minutes</literal> (minutos), <literal>hours</literal> (horas), <literal>days</literal> (días) o <literal>weeks</literal> (semanas). <replaceable>número</replaceable> simplemente indica la cantidad de dichas unidades deben pasar antes de ejecutar el programa.
			</para>
			 <para>
				Para cancelar una tarea programada con <command>cron</command>, simplemente ejecute <command>crontab -e</command> y elimine la línea correspondiente del archivo <emphasis>crontab</emphasis>. Para tareas en <command>at</command> es casi igual de sencillo: ejecute <command>atrm <replaceable>número-tarea</replaceable></command>. El número de tarea es indicado por <command>at</command> cuando la programó, pero puede volver a encontrarla ejecutando <command>atq</command> que le proveerá una lista de las tareas programadas actualmente.
			</para>
			 <indexterm>
				<primary><command>atrm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>atq</command></primary>
			</indexterm>

		</section>

	</section>
	 <section id="sect.asynchronous-task-scheduling-anacron">
		<title>Programación de tareas asincrónicas: <command>anacron</command></title>
		 <para>
			<command>anacron</command> es el demonio que completa <command>cron</command> en equipos que no están encendidos todo el tiempo. Dado que generalmente las tareas recurrentes están programadas para la mitad de la noche, no ejecutarán nunca si la máquina está apagada en esos momentos. El propósito de <command>anacron</command> es ejecutarlas teniendo en cuenta los períodos de tiempo en los que el equipo no estuvo funcionando.
		</para>
		 <indexterm>
			<primary><command>anacron</command></primary>
		</indexterm>
		 <para>
			Sepa que <command>anacron</command> frecuentemente ejecutará dichos programas unos minutos después de iniciar la máquina, lo que utilizará poder de procesamiento del equipo. Es por esto que se ejecutan las tareas en el archivo <filename>/etc/anacrontab</filename> con el programa <command>nice</command> que reduce su prioridad de ejecución, limitando así su impacto en el resto del sistema. Tenga en cuenta que el formato de este archivo no es el mismo que el de <filename>/etc/crontab</filename>; si tiene necesidades especiales para <command>anacron</command> revise la página de manual <citerefentry><refentrytitle>anacrontab</refentrytitle>
			 <manvolnum>5</manvolnum></citerefentry>.
		</para>
		 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Prioridades y <command>nide</command></title>
		 <para>
			Los sistemas Unix (y, por lo tanto, Linux) son sistemas multitarea y multiusuario. Varios procesos puede ejecutar en paralelo y pertenecer a diferentes usuarios: el núcleo mediará el acceso a los recursos para los diferentes procesos. Como parte de esta tarea tiene el concepto de prioridad, que permite favorecer a ciertos procesos por sobre otros según sea necesario. Cuando sabe que un proceso puede ejecutar con prioridad baja, puede indicarlo ejecutándolo con <command>nice <replaceable>programa</replaceable></command>. El programa entonces tendrá una porción más pequeña del CPU y tendrá un menor impacto sobre otros procesos en ejecución. Por supuesto, si no hay otros procesos que necesiten ejecutar el programa no será restringido artificialmente.
		</para>
		 <para>
			<command>nice</command> funciona con niveles de «bondad»: los niveles positivos (de 1 a 19) reducen progresivamente la prioridad mientras que los niveles negativos (de -1 a -20) aumentan la prioridad — pero sólo root puede utilizar estos niveles negativos. A menos que se indique lo contrario (revise la página de manual <citerefentry><refentrytitle>nice</refentrytitle>
			 <manvolnum>1</manvolnum></citerefentry>), <command>nice</command> aumentará en 10 el nivel actual.
		</para>
		 <para>
			Si descubre que una tarea que está procesando debería haberse ejecutado con <command>nice</command> no es muy tarde para corregirlo; el programa <command>renice</command> modifica la prioridad de cualquier proceso que está en ejecución en la dirección que desee (pero reducir la «bondad» de un proceso está reservado al usuario root).
		</para>
		 </sidebar> <para>
			Instalar el paquete <emphasis role="pkg">anacron</emphasis> desactiva la ejecución via <command>cron</command> de los scripts en los directorios <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename> y <filename>/etc/cron.monthly/</filename>. Esto evita que sean ejecutados tanto por <command>anacron</command> como por <command>cron</command>. El programa <command>cron</command> continuará activo y seguirá administrando otras tareas programadas (especialmente aquellas programadas por los usuarios).
		</para>

	</section>
	 <section id="sect.quotas">
		<title>Cuotas</title>
		 <indexterm>
			<primary>cuota</primary>
		</indexterm>
		 <para>
			El sistema de cuotas permite limitar el espacio en disco reservado para un usuario o grupo de usuarios. Para configurarlo, debe tener un núcleo compatible (compilado con la opción <varname>CONFIG_QUOTA</varname>) — como es el caso de los núcleos Debian. Puede encontrar el software de administración de cuotas en el paquete Debian <emphasis role="pkg">quota</emphasis>.
		</para>
		 <para>
			Para activar las cuotas en un sistema de archivos debe indicar las opciones <literal>usrquota</literal> y <literal>grpquota</literal> en el archivo <filename>/etc/fstab</filename> para las cuotas de usuario y grupos, respectivamente. Al reiniciar el equipo se actualizarán las cuotas cuando no exista actividad en el disco (una condición necesaria para poder contabilizar apropiadamente el espacio en disco ya utilizado).
		</para>
		 <para>
			Ejecutar <command>edquota <replaceable>usuario</replaceable></command> (o <command>edquota -g <replaceable>grupo</replaceable></command>) le permite modificar los límites mientras examina el uso actual del espacio en disco.
		</para>
		 <indexterm>
			<primary><command>edquota</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>YENDO MÁS ALLÁ</emphasis> Definición de cuotas con un script</title>
		 <indexterm>
			<primary><command>setquota</command></primary>
		</indexterm>
		 <para>
			Puede utilizar el programa <command>setquota</command> en un script para modificar automáticamente muchas cuotas. Su página de manual <citerefentry><refentrytitle>setquota</refentrytitle>
			 <manvolnum>8</manvolnum></citerefentry> contiene los detalles de la sintaxis que debe utilizar.
		</para>
		 </sidebar> <para>
			El sistema de cuotas le permite definir cuatro límites:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					dos límites (llamados «suave» y «duro») se refieren a la cantidad de bloques utilizados. Si creó el sistema de archivos con un tamaño de bloque de 1 kibibyte, cada bloque contiene 1024 bytes del mismo archivo. Por lo tanto, los bloques no saturados inducen pérdida de espacio en disco. Puede saturar una cuota de 100 bloques, que teóricamente permitirían almacenar 102400 bytes, con sólo 100 archivos de 500 bytes cada uno que sólo representan 50000 bytes en total.
				</para>

			</listitem>
			 <listitem>
				<para>
					dos límites (suave y duro) que hacen referencia a la cantidad de inodos utilizados. Cada archivo ocupa al menos un inodo para almacenar información sobre sí mismo (permisos, dueño, marcas temporales del último acceso, etc.). Por lo tanto, es un límite en la cantidad de archivos del usuario.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Puede exceder temporalmente un límite «suave»; el programa <command>warnquota</command>, generalmente ejecutado por <command>cron</command>, simplemente advertirá al usuario que excedieron su cuota. Nunca podrá exceder un límite «duro»: el sistema rechazará toda operación que fuera a exceder una cuota dura.
		</para>
		 <sidebar> <title><emphasis>VOCABULARIO</emphasis> Bloques e inodos</title>
		 <indexterm>
			<primary>bloque (disco)</primary>
		</indexterm>
		 <indexterm>
			<primary>inodo</primary>
		</indexterm>
		 <para>
			El sistema de archivos divide el disco duro en bloques — pequeñas áreas contiguas. Definirá el tamaño de dichos bloques cuando cree el sistema de archivos y generalmente varía entre 1 y 8 kibibytes.
		</para>
		 <para>
			Un bloque puede utilizarse para almacenar los datos reales de un archivo o los metadatos utilizados por el sistema de archivos. Entre estos metadatos, encontrará especialmente los inodos. Un inodo utiliza un bloque del disco duro (pero no se lo tiene en cuenta respecto a la cuota de bloques, sólo en la cuota de inodos) y contiene tanto la información del archivo al que corresponde (nombre, dueño, permisos, etc.) y punteros a los bloques de datos que son utilizados realmente. Para archivos muy grandes que ocupan más bloques que los un inodo puede referenciar, existe un sistema de bloques indirectos; el inodo hace referencia a una lista de bloques que no contienen datos directamente sino otra lista de bloques.
		</para>
		 </sidebar> <indexterm>
			<primary><command>warnquota</command></primary>
		</indexterm>
		 <para>
			Si ejecuta <command>edquota -t</command> puede definir un «período de gracia» máximo autorizado durante el que se puede exceder un límite suave. Luego de este período se interpretará el límite suave como uno duro y el usuario deberá reducir su uso de espacio en disco por debajo de este límite para poder escribir en disco duro.
		</para>
		 <sidebar> <title><emphasis>YENDO MÁS ALLÁ</emphasis> Configuración de una cuota predeterminada para nuevos usuarios</title>
		 <para>
			Para definir una cuota automática para usuarios nuevos, debe configurar un usuario patrón (con <command>edquota</command> o <command>setquota</command>) e indicar su nombre de usuario en la variable <varname>QUOTAUSER</varname> en el archivo <filename>/etc/adduser.conf</filename>. Se aplicará automáticamente dicha configuración de cuota a cada nuevo usuario creado con el programa <command>adduser</command>.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.backup">
		<title>Respaldo</title>
		 <para>
			Realizar respaldos es una de las principales responsabilidades de cualquier administrador; pero es un tema complejo, que involucra herramientas potentes que usualmente son difíciles de dominar.
		</para>
		 <indexterm>
			<primary>respaldo</primary>
		</indexterm>
		 <indexterm>
			<primary>recuperación</primary>
		</indexterm>
		 <para>
			Existen muchos programas, como <command>amanda</command>, <command>bacula</command> y <command>BackupPC</command>. Éstos son sistemas cliente/servidor con muchas opciones y cuya configuración es bastante complicada. Algunos proveen una interfaz de usuario amigable para mitigarlo. Sin embargo, como bien puede comprobar con <command>apt-cache search backup</command>, Debian contiene docenas de paquetes de software de respaldo que cubren todos los casos de uso posibles.
		</para>
		 <indexterm>
			<primary><command>amanda</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>bacula</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>BackupPC</command></primary>
		</indexterm>
		 <para>
			En lugar de detallar algunos de ellos, esta sección presentará lo que pensaron los administradores de Falcot Corp cuando definieron su estrategia de respaldos.
		</para>
		 <para>
			En Falcot Corp los respaldos tiene dos objetivos: restaurar archivos eliminados por error y recuperar rápidamente cualquier equipo (servidor o de escritorio) en el que falle el disco duro.
		</para>
		 <section>
			<title>Respaldos con <command>rsync</command></title>
			 <para>
				Habiendo descartado los respaldos en cintas por ser lentos y costosos, se respaldarán los datos en discos duros en un servidor dedicado en el que utilizarán RAID por software (revise la <xref linkend="sect.raid-soft" />) que protegerá los datos contra errores de disco duro. No se respaldarán individualmente los equipos de escritorio, pero se le informa a los usuarios que se respaldará su cuenta personal en el servidor de archivos del departamento. Se utiliza diariamente el programa <command>rsync</command> (en el paquete del mismo nombre) para respaldar estos diferentes servidores.
			</para>
			 <indexterm>
				<primary><command>rsync</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> El enlace duro, un segundo nombre para el archivo</title>
			 <indexterm>
				<primary>enlace</primary>
				<secondary>duro</secondary>
			</indexterm>
			 <indexterm>
				<primary>duro, enlace</primary>
			</indexterm>
			 <para>
				A diferencia de un enlace simbólico, no se puede diferenciar un enlace duro del archivo enlazado. Crear un enlace duro es esencialmente lo mismo que dar al archivo un segundo nombre. Es por esto que eliminar un enlace duro sólo elimina uno de los nombres asociados al archivo. Siempre que quede otro nombre asociado al archivo, los datos en él seguirán presentes en el sistema de archivos. Es interesante saber que, a diferencia de una copia, un enlace duro no ocupa espacio adicional en el disco duro.
			</para>
			 <para>
				Puede crear un enlace duro con <command>ln <replaceable>objetivo</replaceable> <replaceable>enlace</replaceable></command>. El archivo <replaceable>enlace</replaceable> será un nuevo nombre para el archivo <replaceable>objetivo</replaceable>. Sólo puede crear enlaces duros en el mismo sistema de archivos, mientras que los enlaces simbólicos no tienen dicha restricción.
			</para>
			 </sidebar> <para>
				El espacio en disco disponible prohíbe la implementación de un respaldo diario completo. Por lo tanto, el programa <command>rsync</command> es precedido con una duplicación del contenido del respaldo anterior con enlaces duros, lo que evita utilizar demasiado espacio en disco. Luego, el proceso <command>rsync</command> sólo reemplazará los archivos que fueron modificados desde el último respaldo. Con este mecanismo, pueden mantener una gran cantidad de respaldos en un espacio pequeño. Debido a que todos los respaldos están disponibles inmediatamente (por ejemplo, en diferentes directorios de un recurso compartido en la red) puede realizar comparaciones entre dos fechas rápidamente.
			</para>
			 <indexterm>
				<primary>copia de respaldo</primary>
			</indexterm>
			 <indexterm>
				<primary>respaldo</primary>
				<secondary>copia</secondary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">dirvish</emphasis></primary>
			</indexterm>
			 <para>
				Puede implementar fácilmente este mecanismo de respaldo con el programa <command>dirvish</command>. Utiliza un espacio de almacenamiento de respaldo («bank» — banco — en su vocabulario) en el que ubica copias con marcas temporales de conjuntos de archivos de respaldo (estos conjuntos son llamados «vaults» — bóvedas — en la documentación de dirvish).
			</para>
			 <para>
				La configuración principal se encuentra en el archivo <filename>/etc/dirvish/master.conf</filename>. Define la ubicación del espacio de almacenamiento de respaldos, la lista de «bóvedas» administradas y los valores predeterminados de expiración de los respaldos. El resto de la configuración está ubicada en los archivos <filename><replaceable>banco</replaceable>/<replaceable>bóveda</replaceable>/dirvish/default.conf</filename> y contienen las configuraciones específicas a los conjuntos de archivos correspondientes.
			</para>
			 <example id="example.dirvish-master">
				<title>EL archivo <filename>/etc/dirvish/master.conf</filename></title>
				 
<programlisting>bank:
    /backup
exclude:
    lost+found/
    core
    *~
Runall:
    root    22:00
expire-default: +15 days
expire-rule:
#   MIN HR    DOM MON       DOW  STRFTIME_FMT
    *   *     *   *         1    +3 months
    *   *     1-7 *         1    +1 year
    *   *     1-7 1,4,7,10  1</programlisting>

			</example>
			 <para>
				La configuración <literal>bank</literal> indica el directorio en el que se almacenarán los respaldos. La configuración <literal>exclude</literal> le permite indicar archivos (o tipos de archivo) a excluir del respaldo. <literal>Runall</literal> es una lista de conjuntos de archivos a respaldar con una marca temporal para cada conjunto, lo que le permite asignar la fecha correcta la copia en caso que el respaldo no ejecute exactamente en el momento programado. Debe indicar una hora justo antes del momento de ejecución (las 22:04 de forma predeterminada en Debian, según <filename>/etc/cron.d/dirvish</filename>). Finalmente, las configuraciones <literal>expire-default</literal> y <literal>expire-rule</literal> definen las políticas de expiración para los respaldos. El ejemplo anterior mantiene por siempre los respaldos generados el primer domingo de cada trimestre, elimina después de un año aquellos realizados el primer domingo de cada mes y luego de 3 meses aquellos realizados otros días domingo. Mantendrá los demás respaldos diarios por 15 días. El orden de las reglas sí importa, Dirvish utiliza la última regla que coincida o la directiva <literal>expire-default</literal> si ninguna línea de <literal>expire-rule</literal> coincide.
			</para>
			 <sidebar> <title><emphasis>EN LA PRÁCTICA</emphasis> Expiración programada</title>
			 <para>
				<command>dirvish-expire</command> no utiliza las reglas de expiración para realizar su trabajo. En realidad, se utilizan las reglas de expiración cuando se crea una nueva copia de respaldo para definir la fecha de expiración asociada con dicha copia. <command>dirvish-expire</command> simplemente examina las copias almacenadas y elimina aquellas cuyas fechas de expiración ya pasaron.
			</para>
			 </sidebar> <example id="example.dirvish-vault">
				<title>El archivo <filename>/backup/root/dirvish/default.conf</filename></title>
				 
<programlisting>client: rivendell.falcot.com
tree: /
xdev: 1
index: gzip
image-default: %Y%m%d
exclude:
    /var/cache/apt/archives/*.deb
    /var/cache/man/**
    /tmp/**
    /var/tmp/**
    *.bak</programlisting>

			</example>
			 <para>
				El ejemplo anterior especifica el conjunto de archivos a respaldar: los archivos en la máquina <emphasis>rivendell.falcot.com</emphasis> (para respaldos de datos locales, simplemente especifique el nombre local del equipo según indica <command>hostname</command>), especialmente aquellos en el árbol raíz (<literal>tree: /</literal>), excepto aquellos enumerados en <literal>exclude</literal>. El respaldo estará limitado a los contenidos de un sistema de archivos (<literal>xdev: 1</literal>). No incluirá archivos de otros puntos de montaje. Generará un índice de los archivos almacenados (<literal>index: gzip</literal>) y el nombre de la imagen estará basado en la fecha actual (<literal>image-default: %Y%m%d</literal>).
			</para>
			 <para>
				Existen muchas opciones disponibles, todas documentadas en la página de manual <citerefentry><refentrytitle>dirvish.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>. Una vez que finalizó estos archivos de configuración deben inicializar cada conjunto de archivos ejecutando <command>dirvish --vault <replaceable>bóveda</replaceable> --init</command>. Luego, la ejecución <command>dirvish-runall</command> automáticamente generará una nueva copia de respaldo inmediatamente después de eliminar aquellas que hayan expirado.
			</para>
			 <sidebar> <title><emphasis>EN LA PRÁCTICA</emphasis> Respaldos remotos sobre SSH</title>
			 <para>
				Cuando dirvish necesita guardar datos en una máquina remota, utilizará <command>ssh</command> para conectarse con ella, e iniciará <command>rsync</command> en modo servidor. Esto necesita que el usuario root pueda conectarse automáticamente. Las llaves de autenticación SSH permiten esto exactamente (revise la <xref linkend="sect.ssh-key-based-auth" />).
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>Restauración de equipos sin repaldos</title>
			 <para>
				Los equipos de escritorio, que no son respaldados, serán fáciles de reinstalar desde DVD-ROMs personalizados que fueron preparados con <emphasis>Simple-CDD</emphasis> (revise la <xref linkend="sect.simple-cdd" />). Dado que se realiza una instalación desde cero, se pierden todas las personalizaciones que pueden haberse realizado luego de la instalación inicial. Esto no es un problema ya que los sistemas están conectados a un directorio LDAP central para las cuentas de usuario y la mayoría de las aplicaciones de escritorio son preconfiguradas gracias a dconf (revise la <xref linkend="sect.gnome-desktop" /> para más información al respecto).
			</para>
			 <para>
				Los administradores de Falcot Corp están al tanto de las limitaciones de sus políticas de respaldo. Debido a que no pueden proteger el servidor de respaldo tan bien como una cinta en una caja fuerte a prueba de fuego, lo instalaron en una habitación separada para que desastres como fuego en la sala de servidores no destruyan los respaldos junto con todo lo demás. Lo que es más, realizan un respaldo incremental en DVD-ROM una vez por semana — sólo se incluyen los archivos que fueron modificados desde el último respaldo.
			</para>
			 <sidebar> <title><emphasis>YENDO MÁS ALLÁ</emphasis> Respaldo de servicios SQL y LDAP</title>
			 <para>
				No es posible hacer copia de seguridad de muchos servicios (como bases de datos SQL y LDAP) simplemente copiando sus archivos (a menos que sean detenidos apropiadamente mientras se crean estos respaldos, lo que frecuentemente es problemático ya que fueron pensados para estar disponibles todo el tiempo). Por lo tanto es necesario utilizar un mecanismo de «exportación» para crear un «volcado de datos» que pueda ser respaldado de forma segura. Generalmente son archivos grandes pero se comprimen fácilmente. Para reducir el espacio de almacenamiento necesario, se puede almacer únicamente un archivo de texto completo por semana y diferencias (<command>diff</command>) cada día, que puede crear utilizando una orden similar a <command>diff <replaceable>archivo_de_ayer</replaceable> <replaceable>archivo_de_hoy</replaceable></command>. El programa <command>xdelta</command> produce diferencias incrementales de volcados binarios.
			</para>
			 <indexterm>
				<primary><command>xdelta</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>diff</command></primary>
			</indexterm>
			 <indexterm>
				<primary>volcado</primary>
			</indexterm>
			 </sidebar> <sidebar> <title><emphasis>CULTURA</emphasis> <emphasis>TAR</emphasis>, el estándar para respaldos en cinta</title>
			 <indexterm>
				<primary>respaldo</primary>
				<secondary>en cinta</secondary>
			</indexterm>
			 <indexterm>
				<primary>cinta, respaldo en</primary>
			</indexterm>
			 <indexterm>
				<primary>TAR</primary>
			</indexterm>
			 <para>
				Históricamente, la forma más sencilla de realizar un respaldo en Unix era almacenar un compendio <emphasis>TAR</emphasis> en una cinta. Inclusive el programa <command>tar</command> obtuvo su nombre de «compendio en cinta» («Tape ARchive»).
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.hotplug">
		<title>Conexión en caliente: <emphasis>hotplug</emphasis></title>
		 <section>
			<title>Introducción</title>
			 <para>
				El subsistema <emphasis>hotplug</emphasis> del núcleo administra dinámicamente el agregar y eliminar dispositivos mediante la carga de los controladores apropiados y la creación de los archivos de dispositivo correspondientes (con la ayuda de <command>udevd</command>). Con el hardware moderno y la virtualización, casi todo puede ser conectado en caliente: desde los periféricos USB/PCMCIA/IEEE 1394 usuales hasta discos duros SATA, pero también la CPU y la memoria.
			</para>
			 <para>
				El núcleo tiene una base de datos que asocia cada ID de dispositivo con el controlador necesario. Se utiliza esta base de datos durante el inicio para cargar todos los controladores de los periféricos detectados en los diferentes canales, pero también cuando se conecta un dispositivo en caliente. Una vez el dispositivo está listo para ser utilizado se envía un mensaje a <command>udevd</command> para que pueda crear los elementos correspondientes en <filename>/dev/</filename>.
			</para>
			 <indexterm>
				<primary><emphasis>hotplug</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>conexión en caliente («hotplug»)</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>PCMCIA</primary>
			</indexterm>
			 <indexterm>
				<primary>SATA</primary>
			</indexterm>

		</section>
		 <section>
			<title>El problema de nombres</title>
			 <para>
				Antes que existieran las conexiones en caliente, era sencillo asignar un nombre fijo a un dispositivo. Simplemente estaba basado en la posición del dispositivo en su canal correspondiente. Pero esto no es posible cuando dichos dispositivos puede aparecer y desaparecer del canal. El caso típico es el uso de una cámara digital y una llave USB, ambos serán un disco para el equipo. El primero en conectarse puede ser <filename>/dev/sdb</filename> y el segundo <filename>/dev/sdc</filename> (siempre que <filename>/dev/sda</filename> represente el disco duro del equipo en sí). El nombre del dispositivo no es fijo, depende del orden en el que se conecte los dispositivos.
			</para>
			 <para>
				Además, más y más controladores utilizan valores dinámicos para los números mayor/menor de los dispositivos, lo que hace imposible tener elementos estáticos para dichos dispositivos ya que estas características esenciales puede cambiar luego de reiniciar el equipo.
			</para>
			 <para>
				Se creó <emphasis>udev</emphasis> precisamente para solucionar este problema.
			</para>

		</section>
		 <section>
			<title>Cómo funciona <emphasis>udev</emphasis></title>
			 <para>
				Cuando el núcleo le informa a <emphasis>udev</emphasis> de la aparición de un nuevo dispositivo, recolecta mucha información sobre el dispositivo consultando los elementos correspondientes en <filename>/sys/</filename>; especialmente aquellos que lo identifican unívocamente (dirección MAC para una tarjeta de red, número de serie para algunos dispositivos USB, etc.).
			</para>
			 <para>
				Con esta información, <emphasis>udev</emphasis> luego consulta todas las reglas en <filename>/etc/udev/rules.d</filename> y <filename>/lib/udev/rules.d</filename>. En este proceso decide cómo nombrar al dispositivo, los enlaces simbólicos que creará (para darle nombres alternativos) y los programas que ejecutará. Se consultan todos estos archivos y se evalúan las reglas secuencialmente (excepto cuando un archivo utiliza la directiva «GOTO»). Por lo tanto, puede haber varias reglas que correspondan a un evento dado.
			</para>
			 <para>
				La sintaxis de los archivos de reglas es bastante simple: cada fila contiene criterios de selección y asignaciones de variables. El primero se utiliza para seleccionar los eventos ante los que reaccionar y el último define las acciones a tomar. Se los separa simplemente con comas y el operador implícitamente diferencia entre un criterio de selección (con operaciones de comparación como <literal>==</literal> o <literal>!=</literal>) o una directiva de asignación (con operadores como <literal>=</literal>, <literal>+=</literal> o <literal>:=</literal>).
			</para>
			 <para>
				Se utilizan los operadores de comparación en las siguientes variables:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>KERNEL</literal>: el nombre que el núcleo le asigna al dispositivo;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ACTION</literal>: la acción que corresponde al evento («add» cuando se agregó un dispositivo, «remove» cuando fue eliminado);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>DEVPATH</literal>: la ruta al elemento del dispositivo en <filename>/sys/</filename>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SUBSYSTEM</literal>: el subsistema del núcleo que generó el pedido (hay muchos, pero unos pocos ejemplos son «usb», «ide», «net», «firmware», etc.);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ATTR{<replaceable>atributo</replaceable>}</literal>: el contenido del archivo <replaceable>attribute</replaceable> en el directorio <filename>/sys/<replaceable>ruta_de_dispositivo</replaceable>/</filename> del dispositivo. Aquí es donde encontrará la dirección MAC y otros identificadores específicos del canal;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> y <literal>ATTRS{<replaceable>atributos</replaceable>}</literal> son variaciones que intentarán coincidir las diferentes opciones en alguno de los dispositivos padre del dispositivo actual;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>PROGRAM</literal>: delega la prueba al programa indicado (coincidirá si devuelve 0, no lo hará de lo contrario). Se almacenará el contenido de la salida estándar del programa para que pueda utilizarse en la prueba <literal>RESULT</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>RESULT</literal>: ejecuta pruebas en la salida estándar almacenada durante la última ejecución de una sentencia <literal>PROGRAM</literal>.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Los operadores correctos puede utilizar expresiones con patrones para que coincidan varios valores simultáneamente. Por ejemplo, <literal>*</literal> coincide con cualquier cadena (inclusive una vacía); <literal>?</literal> coincide con cualquier carácter y <literal>[]</literal> coincide el conjunto de caracteres enumerados entre los corchetes (lo opuesto si el primer carácter es un signo de exclamación y puede indicar rangos de caracteres de forma similar a <literal>a-z</literal>).
			</para>
			 <para>
				En cuanto a los operadores de asignación, <literal>=</literal> asigna un valor (y reemplaza el valor actual); en el caso de una lista, es vaciada y sólo contendrá el valor asignado. <literal>:=</literal> realiza lo mismo pero evita cambios futuros en la misma variable. Respecto a <literal>+=</literal>, agrega elementos a una lista. Puede modificar las siguientes variables:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>NAME</literal>: el nombre del archivo de dispositivo que se creará en <filename>/dev/</filename>. Sólo se tiene en cuenta la primera asignación, las demás son ignoradas;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SYMLINK</literal>: la lista de enlaces simbólicos que apuntarán al mismo dispositivo;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>OWNER</literal>, <literal>GROUP</literal> y <literal>MODE</literal> definen el usuario y el grupo dueños del dispositivo así como también los permisos asociados, respectivamente;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>RUN</literal>: la lista de programas a ejecutar en respuesta a este evento.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Los valores asignados a estas variables pueden utilizar algunas substituciones:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>$kernel</literal> o <literal>%k</literal>: equivalente a <literal>KERNEL</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$number</literal> o <literal>%n</literal>: el número de orden del dispositivo; por ejemplo, para <literal>sda3</literal> sería «3»;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$devpath</literal> o <literal>%p</literal>: equivalente a <literal>DEVPATH</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$attr{<replaceable>atributo</replaceable>}</literal> o <literal>%s{<replaceable>atributo</replaceable>}</literal>: equivalentes a <literal>ATTRS{<replaceable>atributo</replaceable>}</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$major</literal> o <literal>%M</literal>: el número mayor del dispositivo en el núcleo;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$mior</literal> o <literal>%m</literal>: el número menor del dispositivo en el núcleo;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$result</literal> o <literal>%c</literal>: la cadena de salida del último programa ejecutado por <literal>PROGRAM</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						finalmente, <literal>%%</literal> y <literal>$$</literal> para los signos de porcentaje y el símbolo de moneda respectivamente.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				La lista anterior no está completa (sólo incluye los parámetros más importantes), pero la página de manual <citerefentry><refentrytitle>udev</refentrytitle>
				<manvolnum>7</manvolnum></citerefentry> debería serlo.
			</para>

		</section>
		 <section>
			<title>Un ejemplo concreto</title>
			 <para>
				Consideremos el caso de una simple llave USB e intentemos asignarle un nombre fijo. Primero debe encontrar los elementos que la identificarán de manera unívoca. Para ello, conéctela y ejecuta <command>udevadm info -a -n /dev/sdc</command> (reemplazando <replaceable>/dev/sdc</replaceable> con el nombre real asignado a la llave).
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>
<computeroutput>[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</computeroutput></screen>
			 <para>
				Para crear una nueva regla, puede utilizar las pruebas en las variables del dispositivo así como también en los dispositivos padre. El caso anterior le permite crear dos reglas como las siguientes:
			</para>
			 
<programlisting>KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"</programlisting>
			 <para>
				Una vez que haya guardado estas reglas en un archivo, llamado por ejemplo <filename>/etc/udev/rules.d</filename>, puede desconectar y conectar la llave USB. Podrá ver que <filename>/dev/usb_key/disk</filename> representa el disco asociado con la llave USB y <filename>/dev/usb_key/part1</filename> como su primera partición.
			</para>
			 <sidebar> <title><emphasis>YENDO MÁS ALLÁ</emphasis> Depuración de la configuración de <emphasis>udev</emphasis></title>
			 <para>
				Al igual que muchos demonios, <command>udevd</command> almacena registros en <filename>/var/log/daemon.log</filename>. Pero no es muy descriptivo de forma predeterminada y generalmente no son suficientes para entender lo que está sucediendo. Ejecutar <command>udevadm control --log-priority=info</command> aumenta el nivel de información y soluciona este problema. <command>udevadm control --log-priority=err</command> vuelve al valor predeterminado.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.power-management">
		<title>Gestión de energía: interfaz avanzada de configuración y energía (ACPI: «Advanced Configuration and Power Interface)</title>
		 <indexterm>
			<primary>energía, administración</primary>
		</indexterm>
		 <indexterm>
			<primary>administración de energía</primary>
		</indexterm>
		 <para>
			Usualmente, el tema de administración de energía es problemático. Suspender apropiadamente un equipo necesita que todos los controladores de los dispositivos en él sepan cómo configurarlos en reposo y reconfigurarlos apropiadamente al despertar la máquina. Desafortunadamente, aún existen algunos dispositivos que no pueden suspender correctamente en Linux debido a que sus fabricantes no proveen las especificaciones necesarias.
		</para>
		 <para>
			Linux es compatible con ACPI (interfaz avanzada de configuración y energía: «Advanced Configuration and Power Interface») — el estándar más reciente sobre gestión de energía. El paquete <emphasis role="pkg">acpid</emphasis> provee un demonio que busca eventos relacionados con la gestión de energía (cambios entre corriente alterna y batería en un portátil, etc.) y puede ejecutar varios programas en respuesta.
		</para>
		 <indexterm>
			<primary>ACPI</primary>
		</indexterm>
		 <indexterm>
			<primary>Advanced Configuration and Power Interface</primary>
		</indexterm>
		 <indexterm>
			<primary><command>acpid</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>CUIDADO</emphasis> Tarjetas gráficas y suspensión</title>
		 <para>
			El controlador de la tarjeta de video frecuentemente es el problema cuando la suspensión no funciona correctamente. En estos casos, es buena idea probar la última versión del servidor gráfico X.org.
		</para>
		 </sidebar> <para>
			Luego de esta revisión de los servicios básicos comunes a muchos sistemas Unix, nos enfocaremos en el entorno de las máquinas administradas: la red. Se necesitan muchos servicios para que la red funcione correctamente. Hablaremos de ellos en el próximo capítulo.
		</para>

	</section>
</chapter>

