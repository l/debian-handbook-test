<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course">
  <appendixinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-short-remedial-course.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>BIOS</keyword>
      <keyword>Núcleo</keyword>
      <keyword>Unix</keyword>
      <keyword>Proceso</keyword>
      <keyword>Jerarquía</keyword>
      <keyword>Órdenes básicas</keyword>
    </keywordset>
  </appendixinfo>
  <title>Curso breve de emergencia</title>
  <highlights>
    <para>Si bien este libro está apuntado principalmente a administradores y «usuarios avanzados», no deseamos excluir a novatos motivados. Por lo tanto, este apéndice será un curso acelerado que describe los conceptos fundamentales involucrados en el manejo de un equipo Unix.</para>
  </highlights>
  <section id="sect.shell-and-basic-commands">
    <title>Consola y órdenes básicas</title>

    <para>En el mundo Unix, todo administrador debe utilizar la línea de órdenes tarde o temprano; por ejemplo, cuando el sistema no inicia adecuadamente y sólo provee la consola de modo de rescate. Poder manejar tal interfaz es, por lo tanto, una habilidad de supervivencia básica para dichas circunstancias.</para>

    <sidebar>
      <title><emphasis>VISTA RÁPIDA</emphasis> Inicio del intérprete de órdenes</title>

      <para>Puede ejecutar un entorno de línea de órdenes desde el escritorio gráficos, con una aplicación conocida como «terminal»,  como las que encontrará en la vista «Actividades» de Gnome (es la que verá cuando mueva el ratón a la esquina superior izaquierda tecleando las primeras letras del nombre de la aplicación). En KDE lo encontrará en <menuchoice><guimenu>K</guimenu> <guisubmenu>Aplicaciones</guisubmenu> <guisubmenu>Sistema</guisubmenu></menuchoice>.</para>
    </sidebar>

    <para>Esta sección sólo provee una mirada rápida de las órdenes. Todas tienen muchas opciones que no describimos, así que le remitimos a la abundante documentación de las que dispone en sus respectivas páginas de manual.</para>
    <section>
      <title>Navegación del árbol de directorios y gestión de archivos</title>

      <para>Una vez que abrió una sesión, el programa <command>pwd</command> (que significa <emphasis>imprimir directorio de trabajo</emphasis>: «print working directory») mostrará la ubicación actual en el sistema de archivos. Puede cambiar el directorio actual ejecutando <command>cd <replaceable>directorio</replaceable></command> (<command>cd</command> significa <emphasis>cambiar directorio</emphasis>: «change directory»). El directorio padre siempre se llama <literal>..</literal> (dos puntos), mientras que también se conoce al directorio actual como <literal>.</literal> (un punto). El programa <command>ls</command> permite <emphasis>enumerar</emphasis> («listing») el contenido de un directorio. Si no le provee ningún parámetro, operará en el directorio actual.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>cd Desktop</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd .</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates
Documents  Music      Public    Videos</computeroutput>
      </screen>

      <para>Puede crear un directorio nuevo con <command>mkdir <replaceable>directorio</replaceable></command> y puede eliminar un directorio existente (y vacío) con <command>rmdir <replaceable>directorio</replaceable></command>. El programa <command>mv</command> permite <emphasis>mover</emphasis> («move») y/o cambiar el nombre de archivos y directorios; <emphasis>eliminará</emphasis> («remove») un archivo con <command>rm <replaceable>archivo</replaceable></command>.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public    test
$ </computeroutput><userinput>mv test new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  new       Public     Videos
Documents  Music      Pictures  Templates
$ </computeroutput><userinput>rmdir new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public</computeroutput>
      </screen>
    </section>
    <section>
      <title>Visualización y modificación de archivos de texto</title>

      <para>Si ejecuta <command>cat <replaceable>archivo</replaceable></command> (<emphasis>concatena</emphasis> — «concatenate» — archivos a su salida estándar del dispositivo) éste leerá el archivo y mostrará sus contenidos en la terminal. Si el archivo es demasiado grande para entrar en una pantalla, utilice un paginador como <command>less</command> (o <command>more</command>) para mostrarlo página por página.</para>

      <para>El programa <command>editor</command> inicia un editor de texto (como <command>vi</command> o <command>nano</command>) y permite crear, modificar y leer archivos de texto. A veces puede crear los archivos más simples directamente desde el intérprete utilizando redirección: <command>echo "<replaceable>texto</replaceable>" &gt;<replaceable>archivo</replaceable></command> creará un archivo llamado <replaceable>archivo</replaceable> con «<replaceable>texto</replaceable>» como su contenido. También es posible agregar una línea al final de este archivo si ejecuta algo como <command>echo "<replaceable>moretext</replaceable>" &gt;&gt; <replaceable>archivo</replaceable></command>. Note el <literal>&gt;&gt;</literal> en este ejemplo.</para>
    </section>
    <section>
      <title>Búsqueda de y en archivos</title>

      <para>Si ejecuta <command>find <replaceable>directorio</replaceable> <replaceable>criterio</replaceable></command>, buscará archivos en la jerarquía dentro de <replaceable>directorio</replaceable> según varios criterios. El criterio utilizado más frecuentemente es <literal>-name <replaceable>nombre</replaceable></literal>: permite buscar un archivo según su nombre.</para>

      <para>Si ejecuta <command>grep <replaceable>expresión</replaceable> <replaceable>archivos</replaceable></command> busca en el contenido de los archivos y extrae las líneas que coinciden con la expresión regular (revise el recuadro <xref linkend="sidebar.regexp" />). Agregar la opción <literal>-r</literal> activa una búsqueda recursiva en todos los archivos que contenga el directorio que pasó como parámetro. Esto permite buscar en un archivo del que sólo conoce parte de su contenido.</para>
    </section>
    <section>
      <title>Gestión de proceso</title>

      <para>Si ejecuta <command>ps aux</command>, obtendrá una enumeración de los procesos actualmente en ejecución y le ayudará a identificarlos mostrando su <emphasis>pid</emphasis> (id de proceso: «process id»). Una vez que sabe el <emphasis>pid</emphasis> de un proceso, puede ejecutar <command>kill -<replaceable>señal</replaceable> <replaceable>pid</replaceable></command> para enviarle una señal (siempre que sea el dueño del proceso). Existen varias señales, las más utilizadas son <literal>TERM</literal> (pedido de terminación de forma ordenada) y <literal>KILL</literal> (finalización forzada).</para>

      <para>El intérprete de órdenes también puede ejecutar programas en segundo plano si la orden finaliza con «&amp;». Cuando utiliza el símbolo «et», el usuario recupera el control de la consola inmediatamente aún cuando la orden continúa en ejecución (escondido del usuario como un proceso en segundo plano). El programa <command>jobs</command> («trabajos») enumerará los procesos ejecutándose en segundo plano; si ejecuta <command>fg %<replaceable>número-de-trabajo</replaceable></command> (por <emphasis>primer plano</emphasis>: «foreground») recuperará en primer plano una orden. Cuando un programa esté ejecutándose en primer plano (ya sea porque se lo inició de esa forma o porque se lo recuperó desde segundo plano con <command>fg</command>) puede pausar el proceso y obtener el control de la línea de órdenes con la combinación de teclas <keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>. Luego puede continuar el proceso en segundo plano con <command>bg %<replaceable>número-de-trabajo</replaceable></command> (por «segundo plano»: «<foreignphrase>background</foreignphrase>»).</para>
    </section>
    <section>
      <title>Información de sistema: memoria, espacio en disco, identidad</title>

      <para>El programa <command>free</command> («libre») muestra información sobre la memoria; <command>df</command> (<emphasis>libre en disco</emphasis>: «disk free») reporta el espacio en disco disponible para cada uno de los discos montados en el sistema de archivos. Ambos poseen la opción <literal>-h</literal> (<emphasis>legible por humanos</emphasis>: «human readable») convierte los tamaños en unidades más legibles (frecuentemente mebibytes o gibibytes). De forma similar, el programa <command>free</command> soporta las opciones <literal>-m</literal> y <literal>-g</literal> con las que mostrará, respectivamente, los datos en mebibytes o gibibytes.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       used       free     shared    buffers     cached
Mem:       1028420    1009624      18796          0      47404     391804
-/+ buffers/cache:     570416     458004
Swap:      2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda2              9614084   4737916   4387796  52% /
tmpfs                   514208         0    514208   0% /lib/init/rw
udev                     10240       100     10140   1% /dev
tmpfs                   514208    269136    245072  53% /dev/shm
/dev/sda5             44552904  36315896   7784380  83% /home
</computeroutput></screen>

      <para>El programa <command>id</command> muestra la identidad del usuario ejecutando la sesión junto con la lista de grupos a los que pertenece. Debido a que el acceso a algunos archivos o dispositivos puede estar limitados a miembros de ciertos grupos, puede ser útil verificar a qué grupos se pertenece.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
      </screen>
    </section>
  </section>
  <section id="sect.filesystem-hierarchy">
    <title>Organización de la jerarquía del sistema de archivos</title>
    <indexterm><primary>jerarquía del sistema de archivos</primary></indexterm>
    <section>
      <title>El directorio raíz</title>

      <para>Un sistema Debian está organizado según el <emphasis>estándar de jerarquía de archivos</emphasis> (FHS: «File System Hierarchy Standard»). Este estándar define el propósito de cada directorio. Por ejemplo, se describen los directorios de primer nivel como sigue:</para>
      <itemizedlist>
        <listitem>
	  <para><filename>/bin/</filename>: programas básicos;</para>
        </listitem>
        <listitem>
	  <para><filename>/boot/</filename>: núcleo Linux y otros archivos necesarios para las primeras etapas del proceso de arranque;</para>
        </listitem>
        <listitem>
	  <para><filename>/dev/</filename>: archivos de dispositivo;</para>
        </listitem>
        <listitem>
	  <para><filename>/etc/</filename>: archivos de configuración;</para>
        </listitem>
        <listitem>
	  <para><filename>/home/</filename>: archivos personales de los usuarios;</para>
        </listitem>
        <listitem>
	  <para><filename>/lib/</filename>: bibliotecas básicas;</para>
        </listitem>
        <listitem>
	  <para><filename>/media/*</filename>: puntos de montaje para dispositivos removibles (CD-ROM, llaves USB, etc.);</para>
        </listitem>
        <listitem>
	  <para><filename>/mnt/</filename>: punto de montaje temporal;</para>
        </listitem>
        <listitem>
	  <para><filename>/opt/</filename>: aplicaciones adicionales provistas por terceros;</para>
        </listitem>
        <listitem>
	  <para><filename>/root/</filename>: archivos personales del administrador (root);</para>
        </listitem>
        <listitem>
          <para><filename>/run/</filename>: datos volátiles en tiempo de ejecución que no persisten entre reinicios (todavía no incluído en el FHS);</para>
        </listitem>
        <listitem>
	  <para><filename>/sbin/</filename>: programas de sistema;</para>
        </listitem>
        <listitem>
	  <para><filename>/srv/</filename>: datos utilizados por los servidores en este sistema;</para>
        </listitem>
        <listitem>
	  <para><filename>/tmp/</filename>; archivos temporales; generalmente se vacía este directorio durante el arranque;</para>
        </listitem>
        <listitem>
	  <para><filename>/usr/</filename>: aplicaciones; este directorio está subdividido en <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (según la misma lógica que el directorio raíz). Lo que es más, <filename>/usr/share/</filename> contiene datos independientes de la arquitectura. El objetivo de <filename>/usr/local/</filename> es para que el administrador instale aplicaciones manualmente sin sobreescribir archivos administrados por el sistema de paquetes (<command>dpkg</command>).</para>
        </listitem>
        <listitem>
	  <para><filename>/var/</filename>: datos variables administrados por demonios. Esto incluye archivos de registro, colas, cachés, etc.</para>
        </listitem>
        <listitem>
	  <para><filename>/proc/</filename> y <filename>/sys/</filename> son específicos del núcleo Linux (y no son parte del FHS). El núcleo los utiliza para exportar datos a espacio de usuario.  (vea <xref linkend="sect.userspace-presentation" /> y <xref linkend="sect.user-space" /> para explicaciones acerca de este concepto).</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>El directorio personal de los usuarios</title>

      <para>El contenido del directorio personal de un usuario no está estandarizado, pero sí existen algunas convenciones notables. Una de ellas es que usualmente se refiere al directorio personal de un usuario con una virgulilla («~»). Es útil saberlo ya que los intérpretes de órdenes reemplazan una virgulilla automáticamente con el directorio correcto (generalmente <filename>/home/<replaceable>usuario</replaceable>/</filename>).</para>

      <para>Tradicionalmente, las aplicaciones almacenan sus archivos de configuración en el directorio personal del usuario, pero sus nombres generalmente comienzan con un punto (por ejemplo, el cliente de correo <command>mutt</command> almacena su configuración el <filename>~/.muttrc</filename>). Tenga en cuenta que los nombres de archivos que comienzan con un punto están escondidos de forma predeterminada; sólo serán enumerados por <command>ls</command> cuando utilice la opción <literal>-a</literal> y por los gestores gráficos de archivos cuando les indique que muestren archivos ocultos.</para>

      <para>Algunos programas también utilizan múltiples archivos de configuración organizados en un directorio (por ejemplo: <filename>~/.ssh/</filename>). Algunas aplicaciones (como el navegador web Iceweasel) también utlizarán su directorio para almacenar un caché de datos descargados. Esto significa que estos directorios pueden llegar a utilizar mucho espacio en disco.</para>

      <para>Estos archivos de configuración almacenados directamente en el directorio personal de los usuarios, a los que se refieren colectivamente como «<emphasis>dotfiles</emphasis>» («archivos punto»), son tan populares al punto que estos directorios pueden estar atiborrados de ellos. Afortunadamente, se desarrolló la «Especificación de directorio base XDG» («XDG Base Directory Specification») gracias a un esfuerzo colectivo bajo la tutela de FreeDesktop.org, una convención que intenta limpiar estos archivos y directorios. Esta especificación indica que se debe almacenar los archivos de configuración bajo <filename>~/.config</filename>, archivos de caché bajo <filename>~/.cache</filename> y archivos de dato de aplicaciones bajo <filename>~/.local</filename> (o subdirectorios de los mismos). Esta convención está ganando popularidad lentamente y varias aplicaciones (especialmente las gráficas) ya comenzaron a seguirla.</para>

      <para>Los escritorios gráficos generalmente muestran en el escritorio (es decir, lo que se ve cuando se cierran o minimizan todas las aplicaciones) el contenido del directorio <filename>~/Desktop/</filename> (o el término apropiado si el sistema está configurado en otro idioma distinto al inglés).</para>

      <para>Finalmente, el sistema de correo a veces almacena sus correos entrantes en un directorio <filename>~/Mail/</filename>.</para>
    </section>
  </section>
  <section id="sect.computer-layers">
    <title>Funcionamiento interno de un equipo: las diferentes capas involucradas</title>

    <para>Generalmente se considera a un equipo como algo bastante abstracto, y la interfaz visible al exterior es mucho más simple que su complejidad interna. Esta complejidad proviene, en parte, de la cantidad de partes involucradas. Sin embargo, podemos visualizar estas piezas en capas, donde cada capa sólo interactúa con aquellas inmediatamente sobre y bajo ella.</para>

    <para>Un usuario final puede vivir sin saber estos detalles… siempre que todo funcione. Cuando nos enfrentamos con un problema como «¡Internet no anda!», lo primero que debemos hacer es identificar en qué capa se origina el problema. ¿Está funcionando la tarjeta de red (hardware)? ¿Es reconocida por el equipo? ¿El núcleo Linux la ve? ¿Los parámetros de red configurados son correctos? Todas estas preguntas aíslan una capa apropiada y se enfocan en una fuente potencial del problema.</para>
    <section id="sect.hardware">
      <title>La capa más profunda: el hardware</title>
      <indexterm><primary>IDE</primary></indexterm>
      <indexterm><primary>SCSI</primary></indexterm>
      <indexterm><primary>Serial ATA</primary></indexterm>
      <indexterm><primary>Parallel ATA</primary></indexterm>
      <indexterm><primary>ATA</primary></indexterm>
      <indexterm><primary>IEEE 1394</primary></indexterm>
      <indexterm><primary>Firewire</primary></indexterm>
      <indexterm><primary>USB</primary></indexterm>

      <para>Comencemos recordando básicamente que una máquina es, primero y principal, un conjunto de elementos de hardware. Generalmente tendrá una placa principal (conocida como <emphasis>placa base</emphasis>: «motherboard») con uno (o más) procesadores, algo de RAM, controladores de dispositivos y puertos de extensión para placas opcionales (para otros controladores de dispositivos). Los más notables entre estos controladores son IDE (ATA paralelo), SCSI y ATA Serial para conectar dispositivos de almacenamiento como discos duros. Entre otros controladores encontraremos a USB, que es capaz de albergar una gran variedad de dispositivos (desde cámaras web a termómetros, desde teclados a sistemas de automatización hogareña) y IEEE 1394 (Firewire). Estos controladores frecuentemente permiten conectar varios dispositivos por lo que se conoce al subsistema completo gestionado por un controlador como «canal» («bus»). Las placas opcionales incluyen tarjetas gráficas (en las que conectará pantallas y monitores), tarjetas de sonido, tarjetas de interfaz de red, etc. Algunas placas principales son prefabricadas con estas funcionalidades y no necesitan placas opcionales.</para>

      <sidebar>
        <title><emphasis>EN LA PRÁCTICA</emphasis> Revisión del funcionamiento del hardware</title>

	<para>Puede ser complicado revisar que una porción de hardware funciona. Por el otro lado, probar que no funciona a veces es muy simple.</para>

	<para>Un disco duro está hecho de platos giratorios y cabezas magnéticas móviles. Cuando se enciende un disco duro, el motor de las placas genera un zumbido característico. También disipa energía en forma de calor. Por lo tanto, un disco duro que se mantiene frío y silencioso al encender está roto.</para>

	<para>Las tarjetas de red frecuentemente incluyen LEDs que muestran el estado del enlace. Si tiene un cable conectado que lleva a un switch o hub de red funcional, al menos un LED estará encendido. Si ningún LED enciende, la tarjeta en sí, el dispositivo de red o el cable entre ellos tiene una falla. El siguiente paso, obviamente, es probar cada componente de forma individual.</para>

	<para>Algunas placas opcionales — especialmente las tarjetas de video 3D — incluyen dispositivos de enfriamiento como disipadores de calor y/o ventiladores. Si el ventilador no gira aún cuando se enciende la tarjeta, una explicación posible es el sobrecalentamiento de la tarjeta. Esto también es aplicable a el o los procesadores principales ubicados en la placa principal.</para>
      </sidebar>
    </section>
    <section id="sect.bios">
      <title>El iniciador: el BIOS o UEFI</title>
      <indexterm><primary>BIOS</primary></indexterm>
      <indexterm><primary>UEFI</primary></indexterm>
      <indexterm><primary>Registro principal de arranque, Master Boot Record (MBR)</primary></indexterm>

      <para>El hardware, por sí mismo, no es capaz de realizar tareas útiles sin un software asociado que lo maneje. El propósito de los sistemas operativos y las aplicaciones es controlar e interactuar con el hardware. Éstos, sin embargo, necesitan hardware funcional para ejecutar.</para>

      <para>Esta simbiosis entre el hardware y el software no ocurre por sí sola. Cuando recién se enciende el equipo es necesario cierta configuración inicial. Este rol es asumido por la BIOS o UEFI, una parte de software embebido en la placa base que se ejecuta automáticamente cuando se enciende. Su tarea principal es buscar el software y cederle el control. Normalmente en el caso de la BIOS,  esto involucra buscar el primer disco duro con un sector de arranque (también conocido como <emphasis>registro maestro de arranque</emphasis> o <acronym>MBR</acronym>: «Master Boot Record»), cargar dicho sector y ejecutarlo. De allí en adelante, usualmente no se utiliza la BIOS (hasta el próximo arranque). En el caso de UEFI, el proceso conlleva buscar en los discos para encontrar la partición dedicada a EFI que contiene las aplicaciones que EFI ejecutará más adelante.</para>

      <sidebar>
        <title><emphasis>HERRAMIENTA</emphasis> «Setup», la herramienta de configuración del BIOS/UEFI</title>
        <indexterm><primary><emphasis>Configuración</emphasis></primary></indexterm>

	<para>El BIOS/UEFI también contiene un software llamado «Setup», diseñado para permitir configurar aspectos del equipo. En particular, permite elegir el dispositivo de arranque preferido (por ejemplo, un disco flexible o dispositivo CD-ROM), configurar el reloj del sistema, etc. Iniciar «Setup» usualmente involucra presionar una tecla tan pronto como enciende el equipo. Generalmente esta tecla es <keycap>Del</keycap> o <keycap>Esc</keycap>, pero a veces también puede ser <keycap>F2</keycap> o <keycap>F10</keycap>. La mayoría de las veces, la tecla correcta aparece brevemente en la pantalla durante el arranque.</para>
      </sidebar>

      <para>El sector de arranque (o la partición EFI), por su parte, contiene otro software pequeño llamado el gestor de arranque, cuyo propósito es encontrar y ejecutar un sistema operativo. Debido a que dicho gestor de arranque no está embebido en la placa principal sino que se lo carga desde el disco, puede ser más inteligente que el BIOS, lo que explica porqué el BIOS no carga el sistema operativo por su cuenta. Por ejemplo, el gestor de arranque (frecuentemente GRUB en los sistemas Linux) puede enumerar los sistemas operativos disponibles y pedirle al usuario que elija uno. Usualmente, provee un tiempo de espera y una opción predeterminada. A veces el usuario también puede decidir agregar parámetros que pasarle al núcleo, etc. Eventualmente, se encuentra el núcleo, se lo carga en memoria y se lo ejecuta.</para>

      <sidebar>
        <title><emphasis>NOTE</emphasis> UEFI, un reemplazo moderno a la BIOS</title>
        <indexterm><primary>UEFI</primary></indexterm>
        <indexterm><primary>Arranque seguro</primary></indexterm>

        <para>UEFI es un desarrollo relativamente reciente. La mayoría de los ordenadores nuevos soportarán UEFI, pero normalmente soportan tambien arranque por BIOS para asegurar compatibilidad hacia atrás con los sistemas operativos que todavía no están listos para sacar partido a UEFI.</para>
        <para>Este nuevo sistema se deshace de algunas de las limitaciones del arranque BIOS: con la parte útil de la partición dedicada, los gestores de arranque ya no necesitan trucos especiales para adaptarse en un pequeño <emphasis> master boot record</emphasis> y hallar el kernel para arrancar. Aún mejor, con una adecuada construcción de kernel de Linux, UEFI puede arrancar directamente el kernel sin ningún gestor de arranque como intermediario. UEFI también es la base principal usada para usar <emphasis>Secure Boot</emphasis>, una tecnología que te asegura ejecutar solo software validado por el vendedor de tu sistema operativo.</para>
      </sidebar>

      <para>El BIOS/UEFI también está a cargo de detectar e inicializar algunos dispositivos. Obviamente, esto incluye los dispositivos IDE/SATA (generalmente discos duros y dispositivos CD-ROM), pero también dispositivos PCI. Normalmente, se enumeran en pantalla los dispositivos detectados durante el proceso de arranque. Si la lista pasa demasiado rápido, utilice la tecla <keycap>Pause</keycap> para congelarla el tiempo suficiente para leerla. Si faltan dispositivos PCI instalados, es un mal augurio. En el peor de los casos el dispositivo tiene una falla. En el mejor de los casos, simplemente es incompatible con la versión del BIOS o la placa principal. Las especificaciones PCI evolucionan y no se garantiza que las placas principales antiguas sean compatibles con dispositivos PCI más nuevos.</para>
    </section>
    <section id="sect.kernel">
      <title>El núcleo</title>

      <para>Tanto el BIOS/UEFI como el gestor de arranque sólo ejecutan por unos segundos cada uno; ahora llegamos al primer software que ejecuta por más tiempo: el núcleo del sistema operativo. Este núcleo asume el rol del director en una orquesta y asegura la coordinación entre el hardware y el software. Este papel involucra varias tareas que incluyen: administrar el hardware, gestionar procesos, usuarios y permisos, el sistema de archivos, etc. El núcleo provee una base común a todos los otros programas en el sistema.</para>
    </section>
    <section id="sect.userspace-presentation">
      <title>El espacio de usuario</title>

      <para>Si bien todo lo que ocurre fuera del núcleo puede agruparse bajo el nombre «espacio de usuario», todavía podemos separarlo en capas de software. Sin embargo, sus interacciones son más complejas que antes y la clasificación puede no ser tan simple. Una aplicación normalmente utiliza bibliotecas, que a su vez involucran al núcleo, pero la comunicación también puede involucrar otros programas o inclusive bibliotecas que interactúan entre sí.</para>
    </section>
  </section>
  <section id="sect.kernel-role-and-tasks">
    <title>Algunas tareas administradas por el núcleo</title>
    <section id="sect.hardware-drivers">
      <title>Administración del hardware</title>

      <para>El núcleo tiene, antes que nada, la tarea de controlar las partes del hardware, detectarlas, encenderlas cuando se enciende el equipo, etc. También los pone a disposición del software de más alto nivel con una interfaz de programación simplificada para que las aplicaciones puedan aprovechar dispositivos sin tener que preocuparse por detalles como cuál puerto de extensión es aquél en el que está conectada una tarjeta. La interfaz de programación también provee una capa de abstracción; permite, por ejemplo, que el software de videoconferencias utilice una cámara web independientemente de su modelo y fabricante. El software puede utilizar simplemente la interfaz <emphasis>video para Linux</emphasis> (V4L: «Video for Linux») y el núcleo traduce las llamadas a las funciones de esta interfaz a las órdenes de hardware reales que necesita la cámara específica que está utilizando.</para>

     
      <para><indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> El núcleo exporta muchos detalles sobre el hardware detectado a través de los sistemas de archivos virtuales <filename>/proc/</filename> y <filename>/sys/</filename>. Muchas herramientas resumen estos detalles. Entre ellas, <command>lspci</command> (en el paquete <emphasis role="pkg">pciutils</emphasis>) enumera los dispositivos PCI, <command>lsusb</command> (en el paquete <emphasis role="pkg">usbutils</emphasis>) enumera los dispositivos USB y <command>lspcmcia</command> (en el paquete <emphasis role="pkg">pcmciautils</emphasis>) enumera las tarjetas PCMCIA. Estas herramientas son muy útiles para identificar el modelo exacto de un dispositivo. Esta identificación permite realizar búsquedas más precisas en la web lo que, a su vez, lleva a documentos más relevantes.</para>

      <example>
        <title>Ejemplo de información provista por <command>lspci</command> y <command>lsusb</command></title>

        <screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>
      </example>

      <para>Estos programas tienen una opción <literal>-v</literal>, que mostrará información mucho más detallada (pero generalmente innecesaria). Finalmente, el programa <command>lsdev</command> (en el paquete <emphasis role="pkg">procinfo</emphasis>) enumera los recuros de comunicación utilizados por los dispositivos.</para>

      <para>Las aplicaciones frecuentemente acceden a los dispositivos a través de archivos especiales creados en <filename>/dev/</filename> (revise el recuadro <xref linkend="sidebar.special-files" />). Éstos son archivos especiales que representan discos (por ejemplo: <filename>/dev/hda</filename> y <filename>/dev/sdc</filename>), particiones (<filename>/dev/hda1</filename> o <filename>/dev/sdc3</filename>, ratones (<filename>/dev/input/mouse0</filename>), teclados (<filename>/dev/input/event0</filename>), tarjetas de sonido (<filename>/dev/snd/*</filename>), puertos seriales (<filename>/dev/ttyS*</filename>), etc.</para>
    </section>
    <section id="sect.filesystems">
      <title>Sistemas de archivos</title>
      <indexterm><primary>sistema de archivos</primary></indexterm>
      <indexterm><primary>archivos, sistema de</primary></indexterm>

      <para>Los sistemas de archivos son uno de los aspectos más destacados del núcleo. Los sistemas Unix agrupan todos los archivos que almacenan en una jerarquía única, lo que permite a los usuarios (y las aplicaciones) acceder a los datos simplemente conociendo su ubicación dentro de dicha jerarquía.</para>

      <para>El nombre del punto de partida de este árbol jerárquico es la raíz, <filename>/</filename>. Este directorio puede tener subdirectorios con nombres. Por ejemplo, el nombre del subdirectorio <literal>home</literal> de <filename>/</filename> es <filename>/home/</filename>. Este subdirectorio, a su vez, puede contener otros subdirectorios y así sucesivamente. Cada directorio también puede contener archivos, donde se almacenarán los datos en sí. Por lo tanto, el nombre <filename>/home/rmas/Desktop/hello.txt</filename> se refiere al archivo <literal>hello.txt</literal> almacenado en el subdirectorio <literal>Desktop</literal> del subdirectorio <literal>rmas</literal> del directorio <literal>home</literal> presente en la raíz. El núcleo traduce este sistema de nombres en el almacenamiento físico real en un disco.</para>

      <para>A diferencia de otros sistemas, existe sólo una jerarquía de este tipo que puede integrar datos de varios discos. Se utiliza uno de estos discos como raíz y los demás son «montados» en directorios de la jerarquía (el programa Unix se llama <command>mount</command>); luego estos otros discos estarán disponibles bajo estos «puntos de montaje». Esto permite almacenar los directorios personales de los usuarios (tradicionalmente almacenados en <filename>/home/</filename>) en un disco secundario que contendrá directorios <literal>rhertzog</literal> y <literal>rmas</literal>. Una vez que se montó el disco en <filename>/home/</filename>, estos directorios estarán disponibles en su ubicación usual y continuarán funcionando las rutas como <filename>/home/rmas/Desktop/hello.txt</filename>.</para>
      <indexterm><primary><command>mkfs</command></primary></indexterm>

      <para>Hay muchos sistemas de archivos que corresponden con muchas formas de almacenar físicamente los datos en discos. Los más conocidos son <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> y <emphasis>ext4</emphasis>, pero existen otros. Por ejemplo, <emphasis>vfat</emphasis> es el sistema de archivos utilizado históricamente por los sistemas operativos DOS y Windows, lo que permite utilizar discos duros tanto en Debian como en Windows. En cualquier caso, un sistema de archivos debe ser preparado en un disco antes que pueda ser montado, se conoce esta operación como «dar formato». Los programas como <command>mkfs.ext3</command> (donde <command>mkfs</command> significa <emphasis>crear sistema de archivos</emphasis>: «MaKe FileSystem») se encargan de esta operación. Estos programas necesitan, como parámetro, un archivo de dispositivo que representa la partición a la que dar formato (por ejemplo: <filename>/dev/sda1</filename>). Esta operación es destructiva y sólo debe ejecutarla una vez, excepto cuando uno desee eliminar deliberadamente un sistema de archivos y comenzar nuevamente desde cero.</para>

      <para>Existen tambien sistemas de archivos de red, como <acronym>NFS</acronym>, en el que los datos no son almacenados en un disco local. En su lugar, se transmiten los datos a través de la red a un servidor que los almacena y obtiene a pedido. La abstracción del sistema de archivos evita que al usuario le importe: los archivos continúan disponibles en la forma jerárquica usual.</para>
    </section>
    <section id="sect.shared-functions">
      <title>Funciones compartidas</title>

      <para>Debido a que una cantidad de funciones son utilizadas por todo software, tiene sentido centralizarlas en el núcleo. Por ejemplo, la gestión compartida de sistemas de archivos permite que cualquier aplicación simplemente abra un archivo, sin preocuparse dónde está almacenado físicamente dicho archivo. Éste puede estar almacenado en diferentes porciones de un disco duro, dividido entre varios discos duros o inclusive almacenado en un servidor remoto. Las funciones de comunicación compartidas son utilizadas por las aplicaciones para intercambiar datos independientemente de la forma en la que se transportan los mismos. Por ejemplo, el transporte puede ser a través de una combinación de redes locales o inalámbricas o a través de una línea telefónica terrestre.</para>
    </section>
    <section id="sect.process-management">
      <title>Gestión de proceso</title>
      <indexterm><primary><emphasis>pid</emphasis></primary></indexterm>

      <para>Un proceso es una instancia en ejecución de un programa. Esto necesita memoria para almacenar tanto el programa en sí como los datos con los que trabaja. El núcleo es el encargado de crearlos y seguirlos. Cuando se ejecuta un programa, primero el núcleo reserva memoria, carga en ella el código ejecutable desde el sistema de archivos y luego inicia la ejecución de este código. Mantiene información sobre este proceso, de las que la más visible es un número de identificación conocido como <emphasis>pid</emphasis> (<emphasis>identificador de proceso</emphasis>: «process identifier»).</para>

      <para>Los núcleos similares a Unix (incluyendo a Linux), al igual que muchos otros sistemas operativos modernos, poseen la capacidad de ser «multitarea». En otras palabras, permite ejecutar muchos procesos «al mismo tiempo». En realidad sólo hay un proceso ejecutando en un momento dado, pero el núcleo divide el tiempo en pequeñas porciones y ejecuta en orden a cada proceso. Debido a que estas divisiones de tiempo son muy pequeñas (en el rango de los milisegundos), crean la ilusión de procesos ejecutando en paralelo, aún cuando sólo están activos durante algunos intervalos y en espera el resto del tiempo. La tarea del kernel es ajustar con mecanismos planeados para mantener esa ilusión, mientras se maximiza el rendimiento global del sistema. Si las divisiones de tiempo son muy extensas, la aplicación puede que no responda como se desea. Si son muy pequeñas, el sistema perderá tiempo cambiando tareas demasiado frecuentemente. Se pueden personalizar estas decisiones con las prioridades de procesos. Los procesos con prioridad alta ejecutarán por más tiempo y en intervalos más frecuentes que los procesos con prioridad baja.</para>

      <sidebar>
        <title><emphasis>NOTA</emphasis> Sistemas multiprocesador (y variaciones)</title>

	<para>La limitación aquí descripta sólo es un caso extremo. La restricción actual es que, en cada momento, sólo puede existir un proceso en ejecución <emphasis>por núcleo de procesador</emphasis>. Los sistemas multiprocesador, multinúcleo o con «hyper-threading» («multihilos») permite ejecutar varios procesos en paralelo. Sin embargo, se utiliza el mismo sistema de división de tiempo para administrar casos en los que existan más procesos activos que núcleos de procesador disponibles. Este caso no es extraño: un sistema básico, aún aquellos mayormente desocupados, casi siempre posee decenas de procesos en ejecución.</para>
      </sidebar>

      <para>Por supuesto, el núcleo permite ejecutar varias instancias independientes del mismo programa. Pero cada una de ellas sólo puede acceder sus propias divisiones de tiempo y su propia memoria. Sus datos, por lo tanto, se mantienen independientes.</para>
    </section>
    <section id="sect.permissions">
      <title>Gestión de permisos</title>

      <para>Los sistemas similares a Unix también son multiusuario. Proveen un sistema que permite usuarios  separados y grupos; también permite la capacidad de decidir permitir o bloquear acciones según sus permisos. El núcleo gestiona, para cada proceso, permitiéndole controlar los permisos. La mayor parte del tiempo, cada proceso es identificado por el usuario que lo inició. Ese proceso sólo puede realizar las acciones que pueda realizar su dueño. Por ejemplo, intentar abrir un archivo requiere que el núcleo verifique la identidad del proceso según los permisos de acceso (para más detalles sobre este ejemplo particular, revise la <xref linkend="sect.rights-management" />).</para>
    </section>
  </section>
  <section id="sect.user-space">
    <title>El espacio de usuario</title>
    <indexterm><primary>espacio de usuario</primary></indexterm>
    <indexterm><primary>espacio de núcleo</primary></indexterm>

    <para>El «espacio de usuario» se refiere al entorno de ejecución de procesos normales (en contraste con el núcleo). Esto no significa necesariamente que usuarios iniciaron realmente estos procesos debido a que un sistema estándar frecuentemente posee procesos «demonio» (o en segundo plano), procesos que se ejecutan antes que el usuario inicie una sesión. Los procesos demonio son procesos considerados en espacio de usuario.</para>
    <section id="sect.process-basics">
      <title>Proceso</title>
      <indexterm><primary><command>init</command></primary></indexterm>

      <para>Cuando el núcleo supera su fase de inicialización, ejecuta el primer proceso: <command>init</command>. El proceso #1 rara vez es útil por sí mismo, y los sistemas similares a Unix ejecutan con un ciclo de vida con muchos procesos adicionales.</para>
      <indexterm><primary><emphasis>bifurcación</emphasis></primary></indexterm>

      <para>Primero que nada, un proceso puede clonarse a sí mismo (esto es conocido como <emphasis>bifurcación</emphasis> — «fork»). El núcleo reserva un nuevo (pero idéntico) proceso de espacio en memoria, y otros procesos para usarlo. En este momento, la única diferencia entre estos dos procesos es su <emphasis>pid</emphasis>. Al nuevo proceso se le suele llamar proceso hijo al nuevo proceso y proceso padre al proceso cuyo <emphasis>pid</emphasis> no cambió.</para>

      <para>A veces, el proceso hijo continúa su vida de forma independiente a su padre, con sus propios datos copiados del proceso padre. En muchos casos, sin embargo, el proceso hijo ejecuta otro programa. Con unas pocas excepciones, simplemente se reemplaza su memoria con aquella del nuevo programa y comienza la ejecución del mismo.Este es un mecanismo usado para el proceso de inicio (con el número 1 de proceso) para iniciar servicios adicionales y ejecutar toda la secuencia de arranque. En algún punto, uno de los proceso de la descendencia de <command>init</command> inicia una interfaz gráfica en la que los usuarios pueden iniciar sesión (describimos con más detalle la secuencia real de eventos en la <xref linkend="sect.system-boot" />).</para>

      <para>Cuando un proceso finaliza la tarea para la que fue iniciado, termina. El núcleo recupera la memoria asignada a este proceso y no le asignará más divisiones de tiempo de ejecución. Se le informa al proceso padre sobre la finalización de su proceso hijo, lo que permite a un proceso esperar que se complete una tarea que delegó a un proceso hijo. Este comportamiento es obvio a simple vista en los intérpretes de línea de órdenes (conocidos como <emphasis>consolas</emphasis> — «shells»). Cuando se ingresa una orden en una consola, sólo vuelve el prompt cuando finaliza la ejecución de dicha orden. La mayoría de las consolas permiten ejecutar programas en segundo plano, sólo es cuestión de agregar un <userinput>&amp;</userinput> al final de la orden. Se mostrará el prompt inmediatamente, lo que puede llevar a problemas si la orden necesita mostrar datos por su cuenta.</para>
    </section>
    <section id="sect.daemons">
      <title>Demonios</title>
      <indexterm><primary>demonio</primary></indexterm>
      <indexterm><primary>demonio</primary></indexterm>

      <para>Un «demonio» es un proceso iniciado automáticamente por la secuencia de inicio. Continúa ejecutando (en segundo plano) para realizar tareas de mantenimiento o proveer servicios a otros procesos. Esta «tarea en segundo plano» es realmente arbitraria y no tiene un rol especial desde el punto de vista del sistema. Simplemente son procesos, muy similares a otros proceso, que se ejecutarán cuando le corresponda a su división de tiempo. Esta distinción es sólo para los humanos: se dice de un proceso que ejecuta sin interacción de un usuario (en particular, sin una interfaz gráfica) que ejecuta «en segundo plano» o «como un demonio».</para>

      <sidebar>
        <title><emphasis>VOCABULARIO</emphasis> Demonio, ¿un término despectivo?</title>

	<para>En inglés, se utiliza el término «<emphasis>daemon</emphasis>» (en lugar de «<emphasis>demon</emphasis>») para hacer referencia a los demonios. Ambos comparten su etimología griega pero el primero no implica un mal diabólico; en cambio, debería entenderse como una especie de espíritu de ayuda. La distinción es suficientemente sutil en inglés; es aún peor en otros idiomas (como el español) en el que se utiliza la misma palabra para ambos significados.</para>
      </sidebar>

      <para>Describimos en detalle muchos demonios en el <xref linkend="unix-services" />.</para>
    </section>
    <section id="sect.ipc">
      <title>Comunicación entre procesos</title>
      <indexterm><primary>IPC</primary></indexterm>
      <indexterm><primary>comunicación entre procesos</primary></indexterm>

      <para>Un proceso aislado, sea un demonio o una aplicación interactiva, rara vez es útil por sí misma, razón por la que existen varios métodos que permiten la comunicación entre dos procesos separados, ya sea para intercambiar datos o para que se controlen entre sí. El término genérico para referirse a esto es <emphasis>comunicación entre procesos</emphasis> (abreviado IPC: «Inter-Process Communication»).</para>

      <para>El sistema IPC más simple es utilizar archivos. El proceso que desea enviar datos, los escribe en un archivo (cuyo nombre ya conozca), mientras que el receptor sólo debe abrir este archivo y leer su contenido.</para>
      <indexterm><primary><emphasis>tubería</emphasis></primary></indexterm>

      <para>En el caso en que no deseemos almacenar datos en el disco, podemos utiliza una <emphasis>tubería</emphasis> («pipe»), que simplemente es un objeto con dos extremos; los bytes escritos en uno de ellos son legibles en el otro. Si dos procesos separados controlan los extremos, esto se convierte en un canal de comunicación entre procesos simple y conveniente. Podemos clasificar las tuberías en dos: tuberías con nombre y tuberías anónimas. Se representa a una tubería con nombre como un elemento en el sistema de archivos (aunque los datos transmitidos no se almacenen en él), para que ambos procesos puedan abrirlo independientemente si ya conocen la ubicación de la misma. En los casos en los que los procesos que se comunican están relacionados (por ejemplo, un proceso padre y su hijo), el proceso padre también puede crear una tubería anónima antes de bifurcarse que será heredada por el hijo. Ambos procesos podrán intercambiar datos a través de la tubería sin necesitar el sistema de archivos.</para>

      <sidebar>
        <title><emphasis>EN LA PRÁCTICA</emphasis> Un ejemplo concreto</title>

	<para>Describiremos con algo de detalle lo que ocurre cuando se ejecuta en una consola una orden compleja (una <emphasis>cañería</emphasis>: «pipeline»). Asumiremos que tenemos un proceso <command>bash</command> (la consola de usuario estándar en Debian), con <emphasis>pid</emphasis> 4374; en esta consola ingresaremos la siguiente orden: <command>ls | sort</command>.</para>

	<para>La consola primero interpreta la orden que ingresamos. En nuestro caso, entiende que hay dos programas (<command>ls</command> y <command>sort</command>), con un flujo de datos de uno al otro (denotado por el carácter <userinput>|</userinput>, conocido como <emphasis>tubería</emphasis> — «pipe»). <command>bash</command> primero crea una tubería sin nombre (que existe sólo dentro del proceso <command>bash</command> en sí).</para>

	<para>Luego la consola se clona a sí misma; esto lleva a un nuevo proceso <command>bash</command>, con <emphasis>pid</emphasis> #4521 (los <emphasis>pid</emphasis> son números abstractos y generalmente no tienen un significado particular). El proceso #4521 hereda la tubería, lo que significa que puede escribir en su extremo de «entrada»; <command>bash</command> redirige su flujo de salida estándar a la entrada de esta tubería. Luego ejecuta (y se reemplaza a sí mismo) con el programa <command>ls</command>, que enumera el contenido del directorio actual. Debido a que <command>ls</command> escribe en su salida estándar, y anteriormente se redirigió esta salida, efectivamente se envía su resultado a la tubería.</para>

	<para>Ocurre una operación similar para el segundo programa: <command>bash</command> se clona a sí mismo nuevamente, lo que lleva a un nuevo proceso <command>bash</command> con pid #4522. Debido a que también es un proceso hijo de #4374, también hereda la tubería; luego <command>bash</command> conecta su entrada estándar a la salida de la tubería y luego ejecuta (y se reemplaza a sí mismo) con el programa <command>sort</command>, que ordena su entrada y muestra el resultado.</para>

	<para>Ahora están definidas todas las piezas del rompecabezas: <command>ls</command> lee el directorio actual y escribe la lista de archivos en la tubería; <command>sort</command> lee esta lista, la ordena alfabéticamente y muestra los resultados. Luego finalizan los procesos #4521 y #4522, y el proceso #4374 (que estaba esperando durante esta operación), recupera el control y muestra el prompt que permite al usuario ingresar una nueva orden.</para>
      </sidebar>

      <para>Sin embargo, no toda la comunicación entre procesos es para mover datos. En muchas situaciones, la única información que se necesita transmitir son mensajes de control como «suspender la ejecución» o «continuar la ejecución». Unix (y Linux) provee un mecanismo llamado <emphasis>señales</emphasis>, a través de las que un proceso puede simplemente enviar una señal específica (elegida de una lista predefinida de señales) a otro proceso. El único requisito es saber el <emphasis>pid</emphasis> del objetivo.</para>

      <para>Para comunicaciones más complejas también existen mecanismos que le permiten a un proceso acceder, o compartir, parte de la memoria reservada para otros procesos. La memoria ahora compartida entre ellos puede ser usada para mover datos entre procesos.</para>

      <para>Finalmente, las conexiones de red también pueden ayudar a comunicar un proceso; estos procesos inclusive puede estar ejecutando en diferentes equipos, posiblemente a miles de kilómetros de distancia.</para>

      <para>Es bastante estándar que un sistema similar a Unix típico, utilice en varios niveles estos mecanismos.</para>
    </section>
    <section id="sect.libraries">
      <title>Bibliotecas</title>
      <indexterm><primary>biblioteca (de funciones)</primary></indexterm>

      <para>Las bibliotecas de funciones tienen un rol crucial en un sistema operativo similar a Unix. No son programas completos ya que no se las puede ejecutar por su cuenta, sino colecciones de fragmentos de código que los programas estándar pueden utilizar. Entre las bibliotecas comunes podemos encontrar a:</para>
      <itemizedlist>
        <listitem>
	  <para>la biblioteca estándar C (<emphasis>glibc</emphasis>), que contien funciones básicas como aquellas para abrir archivos o conexiones de red y otras que facilitan la interacción con el núcleo;</para>
        </listitem>
        <listitem>
	  <para>herramientas gráficas, como Gtk+ y Qt, que permiten que muchos programas reutilicen los objetos gráficos que proveen;</para>
        </listitem>
        <listitem>
	  <para>la biblioteca <emphasis>libpng</emphasis>, que permite cargar, interpretar y guardar imágenes en el formato PNG.</para>
        </listitem>
      </itemizedlist>

      <para>Gracias a estas bibliotecas, las aplicaciones puede reutilizar código existente. El desarrollo de la aplicación se simplifica cuando muchas aplicaciones reutilizan las mismas funciones. Debido a que diferentes personas desarrollan las bibliotecas, el desarrollo global del sistema es más cercano a la filosofía histórica de Unix.</para>

      <sidebar>
        <title><emphasis>CULTURA</emphasis> La forma Unix: una cosa a la vez</title>

	<para>Uno de los conceptos fundamentales que subyace en la familia Unix de sistemas operativos es que cada herramienta debe hacer sólo una cosa, y hacerla bien; las aplicaciones luego pueden reutilizar estas herramientas para crear sobre ellas lógica más avanzada. Se puede ver esta filosofía en muchas encarnaciones. Los scripts de consola pueden ser el mejor ejemplo: ensamblan secuencias complejas de herramientas muy simples (como <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command>, etc.). Podemos ver otra implementación de esta filosofía en bibliotecas de código: la bilioteca <emphasis>libpng</emphasis> permite leer y escribir imágenes PNG, con diferentes opciones y en diferentes formas, pero sólo hace eso; ni considera incluir funciones que muestren o editen imágenes.</para>
      </sidebar>

      <para>Lo que es más, estas bibliotecas generalmente son llamadas «bibliotecas compartidas» ya que el núcleo puede cargarlas en memoria sólo una vez, aún cuando varios procesos utilicen la misma biblioteca simultáneamente. Esto permite ahorrar memoria si lo comparamos con la situación opuesta (e hipotética) en la que se cargará el código de una biblioteca tantas veces como haya procesos que la utilizan.</para>
    </section>
  </section>
</appendix>
