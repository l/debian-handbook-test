<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="network-infrastructure">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-network-infrastructure.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Red</keyword>
      <keyword>Puerta de enlace</keyword>
      <keyword>TCP/IP</keyword>
      <keyword>IPv6</keyword>
      <keyword>DNS</keyword>
      <keyword>Bind</keyword>
      <keyword>DHCP</keyword>
      <keyword>QoS</keyword>
    </keywordset>
  </chapterinfo>
  <title id="infrastructure.title">Infraestructura de red</title>
  <highlights>
    <para>Linux goza de toda la herencia de Unix sobre redes, y Debian provee un conjunto completo de herramientas para crear y administrarlas. Este capítulo examina estas herramientas.</para>
  </highlights>
  <section id="sect.gateway">
    <title>Puerta de enlace</title>

    <para>Una puerta de enlace es un sistema que enlaza varias redes. Este término usualmente se refiere al «punto de salida» de una red local en el camino obligatorio hacia las direcciones IP externas. La puerta de enlace está conectada a cada una de las redes que enlaza y actúa como router para transmitir paquetes IP entre sus varias interfaces.</para>
    <indexterm><primary>puerta de enlace</primary></indexterm>
    <indexterm><primary>red</primary><secondary>puerta de enlace</secondary></indexterm>
    <indexterm><primary>router</primary></indexterm>

    <sidebar>
      <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Paquete IP</title>
      <indexterm><primary>paquete</primary><secondary>IP</secondary></indexterm>

      <para>La mayoría de las redes hoy en día utilizan el protocolo IP (protocolo de Internet: «<emphasis>Internet Protocol</emphasis>). Este protocolo segmenta los datos transmitidos en paquetes de tamaño limitado. Cada paquete contiene, además de sus datos como carga útil, algunos detalles necesarios para enrutarlos apropiadamente.</para>
    </sidebar>

    <sidebar id="sidebar.tcp-udp">
      <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> TCP/UDP</title>
      <indexterm><primary>puerto</primary><secondary>TCP</secondary></indexterm>
      <indexterm><primary>puerto</primary><secondary>udp</secondary></indexterm>
      <indexterm><primary>TCP, puerto</primary></indexterm>
      <indexterm><primary>UDP, puerto</primary></indexterm>

      <para>Muchos programas no gestionan los paquetes individuales por sí mismos aunque los datos que transmiten viajan por IP; generalmente utilizan TCP (protocolo de control de transmisión: «<emphasis>Transmission Control Protocol</emphasis>»). TCP es una capa sobre IP que permite establecer conexiones dedicadas a flujos de datos entre dos puntos. Los programas sólo ven, entonces, un punto de entrada en el que pueden verter datos con la garantía que los mismos datos existirán sin pérdida (y en el mismo orden) en el punto de salida en el otro extremo de la conexión. Si bien pueden ocurrir muchos tipos de errores en las capas inferiores, TCP los compensa: retransmite paquetes perdidos y reordena apropiadamente los paquetes que lleguen fuera de orden (por ejemplo si utilizaron caminos diferentes).</para>

      <para>Otro protocolo sobre IP es UDP (protocolo de datagramas de usuario: «<emphasis>User Datagram Protocol</emphasis>). A diferencia de TCP, está orientado a paquetes. Sus objetivos son diferentes: el propósito de UDP sólo es transmitir un paquete de una aplicación a otra. El protocolo no intenta compensar la posible pérdida de paquetes en el camino, así como tampoco asegura que los paquetes sean recibidos en el mismo orden en el que se los envió. La principal ventaja de este protocolo es que mejora enormemente la latencia ya que la pérdida de un paquete no demora la recepción de todos los paquetes siguientes hasta que se retransmita aquél perdido.</para>

      <para>Tanto TCP como UDP involucran puertos, que son «números de extensión» para establecer comunicaciones con una aplicación particular en una máquina. Este concepto permite mantener varias comunicaciones diferentes en paralelo con el mismo correspondiente debido a que se pueden diferenciar estas comunicaciones por el número de puerto.</para>

      <para>Algunos de estos números de puerto — estandarizados por IANA (autoridad de números asignados en Internet: «<emphasis>Internet Assigned Numbers Authority</emphasis>») — son «muy conocidos» por estar asociados con servicios de red. Por ejemplo, generalmente el servidor de correo utiliza el puerto TCP 25. <ulink type="block" url="http://www.iana.org/assignments/port-numbers" /></para>
    </sidebar>

    <para>Cuando una red local utiliza un rango de direcciones privadas (no enrutables en Internet), la puerta de enlace necesita implementar <emphasis>enmascarado de dirección</emphasis> («address masquerading») para que los equipos en la red puedan comunicarse con el mundo exterior. La operación de enmascarado es un tipo de proxy que funciona a nivel de red: se reemplaza cada conexión saliente de una máquina interna con una conexión desde la puerta de enlace misma (ya que la puerta de enlace tiene una dirección externa y enrutable), los datos que pasan a través de la conexión enmascarada son enviados a la nueva conexión y los datos recibidos en respuesta son enviados a través de la conexión enmascarada a la máquina interna. La puerta de enlace utiliza un rango de puertos TCP dedicados para este propósito, generalmente con números muy altos (mayores a 60000). Cada conexión que proviene de una máquina interna parece, para el mundo exterior, una conexión que proviene de uno de esos puertos reservados.</para>
    <indexterm><primary>enmascaramiento</primary></indexterm>

    <sidebar>
      <title><emphasis>CULTURA</emphasis> Rango de direcciones privadas</title>
      <indexterm><primary>Dirección IP</primary><secondary>privada</secondary></indexterm>
      <indexterm><primary>privada, dirección IP</primary></indexterm>

      <para>El RFC 1918 define tres rangos de direcciones IPv4 que no deben ser viables en Internet sino sólo utilizadas en redes locales. El primero, <literal>10.0.0.0/8</literal> (revise el recuadro <xref linkend="sidebar.networking-basics" />) es un rango clase A (con 2<superscript>24</superscript> direcciones IP). El segundo, <literal>172.16.0.0/12</literal>, reúne 16 rangos clase B (<literal>172.16.0.0/16</literal> a <literal>172.31.0.0/16</literal>), cada uno de los cuales contiene 2<superscript>16</superscript> direcciones IP. Finalmente, <literal>192.168.0.0/16</literal> es un rango clase B (agrupando 256 rangos clase C, <literal>192.168.0.0/24</literal> a <literal>192.168.255.0/24</literal>, con 256 direcciones IP cada uno). <ulink type="block" url="http://www.faqs.org/rfcs/rfc1918.html" /></para>
    </sidebar>

    <para>La puerta de enlace también puede realizar dos tipos de <emphasis>traducción de direcciones de red</emphasis> («Network Address Translation» o NAT). El primer tipo, <emphasis>NAT de destino</emphasis> (DNAT) es una técnica para alterar la dirección IP de destino (y/o el puerto TCP o UDP) para una conexión (generalmente) entrante. El mecanismo de seguimiento de conexiones también altera los paquetes siguientes en la misma conexión para asegurar continuidad en la comunicación. El segundo tipo de NAT es <emphasis>NAT de origen</emphasis> (SNAT), del que el <emphasis>enmascarado</emphasis> es un caso particular; SNAT modifica la dirección IP de origen (y/o el puerto TCP o UDP) de una conexión (generalmente) saliente. En lo que respecta a DNAT, todos los paquetes en la conexión son gestionados de forma apropiada por el mecanismo de seguimiento de conexiones. Sepa que NAT sólo es relevante para IPv4 y su espacio de direcciones limitado; en IPv6, la amplia disponibilidad de direcciones reduce enormemente la utilidad de NAT permitiendo que todas las direcciones «internas» sean enrutables directamente en Internet (esto no implica que se pueda acceder a las máquinas internas ya que los firewalls intermedios puede filtrar el tráfico).</para>
    <indexterm><primary>NAT</primary></indexterm>
    <indexterm><primary>red</primary><secondary>traducción de direcciones (NAT)</secondary></indexterm>
    <indexterm><primary>SNAT</primary></indexterm>
    <indexterm><primary>DNAT</primary></indexterm>
    <indexterm><primary>NAT, de destino</primary></indexterm>
    <indexterm><primary>NAT, de origen</primary></indexterm>

    <sidebar>
      <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Redirección de puertos</title>
      <indexterm><primary>port forwarding</primary></indexterm>

      <para>Una aplicación concreta de DNAT es <emphasis>redirección de puertos</emphasis> («port forwarding»). Las conexiones entrantes a un puerto dado de una máquina son redireccionados a un puerto en otra máquina. Sin embargo, pueden existir otras soluciones para conseguir un efecto similar, especialmente a nivel de aplicación con <command>ssh</command> (revise la <xref linkend="sect.ssh-port-forwarding" />) o <command>redir</command>.</para>
    </sidebar>

    <para>Suficiente teoría, pongámonos prácticos. Convertir un sistema Debian en una puerta de enlace sólo es cuestión de activar la opción apropiada en el núcleo Linux a través del sistema de archivos virtual <filename>/proc/</filename>:</para>

    <screen>
<computeroutput># </computeroutput><userinput>echo 1 &gt; /proc/sys/net/ipv4/conf/default/forwarding</userinput></screen>

    <para>También se puede activar esta opción automáticamente durante el inicio si <filename>/etc/sysctl.conf</filename> define la opción <literal>net.ipv4.conf.default.forwarding</literal> como <literal>1</literal>.</para>

    <example id="example.sysctl.conf">
      <title>El archivo <filename>/etc/sysctl.conf</filename></title>

      <programlisting>
net.ipv4.conf.default.forwarding = 1
net.ipv4.conf.default.rp_filter = 1
net.ipv4.tcp_syncookies = 1</programlisting>
    </example>

    <para>Puede conseguir el mismo efecto para IPv6 simplemente reemplazando <literal>ipv4</literal> con <literal>ipv6</literal> en la orden manual y utilizando la línea <literal>net.ipv6.conf.all.forwarding</literal> en <filename>/etc/sysctl.conf</filename>.</para>

    <para>Activar enmascarado de IPv4 es una operación un poco más compleja que involucra configurar el firewall <emphasis>netfilter</emphasis>.</para>

    <para>De forma similar, utilizar NAT (para IPv4) necesita configurar <emphasis>netfilter</emphasis>. Debido a que el propósito principal de este componente es filtrar paquetes, se enumeran los detalles en el <xref linkend="security" xrefstyle="select: label quotedtitle nopage" /> (revise la <xref linkend="sect.firewall-packet-filtering" />).</para>
  </section>
  <section id="sect.virtual-private-network">
    <title>Red virtual privada</title>

    <para>Una <emphasis>red virtual privada</emphasis> (VPN: «Virtual Private Network») es una forma de enlazar dos redes locales diferentes a través de Internet utilizando un túnel; el túnel generalmente está cifrado para confidencialidad. Usualmente se utilizan VPNs para integrar una máquina remota a la red local de una empresa.</para>
    <indexterm><primary>red</primary><secondary>privada virtual (VPN)</secondary></indexterm>
    <indexterm><primary>VPN</primary></indexterm>
    <indexterm><primary>privada virtual, red</primary></indexterm>

    <para>Muchas herramientas lo proveen. OpenVPN es una solución eficiente, fácil de desplegar y mantener, basada en SSL/TLS. Otra posibilidad es utilizar IPsec para cifrar el tráfico IP entre dos máquinas; este cifrado es transparente, lo que significa que no necesita modificar las aplicaciones ejecutando en estos equipos para tener en cuenta la VPN. También puede utilizar SSH, además de para sus funcionalidades más convencionales, para proveer una VPN. Finalmente, puede establecer una VPN utilizando el protocolo PPTP de Microsoft. Existen otras soluciones, pero están más allá del alcance de este libro.</para>
    <section id="sect.openvpn">
      <title>OpenVPN</title>
      <indexterm><primary>OpenVPN</primary></indexterm>

      <para>OpenVPN es un pedazo de software dedicado a crear redes privadas virtuales. Su configuración involucra crear interfaces de red virtuales en el servidor VPN y en los clientes; es compatible con interfaces <literal>tun</literal> (para túneles a nivel de IP) y <literal>tap</literal> (para túneles a nivel Ethernet). En la práctica, usualmente utilizará interfaces <literal>tun</literal> excepto cuando los clientes VPN deban intengrarse a la red local del servidor a través de un puente Ethernet.</para>

      <para>OpenVPN se basa en OpenSSL para toda la criptografía SSL/TLS y funcionalidades asociadas (confidencialidad, autenticación, integridad, falta de repudio). Puede configurarlo con una llave privada compartida o con un certificado X.509 basado en la infraestructura de llave pública. Se prefiere fuertemente esta última configuración ya que permite más flexibilidad cuando se enfrenta a un número creciente de usuarios itinerantes que acceden a la VPN.</para>

      <sidebar>
        <title><emphasis>CULTURA</emphasis> SSL y TLS</title>
        <indexterm><primary>SSL</primary></indexterm>
        <indexterm><primary>TLS</primary></indexterm>

	<para>Netscape inventó el protocolo SSL (<emphasis>capa de zócalos seguros</emphasis>: «Secure Socket Layer») para asegurar conexiones con servidores web. Luego fue estandarizado por el IETF bajo el acrónimo TLS (<emphasis>seguridad de capa de transporte</emphasis>: «Transport Layer Security»). Desde entonces, TLS ha seguido evolucionando y en nuestros días SSL ha quedado obsoleto debido a múltiples fallos de diseño que se han ido descubriendo.</para>
      </sidebar>
      <section id="sect.easy-rsa">
        <title>Infraestructura de llave pública: <emphasis>easy-rsa</emphasis></title>
        <indexterm><primary>PKI (infraestructura de llave pública)</primary></indexterm>
        <indexterm><primary>infraestructura de llave pública</primary></indexterm>
        <indexterm><primary>X.509, certificado</primary></indexterm>
        <indexterm><primary>certificado</primary><secondary>X.509</secondary></indexterm>
        <indexterm><primary><emphasis>easy-rsa</emphasis></primary></indexterm>
        <indexterm><primary>RSA (algoritmo)</primary></indexterm>
        <indexterm><primary>par de claves</primary></indexterm>

	<para>El algoritmo RSA es ampliamente utilizado en criptografía de llave pública. Involucra un «par de llaves», compuestas de una llave privada y una llave pública. Las dos llaves están fuertemente relacionadas entre ellas y sus propiedades matemáticas son tales que un mensaje cifrado con la llave pública sólo puede ser descifrado por alguien que conozca la llave privada, lo que asegura confidencialidad. En la dirección opuesta, un mensaje cifrado con la clave privada puede ser descifrado por cualquiera que conozca la llave pública, lo que permite autenticar el origen del mensaje ya que sólo pudo haber sido generado por alguien con acceso a la llave privada. Cuando se asocie una función de hash digital (MD5, SHA1 o una variante más reciente), esto lleva a un mecanismo de firma que puede aplicarse a cualquier mensaje.</para>

	<para>Sin embargo, cualquiera puede crear un par de llaves, almacenar cualquier identidad en ella y pretender ser la identidad que elijan. Una solución involucra el concepto de una <emphasis>autoridad de certificación</emphasis> (CA: «Certification Authority») formalizado por el estándar X.509. Este término se refiere a una entidad que posee un par de llaves confiable conocido como <emphasis>certificado raíz</emphasis>. Sólo se utiliza este certificado para firmar otros certificados (pares de llaves), luego que se siguieron suficientes pasos para revisar la identidad almacenada en el par de llaves. Las aplicaciones que utilizan X.509 luego pueden verificar los certificados que se les presente si conocen los certificados raíz confiables.</para>

	<para>OpenVPN sigue esta regla. Dado que los CA públicos sólo expiden certificados a cambio de un pago (importante), también es posible crear una autoridad de certificación privada dentro de la empresa. El paquete <emphasis>easy-rsa</emphasis> proporciona herramientas que dan soporte a la infraestructura de certificados X.509, implementados como un conjunto de scripts haciendo usp del comando <command>openssl</command>.</para>

        <sidebar>
          <title><emphasis>NOTA</emphasis> <emphasis>easy-rsa</emphasis> antes <emphasis role="distribution">Jessie</emphasis></title>

          <para>En versiones Debian hasta la <emphasis role="distribution">Wheezy</emphasis>, <emphasis>easy-rsa</emphasis> se distribuía como parte del paquete <emphasis role="pkg">openvpn</emphasis>, y sus scripts se encontraban en <filename>/usr/share/doc/openvpn/examples/easy-rsa/2.0/</filename>. Configurar una CA implicaba copiar ese directorio, en vez de usar el comando <command>make-cadir</command> documentado aquí.</para>
        </sidebar>

	<para>Los administradores de Falcot Corp utilizan esta herramienta para crear los certificados necesarios, tanto para los servidores como para los clientes. Esto permite que la configuración de todos los clientes sea similar ya que sólo deberán configurarlos para confiar en certificados que provengan de la CA local de Falcot. Esta CA es el primer certificado a crear; para ello los administradores preparan un directorio con los ficheros necesarios para la CA en una ubicación apropiada, preferentemente a una máquina que no está conectada a la red para evitar el riesgo de robo de la llave privada de la CA.</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>make-cadir pki-falcot
</userinput><computeroutput>$ </computeroutput><userinput>cd pki-falcot</userinput></screen>

	<para>Luego almacenan los parámetros necesarios en el archivo <filename>vars</filename>, especialmente aquellos cuyos nombres comienzan con <literal>KEY_</literal>; estas variables luego son integradas en el entorno:</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>vim vars
</userinput><computeroutput>$ </computeroutput><userinput>grep KEY_ vars
</userinput><computeroutput>export KEY_CONFIG=`$EASY_RSA/whichopensslcnf $EASY_RSA`
export KEY_DIR="$EASY_RSA/keys"
echo NOTE: If you run ./clean-all, I will be doing a rm -rf on $KEY_DIR
export KEY_SIZE=2048
export KEY_EXPIRE=3650
export KEY_COUNTRY="FR"
export KEY_PROVINCE="Loire"
export KEY_CITY="Saint-Étienne"
export KEY_ORG="Falcot Corp"
export KEY_EMAIL="admin@falcot.com"
export KEY_OU="Certificate authority"
export KEY_NAME="Certificate authority for Falcot Corp"
# If you'd like to sign all keys with the same Common Name, uncomment the KEY_CN export below
# export KEY_CN="CommonName"
$ </computeroutput><userinput>. ./vars
</userinput><computeroutput>NOTE: If you run ./clean-all, I will be doing a rm -rf on /home/roland/pki-falcot/keys
$ </computeroutput><userinput>./clean-all
</userinput></screen>

	<para>El siguiente paso es crear el par de llaves en sí de la CA (durante este paso se almacenarán las dos partes del par de llaves en <filename>keys/ca.crt</filename> y <filename>keys/ca.key</filename>):</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>./build-ca</userinput>
<computeroutput>Generating a 2048 bit RSA private key
...................................................................+++
...+++
writing new private key to 'ca.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [Falcot Corp CA]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:
</computeroutput></screen>

	<para>Ahora puede crear el certificado para el servidor VPN, así como también los parámetros Diffie-Hellman necesarios en el servidor para la conexión SSL/TLS. Se identifica el servidor VPN por su nombre DNS <literal>vpn.falcot.com</literal>; se reutiliza este nombre para los archivos de llaves generados (<filename>keys/vpn.falcot.com.crt</filename> para el certificado público, <filename>keys/vpn.falcot.com.key</filename> para la llave privada):</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>./build-key-server vpn.falcot.com
</userinput><computeroutput>Generating a 2048 bit RSA private key
.....................................................................................................................+++
...........+++
writing new private key to 'vpn.falcot.com.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [vpn.falcot.com]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
Using configuration from /home/roland/pki-falcot/openssl-1.0.0.cnf
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
countryName           :PRINTABLE:'FR'
stateOrProvinceName   :PRINTABLE:'Loire'
localityName          :T61STRING:'Saint-\0xFFFFFFC3\0xFFFFFF89tienne'
organizationName      :PRINTABLE:'Falcot Corp'
organizationalUnitName:PRINTABLE:'Certificate authority'
commonName            :PRINTABLE:'vpn.falcot.com'
name                  :PRINTABLE:'Certificate authority for Falcot Corp'
emailAddress          :IA5STRING:'admin@falcot.com'
Certificate is to be certified until Mar  6 14:54:56 2025 GMT (3650 days)
Sign the certificate? [y/n]:</computeroutput><userinput>y
</userinput><computeroutput>

1 out of 1 certificate requests certified, commit? [y/n]</computeroutput><userinput>y
</userinput><computeroutput>Write out database with 1 new entries
Data Base Updated
$ </computeroutput><userinput>./build-dh
</userinput><computeroutput>Generating DH parameters, 2048 bit long safe prime, generator 2
This is going to take a long time
[…]
</computeroutput>
</screen>

	<para>El siguiente paso crea los certificados para los clientes VPN; necesita un certificado para cada equipo o persona autorizada para utilizar la VPN:</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>./build-key JoeSmith
</userinput><computeroutput>Generating a 2048 bit RSA private key
................................+++
..............................................+++
writing new private key to 'JoeSmith.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:</computeroutput><userinput>Development unit
</userinput><computeroutput>Common Name (eg, your name or your server's hostname) [JoeSmith]:</computeroutput><userinput>Joe Smith
</userinput><computeroutput>[…]</computeroutput></screen>

	<para>Ahora que se crearon todos los certificados, necesita copiarlos donde correspondan: la llave pública del certificado raíz (<filename>key/ca.crt</filename>) será almacenada en todas las máquinas (tanto el servidor como los clientes) como <filename>/etc/ssl/certs/Falcot_CA.crt</filename>. Sólo instalará el certificado del servidor en el servidor (<filename>key/vpn.falcot.com.crt</filename> en <filename>/etc/ssl/vpn.falcot.com.crt</filename> y <filename>key/vpn.falcot.com.key</filename> en <filename>/etc/ssl/private/vpn.falcot.com.key</filename> con permisos restringidos para que sólo el administrador pueda leerlo), con los parámetros Diffie-Hellman correspondientes (<filename>key/dh2048.pem</filename>) instalados en <filename>/etc/openvpn/dh2048.pem</filename>. Instale los certificados de clientes en el cliente de VPN correspondiente de forma similar.</para>
      </section>
      <section>
        <title>Configuración del servidor OpenVPN</title>

	<para>El script de inicialización de OpenVPN intenta, de forma predeterminada, iniciar todas las redes privadas virtuales definidas en <filename>/etc/openvpn/*.conf</filename>. Configurar un servidor VPN entonces es cuestión de almacenar el archivo de configuración correspondiente en este directorio. Un buen punto de partida es <filename>/usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz</filename> que lleva a un servidor bastante estándar. Por supuesto necesitará adaptar algunos parámetros: <literal>ca</literal>, <literal>cert</literal>, <literal>key</literal> y <literal>dh</literal> describirán las ubicaciones seleccionadas para cada uno (respectivamente: <literal>/etc/ssl/certs/Falcot_CA.crt</literal>, <literal>/etc/ssl/vpn.falcot.com.crt</literal>, <literal>/etc/ssl/private/vpn.falcot.com.key</literal> y <literal>/etc/openvpn/dh2048.pem</literal>). La directiva <literal>server 10.8.0.0 255.255.255.0</literal> define la subred utilizada por la VPN; el servidor utilizará la primera dirección IP en el rango (<literal>10.8.0.1</literal>) y se asignarán a los clientes el resto de las direcciones.</para>

	<para>Con esta configuración OpenVPN creará una interfaz de red virtual al iniciar, generalmente con el nombre <literal>tun0</literal>. Sin embargo, normalmente se configuran los firewalls al mismo tiempo que las interfaces de red reales, lo que ocurre antes que inicie OpenVPN. La creación de una interfaz de red virtual persistente, y configurar OpenVPN para que la utilice, es una buena práctica recomendada. Esto además permite elegir el nombre de esta interfaz. A tal efecto, <command>openvpn -mktun -dev vpn -dev-type tun</command> crea una interfaz de red virtual llamada <literal>vpn</literal> de tipo <literal>tun</literal>; puede integrar fácilmente esta orden en el script de configuración del firewall o en la directiva <literal>up</literal> del archivo <filename>/etc/network/interfaces</filename>. Debe actualizar también el archivo de configuración de OpenVPN de forma acorde, con las directivas <literal>dev vpn</literal> y <literal>dev-type tun</literal>.</para>

	<para>Sin más cambios, los clientes VPN sólo pueden acceder el servidor VPN en sí a través de la dirección <literal>10.8.0.1</literal>. Para permitir a los clientes que accedan la red local (192.168.0.0/24) necesitará agregar una directiva <literal>push route 192.168.0.0 255.255.255.0</literal> a la configuración de OpenVPN para que los clientes VPN automáticamente obtengan una ruta de red que les indique que esta red está disponible a través de la VPN. Lo que es más, los equipos en la red local también necesitarán ser informados que la ruta a la VPN es a través del servidor de VPN (esto funciona automáticamente cuando instala el servidor VPN en la puerta de enlace). Otra alternativa es configurar el servidor VPN para realizar enmascaramiento de IPs de forma que las conexiones que provengan de los clientes VPN parezcan provenir del servidor VPN en su lugar (revise la <xref linkend="sect.gateway" />).</para>
      </section>
      <section>
        <title>Configuración del cliente OpenVPN</title>

	<para>Para configurar un cliente OpenVPN también necesita crear un archivo de configuración en <filename>/etc/openvpn/</filename>. Puede conseguir una configuración estándar utilizando <filename>/usr/share/doc/openvpn/examples/sample-config-files/client.conf</filename> como punto de partida. La directiva <literal>remote vpn.falcot.com 1194</literal> describe la dirección y puerto del servidor OpenVPN; también necesita adaptar <literal>ca</literal>, <literal>cert</literal> y <literal>key</literal> para describir la ubicación de los archivos de llave.</para>

	<para>Si no se debe iniciar la VPN automáticamente durante el inicio, configure la directiva <literal>AUTOSTART</literal> como <literal>none</literal> en el archivo <filename>/etc/default/openvpn</filename>. Siempre es posible iniciar o detener una conexión VPN dada con los comandos<command>service openvpn@<replaceable>nombre</replaceable> start</command> y <command>service openvpn@<replaceable>nombre</replaceable>stop</command> (donde la conexión <replaceable>nombre</replaceable> coincide con aquella definida en <filename>/etc/openvpn/<replaceable>nombre</replaceable>.conf</filename>).</para>

	<para>El paquete <emphasis role="pkg">network-manager-openvpn-gnome</emphasis> contiene una extensión para Network Manager (revise la <xref linkend="sect.roaming-network-config" />) que permite administrar redes privadas virtuales OpenVPN. Esto permite que cada usuario configure gráficamente sus conexiones OpenVPN y las controle desde el ícono del gestor de red. <indexterm><primary><emphasis role="pkg">network-manager-openvpn-gnome</emphasis></primary></indexterm></para>
      </section>
    </section>
    <section id="sect.ssh-vpn">
      <title>Red privada virtual con SSH</title>
      <indexterm><primary>SSH</primary></indexterm>
      <indexterm><primary>PPP</primary></indexterm>

      <para>En realidad existen dos formas de crear una red privada virtual con SSH. La histórica involucra establecer una capa PPP sobre el enlace SSH. Se describe este método en el siguiente «howto»: <ulink type="block" url="http://www.tldp.org/HOWTO/ppp-ssh/" /></para>

      <para>El segundo método es más reciente y fue introducido con OpenSSH 4.3; ahora OpenSSH puede crear interfaces de red virtuales (<literal>tun*</literal>) en ambos extremos de una conexión SSH y puede configurar estas interfaces virtuales exactamente como si fueran interfaces físicas. Primero debe activar el sistema de túneles configurando <literal>PermitTunnel</literal> como «yes» en el archivo de configuración del servidor SSH (<filename>/etc/ssh/sshd_config</filename>). Cuando se establece la conexión SSH debe solicitar explícitamente la creación del túnel con la opción <literal>-w any:any</literal> (puede reemplaza <literal>any</literal> con el número de dispositivo <literal>tun</literal> deseado). Esto necesita que el usuario tenga permisos de administrador en ambos extremos para poder crear el dispositivo de red (en otras palabras, debe establecer la conexión como root).</para>

      <para>Ambos métodos para crear redes privadas virtuales sobre SSH son bastante directos. Sin embargo, la VPN que proveen no es la más eficiente disponible; en particular, no maneja muy bien altos niveles de tráfico.</para>

      <para>La explicación es que cuando se encapsula TCP/IP en una conexión TCP/IP (para SSH) se utiliza el protocolo TCP dos veces, una vez para la conexión SSH y una vez dentro del túnel. Esto genera problemas, especialmente debido a la forma en la que TCP se adapta a condiciones de red modificando los tiempo de espera. El siguiente sitio describe el problema en más detalle: <ulink type="block" url="http://sites.inka.de/sites/bigred/devel/tcp-tcp.html" /> Por lo tanto debe limitar el uso de VPNs sobre SSH a túneles esporádicos y de un solo uso que no tengan requisitos de rendimiento.</para>
    </section>
    <section id="sect.ipsec">
      <title>IPsec</title>
      <indexterm><primary>IPsec</primary></indexterm>
      <indexterm><primary><command>strongswan</command></primary></indexterm>
      <indexterm><primary><command>racoon</command></primary></indexterm>

      <para>IPsec, a pesar de ser el estándar en VPNs IP, es bastante más complejo en su implementación. El motor de IPsec está incorporado al núcleo Linux; el paquete <emphasis role="pkg">ipsec-tools</emphasis> provee las partes necesarias en espacio de usuario, las herramientas de control y configuración. En términos concretos, el archivo <filename>/etc/ipsec-tools.conf</filename> de cada equipo contiene los parámetros de los <emphasis>túneles IPsec</emphasis> (en términos de IPsec: <emphasis>asociaciones de seguridad</emphasis>, «Security Associations») en los que el equipo está involucrado; el script <command>/etc/init.d/setkey</command> provee una forma de iniciar y detener el túnel (cada túnel es un enlace seguro a otra máquina conectada a la red privada virtual). Puede construir este archivo a mano desde la documentación que provee la página de manual <citerefentry><refentrytitle>setkey</refentrytitle> <manvolnum>8</manvolnum></citerefentry>. Sin embargo, escribir los parámetros para todos los equipos en un conjunto de máquinas no trivial se convierte fácilmente en una tarea ardua ya que la cantidad de túneles crece rápidamente. Instalar un demonio IKE (<emphasis>intercambio de llaves IPsec</emphasis>: «IPsec Key Exchange») como <emphasis role="pkg">racoon</emphasis>, <emphasis role="pkg">strongswan</emphasis> hace el proceso mucho más simple centralizando la administración y más seguro rotando las claves periódicamente.</para>
      <indexterm><primary>IKE</primary></indexterm>
      <indexterm><primary>IPSec</primary><secondary>intercambio de claves</secondary></indexterm>
      <indexterm><primary>par de claves</primary></indexterm>
      <indexterm><primary><command>setkey</command></primary></indexterm>

      <para>A pesar de su estado como referencia, la complejidad de configuración de IPsec restringe su uso en la práctica. Generalmente se preferirán soluciones basadas en OpenVPN cuando los túneles necesarios no sean muchos ni demasiado dinámicos.</para>

      <sidebar>
        <title><emphasis>PRECAUCIÓN</emphasis> IPsec y NAT</title>

	<para>Los firewall con NAT y IPsec no funcionan bien juntos: IPsec firma los paquetes y cualquier cambio en estos paquetes que realice el firewall invalidará la firma y el destino rechazará los paquetes. Muchas implementaciones IPsec incluyen la técnica <emphasis>NAT-T</emphasis> (<emphasis>NAT Traversal</emphasis>), que básicamente encapsula un paquete IP en un paquete UDP estándar.</para>
        <indexterm><primary>NAT-T</primary></indexterm>
        <indexterm><primary>NAT Traversal</primary></indexterm>
      </sidebar>

      <sidebar>
        <title><emphasis>SEGURIDAD</emphasis> IPsec y firewalls</title>

	<para>El modo de operación estándar de IPsec involucra intercambio de datos en el puerto UDP 500 para intercambio de llaves (también en el puerto UDP 4500 si utiliza NAT-T). Lo que es más, los paquetes IPsec utilizan dos protocolos IP dedicados que el firewall debe dejar pasar; la recepción de estos paquetes está basada en sus números de protocolo: 50 (ESP) y 51 (AH).</para>
        <indexterm><primary>ESP, protocolo</primary></indexterm>
        <indexterm><primary>AH, protocolo</primary></indexterm>
        <indexterm><primary>protocolo</primary><secondary>AH</secondary></indexterm>
        <indexterm><primary>protocolo</primary><secondary>ESP</secondary></indexterm>
      </sidebar>
    </section>
    <section id="sect.pptp">
      <title>PPTP</title>

      <para>PPTP (<emphasis>protocolo de túneles punto a punto</emphasis>: «Point-to-Point Tunneling Protocol») utiliza dos canales de comunicación, uno para datos de control y otro para los datos; este último utiliza el protocolo GRE (<emphasis>encapsulación genérica de enrutamiento</emphasis>: «Generic Routing Encapsulation»). Luego se establece un enlace PPP estándar sobre el canal de intercambio de datos.</para>
      <indexterm><primary>PPTP</primary></indexterm>
      <indexterm><primary>túneles punto a punto, protocolo</primary></indexterm>
      <indexterm><primary>GRE, protocolo</primary></indexterm>
      <indexterm><primary>protocolo</primary><secondary>GRE</secondary></indexterm>
      <section id="sect.pptp-config-client">
        <title>Configuración del cliente</title>

	<para>El paquete <emphasis role="pkg">pptp-linux</emphasis> contiene un cliente PPTP para Linux fácil de configurar. Las instrucciones a continuación están inspiradas en la documentación oficial: <ulink type="block" url="http://pptpclient.sourceforge.net/howto-debian.phtml" /></para>
        <indexterm><primary><emphasis role="pkg">pptp-linux</emphasis></primary></indexterm>

	<para>Los administradores de Falcot crearon varios archivos: <filename>/etc/ppp/options.pptp</filename>, <filename>/etc/ppp/peers/falcot</filename>, <filename>/etc/ppp/ip-up.d/falcot</filename> y <filename>/etc/ppp/ip-down.d/falcot</filename>.</para>

        <example id="example.ppp-options.pptp">
          <title>El archivo <filename>/etc/ppp/options.pptp</filename></title>

          <programlisting>
# opciones PPP utilizadas en una conexión PPTP
lock
noauth
nobsdcomp
nodeflate</programlisting>
        </example>

        <example id="example.ppp-peers-falcot">
          <title>El archivo <filename>/etc/ppp/peers/falcot</filename></title>

          <programlisting>
# vpn.falcot.com es el servidor PPTP
pty "pptp vpn.falcot.com --nolaunchpppd"
# el usuario «vpn» identificará a la conexión
user vpn
remotename pptp
# necesita cifrado
require-mppe-128
file /etc/ppp/options.pptp
ipparam falcot</programlisting>
        </example>

        <example id="example.ppp-ip-up.d-falcot">
          <title>El archivo <filename>/etc/ppp/ip-up.d/falcot</filename></title>

          <programlisting>
# Crear la ruta a la red Falcot
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 es la red Falcot (remota)
  route add -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi</programlisting>
        </example>

        <example id="example.ppp-ip-down.d-falcot">
          <title>El archivo <filename>/etc/ppp/ip-down.d/falcot</filename></title>

          <programlisting>
# Eliminar la ruta a la red Falcot
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 es la red Falcot (remota)
  route del -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi</programlisting>
        </example>

        <sidebar>
          <title><emphasis>SEGURIDAD</emphasis> MPPE</title>

	  <para>Asegurar PPTP involucra utilizar la funcionalidad MPPE (<emphasis>cifrado punto a punto de Microsoft</emphasis>: «Microsoft Point-to-Point Encryption»), disponible como un módulo en los núcleos Debian oficiales.</para>
          <indexterm><primary>MPPE</primary></indexterm>
          <indexterm><primary>Microsoft</primary><secondary>cifrado punto a punto</secondary></indexterm>
        </sidebar>
      </section>
      <section id="sect.pptp-config-serveur">
        <title>Configuración del servidor</title>

        <sidebar>
          <title><emphasis>PRECAUCIÓN</emphasis> PPTP y firewalls</title>

	  <para>Necesita configurar los firewalls intermedios para que permitan pasar paquetes IP que utilizan el protocolo 47 (GRE). Lo que es más, necesita abrir el puerto 1723 del servidor PPTP para que pueda utilizar el canal de comunicación.</para>
        </sidebar>

	<para><command>pptpd</command> es el servidor PPTP para Linux. Necesitará cambiar pocas cosas de su archivo de configuración principal, <filename>/etc/pptpd.conf</filename>: <emphasis>localip</emphasis> (dirección IP local) y <emphasis>remoteip</emphasis> (dirección IP remota). En el ejemplo a continuación el servidor PPTP siempre utiliza la dirección <literal>192.168.0.199</literal> y los clientes PPTP reciben una dirección IP desde <literal>192.168.0.200</literal> a <literal>192.168.0.250</literal>.</para>

        <example id="example.pptpd.conf">
          <title>El archivo <filename>/etc/pptpd.conf</filename></title>

          <programlisting>
# ETIQUETA: speed
#
#       Especifica la velocidad a la que se comunica el demonio PPP.
#
speed 115200

# ETIQUETA: option
#
#       Especifica la ubicación del archivo de opciones PPP
#       De forma predeterminada, se lo busca en «/etc/ppp/options»
#
option /etc/ppp/pptpd-options

# ETIQUETA: debug
#
#       Activa (más) depuración al registro del sistema
#
# debug

# ETIQUETA: localip
# ETIQUETA: remoteip
#
#       Especifica los rangos de direcciones IP local y remoto
#
#       Puede especificar direcciones IP individuales separadas por coma o
#       rangos o ambos. Por ejemplo:
#
#               192.168.0.234,192.168.0.245-249,192.168.0.254
#
#       RESTRICCIONES IMPORTANTES:
#
#       1. No se permiten espacios entre las comas o en las direcciones.
#
#       2. Si provee más direcciones IP que MAX_CONNECTIONS, comenzará al
#          principio de la lista y continuará hasta que obtenga
#          MAX_CONNECTIONS direcciones IPs. De lo contrario será ignorado.
#
#       3. ¡Sin atajos en los rangos! Es decir que 234-8 no significa 234
#          a 238, para esto debe tipear 234-238.
#
#       4. Está bien si provee sólo una IP local - se configurarán todas 
#          las IPs locales como la provista. DEBE proveer al menos una IP
#          remota para cada cliente simultáneo.
#
#localip 192.168.0.234-238,192.168.0.245
#remoteip 192.168.1.234-238,192.168.1.245
#localip 10.0.1.1
#remoteip 10.0.1.2-100
localip 192.168.0.199
remoteip 192.168.0.200-250</programlisting>
        </example>

	<para>La configuración PPP utilizada por el servidor PPTP también necesita algunos cambios en el archivo <filename>/etc/ppp/pptpd-options</filename>. Los parámetros importantes son el nombre del servidor (<literal>pptp</literal>), el nombre del dominio (<literal>falcot.com</literal> y la dirección IP para los servidores DNS y WINS.</para>

        <example id="example.ppp-pptpd-options">
          <title>El archivo <filename>/etc/ppp/pptpd-options</filename></title>

          <programlisting>
## activar la depuración de pppd en el registro del sistema
#debug

## modifique «servername» a lo que sea que especificó como su nombre de servidor en chap-secrets
name pptp
## modifique el nombre del dominio a su dominio local
domain falcot.com

## Estos son valores predeterminados razonables para clientes WinXXXX
## para las configuraciones relacionadas con seguridad
# El paquete pppd de Debian ahora es compatible tanto con MSCHAP como con MPPE, actívelos aquí.
# ¡Necesita tener también el módulo de núcleo para MPPE!
auth
require-chap
require-mschap
require-mschap-v2
require-mppe-128

## Complete con sus direcciones
ms-dns 192.168.0.1
ms-wins 192.168.0.1

## Complete con su máscara de red
netmask 255.255.255.0

## Algunos valores predeterminados
nodefaultroute
proxyarp
lock</programlisting>
        </example>

	<para>El último paso consiste en registrar el usuario <literal>vpn</literal> (y su contraseña asociada) en el archivo <filename>/etc/ppp/chap-secrets</filename>. A diferencia de otras instancias en las que un asterisco («<literal>*</literal>») funcionaría, aquí debe proveer explícitamente el nombre del servidor. Lo que es más, los clientes PPTP Windows se identifican a sí mismo en la forma <literal><replaceable>DOMINIO</replaceable>\\<replaceable>USUARIO</replaceable></literal> en lugar de sólo proveer un nombre de usuario. Esto explica porqué el archivo también menciona el usuario <literal>FALCOT\\vpn</literal>. También es posible especificar una dirección IP individual para los usuarios; un asterisco en este campo especifica que debe utilizar direcciones dinámicas.</para>

        <example id="example.ppp-chap-secrets">
          <title>El archivo <filename>/etc/ppp/chap-secrets</filename></title>

          <programlisting>
# Secretos para autenticación utilizando CHAP
# cliente       servidor secreto     dirección IP
vpn             pptp     f@Lc3au     *
FALCOT\\vpn     pptp     f@Lc3au     *</programlisting>
        </example>

        <sidebar>
          <title><emphasis>SEGURIDAD</emphasis> Vulnerabilidades PPTP</title>

	  <para>La primera implementación PPTP de Microsoft tuvo muchas críticas debido a su cantidad de vulnerabilidades de seguridad; la mayoría han sido solucionadas desde entonces en versiones más recientes. La configuración documentada en esta sección utiliza la última versión del protocolo. Sin embargo, debe saber que eliminar algunas opciones (como <literal>require-mppe-128</literal> y <literal>require-mschap-v2</literal>) podría hacer al servicio nuevamente vulnerable.</para>
        </sidebar>
      </section>
    </section>
  </section>
  <section id="sect.quality-of-service">
    <title>Calidad del servicio</title>
    <section id="sect.qos-principe">
      <title>Principle and Mechanism</title>

      <para><emphasis>Calidad del servicio</emphasis> (<emphasis>QoS</emphasis>: «Quality of Service») se refiere a un conjunto de técnicas que garantizan o mejoran la calidad del servicio provisto a las aplicaciones. De éstas, la técnica más popular consiste en clasificar el tráfico de red en categorías y diferenciar la gestión del tráfico según la categoría a la que pertenezca. El uso principal de este concepto de servicios diferenciados es la <emphasis>manipulación de tráfico</emphasis> («traffic shaping»), que limita las tasas de transmisión de datos para conexiones relacionadas con algunos servicios y/o equipos para no saturar el ancho de banda disponible y privar a otros servicios importantes. Esta técnica es particularmente buena para tráfico TCP ya que el protocolo se adapta automáticamente al ancho de banda disponible.</para>
      <indexterm><primary>QoS</primary></indexterm>
      <indexterm><primary>calidad del servicio</primary></indexterm>
      <indexterm><primary>calidad</primary><secondary>del servicio</secondary></indexterm>
      <indexterm><primary>servicio</primary><secondary>calidad del</secondary></indexterm>

      <para>También es posible alterar las prioridades del tráfico, lo que permite priorizar paquetes relacionados con servicios interactivos (como <command>ssh</command> y <command>telnet</command>) o a servicios que sólo trabajan con bloques de datos pequeños.</para>

      <para>Los núcleos Debian incluyen la funcionalidad necesaria para QoS así como también los módulos asociados. Estos módulos son muchos y cada uno de ellos provee un servicio diferente, los más notables como planificadores especiales para las colas de paquetes IP; el amplio rango de comportamientos de planificadores abarca todo el rango de requerimientos posibles.</para>

      <sidebar>
        <title><emphasis>CULTURA</emphasis> LARTC — <emphasis>Enrutamiento avanzado y control de tráfico de Linux</emphasis> («Linux Advanced Routing &amp; Traffic Control»)</title>

	<para>El «howto» de <emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis> es el documento de referencia que cubre todo lo que hace falta saber sobre calidad de servicio en una red. <ulink type="block" url="http://www.lartc.org/howto/" /></para>
        <indexterm><primary>enrutamiento</primary><secondary>avanzado</secondary></indexterm>
        <indexterm><primary>tráfico</primary><secondary>control de</secondary></indexterm>
        <indexterm><primary>control de tráfico</primary></indexterm>
      </sidebar>
    </section>
    <section id="sect.qos-config">
      <title>Configuración e implementación</title>

      <para>Se configuran los parámetros de QoS mediante el programa <command>tc</command> (provisto por el paquete <emphasis role="pkg">iproute</emphasis>). Se recomienda utilizar herramientas de más alto nivel ya que su interfaz es bastante compleja.</para>
      <indexterm><primary><emphasis>iproute</emphasis></primary></indexterm>
      <indexterm><primary><command>tc</command></primary></indexterm>
      <section id="sect.qos-wondershaper">
        <title>Reducción de latencias: <command>wondershaper</command></title>

	<para>El propósito principal de <command>wondershaper</command> (en el paquete con nombre similar) es minimizar las latencias independientemente de la carga en la red. Consigue esto limitando el tráfico total a un valor que está justo por debajo del valor de saturación del enlace.</para>
        <indexterm><primary><command>wondershaper</command></primary></indexterm>
        <indexterm><primary>limitación de tráfico</primary></indexterm>
        <indexterm><primary>tráfico</primary><secondary>limitación</secondary></indexterm>

	<para>Una vez que una interfaz de red está configurada puede definir sus limitaciones de tráfico ejecutando <command>wondershaper <replaceable>interfaz</replaceable> <replaceable>tasa_descarga</replaceable> <replaceable>tasa_subida</replaceable></command>. La interfaz puede ser, por ejemplo, <literal>eth0</literal> o <literal>ppp0</literal> y ambas tasas son en kilobits por segundo. Ejecutar <command>wondershaper remove <replaceable>interfaz</replaceable></command> desactiva el control de tráfico en la interfaz especificada.</para>

	<para>Para una conexión Ethernet, lo mejor es ejecutar este script inmediatamente después de configurar la interfaz. Puede lograrlo agregando directivas <literal>up</literal> y <literal>down</literal> al archivo <filename>/etc/network/interfaces</filename> indicando las órdenes a ejecutar luego que se configure la interfaz y luego que sea desconfigurada, respectivamente. Por ejemplo:</para>

        <example id="example.network-interfaces">
          <title>Cambios en el archivo <filename>/etc/network/interfaces</filename></title>

          <programlisting>
iface eth0 inet dhcp
    up /sbin/wondershaper eth0 500 100
    down /sbin/wondershaper remove eth0</programlisting>
        </example>

	<para>En el caso de PPP, crear un script que ejecute <command>wondershaper</command> en <filename>/etc/ppp/ip-up.d/</filename> activará el control de tráfico tan pronto como esté activa la conexión.</para>

        <sidebar>
          <title><emphasis>YENDO MÁS ALLÁ</emphasis> Configuración óptima</title>

	  <para>El archivo <filename>/usr/share/doc/wondershaper/README.Debian.gz</filename> describe, con suficiente detalles, los métodos de configuración recomendados por el encargado del paquete. En particular, aconseja medir las velocidades de subida y bajada para evaluar de la mejor forma los límites reales.</para>
        </sidebar>
      </section>
      <section id="sect.qos-config-standard">
        <title>Configuración estándar</title>

	<para>A menos que exista una configuración de QoS específica, el núcleo Linux utiliza el planificador de colas <literal>pfifo_fast</literal> el cual provee algunas características interesantes en sí mismo. La prioridad de cada paquete IP procesado está basada en el campo ToS (<emphasis>tipo de servicio</emphasis>: «Type of Service») del mismo; modificar este campo es suficiente para tomar ventaja de sus capacidades de planificación. Existen cinco valores posibles:</para>
        <itemizedlist>
          <listitem>
	    <para>Servicio normal: Normal-Service (0);</para>
          </listitem>
          <listitem>
	    <para>Minimizar costo: Minimize-Cost (2);</para>
          </listitem>
          <listitem>
	    <para>Maximizar confiabilidad: Maximize-Reliability (4);</para>
          </listitem>
          <listitem>
	    <para>Maximizar rendimiento: Maximize-Throughput (8);</para>
          </listitem>
          <listitem>
	    <para>Minimizar demora: Minimize-Delay (16).</para>
          </listitem>
        </itemizedlist>
        <indexterm><primary>ToS</primary></indexterm>
        <indexterm><primary>tipo de servicio</primary></indexterm>

	<para>Las aplicaciones que generan paquetes IP pueden definir el campo ToS, también puede ser modificado al vuelo por <emphasis>netfilter</emphasis>. Las siguientes reglas son suficiente para aumentar la respuesta del servicio de un servidor SSH:</para>

        <programlisting role="scale">
iptables -t mangle -A PREROUTING -p tcp --sport ssh -j TOS --set-tos Minimize-Delay
iptables -t mangle -A PREROUTING -p tcp --dport ssh -j TOS --set-tos Minimize-Delay</programlisting>
      </section>
    </section>
  </section>
  <section id="sect.dynamic-routing">
    <title>Enrutamiento dinámico</title>
    <indexterm><primary>enrutamiento</primary><secondary>dinámico</secondary></indexterm>
    <indexterm><primary><command>quagga</command></primary></indexterm>
    <indexterm><primary><command>zebra</command></primary></indexterm>

    <para>Actualmente, la herramienta de referencia para enrutamiento dinámico es <command>quagga</command>, del paquete con un nombre similar; solía ser <command>zebra</command> hasta que se detuvo el desarrollo de este último. Sin embargo, <command>quagga</command> mantuvo los nombres de los programas por cuestiones de compatibilidad, lo que explica el uso de <command>zebra</command> a continuación.</para>

    <sidebar>
      <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Enrutamiento dinámico</title>

      <para>El enrutamiento dinámico le permite a los routers ajustar, en tiempo real, los caminos utilizados para transmitir paquetes IP. Cada protocolo posee sus propios métodos para definir rutas (camino más corto, utilizar rutas publicadas por pares, etc.).</para>

      <para>En el núcleo Linux una ruta enlaza un dispositivo de red a un conjunto de máquinas que pueden ser alcanzadas a través de este dispositivo. El programa <command>route</command> define nuevas rutas y muestra las existentes.</para>
      <indexterm><primary><command>route</command></primary></indexterm>
    </sidebar>

    <para>Quagga es un conjunto de demonios que cooperan entre sí para definir las tablas de enrutamiento utilizadas por el núcleo Linux; cada protocolo de enrutamiento (BGP, OSPF y RIP siendo los más notables) provee su propio demonio. El demonio <command>zebra</command> recolecta la información de los otros demonios y administra las tablas de enrutamiento estático de forma acorde. Los otros demonios son <command>bgpd</command>, <command>ospfd</command>, <command>ospf6d</command>, <command>ripd</command>, <command>ripngd</command>, <command>isisd</command> y <command>babeld</command>.</para>
    <indexterm><primary>OSPF</primary></indexterm>
    <indexterm><primary>BGP</primary></indexterm>
    <indexterm><primary>RIP</primary></indexterm>
    <indexterm><primary>IS-IS</primary></indexterm>
    <indexterm><primary>BABEL, enrutamiento inalámbrico en malla</primary></indexterm>
    <indexterm><primary><command>bgpd</command></primary></indexterm>
    <indexterm><primary><command>ospfd</command></primary></indexterm>
    <indexterm><primary><command>ospf6d</command></primary></indexterm>
    <indexterm><primary><command>ripd</command></primary></indexterm>
    <indexterm><primary><command>ripngd</command></primary></indexterm>
    <indexterm><primary><command>isisd</command></primary></indexterm>
    <indexterm><primary><command>babeld</command></primary></indexterm>

    <para>Puede activar demonios mediante la edición el archivo <filename>/etc/quagga/daemons</filename> y creando el archivo de configuración apropiado en <filename>/etc/quagga/</filename>; debe nombrar este archivo de configuración según el demonio, con una extensión <filename>.conf</filename> y debe pertenecer al usuario <literal>quagga</literal> y al grupo <literal>quaggavty</literal> para que el script <filename>/etc/init.d/quagga</filename> ejecute el demonio.</para>

    <para>Para configurar cada uno de estos demonio necesita conocer el protocolo de enrutamiento en cuestión. No podemos describir en detalle aquí a estos protocolos, pero el paquete <emphasis role="pkg">quagga-doc</emphasis> provee una explicación extensa en forma de archivos <command>info</command>. Puede navegar los mismos contenidos en formato HTML en el sitio web de Quagga: <ulink type="block" url="http://www.nongnu.org/quagga/docs/docs-info.html" /></para>

    <para>Además, la sintaxis es muy parecida a la configuración de una interfaz estándar de un router, y los administradores de red la adaptarán rápidamente a <command>quagga</command>.</para>

    <sidebar>
      <title><emphasis>EN LA PRÁCTICA</emphasis> ¿OSPF, BGP o RIP?</title>

      <para>OSPF es generalmente el mejor protocolo a utilizar para enrutamiento dinámico en redes privadas pero BGP es maś común para enrutamiento en Internet. RIP es bastante arcaico y rara vez utilizado en la actualidad.</para>
    </sidebar>
  </section>
  <section id="sect.ipv6">
    <title>IPv6</title>

    <para>IPv6, sucesor de IPv4, es una nueva versión del protocolo IP diseñado para corregir sus fallas, especialmente la escasez de direcciones IP disponibles. Este protocolo gestiona la capa de red; su propósito es proveer una forma de direccionar máquinas para transmitir los datos a donde fueron destinados y administrar la fragmentación de datos si es necesaria (en otras palabras, dividir los paquetes en trozos de un tamaño que dependa de los enlaces de red utilizados en el camino y unirlos nuevamente en el orden apropiado cuando lleguen).</para>

    <para>Los núcleos Debian incluyen la gestión de IPv6 en el corazón del núcleo (con la excepción de algunas arquitecturas que la poseen como un módulo llamado <literal>ipv6</literal>). Las herramientas básicas como <command>ping</command> y <command>traceroute</command> tienen sus equivalentes IPv6, <command>ping6</command> y <command>traceroute6</command>, disponibles en los paquetes <emphasis role="pkg">iputils-ping</emphasis> y <emphasis role="pkg">iputils-tracepath</emphasis> respectivamente.</para>
    <indexterm><primary>IPv6</primary></indexterm>
    <indexterm><primary><emphasis role="pkg">iputils-ping</emphasis></primary></indexterm>
    <indexterm><primary><emphasis role="pkg">iputils-tracepath</emphasis></primary></indexterm>

    <para>Una red IPv6 se configura de forma similar a una IPv4, en el archivo <filename>/etc/network/interfaces</filename>. Pero si desea que se pueda acceder globalmente a la red debe asegurarse de tener un router compatible con IPv6 que retransmita datos a la red IPv6 global.</para>

    <example id="example.network-interfaces-ipv6">
      <title>Ejemplo de configuración IPv6</title>

      <programlisting>
iface eth0 inet6 static
    address 2001:db8:1234:5::1:1
    netmask 64
    # Desactivar autoconfiguración
    # autoconf 0
    # El enrutador se configura automáticamente y no tiene dirección 
    # fija (accept_ra 1). Si la tuviera:
    # gateway 2001:db8:1234:5::1</programlisting>
    </example>

    <para>Las subredes IPv6 generalmente tienen una máscara de red de 64 bits. Esto significa que existen 2<superscript>64</superscript> direcciones diferentes dentro de la subred. Esto permite que «Stateless Address Autoconfiguration» (<acronym>SLAAC</acronym>: autoconfiguración de direcciones sin estado) selecione una dirección basada en la dirección MAC de la interfaz de red. De forma predeterminada, si <acronym>SLAAC</acronym> está activado en su red e IPv6 en su equipo, el núcleo encontrará enrutadores IPv6 automáticamente y configurará las interfaces de red.</para>

    <para>Este comportamiento podría tener consecuencias en la privacidad. Si cambia de red frecuentemente, por ejemplo con un portátil, podría no desear que su dirección <acronym>MAC</acronym> sea parte de su dirección IPv6 pública. Esto facilita la identificación del mismo dispositivo en varias redes. Las extensiones de privacidad de IPv6 (las cuales en Debian se habilitan por defecto si se detecta conectividad IPv6 durante la instalación inicial) son una solución a este problema, las que asignarán direcciones adicionales generadas aleatoriamente a la interfaz, las cambiarán periódicamente y las preferirán para conexiones salientes. Las conexiones entrantes todavía podrán utilizar las direcciones generadas por SLAAC. El ejemplo a continuación, para utilizar en <filename>/etc/network/interfaces</filename>, activa estas extensiones de privacidad.</para>

    <example id="example.network-interface-ipv6-privext">
      <title>Extensiones de privacidad IPv6</title>

      <programlisting>
iface eth0 inet6 auto
    # Preferir las direcciones asignadas aleatoriamente para conexiones salientes.
    privext 2</programlisting>
    </example>

    <sidebar>
      <title><emphasis>SUGERENCIA</emphasis> Programas desarrollados con IPv6</title>

      <para>Mucho software necesita ser adaptado para que pueda utilizar IPv6. La mayoría de los paquetes en Debian ya fueron adaptados, pero no todos. Si su paquete favorito no funciona con IPv6 todavía, puede pedir ayuda en la lista de correo <emphasis>debian-ipv6</emphasis>. Allí podrían recomendarle un reemplazo que funcione con IPv6 y reportarán el error para que se lo siga apropiadamente. <ulink type="block" url="http://lists.debian.org/debian-ipv6/" /></para>
    </sidebar>

    <indexterm><primary>IPv6, firewall</primary></indexterm>
    <indexterm><primary>firewall</primary><secondary>IPv6</secondary></indexterm>
    <indexterm><primary><command>ip6tables</command></primary></indexterm>
    <para>Puede restringir las conexiones IPv6 de la misma forma que aquellas IPv4: el núcleo Debian estándar incluye una adaptación de <emphasis>netfilter</emphasis> para IPv6. Puede configurar esta versión de <emphasis>netfilter</emphasis> para IPv6 de forma similar a su contraparte IPv4 utilizando el programa <command>ip6tables</command> en lugar de <command>iptables</command>.</para>

    <section id="sect.ipv6-tunneling">
      <title>Túneles</title>

      <sidebar>
        <title><emphasis>PRECAUCIÓN</emphasis> Firewalls y túneles IPv6</title>

        <para>Los túneles IPv6 sobre IPv4 (a diferencia de IPv6 nativo) necesitan que el firewall acepte el tráfico, que utiliza el número de protocolo IPv4 41.</para>
      </sidebar>

      <para>Si no existe una conexión IPv6 disponible, el método de respaldo es utilizar un túnel sobre IPv4. Gogo es un proveedor (gratuito) de dichos túneles: <ulink type="block" url="http://www.gogo6.net/freenet6/tunnelbroker" /></para>
      <indexterm><primary>Freenet6</primary></indexterm>
      <indexterm><primary>Gogo6</primary></indexterm>

      <para>Para utilizar un túnel de Freenet6 necesita registrarse con una cuenta «Freenet6 Pro» en el sitio web, instalar el paquete <emphasis role="pkh">gogoc</emphasis> y configurar el túnel. Para ello deberá editar el archivo <filename>/etc/gogoc/gogoc.conf</filename>: debe agregar las líneas <literal>userid</literal> y <literal>password</literal> que recibió por email y reemplazar <literal>server</literal> con <literal>authenticated.freenet6.net</literal>.</para>

      <para>Puede agregar las siguientes tres directivas al archivo <filename>/etc/gogoc/gogoc.conf</filename> para proponer conectividad IPv6 a todas las máquinas en una red local (asumiendo que la red local está conectada a la interfaz eth0):</para>

      <programlisting>
host_type=router
prefixlen=56
if_prefix=eth0</programlisting>

      <para>Luego la máquina se convertirá en el router de acceso para una subred con un prefijo de 56 bits. Una vez que el túnel sepa de este cambio, debe informarle a la red al respecto; esto implica instalar el demonio <command>radvd</command> (del paquete del mismo nombre). Este demonio de configuración IPv6 tiene un rol similar al de <command>dhcpd</command> en el mundo IPv4.</para>

      <para>Debe crear el archivo de configuración <filename>/etc/radvd.conf</filename> (revise el archivo <filename>/usr/share/doc/radvd/examples/simple-radvd.conf</filename> como punto de partida). En nuestro caso, el único cambio necesario es el prefijo que debe reemplazar con el provisto por Freenet6; puede encontrarlo en la salida de <command>ifconfig</command>, en el bloque sobre la interfaz <literal>tun</literal>.</para>
      <indexterm><primary><command>radvd</command></primary></indexterm>

      <para>Luego ejecute <command>service gogoc restart</command> y <command>service radvd start</command>, y la red IPv6 debería funcionar.</para>
    </section>

  </section>
  <section id="sect.domain-name-servers">
    <title>Servidores de nombres de dominio (DNS)</title>
    <section id="sect.dns-principe">
      <title>Principle and Mechanism</title>
      <indexterm><primary>DNS</primary></indexterm>
      <indexterm><primary>servidor</primary><secondary>nombre</secondary></indexterm>

      <para>El <emphasis>servicio de nombres de dominio</emphasis> (DNS: «Domain Name Service») es un componente fundamental de Internet: asocia nombres de equipo con direcciones IP (y viceversa), lo que permite utilizar <literal>www.debian.org</literal> en lugar de <literal>5.153.231.4</literal> o <literal>2001:41c8:1000:21::21:4</literal>.</para>

      <para>Los registros DNS se organizan en zonas; cada zona coincide con un dominio (o subdominio) o un rango de direcciones IP (ya que generalmente se proveen direcciones IP en rangos consecutivos). Un servidor primario es autoridad sobre los contenidos de una zona; los servidores secundarios, generalmente en otras máquinas, proveen copias de la zona primaria actualizadas regularmente.</para>
      <indexterm><primary>zona</primary><secondary>DNS</secondary></indexterm>
      <indexterm><primary>DNS</primary><secondary>zona</secondary></indexterm>

      <para>Cada zona puede contener registros de varios tipos (<emphasis>registros de recursos</emphasis>: «Resource Records»):</para>
      <itemizedlist>
        <listitem>
	  <para><literal>A</literal>: dirección IPv4. <indexterm><primary>A, registro DNS</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>CNAME</literal>: alias (<emphasis>nombre canónico</emphasis>: «canonical name»). <indexterm><primary>CNAME, registro DNS</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>MX</literal>: <emphasis>intercambio de correo</emphasis> («mail exchange»), un servidor de correo. Los otros servidores de correo utilizan esta información para encontrar a dónde redirigir los emails enviados a una dirección particular. Cada registro MX tiene una prioridad. Primero se intenta el servidor con mayor prioridad, con el menor número (revise el recuadro <xref linkend="sidebar.smtp" />); se contactan los demás servidores en orden decreciente de prioridad si el primero no responde. <indexterm><primary>MX</primary><secondary>registro DNS</secondary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>PTR</literal>: asociación de una dirección IP con un nombre. Se almacenan estos registros en una zona de «DNS inverso» cuyo nombre está basado en el rango de direcciones IP. Por ejemplo, <literal>1.168.192.in-addr.arpa</literal> es la zona que contiene las asociaciones inversas de todas las direcciones en el rango <literal>192.168.1.0/24</literal>. <indexterm><primary>PTR, registro DNS</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>AAAA</literal>: dirección IPv6. <indexterm><primary>AAAA, registro DNS</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>NS</literal>: asocia un nombre con un servidor de nombres. Cada dominio debe tener al menos un registro NS. Estos registros apuntan al servidor DNS que puede responder consultas sobre este dominio; generalmente apuntan a los servidores primarios y secundarios del dominio. Estos registros también permiten delegaciones de DNS; por ejemplo, la zona <literal>falcot.com</literal> puede incluir un registro NS para <literal>internal.falcot.com</literal>, lo que significa que otro servidor administra la zona <literal>internal.falcot.com</literal>. Por supuesto, este servidor debe declarar una zona <literal>internal.falcot.com</literal>. <indexterm><primary>NS, registro DNS</primary></indexterm></para>
        </listitem>
      </itemizedlist>
      
      <indexterm><primary>DNS</primary><secondary>registro</secondary></indexterm>
      <indexterm><primary>registro DNS</primary></indexterm>

      <para>El servidor de nombres de referencia, Bind, fue desarrollado y es mantenido por ISC (<emphasis>consorte de software de Internet</emphasis>: «Internet Software Consortium»). Está disponible en Debian en el paquete <emphasis role="pkg">bind9</emphasis>. La versión 9 provee dos cambios importantes comparada con versiones anteriores. Primero, el servidor DNS ahora puede ejecutar como un usuario sin privilegios para que una vulnerabilidad de seguridad en el servidor no provea permisos de root al atacante (como pasaba frecuentemente con las versiones 8.X).</para>

      <para>Lo que es más, Bind es compatible con el estándar DNSSEC para firmar (y, por lo tanto, autenticar) registros DNS, lo que permite bloquear datos apócrifos durante ataques con intermediarios («man-in-the-middle»).</para>
      <indexterm><primary><emphasis role="pkg">bind9</emphasis></primary></indexterm>
      <indexterm><primary>ISC</primary></indexterm>
      <indexterm><primary>Internet Software Consortium</primary></indexterm>

      <sidebar>
        <title><emphasis>CULTURA</emphasis> DNSSEC</title>
        <indexterm><primary>DNSSEC</primary></indexterm>

	<para>La normativa DNSSEC es bastante compleja; esto explica parcialmente por qué no es utilizada ampliamente aún (aún si puede coexistir perfectamente con servidores DNS que no conozcan de DNSSEC). Para entender los recovecos debería revisar el siguiente artículo. <ulink type="block" url="http://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions" /></para>
      </sidebar>
    </section>
    <section id="sect.dns-config">
      <title>Configuración</title>

      <para>Archivos de configuración de <command>bind</command>, sin importar su versión, tienen la misma estructura.</para>

      <para>Los administradores de Falcot crearon una zona primaria <literal>falcot.com</literal> para almacenar información relacionada con este dominio y una zona <literal>168.192.in-addr.arpa</literal> para la asociación inversa de direcciones IP en las redes locales.</para>

      <sidebar>
        <title><emphasis>PRECAUCIÓN</emphasis> Nombres de zonas inversas</title>
        <indexterm><primary>zona</primary><secondary>inversa</secondary></indexterm>
        <indexterm><primary>inversa, zona</primary></indexterm>
        <indexterm><primary><literal>in-addr.arpa</literal></primary></indexterm>
        <indexterm><primary><literal>ip6.arpa</literal></primary></indexterm>
	<indexterm><primary>formato nibble</primary></indexterm>

	<para>Las zonas inversas tiene un nombre particular. La zona que cubre la red <literal>192.168.0.0/16</literal> necesita llamarse <literal>168.192.in-addr.arpa</literal>: se invierten los componentes de la dirección IP seguidos del sufijo <literal>in-addr.arpa</literal>.</para>

	<para>Para redes IPv6, el sufijo es <literal>ip6.arpa</literal> y los componentes de la dirección IP, invertidos, son cada caracter de la dirección IP en su representación hexadecimal completa. Por ejemplo, la red <literal>2001:0bc8:31a0::/48</literal> podría utilizar una red llamada <literal>0.a.1.3.8.c.b.0.1.0.0.2.ip6.arpa</literal>.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>SUGERENCIA</emphasis> Pruebas del servidor DNS</title>

	<para>El programa <command>host</command> (en el paquete <emphasis role="pkg">bind9-host</emphasis>) consulta un servidor DNS y puede utilizarse para probar la configuración del servidor. Por ejemplo, <command>host maquina.falcot.com localhost</command> revisa la respuesta del servidor local a la consulta por <literal>maquina.falcot.com</literal>. <command>host <replaceable>direccion.ip</replaceable> localhost</command> prueba la resolución inversa.</para>
	<indexterm><primary><command>host</command></primary></indexterm>
      </sidebar>

      <para>Los siguientes extractos de configuración, de los archivos de Falcot, pueden servirle como punto de partida para configurar un servidor DNS:</para>
      <indexterm><primary><filename>named.conf</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/bind/named.conf</filename></primary></indexterm>

      <example id="example.bind-named.conf.local">
        <title>Extracto de <filename>/etc/bind/named.conf.local</filename></title>

        <programlisting>
zone "falcot.com" {
        type master;
        file "/etc/bind/db.falcot.com";
        allow-query { any; };
        allow-transfer {
                195.20.105.149/32 ; // ns0.xname.org
                193.23.158.13/32 ; // ns1.xname.org
        };
};

zone "internal.falcot.com" {
        type master;
        file "/etc/bind/db.internal.falcot.com";
        allow-query { 192.168.0.0/16; };
};

zone "168.192.in-addr.arpa" {
        type master;
        file "/etc/bind/db.192.168";
        allow-query { 192.168.0.0/16; };
};</programlisting>
      </example>

      <example id="example.bind-db.falcot.com">
        <title>Extracto de <filename>/etc/bind/db.falcot.com</filename></title>

        <programlisting>; Zona falcot.com 
; admin.falcot.com. =&gt; contacto de la zona: admin@falcot.com
$TTL    604800
@       IN      SOA     falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresco
                          86400         ; Reintento
                        2419200         ; Expiración
                         604800 )       ; TTL de caché negativo
;
; El @ hace referencia al nombre de la zona («falcot.com» aquí)
; o a $ORIGIN (origen) si se utilizó esta directiva
;
@       IN      NS      ns
@       IN      NS      ns0.xname.org.

internal IN      NS      192.168.0.2

@       IN      A       212.94.201.10
@       IN      MX      5 mail
@       IN      MX      10 mail2

ns      IN      A       212.94.201.10
mail    IN      A       212.94.201.10
mail2   IN      A       212.94.201.11
www     IN      A       212.94.201.11

dns     IN      CNAME   ns</programlisting>
      </example>

      <sidebar>
        <title><emphasis>PRECAUCIÓN</emphasis> Sintaxis de un nombre</title>

	<para>La sintaxis de los nombres de máquinas deben adherirse a reglas estrictas. Por ejemplo, <literal>maquina</literal> implica <literal>maquina.<replaceable>dominio</replaceable></literal>. Si no se debe agregar el nombre de dominio a un nombre, debe escribir dicho nombre como <literal>maquina.</literal> (con un punto de sufijo). Por lo tanto, indicar un nombre DNS fuera del dominio actual necesita una sintaxis como <literal>maquina.otrodominio.com.</literal> (con el punto final).</para>
      </sidebar>

      <example id="example.bind-db.192.168">
        <title>Extracto de <filename>/etc/bind/db.192.168</filename></title>

        <programlisting>; Zona inversa para 192.168.0.0/16
; admin.falcot.com. =&gt; contacto de la zona: admin@falcot.com
$TTL    604800
@       IN      SOA     ns.internal.falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresco
                          86400         ; Reintento
                        2419200         ; Expiración
                         604800 )       ; TTL de caché negativo

        IN      NS      ns.internal.falcot.com.

; 192.168.0.1 -&gt; arrakis
1.0     IN      PTR     arrakis.internal.falcot.com.
; 192.168.0.2 -&gt; neptune
2.0     IN      PTR     neptune.internal.falcot.com.

; 192.168.3.1 -&gt; pau
1.3     IN      PTR     pau.internal.falcot.com.</programlisting>
      </example>
    </section>
  </section>
  <section id="sect.dhcp">
    <title>DHCP</title>

    <para>DHCP (<emphasis>procolo de configuración dinámica de equipos</emphasis>: «Dynamic Host Configuration Protocol») es un protocolo mediante el cual una máquina puede obtener su configuración de red automáticamente al iniciar. Esto permite centralizar la administración de las configuraciones de red y asegurar que todos los equipos de escritorio obtengan configuraciones similares.</para>
    <indexterm><primary>DHCP</primary></indexterm>
    <indexterm><primary>Dynamic Host Configuration Protocol</primary></indexterm>
    <indexterm><primary>red</primary><secondary>configuración DHCP</secondary></indexterm>

    <para>Un servidor DHCP provee muchos parámetros relacionados con la red. Los más comunes son una dirección IP y la red a la que pertenece el equipo, pero también puede proveer otra información como servidores DNS, servidores WINS, servidores NTP y más.</para>

    <para>El Internet Software Consortium (involucrado también en el desarrollo de <command>bind</command>) es el autor principal del servidor DHCP. El paquete Debian correspondiente es <emphasis role="pkg">isc-dhcp-server</emphasis>.</para>

    <section id="sect.dhcp-config">
      <title>Configuración</title>

      <para>El primer elemento que necesita editar en el archivo de configuración del servidor DHCP (<filename>/etc/dhcp/dhcpd.conf</filename>) son el nombre de dominio y servidores DNS. Si el servidor es el único en la red local (definido en la propagación de difusión), de activar (o descomentar) la directiva <literal>authoritative</literal>. También necesita crear una sección <literal>subnet</literal> (subred) describiendo la red local y la información de configuración que proveerá. El siguiente ejemplo define una red local <literal>192.168.0.0/24</literal> con un router en <literal>192.168.0.1</literal> como puerta de enlace. Las direcciones IP disponibles están en el rango <literal>192.168.0.128</literal> a <literal>192.168.0.254</literal>.</para>

      <example id="example.dhcp-dhcpd.conf">
        <title>Extracto de <filename>/etc/dhcp/dhcpd.conf</filename></title>

        <programlisting>
#
# Archivo de configuración de ejemplo para el dhcpd ISC para Debian
#

# El parámetro ddns-updates-style controla si el servidor intentará o no
# una actualización de DNS cuando se confirme la asignación. Utilizamos
# el comportamiento predeterminado de la versión 2 de paquetes ('none', 
# ya que DHCP v2 no era compatible con DDNS).
ddns-update-style interim;

# Definición de opciones comunes a todas las redes...
option domain-name "internal.falcot.com";
option domain-name-servers ns.internal.falcot.com;

default-lease-time 600;
max-lease-time 7200;

# Si este servidor DHCP es el servidor DHCP oficial para la red local,
# debe descomentar la directiva «authoritative».
authoritative;

# Utilice esto para enviar mensajes de registro dhcp a un archivo de
# registro distinto (también deberá modificar syslog.conf para completar
# la redirección).
log-facility local7;

# Mi subred
subnet 192.168.0.0 netmask 255.255.255.0 {
    option routers 192.168.0.1;
    option broadcast-address 192.168.0.255;
    range 192.168.0.128 192.168.0.254;
    ddns-domainname "internal.falcot.com";
}</programlisting>
      </example>
    </section>
    <section id="sect.dhcp-dns">
      <title>DHCP y DNS</title>
      <indexterm><primary>DNS</primary><secondary>actualizaciones automáticas</secondary></indexterm>

      <para>Una buena funcionalidad es el registro automatizado de clientes DHCP en la zona DNS para que cada máquina obtenga un nombre significativo (en lugar de algo impersonal como <literal>maquina-192-168-0-131.internal.falcot.com</literal>). Para utilizar esta funcionalidad necesita configurar el servidor DNS para que acepte actualizaciones de la zona DNS <literal>internal.falcot.com</literal> desde el servidor DHCP y configurar este último para que envíe actualizaciones para cada registración.</para>

      <para>En el caso de <command>bind</command>, necesita agregar la directiva <literal>allow-update</literal> a cada una de las zonas que puede editar el servidor DHCP (sólo el dominio <literal>internal.falcot.com</literal> y su zona inversa). Esta directiva enumera las direcciones IP que pueden realizar estas actualizaciones; por lo tanto deberá incluir las posibles direcciones del servidor DHCP (tanto la dirección local como la dirección pública en caso que sea apropiado).</para>

      <programlisting>
allow-update { 127.0.0.1 192.168.0.1 212.94.201.10 !any };</programlisting>

      <para>¡Tenga cuidado! Una zona que pueda ser modificada <emphasis>será</emphasis> modificada por <command>bind</command>, y éste último sobreescribirá sus archivos de configuración en intervalos regulares. Debido a que este procedimiento automatizado genera archivos que son menos legibles que aquellos escritos manualmente, los administradores de Falcot administran el dominio <literal>internal.falcot.com</literal> con un servidor DNS delegado; esto significa que el archivo de la zona <literal>falcot.com</literal> se mantiene firmemente bajo su control manual.</para>

      <para>El extracto de la configuración del servidor DHCP anterior ya incluye las directivas necesarias para las actualizaciones de la zona DNS: son las líneas <literal>ddns-update-style interim;</literal> y <literal>ddns-domain-name "internal.falcot.com";</literal> en el bloque que describe la subred.</para>
    </section>
  </section>
  <section id="sect.network-diagnosis-tools">
    <title>Herramientas de diagnóstico de red</title>

    <para>Cuando una aplicación de red no funciona como esperamos es importante poder ver «bajo el capó». Aún cuando todo parezca estar funcionando, realizar un diagnóstico de red puede ayudar a asegurar que todo está funcionando como debe. Existen muchas herramientas de diagnóstico para este propósito, cada una de las cuales opera en un nivel diferente.</para>
    <section id="sect.netstat">
      <title>Diagnóstico local: <command>netstat</command></title>
      <indexterm><primary><command>netstat</command></primary></indexterm>

      <para>Mencionemos primero el programa <command>netstat</command> (en el paquete <emphasis role="pkg">net-tools</emphasis>); muestra un resumen instantáneo de la actividad de red de una máquina. Cuando lo ejecute sin parámetros, mostrará todas las conexiones abiertas; esta lista puede ser demasiado detallada ya que incluye muchos zócalos de dominio Unix (utilizados ampliamente por demonios) que no incluyen la red en absoluto (por ejemplo, la comunicación de <literal>dbus</literal>, tráfico <literal>X11</literal> y comunicaciones entre sistemas de archivos virtuales y el escritorio).</para>

      <para>Por lo tanto, invocaciones usuales utilizan opciones que modifican el comportamiento de <command>netstat</command>. Las opciones utilizadas más frecuentemente incluyen:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>-t</literal>, que filtra los resultados para incluir sólamente conexiones TCP;</para>
        </listitem>
        <listitem>
	  <para><literal>-u</literal>, que realiza algo similar por las conexiones UDP; estas opciones no son mutuamente excluyentes y una de ellas es suficiente para evitar mostrar información sobre conexiones de dominio Unix;</para>
        </listitem>
        <listitem>
	  <para><literal>-a</literal>, para mostrar también los zócalos que están escuchando (que esperan conexiones entrantes);</para>
        </listitem>
        <listitem>
	  <para><literal>-n</literal>, para mostrar los resultados numéricamente: direcciones IP (sin resolución DNS), números de puerto (sin alias definidos en <filename>/etc/services</filename>) y IDs de usuario (sin nombres de usuario);</para>
        </listitem>
        <listitem>
	  <para><literal>-p</literal>, enumerar los procesos involucrados; esta opción sólo es útil cuando ejecute <command>netstat</command> como root ya que los usuarios normales sólo verán sus propios procesos;</para>
        </listitem>
        <listitem>
	  <para><literal>-c</literal>, para actualizar continuamente la lista de conexiones.</para>
        </listitem>
      </itemizedlist>

      <para>Otras opciones, documentadas en la página de manual <citerefentry><refentrytitle>netstat</refentrytitle> <manvolnum>8</manvolnum></citerefentry>, proveen un control más granular en los resultados mostrados. En la práctica,las primeras cinco opciones son utilizadas juntas tan seguido que los administradores de sistemas y red tiene el acto reflejo de ejecutar <command>netstat -tupan</command>. Los resultados típicos, en una máquina con poca carga, pueden parecerse a lo siguiente:</para>

      <screen role="scale">
<computeroutput># </computeroutput><userinput>netstat -tupan</userinput>
<computeroutput>Conexiones activas de Internet (servidores y establecidas)
Proto Reciv-Q Enviado-Q Dirección Local           Dirección externa         Estado PID/Nombre programa
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      397/rpcbind     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      431/sshd        
tcp        0      0 0.0.0.0:36568           0.0.0.0:*               LISTEN      407/rpc.statd   
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      762/exim4       
tcp        0    272 192.168.1.242:22        192.168.1.129:44452     ESTABLISHED 1172/sshd: roland [
tcp6       0      0 :::111                  :::*                    LISTEN      397/rpcbind     
tcp6       0      0 :::22                   :::*                    LISTEN      431/sshd        
tcp6       0      0 ::1:25                  :::*                    LISTEN      762/exim4       
tcp6       0      0 :::35210                :::*                    LISTEN      407/rpc.statd   
udp        0      0 0.0.0.0:39376           0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:996             0.0.0.0:*                           397/rpcbind     
udp        0      0 127.0.0.1:1007          0.0.0.0:*                           407/rpc.statd   
udp        0      0 0.0.0.0:68              0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:48720           0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:111             0.0.0.0:*                           397/rpcbind     
udp        0      0 192.168.1.242:123       0.0.0.0:*                           539/ntpd        
udp        0      0 127.0.0.1:123           0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:123             0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:5353            0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:39172           0.0.0.0:*                           407/rpc.statd   
udp6       0      0 :::996                  :::*                                397/rpcbind     
udp6       0      0 :::34277                :::*                                407/rpc.statd   
udp6       0      0 :::54852                :::*                                916/dhclient    
udp6       0      0 :::111                  :::*                                397/rpcbind     
udp6       0      0 :::38007                :::*                                451/avahi-daemon: r
udp6       0      0 fe80::5054:ff:fe99::123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:a:123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:5:123 :::*                                539/ntpd        
udp6       0      0 ::1:123                 :::*                                539/ntpd        
udp6       0      0 :::123                  :::*                                539/ntpd        
udp6       0      0 :::5353                 :::*                                451/avahi-daemon: r
</computeroutput></screen>

      <para>Como es esperado, enumera las conexiones establecidas: dos conexiones SSH en este caso y las aplicaciones esperando conexiones entrantes (mostradas como <literal>LISTEN</literal>), notablemente el servidor de correo Exim4 está escuchando en el puerto 25.</para>
    </section>
    <section id="sect.nmap">
      <title>Diagnóstico remoto: <command>nmap</command></title>
      <indexterm><primary><command>nmap</command></primary></indexterm>

      <para><command>nmap</command> (en el paquete del mismo nombre) es, en cierta forma, el equivalente remoto de <command>netstat</command>. Puede escanear un conjunto de puertos «muy conocidos» de uno o más servidores remotos y enumerar los puertos donde encontró una aplicación que responda conexiones entrantes. Lo que es más, <command>nmap</command> puede identificar alguna de estas aplicaciones, a veces inclusive también su número de versión. La desventaja de esta herramienta es que, debido a que ejecuta de forma remota, no puede proveer información sobre procesos o usuarios; sin embargo, puede trabajar con varios objetivos al mismo tiempo.</para>

      <para>Una invocación de <command>nmap</command> típica utilizará la opción <literal>-A</literal> (para que <command>nmap</command> intente identificar las versiones del software de servidor que encuentre) seguido de una o más direcciones IP o nombres DNS de los equipos a escanear. Nuevamente, existen muchas más opciones que proveen un control detallado del comportamiento de <command>nmap</command>; revise la documentación en la página de manual <citerefentry> <refentrytitle>nmap</refentrytitle> <manvolnum>1</manvolnum> </citerefentry>.</para>

      <screen role="scale" width="80">
<computeroutput># </computeroutput><userinput>nmap mirtuel</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET
Nmap scan report for mirtuel (192.168.1.242)
Host is up (0.000013s latency).
rDNS record for 192.168.1.242: mirtuel.internal.placard.fr.eu.org
Not shown: 998 closed ports
PORT    STATE SERVICE
22/tcp  open  ssh
111/tcp open  rpcbind

Nmap done: 1 IP address (1 host up) scanned in 2.41 seconds
# </computeroutput><userinput>nmap -A localhost</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000013s latency).
Other addresses for localhost (not scanned): 127.0.0.1
Not shown: 997 closed ports
PORT    STATE SERVICE VERSION
22/tcp  open  ssh     OpenSSH 6.7p1 Debian 3 (protocol 2.0)
|_ssh-hostkey: ERROR: Script execution failed (use -d to debug)
25/tcp  open  smtp    Exim smtpd 4.84
| smtp-commands: mirtuel Hello localhost [127.0.0.1], SIZE 52428800, 8BITMIME, PIPELINING, HELP, 
|_ Commands supported: AUTH HELO EHLO MAIL RCPT DATA NOOP QUIT RSET HELP 
111/tcp open  rpcbind 2-4 (RPC #100000)
| rpcinfo: 
|   program version   port/proto  service
|   100000  2,3,4        111/tcp  rpcbind
|   100000  2,3,4        111/udp  rpcbind
|   100024  1          36568/tcp  status
|_  100024  1          39172/udp  status
Device type: general purpose
Running: Linux 3.X
OS CPE: cpe:/o:linux:linux_kernel:3
OS details: Linux 3.7 - 3.15
Network Distance: 0 hops
Service Info: Host: mirtuel; OS: Linux; CPE: cpe:/o:linux:linux_kernel

OS and Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 11.54 seconds
</computeroutput></screen>

      <para>Como es esperado, se muestran las aplicaciones SSH y Exim4. Sepa que no todas las aplicaciones escuchan en todas las direcciones IP; debido a que sólo se puede acceder a Exim4 mediante la interfaz de «loopback» <literal>lo</literal>, sólo aparecerá durante un análisis de <literal>localhost</literal> pero no cuando se escanea <literal>mirtuel</literal> (asociado con la interfaz <literal>eth0</literal> del mismo equipo).</para>
    </section>
    <section id="sect.sniffers">
      <title>«Sniffers»: <command>tcpdump</command> y <command>wireshark</command></title>

      <para>A veces uno necesita revisar lo que sucede literalmente en el cable, paquete por paquete. Estos casos requieren un «analizador de tramas», más comúnmente conocidos como «<emphasis>sniffers</emphasis>». Estas herramientas observan todos los paquetes en una interfaz de red dada y los muestran en una forma más amigable.</para>
      <indexterm><primary><command>tcpdump</command></primary></indexterm>

      <para>La herramienta de culto en este ámbito es <command>tcpdump</command>, disponible como una herramienta estándar en un amplio rango de plataformas. Permite muchos tipos de capturas de tráfico de red, pero la representación del mismo es bastante críptica. Por lo tanto no la describiremos en más detalle.</para>
      <indexterm><primary><command>wireshark</command></primary></indexterm>

      <para>Una herramienta más reciente (y más moderna), <command>wireshark</command> (en el paquete <emphasis role="pkg">wireshark</emphasis>), se ha convertido en la nueva referencia de análisis de tráfico de red debido a sus módulos de decodificación que permiten un análisis simplificado de los paquetes capturados. Muestra los paquetes gráficamente, organizados basándose en las capas de protocolos. Esto permite al usuario visualizar todos los protocolos involucrados en un paquete. Por ejemplo, en un paquete que contenga un pedido HTTP, <command>wireshark</command> mostrará por separado la información sobre la capa física, la capa Ethernet, la información IP del paquete, los parámetros de conexión TCP y finalmente el pedido HTTP mismo.</para>

      <figure id="figure.wireshark">
        <title>El analizador de tráfico de red <command>wireshark</command></title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/wireshark.png" scalefit="1" width="75%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>En nuestro ejemplo, filtramos los paquetes que viajan sobre SSH (con el filtro <literal>!tcp.port == 22</literal>). El paquete mostrado tiene expandida la capa HTTP.</para>

      <sidebar>
        <title><emphasis>SUGERENCIA</emphasis> <command>wireshark</command> sin interfaz gráfica: <command>tshark</command></title>
        <indexterm><primary><command>tshark</command></primary></indexterm>

	<para>Cuando no podemos ejecutar una interfaz gráfica, o por cualquier razón no deseamos hacerlo, existe una versión sólo de texto de <command>wireshark</command> bajo el nombre <command>tshark</command> (en el paquete independiente <emphasis role="pkg">tshark</emphasis>). La mayoría de la funcionalidad de captura y decodificación está también disponible, pero la falta de interfaz gráfica limita necesariamente la interacción con el programa (filtrar paquetes luego de capturarlos, rastrear una conexión TCP, etc.). Puede utilizarse, sin embargo, como primer intento. Si desea realizar manipulaciones y necesita la interfaz gráfica, puede guardar los paquetes en un archivo y cargarlo en un <command>wireshark</command> gráfico ejecutando en otra máquina.</para>
      </sidebar>
    </section>
  </section>
</chapter>
