<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.11. Conexión en caliente: hotplug</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-es-ES-1.0-1" /><meta
        name="keywords"
        content="Arranque del sistema, Scripts de inicio, SSH, Telnet, Derechos, Permisos, Supervisión, Inetd, Cron, Respaldo, Conexión en caliente («hotplug»), PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="El manual del Administrador de Debian" /><link
        rel="up"
        href="unix-services.html"
        title="Capítulo 9. Servicios Unix" /><link
        rel="prev"
        href="sect.backup.html"
        title="9.10. Respaldo" /><link
        rel="next"
        href="sect.power-management.html"
        title="9.12. Gestión de energía: interfaz avanzada de configuración y energía (ACPI: «Advanced Configuration and Power Interface)" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/es-ES/stable/sect.hotplug.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.backup.html"><strong>Anterior</strong></a></li><li
          class="home">El manual del Administrador de Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.power-management.html"><strong>Siguiente</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.hotplug"></a>9.11. Conexión en caliente: <span
                  class="emphasis"><em>hotplug</em></span></h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.2"></a>9.11.1. Introducción</h3></div></div></div><div
            class="para">
				El subsistema <span
              class="emphasis"><em>hotplug</em></span> del núcleo administra dinámicamente el agregar y eliminar dispositivos mediante la carga de los controladores apropiados y la creación de los archivos de dispositivo correspondientes (con la ayuda de <code
              class="command">udevd</code>). Con el hardware moderno y la virtualización, casi todo puede ser conectado en caliente: desde los periféricos USB/PCMCIA/IEEE 1394 usuales hasta discos duros SATA, pero también la CPU y la memoria.
			</div><div
            class="para">
				El núcleo tiene una base de datos que asocia cada ID de dispositivo con el controlador necesario. Se utiliza esta base de datos durante el inicio para cargar todos los controladores de los periféricos detectados en los diferentes canales, pero también cuando se conecta un dispositivo en caliente. Una vez el dispositivo está listo para ser utilizado se envía un mensaje a <code
              class="command">udevd</code> para que pueda crear los elementos correspondientes en <code
              class="filename">/dev/</code>.
			</div><a
            id="id-1.12.14.2.4"
            class="indexterm"></a><a
            id="id-1.12.14.2.5"
            class="indexterm"></a><a
            id="id-1.12.14.2.6"
            class="indexterm"></a><a
            id="id-1.12.14.2.7"
            class="indexterm"></a><a
            id="id-1.12.14.2.8"
            class="indexterm"></a><a
            id="id-1.12.14.2.9"
            class="indexterm"></a></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.3"></a>9.11.2. El problema de nombres</h3></div></div></div><div
            class="para">
				Antes que existieran las conexiones en caliente, era sencillo asignar un nombre fijo a un dispositivo. Simplemente estaba basado en la posición del dispositivo en su canal correspondiente. Pero esto no es posible cuando dichos dispositivos puede aparecer y desaparecer del canal. El caso típico es el uso de una cámara digital y una llave USB, ambos serán un disco para el equipo. El primero en conectarse puede ser <code
              class="filename">/dev/sdb</code> y el segundo <code
              class="filename">/dev/sdc</code> (siempre que <code
              class="filename">/dev/sda</code> represente el disco duro del equipo en sí). El nombre del dispositivo no es fijo, depende del orden en el que se conecte los dispositivos.
			</div><div
            class="para">
				Además, más y más controladores utilizan valores dinámicos para los números mayor/menor de los dispositivos, lo que hace imposible tener elementos estáticos para dichos dispositivos ya que estas características esenciales puede cambiar luego de reiniciar el equipo.
			</div><div
            class="para">
				Se creó <span
              class="emphasis"><em>udev</em></span> precisamente para solucionar este problema.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.4"></a>9.11.3. Cómo funciona <span
                    class="emphasis"><em>udev</em></span></h3></div></div></div><div
            class="para">
				Cuando el núcleo le informa a <span
              class="emphasis"><em>udev</em></span> de la aparición de un nuevo dispositivo, recolecta mucha información sobre el dispositivo consultando los elementos correspondientes en <code
              class="filename">/sys/</code>; especialmente aquellos que lo identifican unívocamente (dirección MAC para una tarjeta de red, número de serie para algunos dispositivos USB, etc.).
			</div><div
            class="para">
				Con esta información, <span
              class="emphasis"><em>udev</em></span> luego consulta todas las reglas en <code
              class="filename">/etc/udev/rules.d</code> y <code
              class="filename">/lib/udev/rules.d</code>. En este proceso decide cómo nombrar al dispositivo, los enlaces simbólicos que creará (para darle nombres alternativos) y los programas que ejecutará. Se consultan todos estos archivos y se evalúan las reglas secuencialmente (excepto cuando un archivo utiliza la directiva «GOTO»). Por lo tanto, puede haber varias reglas que correspondan a un evento dado.
			</div><div
            class="para">
				La sintaxis de los archivos de reglas es bastante simple: cada fila contiene criterios de selección y asignaciones de variables. El primero se utiliza para seleccionar los eventos ante los que reaccionar y el último define las acciones a tomar. Se los separa simplemente con comas y el operador implícitamente diferencia entre un criterio de selección (con operaciones de comparación como <code
              class="literal">==</code> o <code
              class="literal">!=</code>) o una directiva de asignación (con operadores como <code
              class="literal">=</code>, <code
              class="literal">+=</code> o <code
              class="literal">:=</code>).
			</div><div
            class="para">
				Se utilizan los operadores de comparación en las siguientes variables:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">KERNEL</code>: el nombre que el núcleo le asigna al dispositivo;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">ACTION</code>: la acción que corresponde al evento («add» cuando se agregó un dispositivo, «remove» cuando fue eliminado);
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">DEVPATH</code>: la ruta al elemento del dispositivo en <code
                    class="filename">/sys/</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">SUBSYSTEM</code>: el subsistema del núcleo que generó el pedido (hay muchos, pero unos pocos ejemplos son «usb», «ide», «net», «firmware», etc.);
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">ATTR{<em
                      class="replaceable">atributo</em>}</code>: el contenido del archivo <em
                    class="replaceable">attribute</em> en el directorio <code
                    class="filename">/sys/<em
                      class="replaceable">ruta_de_dispositivo</em>/</code> del dispositivo. Aquí es donde encontrará la dirección MAC y otros identificadores específicos del canal;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">KERNELS</code>, <code
                    class="literal">SUBSYSTEMS</code> y <code
                    class="literal">ATTRS{<em
                      class="replaceable">atributos</em>}</code> son variaciones que intentarán coincidir las diferentes opciones en alguno de los dispositivos padre del dispositivo actual;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">PROGRAM</code>: delega la prueba al programa indicado (coincidirá si devuelve 0, no lo hará de lo contrario). Se almacenará el contenido de la salida estándar del programa para que pueda utilizarse en la prueba <code
                    class="literal">RESULT</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">RESULT</code>: ejecuta pruebas en la salida estándar almacenada durante la última ejecución de una sentencia <code
                    class="literal">PROGRAM</code>.
					</div></li></ul></div><div
            class="para">
				Los operadores correctos puede utilizar expresiones con patrones para que coincidan varios valores simultáneamente. Por ejemplo, <code
              class="literal">*</code> coincide con cualquier cadena (inclusive una vacía); <code
              class="literal">?</code> coincide con cualquier carácter y <code
              class="literal">[]</code> coincide el conjunto de caracteres enumerados entre los corchetes (lo opuesto si el primer carácter es un signo de exclamación y puede indicar rangos de caracteres de forma similar a <code
              class="literal">a-z</code>).
			</div><div
            class="para">
				En cuanto a los operadores de asignación, <code
              class="literal">=</code> asigna un valor (y reemplaza el valor actual); en el caso de una lista, es vaciada y sólo contendrá el valor asignado. <code
              class="literal">:=</code> realiza lo mismo pero evita cambios futuros en la misma variable. Respecto a <code
              class="literal">+=</code>, agrega elementos a una lista. Puede modificar las siguientes variables:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">NAME</code>: el nombre del archivo de dispositivo que se creará en <code
                    class="filename">/dev/</code>. Sólo se tiene en cuenta la primera asignación, las demás son ignoradas;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">SYMLINK</code>: la lista de enlaces simbólicos que apuntarán al mismo dispositivo;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">OWNER</code>, <code
                    class="literal">GROUP</code> y <code
                    class="literal">MODE</code> definen el usuario y el grupo dueños del dispositivo así como también los permisos asociados, respectivamente;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">RUN</code>: la lista de programas a ejecutar en respuesta a este evento.
					</div></li></ul></div><div
            class="para">
				Los valores asignados a estas variables pueden utilizar algunas substituciones:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$kernel</code> o <code
                    class="literal">%k</code>: equivalente a <code
                    class="literal">KERNEL</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$number</code> o <code
                    class="literal">%n</code>: el número de orden del dispositivo; por ejemplo, para <code
                    class="literal">sda3</code> sería «3»;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$devpath</code> o <code
                    class="literal">%p</code>: equivalente a <code
                    class="literal">DEVPATH</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$attr{<em
                      class="replaceable">atributo</em>}</code> o <code
                    class="literal">%s{<em
                      class="replaceable">atributo</em>}</code>: equivalentes a <code
                    class="literal">ATTRS{<em
                      class="replaceable">atributo</em>}</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$major</code> o <code
                    class="literal">%M</code>: el número mayor del dispositivo en el núcleo;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$mior</code> o <code
                    class="literal">%m</code>: el número menor del dispositivo en el núcleo;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$result</code> o <code
                    class="literal">%c</code>: la cadena de salida del último programa ejecutado por <code
                    class="literal">PROGRAM</code>;
					</div></li><li
                class="listitem"><div
                  class="para">
						finalmente, <code
                    class="literal">%%</code> y <code
                    class="literal">$$</code> para los signos de porcentaje y el símbolo de moneda respectivamente.
					</div></li></ul></div><div
            class="para">
				La lista anterior no está completa (sólo incluye los parámetros más importantes), pero la página de manual <span
              class="citerefentry"><span
                class="refentrytitle">udev</span>(7)</span> debería serlo.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.5"></a>9.11.4. Un ejemplo concreto</h3></div></div></div><div
            class="para">
				Consideremos el caso de una simple llave USB e intentemos asignarle un nombre fijo. Primero debe encontrar los elementos que la identificarán de manera unívoca. Para ello, conéctela y ejecuta <code
              class="command">udevadm info -a -n /dev/sdc</code> (reemplazando <em
              class="replaceable">/dev/sdc</em> con el nombre real asignado a la llave).
			</div><pre
            class="screen"><code
              class="computeroutput"># </code><strong
              class="userinput"><code>udevadm info -a -n /dev/sdc</code></strong>
<code
              class="computeroutput">[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</code></pre><div
            class="para">
				Para crear una nueva regla, puede utilizar las pruebas en las variables del dispositivo así como también en los dispositivos padre. El caso anterior le permite crear dos reglas como las siguientes:
			</div><pre
            class="programlisting">KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"</pre><div
            class="para">
				Una vez que haya guardado estas reglas en un archivo, llamado por ejemplo <code
              class="filename">/etc/udev/rules.d</code>, puede desconectar y conectar la llave USB. Podrá ver que <code
              class="filename">/dev/usb_key/disk</code> representa el disco asociado con la llave USB y <code
              class="filename">/dev/usb_key/part1</code> como su primera partición.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>YENDO MÁS ALLÁ</em></span> Depuración de la configuración de <span
                        class="emphasis"><em>udev</em></span></strong></p></div></div></div><div
              class="para">
				Al igual que muchos demonios, <code
                class="command">udevd</code> almacena registros en <code
                class="filename">/var/log/daemon.log</code>. Pero no es muy descriptivo de forma predeterminada y generalmente no son suficientes para entender lo que está sucediendo. Ejecutar <code
                class="command">udevadm control --log-priority=info</code> aumenta el nivel de información y soluciona este problema. <code
                class="command">udevadm control --log-priority=err</code> vuelve al valor predeterminado.
			</div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.backup.html"><strong>Anterior</strong>9.10. Respaldo</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Subir</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Inicio</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.power-management.html"><strong>Siguiente</strong>9.12. Gestión de energía: interfaz avanzada de co...</a></li></ul></body></html>
