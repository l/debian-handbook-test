<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.2. Inicio de sesión remoto</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-es-ES-1.0-1" /><meta
        name="keywords"
        content="Arranque del sistema, Scripts de inicio, SSH, Telnet, Derechos, Permisos, Supervisión, Inetd, Cron, Respaldo, Conexión en caliente («hotplug»), PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="El manual del Administrador de Debian" /><link
        rel="up"
        href="unix-services.html"
        title="Capítulo 9. Servicios Unix" /><link
        rel="prev"
        href="unix-services.html"
        title="Capítulo 9. Servicios Unix" /><link
        rel="next"
        href="sect.rights-management.html"
        title="9.3. Administración de permisos" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/es-ES/stable/sect.remote-login.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Anterior</strong></a></li><li
          class="home">El manual del Administrador de Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Siguiente</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.remote-login"></a>9.2. Inicio de sesión remoto</h2></div></div></div><div
          class="para">
			Es esencial para el administrador poder conectarse a un equipo de forma remota. Los servidores, aislados en su propia habitación, rara vez están equipados con monitores y teclados permanentes — pero están conectados a la red.
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>VOLVER A LOS CIMIENTOS</em></span> Cliente, servidor</strong></p></div></div></div><a
            id="id-1.12.5.3.2"
            class="indexterm"></a><a
            id="id-1.12.5.3.3"
            class="indexterm"></a><div
            class="para">
			Generalmente se describe a un sistema en el que varios procesos se comunican entre ellos con la metáfora «cliente/servidor». El servidor es el programa que toma y ejecuta los pedidos que provienen de un cliente. Es el cliente el que controla la operación, el servidor no tiene iniciativa propia.
		</div></div><a
          id="id-1.12.5.4"
          class="indexterm"></a><a
          id="id-1.12.5.5"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ssh"></a>9.2.1. Inicio seguro de sesión remota: SSH</h3></div></div></div><a
            id="id-1.12.5.6.2"
            class="indexterm"></a><a
            id="id-1.12.5.6.3"
            class="indexterm"></a><div
            class="para">
				El protocolo <span
              class="emphasis"><em>SSH</em></span> (interprete de órdenes seguro: «Secure SHell») fue diseñado pensando en la seguridad y la confiabilidad. Las conexiones que utilizan SSH son seguras: la otra parte es autenticada y se cifran todos los datos intercambiados.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURA</em></span> Telnet y RSH son obsoletos</strong></p></div></div></div><a
              id="id-1.12.5.6.5.2"
              class="indexterm"></a><a
              id="id-1.12.5.6.5.3"
              class="indexterm"></a><div
              class="para">
				Antes de SSH, <span
                class="emphasis"><em>Telnet</em></span> y <span
                class="emphasis"><em>RSH</em></span> eran las principales herramientas para sesiones remotas. Actualmente son generalmente obsoletas y no debería utilizarlas aún cuando Debian todavía las provee.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOCABULARIO</em></span> Autenticación, cifrado</strong></p></div></div></div><div
              class="para">
				Cuando necesita proveerle a un cliente la capacidad de realizar o desencadenar acciones en un servidor, la seguridad es importante. Debe asegurar la identidad del cliente; esto es autenticación. Esta identidad generalmente consisten en una constraseña que debe mantenerse en secreto o cualquier otro cliente podría obtener la contraseña. Este es el propósito del cifrado, que es una forma de codificación que permite a dos sistemas intercambiar información confidencial en un canal público al mismo tiempo que la protege de que otros la puedan leer.
			</div><div
              class="para">
				Frecuentemente se nombran a la autenticación y al cifrado en conjunto, tanto porque se los utiliza a ambos como porque generalmente son implementados con conceptos matemáticos similares.
			</div></div><div
            class="para">
				SSH también ofrece dos servicios de transferencia de archivos. <code
              class="command">scp</code> es una herramienta para la terminal que puede utilizar como <code
              class="command">cp</code> excepto que cualquier ruta a otro equipo utilizará un prefijo con el nombre de la máquina seguido de dos puntos («:»).
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>scp archivo equipo:/tmp/</code></strong></pre><div
            class="para">
				<code
              class="command">sftp</code> es un programa interactivo similar a <code
              class="command">ftp</code>. En una sola sesión <code
              class="command">sftp</code> puede transferir varios archivos y es posible manipular archivos remotos con él (eliminar, renombrar, cambiar permisos, etc.).
			</div><a
            id="id-1.12.5.6.10"
            class="indexterm"></a><a
            id="id-1.12.5.6.11"
            class="indexterm"></a><div
            class="para">
				Debian utiliza OpenSSH, una versión libre de SSH mantenida por el proyecto <code
              class="command">OpenBSD</code> (un sistema operativo libre basado en el núcleo BSD enfocado en seguridad) que es una bifurcación («fork») del software SSH original desarrollado por la empresa SSH Communications Security Corp de Finlandia. Esta empresa inicialmente desarrolló SSH como software libre pero eventualmente decidió continuar su desarrollo bajo una licencia privativa. El proyecto OpenBSD luego creó OpenSSH para mentener una versión libre de SSH.
			</div><a
            id="id-1.12.5.6.13"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOLVER A LOS CIMIENTOS</em></span> Bifurcación: «<span
                        class="foreignphrase"><em
                          class="foreignphrase">fork</em></span>»</strong></p></div></div></div><a
              id="id-1.12.5.6.14.2"
              class="indexterm"></a><div
              class="para">
				Una bifurcación («fork»), en el campo de software, significa que comienza un nuevo proyecto como clon de un proyecto existente y que competirá con él. Desde allí, ambos programas generalmente divergirán rápidamente en términos de nuevos desarrollos. Por lo general son un resultado de desacuerdos dentro del equipo de desarrollo.
			</div><div
              class="para">
				La opción de bifurcar un proyecto es un resultado directo de la naturaleza misma del software libre; es un evento saludable cuando permite la continuación de un proyecto como software libre (por ejemplo, en el caso de cambios de licencia). Una bifurcación generada por desacuerdos técnicos o personales usualmente es un desperdicio de recursos; se prefiere otra solución. También ocurren fusiones de dos proyectos que anteriormente habían bifurcado.
			</div></div><div
            class="para">
				OpenSSH está dividido en dos paquetes: la parte del cliente se encuentra en el paquete <span
              class="pkg pkg">openssh-client</span> y el servidor en el paquete <span
              class="pkg pkg">openssh-server</span>. El metapaquete <span
              class="pkg pkg">ssh</span> depende de ambas partes y facilita la instalación conjunta (<code
              class="command">apt install ssh</code>).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-key-based-auth"></a>9.2.1.1. Autenticación basada en llaves</h4></div></div></div><div
              class="para">
					Cada vez que alguien inicia sesión a través de SSH, el servidor remoto pide una contraseña para autenticar al usuario. Esto puede ser problemático si desea automatizar la conexión o si utiliza una herramienta que necesita conexiones frecuentes sobre SSH. Es por esto que SSH ofrece un sistema de autenticación basada en llaves.
				</div><div
              class="para">
					El usuario genera un par de llaves en la máquina cliente con <code
                class="command">ssh-keygen -t rsa</code>; la llave pública se almacena en <code
                class="filename">~/.ssh/id_rsa.pub</code> mientras que la llave privada correspondiente estará almacenada en <code
                class="filename">~/.ssh/id_rsa</code>. Luego, el usuario utiliza <code
                class="command">ssh-copy-id <em
                  class="replaceable">servidor</em></code> para agregar su llave pública al archivo <code
                class="filename">~/.ssh/authorized_keys</code> en el servidor. Si no se protegió la llave privada con una «frase de contraseña» al momento de crearla, todos los inicios de sesión siguientes al servidor funcionarán sin contraseña. De lo contrario, debe descifrar la llave privada cada vez ingresando la frase de contraseña. Afortunadamente, <code
                class="command">ssh-agent</code> permite mantener llaves privadas en memoria para no tener que ingresar la frase de contraseña regularmente. Para ello, simplemente utilizaría <code
                class="command">ssh-add</code> (una vez por sesión de trabajo) siempre que la sesión ya esté asociada con una instancia funcional de <code
                class="command">ssh-agent</code>. De forma predeterminada, Debian activa este comportamiento en sesiones gráficas pero lo puede desactivar cambiando el archivo <code
                class="filename">/etc/X11/Xsession.options</code>. Para una sesión en consola, puede iniciarlo manualmente con <code
                class="command">eval $(ssh-agent)</code>.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SEGURIDAD</em></span> Protección de la llave privada</strong></p></div></div></div><div
                class="para">
					Quien posea la llave privada puede iniciar sesión con la cuenta configurada. Es por esto que se protege la llave privada con una «frase de contraseña». Quien obtenga una copia del archivo de la llave privada (por ejemplo, <code
                  class="filename">~/.ssh/id_rsa</code>) todavía tendrá que saber dicha frase para poder intentar utilizarla. Sin embargo, esta protección adicional no es infalible y es mejor deshabilitar la llave en aquellos equipos en las que la instaló (eliminándola de los archivos <code
                  class="filename">authorized_keys</code>) y reemplazándola con una nueva llave que haya generado.
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURA</em></span> Falla OpenSSL en Debian <span
                          class="distribution distribution">Etch</span></strong></p></div></div></div><div
                class="para">
					La biblioteca OpenSSL, como fue provista inicialmente en Debian <span
                  class="distribution distribution">Etch</span>, tenía un serio problema en su generador de números aleatorios (RNG: «Random Number Generator»). El desarrollador Debian había realizado una modificación para que los programas que la utilizan no generaran advertencias mientras eran objetivo de análisis por herramientas de pruebas de memoria como <code
                  class="command">valgrind</code>. Desafortunadamente, este cambio también significaba que el RNG sólo utilizaba una fuente de entropía que correspondía al número de proceso (PID); pero los 32000 valores posibles del mismo no ofrecen suficiente aleatoriedad. <div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="http://www.debian.org/security/2008/dsa-1571">http://www.debian.org/security/2008/dsa-1571</a></div>
				</div><div
                class="para">
					Específicamente, cuando utilizaba OpenSSL para generar una llave, siempre producía una llave dentro de un conjunto conocido de cientos de miles de llaves (32000 multiplicado por una pequeña cantidad de longitudes de llaves). Esto afectaba llaves SSH, llaves SSL y certificados X.509 utilizados por numerosas aplicaciones, como OpenVPN. Un «cracker» sólo debía intentar todas estas llaves para obtener un acceso no autorizado. Para reducir el impacto del problema, se modificó el demonio SSH para rechazar las llaves problemáticas incluidas en los paquetes <span
                  class="pkg pkg">openssh-blacklist</span> y <span
                  class="pkg pkg">openssh-blacklist-extra</span>. Además, el programa <code
                  class="command">ssh-vulnkey</code> permite identificar posibles llaves comprometidas en el sistema.
				</div><div
                class="para">
					Un análisis más detallado de este problema resaltó que era el resultado de múltiples problemas (pequeños) del proyecto OpenSSL y del encargado del paquete Debian. Una biblioteca tan utilizada como OpenSSL no debería — sin modificaciones — generar advertencias cuando es probada con <code
                  class="command">valgrind</code>. Lo que es más, el código (especialmente las partes tan sensibles como el RNG) deberían tener mejores comentarios para evitar estos errores. Por parte de Debian, el encargado quería validar las modificaciones con los desarrolladores de OpenSSL, pero simplemente explicó las modificaciones sin proporcionar el parche correspondiente para su revisión y se olvidó de mencionar su papel en Debian. Por último, las decisiones de mantenimiento no fueron las óptimas: los cambios en el código original no estaban comentados de forma clara; todas las modificaciones fueron almacenadas en un repositorio Subversion, pero terminaron agrupadas en un sólo parche durante la creación del paquete fuente.
				</div><div
                class="para">
					Bajo tales condiciones es difícil encontrar las medidas correctivas para evitar que ocurran incidentes similar. La lección a aprender aquí es que cada divergencia que Debian introduce al software de origen debe estar justificada, documentad, debe ser enviada al proyecto de origen cuando sea posible y publicitada ampliamente. Es desde esta perspectiva que se desarrollaron el nuevo formato de paquete fuente («3.0 (quilt)») y el servicio web de código fuente de Debian. <div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="http://sources.debian.net">http://sources.debian.net</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-x11"></a>9.2.1.2. Utilización aplicaciones X11 remotas</h4></div></div></div><div
              class="para">
					El protocolo SSH permite redirigir datos gráficos (sesión «X11» por el nombre del sistema gráfico más utilizado en Unix); el servidor luego mantiene un canal dedicado para estos datos. Específicamente, el programa gráfico ejecutado remotamente puede mostrarse en el servidor X.org de la pantalla local y toda la sesión (datos ingresados y lo que sea mostrado) será segura. De forma predeterminada, esta funcionalidad está desactivada porque permite que aplicaciones remotas interfieran con el sistema local. Puede activarla especificando <code
                class="literal">X11Forwarding yes</code> en el archivo de configuración del servidor (<code
                class="filename">/etc/ssh/sshd_config</code>). Finalmente, el usuario también debe solicitarlo agregando la opción <code
                class="literal">-X</code> al ejecutar <code
                class="command">ssh</code>.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-port-forwarding"></a>9.2.1.3. Creación de túneles cifrados con redirección de puertos</h4></div></div></div><a
              id="id-1.12.5.6.18.2"
              class="indexterm"></a><div
              class="para">
					Las opciones <code
                class="literal">-R</code> y <code
                class="literal">-L</code> le permiten a <code
                class="command">ssh</code> crear «túneles cifrados» entre dos equipos, redirigiendo de forma segura un puerto TCP local (revise el recuadro <a
                class="xref"
                href="network-infrastructure.html#sidebar.tcp-udp"><span
                  class="emphasis"><em>VOLVER A LOS CIMIENTOS</em></span> TCP/UDP</a>) a un equipo remoto o viceversa.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULARIO</em></span> Túnel</strong></p></div></div></div><a
                id="id-1.12.5.6.18.4.2"
                class="indexterm"></a><a
                id="id-1.12.5.6.18.4.3"
                class="indexterm"></a><div
                class="para">
					Internet, y la mayoría de las redes de área local conectadas a ella, funcionan bajo conmutación de paquetes y no bajo conmutación de circuitos, lo que significa que un paquete enviado de un equipo a otro será detenido en varios routers intermedios para encontrar su ruta al destino. Todavía puede simular el modo de conexión en el que el flujo esté encapsulado en paquetes IP normales. Estos paquetes siguen su ruta usual pero se reconstruye el flujo sin cambios en el destino. A esto le llamamos un «túnel», el análogo a un túnel vial en el que los vehículos conducen directamente desde la entrada a la salida sin encontrase con intersección alguna a diferencia de una ruta en la superficie que involucraría intersecciones y cambios de dirección.
				</div><div
                class="para">
					Puede utilizar esta oportunidad para agregar cifrado al túnel: así el flujo del mismo no puede ser reconocido desde el exterior, pero al salir del túnel se encuentra descifrado.
				</div></div><div
              class="para">
					<code
                class="command">ssh -L 8000:servidor:25 intermediario</code> establece una sesión SSH con el equipo <em
                class="replaceable">intermediario</em> y escucha en el puerto local 8000 (revise la <a
                class="xref"
                href="sect.remote-login.html#figure.ssh-L">Figura 9.3, “Redirección de un puerto local con SSH”</a>). Para cualquier conexión en este puerto, <code
                class="command">ssh</code> iniciará una conexión desde el equipo <em
                class="replaceable">intermediario</em> al puerto 25 de <em
                class="replaceable">servidor</em> y unirá ambas conexiones.
				</div><div
              class="para">
					<code
                class="command">ssh -R 8000:servidor:25 intermediario</code> también establece una sesión SSH al equipo <em
                class="replaceable">intermediario</em>, pero es en este equipo que <code
                class="command">ssh</code> escuchará en el puerto 8000 (revise la <a
                class="xref"
                href="sect.remote-login.html#figure.ssh-R">Figura 9.4, “Redirección de un puerto remoto con SSH”</a>). Cualquier conexión establecida en este puerto causará que <code
                class="command">ssh</code> abra una conexión desde el equipo local al puerto 25 de <em
                class="replaceable">servidor</em> y unirá ambas conexiones.
				</div><div
              class="para">
					En ambos casos, se realizan las conexiones en el puerto 25 del equipo <em
                class="replaceable">servidor</em>, que pasarán a través del túnel SSH establecido entre la máquina local y la máquina <em
                class="replaceable">intermediario</em>. En el primer caso, la entrada al túnel es el puerto local 8000 y los datos se mueven hacia la máquina <em
                class="replaceable">intermediario</em> antes de dirigirse a <em
                class="replaceable">servidor</em> en la red «pública». En el segundo caso, la entrada y la salida del túnel son invertidos; la entrada es en el puerto 8000 de la máquina <em
                class="replaceable">intermediario</em>, la salida es en el equipo local y los datos son dirigidos a <em
                class="replaceable">servidor</em>. En la práctica, el servidor generalmente está en la máquina local o el intermediario. De esa forma SSH asegura la conexión un extremo a otro.
				</div><div
              class="figure"><a
                xmlns=""
                id="figure.ssh-L"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-L.png"
                    alt="Redirección de un puerto local con SSH" /></div></div><p
                class="title"><strong>Figura 9.3. Redirección de un puerto local con SSH</strong></p></div><div
              class="figure"><a
                xmlns=""
                id="figure.ssh-R"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-R.png"
                    alt="Redirección de un puerto remoto con SSH" /></div></div><p
                class="title"><strong>Figura 9.4. Redirección de un puerto remoto con SSH</strong></p></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.remote-desktops"></a>9.2.2. Utilización de escritorios gráficos remotos</h3></div></div></div><div
            class="para">
				VNC (computación en redes virtuales: «Virtual Network Computing») permite el acceso remoto a escritorios gráficos.
			</div><a
            id="id-1.12.5.7.3"
            class="indexterm"></a><a
            id="id-1.12.5.7.4"
            class="indexterm"></a><a
            id="id-1.12.5.7.5"
            class="indexterm"></a><a
            id="id-1.12.5.7.6"
            class="indexterm"></a><a
            id="id-1.12.5.7.7"
            class="indexterm"></a><div
            class="para">
				Esta herramienta se utiliza más que nada para asistencia técnica; el administrador puede ver los errores con los que se enfrenta el usuario y mostrarle el curso de acción correcto sin tener que estar a su lado.
			</div><a
            id="id-1.12.5.7.9"
            class="indexterm"></a><a
            id="id-1.12.5.7.10"
            class="indexterm"></a><a
            id="id-1.12.5.7.11"
            class="indexterm"></a><div
            class="para">
				Primero, el usuario debe autorizar compartir su sesión.El entornos gráficos de escritorio GNOME en <span
              class="distribution distribution">Jessie</span> incluye esa opción en su panel de configuración (al contrario que en versiones anteriores de Debian, donde el usuario tenía que instalar y ejecutar la orden <code
              class="command">vino</code>). KDE aún requiere utilizar <code
              class="command">krfb</code> para permitir compartir una sesión existente sobre VNC. Para otros entornos gráficos de escritorio, el programa <code
              class="command">x11vnc</code> (en el paquete Debian del mismo nombre) cumple el mismo propósito; puede ponerlo a disposición del usuario con un ícono explícito.
			</div><a
            id="id-1.12.5.7.13"
            class="indexterm"></a><a
            id="id-1.12.5.7.14"
            class="indexterm"></a><a
            id="id-1.12.5.7.15"
            class="indexterm"></a><a
            id="id-1.12.5.7.16"
            class="indexterm"></a><div
            class="para">
				Cuando la sesión gráfica está disponible a través de VNC, el administrador debe conectarse a ella con un cliente VNC. Para ello GNOME posee <code
              class="command">vinagre</code> y <code
              class="command">remmina</code>, mientras que KDE incluye <code
              class="command">krdc</code> (en el menú <span
              class="guimenu"><strong>K</strong></span> → <span
              class="guisubmenu"><strong>Internet</strong></span> → <span
              class="guimenuitem"><strong>Cliente de Escritorio Remoto</strong></span>). Existen otros clientes VNC para utilizar en una terminal como <code
              class="command">xvnc4viewer</code> en el paquete Debian del mismo nombre. Una vez conectado, el administrador puede ver lo que sucede, trabajar en el equipo remotamente y mostrarle al usuario cómo proceder.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>SEGURIDAD</em></span> VNC sobre SSH</strong></p></div></div></div><a
              id="id-1.12.5.7.18.2"
              class="indexterm"></a><div
              class="para">
				Si desea conectarse con VNC y no desea que se envíen sus datos en texto plano a través de la red, es posible encapsular los datos en un túnel SSH (revise la <a
                class="xref"
                href="sect.remote-login.html#sect.ssh-port-forwarding">Sección 9.2.1.3, “Creación de túneles cifrados con redirección de puertos”</a>). Simplemente tiene que saber que, de forma predeterminada, VNC utiliza el puerto 5900 para la primera pantalla (llamada «localhost:0»), 5901 para la segunda (llamada «localhost:1»), etc.
			</div><div
              class="para">
				La orden <code
                class="command">ssh -L localhost:5901:localhost:5900 -N -T <em
                  class="replaceable">equipo</em></code> crea un túnel entre el puerto local 5901 en la interfaz de «localhost» y el puerto 5900 de <em
                class="replaceable">equipo</em>. La primera ocurrencia de «localhost» restringe a SSH para que sólo escuche en dicha interfaz en la máquina local. El segundo «localhost» indica que la interfaz en la máquina remota que recibirá el tráfico de red que ingrese en «localhost:5901». Por lo tanto, <code
                class="command">vncviewer localhost:1</code> conectará el cliente VNC a la pantalla remota aún cuando indique el nombre de la máquina local.
			</div><div
              class="para">
				Cuando cierre la sesión VNC, recuerde también cerrar el túnel saliendo de la sesión SSH correspondiente.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOLVER A LOS CIMIENTOS</em></span> Gestor de pantallas</strong></p></div></div></div><a
              id="id-1.12.5.7.19.2"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.3"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.4"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.5"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.6"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.7"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">gdm3</code>, <code
                class="command">kdm</code>, <code
                class="command">lightdm</code> y <code
                class="command">xdm</code> son gestores de pantalla. Toman el control de la interfaz gráfica poco después del inicio para proveer al usuario una pantalla de inicio de sesión. Una vez que el usuario inició sesión, ejecutan los programas necesarios para iniciar una sesión gráfica de trabajo.
			</div></div><div
            class="para">
				VNC también funciona para usuarios móviles o ejecutivos de empresas que ocasionalmente necesitan iniciar sesión desde sus casas para acceder a un escritorio remoto similar al que utilizan en la oficina. La configuración de tal servicio es más complicada: primero instale el paquete <span
              class="pkg pkg">vnc4server</span>, modifique la configuración del gestor de pantalla para aceptar pedidos <code
              class="literal">XDMCP Query</code> (en <code
              class="command">gdm3</code> puede hacerlo agregando <code
              class="literal">Enable=true</code> en la sección «xdmcp» del archivo <code
              class="filename">/etc/gdm3/daemon.conf</code>). Finalmente, inicie el servidor VNC con <code
              class="command">inetd</code> para que se inicie una sesión automáticamente cuando el usuario intente hacerlo. Por ejemplo, puede agregar la siguiente línea al archivo <code
              class="filename">/etc/inetd.conf</code>:
			</div><pre
            class="programlisting">5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</pre><div
            class="para">
				Redireccionar las conexiones entrantes al gestor de pantallas soluciona el problema de la autenticación ya que sólo los usuarios con cuentas locales pasarán la pantalla de inicio de sesión de <code
              class="command">gdm3</code> (o su equivalente <code
              class="command">kdm</code>, <code
              class="command">xdm</code>, etc.). Como esta operación permite múltiples sesiones simultáneamente sin problemas (siempre que el servidor sea suficientemente poderoso), incluso puede ser utilizada para proveer escritorios completos para usuarios móviles (o sistemas de escritorios menos potentes configurados como clientes ligeros). Los usuarios simplemente iniciarán sesión en la pantalla del servidor con <code
              class="command">vncviewer <em
                class="replaceable">servidor</em>:50</code> ya que utiliza el puerto 5950.
			</div><a
            id="id-1.12.5.7.23"
            class="indexterm"></a></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Anterior</strong>Capítulo 9. Servicios Unix</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Subir</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Inicio</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Siguiente</strong>9.3. Administración de permisos</a></li></ul></body></html>
