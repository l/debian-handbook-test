<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.3. Supervision: Prevention, Detection, Deterrence</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-tr-TR-1.0-1" /><meta
        name="keywords"
        content="Firewall, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="The Debian Administrator's Handbook" /><link
        rel="up"
        href="security.html"
        title="Bölüm 14. Security" /><link
        rel="prev"
        href="sect.firewall-packet-filtering.html"
        title="14.2. Firewall or Packet Filtering" /><link
        rel="next"
        href="sect.apparmor.html"
        title="14.4. Introduction to AppArmor" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/tr-TR/stable/sect.supervision.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Önceki</strong></a></li><li
          class="home">The Debian Administrator's Handbook</li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Sonraki</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.supervision"></a>14.3. Supervision: Prevention, Detection, Deterrence</h2></div></div></div><a
          id="id-1.17.6.2"
          class="indexterm"></a><div
          class="para">
			Monitoring is an integral part of any security policy for several reasons. Among them, that the goal of security is usually not restricted to guaranteeing data confidentiality, but it also includes ensuring availability of the services. It is therefore imperative to check that everything works as expected, and to detect in a timely manner any deviant behavior or change in quality of the service(s) rendered. Monitoring activity can help detecting intrusion attempts and enable a swift reaction before they cause grave consequences. This section reviews some tools that can be used to monitor several aspects of a Debian system. As such, it completes <a
            class="xref"
            href="sect.monitoring.html">Kısım 12.4, “Monitoring”</a>.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.logcheck"></a>14.3.1. Monitoring Logs with <code
                    class="command">logcheck</code></h3></div></div></div><a
            id="id-1.17.6.4.2"
            class="indexterm"></a><a
            id="id-1.17.6.4.3"
            class="indexterm"></a><a
            id="id-1.17.6.4.4"
            class="indexterm"></a><div
            class="para">
				The <code
              class="command">logcheck</code> program monitors log files every hour by default. It sends unusual log messages in emails to the administrator for further analysis.
			</div><div
            class="para">
				The list of monitored files is stored in <code
              class="filename">/etc/logcheck/logcheck.logfiles</code>; the default values work fine if the <code
              class="filename">/etc/rsyslog.conf</code> file has not been completely overhauled.
			</div><div
            class="para">
				<code
              class="command">logcheck</code> can work in one of three more or less detailed modes: <span
              class="emphasis"><em>paranoid</em></span>, <span
              class="emphasis"><em>server</em></span> and <span
              class="emphasis"><em>workstation</em></span>. The first one is <span
              class="emphasis"><em>very</em></span> verbose, and should probably be restricted to specific servers such as firewalls. The second (and default) mode is recommended for most servers. The last one is designed for workstations, and is even terser (it filters out more messages).
			</div><div
            class="para">
				In all three cases, <code
              class="command">logcheck</code> should probably be customized to exclude some extra messages (depending on installed services), unless the admin really wishes to receive hourly batches of long uninteresting emails. Since the message selection mechanism is rather complex, <code
              class="filename">/usr/share/doc/logcheck-database/README.logcheck-database.gz</code> is a required — if challenging — read.
			</div><div
            class="para">
				The applied rules can be split into several types:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						those that qualify a message as a cracking attempt (stored in a file in the <code
                    class="filename">/etc/logcheck/cracking.d/</code> directory);
					</div></li><li
                class="listitem"><div
                  class="para">
						those canceling such a qualification (<code
                    class="filename">/etc/logcheck/cracking.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						those classifying a message as a security alert (<code
                    class="filename">/etc/logcheck/violations.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						those canceling this classification (<code
                    class="filename">/etc/logcheck/violations.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						finally, those applying to the remaining messages (considered as <span
                    class="emphasis"><em>system events</em></span>).
					</div></li></ul></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CAUTION</em></span> Ignoring a message</strong></p></div></div></div><div
              class="para">
				Any message tagged as a cracking attempt or a security alert (following a rule stored in a <code
                class="filename">/etc/logcheck/violations.d/myfile</code> file) can only be ignored by a rule in a <code
                class="filename">/etc/logcheck/violations.ignore.d/myfile</code> or <code
                class="filename">/etc/logcheck/violations.ignore.d/myfile-<em
                  class="replaceable">extension</em></code> file.
			</div></div><div
            class="para">
				A system event is always signaled unless a rule in one of the <code
              class="filename">/etc/logcheck/ignore.d.{paranoid,server,workstation}/</code> directories states the event should be ignored. Of course, the only directories taken into account are those corresponding to verbosity levels equal or greater than the selected operation mode.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.monitoring-activity"></a>14.3.2. Monitoring Activity</h3></div></div></div><a
            id="id-1.17.6.5.2"
            class="indexterm"></a><a
            id="id-1.17.6.5.3"
            class="indexterm"></a><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.real-time-monitoring"></a>14.3.2.1. In Real Time</h4></div></div></div><div
              class="para">
					<code
                class="command">top</code> is an interactive tool that displays a list of currently running processes. The default sorting is based on the current amount of processor use and can be obtained with the <span
                class="keycap"><strong>P</strong></span> key. Other sort orders include a sort by occupied memory (<span
                class="keycap"><strong>M</strong></span> key), by total processor time (<span
                class="keycap"><strong>T</strong></span> key) and by process identifier (<span
                class="keycap"><strong>N</strong></span> key). The <span
                class="keycap"><strong>k</strong></span> key allows killing a process by entering its process identifier. The <span
                class="keycap"><strong>r</strong></span> key allows <span
                class="emphasis"><em>renicing</em></span> a process, i.e. changing its priority.
				</div><a
              id="id-1.17.6.5.4.3"
              class="indexterm"></a><div
              class="para">
					When the system seems to be overloaded, <code
                class="command">top</code> is a great tool to see which processes are competing for processor time or consume too much memory. In particular, it is often interesting to check if the processes consuming resources match the real services that the machine is known to host. An unknown process running as the www-data user should really stand out and be investigated, since it's probably an instance of software installed and executed on the system through a vulnerability in a web application.
				</div><div
              class="para">
					<code
                class="command">top</code> is a very flexible tool and its manual page gives details on how to customize its display and adapt it to one's personal needs and habits.
				</div><div
              class="para">
					The <code
                class="command">gnome-system-monitor</code> graphical tool is similar to <code
                class="command">top</code> and it provides roughly the same features.
				</div><a
              id="id-1.17.6.5.4.7"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.monitoring-history"></a>14.3.2.2. History</h4></div></div></div><a
              id="id-1.17.6.5.5.2"
              class="indexterm"></a><div
              class="para">
					Processor load, network traffic and free disk space are information that are constantly varying. Keeping a history of their evolution is often useful in determining exactly how the computer is used.
				</div><a
              id="id-1.17.6.5.5.4"
              class="indexterm"></a><a
              id="id-1.17.6.5.5.5"
              class="indexterm"></a><div
              class="para">
					There are many dedicated tools for this task. Most can fetch data via SNMP (<span
                class="emphasis"><em>Simple Network Management Protocol</em></span>) in order to centralize this information. An added benefit is that this allows fetching data from network elements that may not be general-purpose computers, such as dedicated network routers or switches.
				</div><div
              class="para">
					This book deals with Munin in some detail (see <a
                class="xref"
                href="sect.monitoring.html#sect.munin">Kısım 12.4.1, “Setting Up Munin”</a>) as part of <a
                class="xref"
                href="advanced-administration.html">Bölüm 12: “<em>Advanced Administration</em>”</a>. Debian also provides a similar tool, <span
                class="pkg pkg">cacti</span>. Its deployment is slightly more complex, since it is based solely on SNMP. Despite having a web interface, grasping the concepts involved in configuration still requires some effort. Reading the HTML documentation (<code
                class="filename">/usr/share/doc/cacti/html/index.html</code>) should be considered a prerequisite.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> <code
                          class="command">mrtg</code></strong></p></div></div></div><a
                id="id-1.17.6.5.5.8.2"
                class="indexterm"></a><div
                class="para">
					<code
                  class="command">mrtg</code> (in the similarly-named package) is an older tool. Despite some rough edges, it can aggregate historical data and display them as graphs. It includes a number of scripts dedicated to collecting the most commonly monitored data such as processor load, network traffic, web page hits, and so on.
				</div><div
                class="para">
					The <span
                  class="pkg pkg">mrtg-contrib</span> and <span
                  class="pkg pkg">mrtgutils</span> packages contain example scripts that can be used directly.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.17.6.6"></a>14.3.3. Detecting Changes</h3></div></div></div><div
            class="para">
				Once the system is installed and configured, and barring security upgrades, there's usually no reason for most of the files and directories to evolve, data excepted. It is therefore interesting to make sure that files actually do not change: any unexpected change would therefore be worth investigating. This section presents a few tools able to monitor files and to warn the administrator when an unexpected change occurs (or simply to list such changes).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.dpkg-verify"></a>14.3.3.1. Auditing Packages with <code
                      class="command">dpkg --verify</code></h4></div></div></div><a
              id="id-1.17.6.6.3.2"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> Protecting against upstream changes</strong></p></div></div></div><div
                class="para">
					<code
                  class="command">dpkg --verify</code> is useful in detecting changes to files coming from a Debian package, but it will be useless if the package itself is compromised, for instance if the Debian mirror is compromised. Protecting against this class of attacks involves using APT's digital signature verification system (see <a
                  class="xref"
                  href="sect.package-authentication.html">Kısım 6.5, “Checking Package Authenticity”</a>), and taking care to only install packages from a certified origin.
				</div></div><div
              class="para">
					<code
                class="command">dpkg --verify</code> (or <code
                class="command">dpkg -V</code>) is an interesting tool since it allows finding what installed files have been modified (potentially by an attacker), but this should be taken with a grain of salt. To do its job it relies on checksums stored in dpkg's own database which is stored on the hard disk (they can be found in <code
                class="filename">/var/lib/dpkg/info/<em
                  class="replaceable">package</em>.md5sums</code>); a thorough attacker will therefore update these files so they contain the new checksums for the subverted files.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BACK TO BASICS</em></span> File fingerprint</strong></p></div></div></div><a
                id="id-1.17.6.6.3.5.2"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.3"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.4"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.5"
                class="indexterm"></a><div
                class="para">
					As a reminder: a fingerprint is a value, often a number (even though in hexadecimal notation), that contains a kind of signature for the contents of a file. This signature is calculated with an algorithm (MD5 or SHA1 being well-known examples) that more or less guarantee that even the tiniest change in the file contents implies a change in the fingerprint; this is known as the “avalanche effect”. This allows a simple numerical fingerprint to serve as a litmus test to check whether the contents of a file have been altered. These algorithms are not reversible; in other words, for most of them, knowing a fingerprint doesn't allow finding the corresponding contents. Recent mathematical advances seem to weaken the absoluteness of these principles, but their use is not called into question so far, since creating different contents yielding the same fingerprint still seems to be quite a difficult task.
				</div></div><div
              class="para">
					Running <code
                class="command">dpkg -V</code> will verify all installed packages and will print out a line for each file with a failing test. The output format is the same as the one of <code
                class="command">rpm -V</code> where each character denotes a test on some specific meta-data. Unfortunately <code
                class="command">dpkg</code> does not store the meta-data needed for most tests and will thus output question marks for them. Currently only the checksum test can yield a "5" on the third character (when it fails).
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>dpkg -V</code></strong>
<code
                class="computeroutput">??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</code></pre><div
              class="para">
					In the sample above, dpkg reports a change to SSH's service file that the administrator made to the packaged file instead of using an appropriate <code
                class="filename">/etc/systemd/system/ssh.service</code> override (which would be stored below <code
                class="filename">/etc</code> like any configuration change should be). It also lists multiple configuration files (identified by the "c" letter on the second field) that had been legitimately modified.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.debsums"></a>14.3.3.2. Auditing Packages: <code
                      class="command">debsums</code> and its Limits</h4></div></div></div><a
              id="id-1.17.6.6.4.2"
              class="indexterm"></a><div
              class="para">
					<code
                class="command">debsums</code> is the ancestor of <code
                class="command">dpkg -V</code> and is thus mostly obsolete. It suffers from the same limitations than dpkg. Fortunately, some of the limitations can be worked-around (whereas dpkg does not offer similar work-arounds).
				</div><div
              class="para">
					Since the data on the disk cannot be trusted, <code
                class="command">debsums</code> offers to do its checks based on <code
                class="filename">.deb</code> files instead of relying on dpkg's database. To download trusted <code
                class="filename">.deb</code> files of all the packages installed, we can rely on APT's authenticated downloads. This operation can be slow and tedious, and should therefore not be considered a proactive technique to be used on a regular basis.
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</code></strong>
<code
                class="computeroutput">[ ... ]
# </code><strong
                class="userinput"><code>debsums -p /var/cache/apt/archives --generate=all</code></strong></pre><div
              class="para">
					Note that this example uses the <code
                class="command">grep-status</code> command from the <span
                class="pkg pkg">dctrl-tools</span> package, which is not installed by default.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.6.6.5"></a>14.3.3.3. Monitoring Files: AIDE</h4></div></div></div><a
              id="id-1.17.6.6.5.2"
              class="indexterm"></a><div
              class="para">
					The AIDE tool (<span
                class="emphasis"><em>Advanced Intrusion Detection Environment</em></span>) allows checking file integrity, and detecting any change against a previously recorded image of the valid system. This image is stored as a database (<code
                class="filename">/var/lib/aide/aide.db</code>) containing the relevant information on all files of the system (fingerprints, permissions, timestamps and so on). This database is first initialized with <code
                class="command">aideinit</code>; it is then used daily (by the <code
                class="filename">/etc/cron.daily/aide</code> script) to check that nothing relevant changed. When changes are detected, AIDE records them in log files (<code
                class="filename">/var/log/aide/*.log</code>) and sends its findings to the administrator by email.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>IN PRACTICE</em></span> Protecting the database</strong></p></div></div></div><div
                class="para">
					Since AIDE uses a local database to compare the states of the files, the validity of its results is directly linked to the validity of the database. If an attacker gets root permissions on a compromised system, they will be able to replace the database and cover their tracks. A possible workaround would be to store the reference data on read-only storage media.
				</div></div><div
              class="para">
					Many options in <code
                class="filename">/etc/default/aide</code> can be used to tweak the behavior of the <span
                class="pkg pkg">aide</span> package. The AIDE configuration proper is stored in <code
                class="filename">/etc/aide/aide.conf</code> and <code
                class="filename">/etc/aide/aide.conf.d/</code> (actually, these files are only used by <code
                class="command">update-aide.conf</code> to generate <code
                class="filename">/var/lib/aide/aide.conf.autogenerated</code>). Configuration indicates which properties of which files need to be checked. For instance, the contents of log files changes routinely, and such changes can be ignored as long as the permissions of these files stay the same, but both contents and permissions of executable programs must be constant. Although not very complex, the configuration syntax is not fully intuitive, and reading the <span
                class="citerefentry"><span
                  class="refentrytitle">aide.conf</span>(5)</span> manual page is therefore recommended.
				</div><div
              class="para">
					A new version of the database is generated daily in <code
                class="filename">/var/lib/aide/aide.db.new</code>; if all recorded changes were legitimate, it can be used to replace the reference database.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> Tripwire and Samhain</strong></p></div></div></div><div
                class="para">
					Tripwire is very similar to AIDE; even the configuration file syntax is almost the same. The main addition provided by <span
                  class="pkg pkg">tripwire</span> is a mechanism to sign the configuration file, so that an attacker cannot make it point at a different version of the reference database.
				</div><div
                class="para">
					Samhain also offers similar features, as well as some functions to help detecting rootkits (see the sidebar <a
                  class="xref"
                  href="sect.supervision.html#sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"><span
                    class="emphasis"><em>QUICK LOOK</em></span> The <span
                    class="pkg pkg">checksecurity</span> and <span
                    class="pkg pkg">chkrootkit</span>/<span
                    class="pkg pkg">rkhunter</span> packages</a>). It can also be deployed globally on a network, and record its traces on a central server (with a signature).
				</div></div><div
              class="sidebar"><a
                xmlns=""
                id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"></a><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>QUICK LOOK</em></span> The <span
                          class="pkg pkg">checksecurity</span> and <span
                          class="pkg pkg">chkrootkit</span>/<span
                          class="pkg pkg">rkhunter</span> packages</strong></p></div></div></div><a
                id="id-1.17.6.6.5.8.2"
                class="indexterm"></a><div
                class="para">
					The first of these packages contains several small scripts performing basic checks on the system (empty passwords, new setuid files, and so on) and warning the administrator if required. Despite its explicit name, an administrator should not rely solely on it to make sure a Linux system is secure.
				</div><div
                class="para">
					The <span
                  class="pkg pkg">chkrootkit</span> and <span
                  class="pkg pkg">rkhunter</span> packages allow looking for <span
                  class="emphasis"><em>rootkits</em></span> potentially installed on the system. As a reminder, these are pieces of software designed to hide the compromise of a system while discreetly keeping control of the machine. The tests are not 100% reliable, but they can usually draw the administrator's attention to potential problems.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.intrusion-detection"></a>14.3.4. Detecting Intrusion (IDS/NIDS)</h3></div></div></div><a
            id="id-1.17.6.7.2"
            class="indexterm"></a><a
            id="id-1.17.6.7.3"
            class="indexterm"></a><a
            id="id-1.17.6.7.4"
            class="indexterm"></a><a
            id="id-1.17.6.7.5"
            class="indexterm"></a><a
            id="id-1.17.6.7.6"
            class="indexterm"></a><a
            id="id-1.17.6.7.7"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BACK TO BASICS</em></span> Denial of service</strong></p></div></div></div><a
              id="id-1.17.6.7.8.2"
              class="indexterm"></a><div
              class="para">
				A “denial of service” attack has only one goal: to make a service unavailable. Whether such an attack involves overloading the server with queries or exploiting a bug, the end result is the same: the service is no longer operational. Regular users are unhappy, and the entity hosting the targeted network service suffers a loss in reputation (and possibly in revenue, for instance if the service was an e-commerce site).
			</div><div
              class="para">
				Such an attack is sometimes “distributed”; this usually involves overloading the server with large numbers of queries coming from many different sources so that the server becomes unable to answer the legitimate queries. These types of attacks have gained well-known acronyms: <acronym
                class="acronym">DDoS</acronym> and <acronym
                class="acronym">DoS</acronym> (depending on whether the denial of service attack is distributed or not).
			</div></div><div
            class="para">
				<code
              class="command">suricata</code> (in the Debian package of the same name) is a NIDS — a <span
              class="emphasis"><em>Network Intrusion Detection System</em></span>. Its function is to listen to the network and try to detect infiltration attempts and/or hostile acts (including denial of service attacks). All these events are logged in multiple files in <code
              class="filename">/var/log/suricata</code>. There are third party tools (Kibana/logstash) to better browse all the data collected. <div
              xmlns=""
              class="url">→ <a
                xmlns="http://www.w3.org/1999/xhtml"
                href="http://suricata-ids.org">http://suricata-ids.org</a></div> <div
              xmlns=""
              class="url">→ <a
                xmlns="http://www.w3.org/1999/xhtml"
                href="https://www.elastic.co/products/kibana">https://www.elastic.co/products/kibana</a></div>
			</div><a
            id="id-1.17.6.7.10"
            class="indexterm"></a><a
            id="id-1.17.6.7.11"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CAUTION</em></span> Range of action</strong></p></div></div></div><div
              class="para">
				The effectiveness of <code
                class="command">suricata</code> is limited by the traffic seen on the monitored network interface. It will obviously not be able to detect anything if it cannot observe the real traffic. When plugged into a network switch, it will therefore only monitor attacks targeting the machine it runs on, which is probably not the intention. The machine hosting <code
                class="command">suricata</code> should therefore be plugged into the “mirror” port of the switch, which is usually dedicated to chaining switches and therefore gets all the traffic.
			</div></div><div
            class="para">
				Configuring suricata involves reviewing and editing <code
              class="filename">/etc/suricata/suricata-debian.yaml</code>, which is very long because each parameter is abundantly commented. A minimal configuration requires describing the range of addresses that the local network covers (<code
              class="literal">HOME_NET</code> parameter). In practice, this means the set of all potential attack targets. But getting the most of it requires reading it in full and adapting it to the local situation.
			</div><div
            class="para">
				On top of this, you should also edit <code
              class="filename">/etc/default/suricata</code> to define the network interface to monitor and to enable the init script (by setting <code
              class="literal">RUN=yes</code>). You might also want to set <code
              class="literal">LISTENMODE=pcap</code> because the default <code
              class="literal">LISTENMODE=nfqueue</code> requires further configuration to work properly (the netfilter firewall must be configured to pass packets to some user-space queue handled by suricata via the <code
              class="literal">NFQUEUE</code> target).
			</div><div
            class="para">
				To detect bad behaviour, <code
              class="command">suricata</code> needs a set of monitoring rules: you can find such rules in the <span
              class="pkg pkg">snort-rules-default</span> package. <code
              class="command">snort</code> is the historical reference in the IDS ecosystem and <code
              class="command">suricata</code> is able to reuse rules written for it. Unfortunately that package is missing from <span
              class="distribution distribution">Debian Jessie</span> and should be retrieved from another Debian release like <span
              class="distribution distribution">Testing</span> or <span
              class="distribution distribution">Unstable</span>.
			</div><div
            class="para">
				Alternatively, <code
              class="command">oinkmaster</code> (in the package of the same name) can be used to download Snort rulesets from external sources.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>GOING FURTHER</em></span> Integration with <code
                        class="command">prelude</code></strong></p></div></div></div><div
              class="para">
				Prelude brings centralized monitoring of security information. Its modular architecture includes a server (the <span
                class="emphasis"><em>manager</em></span> in <span
                class="pkg pkg">prelude-manager</span>) which gathers alerts generated by <span
                class="emphasis"><em>sensors</em></span> of various types.
			</div><div
              class="para">
				Suricata can be configured as such a sensor. Other possibilities include <span
                class="emphasis"><em>prelude-lml</em></span> (<span
                class="emphasis"><em>Log Monitor Lackey</em></span>) which monitors log files (in a manner similar to <code
                class="command">logcheck</code>, described in <a
                class="xref"
                href="sect.supervision.html#sect.logcheck">Kısım 14.3.1, “Monitoring Logs with <code
                  class="command">logcheck</code>”</a>).
			</div><a
              id="id-1.17.6.7.17.4"
              class="indexterm"></a></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Önceki</strong>14.2. Firewall or Packet Filtering</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Yukarı</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Başlangıç</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Sonraki</strong>14.4. Introduction to AppArmor</a></li></ul></body></html>
