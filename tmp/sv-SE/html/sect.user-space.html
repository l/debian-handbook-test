<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.5. Användarrymden</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-sv-SE-1.0-1" /><meta
        name="keywords"
        content="BIOS, Kärna, Unix, Process, Hierarki, Grundläggande kommandon" /><link
        rel="home"
        href="index.html"
        title="Handbok för Debianadministratören" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Appendix B. Kort snabbkurs" /><link
        rel="prev"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. Vissa uppgifter hanteras av kärnan" /><link
        rel="next"
        href="backcover.html"
        title="Appendix C. Handbok för Debianadministratören" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/sv-SE/stable/sect.user-space.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Föregående</strong></a></li><li
          class="home">Handbok för Debianadministratören</li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Nästa</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.user-space"></a>B.5. Användarrymden</h2></div></div></div><a
          id="id-1.21.8.2"
          class="indexterm"></a><a
          id="id-1.21.8.3"
          class="indexterm"></a><div
          class="para">
			”Användarrymd” refererar till körtidsmiljön för normala processor (till skillnad mot kärnprocesser). Detta innebär inte nödvändigtvis att dessa processer faktiskt startades av användare då ett standard system normatl har flera ”demon”-processer (eller bakgrundsprocesser) körandes innan användaren ens öppnar en session. Demonprocesser anses också vara användarrymdsprocesser.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.process-basics"></a>B.5.1. Process</h3></div></div></div><a
            id="id-1.21.8.5.2"
            class="indexterm"></a><div
            class="para">
				När kärnan komme förbi sin initialiseringsfas startar den den allra första processen, <code
              class="command">init</code>. Process #1 är ensam sällan särskilt användbar, och Unix-liknande system kör med många flera processer.
			</div><a
            id="id-1.21.8.5.4"
            class="indexterm"></a><div
            class="para">
				För det första kan en process klona sig själv (detta är känt som <span
              class="emphasis"><em>fork</em></span>). Kärnan allokerar ett nytt (men identiskt) minnesområde för processen, och en ny process som kan använda den. Vid denna tidpunkt är den enda skillnade mellan dessa två processer deras <span
              class="emphasis"><em>pid</em></span>. Den nya processen kallas vanligen en barnprocess, och originalprocessen vars <span
              class="emphasis"><em>pid</em></span> inte ändras, kallas för föräldraprocessen.
			</div><div
            class="para">
				Ibland fortsätter barnprocessen att leva sitt eget liv, oberoende från sin förälder, med sin egen data kopierad från föräldraprocessen. I många fall exekverar dock denna barnprocess ett annat program. Med ett fåtal undantag ersätts dess minn helt enkelt med det för det nya programmet och exekvering av detta nya program påbörjas. Detta är mekanismen som används av initprocessen (med processnummer 1) för att starta ytterligare tjänster och exekvera hela uppstartssekvensen. Vid en tidpunkt kommer en process bland <code
              class="command">init</code>s barn att starta ett grafiskt gränssnitt genom vilket användare kan logga in (den faktiskta sekvensen av händelser beskrivs i ytterligare detalj i <a
              class="xref"
              href="unix-services.html#sect.system-boot">Avsnitt 9.1, ”System Boot”</a>).
			</div><div
            class="para">
				När en process avslutar uppgiften som var anledningen till att den startades så avslutas den. Kärnan återhämtar sedan minne som tilldelats till denna process och slutar ge den körtidsintervall. Föräldraprocessen informeras om att dess barnprocess avslutats, vilket låter en process vänta på att en uppgift som delegerats till en barnprocess slutförts. Detta beteende syns tydligt i kommandotolkar (kända som <span
              class="emphasis"><em>skal</em></span>). När ett kommando matas in i ett skal, handlar det helt enkelt om att lägga till ett <strong
              class="userinput"><code>&amp;</code></strong> på slutet av kommandot. Prompten visas igen inom kort vilket kan leda till problem om kommandot själv behöver skriva ut data.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.daemons"></a>B.5.2. Demoner</h3></div></div></div><a
            id="id-1.21.8.6.2"
            class="indexterm"></a><a
            id="id-1.21.8.6.3"
            class="indexterm"></a><div
            class="para">
				En ”demon” är en process som startats automatiskt av uppstartsskevensen. Den fortsätter köra (i bakgrunden) för att utföra underhållsuppgifter eller tillhandahålla tjänster till andra processer. Denna ”bakgrundsuppgift” är faktiskt slumpmässig och matchar inte någon särskild typ ur systemets synvinkel. De är helt enkelt processer, liknande andra processer, som kör i turordning när deras tidsintervall kommer. Skillnaden är endast i hur man talar om den: en process som kör utan interaktion med en användare (i synnerhet utan ett grafiskt gränssnitt) kallas för att den kör ”i bakgrunden” eller ”som en demon”.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOKABULÄR</em></span> Demon, ett nedsättande namn?</strong></p></div></div></div><div
              class="para">
				Även om namnet <span
                class="emphasis"><em>demon</em></span> delar sin grekiska etymologi med <span
                class="emphasis"><em>demon</em></span>, implicerar inte den föregående något djävulskt, utan istället bör det förstås som ett slags skyddsande. Denna distinktion är subtil nog på engelska (daemon vs. demon) ; det är än värre på andra språk (till exempel svenska) där samma ord används för båda betydelserna.
			</div></div><div
            class="para">
				Flera sådana demoner beskrivs i detal i <a
              class="xref"
              href="unix-services.html">Kapitel 9, <em>Unix Services</em></a>.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ipc"></a>B.5.3. Interprocesskommunikation</h3></div></div></div><a
            id="id-1.21.8.7.2"
            class="indexterm"></a><a
            id="id-1.21.8.7.3"
            class="indexterm"></a><div
            class="para">
				En isolerad process, vare sig det är en demon eller ett interaktivt program, är sällan användbart på egen hand, vilket är anledning till att det finns flera sätt att låta separata processer kommunicera med varandra, antingen för att utbyta data eller för att styra varandra. Den generella termen för att referera till detta är <span
              class="emphasis"><em>interprocesskommunikation</em></span>, eller IPC (efter engelskans Inter-Process Communication).
			</div><div
            class="para">
				Det enklaste IPC-systemet är ett använda filer. Processen som önskar skicka data skriver denna till en fil (med ett förutbestämt namn), medan mottagaren endast behöver öppna filen och läsa dess innehåll.
			</div><a
            id="id-1.21.8.7.6"
            class="indexterm"></a><div
            class="para">
				I fallet där du inte önskar spara data på disk kan du använda en <span
              class="emphasis"><em>rörledning</em></span>, vilket helt enkelt är ett objekt med två ändar; byte skrivs i en ände och kan läsas i den andra. Om ändarna styrs av olika processer leder detta till en enkelt och behändig kanal för interprocesskommunikation. Rörledningar kan klassificeras i två kategorier: namngivna rörledningar och anonyma rörledningar. En namngiven rörledning representeras av en post i filsystemet (även om den överförda datan inte lagras där), så att båda processerna kan öppna den oberoende av varandra så länge platsen för den namngivna rörledningen är förutbestämd. I fall när kommunicerande processer är relaterade (till exempel en föräldraprocess och dess barnprocess) kan föräldraprocessen också skapa en anonym rörledning innan forkning, och därför kommer barnet att ärva den. Båda processerna kommer sedan kunna utbyta data via rörledningen utan att behöva involvera filsystemet.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>I PRAKTIKEN</em></span> Ett konkret exempel</strong></p></div></div></div><div
              class="para">
				Låt oss beskriva i detalj vad som händer när ett komplext kommando (en <span
                class="emphasis"><em>rörledning</em></span>) körs från ett skal. Vi antar att vi har en <code
                class="command">bash</code>-process (standardskalet på Debian), med <span
                class="emphasis"><em>pid</em></span> 4374; i detta skal matar vi in kommandot: <code
                class="command">ls | sort</code>.
			</div><div
              class="para">
				Skalet tolkar först kommandot som matats in. I vårt fall förstår det att det finns två program(<code
                class="command">ls</code> och <code
                class="command">sort</code>), med en dataström som flödar från ett till ett annat (betecknat av tecknet <strong
                class="userinput"><code>|</code></strong>, känt som <span
                class="emphasis"><em>rörledning</em></span>). <code
                class="command">bash</code> skapar först en icke namngiven rörledning (som i inledningsskedet endast existerar inom <code
                class="command">bash</code>-processen själv).
			</div><div
              class="para">
				Sedan klonar skalet sig själv; detta leder till en ny <code
                class="command">bash</code>-process med <span
                class="emphasis"><em>pid</em></span> #4521 (<span
                class="emphasis"><em>pid</em></span>:ar är abstrakta nummer och har i allmänhet ingen mening). Process #4521 ärver rörledningen, vilket innebär att den kan skriva till dess ”ingångsände”; <code
                class="command">bash</code> omdirigera sin standard ut-ström till denna rörlednings ingång. Sedan exekverar det (och ersätter sig själv med) programmet <code
                class="command">ls</code>, vilket listar innehållet i den aktuella katalogen. Eftersom <code
                class="command">ls</code> skriver på sin standard ut och denna utgång tidigare har omdirigerats kommer resultaten i att skickas in i rörledningen.
			</div><div
              class="para">
				En liknande åtgärd händer för det andra kommandot: <code
                class="command">bash</code> klonar sig själv igen, vilket leder till en ny <code
                class="command">bash</code>-process med pid #4522. Eftersom detta också är en barn process till #4374, ärver denna också rörledningen; <code
                class="command">bash</code> ansluter sedan sin stanard in till rörledningens utgång, sedan kör det (och ersätter sig själv med) <code
                class="command">sort</code>-kommandot, vilket sorterar sin indata och skriver ut resultaten.
			</div><div
              class="para">
				Alla delarna i pusslet är nu inställda: <code
                class="command">ls</code> läser den aktuella katalogen och skriver listan av filer till rörledningen; <code
                class="command">sort</code> läser denna lista, sorterar den alfabetiskt och skriver ut resultaten. Processnummer #4521 och #4522 avslutas sedan och #4374 (vilken väntat på dem under åtgärden), återtar kontrollen och skriver ut en prompt för att låta användaren mata in ett nytt kommando.
			</div></div><div
            class="para">
				Inter all interprocesskommunikation används för att flytta runt data, dock. I många situationer är den enda information som måste översförsta kontrollmeddelanden så som ”pausa körning”, eller ”återuppta körning”. Unix (och Linux) tillhandahåller en mekanism känd som <span
              class="emphasis"><em>signaler</em></span> genom vilka en process enkelt kan skicka en specifik signal (vald från en fördefinierad lista av signaler) till en annan process. Det enda kravet är att veta målets <span
              class="emphasis"><em>pid</em></span>.
			</div><div
            class="para">
				För mer komplex kommunikation finns det också mekanismer för att låta en process göra tillgängligt, eller dela, en del av sitt allokerade minne till andra processser. Minne som nu delas mellan dem kan användas för att flytta data mellan processerna.
			</div><div
            class="para">
				Avslutningsvid kan nätverksanslutningar också hjälpa processer att kommunicera; dessa processer kan till och med köras på olika datorer, tusentals kilometer från varandra.
			</div><div
            class="para">
				Det är ganska vanligt för ett typiskt Unix-liknande system att använda alla dessa mekanismer i olika utsträckning.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.libraries"></a>B.5.4. Bibliotek</h3></div></div></div><a
            id="id-1.21.8.8.2"
            class="indexterm"></a><div
            class="para">
				Function libraries play a crucial role in a Unix-like operating system. They are not proper programs, since they cannot be executed on their own, but collections of code fragments that can be used by standard programs. Among the common libraries, you can find:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						the standard C library (<span
                    class="emphasis"><em>glibc</em></span>), which contains basic functions such as ones to open files or network connections, and others facilitating interactions with the kernel;
					</div></li><li
                class="listitem"><div
                  class="para">
						graphical toolkits, such as Gtk+ and Qt, allowing many programs to reuse the graphical objects they provide;
					</div></li><li
                class="listitem"><div
                  class="para">
						the <span
                    class="emphasis"><em>libpng</em></span> library, that allows loading, interpreting and saving images in the PNG format.
					</div></li></ul></div><div
            class="para">
				Thanks to those libraries, applications can reuse existing code. Application development is simplified since many applications can reuse the same functions. With libraries often developed by different persons, the global development of the system is closer to Unix's historical philosophy.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURE</em></span> The Unix Way: one thing at a time</strong></p></div></div></div><div
              class="para">
				One of the fundamental concepts that underlies the Unix family of operating systems is that each tool should only do one thing, and do it well; applications can then reuse these tools to build more advanced logic on top. This philosophy can be seen in many incarnations. Shell scripts may be the best example: they assemble complex sequences of very simple tools (such as <code
                class="command">grep</code>, <code
                class="command">wc</code>, <code
                class="command">sort</code>, <code
                class="command">uniq</code> and so on). Another implementation of this philosophy can be seen in code libraries: the <span
                class="emphasis"><em>libpng</em></span> library allows reading and writing PNG images, with different options and in different ways, but it does only that; no question of including functions that display or edit images.
			</div></div><div
            class="para">
				Moreover, these libraries are often referred to as “shared libraries”, since the kernel is able to only load them into memory once, even if several processes use the same library at the same time. This allows saving memory, when compared with the opposite (hypothetical) situation where the code for a library would be loaded as many times as there are processes using it.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Föregående</strong>B.4. Vissa uppgifter hanteras av kärnan</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Upp</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Hem</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Nästa</strong>Appendix C. Handbok för Debianadministratören</a></li></ul></body></html>
