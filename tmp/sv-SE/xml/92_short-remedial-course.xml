<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course" lang="sv-SE">
	<appendixinfo>
		 <keywordset>
			<keyword>BIOS</keyword>
			 <keyword>Kärna</keyword>
			 <keyword>Unix</keyword>
			 <keyword>Process</keyword>
			 <keyword>Hierarki</keyword>
			 <keyword>Grundläggande kommandon</keyword>

		</keywordset>

	</appendixinfo>
	 <title>Kort snabbkurs</title>
	 <highlights> <para>
		Även om denna bok i huvudsak har administratörer och avancerade användare som målgrupp vill vi inte exkludera motiverade nybörjare. Denna bilaga kommer därför att utgöra en snabbkurs som beskriver de grundläggande koncepten som inbegrips i att hantera en Unix-dator.
	</para>
	 </highlights> <section id="sect.shell-and-basic-commands">
		<title>Skalet och grundläggande kommandon</title>
		 <para>
			I Unix-världen måste varje administratör använda kommandoraden förr eller senare; till exempel när systemet misslyckas med att starta upp korrekt och endast tillgängliggör ett räddningsläge med en kommandorad. Att kunna hantera ett sådant gränssnitt är därför en grundläggande överlevnadskunskap under dessa förutsättningar.
		</para>
		 <sidebar> <title><emphasis>SNABBTITT</emphasis> Starta kommandotolken</title>
		 <para>
			En kommandoradsmiljö kan köras från det grafiska skrivbordet, via ett program känt som en ”terminal”. I GNOME kan du starta den från översiktsvyn ”Aktiviteter” (som du får tag i när du flyttar musen upp i övre vänstra hörnet av skärmen) genom att skriva de första tecknen i programnamnet. I KDE hittar du det i menyn <menuchoice><guimenu>K</guimenu><guisubmenu>Program</guisubmenu><guisubmenu>System</guisubmenu></menuchoice>.
		</para>
		 </sidebar> <para>
			Detta avsnitt ger endast en snabbtitt på kommandona. De har alla flertalet flaggor som inte beskrivs här, så referera till den rikliga dokumentationen i deras respektive manualsidor.
		</para>
		 <section>
			<title>Att bläddra i katalogstrukturen och att hantera filer</title>
			 <para>
				När en session är öppen visar kommandot <command>pwd</command> (som står för <emphasis>print working directory</emphasis>, skriv ut arbetskatalog) den aktuella platsen i filsystemet. Den aktuella katalogen ändras med kommandot <command>cd <replaceable>katalog</replaceable></command> (<command>cd</command> är kort för <emphasis>change directory</emphasis>, byt katalog). Föräldrakatalogen kallas alltid <literal>..</literal> (två punkter), medan den aktuella katalogen också är känd som <literal>.</literal> (en punkt). Kommandot <command>ls</command> möjliggör <emphasis>listning</emphasis> av innehållet i en katalog. Om inga parametrar anges arbetar det på den aktuella katalogen.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>cd Skrivbord</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Skrivbord
$ </computeroutput><userinput>cd .</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Skrivbord
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>ls</userinput>
<computeroutput>Bilder  Dokument  Hämtningar  Mallar
Musik   Publikt   Skrivbord   Video</computeroutput>
</screen>
			 <para>
				Den ny katalog kan skapas med <command>mkdir <replaceable>katalog</replaceable></command>, och en existerande (tom) katalog kan tas bort med <command>rmdir <replaceable>katalog</replaceable></command>. Kommandot <command>mv</command> möjliggör <emphasis>förflyttning</emphasis> (moving) och/eller namnbyte för filer och kataloger; <emphasis>borttagning</emphasis> av en fil åstadkoms med <command>rm <replaceable>fil</replaceable></command>.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Bilder   Dokument   Hämtningar  Mallar  Musik 
Publikt  Skrivbord  Video       test
$ </computeroutput><userinput>mv test ny</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Bilder   Dokument   Hämtningar  Mallar  Musik 
Publikt  Skrivbord  Video       ny
$ </computeroutput><userinput>rmdir ny</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Bilder  Dokument  Hämtningar  Mallar
Musik   Publikt   Skrivbord   Video</computeroutput>
</screen>

		</section>
		 <section>
			<title>Visa och modifiera textfiler</title>
			 <para>
				Kommandot <command>cat <replaceable>fil</replaceable></command> (avsett att <emphasis>konkatenera</emphasis> filer till enheten standard ut) läaer en fil och visar dess innehåll i terminalen. Om en fil är för stor för att få plats på en skärm, använd en sidvisare så som <command>less</command> (eller <command>more</command>) för att visa den sida för sida.
			</para>
			 <para>
				Kommandot <command>editor</command> startar en textredigerare (så som <command>vi</command> eller <command>naon</command>) och tillåter skapande, modifiering och läsning av textfiler. De enklaste filerna kan ibland skapas direkt från kommandotolken tack vare omdirigering: <command>echo "<replaceable>text</replaceable>" &gt; <replaceable>fil</replaceable></command> skapar en fil vid namn <replaceable>fil</replaceable> med innehållet ”<replaceable>text</replaceable>”. Att lägga till en rad på slutet av filen är också möjligt, med ett kommando så som <command>echo "<replaceable>mertext</replaceable>" &gt;&gt;<replaceable>fil</replaceable></command>. Notera <literal>&gt;&gt;</literal> i detta exempel.
			</para>

		</section>
		 <section>
			<title>Att söka efter filer och inom filer</title>
			 <para>
				Kommandot <command>find <replaceable>katalog</replaceable> <replaceable>kriterier</replaceable></command> letar efter filer i hierarkin under <replaceable>katalog</replaceable> enligt flertalet kriterier. Det vanligaste kriteriet är <literal>-name <replaceable>namn</replaceable></literal>: detta möjliggör sökning efter en fil efter namn.
			</para>
			 <para>
				Kommandot <command>grep <replaceable>uttryck</replaceable> <replaceable>filer</replaceable></command> genomsöker innehållet i filerna och extraherar rader som matchar det reguljära uttrycket (se sidopanelen <xref linkend="sidebar.regexp" />). Att lägga till flaggan <literal>-r</literal> aktiverar en rekursiv sökning av alla filer som finns i katalogen som anges som parameter. Detta möjliggör sökning efter en fil när endast en del av dess innehåll är känt.
			</para>

		</section>
		 <section>
			<title>Hantera processer</title>
			 <para>
				Kommandot <command>ps aux</command> listar processserna som för närvarande kör och hjälper till att identifera dem genom att visa deras <emphasis>pid</emphasis> (process-ID). När <emphasis>pid</emphasis> för en process är känt låter kommandot <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> en signal skickas till processen (om processen tillhör den aktuella användaren). Flera signaler existerar; vanligast är <literal>TERM</literal> (en begäran om att graciöst avsluta programmet) och <literal>KILL</literal> (en påtvingad död).
			</para>
			 <para>
				Kommandotolken kan också köra program i bakgrunden om kommandot åtföljs av ett ”&amp;”. Genom att använda och-tecknet återfår användare kontrollen av skalet omedelbart även om programmet fortfarande kör (gömt från användaren; som en bakgrundsprocess). Kommandot <command>jobs</command> listar processerna som kör i bakgrunden; för att återuppta ett jobb i förgrunden kör <command>fg %<replaceable>job-number</replaceable></command> (som i <emphasis>förgrund</emphasis>). När ett kommando kör i förgrunden (antingen för att det startades normalt, eller återupptaget i förgrunden med <command>fg</command>), kan tangentkombinationen <keycombo action="simul"><keycap>Ctrl</keycap><keycap>Z</keycap></keycombo> användas för att pausa processen och återuppta kontrollen av kommandoraden. Processen kan sedan återstartas i bakgrunden med <command> bg %<replaceable>job-number</replaceable></command> (efter <foreignphrase>bakgrund</foreignphrase>).
			</para>

		</section>
		 <section>
			<title>Systeminformation: Minne, diskutrymme, identitet</title>
			 <para>
				Kommandot <command>free</command> visar information om minnet; <command>df</command> (<emphasis>disk free</emphasis>, ledig disk) rapporterar om tillgängligt diskutrymme på vardera av de monterade diskarna i filsystemet. Dess flagga <literal>-h</literal> (för <emphasis>human readable</emphasis>, mänskligt läsbar) konverterar storlekarna till en mer lättförståelig enhet (vanligtvis mebibyte eller gibibyte). På samma sätt har kommandot <command>free</command> stöd för flaggorna <literal>-m</literal> och <literal>-g</literal> och visar då data antingen i mebibyte eller gibibyte.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       använt     fritt    delat     buffertar   cache
Minne:     1028420    1009624      18796          0      47404     391804
-/+ buff/cache:        570416     458004
Växl.:     2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>Filsystem            1K-block       Använt Tillgängligt Anv% Monterat på
/dev/sda2              9614084   4737916   4387796  52% /
tmpfs                   514208         0    514208   0% /lib/init/rw
udev                     10240       100     10140   1% /dev
tmpfs                   514208    269136    245072  53% /dev/shm
/dev/sda5             44552904  36315896   7784380  83% /home
</computeroutput></screen>
			 <para>
				Kommandot <command>id</command> visar identiteten för användare som kör sessionen, tillsammans med listan över grupper som de är medlemmar i. Då åtkomst till vissa filer eller enheter kan vara begränsat till gruppmedlemmar kan det vara användbart att kontrollera gruppmedlemskap.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
</screen>

		</section>

	</section>
	 <section id="sect.filesystem-hierarchy">
		<title>Organisation av filsystemshierarkin</title>
		 <indexterm>
			<primary>Filsystemshierarki</primary>
		</indexterm>
		 <section>
			<title>Rotkatalogen</title>
			 <para>
				Ett Debian-system organiseras enligt <emphasis>Filesystem Hierarchy Standard</emphasis> (FHS, Standarden för filsystemshierarki). Denna standard definierar syftet med varje katalog. Toppnivåkatalogerna beskrivs till exempel enligt följande:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<filename>/bin/</filename>: grundläggande program;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/boot/</filename>: Linux-kärna och andra filer som krävs för dess tidiga uppstart;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/dev/</filename>: enhetsfiler;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/etc/</filename>: konfigurationsfiler;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/home/</filename>: användares personliga filer;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/lib/</filename>: grundläggande bibliotek;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/media/*</filename>: monteringspunkter för flyttbara enheter (CD-ROM, USB-nycklar och så vidare);
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/mnt/</filename>: temporär monteringspunkt;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/opt/</filename>: extra program som tillhandahålls av tredjepart;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/root/</filename>: administratörens (roots) personliga filer;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/run/</filename>: flyktig körtidsdata som inte består mellan omstarter (ännu inte inkluderad i FHS);
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/sbin/</filename>: systemprogram;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/srv/</filename>: data som används av servrar som är värdar på detta system;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/tmp/</filename>: temporära filer; denna katalog töms ofta vid uppstart;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/usr/</filename>: program; denna katalog är vidare uppdelad i <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (enligt samma logik som i rotkatalogen). Vidare innehåller <filename>/usr/share/</filename> arkitekturoberoende data. <filename>/usr/local/</filename> är avsedd att användas av administratören för att installera program manuellt utan att skriva över filer som hanteras av paketsystemet (<command>dpkg</command>).
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/var/</filename>: variabel data som hanteras av demoner. Detta inkluderar loggfiler, köer, köfiler, cachear och så vidare.
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/proc/</filename> och <filename>/sys/</filename> är specifika för Linux-kärnan (och är inte en del av FHS). De används av kärnan för att exportera data till användarrymden (se <xref linkend="sect.userspace-presentation" /> och <xref linkend="sect.user-space" /> för förklaringar om detta koncept).
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section>
			<title>Användarens hemkatalog</title>
			 <para>
				Innehållet i en användares hemkatalog är inte standardiserat, men det finns trots detta ett antal noterbara konventioner. En är att en användares hemkatalog ofta refereras till genom tilde (”~”). Detta är användbart att känns till eftersom kommandotolkar automatiskt ersätter ett tilde med den korrekta katalogen (vanligen <filename>/home/<replaceable>användare</replaceable>/</filename>).
			</para>
			 <para>
				Traditionellt lagras konfigurationsfiler för program direkt under användarens hemkatalog, men deras namn inleds vanligtvis med en punkt (t.ex. så lagrar e-postklienten <command>mutt</command> sin konfiguration i <filename>~/.muttrc</filename>). Notera att filnamn som börjar med punkt göms som standard; och <command>ls</command> listar endas dem när flaggan <literal>-a</literal> används, och grafiska filhanterare måste ombes att visa gömda filer.
			</para>
			 <para>
				Vissa program använder också multipla konfigurationsfiler organiserade i en katalog (t.ex. <filename>~/.ssh/</filename>). Vissa program (så som webbläsaren Iceweasel) använder också sin katalog för att spara en cache av hämtad data. Detta innebär att dessa kataloger kan komma att använda en stort mängd diskutrymme.
			</para>
			 <para>
				Dessa konfigurationsfiler lagrade direkt i en användares hemkatalog, som ofta korrelktivt refereras till som <emphasis>punktfiler</emphasis>, har länge växt till en punkt att dessa kataloger kan bli ganska röriga. Lyckligtvis har en ansträngning kollektivt ledd under FreeDesktop.org-paraplyet resulteras i ”XDG Base Directory Specification” (XDG Specifikation för grundläggande kataloger), en konvention som ämnar att städa upp dessa filer och kataloger. Denna specifikation uppger att konfigurationsfiler bör sparas under <filename>~/.config</filename>, cachefiler under <filename>~/.cache</filename> och programdatafiler under <filename>~/.local</filename> (eller underkataloger däri). Denna konvention har långsamt börjat få dragkraft och flera program (speciellt grafiska) har börjat följa den.
			</para>
			 <para>
				Grafiska skrivbord visar vanligtvis innehåller i katalogen <filename>~/Skrivbord/</filename> (eller vad nu den lämpliga översättningen är för system som inte konfigurerats på svenska) på skrivbordet (dvs., det som är synligt på skärmen när alla program är stängda eller ikoniserade).
			</para>
			 <para>
				Avslutningsvis så lagrar e-postsystem ikommande e-postmeddelanden i en katalog <filename>~/Mail/</filename>.
			</para>

		</section>

	</section>
	 <section id="sect.computer-layers">
		<title>Hur en dator fungerar inuti: de olika lagren som är inblandade</title>
		 <para>
			En dator betraktas ofta som något ganska abstrakt, och det synliga externa gränssnittet är mycket enklare än dess inre komplexitet. Sådan komplexitet komme från antalet delar som är involverade. Dessa delar kan dock betraktas i lager, där ett lager endas interagerar med de direkt ovanför eller under.
		</para>
		 <para>
			En slutanvändaren kan klara sig utan att känna till dessa detaljer…så länge allt fungerar. Vid konfrontation med ett problem så som ”Internet fungerar inte!”, är det första man ska göra att försöka identifiera i vilket lager felet uppstår. Fungerar nätverkskortet (hårdara)? Hittas det av datorn? Kan Linux-kärnan se det? Är nätverksparametrarna korrekt konfigurerade? Alla dessa frågor isolerar ett specifikt lager och fokuserar på en potentiell källa till problemet.
		</para>
		 <section id="sect.hardware">
			<title>Det djupaste lagret: hårdvaran</title>
			 <indexterm>
				<primary>IDE</primary>
			</indexterm>
			 <indexterm>
				<primary>SCSI</primary>
			</indexterm>
			 <indexterm>
				<primary>Seriell ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>Parallell ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>Firewire</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <para>
				Låt oss börja med den inledande påminnelsen om att en dator i första hand är en uppsättning hårdvarudelar. Generellt finns det ett huvudkort (känt som <emphasis>moderkort</emphasis>) med en processor (eller flera processorer), lite RAM, styrenheter för andra enheter, för expansionskort (med styrenheter för andra enheter). Väsentliga bland dessa styrenheter är IDE (Parallell ATA), SCSI och Seriell ATA, då dessa ansluter lagringsenheter så som hårddiskar. Andra styrenheter inkluderar USB, som kan användas för att ansluta en stor mängd enheter (allt från webbkameror till termometrar, från tangentbord till hemautomationssystem) och IEEE 1394 (Firewire). Dessa styrenheter tillåter ofta anslutning av flera enheter, vilket leder till att det fullstända undersystemet som hanteras av en styrenhet ofta refereras till som en ”buss”. Expansionskort inkluderar grafikkort (till vilket bildskärmar ansluts), ljudkort, nätverkskort, o.s.v. Vissa morderkort har dessa funktioner inbyggda, och behöver därför inte expansionskort.
			</para>
			 <sidebar> <title><emphasis>I PRAKTIKEN</emphasis> Kontrollera att hårdvaran fungerar</title>
			 <para>
				Att kontrollera att en bit hårdvara fungerar kan vara knepigt. Att bevisa att den inte fungerar kan å andra sidan vara ganska enkelt.
			</para>
			 <para>
				En hårddisk består av snurrande plattor och flyttbara magnetiska huvuden. När en hårddisk strömsätts hörs ett karakteristiskt ljud från motorn som snurrar plattorna. Den avger också energi i form av värme. En hårddisk som förblir kall och tyst när den får ström är därför sannolikt trasig.
			</para>
			 <para>
				Närvkerskort har ofta LED:ar som visar tillståndet för länken. Om en kabel som leder till en fungerande nätverkshubb eller switch ansluts kommer åtminstone en LED att tändas. Om ingen LED tänds är antingen kortet självt, nätverksenheten eller kabeln mellan dem trasig. Nästa steg är därför att testa varje komponent individuellt.
			</para>
			 <para>
				Vissa expansionskort — speciellt 3D-grafikkort — har kylningsenheter, så som kylflänsar och/eller fläktar. Om fläkten inte snurrar även om kortet är strömsatt är en trolig förklaring att kortet är överhettat. Detta gäller också för processorn som finns på moderkortet.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.bios">
			<title>Uppstartaren: BIOS eller UEFI</title>
			 <indexterm>
				<primary>BIOS</primary>
			</indexterm>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>Master Boot Record (MBR, huvudstartsektor)</primary>
			</indexterm>
			 <para>
				Hårdvara kan inte på egen hand utföra nyttiga uppgifter utan en motsvarande programvar som driver den. Att kontrollera och interagera med hårdvaran är därför syftet för operativsystemet och programmen. Dessa, å sin sida, kräver fungerande hårdvara för att köra.
			</para>
			 <para>
				Denna symbios mellan hårdvara och programvara uppstår inte på egenhan. När datorm först startas upp krävs en del inledande inställning. Detta hanteras av BIOS eller UEFI, en bit programvara som finns inbyggd i moderkortet som automatiskt kör vid uppstart. Dess primära uppgift är att söka efter programvara som den kan lämna över kontrollen till. Vanligtvis, i BIOS-fallet, involverar detta att leta efter den första hårddisken med en startsektor (ocks känd som <emphasis>master boot record</emphasis> (huvudstartsektor) eller <acronym>MBR</acronym>), läsa in denna sektor och köra den. Därefter är BIOS vanligtvis inte involverat (förrän vid nästa uppstart). I fallet med UEFI involverar processen letande efter diskar för att hitta en specifik EFI-partition som innehåller vidare EFI-program att exekvera.
			</para>
			 <sidebar> <title><emphasis>VERKTYG</emphasis> Inställning, BIOS/UEFI-konfigurationsverktyget</title>
			 <indexterm>
				<primary><emphasis>Inställning</emphasis></primary>
			</indexterm>
			 <para>
				The BIOS/UEFI also contains a piece of software called Setup, designed to allow configuring aspects of the computer. In particular, it allows choosing which boot device is preferred (for instance, the floppy disk or CD-ROM drive), setting the system clock, and so on. Starting Setup usually involves pressing a key very soon after the computer is powered on. This key is often <keycap>Del</keycap> or <keycap>Esc</keycap>, sometimes <keycap>F2</keycap> or <keycap>F10</keycap>. Most of the time, the choice is flashed on screen while booting.
			</para>
			 </sidebar> <para>
				The boot sector (or the EFI partition), in turn, contains another piece of software, called the bootloader, whose purpose is to find and run an operating system. Since this bootloader is not embedded in the main board but loaded from disk, it can be smarter than the BIOS, which explains why the BIOS does not load the operating system by itself. For instance, the bootloader (often GRUB on Linux systems) can list the available operating systems and ask the user to choose one. Usually, a time-out and default choice is provided. Sometimes the user can also choose to add parameters to pass to the kernel, and so on. Eventually, a kernel is found, loaded into memory, and executed.
			</para>
			 <sidebar> <title><emphasis>NOTE</emphasis> UEFI, a modern replacement to the BIOS</title>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>Secure Boot</primary>
			</indexterm>
			 <para>
				UEFI is a relatively recent development. Most new computers will support UEFI booting, but usually they also support BIOS booting alongside for backwards compatibility with operating systems that are not ready to exploit UEFI.
			</para>
			 <para>
				This new system gets rid of some of the limitations of BIOS booting: with the usage of a dedicated partition, the bootloaders no longer need special tricks to fit in a tiny <emphasis>master boot record</emphasis> and then discover the kernel to boot. Even better, with a suitably built Linux kernel, UEFI can directly boot the kernel without any intermediary bootloader. UEFI is also the basic foundation used to deliver <emphasis>Secure Boot</emphasis>, a technology ensuring that you run only software validated by your operating system vendor.
			</para>
			 </sidebar> <para>
				The BIOS/UEFI is also in charge of detecting and initializing a number of devices. Obviously, this includes the IDE/SATA devices (usually hard disk(s) and CD/DVD-ROM drives), but also PCI devices. Detected devices are often listed on screen during the boot process. If this list goes by too fast, use the <keycap>Pause</keycap> key to freeze it for long enough to read. Installed PCI devices that don't appear are a bad omen. At worst, the device is faulty. At best, it is merely incompatible with the current version of the BIOS or main board. PCI specifications evolve, and old main boards are not guaranteed to handle newer PCI devices.
			</para>

		</section>
		 <section id="sect.kernel">
			<title>The Kernel</title>
			 <para>
				Both the BIOS/UEFI and the bootloader only run for a few seconds each; now we are getting to the first piece of software that runs for a longer time, the operating system kernel. This kernel assumes the role of a conductor in an orchestra, and ensures coordination between hardware and software. This role involves several tasks including: driving hardware, managing processes, users and permissions, the filesystem, and so on. The kernel provides a common base to all other programs on the system.
			</para>

		</section>
		 <section id="sect.userspace-presentation">
			<title>The User Space</title>
			 <para>
				Although everything that happens outside of the kernel can be lumped together under “user space”, we can still separate it into software layers. However, their interactions are more complex than before, and the classifications may not be as simple. An application commonly uses libraries, which in turn involve the kernel, but the communications can also involve other programs, or even many libraries calling each other.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-role-and-tasks">
		<title>Some Tasks Handled by the Kernel</title>
		 <section id="sect.hardware-drivers">
			<title>Driving the Hardware</title>
			 <para>
				The kernel is, first and foremost, tasked with controlling the hardware parts, detecting them, switching them on when the computer is powered on, and so on. It also makes them available to higher-level software with a simplified programming interface, so applications can take advantage of devices without having to worry about details such as which extension slot the option board is plugged into. The programming interface also provides an abstraction layer; this allows video-conferencing software, for example, to use a webcam independently of its make and model. The software can just use the <emphasis>Video for Linux</emphasis> (V4L) interface, and the kernel translates the function calls of this interface into the actual hardware commands needed by the specific webcam in use.
			</para>
			 <para>
				<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> The kernel exports many details about detected hardware through the <filename>/proc/</filename> and <filename>/sys/</filename> virtual filesystems. Several tools summarize those details. Among them, <command>lspci</command> (in the <emphasis role="pkg">pciutils</emphasis> package) lists PCI devices, <command>lsusb</command> (in the <emphasis role="pkg">usbutils</emphasis> package) lists USB devices, and <command>lspcmcia</command> (in the <emphasis role="pkg">pcmciautils</emphasis> package) lists PCMCIA cards. These tools are very useful for identifying the exact model of a device. This identification also allows more precise searches on the web, which in turn, lead to more relevant documents.
			</para>
			 <example>
				<title>Example of information provided by <command>lspci</command> and <command>lsusb</command></title>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>

			</example>
			 <para>
				These programs have a <literal>-v</literal> option, that lists much more detailed (but usually not necessary) information. Finally, the <command>lsdev</command> command (in the <emphasis role="pkg">procinfo</emphasis> package) lists communication resources used by devices.
			</para>
			 <para>
				Applications often access devices by way of special files created within <filename>/dev/</filename> (see sidebar <xref linkend="sidebar.special-files" />). These are special files that represent disk drives (for instance, <filename>/dev/hda</filename> and <filename>/dev/sdc</filename>), partitions (<filename>/dev/hda1</filename> or <filename>/dev/sdc3</filename>), mice (<filename>/dev/input/mouse0</filename>), keyboards (<filename>/dev/input/event0</filename>), soundcards (<filename>/dev/snd/*</filename>), serial ports (<filename>/dev/ttyS*</filename>), and so on.
			</para>

		</section>
		 <section id="sect.filesystems">
			<title>Filesystems</title>
			 <indexterm>
				<primary>filesystem</primary>
			</indexterm>
			 <indexterm>
				<primary>system, filesystem</primary>
			</indexterm>
			 <para>
				Filesystems are one of the most prominent aspects of the kernel. Unix systems merge all the file stores into a single hierarchy, which allows users (and applications) to access data simply by knowing its location within that hierarchy.
			</para>
			 <para>
				The starting point of this hierarchical tree is called the root, <filename>/</filename>. This directory can contain named subdirectories. For instance, the <literal>home</literal> subdirectory of <filename>/</filename> is called <filename>/home/</filename>. This subdirectory can, in turn, contain other subdirectories, and so on. Each directory can also contain files, where the actual data will be stored. Thus, the <filename>/home/rmas/Desktop/hello.txt</filename> name refers to a file named <literal>hello.txt</literal> stored in the <literal>Desktop</literal> subdirectory of the <literal>rmas</literal> subdirectory of the <literal>home</literal> directory present in the root. The kernel translates between this naming system and the actual, physical storage on a disk.
			</para>
			 <para>
				Unlike other systems, there is only one such hierarchy, and it can integrate data from several disks. One of these disks is used as the root, and the others are “mounted” on directories in the hierarchy (the Unix command is called <command>mount</command>); these other disks are then available under these “mount points”. This allows storing users' home directories (traditionally stored within <filename>/home/</filename>) on a second hard disk, which will contain the <literal>rhertzog</literal> and <literal>rmas</literal> directories. Once the disk is mounted on <filename>/home/</filename>, these directories become accessible at their usual locations, and paths such as <filename>/home/rmas/Desktop/hello.txt</filename> keep working.
			</para>
			 <indexterm>
				<primary><command>mkfs</command></primary>
			</indexterm>
			 <para>
				There are many filesystem formats, corresponding to many ways of physically storing data on disks. The most widely known are <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> and <emphasis>ext4</emphasis>, but others exist. For instance, <emphasis>vfat</emphasis> is the system that was historically used by DOS and Windows operating systems, which allows using hard disks under Debian as well as under Windows. In any case, a filesystem must be prepared on a disk before it can be mounted and this operation is known as “formatting”. Commands such as <command>mkfs.ext3</command> (where <command>mkfs</command> stands for <emphasis>MaKe FileSystem</emphasis>) handle formatting. These commands require, as a parameter, a device file representing the partition to be formatted (for instance, <filename>/dev/sda1</filename>). This operation is destructive and should only be run once, except if one deliberately wishes to wipe a filesystem and start afresh.
			</para>
			 <para>
				There are also network filesystems, such as <acronym>NFS</acronym>, where data is not stored on a local disk. Instead, data is transmitted through the network to a server that stores and retrieves them on demand. The filesystem abstraction shields users from having to care: files remain accessible in their usual hierarchical way.
			</para>

		</section>
		 <section id="sect.shared-functions">
			<title>Shared Functions</title>
			 <para>
				Since a number of the same functions are used by all software, it makes sense to centralize them in the kernel. For instance, shared filesystem handling allows any application to simply open a file by name, without needing to worry where the file is stored physically. The file can be stored in several different slices on a hard disk, or split across several hard disks, or even stored on a remote file server. Shared communication functions are used by applications to exchange data independently of the way the data is transported. For instance, transport could be over any combination of local or wireless networks, or over a telephone landline.
			</para>

		</section>
		 <section id="sect.process-management">
			<title>Hantera processer</title>
			 <indexterm>
				<primary><emphasis>pid</emphasis></primary>
			</indexterm>
			 <para>
				A process is a running instance of a program. This requires memory to store both the program itself and its operating data. The kernel is in charge of creating and tracking them. When a program runs, the kernel first sets aside some memory, then loads the executable code from the filesystem into it, and then starts the code running. It keeps information about this process, the most visible of which is an identification number known as <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis>).
			</para>
			 <para>
				Unix-like kernels (including Linux), like most other modern operating systems, are capable of “multi-tasking”. In other words, they allow running many processes “at the same time”. There is actually only one running process at any one time, but the kernel cuts time into small slices and runs each process in turn. Since these time slices are very short (in the millisecond range), they create the illusion of processes running in parallel, although they are actually only active during some time intervals and idle the rest of the time. The kernel's job is to adjust its scheduling mechanisms to keep that illusion, while maximizing the global system performance. If the time slices are too long, the application may not appear as responsive as desired. Too short, and the system loses time switching tasks too frequently. These decisions can be tweaked with process priorities. High-priority processes will run for longer and with more frequent time slices than low-priority processes.
			</para>
			 <sidebar> <title><emphasis>NOTE</emphasis> Multi-processor systems (and variants)</title>
			 <para>
				The limitation described above of only one process being able to run at a time, doesn't always apply. The actual restriction is that there can only be one running process <emphasis>per processor core</emphasis> at a time. Multi-processor, multi-core or “hyper-threaded” systems allow several processes to run in parallel. The same time-slicing system is still used, though, so as to handle cases where there are more active processes than available processor cores. This is far from unusual: a basic system, even a mostly idle one, almost always has tens of running processes.
			</para>
			 </sidebar> <para>
				Of course, the kernel allows running several independent instances of the same program. But each can only access its own time slices and memory. Their data thus remain independent.
			</para>

		</section>
		 <section id="sect.permissions">
			<title>Rights Management</title>
			 <para>
				Unix-like systems are also multi-user. They provide a rights management system that supports separate users and groups; it also allows control over actions based on permissions. The kernel manages data for each process, allowing it to control permissions. Most of the time, a process is identified by the user who started it. That process is only permitted to take those actions available to its owner. For instance, trying to open a file requires the kernel to check the process identity against access permissions (for more details on this particular example, see <xref linkend="sect.rights-management" />).
			</para>

		</section>

	</section>
	 <section id="sect.user-space">
		<title>The User Space</title>
		 <indexterm>
			<primary>user space</primary>
		</indexterm>
		 <indexterm>
			<primary>kernel space</primary>
		</indexterm>
		 <para>
			“User space” refers to the runtime environment of normal (as opposed to kernel) processes. This does not necessarily mean these processes are actually started by users because a standard system normally has several “daemon” (or background) processes running before the user even opens a session. Daemon processes are also considered user-space processes.
		</para>
		 <section id="sect.process-basics">
			<title>Process</title>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				When the kernel gets past its initialization phase, it starts the very first process, <command>init</command>. Process #1 alone is very rarely useful by itself, and Unix-like systems run with many additional processes.
			</para>
			 <indexterm>
				<primary><emphasis>fork</emphasis></primary>
			</indexterm>
			 <para>
				First of all, a process can clone itself (this is known as a <emphasis>fork</emphasis>). The kernel allocates a new (but identical) process memory space, and another process to use it. At this time, the only difference between these two processes is their <emphasis>pid</emphasis>. The new process is usually called a child process, and the original process whose <emphasis>pid</emphasis> doesn't change, is called the parent process.
			</para>
			 <para>
				Sometimes, the child process continues to lead its own life independently from its parent, with its own data copied from the parent process. In many cases, though, this child process executes another program. With a few exceptions, its memory is simply replaced by that of the new program, and execution of this new program begins. This is the mechanism used by the init process (with process number 1) to start additional services and execute the whole startup sequence. At some point, one process among <command>init</command>'s offspring starts a graphical interface for users to log in to (the actual sequence of events is described in more details in <xref linkend="sect.system-boot" />).
			</para>
			 <para>
				When a process finishes the task for which it was started, it terminates. The kernel then recovers the memory assigned to this process, and stops giving it slices of running time. The parent process is told about its child process being terminated, which allows a process to wait for the completion of a task it delegated to a child process. This behavior is plainly visible in command-line interpreters (known as <emphasis>shells</emphasis>). When a command is typed into a shell, the prompt only comes back when the execution of the command is over. Most shells allow for running the command in the background, it is a simple matter of adding an <userinput>&amp;</userinput> to the end of the command. The prompt is displayed again right away, which can lead to problems if the command needs to display data of its own.
			</para>

		</section>
		 <section id="sect.daemons">
			<title>Daemons</title>
			 <indexterm>
				<primary>daemon</primary>
			</indexterm>
			 <indexterm>
				<primary>daemon</primary>
			</indexterm>
			 <para>
				A “daemon” is a process started automatically by the boot sequence. It keeps running (in the background) to perform maintenance tasks or provide services to other processes. This “background task” is actually arbitrary, and does not match anything particular from the system's point of view. They are simply processes, quite similar to other processes, which run in turn when their time slice comes. The distinction is only in the human language: a process that runs with no interaction with a user (in particular, without any graphical interface) is said to be running “in the background” or “as a daemon”.
			</para>
			 <sidebar> <title><emphasis>VOCABULARY</emphasis> Daemon, demon, a derogatory term?</title>
			 <para>
				Although <emphasis>daemon</emphasis> term shares its Greek etymology with <emphasis>demon</emphasis>, the former does not imply diabolical evil, instead, it should be understood as a kind of helper spirit. This distinction is subtle enough in English; it is even worse in other languages where the same word is used for both meanings.
			</para>
			 </sidebar> <para>
				Several such daemons are described in detail in <xref linkend="unix-services" />.
			</para>

		</section>
		 <section id="sect.ipc">
			<title>Inter-Process Communications</title>
			 <indexterm>
				<primary>IPC</primary>
			</indexterm>
			 <indexterm>
				<primary>Inter-Process Communications</primary>
			</indexterm>
			 <para>
				An isolated process, whether a daemon or an interactive application, is rarely useful on its own, which is why there are several methods allowing separate processes to communicate together, either to exchange data or to control one another. The generic term referring to this is <emphasis>inter-process communication</emphasis>, or IPC for short.
			</para>
			 <para>
				The simplest IPC system is to use files. The process that wishes to send data writes it into a file (with a name known in advance), while the recipient only has to open the file and read its contents.
			</para>
			 <indexterm>
				<primary><emphasis>pipe</emphasis></primary>
			</indexterm>
			 <para>
				In the case where you do not wish to store data on disk, you can use a <emphasis>pipe</emphasis>, which is simply an object with two ends; bytes written in one end are readable at the other. If the ends are controlled by separate processes, this leads to a simple and convenient inter-process communication channel. Pipes can be classified into two categories: named pipes, and anonymous pipes. A named pipe is represented by an entry on the filesystem (although the transmitted data is not stored there), so both processes can open it independently if the location of the named pipe is known beforehand. In cases where the communicating processes are related (for instance, a parent and its child process), the parent process can also create an anonymous pipe before forking, and the child inherits it. Both processes will then be able to exchange data through the pipe without needing the filesystem.
			</para>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> A concrete example</title>
			 <para>
				Let's describe in some detail what happens when a complex command (a <emphasis>pipeline</emphasis>) is run from a shell. We assume we have a <command>bash</command> process (the standard user shell on Debian), with <emphasis>pid</emphasis> 4374; into this shell, we type the command: <command>ls | sort</command> .
			</para>
			 <para>
				The shell first interprets the command typed in. In our case, it understands there are two programs (<command>ls</command> and <command>sort</command>), with a data stream flowing from one to the other (denoted by the <userinput>|</userinput> character, known as <emphasis>pipe</emphasis>). <command>bash</command> first creates an unnamed pipe (which initially exists only within the <command>bash</command> process itself).
			</para>
			 <para>
				Then the shell clones itself; this leads to a new <command>bash</command> process, with <emphasis>pid</emphasis> #4521 (<emphasis>pids</emphasis> are abstract numbers, and generally have no particular meaning). Process #4521 inherits the pipe, which means it is able to write in its “input” side; <command>bash</command> redirects its standard output stream to this pipe's input. Then it executes (and replaces itself with) the <command>ls</command> program, which lists the contents of the current directory. Since <command>ls</command> writes on its standard output, and this output has previously been redirected, the results are effectively sent into the pipe.
			</para>
			 <para>
				A similar operation happens for the second command: <command>bash</command> clones itself again, leading to a new <command>bash</command> process with pid #4522. Since it is also a child process of #4374, it also inherits the pipe; <command>bash</command> then connects its standard input to the pipe output, then executes (and replaces itself with) the <command>sort</command> command, which sorts its input and displays the results.
			</para>
			 <para>
				All the pieces of the puzzle are now set up: <command>ls</command> reads the current directory and writes the list of files into the pipe; <command>sort</command> reads this list, sorts it alphabetically, and displays the results. Processes numbers #4521 and #4522 then terminate, and #4374 (which was waiting for them during the operation), resumes control and displays the prompt to allow the user to type in a new command.
			</para>
			 </sidebar> <para>
				Not all inter-process communications are used to move data around, though. In many situations, the only information that needs to be transmitted are control messages such as “pause execution” or “resume execution”. Unix (and Linux) provides a mechanism known as <emphasis>signals</emphasis>, through which a process can simply send a specific signal (chosen from a predefined list of signals) to another process. The only requirement is to know the <emphasis>pid</emphasis> of the target.
			</para>
			 <para>
				For more complex communications, there are also mechanisms allowing a process to open access, or share, part of its allocated memory to other processes. Memory now shared between them can be used to move data between the processes.
			</para>
			 <para>
				Finally, network connections can also help processes communicate; these processes can even be running on different computers, possibly thousands of kilometers apart.
			</para>
			 <para>
				It is quite standard for a typical Unix-like system to make use of all these mechanisms to various degrees.
			</para>

		</section>
		 <section id="sect.libraries">
			<title>Libraries</title>
			 <indexterm>
				<primary>library (of functions)</primary>
			</indexterm>
			 <para>
				Function libraries play a crucial role in a Unix-like operating system. They are not proper programs, since they cannot be executed on their own, but collections of code fragments that can be used by standard programs. Among the common libraries, you can find:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						the standard C library (<emphasis>glibc</emphasis>), which contains basic functions such as ones to open files or network connections, and others facilitating interactions with the kernel;
					</para>

				</listitem>
				 <listitem>
					<para>
						graphical toolkits, such as Gtk+ and Qt, allowing many programs to reuse the graphical objects they provide;
					</para>

				</listitem>
				 <listitem>
					<para>
						the <emphasis>libpng</emphasis> library, that allows loading, interpreting and saving images in the PNG format.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Thanks to those libraries, applications can reuse existing code. Application development is simplified since many applications can reuse the same functions. With libraries often developed by different persons, the global development of the system is closer to Unix's historical philosophy.
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> The Unix Way: one thing at a time</title>
			 <para>
				One of the fundamental concepts that underlies the Unix family of operating systems is that each tool should only do one thing, and do it well; applications can then reuse these tools to build more advanced logic on top. This philosophy can be seen in many incarnations. Shell scripts may be the best example: they assemble complex sequences of very simple tools (such as <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command> and so on). Another implementation of this philosophy can be seen in code libraries: the <emphasis>libpng</emphasis> library allows reading and writing PNG images, with different options and in different ways, but it does only that; no question of including functions that display or edit images.
			</para>
			 </sidebar> <para>
				Moreover, these libraries are often referred to as “shared libraries”, since the kernel is able to only load them into memory once, even if several processes use the same library at the same time. This allows saving memory, when compared with the opposite (hypothetical) situation where the code for a library would be loaded as many times as there are processes using it.
			</para>

		</section>

	</section>
</appendix>

