<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course" lang="sv-SE">
	<appendixinfo>
		 <keywordset>
			<keyword>BIOS</keyword>
			 <keyword>Kärna</keyword>
			 <keyword>Unix</keyword>
			 <keyword>Process</keyword>
			 <keyword>Hierarki</keyword>
			 <keyword>Grundläggande kommandon</keyword>

		</keywordset>

	</appendixinfo>
	 <title>Kort snabbkurs</title>
	 <highlights> <para>
		Även om denna bok i huvudsak har administratörer och avancerade användare som målgrupp vill vi inte exkludera motiverade nybörjare. Denna bilaga kommer därför att utgöra en snabbkurs som beskriver de grundläggande koncepten som inbegrips i att hantera en Unix-dator.
	</para>
	 </highlights> <section id="sect.shell-and-basic-commands">
		<title>Skalet och grundläggande kommandon</title>
		 <para>
			I Unix-världen måste varje administratör använda kommandoraden förr eller senare; till exempel när systemet misslyckas med att starta upp korrekt och endast tillgängliggör ett räddningsläge med en kommandorad. Att kunna hantera ett sådant gränssnitt är därför en grundläggande överlevnadskunskap under dessa förutsättningar.
		</para>
		 <sidebar> <title><emphasis>SNABBTITT</emphasis> Starta kommandotolken</title>
		 <para>
			A command-line environment can be run from the graphical desktop, by an application known as a “terminal”. In GNOME, you can start it from the “Activities” overview (that you get when you move the mouse in the top-left corner of the screen) by typing the first letters of the application name. In Plasma, you will find it in the <menuchoice><guimenu>K</guimenu> <guisubmenu>Applications</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice> menu.
		</para>
		 </sidebar> <para>
			Detta avsnitt ger endast en snabbtitt på kommandona. De har alla flertalet flaggor som inte beskrivs här, så referera till den rikliga dokumentationen i deras respektive manualsidor.
		</para>
		 <section>
			<title>Att bläddra i katalogstrukturen och att hantera filer</title>
			 <para>
				När en session är öppen visar kommandot <command>pwd</command> (som står för <emphasis>print working directory</emphasis>, skriv ut arbetskatalog) den aktuella platsen i filsystemet. Den aktuella katalogen ändras med kommandot <command>cd <replaceable>katalog</replaceable></command> (<command>cd</command> är kort för <emphasis>change directory</emphasis>, byt katalog). Föräldrakatalogen kallas alltid <literal>..</literal> (två punkter), medan den aktuella katalogen också är känd som <literal>.</literal> (en punkt). Kommandot <command>ls</command> möjliggör <emphasis>listning</emphasis> av innehållet i en katalog. Om inga parametrar anges arbetar det på den aktuella katalogen.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>cd Skrivbord</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Skrivbord
$ </computeroutput><userinput>cd .</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Skrivbord
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>ls</userinput>
<computeroutput>Bilder  Dokument  Hämtningar  Mallar
Musik   Publikt   Skrivbord   Video</computeroutput>
</screen>
			 <para>
				En ny katalog kan skapas med <command>mkdir <replaceable>katalog</replaceable></command>, och en existerande (tom) katalog kan tas bort med <command>rmdir <replaceable>katalog</replaceable></command>. Kommandot <command>mv</command> möjliggör <emphasis>förflyttning</emphasis> (moving) och/eller namnbyte för filer och kataloger; <emphasis>borttagning</emphasis> av en fil åstadkoms med <command>rm <replaceable>fil</replaceable></command>.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Bilder   Dokument   Hämtningar  Mallar  Musik 
Publikt  Skrivbord  Video       test
$ </computeroutput><userinput>mv test ny</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Bilder   Dokument   Hämtningar  Mallar  Musik 
Publikt  Skrivbord  Video       ny
$ </computeroutput><userinput>rmdir ny</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Bilder  Dokument  Hämtningar  Mallar
Musik   Publikt   Skrivbord   Video</computeroutput>
</screen>

		</section>
		 <section>
			<title>Visa och modifiera textfiler</title>
			 <para>
				Kommandot <command>cat <replaceable>fil</replaceable></command> (avsett att <emphasis>konkatenera</emphasis> filer till enheten standard ut) läser en fil och visar dess innehåll i terminalen. Om en fil är för stor för att få plats på en skärm, använd en sidvisare så som <command>less</command> (eller <command>more</command>) för att visa den sida för sida.
			</para>
			 <para>
				Kommandot <command>editor</command> startar en textredigerare (så som <command>vi</command> eller <command>nano</command>) och tillåter skapande, modifiering och läsning av textfiler. De enklaste filerna kan ibland skapas direkt från kommandotolken tack vare omdirigering: <command>echo "<replaceable>text</replaceable>" &gt; <replaceable>fil</replaceable></command> skapar en fil vid namn <replaceable>fil</replaceable> med innehållet ”<replaceable>text</replaceable>”. Att lägga till en rad på slutet av filen är också möjligt, med ett kommando så som <command>echo "<replaceable>mertext</replaceable>" &gt;&gt;<replaceable>fil</replaceable></command>. Notera <literal>&gt;&gt;</literal> i detta exempel.
			</para>

		</section>
		 <section>
			<title>Att söka efter filer och inom filer</title>
			 <para>
				Kommandot <command>find <replaceable>katalog</replaceable> <replaceable>kriterier</replaceable></command> letar efter filer i hierarkin under <replaceable>katalog</replaceable> enligt flertalet kriterier. Det vanligaste kriteriet är <literal>-name <replaceable>namn</replaceable></literal>: detta möjliggör sökning efter en fil efter namn.
			</para>
			 <para>
				Kommandot <command>grep <replaceable>uttryck</replaceable> <replaceable>filer</replaceable></command> genomsöker innehållet i filerna och extraherar rader som matchar det reguljära uttrycket (se sidopanelen <xref linkend="sidebar.regexp" />). Att lägga till flaggan <literal>-r</literal> aktiverar en rekursiv sökning av alla filer som finns i katalogen som anges som parameter. Detta möjliggör sökning efter en fil när endast en del av dess innehåll är känt.
			</para>

		</section>
		 <section>
			<title>Hantera processer</title>
			 <para>
				Kommandot <command>ps aux</command> listar processerna som för närvarande kör och hjälper till att identifiera dem genom att visa deras <emphasis>pid</emphasis> (process-ID). När <emphasis>pid</emphasis> för en process är känt låter kommandot <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> en signal skickas till processen (om processen tillhör den aktuella användaren). Flera signaler existerar; vanligast är <literal>TERM</literal> (en begäran om att graciöst avsluta programmet) och <literal>KILL</literal> (en påtvingad död).
			</para>
			 <para>
				Kommandotolken kan också köra program i bakgrunden om kommandot åtföljs av ett ”&amp;”. Genom att använda och-tecknet återfår användare kontrollen av skalet omedelbart även om programmet fortfarande kör (gömt från användaren; som en bakgrundsprocess). Kommandot <command>jobs</command> listar processerna som kör i bakgrunden; för att återuppta ett jobb i förgrunden kör <command>fg %<replaceable>job-number</replaceable></command> (som i <emphasis>förgrund</emphasis>). När ett kommando kör i förgrunden (antingen för att det startades normalt, eller återupptaget i förgrunden med <command>fg</command>), kan tangentkombinationen <keycombo action="simul"><keycap>Ctrl</keycap><keycap>Z</keycap></keycombo> användas för att pausa processen och återuppta kontrollen av kommandoraden. Processen kan sedan återstartas i bakgrunden med <command> bg %<replaceable>job-number</replaceable></command> (efter <foreignphrase>bakgrund</foreignphrase>).
			</para>

		</section>
		 <section>
			<title>Systeminformation: Minne, diskutrymme, identitet</title>
			 <para>
				Kommandot <command>free</command> visar information om minnet; <command>df</command> (<emphasis>disk free</emphasis>, ledig disk) rapporterar om tillgängligt diskutrymme på vardera av de monterade diskarna i filsystemet. Dess flagga <literal>-h</literal> (för <emphasis>human readable</emphasis>, mänskligt läsbar) konverterar storlekarna till en mer lättförståelig enhet (vanligtvis mebibyte eller gibibyte). På samma sätt har kommandot <command>free</command> stöd för flaggorna <literal>-m</literal> och <literal>-g</literal> och visar då data antingen i mebibyte eller gibibyte.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       använt     fritt    delat     buffertar   cache
Minne:     1028420    1009624      18796          0      47404     391804
-/+ buff/cache:        570416     458004
Växl.:     2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>Filsystem            1K-block       Använt Tillgängligt Anv% Monterat på
/dev/sda2              9614084   4737916   4387796  52% /
tmpfs                   514208         0    514208   0% /lib/init/rw
udev                     10240       100     10140   1% /dev
tmpfs                   514208    269136    245072  53% /dev/shm
/dev/sda5             44552904  36315896   7784380  83% /home
</computeroutput></screen>
			 <para>
				Kommandot <command>id</command> visar identiteten för användare som kör sessionen, tillsammans med listan över grupper som de är medlemmar i. Då åtkomst till vissa filer eller enheter kan vara begränsat till gruppmedlemmar kan det vara användbart att kontrollera gruppmedlemskap.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
</screen>

		</section>

	</section>
	 <section id="sect.filesystem-hierarchy">
		<title>Organisation av filsystemshierarkin</title>
		 <indexterm>
			<primary>Filsystemshierarki</primary>
		</indexterm>
		 <section>
			<title>Rotkatalogen</title>
			 <para>
				Ett Debian-system organiseras enligt <emphasis>Filesystem Hierarchy Standard</emphasis> (FHS, Standarden för filsystemshierarki). Denna standard definierar syftet med varje katalog. Toppnivåkatalogerna beskrivs till exempel enligt följande:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<filename>/bin/</filename>: grundläggande program;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/boot/</filename>: Linux-kärna och andra filer som krävs för dess tidiga uppstart;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/dev/</filename>: enhetsfiler;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/etc/</filename>: konfigurationsfiler;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/home/</filename>: användares personliga filer;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/lib/</filename>: grundläggande bibliotek;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/media/*</filename>: monteringspunkter för flyttbara enheter (CD-ROM, USB-nycklar och så vidare);
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/mnt/</filename>: temporär monteringspunkt;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/opt/</filename>: extra program som tillhandahålls av tredjepart;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/root/</filename>: administratörens (roots) personliga filer;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/run/</filename>: flyktig körtidsdata som inte består mellan omstarter (ännu inte inkluderad i FHS);
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/sbin/</filename>: systemprogram;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/srv/</filename>: data som används av servrar som är värdar på detta system;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/tmp/</filename>: temporära filer; denna katalog töms ofta vid uppstart;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/usr/</filename>: program; denna katalog är vidare uppdelad i <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (enligt samma logik som i rotkatalogen). Vidare innehåller <filename>/usr/share/</filename> arkitekturoberoende data. <filename>/usr/local/</filename> är avsedd att användas av administratören för att installera program manuellt utan att skriva över filer som hanteras av paketsystemet (<command>dpkg</command>).
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/var/</filename>: variabel data som hanteras av demoner. Detta inkluderar loggfiler, köer, köfiler, cachar och så vidare.
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/proc/</filename> och <filename>/sys/</filename> är specifika för Linux-kärnan (och är inte en del av FHS). De används av kärnan för att exportera data till användarrymden (se <xref linkend="sect.userspace-presentation" /> och <xref linkend="sect.user-space" /> för förklaringar om detta koncept).
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section>
			<title>Användarens hemkatalog</title>
			 <para>
				Innehållet i en användares hemkatalog är inte standardiserat, men det finns trots detta ett antal noterbara konventioner. En är att en användares hemkatalog ofta refereras till genom tilde (”~”). Detta är användbart att känna till eftersom kommandotolkar automatiskt ersätter ett tilde med den korrekta katalogen (vanligen <filename>/home/<replaceable>användare</replaceable>/</filename>).
			</para>
			 <para>
				Traditionellt lagras konfigurationsfiler för program direkt under användarens hemkatalog, men deras namn inleds vanligtvis med en punkt (t.ex. så lagrar e-postklienten <command>mutt</command> sin konfiguration i <filename>~/.muttrc</filename>). Notera att filnamn som börjar med punkt göms som standard; och <command>ls</command> listar endast dem när flaggan <literal>-a</literal> används, och grafiska filhanterare måste ombes att visa gömda filer.
			</para>
			 <para>
				Vissa program använder också multipla konfigurationsfiler organiserade i en katalog (t.ex. <filename>~/.ssh/</filename>). Vissa program (så som webbläsaren Iceweasel) använder också sin katalog för att spara en cache av hämtad data. Detta innebär att dessa kataloger kan komma att använda en stor mängd diskutrymme.
			</para>
			 <para>
				Dessa konfigurationsfiler lagrade direkt i en användares hemkatalog, som ofta kollektivt refereras till som <emphasis>punktfiler</emphasis>, har länge växt till en punkt där dessa kataloger kan bli ganska röriga. Lyckligtvis har en ansträngning kollektivt ledd under FreeDesktop.org-paraplyet resulterat i ”XDG Base Directory Specification” (XDG Specifikation för grundläggande kataloger), en konvention som ämnar att städa upp dessa filer och kataloger. Denna specifikation uppger att konfigurationsfiler bör sparas under <filename>~/.config</filename>, cachefiler under <filename>~/.cache</filename> och programdatafiler under <filename>~/.local</filename> (eller underkataloger däri). Denna konvention har långsamt börjat få dragkraft och flera program (speciellt grafiska) har börjat följa den.
			</para>
			 <para>
				Grafiska skrivbord visar vanligtvis innehåller i katalogen <filename>~/Skrivbord/</filename> (eller vad nu den lämpliga översättningen är för system som inte konfigurerats på svenska) på skrivbordet (dvs., det som är synligt på skärmen när alla program är stängda eller ikoniserade).
			</para>
			 <para>
				Avslutningsvis så lagrar e-postsystem inkommande e-postmeddelanden i en katalog <filename>~/Mail/</filename>.
			</para>

		</section>

	</section>
	 <section id="sect.computer-layers">
		<title>Hur en dator fungerar inuti: de olika lagren som är inblandade</title>
		 <para>
			En dator betraktas ofta som något ganska abstrakt, och det synliga externa gränssnittet är mycket enklare än dess inre komplexitet. Sådan komplexitet kommer från antalet delar som är involverade. Dessa delar kan dock betraktas i lager, där ett lager endast interagerar med de direkt ovanför eller under.
		</para>
		 <para>
			En slutanvändaren kan klara sig utan att känna till dessa detaljer… så länge allt fungerar. Vid konfrontation med ett problem så som ”Internet fungerar inte!”, är det första man ska göra att försöka identifiera i vilket lager felet uppstår. Fungerar nätverkskortet (hårdvara)? Hittas det av datorn? Kan Linux-kärnan se det? Är nätverksparametrarna korrekt konfigurerade? Alla dessa frågor isolerar ett specifikt lager och fokuserar på en potentiell källa till problemet.
		</para>
		 <section id="sect.hardware">
			<title>Det djupaste lagret: hårdvaran</title>
			 <indexterm>
				<primary>IDE</primary>
			</indexterm>
			 <indexterm>
				<primary>SCSI</primary>
			</indexterm>
			 <indexterm>
				<primary>Seriell ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>Parallell ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>Firewire</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <para>
				Låt oss börja med den inledande påminnelsen om att en dator i första hand är en uppsättning hårdvarudelar. Generellt finns det ett huvudkort (känt som <emphasis>moderkort</emphasis>) med en processor (eller flera processorer), lite RAM, styrenheter för andra enheter, platser för expansionskort (med styrenheter för andra enheter). Väsentliga bland dessa styrenheter är IDE (Parallell ATA), SCSI och Seriell ATA, då dessa ansluter lagringsenheter så som hårddiskar. Andra styrenheter inkluderar USB, som kan användas för att ansluta en stor mängd enheter (allt från webbkameror till termometrar, från tangentbord till hemautomationssystem) och IEEE 1394 (Firewire). Dessa styrenheter tillåter ofta anslutning av flera enheter, vilket leder till att det fullständiga undersystemet som hanteras av en styrenhet ofta refereras till som en ”buss”. Expansionskort inkluderar grafikkort (till vilket bildskärmar ansluts), ljudkort, nätverkskort, o.s.v. Vissa moderkort har dessa funktioner inbyggda, och behöver därför inte expansionskort.
			</para>
			 <sidebar> <title><emphasis>I PRAKTIKEN</emphasis> Kontrollera att hårdvaran fungerar</title>
			 <para>
				Att kontrollera att en bit hårdvara fungerar kan vara knepigt. Att bevisa att den inte fungerar kan å andra sidan vara ganska enkelt.
			</para>
			 <para>
				En hårddisk består av snurrande plattor och flyttbara magnetiska huvuden. När en hårddisk strömsätts hörs ett karakteristiskt ljud från motorn som snurrar plattorna. Den avger också energi i form av värme. En hårddisk som förblir kall och tyst när den får ström är därför sannolikt trasig.
			</para>
			 <para>
				Nätverkskort har ofta LED:ar som visar tillståndet för länken. Om en kabel som leder till en fungerande nätverkshubb eller switch ansluts kommer åtminstone en LED att tändas. Om ingen LED tänds är antingen kortet självt, nätverksenheten eller kabeln mellan dem trasig. Nästa steg är därför att testa varje komponent individuellt.
			</para>
			 <para>
				Vissa expansionskort — speciellt 3D-grafikkort — har kylningsenheter, så som kylflänsar och/eller fläktar. Om fläkten inte snurrar även om kortet är strömsatt är en trolig förklaring att kortet är överhettat. Detta gäller också för processorn som finns på moderkortet.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.bios">
			<title>Uppstartaren: BIOS eller UEFI</title>
			 <indexterm>
				<primary>BIOS</primary>
			</indexterm>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>Master Boot Record (MBR, huvudstartsektor)</primary>
			</indexterm>
			 <para>
				Hårdvara kan inte på egen hand utföra nyttiga uppgifter utan en motsvarande programvara som driver den. Att kontrollera och interagera med hårdvaran är därför syftet för operativsystemet och programmen. Dessa, å sin sida, kräver fungerande hårdvara för att köra.
			</para>
			 <para>
				Denna symbios mellan hårdvara och programvara uppstår inte på egen hand. När datorn först startas upp krävs en del inledande inställning. Detta hanteras av BIOS eller UEFI, en bit programvara som finns inbyggd i moderkortet som automatiskt kör vid uppstart. Dess primära uppgift är att söka efter programvara som den kan lämna över kontrollen till. Vanligtvis, i BIOS-fallet, involverar detta att leta efter den första hårddisken med en startsektor (också känd som <emphasis>master boot record</emphasis> (huvudstartsektor) eller <acronym>MBR</acronym>), läsa in denna sektor och köra den. Därefter är BIOS vanligtvis inte involverat (förrän vid nästa uppstart). I fallet med UEFI involverar processen letande efter diskar för att hitta en specifik EFI-partition som innehåller vidare EFI-program att exekvera.
			</para>
			 <sidebar> <title><emphasis>VERKTYG</emphasis> Inställning, BIOS/UEFI-konfigurationsverktyget</title>
			 <indexterm>
				<primary><emphasis>Inställning</emphasis></primary>
			</indexterm>
			 <para>
				BIOS/UEFI innehåller också en bit programvara som kallas Setup (inställning), designad för att tillåta konfiguration av delar av datorn. I synnerhet tillåter det val av vilken startenhet som föredras (till exempel, diskett- eller CD-ROM-enhet), ställa in systemklockan, o.s.v. Att starta Setup involverar vanligtvis att trycka på en knapp snart efter att datorn strömsatts. Tangenten är ofta <keycap>Del</keycap> eller <keycap>Esc</keycap>, eller ibland <keycap>F2</keycap> eller <keycap>F10</keycap>. För det mesta blinkar tangent snabbt förbi på skärmen under uppstarten.
			</para>
			 </sidebar> <para>
				Startsektorn (eller EFI-partitionen) innehåller en annan bit programvara som kallas startinläsaren, vars uppgift är att hitta och köra ett operativsystem. Då startinläsaren inte är inbyggd på moderkortet, utan läses in från disk, kan den vara smartare än BIOS, vilket förklarar varför BIOS inte läser in operativsystemet själv. Startinläsaren (ofta GRUB på Linux-system) kan till exempel lista de tillgängliga operativsystemen och be användaren att välja ett. Efter en tidsgräns finns vanligtvis ett standardval. Ibland kan användaren också välja att lägga till parametrar att skicka till kärnan, o.s.v. Slutligen hittas en kärna, läses in i minne och exekveras.
			</para>
			 <sidebar> <title><emphasis>NOTERA</emphasis> UEFI, en modern ersättare för BIOS</title>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>Säker uppstart</primary>
			</indexterm>
			 <para>
				UEFI är relativt nyutvecklat. De flesta nya datorer har stöd för UEFI-uppstart, men de har också stöd för BIOS-uppstart för bakåtkompatibilitet med operativsystem som inte är redo att utnyttja UEFI.
			</para>
			 <para>
				Detta nya system tar bort en del av begränsningarna hos BIOS-uppstart: via användning av en dedikerad partition behöver startinläsarna inte längre speciella trick för att få plats i en mycket liten <emphasis>master boot record</emphasis> (huvudstartsektor) för att sedan hitta kärnan som ska startas. Ännu bättre är att med en lämpligt byggt Linux-kärna kan UEFI direkt starta kärnan utan några mellanliggande startinläsare. UEFI är också grunden som används för <emphasis>Säker uppstart</emphasis>, en funktion som säkerställer att du endast kör programvara som validerats av leverantören av ditt operativsystem.
			</para>
			 </sidebar> <para>
				BIOS/UEFI är också ansvarigt för att detektera och initiera ett antal enheter. Detta inkluderar självklart IDE-/SATA-enheter (vanligtvis hårddiskar och CD-/DVD-ROM-enheter), men också PCI-enheter. Detekterade enheter listas ofta på skärmen under uppstarten. Om denna lista går för snabbt kan <keycap>Paus</keycap>-tangenten användas för att frysa den länge nog för att den ska kunna läsas. Installerade PCI-enheter som inte syns här är ett dåligt omen. I värsta fall är enheten trasig. I bästa fall är den endast inkompatibel med den aktuella versionen av BIOS eller moderkortet. PCI-specifikationer utvecklas och gamla moderkort garanterar inte att de kan hantera nyare PCI-enheter.
			</para>

		</section>
		 <section id="sect.kernel">
			<title>Kärnan</title>
			 <para>
				Både BIOS/UEFI och startinläsaren kör endast ett par sekunder vardera; nu får vi den första biten programvara som kör under en längre tid, operativsystemets kärna. Denna kärna får rollen som dirigent i en orkester, och säkerställer koordinationen mellan hårdvara och programvara. Denna roll involverar flera uppgifter, inklusive: köra hårdvara, hantera processer, användare och rättigheter, filsystemet o.s.v. Kärnan tillhandahåller en gemensam bas för alla andra program på systemet.
			</para>

		</section>
		 <section id="sect.userspace-presentation">
			<title>Användarrymden</title>
			 <para>
				Även om allting som händer utanför kärnan kan samlas ihop under uttrycket ”användarrymd”, kan vi fortfarande separera det i olika lager av programvara. Interaktionen mellan dem är mer komplex än tidigare och klassifikationerna är inte lika enkla. Ett program använder vanligen bibliotek, vilka i sin tur blandar in kärnan, men kommunikationen kan också involvera andra program eller flera bibliotek som anropar varandra.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-role-and-tasks">
		<title>Vissa uppgifter hanteras av kärnan</title>
		 <section id="sect.hardware-drivers">
			<title>Köra hårdvaran</title>
			 <para>
				Kärnan har, i första hand, uppgiften att kontrollera hårdvarudelarna, detektera dem, slå på dem när datorn är strömsatt o.s.v. Den gör dem också tillgängliga för programvara på högre nivå med ett förenklat programmeringsgränssnitt, så att program kan dra nytta av enheter utan att behöva känna till detaljer så som vilken expansionsport expansionskortet sitter i. Programmeringsgränssnittet tillhandahåller också ett abstraktionslager; detta låter till exempel videokonferenssystem använda en webbkamera oberoende av tillverkare och modell. Programvara kan helt enkelt använda gränssnittet <emphasis>Video for Linux</emphasis> (V4L, Video för Linux), varpå kärnan översätter funktionsanropen för detta gränssnitt till de hårdvarukommandon som behövs för den specifika webbkamera som används.
			</para>
			 <para>
				<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> Kärnan exporterar många detaljer om detekterad hårdvara via de virtuella filsystemen <filename>/proc/</filename> och <filename>/sys/</filename>. Flera verktyg sammanfattar dessa detaljer. Bland dem finns <command>lspci</command> (i paketet <emphasis role="pkg">pciutils</emphasis>) som listar PCI-enheter, <command>lsusb</command> (i paketet <emphasis role="pkg">usbutils</emphasis>) som listar USB-enheter, och <command>lspcmcia</command> (i paketet <emphasis role="pkg">pcmciautils</emphasis>) som listar PCMCIA-kort. Dessa verktyg är mycket användbara för att identifiera en enhets exakta modellnummer. Denna identifikation tillåter också mer precis sökning på internet, vilket i sin tur leder till mer relevanta dokument.
			</para>
			 <example>
				<title>Exempel på information som tillhandahålls av <command>lspci</command> och <command>lsusb</command></title>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>

			</example>
			 <para>
				Dessa program har en flagga <literal>-v</literal> som listar ännu mer detaljerad information (som vanligen inte behövs). Avslutningsvis listar kommandot <command>lsdev</command> (i paketet <emphasis role="pkg">procinfo</emphasis>) kommunikationsresurser som används av enheter.
			</para>
			 <para>
				Program får ofta tillgång till enheter genom speciella filer som skapas i <filename>/dev/</filename> (se sidopanel <xref linkend="sidebar.special-files" />). Dessa är speciella filer som representerar diskenheter (till exempel <filename>/dev/hda</filename> och <filename>/dev/sdc</filename>), partitioner (<filename>/dev/hda1/</filename> eller <filename>/dev/sdc3</filename>), möss (<filename>/dev/input/mouse0</filename>), tangentbord (<filename>/dev/input/event0</filename>), ljudkort (<filename>/dev/snd/*</filename>), serieportar (<filename>/dev/ttyS*</filename>), o.s.v.
			</para>

		</section>
		 <section id="sect.filesystems">
			<title>Filsystem</title>
			 <indexterm>
				<primary>filsystem</primary>
			</indexterm>
			 <indexterm>
				<primary>system, filsystem</primary>
			</indexterm>
			 <para>
				Filsystem är en av de väsentligaste aspekterna av kärnan. Unix-system sammanfogar alla lagrade filer i en enda hierarki, vilket låter användare (och program) komma åt data genom att endast känna till dess plats inom den hierarkin.
			</para>
			 <para>
				Startpunkten för detta hierarkiska träd kallas för roten, <filename>/</filename>. Denna katalog kan innehålla namngivna underkataloger. Till exempel är <literal>home</literal> en underkatalog till <filename>/</filename> som kallas <filename>/home/</filename>. Denna underkatalog kan i sin tur innehålla andra underkataloger, o.s.v. Varje katalog kan också innehålla filer, i vilka faktisk data kommer att lagras. Således refererar namnet <filename>/home/rmas/Skrivbord/hej.txt</filename> till en fil med namnet <literal>hej.txt</literal> lagrad i underkatalogen <literal>Skrivbord</literal> i underkatalogen <literal>rmas</literal> i katalogen <literal>home</literal> som finns i roten. Kärnan översätter mellan detta namngivningssystem och den riktiga fysiska lagringsplatsen på disk.
			</para>
			 <para>
				Till skillnad från andra operativsystem, finns det bara en sådan hierarki, och den kan integrera data från flera diskar. En av dessa diskar används som roten och de andras ”monteras” som kataloger i hierarkin (Unix-kommandot kallas <command>mount</command> (montera)); dess andra diskar är sedan tillgängliga under dessa ”monteringspunkter”. Detta tillåter lagring av användares hemkataloger (vanligtvis lagrade i <filename>/home/</filename>) på en annan hårddisk, vilken kommer att innehålla katalogerna <literal>rhertzog</literal> och <literal>rmas</literal>. När disken är monterad på <filename>/home/</filename> kommer dessa kataloger att kunna nås på deras vanliga platser, och sökvägar så som <filename>/home/rmas/Skrivbord/hej.txt</filename> kommer att fortsätta fungera.
			</para>
			 <indexterm>
				<primary><command>mkfs</command></primary>
			</indexterm>
			 <para>
				Det finns flera filsystemsformat, vilket motsvaras av att det finns många sätt att fysiskt lagra data på diskar. De mest kända är <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> och <emphasis>ext4</emphasis>, men andra finns också. Till exempel så användes filsystemet <emphasis>vfat</emphasis> historiskt av operativsystemen DOS och Windows, vilket tillåter att hårddiskar kan fungera under Debian såväl som under Windows. Oavsett vilket så måste filsystem förberedas på en disk innan de kan monteras och denna operation kallas ”formatering”. Kommandon så som <command>mkfs.ext3</command> (där <command>mkfs</command> står för <emphasis>MaKe FileSystem</emphasis> (skapa filsystem)) hanterar formatering. Dessa kommandon kräver, som en parameter, en enhetsfil som representerar den partition som ska formateras (till exempel <filename>/dev/sda1</filename>). Denna operation är destruktiv och bör endast köras en gång, förutom om man avsiktligen vill rensa ett filsystem och börja om från början.
			</para>
			 <para>
				Det finns också nätverksfilsystem, så som <acronym>NFS</acronym>, där data inte lagras på en lokal disk. Istället skickas data över nätverket till en server som lagrar och hämtar data vid behov. Filsystemsabstraktionen skyddar användaren från att behöva bry sig: filer förblir åtkomliga på det vanliga hierarkiska sättet.
			</para>

		</section>
		 <section id="sect.shared-functions">
			<title>Delade funktioner</title>
			 <para>
				Då ett antal funktioner används av all programvara är det vettigt att centralisera dem i kärnan. Delad filsystemshantering tillåter till exempel vilket program som helst att öppna en fil med namn, utan att behöva bry sig om var filen är lagrad fysiskt. Filen kan lagras på flera olika delar på en hårddisk, eller delad över flera hårddiskar, eller till och med lagrade på en fjärrfilserver. Delade kommunikationsfunktioner används av program för att utbyta data oberoende av hur data transporteras. Till exempel kan transport ske över en kombination av lokala eller trådlösa nätverk eller över en telefonlinje.
			</para>

		</section>
		 <section id="sect.process-management">
			<title>Hantera processer</title>
			 <indexterm>
				<primary><emphasis>pid</emphasis></primary>
			</indexterm>
			 <para>
				En process är en körande instans av ett program. Detta kräver minne för att lagra både programmet självt och dess data. Kärnan är ansvarig för att skapa och spåra dem. När ett program kör tilldelar kärnan först lite minne åt programmet, och läser sedan in den körbara koden från filsystem in i detta minne, och börjar sedan köra koden. Den håller information om denna process, det mest väsentliga är ett identifikationsnummer känt som <emphasis>pid</emphasis> (<emphasis>processidentifierare</emphasis>).
			</para>
			 <para>
				Unix-liknande kärnor (inklusive Linux) kan, likt de flera moderna operativsystem, göra flera saker samtidigt. Med andra ord de tillåter att man kör flera processer ”samtidigt”. Det är faktiskt bara en process som kör åt gången, men kärnan delar in tiden i små intervall och kör varje process i turordning. Då dessa tidsintervall är väldigt korta (i storleksordningen millisekunder), ger detta illusionen av att processerna kör parallell, även om de i verkligheten endast är aktiva under vissa tidsintervall och sover resten av tiden. Kärnans jobb är att justera sina schemaläggningsalgoritmer för att behålla den illusionen, medan systemets globala prestanda maximeras. Om tidsintervallen är för långa kan ett program upplevas som att det inte är responsivt. Om intervallen är för korta förlorar systemet tid då uppgifter växlas mellan allt för fort. Dessa beslut kan justeras med processprioriteter. Högprioriterade processer kommer att köra under länge tidsintervall och oftare än lågprioriterade processer.
			</para>
			 <sidebar> <title><emphasis>NOT</emphasis> Multiprocessorsystem (och varianter)</title>
			 <para>
				Begränsningen som beskrivits ovan, om att endast en process kan köra åt gången, gäller inte alltid. Den faktiska restriktionen är att det kan endast finnas en process som kör <emphasis>per processorkärna</emphasis>. Multiprocessorsystem, system med flera kärnor eller ”hypertrådar” låter flera processor köras parallellt. Samma tidsdelningssystem används fortfarande, för att hantera fall där det finns fler aktiva processer än det finns tillgängliga processorkärnor. Detta är långt i från ovanligt: ett grundläggande system, även ett mestadels vilande, har nästan alltid tiotals körande processer.
			</para>
			 </sidebar> <para>
				Kärnan tillåter förstås att flera oberoende instanser av samma program kör samtidigt. Men var och en kan endast använda sina egna tidsintervall och minne. Deras data förblir därmed oberoende.
			</para>

		</section>
		 <section id="sect.permissions">
			<title>Rättighetshantering</title>
			 <para>
				Unix-liknande system är också fleranvändarsystem. De tillhandahåller ett rättighetssystem som har stöd för separata användare och grupper; det tillåter också styrning av åtgärder baserade på rättigheter. Kärnan hanterar data för varje process, vilket låter den styra rättigheter. För det mesta identifieras en process av användaren som startade den. Den processen tillåts endast utföra de åtgärder som dess ägare kan utföra. Att försöka öppna en fil kräver till exempel att kärnan kontrollerar processidentiteten mot åtkomsträttigheter (för vidare information om detta specifika exempel se <xref linkend="sect.rights-management" />).
			</para>

		</section>

	</section>
	 <section id="sect.user-space">
		<title>Användarrymden</title>
		 <indexterm>
			<primary>användarrymd</primary>
		</indexterm>
		 <indexterm>
			<primary>kärnrymd</primary>
		</indexterm>
		 <para>
			”Användarrymd” refererar till körtidsmiljön för normala processor (till skillnad mot kärnprocesser). Detta innebär inte nödvändigtvis att dessa processer faktiskt startades av användare då ett standardsystem normalt har flera ”demon”-processer (eller bakgrundsprocesser) körandes innan användaren ens öppnar en session. Demonprocesser anses också vara användarrymdsprocesser.
		</para>
		 <section id="sect.process-basics">
			<title>Process</title>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				När kärnan kommer förbi sin initieringsfas startar den den allra första processen, <command>init</command>. Process #1 är ensam sällan särskilt användbar, och Unix-liknande system kör med många flera processer.
			</para>
			 <indexterm>
				<primary><emphasis>fork</emphasis></primary>
			</indexterm>
			 <para>
				För det första kan en process klona sig själv (detta är känt som <emphasis>fork</emphasis>). Kärnan allokerar ett nytt (men identiskt) minnesområde för processen, och en ny process som kan använda den. Vid denna tidpunkt är den enda skillnaden mellan dessa två processer deras <emphasis>pid</emphasis>. Den nya processen kallas vanligen en barnprocess, och originalprocessen vars <emphasis>pid</emphasis> inte ändras, kallas för föräldraprocessen.
			</para>
			 <para>
				Ibland fortsätter barnprocessen att leva sitt eget liv, oberoende från sin förälder, med sin egen data kopierad från föräldraprocessen. I många fall exekverar dock denna barnprocess ett annat program. Med ett fåtal undantag ersätts dess minne helt enkelt med det för det nya programmet och exekvering av detta nya program påbörjas. Detta är mekanismen som används av initprocessen (med processnummer 1) för att starta ytterligare tjänster och exekvera hela uppstartssekvensen. Vid en tidpunkt kommer en process bland <command>init</command>s barn att starta ett grafiskt gränssnitt genom vilket användare kan logga in (den faktiska sekvensen av händelser beskrivs i ytterligare detalj i <xref linkend="sect.system-boot" />).
			</para>
			 <para>
				När en process avslutar uppgiften som var anledningen till att den startades så avslutas den. Kärnan återhämtar sedan minne som tilldelats till denna process och slutar ge den körtidsintervall. Föräldraprocessen informeras om att dess barnprocess avslutats, vilket låter en process vänta på att en uppgift som delegerats till en barnprocess slutförts. Detta beteende syns tydligt i kommandotolkar (kända som <emphasis>skal</emphasis>). När ett kommando matas in i ett skal, handlar det helt enkelt om att lägga till ett <userinput>&amp;</userinput> på slutet av kommandot. Prompten visas igen inom kort vilket kan leda till problem om kommandot själv behöver skriva ut data.
			</para>

		</section>
		 <section id="sect.daemons">
			<title>Demoner</title>
			 <indexterm>
				<primary>demoner</primary>
			</indexterm>
			 <indexterm>
				<primary>demoner</primary>
			</indexterm>
			 <para>
				En ”demon” är en process som startats automatiskt av uppstartssekvensen. Den fortsätter köra (i bakgrunden) för att utföra underhållsuppgifter eller tillhandahålla tjänster till andra processer. Denna ”bakgrundsuppgift” är faktiskt slumpmässig och matchar inte någon särskild typ ur systemets synvinkel. De är helt enkelt processer, liknande andra processer, som kör i turordning när deras tidsintervall kommer. Skillnaden är endast i hur man talar om den: en process som kör utan interaktion med en användare (i synnerhet utan ett grafiskt gränssnitt) kallas för att den kör ”i bakgrunden” eller ”som en demon”.
			</para>
			 <sidebar> <title><emphasis>VOKABULÄR</emphasis> Demon, ett nedsättande namn?</title>
			 <para>
				Även om namnet <emphasis>demon</emphasis> delar sin grekiska etymologi med <emphasis>demon</emphasis>, implicerar inte den föregående något djävulskt, utan istället bör det förstås som ett slags skyddsande. Denna distinktion är subtil nog på engelska (daemon respektive demon) ; det är än värre på andra språk (till exempel svenska) där samma ord används för båda betydelserna.
			</para>
			 </sidebar> <para>
				Flera sådana demoner beskrivs i detalj i <xref linkend="unix-services" />.
			</para>

		</section>
		 <section id="sect.ipc">
			<title>Interprocesskommunikation</title>
			 <indexterm>
				<primary>IPC</primary>
			</indexterm>
			 <indexterm>
				<primary>Interprocesskommunikation</primary>
			</indexterm>
			 <para>
				En isolerad process, vare sig det är en demon eller ett interaktivt program, är sällan användbar på egen hand, vilket är anledning till att det finns flera sätt att låta separata processer kommunicera med varandra, antingen för att utbyta data eller för att styra varandra. Den generella termen för att referera till detta är <emphasis>interprocesskommunikation</emphasis>, eller IPC (efter engelskans Inter-Process Communication).
			</para>
			 <para>
				Det enklaste IPC-systemet är ett använda filer. Processen som önskar skicka data skriver denna till en fil (med ett förutbestämt namn), medan mottagaren endast behöver öppna filen och läsa dess innehåll.
			</para>
			 <indexterm>
				<primary><emphasis>rörledning</emphasis></primary>
			</indexterm>
			 <para>
				I fallet där du inte önskar spara data på disk kan du använda en <emphasis>rörledning</emphasis>, vilket helt enkelt är ett objekt med två ändar; byte skrivs i en ände och kan läsas i den andra. Om ändarna styrs av olika processer leder detta till en enkel och behändig kanal för interprocesskommunikation. Rörledningar kan klassificeras i två kategorier: namngivna rörledningar och anonyma rörledningar. En namngiven rörledning representeras av en post i filsystemet (även om den överförda datan inte lagras där), så att båda processerna kan öppna den oberoende av varandra så länge platsen för den namngivna rörledningen är förutbestämd. I fall när kommunicerande processer är relaterade (till exempel en föräldraprocess och dess barnprocess) kan föräldraprocessen också skapa en anonym rörledning innan forkning, och därför kommer barnet att ärva den. Båda processerna kommer sedan kunna utbyta data via rörledningen utan att behöva involvera filsystemet.
			</para>
			 <sidebar> <title><emphasis>I PRAKTIKEN</emphasis> Ett konkret exempel</title>
			 <para>
				Låt oss beskriva i detalj vad som händer när ett komplext kommando (en <emphasis>rörledning</emphasis>) körs från ett skal. Vi antar att vi har en <command>bash</command>-process (standardskalet på Debian), med <emphasis>pid</emphasis> 4374; i detta skal matar vi in kommandot: <command>ls | sort</command>.
			</para>
			 <para>
				Skalet tolkar först kommandot som matats in. I vårt fall förstår det att det finns två program(<command>ls</command> och <command>sort</command>), med en dataström som flödar från ett till ett annat (betecknat av tecknet <userinput>|</userinput>, känt som <emphasis>rörledning</emphasis>). <command>bash</command> skapar först en icke namngiven rörledning (som i inledningsskedet endast existerar inom <command>bash</command>-processen själv).
			</para>
			 <para>
				Sedan klonar skalet sig själv; detta leder till en ny <command>bash</command>-process med <emphasis>pid</emphasis> #4521 (<emphasis>pid</emphasis>:ar är abstrakta nummer och har i allmänhet ingen mening). Process #4521 ärver rörledningen, vilket innebär att den kan skriva till dess ”ingångsände”; <command>bash</command> omdirigerar sin standard ut-ström till denna rörlednings ingång. Sedan exekverar det (och ersätter sig själv med) programmet <command>ls</command>, vilket listar innehållet i den aktuella katalogen. Eftersom <command>ls</command> skriver på sin standard ut och denna utgång tidigare har omdirigerats kommer resultaten i att skickas in i rörledningen.
			</para>
			 <para>
				En liknande åtgärd händer för det andra kommandot: <command>bash</command> klonar sig själv igen, vilket leder till en ny <command>bash</command>-process med pid #4522. Eftersom detta också är en barn process till #4374, ärver denna också rörledningen; <command>bash</command> ansluter sedan sin standard in till rörledningens utgång, sedan kör det (och ersätter sig själv med) <command>sort</command>-kommandot, vilket sorterar sin indata och skriver ut resultaten.
			</para>
			 <para>
				Alla delarna i pusslet är nu inställda: <command>ls</command> läser den aktuella katalogen och skriver listan av filer till rörledningen; <command>sort</command> läser denna lista, sorterar den alfabetiskt och skriver ut resultaten. Processnummer #4521 och #4522 avslutas sedan och #4374 (vilken väntat på dem under åtgärden), återtar kontrollen och skriver ut en prompt för att låta användaren mata in ett nytt kommando.
			</para>
			 </sidebar> <para>
				Inte all interprocesskommunikation används för att flytta runt data, dock. I många situationer är den enda information som måste överföras kontrollmeddelanden så som ”pausa körning”, eller ”återuppta körning”. Unix (och Linux) tillhandahåller en mekanism känd som <emphasis>signaler</emphasis> genom vilka en process enkelt kan skicka en specifik signal (vald från en fördefinierad lista av signaler) till en annan process. Det enda kravet är att veta målets <emphasis>pid</emphasis>.
			</para>
			 <para>
				För mer komplex kommunikation finns det också mekanismer för att låta en process göra tillgängligt, eller dela, en del av sitt allokerade minne till andra processer. Minne som nu delas mellan dem kan användas för att flytta data mellan processerna.
			</para>
			 <para>
				Avslutningsvis kan nätverksanslutningar också hjälpa processer att kommunicera; dessa processer kan till och med köras på olika datorer, tusentals kilometer från varandra.
			</para>
			 <para>
				Det är ganska vanligt för ett typiskt Unix-liknande system att använda alla dessa mekanismer i olika utsträckning.
			</para>

		</section>
		 <section id="sect.libraries">
			<title>Bibliotek</title>
			 <indexterm>
				<primary>bibliotek (av funktioner)</primary>
			</indexterm>
			 <para>
				Funktionsbibliotek spelar en väsentlig roll i ett Unix-liknande operativsystem. Det är inte egentliga program, då de inte kan köras för sig, utan är samlingar av kodfragment som kan användas av standardprogram. Bland de vanliga biblioteken hittar du:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						standard C-biblioteket (<emphasis>glibc</emphasis>), vilket innehåller grundläggande funktioner för att öppna filer eller nätverksanslutningar, och andra som möjliggör interaktion med kärnan;
					</para>

				</listitem>
				 <listitem>
					<para>
						grafiska verktygslådor, så som Gtk+ och Qt, vilket låter många program återanvända de grafiska objekten de tillhandahåller;
					</para>

				</listitem>
				 <listitem>
					<para>
						biblioteket <emphasis>libpng</emphasis>, som möjliggör inläsning, tolkning och sparande av bilder i PNG-formatet.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Tack vare dessa bibliotek, kan program återanvända kod. Programutveckling förenklas då många program kan återanvända samma funktioner. Med bibliotek som utvecklats av olika personer tas den globala utvecklingen av systemet närmre Unix historiska filosofi.
			</para>
			 <sidebar> <title><emphasis>KULTUR</emphasis> Unix-sättet: en sak åt gången</title>
			 <para>
				En av de fundamentala koncepten som underbygger operativsystemen i Unix-familjen är att varje verktyg endast bör göra en sak och göra det bra; program kan sedan återanvända dessa verktyg för att bygga mer avancerad logik ovanpå. Denna filosofi kan ses i många inkarnationer. Skalskript är kanske det bästa exemplet: de förenar komplexa sekvenser från väldigt enkla verktyg (så som <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command>, o.s.v.) En annan implementation av denna filosofi kan ses i kodbibliotek: biblioteket <emphasis>libpng</emphasis> tillåter inläsning och skrivning av PNG-bilder, med olika flaggor och på olika sätt, men det gör endast det; det finns ingen chans att det inkluderar funktioner som visar eller redigerar bilder.
			</para>
			 </sidebar> <para>
				Därutöver refereras dessa bibliotek ofta till som ”delade bibliotek” då kärnan kan läsa in dem i minne endast en gång även om flera processer använder samma bibliotek samtidigt. Detta möjliggör sparande av minne, när det jämförs med den motsatta (hypotetiska) situationen där koden för ett bibliotek måste läsas in lika många gånger som det finns processor som använder det.
			</para>

		</section>

	</section>
</appendix>

