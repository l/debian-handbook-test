<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course">
  <appendixinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-short-remedial-course.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>BIOS</keyword>
      <keyword>Núcleo</keyword>
      <keyword>Unix</keyword>
      <keyword>Processo</keyword>
      <keyword>Hierarquia</keyword>
      <keyword>Comandos Básicos</keyword>
    </keywordset>
  </appendixinfo>
  <title>Curso Rápido de Reparação</title>
  <highlights>
    <para>Mesmo que este livro tenha como alvo principalmente administradores de sistemas e "usuários experientes", nós não gostaríamos de excluir os iniciantes motivados. Este apêndice será, portanto, um curso intensivo que descreve os conceitos fundamentais envolvidos na operação de um computador com Unix.</para>
  </highlights>
  <section id="sect.shell-and-basic-commands">
    <title>Shell e Comandos Básicos</title>

    <para>No mundo Unix, todo administrador de sistemas terá que usar linha de comandos mais cedo ou mais tarde; por exemplo, quando o sistema falha em iniciar corretamente e provê somente o modo de recuperação via linha de comando. Ser capaz de trabalhar com esta interface, portanto, é uma habilidade de sobrevivência básica para estas circunstâncias.</para>

    <sidebar>
      <title><emphasis>OLHAR RÁPIDO</emphasis> Iniciando o interpretador de comando</title>

      <para>Um ambiente de linha de comando pode ser usado a partir do ambiente gráfico do computador, através de uma aplicação conhecida como "terminal". No GNOME, você pode iniciar ela a partir da visão geral dada em "Atividades" (que você tem quando move o mouse para o canto superior esquerdo da tela), digitando as primeiras letras do nome da aplicação. No KDE, você irá encontrar ela no menu  <menuchoice><guimenu>K</guimenu> <guisubmenu>Aplicações</guisubmenu> <guisubmenu>Sistema</guisubmenu></menuchoice>.</para>
    </sidebar>

    <para>Esta seção só dá uma olhada rápida nos comandos. Todos eles têm muitas opções não descritas aqui. Então, por favor, visite a vasta documentação das suas respectivas páginas de manual.</para>
    <section>
      <title>Navegando na Árvore de Diretórios e Gerenciando Arquivos</title>

      <para>Uma vez que uma sessão é aberta, o comando <command>pwd</command> (que significa <emphasis>print working directory</emphasis> - imprimir o diretório de trabalho) mostra a localização atual no sistema de arquivos. O diretório atual é alterado com o comando <command> cd <replaceable>diretório</replaceable></command> (<command>cd</command> serve para alterar o diretório - <emphasis>change directory</emphasis>). O diretório pai é sempre chamado <literal>..</literal> (dois pontos), enquanto o diretório atual também é conhecido como <literal>.</literal> (ponto). O <command>ls</command> permite <emphasis>listar</emphasis> o conteúdo de um diretório. Se nenhum parâmetro é dado, ele opera no diretório atual.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>cd Desktop</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd .</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates
Documents  Music      Public    Videos</computeroutput>
      </screen>

      <para>Um novo diretório pode ser criado com <command>mkdir <replaceable>diretório</replaceable></command>, e um diretório (vazio) existente pode ser removido com <command> rmdir <replaceable>diretório</replaceable></command>. O comando <command>mv</command> permite <emphasis>mover</emphasis> e/ou renomear arquivos e diretórios; para <emphasis>remover</emphasis> um arquivo use <command>rm <replaceable>arquivo</replaceable></command>.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>mkdir teste</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public    teste
$ </computeroutput><userinput>mv teste novo</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  novo       Public     Videos
Documents  Music      Pictures  Templates
$ </computeroutput><userinput>rmdir novo</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public</computeroutput>
      </screen>
    </section>
    <section>
      <title>Mostrando e Modificando Arquivos Texto</title>

      <para>O comando <command> cat <replaceable>arquivo</replaceable></command> (destinado a <emphasis>concatenar</emphasis> arquivos para o dispositivo de saída padrão) lê um arquivo e exibe seu conteúdo no terminal. Se o arquivo é muito grande para caber na tela, use um paginador como o <command>less</command> (ou <command>more</command>) para exibir o conteúdo página a página.</para>

      <para>O comando <command>editor</command> inicia um editor de texto (como o <command>vi</command> ou o <command>nano</command>) e permite criar, modificar e ler arquivos de texto. Os arquivos mais simples às vezes podem ser criados diretamente a partir do interpretador de comandos graças ao redirecionamento:  <command>echo "<replaceable>texto</replaceable>"&gt;<replaceable>arquivo</replaceable></command> cria um arquivo chamado <replaceable>arquivo</replaceable> com "<replaceable>texto</replaceable>" como o seu conteúdo. Também é possível adicionar uma linha no final deste arquivo com um comando como <command>echo "<replaceable>maistexto</replaceable>"&gt;&gt;<replaceable>arquivo</replaceable></command>. Note o <literal>&gt;&gt;</literal> deste exemplo.</para>
    </section>
    <section>
      <title>Procurando por e nos Arquivos</title>

      <para>O comando <command>find <replaceable>diretório</replaceable> <replaceable>critérios</replaceable></command> procura por arquivos na hierarquia sob o <replaceable>diretório</replaceable> de acordo com vários critérios. O critério mais comum é <literal>-name <replaceable>name</replaceable></literal>: que permite procurar um arquivo pelo nome.</para>

      <para>O comando <command>grep <replaceable>expressão</replaceable> <replaceable>arquivos</replaceable></command> procura o conteúdo nos arquivos e extrai as linhas correspondentes na expressão regular (veja na barra lateral <xref linkend="sidebar.regexp" />). Adicionando a opção <literal>-r</literal> habilita a procura recursiva em todos os arquivos contidos no diretório passado como um parâmetro. Isto permite procurar por um arquivo quando somente uma parte do conteúdo é conhecido.</para>
    </section>
    <section>
      <title>Gerenciamento de Processos</title>

      <para>O comando <command> ps aux </command> lista os processos rodando atualmente e ajuda a identificá-los exibindo seus <emphasis>pid</emphasis> (identificador do processo). Uma vez que o <emphasis>pid</emphasis> de um processo é conhecido, o comando <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> permite enviar um sinal para ele (se o processo pertence ao usuário atual). Existem muitos sinais; os mais usados comumente são <literal>TERM</literal> (uma requisição para terminar suavemente) e <literal>KILL</literal> (matar o processo à força).</para>

      <para>O interpretador de comando também pode rodar programas em segundo plano se o comando é seguido de um “&amp;”. Ao utilizar o  "e comercial", o usuário retorna o controle para o shell imediatamente mesmo que o comando ainda esteja rodando (oculto para o usuário; como um processo em segundo plano). O comando <command>jobs</command> lista os processos rodando em segundo plano; executar <command>fg %<replaceable>número-do-processo</replaceable></command> (para <emphasis>foreground</emphasis> - primeiro plano) restaura o trabalho para o primeiro plano. Quando um comando está rodando em primeiro plano (ou porque ele foi iniciado normalmente, ou trazido de volta para o primeiro plano com <command>fg</command>), a combinação de teclas <keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo> pausa os processos e retorna o controle para a linha de comando. O processo pode então ser reiniciado em segundo plano com o comando <command>bg %<replaceable>número-do-processo</replaceable></command> (para <foreignphrase>background</foreignphrase> - segundo plano).</para>
    </section>
    <section>
      <title>Informações do Sistema: Memória, Espaço em Disco, Identidade</title>

      <para>O comando <command>free</command> exibe informações sobre a memória; o <command>df</command>(<emphasis>disk free</emphasis>) exibe relatórios sobre o espaço disponível no disco em cada um dos discos montados no sistema de arquivo. A opção <literal>-h</literal> (para <emphasis>legível por humanos</emphasis> converte os tamanhos para uma unidade mais legível (normalmente gigabytes ou megabytes). De um modo semelhante, o comando <command>free</command> suporta as opções <literal>-m</literal> e <literal>-g</literal>, e mostra estes dados tanto em megabytes ou em gigabytes, respectivamente.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       used       free     shared    buffers     cached
Mem:       1028420    1009624      18796          0      47404     391804
-/+ buffers/cache:     570416     458004
Swap:      2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda2              9614084   4737916   4387796  52% /
tmpfs                   514208         0    514208   0% /lib/init/rw
udev                     10240       100     10140   1% /dev
tmpfs                   514208    269136    245072  53% /dev/shm
/dev/sda5             44552904  36315896   7784380  83% /home
</computeroutput></screen>

      <para>O comando <command>id</command> exibe a identidade do usuário em execução na seção, juntamente com a lista de grupos a que pertence. Uma vez que o acesso a alguns arquivos ou dispositivos pode ser limitado aos membros de algum grupo, verificar a que grupos pertence pode ser útil.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
      </screen>
    </section>
  </section>
  <section id="sect.filesystem-hierarchy">
    <title>Organização da Hierarquia de Sistema de Arquivos</title>
    <indexterm><primary>Hierarquia do Sistema de Arquivos</primary></indexterm>
    <section>
      <title>O Diretório Raiz</title>

      <para>Um sistema Debian é organizado de acordo com o <emphasis>Filesystem Hierarchy Standard</emphasis> (FHS). Esta norma define a finalidade de cada diretório. Por exemplo, os diretórios de nível superior são descritos como se segue:</para>
      <itemizedlist>
        <listitem>
	  <para><filename>/bin/</filename>: programas básicos;</para>
        </listitem>
        <listitem>
	  <para><filename>/boot/</filename>: núcleo Linux e outros arquivos necessários para os primeiros passos de seu processo de inicialização;</para>
        </listitem>
        <listitem>
	  <para><filename>/dev/</filename>: arquivos de dispositivo;</para>
        </listitem>
        <listitem>
	  <para><filename>/etc/</filename>: Arquivos de configuração;</para>
        </listitem>
        <listitem>
	  <para><filename>/home/</filename>: arquivos pessoais dos usuários;</para>
        </listitem>
        <listitem>
	  <para><filename>/lib/</filename>: bibliotecas básicas;</para>
        </listitem>
        <listitem>
	  <para><filename>/media/*</filename>: pontos de montagem para dispositivos removíveis (CD-ROM, pendrivers e assim por diante);</para>
        </listitem>
        <listitem>
	  <para><filename>/mnt/</filename>: ponto de montagem temporário;</para>
        </listitem>
        <listitem>
	  <para><filename>/opt/</filename>: aplicações extras fornecidas por terceiros;</para>
        </listitem>
        <listitem>
	  <para><filename>/root/</filename>: arquivos pessoais do administrador (root);</para>
        </listitem>
        <listitem>
          <para><filename>/run/</filename>: dados de execução volátil (volatile runtime data) que não persistem entre re-inicializações (ainda não incluído no FHS);</para>
        </listitem>
        <listitem>
	  <para><filename>/sbin/</filename>: programas do sistema;</para>
        </listitem>
        <listitem>
	  <para><filename>/srv/</filename>: dados utilizados por servidores hospedados neste sistema;</para>
        </listitem>
        <listitem>
	  <para><filename>/tmp/</filename>: arquivos temporários, este diretório é comumente limpo na inicialização;</para>
        </listitem>
        <listitem>
	  <para><filename>/usr/</filename>: aplicações; este diretório é subdividido em <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (de acordo com a mesma lógica do diretório raiz). Além disso, <filename>/usr/share/</filename> contém dados independentes de arquitetura. <filename>/usr/local/</filename> é feito para ser usado pelo administrador para instalar aplicativos manualmente, sem sobrescrever arquivos administrados pelo sistema de empacotamento (<command>dpkg</command>).</para>
        </listitem>
        <listitem>
	  <para><filename>/var/</filename>: dados variáveis manipulados por daemons. Isto inclui arquivos de log, filas, spools, caches e por aí vai.</para>
        </listitem>
        <listitem>
	  <para><filename>/proc/</filename> e <filename>/sys/</filename> são específicos do núcleo Linux ( e não fazem parte do FHS). Eles são usados pelo núcleo para exportar dados para o espaço de usuário  (veja <xref linkend="sect.userspace-presentation" /> e <xref linkend="sect.user-space" /> para explicações sobre esse conceito).</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>O Diretório Origem (home) do Usuário</title>

      <para>O conteúdo do diretório home do usuário não é padronizado, mas ainda existem algumas convenções relevantes. Uma delas é que o diretório home do usuário é muitas vezes referenciado por um til ("~"). É bom saber disto porque os interpretadores de comando substituem automaticamente um til pelo diretório correto (geralmente <filename>/home/<replaceable>user</replaceable>/</filename>).</para>

      <para>Tradicionalmente, os arquivos de configuração de aplicativos são frequentemente armazenados diretamente sob o diretório home do usuário, mas seus nomes geralmente começam com um ponto (por exemplo, o cliente de email <command>mutt</command> armazena sua configuração em <filename>~/.muttrc</filename>). Note que nomes de arquivos que começam com um ponto são ocultos por padrão; e <command>ls</command> os lista apenas quando a opção <literal>-a</literal> for usada, e gerenciadores de arquivos gráficos precisa ser ordenados para exibir arquivos ocultos.</para>

      <para>Alguns programas também utilizam vários arquivos de configuração organizados em um diretório (por exemplo, <filename>~/.ssh/</filename>). Alguns aplicativos (como o navegador web Iceweasel) também usam seu diretório para armazenar um cache de dados baixados. Isto significa que os diretórios podem acabar usando muito espaço em disco.</para>

      <para>Esses arquivos de configuração armazenados diretamente no diretório home do usuário, muitas vezes chamados coletivamente como <emphasis>dotfiles</emphasis>, há tempos se proliferam a tal ponto que estes diretórios podem ficar abarrotados com eles. Felizmente, um esforço liderado coletivamente sob a orientação da FreeDesktop.org resultou na "Especificação de Diretórios Base da XDG", uma convenção que visa limpar esses arquivos e diretórios. Esta especificação estabelece que os arquivos de configuração devem ser armazenados sob <filename>~/.config</filename>, arquivos de cache sob <filename>~/.cache</filename>, e arquivos de dados de aplicativos sob <filename>~/.local</filename> (ou subdiretórios nos mesmos). Esta convenção está lentamente ganhando força e vários aplicativos (especialmente os gráficos) começaram a segui-la.</para>

      <para>Ambientes gráficos geralmente exibem o conteúdo do diretório <filename>~/Desktop</filename> (ou qualquer que seja a tradução apropriada para sistemas não configurados em inglês) na área de trabalho (ou seja, o que é visível na tela uma vez que todas as aplicações estão fechadas ou minimizadas).</para>

      <para>Finalmente, o sistema de e-mail às vezes armazena e-mails recebidos no diretório <filename>~/Mail/</filename>.</para>
    </section>
  </section>
  <section id="sect.computer-layers">
    <title>Funcionamento Interno de um Computador: As Diferentes Camadas Envolvidas</title>

    <para>Um computador é muitas vezes considerado como algo bastante abstrato, e a interface visível externamente é muito mais simples do que a sua complexidade interna. Tal complexidade vem, em parte, do número de peças envolvidas. No entanto, estas peças podem ser vistas em camadas, em que uma camada apenas interage com aquelas imediatamente acima ou abaixo.</para>

    <para>Um usuário final pode viver sem saber esses detalhes... enquanto tudo funciona. Ao encontrar um problema como: "A internet não funciona!", A primeira coisa a fazer é identificar em qual camada o problema se origina. A placa de rede (hardware) está funcionando? É reconhecida pelo computador? Será que o kernel do Linux vê a placa? Os parâmetros de rede estão configurados corretamente? Todas estas questões isolam uma camada apropriada e focam numa possível fonte do problema.</para>
    <section id="sect.hardware">
      <title>A Camada mais Profunda: o Hardware</title>
      <indexterm><primary>IDE</primary></indexterm>
      <indexterm><primary>SCSI</primary></indexterm>
      <indexterm><primary>Serial ATA</primary></indexterm>
      <indexterm><primary>Parallel ATA</primary></indexterm>
      <indexterm><primary>ATA</primary></indexterm>
      <indexterm><primary>IEEE 1394</primary></indexterm>
      <indexterm><primary>Firewire</primary></indexterm>
      <indexterm><primary>USB</primary></indexterm>

      <para>Vamos começar com um lembrete básico de que um computador é, em primeiro lugar, um conjunto de elementos de hardware. Há geralmente uma placa principal (conhecida como a <emphasis>placa-mãe</emphasis>), com um (ou mais) processador(es), memória RAM, controladores de dispositivos e encaixes (slots) de extensão para placas opcionais (para outros controladores de dispositivos). O mais importante entre esses controladores são as IDE (Parallel ATA), SCSI e Serial ATA, para conexão com dispositivos de armazenamento, como discos rígidos. Outros controladores incluem USB, que é capaz de hospedar uma grande variedade de dispositivos (variando de webcams até termômetros, de teclados até sistemas de automação residencial) e IEEE 1394 (Firewire). Esses controladores muitas vezes permitem conectar vários dispositivos. O subsistema completo gerenciado por tal controlador é, por este motivo, normalmente conhecido como "barramento". Placas opcionais incluem placas gráficas (onde telas de monitores serão conectadas), placas de som, placas de rede, e assim por diante. Algumas placas principais são pré-fabricadas com esses recursos, e não precisam de placas opcionais.</para>

      <sidebar>
        <title><emphasis>NA PRÄTICA</emphasis> Verificando se o hardware funciona</title>

	<para>Verificar se um hardware está funcionando pode ser complicado. Entretanto, provar que o mesmo não funciona às vezes é bem simples.</para>

	<para>Um disco rígido é feito de pratos giratórios e cabeças magnéticas móveis. Quando um disco rígido é ligado, o motor faz um zumbido característico. Também dissipa a energia na forma de calor. Consequentemente, um disco rígido que permanece frio e silencioso quando ligado está quebrado.</para>

	<para>Placas de rede muitas vezes incluem LEDs que indicam o estado da conexão. Se um cabo estiver conectado e leva a um hub ou switch de rede em funcionamento, pelo menos um LED será ligado. Se nenhum LED acende, ou o próprio cartão, o dispositivo de rede ou o cabo entre eles está com defeito. O passo seguinte é, por conseguinte, o teste de cada componente individualmente.</para>

	<para>Algumas placas opcionais - especialmente as placas de vídeo 3D - incluem dispositivos de refrigeração, tais como dissipadores de calor e/ou ventoinhas. Se a ventoinha não gira, mesmo que o cartão esteja ligado, uma explicação plausível é o cartão superaquecido. Isso vale também para o(s) processador(es) principal(is) localizado na placa principal.</para>
      </sidebar>
    </section>
    <section id="sect.bios">
      <title>O Inicializador: a BIOS ou UEFI</title>
      <indexterm><primary>BIOS</primary></indexterm>
      <indexterm><primary>UEFI</primary></indexterm>
      <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

      <para>O hardware, por si só, é incapaz de realizar tarefas úteis sem um software que o gerenciasse. Controlar e interagir com o hardware é o objetivo do sistema operacional e aplicativos. Estes, por sua vez, requerem hardware funcional para executar.</para>

      <para>Esta simbiose entre hardware e software não acontece por si só. Quando o computador é ligado pela primeira vez, algumas configurações iniciais são necessárias. Esse papel é assumido pela BIOS ou UEFI, um software embarcado na placa principal que é executado automaticamente após a energização. Sua tarefa principal é a procura do software que pode lhe entregar o controle. Normalmente, no caso da BIOS, isso envolve buscar no primeiro disco rígido com um setor de inicialização (também conhecido como o <emphasis>master boot record</emphasis> - registro mestre de inicialização - ou <acronym>MBR</acronym>), carregar esse setor de inicialização e executá-lo. A partir deste ponto, a BIOS geralmente não é mais utilizada (até a próxima inicialização). No caso da UEFI, o processo envolve uma busca nos discos à procura de uma partição EFI contendo outras aplicações EFI para executar.</para>

      <sidebar>
        <title><emphasis>FERRAMENTA</emphasis> Setup, a ferramenta de configuração da BIOS/UEFI</title>
        <indexterm><primary><emphasis>Setup</emphasis></primary></indexterm>

	<para>A BIOS/UEFI também contém software chamado de Setup, projetada para permitir a configuração de aspectos do computador. Em particular, ele permite escolher qual é o dispositivo preferencial de inicialização (por exemplo, o disquete ou CD-ROM), configurar o relógio do sistema, e assim por diante. Iniciar o Setup geralmente envolve pressionar uma tecla logo que o computador é ligado. Esta tecla é muitas vezes o <keycap>Del</keycap> ou <keycap>Esc</keycap>, às vezes a <keycap>F2</keycap> ou <keycap>F10</keycap>. Na maioria das vezes, a escolha é exibida na tela durante a inicialização.</para>
      </sidebar>

      <para>O setor de inicialização (ou a partição EFI), por sua vez, contém outro pedaço de software, chamada de bootloader, cujo propósito é encontrar e executar um sistema operacional. Uma vez que este bootloader não é incorporado na placa principal, mas carregado do disco, pode ser mais esperto do que a BIOS, o que explica por que o BIOS não carrega o sistema operacional por si só. Por exemplo, o carregador de inicialização (geralmente o GRUB em sistemas Linux) pode listar os sistemas operacionais disponíveis e pedir ao usuário para escolher um. Normalmente, fornece uma opção de tempo limite e escolha padrão. Às vezes, o usuário também pode optar por adicionar parâmetros para passar para o kernel, e assim por diante. Eventualmente, um kernel for encontrado, carregado na memória e executado.</para>

      <sidebar>
        <title><emphasis>NOTA</emphasis> UEFI, um moderno substituto para a BIOS</title>
        <indexterm><primary>UEFI</primary></indexterm>
        <indexterm><primary>Secure Boot</primary></indexterm>

        <para>UEFI é um desenvolvimento relativamente recente. A maioria dos computadores novos irão suportar a inicialização por UEFI, mas geralmente eles também suportam a inicialização por BIOS por questões de compatibilidade com sistemas operacionais que ainda não estão prontos para explorar o UEFI.</para>
        <para>Esse novo sistema se livra de algumas das limitações da inicialização pela BIOS: com o uso de uma partição dedicada, os carregadores de inicialização não mais precisam de truques especiais para cabeer na pequena <emphasis>MBR - master boot record</emphasis>, e assim, descobrir qual kernel inicializar. Ainda melhor, com um kernel Linux adequadamente construído, a UEFI pode inicializar o kernel diretamente sem qualquer carregador de inicialização intermediário.  O UEFI é também a fundação básica usada para entregar o <emphasis>Secure Boot</emphasis>, uma tecnologia que garante que você apenas irá rodar software validado pelo seu fabricante de sistema operacional.</para>
      </sidebar>

      <para>A BIOS/UEFI também é responsável por detectar e inicializar uma série de dispositivos. Obviamente, isto inclui os dispositivos IDE/SATA (normalmente disco(s) rígido(s) e unidades de CD/DVD-ROM), mas também dispositivos PCI. Os dispositivos detectados são frequentemente listado na tela durante o processo de inicialização. Se esta lista passa muito rápido, use a tecla <keycap>Pause</keycap> para congelá-la por tempo suficiente para ler. Dispositivos PCI instalados que não aparecem são um mau presságio. Na pior das hipóteses, o dispositivo está com defeito. Na melhor das hipóteses, é apenas incompatível com a versão atual da BIOS ou com a placa mãe. As especificações PCI evoluiem, e as placas mãe antigas não são garantidas de lidar com dispositivos PCI mais recentes.</para>
    </section>
    <section id="sect.kernel">
      <title>O Núcleo</title>

      <para>Tanto a BIOS/UEFI como o bootloader apenas são executados por alguns segundos cada; agora estamos chegando ao primeiro software que é executado por um longo tempo, o kernel do sistema operacional. Este kernel assume o papel de um maestro de uma orquestra e assegura a coordenação entre o hardware e o software. Este papel envolve várias tarefas, incluindo: administrar o hardware, gerenciar processos, usuários e permissões, o sistema de arquivos, e assim por diante. O kernel fornece uma base comum a todos os outros programas no sistema.</para>
    </section>
    <section id="sect.userspace-presentation">
      <title>O Espaço de Usuário</title>

      <para>Apesar de tudo o que acontece fora do kernel podem ser agrupado como "espaço do usuário", ainda podemos separá-lo em camadas de software. No entanto, as suas interações são mais complexas do que antes, e as classificações podem não ser tão simples. Uma aplicação geralmente usa as bibliotecas, que por sua vez envolvem o kernel, mas as comunicações também podem envolver outros programas, ou até mesmo muitas bibliotecas que chamam umas às outras.</para>
    </section>
  </section>
  <section id="sect.kernel-role-and-tasks">
    <title>Algumas Tarefas realizadas pelo Núcleo</title>
    <section id="sect.hardware-drivers">
      <title>Controlando o Hardware</title>

      <para>O kernel tem, em primeiro lugar, a tarefa de controlar as partes do hardware, detectando-os, trocando-os quando o computador é ligado, e assim por diante. Também torna disponíveis para o software de alto nível com uma interface de programação simplificada, para que os aplicativos possam tirar proveito de dispositivos sem ter que se preocupar com detalhes como qual slot de extensão a placa opcional estiver conectada. A interface de programação também fornece uma camada de abstração; isso permite que o software de videoconferência, por exemplo, usar uma webcam independentemente da sua marca e modelo. O software pode apenas usar a interface <emphasis>Vídeo for Linux</emphasis> (V4L), e o kernel traduz as chamadas de função desta interface para os comandos de hardware reais necessários pela webcam específica em uso.</para>

     
      <para><indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> O kernel exporta muitos detalhes sobre o hardware detectado através dos sistemas de arquivos virtuais <filename>/proc/</filename> e <filename>/sys/</filename>. Várias ferramentas resumem esses detalhes. Entre elas, o <command>lspci</command> (no pacote <emphasis role="pkg">pciutils</emphasis>) lista os dispositivos PCI, <command>lsusb</command> (no pacote <emphasis role="pkg">usbutils</emphasis>) lista os dispositivos USB e <command>lspcmcia</command> (no pacote <emphasis role="pkg">pcmciautils</emphasis>) lista de cartões PCMCIA. Estas ferramentas são muito úteis para a identificação do modelo exato de um dispositivo. Esta identificação permite também pesquisas mais precisas na web, que por sua vez, levam a documentos mais relevantes.</para>

      <example>
        <title>Exemplo de informação provida pelo <command>lspci</command> e <command>lsusb</command></title>

        <screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>
      </example>

      <para>Estes programas têm uma opção <literal>-v</literal>, que lista informações com muito mais detalhes (mas geralmente não é necessário). Finalmente, o comando <command>lsdev</command> (no pacote <emphasis role="pkg">procinfo</emphasis>) lista os recursos de comunicação usados pelos dispositivos.</para>

      <para>As aplicações acessam frequentemente os dispositivos por meio de arquivos especiais criados dentro de <filename>/dev/</filename> (veja a barra lateral <xref linkend="sidebar.special-files" />). Estes são arquivos especiais que representam as unidades de disco (por exemplo, <filename>/dev/hda</filename> e <filename>/dev/sdc</filename>), partições (<filename>/dev/hda1</filename> ou <filename>/dev/sdc3</filename>), mouses (<filename>/dev/input/mouse0</filename>), teclados (<filename>/dev/input/event0</filename>), placas de som (<filename>/dev/snd/*</filename>), portas seriais (<filename>/dev/ttyS*</filename>), e assim por diante.</para>
    </section>
    <section id="sect.filesystems">
      <title>Sistema de Arquivos</title>
      <indexterm><primary>sistema de arquivos</primary></indexterm>
      <indexterm><primary>sistema, sistema de arquivos</primary></indexterm>

      <para>Os sistemas de arquivos são um dos aspectos mais importantes do kernel. Sistemas Unix agrupam todos os arquivos que armazenam em uma hierarquia única, que permite aos usuários (e as aplicações) a acessar os dados simplesmente por saber a sua localização dentro dessa hierarquia.</para>

      <para>O ponto de partida desta árvore hierárquica é chamado de raiz, <filename>/</filename>. Este diretório pode conter subdiretórios nomeados. Por exemplo, o subdiretório <literal>home</literal> do <filename>/</filename> é chamado <filename>/home/</filename>. Este subdiretório pode, por sua vez, contêm outros subdiretórios, e assim por diante. Cada diretório também pode conter arquivos, onde os dados reais serão armazenados. Assim, o nome <filename>/home/rmas/Desktop/hello.txt</filename> refere-se a um arquivo chamado <literal>hello.txt</literal> armazenado no subdiretório <literal>Desktop</literal>, subdiretório do <literal>rmas</literal>, subdiretório de <literal>home</literal>, diretório presente na raiz. O kernel traduz entre este sistema de nomenclatura e o armazenamento real e física no disco.</para>

      <para>Ao contrário de outros sistemas, só há uma hierarquia deste tipo, e pode integrar dados de vários discos. Um desses discos é usado como a raiz, e os outros são "montados" em diretórios na hierarquia (o comando Unix é chamado <command>mount</command>); esses outros discos estarão disponíveis sob estes "pontos de montagem". Isso permite o armazenamento do diretório principal dos usuários (tradicionalmente armazenados dentro de <filename>/home/</filename>) em um segundo disco rígido, que irá conter os diretórios <literal>rhertzog</literal> e <literal>rmas</literal>. Depois que o disco é montado em <filename>/home/</filename>, esses diretórios estarão disponíveis em seus locais habituais e caminhos como <filename>/home/rmas/Desktop/hello.txt</filename> continuaram funcionando.</para>
      <indexterm><primary><command>mkfs</command></primary></indexterm>

      <para>Existem muitos formatos de sistemas de arquivo que corresponde a muitas formas de armazenamento físico de dados nos discos. O mais conhecido são o <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> e o <emphasis>ext4</emphasis>, mas existem outros. Por exemplo, o <emphasis>vfat</emphasis> é o sistema que foi historicamente usado pelos sistemas operacionais DOS e Windows, que permite utilizar os discos rígidos tanto no Debian como no Windows. Em qualquer caso, um sistema de arquivos deve ser preparado em um disco antes que ele possa ser montado e esta operação é conhecida como "formatação". Comandos como <command>mkfs.ext3</command> (onde <command>mkfs</command> é <emphasis>MaKe FileSystem</emphasis> - criar sistema de arquivos) fazem a formatação. Estes comandos exigem, como um parâmetro, um arquivo de dispositivo que representa a partição a ser formatada (por exemplo, <filename>/dev/sda1</filename>). Esta operação é destrutiva e só deve ser executado uma vez, exceto se queira limpar deliberadamente um sistema de arquivos e começar de novo.</para>

      <para>Há também sistemas de arquivos de rede, como o <acronym>NFS</acronym>, em que os dados não são armazenados em um disco local. Em vez disso, os dados são transmitidos através da rede para um servidor que os armazena e recupera sob demanda. A abstração de sistema de arquivos evita que os usuários de cuidar: arquivos permanecem acessíveis na sua forma hierárquica usual.</para>
    </section>
    <section id="sect.shared-functions">
      <title>Funções Compartilhadas</title>

      <para>Uma vez que uma quantidade das mesmas funções são usadas por todos os softwares, não faz sentido centralizá-las no kernel. Por exemplo, a gestão do sistema de arquivos compartilhado permite qualquer aplicativo simplesmente abrir um arquivo pelo nome, sem precisar se preocupar onde o arquivo está armazenado fisicamente. O arquivo pode ser armazenado em diferentes partes em um disco rígido, ou dividido em vários discos rígidos, ou mesmo armazenados em um servidor de arquivos remoto. As funções de comunicação compartilhadas são usadas por aplicativos para troca de dados de forma independente da forma como os dados são transportados. Por exemplo, o transporte poderia ser sobre qualquer combinação de redes locais sem fio ou através de uma linha telefônica.</para>
    </section>
    <section id="sect.process-management">
      <title>Gerenciamento de Processos</title>
      <indexterm><primary><emphasis>pid</emphasis></primary></indexterm>

      <para>Um processo é uma instância em execução de um programa. Isso requer memória para armazenar tanto o próprio programa quanto seus dados operacionais. O kernel é responsável pela criação e acompanhá-los. Quando um programa é executado, o kernel primeiro reserva alguma memória, em seguida carrega o código executável do sistema de arquivos para ele, e então começa a execução do código. Ele mantém informações sobre este processo, o mais visível é um número de identificação conhecido como <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis> - identificador de processo).</para>

      <para>Kernels tipo Unix (incluindo o Linux), como a maioria dos outros sistemas operacionais modernos, são capazes de "multitarefa". Em outras palavras, eles permitem a execução de vários processos "ao mesmo tempo". Na verdade, há apenas um processo em execução em qualquer momento, mas o kernel divide o tempo em pequenas porções e executa cada processo de cada vez. Uma vez que estas porções de tempo são muito curtas (com intervalo em milissegundos), eles criam a ilusão de processos em execução em paralelo, embora estejam, na verdade, somente ativo durante alguns intervalos de tempo e ociosos no resto do tempo. O trabalho do kernel é ajustar seus mecanismos de agendamento para manter essa ilusão, enquanto maximiza o desempenho do sistema global. Se as porções de tempo são muito longas, o aplicativo pode não parecer responsivo como desejado. Se são muito curtas, o sistema perde tempo trocando entre as tarefas com muita frequência. Estas decisões podem ser ajustadas pelas prioridades do processo. Os processos de alta prioridade serão executados por porções de tempo mais longas e mais frequentes do que os processos de baixa prioridade.</para>

      <sidebar>
        <title><emphasis>NOTA</emphasis> Sistemas multiprocessados (e suas variantes)</title>

	<para>A restrição descrita acima, de apenas um processo sendo capaz de rodar de cada vez, nem sempre é aplicável. A restrição real é que só pode haver um processo de execução <emphasis>por núcleo de processador</emphasis> de cada vez. Sistemas multiprocessador, multi-core ou "hiper-thread" permitem que vários processos executem em paralelo. O mesmo sistema de divisão de tempo ainda é usado, no entanto, de forma a lidar com casos em que existem mais processos ativos do que núcleos de processador disponíveis. Isto está longe de ser incomum: um sistema básico, ainda que na maior parte inativo, quase sempre tem dezenas de processos em execução.</para>
      </sidebar>

      <para>Claro que, o núcleo permite a execução de várias instâncias independentes do mesmo programa. Mas cada um só pode acessar os seus próprios intervalos de tempo e memória. Assim seus dados se mantém independentes.</para>
    </section>
    <section id="sect.permissions">
      <title>Gerenciamento de Direitos</title>

      <para>Sistemas similares ao Unix também são multiusuário. Eles fornecem um sistema de gerenciamento de direitos que permite grupos e usuários separados; ele também permite controle sobre ações com base em permissões. O kernel gerencia dados de cada processo, permitindo-lhe controlar as permissões. Na maioria das vezes, um processo é identificado pelo usuário que o iniciou. Esse processo só é capaz de agir de acordo com as permissões disponíveis para seu dono. Por exemplo, tentar abrir um arquivo requer que o kernel verifique a identidade do processo em relação as permissões de acesso (para mais detalhes sobre este exemplo em particular, veja <xref linkend="sect.rights-management" />).</para>
    </section>
  </section>
  <section id="sect.user-space">
    <title>O Espaço de Usuário</title>
    <indexterm><primary>espaço de usuário</primary></indexterm>
    <indexterm><primary>espaço de núcleo</primary></indexterm>

    <para>"Espaço de usuário" refere-se ao ambiente de execução de processos normais (em oposição aos do kernel). Isso não significa necessariamente que esses processos foram realmente iniciados por usuários, pois um sistema padrão normalmente tem vários processos "daemon" (serviços) (ou em segundo plano) em execução antes mesmo do usuário abrir uma sessão. Processos daemon também são considerados processos no espaço do usuário.</para>
    <section id="sect.process-basics">
      <title>Processo</title>
      <indexterm><primary><command>init</command></primary></indexterm>

      <para>Quando o kernel passa por sua fase de inicialização, ele inicia o primeiro de todos os processos, o <command>init</command>. O processo #1 sozinho, raramente é útil por si só, e em sistemas similares ao Unix rodam com muitos processos adicionais.</para>
      <indexterm><primary><emphasis>fork</emphasis></primary></indexterm>

      <para>Em primeiro lugar, um processo pode se clonar (isto é conhecido como <emphasis>fork</emphasis>). O kernel aloca um novo (mas idêntico) espaço de memória do processo, e um outro processo para usá-lo. Neste momento, a única diferença entre esses dois processos é o seu <emphasis>pid</emphasis>. O novo processo é costumeiramente chamado de um processo filho, e o processo original cujo <emphasis>pid</emphasis> não muda, é chamado de processo pai.</para>

      <para>Às vezes, o processo filho continua vida de forma independente de seu pai, com os seus próprios dados copiados do processo pai. Em muitos casos, porém, este processo filho executa outro programa. Com poucas exceções, sua memória é simplesmente substituída pela do novo programa, e a execução deste novo programa começa. Esse é o mecanismo usado pelo processo init (com processo número 1) para iniciar serviços adicionais e executar toda a sequência de inicialização. Em algum momento, um dos processos descendentes do <command>init</command> inicia uma interface gráfica para os usuários iniciarem sua sessão (a sequência dos eventos é descrito em mais detalhes no <xref linkend="sect.system-boot" />).</para>

      <para>Quando um processo termina a tarefa para a qual ele foi iniciado, ele termina. O kernel então recupera a memória atribuída para este processo, e para de dar porções de tempo de execução. É dito ao processo pai que seu processo filho que está sendo encerrado, o que permite que um processo aguardar a conclusão de uma tarefa que delegada a um processo filho. Este comportamento é claramente visível nos interpretadores de linha de comando (conhecido como <emphasis>shells</emphasis>). Quando um comando é digitado em um shell, o prompt só volta quando a execução do comando é concluida. A maioria dos shells permitir a execução do comando em segundo plano simplesmente adicionando um <userinput>&amp;</userinput> no final do comando. O prompt é imediatamente exibido em seguida, o que pode ser um problema se o comando deve exibir dados próprios.</para>
    </section>
    <section id="sect.daemons">
      <title>Daemons</title>
      <indexterm><primary>daemon</primary></indexterm>
      <indexterm><primary>daemon</primary></indexterm>

      <para>Um "daemon" (serviço) é um processo iniciado automaticamente pela sequência de inicialização. Ele continua em execução (em segundo plano) para executar as tarefas de manutenção ou prover serviços a outros processos. Esta "tarefa em segundo plano" é realmente arbitrária e não tem uma importância especial do ponto de vista do sistema. Eles são simplesmente os processos, bastante semelhante a outros processos, que se executam quando está em sua porção de tempo. A distinção é apenas na língua humana: um processo que é executado sem interação com o usuário (em particular, sem qualquer interface gráfica) é dita estar em execução "em segundo plano" ou "como um serviço".</para>

      <sidebar>
        <title><emphasis>VOCABULÁRIO</emphasis> Daemon, demon, um termo depreciativo?</title>

	<para>Em inglês, utiliza-se o termo <emphasis>daemon</emphasis> compartilhando sua etimologia grega com <emphasis>demônio</emphasis>, o que não implica formalmente mal diabólico, ao contrário, deve ser entendido como uma espécie de espírito ajudante. Esta distinção é sutil o suficiente em inglês; é ainda pior em outras línguas em que a mesma palavra é usada para ambos os significados.</para>
      </sidebar>

      <para>Vários desses daemon são descritos em detalhe em <xref linkend="unix-services" />.</para>
    </section>
    <section id="sect.ipc">
      <title>Comunicação Inter Processos</title>
      <indexterm><primary>IPC</primary></indexterm>
      <indexterm><primary>Comunicação Inter Processos</primary></indexterm>

      <para>Um processo isolado, seja um daemon ou um aplicativo interativo, raramente é útil por si só, e é por isso que existem vários métodos que permitem a comunicação entre os processos separados, seja para troca de dados ou para controlar um ao outro. O termo genérico que se refere a isso é <emphasis>comunicação entre processos</emphasis>, ou IPC (Inter-Process Communication) para abreviar.</para>

      <para>O sistema IPC mais simples é utilizar arquivos. O processo que deseja enviar dados escreve-os em um arquivo (com um nome já conhecido), enquanto o destinatário só precisa abrir o arquivo e ler seu conteúdo.</para>
      <indexterm><primary><emphasis>pipe</emphasis></primary></indexterm>

      <para>No caso de você não desejar armazenar dados em disco, você pode usar um <emphasis>pipe</emphasis> (conexão), que é simplesmente um objeto com duas extremidades; bytes escritos em uma extremidade são legíveis no outro. Se as extremidades são controladas por processos separados, este se converte em um canal de comunicação entre processos simples e conveniente. Pipes podem ser classificados em duas categorias: pipes nomeados e pipes anônimos. Um pipe nomeado é representado por uma entrada no sistema de arquivos (embora os dados transmitidos não são armazenados lá), para que ambos os processos posam abri-lo de forma independente se a localização do pipe nomeado é conhecido antecipadamente. Nos casos em que os processos de comunicação estão relacionados (por exemplo, um pai e seu processo filho), o processo pai também pode criar um pipe anônimo antes da bifurcação, e o filho o herda. Assim, ambos os processos serão capazes de trocar dados através do pipe sem a necessidade do sistema de arquivos.</para>

      <sidebar>
        <title><emphasis>NA PRÁTICA</emphasis> Um exemplo concreto</title>

	<para>Vamos descrever em detalhes o que acontece quando um comando complexo (um <emphasis>pipeline</emphasis>) é executado a partir de um shell. Vamos assumir que temos um processo <command>bash</command> (o shell do usuário padrão no Debian), com <emphasis>pid</emphasis> 4374; neste shell podemos digitar o comando: <command>ls | sort</command>.</para>

	<para>O shell interpreta pela primeira vez o comando digitado nele. No nosso caso, ele entende que existem dois programas (<command>ls</command> e <command>sort</command>), com um fluxo de dados que flui de um para o outro (denotada pelo caractere <userinput>|</userinput>, conhecido como <emphasis>pipe</emphasis>). O <command>bash</command> primeiro cria um pipe sem nome (que inicialmente só existe dentro do processo <command>bash</command> em si).</para>

	<para>Então o shell se clona; isso leva a um novo processo <command>bash</command> com <emphasis>pid</emphasis> #4521 (<emphasis>pids</emphasis> são números abstratos e geralmente não têm significado particular). O processo #4521 herda o pipe, o que significa que é capaz de escrever em seu lado de "entrada"; o <command>bash</command> redireciona seu fluxo de saída padrão para a entrada deste pipe. Em seguida, ele executa (e substitui-se com) o <command>ls</command> do programa, que lista o conteúdo do diretório atual. Como o <command>ls</command> escreve em sua saída padrão, e anteriormente se direcionou esta saída, seus resultados são efetivamente enviados para o pipe.</para>

	<para>Uma operação similar acontece para o segundo comando: o<command>bash</command> se clona novamente, levando a um novo processo <command>bash</command> com pid #4522. Como também é um processo filho do #4374, também herda o pipe; em seguida o <command>bash</command> conecta sua entrada padrão para a saída do pipe, então executa (e se substitui com) o <command>sort</command>, que classifica sua entrada e exibe os resultados.</para>

	<para>Todas as peças do quebra-cabeça agora estão definidas: o <command>ls</command> lê o diretório atual e escreve a lista de arquivos dentro do pipe; o <command>sort</command> lê esta lista, classifica-a em ordem alfabética e exibe os resultados. Os processos números #4521 e #4522 encerram, e o #4374 (que estava esperando por eles durante a operação), retoma o controle e exibe o prompt permitindo que o usuário digite um novo comando.</para>
      </sidebar>

      <para>No entanto, nem todas as comunicações entre processos são usados para mover os dados. Em muitas situações, a única informação que deve ser transmitida são mensagens de controle tais como "execução em pausa" ou "retomar execução". O Unix (e Linux) fornece um mecanismo conhecido como <emphasis>sinais</emphasis>, através do qual um processo pode simplesmente enviar um sinal específico (escolhido dentro de uma lista pré-definida de sinais) para outro processo. O único requisito é saber o <emphasis>pid</emphasis> do alvo.</para>

      <para>Para comunicações mais complexas também existem mecanismos que permitem um processo acessar, ou compartilhar, parte da  memória alocada para outros processos. A memória agora compartilhada entre eles pode ser usada para mover dados entre os processos.</para>

      <para>Finalmente, as conexões de rede também pode ajudar a comunicação de processos; esses processos podem até ser executados em diferentes computadores, possivelmente a milhares de quilômetros de distância.</para>

      <para>É bastante normal para um típico sistema similar ao Unix fazer uso de todos esses mecanismos em vários graus.</para>
    </section>
    <section id="sect.libraries">
      <title>Bibliotecas</title>
      <indexterm><primary>biblioteca (de funções)</primary></indexterm>

      <para>Bibliotecas de funções desempenham um papel crucial em um sistema operacional similar ao Unix. Eles não são programas propriamente dito, uma vez que não podem ser executados por si próprios, mas coleções de fragmentos de código que podem ser utilizados pelos programas normais. Entre as bibliotecas comuns, você pode encontrar:</para>
      <itemizedlist>
        <listitem>
	  <para>a biblioteca padrão C (<emphasis>glibc</emphasis>), que contém as funções básicas como aqueles para abrir arquivos ou conexões de rede, e outras que facilitam as interações com o kernel;</para>
        </listitem>
        <listitem>
	  <para>toolkits gráficos, como Gtk+ e o Qt, permitindo que muitos programas reutilizem os objetos gráficos que eles provêm;</para>
        </listitem>
        <listitem>
	  <para>a biblioteca <emphasis>libpng</emphasis> que permite carregar, interpretar e salvar imagens no formato PNG.</para>
        </listitem>
      </itemizedlist>

      <para>Graças a essas bibliotecas, as aplicações podem reutilizar o código existente. O desenvolvimento de aplicações é simplificado já que muitas aplicações podem reutilizar as mesmas funções. Como as bibliotecas são geralmente desenvolvidas por pessoas diferentes, o desenvolvimento global do sistema está mais perto da filosofia histórica do Unix.</para>

      <sidebar>
        <title><emphasis>CULTURA</emphasis> O Estilo Unix; uma coisa de cada vez</title>

	<para>Um dos conceitos fundamentais em que subjaz à família de sistemas operacionais Unix é que cada ferramenta deveria fazer uma coisa, e fazê-lo bem; aplicações podem reutilizar essas ferramentas para criar uma lógica mais avançada sobre elas. Essa filosofia pode ser vista em muitas encarnações. Shell scripts podem ser o melhor exemplo: eles montam sequências complexas de ferramentas muito simples (como <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command> e assim por diante). Outra implementação dessa filosofia pode ser vista em bibliotecas de código: a biblioteca <emphasis>libpng</emphasis> permite ler e escrever imagens PNG, com diferentes opções e de maneiras diferentes, mas ele faz só isso; nenhuma questão de incluir funções que exibem ou editam imagens.</para>
      </sidebar>

      <para>Além disso, essas bibliotecas muitas vezes são referidas como "bibliotecas compartilhadas", desde que o kernel possa carregá-las apenas uma vez para a memória, mesmo se vários processos utilizam a mesma biblioteca ao mesmo tempo. Isso permite economia de memória, quando comparado com a situação oposta (hipotética), onde o código para uma biblioteca seria carregada tantas vezes quantos os processos que a utilizam.</para>
    </section>
  </section>
</appendix>
