<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.3. Funcionamento Interno de um Computador: as Diferentes Camadas Envolvidas</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-pt-BR-1.0-1" /><meta
        name="keywords"
        content="BIOS, Núcleo, Unix, Processo, Hierarquia, Comandos Básicos" /><link
        rel="home"
        href="index.html"
        title="O Manual do Administrador Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Apêndice B. Curso Rápido de Reparação" /><link
        rel="prev"
        href="sect.filesystem-hierarchy.html"
        title="B.2. Organização da Hierarquia de Sistema de Arquivos" /><link
        rel="next"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. Algumas Tarefas realizadas pelo Núcleo" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/pt-BR/stable/sect.computer-layers.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.filesystem-hierarchy.html"><strong>Anterior</strong></a></li><li
          class="home">O Manual do Administrador Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-role-and-tasks.html"><strong>Próxima</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.computer-layers"></a>B.3. Funcionamento Interno de um Computador: as Diferentes Camadas Envolvidas</h2></div></div></div><div
          class="para">
			Um computador é muitas vezes considerado como algo bastante abstrato, e a interface visível externamente é muito mais simples do que a sua complexidade interna. Tal complexidade vem, em parte, a partir do número de peças envolvidas. No entanto, estas peças podem ser vistas em camadas, em que uma camada apenas interage com aqueles imediatamente acima ou abaixo.
		</div><div
          class="para">
			Um usuário final pode passar sem saber esses detalhes ... enquanto tudo funciona. Ao encontrar um problema como: "A internet não funciona!", A primeira coisa a fazer é identificar em qual camada o problema se origina. A placa de rede (hardware) está funcionando? É reconhecida pelo computador? Será que o kernel do Linux vê a placa? Os parâmetros de rede estão configurado corretamente? Todas estas questões isolam uma camada apropriada e foco em uma potencial fonte do problema.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.hardware"></a>B.3.1. A Camada mais Profunda: o Hardware</h3></div></div></div><a
            id="id-1.21.6.4.2"
            class="indexterm"></a><a
            id="id-1.21.6.4.3"
            class="indexterm"></a><a
            id="id-1.21.6.4.4"
            class="indexterm"></a><a
            id="id-1.21.6.4.5"
            class="indexterm"></a><a
            id="id-1.21.6.4.6"
            class="indexterm"></a><a
            id="id-1.21.6.4.7"
            class="indexterm"></a><a
            id="id-1.21.6.4.8"
            class="indexterm"></a><a
            id="id-1.21.6.4.9"
            class="indexterm"></a><div
            class="para">
				Vamos começar com um lembrete básico que um computador é, em primeiro lugar, um conjunto de elementos de hardware. Há geralmente uma placa principal (conhecido como a <span
              class="emphasis"><em>placa-mãe</em></span>), com um (ou mais) processador(es), memória RAM, controladores de dispositivos e encaixes (slots) de extensão para placas opcionais (para outros controladores de dispositivo). O mais notável entre esses controladores são IDE (Parallel ATA), SCSI e Serial ATA, para conexão com dispositivos de armazenamento, como discos rígidos. Outros controladores incluem USB, que é capaz de hospedar uma grande variedade de dispositivos (variando de webcams até termômetros, de teclados até sistemas de automação residencial) e IEEE 1394 (Firewire) . Esses controladores muitas vezes permitem conectar vários dispositivos para que o subsistema completo gerenciado por um controlador é, por este motivo, normalmente conhecido como "barramento" . Placas opcionais incluem placas gráficas (onde telas de monitores serão conectadas), placas de som, placas de rede, e assim por diante . Algumas placas principais são pré-fabricadas com esses recursos, e não precisa de placas opcionais .
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NA PRÄTICA</em></span> Verificando se o hardware funciona</strong></p></div></div></div><div
              class="para">
				Verificar se um hardware está funcionando pode ser complicado. Muito embora, provar que o mesmo não funciona às vezes é bem simples.
			</div><div
              class="para">
				Um disco rígido é feito de pratos giratórios e cabeças magnéticas móveis. Quando um disco rígido é ligado, o motor faz um zumbido característico. Também dissipa a energia na forma de calor. Consequentemente, um disco rígido que permanece frio e silencioso quando ligado está quebrado.
			</div><div
              class="para">
				Placas de rede muitas vezes incluem LEDs que indicam o estado da conexão. Se um cabo estiver conectado e leva a um hub ou switch de rede em funcionamento, pelo menos um LED será ligado. Se nenhum LED acende, ou o próprio cartão, o dispositivo de rede ou o cabo entre eles está com defeito. O passo seguinte é, por conseguinte, o teste de cada componente individualmente.
			</div><div
              class="para">
				Algumas placas opcionais - especialmente as placas de vídeo 3D - incluem dispositivos de refrigeração, tais como dissipadores de calor e/ou ventoinhas. Se a ventoinha não gira, mesmo que o cartão esteja ligado, uma explicação plausível é o cartão superaquecido. Isso vale também para o(s) processador(es) principal(is) localizado na placa principal.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.bios"></a>B.3.2. O Inicializador: a BIOS ou UEFI</h3></div></div></div><a
            id="id-1.21.6.5.2"
            class="indexterm"></a><a
            id="id-1.21.6.5.3"
            class="indexterm"></a><a
            id="id-1.21.6.5.4"
            class="indexterm"></a><div
            class="para">
				O hardware, por si só, é incapaz de realizar tarefas úteis sem um software que o gerenciasse. Controlar e interagir com o hardware é o objetivo do sistema operacional e aplicativos. Estes, por sua vez, requerem hardware funcional para executar.
			</div><div
            class="para">
				Esta simbiose entre hardware e software não acontece por si só. Quando o computador é ligado pela primeira vez, algumas configurações iniciais são necessárias. Esse papel é assumido pela BIOS ou UEFI, um software embarcado na placa principal que é executado automaticamente após a energização. Sua tarefa principal é a procura do software que pode lhe entregar o controle. Normalmente, no caso da BIOS, isso envolve buscar no primeiro disco rígido com um setor de inicialização (também conhecido como o <span
              class="emphasis"><em>master boot record</em></span> - registro mestre de inicialização - ou <acronym
              class="acronym">MBR</acronym>), carregar esse setor de inicialização e executá-lo. A partir deste ponto, a BIOS geralmente não é mais utilizada (até a próxima inicialização). No caso da UEFI, o processo envolve uma busca nos discos à procura de uma partição EFI contendo outras aplicações EFI para executar.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>FERRAMENTA</em></span> Setup, a ferramenta de configuração da BIOS/UEFI</strong></p></div></div></div><a
              id="id-1.21.6.5.7.2"
              class="indexterm"></a><div
              class="para">
				A BIOS/UEFI também contém software chamado de Setup, projetada para permitir a configuração de aspectos do computador. Em particular, ele permite escolher qual é o dispositivo preferencial de inicialização (por exemplo, o disquete ou CD-ROM), configurar o relógio do sistema, e assim por diante. Iniciar o Setup geralmente envolve pressionar uma tecla logo que o computador é ligado. Esta tecla é muitas vezes o <span
                class="keycap"><strong>Del</strong></span> ou <span
                class="keycap"><strong>Esc</strong></span>, às vezes a <span
                class="keycap"><strong>F2</strong></span> ou <span
                class="keycap"><strong>F10</strong></span>. Na maioria das vezes, a escolha é exibida na tela durante a inicialização.
			</div></div><div
            class="para">
				O setor de inicialização (ou a partição EFI), por sua vez, contém outro pedaço de software, chamada de bootloader, cujo propósito é encontrar e executar um sistema operacional. Uma vez que este bootloader não é incorporado na placa principal, mas carregado do disco, pode ser mais esperto do que a BIOS, o que explica por que o BIOS não carrega o sistema operacional por si só. Por exemplo, o carregador de inicialização (geralmente o GRUB em sistemas Linux) pode listar os sistemas operacionais disponíveis e pedir ao usuário para escolher um. Normalmente, fornece uma opção de tempo limite e escolha padrão. Às vezes, o usuário também pode optar por adicionar parâmetros para passar para o kernel, e assim por diante. Eventualmente, um kernel for encontrado, carregado na memória e executado.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTA</em></span> UEFI, um moderno substituto para a BIOS</strong></p></div></div></div><a
              id="id-1.21.6.5.9.2"
              class="indexterm"></a><a
              id="id-1.21.6.5.9.3"
              class="indexterm"></a><div
              class="para">
				UEFI é um desenvolvimento relativamente recente. A maioria dos computadores novos irão suportar a inicialização por UEFI, mas geralmente eles também suportam a inicialização por BIOS por questões de compatibilidade com sistemas operacionais que ainda não estão prontos para explorar o UEFI.
			</div><div
              class="para">
				Esse novo sistema se livra de algumas das limitações da inicialização pela BIOS: com o uso de uma partição dedicada, os carregadores de inicialização não mais precisam de truques especiais para cabeer na pequena <span
                class="emphasis"><em>MBR - master boot record</em></span>, e assim, descobrir qual kernel inicializar. Ainda melhor, com um kernel Linux adequadamente construído, a UEFI pode inicializar o kernel diretamente sem qualquer carregador de inicialização intermediário. O UEFI é também a fundação básica usada para entregar o <span
                class="emphasis"><em>Secure Boot</em></span>, uma tecnologia que garante que você apenas irá rodar software validado pelo seu fabricante de sistema operacional.
			</div></div><div
            class="para">
				A BIOS/UEFI também é responsável por detectar e inicializar uma série de dispositivos. Obviamente, isto inclui os dispositivos IDE/SATA (normalmente disco(s) rígido(s) e unidades de CD/DVD-ROM), mas também dispositivos PCI. Os dispositivos detectados são frequentemente listado na tela durante o processo de inicialização. Se esta lista passa muito rápido, use a tecla <span
              class="keycap"><strong>Pause</strong></span> para congelá-la por tempo suficiente para ler. Dispositivos PCI instalados que não aparecem são um mau presságio. Na pior das hipóteses, o dispositivo está com defeito. Na melhor das hipóteses, é apenas incompatível com a versão atual da BIOS ou com a placa mãe. As especificações PCI evoluiem, e as placas mãe antigas não são garantidas de lidar com dispositivos PCI mais recentes.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.kernel"></a>B.3.3. O Núcleo</h3></div></div></div><div
            class="para">
				Tanto a BIOS/UEFI como o bootloader apenas são executados por alguns segundos cada; agora estamos chegando ao primeiro software que é executado por um longo tempo, o kernel do sistema operacional. Este kernel assume o papel de um maestro de uma orquestra e assegura a coordenação entre o hardware e o software. Este papel envolve várias tarefas, incluindo: administrar o hardware, gerenciar processos, usuários e permissões, o sistema de arquivos, e assim por diante. O kernel fornece uma base comum a todos os outros programas no sistema.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.userspace-presentation"></a>B.3.4. O Espaço de Usuário</h3></div></div></div><div
            class="para">
				Apesar de tudo o que acontece fora do kernel podem ser agrupado como "espaço do usuário", ainda podemos separá-lo em camadas de software. No entanto, as suas interações são mais complexas do que antes, e as classificações podem não ser tão simples. Uma aplicação geralmente usa as bibliotecas, que por sua vez envolvem o kernel, mas as comunicações também podem envolver outros programas, ou até mesmo muitas bibliotecas que chamam umas às outras.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.filesystem-hierarchy.html"><strong>Anterior</strong>B.2. Organização da Hierarquia de Sistema de Arqu...</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Acima</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Principal</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-role-and-tasks.html"><strong>Próxima</strong>B.4. Algumas Tarefas realizadas pelo Núcleo</a></li></ul></body></html>
