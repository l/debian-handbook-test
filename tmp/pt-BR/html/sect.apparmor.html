<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.4. Introdução ao AppArmor</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-pt-BR-1.0-1" /><meta
        name="keywords"
        content="Firewall, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="O Manual do Administrador Debian" /><link
        rel="up"
        href="security.html"
        title="Capítulo 14. Segurança" /><link
        rel="prev"
        href="sect.supervision.html"
        title="14.3. Supervisão: Prevenção, Detecção, Desencorajamento" /><link
        rel="next"
        href="sect.selinux.html"
        title="14.5. Introducao ao SELinux" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/pt-BR/stable/sect.apparmor.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.supervision.html"><strong>Anterior</strong></a></li><li
          class="home">O Manual do Administrador Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.selinux.html"><strong>Próxima</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.apparmor"></a>14.4. Introdução ao AppArmor</h2></div></div></div><a
          id="id-1.17.7.2"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.apparmor-principles"></a>14.4.1. Princípios</h3></div></div></div><div
            class="para">
				AppArmor é um sistema de <span
              class="emphasis"><em>Controle de Acesso Mandatório</em></span> (MAC - Mandatory Access Control) construído sobre a interface LSM (<span
              class="emphasis"><em>Linux Security Modules</em></span>) do Linux. Na prática, o kernel consulta o AppArmor antes de cada chamada do sistema para saber se o processo está autorizado a fazer a operação dada. Através desse mecanismo, o AppArmor confina programas a um conjunto limitado de recursos.
			</div><a
            id="id-1.17.7.3.3"
            class="indexterm"></a><a
            id="id-1.17.7.3.4"
            class="indexterm"></a><div
            class="para">
				O AppArmor aplica um conjunto de regras (conhecidas como “perfil”) em cada programa. O perfil aplicado pelo kernel depende do caminho ("path") de instalação do programa sendo executado. Ao contrário do SELinux (discutido em <a
              class="xref"
              href="sect.selinux.html">Seção 14.5, “Introducao ao SELinux”</a>), as regras aplicadas não dependem do usuário. Todos os usuários encontram o mesmo conjunto de regras quando eles estão executando o mesmo programa (mas as permissões tradicionais do usuário ainda se aplicam e podem resultar em um comportamento diferente!).
			</div><div
            class="para">
				Os perfis AppArmor são armazenados em <code
              class="filename">/etc/apparmor.d/</code> e eles contém uma lista de regras de controle de acesso em recursos que cada programa pode fazer uso. Os perfis são compilados e carregados no núcleo pelo comando <code
              class="command">apparmor_parser</code>. Cada perfil pode ser carregado tanto em modo de aplicação ("enforcing") quanto em modo de registro ("complaining"). O primeiro aplica a política e reporta as tentativas de violação, enquanto que o último não aplica a política mas mantém os registros de chamadas de sistema que deveriam ter sido negadas.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.apparmor-setup"></a>14.4.2. Habilitando o AppArmor e gerenciando os perfis AppArmor</h3></div></div></div><div
            class="para">
				O suporte ao AppArmor é construído nos kernel padrões fornecidos pelo Debian. Habilitar o AppArmor é, assim, uma simples questão de instalar alguns pacotes e adicionar alguns parâmetros à linha de comando do kernel:
			</div><pre
            class="screen"><code
              class="computeroutput"># </code><strong
              class="userinput"><code>apt install apparmor apparmor-profiles apparmor-utils
</code></strong><code
              class="computeroutput">[...]
# </code><strong
              class="userinput"><code>perl -pi -e 's,GRUB_CMDLINE_LINUX="(.*)"$,GRUB_CMDLINE_LINUX="$1 apparmor=1 security=apparmor",' /etc/default/grub
</code></strong><code
              class="computeroutput"># </code><strong
              class="userinput"><code>update-grub
</code></strong></pre><div
            class="para">
				Após uma reinicialização, o AppArmor está agora funcional e o <code
              class="command">aa-status</code> irá confirmar isso rapidamente:
			</div><pre
            class="screen">
<code
              class="computeroutput"># </code><strong
              class="userinput"><code>aa-status</code></strong>
<code
              class="computeroutput">apparmor module is loaded.
44 profiles are loaded.
9 profiles are in enforce mode.
   /usr/bin/lxc-start
   /usr/lib/chromium-browser/chromium-browser//browser_java
[...]
35 profiles are in complain mode.
   /sbin/klogd
[...]
3 processes have profiles defined.
1 processes are in enforce mode.
   /usr/sbin/libvirtd (1295) 
2 processes are in complain mode.
   /usr/sbin/avahi-daemon (941) 
   /usr/sbin/avahi-daemon (1000) 
0 processes are unconfined but have a profile defined.</code></pre><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>NOTA</em></span> Mais perfis AppArmor</strong></p></div></div></div><div
              class="para">
				O pacote <span
                class="pkg pkg">apparmor-profiles</span> contém perfis gerenciados pela comunidade upstream do AppArmor. Para obter ainda mais perfis você pode instalar o <span
                class="pkg pkg">apparmor-profiles-extra</span> que contém perfis desenvolvidos pelo Ubuntu e Debian.
			</div></div><div
            class="para">
				O estado de cada perfil pode ser alterado entre aplicação ("enforcing") e registro ("complaining") com chamadas a <code
              class="command">aa-enforce</code> e <code
              class="command">aa-complain</code> dando como parâmetro tanto o caminho para o executável como o caminho para o arquivo de política. Adicionalmente, um perfil pode ser inteiramente desabilitado com <code
              class="command">aa-disable</code> ou posto em modo auditar ("audit") (para aceitar chamadas de sistema também) com <code
              class="command">aa-audit</code>.
			</div><pre
            class="screen">
<code
              class="computeroutput"># </code><strong
              class="userinput"><code>aa-enforce /usr/sbin/avahi-daemon</code></strong>
<code
              class="computeroutput">Setting /usr/sbin/avahi-daemon to enforce mode.</code>
<code
              class="computeroutput"># </code><strong
              class="userinput"><code>aa-complain /etc/apparmor.d/usr.bin.lxc-start</code></strong>
<code
              class="computeroutput">Setting /etc/apparmor.d/usr.bin.lxc-start to complain mode.</code>
</pre></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.apparmor-new-profile"></a>14.4.3. Criando um novo perfil</h3></div></div></div><div
            class="para">
				Mesmo sendo bem fácil criar um perfil AppArmor, a maioria dos programas não tem um. Essa seção irá mostrar a você como criar um novo perfil a partir do zero apenas usando o programa alvo e deixando o AppArmor monitorar a chamada de sistema que ele faz e os recursos que ele acessa.
			</div><div
            class="para">
				Os programas mais importantes que precisam ser confinados são os programas voltados para a rede, pois são mais atrativos à ataques remotos. É por isso que o AppArmor convenientemente fornece o comando <code
              class="command">aa-unconfined</code> para listar os programas que não tem perfil associado e que expôem um soquete de rede aberto. Com a opção <code
              class="literal">--paranoid</code> você tem todos os processos não confinados que tem ao menos uma conexão de rede ativa.
			</div><pre
            class="screen">
<code
              class="computeroutput"># </code><strong
              class="userinput"><code>aa-unconfined</code></strong>
<code
              class="computeroutput">801 /sbin/dhclient not confined
890 /sbin/rpcbind not confined
899 /sbin/rpc.statd not confined
929 /usr/sbin/sshd not confined
941 /usr/sbin/avahi-daemon confined by '/usr/sbin/avahi-daemon (complain)'
988 /usr/sbin/minissdpd not confined
1276 /usr/sbin/exim4 not confined
1485 /usr/lib/erlang/erts-6.2/bin/epmd not confined
1751 /usr/lib/erlang/erts-6.2/bin/beam.smp not confined
19592 /usr/lib/dleyna-renderer/dleyna-renderer-service not confined</code>
</pre><div
            class="para">
				No exemplo a seguir, nós iremos então tentar criar um perfil para o <code
              class="command">/sbin/dhclient</code>. Para isso, nós iremos usar o <code
              class="command">aa-genprof dhclient</code>. Ele irá convidar você a usar a aplicação em outra janela e quando terminar voltar ao <code
              class="command">aa-genprof</code> para procurar por eventos AppArmor nos registros ("logs") do sistema e converter esses registros em regras de acesso. Para cada evento registrado, ele irá fazer uma ou mais sugestões de regras que você pode tanto aprovar quanto fazer edições adicionais de múltiplas maneiras:
			</div><pre
            class="screen">
<code
              class="computeroutput"># </code><strong
              class="userinput"><code>aa-genprof dhclient</code></strong>
<code
              class="computeroutput">Writing updated profile for /sbin/dhclient.
Setting /sbin/dhclient to complain mode.

Before you begin, you may wish to check if a
profile already exists for the application you
wish to confine. See the following wiki page for
more information:
http://wiki.apparmor.net/index.php/Profiles

Please start the application to be profiled in
another window and exercise its functionality now.

Once completed, select the "Scan" option below in 
order to scan the system logs for AppArmor events. 

For each AppArmor event, you will be given the 
opportunity to choose whether the access should be 
allowed or denied.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
Reading log entries from /var/log/audit/audit.log.

Profile:  /sbin/dhclient <span
                id="aa-genprof-execute"><img
                  class="callout"
                  src="Common_Content/images/1.png"
                  alt="1" /></span>
Execute:  /usr/lib/NetworkManager/nm-dhcp-helper
Severity: unknown

(I)nherit / (C)hild / (P)rofile / (N)amed / (U)nconfined / (X) ix On / (D)eny / Abo(r)t / (F)inish
<strong
                class="userinput"><code>P</code></strong>
Should AppArmor sanitise the environment when
switching profiles?

Sanitising environment is more secure,
but some applications depend on the presence
of LD_PRELOAD or LD_LIBRARY_PATH.

(Y)es / [(N)o]
<strong
                class="userinput"><code>Y</code></strong>
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.
Complain-mode changes:
WARN: unknown capability: CAP_net_raw

Profile:    /sbin/dhclient <span
                id="aa-genprof-capability"><img
                  class="callout"
                  src="Common_Content/images/2.png"
                  alt="2" /></span>
Capability: net_raw
Severity:   unknown

[(A)llow] / (D)eny / (I)gnore / Audi(t) / Abo(r)t / (F)inish
<strong
                class="userinput"><code>A</code></strong>
Adding capability net_raw to profile.

Profile:  /sbin/dhclient <span
                id="aa-genprof-read"><img
                  class="callout"
                  src="Common_Content/images/3.png"
                  alt="3" /></span>
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
  3 - #include &lt;abstractions/nameservice&gt; 
  4 - #include &lt;abstractions/totem&gt; 
 [5 - /etc/nsswitch.conf]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<strong
                class="userinput"><code>3</code></strong>

Profile:  /sbin/dhclient
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
 [3 - #include &lt;abstractions/nameservice&gt;]
  4 - #include &lt;abstractions/totem&gt; 
  5 - /etc/nsswitch.conf 
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<strong
                class="userinput"><code>A</code></strong>
Adding #include &lt;abstractions/nameservice&gt; to profile.

Profile:  /sbin/dhclient
Path:     /proc/7252/net/dev
Mode:     r
Severity: 6

  1 - /proc/7252/net/dev 
 [2 - /proc/*/net/dev]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<strong
                class="userinput"><code>A</code></strong>
Adding /proc/*/net/dev r to profile

[...]
Profile:  /sbin/dhclient <span
                id="aa-genprof-write"><img
                  class="callout"
                  src="Common_Content/images/4.png"
                  alt="4" /></span>
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

 [1 - /run/dhclient-eth0.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<strong
                class="userinput"><code>N</code></strong>

Enter new path: /run/dhclient*.pid

Profile:  /sbin/dhclient
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

  1 - /run/dhclient-eth0.pid 
 [2 - /run/dhclient*.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<strong
                class="userinput"><code>A</code></strong>
Adding /run/dhclient*.pid w to profile

[...]
Profile:  /usr/lib/NetworkManager/nm-dhcp-helper <span
                id="aa-genprof-other-profile"><img
                  class="callout"
                  src="Common_Content/images/5.png"
                  alt="5" /></span>
Path:     /proc/filesystems
Mode:     r
Severity: 6

 [1 - /proc/filesystems]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<strong
                class="userinput"><code>A</code></strong>
Adding /proc/filesystems r to profile

= Changed Local Profiles =

The following local profiles were changed. Would you like to save them?

 [1 - /sbin/dhclient]
  2 - /usr/lib/NetworkManager/nm-dhcp-helper 
(S)ave Changes / Save Selec(t)ed Profile / [(V)iew Changes] / View Changes b/w (C)lean profiles / Abo(r)t
<strong
                class="userinput"><code>S</code></strong>
Writing updated profile for /sbin/dhclient.
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
<strong
                class="userinput"><code>F</code></strong>
Setting /sbin/dhclient to enforce mode.
Setting /usr/lib/NetworkManager/nm-dhcp-helper to enforce mode.

Reloaded AppArmor profiles in enforce mode.

Please consider contributing your new profile!
See the following wiki page for more information:
http://wiki.apparmor.net/index.php/Profiles

Finished generating profile for /sbin/dhclient.</code></pre><div
            class="para">
				Note que o programa não exibe de volta os caracteres de controle que você digitou, mas para clarear a explicação eu inclui eles na transcrição prévia.
			</div><div
            class="calloutlist"><table
              border="0"
              summary="Callout list"><tr><td
                  width="5%"
                  valign="top"
                  align="left"><p><a
                      href="#aa-genprof-execute"><img
                        class="callout"
                        src="Common_Content/images/1.png"
                        alt="1" /></a> </p></td><td
                  valign="top"
                  align="left"><div
                    class="para">
						O primeiro evento detectado é a execução de outro programa. Neste caso, você tem múltiplas escolhas: você pode rodar o programa com o perfil do processo pai (a escolha “Inherit”), você pode rodá-lo com seu próprio e dedicado perfil (as escolhas “Profile” e “Named”, diferindo apenas pela possibilidade de usar um nome de perfil arbitrário), você pode rodá-lo com um sub-perfil do processo pai (a escolha “Child”), você pode rodá-lo sem qualquer perfil (a escolha “Unconfined”) ou você pode decidir não rodá-lo de forma alguma (a escolha “Deny”).
					</div><div
                    class="para">
						Note que quando você opta por rodá-lo sob um perfil dedicado que não existe ainda, a ferramenta irá criar o perfil em falta para você e irá fazer sugestões de regras para esse perfil nesta mesma execução.
					</div></td></tr><tr><td
                  width="5%"
                  valign="top"
                  align="left"><p><a
                      href="#aa-genprof-capability"><img
                        class="callout"
                        src="Common_Content/images/2.png"
                        alt="2" /></a> </p></td><td
                  valign="top"
                  align="left"><div
                    class="para">
						A nível do kernel, os poderes especiais do usuário root foram divididos em "recursos" ("capabilities"). Quando uma chamada de sistema requer um recurso específico, o AppArmor irá verificar se o perfil permite ao programa fazer uso desse recurso.
					</div></td></tr><tr><td
                  width="5%"
                  valign="top"
                  align="left"><p><a
                      href="#aa-genprof-read"><img
                        class="callout"
                        src="Common_Content/images/3.png"
                        alt="3" /></a> </p></td><td
                  valign="top"
                  align="left"><div
                    class="para">
						Aqui o programa busca por permissões de leitura para o <code
                      class="filename">/etc/nsswitch.conf</code>. O <code
                      class="command">aa-genprof</code> detectou que essa permissão era também obtida por múltiplas "abstrações” e as oferece como escolhas alternativas. Uma abstração fornece um conjunto de regras de acesso reusável reunindo múltiplos recursos que são comumente usados juntos. Nesse caso específico, o arquivo é geralmente acessado através das funções relacionadas a nameservice da biblioteca do C e nós digitamos "3" para primeiro selecionarmos a opção "#include &lt;abstractions/nameservice&gt;" e então "A" para dar a permissão.
					</div></td></tr><tr><td
                  width="5%"
                  valign="top"
                  align="left"><p><a
                      href="#aa-genprof-write"><img
                        class="callout"
                        src="Common_Content/images/4.png"
                        alt="4" /></a> </p></td><td
                  valign="top"
                  align="left"><div
                    class="para">
						O programa quer criar o arquivo <code
                      class="filename">/run/dhclient-eth0.pid</code>. Se nós permitirmos apenas a criação desse arquivo específico, o programa não irá funcionar quando o usuário for usá-lo com outra interface de rede. Assim, nós selecionamos "Novo" (“New”) para substituir o nome de arquivo por algo mais genérico como “/run/dhclient*.pid” antes de gravar a regra com "Permitir" (“Allow”).
					</div></td></tr><tr><td
                  width="5%"
                  valign="top"
                  align="left"><p><a
                      href="#aa-genprof-other-profile"><img
                        class="callout"
                        src="Common_Content/images/5.png"
                        alt="5" /></a> </p></td><td
                  valign="top"
                  align="left"><div
                    class="para">
						Note que essa requisição de acesso não é parte do perfil do dhclient mas do novo perfil que nós criamos quando nós permitimos o <code
                      class="filename">/usr/lib/NetworkManager/nm-dhcp-helper</code> rodar com seu próprio perfil.
					</div><div
                    class="para">
						Após termos passado por todos os eventos registrados, o programa se oferece para salvar todos os perfis que foram criados durante sua execução. Neste caso, nós temos dois perfis que nós salvamos ao mesmo tempo com "Salvar" (“Save”) (mas você pode salvá-los individualmente também) antes de sair do programa com "Terminar" (“Finish”).
					</div></td></tr></table></div><div
            class="para">
				O <code
              class="command">aa-genprof</code> é na realidade apenas um envoltório inteligente em volta do <code
              class="command">aa-logprof</code>: ele cria um perfil vazio, carrega-o em modo de registro ("complain mode") e então roda o <code
              class="command">aa-logprof</code> que é uma ferramenta para atualizar um perfil com base nas violações de perfil que foram registradas. Então você pode rodar novamente essa ferramenta mais tarde para aprimorar o perfil que você acabou de criar.
			</div><div
            class="para">
				Se você quer que o perfil gerado seja completo, você deveria usar o programa de todas as maneiras que sejam legítimas de usar. No caso do dhclient, isso significa rodá-lo via Network Manager, rodá-lo via ifupdown, rodá-lo manualmente, etc. No final, você deve obter um <code
              class="filename">/etc/apparmor.d/sbin.dhclient</code> próximo a isso:
			</div><pre
            class="programlisting">
# Last Modified: Tue Sep  8 21:40:02 2015
#include &lt;tunables/global&gt;

/sbin/dhclient {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/nameservice&gt;

  capability net_bind_service,
  capability net_raw,

  /bin/dash r,
  /etc/dhcp/* r,
  /etc/dhcp/dhclient-enter-hooks.d/* r,
  /etc/dhcp/dhclient-exit-hooks.d/* r,
  /etc/resolv.conf.* w,
  /etc/samba/dhcp.conf.* w,
  /proc/*/net/dev r,
  /proc/filesystems r,
  /run/dhclient*.pid w,
  /sbin/dhclient mr,
  /sbin/dhclient-script rCx,
  /usr/lib/NetworkManager/nm-dhcp-helper Px,
  /var/lib/NetworkManager/* r,
  /var/lib/NetworkManager/*.lease rw,
  /var/lib/dhcp/*.leases rw,

  profile /sbin/dhclient-script flags=(complain) {
    #include &lt;abstractions/base&gt;
    #include &lt;abstractions/bash&gt;

    /bin/dash rix,
    /etc/dhcp/dhclient-enter-hooks.d/* r,
    /etc/dhcp/dhclient-exit-hooks.d/* r,
    /sbin/dhclient-script r,

  }
}
</pre></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.supervision.html"><strong>Anterior</strong>14.3. Supervisão: Prevenção, Detecção, Desencoraj...</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Acima</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Principal</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.selinux.html"><strong>Próxima</strong>14.5. Introducao ao SELinux</a></li></ul></body></html>
