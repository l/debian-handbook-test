<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.2. Login remoto</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-pt-BR-1.0-1" /><meta
        name="keywords"
        content="Inicialização do Sistema, Initscripts, SSH, Telnet, Direitos, Permissões, Supervisão, Inetd, Cron, Backup, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="O Manual do Administrador Debian" /><link
        rel="up"
        href="unix-services.html"
        title="Capítulo 9. Serviços Unix" /><link
        rel="prev"
        href="unix-services.html"
        title="Capítulo 9. Serviços Unix" /><link
        rel="next"
        href="sect.rights-management.html"
        title="9.3. Gerenciando Direitos" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/pt-BR/stable/sect.remote-login.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Anterior</strong></a></li><li
          class="home">O Manual do Administrador Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Próxima</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.remote-login"></a>9.2. Login remoto</h2></div></div></div><div
          class="para">
			É essencial para o administrador ser capaz de se conectar a um computador remotamente. Servidores, confinados em seu quarto, raramente são equipados com permanentes teclados e monitores — mas eles estão conectados à rede.
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>DE VOLTA AO BÁSICO</em></span> Cliente, servidor</strong></p></div></div></div><a
            id="id-1.12.5.3.2"
            class="indexterm"></a><a
            id="id-1.12.5.3.3"
            class="indexterm"></a><div
            class="para">
			Um sistema onde vários processos comunicarem é frequentemente descrito com a metáfora de "cliente/servidor". O servidor é o programa que recebe as solicitações provenientes de um cliente e os executa. É o cliente que controla as operações, o servidor não toma qualquer iniciativa própria.
		</div></div><a
          id="id-1.12.5.4"
          class="indexterm"></a><a
          id="id-1.12.5.5"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ssh"></a>9.2.1. Login remoto seguro: SSH</h3></div></div></div><a
            id="id-1.12.5.6.2"
            class="indexterm"></a><a
            id="id-1.12.5.6.3"
            class="indexterm"></a><div
            class="para">
				O protocolo <span
              class="emphasis"><em>SSH</em></span> (Secure SHell) foi projetado com segurança e confiabilidade em mente. Conexões usando SSH estão seguras: o parceiro é autenticado e todas as trocas de dados criptografadas.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURA</em></span> Telnet e RSH estão obsoletos</strong></p></div></div></div><a
              id="id-1.12.5.6.5.2"
              class="indexterm"></a><a
              id="id-1.12.5.6.5.3"
              class="indexterm"></a><div
              class="para">
				Antes do SSH, <span
                class="emphasis"><em>Telnet</em></span> e <span
                class="emphasis"><em>RSH</em></span> eram as principais ferramentas usadas para fazer login remotamente. Elas são agora totalmente obsoletas e não devem mais ser usadas, mesmo que o Debian ainda forneça elas.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOCABULÁRIO</em></span> Autenticação, criptografia</strong></p></div></div></div><div
              class="para">
				Quando você precisar dar um cliente a capacidade de conduzir ou desencadear ações em um servidor, a segurança é importante. Você deve garantir a identidade do cliente; Esta é a autenticação. Esta identidade geralmente consiste de uma senha que deve ser mantida em segredo, ou qualquer outro cliente pode obter a senha. Este é o propósito da criptografia, que é uma forma de codificação que permite que dois sistemas de comunicação de informações confidenciais sobre um canal público, protegendo-o de ser lido por outros.
			</div><div
              class="para">
				Autenticação e criptografia, muitas vezes são mencionados juntos, porque eles são freqüentemente usados em conjunto, tanto porque eles geralmente são implementados com conceitos matemáticos semelhantes.
			</div></div><div
            class="para">
				SSH também oferece dois serviços de transferência de arquivo. <code
              class="command">scp</code> é uma ferramenta de linha de comando que pode ser usada como <code
              class="command">cp</code>, exceto que qualquer caminho a outra máquina é prefixado com o nome da máquina, seguido por dois-pontos.
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>scp arquivo máquina:/tmp/</code></strong></pre><div
            class="para">
				<code
              class="command">sftp</code> é um comando interativo, semelhante ao <code
              class="command">ftp</code>. Em uma única sessão, o <code
              class="command">sftp</code> pode transferir vários arquivos, e com ele é possível manipular arquivos remotos (apagar, renomear, alterar permissões, etc.).
			</div><a
            id="id-1.12.5.6.10"
            class="indexterm"></a><a
            id="id-1.12.5.6.11"
            class="indexterm"></a><div
            class="para">
				O Debian usa o OpenSSH, uma versão livre do SSH mantido pelo projeto <code
              class="command">OpenBSD</code> (um sistema operacional livre baseado no kernel BSD, focado em segurança) e uma bifurcação do programa original SSH desenvolvido pela empresa SSH Communications Security Corp, da Finlândia. Esta empresa desenvolveu inicialmente o SSH como software livre, mas num dado momento decidiu continuar o seu desenvolvimento sob uma licença proprietária. O projeto OpenBSD criou então o OpenSSH para manter uma versão gratuita do SSH.
			</div><a
            id="id-1.12.5.6.13"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>DE VOLTA AO BÁSICO</em></span> <span
                        class="foreignphrase"><em
                          class="foreignphrase">Fork</em></span></strong></p></div></div></div><a
              id="id-1.12.5.6.14.2"
              class="indexterm"></a><div
              class="para">
				Uma ramificação ("fork"), na área de software, significa um novo projeto que se inicia como um clone de um projeto existente, e que vai competir com ele. A partir daí, ambos os softwares irão divergir rapidamente em termos de novos desenvolvimentos. Uma ramificação é frequentemente o resultado de divergências dentro da equipe de desenvolvimento.
			</div><div
              class="para">
				A opção de ramificar um projeto é um resultado direto da própria natureza do software livre, uma ramificação é um evento saudável, quando se permite a continuação de um projeto como software livre (por exemplo, em caso de alterações de licença). Uma ramificação decorrente de divergências técnicas ou pessoais é muitas vezes um desperdício de recursos humanos; outra resolução seria preferível. Já se tem notícia de fusões de dois projetos que já passaram por uma divisão anterior.
			</div></div><div
            class="para">
				O OpenSSH é dividido em dois pacotes. A parte do cliente está no pacote <span
              class="pkg pkg">openssh-client</span>, e o pacote do servidor está no <span
              class="pkg pkg">openssh-server</span>. O meta-pacote <span
              class="pkg pkg">ssh</span> depende de ambas as partes e facilita a instalação de ambos (<code
              class="command">apt install ssh</code>).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-key-based-auth"></a>9.2.1.1. Autenticação Baseado em Chave</h4></div></div></div><div
              class="para">
					Cada vez que alguém se conecta por SSH, o servidor remoto pede uma senha para autenticar o usuário. Isto pode ser problemático se você quiser automatizar uma conexão, ou se você usar uma ferramenta que requer conexões frequentes com o SSH. Por este motivo que o SSH oferece um sistema de autenticação baseado em chave.
				</div><div
              class="para">
					O usuário gera um par de chaves na máquina cliente com <code
                class="command">ssh-keygen -t rsa</code>; a chave pública é armazenada em <code
                class="filename">~/.ssh/id_rsa.pub</code>,enquanto o chave privada correspondente é armazenada em <code
                class="filename">~/.ssh/id_rsa</code>.O usuário em seguida usa <code
                class="command">ssh-copy-id <em
                  class="replaceable">server</em></code> para adicionar a sua chave pública no servidor <code
                class="filename">~/.ssh/authorized_keys</code>.Se a chave privada não estava protegida por uma "senha" no momento de sua criação, todos os logins subsequentes sobre o servidor vão funcionar sem uma senha.Caso contrário, a chave privada deve ser decifrada a cada momento digitando a senha.Felizmente, <code
                class="command">ssh-agent</code> nos permite manter as chaves privadas na memória para não ter que re-digitar com frequencia a senha.Para isso, basta usar <code
                class="command">ssh-add</code> (uma vez por sessão de trabalho),desde que a sessão já está associado a uma instância funcional do <code
                class="command">ssh-agent</code>.O Debian ativa por padrão nas sessões gráficas, mas isso pode ser desativado alterando <code
                class="filename">/etc/X11/Xsession.options</code>.Para uma sessão de console, você pode iniciá-lo manualmente com <code
                class="command">eval $(ssh-agent)</code>.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SEGURANÇA</em></span> Proteção da chave privada</strong></p></div></div></div><div
                class="para">
					Quem tem a chave privada pode fazer login na conta, assim, configurada. É por isso que o acesso para a chave privada é protegida por uma "frase". Alguém que adquire uma cópia de um arquivo de chave privada (por exemplo,<code
                  class="filename">~/.ssh/id_rsa</code>) ainda tem de saber esta frasea fim de ser capaz de usá-la. Esta proteção adicional não é, no entanto, impenetrável, e se você acha que esse arquivo foi comprometido, é melhor desativar essa chave nos computadores em que foi instalado (para removê-lo  <code
                  class="filename">authorized_keys</code> files) e substituia com uma chave recentemente gerada.
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURA</em></span> Falha do OpenSSL no Debian <span
                          class="distribution distribution">Etch</span></strong></p></div></div></div><div
                class="para">
					A biblioteca OpenSSL, como era inicialmente fornecida no Debian <span
                  class="distribution distribution">Etch</span>, tinha um grave problema no seu gerador de número aleatório (Random Number Generator - RNG). De fato, o mantenedor Debian tinha feito uma mudança para que aplicações usando ela não gerassem avisos quando analisadas por ferramentas de teste de memória como <code
                  class="command">valgrind</code>.Infelizmente, esta mudança também significou que o RNG estava empregando apenas uma fonte de entropia que corresponde ao número do processo (PID), cujos 32.000 possíveis valores não oferecem aleatoriedade suficiente. <div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="http://www.debian.org/security/2008/dsa-1571">http://www.debian.org/security/2008/dsa-1571</a></div>
				</div><div
                class="para">
					Especificamente, sempre que OpenSSL era utilizado para gerar uma chave, sempre produzia uma chave dentro de um conjunto conhecido de centenas de milhares de chaves (32.000 multiplicada para um pequeno número de comprimentos de chave). Isso afetou as chaves SSH, chaves SSL e certificados X.509 usados por inúmeras aplicações, tais como o OpenVPN. Um cracker só tinha que tentar todas as chaves para ganhar acesso não autorizado. Para reduzir o impacto do problema, o daemon SSH foi modificado para recusar chaves problemáticas que estão listadas nos pacotes <span
                  class="pkg pkg">openssh-blacklist</span> e <span
                  class="pkg pkg">openssh-blacklist-extra</span>. Além disso, o comando <code
                  class="command">ssh-vulnkey</code> permite a identificação de chaves possivelmente comprometidas no sistema.
				</div><div
                class="para">
					Uma análise mais completa deste incidente mostra que ele é o resultado de múltiplos (pequenos) problemas, tanto dentro do projeto OpenSSL, como com o mantenedor do pacote Debian. Uma biblioteca amplamente utilizada como OpenSSL não deveria - sem modificações - gerar advertências quando testada pelo <code
                  class="command">valgrind</code>. Além disso, o código (especialmente as partes sensíveis como o RNG) deveria ser mais bem comentado para evitar tais erros. Pelo lado do Debian, o mantenedor queria validar as modificações com os desenvolvedores do OpenSSL, mas simplesmente explicou as modificações sem fornecer-lhes o patch correspondente para revisão e falhou em mencionar seu papel dentro do Debian. Finalmente, as escolhas de manutenção não eram as ideais, as mudanças feitas no código original não eram documentadas com clareza; todas as modificações eram efetivamente armazenadas em um repositório Subversion, mas elas acabaram todos agrupadas em um único patch durante a criação do pacote fonte.
				</div><div
                class="para">
					It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="http://sources.debian.org">http://sources.debian.org</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-x11"></a>9.2.1.2. Usando Aplicações X11 Remotamente</h4></div></div></div><div
              class="para">
					O protocolo SSH permite o encaminhamento de dados gráficos (sessão “X11”, a partir do nome do sistema gráfico mais difundido no Unix); o servidor então mantém um canal dedicado para esses dados. Especificamente, um programa gráfico executado remotamente pode ser exibido no servidor X.org da tela local, e toda a sessão (entrada e exibição) será segura. Como essa funcionalidade permite que aplicações remotas interfiram com o sistema local, ela é desabilitada por padrão. Você pode habilitá-la especificando <code
                class="literal">X11Forwarding yes</code> no arquivo de configuração do servidor (<code
                class="filename">/etc/ssh/sshd_config</code>). Finalmente, o usuário tem que também requisitá-la adicionando a opção <code
                class="literal">-X</code> na linha de comando do <code
                class="command">ssh</code>.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ssh-port-forwarding"></a>9.2.1.3. Criando Túneis Criptografados com Encaminhamento de Porta</h4></div></div></div><a
              id="id-1.12.5.6.18.2"
              class="indexterm"></a><div
              class="para">
					Suas opções <code
                class="literal">-R</code> e <code
                class="literal">-L</code> permitem ao <code
                class="command">ssh</code> criar “túneis criptografados” entre duas máquinas, encaminhando com segurança uma porta TCP local (veja barra lateral <a
                class="xref"
                href="network-infrastructure.html#sidebar.tcp-udp"><span
                  class="emphasis"><em>DE VOLTA AO BÁSICO</em></span> TCP/UDP</a>) para uma máquina remota ou vice versa.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULÁRIO</em></span> Túnel</strong></p></div></div></div><a
                id="id-1.12.5.6.18.4.2"
                class="indexterm"></a><a
                id="id-1.12.5.6.18.4.3"
                class="indexterm"></a><div
                class="para">
					A Internet, e a maioria das LANs que estão conectadas a ela, operam em modo pacote (packet) e não em modo conectado (connected), o que significa que um pacote emitido de um computador para outro fará paradas em vários roteadores intermediários para encontrar seu destino. Você pode ainda simular uma operação de conectação (connected) aonde o fluxo (stream) é encapsulada em pacotes IP normais. Esses pacotes seguem sua rota usual, mas o fluxo (stream) é rescontruído sem mudanças até o destino. Nós chamamos isso de “túnel”, em analogia a uma estrada com túnel aonde veículos vão diretamente da entrada (input) para a saída (output) sem encontrarem nenhum cruzamento, em oposição a um caminho na superfície que envolveria interseções e mudanças de direção.
				</div><div
                class="para">
					Você pode usar essa oportunidade para adicionar criptografia ao túnel: o fluxo (stream) que flui através dele seria então irreconhecível por quem está de fora, mas retornaria ao forma sem criptografia na saída do túnel.
				</div></div><div
              class="para">
					<code
                class="command">ssh -L 8000:server:25 intermediary</code> estabeleceuma sessão SSH com a máquina <em
                class="replaceable">intermediary</em> e escuta pela porta local 8000 (veja <a
                class="xref"
                href="sect.remote-login.html#figure.ssh-L">Figura 9.3, “Encaminhando uma porta local com SSH”</a>). Para qualquer conexão estabelecida por esta porta, <code
                class="command">ssh</code> irá iniciar uma conexão a partir do computador <em
                class="replaceable">intermediary</em> na porta 25 no <em
                class="replaceable">server</em>, e irá ligar as duas conexões.
				</div><div
              class="para">
					<code
                class="command">ssh -R 8000:server:25 intermediary</code> também estabelece uma sessão SSH com o computador <em
                class="replaceable">intermediary</em>, mas nessa máquina que o <code
                class="command">ssh</code> ouve na porta 8000 (veja <a
                class="xref"
                href="sect.remote-login.html#figure.ssh-R">Figura 9.4, “Encaminhando uma porta remota com SSH”</a>). Qualquer conexão estabelecida nesta porta fará com que o <code
                class="command">ssh</code> abrir uma conexão a partir da máquina local na porta 25 do <em
                class="replaceable">server</em>, e fazer a ligação das duas conexões.
				</div><div
              class="para">
					Nos dois casos, as conexões são feitas pela porta 25 na máquina (host) <em
                class="replaceable">server</em>, que passa pelo túnel SSH estabelecido entre a máquina local e a máquina <em
                class="replaceable">intermediary</em>. No primeiro caso, a entrada do túnel é a porta local 8000, e os dados se movem em direção a máquina <em
                class="replaceable">intermediary</em> antes de ser direcionada ao <em
                class="replaceable">server</em> na rede “pública”. No segundo caso, a entrada e a saída do túnel são invertidas; a entrada é a porta 8000 na máquina <em
                class="replaceable">intermediary</em>, a saída é na máquina (host) local, e os dados são então direcionados para o <em
                class="replaceable">server</em>. Na prática, o servidor é usualmente a máquina local ou a intermediária. Dessa forma o SSH mantém segura a conexão de uma ponta a outra.
				</div><div
              class="figure"><a
                xmlns=""
                id="figure.ssh-L"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-L.png"
                    alt="Encaminhando uma porta local com SSH" /></div></div><p
                class="title"><strong>Figura 9.3. Encaminhando uma porta local com SSH</strong></p></div><div
              class="figure"><a
                xmlns=""
                id="figure.ssh-R"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/ssh-R.png"
                    alt="Encaminhando uma porta remota com SSH" /></div></div><p
                class="title"><strong>Figura 9.4. Encaminhando uma porta remota com SSH</strong></p></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.remote-desktops"></a>9.2.2. Usando Ambientes Gráficos Remotamente</h3></div></div></div><div
            class="para">
				O VNC (Virtual Network Computing) permite o acesso remoto ao ambiente de trabalho (desktops) gráfico.
			</div><a
            id="id-1.12.5.7.3"
            class="indexterm"></a><a
            id="id-1.12.5.7.4"
            class="indexterm"></a><a
            id="id-1.12.5.7.5"
            class="indexterm"></a><a
            id="id-1.12.5.7.6"
            class="indexterm"></a><a
            id="id-1.12.5.7.7"
            class="indexterm"></a><div
            class="para">
				Essa ferramenta é, na maioria das vezes, usada para assistência técnica; o administrador pode ver os erros com os quais o usuário está enfrentando, e mostrar a eles um curso de ação correto, sem estar fisicamente presente.
			</div><a
            id="id-1.12.5.7.9"
            class="indexterm"></a><a
            id="id-1.12.5.7.10"
            class="indexterm"></a><a
            id="id-1.12.5.7.11"
            class="indexterm"></a><div
            class="para">
				Primeiro, o usuário tem que autorizar o compartilhamento de sua sessão. O ambiente gráfico GNOME na <span
              class="distribution distribution">Jessie</span> inclui essa opção em seu painel de configuração (ao contrário das versões prévias do Debian onde o usuário tinha que instalar e rodar o <code
              class="command">vino</code>). O KDE ainda necessita usar o <code
              class="command">krfb</code> para permitir o compartilhamento de uma sessão existente através do VNC. Para outros ambientes gráficos, o comando <code
              class="command">x11vnc</code> (do pacote Debian de mesmo nome) serve ao mesmo propósito; você pode fazê-lo disponível para o usuário com um ícone explícito.
			</div><a
            id="id-1.12.5.7.13"
            class="indexterm"></a><a
            id="id-1.12.5.7.14"
            class="indexterm"></a><a
            id="id-1.12.5.7.15"
            class="indexterm"></a><a
            id="id-1.12.5.7.16"
            class="indexterm"></a><div
            class="para">
				Quando a sessão gráfica se torna disponível através do VNC, o administrador tem que fazer a conexão com ele com o cliente VNC. O GNOME tem o <code
              class="command">vinagre</code> e o <code
              class="command">remmina</code> para isso, enquanto o KDE inclui o <code
              class="command">krdc</code> (no menu em <span
              class="guimenu"><strong>K</strong></span> → <span
              class="guisubmenu"><strong>Internet</strong></span> → <span
              class="guimenuitem"><strong>Remote Desktop Client</strong></span>). Existem outros clientes VNC que usam a linha de comando, como o <code
              class="command">xvnc4viewer</code> no pacote Debian de mesmo nome. Uma vez conectado, o administrador pode ver o que está acontecendo, trabalhar na máquina remotamente, e orientar o usuário como proceder.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>SEGURANÇA</em></span> VNC sobre SSH</strong></p></div></div></div><a
              id="id-1.12.5.7.18.2"
              class="indexterm"></a><div
              class="para">
				Se você quer fazer a conexão pelo VNC, e você não quer que seus dados sejam enviados em texto puro pela rede, é possível encapsular os dados através de um túnel SSH (veja <a
                class="xref"
                href="sect.remote-login.html#sect.ssh-port-forwarding">Seção 9.2.1.3, “Criando Túneis Criptografados com Encaminhamento de Porta”</a>). Você simplesmente tem que saber que o VNC usa a porta 5900 por padrão para a primeira tela (called “localhost:0”), 5901 para a segunda (called “localhost:1”), etc.
			</div><div
              class="para">
				O comando <code
                class="command">ssh -L localhost:5901:localhost:5900 -N -T <em
                  class="replaceable">máquina</em></code> cria um túnel entre a porta local 5901 na interface localhost e a porta 5900 da <em
                class="replaceable">máquina</em> "host". O primeiro “localhost” restringe o SSH a ouvir apenas nesta interface na máquina local. O segundo “localhost” indica a interface na máquina remota a qual irá receber o tráfego de rede entrando em “localhost:5901”. Assim <code
                class="command">vncviewer localhost:1</code> irá conectar o cliente VNC a tela remota, mesmo que você indique o nome da máquina local.
			</div><div
              class="para">
				Quando uma sessão VNC é fechada, lembre-se de fechar o túnel por também saindo da sessão SSH correspondente.
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>DE VOLTA AO BÁSICO</em></span>Gerenciador de tela</strong></p></div></div></div><a
              id="id-1.12.5.7.19.2"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.3"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.4"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.5"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.6"
              class="indexterm"></a><a
              id="id-1.12.5.7.19.7"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">gdm3</code>, <code
                class="command">kdm</code>, <code
                class="command">lightdm</code>, and <code
                class="command">xdm</code> são Gerenciadores de Tela. Eles tomam controle da interface gráfica brevemente depois a inicialização para prover ao usuário uma tela de login. Uma vez que o usuário tenha feito o login, eles executam os programas necessários para iniciar uma sessão gráfica de trabalho.
			</div></div><div
            class="para">
				VNC também funciona para usuários móveis, ou executivos da empresa, os quais ocasionalmente precisam fazer o login a partir de suas casas para acessar um ambiente de trabalho remoto similar ao que eles usam no trabalho. A configuração desse tipo de serviço é mais complicada: você primeiro instala o pacote <span
              class="pkg pkg">vnc4server</span>, altera a configuração do gerenciador de tela para aceitar requisições do <code
              class="literal">XDMCP Query</code> (no <code
              class="command">gdm3</code>, isso pode ser feito adicionando <code
              class="literal">Enable=true</code> na sessão “xdmcp” do <code
              class="filename">/etc/gdm3/daemon.conf</code>), e finalmente, iniciar o servidor VNC com <code
              class="command">inetd</code> para que a sessão seja iniciada automaticamente quando o usuário tentar fazer o login. Por exemplo, você pode adicionar essa linha ao <code
              class="filename">/etc/inetd.conf</code>:
			</div><pre
            class="programlisting">5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</pre><div
            class="para">
				Redirecionando as conexões de entrada para o gerenciador de tela resolve o problema de autenticação, porque apenas usuários com contas locais irão passar pela tela de login do <code
              class="command">gdm3</code> (ou os equivalentes <code
              class="command">kdm</code>, <code
              class="command">xdm</code>, etc.). Como essa operação permite múltiplos logins simultâneos sem qualquer problema (sendo o servidor suficientemente poderoso), ele pode ser usado até para fornecer um ambiente de trabalho completo para usuários móveis (ou para menos poderosos sistema de ambiente de trabalho, configurado como 'thin clients'). Os usuários simplesmente fazem o login na tela do servidor com <code
              class="command">vncviewer <em
                class="replaceable">server</em>:50</code>, porque a porta usada é a 5950.
			</div><a
            id="id-1.12.5.7.23"
            class="indexterm"></a></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="unix-services.html"><strong>Anterior</strong>Capítulo 9. Serviços Unix</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Acima</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Principal</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.rights-management.html"><strong>Próxima</strong>9.3. Gerenciando Direitos</a></li></ul></body></html>
