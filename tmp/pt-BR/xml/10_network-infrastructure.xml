<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="network-infrastructure" lang="pt-BR">
	<chapterinfo>
		 <keywordset>
			<keyword>Rede</keyword>
			 <keyword>Gateway</keyword>
			 <keyword>TCP/IP</keyword>
			 <keyword>IPv6</keyword>
			 <keyword>DNS</keyword>
			 <keyword>Bind</keyword>
			 <keyword>DHCP</keyword>
			 <keyword>QoS</keyword>

		</keywordset>

	</chapterinfo>
	 <title id="infrastructure.title">Infraestrutura de Rede</title>
	 <highlights> <para>
		O Linux dispõe de toda a tradição do Unix na área de redes, e o Debian fornece um conjunto completo de ferramentas para criar e gerenciar tais redes. Este capítulo apresenta estas ferramentas.
	</para>
	 </highlights> <section id="sect.gateway">
		<title>Gateway</title>
		 <para>
			Um gateway é um sistema de ligação de várias redes. Este termo frequentemente se refere ao "ponto de saída" de uma rede local no caminho obrigatório para endereços IP externos. O gateway está ligado a cada uma das redes que une e atua como um roteador para transmitir pacotes IP entre suas várias interfaces.
		</para>
		 <indexterm>
			<primary>gateway</primary>
		</indexterm>
		 <indexterm>
			<primary>rede</primary>
			<secondary>gateway</secondary>
		</indexterm>
		 <indexterm>
			<primary>roteador</primary>
		</indexterm>
		 <sidebar> <title><emphasis>DE VOLTA AO BÁSICO</emphasis> pacote IP</title>
		 <indexterm>
			<primary>pacote</primary>
			<secondary>IP</secondary>
		</indexterm>
		 <para>
			A maioria das redes atualmente utiliza o protocolo IP (<emphasis>Internet Protocol</emphasis>). Este protocolo segmenta a transmissão dos dados em pacotes de tamanho limitado. Cada pacote contém, em adição aos seus dados úteis, uma quantidade de detalhes necessários para seu próprio roteamento.
		</para>
		 </sidebar> <sidebar id="sidebar.tcp-udp"> <title><emphasis>DE VOLTA AO BÁSICO</emphasis> TCP/UDP</title>
		 <indexterm>
			<primary>porta</primary>
			<secondary>TCP</secondary>
		</indexterm>
		 <indexterm>
			<primary>porta</primary>
			<secondary>UDP</secondary>
		</indexterm>
		 <indexterm>
			<primary>TCP, porta</primary>
		</indexterm>
		 <indexterm>
			<primary>UDP, porta</primary>
		</indexterm>
		 <para>
			Muitos programas não manipulam os pacotes individuais por si sós, mesmo que os dados que eles transmitam trafegem sobre IP; Eles geralmente usam TCP (<emphasis>Transmission Control Protocol</emphasis>). TCP é uma camada acima do IP que permite o estabelecimento de conexões dedicadas a fluxos de dados entre dois pontos. Os programas então vêem apenas um ponto de entrada no qual os dados podem ser enviados com a garantia que os mesmos dados vão sair sem perdas (e na mesma sequência) no ponto de saída na outra extremidade da conexão. Embora muitos tipos de erros possam acontecer em camadas mais baixas, eles são compensados pelo TCP: pacotes perdidos são retransmitidos, e pacotes chegando fora de ordem (por exemplo, se pegaram caminhos diferentes) são reordenados corretamente.
		</para>
		 <para>
			Outro protocolo que se baseia no IP é o UDP (<emphasis>User Datagram Protocol</emphasis>). Ao contrário do TCP, ele é orientado a pacote. Seus objetivos são diferentes: O objetivo do UDP é apenas transmitir um pacote de uma aplicação para outra. O protocolo não tenta compensar possíveis perdas de pacotes no caminho, nem garante que pacotes são recebidos na ordem em que foram enviados. A principal vantagem deste protocolo é que a latência fica muito melhor, uma vez que a perda de um pacote único não atrasa o recebimento de todos os pacotes seguintes até que o que se perdeu seja retransmitido.
		</para>
		 <para>
			TCP e UDP ambos envolvem portas, que são "números de ramal" para estabelecer a comunicação com um determinado aplicativo em uma máquina. Este conceito permite manter várias comunicações diferentes em paralelo com o mesmo correspondente, já que estas comunicações podem ser diferenciadas pelo número da porta.
		</para>
		 <para>
			Alguns destes números de portas — pedronizados pela IANA (<emphasis>Internet Assigned Numbers Authority</emphasis>) — são "famosos" por estarem associados a certos serviços de rede. Por exemplo, a porta TCP 25 é geralmente usada pelo servidor de email. <ulink type="block" url="http://www.iana.org/assignments/port-numbers" />
		</para>
		 </sidebar> <para>
			Quando uma rede local usa um intervalo de endereços privado (não roteável na Internet), o gateway precisa implementar <emphasis>mascaramento de endereço</emphasis> para que as máquinas na rede possam se comunicar com o mundo exterior. A operação de mascaramento é um tipo de operação de proxy no nível de rede: cada conexão saindo de uma máquina interna é substituída com uma conexão do próprio gateway (já que o gateway tem um endereço externo e roteável), os dados passando pela conexão mascarada são enviados para a nova, e os dados voltando como resposta são enviados através da conexão mascarada para a máquina interna. O gateway usa um intervalo de portas TCP dedicadas para este objetivo, normalmente com números bastante altos (acima de 60000). Cada conexão vindo de uma máquina interna aparece então para o mundo exterior como uma conexão vindo de uma destas portas reservadas.
		</para>
		 <indexterm>
			<primary>masquerading</primary>
		</indexterm>
		 <sidebar> <title><emphasis>CULTURA</emphasis> Série de Endereços Privados</title>
		 <indexterm>
			<primary>endereço IP</primary>
			<secondary>privado</secondary>
		</indexterm>
		 <indexterm>
			<primary>endereço IP privado</primary>
		</indexterm>
		 <para>
			A RFC 1918 define três intervalos de endereços IPv4 que não devem ser roteados na Internet mas apenas usados em redes locais. O primeiro, <literal>10.0.0.0/8</literal> (veja na barra lateral <xref linkend="sidebar.networking-basics" />), é um intervalo de classe A (com 2<superscript>24</superscript> endereços IP). O segundo, <literal>172.16.0.0/12</literal>, trás 16 intervalos de classe B (<literal>172.16.0.0/16</literal> a <literal>172.31.0.0/16</literal>), cada um contendo 2<superscript>16</superscript> endereços IP. Finalmente, <literal>192.168.0.0/16</literal> é um intervalo de classe B (agrupando 256 intervalos de classe C, <literal>192.168.0.0/24</literal> a <literal>192.168.255.0/24</literal>, com 256 endereços IP cada). <ulink type="block" url="http://www.faqs.org/rfcs/rfc1918.html" />
		</para>
		 </sidebar> <para>
			O gateway também pode realizar dois tipos de NAT (<emphasis>network address translation</emphasis> ou tradução de endereço de rede). O primeiro tipo, DNAT (<emphasis>Destination NAT</emphasis> ou NAT no destino) é uma técnica para alterar o endereço IP de destino (e/ou a porta TCP ou UDP) para uma conexão (geralmente) entrando. O mecanismo de rastreio de conexão também altera os seguintes pacotes na mesma conexão para garantir a continuidade na comunicação. O segundo tipo de NAT é o SNAT (<emphasis>Source NAT</emphasis> ou NAT na origem), do qual <emphasis>masquerading</emphasis> (ou mascaramento) é um caso particular; SNAT altera o endereço IP de origem (e/ou a porta TCP ou UDP) de uma conexão (geramente) saindo. Assim como no DNAT, todos os pacotes na conexão são apropriadamente manipulados pelo mecanismo de rastreio de conexão. Observe que o NAT só é relevante para o IPv4 e seu espaço de endereços limitado; no IPv6, a ampla disponibilidade de endereços reduz grandemente a utilidade de NAT permitindo que todo endereço "interno" possa ser diretamente roteável na Internet (isto não implica que as máquinas internas serão acessíveis, uma vez que firewalls intermediários possam filtrar o tráfego).
		</para>
		 <indexterm>
			<primary>NAT</primary>
		</indexterm>
		 <indexterm>
			<primary>Rede</primary>
			<secondary>Tradução de Endereços</secondary>
		</indexterm>
		 <indexterm>
			<primary>SNAT</primary>
		</indexterm>
		 <indexterm>
			<primary>DNAT</primary>
		</indexterm>
		 <indexterm>
			<primary>NAT de Destino</primary>
		</indexterm>
		 <indexterm>
			<primary>NAT de Origem</primary>
		</indexterm>
		 <sidebar> <title><emphasis>DE VOLTA AO BÁSICO</emphasis> Encaminhamento de porta</title>
		 <indexterm>
			<primary>port forwarding</primary>
		</indexterm>
		 <para>
			Uma aplicação concreta do DNAT é o <emphasis>port forwarding</emphasis> (encaminhamento de portas). Conexões chegando numa porta de uma máquina são direcionadas para uma porta de outra máquina. Outras soluções podem existir para se chegar a um efeito similar, entretanto. Especialmente no nível de aplicação com <command>ssh</command> (veja em <xref linkend="sect.ssh-port-forwarding" />) ou <command>redir</command>.
		</para>
		 </sidebar> <para>
			Chega de teoria, vamos para a prática. Fazer do Debian um gateway é simplesmente habilitar a opção apropriada no núcleo Linux, através do sistema de arquivos virtual <filename>/proc/</filename>:
		</para>
		 
<screen>
<computeroutput># </computeroutput><userinput>echo 1 &gt; /proc/sys/net/ipv4/conf/default/forwarding</userinput></screen>
		 <para>
			Esta opção também pode ser automaticamente habilitada no boot se em <filename>/etc/sysctl.conf</filename> a opção <literal>net.ipv4.conf.default.forwarding</literal> estiver com valor <literal>1</literal>.
		</para>
		 <example id="example.sysctl.conf">
			<title>O arquivo <filename>/etc/sysctl.conf</filename></title>
			 
<programlisting>
net.ipv4.conf.default.forwarding = 1
net.ipv4.conf.default.rp_filter = 1
net.ipv4.tcp_syncookies = 1</programlisting>

		</example>
		 <para>
			O mesmo efeito pode ser obtido para o IPv6 simplesmente substituindo o <literal>ipv4</literal> por <literal>ipv6</literal> no comando manual e usando a linha <literal>net.ipv6.conf.all.forwarding</literal> em <filename>/etc/sysctl.conf</filename>.
		</para>
		 <para>
			Habilitando mascaramento IPv4 é uma operação um pouco mais complexa que envolve configurar o firewall <emphasis>netfilter</emphasis>.
		</para>
		 <para>
			Similarmente, o uso do NAT (para IPv4) requer a configuração do <emphasis>netfilter</emphasis>. Uma vez que o objetivo primário deste componente é filtragem de pacotes, os detalhes são listados em <xref linkend="security" xrefstyle="select: label quotedtitle nopage" /> (veja em <xref linkend="sect.firewall-packet-filtering" />).
		</para>

	</section>
	 <section id="sect.virtual-private-network">
		<title>Rede Privada Virtual</title>
		 <para>
			Uma <emphasis>Rede Privada Virtual</emphasis> (ou VPN, de Virtual Private Network) é uma forma de conectar duas redes locais diferentes através de um túnel pela internet; o túnel é normalmente criptografado para confidencialidade. VPNs são em geral usadas para integrar uma máquina remota numa rede local de uma empresa.
		</para>
		 <indexterm>
			<primary>rede</primary>
			<secondary>privada virtual</secondary>
		</indexterm>
		 <indexterm>
			<primary>VPN</primary>
		</indexterm>
		 <indexterm>
			<primary>rede privada virtual</primary>
		</indexterm>
		 <para>
			Várias ferramentas fornecem isto. O OpenVPN é uma solução eficiente, fácil de publicar e manter, baseado em SSL/TLS. Outra possibilidade é usar o IPsec para criptografar o tráfego IP entre duas máquinas; esta criptografia é transparente, o que significa que aplicações rodando nestas máquinas não precisam ser modificadas para serem compatíveis com VPN. SSH também pode ser usado para fornecer uma VPN, adicionalmente às suas funcionalidades mais convencionais. Finalmente, uma VPN pode ser estabelecida usando o protocolo PPTP da Microsoft. Outras soluções existem, mas estão além do escopo deste livro.
		</para>
		 <section id="sect.openvpn">
			<title>OpenVPN</title>
			 <indexterm>
				<primary>OpenVPN</primary>
			</indexterm>
			 <para>
				O OpenVPN é um pedaço de software dedicado a criar redes virtuais privadas. Sua configuração envolve a criação de interfaces de rede virtual em um servidor VPN e no(s) cliente(s); ambas interfaces <literal>tun</literal> (para túneis IP-level) e <literal>tap</literal> (para túneis Ethernet-level) são suportadas. Na pratica, a interface <literal>tun</literal> irá geralmente ser a mais usada, excerto quando os clientes VPN forem feitos para serem integrados na rede local do servidor por meio de uma ponte (brigde) Ethernet.
			</para>
			 <para>
				O OpenVPN depende do OpenSSL para criptografia SSL/TLS e funcionalidades associadas (confidencialidade, autenticação, integridade, não-repudio). Ele pode ser configurado tanto com uma chave privada compartilhada, como usando um certificado X.509 baseado em uma infraestrutura de chave pública. Essa última configuração é fortemente preferida já que permite grande flexibilidade quando lida com um crescente número de usuários "roaming" acessando a VPN.
			</para>
			 <sidebar> <title><emphasis>CULTURA</emphasis> SSL e TLS</title>
			 <indexterm>
				<primary>SSL</primary>
			</indexterm>
			 <indexterm>
				<primary>TLS</primary>
			</indexterm>
			 <para>
				O protocolo SSL (<emphasis>Secure Socket Layer</emphasis>) foi inventado pela Netscape para dar segurança nas conexões com servidores web. Ele foi, depois, padronizado pela IETF sob o acrônimo TLS (<emphasis>Transport Layer Security</emphasis>). Desde então o TLS continuou a evoluir e hoje em dia o SSL está depreciado devido a múltiplas falhas de projeto que tem sido descobertas.
			</para>
			 </sidebar> <section id="sect.easy-rsa">
				<title>Infraestrutura de Chaves Públicas: <emphasis>easy-rsa</emphasis></title>
				 <indexterm>
					<primary>PKI (Public Key Infrastructure - Infraestrutura de Chave Pública)</primary>
				</indexterm>
				 <indexterm>
					<primary>Infraestrutura de Chave Pública</primary>
				</indexterm>
				 <indexterm>
					<primary>X.509, certificado</primary>
				</indexterm>
				 <indexterm>
					<primary>certificado</primary>
					<secondary>X.509</secondary>
				</indexterm>
				 <indexterm>
					<primary><emphasis>easy-rsa</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary>RSA (algoritmo)</primary>
				</indexterm>
				 <indexterm>
					<primary>par de chaves</primary>
				</indexterm>
				 <para>
					O algorítimo RSA é amplamente usado em criptografia de chave pública. Trata-se de um “par de chaves”, composto de uma chave privada e uma chave pública. As duas chaves são intimamente ligadas uma a outra, e suas propriedades matemáticas são tais que uma mensagem criptografada com a chave pública só pode ser descriptografada por alguém que conhece a chave privada, o que garante confidencialidade. Na direção oposta, uma mensagem criptografada com a chave privada pode ser descriptografada por qualquer um que saiba a chave pública, o que permite autenticar a origem da mensagem já que apenas alguém com acesso a chave privada poderia gerá-la. Quando associada a uma função digital hash (MD5, SHA1, ou uma variante mais recente), isso leva a um mecanismo de assinatura que pode ser aplicado a qualquer mensagem.
				</para>
				 <para>
					Contudo, qualquer um pode criar um par de chaves, armazenar qualquer identidade nele, e fingir ser a identidade de sua escolha. Uma solução envolve o conceito de uma <emphasis>Certification Authority</emphasis> (CA), formalizado pelo padrão X.509. Esse termo cobre uma entidade que possui um par de chaves confiável conhecido como um <emphasis>root certificate</emphasis>. Esse certificado só é usado para assinar outros certificados (par de chaves), após os passos apropriados terem sido tomados para checar a identidade armazenada no par de chaves. Aplicações usando o X.509 podem então checar os certificados apresentados a elas, se elas souberem sobre os root certificates confiáveis.
				</para>
				 <para>
					O OpenVPN segue essa regra. Como CAs públicos apenas emitem certificados em troca de uma (pesada) taxa, também é possível criar um certificado de autoridade privado dentro da companhia. O pacote <emphasis>easy-rsa</emphasis> provê ferramentas que servem como uma infraestrutura de certificação X.509, implementada como um conjunto de scripts usando o comando <command>openssl</command>.
				</para>
				 <sidebar> <title><emphasis>NOTE</emphasis> <emphasis>easy-rsa</emphasis> antes da <emphasis role="distribution">Jessie</emphasis></title>
				 <para>
					Em versões do Debian até o <emphasis role="distribution">Wheezy</emphasis>, o <emphasis>easy-rsa</emphasis> era distribuido com parte do pacote <emphasis role="pkg">openvpn</emphasis>, e seus scripts eram para ser encontrados em <filename>/usr/share/doc/openvpn/examples/easy-rsa/2.0/</filename>. A criação de um CA envolvia a cópia desse diretório, ao invéz de usar o comando <command>make-cadir</command> como documentado aqui.
				</para>
				 </sidebar> <para>
					os adminitradores da Falcot Corp usam essa ferramenta para criar os certificados necessários, tanto para servidor quanto para clientes. Isso permite que a configuração de todos os clientes sejam similar já que eles apenas terão de ser configurados para confiar em certificados vindos da CA local daFalcot. Esse CA é o primeiro certificado a ser criado; para esse fim, os administradoresconfiguram um diretório com os arquivos necessários para o CA em um local apropriado, preferencialmente em uma máquina não conectada a rede, de maneira a mitigar o risco da chave privada CA ser roubada.
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>make-cadir pki-falcot
</userinput><computeroutput>$ </computeroutput><userinput>cd pki-falcot</userinput></screen>
				 <para>
					Eles então armazenam os parâmetros requeridos dentro do arquivo <filename>vars</filename>, especialmente aqueles nomeados com o prefixo <literal>KEY_</literal>; essas variáveis são então integradas ao ambiente:
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>vim vars
</userinput><computeroutput>$ </computeroutput><userinput>grep KEY_ vars
</userinput><computeroutput>export KEY_CONFIG=`$EASY_RSA/whichopensslcnf $EASY_RSA`
export KEY_DIR="$EASY_RSA/keys"
echo NOTE: If you run ./clean-all, I will be doing a rm -rf on $KEY_DIR
export KEY_SIZE=2048
export KEY_EXPIRE=3650
export KEY_COUNTRY="FR"
export KEY_PROVINCE="Loire"
export KEY_CITY="Saint-Étienne"
export KEY_ORG="Falcot Corp"
export KEY_EMAIL="admin@falcot.com"
export KEY_OU="Certificate authority"
export KEY_NAME="Certificate authority for Falcot Corp"
# If you'd like to sign all keys with the same Common Name, uncomment the KEY_CN export below
# export KEY_CN="CommonName"
$ </computeroutput><userinput>. ./vars
</userinput><computeroutput>NOTE: If you run ./clean-all, I will be doing a rm -rf on /home/roland/pki-falcot/keys
$ </computeroutput><userinput>./clean-all
</userinput></screen>
				 <para>
					O próximo passo é a criação do próprio par de chaves CA (as duas partes do par de chaves será armazenada sob <filename>keys/ca.crt</filename> e <filename>keys/ca.key</filename> durante esse passo):
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>./build-ca</userinput>
<computeroutput>Generating a 2048 bit RSA private key
...................................................................+++
...+++
writing new private key to 'ca.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [Falcot Corp CA]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:
</computeroutput></screen>
				 <para>
					O certificado para o servidor VPN pode, agora, ser criado, assim como os parâmetros Diffie-Hellman necessários para o lado do servidor em uma conexão SSL/TLS. O servidor VPN é identificado pelo seu nome DNS <literal>vpn.falcot.com</literal>; esse nome é reutilizado nos arquivos de chave gerados (<filename>keys/vpn.falcot.com.crt</filename> para certificado público, <filename>keys/vpn.falcot.com.key</filename> para chave privada):
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>./build-key-server vpn.falcot.com
</userinput><computeroutput>Generating a 2048 bit RSA private key
.....................................................................................................................+++
...........+++
writing new private key to 'vpn.falcot.com.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [vpn.falcot.com]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
Using configuration from /home/roland/pki-falcot/openssl-1.0.0.cnf
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
countryName           :PRINTABLE:'FR'
stateOrProvinceName   :PRINTABLE:'Loire'
localityName          :T61STRING:'Saint-\0xFFFFFFC3\0xFFFFFF89tienne'
organizationName      :PRINTABLE:'Falcot Corp'
organizationalUnitName:PRINTABLE:'Certificate authority'
commonName            :PRINTABLE:'vpn.falcot.com'
name                  :PRINTABLE:'Certificate authority for Falcot Corp'
emailAddress          :IA5STRING:'admin@falcot.com'
Certificate is to be certified until Mar  6 14:54:56 2025 GMT (3650 days)
Sign the certificate? [y/n]:</computeroutput><userinput>y
</userinput><computeroutput>

1 out of 1 certificate requests certified, commit? [y/n]</computeroutput><userinput>y
</userinput><computeroutput>Write out database with 1 new entries
Data Base Updated
$ </computeroutput><userinput>./build-dh
</userinput><computeroutput>Generating DH parameters, 2048 bit long safe prime, generator 2
This is going to take a long time
[…]
</computeroutput></screen>
				 <para>
					O próximo passo cria certificados para os clientes VPN; um certificado é necessário para cada computar ou pessoa ser autorizada a usar a VPN:
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>./build-key JoeSmith
</userinput><computeroutput>Generating a 2048 bit RSA private key
................................+++
..............................................+++
writing new private key to 'JoeSmith.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:</computeroutput><userinput>Development unit
</userinput><computeroutput>Common Name (eg, your name or your server's hostname) [JoeSmith]:</computeroutput><userinput>Joe Smith
</userinput><computeroutput>[…]</computeroutput></screen>
				 <para>
					Agora que todos os certificados foram criados, eles precisam ser copiados para um local apropriado: a chave pública do root certificate (<filename>keys/ca.crt</filename>) será armazenada em todas as máquinas (tanto servidor quanto clientes) como <filename>/etc/ssl/certs/Falcot_CA.crt</filename>. O certificado do servidor é instalado apenas no servidor (<filename>keys/vpn.falcot.com.crt</filename> vai para <filename>/etc/ssl/vpn.falcot.com.crt</filename>, e <filename>keys/vpn.falcot.com.key</filename> vai para <filename>/etc/ssl/private/vpn.falcot.com.key</filename> com restritivas permissões para que apenas o administrador possa lê-la), com os parâmetros Diffie-Hellman correspondentes (<filename>keys/dh2048.pem</filename>) instalados em <filename>/etc/openvpn/dh2048.pem</filename>. Certificados do clientes são instalados no cliente VPN correspondente de maneira similar.
				</para>

			</section>
			 <section>
				<title>Configurando o Servidor OpenVPN</title>
				 <para>
					Por padrão, o script de inicialização do OpenVPN tenta iniciar todas as redes virtuais privadas definidas em <filename>/etc/openvpn/*.conf</filename>. A configuração de um servidor VPN é portanto uma questão de armazenar o arquivo de configuração correspondente neste diretório. Um bom ponto de partida é o <filename>/usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz</filename>, que orienta em como ter um servidor padrão. Claro que alguns parâmetros precisam ser adaptados: <literal>ca</literal>, <literal>cert</literal>, <literal>key</literal> e <literal>dh</literal> precisam descrever as localizações selecionadas (respectivamente, <literal>/etc/ssl/certs/Falcot_CA.crt</literal>, <literal>/etc/ssl/vpn.falcot.com.crt</literal>, <literal>/etc/ssl/private/vpn.falcot.com.key</literal> e <literal>/etc/openvpn/dh2048.pem</literal>). A diretiva <literal>server 10.8.0.0 255.255.255.0</literal> define a sub-rede a ser usada pela VPN; o servidor usa o primeiro endereço IP nesse intervalo (<literal>10.8.0.1</literal>) e o resto dos endereços são alocados para os clientes.
				</para>
				 <para>
					Com essa configuração, ao iniciar o OpenVPN, é criada uma interface de rede virtual, usualmente sob o nome de <literal>tun0</literal>. Contudo, firewalls são geralmente configurados ao mesmo tempo que interfaces de rede reais, o que acontece antes do OpenVPN ser iniciado. A boa prática então recomenda a criação de uma interface de rede virtual persistênte, e configurara o OpenVPN a usar essa pré-existente interface. Isso inclusive permite a escolha do nome dessa interface. Para esse fim, <command>openvpn --mktun --dev vpn --dev-type tun</command> cria uma interface de rede virtual de nome <literal>vpn</literal> do tipo <literal>tun</literal>; esse comando pode ser facilmente integrado ao script de configuração do firewall, ou na diretiva <literal>up</literal> do arquivo <filename>/etc/network/interfaces</filename>. O arquivo de configuração do OpenVPN deve também ser atualizado em conformidade com as diretivas <literal>dev vpn</literal> e <literal>dev-type tun</literal>.
				</para>
				 <para>
					Salvo ações posteriores, clientes VPN só podem acessar o próprio servidor VPN pelo caminho do endereço <literal>10.8.0.1</literal>. Permitir que os clientes acessem a rede local (192.168.0.0/24) requer a adição da diretiva <literal>push route 192.168.0.0 255.255.255.0</literal> na configuração do OpenVPN para que os clientes VPN automaticamente recebam o roteamento dizendo a eles que essa rede é alcançável através da VPN. Além do mais, máquinas na rede local também precisam ser informadas que a rota para a VPN passa pelo servidor VPN (isso funciona de maneira automática quando o servidor VPN é instalado no gateway). Alternativamente, o servidor VPN pode ser configurado para desempenhar um mascaramento IP, e assim as conexões vidas de clientes VPN aparecem com se elas viessem do servidor VPN (see <xref linkend="sect.gateway" />).
				</para>

			</section>
			 <section>
				<title>Configurando o Cliente OpenVPN</title>
				 <para>
					Configurar um cliente OpenVPN também requer a criação de um arquivo de configuração em <filename>/etc/openvpn/</filename>. Uma configuração padrão pode ser obtida usando <filename>/usr/share/doc/openvpn/examples/sample-config-files/client.conf</filename> como ponto de partida. A diretiva <literal>remote vpn.falcot.com 1194</literal> descreve o endereço e porta do servidor OpenVPN; <literal>ca</literal>, <literal>cert</literal> and <literal>key</literal> também precisam ser adaptadas para descrever a localização dos arquivos com as chaves.
				</para>
				 <para>
					Se a VPN não deve ser iniciadas automaticamente na inicialização, configure a diretiva <literal>AUTOSTART</literal> para <literal>none</literal> no arquivo <filename>/etc/default/openvpn</filename>. Iniciar ou parar uma determinada conexão VPN é sempre possível com os comandos <command>service openvpn@<replaceable>name</replaceable> start</command> and <command>service openvpn@<replaceable>name</replaceable> stop</command> (aonde a conexão <replaceable>nome</replaceable> casa com uma definida em <filename>/etc/openvpn/<replaceable>nome</replaceable>.conf</filename>).
				</para>
				 <para>
					O pacote <emphasis role="pkg">network-manager-openvpn-gnome</emphasis> contém uma extensão para o Network Manager (see <xref linkend="sect.roaming-network-config" />) que permite o gerenciamento de redes virtuais privadas OpenVPN. Isso permite que todo usuário configure e controle as conexões OpenVPN graficamente através do ícone de gerenciamento de redes. <indexterm><primary><emphasis role="pkg">network-manager-openvpn-gnome</emphasis></primary></indexterm>
				</para>

			</section>

		</section>
		 <section id="sect.ssh-vpn">
			<title>Rede Privada Virtual com SSH</title>
			 <indexterm>
				<primary>SSH</primary>
			</indexterm>
			 <indexterm>
				<primary>PPP</primary>
			</indexterm>
			 <para>
				Existem, na verdade, duas maneiras de criar uma rede virtual privada com SSH. A mais antiga envolve estabelecer uma camada PPP sobre uma ligação SSH. Esse método é descrito em um documento HOWTO: <ulink type="block" url="http://www.tldp.org/HOWTO/ppp-ssh/" />
			</para>
			 <para>
				O segundo método é mais recente, e foi introduzido no OpenSSH 4.3; agora é possível para o OpenSSH criar interfaces de rede virtual (<literal>tun*</literal>) nos dois lados de uma conexão SSH, e essas interfaces virtuais podem ser configuradas exatamente como se elas fossem interfaces físicas. O sistema de túnel ("tunneling") deve ser primeiro ativado configurando <literal>PermitTunnel</literal> como “yes” no arquivo de configuração do servidor SSH (<filename>/etc/ssh/sshd_config</filename>). Ao estabelecer uma conexão SSH, a criação de um túnel deve ser explicitamente requisitada com a opção <literal>-w any:any</literal> (<literal>any</literal> pode ser substituída pelo desejado número de dispositivo <literal>tun</literal>). Isso requer que o usuário tenha privilégios de administrador nos dois lados, assim como ser capaz de criar o dispositivo de rede (em outras palavras, a conexão deve ser estabelecida como root).
			</para>
			 <para>
				Ambos os métodos para criação de rede virtual privada pelo SSH são bem simples. Contudo, a VPN que eles implementam não é a mais eficiente disponível, em particular, ela não lida muito bem com elevados níveis de tráfego.
			</para>
			 <para>
				A explicação é que quando uma pilha TCP/IP é encapsulada dentro de uma conexão TCP/IP (para SSH), o protocolo TCP é usado duas vezes, uma vez para a conexão SSH e outra dentro do túnel. Isso leva a problemas, especialmente devido ao modo o TCP se adaptar as condições da rede, alterando os atrasos de "timeout". O seguinte sítio descreve o problema mais detalhadamente: <ulink type="block" url="http://sites.inka.de/sites/bigred/devel/tcp-tcp.html" /> VPNs sobre SSH deve portanto ser restrita a "one-off tunnels" sem restrições de desempenho.
			</para>

		</section>
		 <section id="sect.ipsec">
			<title>IPsec</title>
			 <indexterm>
				<primary>IPsec</primary>
			</indexterm>
			 <indexterm>
				<primary><command>strongswan</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>racoon</command></primary>
			</indexterm>
			 <para>
				O IPsec, apesar de ser o padrão em VPNs IP, é um pouco mais envolvido em sua implementação. O próprio mecanismo IPsec é integrado no núcleo Linux; as partes do espaço usuário necessárias, as ferramentas de controle e configuração, são fornecidas pelo pacote <emphasis role="pkg">ipsec-tools</emphasis>. Em termos concretos, o <filename>/etc/ipsec-tools.conf</filename> de cada máquina contém os parâmetros para os <emphasis>túneis IPsec</emphasis> (ou <emphasis>Security Associations</emphasis>, na terminologia IPsec) que o hospedeiro se preocupa; o script <command>/etc/init.d/setkey</command> fornece uma maneira para iniciar e parar um túnel (cada túnel é uma ligação segura para outra máquina conectada a rede virtual privada). Esse arquivo pode ser construído manualmente a partir da documentação fornecida pela página de manual <citerefentry><refentrytitle>setkey</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry>. Contudo, escrever explicitamente os parâmetros para todas as máquinas em um conjunto não-trivial de máquinas rapidamente se torna uma tarefa árdua, já que o número de túneis cresce rápido. Instalar um daemon IKE (para <emphasis>IPsec Key Exchange</emphasis>) como o <emphasis role="pkg">racoon</emphasis> ou <emphasis role="pkg">strongswan</emphasis> torna o processo muito mais simples, por reunir a administração em um ponto central, e mais seguro por rotacionar as chaves periodicamente.
			</para>
			 <indexterm>
				<primary>IKE</primary>
			</indexterm>
			 <indexterm>
				<primary>IPsec</primary>
				<secondary>Troca de chaves IPsec</secondary>
			</indexterm>
			 <indexterm>
				<primary>par de chaves</primary>
			</indexterm>
			 <indexterm>
				<primary><command>setkey</command></primary>
			</indexterm>
			 <para>
				Apesar do seu status como referência, a complexidade de criação de IPsec restringe seu uso na prática. As soluções baseadas em OpenVPN irão geralmente ser preferidas quando os necessários túneis não forem muitos ou não forem muito dinâmicos.
			</para>
			 <sidebar> <title><emphasis>ATENÇÃO</emphasis> IPsec e NAT</title>
			 <para>
				IPsec e Firewalls que fazem NAT não funcionam bem juntos: como o IPsec assina os pacotes, qualquer alteração nesses pacotes que o firewall possa a vir fazer irá anular essa assinatura, e assim, os pacotes serão rejeitados em seu destino. Várias implementações incluem agora a técnica <emphasis>NAT-T</emphasis> (para <emphasis>NAT Traversal</emphasis>), o que basicamente encapsula o pacote IPsec dentro de um pacote UDP padrão.
			</para>
			 <indexterm>
				<primary>NAT-T</primary>
			</indexterm>
			 <indexterm>
				<primary>NAT Traversal</primary>
			</indexterm>
			 </sidebar> <sidebar> <title><emphasis>SEGURANÇA</emphasis> IPsec e firewalls</title>
			 <para>
				O modo padrão de operação do IPsec envolve troca de dados pela porta UDP 500 para troca de chave (também pela porta UDP 4500 para o caso que o NAT-T esteja em uso). Além disso, os pacotes IPsec usam dois protocolos IP dedicados que o firewall tem que deixar passar; a recepção desses pacotes é baseada nos seus números de protocolo, 50 (ESP) e 51 (AH).
			</para>
			 <indexterm>
				<primary>ESP, protocolo</primary>
			</indexterm>
			 <indexterm>
				<primary>AH, protocolo</primary>
			</indexterm>
			 <indexterm>
				<primary>protocolo</primary>
				<secondary>AH</secondary>
			</indexterm>
			 <indexterm>
				<primary>protocolo</primary>
				<secondary>ESP</secondary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.pptp">
			<title>PPTP</title>
			 <para>
				PPTP (<emphasis>Point-to-Point Tunneling Protocol</emphasis>) usa dois canais de comunicação, um para controlar dados e um para dados de carga útil (payload); o último usa o protocolo GRE (<emphasis>Generic Routing Encapsulation</emphasis>). Um link PPP padrão é então configurado sobre o canal de troca de dados.
			</para>
			 <indexterm>
				<primary>PPTP</primary>
			</indexterm>
			 <indexterm>
				<primary>Point-to-Point Tunneling Protocol</primary>
			</indexterm>
			 <indexterm>
				<primary>GRE, protocolo</primary>
			</indexterm>
			 <indexterm>
				<primary>protocolo</primary>
				<secondary>GRE</secondary>
			</indexterm>
			 <section id="sect.pptp-config-client">
				<title>Configurando o Cliente</title>
				 <para>
					O pacote <emphasis role="pkg">pptp-linux</emphasis> contém um cliente PPTP para Linux fácil de configurar. As instruções a seguir foram inspiradas na documentação oficial: <ulink type="block" url="http://pptpclient.sourceforge.net/howto-debian.phtml" />
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">pptp-linux</emphasis></primary>
				</indexterm>
				 <para>
					Os administradores da Falcot criaram vários arquivos: <filename>/etc/ppp/options.pptp</filename>, <filename>/etc/ppp/peers/falcot</filename>, <filename>/etc/ppp/ip-up.d/falcot</filename>, e <filename>/etc/ppp/ip-down.d/falcot</filename>.
				</para>
				 <example id="example.ppp-options.pptp">
					<title>O arquivo <filename>/etc/ppp/options.pptp</filename></title>
					 
<programlisting>
# PPP options used for a PPTP connection
lock
noauth
nobsdcomp
nodeflate</programlisting>

				</example>
				 <example id="example.ppp-peers-falcot">
					<title>O arquivo <filename>/etc/ppp/peers/falcot</filename></title>
					 
<programlisting>
# vpn.falcot.com is the PPTP server
pty "pptp vpn.falcot.com --nolaunchpppd"
# the connection will identify as the "vpn" user
user vpn
remotename pptp
# encryption is needed
require-mppe-128
file /etc/ppp/options.pptp
ipparam falcot</programlisting>

				</example>
				 <example id="example.ppp-ip-up.d-falcot">
					<title>O arquivo <filename>/etc/ppp/ip-up.d/falcot</filename></title>
					 
<programlisting>
# Create the route to the Falcot network
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 is the (remote) Falcot network
  route add -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi</programlisting>

				</example>
				 <example id="example.ppp-ip-down.d-falcot">
					<title>O arquivo <filename>/etc/ppp/ip-down.d/falcot</filename></title>
					 
<programlisting>
# Delete the route to the Falcot network
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 is the (remote) Falcot network
  route del -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi</programlisting>

				</example>
				 <sidebar> <title><emphasis>SEGURANÇA</emphasis> MPPE</title>
				 <para>
					A segurança do PPTP envolve o uso do recurso MPPE (<emphasis>Microsoft Point-to-Point Encryption</emphasis>), o qual está disponível nos núcleos oficiais Debian como módulo.
				</para>
				 <indexterm>
					<primary>MPPE</primary>
				</indexterm>
				 <indexterm>
					<primary>Microsoft</primary>
					<secondary>Point-to-Point Encryption</secondary>
				</indexterm>
				 </sidebar>
			</section>
			 <section id="sect.pptp-config-serveur">
				<title>Configurando o Servidor</title>
				 <sidebar> <title><emphasis>ATENÇÃO</emphasis> PPTP e firewalls</title>
				 <para>
					Firewalls intermediários precisam ser configurados para deixar passar pacotes IP que usam protocolo 47 (GRE). Além do mais, a porta do servidor PPTP 1723 precisa estar aberta para que a comunicação pelo canal possa acontecer.
				</para>
				 </sidebar> <para>
					<command>pptpd</command> é o servidor PPTP para Linux. Seu principal arquivo de configuração, <filename>/etc/pptpd.conf</filename>, requer muito poucas alterações: <emphasis>localip</emphasis> (endereço IP local) e <emphasis>remoteip</emphasis> (endereço IP remoto). No exemplo abaixo, o servidor PPTP sempre usa o endereço <literal>192.168.0.199</literal>, e os clientes PPTP recebem endereços IP entre <literal>192.168.0.200</literal> e <literal>192.168.0.250</literal>.
				</para>
				 <example id="example.pptpd.conf">
					<title>O arquivo <filename>/etc/pptpd.conf</filename></title>
					 
<programlisting>
# TAG: speed
#
#       Specifies the speed for the PPP daemon to talk at.
#
speed 115200

# TAG: option
#
#       Specifies the location of the PPP options file.
#       By default PPP looks in '/etc/ppp/options'
#
option /etc/ppp/pptpd-options

# TAG: debug
#
#       Turns on (more) debugging to syslog
#
# debug

# TAG: localip
# TAG: remoteip
#
#       Specifies the local and remote IP address ranges.
#
#       You can specify single IP addresses separated by commas or you can
#       specify ranges, or both. For example:
#
#               192.168.0.234,192.168.0.245-249,192.168.0.254
#
#       IMPORTANT RESTRICTIONS:
#
#       1. No spaces are permitted between commas or within addresses.
#
#       2. If you give more IP addresses than MAX_CONNECTIONS, it will
#          start at the beginning of the list and go until it gets
#          MAX_CONNECTIONS IPs. Others will be ignored.
#
#       3. No shortcuts in ranges! ie. 234-8 does not mean 234 to 238,
#          you must type 234-238 if you mean this.
#
#       4. If you give a single localIP, that's ok - all local IPs will
#          be set to the given one. You MUST still give at least one remote
#          IP for each simultaneous client.
#
#localip 192.168.0.234-238,192.168.0.245
#remoteip 192.168.1.234-238,192.168.1.245
#localip 10.0.1.1
#remoteip 10.0.1.2-100
localip 192.168.0.199
remoteip 192.168.0.200-250</programlisting>

				</example>
				 <para>
					A configuração PPP usada pelo servidor PPTP também requer algumas mudanças em <filename>/etc/ppp/pptpd-options</filename>. Os parâmetros importantes são o nome do servidor (<literal>pptp</literal>), o nome de domínio (<literal>falcot.com</literal>), e o endereço IP para os servidores DNS e WINS.
				</para>
				 <example id="example.ppp-pptpd-options">
					<title>O arquivo <filename>/etc/ppp/pptpd-options</filename></title>
					 
<programlisting>
## turn pppd syslog debugging on
#debug

## change 'servername' to whatever you specify as your server name in chap-secrets
name pptp
## change the domainname to your local domain
domain falcot.com

## these are reasonable defaults for WinXXXX clients
## for the security related settings
# The Debian pppd package now supports both MSCHAP and MPPE, so enable them
# here. Please note that the kernel support for MPPE must also be present!
auth
require-chap
require-mschap
require-mschap-v2
require-mppe-128

## Fill in your addresses
ms-dns 192.168.0.1
ms-wins 192.168.0.1

## Fill in your netmask
netmask 255.255.255.0

## some defaults
nodefaultroute
proxyarp
lock</programlisting>

				</example>
				 <para>
					O último passo envolve o registro do usuário <literal>vpn</literal> (e senha correspondente) no arquivo <filename>/etc/ppp/chap-secrets</filename>. Ao contrário de outras instâncias onde um asterisco (<literal>*</literal>) funcionaria, o nome do servidor tem que ser preenchido explícitamente aqui. Além do mais, clientes PPTP em Windows são identificados sob a forma <literal><replaceable>DOMAIN</replaceable>\\<replaceable>USER</replaceable></literal>, ao invés de apenas fornecer um nome de usuário. Isso explica o porque do arquivo também mencionar o usuário <literal>FALCOT\\vpn</literal>. Também é possível especificar um endereço IP individual para usuários; um asterisco neste campo especifica que endereços dinâmicos devem ser usados.
				</para>
				 <example id="example.ppp-chap-secrets">
					<title>O arquivo <filename>/etc/ppp/chap-secrets</filename></title>
					 
<programlisting>
# Secrets for authentication using CHAP
# client        server  secret      IP addresses
vpn             pptp    f@Lc3au     *
FALCOT\\vpn     pptp    f@Lc3au     *</programlisting>

				</example>
				 <sidebar> <title><emphasis>SEGURANÇA</emphasis> Vulnerabilidades PPTP</title>
				 <para>
					A primeira implementação do PPTP da Microsoft atraiu severas críticas porque ela tinha várias vulnerabilidades de segurança; a maioria foi, desde então, consertada em versões mais recentes. A configuração documentada nestas seção usa a última versão do protocolo. Esteja ciente então de que removendo algumas das opções (como <literal>require-mppe-128</literal> e <literal>require-mschap-v2</literal>) fará com que o serviço fique vulnerável novamente.
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.quality-of-service">
		<title>Qualidade do Serviço</title>
		 <section id="sect.qos-principe">
			<title>Principle and Mechanism</title>
			 <para>
				<emphasis>Quality of Service</emphasis> (ou <emphasis>QoS</emphasis> para abreviar) se refere a um conjunto de técnicas que garantem ou melhoram a qualidade do serviço fornecido às aplicações. A mais popular dessas técnicas envolve a classificação o tráfego de rede em categorias, e à diferenciação ao manejar esse tráfego de acordo com a categoria a qual ele pertence. A principal aplicação desse conceito de diferenciação de serviços é <emphasis>traffic shaping</emphasis>, o qual limita a taxa de transmissão de dados para conexões relacionadas a algum serviço e/ou máquinas (hosts) para que não haja saturação da largura de banda disponível e deixe outros importantes serviços sem nada. Traffic shaping se encaixa bem particularmente no tráfego TCP, já que esse protocolo se adapta automaticamente a largura de banda disponível.
			</para>
			 <indexterm>
				<primary>QoS</primary>
			</indexterm>
			 <indexterm>
				<primary>qualidade do serviço</primary>
			</indexterm>
			 <indexterm>
				<primary>qualidade</primary>
				<secondary>do serviço</secondary>
			</indexterm>
			 <indexterm>
				<primary>serviço</primary>
				<secondary>qualidade</secondary>
			</indexterm>
			 <para>
				Também é possível alterar as prioridades do tráfego, o que permite priorizar pacotes relacionados a serviços de interação (como o <command>ssh</command> e o <command>telnet</command>) ou a serviços que lidam apenas com pequenos blocos de dados.
			</para>
			 <para>
				Os núcleos Debian incluem os recursos necessários para o QoS junto com seus módulos associados. Esses módulos são muitos, e cada um deles provê um serviço diferente, principalmente por meio de agendamentos especiais para as filas de pacotes IP; a ampla gama de comportamentos do agendador disponível abrange todos os possíveis requisitos.
			</para>
			 <sidebar> <title><emphasis>CULTURA</emphasis> LARTC — <emphasis>Roteamento avançado e controle de tráfego do Linux</emphasis></title>
			 <para>
				O HOWTO <emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis> é o documento de referencia que cobre tudo que se deve saber sobre serviço de qualidade de rede. <ulink type="block" url="http://www.lartc.org/howto/" />
			</para>
			 <indexterm>
				<primary>roteamento</primary>
				<secondary>avançado</secondary>
			</indexterm>
			 <indexterm>
				<primary>tráfego</primary>
				<secondary>controle</secondary>
			</indexterm>
			 <indexterm>
				<primary>controle de tráfego</primary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.qos-config">
			<title>Configurando e implementando</title>
			 <para>
				Os parametros do QoS são configurados através do comando <command>tc</command> (fornecido pelo pacote <emphasis role="pkg">iproute</emphasis>). Como sua interface é bem complexa, o uso de ferramentas de alto nível é recomendado.
			</para>
			 <indexterm>
				<primary><emphasis>iproute</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><command>tc</command></primary>
			</indexterm>
			 <section id="sect.qos-wondershaper">
				<title>Reduzindo Latências: <command>wondershaper</command></title>
				 <para>
					O principal propósito do <command>wondershaper</command> (em pacote de nome similar) é minimizar latências independente da carga da rede. Isso é alcançado limitando o total de tráfego para um valor que seja pouco abaixo do valor de saturação do link.
				</para>
				 <indexterm>
					<primary><command>wondershaper</command></primary>
				</indexterm>
				 <indexterm>
					<primary>limitação de tráfego</primary>
				</indexterm>
				 <indexterm>
					<primary>tráfego</primary>
					<secondary>limitando</secondary>
				</indexterm>
				 <para>
					Uma vez que uma interface de rede esteja configurada, configura-se sua limitação de tráfego executando <command>wondershaper <replaceable>interface</replaceable> <replaceable>taxa_download</replaceable> <replaceable>taxa_upload</replaceable></command>. A interface pode ser <literal>eth0</literal> ou <literal>ppp0</literal> por exemplo, e ambas as taxas são expressas em kilobits por segundo. O comando <command>wondershaper remove <replaceable>interface</replaceable></command> desabilita o controle de tráfego na interface especificada.
				</para>
				 <para>
					Para uma conexão Ethernet, é melhor chamar esse script assim que a interface esteja configurada. Isso é feito adicionando as diretivas <literal>up</literal> e <literal>down</literal> no arquivo <filename>/etc/network/interfaces</filename> permitindo que os comandos declarados sejam executados, respectivamente, após a configuração da interface e antes que ela seja desconfigurada. Por exemplo:
				</para>
				 <example id="example.network-interfaces">
					<title>Mudanças no arquivo <filename>/etc/network/interfaces</filename></title>
					 
<programlisting>
iface eth0 inet dhcp
    up /sbin/wondershaper eth0 500 100
    down /sbin/wondershaper remove eth0</programlisting>

				</example>
				 <para>
					No caso do PPP, criar um script que chame <command>wondershaper</command> em <filename>/etc/ppp/ip-up.d/</filename> irá habilitar o control de tráfico assim que a conexão seja feita.
				</para>
				 <sidebar> <title><emphasis>INDO ALÉM</emphasis> Configuração ideal</title>
				 <para>
					O arquivo <filename>/usr/share/doc/wondershaper/README.Debian.gz</filename> descreve, com alguns detalhes, o método de configuração recomendado pelo mantenedor do pacote. Em particular, ele aconselha a medição da velocidade de download e upload a fim de melhor avaliar os limites reais.
				</para>
				 </sidebar>
			</section>
			 <section id="sect.qos-config-standard">
				<title>Configuração Padrão</title>
				 <para>
					Salvo uma configuração de QoS específica, o núcleo Linux usa o agendador de fila <literal>pfifo_fast</literal>, que fornece, ele mesmo, alguns recursos interessantes. A prioridade de cada pacote IP processado é baseada no campo ToS (<emphasis>Type of Service</emphasis>) desse pacote; modicar esse campo é o suficiente para tirar vantagem dos recursos de agendamento. Existem cinco possíveis valores:
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							Normal-Service (0); (serviço normal)
						</para>

					</listitem>
					 <listitem>
						<para>
							Minimize-Cost (2); (minimizar custo)
						</para>

					</listitem>
					 <listitem>
						<para>
							Maximize-Reliability (4); (maximizar confiabilidade)
						</para>

					</listitem>
					 <listitem>
						<para>
							Maximize-Throughput (8); (maximizar vazão)
						</para>

					</listitem>
					 <listitem>
						<para>
							Minimize-Delay (16) (minimizar retardo).
						</para>

					</listitem>

				</itemizedlist>
				 <indexterm>
					<primary>ToS</primary>
				</indexterm>
				 <indexterm>
					<primary>Tipo de Serviço</primary>
				</indexterm>
				 <para>
					O campo ToS pode ser configurado por aplicações que geram pacotes IP, ou modificado em tempo de execução pelo <emphasis>netfilter</emphasis>. As regras a seguir são suficientes para aumentar a capacidade de resposta para o serviço de um servidor SSH:
				</para>
				 
<programlisting role="scale">
iptables -t mangle -A PREROUTING -p tcp --sport ssh -j TOS --set-tos Minimize-Delay
iptables -t mangle -A PREROUTING -p tcp --dport ssh -j TOS --set-tos Minimize-Delay</programlisting>

			</section>

		</section>

	</section>
	 <section id="sect.dynamic-routing">
		<title>Roteamento Dinâmico</title>
		 <indexterm>
			<primary>roteamento</primary>
			<secondary>dinâmico</secondary>
		</indexterm>
		 <indexterm>
			<primary><command>quagga</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>zebra</command></primary>
		</indexterm>
		 <para>
			A ferramenta de referencia para roteamento dinâmico é atualmente o <command>quagga</command>, do pacote de nome similar; costumava ser o <command>zebra</command> até que seu desenvolvimento foi descontinuado. Contudo, o <command>quagga</command> mantém os nomes dos programas por questões de compatibilidade, o que explica os comandos <command>zebra</command> abaixo.
		</para>
		 <sidebar> <title><emphasis>DE VOLTA AO BÁSICO</emphasis> Roteamento dinâmico</title>
		 <para>
			O roteamento dinâmico permite que os roteadores ajustem, em tempo real, os caminhos usados para transmitir pacotes IP. Cada protocolo envolve um método próprio para definir rotas (caminhos mais curtos, usam rotas anunciadas pelos pares, e assim por diante).
		</para>
		 <para>
			No núcleo Linux, uma rota "liga" um dispositivo de rede a um conjunto de máquinas que podem ser alcançadas através desse dispositivo. O comando <command>route</command> define novas rotas e exibe as existentes.
		</para>
		 <indexterm>
			<primary><command>route</command></primary>
		</indexterm>
		 </sidebar> <para>
			Quagga é um conjunto de daemons que cooperam para definir as tabelas de roteamento a serem usadas pelo núcleo Linux; cada protocolo de roteamento (mais notadamente BGP, OSPF e RIP) provê seu próprio daemon. O daemon <command>zebra</command> coleta informações a partir de outros daemons e lida com as tabelas de roteamento estático em conformidade. Os outros daemons são conhecidos como <command>bgpd</command>, <command>ospfd</command>, <command>ospf6d</command>, <command>ripd</command>, <command>ripngd</command>, <command>isisd</command>, e <command>babeld</command>.
		</para>
		 <indexterm>
			<primary>OSPF</primary>
		</indexterm>
		 <indexterm>
			<primary>BGP</primary>
		</indexterm>
		 <indexterm>
			<primary>RIP</primary>
		</indexterm>
		 <indexterm>
			<primary>IS-IS</primary>
		</indexterm>
		 <indexterm>
			<primary>BABEL, roteamento mesh sem fio</primary>
		</indexterm>
		 <indexterm>
			<primary><command>bgpd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ospfd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ospf6d</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ripd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ripngd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>isisd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>babeld</command></primary>
		</indexterm>
		 <para>
			Daemons são habilitados editando o arquivo <filename>/etc/quagga/daemons</filename> e criando o arquivo de configuração apropriado em <filename>/etc/quagga/</filename>; esses arquivos de configuração devem ser nomeados após o daemon, com extensão <filename>.conf</filename>, e pertencer ao usuário <literal>quagga</literal> e grupo <literal>quaggavty</literal> para que o script <filename>/etc/init.d/quagga</filename> possa invocar o daemon.
		</para>
		 <para>
			A configuração de cada um desses daemons requer conhecimento do protocolo de roteamento em questão. Esses protocolos não podem ser descritos em detalhes aqui, mas o <emphasis role="pkg">quagga-doc</emphasis> provê uma ampla explanação na forma de um arquivo <command>info</command>. O mesmo conteúdo talvez seja mais fácil de manusear em HTML no website do Quagga: <ulink type="block" url="http://www.nongnu.org/quagga/docs/docs-info.html" />
		</para>
		 <para>
			Adicionalmente, a sintaxe é muito próxima a uma interface de configuração de um roteador padrão, e administradores de rede irão se adaptar rapidamente ao <command>quagga</command>.
		</para>
		 <sidebar> <title><emphasis>NA PRÁTICA</emphasis> OSPF, BGP ou RIP?</title>
		 <para>
			OSPF é geralmente o melhor protocolo a se usar para roteamento dinâmico em redes privadas, mas BGP é mais comum para o amplo roteamento da Internet. RIP é bem antigo, e raramente usado.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.ipv6">
		<title>IPv6</title>
		 <para>
			IPv6, sucessor do IPv4, é a nova versão do protocolo IP desenhado para consertar suas falhas, mais notadamente a excasses de endereços IP disponíveis. Esse protocolo lida com a camada de rede; seu propósito é fornecer uma maneira de endereçar máquinas, para direcionar dados para o destino pretendido, e lidar com fragmentação de dados se necessário (em outras palavras, dividir pacotes em pedaços de tamanho que depende dos links de rede a serem usados pelo caminho e juntar esses pedaços na ordem apropriada na chegada).
		</para>
		 <para>
			Os núcleos Debian incluem o manejo do IPv6 no "core" do núcleo (com exceção de algumas arquiteturas que tem esse suporte compilado como um módulo de nome <literal>ipv6</literal>). Ferramentas básicas como <command>ping</command> e <command>traceroute</command> tem seu equivalente IPv6 como <command>ping6</command> e <command>traceroute6</command>, disponíveis, respectivamente, nos pacotes <emphasis role="pkg">iputils-ping</emphasis> e <emphasis role="pkg">iputils-tracepath</emphasis>.
		</para>
		 <indexterm>
			<primary>IPv6</primary>
		</indexterm>
		 <indexterm>
			<primary><emphasis role="pkg">iputils-ping</emphasis></primary>
		</indexterm>
		 <indexterm>
			<primary><emphasis role="pkg">iputils-tracepath</emphasis></primary>
		</indexterm>
		 <para>
			A rede IPv6 é configurada de maneira similar a IPv4, em <filename>/etc/network/interfaces</filename>. Mas se você quer que a rede esteja disponível globalmente, você tem que garantir que você tenha um roteador de retransmissão de tráfego IPv6 com capacidade para a rede IPv6 global.
		</para>
		 <example id="example.network-interfaces-ipv6">
			<title>Exemplo de configuração IPv6</title>
			 
<programlisting>
iface eth0 inet6 static
    address 2001:db8:1234:5::1:1
    netmask 64
    # Disabling auto-configuration
    # autoconf 0
    # The router is auto-configured and has no fixed address
    # (accept_ra 1). If it had:
    # gateway 2001:db8:1234:5::1</programlisting>

		</example>
		 <para>
			Sub-redes IPv6 geralmente tem uma máscara de rede de 64 bits. Isso significa que endereços distintos 2<superscript>64</superscript> existem dentro da sub-rede. Isso permite a "Stateless Address Autoconfiguration" (<acronym>SLAAC</acronym>) pegar um endereço baseando-se no endereço MAC da interface de rede. Por padrão, se <acronym>SLAAC</acronym> estiver ativada em sua rede e o IPv6 em seu computador, o núcleo irá automaticamente encontrar os roteadores IPv6 e configurar as interfaces de rede.
		</para>
		 <para>
			Esse comportamento pode ter implicações de privacidade. Se você muda de rede com frequência, por exemplo com um laptop, você talvez não queira que seu endereço <acronym>MAC</acronym> faça parte do seu endereço IPv6 público. Isso faz com que seja fácil identificar o mesmo dispositivo através das redes. Uma solução para isso são as extensões de privacidade do IPv6 (que o Debian habilita por padrão se a conectividade IPv6 é detectada durante a instalação inicial), as quais irão definir um endereço adicional para a interface de forma aleatória, periodicamente alterá-lo e usá-los para conexões de saída. Conexões de entrada podem continuar a usar os endereços gerados pelo SLAAC. O exemplo a seguir, para uso em <filename>/etc/network/interfaces</filename>, ativa essas extensões de privacidade.
		</para>
		 <example id="example.network-interface-ipv6-privext">
			<title>Extensões de privacidade IPv6</title>
			 
<programlisting>
iface eth0 inet6 auto
    # Prefer the randomly assigned addresses for outgoing connections.
    privext 2</programlisting>

		</example>
		 <sidebar> <title><emphasis>DICA</emphasis> Programas construídos com IPv6</title>
		 <para>
			Muitos software precisam ser adaptados para lidar com IPv6. A maioria dos pacotes no Debian já foram adaptados, mas não todos. Se o seu pacote favorito ainda não funciona com IPv6, você pode pedir ajuda na lista de email <emphasis>debian-ipv6</emphasis>. Eles podem saber sobre a substituição IPv6 consciente e podem reportar um bug para ter o assunto rastreado de maneira apropriada. <ulink type="block" url="http://lists.debian.org/debian-ipv6/" />
		</para>
		 </sidebar> <indexterm>
			<primary>IPv6 firewall</primary>
		</indexterm>
		 <indexterm>
			<primary>firewall</primary>
			<secondary>IPv6</secondary>
		</indexterm>
		 <indexterm>
			<primary><command>ip6tables</command></primary>
		</indexterm>
		 <para>
			As conexões IPv6 podem ser restringidas, da mesma maneira que as conexões IPv4: os núcleos Debian padrão incluem uma adaptação do <emphasis>netfilter</emphasis> para o IPv6. Esse <emphasis>netfilter</emphasis> habilitado para IPv6 é configurado de maneira similar a contraparte IPv4, excerto que o programa a ser usado é o <command>ip6tables</command> ao invés do <command>iptables</command>.
		</para>
		 <section id="sect.ipv6-tunneling">
			<title>Túneis</title>
			 <sidebar> <title><emphasis>ATENÇÃO</emphasis> Tunelamento IPv6 e firewalls</title>
			 <para>
				O encapsulamento do IPv6 sobre o IPv4 (ao contrário do IPv6 nativo) requer que o firewall aceite o tráfego, o qual usa o protocolo número 41 do IPv4.
			</para>
			 </sidebar> <para>
				Se uma conexão IPv6 nativa não está disponível, o método de recuperação (fallback) é usar o encapsulamento sobre o IPv4. Gogo6 é um fornecedor (livre) desses encapsulamentos: <ulink type="block" url="http://www.gogo6.com/freenet6/tunnelbroker" />
			</para>
			 <indexterm>
				<primary>Freenet6</primary>
			</indexterm>
			 <indexterm>
				<primary>Gogo6</primary>
			</indexterm>
			 <para>
				Para usar o encapsulamento Freenet6, você precisa se registrar no website abrindo uma conta Freenet6 Pro, e depois instalar o pacote <emphasis role="pkg">gogoc</emphasis> e configurar o encapsulamento. Isso requer editar o arquivo <filename>/etc/gogoc/gogoc.conf</filename>: as linhas <literal>userid</literal> e <literal>password</literal> recebidas por email devem ser adicionadas, e <literal>server</literal> deve ser substituída por <literal>authenticated.freenet6.net</literal>.
			</para>
			 <para>
				A conectividade IPv6 é oferecida para todas as máquinas de uma rede local adicionando-se as três seguintes diretivas ao arquivo <filename>/etc/gogoc/gogoc.conf</filename> (assumindo que a rede local esteja conectada a interface eth0):
			</para>
			 
<programlisting>
host_type=router
prefixlen=56
if_prefix=eth0</programlisting>
			 <para>
				A máquina se torna então o roteador de acesso para a subrede com prefixo 56-bit. Uma vez que o túnel esteja ciente dessa alteração, a rede local deve ser avisada sobre isso; isso implica em instalar o daemon <command>radvd</command> (do pacote de nome similar). Esse daemon de configuração IPv6 desempenha papel similar ao do <command>dhcpd</command> no mundo IPv4.
			</para>
			 <para>
				O arquivo de configuração <filename>/etc/radvd.conf</filename> deve então ser criado (veja <filename>/usr/share/doc/radvd/examples/simple-radvd.conf</filename> como um ponto de partida). No nosso caso, a única alteração necessária é o prefixo, o qual precisa se substituído pelo fornecido pela Freenet6; ele pode ser encontrado pela resultado do comando <command>ifconfig</command> no bloco referente à interface <literal>tun</literal>.
			</para>
			 <indexterm>
				<primary><command>radvd</command></primary>
			</indexterm>
			 <para>
				Então execute <command>service gogoc restart</command> e <command>service radvd start</command>, e a rede IPv6 deve funcionar.
			</para>

		</section>

	</section>
	 <section id="sect.domain-name-servers">
		<title>Servidores de Nomes de Domínio (DNS)</title>
		 <section id="sect.dns-principe">
			<title>Principle and Mechanism</title>
			 <indexterm>
				<primary>DNS</primary>
			</indexterm>
			 <indexterm>
				<primary>servidor</primary>
				<secondary>nome</secondary>
			</indexterm>
			 <para>
				O <emphasis>Domain Name Service</emphasis> (DNS) é um componente fundamental da Internet: ele mapeia os nomes de máquinas em endereços IP (e vice-versa), o que permite o uso de <literal>www.debian.org</literal> ao invés de <literal>5.153.231.4</literal> ou <literal>2001:41c8:1000:21::21:4</literal>.
			</para>
			 <para>
				O registros do DNS são organizados em zonas; cada zona coincide com um domínio (ou um subdomínio) ou um intervalo de endereço IP (já que endereços IP são geralmente alocados em intervalos consecutivos). Um servidor primário tem autoridade sobre o conteúdo de uma zona; servidores secundários, geralmente hospedados em máquinas separadas, fornecem regularmente cópias atualizadas da zona primária.
			</para>
			 <indexterm>
				<primary>zona</primary>
				<secondary>DNS</secondary>
			</indexterm>
			 <indexterm>
				<primary>DNS</primary>
				<secondary>zona</secondary>
			</indexterm>
			 <para>
				Cada zona pode conter registros de vários tipos (<emphasis>Resource Records</emphasis>):
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>A</literal>: endereço IPv4. <indexterm><primary>A, registro DNS</primary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>CNAME</literal>: alias (<emphasis>nome canônico</emphasis>). <indexterm><primary>CNAME, registro DNS</primary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>MX</literal>: <emphasis>mail exchange</emphasis>, um servidor de email. Essa informação é usada por outros servidores de email para saber para onde enviar o email destinado a um dado endereço. Cada registro MX tem uma prioridade. O servidor de prioridade mais alta (com o número mais baixo) é tentado primeiro (veja barra lateral <xref linkend="sidebar.smtp" />); outros servidores são contactados em uma ordem de prioridade decrescente caso o primeiro não responda. <indexterm><primary>MX</primary><secondary>registro DNS</secondary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>PTR</literal>: mapeamento de um endereço IP em um nome. Um registro desses é armazenado em uma zona de “DNS reverso” cujo nome vem do intervalo de endereço IP. Por exemplo, <literal>1.168.192.in-addr.arpa</literal> é a zona que contém o mapeamento reverso para todos os endereços no intervalo <literal>192.168.1.0/24</literal>. <indexterm><primary>PTR, registro DNS</primary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>AAAA</literal>: endereço IPv6. <indexterm><primary>AAAA, registro DNS</primary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>NS</literal>: mapeia um nome para o servidor de nomes. Cada domínio tem que ter pelo menos um registro NS. Esses registros apontam para um servidor DNS que pode responder pesquisas relacionadas a esse domínio; eles usualmente apontam para os servidores primário e secundário do domínio. Esses registros também permitem delegação DNS; por exemplo, a zona <literal>falcot.com</literal> pode incluir um registro NS para <literal>internal.falcot.com</literal>, o que significa que a zona <literal>internal.falcot.com</literal> é gerenciada por outro servidor. Claro que, esse servidor tem que declarar uma zona <literal>internal.falcot.com</literal>. <indexterm><primary>NS, registro DNS</primary></indexterm>
					</para>

				</listitem>

			</itemizedlist>
			 <indexterm>
				<primary>registro</primary>
				<secondary>DNS</secondary>
			</indexterm>
			 <indexterm>
				<primary>registro DNS</primary>
			</indexterm>
			 <para>
				O servidor de nomes de referência, o Bind, foi desenvolvido e é mantido pela ISC (<emphasis>Internet Software Consortium</emphasis>). Ele é fornecido pelo Debian pelo pacote <emphasis role="pkg">bind9</emphasis>. A versão 9 trás duas grandes mudanças comparando com versões anteriores. Primeiro, o servidor DNS pode agora ser rodado sob um usuário sem privilégios, então uma vulnerabilidade de segurança no servidor não permiter privilégios de root ao atacante (como já foi visto repetidamente nas versões 8.x).
			</para>
			 <para>
				Além do mais, o Bind suporta o padrão DNSSEC para assinar (e portanto autenticar) registros DNS, o que permite bloquear qualquer falsificação ("spoofing") de seus dados durante ataques "man-in-the-middle".
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">bind9</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>ISC</primary>
			</indexterm>
			 <indexterm>
				<primary>Internet Software Consortium</primary>
			</indexterm>
			 <sidebar> <title><emphasis>CULTURA</emphasis> DNSSEC</title>
			 <indexterm>
				<primary>DNSSEC</primary>
			</indexterm>
			 <para>
				A norma DNSSEC é bem complexa; isso explica um pouco porque ela ainda não é amplamente usada (mesmo que ela coexista perfeitamente com servidores DNS que não estejam cientes da DNSSEC). Para entender todos os meandros, você deveria ver o seguinte artigo. <ulink type="block" url="http://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions" />
			</para>
			 </sidebar>
		</section>
		 <section id="sect.dns-config">
			<title>Configurando</title>
			 <para>
				Arquivos de configuração para o <command>bind</command>, independente da versão, têm a mesma estrutura.
			</para>
			 <para>
				Os administradores da Falcot criaram uma zona primária <literal>falcot.com</literal> para armazenar informações relacionadas a este domínio, e uma zona <literal>168.192.in-addr.arpa</literal> para mapeamento reverso de endereços IP na rede local.
			</para>
			 <sidebar> <title><emphasis>ATENÇÃO</emphasis> Nomes de zonas inversas</title>
			 <indexterm>
				<primary>zona</primary>
				<secondary>reversa</secondary>
			</indexterm>
			 <indexterm>
				<primary>zona reversa</primary>
			</indexterm>
			 <indexterm>
				<primary><literal>in-addr.arpa</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>ip6.arpa</literal></primary>
			</indexterm>
			 <indexterm>
				<primary>formato nibble</primary>
			</indexterm>
			 <para>
				Zonas reversas tem um nome particular. A zona que cobre a rede <literal>192.168.0.0/16</literal> precisa ser nomeada como <literal>168.192.in-addr.arpa</literal>: os componentes do endereço IP são invertidos, e seguidos pelo sufixo <literal>in-addr.arpa</literal>.
			</para>
			 <para>
				Para redes IPv6, o sufixo é <literal>ip6.arpa</literal> e os componentes do endereço IP os quais são invertidos são cada caractere de toda a representação hexadecimal do endereço IP. Como por exemplo, a rede <literal>2001:0bc8:31a0::/48</literal> iria usar uma zona de nome <literal>0.a.1.3.8.c.b.0.1.0.0.2.ip6.arpa</literal>.
			</para>
			 </sidebar> <sidebar> <title><emphasis>DICA</emphasis> Testando o servidor DNS</title>
			 <para>
				O comando <command>host</command> (do pacote <emphasis role="pkg">bind9-host</emphasis>) faz pesquisa em um servidor DNS, e pode ser usado para testar a configuração do servidor. Por exemplo, <command>host machine.falcot.com localhost</command> checa a resposta do servidor local para a pesquisa por <literal>machine.falcot.com</literal>. <command>host <replaceable>ipaddress</replaceable> localhost</command> testa a resolução reversa.
			</para>
			 <indexterm>
				<primary><command>host</command></primary>
			</indexterm>
			 </sidebar> <para>
				Os seguintes trecho de configuração, tirados dos arquivos da Falcot, podem servir como ponto de partida para configurar um servidor DNS:
			</para>
			 <indexterm>
				<primary><filename>named.conf</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/bind/named.conf</filename></primary>
			</indexterm>
			 <example id="example.bind-named.conf.local">
				<title>Trecho do <filename>/etc/bind/named.conf.local</filename></title>
				 
<programlisting>
zone "falcot.com" {
        type master;
        file "/etc/bind/db.falcot.com";
        allow-query { any; };
        allow-transfer {
                195.20.105.149/32 ; // ns0.xname.org
                193.23.158.13/32 ; // ns1.xname.org
        };
};

zone "internal.falcot.com" {
        type master;
        file "/etc/bind/db.internal.falcot.com";
        allow-query { 192.168.0.0/16; };
};

zone "168.192.in-addr.arpa" {
        type master;
        file "/etc/bind/db.192.168";
        allow-query { 192.168.0.0/16; };
};</programlisting>

			</example>
			 <example id="example.bind-db.falcot.com">
				<title>Trecho do <filename>/etc/bind/db.falcot.com</filename></title>
				 
<programlisting>; falcot.com Zone 
; admin.falcot.com. =&gt; zone contact: admin@falcot.com
$TTL    604800
@       IN      SOA     falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
;
; The @ refers to the zone name ("falcot.com" here)
; or to $ORIGIN if that directive has been used
;
@       IN      NS      ns
@       IN      NS      ns0.xname.org.

internal IN      NS      192.168.0.2

@       IN      A       212.94.201.10
@       IN      MX      5 mail
@       IN      MX      10 mail2

ns      IN      A       212.94.201.10
mail    IN      A       212.94.201.10
mail2   IN      A       212.94.201.11
www     IN      A       212.94.201.11

dns     IN      CNAME   ns</programlisting>

			</example>
			 <sidebar> <title><emphasis>ATENÇÃO</emphasis> Sintaxe de um nome</title>
			 <para>
				A sintaxe de nomes de máquina seguem regras rígidas. Por exemplo, <literal>machine</literal> tem que ser <literal>machine.<replaceable>domain</replaceable></literal>. Se o nome de domínio não deve ser anexado ao nome, o dito nome tem que ser escrito como <literal>machine.</literal> (com o ponto como sufixo). Indicar um nome DNS fora do domínio corrente entretanto requer uma sintaxe como <literal>machine.otherdomain.com.</literal> (com o ponto final).
			</para>
			 </sidebar> <example id="example.bind-db.192.168">
				<title>Trecho do <filename>/etc/bind/db.192.168</filename></title>
				 
<programlisting>; Reverse zone for 192.168.0.0/16
; admin.falcot.com. =&gt; zone contact: admin@falcot.com
$TTL    604800
@       IN      SOA     ns.internal.falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL

        IN      NS      ns.internal.falcot.com.

; 192.168.0.1 -&gt; arrakis
1.0     IN      PTR     arrakis.internal.falcot.com.
; 192.168.0.2 -&gt; neptune
2.0     IN      PTR     neptune.internal.falcot.com.

; 192.168.3.1 -&gt; pau
1.3     IN      PTR     pau.internal.falcot.com.</programlisting>

			</example>

		</section>

	</section>
	 <section id="sect.dhcp">
		<title>DHCP</title>
		 <para>
			DHCP (para <emphasis>Dynamic Host Configuration Protocol</emphasis>) é um protocolo pelo qual uma máquina pode receber automaticamente sua configuração de rede no momento de inicialização. Isso permite centralizar o gerenciamento de configuração de uma rede, e garante que todas as máquinas recebam configurações similares.
		</para>
		 <indexterm>
			<primary>DHCP</primary>
		</indexterm>
		 <indexterm>
			<primary>Dynamic Host Configuration Protocol</primary>
		</indexterm>
		 <indexterm>
			<primary>rede</primary>
			<secondary>configuração DHCP</secondary>
		</indexterm>
		 <para>
			Um servidor DHCP provê muitos parâmetros relacionados a redes. O mais comum desses é um endereço IP e a rede a qual a máquina pertence, mas ele também pode prover outras informações, como servidores DNS, servidores WINS, servidores NTP, e assim por diante.
		</para>
		 <para>
			A Internet Software Consortium (também envolvida no desenvolvimento do <command>bind</command>) é a principal autora do servidor DHCP. O pacote Debian correspondente é o <emphasis role="pkg">isc-dhcp-server</emphasis>.
		</para>
		 <section id="sect.dhcp-config">
			<title>Configurando</title>
			 <para>
				Os primeiros elementos que precisam ser editados no arquivo de configuração de um servidor DHCP (<filename>/etc/dhcp/dhcpd.conf</filename>) são o nome de domínio e os servidores DNS. Se esse servidor é o único na rede local (como definido pela propagação broadcast), a diretiva <literal>authoritative</literal> também tem que ser ativada (ou descomentada). Também é necessário criar uma seção <literal>subnet</literal> descrevendo a rede local e a informação de configuração a ser fornecida. O exemplo a seguir descreve uma rede local <literal>192.168.0.0/24</literal> com um roteador em <literal>192.168.0.1</literal> servindo de gateway. Endereços IP disponíveis estão no intervalo de <literal>192.168.0.128</literal> até <literal>192.168.0.254</literal>.
			</para>
			 <example id="example.dhcp-dhcpd.conf">
				<title>Trecho do <filename>/etc/dhcp/dhcpd.conf</filename></title>
				 
<programlisting>
#
# Sample configuration file for ISC dhcpd for Debian
#

# The ddns-updates-style parameter controls whether or not the server will
# attempt to do a DNS update when a lease is confirmed. We default to the
# behavior of the version 2 packages ('none', since DHCP v2 didn't
# have support for DDNS.)
ddns-update-style interim;

# option definitions common to all supported networks...
option domain-name "internal.falcot.com";
option domain-name-servers ns.internal.falcot.com;

default-lease-time 600;
max-lease-time 7200;

# If this DHCP server is the official DHCP server for the local
# network, the authoritative directive should be uncommented.
authoritative;

# Use this to send dhcp log messages to a different log file (you also
# have to hack syslog.conf to complete the redirection).
log-facility local7;

# My subnet
subnet 192.168.0.0 netmask 255.255.255.0 {
    option routers 192.168.0.1;
    option broadcast-address 192.168.0.255;
    range 192.168.0.128 192.168.0.254;
    ddns-domainname "internal.falcot.com";
}</programlisting>

			</example>

		</section>
		 <section id="sect.dhcp-dns">
			<title>DHCP e DNS</title>
			 <indexterm>
				<primary>DNS</primary>
				<secondary>atualizações automáticas</secondary>
			</indexterm>
			 <para>
				Um recurso legal é o registro automatizado de clientes DHCP em uma zona DNS, para que cada máquina receba um nome significativo (ao invés de alguma coisa impessoal como <literal>machine-192-168-0-131.internal.falcot.com</literal>). Usar esse recurso requer a configuração do servidor DNS para aceitar atualizações para a zona DNS <literal>internal.falcot.com</literal> a partir do servidor DHCP, e configurar esse último para submeter atualizações para cada registro.
			</para>
			 <para>
				No caso do <command>bind</command>, a diretiva <literal>allow-update</literal> precisa ser adicionada a cada uma das zonas que o servidor DHCP deve editar (uma para o domínio <literal>internal.falcot.com</literal>, e uma para a zona reversa). Essa diretiva lista o endereço IP que tem permissão para realizar essas atualizações; ela deve então conter os possíveis endereços do servidor DHCP (tanto o endereço local quanto o endereço público, se apropriado).
			</para>
			 
<programlisting>
allow-update { 127.0.0.1 192.168.0.1 212.94.201.10 !any };</programlisting>
			 <para>
				Esteja atento! Uma zona que pode ser modificada <emphasis>será</emphasis> alterada pelo <command>bind</command>, e esse último irá sobrescrever seus arquivos de configuração em intervalos regulares. Como esse procedimento automatizado produz arquivos que são menos legíveis por humanos que os escritos manualmente, os administradores da Falcot lidam com o domínio <literal>internal.falcot.com</literal> com um servidor DNS delegado; isso significa que o arquivo de zona <literal>falcot.com</literal> continua firmemente sob controle manual.
			</para>
			 <para>
				O trecho da configuração do servidor DHCP acima inclui as diretivas necessárias para atualização da zona DNS: elas são as linhas <literal>ddns-update-style interim;</literal> e <literal>ddns-domain-name "internal.falcot.com";</literal> no bloco que descreve a subrede.
			</para>

		</section>

	</section>
	 <section id="sect.network-diagnosis-tools">
		<title>Ferramentas de Diagnóstico de Rede</title>
		 <para>
			Quando uma aplicação de rede não funciona como o esperado, é importante poder olhar sob o capô. E mesmo quando tudo parece rodar suave, fazer um diagnóstico da rede pode ajudar a garantir que tudo está funcionando como deveria. Várias ferramentas de diagóstico existem para esse propósito; cada uma opera em um nível diferente.
		</para>
		 <section id="sect.netstat">
			<title>Diagnóstico Local: <command>netstat</command></title>
			 <indexterm>
				<primary><command>netstat</command></primary>
			</indexterm>
			 <para>
				Vamos primeiro mencionar o comando <command>netstat</command> (do pacote <emphasis role="pkg">net-tools</emphasis>); ele exibe um sumário momentâneo da atividade de rede da máquina. Quando invocado sem argumentos, esse comando lista todas as conexões abertas; essa lista pode ser bem longa já que inclui muitos soquetes Unix-domain (amplamente usados por daemons) que não tem nada a ver com redes (por exemplo, comunicação <literal>dbus</literal>, tráfego <literal>X11</literal> e comunicações entre sistema de arquivos virtuais e o desktop).
			</para>
			 <para>
				Invocações comuns entretanto usam opções que alteram o comportamento do <command>netstat</command>. As opções mais comumente usadas são:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>-t</literal>, que filtra os resultados para incluir apenas conexões TCP;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-u</literal>, que funciona de maneira similar para conexões UDP; essas opções não são mutuamente exclusivas, e uma delas é suficiente para parar de exibir conexões Unix-domain;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-a</literal>, para também listar soquetes ativos (esperando por conexões de entrada);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-n</literal>, para exibir os resultados com números: endereço IP (sem resolução DNS), números de porta (sem as aliases como definidas em <filename>/etc/services</filename>) e ids de usuários (sem nomes de login);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-p</literal>, para listar os processos envolvidos; essa opção só é útil quando o <command>netstat</command> é executado como root, já que usuários normais apenas verão seus próprios processos;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-c</literal>, para atualizar continuamente a lista de conexões.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Outras opções, documentadas na página de manual <citerefentry><refentrytitle>netstat</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry>, fornecem um controle ainda mais apurado sobre os resultados exibidos. Na prática, as cinco primeiras opções são tão comumente usadas em conjunto que administradores de sistemas e de redes praticamente usam <command>netstat -tupan</command> como um reflexo. Resultados típicos em uma máquina levemente carregada devem se parecer com o seguinte:
			</para>
			 
<screen role="scale">
<computeroutput># </computeroutput><userinput>netstat -tupan</userinput>
<computeroutput>Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      397/rpcbind     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      431/sshd        
tcp        0      0 0.0.0.0:36568           0.0.0.0:*               LISTEN      407/rpc.statd   
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      762/exim4       
tcp        0    272 192.168.1.242:22        192.168.1.129:44452     ESTABLISHED 1172/sshd: roland [
tcp6       0      0 :::111                  :::*                    LISTEN      397/rpcbind     
tcp6       0      0 :::22                   :::*                    LISTEN      431/sshd        
tcp6       0      0 ::1:25                  :::*                    LISTEN      762/exim4       
tcp6       0      0 :::35210                :::*                    LISTEN      407/rpc.statd   
udp        0      0 0.0.0.0:39376           0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:996             0.0.0.0:*                           397/rpcbind     
udp        0      0 127.0.0.1:1007          0.0.0.0:*                           407/rpc.statd   
udp        0      0 0.0.0.0:68              0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:48720           0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:111             0.0.0.0:*                           397/rpcbind     
udp        0      0 192.168.1.242:123       0.0.0.0:*                           539/ntpd        
udp        0      0 127.0.0.1:123           0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:123             0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:5353            0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:39172           0.0.0.0:*                           407/rpc.statd   
udp6       0      0 :::996                  :::*                                397/rpcbind     
udp6       0      0 :::34277                :::*                                407/rpc.statd   
udp6       0      0 :::54852                :::*                                916/dhclient    
udp6       0      0 :::111                  :::*                                397/rpcbind     
udp6       0      0 :::38007                :::*                                451/avahi-daemon: r
udp6       0      0 fe80::5054:ff:fe99::123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:a:123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:5:123 :::*                                539/ntpd        
udp6       0      0 ::1:123                 :::*                                539/ntpd        
udp6       0      0 :::123                  :::*                                539/ntpd        
udp6       0      0 :::5353                 :::*                                451/avahi-daemon: r
</computeroutput></screen>
			 <para>
				Como esperado, isso lista conexões estabelecidas, duas conexões SSH neste caso, e aplicações esperando por conexões de entrada (listadas como <literal>LISTEN</literal>), notavelmente o servidor de email Exim4 ouvindo na porta 25.
			</para>

		</section>
		 <section id="sect.nmap">
			<title>Diagnóstico Remoto: <command>nmap</command></title>
			 <indexterm>
				<primary><command>nmap</command></primary>
			</indexterm>
			 <para>
				<command>nmap</command> (em pacote de nome similar) é, de certa forma, o equivalente remoto do <command>netstat</command>. ele pode escanear um conjunto de portas conhecidas em um ou mais servidores remotos, e listar as portas aonde uma aplicação se encontra para responder a conexões de entrada. Além do mais, o <command>nmap</command> é capaz de identificar algumas dessas aplicações, algumas vezes até seu número de versão. A contrapartida dessa ferramenta é que, como ela é executada remotamente, ela não pode fornecer informações sobre processos ou usuários; contudo, ela pode operar em vários alvos de uma vez.
			</para>
			 <para>
				Uma invocação típica do <command>nmap</command> usa apenas a opção <literal>-A</literal> (para que o <command>nmap</command> tente identificar as versões dos softwares no servidor que ele encontrar) seguido de um ou mais endereços IP ou nomes DNS das máquinas a escanear. Novamente, existem muitas outras opções para refinar o comportamento do <command>nmap</command>; por favor veja a documentação na página de manual <citerefentry> <refentrytitle>nmap</refentrytitle>
				 <manvolnum>1</manvolnum> </citerefentry>.
			</para>
			 
<screen role="scale" width="80">
<computeroutput># </computeroutput><userinput>nmap mirtuel</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET
Nmap scan report for mirtuel (192.168.1.242)
Host is up (0.000013s latency).
rDNS record for 192.168.1.242: mirtuel.internal.placard.fr.eu.org
Not shown: 998 closed ports
PORT    STATE SERVICE
22/tcp  open  ssh
111/tcp open  rpcbind

Nmap done: 1 IP address (1 host up) scanned in 2.41 seconds
# </computeroutput><userinput>nmap -A localhost</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000013s latency).
Other addresses for localhost (not scanned): 127.0.0.1
Not shown: 997 closed ports
PORT    STATE SERVICE VERSION
22/tcp  open  ssh     OpenSSH 6.7p1 Debian 3 (protocol 2.0)
|_ssh-hostkey: ERROR: Script execution failed (use -d to debug)
25/tcp  open  smtp    Exim smtpd 4.84
| smtp-commands: mirtuel Hello localhost [127.0.0.1], SIZE 52428800, 8BITMIME, PIPELINING, HELP, 
|_ Commands supported: AUTH HELO EHLO MAIL RCPT DATA NOOP QUIT RSET HELP 
111/tcp open  rpcbind 2-4 (RPC #100000)
| rpcinfo: 
|   program version   port/proto  service
|   100000  2,3,4        111/tcp  rpcbind
|   100000  2,3,4        111/udp  rpcbind
|   100024  1          36568/tcp  status
|_  100024  1          39172/udp  status
Device type: general purpose
Running: Linux 3.X
OS CPE: cpe:/o:linux:linux_kernel:3
OS details: Linux 3.7 - 3.15
Network Distance: 0 hops
Service Info: Host: mirtuel; OS: Linux; CPE: cpe:/o:linux:linux_kernel

OS and Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 11.54 seconds
</computeroutput></screen>
			 <para>
				Como esperado, as aplicações SSH e Exim4 estão listadas. Note que nem todas as aplicações escutam em todos os endereços IP; como o Exim4 só é acessível pela interface loopback <literal>lo</literal>, ele só aparece durante uma análise do <literal>localhost</literal> e não quando se escaneia o <literal>mirtuel</literal> (que é mapeado na interface <literal>eth0</literal> na mesma máquina).
			</para>

		</section>
		 <section id="sect.sniffers">
			<title>Sniffers: <command>tcpdump</command> e <command>wireshark</command></title>
			 <para>
				Às vezes, é preciso olhar o que realmente acontece no fio, pacote a pacote. Nesses casos é necessário invocar um “analizador de quadro”, mais comumente conhecido como <emphasis>sniffer</emphasis>. Uma ferramenta dessas observa todos os pacotes que chegam em uma determinada interface de rede, e os exibe de uma maneira amigável.
			</para>
			 <indexterm>
				<primary><command>tcpdump</command></primary>
			</indexterm>
			 <para>
				A venerável ferramenta neste domínio é o <command>tcpdump</command>, disponível como ferramenta padrão em uma grande variedade de plataformas. Ela permite muitos tipos de captura de tráfego de rede, mas a representação desse tráfego se mantém obscura. Nós então não iremos descrevê-la muito detalhadamente.
			</para>
			 <indexterm>
				<primary><command>wireshark</command></primary>
			</indexterm>
			 <para>
				Uma ferramenta mais recente (e mais moderna), <command>wireshark</command> (do pacote <emphasis role="pkg">wireshark</emphasis>), se tornou a nova referência em análise de tráfego de rede devido a seus vários módulos de "decoding" que permitem uma análise simplificada dos pacotes capturados. Os pacotes são exibidos graficamente organizados com base nas camadas de protocolo. Isso permite ao usuário visualizar todos os protocolos envolvidos em um pacote. Por exemplo, dado um pacote contendo uma requisição HTTP, o <command>wireshark</command> exibe, separadamente, a informação referente a camada física, camada Ethernet, informação do pacote IP, parâmetros de conexão TCP, e finalmente a própria requisição HTTP.
			</para>
			 <figure id="figure.wireshark">
				<title>O analisador de tráfego de rede <command>wireshark</command></title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/wireshark.png" format="PNG" scalefit="1" width="75%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <para>
				Em nosso exemplo, os pacotes que viajam pelo SSH são filtrados (pelo filtro <literal>!tcp.port == 22</literal>). O pacote exibido no momento foi desenvolvido na camada HTTP.
			</para>
			 <sidebar> <title><emphasis>DICA</emphasis> <command>wireshark</command> sem interface gráfica: <command>tshark</command></title>
			 <indexterm>
				<primary><command>tshark</command></primary>
			</indexterm>
			 <para>
				Se não for possível executar a interface gráfica, ou se não se quer fazer isso por uma razão qualquer, uma versão modo texto do <command>wireshark</command> também existe sob o nome de <command>tshark</command> (em um pacote separado <emphasis role="pkg">tshark</emphasis>). A maioria dos recursos de captura e "decoding" ainda estão disponíveis, mas a ausência da interface gráfica necessariamente limita as interações com o programa (a filtragem de pacotes depois de terem sido capturados, rastreio de uma dada conexão TCP, e assim por diante). Mas ele ainda pode ser usado como primeira abordagem. Se manipulações mais profundas forem pretendidas e requererem a interface gráfica, os pacotes podem ser salvos em um arquivo e esse arquivo pode ser carregado no <command>wireshark</command> gráfico que está sendo executado em outra máquina.
			</para>
			 </sidebar>
		</section>

	</section>
</chapter>

