<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="debian-packaging" lang="pt-BR">
	<chapterinfo>
		 <keywordset>
			<keyword>Backport</keyword>
			 <keyword>Reconstruir</keyword>
			 <keyword>Pacote fonte</keyword>
			 <keyword>Arquivo</keyword>
			 <keyword>Meta-pacote</keyword>
			 <keyword>Desenvolvedor Debian</keyword>
			 <keyword>Mantenedor</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Criando um Pacote Debian</title>
	 <highlights> <para>
		É muito comum, para um administrador que vem lidando com pacotes Debian de maneira regular, sentir eventualmente a necessidade de criar o seu próprio pacote, ou modificar um pacote existente. Este capítulo tem a intenção de responder as questões mais comuns neste campo, e dar os elementos necessários para tirar vantagem da infraestrutura do Debian da melhor maneira possível. Com alguma sorte, após testar sua mão em pacotes locais, você sinta a necessidade de se aprofundar e eventualmente juntar-se até mesmo ao projeto Debian!
	</para>
	 </highlights> <section id="sect.rebuilding-package">
		<title>Reconstruindo um Pacote a partir de suas Fontes</title>
		 <para>
			Reconstruir um pacote binário é necessário sob diversas circunstâncias. Em alguns casos, o administrador precisa de uma funcionalidade que necessita que o programa seja compilado a partir de suas fontes, com uma opção particular de compilação; em outras, o programa empacotado na versão instalada do Debian não é suficientemente recente. Em último caso, o administrador irá usualmente construir um pacote mais recente retirado de uma versão mais recente do Debian — como <emphasis role="distribution">Testing</emphasis> ou até mesmo <emphasis role="distribution">Unstable</emphasis> — então este novo pacote funcionará em sua distribuição <emphasis role="distribution">Stable</emphasis>; esta operação é chamada “backporting”. Como de costume, alguma cautela deve ser tomada, antes de se empreender essa tarefa, para verificar se isto já não foi feito anteriormente — uma rápida olhada na página de Rastreamento de Pacote Debian para esse pacote irá revelar essa informação. <ulink type="block" url="https://tracker.debian.org/" /> <indexterm><primary>backport</primary></indexterm>
		</para>
		 <section>
			<title>Pegando os Fontes</title>
			 <para>
				Reconstruir um pacote Debian começa com a obtenção de seu código fonte. A maneira mais fácil é usar o comando <command>apt-get source<replaceable> nome-do-pacote-fonte</replaceable></command>. Este comando requer uma linha <literal>deb-src</literal> no arquivo <filename>/etc/apt/sources.list</filename>, e os arquivos de índice atualizados (ou seja <command>apt-get update</command>). Estas condições já devem estar resolvidas se você seguiu as instruções no capítulo sobre a configuração do APT (veja em <xref linkend="sect.apt-sources.list" />). Note, no entanto, que você estará baixando os pacotes fonte da versão Debian mencionada na linha <literal>deb-src</literal>. Se você precisa de uma outra versão, você pode precisar baixá-lo manualmente a partir de um dos espelho Debian ou a partir do web site. Trata-se de buscar dois ou três arquivos (com extensões <filename>*.dsc</filename> - para <emphasis>Debian Source Control</emphasis> (Controle do Fonte Debian) - <filename>*.tar.<replaceable>comp</replaceable></filename>, e algumas vezes <filename>*.diff.gz</filename> ou <filename>*.debian.tar.<replaceable>comp</replaceable></filename> - <replaceable>comp</replaceable> tendo um valor entre <literal>gz</literal>, <literal>bz2</literal> ou <literal>xz</literal>, dependendo da ferramenta de compressão em uso), em seguida, executando o comando <command>dpkg-source -x<replaceable> arquivo.dsc</replaceable></command>. Se o arquivo <filename>*.dsc</filename> é diretamente acessível em uma determinada URL, há uma maneira ainda mais simples para buscar tudo, com o comando <command>dget <replaceable>URL</replaceable></command>. Este comando (que pode ser encontrado no pacote <emphasis role="pkg">devscripts</emphasis>) obtém o arquivo <filename>*.dsc</filename> no endereço fornecido, então analisa o seu conteúdo e vai buscar automaticamente o arquivo, ou arquivos, referenciados nele. Uma vez que tudo tenha sido baixado, ele extrai o pacote fonte (a menos que a opção <literal>-d</literal> ou <literal>--download-only</literal> seja usada).
			</para>

		</section>
		 <section>
			<title>Fazendo Alterações</title>
			 <para>
				O fonte do pacote está agora disponível em um diretório com o nome baseado no pacote fonte e sua versão (por exemplo, <emphasis>samba-4.1.17+dfsg</emphasis>); este é o lugar onde nós vamos trabalhar em nossas mudanças locais.
			</para>
			 <para>
				A primeira coisa a se fazer é mudar o número de versão do pacote, para que a reconstrução possa ser diferenciada dos pacotes originais fornecidos pelo Debian. Assumindo que a versão atual é <literal>2:4.1.17+dfsg-2</literal>, nós podemos criar uma versão <literal>2:4.1.17+dfsg-2falcot1</literal>, que claramente indica a origem do pacote. Isto faz com que a versão do pacote seja maior do que a provida pelo Debian, então o pacote facilmente instalará como se fosse uma atualização do pacote original. Tal alteração é melhor realizada com o comando <command>dch</command> (<emphasis>Debian CHangelog</emphasis>) do pacote <emphasis role="pkg">devscripts</emphasis>, com um comando <command>dch --local falcot</command>. Isso chama um editor de texto (<command>sensible-editor</command> — este deveria ser seu editor de textos favorito se for mencionado na variável de ambiente <varname>VISUAL</varname> ou <varname>EDITOR</varname>, e o editor padrão de outra forma) para permitir a documentação das diferenças trazidas por esta reconstrução. Este editor nos mostra que <command>dch</command> realmente modificou o arquivo <filename>debian/changelog</filename>.
			</para>
			 <para>
				Quando mudanças nas opções de construção são necessárias, as mudanças precisam ser feitas em <filename>debian/rules</filename>, que controla os passos para o processo de construção do pacote. Nos casos mais simples, as linhas relativas às configurações iniciais (<literal>./configure …</literal>) ou à construção em si (<literal>$(MAKE) …</literal> ou <literal>make …</literal>) são fáceis de achar. Se estes comandos não são explicitamente chamados, eles provavelmente são efeitos colaterais de outro comando explícito. Em qualquer dos casos, por favor verifique a documentação para aprender mais sobre como modificar o comportamento padrão. Com pacotes usando o <command>dh</command>, você talvez precise adicionar um "overridde" para os comandos <command>dh_auto_configure</command> ou <command>dh_auto_build</command> (veja suas respectivas páginas de manual para explicações de como fazer isso).
			</para>
			 <para>
				Dependendo das mudanças locais nos pacotes, uma atualização talvez seja necessária no arquivo <filename>debian/control</filename> , o qual contém uma descrição dos pacotes gerados. Em particular, este arquivo contém linhas <literal>Build-Depends</literal> que controlam uma lista de dependências que devem ser satisfeitas durante a construção do pacote. Estas geralmente se referem a versões de pacotes contidos na distribuição da qual o pacote fonte veio, mas que talvez não estejam disponíveis na distribuição utilizada na reconstrução. Não há maneira automática para determinar se uma dependência é real ou apenas especificada para garantir que a construção seja apenas tentada com a última versão da biblioteca — esta é a única maneira de se forçar um <emphasis>autobuilder (construtor automático)</emphasis> a usar um dado pacote durante a construção, eis o porque dos mantenedores Debian frequentemente utilizarem versões restritas das dependências de construção.
			</para>
			 <para>
				Se você tem certeza de que estas dependências de compilação são muito rigorosas, você deve se sentir livre para relaxá-las localmente. Lendo os arquivos que documentam a forma padrão de construção do software - esses arquivos são chamados frequentemente <filename>INSTALL</filename> - irá ajudar você a descobrir as dependências apropriadas. Idealmente, todas as dependências devem ser satisfeitas a partir da distribuição utilizada para a reconstrução, se não forem, um processo recursivo começa, onde os pacotes mencionados no campo <literal>Build-Depends</literal> devem passar por um "backport" antes do pacote alvo. Alguns pacotes podem não precisar de "backport", e podem ser instalados como estão durante o processo de criação (um exemplo notável é <emphasis role="pkg">debhelper</emphasis>). Note que o processo de backport pode rapidamente tornar-se complexo, se você não for cuidadoso. Portanto, backports devem ser mantidos a um mínimo o mais estrito possível.
			</para>
			 <sidebar> <title><emphasis>DICA</emphasis> Instalando <literal>Build-Depends</literal></title>
			 <indexterm>
				<primary><literal>Build-Depends</literal>, campo de controle</primary>
			</indexterm>
			 <para>
				<command>apt-get</command> permite instalar todos os pacotes mencionados nos campos <literal>Build-Depends</literal> de um pacote fonte disponível em uma distribuição mencionada na linha <literal>deb-src</literal> no arquivo <filename>/etc/apt/sources.list</filename>. Isto é uma questão de simplesmente executar o comando <command>apt-get build-dep <replaceable>source-package</replaceable></command>.
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>Começando a Reconstrução</title>
			 <para>
				Quando todas as mudanças necessárias forem aplicadas aos fontes, podemos começar a gerar o verdadeiro pacote binário (arquivo <filename>.deb</filename>). Todo o processo é gerenciado pelo comando <command>dpkg-buildpackage</command>.
			</para>
			 <example>
				<title>Reconstruindo um pacote</title>
				 
<screen><computeroutput>$ </computeroutput><userinput>dpkg-buildpackage -us -uc
</userinput><computeroutput>[...]
</computeroutput></screen>

			</example>
			 <sidebar id="sidebar.fakeroot"> <title><emphasis>FERRAMENTA</emphasis> <command>fakeroot</command></title>
			 <para>
				Essencialmente, o processo de criação de pacotes é simplesmente uma questão de coletar em um arquivo compactado um conjunto de arquivos existentes (ou construídos); a maioria dos arquivos irá acabar sendo de posse do <emphasis>root</emphasis> no arquivo compactado. Entretanto, construir um pacote inteiro usando este usuário implicaria em riscos maiores; felizmente, isto pode ser evitado com o comando <command>fakeroot</command>. Esta ferramenta pode ser usada para executar um programa e dá-lo a impressão de que é executado como <emphasis>root</emphasis> e cria arquivos com posse e permissões arbitrárias. Quando o programa cria o arquivo que se tornará o pacote Debian, ele acha que está criando um arquivo compactado contendo arquivos marcados como pertencendo a usuário arbitrários, incluindo o <emphasis>root</emphasis>. Esta configuração é tão conveniente que o <command>dpkg-buildpackage</command> usa o <command>fakeroot</command> por padrão quando cria pacotes.
			</para>
			 <para>
				Note que o programa é somente levado a crer que está operando com uma conta privilegiada, e o processo de fato é executado como o usuário que executou o <command><replaceable>programa</replaceable> fakeroot</command> (e os arquivos são na verdade criados com as permissões daquele usuário). Em nenhum momento ele realmente consegue privilégios de root dos quais poderia abusar.
			</para>
			 </sidebar> <para>
				O comando anterior pode falhar se os campos <literal>Build-Depends</literal> não foram atualizados, ou se os pacotes relacionados estiverem instalados. Neste caso, é possível anular esta verificação passando a opção <literal>-d</literal> para o <command>dpkg-buildpackage</command>. Entretanto, ignorar explicitamente essas dependências cria-se o risco do processo de construção falhar em um estágio seguinte. Pior, o pacote pode parecer corretamente construído mas não executar corretamente: alguns programas automaticamente desabilitam algumas de suas funcionalidades quando uma biblioteca necessária não está disponível em tempo de construção.
			</para>
			 <para>
				Na maioria das vezes, os desenvolvedores Debian usam um programa de alto nível como o <command>debuild</command>; ele executa o <command>dpkg-buildpackage</command> como de costume, mas também inclui uma invocação de um programa que executa diversas verificações para validar a geração dos pacotes de acordo com a política do Debian. Este script também limpa o ambiente para que variáveis locais não "poluam" a construção do pacote. O comando <command>debuild</command> é umas das ferramentas da suíte <emphasis>devscripts</emphasis>, que divide alguma consistência e configuração para tornar as tarefa dos mantenedores mais fácil.
			</para>
			 <sidebar> <title><emphasis>OLHADA RÁPIDA</emphasis> <command>pbuilder</command></title>
			 <indexterm>
				<primary><command>pbuilder</command></primary>
			</indexterm>
			 <para>
				O comando <command>pbuilder</command> (no pacote de mesmo nome) permite a construção de um pacote Debian em um ambiente <emphasis>chroot (enjaulado)</emphasis>. Ele primeiramente cria um diretório temporário contendo um sistema mínimo necessário para a construção do pacote (incluindo os pacotes mencionados no campo <emphasis>Build-Depends</emphasis>). Este diretório é então usado como diretório raiz (<filename>/</filename>), utilizando o comando <command>chroot</command>, durante a fase de construção.
			</para>
			 <para>
				Esta ferramenta permite que processo de construção aconteça em um ambiente que não foi alterado pelo usuário. Também permite uma detecção rápida de alguma dependência de construção (build-dependency) perdida (já que a construção irá falhar a não ser que as dependências apropriadas estejam documentadas). Finalmente, ele permite a construção de um pacote para uma versão do Debian diferente do sistema por completo: a máquina pode estar utilizando <emphasis role="distribution">Stable</emphasis> para seu trabalho normal, e um <command>pbuilder</command> rodando na mesma máquina pode estar utilizando <emphasis role="distribution">Unstable</emphasis> para a construção dos pacotes.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.building-first-package">
		<title>Construindo seu Primeiro Pacote</title>
		 <section>
			<title>Meta-pacotes ou Falsos Pacotes</title>
			 <para>
				Pacotes falsos e meta-pacotes são similares, ambos são caixas vazias que existem apenas pelo efeito que seus metadados fazem na pilha de gerenciamento de pacotes.
			</para>
			 <para>
				O propósito de um pacote falso é enganar o <command>dpkg</command> e o <command>apt</command> para acreditarem que algum pacote está instalado mesmo que em realidade seja apenas uma caixa vazia. Isto permite satisfazer dependências num pacote quando o programa correspondente foi instalado fora do escopo do sistema de pacotes. Este método funciona, porém deve mesmo assim ser evitado sempre que possível, já que não existem garantias de que o programa instalado manualmente se comportará exatamente como o pacote correspondente faria e outros pacotes dependentes dele podem não funcionar corretamente.
			</para>
			 <para>
				De outra maneira, um meta-pacote existe em sua maioria como uma coleção de dependências, então instalar um meta-pacote é na verdade instalar um conjunto de pacotes em um único passo.
			</para>
			 <para>
				Ambos os tipos de pacotes podem ser criados pelos comandos <command>equivs-control</command> e <command>equivs-build</command> (do pacote <emphasis role="pkg">equivs</emphasis>). O comando <command>equivs-control <replaceable>arquivo</replaceable></command> cria um arquivo de cabeçalho de pacote Debian que deve ser editado para conter o nome do pacote desejado, seu número de versão, o nome do mantenedor, suas dependências e sua descrição. Outros campos, sem um valor padrão são opcionais e podem ser excluídos. Os campos <literal>Copyright</literal>, <literal>Changelog</literal>, <literal>Readme</literal> e <literal>Extra-Files</literal> não são campos padrões em pacotes Debian; eles só fazem sentido no âmbito da <command>equivs-build</command>, e eles não serão mantidos nos cabeçalhos do pacote gerados.
			</para>
			 <example>
				<title>Arquivo de cabeçalho do pacote falso <emphasis>libxml-libxml-perl</emphasis></title>
				 
<programlisting>
Section: perl
Priority: optional
Standards-Version: 3.9.6

Package: libxml-libxml-perl
Version: 2.0.116-1
Maintainer: Raphael Hertzog &lt;hertzog@debian.org&gt;
Depends: libxml2 (&gt;= 2.7.4)
Architecture: all
Description: Fake package - módulo instalado manualmente em site_perl
  Este é um pacote falso para deixar o sistema de empacotamento
  acreditando que este pacote Debian está instalado.
 .
Na verdade, o pacote não está instalado desde uma versão mais recente
  do módulo que foi manualmente compilada &amp; instalada no
  diretório site_perl.</programlisting>

			</example>
			 <para>
				O próximo passo é gerar o pacote Debian com o comando <command>equivs-build <replaceable>arquivo</replaceable></command>. Voilà: o pacote foi criado no diretório atual e pode ser manejado como qualquer outro pacote Debian seria.
			</para>

		</section>
		 <section>
			<title>Depósito Simples de Arquivos</title>
			 <para>
				Os administradores da Falcot Corp precisam criar um pacote Debian para facilitar a instalação de um conjunto de documentos em um grande número de máquina. O administrador responsável por essa tarefa primeiramente lê o “New Maintainer's Guide”, e então começa a trabalhar no seu primeiro pacote. <ulink type="block" url="https://www.debian.org/doc/manuals/maint-guide/" />
			</para>
			 <para>
				O primeiro passo é criar um diretório <filename>falcot-data-1.0</filename> que conterá o pacote fonte. O pacote irá, logicamente, ser chamado de <literal>falcot-data</literal> e terá o número de versão <literal>1.0</literal>. O administrador então coloca os documentos em um subdiretório <filename>data</filename>. Então ele chama o comando <command>dh_make</command> (do pacote <emphasis role="pkg">dh-make</emphasis>) para adicionar os arquivos necessários para o processo de criação do pacote, o qual será armazenado em um subdiretório <filename>debian</filename>:
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cd falcot-data-1.0</userinput>
<computeroutput>$ </computeroutput><userinput>dh_make --native</userinput>
<computeroutput>
Type of package: single binary, indep binary, multiple binary, library, kernel module, kernel patch or cdbs?
 [s/i/m/l/k/n] </computeroutput><userinput>i</userinput><computeroutput>
Maintainer name : Raphael Hertzog
Email-Address   : hertzog@debian.org
Date            : Fri, 04 Sep 2015 12:09:39 -0400
Package Name    : falcot-data
Version         : 1.0
License         : gpl3
Type of Package : Independente
Pressione &lt;enter&gt; para confirmar:
Atualmente não há nível superior Makefile. Isto pode exigir um ajuste adicional.
Feito. Por favor, edite os arquivos no agora debian/subdiretório. Você também deve
verificar se o instalador falcot-data Makefiles  em $DESTDIR e não em /.
$</computeroutput></screen>
			 <para>
				O tipo de pacote escolhido (<emphasis>indep binary</emphasis>) indica que este pacote fonte irá gerar um único pacote binário que pode ser compartilhado entre todas as arquiteturas (<literal>Arquitetura: all</literal>). <emphasis>single binary</emphasis> atua como contraparte, e leva a um único pacote binário que é dependente da arquitetura alvo (<literal> Arquitetura: any</literal>). Neste caso, a primeira escolha é mais relevante uma vez que o pacote contém apenas os documentos e não programas binários, para que possa ser usado de forma semelhante em computadores de todas as arquiteturas.
			</para>
			 <indexterm>
				<primary>tipos de pacote</primary>
			</indexterm>
			 <indexterm>
				<secondary>tipos</secondary>
				 de <primary>pacote</primary>
			</indexterm>
			 <para>
				O tipo <emphasis>múltiplo binário</emphasis> corresponde a um pacote fonte levando a vários pacotes binários. Um caso particular, <emphasis>biblioteca</emphasis>, é útil para bibliotecas compartilhadas, uma vez que precisa seguir regras rígidas do empacotamento. De forma semelhante, <emphasis>módulo do kernel</emphasis> ou <emphasis>kernel patch</emphasis> devem ser restritos aos pacotes contendo módulos do kernel.
			</para>
			 <sidebar> <title><emphasis>DICA</emphasis> Nome e endereço de e-mail do mantenedor</title>
			 <para>
				A maioria dos programas envolvidos em manutenção de pacotes irá procurar seu nome e endereço de e-mail no <varname>DEBFULLNAME</varname> e <varname>DEBEMAIL</varname> ou nas variáveis de ambiente <varname>EMAIL</varname>. Defini-los de uma vez por todas vai evitar que você tenha de digitá-los várias vezes. Se seu shell usual é o <command>bash</command>, é uma simples questão de adicionar as duas linhas seguintes em seu aquivo <filename>~/.bashrc</filename> (você obviamente substitui os valores com os mais relevantes!):
			</para>
			 
<programlisting>
export EMAIL="hertzog@debian.org"
export DEBFULLNAME="Raphael Hertzog"</programlisting>
			 </sidebar> <para>
				O comando <command>dh_make</command> criou uma pasta <filename>debian</filename> com muitos arquivos. Alguns são necessários, em particular <filename>rules</filename>, <filename>control</filename>, <filename>changelog</filename> e <filename>copyright</filename>. Arquivos com extensão <filename>.ex</filename> são exemplos de arquivos que podem ser utilizados, modificando-os (e removendo a extensão), se for o caso. Quando eles não são necessários, entao é recomendado removê-los. O arquivo <filename>compat</filename> deve ser mantido, uma vez que é necessário para o funcionamento correto do conjunto de programas <emphasis>debhelper</emphasis> (todos começando com o prefixo <command> dh_</command>) utilizado em diferentes estágios do processo de construção do pacote.
			</para>
			 <para>
				O arquivo <filename>copytight</filename> (direitos autorais) deve conter informações sobre os autores dos documentos incluídos no pacote, e as licenças relacionadas. No nosso caso, estes são documentos internos e sua utilização é limitada para dentro da empresa Falcot Corp. O arquivo <filename>changelog</filename> padrão é geralmente apropriado; substituir o "lançamento inicial" com uma explicação mais detalhada e alterar da distribuição <literal>instável</literal> para <literal>interna</literal> é suficiente . O arquivo <filename>control</filename> também foi atualizado: o campo <literal>Section</literal> foi alterado para <emphasis>misc</emphasis> e os campos <literal>Homepage</literal>, <literal>Vcs-Git</literal> e <literal>Vcs-Browser</literal> foram removidos. O campo <literal>Depends</literal> foi completado com <literal>iceweasel | www-browser</literal>, de modo a assegurar a disponibilidade de um navegador web capaz de exibir os documentos contidos no pacote.
			</para>
			 <example>
				<title>O arquivo <filename>control</filename></title>
				 
<programlisting>
Source: falcot-data
Section: misc
Priority: optional
Maintainer: Raphael Hertzog &lt;hertzog@debian.org&gt;
Build-Depends: debhelper (&gt;= 9)
Standards-Version: 3.9.5

Package: falcot-data
Architecture: all
Depends: iceweasel | www-browser, ${misc:Depends}
Description: Internal Falcot Corp Documentation
 This package provides several documents describing the internal
 structure at Falcot Corp.  This includes:
  - organization diagram
  - contacts for each department.
 .
 These documents MUST NOT leave the company.
 Their use is INTERNAL ONLY.</programlisting>

			</example>
			 <example>
				<title>O arquivo <filename>changelog</filename></title>
				 
<programlisting>
falcot-data (1.0) internal; urgency=low

  * Initial Release.
  * Let's start with few documents:
    - internal company structure;
    - contacts for each department.

 -- Raphael Hertzog &lt;hertzog@debian.org&gt;  Fri, 04 Sep 2015 12:09:39 -0400</programlisting>

			</example>
			 <example>
				<title>O arquivo <filename>copyright</filename></title>
				 
<programlisting>
Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
Upstream-Name: falcot-data

Files: *
Copyright: 2004-2015 Falcot Corp
License: 
 All rights reserved.</programlisting>

			</example>
			 <sidebar> <title><emphasis>DE VOLTA AO BÁSICO</emphasis> arquivo <filename>Makefile</filename></title>
			 <indexterm>
				<primary><filename>Makefile</filename></primary>
			</indexterm>
			 <para>
				Um arquivo <filename>Makefile</filename> é um roteiro usado pelo programa <command>make</command>; ele descreve regras para a construção de um conjunto de arquivos a partir de uma árvore de dependências entre si (por exemplo, um programa pode ser construído a partir de um conjunto de arquivos fonte). Os arquivos <filename>Makefile</filename> descrevem essas regras no seguinte formato:
			</para>
			 
<programlisting>
alvo: fonte1 fonte2 ...
        comando1
        comando2</programlisting>
			 <para>
				A interpretação dessas regras é como segue: se um dos arquivos <literal>fonte*</literal> é mais recente do que o arquivo <literal>alvo</literal>, então o alvo precisará ser gerado, usando <command>comando1</command> e <command>comando2</command>.
			</para>
			 <para>
				Note que as linhas com comandos devem começar com um caractere de tabulação, também note que quando uma linha de comando começa com um traço (<literal>-</literal>), a falha do comando não interromperá o processo por inteiro.
			</para>
			 </sidebar> <para>
				O arquivo <filename>rules</filename> geralmente contém um conjunto de regras usado para configurar, construir e instalar o software em um subdiretório específico (nomeado de acordo com o pacote binário gerado). O conteúdo desta pasta é depois arquivado dentro do pacote Debian, como se fosse a raiz do sistema de arquivos. No nosso caso, os arquivos serão instalados na pasta <filename>debian/falcot-data/usr/share/falcot-data/</filename>, para que a instalação do pacote gerado implante os arquivos em <filename>/usr/share/falcot-data/</filename>. O arquivo <filename>rules</filename> é utilizado como um <filename>Makefile</filename>, com alguns alvos padrões (incluindo<literal>clean</literal> e <literal>binary</literal>, utilizados, respectivamente, para limpar a pasta de origem e gerar o pacote binário).
			</para>
			 <para>
				Embora esse arquivo seja o coração do processo, cada vez mais ele contém somente a informação mínima para executar um conjunto padrão de comandos provido pela ferramenta <command>debhelper</command>. Tal é o cado dos arquivos gerados pelo <command>dh_make</command>. Para instalar nossos arquivos, nós simplesmente configuramos o comportamento do comando <command>dh_install</command> criando o seguinte arquivo <filename>debian/falcot-data.install</filename>:
			</para>
			 
<programlisting>
data/* usr/share/falcot-data/</programlisting>
			 <para>
				Neste ponto, o pacote pode ser criado. Nós no entanto vamos adicionar um toque especial. Já que os administradores querem que os documentos sejam facilmente acessados a partir dos menus dos ambientes de trabalho gráficos, nós adicionamos um arquivo <filename>falcot-data.desktop</filename> e o instalaremos em <filename>/usr/share/applications</filename> através da adição de uma segunda linha em <filename>debian/falcot-data.install</filename>.
			</para>
			 <example>
				<title>O arquivo <filename>falcot-data.desktop</filename></title>
				 
<programlisting>
[Desktop Entry]
Name=Internal Falcot Corp Documentation
Comment=Starts a browser to read the documentation
Exec=x-www-browser /usr/share/falcot-data/index.html
Terminal=false
Type=Application
Categories=Documentation;</programlisting>

			</example>
			 <para>
				O <filename>debian/falcot-data.install</filename> atualizado se parece com isso:
			</para>
			 
<programlisting>
data/* usr/share/falcot-data/
falcot-data.desktop usr/share/applications/</programlisting>
			 <para>
				Nosso pacote fonte está pronto. Agora só falta gerar um pacote binário, com o mesmo método que usamos anteriormente para reconstruir pacotes: executamos o comando <command>dpkg-buildpackage -us -uc</command> de dentro do diretório <filename>falcot-data-1.0</filename>.
			</para>

		</section>

	</section>
	 <section id="sect.setup-apt-package-repository">
		<title>Criando um Repositório de Pacotes para o APT</title>
		 <indexterm>
			<primary>arquivamento de pacotes</primary>
		</indexterm>
		 <indexterm>
			<primary>pacote de</primary>
			<secondary>arquivamento</secondary>
			<tertiary>Debian</tertiary>
		</indexterm>
		 <para>
			A Falcot Corp gradualmente começou a manter alguns pacotes Debian modificados localmente a partir de pacotes existentes ou criados do zero para distribuir dados e programas internos.
		</para>
		 <para>
			Para facilitar a instalação, eles querem integrar estes pacotes em um repositório que possa ser acessado diretamente usando a ferramenta APT. Por motivos de manutenção óbvios, eles querem separar os pacotes internos dos pacotes reconstruídos localmente. O objetivo é ter as entradas correspondentes no arquivo <filename>/etc/apt/sources.list.d/falcot.list</filename> como segue:
		</para>
		 
<programlisting>
deb http://packages.falcot.com/ updates/
deb http://packages.falcot.com/ internal/</programlisting>
		 <indexterm>
			<primary><command>mini-dinstall</command></primary>
		</indexterm>
		 <para>
			Os administradores, portanto, configuram uma máquina virtual em seu servidor HTTP interno, com <filename>/srv/vhosts/packages/</filename> como a raiz do espaço web associado. A gestão do repositório é delegada ao comando <command>mini-dinstall</command> (no pacote de mesmo nome). Esta ferramenta mantém um olho em um diretório <filename>incoming/</filename> (no nosso caso, <filename>/srv/vhosts/packages/mini-dinstall/incoming/</filename>) e espera por novos pacotes lá; quando um pacote for carregado, ele é instalado em um repositório Debian em <filename>/srv/vhosts/packages/</filename>. O comando <command>mini-dinstall</command> lê o arquivo <filename>*.changes</filename> criado quando o pacote Debian é gerado. Esses arquivos contêm uma lista de todos os outros arquivos associados com a versão do pacote (<filename>*.deb</filename>, <filename>*.dsc</filename>, <filename>*.diff.gz</filename>/<filename>*.debian.tar.gz</filename>, <filename>*.orig.tar.gz</filename>, ou seus equivalentes com outras ferramentas de compressão), e que permitem <command>mini-dinstall</command> saber quais arquivos instalar. Arquivos <filename>*.changes</filename> também contêm o nome da distribuição alvo (muitas vezes <literal>unstable</literal>) mencionado na última entrada <filename>debian/changelog</filename>, e <command>mini-dinstall</command> usa essas informações para decidir onde o pacote deve ser instalado. É por isso que os administradores devem sempre alterar este campo antes de construir um pacote, e configurá-lo para <literal>internal</literal> ou <literal>updates</literal>, dependendo da localização do alvo. O <command>mini-dinstall</command> gera, então, os arquivos necessários para o APT, como o <filename>Packages.gz</filename>.
		</para>
		 <sidebar> <title><emphasis>ALTERNATIVA</emphasis> <command>apt-ftparchive</command></title>
		 <indexterm>
			<primary><command>apt-ftparchive</command></primary>
		</indexterm>
		 <para>
			Se <command>mini-dinstall</command> parece demasiado complexo para as suas necessidades de empacotamento Debian, você também pode usar o comando <command>apt-ftparchive</command>. Esta ferramenta verifica o conteúdo de um diretório e exibe (em sua saída padrão) um arquivo <filename>Packages</filename> correspondente. No caso da Falcot Corp, os administradores podem carregar os pacotes diretamente em <filename>/srv/vhosts/packages/updates/</filename> ou <filename>/srv/vhosts/packages/internal/</filename>, em seguida, executar os seguintes comandos para criar os arquivos <filename>Packages.gz</filename>:
		</para>
		 
<screen>
<computeroutput>$ </computeroutput><userinput>cd /srv/vhosts/packages</userinput>
<computeroutput>$ </computeroutput><userinput>apt-ftparchive packages updates &gt;updates/Packages</userinput>
<computeroutput>$ </computeroutput><userinput>gzip updates/Packages</userinput>
<computeroutput>$ </computeroutput><userinput>apt-ftparchive packages internal &gt;internal/Packages</userinput>
<computeroutput>$ </computeroutput><userinput>gzip internal/Packages</userinput></screen>
		 <para>
			O comando <command>apt-ftparchive sources</command> permite criar arquivos <filename>Sources.gz</filename> de maneira similar.
		</para>
		 </sidebar> <para>
			Para configurar o <command>mini-dinstall</command> é necessário a configuração do arquivo <filename>~/.mini-dinstall.conf</filename>; no caso da Falcot Corp, o conteúdo é o seguinte:
		</para>
		 
<programlisting>
[DEFAULT]
archive_style = flat
archivedir = /srv/vhosts/packages

verify_sigs = 0
mail_to = admin@falcot.com

generate_release = 1
release_origin = Falcot Corp
release_codename = stable

[updates]
release_label = Recompiled Debian Packages

[internal]
release_label = Internal Packages</programlisting>
		 <para>
			Uma decisão que merece atenção é a geração de arquivos <filename>Release</filename> para cada pacote. Isso pode ajudar a gerenciar as prioridades de instalação de pacotes usando o arquivo de configuração <filename>/etc/apt/preferences</filename> (veja em <xref linkend="sect.apt.priorities" /> para detalhes).
		</para>
		 <sidebar> <title><emphasis>SEGURANÇA</emphasis> <command>mini-dinstall</command> e permissões</title>
		 <para>
			Como o <command>mini-dinstall</command> foi concebido para ser executado como um usuário normal, não há necessidade de executá-lo como root. A maneira mais fácil é configurar tudo dentro da conta de usuário que pertence ao administrador encarregado de criar os pacotes Debian. Uma vez que apenas este administrador tem as permissões necessárias para colocar os arquivos no directório <filename>incoming/</filename>, podemos deduzir que o administrador autenticou a origem de cada pacote antes da publicação e o <command>mini-dinstall</command> não precisam fazê-lo novamente. Isto explica o parâmetro <literal>verify_sigs = 0</literal> (o que significa que as assinaturas não precisam ser verificadas). No entanto, se o conteúdo dos pacotes é secreto, podemos inverter o cenário e eleger para autenticar com um chaveiro contendo as chaves públicas de pessoas com autorização para criar pacotes (configurados com o parâmetro <literal>extra_keyrings</literal>); <command>mini-dinstall</command> irá então verificar a origem de cada pacote de entrada através da análise da assinatura integrado para o arquivo <filename>*.changes</filename>.
		</para>
		 </sidebar> <para>
			Executar <command>mini-dinstall</command> começa, na verdade, um daemon em segundo plano. Enquanto este daemon é executado, ele irá verificar se há novos pacotes no diretório <filename>incoming/</filename> a cada meia hora; quando um novo pacote chegar, ele será movido para o repositório e os arquivos <filename>Packages.gz</filename> e <filename>Sources.gz</filename> serão restaurados. Se executar um daemon é um problema, <command>mini-dinstall</command> também pode ser chamado manualmente no modo batch (com a opção <literal>-b</literal>) cada vez que um pacote for enviado para o diretório <filename>incoming/</filename>. Outras possibilidades oferecidas pelo <command>mini-dinstall</command> estão documentadas na sua página de manual <citerefentry><refentrytitle>mini-dinstall</refentrytitle>
			 <manvolnum>1</manvolnum></citerefentry>.
		</para>
		 <sidebar> <title><emphasis>EXTRA</emphasis> Gerando um arquivo assinado</title>
		 <para>
			A suíte APT verifica uma cadeia de assinaturas criptográficas nos pacotes que ela trata, antes de instalá-los, para que se garantam suas autenticidades (veja <xref linkend="sect.package-authentication" />). Repositórios APT privados podem ser um problema, uma vez que as máquinas que os usam irão ficar exibindo alertas de pacotes não assinados. Um administrador zeloso, portanto, integrará arquivos privados com o mecanismo de APT seguro.
		</para>
		 <para>
			Para ajudar nesse processo, o <command>mini-dinstall</command> inclui uma opção de configuração <literal>release_signscript</literal> que permite especificar um script que será usado para gerar a assinatura. Um bom ponto de partida é o script <filename>sign-release.sh</filename> fornecido pelo pacote <emphasis role="pkg">mini-dinstall</emphasis> em <filename>/usr/share/doc/mini-dinstall/examples/</filename>; pode ser relevante fazer mudanças específicas.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.becoming-package-maintainer">
		<title>Tornando-se um Mantenedor de Pacotes</title>
		 <section>
			<title>Aprendendo a Fazer Pacotes</title>
			 <para>
				Criar um pacote Debian de qualidade não é sempre uma tarefa fácil, e tornar-se um mantenedor de pacote necessita aprendizado, tanto na teoria quanto na prática. Não é simplesmente uma questão de construir ou instalar programas; em vez disso, a maior parte da complexidade vem do entendimento de problemas e conflitos, e mais geralmente as interações, com a miríade de outros pacotes disponíveis.
			</para>
			 <section>
				<title>Regras</title>
				 <para>
					Um pacote Debian deve respeitar as regras precisas elaboradas na política Debian, e cada mantenedor do pacote deve conhecê-las. Não há nenhuma exigência de conhecê-las de cor, mas sim de saber que elas existem e para consultá-las sempre que uma escolha apresente uma alternativa não-trivial. Todo mantenedor Debian comete erros por não conhecer uma regra, mas isso não é um grande problema, contanto que o erro seja corrigido quando um usuário o relate com um relatório de bug (o que tende a acontecer muito em breve graças a usuários avançados). <ulink type="block" url="https://www.debian.org/doc/debian-policy/" />
				</para>

			</section>
			 <section>
				<title>Procedimentos</title>
				 <indexterm>
					<primary>Referência do desenvolvedor Debian</primary>
				</indexterm>
				 <para>
					O Debian não é uma simples coleção de pacotes individuais. O trabalho de empacotamento de cada um é parte de um projeto coletivo; ser um desenvolvedor Debian envolve saber como o projeto Debian funciona como um todo. Todo desenvolvedor irá, mais cedo ou mais tarde, interagir com os outros. O livro Referência do Desenvolvedor Debian (o pacote <emphasis role="pkg">developers-reference</emphasis>) resume o que todo desenvolvedor deve saber, a fim de interagir da melhor forma possível com as diversas equipes dentro do projeto, e para levar a melhores vantagens possíveis dos recursos disponíveis. Este documento também enumera uma série de deveres que se espera que um desenvolvedor cumpra. <ulink type="block" url="https://www.debian.org/doc/manuals/developers-reference/" />
				</para>

			</section>
			 <section>
				<title>Ferramentas</title>
				 <para>
					Muitas ferramentas ajudam os mantenedores de pacotes em seu trabalho. Esta seção as descreve rapidamente, mas não dá todos os detalhes, já que cada uma delas contém documentação detalhada.
				</para>
				 <section>
					<title>O Programa <command>lintian</command></title>
					 <indexterm>
						<primary><command>lintian</command></primary>
					</indexterm>
					 <para>
						Esta ferramenta é uma das mais importantes: é o verificador de pacotes Debian. É baseada em uma vasta matriz de testes criada pela política do Debian, e detecta rapida e automaticamente muitos erros que podem ser então consertados antes de os pacotes serem lançados.
					</para>
					 <para>
						Esta ferramenta é apenas um ajudante, e algumas vezes falha (por exemplo, já que a política do Debian muda com o tempo, <command>lintian</command> fica algumas vezes desatualizado). Também não é exaustiva: não receber nenhum erro no Lintian não deve ser interpretado como prova de que o pacote é perfeito; no máximo, ele evita os erros mais comuns.
					</para>

				</section>
				 <section>
					<title>O Programa <command>piuparts</command></title>
					 <indexterm>
						<primary><command>piuparts</command></primary>
					</indexterm>
					 <para>
						Esta é outra ferramenta importante: ele automatiza a instalação, atualização, remoção e limpeza de um pacote (em um ambiente isolado), verifica se nenhuma dessas operações leva a um erro. Ela pode ajudar na detecção de dependências que estão faltando, e também detecta quando os arquivos são deixados incorretamente depois que o pacote foi expurgado.
					</para>

				</section>
				 <section>
					<title>devscripts</title>
					 <indexterm>
						<primary><emphasis role="pkg">devscripts</emphasis></primary>
					</indexterm>
					 <indexterm>
						<primary><command>debuild</command></primary>
					</indexterm>
					 <indexterm>
						<primary><command>dch</command></primary>
					</indexterm>
					 <indexterm>
						<primary><command>uscan</command></primary>
					</indexterm>
					 <indexterm>
						<primary><command>debi</command></primary>
					</indexterm>
					 <indexterm>
						<primary><command>debc</command></primary>
					</indexterm>
					 <para>
						O pacote <emphasis role="pkg">devscripts</emphasis> contém diversos programas que ajudam com uma vasta gama do trabalho dos desenvolvedores Debian:
					</para>
					 <itemizedlist>
						<listitem>
							<para>
								<command>debuild</command> permite gerar um pacote (com <command>dpkg-buildpackage</command>) e executando <command>lintian</command> para verificar a compatibilidade com a política Debian depois.
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>debclean</command> limpa um pacote fonte após o pacote binário ter sido gerado.
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>dch</command> permite rapidamente e facilmente editar o arquivo <filename>debian/changelog</filename> num pacote fonte.
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>uscan</command> verifica se foi liberada uma nova versão de um software pelo autor; Isso requer um <filename>debian/watch</filename> arquivo com uma descrição da localização de tais lançamentos.
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>debi</command> permite a instalação (com <command>dpkg -i</command>) do pacote Debian que acabou de ser gerado sem a necessidade de digitar seu nome completo e caminho.
							</para>

						</listitem>
						 <listitem>
							<para>
								De uma maneira similar, <command>debc</command> permite varrer o conteúdo de um pacote recentemente criado (com <command>dpkg -c</command>), sem a necessidade de digitar o nome completo e o caminho.
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>bts</command> controla o sistema de bug pela linha de commando, este programa automaticamente gera e-mails apropriados.
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>debrelease</command> envia os pacotes recém gerados a um servidor remoto, sem a necessidades de digitar o nome completo e o caminho do arquivo relacionado <filename>.changes</filename>.
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>debsign</command> assina os arquivos <filename>*.dsc</filename> e <filename>*.changes</filename>.
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>uupdate</command> automatiza a criação de uma nova revisão do pacote quando uma nova versão upstream foi lançada.
							</para>

						</listitem>

					</itemizedlist>

				</section>
				 <section>
					<title><emphasis role="pkg">debhelper</emphasis> e <emphasis role="pkg">dh-make</emphasis></title>
					 <indexterm>
						<primary><emphasis>debhelper</emphasis></primary>
					</indexterm>
					 <indexterm>
						<primary><emphasis>dh-make</emphasis></primary>
					</indexterm>
					 <para>
						Debhelper é um conjunto de scripts que facilitam a criação de pacotes de políticas compatíveis; esses scripts são chamados a partir de <filename>debian/rules</filename>. Debhelper tem sido amplamente adotado no Debian, como evidenciado pelo fato de que ele é usado pela maioria dos pacotes Debian oficiais. Todos os comandos contém um prefixo <command>dh_</command>.
					</para>
					 <para>
						O roteiro <command>dh_make</command> (no pacote <emphasis>dh-make</emphasis>) cria arquivos necessários para geração de um pacote Debian em um diretório inicialmente contendo os fontes do programa. Como você pode ter adivinhado pelo nome do programa, o arquivo gerado usa por padrão o debhelper.
					</para>

				</section>
				 <section>
					<title><command>dupload</command> e <command>dput</command></title>
					 <indexterm>
						<primary><command>dupload</command></primary>
					</indexterm>
					 <indexterm>
						<primary><command>dput</command></primary>
					</indexterm>
					 <para>
						Os comandos <command>dupload</command> e <command>dput</command> permitem o upload de um pacote Debian para um servidor (possivelmente remoto). Isto permite aos desenvolvedores publicarem seu pacote no servidor principal Debian (<literal>ftp-master.debian.org</literal>) de modo que ele possa ser integrado ao arquivo e distribuído por espelhos. Estes comandos tornam um arquivo <filename>*.changes</filename> um parâmetro, e deduzir os outros arquivos relevantes de seu conteúdo.
					</para>

				</section>

			</section>

		</section>
		 <section>
			<title>Processo de Aceitação</title>
			 <para>
				Tornar-se um desenvolvedor Debian não é somente uma questão administrativa. O processo compreende vários passos, e é tanto uma iniciação quando um processo seletivo. Em todo caso, o ele é formalizado e bem documentado, então qualquer um pode verificar o progresso no site web dedicado para o processo de novos membros. <ulink type="block" url="https://nm.debian.org/" />
			</para>
			 <sidebar> <title><emphasis>EXTRA</emphasis> Processo leve para "Mantenedores Debian"</title>
			 <para>
				"Mantenedor Debian" é outro status que dá menos privilégios que o "Desenvolvedor Debian", mas esses processo de associação é mais rápido. Com esse status, os contribuintes podem manter seus próprios pacotes apenas. Um desenvolvedor Debian só precisa executar uma verificação em um envio inicial, e emitir uma declaração para efeito de que eles confiam no mantenedor prospectivo sobre a capacidade de manter o pacote por conta própria.
			</para>
			 <indexterm>
				<primary>Mantenedor Debian</primary>
			</indexterm>
			 </sidebar> <section>
				<title>Pré-requisitos</title>
				 <para>
					É esperado de todos os candidatos ter ao menos conhecimento da linguá inglesa. Isto é requerido em todos os níveis: para a comunicação inicial com o examinador, é claro, mas mais tarde também, já que o inglês é a linguá preferida pela maioria dos documentos; também, os usuários dos pacotes se comunicarão em inglês quando reportando erros, e os mesmos esperam uma reposta em inglês.
				</para>
				 <para>
					Outro pré-requisito lida com motivação. Tornar-se um desenvolvedor Debian é um processo que somente faz sentido se o candidato sabe que seu interesse no Debian durará mais do que muitos meses. O processo de aceitação em si deve durar diversos meses, e o Debian precisa de desenvolvedores para um longo trajeto; cada pacote precisa de manutenção permanente, e não somente uma versão inicial.
				</para>

			</section>
			 <section>
				<title>Registrando</title>
				 <para>
					O primeiro passo (real) consiste em encontrar um patrocinador ou advogado; isso significa que um desenvolvedor oficial disposto a afirmar que eles acreditam que aceitam <emphasis>X</emphasis> seria uma coisa boa para o Debian. Isso geralmente significa que o candidato já tenha sido ativo dentro da comunidade, e que o seu trabalho tem sido apreciado. Se o candidato é tímido e seu trabalho não é apresentado publicamente, eles podem tentar convencer um desenvolvedor Debian para defendê-los, mostrando o seu trabalho de uma forma particular.
				</para>
				 <indexterm>
					<primary>par de chaves</primary>
				</indexterm>
				 <para>
					Ao mesmo tempo, o candidato deve gerar um par de chaves RSA pública/privada com o GnuPG, que deve ser assinado por pelo menos dois desenvolvedores oficiais Debian. A assinatura autentica o nome da chave. Efetivamente, na parte de assinatura de chaves, cada participante deve mostrar uma identificação oficial (normalmente um cartão de identificação ou passaporte), juntamente com os seus identificadores de chave. Esta etapa confirma a ligção entre o humano e as chaves. Esta assinatura, portanto, requer um reunião na vida real. Se você ainda não encontrou quaisquer desenvolvedores Debian em uma conferência de software livre público, você pode procurar explicitamente desenvolvedores que vivem nas proximidades usando a lista na seguinte página web como um ponto de partida. <ulink type="block" url="https://wiki.debian.org/Keysigning" />
				</para>
				 <para>
					Uma vez que o registro no <literal>nm.debian.org</literal> foi validado pelo advogado, um <emphasis>Gerenciador de Aplicações</emphasis> é atribuído ao candidato. O gerenciador de aplicativos, então, conduzir o processo através de várias etapas e verificações pré-definidas.
				</para>
				 <para>
					A primeira verificação é uma verificação de identidade. Se você já tiver uma chave assinada por dois desenvolvedores Debian, este passo é fácil; caso contrário, o Gerenciador de aplicativos irá tentar e guiá-lo em sua busca para desenvolvedores Debian por perto para organizar um meet-up e uma chave de assinatura.
				</para>

			</section>
			 <section>
				<title>Aceitando os Princípios</title>
				 <para>
					Estas formalidades administrativas são seguidas por considerações filosóficas. O ponto é ter certeza de que o candidato compreende e aceita o contrato social e os princípios por trás do Software Livre. Juntando Debian só é possível se a pessoa compartilha os valores que unem os desenvolvedores atuais, como expresso nos textos fundamentais (e resumido na <xref linkend="the-debian-project" />).
				</para>
				 <para>
					Além disso, de cada candidato que pretende aderir as fileiras Debian é esperado saber o funcionamento do projeto e como interagir de forma adequada para resolver os problemas que elas irão sem dúvida encontrar com o passar do tempo. Toda esta informação geralmente está documentado nos manuais visando o novo mantenedor e em referência do desenvolvedor Debian. Uma leitura atenta deste documento deve ser suficiente para responder a perguntas do examinador. Se as respostas não são satisfatórias, o candidato será informado. Em seguida, ele terá que ler (novamente) a documentação pertinente antes de tentar novamente. Nos casos onde a documentação existente não contém a resposta adequada para a questão, o candidato geralmente pode chegar a uma resposta com alguma experiência prática dentro do Debian, ou potencialmente, discutindo com outros desenvolvedores Debian. Esse mecanismo garante que candidatos se envolver um pouco no Debian antes de se tornar parte integral dele. É uma política deliberada, por que candidatos que eventualmente se unem ao projeto integram-se como uma peça de um quebra-cabeça infinitamente extensível.
				</para>
				 <indexterm>
					<primary><emphasis>Filosofia &amp; Procedimentos</emphasis></primary>
				</indexterm>
				 <para>
					Esta etapa é geralmente conhecido como <emphasis>Philosophy &amp; Procedures - Filosofia &amp; Procedimentos</emphasis> (P&amp;P abreviando) no jargão dos programadores envolvidos no processo de novos membros.
				</para>

			</section>
			 <section>
				<title>Verificando Habilidades</title>
				 <para>
					Cada aplicação para se tornar um desenvolvedor oficial Debian deve ser justificada. Se tornar um membro do projeto requer demonstrar que esse status é legítimo, e que facilita o trabalho do candidato no sentido de ajudar o Debian. A justificativa mais comum é que a concessão de status de desenvolvedor Debian facilita a manutenção de um pacote Debian, mas não é o único. Alguns desenvolvedores participam do projeto para contribuir para portar para uma arquitetura específica, outros querem melhorar a documentação, e assim por diante.
				</para>
				 <para>
					Esta etapa representa a oportunidade para o candidato afirmar o que eles pretendem fazer dentro do projeto Debian e para mostrar o que eles já fizeram para esse fim. Debian é um projeto pragmático e dizer alguma coisa, não é suficiente, se as ações não correspondem ao que é anunciado. Geralmente, quando o papel pretendido dentro do projeto está relacionado ao pacote de manutenção, uma primeira versão do pacote de potencial terá que ser validada tecnicamente e enviada para os servidores Debian por um patrocinador entre os desenvolvedores Debian existentes.
				</para>
				 <sidebar> <title><emphasis>COMUNIDADE</emphasis> Patrocinando</title>
				 <indexterm>
					<primary>patrocinando</primary>
				</indexterm>
				 <para>
					Desenvolvedores Debian pode "patrocinador" de pacotes, elaborado por outra pessoa, o que significa que eles os publica nos repositórios oficiais do Debian, após ter efectuado uma revisão cuidadosa. Este mecanismo permite que pessoas externas, que ainda não passaram pelo processo novo membro, contribuiam ocasionalmente para o projeto. Ao mesmo tempo, ele garante que todos os pacotes incluídos no Debian sempre foi marcado por um membro oficial.
				</para>
				 </sidebar> <para>
					Finalmente, o examinador verifica habilidades de técnico (embalagem) do candidato com um questionário detalhado. Respostas ruins não são permitidas, mas o tempo de resposta não é limitado. Toda a documentação está disponível e várias tentativas são permitidas se as primeiras respostas não são satisfatórias. Esta etapa não tem a intenção de discriminar, mas para garantir pelo menos um mínimo de conhecimento comum para novos colaboradores.
				</para>
				 <indexterm>
					<primary><emphasis>Tarefas &amp; Habilidades</emphasis></primary>
				</indexterm>
				 <para>
					Este passo é conhecido como <emphasis>Tasks &amp; Skills - Tarefas &amp; Habilidades</emphasis> passo (T&amp;S abreviando) no jargão dos examinadores.
				</para>

			</section>
			 <section>
				<title>Aprovação Final</title>
				 <para>
					No último passo, todo o processo é analisado por um DAM (<emphasis>Debian Account Manager - Gerente de Contas Debian</emphasis>). O DAM irá rever todas as informações sobre o candidato que o examinador coletou, e toma decisão sobre se deve ou não criar uma conta nos servidores Debian. Nos casos em que a informação adicional é necessária, a criação da conta pode ser adiada. As recusas são bastante raras, se o examinador faz um bom trabalho de acompanhar o processo, mas às vezes acontecem. Eles nunca são permanentes, e o candidato é livre para tentar novamente em um momento posterior.
				</para>
				 <para>
					A decisão do DAM é autoritária e (quase sempre) sem apelo, o que explica porque pessoas nessa posição foram frequentemente criticadas no passado.
				</para>

			</section>

		</section>

	</section>
</chapter>

