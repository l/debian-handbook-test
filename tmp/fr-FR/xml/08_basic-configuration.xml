<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="basic-configuration" lang="fr-FR">
	<chapterinfo>
		 <keywordset>
			<keyword>Configuration</keyword>
			 <keyword>Francisation</keyword>
			 <keyword>Locales</keyword>
			 <keyword>Réseau</keyword>
			 <keyword>Résolution de noms</keyword>
			 <keyword>Utilisateurs</keyword>
			 <keyword>Groupes</keyword>
			 <keyword>Création de compte</keyword>
			 <keyword>Interpréteur de commandes</keyword>
			 <keyword>Shell</keyword>
			 <keyword>Impression</keyword>
			 <keyword>Chargeur de démarrage</keyword>
			 <keyword>Compilation de noyau</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Configuration de base : réseau, comptes, impression...</title>
	 <highlights> <para>
		Un ordinateur nouvellement installé par <command>debian-installer</command> se veut aussi fonctionnel que possible, mais de nombreux services restent à paramétrer. Par ailleurs, il est bon de savoir comment changer certains éléments de configuration définis lors de l'installation initiale.
	</para>
	 </highlights> <para>
		Ce chapitre passe en revue tout qui relève de ce que l'on peut appeler la « configuration de base » : réseau, langue et « locales », utilisateurs et groupes, impression, points de montage, etc.
	</para>
	 <section id="sect.config-language-support">
		<title>Francisation du système</title>
		 <indexterm>
			<primary>francisation</primary>
		</indexterm>
		 <para>
			Il est probable que l'ordinateur fonctionne déjà en français si l'installation a été menée dans cette langue. Mais il est bon de savoir ce que l'installateur a fait à ce sujet pour effectuer des modifications plus tard si le besoin s'en faisait sentir.
		</para>
		 <sidebar> <title><emphasis>OUTIL</emphasis> La commande <command>locale</command> pour afficher la configuration courante</title>
		 <para>
			La commande <command>locale</command> permet d'afficher un résumé de la configuration courante des différents paramétrages de la locale (format des dates, des nombres, etc.), présenté sous la forme d'un ensemble de variables d'environnement standards et dédiées à la modification dynamique de ces réglages.
		</para>
		 </sidebar> <section id="sect.default-language">
			<title>Définir la langue par défaut</title>
			 <indexterm>
				<primary>locales</primary>
			</indexterm>
			 <indexterm>
				<primary>langue</primary>
			</indexterm>
			 <indexterm>
				<primary><command>locale-gen</command></primary>
			</indexterm>
			 <para>
				Une <foreignphrase>locale</foreignphrase> correspond à un jeu de paramètres régionaux. Ceci inclut non seulement la langue des textes, mais aussi le format de présentation des nombres, des dates et des heures, des sommes monétaires ainsi que le mode de comparaison alphabétique (afin de tenir compte des caractères accentués). Bien que chacun de ces paramètres puisse être spécifié indépendamment des autres, on utilisera généralement une locale, qui est un ensemble cohérent de valeurs pour ces paramètres, correspondant à une « région » au sens large. Ces locales sont la plupart du temps décrites sous la forme <literal><replaceable>code-langue</replaceable>_<replaceable>CODE-PAYS</replaceable></literal> avec parfois un suffixe pour spécifier le jeu de caractères et l'encodage à utiliser. Ceci permet de prendre en compte les différences idiomatiques ou typographiques entre différentes régions de langue commune.
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> Jeux de caractères</title>
			 <indexterm>
				<primary>jeu de caractère</primary>
			</indexterm>
			 <indexterm>
				<primary>encodage</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-1</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-15</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 1</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 9</primary>
			</indexterm>
			 <para>
				À chaque locale sont normalement associés un « jeu de caractères » (ensemble des caractères possibles) et un « encodage » (manière de représenter les caractères pour l'ordinateur) de prédilection.
			</para>
			 <para>
				Les encodages les plus populaires pour les langues à alphabet latin utilisaient un octet par caractère et étaient de ce fait limités à 256 caractères. Comme cette limitation à 256 caractères ne permettait pas de couvrir toutes les langues en usage en Europe, plusieurs encodages indépendants étaient requis, ce qui a mené à une multitude de jeux de caractères, notamment la série des <emphasis>ISO-8859-1</emphasis> (connu comme « Latin 1 ») à <emphasis>ISO-8859-15</emphasis> (« Latin 9 »).
			</para>
			 <para>
				Pour travailler avec des langues étrangères, il fallait donc régulièrement jongler avec différents encodages et jeux de caractères. De surcroît, la rédaction de documents multilingues posait parfois des problèmes quasi insurmontables. Unicode (super catalogue de presque tous les systèmes d'écriture des langues du monde) fut créé pour contourner ce problème. Son encodage particulier UTF-8 conserve tous les 128 symboles ASCII (codés sur 7 bits) mais traite différemment les autres caractères. Ces derniers sont précédés par une séquence de bits d'« échappement » plus ou moins longue. Cela permet de représenter tous les caractères Unicode sur un ou plusieurs octets, selon le besoin. L'usage d'UTF-8 s'est largement répandu, aidé par le fait que c'est l'encodage par défaut utilisé dans les documents XML.
			</para>
			 <indexterm>
				<primary>ASCII</primary>
			</indexterm>
			 <indexterm>
				<primary>UTF-8</primary>
			</indexterm>
			 <indexterm>
				<primary>Unicode</primary>
			</indexterm>
			 <para>
				Il s'agit de l'encodage généralement recommandé et de la valeur par défaut sur les systèmes Debian.
			</para>
			 </sidebar> <para>
				Le paquet <emphasis role="pkg">locales</emphasis> rassemble les éléments nécessaires au bon fonctionnement des « localisations » des différentes applications. Lors de son installation, ce paquet pose quelques questions afin de choisir les langues prises en charge. Il est à tout moment possible de revenir sur ces choix en exécutant <command>dpkg-reconfigure locales</command>.
			</para>
			 <para>
				On demande d'abord de choisir toutes les « locales » à prendre en charge. La sélection de toutes les locales françaises (c'est-à-dire celles débutant par « <literal>fr_FR</literal> ») est un choix raisonnable. N'hésitez pas à sélectionner d'autres locales si la machine héberge des utilisateurs étrangers. Cette liste des locales connues du système est stockée dans le fichier <filename>/etc/locale.gen</filename>. Il est possible d'intervenir sur ce fichier à la main, mais il faut penser à exécuter <command>locale-gen</command> après chaque modification ; cela génère les fichiers nécessaires au bon fonctionnement des locales éventuellement ajoutées, tout en supprimant les fichiers obsolètes.
			</para>
			 <para>
				La seconde question, intitulée « Jeu de paramètres régionaux par défaut », requiert une locale par défaut. Le choix recommandé en France est « <literal>fr_FR.UTF-8</literal> ». Les Belges francophones préféreront « <literal>fr_BE.UTF-8</literal> », les Luxembourgeois « <literal>fr_LU.UTF-8</literal> », les Suisses « <literal>fr_CH.UTF-8</literal> » et les Canadiens « <literal>fr_CA.UTF-8</literal> ». Le fichier <filename>/etc/default/locale</filename> est alors modifié pour renseigner la locale par défaut dans la variable d'environnement <varname>LANG</varname>.
			</para>
			 <indexterm>
				<primary><foreignphrase>environment</foreignphrase></primary>
			</indexterm>
			 <indexterm>
				<primary><foreignphrase>locale</foreignphrase></primary>
			</indexterm>
			 <indexterm>
				<primary><varname>LANG</varname></primary>
			</indexterm>
			 <sidebar id="sidebar.intro-pam"> <title><emphasis>EN COULISSES</emphasis> <filename>/etc/environment</filename> et <filename>/etc/default/locale</filename></title>
			 <para>
				Le fichier <filename>/etc/environment</filename> sert aux programmes <command>login</command>, <command>gdm</command>, ou encore <command>ssh</command> pour créer leurs variables d'environnement.
			</para>
			 <para>
				Ces applications n'effectuent pas cela directement, mais via un module PAM (<filename>pam_env.so</filename>). PAM (<foreignphrase>Pluggable Authentication Module</foreignphrase>, ou module d'authentification connectable) est une bibliothèque modulaire centralisant les mécanismes d'authentification, d'initialisation de sessions et de gestion des mots de passe. Voir <xref linkend="sect.config-pam" /> pour un exemple de configuration de PAM.
			</para>
			 <para>
				<filename>/etc/default/locale</filename> fonctionne de la même manière, mais ne contient que la variable d'environnement <varname>LANG</varname>, de sorte que certains utilisateurs de PAM puissent hériter d'un environnement sans localisation. Il est en effet déconseillé que les programmes serveurs utilisent des paramètres régionaux, alors que les programmes qui ouvrent des sessions pour l'utilisateur sont au contraire tout indiqués pour utiliser des paramètres régionaux implicites.
			</para>
			 <indexterm>
				<primary>PAM</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>pam_env.so</filename></primary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.keyboard-config">
			<title>Configurer le clavier</title>
			 <indexterm>
				<primary>disposition du clavier</primary>
			</indexterm>
			 <indexterm>
				<primary>clavier, disposition</primary>
			</indexterm>
			 <para>
				Bien que la disposition du clavier soit gérée différemment entre la console texte et le mode graphique, Debian fournit une interface de configuration unique qui fonctionne pour les deux modes : cette interface est basée sur Debconf et fournie par le paquet <emphasis role="pkg">keyboard-configuration</emphasis>. Ainsi, la commande <command>dpkg-reconfigure keyboard-configuration</command> peut être utilisée à tout instant pour reconfigurer la disposition de clavier.
			</para>
			 <indexterm>
				<primary><emphasis>console-data</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>console-tools</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>keyboard-configuration</emphasis></primary>
			</indexterm>
			 <para>
				<indexterm><primary><literal>azerty</literal></primary></indexterm> Les questions portent dans l'ordre sur l'apparence du clavier physique (un clavier de PC standard en France sera « PC générique 105 touches (intl) »), puis sur la disposition à choisir (on choisira généralement « France » sauf cas particuliers), puis sur la position de la touche AltGr. Vient enfin une question sur la position à utiliser pour la « touche Compose », qui permet de saisir des caractères spéciaux en combinant des caractères simples. Taper successivement <keycombo action="seq"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> produira ainsi un e accent aigu (« é »). Toutes ces combinaisons sont décrites dans le fichier <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> (ou un autre fichier, déterminé en fonction de la locale en cours par la table de correspondance décrite par <filename>/usr/share/X11/locale/compose.dir</filename>).
			</para>
			 <indexterm>
				<primary><literal>Compose</literal>, key</primary>
			</indexterm>
			 <indexterm>
				<primary><literal>Meta</literal>, key</primary>
			</indexterm>
			 <indexterm>
				<primary>touche</primary>
				<secondary><literal>Meta</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary>touche</primary>
				<secondary><literal>Compose</literal></secondary>
			</indexterm>
			 <para>
				Note that the keyboard configuration for graphical mode described here only affects the default layout; the GNOME and KDE Plasma environments, among others, provide a keyboard control panel in their preferences allowing each user to have their own configuration. Some additional options regarding the behavior of some particular keys are also available in these control panels.
			</para>

		</section>
		 <section id="sect.utf8-migration">
			<title>Migration vers UTF-8</title>
			 <para>
				La généralisation de l'encodage UTF-8 a constitué une solution longtemps attendue à de nombreux problèmes d'interopérabilité, puisqu'elle facilite les échanges internationaux et lève les limites arbitraires sur les caractères que l'on peut utiliser dans un document. L'inconvénient est qu'il a fallu passer par une phase de conversion un peu rebutante, d'autant qu'elle n'aurait pu être totalement transparente que si elle avait été synchronisée dans le monde entier et que deux opérations de conversion étaient en réalité à prévoir : l'une sur le contenu des fichiers, l'autre sur leur nom. Fort heureusement, le plus gros de cette migration est passé et nous la citons principalement pour référence.
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> <foreignphrase>Mojibake</foreignphrase> et erreurs d'interprétation</title>
			 <para>
				Lorsqu'un texte est transmis (ou stocké) sans information d'encodage, il n'est pas toujours possible de savoir avec certitude quelle convention utiliser à la réception (ou à la lecture) de ce qui reste un ensemble d'octets. On peut généralement se faire une idée en effectuant des statistiques sur la répartition des valeurs présentes dans le texte, mais cela ne donnera pas une réponse certaine. Lorsque le système d'encodage choisi pour la lecture diffère de celui utilisé à l'écriture, les octets sont mal interprétés et on obtient au mieux des erreurs sur certains caractères, au pire quelque chose d'illisible.
			</para>
			 <para>
				Ainsi, si un texte français apparaît normal à l'exception des lettres accentuées et de certains symboles, qui semblent remplacés par des séquences du type « Ã© », « Ã¨ » ou « Ã§ », il s'agit vraisemblablement d'un texte encodé en UTF-8 mais interprété comme ISO-8859-1 ou ISO-8859-15. C'est le signe d'une installation locale non encore migrée vers UTF-8. Si en revanche vous voyez apparaître des points d'interrogation à la place des lettres accentuées, voire que ces points d'interrogation semblent remplacer également un caractère qui aurait dû suivre cette lettre accentuée, il est probable que votre installation soit déjà configurée en UTF-8 et que l'on vous ait envoyé un document encodé en ISO-8859-*.
			</para>
			 <para>
				Voilà pour les cas « simples ». Ces cas n'apparaissent que pour les cultures occidentales, parce qu'Unicode (et UTF-8) a été conçu pour maximiser les points communs avec les encodages historiques pour les langues occidentales à base d'alphabet latin, ce qui permet de reconnaître en partie le texte même s'il manque des caractères.
			</para>
			 <para>
				Dans les configurations plus complexes, où interviennent par exemple deux environnements correspondant à deux langues différentes n'utilisant pas le même alphabet, on obtient souvent des résultats illisibles, succession de symboles abstraits n'ayant rien à voir les uns avec les autres. Comme cette situation était particulièrement fréquente en Asie du fait de la multiplicité des langues et des systèmes d'écriture, l'usage a consacré le mot japonais <foreignphrase>mojibake</foreignphrase> pour désigner ce phénomène. Lorsqu'il apparaît, le diagnostic est plus complexe et la solution la plus simple est souvent de migrer vers UTF-8 de part et d'autre.
			</para>
			 </sidebar> <para>
				En ce qui concerne les noms de fichiers, la migration pourra être relativement simple. L'outil <command>convmv</command> (dans le paquet du même nom) a été précisément écrit à cet effet : il permet de renommer les fichiers d'un encodage à un autre. Son invocation est relativement simple, mais nous recommandons de l'effectuer en deux étapes pour éviter des surprises. L'exemple qui suit illustre un environnement UTF-8 contenant encore des répertoires dont le nom est encodé en ISO-8859-15 et une utilisation de <command>convmv</command> pour leur renommage.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Ic?nes  ?l?ments graphiques  Textes
$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>Starting a dry run without changes...
mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
No changes to your files done. Use --notest to finally rename the files.
$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
Ready!
$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput></screen>
			 <para>
				Pour le contenu des fichiers, la procédure sera plus complexe, étant donné la multiplicité des formats de fichiers existants. Certains des formats de fichiers embarquent une information d'encodage, ce qui facilite la tâche aux logiciels qui les traitent ; il suffit alors d'ouvrir ces fichiers et de les réenregistrer en spécifiant l'encodage UTF-8. Dans d'autres cas, il faudra spécifier l'encodage d'origine (ISO-8859-1 ou « Occidental », ou ISO-8859-15 ou « Occidental (euro) » suivant les formulations) lors de l'ouverture du fichier.
			</para>
			 <para>
				Pour les simples fichiers texte, on pourra utiliser <command>recode</command> (dans le paquet éponyme), qui permet un recodage automatisé. Cet outil disposant de nombreuses options permettant de jouer sur son comportement, nous vous engageons à consulter sa documentation, la page de manuel <citerefentry> <refentrytitle>recode</refentrytitle>
				 <manvolnum>1</manvolnum> </citerefentry> ou la page info <citerefentry> <refentrytitle>recode</refentrytitle>
				 </citerefentry> (plus complète).
			</para>

		</section>

	</section>
	 <section id="sect.network-config">
		<title>Configuration du réseau</title>
		 <sidebar id="sidebar.networking-basics"> <title><emphasis>B.A.-BA</emphasis> Rappels réseau essentiels (Ethernet, adresse IP, sous-réseau, broadcast...)</title>
		 <indexterm>
			<primary>Ethernet</primary>
		</indexterm>
		 <indexterm>
			<primary>10BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>100BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>1000BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>10GBASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>RJ45, connecteur</primary>
		</indexterm>
		 <indexterm>
			<primary>connecteur RJ45</primary>
		</indexterm>
		 <para>
			La majorité des réseaux locaux actuels sont des réseaux Ethernet qui fonctionnent par trames, c'est-à-dire que les données y circulent de manière non continue, par petits blocs. Le débit varie de 10 Mbit/s pour les cartes Ethernet les plus anciennes, à 10 Gbit/s pour la génération la plus récente (100 Mbit/s étant le débit le plus fréquent à l'heure actuelle). Les câbles correspondants les plus courants sont, selon les débits qu'ils permettent d'acheminer, connus sous les nom de 10BASE-T, 100BASE-T, 1000BASE-T ou 10GBASE-T, dits en « paire torsadée » <foreignphrase>(twisted pair)</foreignphrase>, dont chaque extrémité est munie d'un connecteur RJ45 — mais il existe d'autres types de câbles, qui sont surtout utilisés pour les débits à partir du Gbit/s.
		</para>
		 <indexterm>
			<primary>IP, adresse</primary>
		</indexterm>
		 <indexterm>
			<primary>adresse IP</primary>
		</indexterm>
		 <para>
			Une adresse IP est un numéro employé pour identifier une interface réseau d'un ordinateur sur le réseau local ou sur Internet. Dans la version d'IP actuellement la plus répandue (IPv4), ce numéro se code sur 32 bits et se représente habituellement comme 4 nombres séparés par des points (ex : <literal>192.168.0.1</literal>), chaque nombre pouvant varier de 0 à 255 (représentant ainsi 8 bits de données). La version suivante du protocole, IPv6, étend cet espace d'adressage à 128 bits, une adresse étant représentée sous forme de nombres hexadécimaux séparés par des deux-points (ex : 2002:58bf:13bb:0002:0000:0000:0020, que l'on peut abréger en 2002:58bf:13bb:2::20).
		</para>
		 <indexterm>
			<primary>sous-réseau</primary>
		</indexterm>
		 <indexterm>
			<primary>masque</primary>
			<secondary>de sous-réseau</secondary>
		</indexterm>
		 <indexterm>
			<primary>réseau</primary>
			<secondary>adresse du</secondary>
		</indexterm>
		 <para>
			Un masque de sous-réseau <foreignphrase>(netmask)</foreignphrase> définit par son codage en binaire quelle portion d'une adresse IP correspond au réseau — le reste y spécifiant l'identifiant de la machine. Dans l'exemple de configuration statique IPv4 donné ici, le masque de sous-réseau <literal>255.255.255.0</literal> (24 « 1 » suivis de 8 « 0 » en représentation binaire) indique que les 24 premiers bits de l'adresse IP correspondent à l'adresse réseau, les 8 derniers relevant alors du numéro de machine. En IPv6, pour des raisons de lisibilité, on note uniquement le nombre de « 1 ». Un <foreignphrase>netmask</foreignphrase> IPv6 peut donc être <literal>64</literal>.
		</para>
		 <para>
			L'adresse de réseau est une adresse IP dont la partie décrivant le numéro de machine est à zéro. On décrit souvent la plage d'adresses IPv4 d'un réseau complet par la syntaxe <emphasis>a.b.c.d/e</emphasis> où <emphasis>a.b.c.d</emphasis> est l'adresse réseau et <emphasis>e</emphasis> le nombre de bits affectés à la partie réseau dans une adresse IP. Le réseau de l'exemple s'écrirait ainsi : <literal>192.168.0.0/24</literal>. La syntaxe est similaire en IPv6 : <literal>2001:db8:13bb:2::/64</literal>.
		</para>
		 <indexterm>
			<primary>routeur</primary>
		</indexterm>
		 <indexterm>
			<primary>passerelle</primary>
		</indexterm>
		 <para>
			Un routeur est une machine reliant plusieurs réseaux entre eux. Tout le trafic y parvenant est réorienté sur le bon réseau. Pour cela, le routeur analyse les paquets entrants et les redirige en fonction des adresses IP de leurs destinataires. Le routeur est souvent qualifié de passerelle ; il s'agit alors habituellement d'une machine qui permet de sortir d'un réseau local (vers un réseau étendu comme Internet).
		</para>
		 <indexterm>
			<primary><foreignphrase>broadcast</foreignphrase></primary>
		</indexterm>
		 <para>
			L'adresse de <foreignphrase>broadcast</foreignphrase> (diffusion), spéciale, permet de joindre tous les postes du réseau. Presque jamais « routée », elle ne fonctionne donc que sur le réseau considéré. Concrètement, cela signifie qu'un paquet de données adressé au <foreignphrase>broadcast</foreignphrase> ne franchit jamais un routeur.
		</para>
		 <para>
			Notez que nous nous restreignons dans ce chapitre aux adresses IPv4, les plus couramment utilisées à l'heure actuelle. Les détails du protocole IPv6 seront abordés dans la <xref linkend="sect.ipv6" />, mais les concepts resteront les mêmes.
		</para>
		 </sidebar> <para>
			The network is automatically configured during the initial installation. If Network Manager gets installed (which is generally the case for full desktop installations), then it might be that no configuration is actually required (for example, if you rely on DHCP on a wired connection and have no specific requirements). If a configuration is required (for example for a WiFi interface), then it will create the appropriate file in <filename>/etc/NetworkManager/system-connections/</filename>.
		</para>
		 <para>
			If Network Manager is not installed, then the installer will configure <emphasis role="pkg">ifupdown</emphasis> by creating the <filename>/etc/network/interfaces</filename> file. A line starting with <literal>auto</literal> gives a list of interfaces to be automatically configured on boot by the <literal>networking</literal> service.
		</para>
		 <para>
			In a server context, <emphasis role="pkg">ifupdown</emphasis> is thus the network configuration tool that you usually get. That is why we will cover it in the next sections.
		</para>
		 <indexterm>
			<primary>réseau</primary>
			<secondary>configuration</secondary>
		</indexterm>
		 <indexterm>
			<primary>configuration</primary>
			<secondary>du réseau</secondary>
		</indexterm>
		 <indexterm>
			<primary>interface</primary>
			<secondary>réseau</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> NetworkManager</title>
		 <indexterm>
			<primary><emphasis role="pkg">network-manager</emphasis></primary>
		</indexterm>
		 <para>
			If Network Manager is particularly recommended in roaming setups (see <xref linkend="sect.roaming-network-config" />), it is also perfectly usable as the default network management tool. You can create “System connections” that are used as soon as the computer boots either manually with a <filename>.ini</filename>-like file in <filename>/etc/NetworkManager/system-connections/</filename> or through a graphical tool (<command>nm-connection-editor</command>). Just remember to deactivate all entries in <filename>/etc/network/interfaces</filename> if you want Network Manager to handle them. <ulink type="block" url="https://wiki.gnome.org/Projects/NetworkManager/SystemSettings" /> <ulink type="block" url="https://developer.gnome.org/NetworkManager/1.6/ref-settings.html" />
		</para>
		 </sidebar> <section id="sect.interface-ethernet">
			<title>Interface Ethernet</title>
			 <para>
				Si l'ordinateur dispose d'une carte réseau Ethernet, il faut configurer le réseau qui y est associé en optant pour l'une de deux méthodes. La configuration dynamique par DHCP, la plus simple, nécessite la présence d'un serveur DHCP sur le réseau local. Elle peut indiquer un nom d'hôte souhaité, ce qui correspond au paramètre facultatif <literal>hostname</literal> dans l'exemple qui suit. Le serveur DHCP renvoie alors les paramètres de configuration du réseau qui conviennent.
			</para>
			 <indexterm>
				<primary>Ethernet</primary>
			</indexterm>
			 <indexterm>
				<primary>DHCP</primary>
			</indexterm>
			 <example id="example.config-dhcp">
				<title>Configuration par DHCP</title>
				 
<programlisting>
auto enp0s31f6
iface enp0s31f6 inet dhcp
  hostname arrakis
</programlisting>

			</example>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> Names of network interfaces</title>
			 <indexterm>
				<primary><literal>eth0</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>en*</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>wlan0</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>wl*</literal></primary>
			</indexterm>
			 <para>
				By default, the kernel attributes generic names such a <literal>eth0</literal> (for wired Ethernet) or <literal>wlan0</literal> (for WiFi) to the network interfaces. The number in those names is a simple incremental counter representing the order in which they have been detected. With modern hardware, that order might change for each reboot and thus the default names are not reliable.
			</para>
			 <para>
				Fortunately, systemd and udev are able to rename the interfaces as soon as they appear. The default name policy is defined by <filename>/lib/systemd/network/99-default.link</filename> (see <citerefentry><refentrytitle>systemd.link</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> for an explanation of the <literal>NamePolicy</literal> entry in that file). In practice, the names are often based on the device's physical location (as guessed by where they are connected) and you will see names starting with <literal>en</literal> for wired ethernet and <literal>wl</literal> for WiFi. In the example above, the rest of the name indicates, in abbreviated form, a PCI (<literal>p</literal>) bus number (<literal>0</literal>), a slot number (<literal>s31</literal>), a function number (<literal>f6</literal>).
			</para>
			 <para>
				Obviously, you are free to override this policy and/or to complement it to customize the names of some specific interfaces. You can find out the names of the network interfaces in the output of <command>ip addr</command> (or as filenames in <filename>/sys/class/net/</filename>).
			</para>
			 </sidebar> <para>
				Une configuration « statique » doit mentionner de manière fixe les paramètres du réseau. Cela inclut au minimum l'adresse IP et le masque de sous-réseau, parfois les adresses de réseau et de <foreignphrase>broadcast</foreignphrase>. Un éventuel routeur vers l'extérieur sera précisé en tant que passerelle <foreignphrase>(gateway)</foreignphrase>.
			</para>
			 <example id="example.static-network">
				<title>Configuration statique</title>
				 
<programlisting>
auto enp0s31f6
iface enp0s31f6 inet static
  address 192.168.0.3
  netmask 255.255.255.0
  broadcast 192.168.0.255
  network 192.168.0.0
  gateway 192.168.0.1
</programlisting>

			</example>
			 <sidebar> <title><emphasis>NOTE</emphasis> Adresses multiples</title>
			 <para>
				Il est en effet possible non seulement d'associer plusieurs interfaces à une seule carte réseau physique, mais aussi plusieurs adresses IP à une seule interface. Rappelons également qu'à une adresse IP peuvent correspondre un nombre quelconque de noms par le truchement du DNS, et qu'un nom peut aussi correspondre à un nombre quelconque d'adresses IP numériques.
			</para>
			 <para>
				On l'aura compris, les configurations peuvent être très complexes, mais ces possibilités ne sont utilisées que dans des cas très particuliers. Les exemples cités ici n'exposent donc que les configurations usuelles.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.interface-wireless">
			<title>Wireless Interface</title>
			 <indexterm>
				<primary>wireless</primary>
			</indexterm>
			 <para>
				Getting wireless network cards to work can be a bit more challenging. First of all, they often require the installation of proprietary firmwares which are not installed by default in Debian. Then wireless networks rely on cryptography to restrict access to authorized users only, this implies storing some secret key in the network configuration. Let's tackle those topics one by one.
			</para>
			 <section>
				<title>Installing the required firmwares</title>
				 <indexterm>
					<primary>firmware</primary>
				</indexterm>
				 <indexterm>
					<primary>isenkram</primary>
				</indexterm>
				 <para>
					First you have to enable the non-free repository in APT's sources.list file: see <xref linkend="sect.apt-sources.list" /> for details about this file. Many firmware are proprietary and are thus located in this repository. You can try to skip this step if you want, but if the next step doesn't find the required firmware, retry after having enabled the non-free section.
				</para>
				 <para>
					Then you have to install the appropriate <literal>firmware-*</literal> packages. If you don't know which package you need, you can install the <emphasis role="pkg">isenkram</emphasis> package and run its <command>isenkram-autoinstall-firmware</command> command. The packages are often named after the hardware manufacturer or the corresponding kernel module: <emphasis role="pkg">firmware-iwlwifi</emphasis> for Intel wireless cards, <emphasis role="pkg">firmware-atheros</emphasis> for Qualcomm Atheros, <emphasis role="pkg">firmware-ralink</emphasis> for Ralink, etc. A reboot is then recommended because the kernel driver usually looks for the firmware files when it is first loaded and no longer afterwards.
				</para>

			</section>
			 <section>
				<title>Wireless specific entries in <filename>/etc/network/interfaces</filename></title>
				 <indexterm>
					<primary>WPA</primary>
				</indexterm>
				 <para>
					<emphasis>ifupdown</emphasis> is able to manage wireless interfaces but it needs the help of the <emphasis role="pkg">wpasupplicant</emphasis> package which provides the required integration between <emphasis>ifupdown</emphasis> and the <command>wpa_supplicant</command> command used to configure the wireless interfaces (when using WPA/WPA2 encryption). The usual entry in <filename>/etc/network/interfaces</filename> needs to be extended with two supplementary parameters to specify the name of the wireless network (aka its SSID) and the <emphasis>Pre-Shared Key</emphasis> (PSK).
				</para>
				 <example id="example.config-wireless">
					<title>DHCP configuration for a wireless interface</title>
					 
<programlisting>
auto wlp4s0
iface wlp4s0 inet dhcp
  wpa-ssid Falcot
  wpa-psk ccb290fd4fe6b22935cbae31449e050edd02ad44627b16ce0151668f5f53c01b
</programlisting>
				</example>
				 <para>
					The <literal>wpa-psk</literal> parameter can contain either the plain text passphrase or its hashed version generated with <command>wpa_passphrase <replaceable>SSID</replaceable> <replaceable>passphrase</replaceable></command>. If you use an unencrypted wireless connection, then you should put a <literal>wpa-key-mgmt NONE</literal> and no <literal>wpa-psk</literal> entry. For more information about the possible configuration options, have a look at <filename>/usr/share/doc/wpasupplicant/README.Debian.gz</filename>.
				</para>
				 <para>
					At this point, you should consider restricting the read permissions on <filename>/etc/network/interfaces</filename> to the root user only since the file contains a private key that not all users should have access to.
				</para>
				 <sidebar> <title><emphasis>HISTORY</emphasis> WEP encryption</title>
				 <indexterm>
					<primary>WEP</primary>
				</indexterm>
				 <para>
					Usage of the deprecated WEP encryption protocol is possible with the <emphasis role="pkg">wireless-tools</emphasis> package. See <filename>/usr/share/doc/wireless-tools/README.Debian</filename> for instructions.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.ppp-rtc">
			<title>Connexion PPP par modem téléphonique</title>
			 <indexterm>
				<primary>PPP</primary>
			</indexterm>
			 <indexterm>
				<primary>point à point</primary>
			</indexterm>
			 <indexterm>
				<primary>connexion</primary>
				<secondary>par modem RTC</secondary>
			</indexterm>
			 <indexterm>
				<primary>modem</primary>
				<secondary>RTC</secondary>
			</indexterm>
			 <para>
				Une connexion point à point (PPP) établit une connexion intermittente ; c'est donc la solution la plus souvent employée pour les connexions par modem téléphonique (sur le réseau téléphonique commuté RTC).
			</para>
			 <para>
				Une connexion par modem téléphonique requiert un compte chez un fournisseur d'accès, comprenant numéro de téléphone, identifiant, mot de passe et, parfois, protocole d'authentification employé. On la configurera à l'aide de l'utilitaire <command>pppconfig</command> du paquet Debian éponyme. Par défaut, il utilise la connexion <foreignphrase>provider</foreignphrase> (fournisseur d'accès). En cas de doute sur le protocole d'authentification, choisissez <emphasis>PAP</emphasis> : il est proposé par la majorité des fournisseurs d'accès.
			</para>
			 <indexterm>
				<primary><command>pppconfig</command></primary>
			</indexterm>
			 <indexterm>
				<primary>PAP</primary>
			</indexterm>
			 <para>
				Après configuration, il est possible de se connecter par la commande <command>pon</command> (à laquelle on fournira le nom de la connexion si la valeur par défaut — <foreignphrase>provider</foreignphrase> — ne convient pas). On coupera la connexion par la commande <command>poff</command>. Ces deux commandes peuvent être exécutées par l'utilisateur root ou par un autre utilisateur, à condition qu'il fasse partie du groupe <literal>dip</literal>.
			</para>
			 <indexterm>
				<primary><command>pon</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>poff</command></primary>
			</indexterm>

		</section>
		 <section id="sect.adsl">
			<title>Connexion par modem ADSL</title>
			 <indexterm>
				<primary>connexion</primary>
				<secondary>par modem ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>modem</primary>
				<secondary>ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>ADSL, modem</primary>
			</indexterm>
			 <para>
				Le terme générique de « modem ADSL » recouvre des périphériques aux fonctionnements très différents. Les modems les plus simples à employer avec Linux sont ceux qui disposent d'une interface Ethernet. Ceux-ci ont tendance à se répandre, les fournisseurs d'accès à Internet par ADSL prêtant (ou louant) de plus en plus souvent une « box » disposant d'interfaces Ethernet en plus (ou en remplacement) des interfaces USB. Selon le type de modem, la configuration nécessaire peut fortement varier.
			</para>
			 <section id="sect.adsl-pppoe">
				<title>Modem fonctionnant avec PPPOE</title>
				 <indexterm>
					<primary>PPPOE</primary>
				</indexterm>
				 <indexterm>
					<primary><command>pppoeconf</command></primary>
				</indexterm>
				 <para>
					Certains modems Ethernet fonctionnent avec le protocole PPPOE (<foreignphrase>Point-to-Point Protocol Over Ethernet</foreignphrase>, ou protocole point à point sur Ethernet). L'utilitaire <command>pppoeconf</command> (du paquet éponyme) configurera la connexion. Pour cela, il modifiera le fichier <filename>/etc/ppp/peers/dsl-provider</filename> avec les paramètres fournis et enregistrera les informations d'authentification dans les fichiers <filename>/etc/ppp/pap-secrets</filename> et <filename>/etc/ppp/chap-secrets</filename>. Il est recommandé d'accepter toutes les modifications qu'il propose.
				</para>
				 <para>
					Cette configuration mise en place, on pourra démarrer la connexion ADSL par la commande <command>pon dsl-provider</command> et la stopper avec <command>poff dsl-provider</command>.
				</para>
				 <indexterm>
					<primary><literal>dsl-provider</literal></primary>
				</indexterm>
				 <sidebar> <title><emphasis>ASTUCE</emphasis> Exécuter <command>ppp</command> au démarrage de l'ordinateur</title>
				 <indexterm>
					<primary><command>systemd</command></primary>
				</indexterm>
				 <indexterm>
					<primary><command>init</command></primary>
				</indexterm>
				 <para>
					Les connexions PPP par ADSL sont par définition intermittentes. Comme elles ne sont pas facturées à la durée, la tentation est grande de les garder toujours ouvertes ; un moyen simple est de les faire démarrer par le processus <command>init</command>.
				</para>
				 <para>
					With systemd, adding an automatically restarting task for the ADSL connection is a simple matter of creating a “unit file” such as <filename>/etc/systemd/system/adsl-connection.service</filename>, with contents such as the following:
				</para>
				 
<programlisting>[Unit]
Description=ADSL connection

[Service]
Type=forking
ExecStart=/usr/sbin/pppd call dsl-provider
Restart=always

[Install]
WantedBy=multi-user.target</programlisting>
				 <para>
					Une fois ce nouveau service défini, il doit être activé avec <command>systemctl enable adsl-connection</command> puis démarré avec <command>systemctl start adsl-connection</command>. Ainsi, en plus de se relancer après chaque interruption, il s'activera également à chaque démarrage.
				</para>
				 <para>
					Pour les systèmes qui n'utilisent pas <command>systemd</command> (y compris ceux exploitant <emphasis role="distribution">Wheezy</emphasis> et les versions antérieures de Debian), le système d'initialisation SystemV fonctionne différemment. Sur ces systèmes, il suffit d'ajouter la ligne ci-dessous au fichier <filename>/etc/inittab</filename> ; toute interruption provoquera alors immédiatement l'invocation d'une nouvelle connexion par <command>init</command>.
				</para>
				 
<programlisting>
adsl:2345:respawn:/usr/sbin/pppd call dsl-provider</programlisting>
				 <para>
					Pour les connexions ADSL qui subissent une déconnexion quotidienne, cette méthode permet de réduire la durée de la coupure.
				</para>
				 </sidebar>
			</section>
			 <section id="sect.adsl-pptp">
				<title>Modem fonctionnant avec PPTP</title>
				 <indexterm>
					<primary>PPTP</primary>
				</indexterm>
				 <para>
					Le protocole PPTP (<foreignphrase>Point-to-Point Tunneling Protocol</foreignphrase>, ou protocole point à point par tunnel) est une invention de Microsoft. Déployé aux débuts de l'ADSL, il a rapidement été remplacé par PPPOE. Si ce protocole vous est imposé, voyez la <xref linkend="sect.pptp" />.
				</para>

			</section>
			 <section id="sect.adsl-dhcp">
				<title>Modem fonctionnant avec DHCP</title>
				 <para>
					Lorsque le modem est connecté à l'ordinateur par un câble Ethernet (croisé), il fait le plus souvent office de serveur DHCP (c'est parfois une option de configuration à activer sur le modem). Il suffit alors à l'ordinateur de configurer une connexion réseau par DHCP ; le modem s'inscrit automatiquement comme passerelle par défaut et prend en charge le travail de routage (c'est-à-dire qu'il gère le trafic réseau entre l'ordinateur et Internet).
				</para>
				 <sidebar> <title><emphasis>B.A.-BA</emphasis> Câble croisé pour une connexion Ethernet directe</title>
				 <indexterm>
					<primary>câble croisé</primary>
				</indexterm>
				 <para>
					Les cartes réseau des ordinateurs s'attendent à recevoir les données sur un brin particulier du câble et les envoyer sur un autre. Lorsqu'on relie un ordinateur à un réseau local, on branche habituellement un câble (droit ou décroisé) entre la carte réseau et un répétiteur ou un commutateur, qui est prévu pour. Cependant, si l'on souhaite relier deux ordinateurs directement (c'est-à-dire sans répétiteur/commutateur intermédiaire), il faut acheminer le signal émis par une carte vers le brin de réception de l'autre carte et réciproquement ; c'est là l'objet (et la nécessité) d'un câble croisé.
				</para>
				 <para>
					Il est à noter que cette distinction n'est plus très utile ; les cartes réseau modernes sont capables de détecter automatiquement le type de câble présent et de s'adapter en conséquence, et il n'est pas rare que les deux types de câbles fonctionnent à l'identique dans un environnement donné.
				</para>
				 </sidebar> <para>
					La plupart des « routeurs ADSL » du marché fonctionnent de cette manière, de même que la plupart des modems ADSL mis à disposition par les fournisseurs d'accès à Internet.
				</para>

			</section>

		</section>
		 <section id="sect.roaming-network-config">
			<title>Configuration réseau itinérante</title>
			 <indexterm>
				<primary><emphasis role="pkg">network-manager</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>réseau</primary>
				<secondary>configuration itinérante</secondary>
			</indexterm>
			 <para>
				De nombreux ingénieurs de Falcot disposent d'un ordinateur portable professionnel qu'ils emploient aussi bien chez eux qu'au travail. Bien entendu, la configuration réseau à employer n'est pas la même selon l'endroit. À la maison, c'est un réseau Wi-Fi (protégé par une clé WPA) et au travail, c'est un réseau filaire offrant plus de sécurité et plus de débit.
			</para>
			 <para>
				Pour éviter de devoir manuellement activer ou désactiver les interfaces réseau correspondantes, les administrateurs ont installé le paquet <emphasis role="pkg">network-manager</emphasis> sur ces portables. Ce logiciel permet à l'utilisateur de basculer facilement d'un réseau à un autre grâce à une petite icône affichée dans la zone de notification des bureaux graphiques. Un clic sur l'icône affiche une liste des réseaux disponibles (filaires et Wi-Fi), il ne reste plus qu'à choisir le réseau de son choix. Le logiciel garde en mémoire les réseaux sur lesquels l'utilisateur s'est déjà connecté et bascule automatiquement sur le meilleur réseau disponible lorsque la connexion actuelle vient à disparaître.
			</para>
			 <para>
				Pour réaliser cela, le logiciel est structuré en deux parties : un démon tournant en root effectue les opérations d'activation et de configuration des interfaces réseau, et une interface utilisateur pilote ce démon. La gestion des droits d'accès est confiée à PolicyKit ; la configuration proposée par Debian spécifie que seuls les membres du groupe <literal>netdev</literal> ont le droit de créer ou modifier les connexions de Network Manager.
			</para>
			 <para>
				Network Manager sait désormais gérer des connexions de divers types (DHCP, configuration manuelle, réseau local seulement), mais seulement si la configuration se fait par son biais. C'est pourquoi il ignorera systématiquement toutes les interfaces réseau dont la configuration dans <filename>/etc/network/interfaces</filename> ne lui convient pas. Le plus simple est encore d'enlever toute configuration pour chaque interface qui doit être gérée par Network Manager. En effet, le logiciel n'indiquera pas pourquoi il n'affiche aucune connexion réseau disponible.
			</para>
			 <para>
				Il est intéressant de noter que ce logiciel est installé par défaut lorsque la tâche « Environnement bureautique » est sélectionnée au cours de l'installation initiale.
			</para>

		</section>

	</section>
	 <section id="sect.hostname-name-service">
		<title>Attribution et résolution de noms</title>
		 <indexterm>
			<primary>nom</primary>
			<secondary>attribution et résolution</secondary>
		</indexterm>
		 <indexterm>
			<primary>attribution des noms</primary>
		</indexterm>
		 <para>
			Affubler de noms les numéros IP vise à en faciliter la mémorisation par l'humain. En réalité, une adresse IP identifie une interface réseau — un périphérique associé à une carte réseau ou assimilé ; chaque machine peut donc en compter plusieurs et, par conséquent, recevoir plusieurs noms dans le système responsable de leur attribution : le DNS.
		</para>
		 <para>
			Chaque machine est cependant identifiée par un nom principal (ou « canonique »), stocké dans le fichier <filename>/etc/hostname</filename> et communiqué au noyau Linux par les scripts d'initialisation à travers la commande <command>hostname</command>. On peut en prendre connaissance dans le fichier virtuel <filename>/proc/sys/kernel/hostname</filename>.
		</para>
		 <indexterm>
			<primary><command>hostname</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>B.A.-BA</emphasis> <filename>/proc/</filename> et <filename>/sys/</filename>, systèmes de fichiers virtuels</title>
		 <indexterm>
			<primary><filename>/proc/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>proc</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/sys/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>sys</filename></primary>
		</indexterm>
		 <para>
			Les arborescences <filename>/proc/</filename> et <filename>/sys/</filename> sont gérées par des systèmes de fichiers « virtuels ». Il s'agit en fait d'un moyen pratique de récupérer des informations depuis le noyau (en lisant des fichiers virtuels) et de lui en communiquer (en écrivant dans des fichiers virtuels).
		</para>
		 <para>
			<filename>/sys/</filename> est tout particulièrement prévu pour donner accès à des objets internes du noyau, en particulier ceux qui représentent les différents périphériques du système. Le noyau peut ainsi partager de nombreuses informations : l'état de chaque périphérique (par exemple, s'il est en mode d'économie d'énergie), s'agit-il d'un périphérique amovible, etc. Signalons que <filename>/sys/</filename> n'existe que depuis les noyaux 2.6.
		</para>
		 </sidebar> <para>
			Étonnamment, le nom de domaine n'est pas géré de la même manière, mais provient du nom complet de la machine, obtenu par une résolution de noms. On pourra le modifier dans le fichier <filename>/etc/hosts</filename> ; il suffit d'y placer un nom complet de machine au début de la liste des noms associés à l'adresse de la machine comme dans l'exemple ci-dessous :
		</para>
		 <informalexample> 
<programlisting>
127.0.0.1     localhost
192.168.0.1   arrakis.falcot.com arrakis</programlisting>
		 </informalexample> <indexterm>
			<primary><filename>hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/etc/hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary>domaine</primary>
			<secondary>nom de</secondary>
		</indexterm>
		 <indexterm>
			<primary>nom</primary>
			<secondary>de domaine</secondary>
		</indexterm>
		 <indexterm>
			<primary>NSS</primary>
		</indexterm>
		 <section id="sect.name-resolution">
			<title>Résolution de noms</title>
			 <indexterm>
				<primary>résolution</primary>
				<secondary>de nom</secondary>
			</indexterm>
			 <indexterm>
				<primary>nom</primary>
				<secondary>résolution</secondary>
			</indexterm>
			 <para>
				Le mécanisme de résolution de noms de Linux, modulaire, peut s'appuyer sur différentes sources d'informations déclarées dans le fichier <filename>/etc/nsswitch.conf</filename>. L'entrée qui concerne la résolution des noms d'hôtes est <literal>hosts</literal>. Par défaut, elle contient <literal>files dns</literal>, ce qui signifie que le système consulte en priorité le fichier <filename>/etc/hosts</filename> puis interroge les serveurs DNS. Des serveurs NIS/NIS+ ou LDAP forment d'autres sources possibles.
			</para>
			 <sidebar> <title><emphasis>NOTE</emphasis> NSS et DNS</title>
			 <para>
				Attention, les commandes destinées spécifiquement à interroger le DNS (notamment <command>host</command>) ne consultent pas le mécanisme standard de résolution de noms (NSS). Elles ne tiennent donc pas compte de <filename>/etc/nsswitch.conf</filename>, ni a fortiori de <filename>/etc/hosts</filename>.
			</para>
			 </sidebar> <section id="sect.dns-server-configuration">
				<title>Configuration des serveurs DNS</title>
				 <indexterm>
					<primary>DNS</primary>
				</indexterm>
				 <indexterm>
					<primary><foreignphrase>Domain Name Service</foreignphrase></primary>
				</indexterm>
				 <para>
					Le DNS (<foreignphrase>Domain Name Service</foreignphrase>, ou service de noms) est un service distribué et hiérarchique associant des noms à des adresses IP et vice versa. Concrètement, il permet de savoir que <literal>www.eyrolles.com</literal> est en réalité l'adresse IP <literal>213.244.11.247</literal>.
				</para>
				 <para>
					Pour accéder aux informations du DNS, il faut disposer d'un serveur DNS relayant les requêtes. Falcot SA a les siens, mais un particulier fait normalement appel aux serveurs DNS de son fournisseur d'accès à Internet.
				</para>
				 <indexterm>
					<primary><filename>resolv.conf</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><literal>nameserver</literal></primary>
				</indexterm>
				 <para>
					Les serveurs DNS à employer sont donnés dans le fichier <filename>/etc/resolv.conf</filename> à raison d'un par ligne, le terme <literal>nameserver</literal> y précédant l'adresse IP, comme dans l'exemple suivant :
				</para>
				 
<programlisting>
nameserver 212.27.32.176
nameserver 212.27.32.177
nameserver 8.8.8.8</programlisting>
				 <para>
					Signalons que le fichier <filename>/etc/resolv.conf</filename> est modifié automatiquement (et souvent écrasé) lorsque le réseau est géré par NetworkManager ou configuré par DHCP.
				</para>

			</section>
			 <section id="sect.etc-hosts">
				<title>Fichier <filename>/etc/hosts</filename></title>
				 <indexterm>
					<primary><filename>hosts</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/hosts</filename></primary>
				</indexterm>
				 <para>
					En l'absence d'un serveur de noms sur le réseau local, il est tout de même possible d'établir une petite table de correspondance entre adresses IP et noms de machines dans le fichier <filename>/etc/hosts</filename>, habituellement réservée aux postes du réseau local. La syntaxe de ce fichier est très simple : chaque ligne significative précise une adresse IP suivie de la liste de tous les noms qui y sont associés (le premier étant « complètement qualifié », c'est-à-dire incluant le nom de domaine).
				</para>
				 <para>
					Ce fichier est disponible même en cas de panne réseau ou quand les serveurs DNS sont injoignables, mais ne sera vraiment utile que dupliqué sur toutes les machines du réseau. Au moindre changement dans les correspondances, il faudra donc le mettre à jour partout. C'est pourquoi <filename>/etc/hosts</filename> ne renferme généralement que les entrées les plus importantes (et notamment celle de sa propre machine).
				</para>
				 <para>
					Pour un petit réseau non connecté à Internet, ce fichier suffira, mais à partir de cinq machines il est recommandé d'installer un serveur DNS en bonne et due forme.
				</para>
				 <sidebar> <title><emphasis>ASTUCE</emphasis> Court-circuiter le DNS</title>
				 <para>
					Étant donné que les applications consultent le fichier <filename>/etc/hosts</filename> avant d'interroger le DNS, il est possible d'y mettre des informations différentes de celles habituellement renvoyées par celui-ci, et donc de le court-circuiter.
				</para>
				 <para>
					Cela permet, en cas de changements DNS pas encore propagés, de tester l'accès à un site web avec le nom prévu même si celui-ci n'est pas encore associé à la bonne adresse IP.
				</para>
				 <para>
					Autre emploi original, il est possible de rediriger le trafic destiné à un hôte donné vers la machine locale afin qu'aucune communication avec cet hôte ne soit possible. Les noms de serveurs dédiés à l'envoi de bannières publicitaires pourraient faire l'objet d'une telle mesure, ce qui rendrait la navigation plus fluide et moins distrayante puisque leurs annonces ne pourraient plus être chargées.
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.user-group-databases">
		<title>Base de données des utilisateurs et des groupes</title>
		 <indexterm>
			<primary>utilisateur</primary>
			<secondary>base de données</secondary>
		</indexterm>
		 <indexterm>
			<primary>groupe</primary>
			<secondary>base de données</secondary>
		</indexterm>
		 <indexterm>
			<primary>base de données</primary>
			<secondary>des utilisateurs</secondary>
		</indexterm>
		 <indexterm>
			<primary>base de données</primary>
			<secondary>des groupes</secondary>
		</indexterm>
		 <para>
			La liste des utilisateurs est habituellement stockée dans le fichier <filename>/etc/passwd</filename>, alors que le fichier <filename>/etc/shadow</filename> stocke les mots de passe chiffrés. Tous deux sont de simples fichiers texte, au format relativement simple, consultables et modifiables avec un éditeur de texte. Chaque utilisateur y est décrit sur une ligne par plusieurs champs séparés par deux-points (« <literal>:</literal> »).
		</para>
		 <sidebar> <title><emphasis>ATTENTION</emphasis> Édition des fichiers système</title>
		 <para>
			Les fichiers système mentionnés dans ce chapitre sont au format texte simple et sont donc éditables avec un éditeur de texte. Étant donnée leur importance, il est toutefois recommandé de prendre des précautions supplémentaires garantissant qu'un fichier ne soit pas modifié par plusieurs personnes à la fois (ce qui pourrait causer une corruption).
		</para>
		 <para>
			Pour cela, il suffit d'employer la commande <command>vipw</command> pour éditer <filename>/etc/passwd</filename>, ou <command>vigr</command> pour <filename>/etc/group</filename>. Ces dernières posent un verrou sur le fichier concerné avant d'exécuter un éditeur de texte (<command>vi</command> par défaut, sauf si la variable d'environnement <varname>EDITOR</varname> est définie). L'option <literal>-s</literal> de ces commandes permet d'éditer le fichier <foreignphrase>shadow</foreignphrase> correspondant.
		</para>
		 </sidebar> <sidebar> <title><emphasis>B.A.-BA</emphasis> <foreignphrase>Crypt</foreignphrase>, une fonction à sens unique</title>
		 <indexterm>
			<primary><foreignphrase>crypt</foreignphrase></primary>
		</indexterm>
		 <para>
			<command>crypt</command> est une fonction à sens unique qui transforme une chaîne (<varname>A</varname>) en une autre chaîne (<varname>B</varname>) de telle sorte qu'à partir de <varname>B</varname>, il ne soit pas possible dans le cas général de retrouver <varname>A</varname>. La seule manière d'identifier <varname>A</varname> est de tester toutes les valeurs possibles, en vérifiant pour chacune si sa transformation par la fonction produit <varname>B</varname> ou non. Elle utilise jusqu'à 8 caractères en entrée (chaîne <varname>A</varname>) et génère une chaîne de 13 caractères ASCII imprimables (chaîne <varname>B</varname>).
		</para>
		 </sidebar> <section id="sect.etc-passwd">
			<title>Liste des utilisateurs : <filename>/etc/passwd</filename></title>
			 <para>
				Voici la liste des champs du fichier <filename>/etc/passwd</filename> :
			</para>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/passwd</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>uid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>gid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>GECOS</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>login</literal></primary>
			</indexterm>
			 <itemizedlist>
				<listitem>
					<para>
						identifiant (ou <foreignphrase>login</foreignphrase>), par exemple <literal>rhertzog</literal> ;
					</para>

				</listitem>
				 <listitem>
					<para>
						mot de passe : il s'agit d'un mot de passe chiffré par la fonction à sens unique (<command>crypt</command>), qui utilise <literal>DES</literal>, <literal>MD5</literal>, <literal>SHA-256</literal> ou <literal>SHA-512</literal>. La valeur spéciale « <literal>x</literal> » indique que le mot de passe chiffré est stocké dans <filename>/etc/shadow</filename> ;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uid</literal> : numéro unique identifiant l'utilisateur ;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal> : numéro unique du groupe principal de l'utilisateur (Debian crée par défaut un groupe spécifique à chacun) ;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>GECOS</literal> : champ de renseignements qui contient habituellement le nom complet de l'utilisateur ;
					</para>

				</listitem>
				 <listitem>
					<para>
						répertoire de connexion, attribué à l'utilisateur pour qu'il y stocke ses fichiers personnels (la variable d'environnement <varname>$HOME</varname> y pointe habituellement) ;
					</para>

				</listitem>
				 <listitem>
					<para>
						programme à exécuter après la connexion. Il s'agit généralement d'un interpréteur de commandes (shell), donnant libre cours à l'utilisateur. Si l'on précise <command>/bin/false</command> (programme qui ne fait rien et rend la main immédiatement), l'utilisateur ne pourra pas se connecter.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>B.A.-BA</emphasis> Groupe Unix</title>
			 <indexterm>
				<primary>groupe</primary>
			</indexterm>
			 <para>
				Un groupe Unix est une entité regroupant plusieurs utilisateurs afin qu'ils puissent facilement se partager des fichiers à l'aide du système de droits intégré (en jouissant justement des mêmes droits). On peut également restreindre l'utilisation de certains programmes à un groupe donné.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-shadow">
			<title>Le fichier des mots de passe chiffrés et cachés : <filename>/etc/shadow</filename></title>
			 <indexterm>
				<primary><filename>shadow</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/shadow</filename></primary>
			</indexterm>
			 <para>
				Le fichier <filename>/etc/shadow</filename> contient les champs suivants :
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						identifiant (ou <foreignphrase>login</foreignphrase>) ;
					</para>

				</listitem>
				 <listitem>
					<para>
						mot de passe chiffré ;
					</para>

				</listitem>
				 <listitem>
					<para>
						plusieurs champs de gestion de l'expiration du mot de passe.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>DOCUMENTATION</emphasis> Formats de <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> et <filename>/etc/group</filename></title>
			 <para>
				Ces formats sont documentés dans les pages de manuel suivantes : <citerefentry><refentrytitle>passwd</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>shadow</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> et <citerefentry><refentrytitle>group</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>.
			</para>
			 </sidebar> <sidebar> <title><emphasis>SÉCURITÉ</emphasis> Sûreté du fichier <filename>/etc/shadow</filename></title>
			 <para>
				<filename>/etc/shadow</filename>, contrairement à son alter ego <filename>/etc/passwd</filename>, est inaccessible en lecture aux utilisateurs. Tout mot de passe chiffré stocké dans <filename>/etc/passwd</filename> est lisible par tous ; un indélicat peut alors entreprendre de le « casser » par une méthode de force brute, consistant simplement à chiffrer successivement tous les mots de passe simples pour tenter de le découvrir. Cette attaque, dite « du dictionnaire », qui dévoile les mots de passe mal choisis, n'est plus possible avec le fichier <filename>/etc/shadow</filename>.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.account-modification">
			<title>Modifier un compte ou mot de passe existant</title>
			 <indexterm>
				<primary><command>chsh</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chfn</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chage</command></primary>
			</indexterm>
			 <indexterm>
				<primary>mot de passe</primary>
			</indexterm>
			 <para>
				Quelques commandes permettent de modifier la plupart des informations stockées dans ces bases de données. Chaque utilisateur peut ainsi changer de mot de passe, sans doute le champ le plus variable, grâce à la commande <command>passwd</command>. <command>chfn</command> <foreignphrase>(CHange Full Name)</foreignphrase>, réservée au super-utilisateur root, intervient sur le champ <literal>GECOS</literal>. <command>chsh</command> <foreignphrase>(CHange SHell)</foreignphrase> permet de changer de « shell de login », ou interpréteur de commandes de connexion, mais le choix des utilisateurs sera limité à la liste donnée dans <filename>/etc/shells</filename> — alors que l'administrateur pourra saisir le nom de programme de son choix.
			</para>
			 <para>
				Enfin, la commande <command>chage</command> <foreignphrase>(CHange AGE)</foreignphrase> donnera à l'administrateur la possibilité de modifier les conditions d'expiration du mot de passe (l'option <literal>-l <replaceable>utilisateur</replaceable></literal> listant la configuration actuelle). On pourra d'ailleurs forcer l'expiration d'un mot de passe grâce à la commande <command>passwd -e <replaceable>utilisateur</replaceable></command>, qui obligera l'utilisateur à changer son mot de passe à la prochaine connexion.
			</para>

		</section>
		 <section id="sect.disabling-account">
			<title>Bloquer un compte</title>
			 <indexterm>
				<primary>bloquer un compte</primary>
			</indexterm>
			 <indexterm>
				<primary>compte</primary>
				<secondary>bloquer</secondary>
			</indexterm>
			 <para>
				On peut se trouver dans l'obligation de « bloquer le compte » d'un utilisateur, par mesure disciplinaire, dans le cadre d'une enquête, ou tout simplement en cas de départ prolongé ou définitif de l'utilisateur. Il s'agit en fait de l'empêcher de se connecter à nouveau, sans pour autant détruire son compte et ses fichiers. Cela s'effectue simplement par la commande <command>passwd -l <replaceable>utilisateur</replaceable></command> (<foreignphrase>lock</foreignphrase>, ou bloquer). La remise en service s'effectue de même, avec l'option <literal>-u</literal> (<foreignphrase>unlock</foreignphrase>, ou débloquer).
			</para>
			 <sidebar id="sidebar.intro-nss"> <title><emphasis>POUR ALLER PLUS LOIN</emphasis> Base de données système et NSS</title>
			 <indexterm>
				<primary>NSS</primary>
			</indexterm>
			 <indexterm>
				<primary><foreignphrase>Name Service Switch</foreignphrase></primary>
			</indexterm>
			 <para>
				Au lieu d'employer les fichiers habituels pour gérer les listes des utilisateurs et des groupes, on peut recourir à d'autres types de bases de données — comme LDAP ou <command>db</command> — en employant un module NSS (<foreignphrase>Name Service Switch</foreignphrase>, ou multiplexeur de service de noms) adéquat. Les listes des modules employés se trouvent dans le fichier <filename>/etc/nsswitch.conf</filename> sous les entrées <literal>passwd</literal>, <literal>shadow</literal> et <literal>group</literal>. Voir la <xref linkend="sect.config-nss" /> pour un exemple concret d'emploi du module NSS pour LDAP.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-group">
			<title>Liste des groupes : <filename>/etc/group</filename></title>
			 <para>
				La liste des groupes est stockée dans le fichier <filename>/etc/group</filename>, simple base de données textuelle au format comparable à celui de <filename>/etc/passwd</filename>, qui utilise les champs suivants :
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						identifiant (le nom du groupe) ;
					</para>

				</listitem>
				 <listitem>
					<para>
						mot de passe (facultatif) : il ne sert qu'à intégrer un groupe dont on n'est pas habituellement membre (avec la commande <command>newgrp</command> ou <command>sg</command> — voir encadré <xref linkend="sidebar.working-with-several-groups" />) ;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal> : numéro unique identifiant le groupe ;
					</para>

				</listitem>
				 <listitem>
					<para>
						liste des membres : liste des identifiants d'utilisateurs membres du groupe, séparés par des virgules.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
			</para>
			 <sidebar id="sidebar.working-with-several-groups"> <title><emphasis>B.A.-BA</emphasis> Travailler avec plusieurs groupes</title>
			 <indexterm>
				<primary><command>newgrp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sg</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>id</command></primary>
			</indexterm>
			 <indexterm>
				<primary>groupe</primary>
				<secondary>changer de</secondary>
			</indexterm>
			 <para>
				Chaque utilisateur peut donc faire partie de plusieurs groupes ; l'un d'entre eux est son « groupe principal » ; le groupe principal par défaut est mis en place lors de la connexion. Par défaut, chaque fichier qu'il crée lui appartient, ainsi qu'au groupe principal. Cela n'est pas toujours souhaitable : c'est par exemple le cas lors d'un travail dans un répertoire partagé grâce à un groupe différent de son groupe principal. Dans ce cas, l'utilisateur a intérêt à changer temporairement de groupe principal grâce aux commandes <command>newgrp</command> — qui démarre un nouveau shell — ou <command>sg</command> — qui se contente d'exécuter une commande. Ces commandes permettent aussi de rejoindre un groupe dont on ne fait pas partie si le groupe est protégé par un mot de passe connu.
			</para>
			 <para>
				Une alternative consiste à positionner le bit <literal>setgid</literal> sur le répertoire, ce qui permet aux fichiers créés dans ce répertoire d'appartenir automatiquement au bon groupe. On se référera pour les détails à l'encadré <xref linkend="sidebar.setgid-dir" />.
			</para>
			 <para>
				La commande <command>id</command> permet de vérifier à tout instant son identifiant personnel (variable <varname>uid</varname>), le groupe principal actuel (variable <varname>gid</varname>) et la liste des groupes dont on fait partie (variable <varname>groupes</varname>).
			</para>
			 </sidebar> <indexterm>
				<primary><filename>group</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/group</filename></primary>
			</indexterm>
			 <para>
				The <command>addgroup</command> and <command>delgroup</command> commands add or delete a group, respectively. The <command>groupmod</command> command modifies a group's information (its <literal>gid</literal> or identifier). The command <command>gpasswd <replaceable>group</replaceable></command> changes the password for the group, while the <command>gpasswd -r <replaceable>group</replaceable></command> command deletes it.
			</para>
			 <indexterm>
				<primary><command>addgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>delgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>groupmod</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>gpasswd</command></primary>
			</indexterm>
			 <indexterm>
				<primary>groupe</primary>
				<secondary>création</secondary>
			</indexterm>
			 <indexterm>
				<primary>création</primary>
				<secondary>de groupe</secondary>
			</indexterm>
			 <indexterm>
				<primary>groupe</primary>
				<secondary>suppression</secondary>
			</indexterm>
			 <indexterm>
				<primary>suppression de groupe</primary>
			</indexterm>
			 <sidebar> <title><emphasis>ASTUCE</emphasis> <command>getent</command></title>
			 <indexterm>
				<primary><command>getent</command></primary>
			</indexterm>
			 <para>
				La commande <command>getent</command> (<foreignphrase>get entries</foreignphrase>) consulte les bases de données du système de manière classique, en employant les appels système adéquats, donc les modules NSS configurés dans le fichier <filename>/etc/nsswitch.conf</filename>. Elle prend un ou deux arguments : le nom de la base de données à consulter et une éventuelle clé de recherche. Ainsi, la commande <command>getent passwd rhertzog</command> renvoie les informations de la base de données des utilisateurs concernant l'utilisateur <literal>rhertzog</literal>.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.creating-accounts">
		<title>Création de compte</title>
		 <indexterm>
			<primary>compte</primary>
			<secondary>création</secondary>
		</indexterm>
		 <indexterm>
			<primary>création</primary>
			<secondary>de compte</secondary>
		</indexterm>
		 <para>
			L'une des premières actions de l'administrateur est de créer les comptes de ses utilisateurs, ce qui s'effectue très simplement avec la commande <command>adduser</command>. Celle-ci prend simplement en argument l'identifiant utilisateur à créer.
		</para>
		 <indexterm>
			<primary><command>adduser</command></primary>
		</indexterm>
		 <para>
			<command>adduser</command> pose quelques questions avant de créer le compte à proprement parler, mais son déroulement offre peu de surprises. Le fichier de configuration <filename>/etc/adduser.conf</filename> offre toutefois quelques paramétrages intéressants. On pourra ainsi prévoir automatiquement un quota à chaque nouvel utilisateur en dupliquant celui d'un utilisateur « modèle ». On pourra aussi modifier l'emplacement du compte utilisateur, ce qui ne présente que rarement de l'utilité — c'est le cas si les utilisateurs sont si nombreux qu'il est souhaitable de répartir leurs comptes sur plusieurs disques. On pourra encore choisir un autre interpréteur de commandes par défaut.
		</para>
		 <sidebar> <title><emphasis>B.A.-BA</emphasis> Quota</title>
		 <indexterm>
			<primary>quota</primary>
		</indexterm>
		 <para>
			Le terme « quota » désigne une limitation des ressources de la machine qu'un utilisateur peut employer. Il s'agit souvent d'espace disque.
		</para>
		 </sidebar> <para>
			La création du compte fabrique le répertoire personnel et y recopie le contenu du répertoire modèle <filename>/etc/skel/</filename>, afin de fournir quelques fichiers standards.
		</para>
		 <indexterm>
			<primary>groupe</primary>
			<secondary>ajout d'un utilisateur</secondary>
		</indexterm>
		 <indexterm>
			<primary>ajout d'un utilisateur dans un groupe</primary>
		</indexterm>
		 <para>
			Dans certains cas, il sera utile d'ajouter un utilisateur dans un groupe, en particulier pour lui conférer des droits supplémentaires. Par exemple, un utilisateur intégré au groupe <emphasis>audio</emphasis> pourra accéder aux périphériques son (voir encadré <xref linkend="sidebar.special-files" />). Pour ce faire, on procède avec la commande <command>adduser <replaceable>utilisateur</replaceable> <replaceable>groupe</replaceable></command>.
		</para>
		 <sidebar id="sidebar.special-files"> <title><emphasis>B.A.-BA</emphasis> Droits d'accès à un périphérique</title>
		 <indexterm>
			<primary>périphérique</primary>
			<secondary>droit d'accès</secondary>
		</indexterm>
		 <indexterm>
			<primary>fichier</primary>
			<secondary>spécial</secondary>
		</indexterm>
		 <indexterm>
			<primary>mode</primary>
			<secondary>caractère</secondary>
		</indexterm>
		 <indexterm>
			<primary>mode</primary>
			<secondary>bloc</secondary>
		</indexterm>
		 <indexterm>
			<primary>bloc, mode</primary>
		</indexterm>
		 <indexterm>
			<primary>caractère, mode</primary>
		</indexterm>
		 <indexterm>
			<primary>spécial, fichier</primary>
		</indexterm>
		 <indexterm>
			<primary><command>mknod</command></primary>
		</indexterm>
		 <para>
			Chaque périphérique matériel est représenté sous Unix par un fichier dit « spécial », habituellement stocké dans l'arborescence <filename>/dev/</filename> (<foreignphrase>DEVices</foreignphrase>). On distingue deux types de fichiers spéciaux selon la nature du périphérique : des fichiers en « mode caractère » et des fichiers en « mode bloc », chaque mode ne permettant qu'un nombre limité d'opérations. Alors que le mode caractère limite les interactions aux opérations de lecture et d'écriture, le mode bloc permet aussi de se déplacer dans le flux de données disponibles. Enfin, chaque fichier spécial est associé à deux nombres (dits « majeur » et « mineur ») qui identifient de manière unique le périphérique auprès du noyau. Un tel fichier, créé par la commande <command>mknod</command>, n'a donc qu'un nom symbolique plus pratique pour l'utilisateur humain.
		</para>
		 <para>
			Les droits d'accès à un fichier spécial décrivent directement les droits d'accès au périphérique. Ainsi, un fichier comme <filename>/dev/mixer</filename> — représentant le mixer audio — n'est par défaut accessible en lecture/écriture qu'à l'utilisateur root et aux membres du groupe <literal>audio</literal>. Seuls ces utilisateurs pourront donc exploiter le mixer audio.
		</para>
		 <para>
			Il est à noter que la conjonction d'<emphasis role="pkg">udev</emphasis>, <emphasis role="pkg">consolekit</emphasis> et <emphasis role="pkg">policykit</emphasis> peuvent ajouter des permissions supplémentaires, notamment pour permettre aux utilisateurs connectés physiquement sur la console (et non par le réseau) l'accès à certains périphériques.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.shell-environment">
		<title>Environnement des interpréteurs de commandes</title>
		 <para>
			Les interpréteurs de commandes (ou shells), qui peuvent être le premier contact de l'utilisateur avec l'ordinateur, doivent être assez conviviaux. La plupart utilisent des scripts d'initialisation permettant de configurer leur comportement (complétion automatique, texte d'invite, etc.).
		</para>
		 <indexterm>
			<primary>interpréteur de commandes</primary>
		</indexterm>
		 <indexterm>
			<primary>commandes, interpréteur de</primary>
		</indexterm>
		 <indexterm>
			<primary>shell</primary>
		</indexterm>
		 <indexterm>
			<primary><command>bash</command></primary>
		</indexterm>
		 <para>
			<command>bash</command>, l'interpréteur de commandes standard, emploie les scripts d'initialisation <filename>/etc/bash.bashrc</filename> (pour les shells « interactifs ») et <filename>/etc/profile</filename> (pour les shells « de connexion »).
		</para>
		 <sidebar> <title><emphasis>B.A.-BA</emphasis> Shell de connexion et shell (non) interactif</title>
		 <para>
			Pour simplifier, un shell de connexion est invoqué lors d'une connexion — sur la console, via <command>ssh</command>, ou à travers la commande explicite <command>bash --login</command>. Qu'il soit un shell de connexion ou non, un shell interactif est celui qui prend place dans un terminal de type <command>xterm</command> ; un shell non interactif est celui qui permet d'exécuter un script.
		</para>
		 </sidebar> <sidebar> <title><emphasis>DÉCOUVERTE</emphasis> Autres shells, autres scripts</title>
		 <para>
			Each command interpreter has a specific syntax and its own configuration files. Thus, <command>zsh</command> uses <filename>/etc/zshrc</filename> and <filename>/etc/zshenv</filename>; <command>tcsh</command> uses <filename>/etc/csh.cshrc</filename>, <filename>/etc/csh.login</filename> and <filename>/etc/csh.logout</filename>. The man pages for these programs document which files they use.
		</para>
		 <indexterm>
			<primary><command>zsh</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>tcsh</command></primary>
		</indexterm>
		 </sidebar> <para>
			Pour <command>bash</command>, il est intéressant d'activer la « complétion automatique » dans le fichier <filename>/etc/bash.bashrc</filename> (il suffit pour cela d'y décommenter quelques lignes).
		</para>
		 <sidebar> <title><emphasis>B.A.-BA</emphasis> Complétion automatique</title>
		 <indexterm>
			<primary>complétion automatique</primary>
		</indexterm>
		 <para>
			De nombreux interpréteurs de commandes en sont capables : il s'agit pour eux de compléter automatiquement un nom de commande ou d'argument (fichier ou répertoire) saisi partiellement. Pour cela, l'utilisateur enfoncera la touche de tabulation ; il peut ainsi travailler plus vite et avec moins de risques d'erreur.
		</para>
		 <para>
			This function is very powerful and flexible. It is possible to configure its behavior according to each command. Thus, the first argument following <command>apt</command> will be proposed according to the syntax of this command, even if it does not match any file (in this case, the possible choices are <literal>install</literal>, <literal>remove</literal>, <literal>upgrade</literal>, etc.).
		</para>
		 </sidebar> <sidebar> <title><emphasis>B.A.-BA</emphasis> Le tilde, raccourci vers HOME</title>
		 <indexterm>
			<primary>~</primary>
		</indexterm>
		 <indexterm>
			<primary>tilde</primary>
		</indexterm>
		 <para>
			Le tilde est fréquemment employé pour désigner le répertoire pointé par la variable d'environnement <varname>HOME</varname> (à savoir le répertoire de connexion de l'utilisateur, par exemple <filename>/home/rhertzog/</filename>). Les interpréteurs de commandes font la substitution automatiquement : <filename>~/hello.txt</filename> devient <filename>/home/rhertzog/hello.txt</filename>.
		</para>
		 <para>
			Le tilde permet également d'accéder au répertoire de connexion d'un autre utilisateur. Ainsi, <filename>~rmas/bonjour.txt</filename> est synonyme de <filename>/home/rmas/bonjour.txt</filename>.
		</para>
		 </sidebar> <para>
			En plus de ces scripts communs à tous, chaque utilisateur peut se créer des fichiers <filename>~/.bashrc</filename> et <filename>~/.bash_profile</filename> pour personnaliser son shell. Les ajouts les plus courants sont la mise en place d'alias, mots automatiquement remplacés avant exécution de la commande, ce qui accélère la saisie. On pourra ainsi créer un alias <literal>la</literal> pour la commande <command>ls -la | less</command> et se contenter de saisir <command>la</command> pour inspecter en détail le contenu d'un répertoire.
		</para>
		 <sidebar> <title><emphasis>B.A.-BA</emphasis> Variables d'environnement</title>
		 <indexterm>
			<primary>environnement</primary>
			<secondary>variable d'environnement</secondary>
		</indexterm>
		 <indexterm>
			<primary>variable d'environnement</primary>
		</indexterm>
		 <para>
			Les variables d'environnement permettent de stocker des paramètres globaux à destination du shell ou des divers programmes appelés. Elles sont contextuelles (chaque processus a son propre ensemble de variables d'environnement) mais héritables. Cette dernière caractéristique offre la possibilité à un shell de connexion de déclarer des variables qui se retrouveront dans tous les programmes exécutés par son intermédiaire.
		</para>
		 </sidebar> <para>
			Un élément important de configuration des shells est la mise en place de variables d'environnement par défaut. Si l'on néglige les variables spécifiques à un interpréteur de commandes, il est préférable de mettre celles-ci en place dans le fichier <filename>/etc/environment</filename>, utilisé par les différents programmes susceptibles d'initier une session shell. Parmi les variables susceptibles d'y être définies, citons <varname>ORGANIZATION</varname> qui contient habituellement le nom de l'entreprise ou organisation et <varname>HTTP_PROXY</varname> qui indique l'existence et l'emplacement d'un proxy (ou mandataire) HTTP.
		</para>
		 <sidebar> <title><emphasis>ASTUCE</emphasis> Tous les shells configurés à l'identique</title>
		 <para>
			Les utilisateurs souhaitent souvent configurer de la même manière shells de connexion et interactifs. Pour cela, ils choisissent d'interpréter (ou « sourcer ») le contenu de <filename>~/.bashrc</filename> depuis le fichier <filename>~/.bash_profile</filename>. Il est possible de faire de même avec les fichiers communs à tous les utilisateurs (en appelant <filename>/etc/bash.bashrc</filename> depuis <filename>/etc/profile</filename>).
		</para>
		 </sidebar>
	</section>
	 <section id="sect.config-printing">
		<title>Configuration de l'impression</title>
		 <indexterm>
			<primary>configuration</primary>
			<secondary>de l'impression</secondary>
		</indexterm>
		 <indexterm>
			<primary>impression</primary>
			<secondary>configuration</secondary>
		</indexterm>
		 <para>
			Cette étape a longtemps causé bien des soucis, désormais en passe d'être résolus grâce à <emphasis role="pkg">cups</emphasis>, serveur d'impression libre connaissant le protocole IPP (<foreignphrase>Internet Printing Protocol</foreignphrase>, ou protocole d'impression sur Internet).
		</para>
		 <indexterm>
			<primary>IPP</primary>
		</indexterm>
		 <indexterm>
			<primary><foreignphrase>Internet Printing Protocol</foreignphrase></primary>
		</indexterm>
		 <indexterm>
			<primary><command>cups</command></primary>
		</indexterm>
		 <para>
			This program is divided over several Debian packages: <emphasis role="pkg">cups</emphasis> is the central print server; <emphasis role="pkg">cups-bsd</emphasis> is a compatibility layer allowing use of commands from the traditional BSD printing system (<command>lpd</command> daemon, <command>lpr</command> and <command>lpq</command> commands, etc.); <emphasis role="pkg">cups-client</emphasis> contains a group of programs to interact with the server (block or unblock a printer, view or delete print jobs in progress, etc.); and finally, <emphasis role="pkg">printer-driver-gutenprint</emphasis> contains a collection of additional printer drivers for <command>cups</command>.
		</para>
		 <indexterm>
			<primary><command>lpr</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpq</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>COMMUNAUTÉ</emphasis> CUPS</title>
		 <indexterm>
			<primary>CUPS</primary>
		</indexterm>
		 <indexterm>
			<primary><foreignphrase>Common Unix Printing System</foreignphrase></primary>
		</indexterm>
		 <para>
			CUPS (<foreignphrase>Common Unix Printing System</foreignphrase>, ou système d'impression commun sous Unix) est un projet (et une marque déposée) de la société Apple. <ulink type="block" url="http://www.cups.org/" />
		</para>
		 </sidebar> <para>
			Après installation de ces différents paquets, <command>cups</command> s'administre très facilement grâce à son interface web accessible à l'adresse locale <literal>http://localhost:631</literal>. On pourra y ajouter des imprimantes (y compris réseau), les supprimer et les administrer. On peut encore administrer <emphasis>cups</emphasis> avec l'interface graphique fournie par l'environnement bureautique. Enfin, il y a également l'interface graphique <command>system-config-printer</command> (du paquet Debian éponyme).
		</para>
		 <indexterm>
			<primary><command>cups</command></primary>
			<secondary>administration</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>ATTENTION</emphasis> Obsolescence de <filename>/etc/printcap</filename></title>
		 <para>
			<emphasis>cups</emphasis> no longer uses the <filename>/etc/printcap</filename> file, which is now obsolete. Programs that rely upon this file to get a list of available printers will, thus, fail. To avoid this problem, delete this file and make it a symbolic link (see sidebar <xref linkend="sidebar.symbolic-link" />) to <filename>/run/cups/printcap</filename>, which is maintained by <emphasis>cups</emphasis> to ensure compatibility.
		</para>
		 <indexterm>
			<primary><filename>printcap</filename></primary>
		</indexterm>
		 </sidebar>
	</section>
	 <section id="sect.config-bootloader">
		<title>Configuration du chargeur d'amorçage</title>
		 <indexterm>
			<primary>chargeur</primary>
			<secondary>d'amorçage</secondary>
		</indexterm>
		 <indexterm>
			<primary>amorçage, chargeur de</primary>
		</indexterm>
		 <para>
			Il est probablement déjà fonctionnel, mais il est toujours bon de savoir configurer et installer un chargeur d'amorçage au cas où celui-ci disparaîtrait du <foreignphrase>Master Boot Record</foreignphrase> (enregistrement d'amorçage maître). Cela peut se produire suite à l'installation d'un autre système d'exploitation, tel que Windows. Ces connaissances vous permettront également d'en modifier la configuration si l'actuelle ne vous convient pas.
		</para>
		 <sidebar> <title><emphasis>B.A.-BA</emphasis> <foreignphrase>Master Boot Record</foreignphrase></title>
		 <indexterm>
			<primary>MBR</primary>
		</indexterm>
		 <indexterm>
			<primary><foreignphrase>Master Boot Record</foreignphrase></primary>
		</indexterm>
		 <para>
			Le <foreignphrase>Master Boot Record</foreignphrase> (MBR, ou enregistrement d'amorçage maître) est la zone des 512 premiers octets du premier disque dur, chargée par le BIOS pour donner la main à un programme capable de démarrer le système d'exploitation voulu. En général, un chargeur d'amorçage s'installe donc sur le MBR en écrasant son contenu antérieur.
		</para>
		 </sidebar> <section id="sect.identify-disks">
			<title>Identifier ses disques</title>
			 <sidebar> <title><emphasis>CULTURE</emphasis> <emphasis>udev</emphasis> et <filename>/dev/</filename></title>
			 <para>
				Le répertoire <filename>/dev/</filename> abrite traditionnellement des fichiers dits « spéciaux », destinés à représenter les périphériques du système (voir encadré <xref linkend="sidebar.special-files" />). À une lointaine époque, il contenait des fichiers spéciaux correspondant à tous les périphériques possibles. Cette structure statique présentait un certain nombre d'inconvénients, notamment parce qu'elle restreignait le nombre de périphériques utilisables (puisque leur liste était codée en dur) et qu'elle empêchait de savoir quels fichiers spéciaux correspondaient à un périphérique existant.
			</para>
			 <para>
				De nos jours, les fichiers spéciaux sont gérés de manière entièrement dynamique, ce qui correspond mieux à la nature des périphériques informatiques (dont la plupart peuvent être branchés et débranchés « à chaud »). Le noyau coopère avec <emphasis>udev</emphasis> pour créer et supprimer ces fichiers à la volée lorsque les périphériques apparaissent ou disparaissent. Cela permet de ne pas avoir à stocker le répertoire <filename>/dev/</filename> sur un système de stockage persistant ; au contraire, il est dans un système de fichiers en mémoire qui commence vide et qui ne contient que les entrées pertinentes.
			</para>
			 <para>
				Le noyau fournit de nombreuses informations à propos d'un périphérique lors de son ajout et y ajoute une paire d'identifiants (majeur/mineur). <command>udevd</command> utilise ces informations pour créer le fichier spécial sous le nom voulu et avec les permissions les plus pertinentes. Il peut aussi créer des alias et lancer des actions supplémentaires (par exemple des tâches d'initialisation ou d'enregistrement). Le comportement d'<command>udevd</command> est régi par un vaste ensemble de règles (personnalisables).
			</para>
			 <para>
				Il est ainsi possible, en utilisant les noms affectés de manière dynamique, de garder le même nom pour un périphérique donné, quel que soit le port auquel il est connecté ou l'ordre dans lequel les périphériques ont été branchés, ce qui pourra se révéler très utile si de nombreux périphériques USB sont utilisés. La première partition du premier disque s'appelle généralement <filename>/dev/sda1</filename> pour des raisons de compatibilité ascendante, mais elle pourrait tout aussi bien s'appeler <filename>/dev/partition-principale</filename>, voire les deux à la fois puisqu'il est possible de configurer <command>udevd</command> pour qu'il crée un lien symbolique automatiquement.
			</para>
			 <para>
				En des temps anciens, certains modules noyau se chargeaient automatiquement lorsqu'on tentait d'accéder au périphérique correspondant. Ce n'est désormais plus le cas, le fichier spécial du périphérique n'existant plus avant d'avoir chargé le module… ce qui n'est pas très grave puisque la plupart des modules sont chargés au démarrage grâce à la détection automatique du matériel. Mais pour des périphériques non détectables (comme le bon vieux lecteur de disquettes ou la souris PS/2), cela ne fonctionne pas. Pensez donc à ajouter les modules <literal>floppy</literal>, <literal>psmouse</literal> et <literal>mousedev</literal> dans <filename>/etc/modules</filename> afin de forcer leur chargement au démarrage.
			</para>
			 </sidebar> <indexterm>
				<primary>disque dur, noms</primary>
			</indexterm>
			 <indexterm>
				<primary>nom</primary>
				<secondary>des disques durs</secondary>
			</indexterm>
			 <para>
				La configuration du chargeur d'amorçage doit identifier les différents disques et leurs partitions. Linux emploie pour cela un système de fichiers spéciaux (dits en mode « bloc »), stockés dans le répertoire <filename>/dev/</filename>. Depuis Debian <emphasis role="distribution">Squeeze</emphasis>, le schéma de nommage a été unifié et tous les disques durs (IDE/PATA, SATA, SCSI, USB, IEEE 1394) sont dorénavant représentés par des <filename>/dev/sd*</filename>.
			</para>
			 <para>
				Chaque partition est représentée par un numéro d'ordre au sein du disque où elle réside : <filename>/dev/sda1</filename> est donc la première partition du premier disque et <filename>/dev/sdb3</filename> la troisième partition du deuxième disque.
			</para>
			 <indexterm>
				<primary>partition</primary>
				<secondary>primaire</secondary>
			</indexterm>
			 <indexterm>
				<primary>partition</primary>
				<secondary>étendue</secondary>
			</indexterm>
			 <indexterm>
				<primary>partition</primary>
				<secondary>secondaire</secondary>
			</indexterm>
			 <indexterm>
				<primary>table de partition</primary>
				<secondary>au format MS-DOS</secondary>
			</indexterm>
			 <para>
				L'architecture PC (ou « i386 », y compris son jeune cousin « amd64 ») est limitée à quatre partitions « primaires » par disque. Pour outrepasser cette limitation, l'une d'entre elles sera créée comme une partition « étendue » et pourra alors contenir des partitions « secondaires ». Ces dernières portent toujours un numéro supérieur ou égal à 5. La première partition secondaire pourra donc être <filename>/dev/sda5</filename>, suivie de <filename>/dev/sda6</filename>, etc.
			</para>
			 <para>
				Une autre restriction de la table de partition MS-DOS est qu'elle ne supporte pas des disques de plus de 2 To, ce qui devient un vrai problème avec les disques récents.
			</para>
			 <indexterm>
				<primary>GPT</primary>
				<secondary>format de table de partition</secondary>
			</indexterm>
			 <indexterm>
				<primary>table de partition</primary>
				<secondary>au format GPT</secondary>
			</indexterm>
			 <para>
				Un nouveau format de table de partition, nommé GPT, permet de dépasser ces contraintes sur le nombre de partitions (il supporte jusqu'à 128 partitions) et sur la taille des disques (qui peuvent aller jusqu'à 8 zétaoctets, ce qui représente plus de 8 milliards de téraoctets). Ainsi, si l'on prévoit de créer de nombreuses partitions physiques sur le même disque, il convient de créer une table de partition au format GPT lors de l'étape du partitionnement.
			</para>
			 <para>
				Il n'est pas toujours facile de mémoriser quel disque est branché sur le second contrôleur SATA ou en troisième position dans la chaîne SCSI, d'autant que le nommage des disques durs branchables à chaud (ce qui inclut entre autres la plupart des disques SATA et des disques externes) n'est pas entièrement déterministe et peut changer d'un boot à l'autre. Heureusement, <command>udev</command> crée, en plus des <filename>/dev/sd*</filename>, des liens symboliques de nom fixe, qu'on pourra alors utiliser si l'on souhaite identifier de manière non ambiguë l'un ou l'autre disque. Ces liens symboliques sont stockés dans <filename>/dev/disk/by-id/</filename>. Sur une machine à deux disques physiques, on a par exemple :
			</para>
			 
<screen><computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l
</userinput><computeroutput>total 0
lrwxrwxrwx 1 root root  9 23 juil. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 juil. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 juil. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 juil. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 juil. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 juil. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 juil. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 juil. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 juil. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 juil. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 juil. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 juil. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 juil. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 juil. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 juil. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 juil. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 juil. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </computeroutput></screen>
			 <para>
				On constate que certains disques sont listés plusieurs fois (parce qu'ils se comportent à la fois comme des disques ATA et comme des SCSI), mais l'information pertinente est principalement dans le modèle et le numéro de série des disques, à partir desquels on peut retrouver le fichier de périphérique.
			</para>
			 <para>
				Les exemples de fichiers de configuration donnés dans les sections suivantes reposent tous sur le même cas : un seul disque SATA, dont la première partition est dédiée à un ancien Windows et la seconde contient Debian GNU/Linux.
			</para>

		</section>
		 <section id="sect.config-lilo">
			<title>Configuration de LILO</title>
			 <indexterm>
				<primary>LILO</primary>
			</indexterm>
			 <indexterm>
				<primary><foreignphrase>Linux Loader</foreignphrase></primary>
			</indexterm>
			 <para>
				<emphasis>LILO</emphasis> (<foreignphrase>LInux LOader</foreignphrase>, ou chargeur de Linux) est le plus ancien chargeur d'amorçage, solide mais rustique. Il écrit dans le MBR l'adresse physique du noyau à démarrer ; c'est pourquoi chaque mise à jour de celui-ci (ou du fichier de configuration de LILO) doit être suivie de la commande <command>lilo</command>. L'oublier produira un système incapable de démarrer si l'ancien noyau a été supprimé ou remplacé, puisque le nouveau ne sera pas au même emplacement sur le disque.
			</para>
			 <para>
				LILO a pour fichier de configuration <filename>/etc/lilo.conf</filename> ; un fichier simple pour une configuration standard est illustré par l'exemple ci-dessous.
			</para>
			 <example id="example.lilo.conf">
				<title>Fichier de configuration de LILO</title>
				 
<programlisting>
# Le disque sur lequel LILO doit s'installer.
# En indiquant le disque et non pas une partition,
# on ordonne à LILO de s'installer sur le MBR.
boot=/dev/sda
# la partition qui contient Debian
root=/dev/sda2
# l'élément à charger par défaut
default=Linux

# Noyau le plus récent
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Ancien noyau (si le noyau nouvellement installé ne démarre pas)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# Seulement pour un double amorçage Linux/Windows
other=/dev/sda1
  label=Windows</programlisting>

			</example>

		</section>
		 <section id="sect.config-grub">
			<title>Configuration de GRUB 2</title>
			 <indexterm>
				<primary>GRUB</primary>
			</indexterm>
			 <indexterm>
				<primary>GRUB 2</primary>
			</indexterm>
			 <para>
				<emphasis>GRUB</emphasis> (<foreignphrase>GRand Unified Bootloader</foreignphrase>, ou grand chargeur d'amorçage unifié) est plus récent. Il n'est pas nécessaire de l'invoquer après chaque mise à jour du noyau puisqu'il sait lire les systèmes de fichiers et retrouver tout seul la position du noyau sur le disque. Pour l'installer dans le MBR du premier disque, on saisira simplement <command>grub-install /dev/sda</command>. <indexterm><primary><command>grub-install</command></primary></indexterm>
			</para>
			 <sidebar> <title><emphasis>ATTENTION</emphasis> Noms des disques pour GRUB</title>
			 <para>
				GRUB fait appel au BIOS pour identifier les disques durs. <literal>(hd0)</literal> correspond au premier disque ainsi détecté, <literal>(hd1)</literal> au deuxième, etc. Dans la majorité des cas, cet ordre correspond exactement à l'ordre habituel des disques sous Linux, mais des problèmes peuvent survenir lorsque l'on associe disques SCSI et disques IDE. GRUB stocke les correspondances qu'il détecte dans le fichier <filename>/boot/grub/device.map</filename>. Si vous y trouvez des erreurs (parce que vous savez que votre BIOS détecte les disques dans un autre ordre), corrigez-les manuellement et exécutez à nouveau <command>grub-install</command>. <command>grub-mkdevicemap</command> peut être utile pour créer un fichier <filename>device.map</filename> de départ.
			</para>
			 <para>
				Les partitions portent aussi un nom spécifique à GRUB. Lorsque l'on utilise des partitions « classiques » au format MS-DOS, la première partition du premier disque est notée <literal>(hd0,msdos1)</literal>, la seconde <literal>(hd0,msdos2)</literal>, etc.
			</para>
			 </sidebar> <para>
				GRUB 2 configuration is stored in <filename>/boot/grub/grub.cfg</filename>, but this file (in Debian) is generated from others. Be careful not to modify it by hand, since such local modifications will be lost the next time <command>update-grub</command> is run (which may occur upon update of various packages). The most common modifications of the <filename>/boot/grub/grub.cfg</filename> file (to add command line parameters to the kernel or change the duration that the menu is displayed, for example) are made through the variables in <filename>/etc/default/grub</filename>. To add entries to the menu, you can either create a <filename>/boot/grub/custom.cfg</filename> file or modify the <filename>/etc/grub.d/40_custom</filename> file. For more complex configurations, you can modify other files in <filename>/etc/grub.d</filename>, or add to them; these scripts should return configuration snippets, possibly by making use of external programs. These scripts are the ones that will update the list of kernels to boot: <filename>10_linux</filename> takes into consideration the installed Linux kernels; <filename>20_linux_xen</filename> takes into account Xen virtual systems, and <filename>30_os-prober</filename> lists other operating systems (Windows, OS X, Hurd).
			</para>

		</section>
		 <section id="sect.config-yaboot">
			<title>Cas des Macintosh (PowerPC) : configuration de Yaboot</title>
			 <indexterm>
				<primary><command>yaboot</command></primary>
			</indexterm>
			 <para>
				Yaboot est le chargeur de démarrage employé par les anciens Macintosh utilisant des processeurs PowerPC. Ils n'amorcent pas comme les PC, mais recourent à une partition d'amorçage <foreignphrase>(bootstrap)</foreignphrase>, à partir de laquelle le BIOS (ou <foreignphrase>OpenFirmware</foreignphrase>) exécute le chargeur et sur laquelle le programme <command>ybin</command> installe <command>yaboot</command> et son fichier de configuration. On n'exécutera à nouveau cette commande qu'en cas de modification du fichier <filename>/etc/yaboot.conf</filename> (il est en effet dupliqué sur la partition de <foreignphrase>bootstrap</foreignphrase> et <command>yaboot</command> sait retrouver la position des noyaux sur les disques).
			</para>
			 <para>
				Avant d'exécuter <command>ybin</command>, il faut disposer d'un fichier <filename>/etc/yaboot.conf</filename> valide. L'exemple ci-dessous pourrait constituer un fichier minimal. <indexterm><primary><command>ybin</command></primary></indexterm>
			</para>
			 <example id="example.yaboot.conf">
				<title>Fichier de configuration de Yaboot</title>
				 
<programlisting>
# La partition de bootstrap
boot=/dev/sda2
# Le disque
device=hd:
# La partition Linux
partition=3
root=/dev/sda3
# Démarre après 3 sec. d'inactivité 
# (timeout est en dixièmes de secondes)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# Dernier noyau installé
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# Ancien noyau 
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# Uniquement pour un double amorçage Linux/Mac OS X
macosx=/dev/sda5

# bsd=/dev/sdaX et macos=/dev/sdaX
# sont également possibles</programlisting>

			</example>

		</section>

	</section>
	 <section id="sect.config-misc">
		<title>Autres configurations : synchronisation, logs, partages…</title>
		 <para>
			Cette section regroupe de nombreux éléments qu'il est bon de connaître pour maîtriser tous les aspects de la configuration du système GNU/Linux. Ils sont cependant traités brièvement et renvoient souvent à la documentation de référence.
		</para>
		 <section id="sect.timezone">
			<title>Fuseau horaire</title>
			 <indexterm>
				<primary>fuseau horaire</primary>
			</indexterm>
			 <sidebar id="sidebar.symbolic-link"> <title><emphasis>B.A.-BA</emphasis> Le lien symbolique</title>
			 <indexterm>
				<primary>lien</primary>
				<secondary>symbolique</secondary>
			</indexterm>
			 <indexterm>
				<primary>symbolique, lien</primary>
			</indexterm>
			 <indexterm>
				<primary><command>ln</command></primary>
			</indexterm>
			 <para>
				Un lien symbolique est un pointeur vers un autre fichier. Quand on y accède, c'est le fichier ainsi pointé qui est ouvert. Sa suppression n'entraîne pas la suppression du fichier pointé. De même, il ne dispose pas de droits propres, ce sont ceux de la cible qui comptent. Enfin, il peut pointer sur n'importe quel type de fichier : répertoires, fichiers spéciaux (<foreignphrase>sockets</foreignphrase>, tubes, périphériques, etc.), autres liens symboliques...
			</para>
			 <para>
				La commande <command>ln -s <replaceable>cible</replaceable> <replaceable>nom-lien</replaceable></command> crée un lien symbolique <replaceable>nom-lien</replaceable> pointant sur <replaceable>cible</replaceable>.
			</para>
			 <para>
				Si la cible n'existe pas, alors le lien est « cassé » et y accéder renverra une erreur indiquant que le fichier demandé n'existe pas. Si le lien pointe sur un autre lien, on obtient une « chaîne » de liens qui se transforme en « cycle » si l'un des liens cibles pointe sur l'un de ses prédécesseurs. Dans ce cas, accéder à l'un des liens du cycle renverra une erreur spécifique (« Trop de niveaux de liens symboliques » — c'est l'aveu d'échec du noyau après avoir parcouru le cycle un grand nombre de fois).
			</para>
			 </sidebar> <para>
				Le fuseau horaire, configuré lors de l'installation initiale, est une donnée de configuration du paquet <emphasis role="pkg">tzdata</emphasis>. Pour le modifier, on lancera donc la commande <command>dpkg-reconfigure tzdata</command>, qui permet de choisir de manière interactive le fuseau horaire à utiliser. Sa configuration est stockée dans le fichier <filename>/etc/timezone</filename>. Par ailleurs, le fichier correspondant du répertoire <filename>/usr/share/zoneinfo/</filename> est copié dans <filename>/etc/localtime</filename> ; ce fichier contient notamment les dates des changements d'heure pour les pays appliquant une heure d'été.
			</para>
			 <indexterm>
				<primary><filename>timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>zoneinfo</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/usr/share/zoneinfo/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>heure d'été</primary>
			</indexterm>
			 <indexterm>
				<primary>été, heure</primary>
			</indexterm>
			 <para>
				Pour changer temporairement de fuseau horaire, il est possible de mettre en place un fuseau horaire ayant la priorité sur les réglages du système avec la variable d'environnement <varname>TZ</varname>:
			</para>
			 <indexterm>
				<primary><varname>TZ</varname></primary>
			</indexterm>
			 
<screen id="screen.tz">
<computeroutput>$ </computeroutput><userinput>date</userinput>
<computeroutput>mercredi 23 septembre 2015, 10:28:59 (UTC+0200)</computeroutput>
<computeroutput>$ </computeroutput><userinput>TZ="Pacific/Honolulu" date</userinput>
<computeroutput>mardi 22 septembre 2015, 22:29:15 (UTC-1000)</computeroutput></screen>
			 <sidebar> <title><emphasis>NOTE</emphasis> Horloge système, horloge matérielle</title>
			 <para>
				Il existe en réalité deux sources de temps dans un ordinateur. La carte mère de l'ordinateur dispose d'une horloge matérielle, dite « CMOS ». Cette horloge est peu précise et offre des temps d'accès assez lents. Le noyau du système d'exploitation a la sienne, logicielle, qu'il maintient à l'heure par ses propres moyens (éventuellement à l'aide de serveurs de temps, voir <xref linkend="sect.time-synchronization" />). Cette horloge système est généralement plus précise, notamment parce qu'elle ne nécessite pas de temps d'accès variables à du matériel. Cependant, comme elle n'existe qu'en mémoire vive, elle est remise à zéro à chaque démarrage de l'ordinateur, contrairement à l'horloge CMOS, qui dispose d'une pile et « survit » donc à un redémarrage ou une extinction. L'horloge système est donc réglée sur l'horloge CMOS, lors du démarrage de l'ordinateur, et l'horloge CMOS est mise à jour lors de l'extinction (pour prendre en compte d'éventuels changements ou corrections si elle était déréglée).
			</para>
			 <para>
				En pratique, il se pose un problème, car l'horloge CMOS n'est qu'un compteur et ne contient pas d'informations de fuseau horaire. Il y a donc un choix à faire sur son interprétation : soit le système considère qu'il s'agit de temps universel (UTC, anciennement GMT), soit qu'il s'agit d'heure locale. Ce choix pourrait n'être qu'un simple décalage, mais les choses se compliquent : par suite des considérations d'heure d'été, ce décalage n'est pas constant ; la conséquence est que le système n'a au démarrage aucun moyen de savoir si le décalage est correct, notamment aux alentours des périodes de changement d'heure. Comme il est toujours possible de reconstruire l'heure locale en fonction de l'heure universelle et du fuseau horaire, nous recommandons donc vivement d'adopter une horloge CMOS en temps universel.
			</para>
			 <para>
				Hélas, les systèmes Windows (dans leur configuration par défaut) ignorent cette recommandation ; ils maintiennent l'horloge CMOS en heure locale et appliquent des décalages au démarrage de l'ordinateur en essayant de deviner lors de changements d'heure si le changement a déjà été appliqué précédemment ou non. Cela fonctionne relativement bien lorsque l'ordinateur ne fonctionne que sous un seul Windows, mais dès que l'ordinateur utilise plusieurs systèmes (que ce soit en <foreignphrase>dual-boot</foreignphrase> ou grâce à des machines virtuelles), une cacophonie s'ensuit, aucun n'ayant de moyen de savoir si l'heure locale est correcte. Si l'on doit absolument garder un Windows sur un ordinateur, on devra soit le configurer pour stocker l'heure en temps universel dans l'horloge matérielle (en réglant la valeur de la clé <literal>HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\\RealTimeIsUniversal</literal> au DWORD « 1 » dans la base de registres), soit désactiver <literal>UTC</literal> dans le fichier <filename>/etc/default/rcS</filename> (et prendre soin de vérifier manuellement l'horloge au printemps et à l'automne).
			</para>
			 </sidebar>
		</section>
		 <section id="sect.time-synchronization">
			<title>Synchronisation horaire</title>
			 <indexterm>
				<primary>synchronisation horaire</primary>
			</indexterm>
			 <indexterm>
				<primary>horloge</primary>
				<secondary>synchronisation</secondary>
			</indexterm>
			 <para>
				La synchronisation horaire, qui peut paraître superflue sur un ordinateur, prend toute son importance dans le cadre d'un réseau. Les utilisateurs n'ayant pas le droit de modifier la date et l'heure, il est important que ces informations soient exactes pour ne pas les gêner. Par ailleurs, le fait d'avoir tous les ordinateurs synchronisés permet de mieux croiser les informations obtenues à partir de logs issus de machines différentes. Ainsi, en cas d'attaque, il est plus simple de reconstituer la séquence chronologique des actions des indélicats sur les différentes machines compromises. Des données collectées sur plusieurs machines à des fins de statistiques n'ont pas non plus grand sens si leurs horodatages sont divers.
			</para>
			 <sidebar> <title><emphasis>B.A.-BA</emphasis> NTP</title>
			 <indexterm>
				<primary>NTP</primary>
			</indexterm>
			 <indexterm>
				<primary><foreignphrase>Network</foreignphrase></primary>
				<secondary><foreignphrase>Time Protocol</foreignphrase></secondary>
			</indexterm>
			 <para>
				NTP (<foreignphrase>Network Time Protocol</foreignphrase>, ou protocole d'heure en réseau) permet à une machine de se synchroniser sur une autre en prenant en compte de manière relativement précise les délais induits par le transfert de l'information sur le réseau et les autres décalages possibles.
			</para>
			 <para>
				Bien qu'il existe de nombreux serveurs NTP sur Internet, les plus connus peuvent être surchargés. C'est pourquoi il est recommandé d'employer le serveur NTP <emphasis>pool.ntp.org</emphasis> — c'est en réalité une collection de machines qui ont accepté de jouer le rôle de serveur NTP public. On peut même se limiter à un sous-ensemble spécifique à un pays, avec par exemple <emphasis>fr.pool.ntp.org</emphasis> pour la France.
			</para>
			 <para>
				Si vous administrez un réseau important, il est toutefois recommandé de mettre en place votre propre serveur NTP, qui se synchronisera avec les serveurs publics. Dans ce cas, toutes les autres machines de votre réseau pourront utiliser le serveur NTP interne au lieu d'augmenter la charge sur les serveurs publics. Vous gagnerez également en homogénéité des horloges, puisque toutes les machines seront synchronisées sur la même source, très proche en termes de temps de transfert réseau.
			</para>
			 </sidebar> <section id="sect.ntp-on-workstations">
				<title>Pour les stations de travail</title>
				 <para>
					Les stations de travail étant redémarrées régulièrement (ne serait-ce que par souci d'économie d'énergie), il suffit de les synchroniser par NTP au démarrage. Pour cela, il est possible d'y installer le paquet Debian <emphasis role="pkg">ntpdate</emphasis>. On changera au besoin le serveur NTP employé en modifiant le fichier <filename>/etc/default/ntpdate</filename>.
				</para>
				 <indexterm>
					<primary><filename>ntpdate</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/default/ntpdate</filename></primary>
				</indexterm>

			</section>
			 <section id="sect.ntp-on-servers">
				<title>Pour les serveurs</title>
				 <para>
					Les serveurs ne redémarrent que très rarement et il est très important que leur heure système soit juste. Pour conserver une heure correcte en permanence, on installera un serveur NTP local, service proposé par le paquet <emphasis role="pkg">ntp</emphasis>. Dans sa configuration par défaut, le serveur se synchronisera sur <emphasis>pool.ntp.org</emphasis> et fournira l'heure à qui la lui demandera sur le réseau local. On le configurera à travers le fichier <filename>/etc/ntp.conf</filename> ; l'élément le plus intéressant à changer est le serveur NTP de référence. Si le réseau compte beaucoup de serveurs, il peut être intéressant de n'avoir qu'un seul serveur qui se synchronise sur les serveurs publics, les autres se synchronisant sur lui.
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">ntp</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary>serveur</primary>
					<secondary>NTP</secondary>
				</indexterm>
				 <indexterm>
					<primary>NTP</primary>
					<secondary>serveur</secondary>
				</indexterm>
				 <sidebar> <title><emphasis>POUR ALLER PLUS LOIN</emphasis> Module GPS et autres sources de temps</title>
				 <indexterm>
					<primary>GPS</primary>
				</indexterm>
				 <indexterm>
					<primary>DCF-77</primary>
				</indexterm>
				 <para>
					Si la synchronisation horaire est cruciale dans votre réseau, il est possible d'équiper un serveur d'un module GPS (qui demandera l'heure aux satellites GPS) ou DCF-77 (qui la captera sur une horloge atomique installée près de Francfort). Dans ces cas, la configuration du serveur NTP est un peu plus compliquée et la consultation de sa documentation un préalable absolument nécessaire.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.rotation-logs">
			<title>Rotation des fichiers de logs</title>
			 <indexterm>
				<primary>fichier</primary>
				<secondary>de logs, rotation</secondary>
			</indexterm>
			 <indexterm>
				<primary>logs</primary>
				<secondary>fichiers, rotation</secondary>
			</indexterm>
			 <indexterm>
				<primary>rotation des fichiers de logs</primary>
			</indexterm>
			 <indexterm>
				<primary><command>logrotate</command></primary>
			</indexterm>
			 <para>
				Les fichiers de logs prenant rapidement du volume, il est nécessaire de les archiver. On emploie en général une archive « tournante » : le fichier de log est régulièrement archivé et seules ses <replaceable>X</replaceable> dernières archives sont conservées. <command>logrotate</command>, le programme chargé de ces rotations, suit les directives données dans le fichier <filename>/etc/logrotate.conf</filename> et tous ceux du répertoire <filename>/etc/logrotate.d/</filename>. L'administrateur peut modifier ces fichiers s'il souhaite adapter la politique de rotation des logs définie par Debian. La page de manuel <citerefentry><refentrytitle>logrotate</refentrytitle>
				<manvolnum>1</manvolnum></citerefentry> décrit toutes les options autorisées dans ces fichiers de configuration. Il peut être intéressant d'augmenter le nombre de fichiers conservés dans la rotation des logs, ou de déplacer les fichiers de logs dans un répertoire spécifique dédié à l'archivage au lieu de les supprimer. On peut encore les envoyer par courrier électronique pour les archiver ailleurs.
			</para>
			 <para>
				Le programme <command>logrotate</command> est exécuté quotidiennement par l'ordonnanceur <command>cron</command> (décrit dans la <xref linkend="sect.task-scheduling-cron-atd" xrefstyle="page" />).
			</para>

		</section>
		 <section id="sect.sharing-admin-rights">
			<title>Partage des droits d'administration</title>
			 <indexterm>
				<primary>compte</primary>
				<secondary>administrateur</secondary>
			</indexterm>
			 <indexterm>
				<primary>root</primary>
			</indexterm>
			 <indexterm>
				<primary><command>sudo</command></primary>
			</indexterm>
			 <para>
				Bien souvent, plusieurs administrateurs s'occupent du réseau. Partager le mot de passe de l'utilisateur root n'est pas très élégant et ouvre la porte à des abus du fait de l'anonymat de ce compte partagé. La solution à ce problème est le programme <command>sudo</command>, qui permet à certains utilisateurs d'exécuter certaines commandes avec des droits particuliers. Dans son emploi le plus courant <command>sudo</command> permet à un utilisateur de confiance d'exécuter n'importe quelle commande en tant que root. Pour cela, l'utilisateur doit simplement exécuter <command>sudo <replaceable>commande</replaceable></command> et s'authentifier à l'aide de son mot de passe personnel.
			</para>
			 <para>
				Quand il s'installe, le paquet <emphasis role="pkg">sudo</emphasis> donne les droits complets de root à tous les utilisateurs membres du groupe Unix <literal>sudo</literal>. Pour déléguer d'autres droits, l'administrateur doit faire appel à la commande <command>visudo</command>, qui permet de modifier le fichier de configuration <filename>/etc/sudoers</filename> (ici encore, cela invoquera l'éditeur de texte <command>vi</command>, ou tout éditeur mentionné dans la variable d'environnement <varname>EDITOR</varname>). L'ajout d'une ligne <literal><replaceable>utilisateur</replaceable> ALL=(ALL) ALL</literal> permettra à l'utilisateur concerné d'exécuter n'importe quelle commande en tant que root.
			</para>
			 <indexterm>
				<primary><command>visudo</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>sudoers</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/sudoers</filename></primary>
			</indexterm>
			 <para>
				Des configurations plus sophistiquées permettront de n'autoriser que quelques commandes particulières à certains utilisateurs. Tous les détails de ces différentes possibilités sont donnés dans la page de manuel <citerefentry><refentrytitle>sudoers</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>.
			</para>

		</section>
		 <section id="sect.fstab-mount-points">
			<title>Liste des points de montage</title>
			 <indexterm>
				<primary>montage, point de</primary>
			</indexterm>
			 <indexterm>
				<primary>point de montage</primary>
			</indexterm>
			 <sidebar> <title><emphasis>B.A.-BA</emphasis> Montage et démontage</title>
			 <para>
				Dans un système de type Unix comme Debian, les fichiers sont organisés dans une arborescence unique de répertoires. Le répertoire <filename>/</filename> est appelé la racine et tous les autres sont des sous-répertoires plus ou moins directs de cette racine. Le « montage » est l'action d'intégrer le contenu d'un périphérique (souvent un disque dur) à l'arborescence générale du système. Ainsi, si l'on utilise un disque séparé pour stocker les données personnelles des utilisateurs, ce disque sera « monté » dans le répertoire <filename>/home/</filename>. Le système de fichiers racine est toujours monté par le noyau. Lors de l'initialisation de l'ordinateur, d'autres périphériques y sont souvent intégrés à l'aide de la commande <command>mount</command>.
			</para>
			 <indexterm>
				<primary><command>mount</command></primary>
			</indexterm>
			 <para>
				Some removable devices are automatically mounted when connected, especially when using the GNOME, Plasma or other graphical desktop environments. Others have to be mounted manually by the user. Likewise, they must be unmounted (removed from the file tree). Normal users do not usually have permission to execute the <command>mount</command> and <command>umount</command> commands. The administrator can, however, authorize these operations (independently for each mount point) by including the <literal>user</literal> option in the <filename>/etc/fstab</filename> file.
			</para>
			 <para>
				La commande <command>mount</command> peut s'employer sans arguments (elle liste alors les systèmes de fichiers montés). Pour procéder à un montage ou à un démontage, des paramètres sont nécessaires. On se référera aux pages de manuel correspondantes, <citerefentry><refentrytitle>mount</refentrytitle>
				<manvolnum>8</manvolnum></citerefentry> et <citerefentry><refentrytitle>umount</refentrytitle>
				<manvolnum>8</manvolnum></citerefentry>. Dans les cas courants, la syntaxe est simple : par exemple, pour monter la partition <filename>/dev/sdc1</filename>, dont le système de fichiers est ext3, dans le répertoire <filename>/mnt/tmp/</filename>, on tapera simplement <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command>.
			</para>
			 </sidebar> <para>
				Le fichier <filename>/etc/fstab</filename> donne la liste de tous les montages possibles (effectués automatiquement au démarrage ou à exécuter manuellement pour les périphériques amovibles). Chaque point de montage y est détaillé sur une ligne par plusieurs champs séparés par des blancs, qui sont : <indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						file system: this indicates where the filesystem to be mounted can be found, it can be a local device (hard drive partition, CD-ROM) or a remote filesystem (such as NFS).
					</para>
					 <para>
						Ce champ est fréquemment remplacé par l'identifiant unique du système de fichiers (que l'on peut obtenir par <command>blkid <userinput>périphérique</userinput></command>) préfixé de <literal>UUID=</literal>. Cela permet notamment de ne pas être affecté par le changement possible du nom du périphérique en cas d'ajout ou de suppression de disques (ou de détection des disques dans un ordre différent).
					</para>

				</listitem>
				 <listitem>
					<para>
						Point de montage : c'est l'endroit de l'arborescence où ce système de fichiers sera rendu accessible.
					</para>

				</listitem>
				 <listitem>
					<para>
						Type : ce champ définit le système de fichiers employé sur le périphérique. <literal>ext4</literal>, <literal>ext3</literal>, <literal>vfat</literal>, <literal>ntfs</literal>, <literal>reiserfs</literal>, <literal>xfs</literal> en sont quelques exemples.
					</para>
					 <sidebar> <title><emphasis>B.A.-BA</emphasis> NFS, un système de fichiers réseau</title>
					 <para>
						NFS — <foreignphrase>Network File System</foreignphrase> — est un système de fichiers réseau ; sous Linux, il permet d'accéder de manière transparente à des fichiers distants en les intégrant dans l'arborescence du système.
					</para>
					 </sidebar> <para>
						La liste complète des systèmes de fichiers reconnus est disponible dans la page de manuel <citerefentry><refentrytitle>mount</refentrytitle>
						<manvolnum>8</manvolnum></citerefentry>. La valeur spéciale <literal>swap</literal> sert aux partitions d'échange ; la valeur spéciale <literal>auto</literal> demande au programme <command>mount</command> de détecter automatiquement le système de fichiers (ce qui est surtout utile pour les lecteurs de disquettes et les clés USB, car chacune peut abriter un système de fichiers différent);
					</para>

				</listitem>
				 <listitem>
					<para>
						Options : elles sont nombreuses, dépendent du système de fichiers et sont documentées dans la page de manuel de <command>mount</command>. Voici les plus courantes :
					</para>
					 <itemizedlist>
						<listitem>
							<para>
								<literal>rw</literal> ou <literal>ro</literal> feront respectivement monter le système de fichiers en lecture/écriture ou en lecture seule .
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>noauto</literal> désactive le montage automatique au démarrage .
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>nofail</literal> indique au système d'initialisation que le démarrage peut continuer même si le périphérique n'est pas présent. Il ne faut pas oublier cette option pour les disques externes qui peuvent être débranchés au démarrage, autrement <command>systemd</command> ne tolérera pas leur absence : il interrompra le processus de démarrage jusqu'à ce que tous les points de montage qui doivent être montés automatiquement le soient effectivement. Signalons que l'on peut combiner cette option avec <literal>x-systemd.device-timeout=5s</literal> pour indiquer à <command>systemd</command> de ne pas attendre l'apparition du périphérique pendant plus de 5 secondes (voir <citerefentry><refentrytitle>systemd.mount</refentrytitle>
								<manvolnum>5</manvolnum></citerefentry>) .
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>user</literal> autorise tous les utilisateurs à monter ce système de fichiers (opération d'ordinaire réservée à root) .
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>defaults</literal> correspond à l'ensemble d'options (<literal>rw</literal>, <literal>suid</literal>, <literal>dev</literal>, <literal>exec</literal>, <literal>auto</literal>, <literal>nouser</literal> et <literal>async</literal>), qu'on pourra inhiber individuellement après <literal>defaults</literal> — soit en ajoutant <literal>nosuid</literal>, <literal>nodev</literal>, etc. pour bloquer <literal>suid</literal>, <literal>dev</literal>, etc., soit en ajoutant <literal>user</literal> pour réactiver cette option (puisque <literal>defaults</literal> inclut <literal>nouser</literal>).
							</para>

						</listitem>

					</itemizedlist>

				</listitem>
				 <listitem>
					<para>
						dump: this field is almost always set to <literal>0</literal>. When it is <literal>1</literal>, it tells the <command>dump</command> tool that the partition contains data that is to be backed up.
					</para>

				</listitem>
				 <listitem>
					<para>
						pass: this last field indicates whether the integrity of the filesystem should be checked on boot, and in which order this check should be executed. If it is <literal>0</literal>, no check is conducted. The root filesystem should have the value <literal>1</literal>, while other permanent filesystems get the value <literal>2</literal>.
					</para>

				</listitem>

			</itemizedlist>
			 <example id="example.fstab">
				<title>Exemple de fichier <filename>/etc/fstab</filename></title>
				 
<programlisting>
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 /               ext3    errors=remount-ro 0       1
# swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none            swap    sw              0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto     0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/partage /partage       nfs     defaults        0       0</programlisting>

			</example>
			 <para>
				La dernière entrée de cet exemple correspond à un système de fichiers en réseau (NFS) : le répertoire <filename>/partage/</filename> du serveur <emphasis>arrakis</emphasis> est monté sur le répertoire <filename>/partage/</filename> local. Le format du fichier <filename>/etc/fstab</filename> est documenté dans la page de manuel <citerefentry><refentrytitle>fstab</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>.
			</para>
			 <sidebar> <title><emphasis>POUR ALLER PLUS LOIN</emphasis> Automonteurs</title>
			 <para>
				systemd is able to manage automount points: those are filesystems that are mounted on-demand when a user attempts to access their target mount points. It can also unmount these filesystems when no process is accessing them any longer.
			</para>
			 <para>
				Like most concepts in systemd, automount points are managed with dedicated units (using the <literal>.automount</literal> suffix). See <citerefentry><refentrytitle>systemd.automount</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> for their precise syntax.
			</para>
			 <indexterm>
				<primary><emphasis>am-utils</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><command>amd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>automount</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>autofs</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>automonteur</primary>
			</indexterm>
			 <para>
				Other auto-mounting utilities exist, such as <command>automount</command> in the <emphasis role="pkg">autofs</emphasis> package or <command>amd</command> in the <emphasis role="pkg">am-utils</emphasis>.
			</para>
			 <para>
				Note also that GNOME, Plasma, and other graphical desktop environments work together with <emphasis>udisks</emphasis>, and can automatically mount removable media when they are connected.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.locate-updatedb">
			<title><command>locate</command> et <command>updatedb</command></title>
			 <indexterm>
				<primary><command>locate</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>updatedb</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>mlocate</command></primary>
			</indexterm>
			 <para>
				La commande <command>locate</command> retrouve l'emplacement d'un fichier dont on connaît une partie du nom. Elle renvoie un résultat quasi instantanément car elle consulte une base de données particulière qui stocke l'emplacement de tous les fichiers du système ; celle-ci est mise à jour quotidiennement par la commande <command>updatedb</command>. Il existe plusieurs mises en œuvre de la commande <command>locate</command> ; Debian a choisi <emphasis role="pkg">mlocate</emphasis> comme mise en œuvre standard.
			</para>
			 <para>
				<command>mlocate</command> est suffisamment fin pour ne renvoyer que les fichiers accessibles à l'utilisateur qui lance la commande, et ce bien qu'il utilise une base de données répertoriant tous les fichiers du système (puisque sa mise en œuvre d'<command>updatedb</command> tourne avec les permissions de root). Pour plus de sûreté, l'administrateur peut exclure certains répertoires de l'indexation, en utilisant la variable <varname>PRUNEDPATHS</varname> du fichier de configuration <filename>/etc/updatedb.conf</filename>.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-compilation">
		<title>Compilation d'un noyau</title>
		 <indexterm>
			<primary>compilation</primary>
			<secondary>d'un noyau</secondary>
		</indexterm>
		 <indexterm>
			<primary>noyau</primary>
			<secondary>compilation</secondary>
		</indexterm>
		 <para>
			Les noyaux fournis par Debian intègrent le plus grand nombre possible de fonctionnalités ainsi qu'un maximum de pilotes, afin de couvrir le plus grand spectre de configurations matérielles existantes. C'est pourquoi certains utilisateurs préfèrent recompiler le noyau pour n'y inclure que le strict nécessaire. Il existe deux raisons à ce choix. Premièrement, cela peut être pour optimiser la consommation de mémoire, puisque le code du noyau, même s'il n'est jamais utilisé, occupe de la mémoire pour rien (et ne « descend » jamais sur l'espace d'échange, donc c'est de vraie mémoire vive qu'il s'agit), ce qui peut diminuer les performances globales du système. Il peut également s'agir de limiter le risque de failles de sécurité (le code compilé portant alors sur une fraction plus faible du code existant).
		</para>
		 <sidebar> <title><emphasis>ATTENTION</emphasis> Mises à jour de sécurité</title>
		 <para>
			Si l'on choisit de compiler son propre noyau, il faut en accepter les conséquences : Debian n'assurera pas les mises à jour de sécurité de ce noyau. En restant avec un noyau fourni par Debian, on bénéficie des mises à jour préparées par l'équipe sécurité du projet.
		</para>
		 </sidebar> <para>
			La recompilation du noyau est aussi nécessaire si l'on souhaite employer certaines fonctionnalités non intégrées dans sa version standard mais disponibles sous forme de correctifs, ou patches.
		</para>
		 <sidebar> <title><emphasis>POUR ALLER PLUS LOIN</emphasis> Le Manuel du noyau Debian</title>
		 <indexterm>
			<primary><emphasis role="pkg">debian-kernel-handbook</emphasis></primary>
		</indexterm>
		 <para>
			The Debian kernel teams maintains the “Debian Kernel Handbook” (also available in the <emphasis role="pkg">debian-kernel-handbook</emphasis> package) with comprehensive documentation about most kernel related tasks and about how official Debian kernel packages are handled. This is the first place you should look into if you need more information than what is provided in this section. <ulink type="block" url="https://kernel-team.pages.debian.net/kernel-handbook/" />
		</para>
		 </sidebar> <section id="sect.kernel-compilation-prerequisites">
			<title>Introduction et prérequis</title>
			 <para>
				Comme on peut s'y attendre, Debian gère le noyau sous forme de paquet, ce qui n'est pas la manière traditionnelle de le compiler et de l'installer. Les noyaux restant sous le contrôle du système de paquetage, ils peuvent être rapidement supprimés ou déployés sur plusieurs machines. De plus, les scripts associés à ces paquets permettent également une meilleure interaction avec le chargeur de démarrage et le générateur d'images de démarrage <foreignphrase>(initrd)</foreignphrase>.
			</para>
			 <para>
				Les sources amont du noyau Linux contiennent tout ce qui est requis pour construire un paquet Debian du noyau. Vous aurez simplement besoin d'installer le paquet <emphasis role="pkg">build-essential</emphasis>, qui contient les outils de compilation standards pour générer un paquet Debian. Par ailleurs, la configuration du noyau nécessitera le paquet <emphasis>libncurses5-dev</emphasis>. Enfin, le paquet <emphasis>fakeroot</emphasis> permettra de créer le paquet Debian sans utiliser les droits de l'administrateur.
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> Le bon vieux temps de <emphasis role="pkg">kernel-package</emphasis></title>
			 <indexterm>
				<primary><emphasis role="pkg">kernel-package</emphasis></primary>
			</indexterm>
			 <para>
				À l'époque où le système de compilation du noyau Linux ne permettait pas encore de créer directement des paquets Debian, la manière recommandée de créer ces paquets était d'utiliser l'outil <command>make-kpkg</command> fourni par le paquet <emphasis role="pkg">kernel-package</emphasis>.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-sources">
			<title>Récupérer les sources</title>
			 <indexterm>
				<primary>sources du noyau Linux</primary>
			</indexterm>
			 <indexterm>
				<primary>noyau</primary>
				<secondary>sources</secondary>
			</indexterm>
			 <indexterm>
				<primary>sources</primary>
				<secondary>du noyau Linux</secondary>
			</indexterm>
			 <para>
				Like anything that can be useful on a Debian system, the Linux kernel sources are available in a package. To retrieve them, just install the <emphasis role="pkg">linux-source-<replaceable>version</replaceable></emphasis> package. The <command>apt search ^linux-source</command> command lists the various kernel versions packaged by Debian. The latest version is available in the <emphasis role="distribution">Unstable</emphasis> distribution: you can retrieve them without much risk (especially if your APT is configured according to the instructions of <xref linkend="sect.apt-mix-distros" />). Note that the source code contained in these packages does not correspond precisely with that published by Linus Torvalds and the kernel developers; like all distributions, Debian applies a number of patches, which might (or might not) find their way into the upstream version of Linux. These modifications include backports of fixes/features/drivers from newer kernel versions, new features not yet (entirely) merged in the upstream Linux tree, and sometimes even Debian specific changes.
			</para>
			 <para>
				The remainder of this section focuses on the 4.9 version of the Linux kernel, but the examples can, of course, be adapted to the particular version of the kernel that you want.
			</para>
			 <para>
				We assume the <emphasis role="pkg">linux-source-4.9</emphasis> package has been installed. It contains <filename>/usr/src/linux-source-4.9.tar.xz</filename>, a compressed archive of the kernel sources. You must extract these files in a new directory (not directly under <filename>/usr/src/</filename>, since there is no need for special permissions to compile a Linux kernel): <filename>~/kernel/</filename> is appropriate.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>
<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-4.9.tar.xz</userinput></screen>
			 <sidebar> <title><emphasis>CULTURE</emphasis> Emplacement des sources du noyau</title>
			 <para>
				Traditionnellement, les sources du noyau Linux ont toujours été placées sous <filename>/usr/src/linux/</filename>, nécessitant donc les droits root pour la compilation. Comme vous le savez, il faut pourtant éviter de travailler inutilement avec les droits de l'administrateur. Il existe bien un groupe <literal>src</literal> qui permet à ses membres de travailler dans ce répertoire, mais on évitera malgré tout de recourir à <filename>/usr/src/</filename>. En conservant les sources du noyau dans un répertoire personnel, vous optez pour la sécurité à tout point de vue : pas de fichiers inconnus du système de paquetage dans <filename>/usr/</filename>, ni de risque d'induire en erreur les programmes qui scrutent <filename>/usr/src/linux/</filename> pour obtenir des informations sur le noyau employé.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.config-kernel">
			<title>Configuration du noyau</title>
			 <indexterm>
				<primary>noyau</primary>
				<secondary>configuration</secondary>
			</indexterm>
			 <indexterm>
				<primary>configuration</primary>
				<secondary>du noyau</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>.config</filename></primary>
			</indexterm>
			 <para>
				La prochaine étape consiste à configurer le noyau conformément à ses besoins. Le mode opératoire dépend des objectifs.
			</para>
			 <para>
				Si l'on recompile une version plus récente du noyau (éventuellement dotée d'un patch supplémentaire), le plus probable est qu'on veuille rester aussi près que possible de la configuration standard proposée par Debian. Dans ce cas, et au lieu de tout reconfigurer depuis zéro, il est bon de copier le fichier <filename>/boot/config-<replaceable>version</replaceable></filename> (la version est celle du noyau employé actuellement — <command>uname -r</command> vous la révélera au besoin) en <filename>.config</filename> dans le répertoire des sources du noyau .
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cp /boot/config-4.9.0-3-amd64 ~/kernel/linux-source-4.9/.config</userinput></screen>
			 <para>
				Si vous ne souhaitez pas changer la configuration, vous pouvez en rester là et sauter directement à la <xref linkend="sect.kernel-build" />. Dans le cas contraire, ou si vous avez décidé de tout reconfigurer depuis zéro, il faudra prendre le temps de configurer votre noyau. Pour cela, il propose différentes interfaces, qu'on invoque depuis le répertoire des sources par la commande <command>make</command> suivie d'un argument.
			</para>
			 <para>
				<command>make menuconfig</command> compile et exécute une interface évoluée en mode texte (c'est ici que le paquet <emphasis role="pkg">libncurses5-dev</emphasis> est requis) qui propose de naviguer dans une structure hiérarchique présentant les options proposées. Une pression sur la touche <keycap>Espace</keycap> change la valeur de l'option sélectionnée et <keycap>Entrée</keycap> valide le bouton sélectionné en bas de l'écran : <guibutton>Select</guibutton> permet de rentrer dans le sous-menu sélectionné, <guibutton>Exit</guibutton> remonte d'un cran dans la hiérarchie, et <guibutton>Help</guibutton> produit des informations plus détaillées sur le rôle de l'option sélectionnée. Les flèches permettent de se positionner dans la liste des options et des boutons. Pour quitter le configurateur, il faut sélectionner <guibutton>Exit</guibutton> depuis le menu principal. Le programme propose alors de sauvegarder les changements : acceptez si vous êtes satisfaits de vos choix.
			</para>
			 <para>
				Les autres interfaces ont un fonctionnement similaire, mais inscrit dans des interfaces graphiques plus modernes : <command>make xconfig</command> emploie la boîte à outils Qt et <command>make gconfig</command> recourt à GTK+. La première a besoin de <emphasis role="pkg">libqt4-dev</emphasis> tandis que la seconde requiert <emphasis role="pkg">libglade2-dev</emphasis> et <emphasis role="pkg">libgtk2.0-dev</emphasis>.
			</para>
			 <para>
				Lorsque l'on utilise une de ces interfaces de configuration, il est généralement conseillé de partir d'une configuration par défaut raisonnable. Le noyau fournit de telles configurations dans <filename>arch/<replaceable>architecture</replaceable>/configs/*_defconfig</filename> et il est possible de les mettre en place avec une commande telle que <command>make x86_64_defconfig</command> (pour un PC 64 bits) ou <command>make i386_defconfig</command> (pour un PC 32 bits).
			</para>
			 <sidebar> <title><emphasis>ASTUCE</emphasis> Que faire d'un <filename>.config</filename> obsolète ?</title>
			 <para>
				Lorsque l'on fournit un fichier <filename>.config</filename> qui provient d'une autre version du noyau (généralement plus ancienne), ce fichier doit être mis à jour. Cela se fait avec <command>make oldconfig</command>, qui va poser interactivement les questions portant sur les nouvelles options de configuration. Pour utiliser les réponses par défaut à toutes ces questions, on préfèrera <command>make olddefconfig</command>. Pour finir, la commande <command>make oldnoconfig</command> répondra par la négative à toutes ces nouvelles questions.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-build">
			<title>Compilation et génération du paquet</title>
			 <indexterm>
				<primary><command>make deb-pkg</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>ATTENTION</emphasis> Nettoyer avant de recommencer</title>
			 <para>
				Si vous avez déjà construit un noyau dans le répertoire et si vous voulez tout reconstruire depuis zéro (par exemple après avoir changé la configuration du noyau de manière substantielle), il faudra lancer <command>make clean</command>, qui supprimera les fichiers compilés. <command>make distclean</command> fait un ménage encore plus poussé et supprime tous les fichiers générés, y compris votre <filename>.config</filename> ; faites-en une sauvegarde au préalable .
			</para>
			 </sidebar> <para>
				Une fois que la configuration du noyau est prête, la commande <command>make deb-pkg</command> va créer jusqu'à 5 paquets Debian : <emphasis role="pkg">linux-image-<replaceable>version</replaceable></emphasis>, qui contient le noyau lui-même et les modules associés ; <emphasis role="pkg">linux-headers-<replaceable>version</replaceable></emphasis>, qui contient les fichiers d'en-tête nécessaires pour construire des modules externes ; <emphasis role="pkg">linux-firmware-image-<replaceable>version</replaceable></emphasis>, qui contient des fichiers de microcode requis par certains pilotes de périphériques (ce paquet peut être absent lorsque vous compilez le noyau depuis les sources fournies par Debian) ; <emphasis role="pkg">linux-image-<replaceable>version</replaceable>-dbg</emphasis>, qui contient les symboles de débogage pour l'image du noyau et ses modules ; <emphasis role="pkg">linux-libc-dev</emphasis>, qui contient les fichiers d'en-têtes requis pour certaines bibliothèques de code en espace utilisateur, telles que la bibliothèque C standard de GNU (glibc).
			</para>
			 <para>
				La <replaceable>version</replaceable> est construite à partir de la version amont (définie par les variables <literal>VERSION</literal>, <literal>PATCHLEVEL</literal>, <literal>SUBLEVEL</literal> et <literal>EXTRAVERSION</literal> dans le fichier <filename>Makefile</filename>), du paramètre de configuration <literal>LOCALVERSION</literal> et de la variable d'environnement <literal>LOCALVERSION</literal>. La version du paquet réutilise la même chaîne de version, avec une révision qui est régulièrement incrémentée (et stockée dans le fichier <filename>.version</filename>), sauf si elle est explicitement surchargée par la variable d'environnement <literal>KDEB_PKGVERSION</literal>.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1
</userinput><computeroutput>[...]
$ </computeroutput><userinput>ls ../*.deb
</userinput><computeroutput>../linux-headers-4.9.30-ckt4-falcot_4.9.30-1_amd64.deb
../linux-image-4.9.30-ckt4-falcot_4.9.30-1_amd64.deb
../linux-image-4.9.30-ckt4-falcot-dbg_4.9.30-1_amd64.deb
../linux-libc-dev_4.9.30-1_amd64.deb
</computeroutput></screen>

		</section>
		 <section id="sect.modules-build">
			<title>Compilation de modules externes</title>
			 <indexterm>
				<primary>noyau</primary>
				<secondary>modules externes</secondary>
			</indexterm>
			 <indexterm>
				<primary>modules</primary>
				<secondary>externes au noyau</secondary>
			</indexterm>
			 <indexterm>
				<primary><command>dkms</command></primary>
			</indexterm>
			 <para>
				Certains modules sont gérés en dehors du noyau Linux officiel. Pour les employer, il faut les compiler de concert avec le noyau correspondant. Debian fournit les sources d'un certain nombre de modules externes, tels que <emphasis role="pkg">xtables-addons-source</emphasis> (modules supplémentaires pour iptables) ou <emphasis role="pkg">oss4-source</emphasis> (qui contient un ensemble alternatif de pilotes de cartes audio).
			</para>
			 <para>
				Il est difficile de dresser la liste des modules externes disponibles sous forme de sources dans Debian, mais la commande <command>apt-cache search source$</command> permet de restreindre le champ de la recherche. De toute façon, cette liste n'apporte rien puisqu'il n'y a pas de raison particulière de compiler des modules externes sauf quand on sait qu'on en a besoin — auquel cas la documentation du périphérique vous renseignera.
			</para>
			 <para>
				Examinons par exemple le paquet <emphasis role="pkg">xtables-addons-source</emphasis> : après installation, un fichier <filename>.tar.bz2</filename> des sources du module est stocké dans <filename>/usr/src/</filename>. Nous pourrions extraire cette archive et construire le module à la main, mais en pratique il est d'usage d'automatiser tout cela avec DKMS. La plupart des modules proposent l'intégration avec DKMS dans un paquet dont le nom finit par <literal>-dkms</literal>. Dans notre cas, il suffit d'installer le paquet <emphasis role="pkg">xtables-addons-dkms</emphasis> pour que le module soit compilé pour le noyau courant, à condition que le paquet <emphasis role="pkg">linux-headers-*</emphasis> correspondant au noyau courant soit aussi installé. Par exemple, si l'on utilise <emphasis role="pkg">linux-image-amd64</emphasis>, il faut également installer <emphasis role="pkg">linux-headers-amd64</emphasis>.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>
<computeroutput>
[...]
Setting up xtables-addons-dkms (2.12-0.1) ...
Loading new xtables-addons-2.12 DKMS files...
Building for 4.9.0-3-amd64
Building initial module for 4.9.0-3-amd64
Done.

xt_ACCOUNT:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/4.9.0-3-amd64/updates/dkms/
[...]
DKMS: install completed.
$ </computeroutput><userinput>sudo dkms status</userinput>
<computeroutput>xtables-addons, 2.12, 4.9.0-3-amd64, x86_64: installed
$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>
<computeroutput>filename:       /lib/modules/4.9.0-3-amd64/updates/dkms/xt_ACCOUNT.ko
license:        GPL
alias:          ipt_ACCOUNT
author:         Intra2net AG &lt;opensource@intra2net.com&gt;
description:    Xtables: per-IP accounting for large prefixes
[...]
</computeroutput></screen>
			 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> module-assistant</title>
			 <indexterm>
				<primary><emphasis role="pkg">module-assistant</emphasis></primary>
			</indexterm>
			 <para>
				Avant l'apparition de DKMS, la solution la plus simple pour construire et déployer des modules du noyau était <emphasis role="pkg">module-assistant</emphasis>. Cette solution est toujours disponible, en particulier pour les paquets qui ne proposent pas (encore) une intégration avec DKMS : avec une simple commande telle que <command>module-assistant auto-install xtables-addons</command> (ou même sa version raccourcie, <command>m-a a-i xtables-addons</command>), les modules sont construits pour le noyau courant, puis empaquetés dans un nouveau paquet Debian, qui est lui-même installé à la volée.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-patch">
			<title>Emploi d'un patch sur le noyau</title>
			 <indexterm>
				<primary>noyau</primary>
				<secondary>patch</secondary>
			</indexterm>
			 <indexterm>
				<primary>patch noyau</primary>
			</indexterm>
			 <para>
				Certaines fonctionnalités ne sont pas intégrées au noyau standard faute de stabilité ou d'accord des mainteneurs du noyau. Dans ce cas, il arrive qu'elles soient diffusées sous la forme de correctif (ou patch), que chacun est alors libre d'appliquer sur les sources du noyau.
			</para>
			 <para>
				Debian sometimes provides some of these patches in <emphasis role="pkg">linux-patch-*</emphasis> packages but they often don't make it into stable releases (sometimes for the very same reasons that they are not merged into the official upstream kernel). These packages install files in the <filename>/usr/src/kernel-patches/</filename> directory.
			</para>
			 <para>
				Pour appliquer un ou plusieurs des patches installés, il faudra utiliser la commande <command>patch</command> sur le répertoire de sources, puis lancer la compilation du noyau comme précédemment.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-4.9</userinput>
<computeroutput>$ </computeroutput><userinput>make clean</userinput>
<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.1-4.9.11-201702181444.patch.gz | patch -p1</userinput></screen>
			 <para>
				Attention, un patch ne fonctionnant pas forcément avec toutes les versions des noyaux, il est possible que <command>patch</command> échoue à l'appliquer sur les sources du noyau. Un message vous en informera alors : dans ce cas, référez-vous à la documentation disponible dans le paquet Debian du patch (dans le répertoire <filename>/usr/share/doc/linux-patch-*/</filename>). Il est probable que le mainteneur indique pour quelles versions du noyau il a été prévu.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-installation">
		<title>Installation d'un noyau</title>
		 <indexterm>
			<primary>installation</primary>
			<secondary>d'un noyau</secondary>
		</indexterm>
		 <indexterm>
			<primary>noyau</primary>
			<secondary>installation</secondary>
		</indexterm>
		 <section id="sect.kernel-package">
			<title>Caractéristiques d'un paquet Debian du noyau</title>
			 <indexterm>
				<primary><filename>vmlinuz</filename></primary>
			</indexterm>
			 <para>
				Un paquet Debian de noyau installe l'image du noyau (<filename>vmlinuz-<replaceable>version</replaceable></filename>), sa configuration (<filename>config-<replaceable>version</replaceable></filename>) et sa table de symboles (<filename>System.map-<replaceable>version</replaceable></filename>) dans <filename>/boot/</filename>. La table de symboles permet aux développeurs de comprendre le sens d'un message d'erreur du noyau (en son absence, les « <foreignphrase>oops</foreignphrase> » — équivalents dans le noyau des erreurs de segmentation des programmes de l'espace utilisateur, ces messages sont générés suite à un déréférencement de pointeur invalide — n'indiqueraient que des adresses mémoire numériques, informations inutiles si on ne sait pas à quels symboles elles correspondent). Les modules sont installés dans le répertoire <filename>/lib/modules/<replaceable>version</replaceable>/</filename>.
			</para>
			 <para>
				Les scripts de configuration du paquet génèrent automatiquement une image <foreignphrase>initrd</foreignphrase> <foreignphrase>(init ram disk)</foreignphrase> — cette dernière est un mini-système préparé en mémoire <foreignphrase>(ram disk)</foreignphrase> par le chargeur de démarrage et démarré par le noyau Linux dans le seul but de charger les modules nécessaires pour accéder au périphérique contenant le système Debian complet (par exemple le pilote pour les disques SATA). Enfin, les scripts de post-installation mettent à jour les liens symboliques <filename>/vmlinuz</filename>, <filename>/vmlinuz.old</filename>, <filename>/initrd.img</filename> et <filename>/initrd.img.old</filename> pour qu'ils pointent respectivement sur les deux derniers noyaux installés ainsi que leurs images <foreignphrase>initrd</foreignphrase> associées.
			</para>
			 <para>
				La plupart de ces tâches sont déléguées à des scripts présents dans les répertoires <filename>/etc/kernel/*.d/</filename>. Par exemple, l'intégration avec <command>grub</command> se fait par le biais de <filename>/etc/kernel/postinst.d/zz-update-grub</filename> et <filename>/etc/kernel/postrm.d/zz-update-grub</filename>, qui appellent <command>update-grub</command> lors de l'installation ou la suppression de paquets du noyau.
			</para>

		</section>
		 <section id="sect.kernel-installation-with-dpkg">
			<title>Installation avec <command>dpkg</command></title>
			 <para>
				Using <command>apt</command> is so convenient that it makes it easy to forget about the lower-level tools, but the easiest way of installing a compiled kernel is to use a command such as <command>dpkg -i <replaceable>package</replaceable>.deb</command>, where <literal><replaceable>package</replaceable>.deb</literal> is the name of a <emphasis role="pkg">linux-image</emphasis> package such as <filename>linux-image-4.9.30-ckt4-falcot_1_amd64.deb</filename>.
			</para>
			 <para>
				La configuration de base obtenue peut aussi bien devenir un serveur qu'un poste de bureautique et elle est reproductible en masse de façon semi-automatisée. Une machine en disposant n'est toutefois pas encore adaptée à un usage donné, c'est pourquoi l'administrateur doit à présent compléter la préparation. Pour cela, il commencera par mettre en place les couches logicielles basses appelées « services Unix ».
			</para>

		</section>

	</section>
</chapter>

