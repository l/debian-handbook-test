<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course">
  <appendixinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-short-remedial-course.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>BIOS</keyword>
      <keyword>Noyau</keyword>
      <keyword>Unix</keyword>
      <keyword>Processus</keyword>
      <keyword>Arborescence</keyword>
      <keyword>Commandes de base</keyword>
    </keywordset>
  </appendixinfo>
  <title>Petit cours de rattrapage</title>
  <highlights>
    <para>Bien que cet ouvrage s'adresse principalement aux administrateurs ou utilisateurs avancés, nous ne souhaitons pas exclure les novices désireux de se former. Nous rappelons donc dans cette partie quelques concepts informatiques fondamentaux que l'on côtoie en exploitant un ordinateur sous Unix.</para>
  </highlights>
  <section id="sect.shell-and-basic-commands">
    <title>Interpréteur de commandes et commandes de base</title>

    <para>Dans le monde Unix, l'administrateur est inévitablement confronté à la ligne de commande, ne serait-ce que dans les cas où le système ne démarre plus correctement et propose uniquement ce moyen comme accès de secours. Il est donc important de savoir se débrouiller un minimum dans un interpréteur de commandes.</para>

    <sidebar>
      <title><emphasis>DÉCOUVERTE</emphasis> Démarrer un interpréteur de commmandes</title>

      <para>A command-line environment can be run from the graphical
      desktop, by an application known as a “terminal”. In GNOME,
      you can start it from the “Activities” overview (that you get
      when you move the mouse in the top-left corner of the screen) by
      typing the first letters of the application name. In Plasma, you will
      find it in the <menuchoice><guimenu>K</guimenu>
      <guisubmenu>Applications</guisubmenu>
      <guisubmenu>System</guisubmenu></menuchoice> menu.</para>
    </sidebar>

    <para>Les commandes présentées dans cette section le sont de manière assez rapide. Il ne faut pas hésiter à consulter les pages de manuels correspondantes pour découvrir les nombreuses options disponibles.</para>
    <section>
      <title>Déplacement dans l'arborescence et gestion des fichiers</title>

      <para>Après connexion, la commande <command>pwd</command> (<foreignphrase>print working directory</foreignphrase>, afficher le répertoire de travail) indique l'emplacement courant. La commande <command>cd <replaceable>répertoire</replaceable></command> (<foreignphrase>change directory</foreignphrase>, changer de répertoire) sert à naviguer dans l'arborescence des fichiers. Le répertoire parent est toujours nommé <literal>..</literal> tandis que <literal>.</literal> est un synonyme pour le répertoire courant. La commande <command>ls</command> affiche le contenu d'un répertoire ; en l'absence de paramètres, elle travaille sur le répertoire courant.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>cd Bureau</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Bureau
$ </computeroutput><userinput>cd .</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Bureau
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>ls</userinput>
<computeroutput>Bureau     Images   Musique  Téléchargements
Documents  Modèles  Public   Vidéos</computeroutput>
      </screen>

      <para>Créer un nouveau répertoire s'effectue avec <command>mkdir <replaceable>répertoire</replaceable></command>, alors que la commande <command>rmdir <replaceable>répertoire</replaceable></command> supprime un répertoire vide. La commande <command>mv</command> sert à renommer et/ou à déplacer les fichiers et les répertoires, tandis que <command>rm <replaceable>fichier</replaceable></command> supprime un fichier.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Bureau     Images   Musique  Téléchargements  Vidéos
Documents  Modèles  Public   test
$ </computeroutput><userinput>mv test nouveau</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Bureau     Images   Musique  Public           Vidéos
Documents  Modèles  nouveau  Téléchargements
$ </computeroutput><userinput>rmdir nouveau</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Bureau     Images   Musique  Téléchargements
Documents  Modèles  Public   Vidéos</computeroutput>
      </screen>
    </section>
    <section>
      <title>Consultation et modification des fichiers texte</title>

      <para>La commande <command>cat <replaceable>fichier</replaceable></command> (prévue pour concaténer des fichiers sur la sortie standard) lit un fichier et affiche son contenu dans le terminal. Si le fichier est trop gros, la commande <command>less</command> (ou <command>more</command>) permet de l'afficher page par page.</para>

      <para>La commande <command>editor</command> lance un éditeur de texte (comme <command>vi</command> ou <command>nano</command>) et permet de créer/modifier/lire des fichiers texte. Pour les fichiers les plus simples, il est parfois possible de les créer directement depuis l'interpréteur de commandes grâce aux redirections. Ainsi, <command>echo "<replaceable>texte</replaceable>" &gt;<replaceable>fichier</replaceable></command> crée un fichier nommé <replaceable>fichier</replaceable> contenant « <replaceable>texte</replaceable> ». Pour ajouter une ligne à la fin de ce fichier, il est possible de faire <command>echo "<replaceable>texte supplémentaire</replaceable>" &gt;&gt;<replaceable>fichier</replaceable></command>. On notera l'emploi de <literal>&gt;&gt;</literal> dans cet exemple.</para>
    </section>
    <section>
      <title>Recherche de fichiers et dans les fichiers</title>

      <para>La commande <command>find <replaceable>répertoire</replaceable> <replaceable>critères</replaceable></command> recherche des fichiers dans l'arborescence sous <replaceable>répertoire</replaceable>. L'option <literal>-name <replaceable>nom</replaceable></literal> est le critère de recherche le plus courant et permet de retrouver un fichier par son nom.</para>

      <para>La commande <command>grep <replaceable>expression</replaceable> <replaceable>fichiers</replaceable></command> extrait du contenu des fichiers les lignes correspondant à l'expression rationnelle (voir encadré <xref linkend="sidebar.regexp" />). L'option <literal>-r</literal> exécute une recherche récursive sur tous les fichiers contenus dans le répertoire indiqué en paramètre. Cela permet d'identifier facilement un fichier dont on connaît une partie du contenu.</para>
    </section>
    <section>
      <title>Gestion des processus</title>

      <para>La commande <command>ps aux</command> liste les processus en cours d'exécution et leur identifiant <foreignphrase>pid</foreignphrase> <foreignphrase>(process id)</foreignphrase>. Par la suite, la commande <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> envoie un signal à un processus donné (à condition qu'il appartienne au même utilisateur) ; le signal <literal>TERM</literal> demande au programme de se terminer alors que <literal>KILL</literal> le tue brutalement.</para>

      <para>L'interpréteur de commandes permet de lancer des programmes en tâche de fond : il suffit pour cela d'ajouter « &amp;» à la fin de la commande. Dans ce cas, l'utilisateur retrouve le contrôle immédiatement, bien que la commande lancée ne soit pas encore terminée. La commande <command>jobs</command> indique les processus exécutés en arrière-plan. La commande <command>fg %<replaceable>numéro-de-job</replaceable></command> (<foreignphrase>foreground</foreignphrase>, avant-plan) replace le processus à l'avant-plan. Dans cette situation, la combinaison de touches <keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo> permet de stopper l'exécution du processus et de reprendre le contrôle de la ligne de commande. Pour réactiver en arrière-plan le processus stoppé, il faut faire <command>bg %<replaceable>numéro-de-job</replaceable></command> (pour <foreignphrase>background</foreignphrase>, arrière-plan).</para>
    </section>
    <section>
      <title>Informations système : mémoire, espace disque, identité</title>

      <para>La commande <command>free</command> affiche des informations sur l'usage de la mémoire vive, tandis que <command>df</command> <foreignphrase>(disk free)</foreignphrase> rapporte l'espace disponible sur les différents disques accessibles dans l'arborescence. On emploie fréquemment l'option <literal>-h</literal> de <command>df</command> (pour <foreignphrase>human readable</foreignphrase>) afin qu'il affiche les tailles avec une unité plus adaptée (généralement mégaoctets ou gigaoctets). De même, la commande <command>free</command> dispose de <literal>-m</literal> ou <literal>-g</literal> pour afficher les informations soit en mégaoctets soit en gigaoctets.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       used       free     shared    buffers     cached
Mem:       1028420    1009624      18796          0      47404     391804
-/+ buffers/cache:     570416     458004
Swap:      2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>Sys. de fich.        1K-blocs       Occupé Disponible Capacité Monté sur
/dev/hda6              9614084   4737916   4387796  52% /
tmpfs                   514208         0    514208   0% /lib/init/rw
udev                     10240       100     10140   1% /dev
tmpfs                   514208    269136    245072  53% /dev/shm
/dev/hda7             44552904  36315896   7784380  83% /home
</computeroutput></screen>

      <para>La commande <command>id</command> affiche l'identité de l'utilisateur connecté et indique la liste des groupes dont il est membre. Il est parfois important de pouvoir vérifier si l'on est membre d'un groupe donné ; cela peut conditionner l'accès à certains fichiers ou périphériques.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groupes=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
      </screen>
    </section>
  </section>
  <section id="sect.filesystem-hierarchy">
    <title>Organisation de l'arborescence des fichiers</title>
    <indexterm><primary>arborescence des fichiers</primary></indexterm>
    <section>
      <title>La racine</title>

      <para>L'arborescence d'un système Debian est organisée selon la norme FHS <foreignphrase>(Filesystem Hierarchy Standard)</foreignphrase>. Elle codifie de manière précise l'usage de chaque répertoire. Étudions la subdivision principale :</para>
      <itemizedlist>
        <listitem>
	  <para><filename>/bin/</filename> : programmes de base ;</para>
        </listitem>
        <listitem>
	  <para><filename>/boot/</filename> : noyau Linux et autres fichiers nécessaires à son démarrage ;</para>
        </listitem>
        <listitem>
	  <para><filename>/dev/</filename> : fichiers de périphériques ;</para>
        </listitem>
        <listitem>
	  <para><filename>/etc/</filename> : fichiers de configuration ;</para>
        </listitem>
        <listitem>
	  <para><filename>/home/</filename> : fichiers personnels des utilisateurs ;</para>
        </listitem>
        <listitem>
	  <para><filename>/lib/</filename> : bibliothèques de base ;</para>
        </listitem>
        <listitem>
	  <para><filename>/media/*</filename> : points de montage pour des périphériques amovibles (CD-Rom, clé USB, etc.) ;</para>
        </listitem>
        <listitem>
	  <para><filename>/mnt/</filename> : point de montage temporaire ;</para>
        </listitem>
        <listitem>
	  <para><filename>/opt/</filename> : applications additionnelles fournies par des tierces parties ;</para>
        </listitem>
        <listitem>
	  <para><filename>/root/</filename> : fichiers personnels de l'administrateur (utilisateur <literal>root</literal>) ;</para>
        </listitem>
        <listitem>
          <para><filename>/run/</filename>: données d'exécution volatiles qui ne persistent pas entre les redémarrages (ceci n'est pas encore inclus dans la norme FHS);</para>
        </listitem>
        <listitem>
	  <para><filename>/sbin/</filename> : programmes système ;</para>
        </listitem>
        <listitem>
	  <para><filename>/srv/</filename> : données pour les services hébergés par ce système ;</para>
        </listitem>
        <listitem>
	  <para><filename>/tmp/</filename> : fichiers temporaires, ce répertoire étant souvent vidé au démarrage ;</para>
        </listitem>
        <listitem>
	  <para><filename>/usr/</filename> : applications supplémentaires ; ce répertoire se subdivise à nouveau en <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> selon la même logique. En outre, <filename>/usr/share/</filename> contient des données indépendantes de l'architecture. <filename>/usr/local/</filename> permet à l'administrateur d'installer manuellement certaines applications sans perturber le reste du système qui est géré par le système de paquetage (<command>dpkg</command>).</para>
        </listitem>
        <listitem>
	  <para><filename>/var/</filename> : données variables des démons. Ceci inclut les fichiers de traces, les files d'attente, les caches, etc.</para>
        </listitem>
        <listitem>
	  <para><filename>/proc/</filename> et <filename>/sys/</filename> ne sont pas standardisés et sont spécifiques au noyau Linux. Ils servent à exporter des données du noyau vers l'espace utilisateur (voir <xref linkend="sect.userspace-presentation" /> et <xref linkend="sect.user-space" /> pour des explications sur le sujet).</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Le répertoire personnel de l'utilisateur</title>

      <para>Le contenu des répertoires utilisateurs n'est pas standardisé. Cependant, il y a tout de même quelques conventions à connaître. Avant tout, il faut savoir que l'on désigne fréquemment le répertoire personnel par un tilde (« ~ ») car les interpréteurs de commandes le remplaceront automatiquement par le bon répertoire <filename>/home/<replaceable>utilisateur</replaceable>/</filename>.</para>

      <para>Traditionnellement, les fichiers de configuration des applications sont directement dans le répertoire de l'utilisateur, mais leurs noms débutent par un point (ex : <filename>~/.muttrc</filename> pour le lecteur de courrier <command>mutt</command>). Signalons que les fichiers débutant par un point sont cachés par défaut : il faut passer l'option <literal>-a</literal> à <command>ls</command> pour les voir et les gestionnaires de fichiers graphiques ont chacun leur propre mécanisme d'activation de l'affichage des fichiers cachés.</para>

      <para>Parfois, les logiciels emploient un répertoire complet (comme <filename>~/.ssh/</filename>) lorsqu'ils ont plusieurs fichiers de configuration à stocker. Signalons au passage que certaines applications (les navigateurs web comme Iceweasel par exemple) utilisent ces répertoires comme cache pour des données téléchargées. C'est pourquoi certains de ces répertoires peuvent être assez volumineux.</para>

      <para>Ces fichiers de configuration (en anglais, on parle de <foreignphrase>dotfiles</foreignphrase>) ont longtemps proliféré au point de surcharger le répertoire de l'utilisateur où ils sont directement stockés. Heureusement, un effort collectif, mené sous la bannière du projet FreeDesktop.org, a créé une nouvelle norme connue sous le nom de <foreignphrase>XDG Base Directory Specification</foreignphrase> pour standardiser l'organisation de ces fichiers et répertoires. Cette norme précise que les fichiers de configuration devraient être stockés sous <filename>~/.config</filename>, les fichiers de cache sous <filename>~/.cache</filename> et les données des applications sous <filename>~/.local</filename> (ou des sous-répertoires de ceux-ci). Cette norme commence à être reconnue et plusieurs applications (notamment graphiques) ont commencé à la respecter.</para>

      <para>Les bureaux graphiques affichent généralement le contenu du répertoire <filename>~/Bureau/</filename> (ou <filename>~/Desktop/</filename> pour un système configuré en anglais) sur le bureau (c'est l'écran qui reste une fois toutes les applications fermées ou minimisées).</para>

      <para>Enfin, il arrive que le système de messagerie dépose les courriers électroniques entrants dans <filename>~/Mail/</filename>.</para>
    </section>
  </section>
  <section id="sect.computer-layers">
    <title>Fonctionnement d'un ordinateur : les différentes couches en jeu</title>

    <para>L'ordinateur se présente souvent comme quelque chose d'assez abstrait et sa partie visible est très simplifiée par rapport à sa complexité réelle. Cette complexité réside en partie dans le nombre d'éléments mis en jeu ; ces éléments peuvent cependant être regroupés en couches superposées, les éléments d'une couche n'interagissant qu'avec ceux de la couche immédiatement supérieure et de la couche immédiatement inférieure.</para>

    <para>En tant qu'utilisateur final, il n'est pas forcément nécessaire de connaître ces détails... du moins tant que tout fonctionne. Une fois confronté au problème « l'accès Internet ne fonctionne plus », il est indispensable de pouvoir retrouver dans quelle couche le problème apparaît : est-ce que la carte réseau (le matériel) fonctionne ? Est-ce qu'elle est reconnue par l'ordinateur ? Est-ce que Linux la reconnaît ? Est-ce que le réseau est bien configuré ? etc. Toutes ces questions vont permettre d'isoler la couche responsable et de traiter le problème au bon niveau.</para>
    <section id="sect.hardware">
      <title>Au plus bas niveau : le matériel</title>
      <indexterm><primary>IDE</primary></indexterm>
      <indexterm><primary>SCSI</primary></indexterm>
      <indexterm><primary>Serial ATA</primary></indexterm>
      <indexterm><primary>Parallel ATA</primary></indexterm>
      <indexterm><primary>ATA</primary></indexterm>
      <indexterm><primary>IEEE 1394</primary></indexterm>
      <indexterm><primary>Firewire</primary></indexterm>
      <indexterm><primary>USB</primary></indexterm>

      <para>Pour commencer, rappelons qu'un ordinateur est avant tout un ensemble d'éléments matériels. On a généralement une carte mère, sur laquelle sont connectés un processeur (parfois plusieurs), de la mémoire vive, différents contrôleurs de périphériques intégrés et des emplacements d'extension pour des cartes filles, pour d'autres contrôleurs de périphériques. Parmi ces contrôleurs, on peut citer les normes IDE (Parallel ATA), SCSI et Serial ATA, qui servent à raccorder des périphériques de stockage comme des disques durs. On trouve également des contrôleurs USB, qui accueillent une grande variété de matériels (de la webcam au thermomètre, du clavier à la centrale domotique) et IEEE 1394 (Firewire). Ces contrôleurs permettent souvent de relier plusieurs périphériques à la fois ; c'est pourquoi on emploie fréquemment le terme de « bus » pour désigner le sous-système complet géré par le contrôleur. Les cartes filles incluent les cartes graphiques (sur lesquelles on pourra brancher un écran), les cartes son, les cartes réseau, etc. Certaines cartes mères intègrent une partie de ces fonctionnalités ; il n'est donc pas toujours nécessaire de recourir à des cartes d'extension.</para>

      <sidebar>
        <title><emphasis>EN PRATIQUE</emphasis> Vérifier que le matériel fonctionne</title>

	<para>Il n'est pas toujours évident de vérifier que le matériel fonctionne. En revanche, il est parfois simple de constater qu'il ne marche plus.</para>

	<para>Un disque dur est constitué de plateaux rotatifs et de têtes de lecture qui se déplacent. Lorsque le disque dur est mis sous tension, il fait un bruit caractéristique dû à la rotation des plateaux. De plus, l'énergie dissipée entraîne un réchauffement du disque. Un disque alimenté qui reste froid et silencieux est vraisemblablement hors d'usage.</para>

	<para>Les cartes réseau disposent souvent de LED qui indiquent l'état de la connexion. Si un câble est branché et s'il aboutit sur un concentrateur <foreignphrase>(hub)</foreignphrase> ou un commutateur <foreignphrase>(switch)</foreignphrase> sous tension, une LED au moins sera allumée. Si aucune LED n'est allumée, soit la carte est défectueuse, soit le périphérique connecté à l'autre bout du câble est défectueux, soit le câble est défectueux. Il ne reste plus qu'à tester individuellement les composants incriminés.</para>

	<para>Certaines cartes électroniques filles — les cartes vidéo 3D notamment — disposent de mécanismes de refroidissement intégré, souvent des radiateurs et des ventilateurs. Si le ventilateur ne tourne pas alors que la carte est sous tension, il est probable que la carte ait surchauffé et soit abîmée. Il en va de même pour le (ou les) processeur(s) situé(s) sur la carte mère.</para>
      </sidebar>
    </section>
    <section id="sect.bios">
      <title>Le démarreur : le BIOS ou l'UEFI</title>
      <indexterm><primary>BIOS</primary></indexterm>
      <indexterm><primary>UEFI</primary></indexterm>
      <indexterm><primary>Secteur d'amorçage</primary></indexterm>

      <para>Le matériel seul n'est cependant pas autonome ; il est même totalement inutile sans qu'une partie logicielle permette d'en tirer parti. C'est le but du système d'exploitation et des applications — qui, de manière similaire, ne peuvent fonctionner sans un ordinateur pour les exécuter.</para>

      <para>Il est donc nécessaire d'ajouter un élément de liaison, qui mette en relation le matériel et les logiciels, ne serait-ce qu'au démarrage de l'ordinateur. C'est le rôle principal du BIOS et de l'UEFI, qui sont des logiciels intégrés à la carte mère de l'ordinateur et exécutés automatiquement à l'allumage. Leur tâche primordiale consiste à déterminer à quel logiciel passer la main. Dans le cas du BIOS, il s'agit en général de trouver le premier disque dur contenant un secteur d'amorçage (souvent appelé <acronym>MBR</acronym> pour <foreignphrase>Master Boot Record</foreignphrase>), de charger ce secteur d'amorçage et de l'exécuter. À partir de ce moment, le BIOS n'est généralement plus utilisé (jusqu'au démarrage suivant). Pour l'UEFI, il s'agit de scanner les disques pour trouver la partition EFI dédiée contenant d'autres applications EFI à exécuter.</para>

      <sidebar>
        <title><emphasis>OUTIL</emphasis> Setup, l'outil de configuration du BIOS et de l'UEFI</title>
        <indexterm><primary><foreignphrase>Setup</foreignphrase></primary></indexterm>

	<para>Le BIOS ou l'UEFI contient également un logiciel appelé Setup, qui sert à configurer certains aspects de l'ordinateur. On pourra notamment choisir le périphérique de démarrage à favoriser (par exemple, le lecteur de disquettes ou de CD-Rom), régler l'horloge interne, etc. Pour lancer cet outil, il faut généralement appuyer sur une touche très tôt après la mise sous tension de l'ordinateur. C'est souvent <keycap>Suppr</keycap> ou <keycap>Échap</keycap>, plus rarement <keycap>F2</keycap> ou <keycap>F10</keycap>, mais la plupart du temps elle est indiquée à l'écran.</para>
      </sidebar>

      <para>Le secteur d'amorçage (ou la partition EFI) contient à son tour un autre logiciel, le chargeur de démarrage, dont la tâche sera de trouver un système d'exploitation et de l'exécuter. Comme ce chargeur de démarrage n'est pas embarqué dans la carte mère mais chargé depuis un disque dur (ou autre), il dispose de plus de possibilités que le chargeur du BIOS (ce qui explique pourquoi le BIOS ne charge pas le système d'exploitation directement). Le chargeur de démarrage (souvent GRUB sur les systèmes Linux) peut ainsi proposer de choisir quel système démarrer si plusieurs sont présents, avec un choix par défaut faute de réponse dans un délai imparti, avec des paramètres divers éventuellement saisis par l'utilisateur, etc. Il finit donc par trouver un noyau à démarrer, le charge en mémoire et l'exécute.</para>

      <sidebar>
        <title><emphasis>NOTE</emphasis> UEFI, le remplaçant moderne du BIOS</title>
        <indexterm><primary>UEFI</primary></indexterm>
        <indexterm><primary><foreignphrase>Secure Boot</foreignphrase> (démarrage sécurisé)</primary></indexterm>

        <para>L'UEFI est un développement relativement récent. La plupart des nouveaux ordinateurs supportent le démarrage par UEFI, mais également le démarrage par le BIOS pour assurer la rétrocompatibilité avec des systèmes d'exploitation qui ne sont pas encore prêts pour l'UEFI.</para>
        <para>Ce nouveau système n'a plus certaines limitations que le BIOS avait : avec l'utilisation d'une partition dédiée, le chargeur de démarrage n'a plus besoin de bricoler pour se loger dans un petit secteur d'amorçage, et ensuite trouver le noyau à démarrer. Mieux encore, avec un noyau Linux adapté, l'UEFI peut directement démarrer le noyau sans l'intermédiaire d'un chargeur de démarrage. L'UEFI est aussi un prérequis pour exploiter la technologie <foreignphrase>Secure Boot</foreignphrase> (<emphasis>démarrage sécurisé</emphasis>), qui n'exécutera que des logiciels préalablement validés par le fournisseur du système d'exploitation.</para>
      </sidebar>

      <para>Le BIOS (ou l'UEFI) est également responsable de l'initialisation et de la détection d'un certain nombre de périphériques. Il détecte bien entendu les périphériques IDE/SATA (disques durs et lecteurs de CD-Roms/DVD-Roms), mais souvent aussi les périphériques PCI. Les périphériques détectés sont généralement listés de manière furtive au démarrage (l'appui sur la touche <keycap>Pause</keycap> permet souvent de figer l'écran pour l'analyser plus longuement). Si un des périphériques PCI installés n'y apparaît pas, c'est mauvais signe. Au pire, le périphérique est défectueux, au mieux il fonctionne mais il est incompatible avec cette version du BIOS ou de la carte mère. Les spécifications PCI ont en effet évolué au fil du temps et il n'est pas impossible qu'une ancienne carte mère ne gère pas une carte PCI récente.</para>
    </section>
    <section id="sect.kernel">
      <title>Le noyau</title>

      <para>Nous arrivons alors au premier logiciel qui va s'exécuter de manière durable (le BIOS/l'UEFI et le chargeur de démarrage ne fonctionnent que quelques secondes chacun) : le noyau du système d'exploitation. Celui-ci prend alors le rôle de chef d'orchestre, pour assurer la coordination entre le matériel et les logiciels. Ce rôle inclut différentes tâches, notamment le pilotage du matériel, la gestion des processus, des utilisateurs et des permissions, le système de fichiers, etc. Il fournit ainsi une base commune aux programmes du système.</para>
    </section>
    <section id="sect.userspace-presentation">
      <title>L'espace utilisateur</title>

      <para>Bien que tout ce qui se passe au-dessus du noyau soit regroupé sous le vocable d'espace utilisateur, on peut encore différencier des couches logicielles ; mais leurs interactions étant plus complexes que précédemment, la différenciation n'est plus aussi simple. Un programme peut en effet faire appel à des bibliothèques qui font à leur tour appel au noyau, mais le flux des communications peut aussi mettre en jeu d'autres programmes, voire de multiples bibliothèques s'appelant l'une l'autre.</para>
    </section>
  </section>
  <section id="sect.kernel-role-and-tasks">
    <title>Quelques fonctions remplies par le noyau</title>
    <section id="sect.hardware-drivers">
      <title>Pilotage du matériel</title>

      <para>Le noyau sert d'abord à contrôler les différents composants matériels, les recenser, les mettre en marche lors de l'initialisation de l'ordinateur, etc. Il les rend également disponibles pour les applications de plus haut niveau, avec une interface de programmation simplifiée : les logiciels peuvent ainsi utiliser les périphériques sans se préoccuper de détails de très bas niveau comme l'emplacement dans lequel est enfichée la carte fille. L'interface de programmation offre également une couche d'abstraction qui sert par exemple à un logiciel de visiophonie pour tirer parti d'une webcam de la même manière, quels que soient sa marque et son modèle ; ce logiciel utilise simplement l'interface de programmation V4L (<foreignphrase>Video for Linux</foreignphrase>, le quatre se prononçant comme <foreignphrase>for</foreignphrase> en anglais) et c'est le noyau qui traduira les appels de fonction de cette interface en commandes spécifiques au type de webcam réellement utilisé.</para>

     
      <para><indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmia</command></primary></indexterm> Le noyau exporte de nombreuses informations sur le matériel qu'il a détecté par l'intermédiaire des systèmes de fichiers virtuels <filename>/proc/</filename> et <filename>/sys/</filename>. Plusieurs utilitaires synthétisent certaines de ces informations : citons <command>lspci</command> (du paquet <emphasis role="pkg">pciutils</emphasis>) qui affiche la liste des périphériques PCI connectés, <command>lsusb</command> (du paquet <emphasis role="pkg">usbutils</emphasis>) qui fait de même avec les périphériques USB et <command>lspcmcia</command> (du paquet <emphasis role="pkg">pcmciautils</emphasis>) pour les cartes PCMCIA. Ces programmes sont très utiles quand il faut pouvoir identifier de manière certaine le modèle d'un périphérique. En outre, cette identification unique permet de mieux cibler les recherches sur Internet et de trouver plus facilement des documents pertinents.</para>

      <example>
        <title>Exemple d'informations fournies par <command>lspci</command> et <command>lsusb</command></title>

        <screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>
      </example>

      <para>Les options <literal>-v</literal> de ces programmes permettent d'obtenir des informations beaucoup plus détaillées qui ne seront généralement pas nécessaires. Enfin, la commande <command>lsdev</command> (du paquet <emphasis role="pkg">procinfo</emphasis>) liste les différentes ressources de communication exploitées par les périphériques présents.</para>

      <para>Bien souvent, les applications accèdent aux périphériques par le biais de fichiers spéciaux qui sont créés dans <filename>/dev/</filename> (voir encadré <xref linkend="sidebar.special-files" />). Il existe des fichiers spéciaux qui représentent les disques (par exemple <filename>/dev/hda</filename> et <filename>/dev/sdc</filename>), les partitions (<filename>/dev/hda1</filename> ou <filename>/dev/sdc3</filename>), la souris (<filename>/dev/input/mouse0</filename>), le clavier (<filename>/dev/input/event0</filename>), la carte son (<filename>/dev/snd/*</filename>), les ports série (<filename>/dev/ttyS*</filename>), etc.</para>
    </section>
    <section id="sect.filesystems">
      <title>Systèmes de fichiers</title>
      <indexterm><primary>système de fichiers</primary></indexterm>
      <indexterm><primary>fichiers, système de</primary></indexterm>

      <para>Un des aspects les plus visibles du noyau est celui des systèmes de fichiers. Les systèmes Unix intègrent en effet les différentes méthodes de stockage de fichiers dans une arborescence unique, ce qui permet aux utilisateurs (et aux applications) de stocker ou retrouver des données simplement grâce à leur emplacement dans cette arborescence.</para>

      <para>Le point de départ de cette arborescence est la racine, <filename>/</filename>. Il s'agit d'un répertoire pouvant contenir des sous-répertoires, chacun étant identifié par son nom. Par exemple, le sous-répertoire <literal>home</literal> de <filename>/</filename> est noté <filename>/home/</filename> ; ce sous-répertoire peut à son tour contenir d'autres sous-répertoires et ainsi de suite. Chaque répertoire peut également contenir des fichiers, qui contiendront les données réellement stockées. Le nom de fichier <filename>/home/rmas/Bureau/hello.txt</filename> désigne ainsi un fichier appelé <literal>hello.txt</literal>, stocké dans le sous-répertoire <literal>Bureau</literal> du sous-répertoire <literal>rmas</literal> du répertoire <literal>home</literal> présent à la racine. Le noyau fait alors la traduction entre ce système de nommage de fichiers et leur format de stockage physique sur disque.</para>

      <para>Contrairement à d'autres systèmes, cette arborescence est unique et peut intégrer les données de plusieurs disques. L'un de ces disques est alors utilisé comme racine, les autres étant « montés » dans des répertoires de l'arborescence (la commande Unix qui réalise cela est <command>mount</command>) ; ces autres disques sont alors accessibles sous ces « points de montage ». On peut ainsi déporter sur un deuxième disque dur les données personnelles des utilisateurs (qui sont traditionnellement stockées dans <filename>/home/</filename>). Ce disque contiendra alors les répertoires <literal>rhertzog</literal> et <literal>rmas</literal>. Une fois le disque monté dans <filename>/home/</filename>, ces répertoires deviendront accessibles aux emplacements habituels, et on pourra retrouver <filename>/home/rmas/Bureau/hello.txt</filename>.</para>
      <indexterm><primary><command>mkfs</command></primary></indexterm>

      <para>Il existe différents systèmes de fichiers, qui correspondent à différentes manières de stocker physiquement les données sur les disques. Les plus connus sont <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> et <emphasis>ext4</emphasis>, mais il en existe d'autres. Par exemple, <emphasis>vfat</emphasis> est le système historiquement utilisé par les systèmes de type DOS et Windows et permet donc d'utiliser des disques durs sous Debian autant que sous Windows. Dans tous les cas, il faut préparer le système de fichiers avant de pouvoir le monter ; cette opération, fréquemment appelée formatage, est effectuée par le biais de commandes comme <command>mkfs.ext3</command> (<command>mkfs</command> étant une abréviation de <foreignphrase>MaKe FileSystem</foreignphrase>). Ces commandes prennent en paramètre le fichier de périphérique représentant la partition à formater (par exemple <filename>/dev/hda1</filename>). Cette opération destructrice n'est à exécuter qu'une seule fois, sauf si l'on souhaite délibérément vider le contenu du système de fichiers et repartir de zéro.</para>

      <para>Il existe aussi des systèmes de fichiers réseau, comme <acronym>NFS</acronym>, où les données ne sont pas stockées sur un disque local ; elles sont en effet transmises à un serveur sur le réseau, qui les stockera lui-même et les restituera à la demande ; l'abstraction du système de fichiers permet aux utilisateurs de ne pas avoir à s'en soucier : les fichiers resteront accessibles par leurs emplacements dans l'arborescence.</para>
    </section>
    <section id="sect.shared-functions">
      <title>Fonctions partagées</title>

      <para>Le noyau est également responsable de fonctions utilisées par tous les logiciels et qu'il est judicieux de centraliser ainsi. Ces fonctions incluent notamment la gestion des systèmes de fichiers, permettant à une application d'ouvrir simplement un fichier en fonction de son nom, sans avoir à se préoccuper de l'emplacement physique du fichier (qui peut se trouver morcelé en plusieurs emplacements d'un disque dur, voire entre plusieurs disques durs, ou stocké à distance sur un serveur de fichiers). Il s'agit également de fonctions de communication, que les applications pourront appeler pour échanger des informations à travers le réseau sans se soucier du mode de transport des données (qui pourront transiter sur un réseau local, une ligne téléphonique, un réseau sans fil ou une combinaison de tout cela).</para>
    </section>
    <section id="sect.process-management">
      <title>Gestion des processus</title>
      <indexterm><primary><foreignphrase>pid</foreignphrase></primary></indexterm>

      <para>Un processus correspond à un programme en cours d'exécution. Ceci inclut une zone de mémoire dans laquelle est stocké le programme lui-même, mais également l'ensemble des données sur lesquelles le programme travaille. Le noyau est responsable de la création des processus et de leur suivi : lorsqu'un programme est lancé, le noyau met de côté cette zone de mémoire qu'il réserve au processus, y charge (depuis le disque) le code du programme et lance l'exécution. Il garde également des informations qui concernent ce processus, notamment un numéro d'identification (<foreignphrase>pid</foreignphrase>, pour <foreignphrase>process identifier</foreignphrase>).</para>

      <para>Les noyaux de type Unix (dont fait partie Linux), comme la plupart des systèmes d'exploitation modernes, sont dits « multi-tâches », c'est-à-dire qu'ils permettent l'exécution « simultanée » de nombreux processus. En réalité, un seul processus peut fonctionner à un instant donné ; le noyau découpe alors le fil du temps en fines tranches et exécute les différents processus à tour de rôle. Comme ces intervalles de temps ont des durées très courtes (de l'ordre de la milliseconde), l'utilisateur a l'illusion de programmes s'exécutant en parallèle, alors qu'ils ne sont en réalité actifs que pendant certains intervalles et suspendus le reste du temps. La tâche du noyau est d'ajuster ses mécanismes d'ordonnancement pour parfaire cette illusion tout en maximisant les performances globales du système : si les intervalles sont trop longs, l'application manquera de réactivité vis-à-vis de l'utilisateur ; s'ils sont trop courts, le système perdra du temps à basculer d'une tâche à l'autre trop souvent. Ces décisions peuvent être influencées par des notions de priorités affectées à un processus ; un processus de haute priorité bénéficiera pour s'exécuter d'intervalles de temps plus longs et plus fréquents qu'un processus de basse priorité.</para>

      <sidebar>
        <title><emphasis>NOTE</emphasis> Systèmes multi-processeurs et assimilés</title>

	<para>La limitation évoquée ci-dessus d'un seul processus pouvant fonctionner à la fois, ne s'applique pas systématiquement. La réelle restriction est qu'il ne peut s'exécuter à un instant donné qu'un processus <emphasis>par cœur de processeur</emphasis>. Les systèmes multi-processeurs, multi-cœurs ou proposant de l'<foreignphrase>hyperthreading</foreignphrase> permettent en effet à plusieurs processus d'être exécutés simultanément. Le même principe de découpage du temps en intervalles attribués à tour de rôle aux processus actifs reste appliqué, afin de pouvoir traiter le cas où le nombre de processus en cours est supérieur à celui des cœurs disponibles. Cette situation est loin d'être exceptionnelle : un système de base, même peu actif, a presque toujours quelques dizaines de processus en cours d'exécution.</para>
      </sidebar>

      <para>Bien entendu, le noyau autorise l'exécution en parallèle de plusieurs processus correspondant au même programme : chacun dispose alors de ses propres intervalles de temps pour s'exécuter, ainsi que de sa zone de mémoire réservée. Comme un processus n'a accès qu'à sa propre zone de mémoire, les données de chacun restent indépendantes.</para>
    </section>
    <section id="sect.permissions">
      <title>Gestion des permissions</title>

      <para>Les systèmes de type Unix sont également multi-utilisateurs. Ils intègrent une notion de droits séparant les utilisateurs et les groupes d'utilisateurs entre eux ; ils autorisent ou non certaines actions en fonction de l'ensemble de droits dont on dispose. Le noyau gère donc, pour chaque processus, un ensemble de données qui vérifient les permissions de ce processus. En règle générale, il s'agit de « l'identité » sous laquelle tourne le processus, qui correspond le plus souvent au compte utilisateur qui a déclenché son exécution. Beaucoup d'actions ne pourront être menées à bien par le processus que s'il dispose des permissions requises. Par exemple, l'opération d'ouverture d'un fichier est subordonnée à une vérification de la compatibilité entre les permissions du fichier et l'identité du processus (cet exemple particulier est détaillé dans la <xref linkend="sect.rights-management" />).</para>
    </section>
  </section>
  <section id="sect.user-space">
    <title>L'espace utilisateur</title>
    <indexterm><primary>espace utilisateur</primary></indexterm>
    <indexterm><primary>espace noyau</primary></indexterm>

    <para>On appelle espace utilisateur l'environnement d'exécution des processus normaux, par opposition aux processus qui font partie du noyau. Cela ne signifie pas pour autant que tous ces processus soient réellement lancés directement par l'utilisateur : un système normal exécute un certain nombre de « démons » (ou processus d'arrière-plan) avant même que l'utilisateur ouvre une session de travail. Les « démons » sont alors considérés comme des processus de l'espace utilisateur.</para>
    <section id="sect.process-basics">
      <title>Processus</title>
      <indexterm><primary><command>init</command></primary></indexterm>

      <para>Lorsque le noyau a terminé son initialisation, il lance le tout premier processus, <command>init</command>, qui n'est généralement pas utile par lui-même. Les systèmes Unix fonctionnent donc avec de nombreux processus supplémentaires.</para>
      <indexterm><primary><foreignphrase>fork</foreignphrase></primary></indexterm>

      <para>Tout d'abord, un processus peut se dupliquer (on parle de <foreignphrase>fork</foreignphrase>). Le noyau alloue alors une nouvelle zone de mémoire pour le deuxième processus, de contenu identique à celle du premier, et se retrouve simplement avec un processus supplémentaire à gérer. À ce moment précis, la seule différence entre les deux processus est leur <foreignphrase>pid</foreignphrase>. Par convention, le nouveau processus est appelé le fils, alors que celui dont le <foreignphrase>pid</foreignphrase> n'a pas changé est appelé le père.</para>

      <para>Il arrive que le processus fils reste tel quel et « vive sa vie », indépendamment de son père, avec ses propres données correspondant au programme initial. Néanmoins, le cas le plus fréquent est que ce fils exécute un autre programme ; à de rares exceptions près, sa zone mémoire est alors simplement remplacée par le nouveau programme, dont l'exécution démarre. C'est précisément ce mécanisme que le système d'initialisation (le processus n°1) exploite pour démarrer des services additionnels et exécuter la séquence de démarrage, jusqu'à aboutir au lancement d'une interface graphique pour l'utilisateur (la séquence des événements est décrite avec plus de détails dans la <xref linkend="sect.system-boot" />).</para>

      <para>Lorsqu'un processus finit la tâche qui lui était dévolue, il se termine. Le noyau récupère alors la mémoire qui lui était affectée et cesse de lui distribuer des intervalles de temps d'exécution. Le processus père est informé de la destruction du fils : cela permet entre autres au père d'attendre la complétion d'une tâche sous-traitée. On retrouve ce mode de fonctionnement dans les interpréteurs de commandes (shells) : lorsque l'on tape une commande dans un shell, on ne retrouve l'invite que lorsqu'elle s'est terminée. La plupart des shells permettent cependant de ne pas attendre la fin de l'exécution d'une commande : il suffit pour cela de faire suivre le nom du programme à exécuter par &amp;. On retrouve alors l'invite aussitôt, ce qui peut poser des problèmes si la commande a des données à afficher.</para>
    </section>
    <section id="sect.daemons">
      <title>Démons</title>
      <indexterm><primary>démon</primary></indexterm>
      <indexterm><primary>démon</primary></indexterm>

      <para>Un démon est un processus lancé automatiquement au démarrage et qui fonctionne en tâche de fond pour accomplir certaines tâches de maintenance ou fournir des services aux autres processus. Cette notion de « tâche de fond » est arbitraire et ne correspond à rien de particulier du point de vue du système : ce sont des processus comme les autres, qui sont exécutés chacun à leur tour pendant un bref intervalle de temps de la même manière que les applications visibles. La distinction est simplement humaine : un processus qui fonctionne sans interaction avec l'utilisateur (sans interface graphique, notamment) est dit fonctionner en tâche de fond ou en tant que démon.</para>

      <sidebar>
        <title><emphasis>VOCABULAIRE</emphasis> Démon, un terme péjoratif ?</title>

	<para>Le terme démon est en réalité une transcription un peu hâtive de l'anglais <foreignphrase>daemon</foreignphrase>. Bien que l'origine grecque de ce mot ait également donné le mot <foreignphrase>demon</foreignphrase>, au sens de créature diabolique, le <foreignphrase>daemon</foreignphrase> est simplement à interpréter comme un aide, un auxiliaire (tout en gardant une dimension surnaturelle). Il n'y a pas en français de mot réellement adapté à ce concept, le sens du <foreignphrase>daemon</foreignphrase> anglais s'est donc retrouvé projeté sur le « démon » français et l'usage a consacré ce choix bien qu'il ne soit pas très heureux.</para>
      </sidebar>

      <para>Plusieurs de ces démons sont détaillés dans le <xref linkend="unix-services" />.</para>
    </section>
    <section id="sect.ipc">
      <title>Communications entre processus</title>
      <indexterm><primary>IPC</primary></indexterm>
      <indexterm><primary>communications inter-processus</primary></indexterm>

      <para>Qu'il s'agisse de démons ou d'applications interactives, un processus isolé n'est souvent pas très utile. Il existe donc différentes méthodes permettant à des processus séparés de communiquer entre eux, soit pour s'échanger des données, soit pour se contrôler l'un l'autre. Le terme générique les désignant est <foreignphrase>InterProcess Communications</foreignphrase> (IPC) c'est-à-dire communications inter-processus.</para>

      <para>Le système le plus simple est le fichier : le processus qui souhaite émettre des données les écrit dans un fichier dont le nom est convenu à l'avance ; le processus destinataire n'a alors qu'à lire ce fichier pour y récupérer les données.</para>
      <indexterm><primary>tube</primary></indexterm>

      <para>Pour éviter que les données soient stockées sur un disque dur, on peut également utiliser un tuyau ou tube (<foreignphrase>pipe</foreignphrase> en anglais). Il s'agit simplement d'un système de communication où des octets écrits à un bout ressortent tels quels à l'autre bout. Si les deux extrémités sont contrôlées par deux processus différents, on obtient un canal de communication simple et pratique. Les tubes se décomposent en deux catégories. Un tube nommé dispose d'une entrée spéciale dans le système de fichiers (bien que les données qui y transitent n'y soient pas stockées) et les deux processus peuvent donc l'ouvrir indépendamment l'un de l'autre, si l'emplacement du tube nommé est connu. Dans les cas où l'on cherche à faire communiquer deux processus apparentés (par exemple un père et son fils), il est possible au père de créer un tube anonyme, dont héritera son fils après le <foreignphrase>fork</foreignphrase> ; les deux processus pourront alors s'échanger des données sans passer par le système de fichiers.</para>

      <sidebar>
        <title><emphasis>EN PRATIQUE</emphasis> Un exemple concret</title>

	<para>Étudions ce qui se passe lorsqu'on lance une commande complexe (un <foreignphrase>pipeline</foreignphrase>) dans un shell. Supposons que nous ayons un processus <command>bash</command> (le shell standard sous Debian), de <foreignphrase>pid</foreignphrase> 4 374, dans lequel nous tapons la commande <command>ls | sort</command>.</para>

	<para>Le shell commence par interpréter la commande saisie. En l'occurrence, il s'agit de deux programmes (<command>ls</command> et <command>sort</command>), avec un flux de données de l'un vers l'autre (noté par le caractère <userinput>|</userinput>, dit <foreignphrase>pipe</foreignphrase>). <command>bash</command> crée donc un tube anonyme (qui n'existe pour l'instant que pour lui seul).</para>

	<para>Puis il se duplique ; on obtient donc un nouveau processus <command>bash</command>, de <foreignphrase>pid</foreignphrase> 4 521 (les <foreignphrase>pids</foreignphrase> sont de simples numéros abstraits et n'ont généralement pas de signification particulière). Ce processus n°4 521 hérite du tuyau anonyme, il pourra donc écrire du côté « entrée » ; <command>bash</command> redirige d'ailleurs le flux de sortie standard vers cette entrée du tuyau. Il se remplace ensuite par le programme <command>ls</command>, qui va lister le contenu du répertoire courant ; comme il écrit sur sa sortie standard et que celle-ci a été au préalable redirigée, le résultat est effectivement envoyé dans le tuyau.</para>

	<para>Une opération similaire est effectuée pour la deuxième commande : <command>bash</command> se duplique de nouveau, on obtient alors un nouveau processus <command>bash</command> de numéro 4 522. Comme ce dernier est également un fils du n°4 374, il hérite aussi du tuyau ; <command>bash</command> branche alors la sortie du tuyau sur son flux d'entrée standard, puis se remplace par le programme <command>sort</command>, dont la vocation est de trier les données reçues et d'afficher le résultat.</para>

	<para>Toutes les pièces sont maintenant en place : <command>ls</command> parcourt le répertoire courant et envoie la liste des fichiers dans le tuyau ; <command>sort</command> lit cette liste, puis la trie par ordre alphabétique et affiche le résultat. Les processus n°4 521 et n°4 522 se terminent alors et le 4 374, qui s'était mis en attente, reprend la main et affiche l'invite pour permettre à l'utilisateur de saisir une nouvelle commande.</para>
      </sidebar>

      <para>Mais toutes les communications inter-processus ne servent pas à faire transiter des flux de données. Il arrive également que des applications aient simplement besoin de se transmettre des messages comme « suspendre l'exécution » ou « reprendre ». Unix (et donc Linux) fournit pour cela un mécanisme de signaux, par lequel un processus peut simplement envoyer un signal spécifique (parmi une liste prédéfinie de signaux) à un autre, simplement en connaissant son <foreignphrase>pid</foreignphrase>.</para>

      <para>Pour des communications plus complexes, il existe aussi des mécanismes par lesquels un processus peut par exemple ouvrir l'accès d'une partie de sa zone mémoire à d'autres ; cette mémoire est alors partagée entre plusieurs processus, ce qui autorise à faire passer des données de l'un à l'autre.</para>

      <para>Enfin, les connexions par le réseau peuvent également servir à faire communiquer différents processus, susceptibles de s'exécuter sur des ordinateurs différents (voire séparés de milliers de kilomètres).</para>

      <para>Tous ces mécanismes sont utilisés, à des degrés divers, dans le fonctionnement normal d'un système Unix typique.</para>
    </section>
    <section id="sect.libraries">
      <title>Bibliothèques</title>
      <indexterm><primary>bibliothèque (de fonctions)</primary></indexterm>

      <para>Les bibliothèques de fonctions jouent un rôle crucial dans le fonctionnement d'un système d'exploitation Unix. Ce ne sont pas à proprement parler des programmes, puisqu'elles ne s'exécutent pas indépendamment, mais des collections de fragments de programmes qui sont utilisés par des programmes classiques. Parmi les bibliothèques les plus courantes, citons par exemple :</para>
      <itemizedlist>
        <listitem>
	  <para>la bibliothèque C standard <emphasis>(glibc)</emphasis>, qui contient des fonctions de base telles que celles permettant d'ouvrir des fichiers ou des connexions réseau, mais aussi de faciliter les interactions avec le noyau ;</para>
        </listitem>
        <listitem>
	  <para>les boîtes à outils graphiques <foreignphrase>(toolkits)</foreignphrase>, Gtk+ et Qt, qui permettent à de nombreux programmes de réutiliser les objets graphiques qu'elles proposent ;</para>
        </listitem>
        <listitem>
	  <para>la bibliothèque <emphasis>libpng</emphasis>, qui charge, interprète et sauvegarde des images au format PNG.</para>
        </listitem>
      </itemizedlist>

      <para>L'existence de ces bibliothèques permet aux applications de réutiliser du code existant ; leur développement en est simplifié d'autant, surtout lorsque de nombreuses applications font appel aux mêmes fonctions. Comme les bibliothèques sont souvent développées par des personnes différentes, le développement global du système est ainsi plus proche de la philosophie historique d'Unix.</para>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> La méthode Unix : une chose à la fois</title>

	<para>Un des concepts qui sous-tend le fonctionnement général des systèmes d'exploitation de la famille Unix est que chaque outil ne devrait faire qu'une chose, mais la faire bien, les applications pouvant alors réutiliser ces outils et construire une logique plus poussée par-dessus. Cela transparaît dans de nombreux domaines. Les scripts shell sont peut-être le meilleur exemple : ils assemblent en des séquences complexes des outils très simples (<command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command>, etc.). Une autre mise en pratique de cette philosophie est visible dans les bibliothèques de code : la <emphasis>libpng</emphasis> permet de lire et d'écrire des images au format PNG, avec différentes options et de différentes manières, mais elle ne fait que cela ; pas question pour elle de proposer des fonctions d'affichage ou d'édition.</para>
      </sidebar>

      <para>De plus, ces bibliothèques sont souvent dites « partagées », parce que le noyau est capable de ne les charger qu'une fois en mémoire même si plusieurs processus y font appel. Si le code qu'elles contiennent était au contraire intégré dans les applications, il serait présent en mémoire autant de fois qu'il y a de processus qui l'utilisent.</para>
    </section>
  </section>
</appendix>
