<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="unix-services">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-unix-services.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Démarrage du système</keyword>
      <keyword>Scripts d'initialisation</keyword>
      <keyword>SSH</keyword>
      <keyword>Telnet</keyword>
      <keyword>Droits</keyword>
      <keyword>Permissions</keyword>
      <keyword>Supervision</keyword>
      <keyword>Inetd</keyword>
      <keyword>Cron</keyword>
      <keyword>Sauvegarde</keyword>
      <keyword>Hotplug</keyword>
      <keyword>PCMCIA</keyword>
      <keyword>APM</keyword>
      <keyword>ACPI</keyword>
    </keywordset>
  </chapterinfo>
  <title>Services Unix</title>
  <highlights>
    <para>Ce chapitre parcourt un ensemble de services fondamentaux, souvent communs à beaucoup d'Unix. Tout administrateur se doit de les connaître.</para>
  </highlights>
  <section id="sect.system-boot">
    <title>Démarrage du système</title>
    <indexterm><primary>démarrage</primary><secondary>du système</secondary></indexterm>

    <para>Lorsque l'ordinateur démarre, les messages défilant sur la console révèlent de nombreuses initialisations et configurations automatiques. Parfois, il est souhaitable de modifier légèrement le déroulement de cette étape, ce qui implique de bien la comprendre. C'est l'objet de cette section.</para>

    
    <para>En tout premier lieu, le BIOS prend le contrôle de l'ordinateur, détecte les disques, charge le <emphasis>Master Boot Record</emphasis> (enregistrement d'amorçage maître) et l'exécute. Le chargeur d'amorçage prend alors le relais, trouve le noyau sur le disque, le charge et l'exécute. Le noyau s'initialise alors et se met en devoir de trouver et monter la partition contenant la racine de l'arborescence pour enfin démarrer le premier programme : <command>init</command>. Il est fréquent que cette « partition racine » et cet <command>init</command> soient en réalité sur un système de fichiers virtuel qui n'existe qu'en mémoire vive (d'où son nom <foreignphrase>initramfs</foreignphrase>, anciennement appelé <foreignphrase>initrd</foreignphrase> pour <foreignphrase>initialization RAM disk</foreignphrase>). Ce système de fichiers est chargé en mémoire par le chargeur d'amorçage, souvent à partir d'un fichier sur un disque dur ou sur le réseau. Il contient le strict minimum qui peut être requis par le noyau pour charger le « vrai » système de fichiers racine : il peut s'agir de modules de pilotes pour les disques durs ou d'autres périphériques sans lesquels le système ne peut pas démarrer, ou, plus fréquemment, des modules et des scripts d'initialisation permettant d'assembler des grappes RAID, d'ouvrir des partitions chiffrées, d'activer des volumes LVM… Une fois que la partition racine est montée, l'<foreignphrase>initramfs</foreignphrase> passe la main au vrai <command>init</command> et on revient sur le processus de démarrage standard.</para>

    <figure id="figure.boot-process-systemd">
      <title>Étapes du démarrage d'un ordinateur sous Linux avec systemd</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/startup-systemd.png" scalefit="1" width="80%" />
        </imageobject>
      </mediaobject>
    </figure>

    <section id="sect.systemd"><title>Le système d'initialisation systemd</title>

    <para>Le « vrai init » est actuellement fourni par <emphasis role="pkg">systemd</emphasis>, sur lequel cette section se focalise.</para>

    <sidebar>
      <title><emphasis>CULTURE</emphasis> Avant <command>systemd</command></title>

      <para><command>systemd</command> un « système d'initialisation » relativement récent, et bien qu'il était déjà disponible – dans une certaine mesure – dans <emphasis role="distribution">Wheezy</emphasis>, ce n'est que depuis <emphasis role="distribution">Jessie</emphasis> qu'il est employé par défaut. Les versions précédentes de Debian exploitaient « System V » (du paquet <emphasis role="pkg">sysv-rc</emphasis>), un système d'initialisation bien plus traditionnel qui sera présenté un peu plus loin.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> Autres systèmes d'initialisation</title>

      <para>Nous décrivons ici le processus d'initialisation utilisé par défaut sous Debian <emphasis role="distribution">Jessie</emphasis> (tel qu'implémenté par le paquet <emphasis role="pkg">systemd</emphasis>), ainsi que l'ancien système, <emphasis role="pkg">sysvinit</emphasis>, qui est dérivé et hérité des Unix de type <emphasis>System V</emphasis>, mais il en existe d'autres.</para>

      <para>Citons également le processus simplifié contenu dans le paquet <emphasis role="pkg">file-rc</emphasis>. Ce dernier garde le principe des niveaux de fonctionnement <foreignphrase>(runlevels)</foreignphrase>, mais remplace les répertoires et les liens symboliques par un unique fichier de configuration, qui spécifie à <command>init</command> les processus à lancer et l'ordre de lancement.</para>

      <para>Le système <command>upstart</command>, apparu plus récemment, n'est pas encore parfaitement testé sous Debian. Il est basé sur les événements ; les scripts de lancement ne sont plus exécutés de manière séquentielle mais en réponse à des événements comme l'aboutissement d'autres scripts dont ils dépendent. Ce système, initié par Ubuntu, est présent dans Debian <emphasis role="distribution">Jessie</emphasis> mais n'est pas le système par défaut : il vient en fait en remplacement de <emphasis role="package">sysvinit</emphasis> et une des tâches lancées par <command>upstart</command> est de lancer les scripts écrits pour les systèmes traditionnels, notamment ceux du paquet <emphasis role="package">sysv-rc</emphasis>.</para>

      <para>Il existe encore bien d'autres systèmes et d'autres modes de fonctionnement, comme <command>runit</command> ou <command>minit</command>, mais ils sont relativement spécialisés et minoritaires.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>CAS PARTICULIER</emphasis> Le démarrage sur le réseau</title>

      <para>Dans certaines configurations, le BIOS peut être configuré pour ne pas exécuter le MBR mais aller chercher son équivalent sur le réseau, ce qui permet par exemple de construire des ordinateurs sans disque dur, ou qui se réinstallent complètement à chaque démarrage. Cette possibilité n'est pas offerte par tous les matériels et il faut généralement une combinaison adaptée du BIOS et de la carte réseau.</para>

      <para>Le démarrage sur le réseau peut être utilisé pour lancer <command>debian-installer</command> ou FAI (voir <xref linkend="sect.installation-methods" />).</para>
    </sidebar>

    <sidebar>
      <title><emphasis>B.A.-BA</emphasis> Le processus, une invocation de programme</title>
      <indexterm><primary>processus</primary></indexterm>

      <para>Un processus est la représentation en mémoire d'un programme qui s'exécute. Il regroupe toutes les informations nécessaires au bon déroulement du logiciel (le code lui-même, mais aussi les données qu'il a en mémoire, la liste des fichiers qu'il a ouverts, des connexions réseau qu'il a établies, etc.). Un même programme peut faire l'objet de plusieurs processus, y compris sous le même identifiant utilisateur.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>SÉCURITÉ</emphasis> Gare à la substitution d'<command>init</command> par un shell</title>

      <para>Le premier processus démarré est par convention le programme <command>init</command> (qui par défaut est un lien symbolique vers <filename>/lib/systemd/systemd</filename>). Toutefois, il est possible de passer au noyau une option <literal>init</literal> indiquant un autre programme.</para>
      <indexterm><primary><command>init</command></primary></indexterm>

      <para>Toute personne capable d'accéder à l'ordinateur pourra appuyer sur le bouton <keycap>Reset</keycap> et ainsi le redémarrer, puis, via l'invite du chargeur d'amorçage, passer au noyau l'option <literal>init=/bin/sh</literal> pour obtenir un accès root sans connaître le mot de passe de l'administrateur.</para>

      <para>Pour éviter cela, on peut protéger le chargeur d'amorçage par un mot de passe. Pensez alors à protéger aussi l'accès au BIOS (un mécanisme de protection par mot de passe est presque toujours disponible), sans quoi un indélicat pourra toujours démarrer sur une disquette contenant son propre système Linux, qu'il utilisera pour accéder aux disques durs de l'ordinateur.</para>

      <para>Sachez enfin que la plupart des BIOS disposent de passe-partout génériques. Prévus à l'origine pour dépanner les distraits qui oublient les leurs, ces mots de passe sont désormais publics et diffusés sur Internet (vérifiez vous-même en cherchant <foreignphrase>BIOS generic passwords</foreignphrase> sur un moteur de recherche). Toutes ces protections ralentiront donc l'accès non autorisé à la machine, sans pouvoir l'empêcher totalement. C'est pourquoi il est vain de chercher à protéger un ordinateur si l'attaquant peut y accéder physiquement : il pourra de toute manière démonter les disques durs pour les brancher sur un ordinateur sous son contrôle, voire voler l'ordinateur entier, ou vider la mémoire du BIOS pour remettre à zéro le mot de passe...</para>
    </sidebar>


<para><command>systemd</command> exécute plusieurs processus qui ont la responsabilité de mettre en place le système : clavier, pilotes, systèmes de fichiers, réseau et services. Il effectue cela en conservant une vue globale du système et des exigences de chaque composant. Chaque composant est décrit par un (ou plusieurs) « fichier unité » <foreignphrase>(unit file)</foreignphrase> ; la syntaxe générale est dérivée de celle des « fichiers *.ini », avec des paires <literal><replaceable>clé</replaceable> = <replaceable>valeur</replaceable></literal> regroupées entre des en-têtes <literal>[<replaceable>section</replaceable>]</literal>. Ces fichiers sont placés dans <filename>/lib/systemd/system/</filename> et dans <filename>/etc/systemd/system/</filename> ; ils en existent plusieurs sortes (chacune avec sa spécialité) mais dans cette section on ne traitera que des <foreignphrase>services</foreignphrase> et des <foreignphrase>targets</foreignphrase> (« cibles »).</para>

<para>Un « fichier service » de systemd décrit un processus géré par systemd. Il contient approximativement les mêmes informations que les anciens scripts d'initialisation, mais exprimés d'une manière déclarative (et bien plus concise). <command>systemd</command> s'occupe de toutes les tâches répétitives (démarrer et arrêter le processus, vérifier son état, enregistrer des logs, abandonner des privilèges, etc.), et le fichier service n'a plus qu'à préciser les particularités du processus. Voici par exemple celui pour SSH :</para>

<programlisting>[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists= !/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</programlisting>

<para>On constate qu'il y a très peu de code dans ce fichier, juste des déclarations. <command>systemd</command> s'occupe d'afficher l'état d'avancement, garde une trace des processus, et les redémarre même lorsque c'est nécessaire.</para>

<para>Un « fichier <foreignphrase>target</foreignphrase> » de systemd décrit un état « cible » du système, dans lequel un certain nombre de services sont réputés être fonctionnels. On peut le concevoir comme l'équivalent d'un « niveau d'exécution » <foreignphrase>(runlevel)</foreignphrase> de l'ancien système. Une de ces cibles est <literal>local-fs.target</literal> ; lorsqu'elle est atteinte, le reste du système peut considérer que tous les systèmes de fichiers locaux sont montés et accessibles. Parmi les autres cibles existantes, citons <literal>network-online.target</literal> (« réseau en ligne ») et <literal>sound.target</literal> (« son »). Les dépendances d'une cible peuvent être listées soit dans le fichier <foreignphrase>target</foreignphrase> lui-même (sur la ligne <literal>Requires=</literal>), soit en créant un lien symbolique vers un fichier service dans le répertoire <literal>/lib/systemd/system/<replaceable>nom-de-la-cible</replaceable>.target.wants/</literal>. Ainsi, <filename>/etc/systemd/system/printer.target.wants/</filename> contient un lien vers <filename>/lib/systemd/system/cups.service</filename> ; systemd s'assurera donc que CUPS soit bien démarré pour atteindre la cible <literal>printer.target</literal>.</para>

<para>Puisque les fichiers de systemd ne sont pas des scripts ou des programmes, ils ne peuvent être exécutés directement : ils doivent être interprétés par systemd. C'est pourquoi l'administrateur dispose de plusieurs utilitaires pour interagir avec systemd, et contrôler l'état du système et de chacun de ses composants.</para>

<para>Le premier de ces outils est <command>systemctl</command>. Lorsqu'il est exécuté sans paramètres, il liste toutes les « unités » connues de systemd (à l'exception de celles qui ont été désactivées), ainsi que leur état. <command>systemctl status</command> donne une meilleure vue des services, et des processus associés. En lui passant un nom de service (comme dans <command>systemctl status ntp.service</command>), il renvoie encore plus de détails, ainsi que les dernières lignes de log en rapport avec le service (nous reviendrons là dessus plus loin).</para>

<para>Démarrer un service manuellement se fait simplement avec <command>systemctl start <replaceable>nom-de-service</replaceable>.service</command>. Inversement et sans surprise, arrêter un service se fait avec <command>systemctl stop <replaceable>nom-de-service</replaceable>.service</command> ; d'autres sous-commandes existent, comme <command>reload</command> (« recharger ») et <command>restart</command> (« redémarrer »).</para>

<para>Pour activer un service (autrement dit pour qu'il soit lancé automatiquement au démarrage de l'ordinateur), il convient de faire <command>systemctl enable <replaceable>nom-du-service</replaceable>.service</command> (ou <command>disable</command> pour le désactiver). La sous-commande <command>is-enabled</command> permet de vérifier l'état d'activation du service.</para>

<para>Une autre particularité de systemd est son système de journalisation – <command>journald</command>. Il peut être employé en complément des outils de journalisation traditionnels comme <command>syslogd</command> : il rajoute des fonctionnalités intéressantes comme l'association d'un message au service qui l'a généré, et la capacité de capturer les messages émis sur la sortie d'erreur des processus gérés. Les messages peuvent être consultés après coup, grâce à la commande <command>journalctl</command>. Sans arguments, elle affiche simplement tous les messages enregistrés depuis le démarrage du système ; on ne l'emploie que rarement de cette manière. La plupart du temps, on lui communique un identifiant de service dont on veut voir les messages :</para>

<screen><computeroutput># </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at mar. 2015-03-31 10:08:49 CEST, end at mar. 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</computeroutput></screen>

<para>Une autre option très utile est <command>-f</command>, qui demande à <command>journalctl</command> d'afficher les nouveaux messages au fur et à mesure de leur émission (de manière similaire à ce que réalise <command>tail -f <replaceable>fichier</replaceable></command>).</para>

<para>Lorsqu'un service n'a pas l'air de fonctionner correctement, la première étape pour résoudre le problème est de vérifier si le service est lancé avec <command>systemctl status</command> ; si ce n'est pas le cas, et si les messages affichés par cette première commande ne suffisent pas à identifier le problème, il convient alors de consulter les messages que journald a collecté au sujet de ce service. Prenons le cas d'un serveur SSH qui ne fonctionne pas :</para>

<screen><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since mar. 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at mar. 2015-03-31 17:29:27 CEST, end at mar. 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>vi /etc/ssh/sshd_config
</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service
</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since mar. 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </computeroutput></screen>

<para>Après avoir vérifié l'état du service (<foreignphrase>failed</foreignphrase>, en échec), nous avons consulté les messages du journal ; ils indiquaient une erreur dans le fichier de configuration. Après avoir corrigé ce dernier, nous avons redémarré le service et nous avons vérifié qu'il fonctionnait pour de bon.</para>

<sidebar><title><emphasis>POUR ALLER PLUS LOIN</emphasis> D'autres sortes de fichiers systemd <foreignphrase>(unit files)</foreignphrase></title>

<para>Dans cette section nous avons découvert les facettes les plus importantes de systemd. Mais il dispose de nombreuses autres fonctionnalités ; nous n'en listerons que quelques-unes ici.</para>

<itemizedlist>

<listitem><para>activation de socket : un fichier « socket » décrit une socket réseau ou Unix gérée par systemd ; concrètement la socket est créée par systemd, et le service sous-jacent peut être démarré à la demande lorsqu'une demande de connexion est reçue. Cela reprend approximativement les fonctionnalités de <command>inetd</command>. Voir <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para></listitem>

<listitem><para>minuterie : un fichier « timer » décrit un événement qui se reproduit à un intervalle régulier ou à un horaire particulier ; lorsqu'un service est lié à une minuterie, la tâche correspondante est exécutée chaque fois que la minuterie se déclenche. Cette fonctionnalité est similaire à celle offerte par <command>cron</command>. Voir <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para></listitem>

<listitem><para>réseau : un fichier « network » décrit une interface réseau, ce qui permet de configurer ces interfaces et d'exprimer le fait qu'un service dépend de la disponibilité d'une interface particulière.</para></listitem>

</itemizedlist>
</sidebar>

</section>

<section id="sect.sysvinit"><title>Le système d'initialisation System V</title>
    <para>Le système d'initialisation System V exécute tout un ensemble de processus en suivant les indications du fichier <filename>/etc/inittab</filename>. Le premier programme exécuté (correspondant à l'étape <emphasis>sysinit</emphasis>) est <command>/etc/init.d/rcS</command>, script qui exécute tous les programmes du répertoire <filename>/etc/rcS.d/</filename>. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm></para>

    <para>Parmi ceux-ci, on trouve successivement :</para>
    <itemizedlist>
      <listitem>
	<para>la configuration du clavier de la console ;</para>
      </listitem>
      <listitem>
	<para>le chargement des pilotes : la plupart des modules noyau sont chargés par le noyau lui-même en fonction du matériel détecté ; certains pilotes peuvent ensuite être systématiquement chargés, les modules correspondants doivent être listés dans <filename>/etc/modules</filename> ;</para>
      </listitem>
      <listitem>
	<para>la vérification de l'intégrité des systèmes de fichiers ;</para>
      </listitem>
      <listitem>
	<para>le montage des partitions locales ;</para>
      </listitem>
      <listitem>
	<para>la configuration du réseau ;</para>
      </listitem>
      <listitem>
	<para>le montage des systèmes de fichiers distants (NFS).</para>
      </listitem>
    </itemizedlist>

    <sidebar>
      <title><emphasis>B.A.-BA</emphasis> Modules du noyau et options</title>
      <indexterm><primary>modules</primary><secondary>du noyau</secondary></indexterm>

      <para>Les modules du noyau disposent eux aussi d'options qu'on peut paramétrer en plaçant des fichiers dans <filename>/etc/modprobe.d/</filename>. Les options sont définies à l'aide de directives <literal>options <replaceable>nom-du-module</replaceable> <replaceable>nom-option</replaceable>=<replaceable>valeur-option</replaceable></literal>. Plusieurs options peuvent être spécifiées avec une seule directive si nécessaire.</para>

      <para>Ces fichiers de configuration sont destinés à <command>modprobe</command> — le programme permettant de charger un module noyau avec ses dépendances (les modules peuvent en effet faire appel à d'autres modules). Ce dernier est fourni par le paquet <emphasis role="pkg">kmod</emphasis>.</para>
      <indexterm><primary><command>modprobe</command></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">kmod</emphasis></primary></indexterm>
    </sidebar>

    <para>Après cette phase, <command>init</command> reprend la main et démarre les programmes associés au niveau d'exécution <foreignphrase>(runlevel)</foreignphrase> normal, soit par défaut le niveau 2. Il exécute <command>/etc/init.d/rc 2</command>, script qui démarre tous les services donnés du répertoire <filename>/etc/rc2.d/</filename> débutant par la lettre « S ». Le nombre (à deux chiffres) qui suit servait historiquement à classer les services pour les démarrer dans le bon ordre, mais de nos jours le système de démarrage par défaut utilise <command>insserv</command>, un système de démarrage où l'ordonnancement se fait en fonction des dépendances entre scripts. Chaque script de démarrage déclare ainsi les contraintes qui s'appliquent à lui (par exemple, s'il doit démarrer avant ou après tel autre service) ; <command>init</command> les lance alors dans un ordre qui satisfait les contraintes. La numérotation statique des scripts n'est donc plus prise en compte (mais ils doivent toujours s'appeler d'un nom composé d'un « S » suivi de deux caractères, suivis à leur tour du véritable nom du script utilisé pour les dépendances). D'une manière générale, les services de base (comme le service de collecte des journaux, <command>rsyslog</command>, ou celui d'attribution des ports, <command>portmap</command>) sont démarrés en premier, suivis par les services standards et l'interface graphique (<command>gdm3</command>).</para>

    <para>Ce système de démarrage par dépendances permet d'automatiser des renumérotations qui pourraient s'avérer fastidieuses si elles devaient être faites manuellement et il prévient les erreurs humaines, puisque l'ordonnancement se fait en fonction des contraintes exprimées. Il présente également l'avantage supplémentaire de permettre le démarrage de plusieurs services en parallèle, si plusieurs scripts sont indépendants entre eux, ce qui peut accélérer la séquence de démarrage.</para>

    <indexterm><primary><foreignphrase>runlevel</foreignphrase></primary></indexterm>
    <indexterm><primary>exécution</primary><secondary>niveau</secondary></indexterm>

    <para><command>init</command> distingue plusieurs niveaux d'exécution car il peut basculer de l'un à l'autre par la commande <command>telinit <replaceable>nouveau-niveau</replaceable></command>. Dès son invocation, <command>init</command> exécute à nouveau <command>/etc/init.d/rc</command> avec le nouveau niveau d'exécution désiré, script qui démarre à son tour les services manquants et arrête ceux qui ne sont plus souhaités. Pour cela, il se réfère au contenu du répertoire <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (où <replaceable>X</replaceable> représente le nouveau niveau d'exécution). Les scripts débutant par « S » (comme <foreignphrase>Start</foreignphrase>) sont des services à démarrer, ceux débutant par « K » (comme <foreignphrase>Kill</foreignphrase>) sont des services à stopper. Le script évite de redémarrer tout service déjà actif dans le niveau d'exécution précédent.</para>

    <para>Dans Debian, le système d'initialisation System V n'utilise par défaut que quatre <foreignphrase>runlevels</foreignphrase> différents.</para>
    <itemizedlist>
      <listitem>
	<para>Le niveau 0 n'est utilisé que de manière transitoire, lors de la phase d'extinction de l'ordinateur. Il contient donc de nombreux scripts « K ».</para>
      </listitem>
      <listitem>
	<para>Le niveau 1, aussi connu sous le nom de <foreignphrase>single-user</foreignphrase>, correspond au système en mode dégradé ; il ne contient que les services de base et est prévu pour les opérations de maintenance en dehors de l'interaction des utilisateurs.</para>
      </listitem>
      <listitem>
	<para>Le niveau 2 est le niveau de fonctionnement normal, qui inclut les services réseau, l'interface graphique, les connexions des utilisateurs, etc.</para>
      </listitem>
      <listitem>
	<para>Le niveau 6 est similaire au niveau 0, à ceci près qu'il est utilisé lors de la phase d'extinction qui précède un redémarrage.</para>
      </listitem>
    </itemizedlist>

    <para>D'autres niveaux existent, notamment de 3 à 5. Ils sont par défaut configurés pour fonctionner de la même manière que le niveau 2, mais l'administrateur peut les modifier (en ajoutant ou supprimant des scripts dans les répertoires <filename>/etc/rc<replaceable>X</replaceable>.d/</filename> correspondants) pour les adapter à un besoin particulier.</para>

    <figure id="figure.boot-process-sysvinit">
      <title>Étapes du démarrage d'un ordinateur sous Linux avec le système d'initialisation System V</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/startup-sysvinit.png" scalefit="1" width="80%" />
        </imageobject>
      </mediaobject>
    </figure>
    <indexterm><primary>script d'initialisation</primary></indexterm>

    <para>Tous les scripts contenus dans les différents répertoires <filename>/etc/rc<replaceable>X</replaceable>.d</filename> ne sont que des liens symboliques, créés à l'installation du paquet concerné par le programme <command>update-rc.d</command>, et menant vers les scripts réels, stockés sous <filename>/etc/init.d/</filename>. Pour adapter à sa guise les services à démarrer ou à stopper à chaque niveau d'exécution, l'administrateur exécutera à nouveau le programme <command>update-rc.d</command> en lui fournissant les paramètres adéquats. La page de manuel <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> en détaille la syntaxe précise. Signalons au passage que supprimer tous les liens symboliques (avec le paramètre <literal>remove</literal>) n'est pas la bonne méthode pour désactiver un service. Il faut simplement le configurer pour ne pas démarrer dans les niveaux d'exécution souhaités (tout en conservant les appels correspondants pour l'arrêter au cas où le service tournait dans le niveau d'exécution précédent). L'utilisation d'<command>update-rc.d</command> étant quelque peu alambiquée, on pourra utiliser <command>rcconf</command> (du paquet <emphasis role="pkg">rcconf</emphasis>) pour se voir présenter une interface plus simple à manipuler.</para>
    <indexterm><primary><command>update-rc.d</command></primary></indexterm>

    <sidebar>
      <title><emphasis>CHARTE DEBIAN</emphasis> Redémarrage des services</title>
      <indexterm><primary><command>invoke-rc.d</command></primary></indexterm>
      <indexterm><primary>service</primary><secondary>redémarrage</secondary></indexterm>
      <indexterm><primary>redémarrage des services</primary></indexterm>

      <para>Les scripts de configuration des paquets Debian redémarrent parfois certains services pour assurer leur disponibilité ou leur faire prendre en compte certaines nouvelles options. La commande de manipulation d'un service <command>service <replaceable>service</replaceable> <replaceable>opération</replaceable></command> ne prend pas en compte le niveau d'exécution, suppose (à tort) que le service est actuellement employé et peut donc effectuer des opérations inadéquates (démarrage d'un service volontairement arrêté, ou arrêt d'un service déjà stoppé, etc.). Debian a donc introduit le programme <command>invoke-rc.d</command>, auquel les scripts de configuration doivent recourir pour appeler les scripts d'initialisation des services. Il n'exécutera que les commandes nécessaires. Attention, contrairement à l'usage, le suffixe <filename>.d</filename> est ici employé sur un nom de programme et non pas sur un répertoire.</para>
    </sidebar>

    <para>Enfin, <command>init</command> démarre les programmes de contrôle des différentes consoles virtuelles (<command>getty</command>). Ils affichent une invite, attendent un nom d'utilisateur, puis exécutent <command>login <replaceable>utilisateur</replaceable></command> pour démarrer une session.</para>
    <indexterm><primary><command>getty</command></primary></indexterm>

    <sidebar>
      <title><emphasis>VOCABULAIRE</emphasis> Console et terminal</title>

      <para>Les premiers ordinateurs étaient habituellement séparés en plusieurs parties, très volumineuses : l'armoire de stockage et l'unité de calcul étaient distinctes des organes de contrôle utilisés par les opérateurs. Ceux-ci constituaient donc un meuble à part, la « console ». Ce terme est resté, mais sa signification a évolué. Il est devenu plus ou moins synonyme de « terminal » : un ensemble constitué d'un clavier et d'un écran.</para>

      <para>Au fil de l'évolution de l'informatique, les systèmes d'exploitation ont proposé plusieurs consoles virtuelles pour offrir plusieurs sessions indépendantes en même temps, même s'il n'existe physiquement qu'un clavier et un écran. La plupart des systèmes GNU/Linux proposent ainsi six consoles virtuelles (en mode texte), accessibles grâce aux combinaisons de touches <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> à <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo>.</para>

      <para>Les termes « console » et « terminal » peuvent aussi, au sens large, désigner un émulateur de terminal dans une session graphique X11 (comme <command>xterm</command>, <command>gnome-terminal</command> ou <command>konsole</command>).</para>
    </sidebar>
</section>
  </section>
  <section id="sect.remote-login">
    <title>Connexion à distance</title>

    <para>Il est essentiel pour un administrateur de pouvoir se connecter à distance sur un ordinateur. Les serveurs, confinés dans leur propre salle, disposent en effet rarement d'un clavier et d'un écran connectés en permanence — mais sont reliés au réseau.</para>

    <sidebar>
      <title><emphasis>B.A.-BA</emphasis> Client, serveur</title>
      <indexterm><primary>client</primary><secondary>architecture client/serveur</secondary></indexterm>
      <indexterm><primary>serveur</primary><secondary>architecture client/serveur</secondary></indexterm>

      <para>Lorsqu'un système comporte plusieurs mécanismes qui communiquent entre eux, on emploie souvent la métaphore client/serveur. Le serveur désigne alors le programme qui attend des requêtes en provenance d'un client, puis les exécute. C'est le client qui dirige les opérations, le serveur ne prenant pas d'initiatives de lui-même.</para>
    </sidebar>

    <indexterm><primary>connexion</primary><secondary>à distance</secondary></indexterm>
    <indexterm><primary>distance, connexion</primary></indexterm>

    <section id="sect.ssh">
      <title>Connexion à distance sécurisée : SSH</title>
      <indexterm><primary>SSH</primary></indexterm>
      <indexterm><primary><foreignphrase>Secured Shell</foreignphrase></primary></indexterm>

      <para>Le protocole <emphasis>SSH</emphasis> (<foreignphrase>Secured Shell</foreignphrase>, ou shell sécurisé) a été conçu dans une optique de sécurité et de fiabilité. Les connexions ainsi mises en place sont sûres : le partenaire est authentifié et tous les échanges sont chiffrés.</para>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> Telnet et RSH sont obsolètes</title>
	<indexterm><primary><command>telnet</command></primary></indexterm>
	<indexterm><primary><command>rsh</command></primary></indexterm>

	<para>Avant l'apparition de SSH, <emphasis>Telnet</emphasis> et <emphasis>RSH</emphasis> étaient les outils les plus largement utilisés pour se connecter à distance.  Ils sont maintenant véritablement obsolètes et ne devraient plus être utilisés (même si Debian continue de les fournir).</para>
      </sidebar>

      <sidebar>
        <title><emphasis>VOCABULAIRE</emphasis> Authentification, chiffrement</title>

	<para>Lorsqu'il s'agit de donner à un client la possibilité d'effectuer ou de déclencher des actions sur un serveur, les implications de sécurité sont importantes. On doit donc s'assurer de l'identité du client ; c'est l'authentification. Cette identité consistant souvent en un mot de passe, il faut bien entendu protéger la confidentialité de ce dernier, faute de quoi n'importe quel autre client pourra le récupérer ; c'est l'objet du chiffrement, qui est une forme de codage permettant à deux systèmes de communiquer des secrets sur un canal public sans qu'ils puissent être interceptés par des tierces parties.</para>

	<para>L'authentification et le chiffrement sont souvent évoqués ensemble, à la fois parce qu'ils interviennent fréquemment conjointement et parce qu'ils sont en général mis en œuvre à l'aide de concepts mathématiques similaires.</para>
      </sidebar>

      <para>SSH offre encore deux services de transfert de fichiers. <command>scp</command> est un utilitaire en ligne de commande qui s'emploie comme <command>cp</command> sauf que tout chemin sur une autre machine sera préfixé du nom de celle-ci suivi du caractère deux-points.</para>

      <screen><computeroutput>$ </computeroutput><userinput>scp fichier machine:/tmp/</userinput>
</screen>

      <para><command>sftp</command> est un programme interactif très similaire à <command>ftp</command>. Ainsi, une même session <command>sftp</command> peut transférer plusieurs fichiers et il est possible d'y manipuler les fichiers distants (supprimer, changer leur nom ou leurs droits, etc.).</para>
      <indexterm><primary><command>scp</command></primary></indexterm>
      <indexterm><primary><command>sftp</command></primary></indexterm>

      <para>Debian emploie OpenSSH, version libre de SSH maintenue par le projet <command>OpenBSD</command> (un système d'exploitation libre basé sur un noyau BSD et qui se focalise sur la sécurité) et <foreignphrase>fork</foreignphrase> du logiciel SSH originel développé par la société finlandaise SSH Communications Security Corp. Celle-ci, qui en avait débuté le développement sous la forme d'un logiciel libre, avait en effet décidé de le poursuivre sous une licence propriétaire. Le projet OpenBSD créa donc OpenSSH pour maintenir une version libre de SSH.</para>
      <indexterm><primary>OpenSSH</primary></indexterm>

      <sidebar>
        <title><emphasis>B.A.-BA</emphasis> Fork</title>
        <indexterm><primary><foreignphrase>fork</foreignphrase></primary></indexterm>

	<para>Le terme <foreignphrase>fork</foreignphrase> (fourche, ou projet dérivé), dans le cadre d'un logiciel, désigne un nouveau projet, concurrent de l'original dont il s'inspire, et qu'il a entièrement copié au début. Ces deux logiciels identiques divergent rapidement sur le plan du développement. C'est souvent un désaccord dans l'équipe qui est à l'origine d'un <foreignphrase>fork</foreignphrase>.</para>

	<para>Cette possibilité provient directement du caractère libre d'un logiciel ; un <foreignphrase>fork</foreignphrase> est sain lorsqu'il permet la poursuite du développement sous forme de logiciel libre (en cas de changement de licence par exemple). Un <foreignphrase>fork</foreignphrase> issu d'un désaccord technique ou relationnel est souvent un gâchis de ressources humaines ; on lui préférera la résolution du différend. Il n'est d'ailleurs pas rare d'assister à la fusion des branches d'un <foreignphrase>fork</foreignphrase> quand elles font ce constat amer.</para>
      </sidebar>

      <para>OpenSSH est séparé en deux paquets. La partie cliente est dans le paquet <emphasis role="pkg">openssh-client</emphasis>, le serveur dans <emphasis role="pkg">openssh-server</emphasis>. Le métapaquet <emphasis role="pkg">ssh</emphasis> dépend des deux parties et facilite leur installation conjointe (<command>apt install ssh</command>).</para>

      <section id="sect.ssh-key-based-auth">
        <title>Authentification par clé</title>

	<para>Chaque fois que l'on se connecte par SSH, le serveur distant demande un mot de passe pour authentifier l'utilisateur. Cela peut être problématique si l'on souhaite automatiser une connexion ou si l'on emploie un outil qui requiert de fréquentes connexions par SSH. C'est pourquoi SSH propose un système d'authentification par clé.</para>

	<para>L'utilisateur génère une biclé sur la machine cliente avec <command>ssh-keygen -t rsa</command> : la clé publique est stockée dans <filename>~/.ssh/id_rsa.pub</filename> tandis que la clé privée correspondante est placée dans <filename>~/.ssh/id_rsa</filename>. L'utilisateur emploie alors <command>ssh-copy-id <replaceable>serveur</replaceable></command> pour ajouter sa clé publique dans le fichier <filename>~/.ssh/authorized_keys</filename> du serveur. Si, lors de sa création, la clé privée n'a pas été protégée par une « phrase de passe » <foreignphrase>(passphrase)</foreignphrase> qui la protège, toutes les connexions au serveur fonctionneront désormais sans mot de passe. Sinon, il faudra à chaque fois déchiffrer la clé privée donc saisir la phrase de passe. Heureusement <command>ssh-agent</command> va nous permettre de garder en mémoire la (ou les) clé(s) privée(s) afin de ne pas devoir régulièrement ressaisir la phrase de protection. Pour cela, il suffit d'invoquer <command>ssh-add</command> (une fois par session de travail) à la condition que la session soit déjà associée à une instance fonctionnelle de <command>ssh-agent</command>. Debian l'active en standard dans les sessions graphiques, mais cela peut se désactiver en modifiant <filename>/etc/X11/Xsession.options</filename>. Pour une session en console, on peut le démarrer manuellement avec <command>eval $(ssh-agent)</command>.</para>

        <sidebar>
          <title><emphasis>SÉCURITÉ</emphasis> Protection de la clé privée</title>

	  <para>Quiconque dispose de la clé privée peut se connecter sur le compte ainsi configuré. C'est pourquoi l'accès à la clé privée est protégé par une « phrase de passe ». Quelqu'un qui récupérerait une copie d'un fichier abritant une clé privée (par exemple <filename>~/.ssh/id_rsa</filename>) devrait encore retrouver cette phrase avant de pouvoir l'utiliser. Cette protection supplémentaire n'est cependant pas inviolable et si l'on pense que ce fichier a été compromis, il vaut mieux désactiver cette clé sur les ordinateurs où elle a été installée (en la retirant des fichiers <filename>authorized_keys</filename>) et la remplacer par une clé nouvellement générée.</para>
        </sidebar>

        <sidebar>
          <title><emphasis>CULTURE</emphasis> Faille OpenSSL de Debian <emphasis role="distribution">Etch</emphasis></title>

	  <para>La bibliothèque OpenSSL telle qu'initialement fournie dans Debian <emphasis role="distribution">Etch</emphasis> souffrait d'un grave problème dans son générateur de nombres aléatoires (RNG, <foreignphrase>Random Number Generator</foreignphrase>). Le mainteneur Debian avait en effet effectué une modification afin que la bibliothèque ne soit pas la source d'avertissements pour des programmes l'utilisant et qui seraient analysés par des outils vérificateurs de mémoire comme <command>valgrind</command>. Malheureusement, ce changement a également eu pour conséquence que le RNG n'employait plus qu'une seule source d'aléas correspondant au numéro du processus (PID) dont le nombre est très restreint (environ 32 000). <ulink type="block" url="http://www.debian.org/security/2008/dsa-1571" /></para>

	  <para>Concrètement, chaque fois que OpenSSL était employé pour générer une clé, il produisait systématiquement une clé comprise dans un ensemble connu de quelques centaines de milliers de clés (32 000, multipliées par un petit nombre de longueurs de clés). Cela affectait les clés SSH, SSL et les certificats X.509 employés par de nombreuses applications comme OpenVPN. Un pirate n'avait plus qu'à essayer toutes les clés pour essayer d'obtenir un accès non autorisé. Pour réduire l'impact du problème, le démon SSH a été modifié pour refuser les clés problématiques qui sont recensées dans les paquets <emphasis role="pkg">openssh-blacklist</emphasis> et <emphasis role="pkg">openssh-blacklist-extra</emphasis>. De plus, le programme <command>ssh-vulnkey</command> permet d'identifier d'éventuelles clés compromises présentes sur le système.</para>

	  <para>Une analyse plus poussée de cet incident permet de se rendre compte que c'est le fruit de multiples (petits) problèmes tant au niveau du projet OpenSSL que du mainteneur du paquet Debian. Une bibliothèque aussi largement employée que OpenSSL devrait — sans modifications — ne pas générer d'avertissements lorsque scrutée par <command>valgrind</command>. En outre, le code (en particulier des parties aussi sensibles que le RNG) mériterait d'être mieux commenté pour éviter de telles erreurs. De son côté, le mainteneur Debian, en voulant faire valider sa modification par les développeurs d'OpenSSL, s'est contenté d'expliquer la modification sans fournir de patch à relire, et a négligé de préciser son rôle au sein de Debian. Enfin, ses choix de maintenance n'étaient pas optimaux : les changements effectués par rapport au logiciel original n'étaient pas clairement documentés ; toutes les modifications étaient certes stockées dans un dépôt Subversion mais elles se retrouvaient agglomérées en un seul patch lors de la création du paquet source.</para>

	  <para>Difficile dans ces conditions de trouver des mesures correctives pour éviter que de tels incidents ne se reproduisent. La leçon retenue est que chaque divergence introduite par Debian par rapport au logiciel amont doit être justifiée, documentée, soumise au projet amont lorsque possible et largement publiée. C'est dans cette optique qu'ont été développés le nouveau format de paquet source ("3.0 (quilt)") et le service web de consultation des sources Debian. <ulink type="block" url="http://sources.debian.net" /></para>
        </sidebar>
      </section>
      <section id="sect.ssh-x11">
        <title>Utiliser des applications X11 à distance</title>

	<para>Le protocole SSH permet de faire suivre <foreignphrase>(forward)</foreignphrase> les données graphiques (dites « X11 », du nom du système graphique le plus répandu sous Unix) : le serveur leur réserve alors un canal de données spécifique. Concrètement, une application graphique exécutée à distance peut s'afficher sur le serveur X.org de l'écran local et toute la session (manipulation comme affichage) sera sécurisée. Cette fonctionnalité donne à une application exécutée à distance de nombreuses possibilités d'interférer sur le système local, elle est donc préventivement désactivée par défaut ; on l'activera en précisant <literal>X11Forwarding yes</literal> dans le fichier de configuration <filename>/etc/ssh/sshd_config</filename> du serveur. L'utilisateur pourra ensuite en profiter en spécifiant l'option <literal>-X</literal> de <command>ssh</command>.</para>
      </section>
      <section id="sect.ssh-port-forwarding">
        <title>Créer des tunnels chiffrés avec le <foreignphrase>port forwarding</foreignphrase></title>
        <indexterm><primary><foreignphrase>port forwarding</foreignphrase></primary></indexterm>

	<para>Ses options <literal>-R</literal> et <literal>-L</literal> permettent à <command>ssh</command> de créer des « tunnels chiffrés » entre deux machines, déportant de manière sécurisée un port TCP (voir l'encadré <xref linkend="sidebar.tcp-udp" />) local vers une machine distante ou vice versa.</para>

        <sidebar>
          <title><emphasis>VOCABULAIRE</emphasis> Tunnel</title>
          <indexterm><primary>SSH</primary><secondary>tunnel SSH</secondary><seealso>VPN</seealso></indexterm>
          <indexterm><primary>tunnel SSH</primary><seealso>VPN</seealso></indexterm>

	  <para>Le réseau Internet et la plupart des réseaux locaux qui y sont raccordés fonctionnent en mode paquet et non en mode connecté, c'est-à-dire qu'un paquet émis depuis un ordinateur en direction d'un autre va s'arrêter sur plusieurs routeurs intermédiaires pour être acheminé jusqu'à sa destination. On peut néanmoins simuler un fonctionnement connecté, selon lequel le flux est encapsulé dans des paquets IP normaux ; ces paquets suivent leur chemin habituel, mais le flux est restitué tel quel à destination. On parle alors de « tunnel », par analogie avec un tunnel routier, dans lequel les véhicules roulent directement de l'entrée à la sortie sans rencontrer de carrefours, par opposition au trajet en surface qui impliquerait des intersections et des changements de direction.</para>

	  <para>On peut profiter de l'opération pour ajouter du chiffrement au tunnel : le flux qui y circule est alors méconnaissable de l'extérieur, mais il est restauré à son état de flux en clair à la sortie du tunnel.</para>
        </sidebar>

	<para><command>ssh -L 8000:serveur:25 intermediaire</command> lance un <command>ssh</command> qui établit une session vers <replaceable>intermediaire</replaceable> tout en écoutant le port 8000 local. Toute connexion établie sur ce port fera débuter par <command>ssh</command> une connexion de l'ordinateur <replaceable>intermediaire</replaceable> vers le port 25 de <replaceable>serveur</replaceable>, à laquelle <command>ssh</command> la reliera.</para>

	<para><command>ssh -R 8000:serveur:25 intermediaire</command> établit également une session SSH vers <replaceable>intermediaire</replaceable>, mais c'est sur cette machine que le processus <command>ssh</command> écoute le port 8000. Toute connexion établie sur ce port fera débuter par <command>ssh</command> une connexion depuis la machine locale vers le port 25 de <replaceable>serveur</replaceable>, à laquelle <command>ssh</command> la reliera.</para>

	<para>Dans les deux cas, il s'agit de créer des connexions vers le port 25 de la machine <replaceable>serveur</replaceable>, qui passent au travers du tunnel SSH établi entre la machine locale et la machine <replaceable>intermediaire</replaceable>. Dans le premier cas, l'entrée du tunnel est le port 8000 local et les données transitent vers <replaceable>intermediaire</replaceable> avant de se diriger vers <replaceable>serveur</replaceable> sur le réseau « public ». Dans le second cas, l'entrée et la sortie du tunnel sont inversées : l'entrée est le port 8000 d'<replaceable>intermediaire</replaceable>, la sortie est locale et les données se dirigent ensuite vers <replaceable>serveur</replaceable> depuis la machine locale. En pratique, dans les cas d'usage les plus courants, le serveur est soit la machine locale, soit l'intermédiaire.</para>

        <figure id="figure.ssh-L">
          <title>Déport d'un port local par SSH</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ssh-L.png" width="35%" />
            </imageobject>
          </mediaobject>
        </figure>

        <figure id="figure.ssh-R">
          <title>Déport d'un port distant par SSH</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ssh-R.png" width="35%" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>
    <section id="sect.remote-desktops">
      <title>Accéder à distance à des bureaux graphiques</title>

      <para>VNC (<foreignphrase>Virtual Network Computing</foreignphrase>, ou informatique en réseau virtuel) permet d'accéder à distance à des bureaux graphiques.</para>
      <indexterm><primary>VNC</primary></indexterm>
      <indexterm><primary><foreignphrase>Virtual Network Computing</foreignphrase></primary></indexterm>
      <indexterm><primary>bureau graphique</primary><secondary>déporté</secondary></indexterm>
      <indexterm><primary>déporté, bureau graphique</primary></indexterm>
      <indexterm><primary>graphique, bureau déporté</primary></indexterm>

      <para>Cet outil sert principalement en assistance technique : l'administrateur peut constater les erreurs de l'utilisateur et lui montrer la bonne manipulation sans devoir se déplacer à ses côtés.</para>
      <indexterm><primary><emphasis role="pkg">vino</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">krfb</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">x11vnc</emphasis></primary></indexterm>

      <para>Il faut tout d'abord que l'utilisateur autorise le partage de sa session. Dans <emphasis role="distribution">Jessie</emphasis>, l'environnement de bureau GNOME inclut cette option dans son panneau de configuration (contrairement aux versions précédentes où il était nécessaire d'installer vino). En ce qui concerne KDE, il faut exécuter <command>krfb</command> pour pouvoir partager le bureau actif via VNC. Pour les autres environnements bureautiques, la commande <command>x11vnc</command> (du paquet Debian éponyme) a le même effet ; on pourra la rendre disponible à l'utilisateur via une icône explicite.</para>

      <indexterm><primary><emphasis role="pkg">vinagre</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">tsclient</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">krdc</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">xvnc4viewer</emphasis></primary></indexterm>

      <para>Lorsque la session graphique est rendue disponible par VNC, l'administrateur doit s'y connecter à l'aide d'un client VNC. GNOME propose pour cela <command>vinagre</command> et <command>remmina</command>, et KDE inclut <command>krdc</command> (dans le menu <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Krdc Connexion à un bureau distant</guimenuitem></menuchoice>). Il existe aussi des clients VNC qui s'invoquent en ligne de commande, comme <command>xvnc4viewer</command>, du paquet Debian éponyme. Une fois connecté, il peut examiner ce qui se passe, voire intervenir et montrer à l'utilisateur comment procéder.</para>

      <sidebar>
        <title><emphasis>SÉCURITÉ</emphasis> VNC sur SSH</title>
        <indexterm><primary>tunnel SSH</primary> <secondary>VNC</secondary></indexterm>

	<para>Si l'on souhaite se connecter par VNC et si on ne veut pas que les données circulent en clair sur le réseau, il est possible de les encapsuler dans un tunnel SSH (voir <xref linkend="sect.ssh-port-forwarding" />). Il faut simplement savoir que VNC emploie par défaut le port 5900 pour le premier écran (appelé « localhost:0 »), 5901 pour le second (appelé « localhost:1 »), etc.</para>

	<para>La commande <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command> crée un tunnel entre le port local 5901 de l'interface <command>localhost</command> et le port 5900 de l'ordinateur <replaceable>machine</replaceable>. Le premier <command>localhost</command> contraint SSH à n'écouter, sur la machine locale, que sur cette interface. Le second <command>localhost</command> désigne l'interface de la machine distante à laquelle SSH communiquera le trafic réseau expédié à <literal>localhost:5901</literal>. Ainsi, <command>vncviewer localhost:1</command> connectera le client VNC à l'écran distant bien que l'on indique le nom de la machine locale.</para>

	<para>Une fois la session VNC terminée, il convient de ne pas oublier de fermer le tunnel en quittant la session SSH ouverte à cette fin.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>B.A.-BA</emphasis> Gestionnaire d'écran</title>
        <indexterm><primary><command>gdm3</command></primary></indexterm>
        <indexterm><primary><command>kdm</command></primary></indexterm>
        <indexterm><primary><command>xdm</command></primary></indexterm>
        <indexterm><primary><command>lightdm</command></primary></indexterm>
        <indexterm><primary>gestionnaire</primary><secondary>d'écran</secondary></indexterm>
        <indexterm><primary>écran, gestionnaire de</primary></indexterm>

	<para><command>gdm3</command>, <command>kdm</command>, <command>lightdm</command> et <command>xdm</command> sont des gestionnaires d'écran <foreignphrase>(Display Manager)</foreignphrase>. Ils prennent le contrôle de l'interface graphique peu après son initialisation afin de proposer à l'utilisateur un écran d'identification. Une fois ce dernier authentifié, il exécute les programmes requis pour démarrer une session de travail graphique.</para>
      </sidebar>

      <para>VNC sert aussi aux utilisateurs nomades, ou responsables d'entreprises, ayant des besoins ponctuels de connexion depuis chez eux, qui retrouvent ainsi à distance un bureau similaire à celui qu'ils ont au travail. La configuration d'un tel service est plus compliquée : il faut d'abord installer le paquet <emphasis role="pkg">vnc4server</emphasis>, modifier la configuration du gestionnaire d'écran pour accepter les requêtes <literal>XDMCP Query</literal> (pour <command>gdm3</command>, cela peut se faire en ajoutant <literal>Enable=true</literal> dans la section « xdmcp » du fichier <filename>/etc/gdm3/daemon.conf</filename>) et enfin démarrer le serveur VNC via <command>inetd</command> pour qu'une session VNC soit démarrée dès qu'un utilisateur essaie de se connecter. On ajoutera par exemple cette ligne dans <filename>/etc/inetd.conf</filename> :</para>

      <programlisting>
5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none
</programlisting>

      <para>Rediriger les connexions entrantes vers un gestionnaire d'écran résout le problème de l'authentification, puisque seuls les utilisateurs disposant de comptes locaux passeront le cap de la connexion via <command>gdm3</command> (ou les équivalents <command>kdm</command>, <command>xdm</command>, etc.). Comme ce fonctionnement permet sans problème plusieurs connexions simultanées (à condition que le serveur soit suffisamment puissant), il peut même être utilisé pour offrir des bureaux complets à différents utilisateurs itinérants (voire à des postes bureautiques peu puissants, configurés en clients légers). Les utilisateurs doivent simplement se connecter au 51<superscript>e</superscript> écran du serveur (<command>vncviewer <replaceable>serveur</replaceable>:50</command>) parce que le port employé est le 5950.</para>
      <indexterm><primary><emphasis role="pkg">vnc4server</emphasis></primary></indexterm>
    </section>
  </section>
  <section id="sect.rights-management">
    <title>Gestion des droits</title>

    <para>Linux est résolument multi-utilisateur ; il est donc nécessaire de prévoir un système de permissions contrôlant les opérations autorisées pour chacun sur les fichiers et répertoires, recouvrant toutes les ressources du système (y compris les périphériques : sur un système Unix, tout périphérique est représenté par un fichier ou répertoire). Ce principe est commun à tous les Unix mais un rappel est toujours utile, d'autant qu'il existe quelques usages avancés méconnus et relativement intéressants.</para>
    <indexterm><primary>droits</primary></indexterm>
    <indexterm><primary>permissions</primary></indexterm>
    <indexterm><primary>utilisateur</primary><secondary>propriétaire</secondary></indexterm>
    <indexterm><primary>groupe</primary><secondary>propriétaire</secondary></indexterm>
    <indexterm><primary>propriétaire</primary><secondary>utilisateur</secondary></indexterm>
    <indexterm><primary>propriétaire</primary><secondary>groupe</secondary></indexterm>

    <para>Chaque fichier ou répertoire dispose de permissions spécifiques pour trois catégories d'utilisateurs :</para>
    <itemizedlist>
      <listitem>
	<para>son propriétaire (symbolisé par <literal>u</literal> comme <foreignphrase>user</foreignphrase>) ;</para>
      </listitem>
      <listitem>
	<para>son groupe propriétaire (symbolisé par <literal>g</literal> comme <foreignphrase>group</foreignphrase>) — représentant tous les utilisateurs membres du groupe ;</para>
      </listitem>
      <listitem>
	<para>les autres (symbolisés par <literal>o</literal> comme <foreignphrase>other</foreignphrase>).</para>
      </listitem>
    </itemizedlist>

    <para>Trois types de droits peuvent s'y combiner :</para>
    <itemizedlist>
      <listitem>
	<para>lecture (symbolisé par <literal>r</literal> comme <foreignphrase>read</foreignphrase>) ;</para>
      </listitem>
      <listitem>
	<para>écriture (ou modification, symbolisé par <literal>w</literal> comme <foreignphrase>write</foreignphrase>) ;</para>
      </listitem>
      <listitem>
	<para>exécution (symbolisé par <literal>x</literal> comme <foreignphrase>eXecute</foreignphrase>).</para>
      </listitem>
    </itemizedlist>
    <indexterm><primary>lecture, droit</primary></indexterm>
    <indexterm><primary>écriture, droit</primary></indexterm>
    <indexterm><primary>modification, droit</primary></indexterm>
    <indexterm><primary>exécution, droit</primary></indexterm>

    <para>Dans le cas d'un fichier, ces droits sont faciles à interpréter : l'accès en lecture permet d'en consulter le contenu (et notamment de le copier), l'accès en écriture de le modifier et l'accès en exécution permet de tenter de l'exécuter (ce qui ne fonctionnera que s'il s'agit d'un programme).</para>

    <sidebar>
      <title><emphasis>SÉCURITÉ</emphasis> Exécutables <literal>setuid</literal> et <literal>setgid</literal></title>

      <para>Deux droits particuliers concernent les fichiers exécutables : le droit <literal>setuid</literal> et le droit <literal>setgid</literal> (symbolisés par la lettre « s »). Remarquons qu'on parle souvent de « bit » car chacune de ces informations booléennes se représente individuellement par un 0 ou un 1. Ces deux droits permettent à n'importe quel utilisateur d'exécuter le programme en question avec respectivement les droits de son propriétaire ou de son groupe propriétaire. Ce mécanisme donne accès à des fonctionnalités requérant des droits plus élevés que ceux dont on dispose habituellement.</para>
      <indexterm><primary><literal>setuid</literal>, droit</primary></indexterm>
      <indexterm><primary><literal>setgid</literal>, droit</primary></indexterm>

      <para>Un programme <literal>setuid</literal> root s'exécutant systématiquement sous l'identité du super-utilisateur, il est très important d'en contrôler la fiabilité. En effet, un utilisateur capable de le détourner pour lui faire appeler une commande de son choix pourrait alors endosser l'identité de root et avoir tous les droits sur le système.</para>
    </sidebar>

    <para>Un répertoire est traité différemment. L'accès en lecture donne le droit de consulter la liste de ses entrées, l'accès en écriture celui d'y créer ou supprimer des fichiers et l'accès en exécution de le traverser (et notamment de s'y rendre avec la commande <command>cd</command>). Pouvoir traverser un répertoire sans le lire donne le droit d'accéder à celles de ses entrées dont on connaît le nom, mais pas de les trouver si on ignore leur existence ou leur nom exact.</para>

    <sidebar id="sidebar.setgid-dir">
      <title><emphasis>SÉCURITÉ</emphasis> Répertoire <literal>setgid</literal> et sticky bit</title>
      <indexterm><primary><literal>setgid</literal>, répertoire</primary></indexterm>

      <para>Le bit <literal>setgid</literal> s'applique également aux répertoires. Toutes les entrées qu'on y créera recevront alors pour groupe propriétaire celui du répertoire, au lieu de prendre comme c'est l'habitude le groupe principal de leur créateur. Cela évitera à celui-ci de changer de groupe principal (par la commande <command>newgrp</command>) lors d'un travail dans une arborescence partagée entre plusieurs utilisateurs d'un même groupe dédié.</para>
      <indexterm><primary><foreignphrase>sticky bit</foreignphrase></primary></indexterm>

      <para>Le bit <literal>sticky</literal> (symbolisé par la lettre « t ») est un droit qui n'est utile que sur les répertoires. Il est notamment employé pour les répertoires temporaires ouverts en écriture à tous (comme <filename>/tmp/</filename>) : il n'autorise la suppression d'un fichier que par son propriétaire ou celui de son répertoire parent. En son absence, tout le monde pourrait supprimer les fichiers d'autrui dans <filename>/tmp/</filename>.</para>
    </sidebar>

    <para>Trois commandes manipulent les permissions associées à un fichier.</para>
    <itemizedlist>
      <listitem>
	<para><command>chown <replaceable>utilisateur</replaceable> <replaceable>fichier</replaceable></command> affecte un nouveau propriétaire à un fichier.</para>
      </listitem>
      <listitem>
	<para><command>chgrp <replaceable>groupe</replaceable> <replaceable>fichier</replaceable></command> opère sur son groupe propriétaire.</para>
      </listitem>
      <listitem>
	<para><command>chmod <replaceable>droits</replaceable> <replaceable>fichier</replaceable></command> intervient sur ses droits.</para>
      </listitem>
    </itemizedlist>

    <para>Il existe deux manières de présenter les droits ; parmi elles, la représentation symbolique, sans doute la plus simple à comprendre et mémoriser, met en jeu les lettres symboles déjà citées. Pour chaque catégorie d'utilisateurs (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), on peut définir les droits (<literal>=</literal>), en ajouter (<literal>+</literal>), ou en retrancher (<literal>-</literal>). Ainsi, la formule <literal>u=rwx,g+rw,o-r</literal> donne au propriétaire les droits de lecture, d'écriture et d'exécution ; ajoute au groupe propriétaire les droits de lecture et d'écriture ; et supprime le droit de lecture aux autres utilisateurs. Les droits non concernés par les opérations d'ajout ou de retranchement restent inchangés. La lettre <literal>a</literal>, pour <foreignphrase>all</foreignphrase>, recouvre les trois catégories d'utilisateurs, de sorte que <literal>a=rx</literal> donne aux trois catégories les mêmes droits (lecture et exécution, mais pas écriture).</para>
    <indexterm><primary><command>chmod</command></primary></indexterm>
    <indexterm><primary><command>chown</command></primary></indexterm>
    <indexterm><primary><command>chgrp</command></primary></indexterm>
    <indexterm><primary>octale, représentation des droits</primary></indexterm>
    <indexterm><primary>droits</primary><secondary>représentation octale</secondary></indexterm>

    <para>La représentation numérique octale associe chaque droit à une valeur : 4 pour la lecture, 2 pour l'écriture et 1 pour l'exécution. On associe à chaque combinaison de droits la somme de ces chiffres, valeurs qu'on attribue ensuite aux différentes catégories d'utilisateurs en les mettant bout à bout dans l'ordre habituel (propriétaire, groupe, autres).</para>

    <para>La commande <command>chmod 754 <replaceable>fichier</replaceable></command> mettra donc en place les droits suivants : lecture, écriture et exécution au propriétaire (car 7 = 4 + 2 + 1) ; lecture et exécution au groupe (car 5 = 4 + 1) ; lecture seule aux autres. Le chiffre <literal>0</literal> correspond à l'absence de droits, ainsi <command>chmod 600 <replaceable>fichier</replaceable></command> ne donne que les droits de lecture/écriture au propriétaire, les autres ne pouvant rien faire du tout. Les droits les plus fréquents sont <literal>755</literal> pour les exécutables ou les répertoires et <literal>644</literal> pour les fichiers de données.</para>

    <para>Pour représenter le cas échéant les droits spéciaux, on pourra préfixer à ce nombre un quatrième chiffre selon le même principe, sachant que les bits <literal>setuid</literal>, <literal>setgid</literal> et <literal>sticky</literal> valent respectivement 4, 2 et 1. <command>chmod 4754</command> associera donc le bit <literal>setuid</literal> aux droits décrits précédemment.</para>

    <para>On notera que l'utilisation de la notation numérique octale ne permet que de modifier en bloc l'ensemble des droits sur un fichier ; on ne peut pas l'utiliser pour se contenter d'ajouter par exemple le droit en lecture pour le groupe propriétaire, puisqu'il faut obligatoirement prendre en compte les droits existants et calculer la nouvelle valeur numérique correspondante.</para>

    <sidebar>
      <title><emphasis>ASTUCE</emphasis> Application récursive</title>

      <para>Il arrive que l'on doive changer les permissions de toute une arborescence. Toutes les commandes décrites disposent donc d'une option <literal>-R</literal>, effectuant l'opération demandée de manière récursive.</para>

      <para>La distinction entre répertoires et fichiers pose souvent problème lors des opérations récursives. C'est la raison de l'introduction de la lettre « X » dans la représentation symbolique des droits. Elle représente un droit d'exécution qui ne concerne que les répertoires (mais pas les fichiers ne disposant pas encore de ce droit). Ainsi, <command>chmod -R a+X <replaceable>répertoire</replaceable></command> n'ajoutera les droits d'exécution pour toutes les catégories d'utilisateurs (<literal>a</literal>) qu'à tous les sous-répertoires et aux fichiers sur lesquels au moins une catégorie d'utilisateurs (ne serait-ce que leur seul propriétaire) a déjà les droits d'exécution.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ASTUCE</emphasis> Changer l'utilisateur et le groupe</title>

      <para>On souhaite souvent changer le groupe d'un fichier en même temps qu'on change celui-ci de propriétaire. La commande <command>chown</command> propose donc une syntaxe spéciale pour cela : <command>chown <replaceable>utilisateur</replaceable>:<replaceable>groupe</replaceable> <replaceable>fichier</replaceable></command></para>
    </sidebar>

    <sidebar>
      <title><emphasis>POUR ALLER PLUS LOIN</emphasis> <command>umask</command></title>

      <para>Lorsqu'une application crée un fichier, elle lui donne des permissions indicatives, sachant que le système retire automatiquement certains droits, donnés par la commande <command>umask</command>. Saisissez <command>umask</command> dans un shell ; vous observerez un masque tel que <computeroutput>0022</computeroutput>. Ce n'est qu'une représentation octale des droits à retirer systématiquement (en l'occurrence, les droits en écriture pour le groupe et les autres utilisateurs).</para>
      <indexterm><primary><foreignphrase>umask</foreignphrase></primary></indexterm>
      <indexterm><primary>droits</primary><secondary>masque</secondary></indexterm>
      <indexterm><primary>masque</primary><secondary>de droits</secondary></indexterm>

      <para>Si on lui passe une nouvelle valeur octale, la commande <command>umask</command> permet également de changer de masque. Employée dans un fichier d'initialisation de l'interpréteur de commandes (par exemple <filename>~/.bash_profile</filename>), elle aura pour effet de changer le masque par défaut de vos sessions de travail.</para>
    </sidebar>
  </section>
  <section id="sect.administration-interfaces">
    <title>Interfaces d'administration</title>
    <indexterm><primary>interface</primary><secondary>d'administration</secondary></indexterm>
    <indexterm><primary>administration, interfaces</primary></indexterm>

    <para>Recourir à une interface graphique d'administration est intéressant dans différentes circonstances. Un administrateur ne connaît pas nécessairement tous les détails de configuration de tous ses services et n'a pas forcément le temps de se documenter à leur sujet. Une interface graphique d'administration accélérera donc le déploiement d'un nouveau service. Par ailleurs, elle pourra simplifier la mise en place des réglages des services les plus pénibles à configurer.</para>

    <para>Une telle interface n'est qu'une aide, pas une fin en soi. Dans tous les cas, l'administrateur devra maîtriser son comportement pour comprendre et contourner tout problème éventuel.</para>

    <para>Aucune interface n'étant parfaite, on est par ailleurs tenté de recourir à plusieurs solutions. C'est à éviter dans la mesure du possible, car les différents outils sont parfois incompatibles de par leurs hypothèses de travail. Même si tous visent une grande souplesse et tentent d'adopter comme unique référence le fichier de configuration, ils ne sont pas toujours capables d'intégrer des modifications externes.</para>
    <section id="sect.webmin">
      <title>Administrer sur interface web : <command>webmin</command></title>
      <indexterm><primary><emphasis>webmin</emphasis></primary></indexterm>

      <para>C'est sans doute l'une des interfaces d'administration les plus abouties. Il s'agit d'un système modulaire fonctionnant dans un navigateur web, couvrant une vaste palette de domaines et d'outils. Par ailleurs, il est internationalisé et relativement bien traduit en français.</para>

      <para>Malheureusement, <command>webmin</command> ne fait plus partie de Debian. Le responsable des paquets <emphasis role="pkg">webmin</emphasis> et assimilés (ainsi d'ailleurs que des paquets <emphasis role="pkg">usermin</emphasis>), Jaldhar H. Vyas, a en effet demandé leur suppression, faute de temps pour les maintenir à un niveau de qualité acceptable. Personne n'ayant officiellement pris le relais, <emphasis role="distribution">Jessie</emphasis> ne dispose donc pas de paquets de <command>webmin</command>.</para>

      <para>Il existe toutefois un paquet non officiel, distribué sur le site <literal>webmin.com</literal>. Contrairement aux paquets initialement présents dans Debian, ce dernier est monolithique : tous les modules de configuration sont installés et activés par défaut même si le service correspondant n'est pas installé sur la machine.</para>

      <sidebar>
        <title><emphasis>SÉCURITÉ</emphasis> Mot de passe root</title>

	<para>À la première connexion, l'identification s'effectue avec l'identifiant root et son mot de passe habituel. Il est cependant recommandé de changer dès que possible le mot de passe employé pour <command>webmin</command> ; ainsi, une compromission de celui-ci n'impliquera pas le mot de passe de root, même si elle confère des droits administratifs importants sur la machine.</para>

	<para>Attention ! <command>webmin</command> étant fonctionnellement très riche, un utilisateur malveillant y accédant pourra vraisemblablement compromettre la sécurité de tout le système. D'une manière générale, les interfaces de ce type sont déconseillées sur les systèmes importants, aux contraintes de sécurité élevées (pare-feu, serveurs sensibles, etc.).</para>
      </sidebar>

      <para>Webmin s'emploie par le biais d'une interface web mais il ne nécessite pas pour autant d'avoir Apache installé : en effet, ce logiciel dispose d'un mini-serveur web dédié. Ce dernier écoute par défaut sur le port 10 000 et accepte les connexions HTTP sécurisées.</para>

      <para>Les modules intégrés couvrent une large palette de services, citons notamment :</para>
      <itemizedlist>
        <listitem>
	  <para>tous les services de base : créer des utilisateurs et des groupes, gérer les fichiers <filename>crontab</filename>, les scripts d'initialisation, consulter les logs, etc.</para>
        </listitem>
        <listitem>
	  <para>bind : configuration du serveur DNS (service de noms) ;</para>
        </listitem>
        <listitem>
	  <para>postfix : configuration du serveur SMTP (courrier électronique) ;</para>
        </listitem>
        <listitem>
	  <para>inetd : configuration du super-serveur <command>inetd</command> ;</para>
        </listitem>
        <listitem>
	  <para>quota : gestion des quotas utilisateur ;</para>
        </listitem>
        <listitem>
	  <para>dhcpd : configuration du serveur DHCP ;</para>
        </listitem>
        <listitem>
	  <para>proftpd : configuration du serveur FTP ;</para>
        </listitem>
        <listitem>
	  <para>samba : configuration du serveur de fichiers Samba ;</para>
        </listitem>
        <listitem>
	  <para>software : installation ou suppression de logiciels à partir des paquets Debian et mise à jour du système.</para>
        </listitem>
      </itemizedlist>

      <para>L'interface d'administration est accessible depuis un navigateur web à l'adresse <literal>https://localhost:10000</literal>. Attention ! tous les modules ne sont pas directement exploitables ; il faut parfois les configurer en précisant les emplacements du fichier de configuration concerné et de quelques exécutables. Souvent, le système vous y invite poliment lorsqu'il n'arrive pas à faire fonctionner le module demandé.</para>

      <sidebar>
        <title><emphasis>ALTERNATIVE</emphasis> Le panneau de contrôle de GNOME</title>
        <indexterm><primary><emphasis role="pkg">gnome-control-center</emphasis></primary></indexterm>

	<para>Le projet GNOME fournit également plusieurs interfaces d'administration, généralement accessibles via l'entrée « Paramètres système » du menu utilisateur en haut à droite de l'écran. <command>gnome-control-center</command> est l'outil principal qui les rassemble, mais beaucoup des outils de configuration du système lui-même sont en réalité fournis par d'autres paquets (<emphasis role="pkg">accountsservice</emphasis>, <emphasis role="pkg">system-config-printer</emphasis>, etc.). Même si ces applications sont faciles d'usage, elles ne couvrent qu'une petite partie des services de base : gestion des utilisateurs, configuration de l'horloge, du réseau, des imprimantes, etc.</para>
      </sidebar>
    </section>
    <section id="sect.debconf">
      <title>Configuration des paquets : <command>debconf</command></title>
      <indexterm><primary><command>debconf</command></primary></indexterm>
      <indexterm><primary><command>dpkg-reconfigure</command></primary></indexterm>

      <para>De nombreux paquets s'autoconfigurent après avoir demandé quelques éléments durant l'installation, questions posées à travers l'outil Debconf. On peut reconfigurer ces paquets en exécutant <command>dpkg-reconfigure <replaceable>paquet</replaceable></command>.</para>

      <para>Dans la plupart des cas, ces réglages sont très simples : seules quelques variables importantes du fichier de configuration sont modifiées. Ces variables sont parfois regroupées entre deux lignes « démarcatrices » de sorte qu'une reconfiguration du paquet limite sa portée sur la zone qu'elles délimitent. Dans d'autres cas, une reconfiguration ne changera rien si le script détecte une modification manuelle du fichier de configuration, l'objectif étant bien évidemment de préserver ces interventions humaines (le script se considère alors incapable d'assurer que ses propres modifications ne perturberont pas l'existant).</para>

      <sidebar>
        <title><emphasis>CHARTE DEBIAN</emphasis> Préserver les modifications</title>

	<para>La charte Debian demandant expressément de tout faire pour préserver au maximum les changements manuels apportés aux fichiers de configuration, de plus en plus de scripts modifiant ces derniers prennent des précautions. Le principe général est simple : le script n'effectue des modifications que s'il connaît l'état du fichier de configuration, vérification effectuée par comparaison de la somme de contrôle du fichier avec celle du dernier fichier produit automatiquement. Si elles correspondent, le script s'autorise à modifier le fichier de configuration. Dans le cas contraire, il considère qu'on y est intervenu et demande quelle action il doit effectuer (installer le nouveau fichier, conserver l'ancien, ou tenter d'intégrer les nouvelles modifications au fichier existant). Ce principe de précaution fut longtemps propre à Debian, mais les autres distributions l'embrassent peu à peu.</para>

	<para>Le programme <command>ucf</command> (du paquet Debian éponyme) offre des facilités pour gérer cela.</para>
        <indexterm><primary><command>ucf</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.syslog">
    <title>Les événements système de <command>syslog</command></title>
    <indexterm><primary><command>rsyslogd</command></primary></indexterm>
    <indexterm><primary>fichier</primary><secondary>de logs</secondary></indexterm>
    <indexterm><primary>logs</primary><secondary>répartition</secondary></indexterm>
    <section id="sect.syslog-principe">
      <title>Principe et fonctionnement</title>

      <para>Le démon <command>rsyslogd</command> a pour charge de collecter les messages de service provenant des applications et du noyau puis de les répartir dans des fichiers de logs (habituellement stockés dans le répertoire <filename>/var/log/</filename>). Il obéit au fichier de configuration <filename>/etc/rsyslog.conf</filename>.</para>

      <para>Chaque message de log est associé à un sous-système applicatif (nommé <foreignphrase>facility</foreignphrase> dans la documentation) :</para>
      <itemizedlist>
        <listitem>
	  <para><literal>auth</literal> et <literal>authpriv</literal> : concernent l'authentification ;</para>
        </listitem>
        <listitem>
	  <para><literal>cron</literal> : provient des services de planification de tâches, <command>cron</command> et <command>atd</command> ;</para>
        </listitem>
        <listitem>
	  <para><literal>daemon</literal> : concerne un démon sans classification particulière (serveur DNS, NTP, etc.) ;</para>
        </listitem>
        <listitem>
	  <para><literal>ftp</literal> : concerne le serveur FTP ;</para>
        </listitem>
        <listitem>
	  <para><literal>kern</literal> : message provenant du noyau ;</para>
        </listitem>
        <listitem>
	  <para><literal>lpr</literal> : provient du sous-système d'impression ;</para>
        </listitem>
        <listitem>
	  <para><literal>mail</literal> : provient de la messagerie électronique ;</para>
        </listitem>
        <listitem>
	  <para><literal>news</literal> : message du sous-système Usenet (notamment du serveur NNTP — <foreignphrase>Network News Transfer Protocol</foreignphrase>, ou protocole de transfert des nouvelles sur le réseau — gérant les forums de discussion) ;</para>
        </listitem>
        <listitem>
	  <para><literal>syslog</literal> : message du serveur <command>syslogd</command> lui-même ;</para>
        </listitem>
        <listitem>
	  <para><literal>user</literal> : messages utilisateur (générique) ;</para>
        </listitem>
        <listitem>
	  <para><literal>uucp</literal> : messages du sous-système UUCP (<foreignphrase>Unix to Unix Copy Program</foreignphrase>, ou programme de copie d'Unix à Unix, un vieux protocole employé pour faire circuler entre autres des messages électroniques) ;</para>
        </listitem>
        <listitem>
	  <para><literal>local0</literal> à <literal>local7</literal> : réservés pour les utilisations locales.</para>
        </listitem>
      </itemizedlist>

      <para>À chaque message est également associé un niveau de priorité. En voici la liste par ordre décroissant :</para>
      <itemizedlist>
        <listitem>
	  <para><literal>emerg</literal> : « Au secours ! » le système est probablement inutilisable ;</para>
        </listitem>
        <listitem>
	  <para><literal>alert</literal> : vite, il y a péril en la demeure, des actions doivent être entreprises immédiatement ;</para>
        </listitem>
        <listitem>
	  <para><literal>crit</literal> : les conditions sont critiques ;</para>
        </listitem>
        <listitem>
	  <para><literal>err</literal> : erreur ;</para>
        </listitem>
        <listitem>
	  <para><literal>warn</literal> : avertissement (erreur potentielle) ;</para>
        </listitem>
        <listitem>
	  <para><literal>notice</literal> : condition normale mais message significatif ;</para>
        </listitem>
        <listitem>
	  <para><literal>info</literal> : message informatif ;</para>
        </listitem>
        <listitem>
	  <para><literal>debug</literal> : message de débogage.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="sect.syslog-config">
      <title>Le fichier de configuration</title>

      <para>La syntaxe complexe du fichier <filename>/etc/rsyslog.conf</filename> est détaillée dans la page de manuel <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> mais aussi dans la documentation HTML disponible dans le paquet <emphasis role="pkg">rsyslog-doc</emphasis> (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). Le principe global est d'écrire des paires « sélecteur » et « action ». Le sélecteur définit l'ensemble des messages concernés et l'action décrit comment le traiter.</para>
      <section id="sect.syslog-selector-syntax">
        <title>Syntaxe du sélecteur</title>

	<para>Le sélecteur est une liste (ayant pour séparateur le point-virgule) de couples <literal><replaceable>sous-système</replaceable></literal>.<literal><replaceable>priorité</replaceable></literal> (exemple : <literal>auth.notice;mail.info</literal>). L'astérisque peut y représenter tous les sous-systèmes ou toutes les priorités (exemples : <literal>*.alert</literal> ou <literal>mail.*</literal>). On peut regrouper plusieurs sous-systèmes en les séparant par une virgule (exemple : <literal>auth,mail.info</literal>). La priorité indiquée recouvre aussi les messages de priorité supérieure ou égale : <literal>auth.alert</literal> désigne donc les messages du sous-système <literal>auth</literal> de priorités <literal>alert</literal> ou <literal>emerg</literal>. Préfixée par un point d'exclamation, elle désignera au contraire les priorités strictement inférieures : <literal>auth.!notice</literal> désignera donc les messages issus de <literal>auth</literal> et de priorité <literal>info</literal> ou <literal>debug</literal>. Préfixée par un signe égal, elle correspondra exactement à la seule priorité indiquée (<literal>auth.=notice</literal> ne concernera donc que les messages de <literal>auth</literal> de priorité <literal>notice</literal>).</para>

	<para>Au sein du sélecteur, chaque élément de la liste surcharge les éléments précédents. Il est donc possible de restreindre un ensemble ou d'en exclure certains éléments. À titre d'exemple, <literal>kern.info;kern.!err</literal> définit les messages du noyau de priorité comprise entre <literal>info</literal> et <literal>warn</literal>. La priorité <literal>none</literal> désigne l'ensemble vide (aucune des priorités) et peut servir pour exclure un sous-système d'un ensemble de messages. Ainsi, <literal>*.crit;kern.none</literal> désigne tous les messages de priorité supérieure ou égale à <literal>crit</literal> ne provenant pas du noyau.</para>
      </section>
      <section id="sect.syslog-action-syntax">
        <title>Syntaxe des actions</title>

        <sidebar>
          <title><emphasis>B.A.-BA</emphasis> Le tube nommé, un tube persistant</title>
          <indexterm><primary>tube nommé</primary></indexterm>
          <indexterm><primary>nommé, tube</primary></indexterm>

	  <para>Un tube nommé est un type particulier de fichier fonctionnant comme un tube traditionnel (le <foreignphrase>pipe</foreignphrase> que l'on crée à l'aide du symbole « | » sur la ligne de commande), mais par l'intermédiaire d'un fichier. Ce mécanisme a l'avantage de pouvoir mettre en relation deux processus n'ayant aucun rapport de parenté. Toute écriture dans un tube nommé bloque le processus qui écrit jusqu'à ce qu'un autre processus tente d'y lire des données. Ce dernier lira alors les données écrites par l'autre partie, qui pourra donc reprendre son exécution.</para>

	  <para>Un tel fichier se crée avec la commande <command>mkfifo</command>.</para>
        </sidebar>

	<para>Les différentes actions possibles sont :</para>
        <itemizedlist>
          <listitem>
	    <para>ajouter le message à un fichier (exemple : <filename>/var/log/messages</filename>) ;</para>
          </listitem>
          <listitem>
	    <para>envoyer le message à un serveur <command>syslog</command> distant (exemple : <literal>@log.falcot.com</literal>) ;</para>
          </listitem>
          <listitem>
	    <para>envoyer le message dans un tube nommé préexistant (exemple : <literal>|/dev/xconsole</literal>) ;</para>
          </listitem>
          <listitem>
	    <para>envoyer le message à un ou plusieurs utilisateurs s'ils sont connectés (exemple : <literal>root,rhertzog</literal>) ;</para>
          </listitem>
          <listitem>
	    <para>envoyer le message à tous les utilisateurs connectés (exemple : <literal>*</literal>) ;</para>
          </listitem>
          <listitem>
	    <para>écrire le message sur une console texte (exemple : <literal>/dev/tty8</literal>).</para>
          </listitem>
        </itemizedlist>

        <sidebar>
          <title><emphasis>SÉCURITÉ</emphasis> Déporter les logs</title>
          <indexterm><primary><foreignphrase>log</foreignphrase></primary> <secondary>déporté</secondary></indexterm>

	  <para>C'est une bonne idée que d'enregistrer les logs les plus importants sur une machine séparée (voire dédiée), car cela empêchera un éventuel intrus de supprimer les traces de son passage (sauf à compromettre également cet autre serveur). Par ailleurs, en cas de problème majeur (tel qu'un plantage du noyau), disposer de logs sur une autre machine augmente les chances de retrouver le déroulement des événements.</para>

	  <para>Pour accepter les messages de log envoyés par d'autres machines, il faut reconfigurer <emphasis>rsyslog</emphasis> : dans la pratique il suffit d'activer des directives prêtes à l'emploi qui sont déjà présentes dans <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> et <literal>$UDPServerRun 514</literal>).</para>
        </sidebar>
      </section>
    </section>
  </section>
  <section id="sect.inetd">
    <title>Le super-serveur <command>inetd</command></title>

    <para><command>inetd</command> (souvent appelé « super-serveur Internet ») est en réalité un serveur de serveurs, employé pour invoquer à la demande les serveurs rarement employés qui ne fonctionnent donc pas en permanence.</para>
    <indexterm><primary><command>inetd</command></primary></indexterm>
    <indexterm><primary>super-serveur</primary></indexterm>

    <para>Le fichier <filename>/etc/inetd.conf</filename> donne la liste de ces serveurs et de leurs ports habituels, qu'<command>inetd</command> écoute tous ; dès qu'il détecte une connexion sur l'un d'entre eux, il exécute le programme du serveur correspondant.</para>

    <sidebar>
      <title><emphasis>CHARTE DEBIAN</emphasis> Enregistrer un service dans <filename>inetd.conf</filename></title>

      <para>Les paquets souhaiteraient parfois enregistrer un nouveau serveur dans le fichier <filename>/etc/inetd.conf</filename>, mais la charte Debian interdit à tout paquet de modifier un fichier de configuration qui ne relève pas de lui. C'est pourquoi le script <command>update-inetd</command> (du paquet éponyme) a été créé : il a à sa charge le fichier de configuration et les autres paquets peuvent ainsi l'employer pour demander au super-serveur de prendre en compte un nouveau serveur.</para>
    </sidebar>

    <para>Chaque ligne significative du fichier <filename>/etc/inetd.conf</filename> décrit un service par sept champs (séparés par des blancs).</para>
    <itemizedlist>
      <listitem>
	<para>Le numéro du port TCP ou UDP, ou le nom du service (qui est associé à un numéro de port standard par la table de correspondance définie dans le fichier <filename>/etc/services</filename>).</para>
      </listitem>
      <listitem>
	<para>Le type de <foreignphrase>socket</foreignphrase> : <literal>stream</literal> pour une connexion TCP, <literal>dgram</literal> pour des datagrammes UDP ;</para>
      </listitem>
      <listitem>
	<para>Le protocole : <literal>tcp</literal> ou <literal>udp</literal>.</para>
      </listitem>
      <listitem>
	<para>Les options : deux valeurs sont possibles : <literal>wait</literal> ou <literal>nowait</literal>, pour signifier à <command>inetd</command> qu'il doit, ou non, attendre la fin du processus lancé avant d'accepter une autre connexion. Pour les connexions TCP, facilement multiplexables, on pourra généralement utiliser <literal>nowait</literal>. Pour les programmes répondant sur UDP, il ne faut retenir <literal>nowait</literal> que si le serveur est capable de gérer plusieurs connexions en parallèle. On pourra suffixer ce champ d'un point suivi du nombre maximum de connexions autorisées par minute (la limite par défaut étant de 256).</para>
      </listitem>
      <listitem>
	<para>L'identifiant de l'utilisateur sous l'identité duquel le serveur sera exécuté.</para>
      </listitem>
      <listitem>
	<para>Le chemin complet du programme serveur à exécuter.</para>
      </listitem>
      <listitem>
	<para>Les arguments : il s'agit de la liste complète des arguments du programme, y compris son propre nom (<literal>argv[0]</literal> en C).</para>
      </listitem>
    </itemizedlist>

    <para>L'exemple suivant illustre les cas les plus courants.</para>

    <example id="example.inetd-conf">
      <title>Extrait de <filename>/etc/inetd.conf</filename></title>

      <programlisting>talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd
finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd
ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i
</programlisting>
    </example>
    <indexterm><primary><command>tcpd</command></primary></indexterm>

    <para>Le programme <command>tcpd</command> est souvent employé dans le fichier <filename>/etc/inetd.conf</filename>. Il permet de restreindre les connexions entrantes en appliquant des règles de contrôle, documentées dans la page de manuel <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry> et qui se configurent dans les fichiers <filename>/etc/hosts.allow</filename> et <filename>/etc/hosts.deny</filename>. Une fois qu'il a été déterminé que la connexion est autorisée, <command>tcpd</command> exécute à son tour le serveur réellement demandé (comme <command>in.fingerd</command> dans notre exemple).</para>

    <sidebar>
      <title><emphasis>COMMUNAUTÉ</emphasis> Wietse Venema</title>
      <indexterm><primary>Wietse Venema</primary></indexterm>
      <indexterm><primary>Venema, Wietse</primary></indexterm>

      <para>Wietse Venema, dont les compétences en matière de sécurité en font un programmeur réputé, est l'auteur du programme <command>tcpd</command>. C'est également l'auteur principal de Postfix, serveur de messagerie électronique (SMTP — <foreignphrase>Simple Mail Transfer Protocol</foreignphrase>, ou protocole simple de courrier électronique) modulaire conçu pour être plus sûr et plus fiable que <command>sendmail</command>, au long historique de failles de sécurité.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> Autres <command>inetd</command></title>

      <para>Bien que Debian installe <emphasis role="pkg">openbsd-inetd</emphasis> par défaut, les alternatives ne manquent pas. Outre celles déjà mentionnées, il existe <emphasis role="pkg">inetutils-inetd</emphasis>, <emphasis role="pkg">micro-inetd</emphasis>, <emphasis role="pkg">rlinetd</emphasis> et <emphasis role="pkg">xinetd</emphasis>.</para>

      <para>Cette dernière incarnation d'un super-serveur offre des possibilités intéressantes. Elle permet notamment de séparer la configuration dans plusieurs fichiers (stockés, bien entendu, dans le répertoire <filename>/etc/xinetd.d/</filename>), ce qui peut faciliter la vie des administrateurs.</para>

      <para>Enfin, il est également possible d'émuler le comportement d'<command>inetd</command> avec le mécanisme d'activation de socket de <command>systemd</command> (voir <xref linkend="sect.systemd" />).</para>
    </sidebar>
  </section>
  <section id="sect.task-scheduling-cron-atd">
    <title>Planification de tâches : <command>cron</command> et <command>atd</command></title>
    <indexterm><primary><command>cron</command></primary></indexterm>
    <indexterm><primary><command>atd</command></primary></indexterm>
    <indexterm><primary>commandes planifiées</primary></indexterm>
    <indexterm><primary>planification de commandes</primary></indexterm>

    <para><command>cron</command> est le démon en charge d'exécuter des commandes planifiées et récurrentes (chaque jour, chaque semaine, etc.) ; <command>atd</command> est celui qui s'occupe des commandes à exécuter une seule fois, à un instant précis et futur.</para>

    <para>Dans un système Unix, de nombreuses tâches sont régulièrement planifiées :</para>
    <itemizedlist>
      <listitem>
	<para>la rotation des logs ;</para>
      </listitem>
      <listitem>
	<para>la mise à jour de la base de données du programme <command>locate</command> ;</para>
      </listitem>
      <listitem>
	<para>les sauvegardes ;</para>
      </listitem>
      <listitem>
	<para>des scripts d'entretien (comme le nettoyage des fichiers temporaires).</para>
      </listitem>
    </itemizedlist>

    <para>Par défaut, tous les utilisateurs peuvent planifier l'exécution de tâches. C'est pourquoi chacun dispose de sa propre <emphasis>crontab</emphasis>, où il peut consigner les commandes à planifier. Il peut la modifier en exécutant <command>crontab -e</command> (ses informations sont stockées dans le fichier <filename>/var/spool/cron/crontabs/<replaceable>utilisateur</replaceable></filename>).</para>

    <sidebar>
      <title><emphasis>SÉCURITÉ</emphasis> Restreindre <command>cron</command> ou <command>atd</command></title>

      <para>On peut restreindre l'accès à <command>cron</command> en créant le fichier d'autorisation explicite <filename>/etc/cron.allow</filename>, où l'on consignera les seuls utilisateurs autorisés à planifier des commandes. Tous les autres seront automatiquement dépourvus de cette fonctionnalité. Inversement, pour n'en priver qu'un ou deux trouble-fête, on écrira leur nom dans le fichier d'interdiction explicite <filename>/etc/cron.deny</filename>. Le même mécanisme encadre <command>atd</command>, avec les fichiers <filename>/etc/at.allow</filename> et <filename>/etc/at.deny</filename>.</para>
    </sidebar>

    <para>L'utilisateur root dispose de sa <emphasis>crontab</emphasis> personnelle, mais peut également employer le fichier <filename>/etc/crontab</filename> ou déposer des <emphasis>crontab</emphasis> supplémentaires dans le répertoire <filename>/etc/cron.d/</filename>. Ces deux dernières solutions ont l'avantage de pouvoir préciser l'utilisateur sous l'identité duquel exécuter la commande.</para>

    <para>Le paquet <emphasis>cron</emphasis> propose par défaut des commandes planifiées qui exécutent :</para>
    <itemizedlist>
      <listitem>
	<para>une fois par heure les programmes du répertoire <filename>/etc/cron.hourly/</filename> ;</para>
      </listitem>
      <listitem>
	<para>une fois par jour les programmes du répertoire <filename>/etc/cron.daily/</filename> ;</para>
      </listitem>
      <listitem>
	<para>une fois par semaine les programmes du répertoire <filename>/etc/cron.weekly/</filename> ;</para>
      </listitem>
      <listitem>
	<para>une fois par mois les programmes du répertoire <filename>/etc/cron.monthly/</filename>.</para>
      </listitem>
    </itemizedlist>

    <para>De nombreux paquets Debian profitent de ce service : en déposant dans ces répertoires des scripts de maintenance, ils assurent le fonctionnement optimal de leur service.</para>
    <section id="sect.format-crontab">
      <title>Format d'un fichier <filename>crontab</filename></title>
      <indexterm><primary><filename>crontab</filename></primary></indexterm>

      <sidebar>
        <title><emphasis>ASTUCE</emphasis> Raccourcis textuels pour <command>cron</command></title>

	<para>Des abréviations, qui remplacent les cinq premiers champs d'une entrée de <filename>crontab</filename>, décrivent les planifications les plus classiques. Les voici :</para>
        <itemizedlist>
          <listitem>
	    <para><literal>@yearly</literal> : une fois par an (le premier janvier à 0 h 00) ;</para>
          </listitem>
          <listitem>
	    <para><literal>@monthly</literal> : une fois par mois (le premier du mois à 0 h 00) ;</para>
          </listitem>
          <listitem>
	    <para><literal>@weekly</literal> : une fois par semaine (le dimanche à 0 h 00) ;</para>
          </listitem>
          <listitem>
	    <para><literal>@daily</literal> : une fois par jour (à 0 h 00) ;</para>
          </listitem>
          <listitem>
	    <para><literal>@hourly</literal> : une fois par heure (au début de chaque heure).</para>
          </listitem>
        </itemizedlist>
      </sidebar>

      <sidebar>
        <title><emphasis>CAS PARTICULIER</emphasis> <command>cron</command> et l'heure d'été</title>

	<para>Sous Debian, <command>cron</command> prend en compte au mieux les changements d'heure (en fait, lorsqu'un saut important est détecté dans l'heure locale). Ainsi, les commandes qui auraient dû être exécutées à une heure qui n'a pas existé (par exemple, 2 h 30 lors du changement d'heure de printemps en France) sont exécutées peu après le changement d'heure (soit peu après 3 h du matin en heure d'été). À l'inverse, à l'automne, les commandes qui auraient pu être exécutées plusieurs fois (à 2 h 30 heure d'été puis, une heure plus tard, à 2 h 30 heure d'hiver) ne le sont qu'une fois.</para>

	<para>On prendra cependant soin, si l'ordre dans lequel les différentes tâches planifiées et le délai entre leurs déclenchements respectifs est important, de vérifier la compatibilité de ces contraintes avec le mode de fonctionnement de <command>cron</command> — le cas échéant, on pourra préparer une planification spéciale pour les deux nuits de l'année où le problème risque d'apparaître.</para>
      </sidebar>

      <para>Chaque ligne significative d'une <emphasis>crontab</emphasis> décrit une commande planifiée grâce aux six (ou sept) champs suivants :</para>
      <itemizedlist>
        <listitem>
	  <para>la condition sur les minutes (nombres compris de 0 à 59) ;</para>
        </listitem>
        <listitem>
	  <para>la condition sur les heures (de 0 à 23) ;</para>
        </listitem>
        <listitem>
	  <para>la condition sur le jour du mois (de 1 à 31) ;</para>
        </listitem>
        <listitem>
	  <para>la condition sur le mois (de 1 à 12) ;</para>
        </listitem>
        <listitem>
	  <para>la condition sur le jour de la semaine (de 0 à 7, le 1 correspondant au lundi — le dimanche est représenté à la fois par 0 et par 7 ; il est également possible d'employer les trois premières lettres du nom du jour en anglais comme <literal>Sun</literal>, <literal>Mon</literal>, etc.) ;</para>
        </listitem>
        <listitem>
	  <para>le nom d'utilisateur sous lequel la commande devra s'exécuter (dans le fichier <filename>/etc/crontab</filename> et dans les fragments déposés dans <filename>/etc/cron.d/</filename>, mais pas les crontabs des utilisateurs) ;</para>
        </listitem>
        <listitem>
	  <para>la commande à exécuter (quand les conditions définies par les cinq premières colonnes sont remplies).</para>
        </listitem>
      </itemizedlist>

      <para>Tous les détails sont documentés dans la page de manuel <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry>.</para>

      <para>Chaque condition peut s'exprimer sous la forme d'une énumération de valeurs possibles (séparées par des virgules). La syntaxe <literal>a-b</literal> décrit l'intervalle de toutes les valeurs comprises entre <literal>a</literal> et <literal>b</literal>. La syntaxe <literal>a-b/c</literal> décrit un intervalle avec un incrément de <literal>c</literal> (exemple : <literal>0-10/2</literal> correspond à <literal>0,2,4,6,8,10</literal>). Le joker <literal>*</literal> représente toutes les valeurs possibles.</para>

      <example id="example.crontab">
        <title>Exemple de <filename>crontab</filename></title>

        <programlisting>
#Format
#min heu jou moi jsem commande

# Télécharge les données tous les soirs à 19:25
 25  19  *   *   *    $HOME/bin/get.pl

# Le matin à 8:00, en semaine (lundi à vendredi)
 00  08  *   *   1-5  $HOME/bin/fait_quelquechose

# Redémarre le proxy IRC après chaque reboot
@reboot /usr/bin/dircproxy
</programlisting>
      </example>

      <sidebar>
        <title><emphasis>ASTUCE</emphasis> Exécuter une commande au démarrage</title>

	<para>Pour exécuter une commande une seule fois, juste après le démarrage de l'ordinateur, on peut recourir à la macro <literal>@reboot</literal> (un simple redémarrage de <command>cron</command> ne déclenche pas une commande planifiée avec <literal>@reboot</literal>). Cette macro remplace elle aussi les cinq premiers champs d'une entrée dans la <emphasis>crontab</emphasis>.</para>
      </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> Émuler <command>cron</command> avec <command>systemd</command></title>

      <para>Il est possible d'émuler un partie du comportement de <command>cron</command> avec le système de minuterie <foreignphrase>(timer)</foreignphrase> de <command>systemd</command> (voir <xref linkend="sect.systemd" />).</para>
    </sidebar>

    </section>
    <section id="sect.at-command">
      <title>Emploi de la commande <command>at</command></title>
      <indexterm><primary><command>at</command></primary></indexterm>

      <para>La commande <command>at</command> prévoit l'exécution d'une commande à un moment ultérieur. Elle prend l'horaire et la date prévus en paramètres sur sa ligne de commande, et la commande à exécuter sur son entrée standard. La commande sera exécutée comme si elle avait été saisie dans un interpréteur de commandes. <command>at</command> conserve d'ailleurs l'environnement courant afin de pouvoir travailler exactement dans les mêmes conditions que celles de la planification. L'horaire est indiqué en suivant les conventions habituelles : <literal>16:12</literal> représente 16 h 12. La date peut être précisée au format <literal>JJ.MM.AA</literal> (<literal>27.07.15</literal> représentant ainsi 27 juillet 2015) ou <literal>AAAA-MM-JJ</literal> (cette même date étant alors représentée par <literal>2015-07-27</literal>). En son absence, la commande sera exécutée dès que l'horloge atteindra l'heure signalée (le jour même ou le lendemain). On peut encore écrire explicitement <foreignphrase>today</foreignphrase> (aujourd'hui) ou <foreignphrase>tomorrow</foreignphrase> (demain).</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;FIN</userinput>
<computeroutput>&gt; </computeroutput><userinput>echo "Penser à souhaiter un bon anniversaire à Raphaël" \</userinput>
<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>
<computeroutput>&gt; </computeroutput><userinput>FIN</userinput>
<computeroutput>warning: commands will be executed using /bin/sh
job 31 at Mon Jul 27 09:00:00 2015</computeroutput>
</screen>

      <para>Une autre syntaxe permet d'exprimer une durée d'attente : <command>at now + <replaceable>nombre</replaceable> <replaceable>période</replaceable></command>. La <replaceable>période</replaceable> peut valoir <literal>minutes</literal>, <literal>hours</literal> (heures), <literal>days</literal> (jours) ou <literal>weeks</literal> (semaines). Le <replaceable>nombre</replaceable> indique simplement le nombre de ces unités qui doivent s'écouler avant exécution de la commande.</para>

      <para>Pour annuler une tâche planifiée pour <command>cron</command>, il suffit, lors d'un appel à <command>crontab -e</command>, de supprimer la ligne correspondante dans la <emphasis>crontab</emphasis> où la tâche est définie. Pour les tâches <command>at</command>, c'est à peine plus complexe : il suffit d'exécuter la commande <command>atrm <replaceable>numéro-de-tâche</replaceable></command>. Le numéro de tâche est indiqué par la commande <command>at</command> lors de la planification mais on pourra le retrouver grâce à la commande <command>atq</command>, qui donne la liste des commandes actuellement planifiées.</para>
      <indexterm><primary><command>atrm</command></primary></indexterm>
      <indexterm><primary><command>atq</command></primary></indexterm>
    </section>
  </section>
  <section id="sect.asynchronous-task-scheduling-anacron">
    <title>Planification asynchrone : <command>anacron</command></title>

    <para><command>anacron</command> est le démon qui complète <command>cron</command> pour les ordinateurs non allumés en permanence. Les tâches régulières étant habituellement planifiées au milieu de la nuit, elles ne seront jamais exécutées si la machine est éteinte à ce moment-là. La fonction d'<command>anacron</command> est de les exécuter en prenant en compte les périodes où l'ordinateur ne fonctionne pas.</para>
    <indexterm><primary><command>anacron</command></primary></indexterm>

    <para>Attention, <command>anacron</command> fera fréquemment exécuter cette activité en retard quelques minutes après le démarrage de la machine, ce qui peut en perturber la réactivité. C'est pourquoi les tâches du fichier <filename>/etc/anacrontab</filename> sont démarrées sous la commande <command>nice</command>, qui réduit leur priorité d'exécution et limitera donc l'impression de lenteur du reste du système. Attention, le format de ce fichier n'est pas le même que celui de <filename>/etc/crontab</filename> ; si vous avez des besoins particuliers avec <command>anacron</command>, consultez la page de manuel <citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry>.</para>

    <sidebar>
      <title><emphasis>B.A.-BA</emphasis> Priorité, <command>nice</command></title>

      <para>Les systèmes Unix (et donc Linux) sont éminemment multi-tâches et multi-utilisateurs. Plusieurs processus peuvent en effet tourner en parallèle, appartenant à plusieurs utilisateurs différents, le noyau se chargeant d'assurer la répartition des ressources entre les différents processus. Il gère pour cela une notion de priorité, qui lui permet de favoriser certains processus au détriment d'autres selon les besoins. Lorsque l'on sait qu'un processus peut tourner en basse priorité, on le signale lors de son lancement, en utilisant <command>nice <replaceable>programme</replaceable></command> (<foreignphrase>nice</foreignphrase> signifiant « gentil, agréable »). Le programme disposera alors d'une proportion amoindrie des ressources du système, il perturbera donc moins les autres processus s'ils ont besoin de fonctionner. Bien entendu, si aucun autre processus n'a besoin de ressources, le programme ne sera pas artificiellement ralenti.</para>

      <para><command>nice</command> fonctionne avec des niveaux de « gentillesse » : les niveaux positifs (de 1 à 19) rendent progressivement un processus moins prioritaire, les niveaux négatifs (de -1 à -20) le rendent au contraire plus avide de ressources — mais seul le super-utilisateur est autorisé à utiliser ces niveaux négatifs. Sauf indication contraire (voir la page de manuel <citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry>), <command>nice</command> utilise le niveau 10.</para>

      <para>Si l'on s'aperçoit qu'une tâche déjà lancée aurait dû l'être avec <command>nice</command>, il n'est pas trop tard pour réagir : la commande <command>renice</command> permet de changer la priorité d'un processus déjà existant, dans un sens ou dans l'autre (mais diminuer la « gentillesse » d'un processus est réservé au super-utilisateur).</para>
    </sidebar>

    <para>L'installation du paquet <emphasis role="pkg">anacron</emphasis> désactive l'exécution par <command>cron</command> des scripts des fichiers <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename> et <filename>/etc/cron.monthly/</filename>. On évite ainsi qu'ils soient pris en compte à la fois par <command>anacron</command> et par <command>cron</command>. Mais <command>cron</command> reste actif et se chargera encore d'exécuter les autres commandes planifiées (notamment par les utilisateurs).</para>
  </section>
  <section id="sect.quotas">
    <title>Les quotas</title>
    <indexterm><primary>quota</primary></indexterm>

    <para>Le système des quotas permet de limiter l'espace disque alloué à un utilisateur ou un groupe d'utilisateurs. Pour le mettre en place, il faut disposer d'un noyau activant sa prise en charge (option de compilation <varname>CONFIG_QUOTA</varname>) — ce qui est le cas des noyaux Debian. Les logiciels de gestion des quotas se trouvent dans le paquet Debian <emphasis role="pkg">quota</emphasis>.</para>

    <para>Pour activer les quotas sur un système de fichiers, il faut mentionner, dans le fichier <filename>/etc/fstab</filename>, les options <literal>usrquota</literal> et <literal>grpquota</literal>, respectivement pour des quotas utilisateurs ou de groupes. Redémarrer l'ordinateur permet ensuite de mettre à jour les quotas en l'absence d'activité disque (condition nécessaire à une bonne comptabilisation de l'espace disque déjà consommé).</para>

    <para>La commande <command>edquota <replaceable>utilisateur</replaceable></command> (ou <command>edquota -g <replaceable>groupe</replaceable></command>) permet de changer les limites tout en consultant la consommation actuelle.</para>
    <indexterm><primary><command>edquota</command></primary></indexterm>

    <sidebar>
      <title><emphasis>POUR ALLER PLUS LOIN</emphasis> Définir les quotas par script</title>
      <indexterm><primary><command>setquota</command></primary></indexterm>

      <para>Le programme <command>setquota</command> peut être employé dans un script pour modifier automatiquement de nombreux quotas. Sa page de manuel <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry> détaille la syntaxe précise à employer.</para>
    </sidebar>

    <para>Le système de quotas permet de définir quatre limites :</para>
    <itemizedlist>
      <listitem>
	<para>Deux limites (<foreignphrase>soft</foreignphrase> et <foreignphrase>hard</foreignphrase>, respectivement douce et dure) concernent le nombre de blocs consommés. Si le système de fichiers a été créé avec une taille de bloc de 1 kilo-octet, un bloc contient 1 024 octets du même fichier. Les blocs non saturés induisent donc des pertes d'espace disque. Un quota de 100 blocs, qui permet théoriquement de stocker 102 400 octets, sera pourtant saturé par 100 fichiers de 500 octets, ne représentant que 50 000 octets au total.</para>
      </listitem>
      <listitem>
	<para>Deux limites (<foreignphrase>soft</foreignphrase> et <foreignphrase>hard</foreignphrase>) concernent le nombre d'<foreignphrase>inodes</foreignphrase> employés. Chaque fichier consomme au moins un <foreignphrase>inode</foreignphrase> pour stocker les informations le concernant (droits, propriétaires, date de dernier accès, etc.). Il s'agit donc d'une limite sur le nombre de fichiers de l'utilisateur.</para>
      </listitem>
    </itemizedlist>

    <para>Une limite <foreignphrase>soft</foreignphrase> peut être franchie temporairement ; l'utilisateur sera simplement averti de son dépassement de quota par le programme <command>warnquota</command>, habituellement invoqué par <command>cron</command>. Une limite <foreignphrase>hard</foreignphrase> ne peut jamais être franchie : le système refusera toute opération provoquant un dépassement du quota dur.</para>

    <sidebar>
      <title><emphasis>VOCABULAIRE</emphasis> Blocs et <foreignphrase>inodes</foreignphrase></title>
      <indexterm><primary>bloc (disque)</primary></indexterm>
      <indexterm><primary><foreignphrase>inode</foreignphrase></primary></indexterm>

      <para>Le système de fichiers découpe le disque dur en blocs, petites zones contiguës. La taille de ces blocs est déterminée lors de la création du système de fichiers et varie généralement entre 1 et 8 ko.</para>

      <para>Un bloc peut être utilisé soit pour stocker des données réelles du fichier, soit des métadonnées utilisées par le système de fichiers. Parmi ces métadonnées, on trouve notamment les <foreignphrase>inodes</foreignphrase> (terme parfois traduit par « i-nœuds » mais généralement laissé tel quel). Un inode utilise un bloc sur le disque (mais ce bloc n'est pas pris en compte dans le quota de blocs, seulement dans le quota d'inodes) et contient à la fois des informations sur le fichier qu'il concerne (nom, propriétaire, permissions etc.) et des pointeurs vers les blocs de données réellement utilisés. Pour les fichiers volumineux occupant plus de blocs qu'il n'est possible d'en référencer dans un seul inode, il y a même un système de blocs indirects : l'inode référence une liste de blocs ne contenant pas directement des données mais une autre liste de blocs.</para>
    </sidebar>
    <indexterm><primary><command>warnquota</command></primary></indexterm>

    <para>On peut définir, par la commande <command>edquota -t</command>, une « période de grâce » maximale autorisée pour un dépassement de limite <foreignphrase>soft</foreignphrase>. Ce délai écoulé, la limite <foreignphrase>soft</foreignphrase> se comportera comme une limite <foreignphrase>hard</foreignphrase> et l'utilisateur devra donc repasser sous elle pour pouvoir à nouveau écrire quoi que ce soit sur le disque.</para>

    <sidebar>
      <title><emphasis>POUR ALLER PLUS LOIN</emphasis> Systématiser un quota pour les nouveaux utilisateurs</title>

      <para>Pour instaurer un quota systématique chez les nouveaux utilisateurs, il faut le configurer sur un utilisateur « modèle » (avec <command>edquota</command> ou <command>setquota</command>) et indiquer son nom dans la variable <varname>QUOTAUSER</varname> du fichier <filename>/etc/adduser.conf</filename>. Ce paramétrage sera alors automatiquement repris pour chaque nouvel utilisateur créé avec la commande <command>adduser</command>.</para>
    </sidebar>
  </section>
  <section id="sect.backup">
    <title>Sauvegarde</title>

    <para>L'une des responsabilités principales de tout administrateur, la sauvegarde reste un sujet complexe dont les outils puissants sont en général difficiles à maîtriser.</para>
    <indexterm><primary>sauvegarde</primary></indexterm>
    <indexterm><primary>restauration</primary></indexterm>

    <para>De nombreux logiciels existent : citons <command>amanda</command>, <command>bacula</command> et <command>BackupPC</command>.  Il s'agit de systèmes client/serveur dotés de nombreuses options, dont la configuration peut être difficile.  Certains disposent d'une interface de configuration web.  Des dizaines d'autres paquets Debian sont dédiés à des solutions de sauvegarde, comme vous le montrera la commande <command>apt-cache search backup</command>.</para>
    <indexterm><primary><command>amanda</command></primary></indexterm>
    <indexterm><primary><command>bacula</command></primary></indexterm>
    <indexterm><primary><command>BackupPC</command></primary></indexterm>

    <para>Plutôt que de détailler le fonctionnement de certains d'entre eux, nous prenons le parti d'exposer la réflexion menée par les administrateurs de Falcot SA pour définir leur stratégie de sauvegarde.</para>

    <para>Chez Falcot SA, les sauvegardes répondent à deux besoins : récupérer des fichiers supprimés par erreur et remettre en route rapidement tout ordinateur (serveur ou bureautique) dont le disque dur subit une panne.</para>
    <section>
      <title>Sauvegarde avec <command>rsync</command></title>

      <para>Les sauvegardes sur bandes ayant été jugées trop lentes et trop coûteuses, les données seront sauvegardées sur les disques durs d'un serveur dédié, où l'emploi du RAID logiciel (détaillé dans la <xref linkend="sect.raid-soft" />) les protégera d'une défaillance du disque. Les ordinateurs bureautiques ne sont pas sauvegardés individuellement, mais les utilisateurs sont informés que leur compte personnel, situé sur le serveur de fichiers de leur département, sera sauvegardé. La commande <command>rsync</command> (du paquet éponyme) sauvegarde quotidiennement ces différents serveurs.</para>
      <indexterm><primary><command>rsync</command></primary></indexterm>

      <sidebar>
        <title><emphasis>B.A.-BA</emphasis> Le lien dur, un deuxième nom pour le fichier</title>
        <indexterm><primary>lien</primary><secondary>dur</secondary></indexterm>
        <indexterm><primary>dur, lien</primary></indexterm>

	<para>Un lien dur <foreignphrase>(hardlink)</foreignphrase>, contrairement au lien symbolique, ne peut être différencié du fichier pointé. Créer un lien dur revient en fait à affecter un deuxième nom à un fichier déjà existant (cible). C'est pourquoi la suppression d'un lien dur ou de la cible ne supprime en fait qu'un des noms associés au fichier. Tant qu'un nom est encore affecté au fichier, les données de celui-ci restent présentes sur le système de fichiers. Il est intéressant de noter que contrairement à une copie, le lien dur ne consomme pas d'espace disque supplémentaire.</para>

	<para>Le lien dur se crée avec la commande <command>ln <replaceable>cible</replaceable> <replaceable>lien</replaceable></command>. Le fichier <replaceable>lien</replaceable> est alors un nouveau nom du fichier <replaceable>cible</replaceable>. Les liens durs ne peuvent être créés qu'au sein d'un même système de fichiers, alors que les liens symboliques ne souffrent pas de cette limitation.</para>
      </sidebar>

      <para>L'espace disque disponible interdit la mise en place d'une sauvegarde complète quotidienne. C'est pourquoi la synchronisation par <command>rsync</command> est précédée d'une duplication du contenu de la dernière sauvegarde par des liens durs <foreignphrase>(hard links)</foreignphrase>, qui évitent de consommer trop d'espace disque. Le processus <command>rsync</command> ne remplacera ensuite que les fichiers modifiés depuis la dernière sauvegarde. Ce mécanisme permet de conserver un grand nombre de sauvegardes sur un volume réduit. Toutes les sauvegardes étant accessibles en même temps (par exemple dans des répertoires différents d'un même volume accessible à travers le réseau), on pourra effectuer rapidement des comparaisons entre deux dates données.</para>
      <indexterm><primary>copie de sauvegarde</primary></indexterm>
      <indexterm><primary>sauvegarde</primary><secondary>copie</secondary></indexterm>
      <indexterm><primary><emphasis role="pkg">dirvish</emphasis></primary></indexterm>

      <para>Ce mécanisme de sauvegarde se met facilement en place à l'aide du programme <command>dirvish</command>. Il emploie un espace de stockage des sauvegardes (<foreignphrase>bank</foreignphrase>, dans son vocabulaire) dans lequel il place les différentes copies horodatées des ensembles de fichiers sauvegardés (ces ensembles sont nommés <foreignphrase>vaults</foreignphrase>, donc « chambre forte », dans la documentation de <command>dirvish</command>).</para>

      <para>La configuration principale se trouve dans le fichier <filename>/etc/dirvish/master.conf</filename>. Elle indique l'emplacement de l'espace de stockage des sauvegardes, la liste des ensembles à sauvegarder ainsi que des valeurs par défaut pour l'expiration des sauvegardes. Le reste de la configuration se trouve dans les fichiers <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> et contient à chaque fois la configuration spécifique à l'ensemble de fichiers en question.</para>

      <example id="example.dirvish-master">
        <title>Fichier <filename>/etc/dirvish/master.conf</filename></title>

        <programlisting>
bank:
    /backup
exclude:
    lost+found/
    core
    *~
Runall:
    root    22:00
expire-default: +15 days
expire-rule:
#   MIN HR    DOM MON       DOW  STRFTIME_FMT
    *   *     *   *         1    +3 months
    *   *     1-7 *         1    +1 year
    *   *     1-7 1,4,7,10  1
</programlisting>
      </example>

      <para>Le paramètre <literal>bank</literal> indique le répertoire dans lequel les sauvegardes sont stockées. Le paramètre <literal>exclude</literal> permet d'indiquer des fichiers (ou des formes de noms de fichiers) à exclure de la sauvegarde. Le paramètre <literal>Runall</literal> est la liste des ensembles de fichiers à sauvegarder avec un horodatage pour chaque ensemble, ce dernier permet simplement d'attribuer la bonne date à la copie au cas où la sauvegarde ne se déclencherait pas exactement à l'heure prévue. Il faut indiquer un horaire légèrement inférieur à l'horaire réel d'exécution (qui est 22h04 par défaut sur un système Debian, selon <filename>/etc/cron.d/dirvish</filename>). Enfin, les paramètres <literal>expire-default</literal> et <literal>expire-rule</literal> définissent la politique d'expiration (donc de conservation) des sauvegardes. L'exemple précédent conserve pour toujours les sauvegardes générées le premier dimanche de chaque trimestre, détruit après un an celles du premier dimanche de chaque mois et après 3 mois celles des autres dimanches. Les autres sauvegardes quotidiennes sont conservées 15 jours. L'ordre des règles compte : <command>dirvish</command> emploie la dernière règle qui correspond, ou celle mentionnée dans <literal>expire-default</literal> si aucune des règles de <literal>expire-rule</literal> ne correspond.</para>

      <sidebar>
        <title><emphasis>EN PRATIQUE</emphasis> Expiration planifiée</title>

	<para>Les règles d'expiration ne sont pas employées par <command>dirvish-expire</command> pour faire son travail. En réalité, les règles d'expiration interviennent au moment de la création d'une nouvelle copie de sauvegarde pour définir une date d'expiration associée à cette copie. <command>dirvish-expire</command> se contente de parcourir les copies stockées et de supprimer celles dont la date d'expiration est dépassée.</para>
      </sidebar>

      <example id="example.dirvish-vault">
        <title>Fichier <filename>/backup/root/dirvish/default.conf</filename></title>

        <programlisting>
client: rivendell.falcot.com
tree: /
xdev: 1
index: gzip
image-default: %Y%m%d
exclude:
    /var/cache/apt/archives/*.deb
    /var/cache/man/**
    /tmp/**
    /var/tmp/**
    *.bak
</programlisting>
      </example>

      <para>L'exemple ci-dessus précise l'ensemble de fichiers à sauvegarder : il s'agit de fichiers sur la machine <emphasis>rivendell.falcot.com</emphasis> (pour une sauvegarde de données locales, il faut simplement préciser le nom de la machine locale tel que <command>hostname</command> le rapporte), en particulier ceux qui sont dans l'arborescence racine (<literal>tree: /</literal>) à l'exclusion de ceux listés dans <literal>exclude</literal>. La sauvegarde restera limitée au contenu d'un seul système de fichiers (<literal>xdev: 1</literal>), elle n'inclura pas les fichiers d'autres montages. Un index des fichiers sauvegardés sera généré (<literal>index: gzip</literal>) et l'image sera nommée selon la date du jour (<literal>image-default: %Y%m%d</literal>).</para>

      <para>De nombreuses options existent, toutes documentées dans la page de manuel <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>. Une fois ces fichiers de configuration mis en place, il faut initialiser chaque ensemble de fichiers avec la commande <command>dirvish --vault <replaceable>vault</replaceable> --init</command>. Puis l'invocation quotidienne de <command>dirvish-runall</command> créera automatiquement une nouvelle copie de sauvegarde juste après avoir supprimé celles qui devaient l'être.</para>

      <sidebar>
        <title><emphasis>EN PRATIQUE</emphasis> Sauvegarde distante par SSH</title>

	<para>Lorsque <command>dirvish</command> doit sauvegarder des données d'une machine distante, il va employer <command>ssh</command> pour s'y connecter et y démarrer <command>rsync</command> en tant que serveur. Cela nécessite donc que l'utilisateur root puisse se connecter automatiquement à la machine en question. L'emploi d'une clé d'authentification SSH permet précisément cela (voir <xref linkend="sect.ssh-key-based-auth" />).</para>
      </sidebar>
    </section>
    <section>
      <title>Restauration des machines non sauvegardées</title>

      <para>Les ordinateurs bureautiques, qui ne sont pas sauvegardés, pourront être réinstallés à partir des DVD-Rom personnalisés préparés avec <emphasis>Simple-CDD</emphasis> (voir <xref linkend="sect.simple-cdd" />).  Comme il s'agit d'une installation à partir de zéro, cela perdra toute configuration qui aura été faite après l'installation initiale ; cela ne pose pas de problème, puisque tous les systèmes sont connectés à un annuaire LDAP qui centralise les comptes utilisateurs et la plupart des applications bureautiques sont préconfigurées par le biais de <command>dconf</command> (voir <xref linkend="sect.gnome-desktop" /> à ce propos).</para>

      <para>Les administrateurs de Falcot SA sont conscients des limites de leur politique de sauvegarde. Ne pouvant pas protéger le serveur de sauvegarde aussi bien qu'une bande dans un coffre ignifugé, ils l'ont installé dans une pièce séparée de sorte qu'un sinistre tel qu'un incendie se déclarant dans la salle des serveurs ne détruise pas aussi les sauvegardes. Par ailleurs, ils réalisent une sauvegarde incrémentale sur DVD-Rom une fois par semaine — seuls les fichiers modifiés depuis la dernière sauvegarde sont concernés.</para>

      <sidebar>
        <title><emphasis>POUR ALLER PLUS LOIN</emphasis> Sauvegarde SQL, LDAP</title>

	<para>De nombreux services (comme les bases de données SQL ou LDAP) ne peuvent pas être sauvegardés simplement en copiant leurs fichiers (sauf s'ils sont correctement interrompus durant la sauvegarde, ce qui pose souvent problème car ils sont prévus pour être disponibles en permanence). Il est alors nécessaire de faire appel à une procédure « d'export » des données, dont on sauvegardera alors le <foreignphrase>dump</foreignphrase>. Souvent volumineux, celui-ci se prête cependant bien à la compression. Pour réduire l'espace de stockage nécessaire, on ne stockera qu'un fichier texte complet par semaine et un <command>diff</command> chaque jour, ce dernier étant obtenu par une commande du type <command>diff <replaceable>fichier-de-la-veille</replaceable> <replaceable>fichier-du-jour</replaceable></command>. Le programme <command>xdelta</command> produira les différences incrémentales des <foreignphrase>dumps</foreignphrase> binaires.</para>
        <indexterm><primary><command>xdelta</command></primary></indexterm>
        <indexterm><primary><command>diff</command></primary></indexterm>
        <indexterm><primary><foreignphrase>dump</foreignphrase></primary></indexterm>
      </sidebar>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> <emphasis>TAR</emphasis>, standard de sauvegarde sur bande</title>
        <indexterm><primary>sauvegarde</primary><secondary>sur bande</secondary></indexterm>
        <indexterm><primary>bande, sauvegarde</primary></indexterm>
        <indexterm><primary>TAR</primary></indexterm>

	<para>Historiquement, le moyen le plus simple de réaliser une sauvegarde sous Unix était de stocker sur bande une archive au format <emphasis>TAR</emphasis>. La commande <command>tar</command> tire d'ailleurs son nom de <foreignphrase>Tape ARchive</foreignphrase> (« archive sur bande »).</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.hotplug">
    <title>Branchements « à chaud » : <emphasis>hotplug</emphasis></title>
    <section>
      <title>Introduction</title>

      <para>Le sous-système <emphasis>hotplug</emphasis> du noyau permet de charger les pilotes des périphériques et de créer les fichiers de périphériques correspondants (avec l'aide d'<command>udevd</command>).  Avec le matériel moderne et la virtualisation, quasiment tous les périphériques peuvent être connectés à chaud, depuis les classiques USB/PCMCIA/IEEE 1394 et les disques durs SATA jusqu'au processeur et à la mémoire eux-mêmes.</para>

      <para>Le noyau dispose d'une base de données associant à chaque identifiant de périphérique le pilote requis. Cette base de données est employée au démarrage de l'ordinateur pour charger tous les pilotes des périphériques détectés sur les différents bus mentionnés, mais aussi lors de l'insertion à chaud d'un périphérique supplémentaire. Une fois le pilote chargé, un message est envoyé à <command>udevd</command> afin que celui-ci puisse créer l'entrée correspondante dans <filename>/dev/</filename>.</para>

      <indexterm><primary><emphasis>hotplug</emphasis></primary></indexterm>
      <indexterm><primary>branchement à chaud</primary></indexterm>
      <indexterm><primary>USB</primary></indexterm>
      <indexterm><primary>IEEE 1394</primary></indexterm>
      <indexterm><primary>PCMCIA</primary></indexterm>
      <indexterm><primary>SATA</primary></indexterm>
    </section>
    <section>
      <title>La problématique du nommage</title>

      <para>Avant l'introduction des branchements à chaud, il était simple de donner un nom fixe à un périphérique. On se basait simplement sur le positionnement des périphériques dans leur bus respectif. Mais si les périphériques apparaissent et disparaissent sur le bus, ce n'est plus possible. L'exemple typique est l'emploi d'un appareil photo numérique et d'une clé USB : tous les deux apparaissent comme des disques, le premier branché pourra être <filename>/dev/sdb</filename> et le second <filename>/dev/sdc</filename> (avec <filename>/dev/sda</filename> représentant le disque dur). Le nom du périphérique n'est donc pas fixe, il dépend de l'ordre dans lequel ils ont été connectés.</para>

      <para>En outre, de plus en plus de pilotes emploient des numéros majeur/mineur dynamiques, ce qui fait qu'il est impossible d'avoir une entrée statique pour le périphérique, puisque ces caractéristiques essentielles peuvent varier après un redémarrage de l'ordinateur.</para>

      <para>C'est pour résoudre ces problématiques qu'<emphasis>udev</emphasis> a été créé.</para>

      <sidebar>
        <title><emphasis>EN PRATIQUE</emphasis> Gestion des cartes réseau</title>

	<para>De nombreux ordinateurs intègrent plusieurs cartes réseau (parfois deux interfaces filaires et une interface Wi-Fi) et avec la prise en charge de <emphasis>hotplug</emphasis> sur la plupart des types de bus, le noyau Linux n'offre pas de garantie de nommage fixe sur ces interfaces réseau. Pourtant l'utilisateur qui veut configurer son réseau dans <filename>/etc/network/interfaces</filename> a besoin d'un nom fixe !</para>

	<para>Il serait pénible de demander à chaque utilisateur de se créer ses propres règles <emphasis>udev</emphasis> pour régler ce problème, c'est pourquoi <emphasis>udev</emphasis> a été configuré d'une manière un peu particulière : au premier démarrage (et plus généralement à chaque fois qu'une carte jamais rencontrée apparaît), il utilise le nom de l'interface réseau et son adresse MAC pour créer des nouvelles règles qui, aux prochains redémarrages, seront employées pour réattribuer systématiquement les mêmes noms. Ces règles sont stockées dans <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>.</para>

        
	<para>Ce mécanisme a des effets de bord qu'il est bon de connaître. Considérons le cas d'un ordinateur qui n'a qu'une seule carte réseau PCI. L'interface réseau se nomme logiquement <literal>eth0</literal>. La carte tombe en panne et l'administrateur la remplace, la nouvelle carte a donc une nouvelle adresse MAC. Puisque l'ancienne carte avait reçu le nom <literal>eth0</literal>, la nouvelle se verra attribuer le nom <literal>eth1</literal> alors même que la carte <literal>eth0</literal> ne réapparaîtra jamais (et le réseau ne sera pas fonctionnel car <filename>/etc/network/interfaces</filename> configure vraisemblablement une interface <literal>eth0</literal>). Dans ces cas, il suffit de supprimer le fichier <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> avant de redémarrer l'ordinateur et la nouvelle carte recevra le nom <literal>eth0</literal> attendu.</para>
      </sidebar>
    </section>
    <section>
      <title>Fonctionnement de udev</title>

      <para>Lorsqu'<emphasis>udev</emphasis> est informé par le noyau de l'apparition d'un nouveau périphérique, il récupère de nombreuses informations sur le périphérique en question en consultant les entrées correspondantes dans <filename>/sys/</filename>, en particulier celles qui permettent de l'identifier de manière unique (adresse MAC pour une carte réseau, numéro de série pour certains périphériques USB, etc.).</para>

      <para>Armé de toutes ces informations, <emphasis>udev</emphasis> consulte l'ensemble de règles contenu dans <filename>/etc/udev/rules.d/</filename> et <filename>/lib/udev/rules.d/</filename> et décide à partir de cela du nom à attribuer au périphérique, des liens symboliques à créer (pour offrir des noms alternatifs), ainsi que des commandes à exécuter. Tous les fichiers sont consultés et les règles sont toutes évaluées séquentiellement (sauf quand un fichier fait appel à des constructions de type « GOTO »). Ainsi, il peut y avoir plusieurs règles qui correspondent à un événement donné.</para>

      <para>La syntaxe des fichiers de règles est assez simple : chaque ligne contient des critères de sélection et des directives d'affectation. Les premiers permettent de sélectionner les événements sur lesquels il faudra réagir et les seconds définissent l'action à effectuer. Tous sont simplement séparés par des virgules et c'est l'opérateur qui désigne s'il s'agit d'un critère de sélection (pour les opérateurs de comparaison <literal>==</literal> ou <literal>!=</literal>) ou d'une directive d'affectation (pour les opérateurs <literal>=</literal>, <literal>+=</literal> ou <literal>:=</literal>).</para>

      <para>Les opérateurs de comparaison s'emploient sur les variables suivantes :</para>
      <itemizedlist>
        <listitem>
	  <para><literal>KERNEL</literal> : le nom que le noyau affecte au périphérique ;</para>
        </listitem>
        <listitem>
	  <para><literal>ACTION</literal> : l'action correspondant à l'événement (« add » pour l'ajout d'un périphérique, « remove » pour la suppression) ;</para>
        </listitem>
        <listitem>
	  <para><literal>DEVPATH</literal> : le chemin de l'entrée correspondant au périphérique dans <filename>/sys/</filename> ;</para>
        </listitem>
        <listitem>
	  <para><literal>SUBSYSTEM</literal> : le sous-système du noyau à l'origine de la demande (ils sont nombreux mais citons par exemple « usb », « ide », « net », « firmware », etc.) ;</para>
        </listitem>
        <listitem>
	  <para><literal>ATTR{<replaceable>attribut</replaceable>}</literal> : contenu du fichier <replaceable>attribut</replaceable> dans le répertoire <filename>/sys/<replaceable>$devpath</replaceable>/</filename> du périphérique. C'est ici que l'on va trouver les adresses MAC et autres identifiants spécifiques à chaque bus ;</para>
        </listitem>
        <listitem>
	  <para><literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> et <literal>ATTRS{<replaceable>attribut</replaceable>}</literal> sont des variantes qui vont chercher à faire correspondre les différentes options sur un des périphériques parents du périphérique actuel ;</para>
        </listitem>
        <listitem>
	  <para><literal>PROGRAM</literal> : délègue le test au programme indiqué (vrai s'il renvoie 0, faux sinon). Le contenu de la sortie standard du programme est stocké afin de pouvoir l'utiliser dans le cadre du test <literal>RESULT</literal> ;</para>
        </listitem>
        <listitem>
	  <para><literal>RESULT</literal> : effectue des tests sur la sortie standard du dernier appel à <literal>PROGRAM</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>Les opérandes de droite peuvent employer certaines expressions de motifs pour correspondre à plusieurs valeurs en même temps. Ainsi, <literal>*</literal> correspond à une chaîne quelconque (même vide), <literal>?</literal> correspond à un caractère quelconque et <literal>[]</literal> correspond à l'ensemble de caractères cités entre les crochets (l'ensemble inverse si le premier caractère est un point d'exclamation, et les intervalles de caractères sont possibles grâce à la notation <literal>a-z</literal>).</para>

      <para>En ce qui concerne les opérateurs d'affectation, <literal>=</literal> affecte une valeur (et remplace la valeur actuelle) ; s'il s'agit d'une liste elle est vidée et ne contient plus que la valeur affectée. <literal>:=</literal> fait de même mais empêche les modifications subséquentes de cette même variable. Quant à <literal>+=</literal>, il ajoute une valeur dans une liste. Voici les variables qui peuvent être modifiées :</para>
      <itemizedlist>
        <listitem>
	  <para><literal>NAME</literal> : le nom du fichier de périphérique à créer dans <filename>/dev/</filename>. Seule la première affectation compte, les autres sont ignorées ;</para>
        </listitem>
        <listitem>
	  <para><literal>SYMLINK</literal> : la liste des noms symboliques qui pointeront sur le même périphérique ;</para>
        </listitem>
        <listitem>
	  <para><literal>OWNER</literal>, <literal>GROUP</literal> et <literal>MODE</literal> définissent l'utilisateur et le groupe propriétaire du périphérique ainsi que les permissions associées ;</para>
        </listitem>
        <listitem>
	  <para><literal>RUN</literal> : la liste des programmes à exécuter en réponse à cet événement.</para>
        </listitem>
      </itemizedlist>

      <para>Les valeurs affectées à ces variables peuvent employer un certain nombre de substitutions :</para>
      <itemizedlist>
        <listitem>
	  <para><literal>$kernel</literal> ou <literal>%k</literal> : équivalent de <literal>KERNEL</literal> ;</para>
        </listitem>
        <listitem>
	  <para><literal>$number</literal> ou <literal>%n</literal> : le numéro d'ordre du périphérique, par exemple « 3 » pour <literal>sda3</literal> ;</para>
        </listitem>
        <listitem>
	  <para><literal>$devpath</literal> ou <literal>%p</literal> : équivalent de <literal>DEVPATH</literal> ;</para>
        </listitem>
        <listitem>
	 
	  <para><literal>$attr{<replaceable>attribut</replaceable>}</literal> ou <literal>%s{<replaceable>attribut</replaceable>}</literal> : équivalent de <literal>ATTRS{<replaceable>attribut</replaceable>}</literal> ;</para>
        </listitem>
        <listitem>
	  <para><literal>$major</literal> ou <literal>%M</literal> : le numéro majeur du périphérique ;</para>
        </listitem>
        <listitem>
	  <para><literal>$minor</literal> ou <literal>%m</literal> : le numéro mineur du périphérique ;</para>
        </listitem>
        <listitem>
	  <para><literal>$result</literal> ou <literal>%c</literal> : la chaîne renvoyée par le dernier programme invoqué par <literal>PROGRAM</literal> ;</para>
        </listitem>
        <listitem>
	  <para>enfin <literal>%%</literal> et <literal>$$</literal> pour les caractères pourcent et dollar respectivement.</para>
        </listitem>
      </itemizedlist>

      <para>Ces listes ne sont pas exhaustives (elles reprennent les paramètres les plus importants) mais la page de manuel <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry> devrait l'être.</para>
    </section>
    <section>
      <title>Cas pratique</title>

      <para>Prenons le cas d'une simple clé USB et essayons de lui affecter un nom fixe. Il faut d'abord trouver les éléments qui vont permettre de l'identifier de manière unique. Pour cela, on la branche et on exécute <command>udevadm info -a -n /dev/sdc</command> (en remplaçant évidemment <replaceable>/dev/sdc</replaceable> par le nom réel affecté à la clé).</para>

      <screen>
<computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>
<computeroutput>[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="1-2.2"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</computeroutput>
</screen>

      <para>Pour constituer une ligne de règle, on peut employer des tests sur les variables du périphérique ainsi que celles d'un seul des périphériques parents. L'exemple ci-dessus permet notamment de créer deux règles comme celles-ci :</para>

      <programlisting>
KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="clef_usb/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="clef_usb/part%n"
</programlisting>

      <para>Une fois ces règles placées dans un fichier, nommé par exemple <filename>/etc/udev/rules.d/010_local.rules</filename>, il suffit de retirer puis réinsérer la clé USB. On peut alors constater que <filename>/dev/clef_usb/disk</filename> représente le disque associé à la clé USB et que <filename>/dev/clef_usb/part1</filename> est sa première partition.</para>

      <sidebar>
        <title><emphasis>POUR ALLER PLUS LOIN</emphasis> Déboguer la configuration de <emphasis>udev</emphasis></title>

	<para>Comme beaucoup de démons, <command>udevd</command> enregistre des traces dans <filename>/var/log/daemon.log</filename>. Mais il n'est pas très verbeux par défaut et cela ne permet que rarement de comprendre ce qu'il fait. La commande <command>sudo udevadm control --log-priority=info</command> augmente le niveau de verbosité courant et résout ce problème. <command>udevadm control --log-priority=err</command> remet en place le niveau par défaut.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.power-management">
    <title>Gestion de l'énergie : Advanced Configuration and Power Interface (ACPI)</title>
    <indexterm><primary>gestion de l'énergie</primary></indexterm>
    <indexterm><primary>énergie, gestion</primary></indexterm>

    <para>La question de la gestion de l'énergie reste souvent problématique. En effet, une mise en veille réussie requiert que les pilotes de tous les périphériques de l'ordinateur sachent se désactiver et surtout reconfigurer le périphérique au réveil. Malheureusement, il subsiste quelques périphériques incapables de bien se mettre en veille sous Linux car leurs constructeurs n'en ont pas fourni les spécifications.</para>

    <para>Linux supporte le ACPI <foreignphrase>(Advanced Configuration and Power Interface)</foreignphrase>, le standard le plus récent en matière de gestion de l'énergie.  Le paquet <emphasis role="pkg">acpid</emphasis> fournit un démon qui se met à l'écoute d'événements liés à la gestion de l'énergie (par exemple, le basculement d'un portable depuis sa batterie vers l'alimentation secteur) et qui peut exécuter diverses commandes en réponse.</para>

    <indexterm><primary>ACPI</primary></indexterm>
    <indexterm><primary><foreignphrase>Advanced Configuration and Power Interface</foreignphrase></primary></indexterm>
    <indexterm><primary><command>acpid</command></primary></indexterm>
    
    <sidebar>
      <title><emphasis>ATTENTION</emphasis> Carte graphique et mise en veille</title>

      <para>Le pilote de la carte graphique est souvent celui qui pose problème lors de la mise en veille. En cas de souci, il convient donc de tester la dernière version du serveur graphique X.org.</para>
    </sidebar>

    <para>Après ce survol des services de base communs à de nombreux Unix, nous nous focaliserons sur l'environnement dans lequel évoluent les machines administrées : le réseau. De nombreux services sont en effet nécessaires à son bon fonctionnement — nous vous proposons de les découvrir dans le chapitre qui suit.</para>
  </section>
</chapter>
