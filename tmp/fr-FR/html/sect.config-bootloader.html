<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">8.8. Configuration du chargeur d'amorçage</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-fr-FR-1.0-1" /><meta
        name="keywords"
        content="Configuration, Francisation, Locales, Réseau, Résolution de noms, Utilisateurs, Groupes, Création de compte, Interpréteur de commandes, Shell, Impression, Chargeur de démarrage, Compilation de noyau" /><link
        rel="home"
        href="index.html"
        title="Le cahier de l'administrateur Debian" /><link
        rel="up"
        href="basic-configuration.html"
        title="Chapitre 8. Configuration de base : réseau, comptes, impression..." /><link
        rel="prev"
        href="sect.config-printing.html"
        title="8.7. Configuration de l'impression" /><link
        rel="next"
        href="sect.config-misc.html"
        title="8.9. Autres configurations : synchronisation, logs, partages…" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/fr-FR/stable/sect.config-bootloader.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-printing.html"><strong>Précédent</strong></a></li><li
          class="home">Le cahier de l'administrateur Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.config-misc.html"><strong>Suivant</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.config-bootloader"></a>8.8. Configuration du chargeur d'amorçage</h2></div></div></div><a
          id="id-1.11.12.2"
          class="indexterm"></a><a
          id="id-1.11.12.3"
          class="indexterm"></a><div
          class="para">
			Il est probablement déjà fonctionnel, mais il est toujours bon de savoir configurer et installer un chargeur d'amorçage au cas où celui-ci disparaîtrait du <span
            class="foreignphrase"><em
              class="foreignphrase">Master Boot Record</em></span> (enregistrement d'amorçage maître). Cela peut se produire suite à l'installation d'un autre système d'exploitation, tel que Windows. Ces connaissances vous permettront également d'en modifier la configuration si l'actuelle ne vous convient pas.
		</div><div
          class="sidebar"><div
            class="titlepage"><div><div><p
                  class="title"><strong><span
                      class="emphasis"><em>B.A.-BA</em></span> <span
                      class="foreignphrase"><em
                        class="foreignphrase">Master Boot Record</em></span></strong></p></div></div></div><a
            id="id-1.11.12.5.2"
            class="indexterm"></a><a
            id="id-1.11.12.5.3"
            class="indexterm"></a><div
            class="para">
			Le <span
              class="foreignphrase"><em
                class="foreignphrase">Master Boot Record</em></span> (MBR, ou enregistrement d'amorçage maître) est la zone des 512 premiers octets du premier disque dur, chargée par le BIOS pour donner la main à un programme capable de démarrer le système d'exploitation voulu. En général, un chargeur d'amorçage s'installe donc sur le MBR en écrasant son contenu antérieur.
		</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.identify-disks"></a>8.8.1. Identifier ses disques</h3></div></div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURE</em></span> <span
                        class="emphasis"><em>udev</em></span> et <code
                        class="filename">/dev/</code></strong></p></div></div></div><div
              class="para">
				Le répertoire <code
                class="filename">/dev/</code> abrite traditionnellement des fichiers dits « spéciaux », destinés à représenter les périphériques du système (voir encadré <a
                class="xref"
                href="sect.creating-accounts.html#sidebar.special-files"><span
                  class="emphasis"><em>B.A.-BA</em></span> Droits d'accès à un périphérique</a>). À une lointaine époque, il contenait des fichiers spéciaux correspondant à tous les périphériques possibles. Cette structure statique présentait un certain nombre d'inconvénients, notamment parce qu'elle restreignait le nombre de périphériques utilisables (puisque leur liste était codée en dur) et qu'elle empêchait de savoir quels fichiers spéciaux correspondaient à un périphérique existant.
			</div><div
              class="para">
				De nos jours, les fichiers spéciaux sont gérés de manière entièrement dynamique, ce qui correspond mieux à la nature des périphériques informatiques (dont la plupart peuvent être branchés et débranchés « à chaud »). Le noyau coopère avec <span
                class="emphasis"><em>udev</em></span> pour créer et supprimer ces fichiers à la volée lorsque les périphériques apparaissent ou disparaissent. Cela permet de ne pas avoir à stocker le répertoire <code
                class="filename">/dev/</code> sur un système de stockage persistant ; au contraire, il est dans un système de fichiers en mémoire qui commence vide et qui ne contient que les entrées pertinentes.
			</div><div
              class="para">
				Le noyau fournit de nombreuses informations à propos d'un périphérique lors de son ajout et y ajoute une paire d'identifiants (majeur/mineur). <code
                class="command">udevd</code> utilise ces informations pour créer le fichier spécial sous le nom voulu et avec les permissions les plus pertinentes. Il peut aussi créer des alias et lancer des actions supplémentaires (par exemple des tâches d'initialisation ou d'enregistrement). Le comportement d'<code
                class="command">udevd</code> est régi par un vaste ensemble de règles (personnalisables).
			</div><div
              class="para">
				Il est ainsi possible, en utilisant les noms affectés de manière dynamique, de garder le même nom pour un périphérique donné, quel que soit le port auquel il est connecté ou l'ordre dans lequel les périphériques ont été branchés, ce qui pourra se révéler très utile si de nombreux périphériques USB sont utilisés. La première partition du premier disque s'appelle généralement <code
                class="filename">/dev/sda1</code> pour des raisons de compatibilité ascendante, mais elle pourrait tout aussi bien s'appeler <code
                class="filename">/dev/partition-principale</code>, voire les deux à la fois puisqu'il est possible de configurer <code
                class="command">udevd</code> pour qu'il crée un lien symbolique automatiquement.
			</div><div
              class="para">
				En des temps anciens, certains modules noyau se chargeaient automatiquement lorsqu'on tentait d'accéder au périphérique correspondant. Ce n'est désormais plus le cas, le fichier spécial du périphérique n'existant plus avant d'avoir chargé le module… ce qui n'est pas très grave puisque la plupart des modules sont chargés au démarrage grâce à la détection automatique du matériel. Mais pour des périphériques non détectables (comme le bon vieux lecteur de disquettes ou la souris PS/2), cela ne fonctionne pas. Pensez donc à ajouter les modules <code
                class="literal">floppy</code>, <code
                class="literal">psmouse</code> et <code
                class="literal">mousedev</code> dans <code
                class="filename">/etc/modules</code> afin de forcer leur chargement au démarrage.
			</div></div><a
            id="id-1.11.12.6.3"
            class="indexterm"></a><a
            id="id-1.11.12.6.4"
            class="indexterm"></a><div
            class="para">
				La configuration du chargeur d'amorçage doit identifier les différents disques et leurs partitions. Linux emploie pour cela un système de fichiers spéciaux (dits en mode « bloc »), stockés dans le répertoire <code
              class="filename">/dev/</code>. Depuis Debian <span
              class="distribution distribution">Squeeze</span>, le schéma de nommage a été unifié et tous les disques durs (IDE/PATA, SATA, SCSI, USB, IEEE 1394) sont dorénavant représentés par des <code
              class="filename">/dev/sd*</code>.
			</div><div
            class="para">
				Chaque partition est représentée par un numéro d'ordre au sein du disque où elle réside : <code
              class="filename">/dev/sda1</code> est donc la première partition du premier disque et <code
              class="filename">/dev/sdb3</code> la troisième partition du deuxième disque.
			</div><a
            id="id-1.11.12.6.7"
            class="indexterm"></a><a
            id="id-1.11.12.6.8"
            class="indexterm"></a><a
            id="id-1.11.12.6.9"
            class="indexterm"></a><a
            id="id-1.11.12.6.10"
            class="indexterm"></a><div
            class="para">
				L'architecture PC (ou « i386 », y compris son jeune cousin « amd64 ») est limitée à quatre partitions « primaires » par disque. Pour outrepasser cette limitation, l'une d'entre elles sera créée comme une partition « étendue » et pourra alors contenir des partitions « secondaires ». Ces dernières portent toujours un numéro supérieur ou égal à 5. La première partition secondaire pourra donc être <code
              class="filename">/dev/sda5</code>, suivie de <code
              class="filename">/dev/sda6</code>, etc.
			</div><div
            class="para">
				Une autre restriction de la table de partition MS-DOS est qu'elle ne supporte pas des disques de plus de 2 To, ce qui devient un vrai problème avec les disques récents.
			</div><a
            id="id-1.11.12.6.13"
            class="indexterm"></a><a
            id="id-1.11.12.6.14"
            class="indexterm"></a><div
            class="para">
				Un nouveau format de table de partition, nommé GPT, permet de dépasser ces contraintes sur le nombre de partitions (il supporte jusqu'à 128 partitions) et sur la taille des disques (qui peuvent aller jusqu'à 8 zétaoctets, ce qui représente plus de 8 milliards de téraoctets). Ainsi, si l'on prévoit de créer de nombreuses partitions physiques sur le même disque, il convient de créer une table de partition au format GPT lors de l'étape du partitionnement.
			</div><div
            class="para">
				Il n'est pas toujours facile de mémoriser quel disque est branché sur le second contrôleur SATA ou en troisième position dans la chaîne SCSI, d'autant que le nommage des disques durs branchables à chaud (ce qui inclut entre autres la plupart des disques SATA et des disques externes) n'est pas entièrement déterministe et peut changer d'un boot à l'autre. Heureusement, <code
              class="command">udev</code> crée, en plus des <code
              class="filename">/dev/sd*</code>, des liens symboliques de nom fixe, qu'on pourra alors utiliser si l'on souhaite identifier de manière non ambiguë l'un ou l'autre disque. Ces liens symboliques sont stockés dans <code
              class="filename">/dev/disk/by-id/</code>. Sur une machine à deux disques physiques, on a par exemple :
			</div><pre
            class="screen"><code
              class="computeroutput">mirexpress:/dev/disk/by-id# </code><strong
              class="userinput"><code>ls -l
</code></strong><code
              class="computeroutput">total 0
lrwxrwxrwx 1 root root  9 23 juil. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 juil. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 juil. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 juil. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 juil. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 juil. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 juil. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 juil. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 juil. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 juil. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 juil. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 juil. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 juil. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 juil. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 juil. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 juil. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 juil. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </code></pre><div
            class="para">
				On constate que certains disques sont listés plusieurs fois (parce qu'ils se comportent à la fois comme des disques ATA et comme des SCSI), mais l'information pertinente est principalement dans le modèle et le numéro de série des disques, à partir desquels on peut retrouver le fichier de périphérique.
			</div><div
            class="para">
				Les exemples de fichiers de configuration donnés dans les sections suivantes reposent tous sur le même cas : un seul disque SATA, dont la première partition est dédiée à un ancien Windows et la seconde contient Debian GNU/Linux.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.config-lilo"></a>8.8.2. Configuration de LILO</h3></div></div></div><a
            id="id-1.11.12.7.2"
            class="indexterm"></a><a
            id="id-1.11.12.7.3"
            class="indexterm"></a><div
            class="para">
				<span
              class="emphasis"><em>LILO</em></span> (<span
              class="foreignphrase"><em
                class="foreignphrase">LInux LOader</em></span>, ou chargeur de Linux) est le plus ancien chargeur d'amorçage, solide mais rustique. Il écrit dans le MBR l'adresse physique du noyau à démarrer ; c'est pourquoi chaque mise à jour de celui-ci (ou du fichier de configuration de LILO) doit être suivie de la commande <code
              class="command">lilo</code>. L'oublier produira un système incapable de démarrer si l'ancien noyau a été supprimé ou remplacé, puisque le nouveau ne sera pas au même emplacement sur le disque.
			</div><div
            class="para">
				LILO a pour fichier de configuration <code
              class="filename">/etc/lilo.conf</code> ; un fichier simple pour une configuration standard est illustré par l'exemple ci-dessous.
			</div><div
            class="example"><a
              xmlns=""
              id="example.lilo.conf"></a><p
              class="title"><strong>Exemple 8.3. Fichier de configuration de LILO</strong></p><div
              class="example-contents"><pre
                class="programlisting">
# Le disque sur lequel LILO doit s'installer.
# En indiquant le disque et non pas une partition,
# on ordonne à LILO de s'installer sur le MBR.
boot=/dev/sda
# la partition qui contient Debian
root=/dev/sda2
# l'élément à charger par défaut
default=Linux

# Noyau le plus récent
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Ancien noyau (si le noyau nouvellement installé ne démarre pas)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# Seulement pour un double amorçage Linux/Windows
other=/dev/sda1
  label=Windows
</pre></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.config-grub"></a>8.8.3. Configuration de GRUB 2</h3></div></div></div><a
            id="id-1.11.12.8.2"
            class="indexterm"></a><a
            id="id-1.11.12.8.3"
            class="indexterm"></a><div
            class="para">
				<span
              class="emphasis"><em>GRUB</em></span> (<span
              class="foreignphrase"><em
                class="foreignphrase">GRand Unified Bootloader</em></span>, ou grand chargeur d'amorçage unifié) est plus récent. Il n'est pas nécessaire de l'invoquer après chaque mise à jour du noyau puisqu'il sait lire les systèmes de fichiers et retrouver tout seul la position du noyau sur le disque. Pour l'installer dans le MBR du premier disque, on saisira simplement <code
              class="command">grub-install /dev/sda</code>. <a
              id="id-1.11.12.8.4.4"
              class="indexterm"></a>
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ATTENTION</em></span> Noms des disques pour GRUB</strong></p></div></div></div><div
              class="para">
				GRUB fait appel au BIOS pour identifier les disques durs. <code
                class="literal">(hd0)</code> correspond au premier disque ainsi détecté, <code
                class="literal">(hd1)</code> au deuxième, etc. Dans la majorité des cas, cet ordre correspond exactement à l'ordre habituel des disques sous Linux, mais des problèmes peuvent survenir lorsque l'on associe disques SCSI et disques IDE. GRUB stocke les correspondances qu'il détecte dans le fichier <code
                class="filename">/boot/grub/device.map</code>. Si vous y trouvez des erreurs (parce que vous savez que votre BIOS détecte les disques dans un autre ordre), corrigez-les manuellement et exécutez à nouveau <code
                class="command">grub-install</code>. <code
                class="command">grub-mkdevicemap</code> peut être utile pour créer un fichier <code
                class="filename">device.map</code> de départ.
			</div><div
              class="para">
				Les partitions portent aussi un nom spécifique à GRUB. Lorsque l'on utilise des partitions « classiques » au format MS-DOS, la première partition du premier disque est notée <code
                class="literal">(hd0,msdos1)</code>, la seconde <code
                class="literal">(hd0,msdos2)</code>, etc.
			</div></div><div
            class="para">
				La configuration de GRUB 2 est stockée dans <code
              class="filename">/boot/grub/grub.cfg</code>, mais ce fichier est (sous Debian) généré à partir d'autres. On prendra donc garde de ne pas le modifier à la main, sous peine de voir ces modifications locales perdues à la prochaine invocation de <code
              class="command">update-grub</code> (qui peut se faire lors d'une mise à jour de différents paquets). Les modifications les plus courantes du fichier <code
              class="filename">/boot/grub/grub.cfg</code> (pour ajouter des paramètres de ligne de commande au noyau ou changer la durée d'affichage du menu, par exemple) se font par le biais des variables définies dans <code
              class="filename">/etc/default/grub</code>. Pour ajouter des entrées dans le menu, on pourra soit créer un fichier <code
              class="filename">/boot/grub/custom.cfg</code>, soit modifier le fichier <code
              class="filename">/etc/grub.d/50_custom</code>. Pour des personnalisations plus complexes, on pourra modifier les autres fichiers de <code
              class="filename">/etc/grub.d/</code>, ou en ajouter ; il s'agit de scripts qui doivent renvoyer des extraits de configuration, en s'appuyant éventuellement sur des programmes externes. Ce sont ces scripts qui vont mettre à jour la liste des noyaux à démarrer : <code
              class="filename">10_linux</code> prend en compte les noyaux Linux installés, <code
              class="filename">20_linux_xen</code> prend en compte les systèmes de virtualisation Xen et <code
              class="filename">30_os-prober</code> prend en compte d'autres systèmes d'exploitation (Windows, OS X, Hurd).
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.config-yaboot"></a>8.8.4. Cas des Macintosh (PowerPC) : configuration de Yaboot</h3></div></div></div><a
            id="id-1.11.12.9.2"
            class="indexterm"></a><div
            class="para">
				Yaboot est le chargeur de démarrage employé par les anciens Macintosh utilisant des processeurs PowerPC. Ils n'amorcent pas comme les PC, mais recourent à une partition d'amorçage <span
              class="foreignphrase"><em
                class="foreignphrase">(bootstrap)</em></span>, à partir de laquelle le BIOS (ou <span
              class="foreignphrase"><em
                class="foreignphrase">OpenFirmware</em></span>) exécute le chargeur et sur laquelle le programme <code
              class="command">ybin</code> installe <code
              class="command">yaboot</code> et son fichier de configuration. On n'exécutera à nouveau cette commande qu'en cas de modification du fichier <code
              class="filename">/etc/yaboot.conf</code> (il est en effet dupliqué sur la partition de <span
              class="foreignphrase"><em
                class="foreignphrase">bootstrap</em></span> et <code
              class="command">yaboot</code> sait retrouver la position des noyaux sur les disques).
			</div><div
            class="para">
				Avant d'exécuter <code
              class="command">ybin</code>, il faut disposer d'un fichier <code
              class="filename">/etc/yaboot.conf</code> valide. L'exemple ci-dessous pourrait constituer un fichier minimal. <a
              id="id-1.11.12.9.4.3"
              class="indexterm"></a>
			</div><div
            class="example"><a
              xmlns=""
              id="example.yaboot.conf"></a><p
              class="title"><strong>Exemple 8.4. Fichier de configuration de Yaboot</strong></p><div
              class="example-contents"><pre
                class="programlisting">
# La partition de bootstrap
boot=/dev/sda2
# Le disque
device=hd:
# La partition Linux
partition=3
root=/dev/sda3
# Démarre après 3 sec. d'inactivité 
# (timeout est en dixièmes de secondes)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# Dernier noyau installé
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# Ancien noyau 
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# Uniquement pour un double amorçage Linux/Mac OS X
macosx=/dev/sda5

# bsd=/dev/sdaX et macos=/dev/sdaX
# sont également possibles
</pre></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-printing.html"><strong>Précédent</strong>8.7. Configuration de l'impression</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Niveau supérieur</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Sommaire</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.config-misc.html"><strong>Suivant</strong>8.9. Autres configurations : synchronisation, log...</a></li></ul></body></html>
