<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.5. L'espace utilisateur</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-fr-FR-1.0-1" /><meta
        name="keywords"
        content="BIOS, Noyau, Unix, Processus, Arborescence, Commandes de base" /><link
        rel="home"
        href="index.html"
        title="Le cahier de l'administrateur Debian" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Annexe B. Petit cours de rattrapage" /><link
        rel="prev"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. Quelques fonctions remplies par le noyau" /><link
        rel="next"
        href="backcover.html"
        title="Annexe C. Le cahier de l'administrateur Debian" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/fr-FR/stable/sect.user-space.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Précédent</strong></a></li><li
          class="home">Le cahier de l'administrateur Debian</li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Suivant</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.user-space"></a>B.5. L'espace utilisateur</h2></div></div></div><a
          id="id-1.21.8.2"
          class="indexterm"></a><a
          id="id-1.21.8.3"
          class="indexterm"></a><div
          class="para">
			On appelle espace utilisateur l'environnement d'exécution des processus normaux, par opposition aux processus qui font partie du noyau. Cela ne signifie pas pour autant que tous ces processus soient réellement lancés directement par l'utilisateur : un système normal exécute un certain nombre de « démons » (ou processus d'arrière-plan) avant même que l'utilisateur ouvre une session de travail. Les « démons » sont alors considérés comme des processus de l'espace utilisateur.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.process-basics"></a>B.5.1. Processus</h3></div></div></div><a
            id="id-1.21.8.5.2"
            class="indexterm"></a><div
            class="para">
				Lorsque le noyau a terminé son initialisation, il lance le tout premier processus, <code
              class="command">init</code>, qui n'est généralement pas utile par lui-même. Les systèmes Unix fonctionnent donc avec de nombreux processus supplémentaires.
			</div><a
            id="id-1.21.8.5.4"
            class="indexterm"></a><div
            class="para">
				Tout d'abord, un processus peut se dupliquer (on parle de <span
              class="foreignphrase"><em
                class="foreignphrase">fork</em></span>). Le noyau alloue alors une nouvelle zone de mémoire pour le deuxième processus, de contenu identique à celle du premier, et se retrouve simplement avec un processus supplémentaire à gérer. À ce moment précis, la seule différence entre les deux processus est leur <span
              class="foreignphrase"><em
                class="foreignphrase">pid</em></span>. Par convention, le nouveau processus est appelé le fils, alors que celui dont le <span
              class="foreignphrase"><em
                class="foreignphrase">pid</em></span> n'a pas changé est appelé le père.
			</div><div
            class="para">
				Il arrive que le processus fils reste tel quel et « vive sa vie », indépendamment de son père, avec ses propres données correspondant au programme initial. Néanmoins, le cas le plus fréquent est que ce fils exécute un autre programme ; à de rares exceptions près, sa zone mémoire est alors simplement remplacée par le nouveau programme, dont l'exécution démarre. C'est précisément ce mécanisme que le système d'initialisation (le processus n°1) exploite pour démarrer des services additionnels et exécuter la séquence de démarrage, jusqu'à aboutir au lancement d'une interface graphique pour l'utilisateur (la séquence des événements est décrite avec plus de détails dans la <a
              class="xref"
              href="unix-services.html#sect.system-boot">Section 9.1, « Démarrage du système »</a>).
			</div><div
            class="para">
				Lorsqu'un processus finit la tâche qui lui était dévolue, il se termine. Le noyau récupère alors la mémoire qui lui était affectée et cesse de lui distribuer des intervalles de temps d'exécution. Le processus père est informé de la destruction du fils : cela permet entre autres au père d'attendre la complétion d'une tâche sous-traitée. On retrouve ce mode de fonctionnement dans les interpréteurs de commandes (shells) : lorsque l'on tape une commande dans un shell, on ne retrouve l'invite que lorsqu'elle s'est terminée. La plupart des shells permettent cependant de ne pas attendre la fin de l'exécution d'une commande : il suffit pour cela de faire suivre le nom du programme à exécuter par &amp;. On retrouve alors l'invite aussitôt, ce qui peut poser des problèmes si la commande a des données à afficher.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.daemons"></a>B.5.2. Démons</h3></div></div></div><a
            id="id-1.21.8.6.2"
            class="indexterm"></a><a
            id="id-1.21.8.6.3"
            class="indexterm"></a><div
            class="para">
				Un démon est un processus lancé automatiquement au démarrage et qui fonctionne en tâche de fond pour accomplir certaines tâches de maintenance ou fournir des services aux autres processus. Cette notion de « tâche de fond » est arbitraire et ne correspond à rien de particulier du point de vue du système : ce sont des processus comme les autres, qui sont exécutés chacun à leur tour pendant un bref intervalle de temps de la même manière que les applications visibles. La distinction est simplement humaine : un processus qui fonctionne sans interaction avec l'utilisateur (sans interface graphique, notamment) est dit fonctionner en tâche de fond ou en tant que démon.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOCABULAIRE</em></span> Démon, un terme péjoratif ?</strong></p></div></div></div><div
              class="para">
				Le terme démon est en réalité une transcription un peu hâtive de l'anglais <span
                class="foreignphrase"><em
                  class="foreignphrase">daemon</em></span>. Bien que l'origine grecque de ce mot ait également donné le mot <span
                class="foreignphrase"><em
                  class="foreignphrase">demon</em></span>, au sens de créature diabolique, le <span
                class="foreignphrase"><em
                  class="foreignphrase">daemon</em></span> est simplement à interpréter comme un aide, un auxiliaire (tout en gardant une dimension surnaturelle). Il n'y a pas en français de mot réellement adapté à ce concept, le sens du <span
                class="foreignphrase"><em
                  class="foreignphrase">daemon</em></span> anglais s'est donc retrouvé projeté sur le « démon » français et l'usage a consacré ce choix bien qu'il ne soit pas très heureux.
			</div></div><div
            class="para">
				Plusieurs de ces démons sont détaillés dans le <a
              class="xref"
              href="unix-services.html">Chapitre 9, <em>Services Unix</em></a>.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ipc"></a>B.5.3. Communications entre processus</h3></div></div></div><a
            id="id-1.21.8.7.2"
            class="indexterm"></a><a
            id="id-1.21.8.7.3"
            class="indexterm"></a><div
            class="para">
				Qu'il s'agisse de démons ou d'applications interactives, un processus isolé n'est souvent pas très utile. Il existe donc différentes méthodes permettant à des processus séparés de communiquer entre eux, soit pour s'échanger des données, soit pour se contrôler l'un l'autre. Le terme générique les désignant est <span
              class="foreignphrase"><em
                class="foreignphrase">InterProcess Communications</em></span> (IPC) c'est-à-dire communications inter-processus.
			</div><div
            class="para">
				Le système le plus simple est le fichier : le processus qui souhaite émettre des données les écrit dans un fichier dont le nom est convenu à l'avance ; le processus destinataire n'a alors qu'à lire ce fichier pour y récupérer les données.
			</div><a
            id="id-1.21.8.7.6"
            class="indexterm"></a><div
            class="para">
				Pour éviter que les données soient stockées sur un disque dur, on peut également utiliser un tuyau ou tube (<span
              class="foreignphrase"><em
                class="foreignphrase">pipe</em></span> en anglais). Il s'agit simplement d'un système de communication où des octets écrits à un bout ressortent tels quels à l'autre bout. Si les deux extrémités sont contrôlées par deux processus différents, on obtient un canal de communication simple et pratique. Les tubes se décomposent en deux catégories. Un tube nommé dispose d'une entrée spéciale dans le système de fichiers (bien que les données qui y transitent n'y soient pas stockées) et les deux processus peuvent donc l'ouvrir indépendamment l'un de l'autre, si l'emplacement du tube nommé est connu. Dans les cas où l'on cherche à faire communiquer deux processus apparentés (par exemple un père et son fils), il est possible au père de créer un tube anonyme, dont héritera son fils après le <span
              class="foreignphrase"><em
                class="foreignphrase">fork</em></span> ; les deux processus pourront alors s'échanger des données sans passer par le système de fichiers.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>EN PRATIQUE</em></span> Un exemple concret</strong></p></div></div></div><div
              class="para">
				Étudions ce qui se passe lorsqu'on lance une commande complexe (un <span
                class="foreignphrase"><em
                  class="foreignphrase">pipeline</em></span>) dans un shell. Supposons que nous ayons un processus <code
                class="command">bash</code> (le shell standard sous Debian), de <span
                class="foreignphrase"><em
                  class="foreignphrase">pid</em></span> 4 374, dans lequel nous tapons la commande <code
                class="command">ls | sort</code>.
			</div><div
              class="para">
				Le shell commence par interpréter la commande saisie. En l'occurrence, il s'agit de deux programmes (<code
                class="command">ls</code> et <code
                class="command">sort</code>), avec un flux de données de l'un vers l'autre (noté par le caractère <strong
                class="userinput"><code>|</code></strong>, dit <span
                class="foreignphrase"><em
                  class="foreignphrase">pipe</em></span>). <code
                class="command">bash</code> crée donc un tube anonyme (qui n'existe pour l'instant que pour lui seul).
			</div><div
              class="para">
				Puis il se duplique ; on obtient donc un nouveau processus <code
                class="command">bash</code>, de <span
                class="foreignphrase"><em
                  class="foreignphrase">pid</em></span> 4 521 (les <span
                class="foreignphrase"><em
                  class="foreignphrase">pids</em></span> sont de simples numéros abstraits et n'ont généralement pas de signification particulière). Ce processus n°4 521 hérite du tuyau anonyme, il pourra donc écrire du côté « entrée » ; <code
                class="command">bash</code> redirige d'ailleurs le flux de sortie standard vers cette entrée du tuyau. Il se remplace ensuite par le programme <code
                class="command">ls</code>, qui va lister le contenu du répertoire courant ; comme il écrit sur sa sortie standard et que celle-ci a été au préalable redirigée, le résultat est effectivement envoyé dans le tuyau.
			</div><div
              class="para">
				Une opération similaire est effectuée pour la deuxième commande : <code
                class="command">bash</code> se duplique de nouveau, on obtient alors un nouveau processus <code
                class="command">bash</code> de numéro 4 522. Comme ce dernier est également un fils du n°4 374, il hérite aussi du tuyau ; <code
                class="command">bash</code> branche alors la sortie du tuyau sur son flux d'entrée standard, puis se remplace par le programme <code
                class="command">sort</code>, dont la vocation est de trier les données reçues et d'afficher le résultat.
			</div><div
              class="para">
				Toutes les pièces sont maintenant en place : <code
                class="command">ls</code> parcourt le répertoire courant et envoie la liste des fichiers dans le tuyau ; <code
                class="command">sort</code> lit cette liste, puis la trie par ordre alphabétique et affiche le résultat. Les processus n°4 521 et n°4 522 se terminent alors et le 4 374, qui s'était mis en attente, reprend la main et affiche l'invite pour permettre à l'utilisateur de saisir une nouvelle commande.
			</div></div><div
            class="para">
				Mais toutes les communications inter-processus ne servent pas à faire transiter des flux de données. Il arrive également que des applications aient simplement besoin de se transmettre des messages comme « suspendre l'exécution » ou « reprendre ». Unix (et donc Linux) fournit pour cela un mécanisme de signaux, par lequel un processus peut simplement envoyer un signal spécifique (parmi une liste prédéfinie de signaux) à un autre, simplement en connaissant son <span
              class="foreignphrase"><em
                class="foreignphrase">pid</em></span>.
			</div><div
            class="para">
				Pour des communications plus complexes, il existe aussi des mécanismes par lesquels un processus peut par exemple ouvrir l'accès d'une partie de sa zone mémoire à d'autres ; cette mémoire est alors partagée entre plusieurs processus, ce qui autorise à faire passer des données de l'un à l'autre.
			</div><div
            class="para">
				Enfin, les connexions par le réseau peuvent également servir à faire communiquer différents processus, susceptibles de s'exécuter sur des ordinateurs différents (voire séparés de milliers de kilomètres).
			</div><div
            class="para">
				Tous ces mécanismes sont utilisés, à des degrés divers, dans le fonctionnement normal d'un système Unix typique.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.libraries"></a>B.5.4. Bibliothèques</h3></div></div></div><a
            id="id-1.21.8.8.2"
            class="indexterm"></a><div
            class="para">
				Les bibliothèques de fonctions jouent un rôle crucial dans le fonctionnement d'un système d'exploitation Unix. Ce ne sont pas à proprement parler des programmes, puisqu'elles ne s'exécutent pas indépendamment, mais des collections de fragments de programmes qui sont utilisés par des programmes classiques. Parmi les bibliothèques les plus courantes, citons par exemple :
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						la bibliothèque C standard <span
                    class="emphasis"><em>(glibc)</em></span>, qui contient des fonctions de base telles que celles permettant d'ouvrir des fichiers ou des connexions réseau, mais aussi de faciliter les interactions avec le noyau ;
					</div></li><li
                class="listitem"><div
                  class="para">
						les boîtes à outils graphiques <span
                    class="foreignphrase"><em
                      class="foreignphrase">(toolkits)</em></span>, Gtk+ et Qt, qui permettent à de nombreux programmes de réutiliser les objets graphiques qu'elles proposent ;
					</div></li><li
                class="listitem"><div
                  class="para">
						la bibliothèque <span
                    class="emphasis"><em>libpng</em></span>, qui charge, interprète et sauvegarde des images au format PNG.
					</div></li></ul></div><div
            class="para">
				L'existence de ces bibliothèques permet aux applications de réutiliser du code existant ; leur développement en est simplifié d'autant, surtout lorsque de nombreuses applications font appel aux mêmes fonctions. Comme les bibliothèques sont souvent développées par des personnes différentes, le développement global du système est ainsi plus proche de la philosophie historique d'Unix.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURE</em></span> La méthode Unix : une chose à la fois</strong></p></div></div></div><div
              class="para">
				Un des concepts qui sous-tend le fonctionnement général des systèmes d'exploitation de la famille Unix est que chaque outil ne devrait faire qu'une chose, mais la faire bien, les applications pouvant alors réutiliser ces outils et construire une logique plus poussée par-dessus. Cela transparaît dans de nombreux domaines. Les scripts shell sont peut-être le meilleur exemple : ils assemblent en des séquences complexes des outils très simples (<code
                class="command">grep</code>, <code
                class="command">wc</code>, <code
                class="command">sort</code>, <code
                class="command">uniq</code>, etc.). Une autre mise en pratique de cette philosophie est visible dans les bibliothèques de code : la <span
                class="emphasis"><em>libpng</em></span> permet de lire et d'écrire des images au format PNG, avec différentes options et de différentes manières, mais elle ne fait que cela ; pas question pour elle de proposer des fonctions d'affichage ou d'édition.
			</div></div><div
            class="para">
				De plus, ces bibliothèques sont souvent dites « partagées », parce que le noyau est capable de ne les charger qu'une fois en mémoire même si plusieurs processus y font appel. Si le code qu'elles contiennent était au contraire intégré dans les applications, il serait présent en mémoire autant de fois qu'il y a de processus qui l'utilisent.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Précédent</strong>B.4. Quelques fonctions remplies par le noyau</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Niveau supérieur</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Sommaire</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Suivant</strong>Annexe C. Le cahier de l'administrateur Debian</a></li></ul></body></html>
