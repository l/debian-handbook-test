<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">9.11. Branchements « à chaud » : hotplug</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-fr-FR-1.0-1" /><meta
        name="keywords"
        content="Démarrage du système, Scripts d'initialisation, SSH, Telnet, Droits, Permissions, Supervision, Inetd, Cron, Sauvegarde, Hotplug, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Le cahier de l'administrateur Debian" /><link
        rel="up"
        href="unix-services.html"
        title="Chapitre 9. Services Unix" /><link
        rel="prev"
        href="sect.backup.html"
        title="9.10. Sauvegarde" /><link
        rel="next"
        href="sect.power-management.html"
        title="9.12. Gestion de l'énergie : Advanced Configuration and Power Interface (ACPI)" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/fr-FR/stable/sect.hotplug.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.backup.html"><strong>Précédent</strong></a></li><li
          class="home">Le cahier de l'administrateur Debian</li><li
          class="next"><a
            accesskey="n"
            href="sect.power-management.html"><strong>Suivant</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.hotplug"></a>9.11. Branchements « à chaud » : <span
                  class="emphasis"><em>hotplug</em></span></h2></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.2"></a>9.11.1. Introduction</h3></div></div></div><div
            class="para">
				Le sous-système <span
              class="emphasis"><em>hotplug</em></span> du noyau permet de charger les pilotes des périphériques et de créer les fichiers de périphériques correspondants (avec l'aide d'<code
              class="command">udevd</code>). Avec le matériel moderne et la virtualisation, quasiment tous les périphériques peuvent être connectés à chaud, depuis les classiques USB/PCMCIA/IEEE 1394 et les disques durs SATA jusqu'au processeur et à la mémoire eux-mêmes.
			</div><div
            class="para">
				Le noyau dispose d'une base de données associant à chaque identifiant de périphérique le pilote requis. Cette base de données est employée au démarrage de l'ordinateur pour charger tous les pilotes des périphériques détectés sur les différents bus mentionnés, mais aussi lors de l'insertion à chaud d'un périphérique supplémentaire. Une fois le pilote chargé, un message est envoyé à <code
              class="command">udevd</code> afin que celui-ci puisse créer l'entrée correspondante dans <code
              class="filename">/dev/</code>.
			</div><a
            id="id-1.12.14.2.4"
            class="indexterm"></a><a
            id="id-1.12.14.2.5"
            class="indexterm"></a><a
            id="id-1.12.14.2.6"
            class="indexterm"></a><a
            id="id-1.12.14.2.7"
            class="indexterm"></a><a
            id="id-1.12.14.2.8"
            class="indexterm"></a><a
            id="id-1.12.14.2.9"
            class="indexterm"></a></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.3"></a>9.11.2. La problématique du nommage</h3></div></div></div><div
            class="para">
				Avant l'introduction des branchements à chaud, il était simple de donner un nom fixe à un périphérique. On se basait simplement sur le positionnement des périphériques dans leur bus respectif. Mais si les périphériques apparaissent et disparaissent sur le bus, ce n'est plus possible. L'exemple typique est l'emploi d'un appareil photo numérique et d'une clé USB : tous les deux apparaissent comme des disques, le premier branché pourra être <code
              class="filename">/dev/sdb</code> et le second <code
              class="filename">/dev/sdc</code> (avec <code
              class="filename">/dev/sda</code> représentant le disque dur). Le nom du périphérique n'est donc pas fixe, il dépend de l'ordre dans lequel ils ont été connectés.
			</div><div
            class="para">
				En outre, de plus en plus de pilotes emploient des numéros majeur/mineur dynamiques, ce qui fait qu'il est impossible d'avoir une entrée statique pour le périphérique, puisque ces caractéristiques essentielles peuvent varier après un redémarrage de l'ordinateur.
			</div><div
            class="para">
				C'est pour résoudre ces problématiques qu'<span
              class="emphasis"><em>udev</em></span> a été créé.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>EN PRATIQUE</em></span> Gestion des cartes réseau</strong></p></div></div></div><div
              class="para">
				De nombreux ordinateurs intègrent plusieurs cartes réseau (parfois deux interfaces filaires et une interface Wi-Fi) et avec la prise en charge de <span
                class="emphasis"><em>hotplug</em></span> sur la plupart des types de bus, le noyau Linux n'offre pas de garantie de nommage fixe sur ces interfaces réseau. Pourtant l'utilisateur qui veut configurer son réseau dans <code
                class="filename">/etc/network/interfaces</code> a besoin d'un nom fixe !
			</div><div
              class="para">
				Il serait pénible de demander à chaque utilisateur de se créer ses propres règles <span
                class="emphasis"><em>udev</em></span> pour régler ce problème, c'est pourquoi <span
                class="emphasis"><em>udev</em></span> a été configuré d'une manière un peu particulière : au premier démarrage (et plus généralement à chaque fois qu'une carte jamais rencontrée apparaît), il utilise le nom de l'interface réseau et son adresse MAC pour créer des nouvelles règles qui, aux prochains redémarrages, seront employées pour réattribuer systématiquement les mêmes noms. Ces règles sont stockées dans <code
                class="filename">/etc/udev/rules.d/70-persistent-net.rules</code>.
			</div><div
              class="para">
				Ce mécanisme a des effets de bord qu'il est bon de connaître. Considérons le cas d'un ordinateur qui n'a qu'une seule carte réseau PCI. L'interface réseau se nomme logiquement <code
                class="literal">eth0</code>. La carte tombe en panne et l'administrateur la remplace, la nouvelle carte a donc une nouvelle adresse MAC. Puisque l'ancienne carte avait reçu le nom <code
                class="literal">eth0</code>, la nouvelle se verra attribuer le nom <code
                class="literal">eth1</code> alors même que la carte <code
                class="literal">eth0</code> ne réapparaîtra jamais (et le réseau ne sera pas fonctionnel car <code
                class="filename">/etc/network/interfaces</code> configure vraisemblablement une interface <code
                class="literal">eth0</code>). Dans ces cas, il suffit de supprimer le fichier <code
                class="filename">/etc/udev/rules.d/70-persistent-net.rules</code> avant de redémarrer l'ordinateur et la nouvelle carte recevra le nom <code
                class="literal">eth0</code> attendu.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.4"></a>9.11.3. Fonctionnement de udev</h3></div></div></div><div
            class="para">
				Lorsqu'<span
              class="emphasis"><em>udev</em></span> est informé par le noyau de l'apparition d'un nouveau périphérique, il récupère de nombreuses informations sur le périphérique en question en consultant les entrées correspondantes dans <code
              class="filename">/sys/</code>, en particulier celles qui permettent de l'identifier de manière unique (adresse MAC pour une carte réseau, numéro de série pour certains périphériques USB, etc.).
			</div><div
            class="para">
				Armé de toutes ces informations, <span
              class="emphasis"><em>udev</em></span> consulte l'ensemble de règles contenu dans <code
              class="filename">/etc/udev/rules.d/</code> et <code
              class="filename">/lib/udev/rules.d/</code> et décide à partir de cela du nom à attribuer au périphérique, des liens symboliques à créer (pour offrir des noms alternatifs), ainsi que des commandes à exécuter. Tous les fichiers sont consultés et les règles sont toutes évaluées séquentiellement (sauf quand un fichier fait appel à des constructions de type « GOTO »). Ainsi, il peut y avoir plusieurs règles qui correspondent à un événement donné.
			</div><div
            class="para">
				La syntaxe des fichiers de règles est assez simple : chaque ligne contient des critères de sélection et des directives d'affectation. Les premiers permettent de sélectionner les événements sur lesquels il faudra réagir et les seconds définissent l'action à effectuer. Tous sont simplement séparés par des virgules et c'est l'opérateur qui désigne s'il s'agit d'un critère de sélection (pour les opérateurs de comparaison <code
              class="literal">==</code> ou <code
              class="literal">!=</code>) ou d'une directive d'affectation (pour les opérateurs <code
              class="literal">=</code>, <code
              class="literal">+=</code> ou <code
              class="literal">:=</code>).
			</div><div
            class="para">
				Les opérateurs de comparaison s'emploient sur les variables suivantes :
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">KERNEL</code> : le nom que le noyau affecte au périphérique ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">ACTION</code> : l'action correspondant à l'événement (« add » pour l'ajout d'un périphérique, « remove » pour la suppression) ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">DEVPATH</code> : le chemin de l'entrée correspondant au périphérique dans <code
                    class="filename">/sys/</code> ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">SUBSYSTEM</code> : le sous-système du noyau à l'origine de la demande (ils sont nombreux mais citons par exemple « usb », « ide », « net », « firmware », etc.) ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">ATTR{<em
                      class="replaceable">attribut</em>}</code> : contenu du fichier <em
                    class="replaceable">attribut</em> dans le répertoire <code
                    class="filename">/sys/<em
                      class="replaceable">$devpath</em>/</code> du périphérique. C'est ici que l'on va trouver les adresses MAC et autres identifiants spécifiques à chaque bus ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">KERNELS</code>, <code
                    class="literal">SUBSYSTEMS</code> et <code
                    class="literal">ATTRS{<em
                      class="replaceable">attribut</em>}</code> sont des variantes qui vont chercher à faire correspondre les différentes options sur un des périphériques parents du périphérique actuel ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">PROGRAM</code> : délègue le test au programme indiqué (vrai s'il renvoie 0, faux sinon). Le contenu de la sortie standard du programme est stocké afin de pouvoir l'utiliser dans le cadre du test <code
                    class="literal">RESULT</code> ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">RESULT</code> : effectue des tests sur la sortie standard du dernier appel à <code
                    class="literal">PROGRAM</code>.
					</div></li></ul></div><div
            class="para">
				Les opérandes de droite peuvent employer certaines expressions de motifs pour correspondre à plusieurs valeurs en même temps. Ainsi, <code
              class="literal">*</code> correspond à une chaîne quelconque (même vide), <code
              class="literal">?</code> correspond à un caractère quelconque et <code
              class="literal">[]</code> correspond à l'ensemble de caractères cités entre les crochets (l'ensemble inverse si le premier caractère est un point d'exclamation, et les intervalles de caractères sont possibles grâce à la notation <code
              class="literal">a-z</code>).
			</div><div
            class="para">
				En ce qui concerne les opérateurs d'affectation, <code
              class="literal">=</code> affecte une valeur (et remplace la valeur actuelle) ; s'il s'agit d'une liste elle est vidée et ne contient plus que la valeur affectée. <code
              class="literal">:=</code> fait de même mais empêche les modifications subséquentes de cette même variable. Quant à <code
              class="literal">+=</code>, il ajoute une valeur dans une liste. Voici les variables qui peuvent être modifiées :
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">NAME</code> : le nom du fichier de périphérique à créer dans <code
                    class="filename">/dev/</code>. Seule la première affectation compte, les autres sont ignorées ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">SYMLINK</code> : la liste des noms symboliques qui pointeront sur le même périphérique ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">OWNER</code>, <code
                    class="literal">GROUP</code> et <code
                    class="literal">MODE</code> définissent l'utilisateur et le groupe propriétaire du périphérique ainsi que les permissions associées ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">RUN</code> : la liste des programmes à exécuter en réponse à cet événement.
					</div></li></ul></div><div
            class="para">
				Les valeurs affectées à ces variables peuvent employer un certain nombre de substitutions :
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$kernel</code> ou <code
                    class="literal">%k</code> : équivalent de <code
                    class="literal">KERNEL</code> ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$number</code> ou <code
                    class="literal">%n</code> : le numéro d'ordre du périphérique, par exemple « 3 » pour <code
                    class="literal">sda3</code> ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$devpath</code> ou <code
                    class="literal">%p</code> : équivalent de <code
                    class="literal">DEVPATH</code> ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$attr{<em
                      class="replaceable">attribut</em>}</code> ou <code
                    class="literal">%s{<em
                      class="replaceable">attribut</em>}</code> : équivalent de <code
                    class="literal">ATTRS{<em
                      class="replaceable">attribut</em>}</code> ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$major</code> ou <code
                    class="literal">%M</code> : le numéro majeur du périphérique ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$minor</code> ou <code
                    class="literal">%m</code> : le numéro mineur du périphérique ;
					</div></li><li
                class="listitem"><div
                  class="para">
						<code
                    class="literal">$result</code> ou <code
                    class="literal">%c</code> : la chaîne renvoyée par le dernier programme invoqué par <code
                    class="literal">PROGRAM</code> ;
					</div></li><li
                class="listitem"><div
                  class="para">
						enfin <code
                    class="literal">%%</code> et <code
                    class="literal">$$</code> pour les caractères pourcent et dollar respectivement.
					</div></li></ul></div><div
            class="para">
				Ces listes ne sont pas exhaustives (elles reprennent les paramètres les plus importants) mais la page de manuel <span
              class="citerefentry"><span
                class="refentrytitle">udev</span>(7)</span> devrait l'être.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.12.14.5"></a>9.11.4. Cas pratique</h3></div></div></div><div
            class="para">
				Prenons le cas d'une simple clé USB et essayons de lui affecter un nom fixe. Il faut d'abord trouver les éléments qui vont permettre de l'identifier de manière unique. Pour cela, on la branche et on exécute <code
              class="command">udevadm info -a -n /dev/sdc</code> (en remplaçant évidemment <em
              class="replaceable">/dev/sdc</em> par le nom réel affecté à la clé).
			</div><pre
            class="screen">
<code
              class="computeroutput"># </code><strong
              class="userinput"><code>udevadm info -a -n /dev/sdc</code></strong>
<code
              class="computeroutput">[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="1-2.2"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</code></pre><div
            class="para">
				Pour constituer une ligne de règle, on peut employer des tests sur les variables du périphérique ainsi que celles d'un seul des périphériques parents. L'exemple ci-dessus permet notamment de créer deux règles comme celles-ci :
			</div><pre
            class="programlisting">
KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="clef_usb/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="clef_usb/part%n"
</pre><div
            class="para">
				Une fois ces règles placées dans un fichier, nommé par exemple <code
              class="filename">/etc/udev/rules.d/010_local.rules</code>, il suffit de retirer puis réinsérer la clé USB. On peut alors constater que <code
              class="filename">/dev/clef_usb/disk</code> représente le disque associé à la clé USB et que <code
              class="filename">/dev/clef_usb/part1</code> est sa première partition.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>POUR ALLER PLUS LOIN</em></span> Déboguer la configuration de <span
                        class="emphasis"><em>udev</em></span></strong></p></div></div></div><div
              class="para">
				Comme beaucoup de démons, <code
                class="command">udevd</code> enregistre des traces dans <code
                class="filename">/var/log/daemon.log</code>. Mais il n'est pas très verbeux par défaut et cela ne permet que rarement de comprendre ce qu'il fait. La commande <code
                class="command">sudo udevadm control --log-priority=info</code> augmente le niveau de verbosité courant et résout ce problème. <code
                class="command">udevadm control --log-priority=err</code> remet en place le niveau par défaut.
			</div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.backup.html"><strong>Précédent</strong>9.10. Sauvegarde</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Niveau supérieur</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Sommaire</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.power-management.html"><strong>Suivant</strong>9.12. Gestion de l'énergie : Advanced Configurati...</a></li></ul></body></html>
