<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="packaging-system" lang="zh-TW">
	<chapterinfo>
		 <keywordset>
			<keyword>執行檔套件</keyword>
			 <keyword>原始檔套件</keyword>
			 <keyword>dpkg</keyword>
			 <keyword>相依性</keyword>
			 <keyword>衝突</keyword>

		</keywordset>

	</chapterinfo>
	 <title>套件系統：工具與基本原則</title>
	 <highlights> <para>
		身為 Debian 系統管理員，經常處理 <filename>.deb</filename> 套件，因為含有一致的功能單元 (應用程式、文件等)，強化安裝與維護工作。所以能夠瞭解它們是什麼與如何使用是應該的。
	</para>
	 </highlights> <para>
		本章介紹 “執行檔” 與 “原始檔” 套件的結構與內容。前者是 <filename>.deb</filename> 檔案，以 <command>dpkg</command> 執行，後者是原始碼，以及建立執行檔套件的指令。
	</para>
	 <section id="sect.binary-package-structure">
		<title>執行檔套件的結構</title>
		 <indexterm>
			<primary>套件</primary>
			<secondary>執行檔套件</secondary>
		</indexterm>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <para>
			Debian 套件格式設計成任何 Unix 系統均可用傳統的指令 <command>ar</command>、<command>tar</command>、與 <command>gzip</command> (有時是 <command>xz</command> 或 <command>bzip2</command>) 提取其內容。看起來有點挑剔的屬性卻是跨平台與災難復原的必需品。
		</para>
		 <para>
			舉個例子，您誤刪 <command>dpkg</command> 程式，不能安裝 Debian 套件了。<command>dpkg</command> 本身就是一個 Debian 套件，好像就此和系統再見了... 幸運的，您知道套件的格式並可下載 <filename>.deb</filename> 檔案來自 <emphasis role="pkg">dpkg</emphasis> 套件且以手動方式安裝它 (見專欄 <xref linkend="sidebar.dpkg-apt-ar" />)。然而不幸的是 <command>ar</command>、<command>tar</command> 或 <command>gzip</command>/<command>xz</command>/<command>bzip2</command> 等程式都不見了，必須從別的系統複製該程式 (這些都是自主存在的，沒有相依性，祗需複製就能用)。若碰到更不像話的情況，以上作為都行不通 (遺失更深層的程式庫？)，則應試試靜態版的 <command>busybox</command> (於 <emphasis role="pkg">busybox-static</emphasis> 套件內)，它更為自足，還有諸如 <command>busybox ar</command>、<command>busybox tar</command> 與 <command>busybox gunzip</command> 等次指令。
		</para>
		 <sidebar id="sidebar.dpkg-apt-ar"> <title><emphasis>工具</emphasis> <command>dpkg</command>、<command>APT</command> 與 <command>ar</command></title>
		 <indexterm>
			<primary><command>dpkg</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <indexterm>
			<primary>APT</primary>
		</indexterm>
		 <para>
			<command>dpkg</command> 是處理 <filename>.deb</filename> 檔案的程式，提取、分析與解包他們。
		</para>
		 <para>
			<command>APT</command> 是允許對系統進行高階修改的一群程式：安裝或移除套件 (同時保持原來的相依性)、升級系統、列出可用的套件等。
		</para>
		 <indexterm>
			<primary><command>ar</command></primary>
		</indexterm>
		 <para>
			在 <command>ar</command> 程式裡，允許處理同名的檔案：<command>ar t <replaceable>archive</replaceable></command> 顯示在 archive 檔案內的清單，<command>ar x <replaceable>archive</replaceable></command> 提取 archive 檔案內容至於目前的工作資料夾，<command>ar d <replaceable>archive</replaceable> <replaceable>file</replaceable></command> 則刪除 archive 裡的一個檔案。它的首頁 (<citerefentry><refentrytitle>ar</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry>) 列出其他的功能。<command>ar</command> 是極少用到的低階工具，通常用的是更專注於歸檔與檔案管理的程式 <command>tar</command>。所以在誤刪時很容易恢復 <command>dpkg</command>。祗需下載 Debian 套件並提取 <filename>data.tar.gz</filename> 的檔案於根目錄 (<filename>/</filename>)：
		</para>
		 
<screen>
<computeroutput># </computeroutput><userinput>ar x dpkg_1.17.23_amd64.deb</userinput>
<computeroutput># </computeroutput><userinput>tar -C / -p -xzf data.tar.gz</userinput></screen>
		 </sidebar> <sidebar> <title><emphasis>基礎</emphasis> Man 手冊註記</title>
		 <para>
			初學者不太容易找到 “<citerefentry><refentrytitle>ar</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry>” 的參考資料。實際上祗需進入 man 頁面第 1 區的 <literal>ar</literal>。
		</para>
		 <para>
			有時，此註記也用來消除模棱兩可，例如 <command>printf</command> 命令可能指的是 <citerefentry><refentrytitle>printf</refentrytitle>
			<manvolnum>1</manvolnum></citerefentry> 與 C 程式語言的 <function>printf</function> 函數，指的是 <citerefentry><refentrytitle>printf</refentrytitle>
			<manvolnum>3</manvolnum></citerefentry>。
		</para>
		 <para>
			<xref linkend="solving-problems" /> 討論手冊的詳情 (見 <xref linkend="sect.manual-pages" />)。
		</para>
		 </sidebar> <para>
			查看 <filename>.deb</filename> 檔案的內容：
		</para>
		 
<screen><computeroutput>$ </computeroutput><userinput>ar t dpkg_1.17.23_amd64.deb</userinput>
<computeroutput>debian-binary
control.tar.gz
data.tar.gz
$ </computeroutput><userinput>ar x dpkg_1.17.23_amd64.deb</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>control.tar.gz  data.tar.gz  debian-binary  dpkg_1.17.23_amd64.deb
$ </computeroutput><userinput>tar tzf data.tar.gz | head -n 15</userinput>
<computeroutput>./
./var/
./var/lib/
./var/lib/dpkg/
./var/lib/dpkg/parts/
./var/lib/dpkg/info/
./var/lib/dpkg/alternatives/
./var/lib/dpkg/updates/
./etc/
./etc/logrotate.d/
./etc/logrotate.d/dpkg
./etc/dpkg/
./etc/dpkg/dpkg.cfg.d/
./etc/dpkg/dpkg.cfg
./etc/alternatives/
$ </computeroutput><userinput>tar tzf control.tar.gz</userinput>
<computeroutput>./
./conffiles
./postinst
./md5sums
./prerm
./preinst
./control
./postrm
$ </computeroutput><userinput>cat debian-binary</userinput>
<computeroutput>2.0</computeroutput></screen>
		 <para>
			如您所見，Debian 套件的 <command>ar</command> 包括以下三個檔案：
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					<filename>debian-binary</filename>。這是指明 <filename>.deb</filename> 檔案版本的純文字檔 (在 2015: version 2.0)。
				</para>

			</listitem>
			 <listitem>
				<para>
					<filename>control.tar.gz</filename>。這個檔案包括軟體套件的名稱與版本等中介資料。安裝與移除時，套件管理工具可以修正部份的中介資料，以配合機器內已有的套件清單。
				</para>

			</listitem>
			 <listitem>
				<para>
					<filename>data.tar.gz</filename>。此檔案包括套件所有可以解壓縮的內容；包括可執行檔、文件等。使用其他壓縮格式的套件，可能有不同的名字 (<filename>data.tar.bz2</filename> 是 bzip2、<filename>data.tar.xz</filename> 是 XZ)。
				</para>

			</listitem>

		</itemizedlist>

	</section>
	 <section id="sect.package-meta-information">
		<title>軟體套件中介資訊</title>
		 <indexterm>
			<primary>套件中介資訊</primary>
		</indexterm>
		 <indexterm>
			<primary>套件</primary>
			<secondary>中介資訊</secondary>
		</indexterm>
		 <para>
			Debian 軟體套件不祗是被安裝檔案的集合。還包括其他的資訊，描述與其他 Debian 軟體套件的關係 (相依、衝突、建議)。也提供在套件生命週期 (安裝、移除、升級) 各階段的腳本供執行之用。這些資料供套件管理工具使用但不是套件軟體的一部份；它們在套件內，稱為 「中介資訊」 (關於其他資訊的資訊)。
		</para>
		 <section id="sect.control">
			<title>描述：<filename>control</filename> 檔案</title>
			 <indexterm>
				<primary>套件中介資訊</primary>
			</indexterm>
			 <indexterm>
				<primary>套件</primary>
				<secondary>中介資訊</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>control</filename></primary>
			</indexterm>
			 <para>
				此檔案採用類似電子郵件標頭 (如 RFC 2822 的定義) 的做法。例如，<emphasis role="pkg">apt</emphasis>、 <filename>控制</filename> 檔案內容如下：
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>apt-cache show apt</userinput>
<computeroutput>Package: apt
Version: 1.0.9.6
Installed-Size: 3788
Maintainer: APT Development Team &lt;deity@lists.debian.org&gt;
Architecture: amd64
Replaces: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0)
Depends: libapt-pkg4.12 (&gt;= 1.0.9.6), libc6 (&gt;= 2.15), libgcc1 (&gt;= 1:4.1.1), libstdc++6 (&gt;= 4.9), debian-archive-keyring, gnupg
Suggests: aptitude | synaptic | wajig, dpkg-dev (&gt;= 1.17.2), apt-doc, python-apt
Conflicts: python-apt (&lt;&lt; 0.7.93.2~)
Breaks: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0)
Description-en: commandline package manager
 This package provides commandline tools for searching and
 managing as well as querying information about packages
 as a low-level access to all features of the libapt-pkg library.
 .
 These include:
  * apt-get for retrieval of packages and information about them
    from authenticated sources and for installation, upgrade and
    removal of packages together with their dependencies
  * apt-cache for querying available information about installed
    as well as installable packages
  * apt-cdrom to use removable media as a source for packages
  * apt-config as an interface to the configuration settings
  * apt-key as an interface to manage authentication keys
Description-md5: 9fb97a88cb7383934ef963352b53b4a7
Tag: admin::package-management, devel::lang:ruby, hardware::storage,
 hardware::storage:cd, implemented-in::c++, implemented-in::perl,
 implemented-in::ruby, interface::commandline, network::client,
 protocol::ftp, protocol::http, protocol::ipv6, role::program,
 role::shared-lib, scope::application, scope::utility, sound::player,
 suite::debian, use::downloading, use::organizing, use::searching,
 works-with::audio, works-with::software:package, works-with::text
Section: admin
Priority: important
Filename: pool/main/a/apt/apt_1.0.9.6_amd64.deb
Size: 1107560
MD5sum: a325ccb14e69fef2c50da54e035a4df4
SHA1: 635d09fcb600ec12810e3136d51e696bcfa636a6
SHA256: 371a559ce741394b59dbc6460470a9399be5245356a9183bbeea0f89ecaabb03</computeroutput></screen>
			 <sidebar> <title><emphasis>基礎</emphasis> RFC — 網際網路標準</title>
			 <indexterm>
				<primary>RFC</primary>
			</indexterm>
			 <indexterm>
				<primary>徵求修正意見書</primary>
			</indexterm>
			 <para>
				RFC 是 “Request For Comments” 的縮寫。意思是，徵求修正意見書，通常是一份即將成為網際網路標準的技術文件。在成為標準前先凍結它，並交付大眾評估 (就是名稱的由來)。由網際網路工程任務組 (Internet Engineering Task Force, IETF) 決定這些文件的狀態 (建議標準、草案、或標準)。
			</para>
			 <para>
				RFC 2026 定義網際網路協定標準化的程序。<ulink type="block" url="http://www.faqs.org/rfcs/rfc2026.html" />
			</para>
			 </sidebar> <section>
				<title>相依性：<literal>依賴</literal> 欄位</title>
				 <indexterm>
					<primary>相依</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>相依</literal>，標頭欄位</primary>
				</indexterm>
				 <indexterm>
					<primary>套件</primary>
					<secondary>相依</secondary>
				</indexterm>
				 <para>
					相依性定義在套件標頭的 <literal>Depends</literal> 欄位。這是情況清單用來滿足套件正確工作所需 — 此資訊用於 <command>apt</command> 之類的工具用來安裝必備的程式庫，以適當的版本滿足套件的相依性。每個相依性，都指定符合其需求的版本。換句話說，像是這樣的，我們需要套件 <emphasis role="pkg">libc6</emphasis> 版本大於或等於 “2.15” (寫法是 “<command>libc6 (&gt;= 2.15)</command>”)。版本的寫法是：
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							<command>&lt;&lt;</command>：小於；
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&lt;=</command>：小於或等於；
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>=</command>：等於 (“<literal>2.6.1</literal>” 不等於 “<literal>2.6.1-1</literal>”)；
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&gt;=</command>：大於或等於；
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>&gt;&gt;</command>：大於。
						</para>

					</listitem>

				</itemizedlist>
				 <para>
					碰到條件時，以逗點做為交集 “and” 符號。以直線 (“|”) 為聯集 “or” 符號 (它是包容性的或 “or”、不是排它性的非此即彼 “either/or”)。優先順序比 “and” 高，可以無限次使用。因此，相依性 “(A or B) and C” 可寫成 <command>A | B, C</command>。另個例子，“A or (B and C)” 應寫成 “(A or B) and (A or C)”，因為 <literal>Depends</literal> 欄位不接受以括號改變邏輯運算元 “or” 與 “and”的優先次序。所以須寫成 <command>A | B, A | C</command>。<ulink type="block" url="http://www.debian.org/doc/debian-policy/ch-relationships.html" />
				</para>
				 <indexterm>
					<primary>meta-package</primary>
				</indexterm>
				 <para>
					相依性系統是保證程式順利運作的良好機制，但它也有另個用法 「中介套件」。這些空的軟體套件內容祗有相依性的說明。由中介套件維護者把一群程式的相依性描述在其中；例如，<command>apt install <replaceable>meta-package</replaceable></command> 將自動安裝所有用到中介套件相依的檔案。<emphasis role="pkg">gnome</emphasis>、<emphasis role="pkg">kde-full</emphasis> 與 <emphasis role="pkg">linux-image-amd64</emphasis> 套件就是中介套件之一。
				</para>
				 <sidebar> <title><emphasis>DEBIAN 政策</emphasis> <literal>預相依</literal>，更苛刻的 <literal>相依</literal></title>
				 <indexterm>
					<primary><literal>預相依</literal>，標頭欄位</primary>
				</indexterm>
				 <indexterm>
					<primary>預相依</primary>
				</indexterm>
				 <para>
					“預相依性”，列在套件標頭的 “<literal>Pre-Depends</literal>” 欄位，滿足完整的正常相依性；它的語法是相同的。正常相依性係指必須在宣告相依性前先解開並組態的問題套件。預相依性規定在執行套件的預安裝腳本前，必須先解開並組態套件，就是在安裝之前。
				</para>
				 <para>
					<command>apt</command> 極度需要預相依，因為在安裝前加入嚴格的限制。因此，除非絕對的必要，不鼓勵加入預相依性。甚至要求在加入預相依性之前，在 <email>debian-devel@lists.debian.org</email> 郵寄清單諮詢其他發展者的意見。通常可以找出其他的解決方案。
				</para>
				 </sidebar> <sidebar> <title><emphasis>DEBIAN 政策</emphasis> <literal>推薦</literal>、<literal>建議</literal>、與 <literal>強化</literal> 欄位</title>
				 <indexterm>
					<primary><literal>推薦</literal>，標題欄位</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>建議</literal>，標題欄位</primary>
				</indexterm>
				 <para>
					<literal>推薦</literal> 與 <literal>建議</literal> 欄位描述非強制性的相依。“推薦” 相依性是最重要的，改善套件提供的功能但不是運作的必要部份。“建議” 相依性是次重要的，指出套件可能補充與增加其功能，但仍可以在不安裝其他套件的情況安裝它。
				</para>
				 <para>
					必須安裝 “推薦” 套件，除非確知不需要的理由。反之，沒有必要安裝 “建議” 套件，除非確知需要它們。
				</para>
				 <indexterm>
					<primary><literal>強化</literal>，標頭欄位</primary>
				</indexterm>
				 <para>
					<literal>Enhances</literal> 欄位也描述建議，但是位於不同的內文。實際上位於建議套件內，而不是受益於建議的套件內。有可能在不修改套件的前提下新增建議。因此所有插件、外掛與其他的程式延伸可以顯示在與軟體相關的建議清單內。雖然已存在多年，但是 <command>apt</command> 或 <command>synaptic</command> 等程式依然忽略此欄位的存在。<literal>Enhances</literal> 欄位提出的建議係在傳統建議 — <literal>Suggests</literal> 欄位供使用者參考。
				</para>
				 </sidebar>
			</section>
			 <section>
				<title>衝突： <literal>Conflicts</literal> 欄位</title>
				 <indexterm>
					<primary>衝突</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Conflicts</literal>，標頭欄位</primary>
				</indexterm>
				 <indexterm>
					<primary>套件</primary>
					<secondary>conflict</secondary>
				</indexterm>
				 <para>
					<literal>Conflicts</literal> 欄位指示不能與其共存的其他套件。最常見的理由是兩個套件使用相同的名稱，或在同個 TCP 埠提供相同的服務，或會隱藏彼此的運作。
				</para>
				 <para>
					<command>dpkg</command> 不會安裝衝突的套件，除非新套件指明 “取代” 被衝突的套件，<command>dpkg</command> 才會以新的套件取代舊的套件。<command>apt</command> 總是遵循您的指示：若選擇安裝新套件，則自動移除造成問題的舊套件。
				</para>

			</section>
			 <section>
				<title>不相容：<literal>Breaks</literal> 欄位</title>
				 <indexterm>
					<primary>不相容</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Breaks</literal>，標頭欄位</primary>
				</indexterm>
				 <indexterm>
					<primary>套件</primary>
					<secondary>不相容</secondary>
				</indexterm>
				 <para>
					<literal>Breaks</literal> 欄位的影響類似於 <literal>Conflicts</literal> 欄位，但具有特殊的意義。指出安裝一個套件將 “中斷” 另個套件 (或特別版本的套件)。通常而言，兩個套件的不相容是短暫的，且 <literal>Breaks</literal> 關係係指不相容的特定版本。
				</para>
				 <para>
					已經中斷現有套件時，<command>dpkg</command> 將拒絕安裝並且 <command>apt</command> 將更新套件至新的版本試圖解決此問題 (通常可解決此問題，並再度相容)。
				</para>
				 <para>
					此狀況可能發生在未向下相容的昇級：新版本不再與舊版本相容，沒有特別安排將造成故障。<literal>Breaks</literal> 欄位避免使用者進入此問題。
				</para>

			</section>
			 <section>
				<title>提供項目：<literal>Provides</literal> 欄位</title>
				 <indexterm>
					<primary><literal>Provides</literal>，標頭欄位</primary>
				</indexterm>
				 <para>
					這個欄位引進有趣的 “虛擬套件” 概念。它有很多角色，其中兩個特別重要。第一個是以虛擬套件關連至一個通用的服務 (此套件 “提供” 此服務)。第二個是指出此套件完全取代另個套件，它也能滿足相依性的要求。因此，可能建立替代套件而不必使用相同名稱的套件。
				</para>
				 <sidebar> <title><emphasis>術語</emphasis> 中介套件與虛擬套件</title>
				 <indexterm>
					<primary>meta-package</primary>
				</indexterm>
				 <indexterm>
					<primary>套件</primary>
					<secondary>虛擬套件</secondary>
				</indexterm>
				 <indexterm>
					<primary>虛擬套件</primary>
				</indexterm>
				 <para>
					必須從虛擬套件中明確的分離出中介套件。後者是真實的套件 (包括真實的 <filename>.deb</filename> 檔案)，其唯一目的是用來表示其相依性。
				</para>
				 <para>
					然而，虛擬套件並未真實的存在；祗是依照通用、邏輯範圍 (提供的服務、相容於標準程式或已存在的套件等) 辨認真實套件的手段。
				</para>
				 </sidebar> <section>
					<title>提供 “服務”</title>
					 <para>
						讓我們以範例詳述第一個案子：<emphasis role="pkg">postfix</emphasis> 或 <emphasis role="pkg">sendmail</emphasis> 之類的郵件伺服器都 “提供” <emphasis role="pkg">mail-transport-agent</emphasis> 虛擬套件。因此需要啟用該等服務的套件 (如：<emphasis role="pkg">smartlist</emphasis> 或 <emphasis role="pkg">sympa</emphasis> 之類的郵寄名單管理器) 祗要在其相依性裡敘明需要 <emphasis role="pkg">mail-transport-agent</emphasis> 而不是指明還不相容的可能解決方案清單 (如 <command>postfix | sendmail | exim4 | …</command>)。更進一步來說，在同個機器安裝兩個郵件伺服器是沒有用的，因此每個套件都聲明與 <emphasis role="pkg">mail-transport-agent</emphasis> 虛擬套件衝突。系統忽略衝突的兩個套件，但技術上可以禁止同時安裝兩個郵件伺服器。
					</para>
					 <sidebar> <title><emphasis>DEBIAN 政策</emphasis> 虛擬套件清單</title>
					 <indexterm>
						<primary>套件</primary>
						<secondary>虛擬套件</secondary>
					</indexterm>
					 <para>
						使用虛擬套件時，每個人都必須同意其名稱。這就是在 Debian 政策內把他們標準化的原因。此清單包括郵件伺服器 <emphasis role="pkg">mail-transport-agent</emphasis>、C 語文編譯器 <emphasis role="pkg">c-compiler</emphasis>、網頁瀏覽器 <emphasis role="pkg">www-browser</emphasis>、網頁伺服器 <emphasis role="pkg">httpd</emphasis>、FTP 伺服器 <emphasis role="pkg">ftp-server</emphasis>、圖形模式終端機模擬器 <emphasis role="pkg">x-terminal-emulator</emphasis> (<command>xterm</command>)、以及視窗管理員 <emphasis role="pkg">x-window-manager</emphasis>。
					</para>
					 <para>
						完整清單參見網站。<ulink type="block" url="http://www.debian.org/doc/packaging-manuals/virtual-package-names-list.txt" />
					</para>
					 </sidebar>
				</section>
				 <section>
					<title>與另個套件的交換性</title>
					 <para>
						套件內容被置於另個較大的套件內時，<literal>Provides</literal> 欄位就很有意思。例如，<emphasis role="pkg">libdigest-md5-perl</emphasis> Perl 模組是 Perl 5.6 的選項之一，已被整合入標準的 Perl 5.8 (及其以後的版本，如 5.20 並納入 <emphasis role="distribution">Jessie</emphasis>)。所以，套件 <emphasis role="pkg">perl</emphasis> 5.8 版之後已被宣告 <literal>Provides: libdigest-md5-perl</literal> 所以祗要使用 Perl 5.8 (或更新版) 就已滿足其相依性。<emphasis role="pkg">libdigest-md5-perl</emphasis> 套件本身早就被刪除，因為移除 Perl 舊版之後就沒有任何意義。
					</para>
					 <figure>
						<title>使用 <literal>Provides</literal> 欄位以避免中斷相依性</title>
						 <mediaobject>
							<imageobject>
								<imagedata fileref="images/virtual-package.png" format="PNG" width="50%" />
							</imageobject>

						</mediaobject>

					</figure>
					 <para>
						此功能極有用，因為它永遠不可能預料變化莫測的發展，也不能重新命名、或者自動替換過時的軟體。
					</para>
					 <sidebar> <title><emphasis>基本</emphasis> Perl，程式語言</title>
					 <indexterm>
						<primary>Perl</primary>
					</indexterm>
					 <indexterm>
						<primary>CPAN</primary>
					</indexterm>
					 <para>
						Perl (Practical Extraction and Report Language) 是極為普遍的程式語言。經由詳盡的 Perl 套件網路，CPAN (Comprehensive Perl Archive Network) 伺服器，包括涵蓋層面很廣的多個現成模組。<ulink type="block" url="http://www.perl.org/" /> <ulink type="block" url="http://www.cpan.org/" />
					</para>
					 <para>
						因為它是解譯語言，Perl 寫成的程式在執行前不需要編譯。所以也被稱為 “Perl 腳本”。
					</para>
					 </sidebar>
				</section>
				 <section>
					<title>過去的限制</title>
					 <para>
						虛擬套件曾有很多限制，最麻煩的是沒有版本編號。從上例可知，這種 <literal>Depends: libdigest-md5-perl (&gt;= 1.6)</literal> 相依性，在 Perl 5.10 沒問題，但在包裝系統時仍不會滿足其相依性 — 雖然實際上已滿足了。但是包裝不知道相依性沒問題，祗好選擇風險最小的做法，假設其版本未相依。
					</para>
					 <para>
						<emphasis role="pkg">dpkg</emphasis> 1.17.11 移除了這個限制，在 Jessie 裡沒問題。套件可以指定版本給虛擬套件使其相依，諸如 <literal>Provides: libdigest-md5-perl (= 1.8)</literal>。
					</para>

				</section>

			</section>
			 <section>
				<title>取代檔案：<literal>Replaces</literal> 欄位</title>
				 <indexterm>
					<primary>取代</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Replaces</literal>，標頭欄位</primary>
				</indexterm>
				 <indexterm>
					<primary>套件</primary>
					<secondary>取代</secondary>
				</indexterm>
				 <para>
					<literal>Replaces</literal> 欄位指出在其他套件的檔案，但該套件也合理地取代他們。沒有指名，<command>dpkg</command> 失敗，說明它不能覆寫另個套件的檔案 (技術上來說，雖不能強迫使用 <literal>--force-overwrite</literal> 選項，但可視為標準選項)。因此在加入該欄位之前，先辦認可能的問題並要求維護者研究它。
				</para>
				 <para>
					套件變更名稱或被包入其他套件時，就可合理地使用此欄位。這種情況也發生在維護者從相同的原始碼套件的執行套件中分離出檔案：被取代的檔案不再屬於舊的套件，祗屬於新的套件。
				</para>
				 <para>
					已安裝套件內的所有檔案都被取代後，就該移除此套件。最後，此欄位亦鼓勵 <command>dpkg</command> 移除衝突的被取代套件。
				</para>
				 <sidebar id="sidebar.debtags"> <title><emphasis>進一步</emphasis> <literal>Tag</literal> 欄位</title>
				 <para>
					以上述的 <emphasis role="pkg">apt</emphasis> 為例，還有一個欄位未說明，<literal>Tag</literal> 欄位。此欄位不是說明套件的關係，而是把套件分類。根據若干屬性 (介面類型、程式語言、應用範圍等) 來分類。僅管如此，並非每個套件都有精準的標籤且未融入所有的 Debian 工具；<command>aptitude</command> 顯示該等標籤，且可以被搜尋。未被 <command>aptitude</command> 搜尋的範圍，可使用以下的網站瀏覽標籤資料庫：<ulink type="block" url="http://debtags.alioth.debian.org/" />
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.configuration-scripts">
			<title>組態腳本</title>
			 <indexterm>
				<primary><filename>postinst</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>preinst</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>postrm</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>prerm</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>control.tar.gz</filename></primary>
			</indexterm>
			 <para>
				除了 <filename>control</filename> 檔案，給 Debian 套件使用的 <filename>control.tar.gz</filename> 也有若干腳本，在處理套件的各階段由 <command>dpkg</command> 啟用。Debian 政策詳細說明可能的個案，指出他們可能接收的腳本與參數。這些程序可能極為複雜，可能多個腳本同時失敗，<command>dpkg</command> 將取消安裝或移除 (祗要可能的話) 以返回前個滿意的階段。
			</para>
			 <sidebar> <title><emphasis>進一步</emphasis> <command>dpkg</command> 的資料庫</title>
			 <indexterm>
				<primary><filename>/var/lib/dpkg/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>dpkg</primary>
				<secondary>資料庫</secondary>
			</indexterm>
			 <para>
				已安裝套件的所有組態腳本，都以前置套件檔名的方式，儲存在 <filename>/var/lib/dpkg/info/</filename> 資料夾。此資料夾包括每個套件的延伸檔名 <filename>.list</filename>，包括屬於該套件的檔案清單。
			</para>
			 <para>
				<filename>/var/lib/dpkg/status</filename> 檔案包括一群資料塊 (以電子郵件標頭方式呈現，RFC 2822) 描述套件的狀態。已安裝套件的 <filename>control</filename> 檔案也複製於此。
			</para>
			 </sidebar> <para>
				一般情況下，先執行 <filename>preinst</filename> 腳本，再安裝套件，然後執行 <filename>postinst</filename>。同樣的，先執行 <filename>prerm</filename> 腳本，再移除套件，然後執行 <filename>postrm</filename>。更新套件就是先移除前個版本再安裝新的版本。沒辦法在這裡詳述所有可能發生的場景，但可以討論兩個最常發生的：安裝/更新與移除。
			</para>
			 <sidebar> <title><emphasis>注意</emphasis> 腳本名稱的象徵意義</title>
			 <para>
				本節描述的順序由特別名稱的組態腳本啟用，諸如 <command>old-prerm</command> 或 <command>new-postinst</command>。<command>prerm</command> 腳本是套件的舊版本 (未更新前的)而 <command>postinst</command> 腳本是在新版本 (經由更新安裝) 內。
			</para>
			 </sidebar> <sidebar> <title><emphasis>提示</emphasis> 狀態圖</title>
			 <para>
				Manoj Srivastava 以圖解釋這些組態腳本被 <command>dpkg</command> 叫用的情況。Debian 女子計畫也有類似的圖；容易瞭解，略為不夠完整。<ulink type="block" url="https://people.debian.org/~srivasta/MaintainerScripts.html" /> <ulink type="block" url="https://wiki.debian.org/MaintainerScripts" />
			</para>
			 </sidebar> <section>
				<title>安裝與升級</title>
				 <indexterm>
					<primary><command>dpkg</command></primary>
					<secondary>內部運作</secondary>
				</indexterm>
				 <para>
					安裝 (或升級) 時候發生的事：
				</para>
				 <orderedlist>
					<listitem>
						<para>
							升級時，<command>dpkg</command> 叫用 <command>old-prerm upgrade <replaceable>新版本</replaceable></command>.
						</para>

					</listitem>
					 <listitem>
						<para>
							還是在升級時候，<command>dpkg</command> 執行 <command>new-preinst upgrade <replaceable>舊版本</replaceable></command>；第一次安裝時，它執行 <command>new-preinst install</command>。若已經安裝或移除該套件 (但未合併，仍保留組態檔案)，可能在舊版本加入最新的參數。
						</para>

					</listitem>
					 <listitem>
						<para>
							解開新的套件。取代已存在的檔案，但暫時備份舊檔案。
						</para>

					</listitem>
					 <listitem>
						<para>
							升級時，<command>dpkg</command> 執行 <command>old-postrm upgrade <replaceable>新版本</replaceable></command>.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> 升級所有的內部資料 (檔案清單、組態腳本等) 並且移除被取代檔案的備份。這是臨界點：<command>dpkg</command> 不能再近用回復稍早狀態的元素。
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> 將更新組態檔案，無法自動管理此工作時，要求使用者做決定。詳情在此 <xref linkend="sect.conffiles" />。
						</para>

					</listitem>
					 <listitem>
						<para>
							最後，<command>dpkg</command> 執行 <command>new-postinst configure <replaceable>舊版本組態</replaceable></command> 組態套件。
						</para>

					</listitem>

				</orderedlist>

			</section>
			 <section>
				<title>移除套件</title>
				 <para>
					移除套件時發生的事：
				</para>
				 <orderedlist>
					<listitem>
						<para>
							<command>dpkg</command> 呼叫 <command>prerm remove</command>.
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> 移除套件所有檔案，但保留組態檔案與組態腳本。
						</para>

					</listitem>
					 <listitem>
						<para>
							<command>dpkg</command> 執行 <command>postrm remove</command>。移除所有組態腳本，保留 <filename>postrm</filename>。若使用者未選擇 “清除” 選項，則工作完成。
						</para>

					</listitem>
					 <listitem>
						<para>
							完全清除的套件 (由 <command>dpkg --purge</command> 或 <command>dpkg -P</command> 執行此工作)，同時刪除其組態檔，以及若干複本 (<filename>*.dpkg-tmp</filename>, <filename>*.dpkg-old</filename>, <filename>*.dpkg-new</filename>) 和暫存檔案；<command>dpkg</command> 然後執行 <command>postrm purge</command>。
						</para>

					</listitem>

				</orderedlist>
				 <sidebar> <title><emphasis>術語</emphasis> Purge，完全移除</title>
				 <indexterm>
					<primary>完整移除套件</primary>
				</indexterm>
				 <para>
					移除 Debian 套件時，仍保留組態檔案以備未來可能重新安裝該套件。同樣的，守護進程產生的資料 (諸如 LDAP 伺服器資料夾的內容、或 SQL 伺服器資料庫的內容) 也會被保留。
				</para>
				 <para>
					移除套件內所有資料，必須以指令 “清除” 該套件，<command>dpkg -P <replaceable>套件</replaceable></command>、<command>apt-get remove --purge <replaceable>套件</replaceable></command> 或 <command>aptitude purge <replaceable>套件</replaceable></command>。
				</para>
				 <para>
					移除該等資料，不能掉以輕心去清除。
				</para>
				 </sidebar> <indexterm>
					<primary><filename>config</filename>、<command>debconf</command> 腳本</primary>
				</indexterm>
				 <para>
					<filename>config</filename> 腳本補充前述的 4 個腳本，套件以 <command>debconf</command> 取得組態用的資訊。安裝過程中，此腳本以 <command>debconf</command> 指令詢問使用者詳細的問題。把回應記錄在 <command>debconf</command> 資料庫供未來的參考。在安裝之前先由 <command>apt</command> 逐一執行該等腳本，歸納問題與回答。事前與事後安裝腳本可使用該等資訊回應使用者的期望。
				</para>
				 <sidebar> <title><emphasis>工具</emphasis> <command>debconf</command></title>
				 <indexterm>
					<primary><command>debconf</command></primary>
				</indexterm>
				 <para>
					<command>debconf</command> 係用於解決重複出現於 Debian 的問題。Debian 所有的套件都需要 <command>echo</command> 與 <command>read</command> 命令於 <filename>postinst</filename> 殼腳本 (及其他類似腳本) 的最低組態才能提出問題。也就是說在大型安裝或升級過程裡，使用者必須在電腦旁回應這些隨時出現的問題。感謝 <command>debconf</command> 工具的出現，這些人工互動幾乎全部免除了。
				</para>
				 <para>
					<command>debconf</command> 包括很多有趣的功能：要求開發者指明使用者的互動；允許在地化顯示給使用者的字串 (描述互動的所有翻譯儲存在 <filename>templates</filename> 檔案)；顯示給使用者的前端問題 (文字模式、圖形模式、非互動式)；把回應集中在資料庫供其他電腦使用 ... 但最重要的已可把所有問題，在安裝或升級之前，以一列的模式顯示給使用者。使用者可以放任系統自行安裝，不必待在電腦旁，緊盯螢幕等待問題。
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.conffiles">
			<title>校驗，組態檔案清單</title>
			 <indexterm>
				<primary><filename>md5sums</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>conffiles</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>校驗</primary>
			</indexterm>
			 <indexterm>
				<primary>檔案</primary>
				<secondary>組態檔案</secondary>
			</indexterm>
			 <indexterm>
				<primary>組態</primary>
				<secondary>檔案</secondary>
			</indexterm>
			 <para>
				除了稍早提過的維護者腳本與控制資料外，在 Debian 套件內的 <filename>control.tar.gz</filename> 可能包括若干有趣的檔案。首先，<filename>md5sums</filename>，包括套件內所有檔案的 MD5 校驗。它的優點是允許 <command>dpkg --verify</command> (詳情見 <xref linkend="sect.dpkg-verify" />) 檢查該等檔案在安裝後是否被修改。若此檔案不存在，<command>dpkg</command> 將在安裝時動態產生一個 (並且如同其他控制檔案般儲存在 dpkg 資料庫)。
			</para>
			 <para>
				<filename>conffiles</filename> 列出必須當成組態檔案處理的套件。管理員可修改組態檔案，升級套件時 <command>dpkg</command> 將保留這些變動。
			</para>
			 <para>
				實際上，在此情況下，<command>dpkg</command> 儘可能地機靈：若在兩個版本間的標準組態檔並未改變， dpkg 就什麼事也不做。但是，若檔案改變動，就會更新此檔案。有兩種可能：管理員碰觸此組態檔時，由 <command>dpkg</command> 自動安裝新版本；或者被管理員修改過，<command>dpkg</command> 將要求管理員指定安裝的版本 (修訂過的舊版本、或套件提供的新版本)。為了有助於決定，<command>dpkg</command> 提供 “<command>diff</command>” 指令顯示兩個版本的差異。若選擇保留舊版本，新版仍儲存在同個資料夾其後綴檔名為 <filename>.dpkg-dist</filename>。若選擇使用新版本，舊仍儲存在同個資料夾其後綴檔名為 <filename>.dpkg-old</filename>。另一個作為是暫時中斷 <command>dpkg</command> 以編輯檔案並試圖重新安裝相關的修訂 (之前被 <command>diff</command> 驗証的差異)。
			</para>
			 <sidebar id="sidebar.questions-conffiles"> <title><emphasis>進一步</emphasis> 避免組態檔的問題</title>
			 <para>
				<command>dpkg</command> 處理組態檔案升級，但經常中斷作業，要求管理者鍵入資料。如此一來，就不能以無中斷方式一氣呵成升級作業。此指令提供選項讓系統依同樣的邏輯自動回應：<command>--force-confold</command> 保留該檔案的舊版本；<command>--force-confnew</command> 使用該檔案的新版本 (即使該檔案未被管理者修改，仍使用指定的選擇，極少發生問題)。加入 <command>--force-confdef</command> 選項告訴 <command>dpkg</command> 在可能情況下自行決定 (換句話說，不改變原組態檔)，祗在其他的情況下，才使用 <command>--force-confnew</command> 或 <command>--force-confold</command>。
			</para>
			 <para>
				這些選項適用於 <command>dpkg</command>，但是大多數情況下，管理者選擇直接使用 <command>aptitude</command> 或 <command>apt-get</command> 程式。因此，需要知道給 <command>dpkg</command> 指令用的選項語 (他們的指令介面極為類似)。
			</para>
			 
<screen>
<computeroutput># </computeroutput><userinput>apt -o DPkg::options::="--force-confdef" -o DPkg::options::="--force-confold" full-upgrade</userinput></screen>
			 <para>
				此選項可直接儲存在 <command>apt</command> 的組態內。祗需把下列這行字寫入 <filename>/etc/apt/apt.conf.d/local</filename> 檔案內：
			</para>
			 <informalexample> 
<programlisting>
DPkg::options { "--force-confdef"; "--force-confold"; }</programlisting>
			 </informalexample> <para>
				把此選項納入組態檔的意思是，將使用 <command>aptitude</command> 之類的圖形介面。
			</para>
			 </sidebar> <sidebar id="sidebar.questions-conffiles-bis"> <title><emphasis>進一步</emphasis> 強迫 dpkg 詢問組態檔的問題</title>
			 <para>
				<command>--force-confask</command> 選項要求 <command>dpkg</command> 顯示有關組態檔案的問題，即使不是必要的問題也需顯示。因此，以此選項重新安裝套件時，<command>dpkg</command> 將再詢管理者修改過的組態檔案問題。這種方式極為便利，尤其是重新安裝已經被刪除且無可用複本的原始組態檔：標準的重新安裝無效，因為 <command>dpkg</command> 認為移除為合法的修改，且不會安裝預期的組態檔。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.source-package-structure">
		<title>原始套件的結構</title>
		 <indexterm>
			<primary>套件</primary>
			<secondary>原始套件</secondary>
		</indexterm>
		 <indexterm>
			<primary>原始</primary>
			<secondary>套件</secondary>
		</indexterm>
		 <section>
			<title>格式</title>
			 <indexterm>
				<primary>DSC 檔案</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>diff.gz</filename> 檔案</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>debian.tar.gz</filename> 檔案</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>orig.tar.gz</filename> 檔案</primary>
			</indexterm>
			 <para>
				原始檔案通常包括三個檔案，<filename>.dsc</filename>、<filename>.orig.tar.gz</filename>、與 <filename>.debian.tar.gz</filename> (或 <filename>.diff.gz</filename>)。它們允許從以程式語言撰寫的程式原始碼檔案，新增可執行套件 (如前所述的 <filename>.deb</filename> 檔案)。
			</para>
			 <para>
				<filename>.dsc</filename> (Debian Source Control) 檔案是包括 RFC 2822 標頭 (如同 <filename>control</filename> 檔案於 <xref linkend="sect.control" />) 的簡短文字檔，描述原始套件及包括的其他檔案。由維護者簽署，保證其真實性。詳情見 <xref linkend="sect.package-authentication" />。
			</para>
			 <example>
				<title>A <filename>.dsc</filename> 檔案</title>
				 
<programlisting>
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

Format: 3.0 (quilt)
Source: zim
Binary: zim
Architecture: all
Version: 0.62-3
Maintainer: Emfox Zhou &lt;emfox@debian.org&gt;
Uploaders: Raphaël Hertzog &lt;hertzog@debian.org&gt;
Homepage: http://zim-wiki.org
Standards-Version: 3.9.6
Vcs-Browser: http://anonscm.debian.org/gitweb/?p=collab-maint/zim.git
Vcs-Git: git://anonscm.debian.org/collab-maint/zim.git
Build-Depends: debhelper (&gt;= 9), xdg-utils, python (&gt;= 2.6.6-3~), libgtk2.0-0 (&gt;= 2.6), python-gtk2, python-xdg
Package-List:
 zim deb x11 optional arch=all
Checksums-Sha1:
 ad8de170826682323c10195b65b9f1243fd75637 1772246 zim_0.62.orig.tar.gz
 a4f70d6f7fb404022c9cc4870a4e62ea3ca08388 14768 zim_0.62-3.debian.tar.xz
Checksums-Sha256:
 19d62aebd2c1a92d84d80720c6c1dcdb779c39a2120468fed01b7f252511bdc2 1772246 zim_0.62.orig.tar.gz
 fc2e827e83897d5e33f152f124802c46c3c01c5158b75a8275a27833f1f6f1de 14768 zim_0.62-3.debian.tar.xz
Files:
 43419efba07f7086168442e3d698287a 1772246 zim_0.62.orig.tar.gz
 725a69663a6c2961f07673ae541298e4 14768 zim_0.62-3.debian.tar.xz

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v2
Comment: Signed by Raphael Hertzog

iQEcBAEBCAAGBQJUR2jqAAoJEAOIHavrwpq5WFcH/RsdzCHc1oXXxHitU23hEqMj
T6ok29M1UFDJDowMXW75jQ1nT4WPUtvEGygkCHeoO/PvjEvB0sjU8GQlX+N9ddSB
aHfqfAYmVhADNGxrXQT5inZXUa8qGeeq2Sqf6YcWtsnuD56lDbvxkyf/XYopoIEl
oltfl05z/AI+vYsW482YrCz0fxNAKAvkyuPhDebYI8jnKWeAANoqmKpsNc/HYyvT
+ZiA5o57OiGdOKT6XGy3/FiF3dkHiRY8lXW7xdr1BbIgulwl9UmiUNwuxwOYbQO7
edtjiTJqOaFUA0x1zB/XGv5tHr1MjP8naT+kfVoVHTOox51CDbeu5D3DZY4imcY=
=Wtoa
-----END PGP SIGNATURE-----</programlisting>

			</example>
			 <indexterm>
				<primary><literal>Build-Depends</literal>，標頭欄位</primary>
			</indexterm>
			 <para>
				需注意原始套件和可執行套件一樣有相依性 (<literal>Build-Depends</literal>)，指出編譯有問題軟體與建構其可執行套件的工具。
			</para>
			 <sidebar> <title><emphasis>注意</emphasis> 不同的命名空間</title>
			 <para>
				需注意，原始套件與其產生的可執行套件間，不需使用對應的名稱。每個原始套件可能產生多個可執行套件。所以 <filename>.dsc</filename> 檔案有 <literal>Source</literal> 與 <literal>Binary</literal> 欄位記錄原始套件的名稱與其產生的可執行套件清單。
			</para>
			 </sidebar> <sidebar> <title><emphasis>文化</emphasis> 為什麼分為多個套件</title>
			 <para>
				通常，一個原始套件 (供指定軟體使用) 可產生多個可執行檔。因為可以在不同的環境使用 (部份) 軟體。在共享程式庫裡，可以安裝於構成應用作用 (如，<emphasis role="pkg">libc6</emphasis>)、或可以安裝以構成新的程式 (<emphasis role="pkg">libc6-dev</emphasis> 然後形成正確的套件)。在主從服務裡發現同樣的邏輯，在一部機器安裝伺服器的內容同時在另部機器安裝客戶端的內容 (在此情況下，是 <emphasis role="pkg">openssh-server</emphasis> 與 <emphasis role="pkg">openssh-client</emphasis>)。
			</para>
			 <para>
				同樣的，文件可供專屬套件使用：使用者可以在軟體之外獨立安裝它，且隨時可以自磁碟空間中移除它。此外，也儲存在 Debian 鏡射的磁碟空間內，因為所有的架構都共享文件套件 (不必在各架構的套件中重複此文件)。
			</para>
			 </sidebar> <sidebar> <title><emphasis>透視</emphasis> 原始套件的不同格式</title>
			 <para>
				本來祗有一種原始套件的格式。就是 <literal>1.0</literal> 格式，與 <filename>.orig.tar.gz</filename> 和 <filename>.diff.gz</filename> “debian 化” 套件有關 (還有一個變種，由一個 <filename>.tar.gz</filename> 檔案構成，若無 <filename>.orig.tar.gz</filename> 可用時自動取用它)。
			</para>
			 <para>
				因為 Debian <emphasis role="distribution">Squeeze</emphasis>、及其發展者可以選擇新的格式以校正舊格式的問題。格式 <literal>3.0 (quilt)</literal> 在同個原始套件裡納入多個上游檔案：除了使用 <filename>.orig.tar.gz</filename>，還可納入 <filename>.orig-<replaceable>component</replaceable>.tar.gz</filename> 檔案。這種做法有助於散布在多個上游組件的軟體，祗需準備一個原始套件。通常把這些檔案壓縮成 <command>bzip2</command> 或 <command>xz</command> 格式而不是 <command>gzip</command>，以節省磁碟空間與網路資源。最後，在單件補丁的情況下，<filename>.diff.gz</filename> 被 <filename>.debian.tar.gz</filename> 取代，包括編譯指令與套件維護者奉獻的上傳套件補丁。最後的這些部份記錄於格式相容的 <command>quilt</command> — 它是強化補丁管理的工具。
			</para>
			 </sidebar> <para>
				<filename>.orig.tar.gz</filename> 檔案包括原發展者提供的原始碼。要求 Debian 的套件維護者不要修改它，以便檢查原來的檔案與整合後的檔案 (比較校驗碼就知道) 並且尊重其他著者的意願。
			</para>
			 <para>
				<filename>.debian.tar.gz</filename> 包括 Debian 維護者做的所有修訂，特別是新增至 <filename>debian</filename> 目錄執行 Debian 套件的指令。
			</para>
			 <sidebar> <title><emphasis>工具</emphasis> 解壓縮原始套件</title>
			 <indexterm>
				<primary><command>dpkg-source</command></primary>
			</indexterm>
			 <indexterm>
				<primary>解壓縮，原始套件</primary>
			</indexterm>
			 <indexterm>
				<primary>解壓縮，原始套件</primary>
			</indexterm>
			 <indexterm>
				<primary>拆包</primary>
				<secondary>原始套件</secondary>
			</indexterm>
			 <para>
				使用原始套件時，您可使用 <command>dpkg-source</command> 指令 (從 <emphasis role="pkg">dpkg-dev</emphasis> 套件取得) 解壓縮它：
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>dpkg-source -x package_0.7-1.dsc</userinput></screen>
			 <para>
				可以使用 <command>apt-get</command> 下載原始套件並立即拆包它。需使用適當的 <literal>deb-src</literal> 位於 <filename>/etc/apt/sources.list</filename> 檔案內，然而 (詳情見 <xref linkend="sect.apt-sources.list" />)。用於列出原始套件的 “來源” (就是收藏原始套件的伺服器)。
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>apt-get source <replaceable>套件</replaceable></userinput></screen>
			 </sidebar>
		</section>
		 <section>
			<title>Debian 內的使用</title>
			 <para>
				Debian 的基礎是原始套件。Debian 所有的套件都從原始套件而來，對套件的修改也是針對原始套件。執行套件出了問題後，Debian 維護者修改原始套件後，再編譯為執行套件。維護者的工作成果都在 Debian 的原始套件內：您可輕易地回到原始套件找出源頭。
			</para>
			 <para>
				Debian 伺服器收到新版套件 (原始套件或執行套件) 時，原始套件是最重要的。原始套件被支援 Debian 的多種架構機器編譯。發展者同時送出指定架構 (通常是 i386 或 amd64) 的多個執行套件，其實一點都不重要，因為可以自動生成該等執行套件。
			</para>

		</section>

	</section>
	 <section id="sect.manipulating-packages-with-dpkg">
		<title>以 <command>dpkg</command> 管理套件</title>
		 <indexterm>
			<primary><command>dpkg</command></primary>
		</indexterm>
		 <para>
			<command>dpkg</command> 是系統層面處理 Debian 套件的基礎指令。若您有 <filename>.deb</filename> 套件，可以用 <command>dpkg</command> 安裝及分析其內容。但此指令祗能看到 Debian 世界的部份內容：它知道系統安裝那些套件、指令列給了那些參數，但不知道還有那些可用的套件。因此，沒有相依性就完了。<command>apt</command> 之類的工具，則可產生相依性清單，儘量自動安裝套件。
		</para>
		 <sidebar> <title><emphasis>說明</emphasis> <command>dpkg</command> 或 <command>apt</command>?</title>
		 <para>
			<command>dpkg</command> 應視為系統工具 (背景) 之一，而 <command>apt</command> 則是較傾向使用者的工具，可克服前者的限制。這些工具各有其限制，共同解決特定的作業。
		</para>
		 </sidebar> <section>
			<title>安裝套件</title>
			 <indexterm>
				<primary>安裝</primary>
				<secondary>套件安裝</secondary>
			</indexterm>
			 <indexterm>
				<primary>套件</primary>
				<secondary>安裝</secondary>
			</indexterm>
			 <para>
				首先，<command>dpkg</command> 是安裝 Debian 已經可用套件的工具 (因為不需下載任何東西)。我們使用它的 <literal>-i</literal> 或 <literal>--install</literal> 選項。
			</para>
			 <example>
				<title>以 <command>dpkg</command> 安裝套件</title>
				 
<screen role="scale">
<computeroutput># </computeroutput><userinput>dpkg -i man-db_2.7.0.2-5_amd64.deb</userinput>
<computeroutput>(讀取資料庫安裝的 ... 86425 檔案與資料夾。)
準備打開 man-db_2.7.0.2-5_amd64.deb ...
打開 man-db (2.7.0.2-5) over (2.7.0.2-4) ...
設定 man-db (2.7.0.2-5) ...
更新使用頁面的資料庫 ...
Processing triggers for mime-support (3.58) ...</computeroutput></screen>

			</example>
			 <para>
				我們可看到 <command>dpkg</command> 執行的不同階段；因此，我們知道可能發生錯誤的時刻。安裝可能分為兩個階段；解壓縮、組態。<command>apt-get</command> 用到此等階段，限制被 <command>dpkg</command> 調用的內容 (因為調用的過程極為費力，必須載入記憶體的資料庫，尤其是已經被安裝清單內的)。
			</para>
			 <example>
				<title>分開解壓與組態</title>
				 
<screen role="scale">
<computeroutput># </computeroutput><userinput>dpkg --unpack man-db_2.7.0.2-5_amd64.deb</userinput>
<computeroutput>(Reading database ... 86425 files and directories currently installed.)
Preparing to unpack man-db_2.7.0.2-5_amd64.deb ...
Unpacking man-db (2.7.0.2-5) over (2.7.0.2-5) ...
Processing triggers for mime-support (3.58) ...
# </computeroutput><userinput>dpkg --configure man-db</userinput>
<computeroutput>Setting up man-db (2.7.0.2-5) ...
Updating database of manual pages ...
</computeroutput></screen>

			</example>
			 <indexterm>
				<primary>包裝</primary>
				<secondary>解壓</secondary>
			</indexterm>
			 <indexterm>
				<primary>解壓</primary>
				<secondary>執行套件</secondary>
			</indexterm>
			 <para>
				<command>dpkg</command> 安裝套件時偶而失敗並送回錯誤的訊息；若使用者要求忽略該等訊息，就能送出警示；這就是 <literal>--force-*</literal> 選項的用途。<command>dpkg --force-help</command> 命令，或此命令的文件，將提供完整的選項。最常發生的錯誤，遲早每個人都會碰到，就是檔案衝突。已被其他套件安裝使用的檔案，另個套件同時需要用到它時，<command>dpkg</command> 會於安裝時再次使手它。此時出現以下的訊息：
			</para>
			 
<screen>
<computeroutput>Unpacking libgdm (from .../libgdm_3.8.3-2_amd64.deb) ...
dpkg: 處理 /var/cache/apt/archives/libgdm_3.8.3-2_amd64.deb (--unpack) 時發生錯誤:
 試圖覆寫 '/usr/bin/gdmflexiserver'，也同時在套件 gdm3 3.4.1-9 內</computeroutput></screen>
			 <para>
				碰到此情況，若您認為取代此檔案不會對系統的穩定產生重大的風險 (通常如此)，您可使用選項 <literal>--force-overwrite</literal>，告訴 <command>dpkg</command> 忽略此錯誤並覆寫該檔案。
			</para>
			 <para>
				<literal>--force-*</literal> 有很多選項，祗有 <literal>--force-overwrite</literal> 是固定使用的。這些選項祗存在於極為特殊的情況，最好是儘量不要碰它以尊重套件本身的機制。別忘了，這些機制確保系統的一致性與穩定性。
			</para>
			 <sidebar> <title><emphasis>注意</emphasis> 有效使用 <literal>--force-*</literal></title>
			 <indexterm>
				<primary>破碎的相依性</primary>
			</indexterm>
			 <para>
				若不小心使用 <literal>--force-*</literal> 的選項，可能造成 APT 命令家族拒絕運作的困境。在相依性不足或衝突的情況下，使用部份選項後，仍可安裝該等套件。結果就是相依性不足的不一致系統，APT 命令將拒絕執行任何工作，直到系統恢復一致 (通常包括安裝遺失的相依套件或移除問題套件)。通常出現以下的訊息，安裝新版 <emphasis role="pkg">rdesktop</emphasis> 時忽略其對新版 <emphasis role="pkg">libc6</emphasis> 的相依性：
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>apt full-upgrade
</userinput><computeroutput>[...]
You might want to run 'apt-get -f install' to correct these.
The following packages have unmet dependencies:
  rdesktop: Depends: libc6 (&gt;= 2.5) but 2.3.6.ds1-13etch7 is installed
E: Unmet dependencies. Try using -f.</computeroutput></screen>
			 <para>
				確信其分析結果的勇敢管理者，可能選擇忽略使用 <literal>--force-*</literal> 選項時發生的相依性問題與衝突。結果是，想要繼續使用 <command>apt</command> 或 <command>aptitude</command> 的話，他們必須先編輯 <filename>/var/lib/dpkg/status</filename> 以刪除/修改相依性問題或衝突。
			</para>
			 <para>
				這是一種醜陋的黑客行為，除了極為必要的情況，否則不該發生。比較常見的手法是，重新編譯有問題的套件 (見 <xref linkend="sect.rebuilding-package" />) 或從 <literal>stable-backports</literal> 裡 (see <xref linkend="sect.backports" />)，使用新版本 (可能已修復該問題) 的套件。
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>移除套件</title>
			 <indexterm>
				<primary>移除套件</primary>
			</indexterm>
			 <indexterm>
				<primary>清除套件</primary>
			</indexterm>
			 <indexterm>
				<primary>套件</primary>
				<secondary>移除</secondary>
			</indexterm>
			 <indexterm>
				<primary>套件</primary>
				<secondary>清除</secondary>
			</indexterm>
			 <para>
				使用 <command>dpkg</command> 加上 <literal>-r</literal> 或 <literal>--remove</literal> 選項，再加上套件名稱，就可移除該套件。然而，這種方式的移除並不完整：仍保留所有的組態檔、維護腳本、記錄檔案 (系統記錄檔) 及該套件的其他使用者資料。這種方式是停用程式，仍可以相同的組態快速地再安裝回來。完全移除該套件的所有相關檔案，應使用 <literal>-P</literal> 或 <literal>--purge</literal> 選項，再加上套件名稱。
			</para>
			 <example>
				<title>移除與清除 <emphasis role="pkg">debian-cd</emphasis> 套件</title>
				 
<screen><computeroutput># </computeroutput><userinput>dpkg -r debian-cd</userinput>
<computeroutput>(Reading database ... 97747 files and directories currently installed.)
Removing debian-cd (3.1.17) ...
# </computeroutput><userinput>dpkg -P debian-cd</userinput>
<computeroutput>(Reading database ... 97401 files and directories currently installed.)
Removing debian-cd (3.1.17) ...
Purging configuration files for debian-cd (3.1.17) ...</computeroutput></screen>

			</example>

		</section>
		 <section>
			<title>查詢 <command>dpkg</command> 的資料庫與檢查 <filename>.deb</filename> 檔案</title>
			 <indexterm>
				<primary>套件</primary>
				<secondary>狀態</secondary>
			</indexterm>
			 <indexterm>
				<primary>套件</primary>
				<secondary>檔案清單</secondary>
			</indexterm>
			 <indexterm>
				<primary>套件</primary>
				<secondary>內容的檢視</secondary>
			</indexterm>
			 <sidebar> <title><emphasis>回到</emphasis> 選項語法</title>
			 <para>
				“長” 版 (一個或多個字，前置兩個連結號) 與 “短” 版 (一個字母，通常是長版字的第一個字母，前置一個連結號) 套件都有該等選項。這是 POSIX 標準常見的用法。
			</para>
			 </sidebar> <para>
				做結論前，我們將學習查詢內部資料庫以獲取資訊的 <command>dpkg</command> 選項。先給長版的選項再給對應的短版選項 (其參數是一樣的) 以 <literal>--listfiles <replaceable>套件</replaceable></literal> (或 <literal>-L</literal>) 為例，列出該套件安裝的檔案清單；<literal>--search <replaceable>檔案</replaceable></literal> (或 <literal>-S</literal>)，尋找包括該檔案的套性；<literal>--status <replaceable>套件</replaceable></literal> (或 <literal>-s</literal>)，顯示該套件的標頭；<literal>--list</literal> (或 <literal>-l</literal>)，顯示該系統內套件清單與安裝狀態；<literal>--contents <replaceable>file.deb</replaceable></literal> (或 <literal>-c</literal>)，列出 Debian 指定套件清單；<literal>--info<replaceable> file.deb </replaceable></literal> (或 <literal>-I</literal>)，列出該套件的標頭。
			</para>
			 <example>
				<title><command>dpkg</command> 的各種查詢</title>
				 
<screen role="scale" width="80">
<computeroutput>$ </computeroutput><userinput>dpkg -L base-passwd</userinput>
<computeroutput>/.
/usr
/usr/sbin
/usr/sbin/update-passwd
/usr/share
/usr/share/lintian
/usr/share/lintian/overrides
/usr/share/lintian/overrides/base-passwd
/usr/share/doc-base
/usr/share/doc-base/users-and-groups
/usr/share/base-passwd
/usr/share/base-passwd/group.master
/usr/share/base-passwd/passwd.master
/usr/share/man
/usr/share/man/pl
/usr/share/man/pl/man8
/usr/share/man/pl/man8/update-passwd.8.gz
/usr/share/man/ru
/usr/share/man/ru/man8
/usr/share/man/ru/man8/update-passwd.8.gz
/usr/share/man/ja
/usr/share/man/ja/man8
/usr/share/man/ja/man8/update-passwd.8.gz
/usr/share/man/fr
/usr/share/man/fr/man8
/usr/share/man/fr/man8/update-passwd.8.gz
/usr/share/man/es
/usr/share/man/es/man8
/usr/share/man/es/man8/update-passwd.8.gz
/usr/share/man/de
/usr/share/man/de/man8
/usr/share/man/de/man8/update-passwd.8.gz
/usr/share/man/man8
/usr/share/man/man8/update-passwd.8.gz
/usr/share/doc
/usr/share/doc/base-passwd
/usr/share/doc/base-passwd/users-and-groups.txt.gz
/usr/share/doc/base-passwd/changelog.gz
/usr/share/doc/base-passwd/copyright
/usr/share/doc/base-passwd/README
/usr/share/doc/base-passwd/users-and-groups.html
$ </computeroutput><userinput>dpkg -S /bin/date</userinput>
<computeroutput>coreutils: /bin/date
$ </computeroutput><userinput>dpkg -s coreutils</userinput>
<computeroutput>Package: coreutils
Essential: yes
Status: install ok installed
Priority: required
Section: utils
Installed-Size: 13855
Maintainer: Michael Stone &lt;mstone@debian.org&gt;
Architecture: amd64
Multi-Arch: foreign
Version: 8.23-3
Replaces: mktemp, realpath, timeout
Pre-Depends: libacl1 (&gt;= 2.2.51-8), libattr1 (&gt;= 1:2.4.46-8), libc6 (&gt;= 2.17), libselinux1 (&gt;= 2.1.13)
Conflicts: timeout
Description: GNU core utilities
 This package contains the basic file, shell and text manipulation
 utilities which are expected to exist on every operating system.
 .
 Specifically, this package includes:
 arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp
 csplit cut date dd df dir dircolors dirname du echo env expand expr
 factor false flock fmt fold groups head hostid id install join link ln
 logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt
 od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm
 rmdir runcon sha*sum seq shred sleep sort split stat stty sum sync tac
 tail tee test timeout touch tr true truncate tsort tty uname unexpand
 uniq unlink users vdir wc who whoami yes
Homepage: http://gnu.org/software/coreutils
$ </computeroutput><userinput>dpkg -l 'b*'</userinput>
<computeroutput>Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                    Version          Architecture     Description
+++-=======================-================-================-====================================================
un  backupninja             &lt;none&gt;           &lt;none&gt;           (no description available)
ii  backuppc                3.3.0-2          amd64            high-performance, enterprise-grade system for backin
un  base                    &lt;none&gt;           &lt;none&gt;           (no description available)
un  base-config             &lt;none&gt;           &lt;none&gt;           (no description available)
ii  base-files              8                amd64            Debian base system miscellaneous files
ii  base-passwd             3.5.37           amd64            Debian base system master password and group files
[...]
$ </computeroutput><userinput>dpkg -c /var/cache/apt/archives/gnupg_1.4.18-6_amd64.deb</userinput>
<computeroutput>drwxr-xr-x root/root         0 2014-12-04 23:03 ./
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/udev/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./lib/udev/rules.d/
-rw-r--r-- root/root      2711 2014-12-04 23:03 ./lib/udev/rules.d/60-gnupg.rules
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/lib/
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/lib/gnupg/
-rwxr-xr-x root/root     39328 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_ldap
-rwxr-xr-x root/root     92872 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_hkp
-rwxr-xr-x root/root     47576 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_finger
-rwxr-xr-x root/root     84648 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_curl
-rwxr-xr-x root/root      3499 2014-12-04 23:03 ./usr/lib/gnupg/gpgkeys_mailto
drwxr-xr-x root/root         0 2014-12-04 23:03 ./usr/bin/
-rwxr-xr-x root/root     60128 2014-12-04 23:03 ./usr/bin/gpgsplit
-rwxr-xr-x root/root   1012688 2014-12-04 23:03 ./usr/bin/gpg
[...]
$ </computeroutput><userinput>dpkg -I /var/cache/apt/archives/gnupg_1.4.18-6_amd64.deb</userinput>
<computeroutput> new debian package, version 2.0.
 size 1148362 bytes: control archive=3422 bytes.
    1264 bytes,    26 lines      control              
    4521 bytes,    65 lines      md5sums              
     479 bytes,    13 lines   *  postinst             #!/bin/sh
     473 bytes,    13 lines   *  preinst              #!/bin/sh
 Package: gnupg
 Version: 1.4.18-6
 Architecture: amd64
 Maintainer: Debian GnuPG-Maintainers &lt;pkg-gnupg-maint@lists.alioth.debian.org&gt;
 Installed-Size: 4888
 Depends: gpgv, libbz2-1.0, libc6 (&gt;= 2.15), libreadline6 (&gt;= 6.0), libusb-0.1-4 (&gt;= 2:0.1.12), zlib1g (&gt;= 1:1.1.4)
 Recommends: gnupg-curl, libldap-2.4-2 (&gt;= 2.4.7)
 Suggests: gnupg-doc, libpcsclite1, parcimonie, xloadimage | imagemagick | eog
 Section: utils
 Priority: important
 Multi-Arch: foreign
 Homepage: http://www.gnupg.org
 Description: GNU privacy guard - a free PGP replacement
  GnuPG is GNU's tool for secure communication and data storage.
  It can be used to encrypt data and to create digital signatures.
  It includes an advanced key management facility and is compliant
  with the proposed OpenPGP Internet standard as described in RFC 4880.
[...]</computeroutput></screen>

			</example>
			 <sidebar> <title><emphasis>進一步</emphasis> 版本的比較</title>
			 <indexterm>
				<primary>版本，比較</primary>
			</indexterm>
			 <indexterm>
				<primary>比較版本</primary>
			</indexterm>
			 <para>
				因為 <command>dpkg</command> 是處理 Debian 套件的程式，它也能夠邏輯地比較版本編號。所以有 <literal>--compare-versions</literal> 選項，以外部程式使用它 (尤其是被 <command>dpkg</command> 本身執行的組態腳本)。這個選項需要三個參數：版本編號、比較運算元、以及第二個版本編號。可能的運算元為 <literal>lt</literal> (小於)、<literal>le</literal> (大於或等於)、<literal>eq</literal> (等於)、<literal>ne</literal> (不等於)、<literal>ge</literal> (大於或等於)、以及 <literal>gt</literal> (大於)。若比較結果正確，<command>dpkg</command> 送回 0 (成功)；若不正確，則送回 0 以外的數值 (表示失敗)。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>dpkg --compare-versions 1.2-3 gt 1.1-4</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>0
$ </computeroutput><userinput>dpkg --compare-versions 1.2-3 lt 1.1-4</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>1
$ </computeroutput><userinput>dpkg --compare-versions 2.6.0pre3-1 lt 2.6.0-1</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>1</computeroutput></screen>
			 <para>
				注意前例最後一個比較的失敗：<command>dpkg</command>、<literal>pre</literal>，表示為預釋出版，沒有特別的意義，此程式以比較數字版本 (a &lt; b &lt; c ...) 相同的方式比較字順版本。所以，“<literal>0pre3</literal>” 大於 “<literal>0</literal>”。我們以毛毛蟲 “<literal>~</literal>” 表示該套件的預釋出版：
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>dpkg --compare-versions 2.6.0~pre3-1 lt 2.6.0-1</userinput>
<computeroutput>$ </computeroutput><userinput>echo $?</userinput>
<computeroutput>0</computeroutput></screen>
			 </sidebar>
		</section>
		 <section>
			<title><command>dpkg</command> 的日誌檔</title>
			 <para>
				<command>dpkg</command> 把所有的交易記錄存在名為 <filename>/var/log/dpkg.log</filename> 的日誌檔。這個日誌檔的內容頗為詳盡且囉唆，記錄套件被 <command>dpkg</command> 處理的每個程序。追蹤 dpkg 的每個作為之外，日誌檔還保留系統發展的記錄：可以覆查每個套件的安裝與移除步驟，對於瞭解最近的變動極有幫助。此外，還記錄所有的版本，可以交互檢查 <filename>changelog.Debian.gz</filename> 的內容，查看有問題的套件或線上的錯誤報告。
			</para>

		</section>
		 <section id="sect.multi-arch">
			<title>多架構支援</title>
			 <indexterm>
				<primary>多架構</primary>
			</indexterm>
			 <indexterm>
				<primary>架構</primary>
				<secondary>多架構支援</secondary>
			</indexterm>
			 <para>
				Debian 套件在其控制資訊內有個 <literal>Architecture</literal> 欄位。其內容為 “<literal>all</literal>” (表示該套件不受架構限制) 或指出其適用的架構 (如 “amd64”、“armhf”、…)。以後例而言，主機的架構符合後，<command>dpkg</command> 才開始安裝該套件，並送回 <command>dpkg --print-architecture</command>。
			</para>
			 <para>
				此限制確保使用者不會用到不合其架構的執行檔。除了可以執行多個架構的電腦之外，不論在地的 ( “amd64“ 系統可執行 “i386” 執行檔) 或虛擬的電腦都可找到適用的套件。
			</para>
			 <section>
				<title>啟用多架構</title>
				 <para>
					<command>dpkg</command> 的多架構支授允許使用者限制 “怪異的架構” 安裝在現行的系統上。以下例的 <command>dpkg --add-architecture</command> 就能做到。有個對應的 <command>dpkg --remove-architecture</command> 指令可以除去怪異的架構，不過祗發生於無套件可用時。
				</para>
				 
<screen>
<computeroutput># </computeroutput><userinput>dpkg --print-architecture</userinput>
<computeroutput>amd64
# </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput># </computeroutput><userinput>dpkg -i gcc-4.9-base_4.9.1-19_armhf.deb</userinput>
<computeroutput>dpkg: error processing archive gcc-4.9-base_4.9.1-19_armhf.deb (--install):
 package architecture (armhf) does not match system (amd64)
Errors were encountered while processing:
 gcc-4.9-base_4.9.1-19_armhf.deb
# </computeroutput><userinput>dpkg --add-architecture armhf</userinput>
<computeroutput># </computeroutput><userinput>dpkg --add-architecture armel</userinput>
<computeroutput># </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput>armhf
armel
# </computeroutput><userinput>dpkg -i gcc-4.9-base_4.9.1-19_armhf.deb</userinput>
<computeroutput>Selecting previously unselected package gcc-4.9-base:armhf.
(Reading database ... 86425 files and directories currently installed.)
Preparing to unpack gcc-4.9-base_4.9.1-19_armhf.deb ...
Unpacking gcc-4.9-base:armhf (4.9.1-19) ...
Setting up gcc-4.9-base:armhf (4.9.1-19) ...
# </computeroutput><userinput>dpkg --remove-architecture armhf</userinput>
<computeroutput>dpkg: error: cannot remove architecture 'armhf' currently in use by the database
# </computeroutput><userinput>dpkg --remove-architecture armel</userinput>
<computeroutput># </computeroutput><userinput>dpkg --print-foreign-architectures</userinput>
<computeroutput>armhf</computeroutput></screen>
				 <sidebar> <title><emphasis>說明</emphasis> APT 的多架構支援</title>
				 <para>
					dpkg 完成組態支援怪異架構後，APT 自動偵測且在升級過程中下載對應的 <filename>套件</filename> 檔案。
				</para>
				 <para>
					可以使用 <command>apt install <replaceable>套件</replaceable>:<replaceable>架構</replaceable></command> 指令安裝怪異套件。
				</para>
				 </sidebar> <sidebar> <title><emphasis>實務</emphasis> 在 amd64 使用專屬的 i386 執行檔</title>
				 <para>
					多架構的案例不少，但最常見的是在 64 位元系統 (amd64) 安裝 32 位元執行檔 (i386)，尤其是若干專屬應用程式 (如 Skype) 祗提供 32 位元版本。
				</para>
				 </sidebar>
			</section>
			 <section>
				<title>多架構相關的改變</title>
				 <para>
					為了讓多架構真正可用，必須重新包裝程式庫且移至指定架構的資料夾，才能夠有多個複本 (針對不同架構) 供安裝使用。升級後的套件以 “<literal>Multi-Arch: same</literal>” 標頭欄位告知套件系統，可以安全地安裝各種架構的套件 (可滿足同個架構套件的相依性)。多架構從 Debian <emphasis role="distribution">Wheezy</emphasis> 登場之後，仍有部份程式庫未轉換。
				</para>
				 
<screen><computeroutput>$ </computeroutput><userinput>dpkg -s gcc-4.9-base
</userinput><computeroutput>dpkg-query: error: --status needs a valid package name but 'gcc-4.9-base' is not: ambiguous package name 'gcc-4.9-base' with more than one installed instance

Use --help for help about querying packages.
$ </computeroutput><userinput>dpkg -s gcc-4.9-base:amd64 gcc-4.9-base:armhf | grep ^Multi
</userinput><computeroutput>Multi-Arch: same
Multi-Arch: same
$ </computeroutput><userinput>dpkg -L libgcc1:amd64 |grep .so
</userinput><computeroutput>/lib/x86_64-linux-gnu/libgcc_s.so.1
$ </computeroutput><userinput>dpkg -S /usr/share/doc/gcc-4.9-base/copyright
</userinput><computeroutput>gcc-4.9-base:amd64, gcc-4.9-base:armhf: /usr/share/doc/gcc-4.9-base/copyright
</computeroutput></screen>
				 <para>
					<literal>Multi-Arch: same</literal> 套件的名稱必須符合其架構才能被明確的指認出來。也可能以相同的套件在其他情況下共享檔案；共享時，<command>dpkg</command> 確認所有套件的每個位元都相同。最後但不是最不重要，套件的所有實例必須使用相同的版本。也必須一起更新。
				</para>
				 <para>
					多架構支援帶來處理相依性的有趣挑戰。滿足相依性的套件標示為 “<literal>Multi-Arch: foreign</literal>” 或宣告其匹配架構的相依性 (在這種相依性解決過程中，假設架構獨立的套件與主機不同)。相依性可能被弱化以允許納入其他架構，以 <literal><replaceable>套件</replaceable>:any</literal> 語法，但怪異套件祗需滿足一個相依性，如果標示為 “<literal>Multi-Arch: allowed</literal>”。
				</para>

			</section>

		</section>

	</section>
	 <section id="sect.coexistence-with-other-packaging-systems">
		<title>與其他打包系統共存</title>
		 <indexterm>
			<primary>RPM</primary>
		</indexterm>
		 <indexterm>
			<primary>Red Hat Package Manager</primary>
		</indexterm>
		 <indexterm>
			<primary><command>外來</command></primary>
		</indexterm>
		 <para>
			Debian 套件不是自由軟體世界唯一的軟體套件。主要的競爭者是紅帽發行版的 RPM 格式及其衍生者。紅帽是極為風行、商業化的發行版。第三方軟體極喜歡使用 RPM 套件而不是 Debian。
		</para>
		 <para>
			在此情況下，Debian 套件也有能夠處理 RPM 套件的 <command>rpm</command> 程式，因此，Debian 也能使用此等格式套件。不過，要小心提取該等套件的資訊或確認其正當性。因此，在 Debian 系統過度使用 <command>rpm</command> 安裝 RPM 套件，有點麻煩；RPM 使用自己的資料庫，不理會原生軟體 (諸如 <command>dpkg</command>) 的資料庫。無法保證這兩種套件系統並存的穩定性。
		</para>
		 <para>
			換句話說，<emphasis role="pkg">alien</emphasis> 工具可以把 RPM 套件與 Debian 套件互相轉換。
		</para>
		 <sidebar> <title><emphasis>社群</emphasis> 鼓勵採用 <filename>.deb</filename></title>
		 <para>
			若經常使用 <command>alien</command> 程式安裝 RPM 套件，應告訴該等套件的提供者，和藹地表達您希望能有 <filename>.deb</filename> 格式的願望。套件的格式不是全部：<filename>.deb</filename> 套件以 <command>alien</command> 建立或專為 Debian 建立，或由 Ubuntu 之類衍生版取得，其品質與整合性，可能不如來自專為 Debian <emphasis role="distribution">Jessie</emphasis> 所做的套件。
		</para>
		 </sidebar> 
<screen>
<computeroutput>$ </computeroutput><userinput>fakeroot alien --to-deb phpMyAdmin-2.0.5-2.noarch.rpm</userinput> 
<computeroutput>phpmyadmin_2.0.5-2_all.deb generated
$ </computeroutput><userinput>ls -s phpmyadmin_2.0.5-2_all.deb</userinput>
<computeroutput>  64 phpmyadmin_2.0.5-2_all.deb</computeroutput></screen>
		 <para>
			此例極為簡單。然而，您必須知道不需任何相依性資訊就能產生套件，兩種套件格式並不必然有系統性的關係。管理者必須以手動方式確保轉換過的套件能夠正確運作，這就是 Debian 產生的套件能夠避免此種可能。幸運的是，Debian 擁有軟體套件各種版本的資料庫，想要的都能找到。
		</para>
		 <para>
			查看 <command>alien</command> 指令的 man 頁面，您將注意到此程式也處理其他套件格式，尤其是 Slackware 發行版 (即簡單的 <filename>tar.gz</filename> 壓縮檔) 使用的套件格式。
		</para>
		 <para>
			使用 <command>dpkg</command> 工具可穩定地部署軟體維護 Debian 的名聲。接著討論的 APT 工具組，保留這些優點，而且讓管理者從必要且複雜的套件管理工作中解放出來。
		</para>

	</section>
</chapter>

