<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course" lang="nb-NO">
	<appendixinfo>
		 <keywordset>
			<keyword>BIOS</keyword>
			 <keyword>Kjerne</keyword>
			 <keyword>Unix</keyword>
			 <keyword>Prosess</keyword>
			 <keyword>Hierarki</keyword>
			 <keyword>Grunnleggende kommandoer</keyword>

		</keywordset>

	</appendixinfo>
	 <title>Kort støttekurs</title>
	 <highlights> <para>
		Selv om denne boken i hovedsak retter seg mot administratorer og «superbrukere», så ønsker vi ikke å ekskludere motiverte nybegynnere. Dette vedlegget er derfor et krasjkurs som beskriver de grunnleggende konseptene involvert i håndtering av en Unix-datamaskin.
	</para>
	 </highlights> <section id="sect.shell-and-basic-commands">
		<title>Skall og grunnleggende kommandoer</title>
		 <para>
			I Unix-verden må enhver administrator bruke kommandolinjen før eller senere; for eksempel når systemet ikke starter som det skal, og kun tilbyr en redningsmodus med kommandolinje. Det å være i stand til å håndtere et slikt grensesnitt er dermed grunnleggende overlevelseskunnskap i slike tilfeller.
		</para>
		 <sidebar> <title><emphasis>HURTIGVISNING</emphasis> Oppstart av kommandotolkeren</title>
		 <para>
			Et kommandolinjemiljø kan kjøres fra det grafiske skrivebordet med et program som kalles en «terminal». I GNOME kan du starte det fra «Aktivitets»-oversikten (som du får når du beveger musen i øverste venstre hjørne av skjermen) ved å skrive de første bokstavene i navnet på programmet. I KDE vil du finne det i <menuchoice><guimenu>K</guimenu> <guisubmenu>Applikasjoner</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice>-menyen.
		</para>
		 </sidebar> <para>
			Denne delen gir bare en kort oversikt over kommandoene. Alle har mange alternativer som ikke er beskrevet her, så vis gjerne til den rikholdige dokumentasjon på de respektive manualsidene.
		</para>
		 <section>
			<title>Å surfe i mappetreet og operativsystemet</title>
			 <para>
				Så snart en sesjon er åpen, viser <command>pwd</command>-kommandoen (som står for <emphasis>print working directory</emphasis>) den gjeldende plasseringen i filsystemet. Den nåværende mappen endres med <command>cd <replaceable>mappe</replaceable></command>-kommandoen, (<command>cd</command> står for <emphasis>endre mappe</emphasis>). Den overordnede mappen er alltid kalt <literal>..</literal> (to punkter), mens den gjeldende mappen også er kjent som <literal>.</literal> (ett punkt). <command>ls</command>-kommandoen åpner for å <emphasis>liste</emphasis> innholdet i en mappe/katalog. Hvis ingen parametere er angitt, opererer den på den gjeldende mappen.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>cd Desktop</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd .</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates
Documents  Music      Public    Videos</computeroutput>
</screen>
			 <para>
				En ny mappe kan lages med <command>mkdir <replaceable>mappe</replaceable></command>, og en eksisterende (tom) mappe kan fjernes med <command>rmdir <replaceable>mappe</replaceable></command>. <command>mv</command>-kommando åpner for <emphasis>flytting</emphasis>, og/eller for å døpe om filer og mapper; <emphasis>flytte</emphasis> en fil skjer med <command>rm <replaceable>fil</replaceable></command>.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public    test
$ </computeroutput><userinput>mv test new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  new       Public     Videos
Documents  Music      Pictures  Templates
$ </computeroutput><userinput>rmdir new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public</computeroutput>
</screen>

		</section>
		 <section>
			<title>Å vise og modifisere tekstfiler</title>
			 <para>
				Kommandoen <command>cat <replaceable>fil</replaceable></command> (med formål å <emphasis>sette sammen</emphasis> filer til standard ut-enheten) leser en fil, og viser innholdet på terminalen. Hvis filen er for stor til å passe til en skjerm, kan du bruke <command>less</command> (eller <command>more</command>) for å vise den side for side.
			</para>
			 <para>
				Kommandoen <command>editor</command> starter en tekstredigerer (slik som <command>vi</command> eller <command>nano</command>), og tillater å lage, modifisere og lese tekstfiler. De enkleste filene kan noen ganger opprettes direkte fra kommandokonsollen/-linjen takket være omdirigering: <command>echo «<replaceable>tekst</replaceable>» &gt;<replaceable>fil</replaceable></command> lager en fil med navnet <replaceable>fil</replaceable> med «<replaceable>tekst</replaceable>» som sitt innhold. Å legge til en linje på slutten av denne filen er også mulig, med en kommando som <command>echo «<replaceable>linje</replaceable>» &gt;&gt;<replaceable>file</replaceable></command>. Merk <literal>&gt;&gt;</literal> i dette eksemplet.
			</para>

		</section>
		 <section>
			<title>Søk etter filer og i filer</title>
			 <para>
				Kommandoen <command>find <replaceable>mappe</replaceable> <replaceable>kriterier</replaceable></command> ser etter filer i hierarkiet under <replaceable>mappe</replaceable> etter flere kriterier. Det mest brukte er kriteriet <literal>-name <replaceable>navn</replaceable></literal>, som tillater å lete etter en fil med det navnet.
			</para>
			 <para>
				Kommandoen <command>grep <replaceable>uttrykket</replaceable> <replaceable>filer</replaceable></command> søker igjennom innholdet i filene, og trekker ut de linjene som samsvarer med det regulære uttrykket (se sidestolpe <xref linkend="sidebar.regexp" />). Å legge til <literal>-r</literal>-alternativet muliggjør at et gjentakende søk på alle filene i katalogen sendes som et parameter. Dette gjør det mulig å se etter en fil når bare en del av innholdet er kjent.
			</para>

		</section>
		 <section>
			<title>Å håndtere prosesser</title>
			 <para>
				Kommandoen <command>ps aux</command> viser prosessene som kjører og hjelper å identifisere dem ved å vise sin <emphasis>pid</emphasis> (process id). Så snart <emphasis>pid</emphasis> av en prosess er kjent, kan <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command>-kommandoen sende den et signal (hvis prosessen tilhører den aktuelle brukeren). Flere signaler finnes; de mest brukte er <literal>TERM</literal> (en elegant anmodning om å avslutte) og <literal>KILL</literal> (en tvunget avslutning).
			</para>
			 <para>
				Kommandokonsollet kan også kjøre programmer i bakgrunnen hvis kommandoen er etterfulgt av et «&amp;». Ved å bruke &amp;-tegnet (og-tegnet/et-tegnet (ampersand)), får brukeren umiddelbart tilbake kontroll over skallet, selv om kommandoen fortsatt kjører (skjult for brukeren, som en bakgrunnsprosess). Kommandoen <command>jobs</command> lister prosesser som kjører i bakgrunnen; å kjøre <command>fg %<replaceable>jobbnummer</replaceable></command> (for <emphasis>foreground</emphasis>) gjenopprettes en jobb til forgrunnen. Når en kommando kjører i forgrunnen (enten fordi den ble startet normalt, eller bringes tilbake til forgrunnen med <command>fg</command>), pauser <keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>-tastekombinasjonen prosessen, og gjenopptar kontrollen over kommandolinjen. Prosessen kan deretter restartes i bakgrunnen med <command>bg %<replaceable>jobbnummer</replaceable></command> (for <foreignphrase>background</foreignphrase>).
			</para>

		</section>
		 <section>
			<title>Systeminformasjon: Minne, diskplass, identitet</title>
			 <para>
				Kommandoen <command>free</command> viser informasjon om minne; <command>df</command> (<emphasis>disk free</emphasis>) rapporterer om ledig diskplass på hver av diskene montert i filsystemet. <literal>-h</literal>-valget dens (for <emphasis>human readable (lesbar)</emphasis>) konverterer størrelsene til en mer leselig enhet (vanligvis mebibytes eller gibibytes). På lignende måte støtter <command>free</command>-kommandoen <literal>-m</literal> og <literal>-g</literal>-valgene, og viser dataene dens henholdsvis enten i mebibytes eller i gibibytes.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       used       free     shared    buffers     cached
Mem:       1028420    1009624      18796          0      47404     391804
-/+ buffers/cache:     570416     458004
Swap:      2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda2              9614084   4737916   4387796  52% /
tmpfs                   514208         0    514208   0% /lib/init/rw
udev                     10240       100     10140   1% /dev
tmpfs                   514208    269136    245072  53% /dev/shm
/dev/sda5             44552904  36315896   7784380  83% /home
</computeroutput></screen>
			 <para>
				Kommandoen <command>id</command> viser identiteten til brukeren som kjører økten, sammen med listen over grupper de tilhører. Siden tilgang til noen filer eller enheter kan være begrenset til gruppemedlemmene, kan det være nyttig å sjekke tilgjengelige gruppemedlemskap.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
</screen>

		</section>

	</section>
	 <section id="sect.filesystem-hierarchy">
		<title>Organisering av filsystemhierarkiet</title>
		 <indexterm>
			<primary> Filsystemhierarkiet</primary>
		</indexterm>
		 <section>
			<title>Rotmappen</title>
			 <para>
				Et Debian-system er organisert i tråd med <emphasis>Filesystem Hierarchy Standard</emphasis> (FHS). Denne standarden definerer formålet med hver mappe. For eksempel er toppnivå-mapper beskrevet som følger:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<filename>/bin/</filename>: basisprogrammet;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/boot/</filename>: Linux-kjernen og andre filer som kreves til den tidlige oppstartsprosessen;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/dev/</filename>: filer for enheter;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/etc/</filename>: Oppsettsfiler;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/home/</filename>: brukerens personlige filer;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/lib/</filename>: basisbiblioteker;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/media/*</filename>: monteringspunkter for flyttbare enheter (CD-ROM, USB-nøkler, og så videre);
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/mnt/</filename>: midlertidige monteringspunkter;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/opt/</filename>: ekstra programmer levert av tredjeparter;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/root/</filename>: administrators (rots) personlige filer;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/run/</filename>: omskiftelige kjøretidsdata som ikke vedvarer igjennom oppstarter (ennå ikke inkludert i FHS);
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/sbin/</filename>: systemprogrammer;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/srv/</filename>: data brukt av tjenere på dette systemet;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/tmp/</filename>: midlertidige filer; denne katalogen tømmes ofte ved oppstart;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/usr/</filename>: programmer; denne katalogen er videre inndelt i <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (ifølge samme logikk som i rotkatalogen). Videre inneholder <filename>/usr/share/</filename> arkitekturuavhengige data. <filename>/usr/local/</filename> er ment til å brukes av administrator for å installere programmer manuelt uten å overskrive filer som håndteres av pakkesystemet (<command>dpkg</command>).
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/var/</filename>: variable data som håndteres av nisser. Dette inkluderer loggfiler, køer, utskriftskøer, hurtiglagre og så videre.
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/proc/</filename> og <filename>/sys/</filename> er spesifikke for Linux-kjernen (og ikke en del av FHS). De brukes av kjernen for å eksportere data til brukerområde (se <xref linkend="sect.userspace-presentation" /> og <xref linkend="sect.user-space" /> for forklaringer på dette begrepet).
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section>
			<title>Brukerens hjemmemappe</title>
			 <para>
				Innholdet i en brukers hjemmemappe er ikke standardisert, men det er fortsatt noen få nevneverdige konvensjoner. Den ene er at en brukers hjemmemappe ofte er referert til av en krøllstrek («~»). Det er nyttig å vite fordi kommandokonsollet automatisk erstatter en krøllstrek med riktig katalog (vanligvis <filename>/home/<replaceable>bruker</replaceable>/</filename>).
			</para>
			 <para>
				Tradisjonelt er applikasjonens oppsettsfiler ofte lagret direkte i brukerens hjemmemappe, men filnavnene deres starter vanligvis med et punktum (for eksempel lagrer e-postklient <command>mutt</command> oppsettet i <filename>~/.muttrc</filename>). Merk at filnavn som starter med en prikk er skjult som standard; og <command>ls</command> bare lister dem når <literal>-a</literal>-valget blir brukt, og grafiske fil-håndterere må få beskjed om å vise skjulte filer.
			</para>
			 <para>
				Noen programmer bruker også flere oppsettsfiler organisert i en mappe (for eksempel, <filename>~/.ssh/</filename>). Noen programmer (for eksempel nettleseren Iceweasel) bruker også sin mappe for å lagre et mellomlager med nedlastede data. Dette betyr at disse katalogene kan ende med å bruke mye diskplass.
			</para>
			 <para>
				Disse oppsettsfilene som er lagret direkte i brukerens hjemmekatalog, som ofte kollektivt er referert til som <emphasis>dotfiler</emphasis>, har lenge formert seg til det punktet at disse mappene kan bli ganske rotete. Heldigvis resulterte en innsats gjennomført i fellesskap i regi av FreeDesktop.org-paraplyen, i «XDG Base Directory Specification», en konvensjon (avtale) som tar sikte på å rydde opp i disse filene og mappene. Denne spesifikasjonen sier at oppsettsfiler bør lagres under <filename>~/.config</filename>, hurtiglagerfiler under <filename>~ /.cache</filename>, og applikasjonsdatafiler under <filename>~/.local</filename> (eller undermapper under denne). Denne konvensjonen er langsomt i ferd med å få trekkraft, og flere programmer (spesielt de grafiske) har begynt å følge den.
			</para>
			 <para>
				Grafiske skrivebord viser vanligvis innholdet i <filename>~/Desktop/</filename>-katalogen på skrivebordet (eller hva den riktige oversettelsen er for systemer som ikke er satt opp på engelsk, dvs. det som er synlig på skjermen når alle programmer er lukket eller vises som ikoner).
			</para>
			 <para>
				Til slutt, e-postsystemet lagrer noen ganger innkommende e-poster til en <filename>~/Mail/</filename>-mappe.
			</para>

		</section>

	</section>
	 <section id="sect.computer-layers">
		<title>Datamaskinens indre arbeid: de forskjellige involverte lagene</title>
		 <para>
			En datamaskin er ofte betraktet som noe heller abstrakt, og det ytre, synlige grensesnittet er mye enklere enn den interne kompleksiteten. Slik kompleksitet kommer delvis fra antallet deler som inngår. Imidlertid kan disse delene sees i lag, hvor et lag bare vekselvirker (samhandler) med de umiddelbart over eller under.
		</para>
		 <para>
			En sluttbruker kan klare seg uten å kunne disse detaljene ... så lenge alt fungerer. Når man møter et problem som «Internett fungerer ikke!», er den første tingen å gjøre å identifisere i hvilket lag problemet stammer fra. Fungerer nettverkskortet (hardvare/maskinvaren)? Er det anerkjent av datamaskinen? Ser Linux-kjernen det? Er nettverksparametrene riktig satt opp? Alle disse spørsmålene avgrenser et passende lag, og fokuserer på en potensiell problemkilde.
		</para>
		 <section id="sect.hardware">
			<title>Det nederste laget: maskinvaren</title>
			 <indexterm>
				<primary>IDE</primary>
			</indexterm>
			 <indexterm>
				<primary>SCSI</primary>
			</indexterm>
			 <indexterm>
				<primary>Seriell ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>Parallel ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>Firewire</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <para>
				La oss starte med en grunnleggende påminnelse om at en datamaskin først og fremst er et sett med maskinvareelementer. Det er generelt et hovedkort, med en (eller flere) prosessor(er), endel RAM, enhetskontrollere, og utvidelsesspor for tilleggskort (for andre enhetskontrollere). Mest bemerkelsesverdige blant disse kontrollerne er IDE (Parallel ATA), SCSI og Serial ATA, til å koble til lagringsenheter som harddisker. Andre kontrollere inkluderer USB, som er i stand til å være vert for et stort utvalg enheter (alt fra nettkameraer til termometre, fra tastaturer til hjemmeautomasjonssystemer) og IEEE 1394 (Firewire). Disse kontrollerne tillater ofte tilkobling av flere enheter slik at hele delsystemet håndteres av en kontroller, og derfor vanligvis er kjent som en «buss». Tilvalgskort inkluderer grafikkort (som skjermer kan plugges inn i), lydkort, nettverkskort, og så videre. Noen av hovedkortene har disse funksjonene innebygget, og trenger ikke tilleggskort.
			</para>
			 <sidebar> <title><emphasis>I PRAKSIS</emphasis> Å sjekke at maskinvaren virker</title>
			 <para>
				Å kontrollere at en maskinvaredel virker, kan være vanskelig. På den annen side, å bevise at den noen ganger ikke virker er ganske enkelt.
			</para>
			 <para>
				En harddisk er laget av spinnende plater og bevegelige magnetiske hoder. Når en harddisk er slått på, avgir tallerkenmotoren en karakteristisk svirring. Den avgir også energi som varme. Følgelig er en harddisk som forblir kald og stille, når den slås på, gått i stykker.
			</para>
			 <para>
				Nettverkskort inkluderer ofte lysdioder som viser tilstanden til linken. Hvis en kabel er koblet til, og fører til et fungerende nettverksnav eller -veksler, vil minst én LED være på. Hvis ingen LED lyser opp, er enten kortet selv, nettverksenheten, eller kabelen mellom dem, defekt. Det neste trinnet er derfor å teste hver enkelt komponent.
			</para>
			 <para>
				Noen opsjonskort - spesielt 3D-skjermkort - inkluderer avkjølingsenheter, for eksempel kjøleribber og/eller vifter. Hvis viften ikke spinner selv om kortet er slått på, er det en plausibel forklaring at kortet er overopphetet. Dette gjelder også for hovedprosessoren(e) som er plassert på hovedkortet .
			</para>
			 </sidebar>
		</section>
		 <section id="sect.bios">
			<title>Starteren: BIOS eller UEFI</title>
			 <indexterm>
				<primary>BIOS</primary>
			</indexterm>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>Master Boot Record (MBR)</primary>
			</indexterm>
			 <para>
				På egen hånd er maskinvare ute av stand til å utføre nyttige oppgaver uten et samsvarende dataprogram som kjører den. Kontroll og samspill med maskinvaren er hensikten med operativsystemet og programmene. Disse krever i sin tur funksjonell maskinvare for å kjøre.
			</para>
			 <para>
				Denne symbiosen mellom maskinvare og programvare skjer ikke av seg selv. Når datamaskinen først er slått på, kreves det innledende oppsett. Denne rollen er antatt av BIOS eller UEFI, et dataprogram innebygd i hovedkortet og som kjører automatisk ved oppstart. Den primære oppgaven er å søke etter programvare som det kan overlate kontrollen til. Vanligvis, i BIOS tilfelle, innebærer dette å se etter den første harddisken med en oppstartssektor (også kjent som <emphasis>master boot record</emphasis> eller <acronym>MBR</acronym>), laster oppstartssektoren, og kjører den. Fra da av er BIOS vanligvis ikke involvert (til neste oppstart). I tilfellet med UEFI, innebærer prosessen skanning av disker for å finne en øremerket EFI-partisjon som inneholder ytterligere EFI-programmer for kjøring.
			</para>
			 <sidebar> <title><emphasis>VERKTØY</emphasis> Innstillinger, BIOS/UEFI-oppsettsverktøyet</title>
			 <indexterm>
				<primary><emphasis>Oppsett</emphasis></primary>
			</indexterm>
			 <para>
				BIOS/UEFI inneholder også en programvare som heter Setup, designet for å tillate datamaskinens oppsettsaspekter. Spesielt tillater den å velge hvilke oppstartsenhet som er å foretrekke (for eksempel diskett eller CD-ROM-stasjonen), å sette systemklokken, og så videre. Å starte Setup innebærer vanligvis å trykke en tast ganske snart etter at datamaskinen er slått på. Denne nøkkelen er ofte <keycap>Del</keycap> eller <keycap>Esc</keycap>, noen ganger <keycap>F2</keycap> eller <keycap>F10</keycap>. Mesteparten av tiden blinkes valget på skjermen under oppstart.
			</para>
			 </sidebar> <para>
				Oppstartssektoren (eller EFI-partisjonen), inneholder i sin tur et annet dataprogram, kalt oppstartslaster, med formålet å finne og kjøre et operativsystem. Siden denne oppstartslasteren ikke er innebygd i hovedkortet, men lastet fra disk, kan det være smartere enn BIOS, noe som forklarer hvorfor BIOS ikke laster operativsystemet selv. For eksempel kan oppstartslasteren (ofte GRUB på Linux-systemer) liste tilgjengelige operativsystemer, og be brukeren om å velge en. Vanligvis er et tidsavbrudd og standardvalg gitt. Noen ganger kan brukeren også velge å legge til parametere som skal sendes til kjernen, og så videre. Til slutt blir en kjerne funnet, lastet inn i minnet, og utført.
			</para>
			 <sidebar> <title><emphasis>MERK</emphasis> UEFI, en moderne erstatning for BIOS</title>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>Sikker oppstart</primary>
			</indexterm>
			 <para>
				UEFI er en relativt ny utvikling. De fleste nye datamaskiner vil støtte UEFIs oppstart, men som regel støtter de også BIOS-oppstart samtidig for bakoverkompatibiliteten til operativsystemer som ikke er klare til å bruke UEFI.
			</para>
			 <para>
				Dette nye systemet blir kvitt noen av begrensningene til BIOS-oppstart. Med bruk av en dedikert partisjon, trenger ikke oppstartsladeren lenger spesielle triks for å få plass i en liten <emphasis>master boot record (applikasjonsnivå)</emphasis>, og så oppdage kjernen for å starte opp. Enda bedre, med en passende bygget Linux-kjerne, kan UEFI starte kjernen direkte uten noen mellomledds oppstartslaster. UEFI er også fundamentet for å levere <emphasis>Secure Boot (sikker oppstart)</emphasis>, en teknologi som sikrer at du bare kjører programvare godkjent av din operativsystemleverandør.
			</para>
			 </sidebar> <para>
				BIOS/ EFI er også ansvarlig for å oppdage og initialisere en rekke enheter. Selvfølgelig omfatter dette IDE/SATA-enheter (vanligvis harddisken(e) og CD/DVD-ROM-stasjoner), men også PCI-enheter. Oppdagede enheter blir ofte oppført på skjermen under oppstartsprosessen. Hvis denne listen går for fort, kan du bruke <keycap>Pause</keycap>-nøkkelen til å fryse den lenge nok til å få den lest. Installerte PCI-enheter som ikke vises er et dårlig tegn. I verste fall er enheten defekt. I beste fall er den bare inkompatibel med den gjeldende versjonen av BIOS eller hovedkortet. PCI-spesifikasjoner utvikler seg, og gamle hovedkort er ikke garantert for å håndtere nyere PCI-enheter.
			</para>

		</section>
		 <section id="sect.kernel">
			<title>Kjernen</title>
			 <para>
				Både BIOS/UEFI og oppstartslasteren kjører bare noen få sekunder hver. Nå kommer vi til en programvaredel som kjører i lengre tid, operativsystemkjernen. Denne kjernen tar rollen som en dirigent i et orkester, og sikrer koordinering mellom maskinvare og programvare. Denne rollen innebærer flere oppgaver inkludert: Å kjøre maskinvare, administrere prosesser, brukere og tillatelser, filsystemet, og så videre. Kjernen gir en felles basis for alle andre programmer på systemet.
			</para>

		</section>
		 <section id="sect.userspace-presentation">
			<title>Brukerrommet</title>
			 <para>
				Selv om alt som skjer utenfor kjernen kan bli samlet sammen under «brukerrom», kan vi likevel skille det inn i lag med programvare. Men samhandlingene deres er mer komplekse enn før, og klassifiseringene behøver ikke å være så enkle. Et program bruker ofte biblioteker, som i sin tur berører kjernen, men kommunikasjonen kan også involvere andre programmer, eller til og med mange biblioteker som kontakter hverandre.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-role-and-tasks">
		<title>Noen oppgaver som håndteres av kjernen</title>
		 <section id="sect.hardware-drivers">
			<title>Å drifte maskinvaren</title>
			 <para>
				Kjernen har først og fremst som oppgave å kontrollere maskinvaretilbehøret, oppdage det, slå det på når datamaskinen blir slått på, og så videre. Det gjør dem også tilgjengelige på et høyere nivå programvare med et forenklet programmeringsgrensesnitt, slik at programmene kan dra nytte av enheter uten å måtte bekymre seg om detaljer, slik som hvilken kortplass det valgte kortet er satt inn i. Programgrensesnittet gir også et abstraksjonslag; det tillater for eksempel at programvare for videokonferanser kan bruke et nettkamera uavhengig av merke og modell. Programvaren kan bare bruke grensesnittet <emphasis>Video for Linux</emphasis> (V4L), og kjernen oversetter funksjonspåkallingene i dette grensesnittet til de aktuelle maskinvarekommandoene som trengs når nettkameraet brukes.
			</para>
			 <para>
				<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> Kjernen eksporterer mange detaljer om programvare den finner med <filename>/proc/</filename> og <filename>/sys/</filename>-virtuelle filsystemer. Flere verktøy oppsummerer disse detaljene. Blant dem,<command>lspci</command> (i <emphasis role="pkg">pciutils</emphasis> -pakken) lister PCI-enheter, <command>lsusb</command> (i <emphasis role="pkg">usbutils</emphasis>-pakke) lister USB-enheter, og <command>lspcmcia</command> (i <emphasis role="pkg">pcmciautils</emphasis>-pakken) lister PCMCIA-kort. Disse verktøyene er meget nyttige til å identifisere den eksakte modellen for enheten. Denne identifikasjonen gir også mer presise søk på nettet, noe som i sin tur fører til mer relevant dokumentasjon.
			</para>
			 <example>
				<title>Eksempel på informasjon fra <command>lspci</command> og <command>lsusb</command></title>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>

			</example>
			 <para>
				Disse programmene har et <literal>-v</literal>-valg som lister mye mer detaljert (men vanligvis ikke nødvendig) informasjon. Til slutt¸ <command>lsdev</command>-kommandoen (i <emphasis role="pkg">procinfo</emphasis>-pakken) lister kommunikasjonsressurser som enhetene bruker.
			</para>
			 <para>
				Programmer kobler seg ofte til enheter ved hjelp av spesielle filer som er opprettet innenfor <filename>/dev/</filename> (se sidestolpe <xref linkend="sidebar.special-files" />). Dette er spesielle filer som representerer platelager (for eksempel, <filename>/dev/hda</filename> og <filename>/dev/sdc</filename>), partisjoner (<filename>/dev/hda1</filename> eller <filename>/dev/sdc3</filename>), mus (<filename>/dev/input/mouse0</filename>), tastatur (<filename>/dev/input/event0</filename>), lydkort (<filename>/dev/snd/*</filename>), serieporter (<filename>/dev/ttyS*</filename>), og så videre.
			</para>

		</section>
		 <section id="sect.filesystems">
			<title>Filsystemer</title>
			 <indexterm>
				<primary>filsystem</primary>
			</indexterm>
			 <indexterm>
				<primary>system, filsystem</primary>
			</indexterm>
			 <para>
				Filsystemer er en av kjernens mest fremtredende aspekter. Unix-systemer fletter alle fillagre inn i et enkelt hierarki, som gir brukere (og programmer) tilgang til data ved å kjenne til plasseringen i det hierarkiet.
			</para>
			 <para>
				Startpunktet til dette hierarkiske treet kalles roten, <filename>/</filename>. Denne katalogen kan inneholde navngitte underkataloger. For eksempel, <literal>home</literal>-underkatalog i <filename>/</filename> kalles <filename>/home/</filename>. Denne underkatalogen kan i sin tur inneholde andre underkataloger, og så videre. Hver katalog kan også inneholde filer, hvor de faktiske dataene blir lagret. Dermed refererer <filename>/home/rmas/Desktop/hello.txt</filename>-navnet til en fil med navnet <literal>hello.txt</literal> lagret i <literal>Desktop</literal>-underkatalog i <literal>rmas</literal>-underkatalogen i <literal>home</literal>-katalogen i roten. Kjernen oversetter mellom dette navnesystemet og den faktiske, fysiske lagring på en disk.
			</para>
			 <para>
				I motsetning til andre systemer, er det bare ett slikt hierarki, og det kan integrere data fra flere disker. En av disse diskene anvendes som referanse, og de andre er «montert» på kataloger i hierarkiet (Unix-kommandoen er kalt <command>mount</command>); disse andre diskene er deretter tilgjengelige under disse «monteringspunktene». Dette tillater lagring av brukernes hjemmeområder (tradisjonelt lagret i <filename>/home/</filename>) på en annen harddisk, som da vil inneholde <literal>rhertzog</literal> og <literal>rmas</literal>-katalogene. Så snart disken er montert på <filename>/home/</filename>, blir disse katalogene tilgjengelige på sine vanlige steder, og stier som <filename>/home/rmas/Desktop/hello.txt</filename> fortsetter å virke.
			</para>
			 <indexterm>
				<primary><command>mkfs</command></primary>
			</indexterm>
			 <para>
				Det er mange filsystemformater, og tilsvarende mange måter å lagre data fysisk på disker. De mest kjente er <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> og <emphasis>ext4</emphasis>, men også andre finnes. For eksempel er <emphasis>vfat</emphasis> det systemet som historisk ble brukt av DOS og Windows-operativsystemer, som gjør det mulig å bruke harddisker under Debian så vel som under Windows. I alle fall må et filsystem være forberedt på en disk før den kan monteres, og denne operasjonen er kjent som «formatering». Kommandoer som <command>mkfs.ext3</command> (der <command>mkfs</command> står for <emphasis>MaKe FileSystem</emphasis>) formatteringsbehandling. Disse kommandoer krever, som et parameter, en enhetsfil som representerer den partisjonen som skal formateres (f.eks <filename>/dev/sda1</filename>). Denne operasjonen er destruktiv, og bør bare kjøres en gang, bortsett fra hvis man bevisst ønsker å stryke ut et filsystem og starte på nytt.
			</para>
			 <para>
				Det er også filsystemer i nettverk, slik som <acronym>NFS</acronym>, der data ikke er lagret på en lokal disk. I stedet overføres data via nettverket til en tjener som lagrer og henter dem ved behov. Filsystemets atskillelse skjermer brukere fra å være bekymret: filer forblir tilgjengelige på sin vanlige hierarkiske måte.
			</para>

		</section>
		 <section id="sect.shared-functions">
			<title>Delte funksjoner</title>
			 <para>
				Siden en rekke av de samme funksjonene brukes av all programvare, er det fornuftig å sentralisere dem i kjernen. For eksempel tillater et delt filsystem at et hvilket som helst program bare kan åpne en fil etter navn, uten å trenger å bekymre seg om hvor filen er lagret fysisk. Filen kan lagres i flere forskjellige disker på en harddisk, eller delt over flere harddisker, eller til og med lagret på en ekstern filtjener. Delte kommunikasjonsfunksjoner blir brukt av programmer til å utveksle data uavhengig av måten dataene transporteres. For eksempel kan transport være over hvilken som helst kombinasjon av lokale eller trådløse nettverk, eller over en fasttelefon.
			</para>

		</section>
		 <section id="sect.process-management">
			<title>Å håndtere prosesser</title>
			 <indexterm>
				<primary><emphasis>pid</emphasis></primary>
			</indexterm>
			 <para>
				En prosess er en kjørende forekomst av et program. Dette krever minne til å lagre både selve programmet og dets driftsdata. Kjernen er ansvarlig for å opprette og spore dem. Når et program kjøres, setter kjernen først av litt minne, deretter laster den kjørbar kode fra filsystemet inn i det, og starter så å kjøre koden. Den tar vare på informasjon om denne prosessen, i hvilken det mest synlige er et identifikasjonsnummer som kalles <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis>).
			</para>
			 <para>
				Unix-lignende kjerner (inkludert Linux), som de fleste andre moderne operativsystemer, er i stand til «fleroppgavekjøring». Med andre ord, de kan kjøre mange prosesser «samtidig». Det er faktisk bare en kjørende prosess til enhver tid, men kjernen forkorter tiden i små deler, og kjører hver prosess etter tur. Siden disse tidssnittene er meget korte (i millisekund-området), skaper de en illusjon av prosesser som kjører i parallell, selv om de faktisk bare er aktive i noen tidsintervall, og i tomgang resten av tiden. Kjernens jobb er å justere sine planleggingsmekanismer for å holde på denne illusjonen, og samtidig maksimere den globale systemytelsen. Dersom tidsintervallene er for lange, kan programmet ikke fremstå som så responsivt som ønskelig. For kort, og systemet mister tid på grunn av hyppig veksling mellom oppgaver. Disse beslutningene kan bli forskjøvet med prosessprioriteringer. Høyt prioriterte prosesser vil kjøre lenger, og med mer hyppige tidsintervaller enn lavt prioriterte prosesser.
			</para>
			 <sidebar> <title><emphasis>MERK</emphasis> Flerprosessorsystemer (og varianter)</title>
			 <para>
				Begrensningen beskrevet ovenfor, at bare én prosess kan kjøre på ett tidspunkt, gjelder ikke alltid. Selve begrensningen er at det bare kan være en kjørende prosess <emphasis>per prosessorkjerne</emphasis> om gangen. Multiprosessor, multikjerne eller «hypertrådede» systemer tillater at flere prosesser kjører parallelt. Systemet med fleroppgavekjøring er fortsatt i bruk, slik som å håndtere tilfeller der det er flere aktive prosesser enn tilgjengelige prosessorkjerner. Dette er langt fra uvanlig. Et grunnleggende system, selv et stort sett inaktivt et, har nesten alltid et titalls prosesser som kjører.
			</para>
			 </sidebar> <para>
				Selvfølgelig tillater kjernen å kjøre flere uavhengige prosesser med det samme programmet. Men hver kan bare få tilgang til sine egne tidsperioder og sitt eget minne. Deres data forblir dermed uavhengig.
			</para>

		</section>
		 <section id="sect.permissions">
			<title>Å håndtere rettigheter</title>
			 <para>
				Unix-lignende systemer er også flerbrukere. De gir et rettighetsforvaltningssystem som støtter egne brukere og grupper; det gir også kontroll over handlinger basert på tillatelser. Kjernen forvalter data for hver prosess, som tillater å kontrollere tillatelser. Mesteparten av tiden er en prosess identifisert med brukeren som startet den. Den prosessen er kun tillatt å gjøre det som er tilgjengelig for brukeren. For eksempel for å prøve å åpne en fil kreves det at kjernen kontrollerer prosessens identitet mot adgangstillatelser (for mer informasjon om dette eksempelet, se <xref linkend="sect.rights-management" />).
			</para>

		</section>

	</section>
	 <section id="sect.user-space">
		<title>Brukerrommet</title>
		 <indexterm>
			<primary>brukerland</primary>
		</indexterm>
		 <indexterm>
			<primary>kjerneland</primary>
		</indexterm>
		 <para>
			«Brukerområde» refererer til kjøretidsmiljøets normale prosesser (i motsetning til kjerneprosesser). Dette betyr ikke nødvendigvis at disse prosessene faktisk er startet av brukere fordi et standardsystem normalt har flere «nisse»-prosesser (eller bakgrunnsprosesser) som kjører før brukeren selv åpner en økt. Nisse-prosesser regnes også som brukerområdeprosesser.
		</para>
		 <section id="sect.process-basics">
			<title>Prosess</title>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				Når kjernen kommer forbi, starter den aller første prosessen, <command>init</command>. Prosess #1 er alene svært sjelden nyttig i seg selv, og Unix-lignende systemer kjører med mange prosesser i tillegg.
			</para>
			 <indexterm>
				<primary><emphasis>gaffel</emphasis></primary>
			</indexterm>
			 <para>
				Først av alt kan en prosess klone seg selv (dette er kjent som en <emphasis>gaffel</emphasis>). Kjernen tildeler et nytt (men identisk) prosessminne, og en annen prosess for å bruke det. På denne tiden er den eneste forskjellen mellom disse to prosessene deres <emphasis>pid</emphasis>. Den nye prosessen kalles vanligvis en barneprosess, og den opprinnelige prosessen, hvis <emphasis>pid</emphasis> ikke forandres, kalles foreldreprosessen.
			</para>
			 <para>
				Noen ganger fortsetter barneprosessen å leve sitt eget liv uavhengig av foreldreprosessen, med sine egne data kopiert fra den overordnede prosessen. I mange tilfeller kjører denne barneprosessen et annet program. Med noen få unntak, er minnet dens bare erstattet av det nye programmet, og gjennomføringen av dette nye programmet starter. Dette er mekanismen som brukes av init-prosessen (med prosess nummer 1) for å starte tilleggstjenester og gjennomføre hele oppstartssekvensen. På et tidspunkt starter en prosess blant <command>init</command>s avkom et grafisk grensesnitt som brukerne kan logge seg på (det faktiske hendelsesforløpet er beskrevet mer i detalj i <xref linkend="sect.system-boot" />).
			</para>
			 <para>
				Når en prosessen har fullført oppgaven den ble startet for å utføre, så avslutter den. Kjernen tar deretter tilbake minnet som er tilordnet denne prosessen, og slutter å dele ut tidsressurser den kan bruke til å kjøre. Foreldreprosessen blir fortalt at barneprosessen er avsluttet, noe som tillater en prosess å vente på fullføringen av en oppgave den delegerte til en barneprosess. Denne oppførselen vises tydelig i kommandolinjetolker (kjent som <emphasis>skall</emphasis>). Når en kommando er skrevet inn i et skall, kommer ledeteksten først tilbake når kommandoen er ferdig utført. De fleste skall lar en kjøre en kommando i bakgrunnen, som er bare å legge til <userinput>&amp;</userinput> på slutten av kommandoen. Ledeteksten vises igjen med en gang, noe som kan føre til problemer hvis kommandoen må skrive ut sitt eget resultat.
			</para>

		</section>
		 <section id="sect.daemons">
			<title>Nisser</title>
			 <indexterm>
				<primary>nisse</primary>
			</indexterm>
			 <indexterm>
				<primary>nisse</primary>
			</indexterm>
			 <para>
				En «nisse» er en prosess som startet automatisk ved oppstartssekvensen. Den fortsetter å kjøre (i bakgrunnen) for å utføre vedlikeholdsoppgaver, eller yte tjenester til andre prosesser. Denne «bakgrunnsoppgaven» er faktisk tilfeldig, og samsvarer ikke med noe bestemt fra systemets synspunkt. De er bare prosesser, ganske lik andre prosesser, som går igjen når deres tidskvote kommer. Forskjellen er bare i menneskelig språk: En prosess som går uten interaksjon med brukeren (særlig uten grafisk grensesnitt) sies å være kjørt «i bakgrunnen», eller «som en nisse».
			</para>
			 <sidebar> <title><emphasis>ORDFORRÅD</emphasis> Nisse, demon, en nedsettende betegnelse?</title>
			 <para>
				Selv om <emphasis>nisse (daemon)</emphasis>-begrepet deler sin greske etymologi med <emphasis>demon</emphasis>, innebærer førstnevnte ikke noe diabolsk onde, i stedet skal den forstås som en slags hjelpende ånd. Dette skillet er subtilt nok i engelsk, men det er til og med verre i andre språk der samme ordet er brukt for begge betydninger.
			</para>
			 </sidebar> <para>
				Forskjellige slike nisser er beskrevet i detalj i <xref linkend="unix-services" />.
			</para>

		</section>
		 <section id="sect.ipc">
			<title>Kommunikasjon mellom prosesser
			<indexterm>
				<primary>Inter-Process Communications</primary>
			</indexterm>
			</title>
			 <indexterm>
				<primary>IPC</primary>
			</indexterm>
			 <indexterm>
				<primary>Kommunikasjon mellom prosesser</primary>
			</indexterm>
			 <para>
				En isolert prosess, enten en nisse eller et interaktivt program, er sjelden nyttig i seg selv, noe som er grunnen til at det er flere metoder som lar separate prosesser kommunisere sammen, enten for å utveksle data, eller for å kontrollere hverandre. Det generiske begrepet for dette er <emphasis>inter-process communication</emphasis>, eller i kortform IPC.
			</para>
			 <para>
				Det enkleste IPC-systemet er å bruke filer. Prosessen som ønsker å sende data, skriver den inn i en fil (med et navn kjent på forhånd), mens mottakeren bare har å åpne filen, og lese innholdet.
			</para>
			 <indexterm>
				<primary><emphasis>kanal</emphasis></primary>
			</indexterm>
			 <para>
				I tilfeller der du ikke ønsker å lagre data på disken, kan du bruke en <emphasis>kanal</emphasis> som rett og slett er et objekt med to ender; byte skrevet i den ene enden er lesbar i den andre. Dersom endene er styrt med separate prosesser, fører dette til en enkel og praktisk kommunikasjon mellom prosesser. Kanaler kan deles inn i to kategorier: Navngitte kanaler, og anonyme kanaler. En navngitt kanal er representert ved en oppføring i filsystemet (selv om de overførte data ikke er lagret der), slik at begge prosessene kan åpne det uavhengig om plasseringen av den navngitte kanalen er kjent på forhånd. I tilfeller hvor de kommuniserende prosessene er relatert (for eksempel en foreldre- og dens barneprosess), den overordnede prosessen kan også opprette en anonym kanal før forgreninger, og barnet arver det. Begge prosesser vil da være i stand til å utveksle data gjennom kanalen uten filsystemet.
			</para>
			 <sidebar> <title><emphasis>I PRAKSIS</emphasis> Et konkret eksempel</title>
			 <para>
				La oss beskrive i detalj hva som skjer når en kompleks kommando (en <emphasis>pipeline (kanal)</emphasis>) kjøres fra et skall. Vi antar vi har en <command>bash</command>-prosess (standard brukerskallet på Debian), med <emphasis>pid</emphasis> 4374; I dette skallet skriver vi kommandoen:<command>ls | sort</command>.
			</para>
			 <para>
				Skallet tolker første kommandoen skrevet inn. I vårt tilfelle forstår det at det er to programmer (<command>ls</command> og <command>sort</command>), med en datastrøm som flyter fra den ene til den andre (merket med <userinput>|</userinput>-tegnet, kjent som <emphasis>pipe</emphasis>). <command>bash</command> oppretter først en ikke navngitt kanal (som i utgangspunktet bare eksisterer i selve <command>bash</command>-prosessen).
			</para>
			 <para>
				Deretter kloner skallet seg selv. Dette fører til en ny <command>bash</command>-prosess, med <emphasis>pid</emphasis> nummer 4521 (<emphasis>pid-er</emphasis> er abstrakte tall, og har generelt ikke noen bestemt mening). Prosess nummer 4521 arver kanalen/røret, noe som betyr at den er i stand til å skrive på sin «input»-side; <command>bash</command> omdirigeringer sin standard utgående strøm til dette rørets/kanalens inngang. Så utfører den (og erstatter seg med) <command>ls</command>-programmet, som viser innholdet i den gjeldende katalogen. Ettersom <command>ls</command> skriver til sine standard utdata, og denne produksjonen tidligere er omdirigert, blir resultatene effektivt sendt inn i kanalen/røret.
			</para>
			 <para>
				En lignende operasjon skjer for den andre kommandoen: <command>bash</command> kloner seg igjen, noe som fører til en ny <command>bash</command>-prosess med pid #4522. Siden den også er en barneprosess fra #4374, arver den også kanalen; <command>bash</command> kobler deretter sin standard inngang til kanalens utgang, deretter kjøres (og erstatter seg med) <command>sort</command>-kommandoen, som sorterer sine innspill, og viser resultatene.
			</para>
			 <para>
				Alle bitene i puslespillet er nå satt sammen: <command>ls</command> leser den gjeldende katalogen og skriver en liste over filer inn i kanalen; <command>sort</command> leser denne listen, sorterer den alfabetisk, og viser resultatene. Så avsluttes prosessnummer #4521 og #4522, og #4374 (som ventet på dem under operasjonen), gjenopptar kontrollen, og viser meldingen for å tillate brukeren å skrive inn en ny kommando.
			</para>
			 </sidebar> <para>
				Ikke all inter-prosesskommunikasjon brukes til å flytte data rundt. I mange situasjoner er den eneste informasjonen som må overføres, kontrollmeldinger som «pause utførelse» eller «gjenoppta kjøring». Unix (og Linux) gir en mekanisme som kalles <emphasis>signaler</emphasis>, gjennom hvilken en prosess bare kan sende et bestemt signal (valgt fra en forhåndsdefinert liste av signaler) til en annen prosess. Det eneste kravet er å kjenne til målets <emphasis>pid</emphasis>.
			</para>
			 <para>
				For mer komplekse kommunikasjoner er det også mekanismer som tillater at en prosess åpner tilgang, eller deler, en del av sitt tildelte minne til andre prosesser. Minnet, som nå er delt mellom dem, kan brukes til å flytte data mellom prosessene.
			</para>
			 <para>
				Endelig, nettverkstilkoblinger kan også hjelpe prosesser å kommunisere; disse prosessene kan også kjøres på forskjellige datamaskiner, muligens tusenvis av kilometer fra hverandre.
			</para>
			 <para>
				Det er ganske standard for et typisk Unix-lignende system i ulik grad å gjøre bruk av alle disse mekanismene.
			</para>

		</section>
		 <section id="sect.libraries">
			<title>Biblioteker</title>
			 <indexterm>
				<primary>bibliotek (funksjoner))</primary>
			</indexterm>
			 <para>
				Funksjonsbibliotekene spiller en avgjørende rolle i et Unix-lignende operativsystem. De er ikke egentlig programmer, da de ikke kan kjøres på egen hånd, men er samlinger av kodefragmenter som kan brukes av standardprogrammer. Blant de vanligste biblioteker, kan du finne:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						standard C biblioteket (<emphasis>glibc</emphasis>), som inneholder grunnleggende funksjoner som det å åpne filer eller nettverkstilkoblinger - og andre som legger til rette for interaksjoner med kjernen;
					</para>

				</listitem>
				 <listitem>
					<para>
						grafiske verktøysett, for eksempel Gtk+ og Qt, som tillater at mange programmer gjenbruker de grafiske objektene de leverer;
					</para>

				</listitem>
				 <listitem>
					<para>
						<emphasis>libpng</emphasis>-biblioteket som tillater lasting, tolking og lagring av bilder i PNG-format.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Takket være disse bibliotekene kan programmer gjenbruke eksisterende kode. Programutvikling forenkles fordi mange programmer kan bruke de samme funksjonene. Med bibliotekene, ofte utviklet av forskjellige personer, så er den globale utviklingen av systemet nærmere Unixs historiske filosofi.
			</para>
			 <sidebar> <title><emphasis>KULTUR</emphasis> Unix-måten: En ting om gangen</title>
			 <para>
				Et av de grunnleggende begreper som ligger til grunn for Unix-familiens operativsystemer, er at hvert verktøy bare skal gjøre en ting, og gjøre det bra; programmer kan deretter bruke disse verktøyene for å bygge en mer avansert logikk på toppen. Denne filosofien kan gjenfinnes i mange utgaver. Skall-skript kan være det beste eksemplet: De kan sette sammen komplekse sekvenser av svært enkle verktøy (for eksempel <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command>, og så videre). En annen implementering av denne filosofien sees i kodebiblioteker: <emphasis>libpng</emphasis>-biblioteket gjør det mulig å lese og skrive PNG-bilder, med ulike alternativer og på ulike måter, men det gjør bare det; ikke noe spørsmål om å inkludere funksjoner som viser eller redigerer bilder.
			</para>
			 </sidebar> <para>
				Dessuten er disse bibliotekene ofte referert til som «felles biblioteker», ettersom kjernen bare er i stand til å laste dem inn i minnet én gang, selv om flere prosesser benytter samme bibliotek samtidig. Dette tillater å spare lagringsminne, sammenlignet med den motsatte (hypotetisk) situasjonen, hvor koden for et bibliotek ville være lastet like mange ganger som det er prosesser som benytter den.
			</para>

		</section>

	</section>
</appendix>

