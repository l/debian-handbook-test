<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="unix-services" lang="nb-NO">
	<chapterinfo>
		 <keywordset>
			<keyword>Systemoppstart</keyword>
			 <keyword>Initskript</keyword>
			 <keyword>SSH</keyword>
			 <keyword>Telnet</keyword>
			 <keyword>Rettigheter</keyword>
			 <keyword>Tillatelser</keyword>
			 <keyword>Overvåking</keyword>
			 <keyword>Inetd</keyword>
			 <keyword>Cron</keyword>
			 <keyword>Sikkerhetskopiering</keyword>
			 <keyword>Hot-plugging</keyword>
			 <keyword>PCMCIA</keyword>
			 <keyword>APM</keyword>
			 <keyword>ACPI</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Unix tjenester</title>
	 <highlights> <para>
		Dette kapitlet dekker en rekke grunnleggende tjenester felles for mange Unix-systemer. Alle administratorer bør være kjent med dem.
	</para>
	 </highlights> <section id="sect.system-boot">
		<title>Systemoppstart</title>
		 <indexterm>
			<primary>booting</primary>
			<secondary>the system</secondary>
		</indexterm>
		 <para>
			Når du starter datamaskinen, vises mange meldinger på konsollskjermen at mange automatiske initialiseringer og konfigurasjoner blir utført. Noen ganger kan du ønske å endre litt på hvordan dette stadiet fungerer, noe som betyr at du må forstå det godt. Det er hensikten med denne seksjonen.
		</para>
		 <para>
			Først tar BIOS kontroll over datamaskinen, registrerer diskene, laster <emphasis>Master Boot Record</emphasis>, og starter oppstartslasteren. Oppstartslasteren tar over, finner kjernen på disken, laster og kjører den. Kjernen blir så initialisert, og begynner å søke etter og montere partisjonen som inneholder rotfilsystemet, og til slutt utfører det første programmet - <command>init</command>. Ofte er, faktisk, denne “rotpartisjonen” og denne <command>init</command> ligger i et virtuelt filsystem som bare finnes i RAM (derav navnet, "initramfs", tidligere kalt "initrd" for "initialisering RAM disk"). Dette filsystem er lastet inn i minnet av oppstartslasteren, ofte fra en fil på en harddisk eller fra nettverket. Den inneholder blotte minimum som kreves av kjernen for å laste det "sanne" rotfilsystemet: Dette kan være drivermoduler for harddisken eller andre enheter uten noe som systemet ikke kan starte opp, eller, oftere, initialiseringsskript og moduler for montering av RAID matriser, åpne krypterte partisjoner, aktivere LVM, etc. Når rotpartisjonen er montert, overlater initramfs kontrollen til den virkelige init-en, og maskinen går tilbake til standard oppstartsprosess.
		</para>
		 <figure id="figure.boot-process-systemd">
			<title>Oppstartssekvens med en datamaskin som kjører Linux med systemd</title>
			 <mediaobject>
				<imageobject>
					<imagedata fileref="images/startup-systemd.png" format="PNG" scalefit="1" width="80%" />
				</imageobject>

			</mediaobject>

		</figure>
		 <section id="sect.systemd">
			<title>Systemd init system</title>
			 <para>
				“real init” blir nå levert av <emphasis role="pkg">systemd</emphasis> og denne seksjonen dokumenter dette init-systemet.
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> Before <command>systemd</command></title>
			 <para>
				<command>systemd</command> er et relativt nytt “init system”, og selv om det allerede er tilgjengelig, til en viss grad, i <emphasis role="distribution">Wheezy</emphasis>, er det bare blitt standard i Debian <emphasis role="distribution">Jessie</emphasis>. Tidligere versjoner bygger, som standard, på “System V init” (in the <emphasis role="pkg">sysv-rc</emphasis>-pakken), et mye mer tradisjonelt system. Vi beskriver System V init senere.
			</para>
			 </sidebar> <sidebar> <title><emphasis>ALTERNATIVE</emphasis> Andre systemer for oppstart</title>
			 <para>
				Denne boken beskriver oppstartsystemet som brukes som standard i Debian <emphasis role="distribution">Jessie</emphasis> (som implementert av <emphasis role="pkg">systemd</emphasis>-pakken), så vel som den tidligere standarden, <emphasis role="pkg">sysvinit</emphasis>, som er avledet og arvet fra <emphasis>System V</emphasis> Unix systemer; det er andre.
			</para>
			 <para>
				<emphasis role="pkg">file-rc</emphasis> er et oppstartsystem med en veldig enkel prosess. Det holder prinsippet om kjørenivå, men erstatter mapper og symbolske lenker med en konfigurasjonsfil, som viser til <command>init</command> - prosessene som må startes og lanseringsrekkefølgen deres.
			</para>
			 <para>
				<command>upstart</command>-systemet er fortsatt ikke helt testet ut på Debian. Det er hendelsesbasert: init skripter utføres ikke lenger i en sekvensiell rekkefølge, men som respons til hendelser som for eksempel fullføring av et annet skript som de er avhengige av. Dette systemet, startet av Ubuntu, er med i Debian <emphasis role="distribution">Jessie</emphasis>, men er ikke i standarden. Det kommer faktisk som en erstatning for <emphasis role="pkg">sysvinit</emphasis>, og en av oppgavene kjørt av <command>upstart</command> er å kjøre de prosedyrer som er skrevet for tradisjonelle systemer, spesielt de fra <emphasis role="pkg">sysv-rc</emphasis>-pakken.
			</para>
			 <para>
				Det er også andre systemer og andre driftsmodi, for eksempel <command>runit</command> eller <command>minit</command>, men de er relativt spesialiserte og ikke utbredt.
			</para>
			 </sidebar> <sidebar> <title><emphasis>SPECIFIC CASE</emphasis> Oppstart fra nettverket</title>
			 <para>
				I noen konfigurasjoner, kan BIOS bli konfigurert til ikke å utføre MBR, men å søke dens tilsvarende i nettverket, noe som gjør det mulig å bygge datamaskiner uten en harddisk, eller som blir helt reinstallert ved hver oppstart. Dette alternativet er ikke tilgjengelig for alle maskinvarer og det krever vanligvis en egnet kombinasjon av BIOS og nettverkskort.
			</para>
			 <para>
				Oppstart fra nettverket kan bli brukt til å kjøre <command>debian-installer</command> eller FAI (se <xref linkend="sect.installation-methods" />).
			</para>
			 </sidebar> <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Prosessen, et programeksempel</title>
			 <indexterm>
				<primary>process</primary>
			</indexterm>
			 <para>
				En prosess er representasjonen av et program som kjører i minnet. Det inkluderer all informasjon som er nødvendig for en forsvarlig kjøring av programvaren (selve koden, men også dataene som den har i minnet, en liste over filer som den har åpnet, nettverksforbindelsene den har etablert, etc.). Et enkelt program kan startes opp i flere prosesser, som ikke nødvendigvis kjører under forskjellige bruker-IDer.
			</para>
			 </sidebar> <sidebar> <title><emphasis>SECURITY</emphasis> Bruke skall som <command>init</command> for å få rotrettingheter</title>
			 <para>
				Av tradisjon, den første prosessen som starter er <command>init</command> programmet (som er en symbolsk lenke til <filename>/lib/systemd/systemd</filename> som standard). Imidlertid er det mulig å sende et <literal>init</literal>-valg til kjernen for å indikere et annet program.
			</para>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				Alle som er i stand til å få tilgang til datamaskinen kan trykke på <keycap>Reset</keycap>-knappen og restarte den. Så, på oppstartslasterens ledetekst, er det mulig å sende <literal>init=/bin/sh</literal>-valget til kjernen for å få rottilgang uten å kjenne administratorens passord.
			</para>
			 <para>
				For å unngå dette, kan du beskytte oppstartslasteren med et passord. Du kan også tenke på å beskytte tilgang til BIOS (en mekanisme for passordbeskyttelse er nesten alltid tilgjengelig). Uten den kan en en ondsinnet inntrenger fortsatt starte maskinen med et flyttbart medium som har sitt eget Linux-system, som de deretter kan bruke til å få tilgang til data på datamaskinens harddisker.
			</para>
			 <para>
				Til slutt, være klar over at de fleste BIOS-er har en generisk passord tilgjengelig. I utgangspunktet er de tenkt for feilsøking for de som har glemt passordet sitt, disse passordene er nå offentlige og tilgjengelig på Internett (se selv ved å søke etter "generiske BIOS-passord" i en søkemotor). Alle disse beskyttelsene vil dermed hindre uautorisert tilgang til maskinen, men uten å være i stand til å fullstendig hindre det. Det er ingen pålitelig måte å beskytte en datamaskin på hvis angriperen kan få fysisk fysisk tilgang til den; de kan uansett demontere harddisker for å koble dem til en datamaskin under egen kontroll, eller stjele hele maskinen, eller slette BIOS-minnet for å tilbakestille passordet …
			</para>
			 </sidebar> <para>
				Systemd utfører flere prosesser, som svarer for å sette opp systemet: tastatur, drivere, filsystemer, nettverk, tjenester. Den gjør dette mens du holder et overordnet syn på systemet som en helhet, og kravene til komponentene. Hver komponent er beskrevet av en "unit file" (noen ganger mer); den generelle syntaksen er avledet fra det mye brukte "* INI filer" syntaks, med <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> par gruppert mellom <literal>[<replaceable>section</replaceable>]</literal> topptekster. "Unit filer" er lagret under <filename>/lib/systemd/system/</filename> og <filename>/etc/systemd/system/</filename>. De kommer i flere varianter, men her vil vi fokusere på "tjenester" og "mål".
			</para>
			 <para>
				En systemd "tjenestefil" beskriver en prosess styrt av systemd. Den inneholder omtrent den samme informasjonen som i et i gammel stil init-skript, men uttrykt på en deklaratorisk (og mye mer konsis) måte. Systemd håndterer mesteparten av de repeterende oppgavene (som starter og stopper prosessen, sjekker statusen, loggingen, dropper privilegier, og så videre), og tjenestefilen trenger bare å fylle ut detaljene i prosessen. For eksempel, her er tjenestefilen for SSH:
			</para>
			 
<programlisting>[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service
</programlisting>
			 <para>
				Som du kan se, er det svært lite kode her, bare deklarasjoner. Systemd tar seg av visning av fremdriftsrapporter, holder orden på prosessene, og starter dem selv når det trengs.
			</para>
			 <para>
				En systemd "target file" beskriver et systems tilstand, hvor et sett av tjenester som er kjent for å være i operasjonelle. Det kan sees på som å tilsvare det gammeldagse kjørenivået. Ett av målene er <literal>local-fs.target</literal>; Når det er nådd, kan resten av systemet gå ut fra at alle de lokale filsystemer er montert og tilgjengelige. Andre mål inkluderer <literal>network-online.target</literal> og <literal>sound.target</literal>. Avhengigheter for et mål kan enten være oppført i målfilen (i <literal>Requires=</literal>-linjen), eller man kan bruke en symbolsk fil i <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal>-mappen. For eksempel inneholder <filename>/etc/systemd/system/printer.target.wants/</filename> en link til <filename>/lib/systemd/system/cups.service</filename>; systemd vil derfor sikre at CUPS kjører, for å nå <literal>printer.target</literal>.
			</para>
			 <para>
				Siden enhetsfiler er deklarative heller enn skripter eller programmer, de kan ikke kjøres direkte, og de blir bare tolket av systemd. Flere verktøy tillater derfor administratoren å samhandle med systemd for å kontrollere tilstanden til systemet og for hver komponent.
			</para>
			 <para>
				Det første slike verktøy er <command>systemctl</command>. Kjørt uten argumenter, viser den alle enhetsfiler som er kjent for systemd (bortsett fra de som er blitt deaktivert), samt deres status. <command>systemctl status</command> gir en bedre oversikt over tjenestene, samt relaterte prosesser. Hvis gitt navnet på en tjeneste (som i <command>systemctl status ntp.service</command>), returnerer den enda flere detaljer, så vel som de få siste logglinjer knyttet til denne tjenesten (mer om det senere).
			</para>
			 <para>
				Å starte en tjeneste for hånd er en enkel sak, kjør <command>systemctl start <replaceable>servicename</replaceable>.service</command>. Som man kan gjette seg til, å stoppe tjenesten gjøres med <command>systemctl stop <replaceable>servicename</replaceable>.service</command>. Andre underkommandoer inkluderer <command>reload</command> og <command>restart</command>.
			</para>
			 <para>
				For å kontrollere om en tjeneste er aktiv (dvs. om det vil komme i gang automatisk ved oppstart), bruk <command>systemctl enable <replaceable>servicename</replaceable>.service</command> (eller <command>disable</command>). <command>is-enabled</command> åpner for å sjekke tjenestens status.
			</para>
			 <para>
				Et interessant trekk ved systemd er at den inneholder en loggingskomponent som heter <command>journald</command>. Den kommer som et supplement til mer tradisjonelle loggingsystemer, for eksempel <command>syslogd</command>, men den legger til interessante funksjoner, som en formell kobling mellom en tjeneste og meldingene den genererer, og evnen til å fange opp feilmeldinger generert fra sin initialiseringsekvens. Meldingene kan vises senere, med litt hjelp fra <command>journalctl</command>-kommandoen. Uten noen argumenter, avgir den bare alle loggmeldinger som har oppstått etter oppstart av systemet. Det vil sjelden bli brukt på den måten. Mesteparten av tiden, vil den bli brukt med en tjenesteidentifikator:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</computeroutput></screen>
			 <para>
				En annen nyttig kommandolinjemarkør er <command>-f</command>, som instruerer <command>journalctl</command> til å fortsette å vise nye meldinger etterhvert som de er sendt ut (mye på samme måte som <command>tail -f <replaceable>file</replaceable></command>).
			</para>
			 <para>
				Hvis en tjeneste ikke ut til å virke som forventet, er første skritt for å løse problemet å kontrollere at tjenesten faktisk kjører, med <command>systemctl status</command>. Hvis den ikke kjører, og meldingene er gitt av den første kommandoen ikke er nok til å diagnostisere problemet, sjekk loggene samlet av journald om denne tjenesten. For eksempel, anta SSH server ikke virker:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>vi /etc/ssh/sshd_config
</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service
</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </computeroutput></screen>
			 <para>
				Etter å ha sjekket status på tjenesten (feilet), gikk vi videre til å sjekke loggene. De indikerer en feil i konfigurasjonsfilen. Etter å ha redigert konfigurasjonsfilen og fikset feilen, starter vi tjenesten, og kontroller så at den faktisk kjører.
			</para>
			 <sidebar><title><emphasis>GOING FURTHER</emphasis> Andre typer enhetsfiler</title>
			 <para>
				Vi har bare beskrevet de mest grunnleggende av systemd muligheter i denne seksjonen. Den tilbyr mange andre interessante funksjoner og vi vil bare liste noen her:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						socket aktivering: en "socket" enhetsfil kan brukes til å beskrive et nettverk eller en Unix socket administrert av systemd. Dette betyr at socket-en vil bli opprettet av systemd, og selve tjenesten kan startes etter behov ved et faktisk tilkoblingsforsøk. Dette replikerer omtrent funksjonssettet til <command>inetd</command>. See <citerefentry><refentrytitle>systemd.socket</refentrytitle>
						<manvolnum>5</manvolnum></citerefentry>.
					</para>
				</listitem>
				 <listitem>
					<para>
						timere: en "timer" enhetsfile beskriver hendelser som inntreffer med en fast frekvens eller på bestemte tider. Når en tjeneste er knyttet til en slik timer, vil den tilsvarende oppgaven bli utføret når tiden slår inn. Dette gjør det mulig å kopiere en del av <command>cron</command>s egenskaper. Se <citerefentry><refentrytitle>systemd.timer</refentrytitle>
						<manvolnum>5</manvolnum></citerefentry>.
					</para>
				</listitem>
				 <listitem>
					<para>
						nettverk: en "nettverk" enhetsfil beskriver et nettverksgrensesnitt som gjør det mulig å konfigurere slike grensesnitt samt uttrykke at en tjeneste er avhengig av at et bestemt grensesnitt er oppe.
					</para>
				</listitem>

			</itemizedlist>
			</sidebar>
		</section>
		 <section id="sect.sysvinit">
			<title>System V init system</title>
			 <para>
				System V init system (som vi kaller init for korthets skyld) utfører flere prosesser, etter anvisning fra <filename>/etc/inittab</filename>-filen. Den første program som kjøres (som tilsvarer <emphasis>sysinit</emphasis> trinnet) er <command>/etc/init.d/rcS</command>, et skript som kjører alle programene i <filename>/etc/rcS.d/</filename>-mappen. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm>
			</para>
			 <para>
				Blant disse finner du suksessivt programmer med ansvar for:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						oppsettet av konsollets tastatur;
					</para>

				</listitem>
				 <listitem>
					<para>
						laste drivere: de fleste av kjernemodulene er lastet av kjernen selv i takt med at maskinvaren blir oppdaget; ekstra drivere blir deretter lastet inn automatisk når de korresponderende modulene er oppført i <filename>/etc/modules</filename>;
					</para>

				</listitem>
				 <listitem>
					<para>
						sjekke integriteten til filsystemene;
					</para>

				</listitem>
				 <listitem>
					<para>
						montere lokale partisjoner;
					</para>

				</listitem>
				 <listitem>
					<para>
						sette opp nettverket
					</para>

				</listitem>
				 <listitem>
					<para>
						montere nettverk filsystemer (NFS).
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Kildemoduler og valgmuligheter</title>
			 <indexterm>
				<primary>modules</primary>
				<secondary>kernel modules</secondary>
			</indexterm>
			 <para>
				Kjernemoduler har også valgmuligheter som kan konfigureres ved å sette noen filer i <filename>/etc/modprobe.d/</filename>. Disse alternativene er definert med direktiver som dette: <literal>options <replaceable>module-name</replaceable> <replaceable>option-name</replaceable>=<replaceable>option-value</replaceable></literal>. Flere alternativer kan spesifiseres med ett eneste direktiv om nødvendig.
			</para>
			 <para>
				Disse konfigurasjonsfiler er beregnet for <command>modprobe</command> - programmet som laster en kjernemodul med dets avhengigheter (moduler kan faktisk påkalle andre moduler). Dette programmet blir levert av <emphasis role="pkg">kmod</emphasis>-pakken.
			</para>
			 <indexterm>
				<primary><command>modprobe</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">kmod</emphasis></primary>
			</indexterm>
			 </sidebar> <para>
				Etter dette trinnet tar, <command>init</command> over og starter programmene aktivert i standard kjørenivå (som vanligvis er driftsnivå 2). Den utfører <command>/etc/init.d/rc 2</command>, et skript som starter alle tjenestene som er oppført i <filename>/etc/rc2.d/</filename> og der navnet begynner med bokstaven "S". Det tosifrede nummer som følger, har historisk blitt brukt til å definere i hvilken rekkefølge tjenestene måtte startes, men i dag brukes det standard oppstartsystemet <command>insserv</command>, som berammer alt automatisk basert på skriptenes avhengigheter. Hvert oppstartskript melder om betingelsene som må være oppfylt for å starte eller stoppe tjenesten (for eksempel hvis det må starte før eller etter en annen tjeneste); Så starter <command>init</command> dem i den rekkefølgen som oppfyller disse betingelsene. Skriptenes statiske nummerering tas derfor ikke lenger i betraktning (men de må alltid ha et navn som begynner med "S" etterfulgt av to sifre og selve navnet på skriptet som brukes for avhengighetene. Vanligvis startes basistjenester (for eksempel logger med <command>rsyslog</command>, eller tildeling av port med <command>portmap</command>) først, fulgt av standardtjenestene og det grafiske brukergrensesnittet (<command>gdm3</command>).
			</para>
			 <para>
				Denne avhengighetsbaserte oppstartsystemet gjør det mulig å automatisere renummerering, som kan være ganske kjedelig hvis det må gjøres manuelt. Det begrenser risikoen for menneskelige feil, ettersom tidsrekkefølgen blir gjennomført i henhold til de parameterne som er angitt. En annen fordel er at tjenester kan startes parallelt når de er uavhengige av hverandre, noe som kan akselerere oppstartsprosessen.
			</para>
			 <indexterm>
				<primary>runlevel</primary>
			</indexterm>
			 <indexterm>
				<primary>level, runlevel</primary>
			</indexterm>
			 <para>
				<command>init</command> skiller mellom ulike kjørenivåer, så den kan bytte fra ett til en annet med <command>telinit <replaceable>new-level</replaceable></command>-kommandoen. Umiddelbart vil <command>init</command> kjøre <command>/etc/init.d/rc</command> igjen med det nye kjørenivået. Dette skriptet vil da starte de manglende tjenestene og stoppe de som ikke lenger er ønsket. For å gjøre dette, viser det til innholdet i<filename>/etc/rc<replaceable>X</replaceable>.d</filename> (der <replaceable>X</replaceable> representerer det nye kjørenivået). Scripts som begynner med "S" (som i "Start") er tjenester som skal i gang; de som starter med "K" (som i "Kill") er de tjenestene som skal stoppes. Skriptet starter ikke noen tjenester som allerede var aktive med det forrige driftsnivået.
			</para>
			 <para>
				Som standard, bruker System V init i Debian fire forskjellige driftsnivåer:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						Nivå 0 brukes bare midlertidig, mens maskinen slår seg av. Dermed inneholder den bare mange "K" skripter.
					</para>

				</listitem>
				 <listitem>
					<para>
						Nivå 1, også kjent som enkeltbrukermodus, tilsvarer systemet i nedgradert modus; det inneholder bare basistjenester, og er beregnet for vedlikeholdsoperasjoner hvor samhandling med vanlige brukere ikke er ønsket.
					</para>

				</listitem>
				 <listitem>
					<para>
						Nivå 2 er nivået for normal drift, som omfatter nettverkstjenester, et grafisk grensesnitt, brukerpålogging, etc.
					</para>

				</listitem>
				 <listitem>
					<para>
						Nivå 6 er lik nivå 0, bortsett fra at det brukes under nedkoblingsfasen før en omstart.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Andre nivåer finnes, spesielt 3 til 5. Som standard de er konfigurert til å operere på samme måte som nivå 2, men administratoren kan endre dem (ved å legge til eller slette skript i den tilsvarende <filename>/etc/rc<replaceable>X</replaceable>.d</filename> directories) for å tilpasse dem til spesielle behov.
			</para>
			 <figure id="figure.boot-process-sysvinit">
				<title>Oppstartssekvens for en datamaskin som kjører Linux med System V init</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/startup-sysvinit.png" format="PNG" scalefit="1" width="80%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <indexterm>
				<primary>initialization script</primary>
			</indexterm>
			 <para>
				Alle skriptene som inngår i de ulike <filename>/etc/rc<replaceable>X</replaceable>.d</filename>-kataloger er egentlig bare symbolske lenker - opprettet ved pakkeinstallasjon av <command>update-rc.d</command>-programmet - som peker til selve skriptet som er lagret i<filename>/etc/init.d/</filename>. Administratoren kan finjustere tjenestene som er tilgjengelige i hvert kjørenivå ved å kjøre <command>update-rc.d</command> igjen med justerte parametre. <citerefentry><refentrytitle>update-rc.d</refentrytitle>
				<manvolnum>1</manvolnum></citerefentry> - denne manuelle siden beskriver syntaksen i detalj. Vær oppmerksom på at å fjerne alle symbolske lenker (med <literal>remove</literal>-parameteret) ikke er noen god metode for å deaktivere en tjeneste. I stedet bør du bare konfigurere den til ikke å starte i det ønskede kjørenivået (mens man skjermer de samsvarende påkallinger for å stoppe den i det tilfelle tjenesten bruker det forrige kjørenivået. Siden <command>update-rc.d</command> har et noe innfløkt grensesnitt, kan du foretrekke å bruke <command>rcconf</command> (fra <emphasis role="pkg">rcconf</emphasis>-pakken som gir et mer brukervennlig grensesnitt.
			</para>
			 <indexterm>
				<primary><command>update-rc.d</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>DEBIAN POLICY</emphasis> Å restarte tjenester</title>
			 <indexterm>
				<primary><command>invoke-rc.d</command></primary>
			</indexterm>
			 <indexterm>
				<primary>service</primary>
				<secondary>restart</secondary>
			</indexterm>
			 <indexterm>
				<primary>restarting services</primary>
			</indexterm>
			 <para>
				Vedlikeholdsskripter for Debian-pakker vil noen ganger restarte visse tjenester for å sikre at de er tilgjengelige, eller få dem til å ta hensyn til visse valgmuligheter. Kommandoen som styrer en tjeneste - <command>service <replaceable>service</replaceable> <replaceable>operation</replaceable></command> - tar ikke driftsnivå i betraktning, forutsetter (feilaktig) at tjenesten brukes for øyeblikket, og kan dermed iverksette uriktige operasjoner (starter en tjeneste som bevisst var bevisst, eller stoppe en tjeneste som allerede er stanset, etc.). Debian introduserte derfor <command>invoke-rc.d</command>-programmet: Dette programmet må benyttes av vedlikeholdsskripter til å kjøre skripter for å ta initiativet til tjenester og det vil bare utføre de nødvendige kommandoer. Legg merke til at, i motsetning til vanlig bruk, er <filename>.d</filename>-suffikset her brukt i et programnavn, og ikke i en katalog.
			</para>
			 </sidebar> <para>
				Til slutt, <command>init</command> starter kontrollprogrammer for ulike virtuelle konsoller (<command>getty</command>). Den viser en ledetekst, venter for et brukernavn, og så kjører <command>login <replaceable>user</replaceable></command> for å starte en økt.
			</para>
			 <indexterm>
				<primary><command>getty</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>VOCABULARY</emphasis> Konsoll og terminal</title>
			 <para>
				De første datamaskinene besto vanligvis av flere, svært store deler: lagringskabinett og den sentrale prosessenheten var atskilt fra eksterne enheter som ble brukt av operatørene til å kontrollere maskinene. Dette var deler i et eget møbel, "konsollet". Dette begrepet ble beholdt, men betydningen har endret seg. Det har blitt mer eller mindre synonymt med "terminal", som er et tastatur og en skjerm.
			</para>
			 <para>
				Med utviklingen av datamaskiner, tilbyr operativsystemer flere virtuelle konsoller for å muliggjøre flere uavhengige sesjoner på samme tid, selv om det er bare ett tastatur og en skjerm. De fleste GNU/Linux-systemer tilbyr seks virtuelle konsoller (i tekstmodus), som er tilgjengelige ved å skrive inn tastekombinasjonene <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> through <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo>.
			</para>
			 <para>
				I forlengelsen av dette, kan begrepene "konsoll" og "terminal" også referere til en terminalemulator i en grafisk X11 sesjon (for eksempel <command>xterm</command>, <command>gnome-terminal</command> eller <command>konsole</command>).
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.remote-login">
		<title>Ekstern innlogging</title>
		 <para>
			Det er viktig for en administrator å kunne koble seg til en datamaskin utenfra. Tjenere, innesperret i sitt eget rom, er sjelden utstyrt med permanente tastaturer og skjermer - men de er koblet til nettverket.
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Klient, tjener</title>
		 <indexterm>
			<primary>client</primary>
			<secondary>client/server architecture</secondary>
		</indexterm>
		 <indexterm>
			<primary>server</primary>
			<secondary>client/server architecture</secondary>
		</indexterm>
		 <para>
			Et system hvor flere prosesser kommuniserer med hverandre, blir ofte beskrevet med "klient/tjener" metaforer. Tjeneren er programmet som tar forespørsler som kommer fra en klient og utfører dem. Det er klienten som styrer operasjonene, tjeneren tar ikke ta noen egne initiativ.
		</para>
		 </sidebar> <indexterm>
			<primary>login</primary>
			<secondary>remote login</secondary>
		</indexterm>
		 <indexterm>
			<primary>remote login</primary>
		</indexterm>
		 <section id="sect.ssh">
			<title>Sikker ekstern innlogging: SSH</title>
			 <indexterm>
				<primary>SSH</primary>
			</indexterm>
			 <indexterm>
				<primary>Secure Shell</primary>
			</indexterm>
			 <para>
				<emphasis>SSH</emphasis> (Secure SHell)-protokollen ble utformet med tanke på sikkerhet og pålitelighet. Tilkoblinger som bruker SSH er sikre: Partneren er godkjent og all datautveksling er kryptert.
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> Telnet og RSH er foreldet</title>
			 <indexterm>
				<primary><command>telnet</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>rsh</command></primary>
			</indexterm>
			 <para>
				Før SSH var, <emphasis>Telnet</emphasis> og <emphasis>RSH</emphasis> de viktigste verktøyene for ekstern innlogging. Nå er de i stor grad foreldet og skal ikke lenger brukes selv om Debian fortsatt har dem med.
			</para>
			 </sidebar> <sidebar> <title><emphasis>VOCABULARY</emphasis> Autentisering, kryptering</title>
			 <para>
				Når du trenger å gi en klient evnen til å utføre eller utløse handlinger på en server, er sikkerhet viktig. Du må sikkerstille identiteten til klienten; dette er autentisering. Denne identiteten består vanligvis av et passord som må holdes hemmelig, ellers kan hvilken som helst skaffe seg passordet. Dette er hensikten med kryptering, som er en form for koding som tillater to systemer å kommunisere konfidensiell informasjon på en offentlig kanal, samtidig som den er beskyttet mot å være lesbar for andre.
			</para>
			 <para>
				Autentisering og kryptering er ofte nevnt sammen, både fordi de er ofte brukt sammen, og fordi de vanligvis gjennomføres med matematiske begreper som ligner hverandre.
			</para>
			 </sidebar> <para>
				SSH tilbyr også to filoverføringstjenester. <command>scp</command> er et kommandolinjeverktøy som kan brukes som <command>cp</command>, bortsett fra at hvilken som helst sti til en annen maskin har et prefiks med maskinens navn, etterfulgt av et kolon.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput></screen>
			 <para>
				<command>sftp</command> er en interaktiv komomando, som svarer til <command>ftp</command>. I en enkelt økt kan <command>sftp</command> overføre flere filer, og med den er mulig å manipulere eksterne filer (slette, endre navn, endre tillatelser, etc.).
			</para>
			 <indexterm>
				<primary><command>scp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sftp</command></primary>
			</indexterm>
			 <para>
				Debian bruker OpenSSH, som er en fri versjon av SSH, som vedlikeholdes av <command>OpenBSD</command>-prosjektet (et fritt operativsystem basert på BSD-kjernen, med fokus på sikkerhet) og er en gaffel av den opprinnelige SSH programvaren utviklet av SSH Communications Security Corp selskapet i Finland. Dette selskapet utviklet opprinnelig SSH som fri programvare, men som til slutt bestemte seg for å fortsette utviklingen under en proprietær lisens. OpenBSD-prosjektet opprettet deretter OpenSSH for å opprettholde en fri versjon av SSH.
			</para>
			 <indexterm>
				<primary>OpenSSH</primary>
			</indexterm>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> <foreignphrase>Fork</foreignphrase></title>
			 <indexterm>
				<primary>fork</primary>
			</indexterm>
			 <para>
				På programvarefeltet betyr en "gaffel" et nytt prosjekt som starter som en klone av et eksisterende prosjekt, og som vil konkurrere med det. Fra da av vil begge programvarer raskt avvike fra hverandre i nyutvikling. En gaffel er ofte et resultat av uenighet innenfor utviklingsteamet.
			</para>
			 <para>
				Alternativet å "gafle" et prosjekt, er et direkte resultat av selve naturen til fri programvare; en gaffel er en sunn hendelse når det muliggjør en videreføring av et prosjekt som fri programvare (for eksempel i tilfelle av lisensendringer). En gaffel, som følge av tekniske eller personlige uoverensstemmelser, er ofte en sløsing med menneskelige ressurser; En annen løsning ville være å foretrekke. Fusjoner av to prosjekter som tidligere gikk gjennom en tidligere gaffel har forekommet.
			</para>
			 </sidebar> <para>
				OpenSSL er delt i to pakker: Klientdelen er i <emphasis role="pkg">openssh-client</emphasis>-pakken, og tjeneren er i <emphasis role="pkg">openssh-server</emphasis>-pakken. <emphasis role="pkg">ssh</emphasis>-meta-pakken er avhengig av begge, og forenkler installeringen av begge (<command>apt install ssh</command>).
			</para>
			 <section id="sect.ssh-key-based-auth">
				<title>Nøkkel-basert autentisering</title>
				 <para>
					Hver gang noen logger inn over SSH, spør en ekstern tjener om et passord for å autentisere brukeren. Dette kan være problematisk hvis du ønsker å automatisere en tilkobling, eller hvis du bruker et verktøy som krever hyppige forbindelser over SSH. Dette er grunnen til SSH tilbyr et nøkkelbasert autentiseringssystem.
				</para>
				 <para>
					Brukeren generer et nøkkelpar på klientmaskinen med <command>ssh-keygen -t rsa</command>; Den offentlige nøkkelen er lagret i <filename>~/.ssh/id_rsa.pub</filename>, mens den korresponderende private nøkkel er lagret i <filename>~/.ssh/id_rsa</filename>. Brukeren bruker så <command>ssh-copy-id <replaceable>server</replaceable></command> for å legg til sin offentlige nøkke til <filename>~/.ssh/authorized_keys</filename>-filen på tjeneren. Dersom den private nøkkelen ikke var beskyttet med en "adgangsfrase" på tidspunktet for etableringen, vil alle etterfølgende innlogginger på serveren fungere uten et passord. Ellers må den private nøkkelen dekrypteres hver gang ved å skrive inn passordet. Heldigvis tillater <command>ssh-agent</command> oss å holde private nøkler i minnet for å ikke regelmessig å måtte taste inn igjen passord. For dette, bruker du bare <command>ssh-add</command> (en gang per økt), forutsatt at økten allerede er knyttet til en funksjonell forekomst med <command>ssh-agent</command>. Debian aktiverer den som standard i grafiske økter, men dette kan deaktiveres ved å endre <filename>/etc/X11/Xsession.options</filename>. Du kan manuelt starte en konsolløkt med <command>eval $(ssh-agent)</command>.
				</para>
				 <sidebar> <title><emphasis>SECURITY</emphasis> Protection of the private key</title>
				 <para>
					Den som har den private nøkkelen kan logge seg på den kontoen som er konfigurert for det. Dette er grunnen til tilgang til den private nøkkelen er beskyttet av en "adgangsfrase". Noen som får en kopi av en privat nøkkelfil (for eksempel <filename>~/.ssh/id_rsa</filename>) må fremdeles kjenne denne frasen for å kunne bruke den. Denne ekstra beskyttelse er imidlertid ikke uangripelig, og hvis du tror at denne filen har blitt kompromittert, er det best å deaktivere den nøkkelen på datamaskinene der den har blitt installert (ved å fjerne den fra <filename>authorized_keys</filename> files) og erstatte den med en nylig generert nøkkel.
				</para>
				 </sidebar> <sidebar> <title><emphasis>CULTURE</emphasis> OpenSSL feil i Debian <emphasis role="distribution">Etch</emphasis></title>
				 <para>
					OpenSSL-biblioteket, som i utgangspunktet er tilgjengelig i Debian <emphasis role="distribution">Etch</emphasis>, hadde et alvorlig problem i sin generator for tilfeldige tall (RNG). Faktisk, Debian vedlikeholderen hadde gjort en endring slik at programmer som bruker den ikke lenger ville generere advarsler når den ble analysert av et testverktøy for minne som <command>valgrind</command>. Dessverre, denne endringen betydde også at RNG-en bare anvender e n e entropikilde som korresponderer med prosessantallet (PID), der 32 000 mulige verdier ikke gir tilstrekkelig tilfeldighet. <ulink type="block" url="http://www.debian.org/security/2008/dsa-1571" />
				</para>
				 <para>
					Spesielt, når OpenSSL ble brukt til å generere en nøkkel, produserte den alltid en nøkkel i løpet av et visst sett av hundretusener av nøkler (32 000 multiplisert med et lite antall nøkkellengder). Dette påvirket SSH-nøkler, SSL-nøkler og X.509 sertifikater som brukes av mange programmer, som OpenVPN. En inntrengerr hadde bare å prøve alle nøklene til å få uautorisert tilgang. For å redusere virkningen av problemSpesielt når OpenSSL ble brukt til å generere en nøkkel, er det alltid produsert en tast i løpet av et visst sett av hundretusener av nøkler (32 000 multiplisert med et lite antall nøkkellengder ). Dette påvirket SSH nøkler, SSL nøkler og X.509 sertifikater som brukes av mange programmer, som OpenVPN. En cracker hadde bare å prøve alle nøklene til å få uautorisert tilgang. For å redusere virkningen av problemet, ble SSH nissen modifisert til å nekte problematiske nøkler som er oppført i <emphasis role="pkg">openssh-blacklist</emphasis>- og <emphasis role="pkg">openssh-blacklist-extra</emphasis>-pakkene. I tillegg tillater <command>ssh-vulnkey</command>-kommandoen identifisering av mulige kompromitterte nøkler i systemet.
				</para>
				 <para>
					En grundigere analyse av denne hendelsen bringer frem i lyset at det er et resultat av flere (små) problemer, både i OpenSSL-prosjektet og med Debian pakkevedlikeholderen. Et mye brukt bibliotek som OpenSSL skal - uten endringer - ikke generere advarsler under testing av <command>valgrind</command>. Videre bør koden (spesielt de delene som er så følsomme som RNG) bli bedre kommentert for å forhindre slike feil. På Debians side, ønsket vedlikeholderen å validere modifikasjonene med OpenSSLs utviklere, men forklarte ganske enkelt endringene, uten å legge ut den korresponderende programfiksen til gjennomgang og unnlot å nevne sin rolle i Debian. Endelig, vedlikeholdsvalgene var sub-optimale: Endringene i den opprinnelige koden ble ikke klart dokumentert; alle modifikasjoner ble effektivt lagret i en Subversion kildebrønn, men de endte opp med alt samlet i en enkelt programfiks under oppretting av kildepakken.
				</para>
				 <para>
					Det er vanskelig under slike forhold for å finne de korrigerende tiltak for å hindre gjentakelse av slike hendelser. Denne leksen ga her den lærdommen at alle divergenser Debian introduserer i oppstrøms programvare, må begrunnes, dokumenteres, sendes til oppstrømsprosjektetet når det er mulig, og publiseres vidt. Det er fra dette perspektivet at den nye kildepakkeformatet ("3.0 (quilt)") og webtjenesten for Debian-kilder ble utviklet. <ulink type="block" url="http://sources.debian.net" />
				</para>
				 </sidebar>
			</section>
			 <section id="sect.ssh-x11">
				<title>Using Remote X11 Applications</title>
				 <para>
					SSH-protokollen tillater videresending av grafiske data ("X11" sesjon, fra navnet på det mest utbredte grafiske systemet i Unix); tjeneren holder da en egen kanal for disse dataene. Spesielt kan et grafisk program, kjørt eksternt, vises på X.org-tjeneren til den lokale skjermen, og hele økten (inndata og visning) vil være sikker. Ettersom denne funksjonen tillater at eksterne programmer forstyrrer det lokale systemet, er det deaktivert som standard. Du kan aktivere det ved å angi <literal>X11Forwarding yes</literal> i tjenerkonfigurasjonsfilen (<filename>/etc/ssh/sshd_config</filename>). Avslutningsvis, brukeren må også be om de ved å legge <literal>-X</literal>-valget til <command>ssh</command>-kommandolinjen.
				</para>

			</section>
			 <section id="sect.ssh-port-forwarding">
				<title>Å lage krypterte tunneler med portvideresending</title>
				 <indexterm>
					<primary>port forwarding</primary>
				</indexterm>
				 <para>
					Dets <literal>-R</literal> og <literal>-L</literal> valg tillater <command>ssh</command> å lage "krypterte tunneler" mellom to maskiner, sikker videresending til en lokal TCP-port (se sidestolpe <xref linkend="sidebar.tcp-udp" />) til en ekstern maskin og omvendt.
				</para>
				 <sidebar> <title><emphasis>VOCABULARY</emphasis> Tunnel</title>
				 <indexterm>
					<primary>tunnel (SSH)</primary>
					<seealso>VPN</seealso>
				</indexterm>
				 <indexterm>
					<primary>SSH tunnel</primary>
					<seealso>VPN</seealso>
				</indexterm>
				 <para>
					Internettet, og de fleste lokalnett som er koblet til det, opererer i pakke-modus og ikke i tilkoblet modus. Noe som betyr at en pakke utstedt fra en datamaskin til en annen, kommer til å bli oppholdt på flere mellomliggende rutere for å finne veien til sin destinasjon. Du kan fortsatt simulere en tilkoblet operasjon der strømmen er innkapslet i normale IP-pakker. Disse pakkene følger sin vanlige rute, men strømmen blir rekonstruert uendret på destinasjonen. Vi kaller dette en "tunnel", tilsvarende en veitunnel der biler kjører direkte fra inngangen (inndata) til utgangen (utdata) uten å møte noen kryss, i motsetning til en bane på overflaten som ville innebære kryss og skiftende retninger .
				</para>
				 <para>
					Du kan bruke denne muligheten til å legge kryptering til tunnelen: Strømmen som flommer igjennom er da ugjenkjennelig fra utsiden, men den blir levert dekryptert ved utgangen av tunnelen.
				</para>
				 </sidebar> <para>
					<command>ssh -L 8000:server:25 intermediary</command> etablerer en SSH-økt med <replaceable>intermediary</replaceable>-verten og lytter til lokal port 8000 (see <xref linkend="figure.ssh-L" />). For alle tilkoblinger som etableres til denne porten, vil <command>ssh</command> initiere en forbindelse fra <replaceable>intermediary</replaceable>-datamaskinen til port 25 på <replaceable>server</replaceable>-tjeneren, og vil binde begge tilknytninger sammen.
				</para>
				 <para>
					<command>ssh -R 8000:server:25 intermediary</command> etablerer også en SSH-økt til <replaceable>intermediary</replaceable>-datamaskinen, men det er på denne maskinen at <command>ssh</command> lytter til port 8000 (se <xref linkend="figure.ssh-R" />). Alle tilknytninger som etablert til denne porten vil få <command>ssh</command> til å åpne en en tilknytning fra den lokale maskinen til port 25 hos <replaceable>server</replaceable>-en, og til å binde begge tilknytninger sammen.
				</para>
				 <para>
					I begge tilfeller er forbindelsene lagt til port 25 på <replaceable> 1server</replaceable>-verten, og passerer gjennom SSH-tunnelen som er etablert mellom den lokale maskinen og <replaceable> 3intermediary</replaceable>-maskinen. I det første tilfellet, er inngangen til tunnelen lokal port 8000, og dataene beveger seg mot <replaceable>intermediary</replaceable>-maskinen før de blir dirigert videre til <replaceable>server</replaceable>-en i det "offentlige" nettverket. I det andre tilfellet er inngangen og utgangen i tunnelen reversert: Inngangen er port 8000 på <replaceable>intermediary</replaceable>-maskinen, og utdataene er på den lokale verten, og dataene blir deretter sendt til <replaceable>server</replaceable>-en. I praksis er tjeneren vanligvis enten den lokale maskinen eller mellomstasjonen. På den måten sikrer SSH forbindelsen fra den ene enden til den andre.
				</para>
				 <figure id="figure.ssh-L">
					<title>Videresende en lokal port med SSH</title>
					 <mediaobject>
						<imageobject>
							<imagedata fileref="images/ssh-L.png" format="PNG" width="35%" />
						</imageobject>

					</mediaobject>

				</figure>
				 <figure id="figure.ssh-R">
					<title>Videresende en ekstern port med SSH</title>
					 <mediaobject>
						<imageobject>
							<imagedata fileref="images/ssh-R.png" format="PNG" width="35%" />
						</imageobject>

					</mediaobject>

				</figure>

			</section>

		</section>
		 <section id="sect.remote-desktops">
			<title>Å bruke eksterne grafiske skrivebord</title>
			 <para>
				VNC (Virtual Network Computing) tillater ekstern tilgang til grafiske skrivebord.
			</para>
			 <indexterm>
				<primary>VNC</primary>
			</indexterm>
			 <indexterm>
				<primary>Virtual Network Computing</primary>
			</indexterm>
			 <indexterm>
				<primary>graphical desktop</primary>
				<secondary>remote</secondary>
			</indexterm>
			 <indexterm>
				<primary>remote graphical desktop</primary>
			</indexterm>
			 <indexterm>
				<primary>desktop, remote graphical desktop</primary>
			</indexterm>
			 <para>
				Dette verktøyet er mest brukt for teknisk assistanse; administratoren kan se feil som brukeren står overfor, og vise dem hva det er riktige å gjøre, uten å måtte stå ved siden av dem.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vino</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">krfb</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">x11vnc</emphasis></primary>
			</indexterm>
			 <para>
				Først må brukeren autorisere deling av sin sesjon. GNOMEs grafiske skrivebordsmiljø i <emphasis role="distribution">Jessie</emphasis> omfatter dette alternativet i sitt konfigurasjonspanel (i motsetning til tidligere versjoner av Debian, der brukeren måtte installere og kjøre <command>vino</command>). KDE krever fortsatt at <command>krfb</command> brukes for å tillate deling av en eksisterende økt over VNC. For andre grafiske skrivebordsmiljøer, tjener <command>x11vnc</command>-kommandoen (fra Debian-pakken med samme navn) samme formål; Du kan gjøre det tilgjengelig for brukeren med et eksplisitt ikon.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vinagre</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">tsclient</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">krdc</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">xvnc4viewer</emphasis></primary>
			</indexterm>
			 <para>
				Når den grafiske økten er gjort tilgjengelig av VNC, må administratoren koble den til med en VNC klient. GNOME har <command>vinagre</command> og <command>remmina</command> til det, mens KDE innkluderer <command>krdc</command> (i menyen hos <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). Det er andre VNC-klienter som bruker kommandolinjen, for eksempel <command>xvnc4viewer</command> i Debian pakken med samme navn. Når du er tilkoblet, kan administratoren se hva som skjer, arbeide eksternt på maskinen, og vise brukeren hvordan man går frem.
			</para>
			 <sidebar> <title><emphasis>SECURITY</emphasis> VNC over SSH</title>
			 <indexterm>
				<primary>SSH tunnel</primary>
				<secondary>VNC</secondary>
			</indexterm>
			 <para>
				Hvis du ønsker å koble til med VNC, og du ikke vil at dataene sendes i klartekst på nettverket, er det mulig å kapsle dataene i en SSH-tunnel (se <xref linkend="sect.ssh-port-forwarding" />). Du bare må vite at VNC bruker port 5900 som standard for det første skjermbildet (kalt "localhost:0"), 5901 for den andre (kalt "localhost:1"), osv.
			</para>
			 <para>
				<command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command>-kommandoen oppretter en tunnel mellom lokal port 5901 i lokalvertgrensesnittet og til 5900-porten hos <replaceable>machine</replaceable>-verten. Den første "lokalverten" begrenser SSH til å lytte til bare det grensesnittet på den lokale maskinen. Den andre "lokalverten" indikerer grensesnittet på den eksterne maskinen som skal motta nettverkstrafikk til "localvertst:5901". Dermed vil <command>vncviewer localhost:1</command> knytte VNC-klienten til den eksterne skjermen, selv om du anga navnet på den lokale maskinen.
			</para>
			 <para>
				Når VNC sesjon er lukket, må du huske å stenge tunnelen ved også å avslutte den tilsvarende SSH-økten.
			</para>
			 </sidebar> <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Display manager</title>
			 <indexterm>
				<primary><command>gdm3</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>kdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>xdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>lightdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary>manager</primary>
				<secondary>display manager</secondary>
			</indexterm>
			 <indexterm>
				<primary>display manager</primary>
			</indexterm>
			 <para>
				<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, og <command>xdm</command> er Display Managere. De tar kontroll over det grafiske grensesnittet kort etter oppstart for å gi brukeren et innloggingsbilde. Når brukeren har logget inn, kjøres de programmene som trengs for å starte en grafisk arbeidsøkt .
			</para>
			 </sidebar> <para>
				VNC fungerer også for mobile brukere, eller næringslivsledere, som av og til trenger å logge inn hjemmefra for å få tilgang til et eksternt skrivebord lik det de bruker på jobben. Konfigurasjonen av en slik tjeneste er mer komplisert: Du må først installere<emphasis role="pkg">vnc4server</emphasis>pakken, endre oppsettet på skjermviseren til å godta <literal>XDMCP Query</literal>-forespørsler (for <command>gdm3</command>. Dette kan gjøres ved å legge til <literal>Enable=true</literal> i “xdmcp”-seksjonen til <filename>/etc/gdm3/daemon.conf</filename>), og til slutt, starte VNC-tjeneren med <command>inetd</command> slik at en økt starter automatisk når en bruker prøver å logge seg inn. For eksempel kan du legge til denne linjen til <filename>/etc/inetd.conf</filename>:
			</para>
			 
<programlisting>5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none
</programlisting>
			 <para>
				Å omdirigere innkomne forbindelser til skjermhåndterer, løser problemet med autentisering, fordi bare brukere med lokale kontoer vil passere logginn-skjermen <command>gdm3</command> login screen (eller tilsvarende <command>kdm</command>, <command>xdm</command>, etc.). Ettersom denne operasjonen tillater flere samtidige pålogginger uten problem (forutsatt at serveren er kraftig nok), kan den også brukes til å tilby komplette skrivebord til mobile brukere (eller til mindre kraftige stasjonære systemer, konfigurert som tynne klienter). Brukere logger bare inn på serverens skjerm med <command>vncviewer <replaceable>server</replaceable>:50</command>, fordi den benyttede porten er 5950.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vnc4server</emphasis></primary>
			</indexterm>

		</section>

	</section>
	 <section id="sect.rights-management">
		<title>Å håndtere rettigheter</title>
		 <para>
			Linux er definitivt et multi-bruker system, så det er nødvendig å gi en tillatelsessystem for å kontrollere et sett autoriserte operasjoner på filer og kataloger, for alle systemressurser og enheter (på et Unix-system, er enhver enhet representert ved en fil eller katalog). Dette prinsippet er felles for alle Unix-systemer, men en påminnelse er alltid nyttig, særlig fordi det er noen interessante og relativt ukjente, avanserte bruksmåter.
		</para>
		 <indexterm>
			<primary>rights</primary>
		</indexterm>
		 <indexterm>
			<primary>permissions</primary>
		</indexterm>
		 <indexterm>
			<primary>user</primary>
			<secondary>owner</secondary>
		</indexterm>
		 <indexterm>
			<primary>group</primary>
			<secondary>owner</secondary>
		</indexterm>
		 <indexterm>
			<primary>owner</primary>
			<secondary>user</secondary>
		</indexterm>
		 <indexterm>
			<primary>owner</primary>
			<secondary>group</secondary>
		</indexterm>
		 <para>
			Hver fil eller katalog har egne tillatelser for tre kategorier av brukere:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					dens eier (symbolisert ved <literal>u</literal> som i "user");
				</para>

			</listitem>
			 <listitem>
				<para>
					dens eiergruppe (symbolisert med <literal>g</literal> som i "gruppe"), som representerer alle medlemmene i gruppen;
				</para>

			</listitem>
			 <listitem>
				<para>
					de andre (symbolisert med <literal>o</literal> som i “other”).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Tre typer rettigheter kan kombineres:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					lesing (symbolisert med <literal>r</literal> som i “read”);
				</para>

			</listitem>
			 <listitem>
				<para>
					skrive (eller modifisere, symbolisert ved <literal>w</literal> som i “write”);
				</para>

			</listitem>
			 <listitem>
				<para>
					utføre (symbolisert med <literal>x</literal> som i “eXecute”).
				</para>

			</listitem>

		</itemizedlist>
		 <indexterm>
			<primary>read, right</primary>
		</indexterm>
		 <indexterm>
			<primary>write, right</primary>
		</indexterm>
		 <indexterm>
			<primary>modification, right</primary>
		</indexterm>
		 <indexterm>
			<primary>execution, right</primary>
		</indexterm>
		 <para>
			Når det gjelder en fil, er disse rettighetene lette å forstå: Lesetilgang tillater å lese innhold (inkludert kopiering), skrivetilgang tillater å endre den, og med kjøretilgang kan du kjøre den (som bare vil fungere hvis den er et program).
		</para>
		 <sidebar> <title><emphasis>SECURITY</emphasis> <literal>setuid</literal> og <literal>setgid</literal> kjørbare</title>
		 <para>
			To spesielle rettigheter er relevante for kjørbare filer:<literal>setuid</literal> og <literal>setgid</literal> (symbolisert med bokstaven "s"). Merk at vi ofte snakker om "bit", siden hver av disse boolske verdiene kan representeres ved en 0 eller et 1. Disse to rettighetene tillater alle brukere å kjøre programmet med henholdsvis rettighetene til eieren eller gruppen. Denne mekanismen gir tilgang til funksjoner som krever tillatelser på et høyere nivå enn du vanligvis har.
		</para>
		 <indexterm>
			<primary><literal>setuid</literal>, right</primary>
		</indexterm>
		 <indexterm>
			<primary><literal>setgid</literal>, right</primary>
		</indexterm>
		 <para>
			Ettersom et <literal>setuid</literal>-rotprogram systematisk kjøres under superbruker-identiteten, er det svært viktig å sikre at det er trygt og pålitelig. Faktisk, skulle en bruker klare å forbigå det for å bruke en kommando etter eget valg, kunne denne brukeren utgi seg for å være rotbruker og få alle rettigheter til systemet.
		</para>
		 </sidebar> <para>
			En katalog håndteres annerledes. Lesetilgang gir rett til å gjennomgå listen over oppføringene (filer og kataloger), skrivetilgang tillater å lage eller slette filer, og utføringstilgang tillater å krysse gjennom den (spesielt å gå dit med <command>cd</command>-kommandoen). Å kunne krysse gjennom en katalog uten å kunne lese den, gir tillatelse til å gå til de oppføringene som er kjent ved navn, men ikke til å finne dem hvis man ikke vet at de finnes, eller det nøyaktige navnet.
		</para>
		 <sidebar id="sidebar.setgid-dir"> <title><emphasis>SECURITY</emphasis> <literal>setgid</literal> directory and <emphasis>sticky bit</emphasis></title>
		 <indexterm>
			<primary><literal>setgid</literal> directory</primary>
		</indexterm>
		 <para>
			<literal>setgid</literal>-biten gjelder også kataloger. Enhvert nyopprettet elementet i slike kataloger blir automatisk knyttet til eiergruppen til den overordnede katalogen, i stedet for, som vanlig, å arve opphavsmannens hovedgruppe. Med dette oppsettet unngås det at brukeren trenger å endre sin hovedgruppe (med <command>newgrp</command>-kommandoen) når man arbeider i et fil-tre som deles mellom flere brukere i samme dediserte gruppe.
		</para>
		 <indexterm>
			<primary>sticky bit</primary>
		</indexterm>
		 <para>
			Den "klebrige" biten (symbolisert med bokstaven "t") er en tillatelse som bare er nyttig i kataloger. Det blir spesielt brukt for midlertidige kataloger, der alle har skrivetilgang (for eksempel <filename>/tmp/</filename>): Biten begrenser slettingen av filer slik at bare fileieren (eller eieren av den overordnede katalogen) kan gjøre det. Mangler denne, kan alle slette andre brukeres filer i <filename>/tmp/</filename>.
		</para>
		 </sidebar> <para>
			Tre kommandoer kontrollerer tillatelser knyttet til en fil:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					<command>chown <replaceable>user</replaceable> <replaceable>file</replaceable></command> endrer eieren av filen;
				</para>

			</listitem>
			 <listitem>
				<para>
					<command>chgrp <replaceable>group</replaceable> <replaceable>file</replaceable></command> endrer eiergruppen;
				</para>

			</listitem>
			 <listitem>
				<para>
					<command>chmod <replaceable>rights</replaceable> <replaceable>file</replaceable></command> endrer tillatelsene for filen.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Det er to måter å presentere rettighetene. Blant dem er den symbolske representasjon trolig den enkleste å forstå og huske. Det innebærer bokstavsymboler som nevnt ovenfor. Du kan definere rettigheter for hver kategori av brukere (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), ved å sette dem eksplisitt (ved <literal>=</literal>), ved å legge til (<literal>+</literal>), eller trekke fra (<literal>-</literal>). Dermed gir <literal>u=rwx,g+rw,o-r</literal>-formulaen eieren lese-, skrive-, og utførings-rettigheter, legger til lese- og skriverettigheter for eiergruppen, og fjerner leserettigheter for andre brukere. Rettigheter som ikke er endret ved tilsetninger eller subtraksjon i en slik kommando, forblir uendret. Bokstaven <literal>a</literal>, for “alle”, dekker alle tre kategorier brukere, slik at <literal>a=rx</literal> gir alle tre kategorier de samme rettigheter (lese og kjøre, men ikke skrive).
		</para>
		 <indexterm>
			<primary><command>chmod</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>chown</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>chgrp</command></primary>
		</indexterm>
		 <indexterm>
			<primary>octal representation of rights</primary>
		</indexterm>
		 <indexterm>
			<primary>rights</primary>
			<secondary>octal representation</secondary>
		</indexterm>
		 <para>
			Den (åttetalls-) numeriske representasjonen forbinder hver rettighet med en verdi: 4 for lese-, 2 for skrive, og 1 for å utføre. Vi forbinder hver kombinasjon av rettigheter med summen av tallene. Hver verdi blir deretter knyttet til ulike kategorier av brukere ved å sette dem side ved side i den vanlige rekkefølgen (eier, gruppe, andre).
		</para>
		 <para>
			For eksempel <command>chmod 754 <replaceable>file</replaceable></command> kommandoen vil gi de følgende rettigheter: lese, skrive og utføre for eieren (fordi 7 = 4 + 2 + 1); lese og utføre for gruppen (fordi 5 = 4 + 1); bare lese for andre. <literal>0</literal> betyr ingen rettigheter; da <command>chmod 600 <replaceable>file</replaceable></command> tillater lese/skrive-rettigheter for eieren, og ingen rettigheter for noen andre. De hyppigste rettighetskombinasjonene er <literal>755</literal> for kjørbare filer og kataloger, og <literal>644</literal> for datafiler.
		</para>
		 <para>
			Å representere spesielle rettigheter, kan du stille et fjerde siffer foran dette tallet etter samme prinsipp, der <literal>setuid</literal>, <literal>setgid</literal> og <literal>sticky</literal>-bitene er 4, 2 and 1, respektivt. <command>chmod 4754</command> vil knytte <literal>setuid</literal>-biten til den tidligere beskrevne rettigheten.
		</para>
		 <para>
			Merk at bruk av åttetallsystemet bare tillater å sette alle rettigheter samtidig i en fil; Du kan ikke bruke den til å bare legge til en ny rett, slik som lesetilgang for gruppens eier, siden du må ta hensyn til eksisterende rettigheter og beregne ny tilsvarende tallverdi.
		</para>
		 <sidebar> <title><emphasis>TIP</emphasis> Gjentatte operasjoner</title>
		 <para>
			Noen ganger må vi endre rettighetene for et helt fil-tre. Alle kommandoene ovenfor har en <literal>-R</literal>-mulighet til å operere gjentakende i underkataloger.
		</para>
		 <para>
			Skillet mellom kataloger og filer fører noen ganger til problemer med rekursive operasjoner. Derfor er "X"-bokstaven innført i symboloversikten over rettigheter. Den representerer en rett til å utføre noe som bare gjelder kataloger (og som ikke gjelder filer som ikke har denne retten). Dermed vil <command>chmod -R a+X <replaceable>directory</replaceable></command> bare legge til utføringsrettigheter for alle kategorier av brukere (<literal>a</literal>) for alle underkataloger, og filer der minst én brukerkategori (selv om det er eneeieren) allerede har utføringsrettigheter.
		</para>
		 </sidebar> <sidebar> <title><emphasis>TIP</emphasis> Endre bruker og gruppe</title>
		 <para>
			Ofte vil du ønske å endre filgruppen samtidig som du endre eier <command>chown</command>-kommandoen har en egen syntaks for det: <command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command>
		</para>
		 </sidebar> <sidebar> <title><emphasis>GOING FURTHER</emphasis> <command>umask</command></title>
		 <para>
			Når et program oppretter en fil, tildeler det indikative tillatelser, vel vitende om at systemet fjerner visse rettigheter, gitt av kommandoen <command>umask</command>. Skriv inn <command>umask</command> i et skall; og du vil se en maske slik som <computeroutput>0022</computeroutput>. Dette er rett og slett en åttetalls-representasjon av rettighetene som systematisk skal fjernes (i dette tilfellet, skriverettigheten for gruppen og andre brukere).
		</para>
		 <indexterm>
			<primary>umask</primary>
		</indexterm>
		 <indexterm>
			<primary>rights</primary>
			<secondary>mask</secondary>
		</indexterm>
		 <indexterm>
			<primary>mask</primary>
			<secondary>rights mask</secondary>
		</indexterm>
		 <para>
			Hvis du gir den en ny oktal verdi, modifiserer <command>umask</command> -kommandoen masken. Brukt i en skall-initialiseringsfil (for eksempel <filename>~/.bash_profile</filename>), vil den effektivt endre standardmasken for dine arbeidsøkter.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.administration-interfaces">
		<title>Administrasjonsgrensesnitt</title>
		 <indexterm>
			<primary>interface</primary>
			<secondary>administration interface</secondary>
		</indexterm>
		 <indexterm>
			<primary>administration, interfaces</primary>
		</indexterm>
		 <para>
			Å bruke et grafisk administrasjonsgrensesnitt er interessant i ulike situasjoner. En administrator kjenner ikke nødvendigvis alle konfigurasjonsdetaljer for alle sine tjenester, og har ikke alltid tid til å gå igjennom dokumentasjonen i saken. En grafisk administrasjonsgrensesnitt kan dermed akselerere utplassering av en ny tjeneste. Det kan også forenkle oppsettet av tjenester som er vanskelige å konfigurere.
		</para>
		 <para>
			Et slikt grensesnittet er bare et hjelpemiddel, og ikke et mål i seg selv. I alle tilfelle må administratoren beherske hvordan det virker for å forstå og løse mulige problemer.
		</para>
		 <para>
			Siden ingen grensesnitt er perfekte, kan du bli fristet til å prøve ulike løsninger. Dette bør så mye som mulig unngås, siden arbeidsmetodikken til ulike verktøy ofte er ofte uforenlige. Selv om alle har som mål å være svært fleksible og prøve å adoptere konfigurasjonsfilen som en eneste referanse, er de ikke alltid i stand til å integrere eksterne endringer.
		</para>
		 <section id="sect.webmin">
			<title>Å administrere med et nettbrukergrensesnitt: <command>webmin</command></title>
			 <indexterm>
				<primary><emphasis>webmin</emphasis></primary>
			</indexterm>
			 <para>
				Dette er uten tvil en av de mest vellykkede administrasjonsgrensesnittene. Det er et modulsystem styret gjennom en nettleser, og dekker et bredt spekter av områder og verktøy. Videre er det internasjonalisert og tilgjengelig på mange språk.
			</para>
			 <para>
				Trist nok, <command>webmin</command> er ikke lenger en del av Debian. Debian vedlikeholder - Jaldhar H. Vyas - fjernet pakkene han hadde laget fordi han ikke lenger hadde den tiden som er nødvendig til å vedlikeholde dem på et akseptabelt kvalitetsnivå. Ingen har offisielt tatt over, så <emphasis role="distribution">Jessie</emphasis> har ikke med <command>webmin</command>-pakken.
			</para>
			 <para>
				Det er imidlertid en uoffisiell pakke fordelt på <literal>webmin.com</literal>-nettsiden. Til forskjell fra den opprinnelige Debian-pakken, er denne pakken monolittisk; alle konfigurasjonsmodulene installeres og aktiveres som standard, selv om den tilsvarende tjenesten ikke er installert på maskinen.
			</para>
			 <sidebar> <title><emphasis>SECURITY</emphasis> Endre rotpassordet</title>
			 <para>
				Ved den første innloggingen, blir identifikasjon avklart med rotbrukernavn og tilhørende passord. Det anbefales å endre passordet som brukes for <command>webmin</command> så snart som mulig, slik at hvis det er kompromittert, berøres ikke rot-passordet, selv om dette tildeler viktige administrative rettigheter til maskinen.
			</para>
			 <para>
				Vær forsiktig! Fordi <command>webmin</command> har så mange funksjoner, vil en ondsinnet bruker med tilgang til den kunne kompromittere sikkerheten til hele systemet. Generelt er grensesnitt av denne typen ikke anbefalt for viktige systemer med sterke sikkerhetsbegrensninger (brannmur, sensitive servere, etc.).
			</para>
			 </sidebar> <para>
				Webmin brukes via et nettgrensesnitt, men krever ikke at Apache installeres. I hovedsak har dette programmet sin egen integrerte mini-nettjener. Denne tjeneren lytter som standard på port 10000 og aksepterer sikre HTTP-tilkoblinger.
			</para>
			 <para>
				De inkluderte moduler dekker et bredt spekter av tjenester, blant disse er:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						alle basistjenester: oppretting av brukere og grupper, håndtering av <filename>crontab</filename>-filer, init skripter, å se logger, etc.
					</para>

				</listitem>
				 <listitem>
					<para>
						bind: DNS tjeneroppsett (navntjeneste);
					</para>

				</listitem>
				 <listitem>
					<para>
						postfix: SMTP tjeneroppsett (e-post);
					</para>

				</listitem>
				 <listitem>
					<para>
						inetd: oppsett for <command>inetd</command>-supertjeneren;
					</para>

				</listitem>
				 <listitem>
					<para>
						quota: brukerkvotehåndtering;
					</para>

				</listitem>
				 <listitem>
					<para>
						dhcpd: DHCP-tjeneroppsett;
					</para>

				</listitem>
				 <listitem>
					<para>
						proftpd: FTP-tjeneroppsett;
					</para>

				</listitem>
				 <listitem>
					<para>
						samba: Samba filtjeneroppsett;
					</para>

				</listitem>
				 <listitem>
					<para>
						software: Installasjon eller fjerning av programvare fra Debian-pakker og systemoppdateringer .
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Administrasjonsgrensesnittet er tilgjengelig i en nettleser på <literal>https://localhost:10000</literal>. Pass opp! Ikke alle modulene kan brukes direkte. Noen ganger må de konfigureres ved å angi plasseringen av de tilhørende konfigurasjonsfiler og noen kjørbare filer (programmer). Ofte vil systemet høflig be deg når det ikke klarer å aktivere en modulen det er bedt om.
			</para>
			 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> GNOME kontrollsenter</title>
			 <indexterm>
				<primary><emphasis role="pkg">gnome-control-center</emphasis></primary>
			</indexterm>
			 <para>
				GNOME-prosjektet gir også flere administrasjonsgrensesnitt som vanligvis er tilgjengelig via <command>gnome-control-center</command> er hovedprogrammet som bringer dem alle sammen, men mange av de brede konfigurasjonsverktøy system er effektivt levert av andre pakker (<emphasis role="pkg">accountsservice</emphasis>, <emphasis role="pkg">system-config-printer</emphasis>, etc.). Selv om de er enkle å bruke, dekker disse programmene kun et begrenset antall basetjenester: Brukeradministrasjon, tidsoppsett, nettverksoppsett, skriveroppsett, og så videre.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.debconf">
			<title>Oppsettspakker: <command>debconf</command></title>
			 <indexterm>
				<primary><command>debconf</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>dpkg-reconfigure</command></primary>
			</indexterm>
			 <para>
				Mange pakker blir automatisk konfigurert etter å ha spurt noen spørsmål under installasjon via Debconf-verktøyet. Disse pakkene kan konfigureres ved å kjøre <command>dpkg-reconfigure <replaceable>package</replaceable></command>.
			</para>
			 <para>
				I de fleste tilfeller er disse innstillingene veldig enkle; Bare noen få viktige variabler i konfigurasjonsfilen er endret. Disse variablene er ofte gruppert mellom to "avgrensnings"-linjer slik at ny konfigurering av pakken bare påvirker dette avgrensede området. I andre tilfeller, vil ikke en ny konfigurering endre noe om skriptet oppdager en manuell endring i konfigurasjonsfilen, for å kunne bevare disse manuelle inngrepene (fordi skriptet ikke kan sikre at egne tilpasninger ikke vil forstyrre eksisterende innstillinger).
			</para>
			 <sidebar> <title><emphasis>DEBIAN POLICY</emphasis> Ta vare på forandringer</title>
			 <para>
				Debian Policy-en fastslår uttrykkelig at alt skal gjøres for å bevare manuelle endringer i en konfigurasjonsfil, slik at flere og flere skript ta forholdsregler når du redigerer konfigurasjonsfiler. Det generelle prinsippet er enkelt: Skriptet vil bare gjøre endringer hvis den kjenner statusen til konfigurasjonsfilen, som er bekreftet ved å sammenligne kontrollsummen til filen mot den til den siste automatisk generert filen. Hvis de er de samme, er skriptet autorisert til å endre konfigurasjonsfilen. Ellers bestemmer det at filen er blitt endret, og spør hvilke tiltak det skal ta (installere den nye filen, lagre den gamle filen, eller prøve å integrere de nye endringene med den eksisterende filen). Dette føre var-prinsippet har lenge vært unikt for Debian, men andre distribusjoner har gradvis begynt å omfavne det.
			</para>
			 <para>
				<command>ucf</command> programmet (fra Debian pakken med samme navn) kan brukes til å få til at det skjer.
			</para>
			 <indexterm>
				<primary><command>ucf</command></primary>
			</indexterm>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.syslog">
		<title><command>syslog</command> Systemhendelser</title>
		 <indexterm>
			<primary><command>rsyslogd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>files</primary>
			<secondary>log files</secondary>
		</indexterm>
		 <indexterm>
			<primary>logs</primary>
			<secondary>dispatching</secondary>
		</indexterm>
		 <section id="sect.syslog-principe">
			<title>Prinsipp og mekanisme</title>
			 <para>
				<command>rsyslogd</command>-nissen er ansvarlig for innsamling av servicemeldinger som kommer fra programmer og kjernen, og deretter ekspedere dem til loggfiler (vanligvis lagret i <filename>/var/log/</filename> mappen). Den adlyder konfigurasjonsfilen <filename>/etc/rsyslog.conf</filename>.
			</para>
			 <para>
				Hver loggmelding er forbundet med en delsystemapplikasjon (kalt "facility" i dokumentasjonen):
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>auth</literal> og <literal>authpriv</literal>: for autentisering;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>cron</literal>: kommer fra aktivitetsplanleggingstjenester,<command>cron</command> og <command>atd</command>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>daemon</literal>: påvirker en nisse uten noen spesiell klassifisering (DNS, NTP, etc.);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ftp</literal>: gjelder FTP-tjeneren;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>kern</literal>: melding kommer fra kjernen;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>lpr</literal>: kommer fra skriver-delsystemet;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>mail</literal>: kommer fra e-post-delsystemet;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>news</literal>: Usenet delsystem-melding (spesielt fra en NNTP - Network News Transfer Protocol-tjener som styrer nyhetsgrupper);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>syslog</literal>: melding fra <command>syslogd</command>-tjeneren, seg selv;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>user</literal>: brukermeldinger (generisk);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uucp</literal>: meldinger fra UUCP tjeneren (Unix til Unix Copy Program, en gammel protokoll som særlig brukes til å distribuere e-postmeldinger);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>local0</literal> til <literal>local7</literal>: reservert for lokal bruk.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Hver melding er også knyttet til et prioritetsnivå. Her er listen i synkende rekkefølge:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>emerg</literal>: "Hjelp!" Det er krise, systemet er sannsynligvis ikke brukes.
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>alert</literal>: skynd deg, enhver forsinkelse kan være farlig, det må handles umiddelbart;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>crit</literal>: forholdene er kritiske;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>err</literal>: feil;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>warn</literal>: advarsel (mulig fare);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>notice</literal>: forholdene er normale, men budskapet er viktig;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>info</literal>: informativt budskap;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>debug</literal>: feilsøkingsbudskap.
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section id="sect.syslog-config">
			<title>Konfigurasjonsfilen</title>
			 <para>
				Syntaksen til <filename>/etc/rsyslog.conf</filename>-file detaljeres i <citerefentry><refentrytitle>rsyslog.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>-manualside, men det er også HTML-dokumentasjon tilgjengelig i <emphasis role="pkg">rsyslog-doc</emphasis> package (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). Det gjennomgående prinsippet er å skrive "selector" og "action"-par. "Selector" definerer alle relevante meldinger, og handlingene beskriver hvordan man skal håndtere dem.
			</para>
			 <section id="sect.syslog-selector-syntax">
				<title>Syntaksen til Selector</title>
				 <para>
					Selectoren er en semikolon-delt liste med <literal><replaceable>subsystem</replaceable>.<replaceable>priority</replaceable></literal>-par (for eksempel: <literal>auth.notice;mail.info</literal>). En stjerne kan representere alle delsystemer eller alle prioriteringer (eksempler:<literal>*.alert</literal> eller <literal>mail.*</literal>). En stjerne kan representere alle delsystemer eller alle prioriteringer (eksempler:<literal>auth,mail.info</literal>). Den indikerte prioriteten dekker også meldinger med tilsvarende eller høyere prioritet; på den måten <literal>auth.alert</literal> indikerer <literal>auth</literal> subsystem-meldingene til <literal>alert</literal> eller <literal>emerg</literal> prioritet. Prefiks med et utropstegn (!), indikerer det motsatte, med andre ord de strengt tatt lavere prioriteringer; <literal>auth.!notice</literal>, og indikerer dermed meldinger utstedt fra <literal>auth</literal>, med <literal>info</literal> eller <literal>debug</literal> prioritet. Prefiks med et likhetstegn (=), tilsvarer presist og bare den angitte prioriteten (<literal>auth.=notice</literal> angår bare budskap fra <literal>auth</literal> med <literal>notice</literal> prioritet).
				</para>
				 <para>
					Hvert element i Selector-listen overstyrer tidligere elementer. Dermed er det mulig å avgrense et sett eller å utestenge visse elementer fra den. For eksempel betyr <literal>kern.info;kern.!err</literal> meldinger fra kjernen med prioritet mellom <literal>info</literal> og <literal>warn</literal>. <literal>none</literal>-prioritet indikerer det tomme settet (ingen prioriteringer), og kan tjene til å utelukke et delsystem fra et sett med meldinger. Dermed indikerer <literal>*.crit;kern.none</literal> alle meldingene med prioritet lik eller høyere enn <literal>crit</literal> som ikke kommer fra kjernen.
				</para>

			</section>
			 <section id="sect.syslog-action-syntax">
				<title>Syntaks for handlinger</title>
				 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Den navngitte kanalen, en vedvarende kanal</title>
				 <indexterm>
					<primary>named pipe</primary>
				</indexterm>
				 <indexterm>
					<primary>pipe, named pipe</primary>
				</indexterm>
				 <para>
					En navngitt kanal er en spesiell type fil som virker som en tradisjonell kanal (kanalen som du lager med "|" -symbolet på kommandolinjen), men via en fil. Denne mekanismen har fordelen av å kunne forholde seg til to ikke-relaterte prosesser. Alt som er skrevet til en navngitt kanal blokker prosessen som skriver frem til en annen fremgangsmåte forsøker å lese de data som er skrevet. Denne andre prosessen leser de dataene som er skrevet av den første, som så kan gjenoppta kjøringen.
				</para>
				 <para>
					En slik fil er laget med <command>mkfifo</command> kommandoen.
				</para>
				 </sidebar> <para>
					De forskjellige mulige handlinger er:
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							å legge til en melding til en fil (eksempel: <filename>/var/log/messages</filename>);
						</para>

					</listitem>
					 <listitem>
						<para>
							sende meldingen til en ekstern <command>syslog</command> tjener (eksempel: <literal>@log.falcot.com</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							sende meldingen til en eksisterende navngitt kanal (example: <literal>|/dev/xconsole</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							sende meldingen til en eller flere brukere, hvis de er logget inn (eksempel:<literal>root,rhertzog</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							sende meldingen til alle innloggede brukere (eksempel: <literal>*</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							skrive meldingen i et tekstkonsoll (eksempel: <literal>/dev/tty8</literal>).
						</para>

					</listitem>

				</itemizedlist>
				 <sidebar> <title><emphasis>SECURITY</emphasis> Å videresende logger</title>
				 <indexterm>
					<primary>log</primary>
					<secondary>forwarding</secondary>
				</indexterm>
				 <para>
					Det er en god idé å spille inn de viktigste loggene på en annen maskin (kanskje avsatt til dette formålet), siden dette vil hindre eventuell inntrenger fra å fjerne inntrengningsspor (med mindre, selvfølgelig, de også kompromitterer denne andre tjeneren). Videre har du, ved et stort problem (for eksempel et kjernekrasj), logger tilgjengelig på en annen maskin, noe som øker dine sjanser til å bestemme rekkefølgen av hendelser som forårsaket ulykken.
				</para>
				 <para>
					For å godta loggmeldinger sendt fra andre maskiner, må du konfigurere <emphasis>rsyslog</emphasis>: I praksis, er det tilstrekkelig å aktivere de ferdig-til-bruk oppføringene i <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> og <literal>$UDPServerRun 514</literal>).
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.inetd">
		<title>The <command>inetd</command> Super-Server</title>
		 <para>
			Inetd (ofte kalt "Internet super-tjener") er en tjener for tjenere. Den kjører sjelden brukte tjenere etter behov, slik at de slipper å kjøre kontinuerlig.
		</para>
		 <indexterm>
			<primary><command>inetd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>super-server</primary>
		</indexterm>
		 <para>
			<filename>/etc/inetd.conf</filename>-filen lister disse tjenerne og deres vanlige porter. <command>inetd</command>kommandoen lytter til dem alle; Når den oppdager en forbindelse til en slik port, kjører den det tjenesteprogrammet som hører til.
		</para>
		 <sidebar> <title><emphasis>DEBIAN POLICY</emphasis> Å registrere en tjener i <filename>inetd.conf</filename></title>
		 <para>
			Pakker ønsker ofte å registrere en ny tjener i <filename>/etc/inetd.conf</filename> filen, men Debian Policy forhindrer alle pakker fra å modifisere en konfigurasjonsfil som den ikke eier. Dette er grunnen til at <command>update-inetd</command> skriptet (i pakken med samme navn) ble opprettet: Den håndterer konfigurasjonsfilen, og andre pakker kan dermed bruke den til å registrere en ny tjener i super-tjenerens konfigurasjon.
		</para>
		 </sidebar> <para>
			Hver viktige linje i <filename>/etc/inetd.conf</filename>filen beskriver en tjener med syv felt (atskilt med mellomrom):
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					TCP eller UDP portnummer, eller tjenestenavnet (som er koblet til et standard portnummer med den informasjonen som finnes i <filename>/etc/services</filename> file).
				</para>

			</listitem>
			 <listitem>
				<para>
					Type socket: <literal>stream</literal> for en TCP-forbindelse, <literal>dgram</literal> for UDP datagrammer.
				</para>

			</listitem>
			 <listitem>
				<para>
					Protokollen: <literal>tcp</literal> eller <literal>udp</literal>.
				</para>

			</listitem>
			 <listitem>
				<para>
					Valgene: To mulige verdier: <literal>wait</literal> eller <literal>nowait</literal>, for å formidle til <command>inetd</command> om det skal vente eller ikke til slutten av den startede prosessen før du godtar en annen forbindelse. For TCP-forbindelser, enkelt multiplexbare, kan du vanligvis bruke <literal>nowait</literal>. For programmer som svarer over UDP, skal du bruke <literal>nowait</literal> bare hvis tjeneren kan håndtere flere tilkoblinger i parallell. Du kan ende dette feltet med et punktum, fulgt av det maksimale antall forbindelser autorisert per minutt (standardgrensen er 256).
				</para>

			</listitem>
			 <listitem>
				<para>
					Brukernavnet til brukeren under hvilken identitet tjeneren vil kjøre.
				</para>

			</listitem>
			 <listitem>
				<para>
					Den fullstendige banen til det tjenerprogrammet som skal kjøres.
				</para>

			</listitem>
			 <listitem>
				<para>
					Argumentene: Dette er en oversikt over programmets argumenter, inkludert dets egne navn (<literal>argv[0]</literal> in C).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Følgende eksempel illustrerer de mest vanlige tilfellene:
		</para>
		 <example id="example.inetd-conf">
			<title>Utdrag fra <filename>/etc/inetd.conf</filename></title>
			 
<programlisting>talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd
finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd
ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i
</programlisting>

		</example>
		 <indexterm>
			<primary><command>tcpd</command></primary>
		</indexterm>
		 <para>
			<command>tcpd</command>-programmet er ofte brukt i <filename>/etc/inetd.conf</filename>-filen. Det lar deg begrense innkommende tilkoblinger ved å bruke regler for adgangskontroll, dokumentert på manualsiden <citerefentry><refentrytitle>hosts_access</refentrytitle>
			<manvolnum>5</manvolnum></citerefentry>, og som er konfigurert i <filename>/etc/hosts.allow</filename> og <filename>/etc/hosts.deny</filename>-filene. Når det er fastslått at tilkoblingen er autorisert,<command>tcpd</command> kjøres den virkelige tjeneren (som <command>in.fingerd</command> i vårt eksempel). Det er ikke verd noe at <command>tcpd</command> støtter seg til det navnet det ble aktivert med (som er det første argumentet, <literal>argv[0]</literal>) for å identifisere det virkelige programmet skal kjøres. Så du bør ikke starte arguments liste med <literal>tcpd</literal> men med det omgivende programmet.
		</para>
		 <sidebar> <title><emphasis>COMMUNITY</emphasis> Wietse Venema</title>
		 <indexterm>
			<primary>Wietse Venema</primary>
		</indexterm>
		 <indexterm>
			<primary>Venema, Wietse</primary>
		</indexterm>
		 <para>
			Wietse Venema, hvis ekspertise innen sikkerhet har gjort ham til en kjent programmerer, er forfatter av <command>tcpd</command> programmet. Han er også den viktigste skaperen av Postfix, den modulære e-post (SMTP, Simple Mail Transfer Protocol), designet for å være tryggere og mer pålitelig enn <command>sendmail</command>, som har en lang historie med sikkerhetsproblemer.
		</para>
		 </sidebar> <sidebar> <title><emphasis>ALTERNATIVE</emphasis> Other <command>inetd</command>-kommandoer</title>
		 <para>
			Mens Debian installerer <emphasis role="pkg">openbsd-inetd</emphasis> ved oppstart, mangler det ikke alternativer. Vi kan nevne <emphasis role="pkg">inetutils-inetd</emphasis>, <emphasis role="pkg">micro-inetd</emphasis>, <emphasis role="pkg">rlinetd</emphasis> og <emphasis role="pkg">xinetd</emphasis>.
		</para>
		 <para>
			Denne siste utgaven av en super-tjener tilbyr svært interessante muligheter. Først og fremst kan konfigurasjonen deles opp i flere filer (lagret, selvfølgelig, i <filename>/etc/xinetd.d/</filename>-mappen), noe som kan gjøre en administrators liv lettere.
		</para>
		 <para>
			Sist men ikke minst, er det også mulig å etterligne <command>inetd</command>s virke med <command>systemd</command>s socket-akiveringsmekanisme (se <xref linkend="sect.systemd" />).
		</para>
		 </sidebar>
	</section>
	 <section id="sect.task-scheduling-cron-atd">
		<title>Tidfeste oppgaver med <command>cron</command> og <command>atd</command></title>
		 <indexterm>
			<primary><command>cron</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>atd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>scheduled commands</primary>
		</indexterm>
		 <indexterm>
			<primary>command scheduling</primary>
		</indexterm>
		 <para>
			<command>cron</command> is the daemon responsible for executing scheduled and recurring commands (every day, every week, etc.); <command>atd</command> is that which deals with commands to be executed a single time, but at a specific moment in the future.
		</para>
		 <para>
			In a Unix system, many tasks are scheduled for regular execution:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					rotating the logs;
				</para>

			</listitem>
			 <listitem>
				<para>
					updating the database for the <command>locate</command> program;
				</para>

			</listitem>
			 <listitem>
				<para>
					back-ups;
				</para>

			</listitem>
			 <listitem>
				<para>
					maintenance scripts (such as cleaning out temporary files).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			By default, all users can schedule the execution of tasks. Each user has thus their own <emphasis>crontab</emphasis> in which they can record scheduled commands. It can be edited by running <command>crontab -e</command> (its content is stored in the <filename>/var/spool/cron/crontabs/<replaceable>user</replaceable></filename> file).
		</para>
		 <sidebar> <title><emphasis>SECURITY</emphasis> Restricting <command>cron</command> or <command>atd</command></title>
		 <para>
			You can restrict access to <command>cron</command> by creating an explicit authorization file (whitelist) in <filename>/etc/cron.allow</filename>, in which you indicate the only users authorized to schedule commands. All others will automatically be deprived of this feature. Conversely, to only block one or two troublemakers, you could write their username in the explicit prohibition file (blacklist), <filename>/etc/cron.deny</filename>. This same feature is available for <command>atd</command>, with the <filename>/etc/at.allow</filename> and <filename>/etc/at.deny</filename> files.
		</para>
		 </sidebar> <para>
			The root user has their own <emphasis>crontab</emphasis>, but can also use the <filename>/etc/crontab</filename> file, or write additional <emphasis>crontab</emphasis> files in the <filename>/etc/cron.d</filename> directory. These last two solutions have the advantage of being able to specify the user identity to use when executing the command.
		</para>
		 <para>
			The <emphasis>cron</emphasis> package includes by default some scheduled commands that execute:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					programs in the <filename>/etc/cron.hourly/</filename> directory once per hour;
				</para>

			</listitem>
			 <listitem>
				<para>
					programs in <filename>/etc/cron.daily/</filename> once per day;
				</para>

			</listitem>
			 <listitem>
				<para>
					programs in <filename>/etc/cron.weekly/</filename> once per week;
				</para>

			</listitem>
			 <listitem>
				<para>
					programs in <filename>/etc/cron.monthly/</filename> once per month.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Many Debian packages rely on this service: by putting maintenance scripts in these directories, they ensure optimal operation of their services.
		</para>
		 <section id="sect.format-crontab">
			<title>Format of a <filename>crontab</filename> File</title>
			 <indexterm>
				<primary><filename>crontab</filename></primary>
			</indexterm>
			 <sidebar> <title><emphasis>TIP</emphasis> Text shortcuts for <command>cron</command></title>
			 <para>
				<command>cron</command> recognizes some abbreviations which replace the first five fields in a <filename>crontab</filename> entry. They correspond to the most classic scheduling options:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>@yearly</literal>: once per year (January 1, at 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@monthly</literal>: once per month (the 1st of the month, at 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@weekly</literal>: once per week (Sunday at 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@daily</literal>: once per day (at 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@hourly</literal>: once per hour (at the beginning of each hour).
					</para>

				</listitem>

			</itemizedlist>
			 </sidebar> <sidebar> <title><emphasis>SPECIAL CASE</emphasis> <command>cron</command> and daylight savings time</title>
			 <para>
				In Debian, <command>cron</command> takes the time change (for Daylight Savings Time, or in fact for any significant change in the local time) into account as best as it can. Thus, the commands that should have been executed during an hour that never existed (for example, tasks scheduled at 2:30 am during the Spring time change in France, since at 2:00 am the clock jumps directly to 3:00 am) are executed shortly after the time change (thus around 3:00 am DST). On the other hand, in autumn, when commands would be executed several times (2:30 am DST, then an hour later at 2:30 am standard time, since at 3:00 am DST the clock turns back to 2:00 am) are only executed once.
			</para>
			 <para>
				Be careful, however, if the order in which the different scheduled tasks and the delay between their respective executions matters, you should check the compatibility of these constraints with <command>cron</command>'s behavior; if necessary, you can prepare a special schedule for the two problematic nights per year.
			</para>
			 </sidebar> <para>
				Each significant line of a <emphasis>crontab</emphasis> describes a scheduled command with the six (or seven) following fields:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						the value for the minute (number from 0 to 59);
					</para>

				</listitem>
				 <listitem>
					<para>
						the value for the hour (from 0 to 23);
					</para>

				</listitem>
				 <listitem>
					<para>
						the value for the day of the month (from 1 to 31);
					</para>

				</listitem>
				 <listitem>
					<para>
						the value for the month (from 1 to 12);
					</para>

				</listitem>
				 <listitem>
					<para>
						the value for the day of the week (from 0 to 7, 1 corresponding to Monday, Sunday being represented by both 0 and 7; it is also possible to use the first three letters of the name of the day of the week in English, such as <literal>Sun</literal>, <literal>Mon</literal>, etc.);
					</para>

				</listitem>
				 <listitem>
					<para>
						the user name under whose identity the command must be executed (in the <filename>/etc/crontab</filename> file and in the fragments located in <filename>/etc/cron.d/</filename>, but not in the users' own crontab files);
					</para>

				</listitem>
				 <listitem>
					<para>
						the command to execute (when the conditions defined by the first five columns are met).
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				All these details are documented in the <citerefentry><refentrytitle>crontab</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry> man page.
			</para>
			 <para>
				Each value can be expressed in the form of a list of possible values (separated by commas). The syntax <literal>a-b</literal> describes the interval of all the values between <literal>a</literal> and <literal>b</literal>. The syntax <literal>a-b/c</literal> describes the interval with an increment of <literal>c</literal> (example: <literal>0-10/2</literal> means <literal>0,2,4,6,8,10</literal>). An asterisk <literal>*</literal> is a wildcard, representing all possible values.
			</para>
			 <example id="example.crontab">
				<title>Sample <filename>crontab</filename> file</title>
				 
<programlisting>#Format
#min hour day mon dow  command

# Download data every night at 7:25 pm
 25  19   *   *   *    $HOME/bin/get.pl

# 8:00 am, on weekdays (Monday through Friday)
 00  08   *   *   1-5  $HOME/bin/dosomething

# Restart the IRC proxy after each reboot
@reboot /usr/bin/dircproxy
</programlisting>

			</example>
			 <sidebar> <title><emphasis>TIP</emphasis> Executing a command on boot</title>
			 <para>
				To execute a command a single time, just after booting the computer, you can use the <literal>@reboot</literal> macro (a simple restart of <command>cron</command> does not trigger a command scheduled with <literal>@reboot</literal>). This macro replaces the first five fields of an entry in the <emphasis>crontab</emphasis>.
			</para>
			 </sidebar> <sidebar> <title><emphasis>ALTERNATIVE</emphasis> Emulating <command>cron</command> with <command>systemd</command></title>
			 <para>
				It is possible to emulate part of <command>cron</command>'s behaviour with <command>systemd</command>'s timer mechanism (see <xref linkend="sect.systemd" />).
			</para>
			 </sidebar>
		</section>
		 <section id="sect.at-command">
			<title>Using the <command>at</command> Command</title>
			 <indexterm>
				<primary><command>at</command></primary>
			</indexterm>
			 <para>
				The <command>at</command> executes a command at a specified moment in the future. It takes the desired time and date as command-line parameters, and the command to be executed in its standard input. The command will be executed as if it had been entered in the current shell. <command>at</command> even takes care to retain the current environment, in order to reproduce the same conditions when it executes the command. The time is indicated by following the usual conventions: <literal>16:12</literal> or <literal>4:12pm</literal> represents 4:12 pm. The date can be specified in several European and Western formats, including <literal>DD.MM.YY</literal> (<literal>27.07.15</literal> thus representing 27 July 2015), <literal>YYYY-MM-DD</literal> (this same date being expressed as <literal>2015-07-27</literal>), <literal>MM/DD/[CC]YY</literal> (ie., <literal>12/25/15</literal> or <literal>12/25/2015</literal> will be December 25, 2015), or simple <literal>MMDD[CC]YY</literal> (so that <literal>122515</literal> or <literal>12252015</literal> will, likewise, represent December 25, 2015). Without it, the command will be executed as soon as the clock reaches the time indicated (the same day, or tomorrow if that time has already passed on the same day). You can also simply write “today” or “tomorrow”, which is self-explanatory.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>
<computeroutput>&gt; </computeroutput><userinput>echo "Don't forget to wish a Happy Birthday to Raphaël!" \</userinput>
<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>
<computeroutput>&gt; </computeroutput><userinput>END</userinput>
<computeroutput>warning: commands will be executed using /bin/sh
job 31 at Mon Jul 27 09:00:00 2015</computeroutput></screen>
			 <para>
				An alternative syntax postpones the execution for a given duration: <command>at now + <replaceable>number</replaceable> <replaceable>period</replaceable></command>. The <replaceable>period</replaceable> can be <literal>minutes</literal>, <literal>hours</literal>, <literal>days</literal>, or <literal>weeks</literal>. The <replaceable>number</replaceable> simply indicates the number of said units that must elapse before execution of the command.
			</para>
			 <para>
				To cancel a task scheduled by <command>cron</command>, simply run <command>crontab -e</command> and delete the corresponding line in the <emphasis>crontab</emphasis> file. For <command>at</command> tasks, it is almost as easy: run <command>atrm <replaceable>task-number</replaceable></command>. The task number is indicated by the <command>at</command> command when you scheduled it, but you can find it again with the <command>atq</command> command, which gives the current list of scheduled tasks.
			</para>
			 <indexterm>
				<primary><command>atrm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>atq</command></primary>
			</indexterm>

		</section>

	</section>
	 <section id="sect.asynchronous-task-scheduling-anacron">
		<title>Scheduling Asynchronous Tasks: <command>anacron</command></title>
		 <para>
			<command>anacron</command> is the daemon that completes <command>cron</command> for computers that are not on at all times. Since regular tasks are usually scheduled for the middle of the night, they will never be executed if the computer is off at that time. The purpose of <command>anacron</command> is to execute them, taking into account periods in which the computer is not working.
		</para>
		 <indexterm>
			<primary><command>anacron</command></primary>
		</indexterm>
		 <para>
			Please note that <command>anacron</command> will frequently execute such activity a few minutes after booting the machine, which can render the computer less responsive. This is why the tasks in the <filename>/etc/anacrontab</filename> file are started with the <command>nice</command> command, which reduces their execution priority and thus limits their impact on the rest of the system. Beware, the format of this file is not the same as that of <filename>/etc/crontab</filename>; if you have particular needs for <command>anacron</command>, see the <citerefentry><refentrytitle>anacrontab</refentrytitle>
			 <manvolnum>5</manvolnum></citerefentry> manual page.
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Priorities and <command>nice</command></title>
		 <para>
			Unix systems (and thus Linux) are multi-tasking and multi-user systems. Indeed, several processes can run in parallel, and be owned by different users: the kernel mediates access to the resources between the different processes. As a part of this task, it has a concept of priority, which allows it to favor certain processes over others, as needed. When you know that a process can run in low priority, you can indicate so by running it with <command>nice <replaceable>program</replaceable></command>. The program will then have a smaller share of the CPU, and will have a smaller impact on other running processes. Of course, if no other processes needs to run, the program will not be artificially held back.
		</para>
		 <para>
			<command>nice</command> works with levels of “niceness”: the positive levels (from 1 to 19) progressively lower the priority, while the negative levels (from -1 to -20) will increase it — but only root can use these negative levels. Unless otherwise indicated (see the <citerefentry><refentrytitle>nice</refentrytitle>
			 <manvolnum>1</manvolnum></citerefentry> manual page), <command>nice</command> increases the current level by 10.
		</para>
		 <para>
			If you discover that an already running task should have been started with <command>nice</command> it is not too late to fix it; the <command>renice</command> command changes the priority of an already running process, in either direction (but reducing the “niceness” of a process is reserved for the root user).
		</para>
		 </sidebar> <para>
			Installation of the <emphasis role="pkg">anacron</emphasis> package deactivates execution by <command>cron</command> of the scripts in the <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename>, and <filename>/etc/cron.monthly/</filename> directories. This avoids their double execution by <command>anacron</command> and <command>cron</command>. The <command>cron</command> command remains active and will continue to handle the other scheduled tasks (especially those scheduled by users).
		</para>

	</section>
	 <section id="sect.quotas">
		<title>Quotas</title>
		 <indexterm>
			<primary>quota</primary>
		</indexterm>
		 <para>
			The quota system allows limiting disk space allocated to a user or group of users. To set it up, you must have a kernel that supports it (compiled with the <varname>CONFIG_QUOTA</varname> option) — as is the case with Debian kernels. The quota management software is found in the <emphasis role="pkg">quota</emphasis> Debian package.
		</para>
		 <para>
			To activate quota in a filesystem, you have to indicate the <literal>usrquota</literal> and <literal>grpquota</literal> options in <filename>/etc/fstab</filename> for the user and group quotas, respectively. Rebooting the computer will then update the quotas in the absence of disk activity (a necessary condition for proper accounting of already used disk space).
		</para>
		 <para>
			The <command>edquota <replaceable>user</replaceable></command> (or <command>edquota -g <replaceable>group</replaceable></command>) command allows you to change the limits while examining current disk space usage.
		</para>
		 <indexterm>
			<primary><command>edquota</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>GOING FURTHER</emphasis> Defining quotas with a script</title>
		 <indexterm>
			<primary><command>setquota</command></primary>
		</indexterm>
		 <para>
			The <command>setquota</command> program can be used in a script to automatically change many quotas. Its <citerefentry><refentrytitle>setquota</refentrytitle>
			 <manvolnum>8</manvolnum></citerefentry> manual page details the syntax to use.
		</para>
		 </sidebar> <para>
			The quota system allows you to set four limits:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					two limits (called “soft” and “hard”) refer to the number of blocks consumed. If the filesystem was created with a block-size of 1 kibibyte, a block contains 1024 bytes from the same file. Unsaturated blocks thus induce losses of disk space. A quota of 100 blocks, which theoretically allows storage of 102,400 bytes, will however be saturated with just 100 files of 500 bytes each, only representing 50,000 bytes in total.
				</para>

			</listitem>
			 <listitem>
				<para>
					two limits (soft and hard) refer to the number of inodes used. Each file occupies at least one inode to store information about it (permissions, owner, timestamp of last access, etc.). It is thus a limit on the number of user files.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			A “soft” limit can be temporarily exceeded; the user will simply be warned that they are exceeding the quota by the <command>warnquota</command> command, which is usually invoked by <command>cron</command>. A “hard” limit can never be exceeded: the system will refuse any operation that will cause a hard quota to be exceeded.
		</para>
		 <sidebar> <title><emphasis>VOCABULARY</emphasis> Blocks and inodes</title>
		 <indexterm>
			<primary>block (disk)</primary>
		</indexterm>
		 <indexterm>
			<primary>inode</primary>
		</indexterm>
		 <para>
			The filesystem divides the hard drive into blocks — small contiguous areas. The size of these blocks is defined during creation of the filesystem, and generally varies between 1 and 8 kibibytes.
		</para>
		 <para>
			A block can be used either to store the real data of a file, or for meta-data used by the filesystem. Among this meta-data, you will especially find the inodes. An inode uses a block on the hard drive (but this block is not taken into consideration in the block quota, only in the inode quota), and contains both the information on the file to which it corresponds (name, owner, permissions, etc.) and the pointers to the data blocks that are actually used. For very large files that occupy more blocks than it is possible to reference in a single inode, there is an indirect block system; the inode references a list of blocks that do not directly contain data, but another list of blocks.
		</para>
		 </sidebar> <indexterm>
			<primary><command>warnquota</command></primary>
		</indexterm>
		 <para>
			With the <command>edquota -t</command> command, you can define a maximum authorized “grace period” within which a soft limit may be exceeded. After this period, the soft limit will be treated like a hard limit, and the user will have to reduce their disk space usage to within this limit in order to be able to write anything to the hard drive.
		</para>
		 <sidebar> <title><emphasis>GOING FURTHER</emphasis> Setting up a default quota for new users</title>
		 <para>
			To automatically setup a quota for new users, you have to configure a template user (with <command>edquota</command> or <command>setquota</command>) and indicate their user name in the <varname>QUOTAUSER</varname> variable in the <filename>/etc/adduser.conf</filename> file. This quota configuration will then be automatically applied to each new user created with the <command>adduser</command> command.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.backup">
		<title>Sikkerhetskopiering</title>
		 <para>
			Making backups is one of the main responsibilities of any administrator, but it is a complex subject, involving powerful tools which are often difficult to master.
		</para>
		 <indexterm>
			<primary>backup</primary>
		</indexterm>
		 <indexterm>
			<primary>restoration</primary>
		</indexterm>
		 <para>
			Many programs exist, such as <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. Those are client/server system featuring many options, whose configuration is rather difficult. Some of them provide user-friendly web interfaces to mitigate this. But Debian contains dozens of other backup software covering all possible use cases, as you can easily confirm with <command>apt-cache search backup</command>.
		</para>
		 <indexterm>
			<primary><command>amanda</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>bacula</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>BackupPC</command></primary>
		</indexterm>
		 <para>
			Rather than detailing some of them, this section will present the thoughts of the Falcot Corp administrators when they defined their backup strategy.
		</para>
		 <para>
			At Falcot Corp, backups have two goals: recovering erroneously deleted files, and quickly restoring any computer (server or desktop) whose hard drive has failed.
		</para>
		 <section>
			<title>Backing Up with <command>rsync</command></title>
			 <para>
				Backups on tape having been deemed too slow and costly, data will be backed up on hard drives on a dedicated server, on which the use of software RAID (see <xref linkend="sect.raid-soft" />) will protect the data from hard drive failure. Desktop computers are not backed up individually, but users are advised that their personal account on their department's file server will be backed up. The <command>rsync</command> command (from the package of the same name) is used daily to back up these different servers.
			</para>
			 <indexterm>
				<primary><command>rsync</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> The hard link, a second name for the file</title>
			 <indexterm>
				<primary>link</primary>
				<secondary>hard link</secondary>
			</indexterm>
			 <indexterm>
				<primary>hard link</primary>
			</indexterm>
			 <para>
				A hard link, as opposed to a symbolic link, cannot be differentiated from the linked file. Creating a hard link is essentially the same as giving an existing file a second name. This is why the deletion of a hard link only removes one of the names associated with the file. As long as another name is still assigned to the file, the data therein remain present on the filesystem. It is interesting to note that, unlike a copy, the hard link does not take up additional space on the hard drive.
			</para>
			 <para>
				A hard link is created with the <command>ln <replaceable>target</replaceable> <replaceable>link</replaceable></command> command. The <replaceable>link</replaceable> file is then a new name for the <replaceable>target</replaceable> file. Hard links can only be created on the same filesystem, while symbolic links are not subject to this limitation.
			</para>
			 </sidebar> <para>
				The available hard drive space prohibits implementation of a complete daily backup. As such, the <command>rsync</command> command is preceded by a duplication of the content of the previous backup with hard links, which prevents usage of too much hard drive space. The <command>rsync</command> process then only replaces files that have been modified since the last backup. With this mechanism a great number of backups can be kept in a small amount of space. Since all backups are immediately available and accessible (for example, in different directories of a given share on the network), you can quickly make comparisons between two given dates.
			</para>
			 <indexterm>
				<primary>copy, backup copy</primary>
			</indexterm>
			 <indexterm>
				<primary>backup</primary>
				<secondary>copy</secondary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">dirvish</emphasis></primary>
			</indexterm>
			 <para>
				This backup mechanism is easily implemented with the <command>dirvish</command> program. It uses a backup storage space (“bank” in its vocabulary) in which it places timestamped copies of sets of backup files (these sets are called “vaults” in the dirvish documentation).
			</para>
			 <para>
				The main configuration is in the <filename>/etc/dirvish/master.conf</filename> file. It defines the location of the backup storage space, the list of “vaults” to manage, and default values for expiration of the backups. The rest of the configuration is located in the <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> files and contains the specific configuration for the corresponding set of files.
			</para>
			 <example id="example.dirvish-master">
				<title>The <filename>/etc/dirvish/master.conf</filename> file</title>
				 
<programlisting>bank:
    /backup
exclude:
    lost+found/
    core
    *~
Runall:
    root    22:00
expire-default: +15 days
expire-rule:
#   MIN HR    DOM MON       DOW  STRFTIME_FMT
    *   *     *   *         1    +3 months
    *   *     1-7 *         1    +1 year
    *   *     1-7 1,4,7,10  1
</programlisting>

			</example>
			 <para>
				The <literal>bank</literal> setting indicates the directory in which the backups are stored. The <literal>exclude</literal> setting allows you to indicate files (or file types) to exclude from the backup. The <literal>Runall</literal> is a list of file sets to backup with a time-stamp for each set, which allows you to assign the correct date to the copy, in case the backup is not triggered at precisely the assigned time. You have to indicate a time just before the actual execution time (which is, by default, 10:04 pm in Debian, according to <filename>/etc/cron.d/dirvish</filename>). Finally, the <literal>expire-default</literal> and <literal>expire-rule</literal> settings define the expiration policy for backups. The above example keeps forever backups that are generated on the first Sunday of each quarter, deletes after one year those from the first Sunday of each month, and after 3 months those from other Sundays. Other daily backups are kept for 15 days. The order of the rules does matter, Dirvish uses the last matching rule, or the <literal>expire-default</literal> one if no other <literal>expire-rule</literal> matches.
			</para>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> Scheduled expiration</title>
			 <para>
				The expiration rules are not used by <command>dirvish-expire</command> to do its job. In reality, the expiration rules are applied when creating a new backup copy to define the expiration date associated with that copy. <command>dirvish-expire</command> simply peruses the stored copies and deletes those for which the expiration date has passed.
			</para>
			 </sidebar> <example id="example.dirvish-vault">
				<title>The <filename>/backup/root/dirvish/default.conf</filename> file</title>
				 
<programlisting>client: rivendell.falcot.com
tree: /
xdev: 1
index: gzip
image-default: %Y%m%d
exclude:
    /var/cache/apt/archives/*.deb
    /var/cache/man/**
    /tmp/**
    /var/tmp/**
    *.bak
</programlisting>

			</example>
			 <para>
				The above example specifies the set of files to back up: these are files on the machine <emphasis>rivendell.falcot.com</emphasis> (for local data backup, simply specify the name of the local machine as indicated by <command>hostname</command>), especially those in the root tree (<literal>tree: /</literal>), except those listed in <literal>exclude</literal>. The backup will be limited to the contents of one filesystem (<literal>xdev: 1</literal>). It will not include files from other mount points. An index of saved files will be generated (<literal>index: gzip</literal>), and the image will be named according to the current date (<literal>image-default: %Y%m%d</literal>).
			</para>
			 <para>
				There are many options available, all documented in the <citerefentry><refentrytitle>dirvish.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> manual page. Once these configuration files are setup, you have to initialize each file set with the <command>dirvish --vault <replaceable>vault</replaceable> --init</command> command. From there on the daily invocation of <command>dirvish-runall</command> will automatically create a new backup copy just after having deleted those that expired.
			</para>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> Remote backup over SSH</title>
			 <para>
				When dirvish needs to save data to a remote machine, it will use <command>ssh</command> to connect to it, and will start <command>rsync</command> as a server. This requires the root user to be able to automatically connect to it. The use of an SSH authentication key allows precisely that (see <xref linkend="sect.ssh-key-based-auth" />).
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>Restoring Machines without Backups</title>
			 <para>
				Desktop computers, which are not backed up, will be easy to reinstall from custom DVD-ROMs prepared with <emphasis>Simple-CDD</emphasis> (see <xref linkend="sect.simple-cdd" />). Since this performs an installation from scratch, it loses any customization that can have been made after the initial installation. This is fine since the systems are all hooked to a central LDAP directory for accounts and most desktop applications are preconfigured thanks to dconf (see <xref linkend="sect.gnome-desktop" /> for more information about this).
			</para>
			 <para>
				The Falcot Corp administrators are aware of the limits in their backup policy. Since they can't protect the backup server as well as a tape in a fireproof safe, they have installed it in a separate room so that a disaster such as a fire in the server room won't destroy backups along with everything else. Furthermore, they do an incremental backup on DVD-ROM once per week — only files that have been modified since the last backup are included.
			</para>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> Backing up SQL and LDAP services</title>
			 <para>
				Many services (such as SQL or LDAP databases) cannot be backed up by simply copying their files (unless they are properly interrupted during creation of the backups, which is frequently problematic, since they are intended to be available at all times). As such, it is necessary to use an “export” mechanism to create a “data dump” that can be safely backed up. These are often quite large, but they compress well. To reduce the storage space required, you will only store a complete text file per week, and a <command>diff</command> each day, which is created with a command of the type <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command>. The <command>xdelta</command> program produces incremental differences from binary dumps.
			</para>
			 <indexterm>
				<primary><command>xdelta</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>diff</command></primary>
			</indexterm>
			 <indexterm>
				<primary>dump</primary>
			</indexterm>
			 </sidebar> <sidebar> <title><emphasis>CULTURE</emphasis> <emphasis>TAR</emphasis>, the standard for tape backups</title>
			 <indexterm>
				<primary>backup</primary>
				<secondary>on tape</secondary>
			</indexterm>
			 <indexterm>
				<primary>tape, backup</primary>
			</indexterm>
			 <indexterm>
				<primary>TAR</primary>
			</indexterm>
			 <para>
				Historically, the simplest means of making a backup on Unix was to store a <emphasis>TAR</emphasis> archive on a tape. The <command>tar</command> command even got its name from “Tape ARchive”.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.hotplug">
		<title>Hot Plugging: <emphasis>hotplug</emphasis></title>
		 <section>
			<title>Introduction</title>
			 <para>
				The <emphasis>hotplug</emphasis> kernel subsystem dynamically handles the addition and removal of devices, by loading the appropriate drivers and by creating the corresponding device files (with the help of <command>udevd</command>). With modern hardware and virtualization, almost everything can be hotplugged: from the usual USB/PCMCIA/IEEE 1394 peripherals to SATA hard drives, but also the CPU and the memory.
			</para>
			 <para>
				The kernel has a database that associates each device ID with the required driver. This database is used during boot to load all the drivers for the peripheral devices detected on the different buses, but also when an additional hotplug device is connected. Once the device is ready for use, a message is sent to <command>udevd</command> so it will be able to create the corresponding entry in <filename>/dev/</filename>.
			</para>
			 <indexterm>
				<primary><emphasis>hotplug</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>hotplug</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>PCMCIA</primary>
			</indexterm>
			 <indexterm>
				<primary>SATA</primary>
			</indexterm>

		</section>
		 <section>
			<title>The Naming Problem</title>
			 <para>
				Before the appearance of hotplug connections, it was easy to assign a fixed name to a device. It was based simply on the position of the devices on their respective bus. But this is not possible when such devices can come and go on the bus. The typical case is the use of a digital camera and a USB key, both of which appear to the computer as disk drives. The first one connected may be <filename>/dev/sdb</filename> and the second <filename>/dev/sdc</filename> (with <filename>/dev/sda</filename> representing the computer's own hard drive). The device name is not fixed; it depends on the order in which devices are connected.
			</para>
			 <para>
				Additionally, more and more drivers use dynamic values for devices' major/minor numbers, which makes it impossible to have static entries for the given devices, since these essential characteristics may vary after a reboot.
			</para>
			 <para>
				<emphasis>udev</emphasis> was created precisely to solve this problem.
			</para>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> Network card management</title>
			 <para>
				Many computers have multiple network cards (sometimes two wired interfaces and a wifi interface), and with <emphasis>hotplug</emphasis> support on most bus types, the Linux kernel does not guarantee fixed naming of network interfaces. But users who want to configure their network in <filename>/etc/network/interfaces</filename> need a fixed name!
			</para>
			 <para>
				It would be difficult to ask every user to create their own <emphasis>udev</emphasis> rules to address this problem. This is why <emphasis>udev</emphasis> was configured in a rather peculiar manner; on first boot (and, more generally, each time that a new network card appears) it uses the name of the network interface and its MAC address to create new rules that will reassign the same name on subsequent boots. These rules are stored in <filename>/etc/udev/rules.d/70-persistent-net.rules</filename>.
			</para>
			 <para>
				This mechanism has some side effects that you should know about. Let's consider the case of a computer that has only one PCI network card. The network interface is named <literal>eth0</literal>, logically. Now say the card breaks down, and the administrator replaces it; the new card will have a new MAC address. Since the old card was assigned the name, <literal>eth0</literal>, the new one will be assigned <literal>eth1</literal>, even though the <literal>eth0</literal> card is gone for good (and the network will not be functional because <filename>/etc/network/interfaces</filename> likely configures an <literal>eth0</literal> interface). In this case, it is enough to simply delete the <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> file before rebooting the computer. The new card will then be given the expected <literal>eth0</literal> name.
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>How <emphasis>udev</emphasis> Works</title>
			 <para>
				When <emphasis>udev</emphasis> is notified by the kernel of the appearance of a new device, it collects various information on the given device by consulting the corresponding entries in <filename>/sys/</filename>, especially those that uniquely identify it (MAC address for a network card, serial number for some USB devices, etc.).
			</para>
			 <para>
				Armed with all of this information, <emphasis>udev</emphasis> then consults all of the rules contained in <filename>/etc/udev/rules.d/</filename> and <filename>/lib/udev/rules.d/</filename>. In this process it decides how to name the device, what symbolic links to create (to give it alternative names), and what commands to execute. All of these files are consulted, and the rules are all evaluated sequentially (except when a file uses “GOTO” directives). Thus, there may be several rules that correspond to a given event.
			</para>
			 <para>
				The syntax of rules files is quite simple: each row contains selection criteria and variable assignments. The former are used to select events for which there is a need to react, and the latter defines the action to take. They are all simply separated with commas, and the operator implicitly differentiates between a selection criterion (with comparison operators, such as <literal>==</literal> or <literal>!=</literal>) or an assignment directive (with operators such as <literal>=</literal>, <literal>+=</literal> or <literal>:=</literal>).
			</para>
			 <para>
				Comparison operators are used on the following variables:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>KERNEL</literal>: the name that the kernel assigns to the device;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ACTION</literal>: the action corresponding to the event (“add” when a device has been added, “remove” when it has been removed);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>DEVPATH</literal>: the path of the device's <filename>/sys/</filename> entry;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SUBSYSTEM</literal>: the kernel subsystem which generated the request (there are many, but a few examples are “usb”, “ide”, “net”, “firmware”, etc.);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ATTR{<replaceable>attribute</replaceable>}</literal>: file contents of the <replaceable>attribute</replaceable> file in the <filename>/sys/<replaceable>$devpath</replaceable>/</filename> directory of the device. This is where you find the MAC address and other bus specific identifiers;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> and <literal>ATTRS{<replaceable>attributes</replaceable>}</literal> are variations that will try to match the different options on one of the parent devices of the current device;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>PROGRAM</literal>: delegates the test to the indicated program (true if it returns 0, false if not). The content of the program's standard output is stored so that it can be reused by the <literal>RESULT</literal> test;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>RESULT</literal>: execute tests on the standard output stored during the last call to <literal>PROGRAM</literal>.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				The right operands can use pattern expressions to match several values at the same time. For instance, <literal>*</literal> matches any string (even an empty one); <literal>?</literal> matches any character, and <literal>[]</literal> matches the set of characters listed between the square brackets (or the opposite thereof if the first character is an exclamation point, and contiguous ranges of characters are indicated like <literal>a-z</literal>).
			</para>
			 <para>
				Regarding the assignment operators, <literal>=</literal> assigns a value (and replaces the current value); in the case of a list, it is emptied and contains only the value assigned. <literal>:=</literal> does the same, but prevents later changes to the same variable. As for <literal>+=</literal>, it adds an item to a list. The following variables can be changed:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>NAME</literal>: the device filename to be created in <filename>/dev/</filename>. Only the first assignment counts; the others are ignored;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SYMLINK</literal>: the list of symbolic links that will point to the same device;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>OWNER</literal>, <literal>GROUP</literal> and <literal>MODE</literal> define the user and group that owns the device, as well as the associated permission;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>RUN</literal>: the list of programs to execute in response to this event.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				The values assigned to these variables may use a number of substitutions:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>$kernel</literal> or <literal>%k</literal>: equivalent to <literal>KERNEL</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$number</literal> or <literal>%n</literal>: the order number of the device, for example, for <literal>sda3</literal>, it would be “3”;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$devpath</literal> or <literal>%p</literal>: equivalent to <literal>DEVPATH</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$attr{<replaceable>attribute</replaceable>}</literal> or <literal>%s{<replaceable>attribute</replaceable>}</literal>: equivalent to <literal>ATTRS{<replaceable>attribute</replaceable>}</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$major</literal> or <literal>%M</literal>: the kernel major number of the device;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$minor</literal> or <literal>%m</literal>: the kernel minor number of the device;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$result</literal> or <literal>%c</literal>: the string output by the last program invoked by <literal>PROGRAM</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						and, finally, <literal>%%</literal> and <literal>$$</literal> for the percent and dollar sign, respectively.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				The above lists are not complete (they include only the most important parameters), but the <citerefentry><refentrytitle>udev</refentrytitle>
				<manvolnum>7</manvolnum></citerefentry> manual page should be exhaustive.
			</para>

		</section>
		 <section>
			<title>A concrete example</title>
			 <para>
				Let us consider the case of a simple USB key and try to assign it a fixed name. First, you must find the elements that will identify it in a unique manner. For this, plug it in and run <command>udevadm info -a -n /dev/sdc</command> (replacing <replaceable>/dev/sdc</replaceable> with the actual name assigned to the key).
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>
<computeroutput>[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</computeroutput></screen>
			 <para>
				To create a new rule, you can use tests on the device's variables, as well as those of one of the parent devices. The above case allows us to create two rules like these:
			</para>
			 
<programlisting>KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"
</programlisting>
			 <para>
				Once these rules are set in a file, named for example <filename>/etc/udev/rules.d/010_local.rules</filename>, you can simply remove and reconnect the USB key. You can then see that <filename>/dev/usb_key/disk</filename> represents the disk associated with the USB key, and <filename>/dev/usb_key/part1</filename> is its first partition.
			</para>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> Debugging <emphasis>udev</emphasis>'s configuration</title>
			 <para>
				Like many daemons, <command>udevd</command> stores logs in <filename>/var/log/daemon.log</filename>. But it is not very verbose by default, and it is usually not enough to understand what is happening. The <command>udevadm control --log-priority=info</command> command increases the verbosity level and solves this problem. <command>udevadm control --log-priority=err</command> returns to the default verbosity level.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.power-management">
		<title>Power Management: Advanced Configuration and Power Interface (ACPI)</title>
		 <indexterm>
			<primary>power management</primary>
		</indexterm>
		 <indexterm>
			<primary>management, power management</primary>
		</indexterm>
		 <para>
			The topic of power management is often problematic. Indeed, properly suspending the computer requires that all the computer's device drivers know how to put them to standby, and that they properly reconfigure the devices upon waking. Unfortunately, there are still a few devices unable to sleep well under Linux, because their manufacturers have not provided the required specifications.
		</para>
		 <para>
			Linux supports ACPI (Advanced Configuration and Power Interface) — the most recent standard in power management. The <emphasis role="pkg">acpid</emphasis> package provides a daemon that looks for power management related events (switching between AC and battery power on a laptop, etc.) and that can execute various commands in response.
		</para>
		 <indexterm>
			<primary>ACPI</primary>
		</indexterm>
		 <indexterm>
			<primary>Advanced Configuration and Power Interface</primary>
		</indexterm>
		 <indexterm>
			<primary><command>acpid</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>BEWARE</emphasis> Graphics card and standby</title>
		 <para>
			The graphics card driver is often the culprit when standby doesn't work properly. In that case, it is a good idea to test the latest version of the X.org graphics server.
		</para>
		 </sidebar> <para>
			After this overview of basic services common to many Unix systems, we will focus on the environment of the administered machines: the network. Many services are required for the network to work properly. They will be discussed in the next chapter.
		</para>

	</section>
</chapter>

