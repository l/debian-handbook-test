<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course">
  <appendixinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-short-remedial-course.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>BIOS</keyword>
      <keyword>Kjerne</keyword>
      <keyword>Unix</keyword>
      <keyword>Prosess</keyword>
      <keyword>Hierarki</keyword>
      <keyword>Grunnleggende kommandoer</keyword>
    </keywordset>
  </appendixinfo>
  <title>Kort støttekurs</title>
  <highlights>
    <para>Selv om denne boken i hovedsak retter seg mot administratorer og "superbrukere", så ønsker vi ikke å ekskludere motiverte nybegynnere.  Dette vedlegget er derfor et krasjkurs som beskriver de grunnleggende konseptene involvert i håndtering av en Unix-datamaskin.</para>
  </highlights>
  <section id="sect.shell-and-basic-commands">
    <title>Skall og grunnleggende kommandoer</title>

    <para>I Unix-verden må enhver administrator bruke kommandolinjen før eller senere.  For eksempel når systemet ikke starter som det skal og kun tilbyr en redningsmodus med kommandolinje.  Det å være i stand til å håndtere et slikt grensesnitt er dermed grunnleggende overlevelseskunnskap i slike tilfeller.</para>

    <sidebar>
      <title><emphasis>QUICK LOOK</emphasis> Å starte kommando-konsollet</title>

      <para>Et kommandolinjemiljø kan kjøres fra det grafiske skrivebordet med et program som kalles en "terminal". I GNOME, kan du starte det fra "Activities"-oversikten (som du får når du beveger musen i øverste venstre hjørne av skjermen) ved å skrive de første bokstavene i navnet på programmet. I KDE, vil du finne det i <menuchoice><guimenu>K</guimenu> <guisubmenu>Applications</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice>-menyen.</para>
    </sidebar>

    <para>Denne delen gir bare et raskt kikk på kommandoene. Alle har mange alternativer som ikke er beskrevet her, så vis gjerne til den rikholdige dokumentasjon i de respektive manualsidene.</para>
    <section>
      <title>Å surfe i mappetreet og operativsystemet</title>

      <para>Så snart en sesjon er åpen, viser <command>pwd</command>-kommandoen (som står for <emphasis>print working directory</emphasis>) den gjeldende plasseringen i filsystemet. Den nåværende katalogen endres med <command>cd <replaceable>directory</replaceable></command>-kommandoen, (<command>cd</command> står for <emphasis>change directory</emphasis>). Den overordnede katalogen er alltid kalt <literal>..</literal> (to punkter), mens den gjeldende katalogen også er kjent som <literal>.</literal> (ett punkt).  <command>ls</command>-kommandoen åpner for <emphasis>listing</emphasis> av innholdet i en katalog. Hvis ingen parametere er angitt, opererer den på den gjeldende katalogen.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>cd Desktop</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd .</userinput>Arrivederci a presto!
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates
Documents  Music      Public    Videos</computeroutput>
      </screen>

      <para>En ny mappe kan lages med <command>mkdir <replaceable>directory</replaceable></command>, og en eksisterende (tom) katalog kan fjernes med <command>rmdir <replaceable>directory</replaceable></command>. <command>mv</command>-kommando åpner for  <emphasis>moving</emphasis> og/eller for å døpe om filer og mapper; <emphasis>removing</emphasis> en fil skjer med <command>rm <replaceable>file</replaceable></command>.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public    test
$ </computeroutput><userinput>mv test new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  new       Public     Videos
Documents  Music      Pictures  Templates
$ </computeroutput><userinput>rmdir new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public</computeroutput>
      </screen>
    </section>
    <section>
      <title>Å vise og modifisere tekstfiler</title>

      <para><command>cat <replaceable>file</replaceable></command>-kommandoen (med formål å <emphasis>concatenate</emphasis> filer til standard ut-enheten) leser en fil og viser innholdet på terminalen. Hvis filen er for stor til å passe til en skjerm, kan du bruke <command>less</command> (eller <command>more</command>) for å vise den side for side.</para>

      <para><command>editor</command>-kommandoen starter en tekstredigerer (slik som  <command>vi</command> eller <command>nano</command>) og tillater å lage, modifisere og lese tekstfiler. De enkleste filene kan noen ganger opprettes direkte fra kommando-konsollet takket være omdirigering: <command>echo "<replaceable>text</replaceable>" &gt;<replaceable>file</replaceable></command> lager en fil med navnet <replaceable>file</replaceable> med “<replaceable>text</replaceable>” som sitt innhold. Å legge til en linje på slutten av denne filen er også mulig, med en kommando som <command>echo "<replaceable>moretext</replaceable>" &gt;&gt;<replaceable>file</replaceable></command>. Merk <literal>&gt;&gt;</literal> i dette eksemplet.</para>
    </section>
    <section>
      <title>Å søke etter filer og innenfor filer</title>

      <para><command>find <replaceable>directory</replaceable> <replaceable>criteria</replaceable></command>-kommandoen ser etter filer i hierarkiet under <replaceable>directory</replaceable> etter flere kriterier. Det mest brukte er kriteriet <literal>-name <replaceable>name</replaceable></literal>: som tillater å lete etter en fil med det navnet.</para>

      <para><command>grep <replaceable>expression</replaceable> <replaceable>files</replaceable></command>-kommando søker igjennom innholdet i filene, og trekker ut de linjene som samsvarer med det regulære uttrykket (se sidestolpe <xref linkend="sidebar.regexp" />). Å legge til <literal>-r</literal>-alternativet muliggjør at et gjentakende søk på alle filene i katalogen sendes som et parameter. Dette gjør det mulig å se etter en fil når bare en del av innholdet er kjent.</para>
    </section>
    <section>
      <title>Å håndtere prosesser</title>

      <para><command>ps aux</command>-kommandoen viser prosessene som kjører og hjelper å identifisere dem ved å vise sin <emphasis>pid</emphasis> (process id). Så snart <emphasis>pid</emphasis>-rn for en prosess er kjent, kan <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command>-kommandoen sende den et signal (hvis prosessen tilhører den aktuelle brukeren). Flere signaler finnes; de mest brukte er <literal>TERM</literal> (En elegant anmodning om å avslutte) og <literal>KILL</literal> (en tvunget avslutning).</para>

      <para>Kommando-konsollet kan også kjøre programmer i bakgrunnen hvis kommandoen er etterfulgt av et “&amp;”. Ved å bruke &amp;-tegnet (og-tegnet/et-tegnet (ampersand)), får brukeren umiddelbart tilbake kontroll over skallet, selv om kommandoen fortsatt kjører (skjult for brukeren, som en bakgrunnsprosess). <command>jobs</command>-kommandoen lister prosesser som kjører i bakgrunnen; å kjøre <command>fg %<replaceable>job-number</replaceable></command> (for <emphasis>foreground</emphasis>) gjenoppretter en jobb til forgrunnen. Når en kommando kjører i forgrunnen (enten fordi den ble startet normalt, eller bringes tilbake til forgrunnen med <command>fg</command>), pauser <keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>-tastekombinasjonen prosessen, og gjenopptar kontrollen over kommandolinjen. Prosessen kan deretter restartes i bakgrunnen med <command>bg %<replaceable>job-number</replaceable></command> (for <foreignphrase>background</foreignphrase>).</para>
    </section>
    <section>
      <title>Systeminformasjon: Minne, diskplass, identitet</title>

      <para><command>free</command>-kommandoen visere informasjon om minne; <command>df</command> (<emphasis>disk free</emphasis>) rapporter om ledig diskplass på hver av diskene montert i filsystemet. <literal>-h</literal>-valget dens (for <emphasis>human readable</emphasis>) konverterer størrelsene til en mer leselig enhet (vanligvis mebibytes eller gibibytes). På lignende måte, støtter <command>free</command>-kommandoen <literal>-m</literal> og <literal>-g</literal>-valgene, og viser dataene dens enten i  mebibytes eller i gibibytes, respektivt.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       used       free     shared    buffers     cached
Mem:       1028420    1009624      18796          0      47404     391804
-/+ buffers/cache:     570416     458004
Swap:      2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda2              9614084   4737916   4387796  52% /
tmpfs                   514208         0    514208   0% /lib/init/rw
udev                     10240       100     10140   1% /dev
tmpfs                   514208    269136    245072  53% /dev/shm
/dev/sda5             44552904  36315896   7784380  83% /home
</computeroutput></screen>

      <para><command>id</command>-kommandoen viser identiteten til brukeren som kjører økten, sammen med listen over grupper de tilhører. Siden tilgang til noen filer eller enheter kan være begrenset til gruppemedlemmene, kan det være nyttig å sjekke tilgjengelige gruppemedlemskap.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
      </screen>
    </section>
  </section>
  <section id="sect.filesystem-hierarchy">
    <title>Organisering av filsystemhierarkiet</title>
    <indexterm><primary>Filesystem Hierarchy</primary></indexterm>
    <section>
      <title>Rotmappen</title>

      <para>Et Debian-system er organisert i tråd med <emphasis>Filesystem Hierarchy Standard</emphasis> (FHS). Denne standarden definerer formålet med hver katalog. For eksempel er toppnivå-kataloger beskrevet som følger:</para>
      <itemizedlist>
        <listitem>
	  <para><filename>/bin/</filename>: basisprogrammet;</para>
        </listitem>
        <listitem>
	  <para><filename>/boot/</filename>: Linux-kjernen og andre filer som kreves til den tidlige oppstartsprosessen;</para>
        </listitem>
        <listitem>
	  <para><filename>/dev/</filename>: filer for enheter;</para>
        </listitem>
        <listitem>
	  <para><filename>/etc/</filename>: Oppsettsfiler;</para>
        </listitem>
        <listitem>
	  <para><filename>/home/</filename>: Brukerens personlige filer;</para>
        </listitem>
        <listitem>
	  <para><filename>/lib/</filename>: Basisbiblioteker;</para>
        </listitem>
        <listitem>
	  <para><filename>/media/*</filename>: Monteringspunkter for flyttbare enheter (CD-ROM, USB-nøkler og så videre);</para>
        </listitem>
        <listitem>
	  <para><filename>/mnt/</filename>: Midlertidige monteringspunkter;</para>
        </listitem>
        <listitem>
	  <para><filename>/opt/</filename>: Ekstra programmer levert av tredeparter;</para>
        </listitem>
        <listitem>
	  <para><filename>/root/</filename>: Administrators (rots) personlige filer;</para>
        </listitem>
        <listitem>
          <para><filename>/run/</filename>: Omskiftelige kjøretidsdata som ikke vedvarer igjennom oppstarter (ennå ikke inkludert i FHS);</para>
        </listitem>
        <listitem>
	  <para><filename>/sbin/</filename>: Systemprogrammer;</para>
        </listitem>
        <listitem>
	  <para><filename>/srv/</filename>: Data brukt av tjenere med vertskap på dette systemet;</para>
        </listitem>
        <listitem>
	  <para><filename>/tmp/</filename>: Midlertidige filer; denne katalogen tømmes ofte ved oppstart;</para>
        </listitem>
        <listitem>
	  <para><filename>/usr/</filename>: Programmer; denne katalogen er videre inndelt i <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (ifølge samme logikk som i rotkatalogen). Videre inneholder <filename>/usr/share/</filename> arkitektur-uavhengige data. <filename>/usr/local/</filename> er ment til å brukes av administrator for å installere programmer manuelt uten å overskrive filer som håndteres av pakkesystemet (<command>dpkg</command>).</para>
        </listitem>
        <listitem>
	  <para><filename>/var/</filename>: Variable data som håndteres av nisser. Dette inkluderer loggfiler, køer, utskriftskøer, hurtiglagre og så videre.</para>
        </listitem>
        <listitem>
	  <para><filename>/proc/</filename> og <filename>/sys/</filename> er spesifikke for Linux-kjernen (og ikke en del av FHS). De brukes av kjernen for å eksportere data til brukerområde (se <xref linkend="sect.userspace-presentation" /> og <xref linkend="sect.user-space" /> for forklaringer på dette begrepet).</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Brukerens hjemmemappe</title>

      <para>Innholdet i en brukers hjemmekatalog er ikke standardisert, men det er fortsatt noen få nevneverdige konvensjoner. Den ene er at en brukers hjemmekatalog ofte er referert til av en krøllstrek ("~"). Det er nyttig å vite fordi kommando-konsollet automatisk erstatter en krøllstrek med riktig katalog (vanligvis <filename>/home/<replaceable>user</replaceable>/</filename>).</para>

      <para>Tradisjonelt er applikasjonens konfigurasjonsfiler ofte lagret direkte i brukerens hjemmekatalog, men filnavnene deres starter vanligvis med et punktum (for eksempel, <command>mutt</command>-e-postklient lagrer konfigurasjonen i <filename>~/.muttrc</filename>). Merk at filnavn som starter med en prikk er skjult som standard; og <command>ls</command> bare lister dem når <literal>-a</literal>-valget blir brukt, og grafiske fil-håndterere må få beskjed om å vise skjulte filer.</para>

      <para>Noen programmer bruker også flere konfigurasjonsfiler organisert i en katalog (for eksempel, <filename>~/.ssh/</filename>). Noen programmer (for eksempel nettleseren Iceweasel) bruker også sin katalog for å lagre et mellomlager med nedlastede data. Dette betyr at disse katalogene kan ende med å bruke mye diskplass.</para>

      <para>Disse konfigurasjonsfilene som er lagret direkte i brukerens hjemmekatalog, er ofte kollektivt referert til som <emphasis>dotfiles</emphasis>, har lenge formert seg til det punktet at disse katalogene kan bli ganske rotete. Heldigvis, et forsøk kollektivt ledet under FreeDesktop.org-paraplyen har resultert i "XDG Base Directory Specification", en konvensjon som tar sikte på å rydde opp disse filene og katalogen. Denne spesifikasjonen sier at konfigurasjonsfiler bør lagres under <filename>~/.config</filename>, hurtiglagerfile under <filename>~/.cache</filename>, og applikasjonsdatafiler under <filename>~/.local</filename> (eller undermapper under denne). Denne konvensjonen får langsomt trekkraft, og flere programmer (spesielt de grafiske) har begynt å følge den.</para>

      <para>Grafiske skrivebord viser vanligvis innholdet i <filename>~/Desktop/</filename>-katalogen på skrivebordet (eller hva den riktige oversettelsen er for systemer som ikke er konfigurert på engelsk, dvs. det som er synlig på skjermen når alle programmer er lukket eller vises som ikoner).</para>

      <para>Til slutt, e-postsystemet lagrer noen ganger innkommende e-poster til en <filename>~/Mail/</filename>-mappe.</para>
    </section>
  </section>
  <section id="sect.computer-layers">
    <title>Datamaskinens indre arbei : de forskjellige involverte lagene</title>

    <para>En datamaskin er ofte betraktet som noe heller abstrakt, og det ytre, synlige grensesnittet er mye enklere enn den interne kompleksiteten. Slik kompleksitet kommer delvis fra antallet deler som inngår. Imidlertid kan disse delene sees i lag, hvor et lag bare vekselvirker med de umiddelbart over eller under.</para>

    <para>En sluttbruker kan klare seg uten å kunne disse detaljene ... så lenge alt fungerer. Når man møter et problem som "Internett fungerer ikke!", er den første tingen å gjøre for å identifisere i hvilket lag problemet stammer fra. Fungerer nettverkskortet (hardvare)? Er det anerkjent av datamaskinen? Ser  Linux-kjernen det? Er nettverksparameterene riktig satt opp? Alle disse spørsmålene avgrenser et passende lag, og fokuserer på en potensiell problemkilde.</para>
    <section id="sect.hardware">
      <title>Det dypeste laget: Hardvaren</title>
      <indexterm><primary>IDE</primary></indexterm>
      <indexterm><primary>SCSI</primary></indexterm>
      <indexterm><primary>Serial ATA</primary></indexterm>
      <indexterm><primary>Parallel ATA</primary></indexterm>
      <indexterm><primary>ATA</primary></indexterm>
      <indexterm><primary>IEEE 1394</primary></indexterm>
      <indexterm><primary>Firewire</primary></indexterm>
      <indexterm><primary>USB</primary></indexterm>

      <para>La oss starte med en grunnleggende påminnelse om at en datamaskin først og fremst er et sett med maskinvare-elementer. Det er generelt en hovedkort (kjent som <emphasis>motherboard</emphasis>), med en (eller flere) prosessor(er), noe RAM, enhetskontrollere, og forlengelsespor for tilleggskort (for andre enhetskontrollerere). Mest bemerkelsesverdige blant disse kontrollerne er IDE (Parallel ATA), SCSI og Serial ATA, til å koble til lagringsenheter som harddisker . Andre kontrollere inkluderer USB, som er i stand til å være vert for et stort utvalf enheter (alt fra nettkameraer til termometre, fra tastaturer til hjemmeautomasjons-systemer) og IEEE 1394 (Firewire). Disse kontrollerne tillater ofte tilkobling av flere enheter slik at hele delsystemet håndteres av en kontroller og er derfor vanligvis kjent som en "buss". Opsjonskort inkluderer grafikkort (som overvåkningsskjermer kan plugges til), lydkort, nettverkskort, og så videre. Noen hovedkortene er forhåndsbygget med disse funksjonene, og trenger ikke tilleggskort.</para>

      <sidebar>
        <title><emphasis>IN PRACTICE</emphasis> Å sjekke at maskinvaren virker</title>

	<para>Å kontrollere at en maskinvaredel virker, kan være vanskelig. På den annen side, å bevise at den noen ganger ikke virker er ganske enkelt.</para>

	<para>En harddisk er laget av spinnende plater og bevegelige magnetiske hoder. Når en harddisk er slått på, avgir tallerkenmotoren en karakteristisk svirring. Den avgir også energi som varme. Følgelig er en harddisk som forblir kald og stille, når den slås på, gått i stykker.</para>

	<para>Nettverkskort inkluderer ofte lysdioder som viser tilstanden til linken. Hvis en kabel er koblet til og fører til et fungerende nettverksnav eller -veksler, vil minst en LED være på. Hvis ingen LED lyser opp, er enten kortet selv, nettverksenheten, eller kabelen mellom dem, defekt. Det neste trinnet er derfor å teste hver enkelt komponent.</para>

	<para>Noen opsjonskort - spesielt 3D-skjermkort - inkluderer avkjølingsenheter, for eksempel kjølefinner og/eller vifter. Hvis viften ikke spinner selv om kortet er slått på, er det en plausibel forklaring på hvorfor kortet er overopphetet. Dette gjelder også for hovedprosessoren(e) som er plassert på hovedkortet .</para>
      </sidebar>
    </section>
    <section id="sect.bios">
      <title>Starteren: BIOS eller UEFI</title>
      <indexterm><primary>BIOS</primary></indexterm>
      <indexterm><primary>UEFI</primary></indexterm>
      <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

      <para>På egen hånd er maskinvare ute av stand til å utføre nyttige oppgaver uten et samsvarende dataprogram som kjører den. Kontroll og samspill med maskinvaren er hensikten med operativsystemet og programmene. Disse krever i sin tur funksjonell maskinvare for å kjøre.</para>

      <para>Denne symbiosen mellom maskinvare og programvare skjer ikke av seg selv. Når datamaskinen er først slått på, er kreves det en innledende konfigurering. Denne rollen er antatt av BIOS eller UEFI, et dataprogram innebygd i hovedkortet og kjører automatisk ved oppstart. Den primære oppgaven er å søke etter programvare kan det overlate kontrollen til. Vanligvis, i BIOS tilfelle, iinnebærer dette å se etter den første harddisken med en oppstartssektor  (også kjent som <emphasis>master boot record</emphasis> eller <acronym>MBR</acronym>), laster oppstartssektoren, og kjører den. Fra da av er BIOS vanligvis ikke involvert (til neste oppstart). I tilfellet med UEFI, innebærer prosessen skanning av disker for å finne en øremerket EFI-partisjonen som inneholder ytterligere EFI-programmer for kjøring.</para>

      <sidebar>
        <title><emphasis>TOOL</emphasis> Oppsett, BIOS/UEFI-konfigurasjonsverktøyet</title>
        <indexterm><primary><emphasis>Setup</emphasis></primary></indexterm>

	<para>BIOS/UEFI inneholder også en programvare som heter Setup, designet for å tillate å datamaskinens konfigueringsaspekter. Spesielt tillater den å velge hvilke oppstartsenhet som er å foretrekke (for eksempel diskett eller CD-ROM-stasjonen), å sette systemklokken, og så videre. Å starte Setup innebærer vanligvis å trykke en tast ganske snart etter at datamaskinen er slått på. Denne nøkkelen er ofte <keycap>Del</keycap> eller <keycap>Esc</keycap>, noen ganger <keycap>F2</keycap> eller <keycap>F10</keycap>. Mesteparten av tiden, blinkes valget på skjermen under oppstart.</para>
      </sidebar>

      <para>Oppstartssektoren (eller EFI-partisjonen), inneholder i sin tur en annet dataprogram, kalt oppstartslaster, med formålet å finne og kjøre et operativsystem. Siden denne oppstartslasteren ikke er innebygd i hovedkortet, men lastet fra disk, kan det være smartere enn BIOS, noe som forklarer hvorfor BIOS ikke laste operativsystemet selv. For eksempel kan oppstartlasteren (ofte GRUB på Linux-systemer) liste tilgjengelige operativsystemer og be brukeren om å velge en. Vanligvis er et tidsavbrudd og standardvalg gitt. Noen ganger kan brukeren også velge å legge til parametre som skal sendes til kjernen, og så videre. Til slutt blir en kjerne funnet, lastet inn i minnet, og utført.</para>

      <sidebar>
        <title><emphasis>NOTE</emphasis> UEFI, en moderne erstatning for BIOS</title>
        <indexterm><primary>UEFI</primary></indexterm>
        <indexterm><primary>Secure Boot</primary></indexterm>

        <para>UEFI er en relativt ny utvikling. De fleste nye datamaskiner vil støtte UEFIs oppstart, men som regel støtter de også BIOS-oppstart samtidig for bakoverkompatibiliteten til operativsystemer som ikke er klare til å bruke UEFI.</para>
        <para>Dette nye systemet blir kvitt noen av begrensningene til BIOS oppstart: med bruk av en dedikert partisjon, trenger ikke oppstartsladeren lenger spesielle triks for å få plass i en liten <emphasis>master boot record</emphasis> og så oppdage kjernen for å starte opp. Enda bedre, med en passende bygget Linux-kjerne, kan UEFI starte kjernen direkte uten noen mellomledds oppstartslaster. UEFI er også fundamentet for å levere <emphasis>Secure Boot</emphasis>, en teknologi som sikrer at du bare kjører programvare godkjent av din operativsystem-leverandør.</para>
      </sidebar>

      <para>BIOS / UEFI er også ansvarlig for å oppdage og initialisere en rekke enheter. Selvfølgelig omfatter dette IDE/SATA-enheter (vanligvis harddisken(e) og CD/DVD-ROM-stasjoner), men også PCI-enheter. Oppdagede enheter blir ofte oppført på skjermen under oppstartsprosessen. Hvis denne listen går for fort, kan du bruke <keycap>Pause</keycap>-nøkkelen til å fryse den lenge nok til å få den lest. Installerte PCI-enheter som ikke vises er et dårlig tegn. I verste fall er enheten defekt. I beste fall er den bare inkompatibel med den gjeldende versjonen av BIOS eller hovedkortet. PCI-spesifikasjoner utvikler seg, og gamle hovedkort er ikke garantert for å håndtere nyere PCI-enheter.</para>
    </section>
    <section id="sect.kernel">
      <title>Kjernen</title>

      <para>Både BIOS/UEFI og oppstartslasteren kjører bare noen få sekunder hver. Nå kommer vi til en programvaredel som kjører i lengre tid, operativsystemkjernen. Denne kjernen tar rollen som en dirigent i et orkester, og sikrer koordinering mellom maskinvare og programvare. Denne rollen innebærer flere oppgaver inkludert: Å kjøre maskinvare, administrere prosesser, brukere og tillatelser, filsystemet, og så videre. Kjernen gir en felles basis for alle andre programmer på systemet.</para>
    </section>
    <section id="sect.userspace-presentation">
      <title>Brukerrommet</title>

      <para>Selv om alt som skjer utenfor kjernen kan bli samlet sammen under "brukerrom", kan vi likevel skille det inn i lag med programvare. Men samhandlingene deres er mer komplekse enn før, og klassifiseringene behøver ikke å være så enkle. Et program bruker ofte biblioteker, som i sin tur berører kjernen, men kommunikasjonen kan også involvere andre programmer, eller til og med mange biblioteker som kontakter hverandre.</para>
    </section>
  </section>
  <section id="sect.kernel-role-and-tasks">
    <title>Noen oppgaver som håndteres av kjernen</title>
    <section id="sect.hardware-drivers">
      <title>Å drifte maskinvaren</title>

      <para>Kjernen har først og fremst som oppgave å kontrollere maskinvaretilbehøret, oppdage det, slå det på når datamaskinen blir slått på, og så videre. Det gjør dem også tilgjengelige for høyere nivå programvare med et forenklet programmeringsgrensesnitt, slik at programmene kan dra nytte av enheter uten å måtte bekymre seg om detaljer som hvilken kortplass det valgte kortet er satt inn i. Programgrensesnittet gir også et abstraksjonslag; det tillater at programvare for videokonferanser, for eksempel, kan bruke et nettkamera uavhengig av merke og modell. Programvaren kan bare bruke <emphasis>Video for Linux</emphasis> (V4L) grensesnitt, og kjernen oversetter funksjonspåkallingene i dette grensesnittet til de aktuelle maskinvarekommandoene som trengs når nettkameraet brukes.</para>

     
      <para><indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> Kjernen eksporterer mange detaljer om programvare den finner med <filename>/proc/</filename> og <filename>/sys/</filename>-virtuelle filsystemer. Flere verktøy oppsummerer disse detaljene. Blant dem,<command>lspci</command> (i <emphasis role="pkg">pciutils</emphasis> -pakken) lister PCI-enheter, <command>lsusb</command> (i <emphasis role="pkg">usbutils</emphasis>-pakke) lister USB-enheter, og <command>lspcmcia</command> (i <emphasis role="pkg">pcmciautils</emphasis>-pakken) lister PCMCIA-kort. Disse verktøyene er meget nyttige til å identifisere den eksakte modellen for enheten. Denne identifikasjonen gir også mer presise søk på nettet, noe som i sin tur fører til mer relevant dokumentasjon.</para>

      <example>
        <title>Eksempel på informasjon fra <command>lspci</command> og <command>lsusb</command></title>

        <screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>
      </example>

      <para>Disse programmene har et <literal>-v</literal>-valg som lister mye mer detaljert (men vanligvis ikke nødvendig) informasjon. Til slutt¸ <command>lsdev</command>-kommandoen (i <emphasis role="pkg">procinfo</emphasis>-pakken) lister kommunikasjonsressurser som enhetene bruker.</para>

      <para>Programmer kobler seg ofte til enheter ved hjelp av spesielle filer som er opprettet innenfor <filename>/dev/</filename> (se sidestolpe <xref linkend="sidebar.special-files" />). Dette er spesielle filer som representerer platelager (for eksempel, <filename>/dev/hda</filename> og <filename>/dev/sdc</filename>), partisjoner (<filename>/dev/hda1</filename> eller <filename>/dev/sdc3</filename>), mus (<filename>/dev/input/mouse0</filename>), tastatur (<filename>/dev/input/event0</filename>), lydkort (<filename>/dev/snd/*</filename>), serieporter (<filename>/dev/ttyS*</filename>), og så videre.</para>
    </section>
    <section id="sect.filesystems">
      <title>Filsystemer</title>
      <indexterm><primary>filesystem</primary></indexterm>
      <indexterm><primary>system, filesystem</primary></indexterm>

      <para>Filsystemer er en av kjernens mest fremtredende aspekter. Unix-systemer fletter alle fil-lagre inn i et enkelt hierarki, som gir brukere (og programmer) tilgang til data ved å kjenne til plasseringen i det hierarkiet.</para>

      <para>Startpunktet til dette hierarkiske treet kalles roten, <filename>/</filename>. Denne katalogen kan inneholde navngitte underkataloger. For eksempel, <literal>home</literal>-underkatalog i <filename>/</filename> kalles <filename>/home/</filename>. Denne underkatalogen kan i sin tur inneholde andre underkataloger, og så videre. Hver katalog kan også inneholde filer, hvor de faktiske dataene blir lagret. Dermed referer <filename>/home/rmas/Desktop/hello.txt</filename>-navnet til en fil med navnet <literal>hello.txt</literal> lagret i <literal>Desktop</literal>-underkatalog i <literal>rmas</literal>-underkatalogen i <literal>home</literal>-katalogen i roten. Kjernen oversetter mellom dette navnesystemet og den faktiske, fysiske lagring på en disk.</para>

      <para>I motsetning til andre systemer, er det bare ett slikt hierarki, og det kan integrere data fra flere disker. En av disse diskene anvendes som referanse, og de andre er "montert" på kataloger i hierarkiet (Unix-kommandoen er kalt <command>mount</command>); disse andre diskene er deretter tilgjengelige under disse "monteringspunktene". Dette tillater lagring av brukernes hjemmeområder (tradisjonelt lagret i <filename>/home/</filename>) på en andre harddisk, som da vil inneholde <literal>rhertzog</literal> og <literal>rmas</literal>-katalogene. Så snart disken er montert på  <filename>/home/</filename>, blir disse katalogene tilgjengelige på sine vanlige steder, og stier som <filename>/home/rmas/Desktop/hello.txt</filename> fortsetter å virke.</para>
      <indexterm><primary><command>mkfs</command></primary></indexterm>

      <para>Det er mange filsystemformater, og tilsvarende mange måter å lagre data fysisk på disker. De mest kjente er <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> og <emphasis>ext4</emphasis>, men også andre finnes. For eksempel, <emphasis>vfat</emphasis> er det systemet som  historisk ble brukt av DOS og Windows-operativsystemer, som gjør det mulig å bruke harddisker under Debian så vel som under Windows. I alle fall må et filsystem være forberedt på en disk før den kan monteres og denne operasjonen er kjent som "formatering". Kommandoer som <command>mkfs.ext3</command> (der <command>mkfs</command> står for <emphasis>MaKe FileSystem</emphasis>) formatteringsbehandling. Disse kommandoer krever, som et parameter, en enhetsfil som representerer den partisjonen som skal formateres (f.eks <filename>/dev/sda1</filename>). Denne operasjonen er destruktiv og bør bare kjøres en gang, bortsett fra hvis man bevisst ønsker å stryke ut et filsystem og starte på nytt.</para>

      <para>Det er også filsystemer i nettverk, slik som <acronym>NFS</acronym>, der data ikke er lagret på en lokal disk. I stedet overføres data via nettverket til en tjener som lagrer og henter dem ved behov. Filsystemets atskillelse skjermer brukere fra å være bekymret: filer forblir tilgjengelige på sine vanlige hierarkiske måte.</para>
    </section>
    <section id="sect.shared-functions">
      <title>Delte funksjoner</title>

      <para>Siden en rekke av de samme funksjonene brukes av all programvare, er det fornuftig å sentralisere dem i kjernen. For eksempel tillater et delt filsystem at et hvilket som helst program bare kan åpne en fil etter navn, uten å trenger å bekymre seg om hvor filen er lagret fysisk. Filen kan lagres i flere forskjellige disker på en harddisk, eller delt over flere harddisker, eller til og med lagret på en ekstern filtjener. Delte kommunikasjonsfunksjoner blir brukt av programmer til å utveksle data uavhengig av måten dataene transporteres. For eksempel kan transport være over hvilken som helst kombinasjon av lokale eller trådløse nettverk, eller over en fasttelefon.</para>
    </section>
    <section id="sect.process-management">
      <title>Å håndtere prosesser</title>
      <indexterm><primary><emphasis>pid</emphasis></primary></indexterm>

      <para>En prosess er en kjørende forekomst av et program. Dette krever minne til å lagre både selve programmet og dets driftsdata. Kjernen er ansvarlig for å opprette og spore dem. Når et program kjøres, setter kjernen først av litt minne, deretter laster den kjørbar kode fra filsystemet inn i det, og starter så å kjøre koden. Den tar vare på informasjon om denne prosessen, i hvilken det mest synlige er et identifikasjonsnummer som kalles <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis>).</para>

      <para>Unix-lignende kjerner (inkludert Linux), som de fleste andre moderne operativsystemer, er i stand til "fleroppgavekjøring". Med andre ord, at de kan kjøre mange prosesser "samtidig". Det er faktisk bare en kjørende prosess til enhver tid, men kjernen forkorter tiden i små deler og kjører hver prosess etter tur. Siden disse tidssnittene er meget korte (i millisekund-området), skaper de en illusjon av prosesser som kjører i parallell, selv om de faktisk er bare aktive i noen tidsintervaller og i tomgang resten av tiden. Kjernens jobb er å justere sine planleggingsmekanismer for å holde på denne illusjonen, og samtidig maksimere den globale Unix-lignende kjerner (inkludert Linux), som de fleste andre moderne operativsystemer, er i stand til "multi-tasking". Med andre ord, at de kjører mange prosesser "samtidig". Det er faktisk bare en kjørende prosess til enhver tid, men kjernen forkorter tiden i små skiver og løper hver prosess etter tur. Siden disse tidssnitt er meget kort (i millisekund-området), skaper de en illusjon av prosesser som kjører i parallell, selv om de faktisk er bare aktive i løpet av noen tidsintervaller og tomgang resten av tiden. Kjernen jobb er å justere sine planleggingsmekanismer for å holde på den illusjonen, samtidig maksimere den globale systemytelsen. Dersom tidssnitt er for langt kan programmet ikke fremstå som så responsivt som ønskelig. For kort, og systemet mister tid på bytte oppgaver for ofte. Disse beslutningene kan bli forskjøvet med prosess prioriteringer. Høyt prioriterte prosesser vil kjøre lenger og med mer hyppige tidssnitt enn lavt prioriterte prosesser.. Dersom tidssnitt er for langt kan programmet ikke fremstå som responsivt som ønskelig. For kort, og systemet mister tid på bytte oppgaver for ofte. Disse beslutningene kan endres med prosessprioriteringer. Høyt prioriterte prosesser vil kjøre lenger og med mer hyppige tidssnitt enn lavt prioriterte prosesser.</para>

      <sidebar>
        <title><emphasis>NOTE</emphasis> Fleroppgavekjøring (og varianter)</title>

	<para>Begrensningen beskrevet ovenfor, at bare én prosess kan kjøre på ett tidspunkt, gjelder ikke alltid. Selve begrensningen er at det bare kan være en kjørende prosess <emphasis>per processor core</emphasis> om gangen. Multi-prosessor, multi-kjerne eller "hypertrådede" systemer tillater at flere prosesser kjører parallelt. Systemet med fleroppgavekjøring er fortsatt i bruk, slik som å håndtere tilfeller der det er flere aktive prosesser enn tilgjengelige prosessorkjerner. Dette er langt fra uvanlig: et grunnleggende system, selv et stort sett inaktivt et, har nesten alltid et titalls prosesser som kjører.</para>
      </sidebar>

      <para>Selvfølgelig tillater kjernen å kjøre flere uavhengige prosesser med det samme program. Men hver kan bare få tilgang til sine egne tidssnitt og minne. Deres data og dermed forbli uavhengig.</para>
    </section>
    <section id="sect.permissions">
      <title>Å håndtere rettigheter</title>

      <para>Unix-lignende systemer er også multi-brukere. De gir et rettighetsforvaltnings- system som støtter egne brukere og grupper; det gir også kontroll over handlinger basert på tillatelser. Kjernen forvalter data for hver prosess, som tillater å kontrollere tillatelser. Mesteparten av tiden, er en prosess identifisert med brukeren som startet den. For den prosessen er kun tillatt å gjøre det som er tilgjengelig for brukeren. For eksempel å prøve å åpne en fil kreves det at kjernen kontrollerer prosessens identitet mot adgangstillatelser (for mer informasjon om dette eksempelet, se <xref linkend="sect.rights-management" />).</para>
    </section>
  </section>
  <section id="sect.user-space">
    <title>Brukerrommet</title>
    <indexterm><primary>user space</primary></indexterm>
    <indexterm><primary>kernel space</primary></indexterm>

    <para>"Brukerrom" refererer til kjøretidsmiljøet normale (i motsetning til kjerne-) prosesser. Dette betyr ikke nødvendigvis at disse prosessene faktisk er startet av brukere fordi et standard system normalt har flere "nisser" (eller bakgrunns-) prosesser som kjører før brukeren selv åpner en økt. Nisse-prosesser regnes også brukerrom-prosesser.</para>
    <section id="sect.process-basics">
      <title>Prosess</title>
      <indexterm><primary><command>init</command></primary></indexterm>

      <para>Når kjernen kommer forbi, starter den den aller første prosessen, <command>init</command>.  Prosess #1 er alene svært sjelden nyttig i seg selv, og Unix-lignende systemer kjører med mange prosesser i tillegg.</para>
      <indexterm><primary><emphasis>fork</emphasis></primary></indexterm>

      <para>Først av alt, kan en prosess klone seg selv (dette er kjent som en<emphasis>fork</emphasis>). Kjernen tildeler et nytt (men identisk) prosessminne, og en annen prosess for å bruke det. På denne tiden, er den eneste forskjellen mellom disse to prosessene deres <emphasis>pid</emphasis>. Den nye prosessen kalles vanligvis en barneprosess, og den opprinnelige prosessen, hvis <emphasis>pid</emphasis> ikke forandres, kalles foreldreprosessen.</para>

      <para>Noen ganger, fortsetter barneprosessen å leve sitt eget liv uavhengig av foreldreprosessen, med sine egne data kopiert fra den overordnede prosessen. I mange tilfelle kjører denne barneprosessen et annet program. Med noen få unntak, er minnet dens bare erstattet av det nye programmet, og gjennomføringen av dette nye programmet starter. Dette er mekanismen som brukes av init-prosessen (med prosess nummer 1) for å starte tilleggstjenester og gjennomføre hele oppstartsekvensen. På et tidspunkt, starter en prosess blant <command>init</command>s avkom et grafisk grensesnitt som brukerne kan logge seg på (det faktiske hendelsesforløpet er beskrevet mer i detalj i <xref linkend="sect.system-boot" />).</para>

      <para>Når en prosessen har fullført oppgaven den ble startet for, opphører den. Kjernen gjenvinner deretter minnet som er tilordnet denne prosessen, og stopper å gi den deler av diskens driftstid. Foreldreprosessen blir fortalt at barneprosessen dens blir avsluttet, noe som tillater at en prosess å vente på  fullføringen av en oppgave den delegerte til en barneprosess. Denne oppførselen synes tydelig i kommandolinje-tolker (kjent som <emphasis>shells</emphasis>). Når en kommando er skrevet inn i et skall, kommer bare meldingen tilbake når utførelsen av kommandoen er over. De fleste skjell tillater å kjøre kommandoen i bakgrunnen, som er det en så enkelt som å legge til <userinput>&amp;</userinput> til slutten av kommandoen. Ledeteksten vises igjen med en gang, noe som kan føre til problemer hvis kommandoen må vise sine egne data.</para>
    </section>
    <section id="sect.daemons">
      <title>Nisser</title>
      <indexterm><primary>nisse</primary></indexterm>
      <indexterm><primary>nisse</primary></indexterm>

      <para>En "nisse" er en prosess som startet automatisk ved oppstartsekvensen. Den fortsetter å kjøre (i bakgrunnen) for å utføre vedlikeholdsoppgaver eller yte tjenester til andre prosesser. Denne "bakgrunnsoppgaven" er faktisk tilfeldig, og samsvarer ikke med noe bestemt fra systemets synspunkt. De er bare prosesser, ganske lik andre prosesser, som går igjen når deres tidskvote kommer. Forskjellen er bare i menneskelig språk: En prosess som går uten interaksjon med brukeren (særlig uten grafisk grensesnitt) sies å være kjørt "i bakgrunnen" eller "som en nisse".</para>

      <sidebar>
        <title><emphasis>VOCABULARY</emphasis> Nisse, demon, en nedsettende betegnelse?</title>

	<para>Selv om <emphasis>daemon</emphasis>-begrepet deler sin greske etymologi med <emphasis>demon</emphasis>, innebærer førstnevnte ikke noe diabolsk onde, i stedet, skal den forstås som en slags hjelpende ånd. Dette skillet er subtilt nok i engelsk, men det er til og med verre i andre språk der samme ordet er brukt for begge betydninger.</para>
      </sidebar>

      <para>Forskjellige slike nisser er beskrevet i detalj i <xref linkend="unix-services" />.</para>
    </section>
    <section id="sect.ipc">
      <title>Inter-prosess kommunikasjoner (IPC)</title>
      <indexterm><primary>IPC</primary></indexterm>
      <indexterm><primary>Inter-Process Communications</primary></indexterm>

      <para>En isolert prosess, enten en nisse eller et interaktivt program, er sjelden nyttig i seg selv, noe som er grunnen til at det er flere metoder som lar separate prosesser kommunisere sammen, enten for å utveksle data eller for å kontrollere hverandre. Den generiske begrepet for dette er <emphasis>inter-process communication</emphasis>, eller i kortform IPC.</para>

      <para>Det enkleste IPC-systemet er å bruke filer. Prosessen som ønsker å sende data skriver den inn i en fil (med et navn kjent på forhånd), mens mottakeren bare har å åpne filen, og lese innholdet.</para>
      <indexterm><primary><emphasis>pipe</emphasis></primary></indexterm>

      <para>I tilfeller der du ikke ønsker å lagre data på disken, kan du bruke en <emphasis>pipe</emphasis>, som er rett og slett et objekt med to ender; bytes skrevet i den ene enden er lesbar i den andre. Dersom endene er styrt med separate prosesser, fører dette til en enkel og praktisk inter-prosess kommunikasjonskanal. Rør kan deles inn i to kategorier: Navngitte rør, og anonyme rør. Et navngitt rør er representert ved en oppføring i filsystemet (selv om de overførte data ikke er lagret der), slik at begge prosessene kan åpne det uavhengig om plasseringen av den navngitte røret er kjent på forhånd. I tilfeller hvor de kommuniserende prosessene er relatert (for eksempel en foreldre- og dens barne-prosess), den overordnede prosessen kan også opprette en anonymt rør før forgreninger, og barnet arver det. Begge prosesser vil da være i stand til å utveksle data gjennom røret uten filsystemet.</para>

      <sidebar>
        <title><emphasis>IN PRACTICE</emphasis> Et konkret eksempel</title>

	<para>La oss beskrive i detalj hva som skjer når en kompleks kommando (en <emphasis>pipeline</emphasis>) kjøres fra et skall. Vi antar vi har en <command>bash</command>-prosess (standard brukerskallet på Debian), med <emphasis>pid</emphasis> 4374; I dette skallet, skriver vi kommandoen:<command>ls | sort</command>.</para>

	<para>Skallet tolker første kommandoen skrevet i. I vårt tilfelle, det forstår at det er to programmer (<command>ls</command> og <command>sort</command>), med en datastrøm som flyter fra den ene til den andre (merket med <userinput>|</userinput>-tegnet, kjent som <emphasis>pipe</emphasis>). <command>bash</command> oppretter først et ikke navngitt rør (som i utgangspunktet bare eksisterer i selve <command>bash</command>-prosessen).</para>

	<para>Deretter kloner skallet seg selv; Dette fører til en ny   <command>bash</command>-prosess, med <emphasis>pid</emphasis> #4521 (<emphasis>pids</emphasis> er abstrakte tall, og generelt ikke har noen bestemt mening). Process #4521 arver røret, noe som betyr at den er i stand til å skrive på sin "input" side;<command>bash</command> omdirigeringer sin standard utgående strøm til dette rørets inngang. Så utfører den (og erstatter seg med)<command>ls</command>-programmet, som viser innholdet i den gjeldende katalogen. Ettersom <command>ls</command> skriver til sine standard utdata, og denne produksjonen tidligere er omdirigert, blir resultatene effektivt sendt inn i røret.</para>

	<para>En lignende operasjon skjer for den andre kommandoen:<command>bash</command> kloner seg igjen, noe som fører til en ny <command>bash</command>-prosess med pid #4522. Siden den også er en barneprosess fra #4374, arver den også røret; <command>bash</command> kobler deretter sin standard inngang til rørets utgang, deretter kjøres (og erstatter seg med) <command>sort</command>-kommandoen, som sorterer sine innspill og viser resultatene.</para>

	<para>Alle bitene i puslespillet er nå satt sammen: <command>ls</command> leser den gjeldende katalogen og skriver en liste over filer inn i røret; <command>sort</command> leser denne listen, sorterer den alfabetisk, og viser resultatene. Så avsluttes prosessnummer #4521 og #4522, og #4374 (som ventet på dem under operasjonen), gjenopptar kontrollen og viser meldingen for å tillate brukeren å skrive inn en ny kommando.</para>
      </sidebar>

      <para>Ikke all inter-prosess kommunikasjon brukes til å flytte data rundt. I mange situasjoner, er den eneste informasjonen som må overføres kontrollmeldinger som "pause utførelse" eller "gjenoppta kjøring". Unix (og Linux) gir en mekanisme som kalles <emphasis>signals</emphasis>, gjennom hvilken en prosess bare kan sende et bestemt signal (valgt fra en forhåndsdefinert liste av signaler) til en annen prosess. Det eneste kravet er å kjenne til målets <emphasis>pid</emphasis>.</para>

      <para>For mer komplekse kommunikasjoner, er det også mekanismer som tillater at en prosess åpner tilgang, eller deler, en del av sitt tildelte minne til andre prosesser. Minnet, som nå er delt mellom dem, kan brukes til å flytte data mellom prosessene.</para>

      <para>Endelig, nettverkstilkoblinger kan også hjelpe prosesser å kommunisere; disse prosessene kan også kjøres på forskjellige datamaskiner, muligens tusenvis av kilometer fra hverandre.</para>

      <para>Det er ganske standard for et typisk Unix-likt system i ulik grad å gjøre bruk av alle disse mekanismene.</para>
    </section>
    <section id="sect.libraries">
      <title>Biblioteker</title>
      <indexterm><primary>library (of functions)</primary></indexterm>

      <para>Funksjonsbibliotekene spiller en avgjørende rolle i en Unix-likt operativsystem. De er ikke egentlig programmer, da de ikke kan kjøres på egen hånd, men er samlinger av kodefragmenter som kan brukes av standardprogrammer. Blant de vanligste biblioteker, kan du finne:</para>
      <itemizedlist>
        <listitem>
	  <para>Standard C biblioteket (<emphasis>glibc</emphasis>), som inneholder grunnleggende funksjoner som det å åpne filer eller nettverkstilkoblinger - og andre som legger til rette for interaksjoner med kjernen;</para>
        </listitem>
        <listitem>
	  <para>grafiske verktøysett, for eksempel Gtk+ og Qt, som tillater at mange programmer gjenbruker de grafiske objektene de leverer;</para>
        </listitem>
        <listitem>
	  <para><emphasis>libpng</emphasis>-biblioteket som tillater lasting, tolking og lagring av bilder i PNG-format.</para>
        </listitem>
      </itemizedlist>

      <para>Takket være disse bibliotekene, kan programmer gjenbruke eksisterende kode. Programutvikling forenkles fordi mange programmer kan bruke de samme funksjonene. Med bibliotekene er ofte utviklet av forskjellige personer, så den globale utviklingen av systemet er nærmere Unixs historiske filosofi.</para>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> Unix-måten: En ting om gangen</title>

	<para>En av de grunnleggende begreper som ligger til grunn for Unix-familiens operativsystemer er at hvert verktøyet bare skal gjøre en ting, og gjør det bra; programmer kan deretter bruke disse verktøyene for å bygge en mer avansert logikk på toppen. Denne filosofien kan gjenfinnes i mange utgaver. Skjell-skript kan være det beste eksemplet: De kan sette sammen komplekse sekvenser av svært enkle verktøy (for eksempel <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command> og så videre). En annen implementering av denne filosofien sees i kodebiblioteker: <emphasis>libpng</emphasis> -biblioteket gjør det mulig å lese og skrive PNG-bilder, med ulike alternativer og på ulike måter, men det gjør bare det; ikke noe spørsmål om å inkludere funksjoner som viser eller redigerer bilder.</para>
      </sidebar>

      <para>Dessuten er disse bibliotekene ofte referert til som "felles biblioteker", ettersom kjernen bare er i stand til å laste dem inn i minnet én gang, selv om flere prosesser benytter samme bibliotek samtidig. Dette tillater å spare  lagringsminne, sammenlignet med den motsatte (hypotetisk) situasjon, hvor koden for et bibliotek ville være lastet like mange ganger som det er prosesser som benytter den.</para>
    </section>
  </section>
</appendix>
