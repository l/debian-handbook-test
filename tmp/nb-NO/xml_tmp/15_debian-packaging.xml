<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="debian-packaging">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-debian-packaging.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Bakdør</keyword>
      <keyword>Gjenoppbygge</keyword>
      <keyword>Kildepakke</keyword>
      <keyword>Arkiv</keyword>
      <keyword>Meta-pakke</keyword>
      <keyword>Debian utvikler</keyword>
      <keyword>Vedlikeholder</keyword>
    </keywordset>
  </chapterinfo>
  <title>Å lage en Debian-pakke</title>
  <highlights>
    <para>Det er ganske vanlig, for en administrator som regulært har håndtert Debian-pakker, å kanskje føle behov for å lage sine egne pakker, eller å modifisere en eksisterende pakke. Dette kapitlet tar sikte på å svare på de vanligste spørsmålene for det, og vise de nødvendige elementer som skal til for å nyttiggjøre seg Debian infrastruktur på en best mulig måte. Med litt hell, etter å ha prøvd lokale pakker, kan du selv føle behov for å gå lenger enn det, og selv bli med i Debian-prosjektet!</para>
  </highlights>
  <section id="sect.rebuilding-package">
    <title>Å bygge om en pakke fra sine kilder</title>

    <para>Å bygge om en binær pakke er nødvendig under flere omstendigheter. I noen tilfeller trenger administratoren en programvarefunksjon som krever at programvaren som skal kompileres fra kilder med et spesielt kompileringsalternativ; i andre, er programvaren som er pakket i den installerte versjonen av Debian ikke ny nok. I det sistnevnte tilfelle vil administratoren vanligvis bygge en nyere pakke tatt fra en nyere versjon av Debian - såsom <emphasis role="distribution">Testing</emphasis> eller til og med <emphasis role="distribution">Unstable</emphasis> — slik at denne nye pakken virker i deres <emphasis role="distribution">Stable</emphasis>-distribusjon; denne operation kalles “backporting”. Som vanlig, bør man være forsiktig før en tar på seg en slik oppgave, me sjekke om den har blitt gjort allerede: ta en rask titt på Debian Package Tracker for å se om pakken kan vise informasjon om det. <ulink type="block" url="https://tracker.debian.org/" /> <indexterm><primary>backport</primary></indexterm></para>
    <section>
      <title>Å skaffe kildene</title>

      <para>Å bygge om en Debian pakke starter med å skaffe seg kildekoden. Den enkleste måten er å bruke <command>apt-get source <replaceable>source-package-name</replaceable></command>-kommandoen. Denne kommanoen krever en  <literal>deb-src</literal>-linje i <filename>/etc/apt/sources.list</filename>-filen, og oppdaterte indeksfiler( det er <command>apt-get update</command>). Disse betingelsene skulle allerede være imøtekommet hvis du fulgte instrujksjonene from kapitelet om APT-konfigurasjon (se <xref linkend="sect.apt-sources.list" />). Merk imidlertid at du vil laste ned kildekodepakkene fra den Debian-versjonen som er nevnt i <literal>deb-src</literal>-linjen. Hvis du trenger en annen versjon, må du kanskje laste den ned manuelt fra et Debian speil eller fra nettstedet. Dette innebærer henting av to eller tre filer (med utvidelser <filename>*.dsc</filename> — for <emphasis>Debian Source Control</emphasis> — <filename>*.tar.<replaceable>comp</replaceable></filename>, og noen ganger  <filename>*.diff.gz</filename> eller <filename>*.debian.tar.<replaceable>comp</replaceable></filename> — <replaceable>comp</replaceable> som tar en verdi blant <literal>gz</literal>, <literal>bz2</literal> eller <literal>xz</literal> avhengig av det kompresjonsverktøyet som er i bruk), så kjør <command>dpkg-source -x <replaceable>file.dsc</replaceable></command>-kommandoen. Hvis <filename>*.dsc</filename>-filen er tilgjengelig direkte fra en gitt URL, er det en til og med enklere vei å få tak i alt sammen, med <command>dget <replaceable>URL</replaceable></command>-kommandoen. Denne kommandoen (som kan bli funnet i <emphasis role="pkg">devscripts</emphasis> pakken) fanger opp <filename>*.dsc</filename>-filen på den gitte adressen, så analyserer den innholdet, og filen eller filene det refereres til hentes automatisk. Når alt er lastet ned, pakkes kildepakken ut (såfremt <literal>-d</literal> eller <literal>--download-only</literal>-valget er benyttet).</para>
    </section>
    <section>
      <title>Å lage forandringer</title>

      <para>Pakkekilden er tilgjengelig i en katalog oppkalt etter kildepakkes versjon (for eksempel <emphasis>samba-4.1.17+dfsg</emphasis>); Dette er der vi skal jobbe med våre lokale endringer.</para>

      <para>Det første du må gjøre er å endre pakkens versjonsnummer, slik at de gjenoppbygde pakkene kan skilles fra de opprinnelige pakkene som følger med Debian. Forutsatt at gjeldende versjon er <literal>2:4.1.17+dfsg-2</literal>, kan vi lage versjon <literal>2:4.1.17+dfsg-2falcot1</literal>, som tydelig viser opprinnelsen av pakken. Dette gjør pakkens versjonsnummer høyere enn den som tilbys av Debian, slik at pakken lett vil installeres som en oppdatering til den opprinnelige pakken. En slik endring er best utføres med <command>dch</command>-kommandoen (<emphasis>Debian CHangelog</emphasis>) fra <emphasis role="pkg">devscripts</emphasis>-pakken med en kommando slik som <command>dch --local falcot</command>. Dette tar i bruk en tekstredigere (<command>sensible-editor</command> — dette burder være din favorittredigerer hvis den er nevnt i  <varname>VISUAL</varname> eller <varname>EDITOR</varname>-miljøvariablene, og ellers standard redigereren) for å tillate å dokumentere forskjellene som følger av denne ombygningen. Denne redigereren viser oss at <command>dch</command> virkelig forandret <filename>debian/changelog</filename>-filen.</para>

      <para>Når det kreves en endring i oppbyggingen, må det lages endringer i  <filename>debian/rules</filename>, som skritt for skrit driver pakkens byggeprosess. I de enkleste tilfellene, er linjene om den opprinnelige konfigurasjonen (<literal>./configure …</literal>) eller i den aktuelle utgaven (<literal>$(MAKE) …</literal> or <literal>make …</literal>) enkle å finne. Hvis disse kommandoene ikke påkalles eksplisitt kalles, er de sannsynligvis en bivirkning av en annen eksplisitt kommando, i så fall kan du se i dokumentasjonen for å lære mer om hvordan du endrer standard virkemåten. Med pakker som bruker <command>dh</command>, kan du trenge å legge til en overstyring for <command>dh_auto_configure</command> eller <command>dh_auto_build</command>-kommandoene (se de respektive manualsidene deres for forklaringer om hvordan du oppnå dette).</para>

      <para>Avhengig av de lokale endringene pakkene, kan en oppdatering også være nødvendig i <filename>debian/control</filename>-filen, som inneholder en beskrivelse av de genererte pakker. Spesielt inneholder denne filen <literal>Build-Depends</literal> linjer som kontrollerer listen over avhengigheter som må være oppfylt når pakken bygges. Disse refererer ofte til versjonene til pakkene i distribusjonen kildepakken kommer fra, men som kanskje ikke er tilgjengelig i distribusjonen som brukes til ombygging. Det er ingen automatisk måte å avgjøre om en avhengighet er ekte, eller bare spesifisert til å garantere at bygget kun skal bli forsøkt med den nyeste versjonen av et bibliotek - dette er den eneste tilgjengelige måten å tvinge en <emphasis>autobuilder</emphasis> til å bruke en gitt pakkeversjon under oppbyggingen, og det er derfor Debians vedlikeholdere ofte bruker strenge versjonsbestemte bygge-avhengigheter.</para>

      <para>Hvis du vet sikkert at disse bygge-avhengigheter er for strenge, bør du føle deg fri til å løsne på dem lokalt. Å lese filene som dokumenterer den vanlige måten å bygge programvare - disse filene blir ofte kalt <filename>INSTALL</filename> — vil hjelpe deg å finne de riktige avhengighetene. Ideelt sett bør alle avhengigheter være imøtekommet fra distribusjonen som brukes til ombygging. Hvis de ikke er det, starter en gjentakingsprosess, der pakkene nevnt i <literal>Build-Depends</literal> feltet må backportes før målet pakken kan bli det. Noen pakker trenger kanskje ikke backporting, og kan installeres som de er i løpet av byggeprosessen (et kjent eksempel er <emphasis role="pkg">debhelper</emphasis>). Merk at backporting-prosessen raskt kan bli komplisert hvis du ikke er forsiktig. Derfor bør backporter holdes på et absolutt minimum der det er mulig.</para>

      <sidebar>
        <title><emphasis>TIP</emphasis> Installing <literal>Build-Depends</literal></title>
        <indexterm><primary><literal>Build-Depends</literal>, control field</primary></indexterm> 
	<para><command>apt-get</command> tillater installasjon av alle pakker nevnt i  <literal>Build-Depends</literal>-feltene til en kildepakke som er tilgjengelig i en distribusjon nevnt i en <literal>deb-src</literal> line i <filename>/etc/apt/sources.list</filename>-filen. Dette er så enkelt om å kjøre <command>apt-get build-dep <replaceable>source-package</replaceable></command>-kommandoen.</para>
      </sidebar>
    </section>
    <section>
      <title>Å starte en gjenoppbygging</title>

      <para>Når alle de nødvendige endringene har blitt brukt på kildene, kan vi starte å generere den aktuelle binære pakkefilen (<filename>.deb</filename>). Hele prosessen er håndtert av <command>dpkg-buildpackage</command>-kommandoen.</para>

      <example>
        <title>Å bygge om en pakke</title>

        <screen><computeroutput>$ </computeroutput><userinput>dpkg-buildpackage -us -uc
</userinput><computeroutput>[...]
</computeroutput></screen>
      </example>

      <sidebar id="sidebar.fakeroot">
        <title><emphasis>TOOL</emphasis> <command>fakeroot</command></title>

	<para>I hovedsak er prosessen med å bygge pakker en så enkel sak som, i et arkiv, å samle et sett av eksisterende (eller bygde) filer. De fleste filene vil så bli eid av <emphasis>root</emphasis> i arkivet. Men å bygge hele pakken under denne brukeren skulle tilsi økt risiko. Heldigvis kan dette unngås med <command>fakeroot</command>-kommandoen. Dette verktøyet kan brukes til å kjøre et program og gi det inntrykk av at det kjører som <emphasis>root</emphasis> og skaper filer med vilkårlig eierskap og rettigheter. Når programmet skaper arkivet som vil bli Debian-pakken, er det lurt til å skape et arkiv som inneholder filer merket som tilhørende vilkårlige eiere, inkludert <emphasis>root</emphasis>. Dette oppsettet er så praktisk at <command>dpkg-buildpackage</command> bruker <command>fakeroot</command> som standard ved pakkebygging.</para>

	<para>Merk at programmet bare er lurt til å "tro" at det fungerer som en priviligert konto, og prosessen faktisk kjører som om brukeren kjører <command>fakeroot <replaceable>program</replaceable></command> (og filene faktisk er opprettet med den brukerens tillatelser). Ikke på noe tidspunkt får det faktisk rotprivilegier som det kunne misbruke.</para>
      </sidebar>

      <para>Den tidligere kommandoen kan mislykkes hvis <literal>Build-Depends</literal>-feltene ikke her blitt oppdatert, eller hvis de relaterte pakker ikke er installert. I dette tilfelle er det mulig å overprøve denne sjekken ved å sende <literal>-d</literal>-valget til <command>dpkg-buildpackage</command>. Men å eksplisitt ignorere disse avhengigheter gir risiko for at byggeprosessen mislykkes på et senere tidspunkt. Verre, kan pakken synes å bli bygget riktig, men klarer ikke å kjøre skikkelig: Noen programmer deaktiverer automatisk noen av sine oppgaver når et nødvendig bibliotek er ikke tilgjengelig på byggetidspunktet.</para>

      <para>Oftere enn ikke bruker Debian-utviklere et høynivå-program som <command>debuild</command>; Dette kjører <command>dpkg-buildpackage</command> til vanlig, men legger også til en påkalling til et program som kjører mange kontroller for å validere den genererte pakken opp mot Debians politikk. Dette skriptet renser også opp i miljøet, slik at lokale miljøvariabler ikke "forurenser" pakkebyggingen. <command>debuild</command>-kommandoen er et av verktøyene i <emphasis>devscripts</emphasis>-pakken, som deler noe konsistens og oppsett for å gjøre vedlikeholderens oppgave enklere.</para>

      <sidebar>
        <title><emphasis>QUICK LOOK</emphasis> <command>pbuilder</command></title>
        <indexterm><primary><command>pbuilder</command></primary></indexterm>

	<para><command>pbuilder</command>-programmet (i pakken med det tilsvarende navnet) tillater bygging av en Debian-pakke i en  <emphasis>chrooted</emphasis>-omgivelse. Den lager først en midlertidig katalog med det minimale systemet som kreves for å bygge pakken (inkludert pakkene nevnt i <emphasis>Build-Depends</emphasis>-feltet). Denne katalogen blir så brukt som rotkatalog (<filename>/</filename>), og bruker <command>chroot</command>-kommandoen under byggeprosessen.</para>

	<para>Dette verktøyet gjør at byggeprosessen skjer i et miljø som ikke endres av brukernes virksomhet. Dette gir også mulighet for rask påvisning av manglende bygge-avhengigheter (siden byggingen vil mislykkes uten dokumentasjon av de riktige avhengighetene). Til slutt, tillater det å bygge en pakke for en Debian-versjon som ikke er den som brukes av systemet som helhet: Maskinen kan  bruke <emphasis role="distribution">Stable</emphasis> i sitt normale arbeid, og  en <command>pbuilder</command> som kjører på den samme maskinen, kan bruke <emphasis role="distribution">Unstable</emphasis> til pakkebygging.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.building-first-package">
    <title>Å bygge din første pakke</title>
    <section>
      <title>Meta-pakker eller falsk pakker</title>

      <para>Falske pakker og meta-pakker er like, ved at de er tomme skall som bare eksisterer for effektene meta-dataene deres har på pakkehåndterings-stabelen.</para>

      <para>Formålet med en falsk pakke er å lure <command>dpkg</command> og <command>apt</command> til å tro at noen pakker er installert, selv om de bare er et tomt skall. Dette tillater å tilfredsstille avhengigheter i en pakke når den tilsvarende programvaren ble installert utenfor rammen av pakkesystemet. En slik metode fungerer, men bør likevel unngås når det er mulig, ettersom det ikke er noen garanti for at den manuelt installerte programvaren oppfører seg akkurat som den tilsvarende pakken ville ha gjort, og andre pakker som er avhengig av den, ikke vil fungere ordentlig.</para>

      <para>På den annen side foreligger det en meta-pakke oftest som en samling av avhengigheter, slik at montering av meta-pakken faktisk vil føre inn et sett av andre pakker i et enkelt trinn.</para>

      <para>Begge disse pakkesalgene kan lages av <command>equivs-control</command> og <command>equivs-build</command>-kommandoene (i <emphasis role="pkg">equivs</emphasis>-pakken). <command>equivs-control <replaceable>file</replaceable></command>-kommandoen oppretter en Debian-pakke topptekstfil som skal redigeres for å inneholde navnet på den forventede pakken, dens versjonsnummer, navnet på vedlikeholderen, avhengighetene, og beskrivelsen. Andre felt uten en standardverdi er valgfrie og kan slettes.<literal>Copyright</literal>, <literal>Changelog</literal>, <literal>Readme</literal> og <literal>Extra-Files</literal>-feltene er ikke standard felt i Debian-pakker; de bare gir mening innenfor rammen av <command>equivs-build</command>, og de vil ikke bli beholdt i overskriftene til den genererte pakken.</para>

      <example>
        <title>Topptekstfil for den falske pakken <emphasis>libxml-libxml-perl</emphasis></title>

        <programlisting>
Section: perl
Priority: optional
Standards-Version: 3.9.6

Package: libxml-libxml-perl
Version: 2.0116-1
Maintainer: Raphael Hertzog &lt;hertzog@debian.org&gt;
Depends: libxml2 (&gt;= 2.7.4)
Architecture: all
Description: Fake package - module manually installed in site_perl
 This is a fake package to let the packaging system
 believe that this Debian package is installed. 
 .
 In fact, the package is not installed since a newer version
 of the module has been manually compiled &amp; installed in the
 site_perl directory.
</programlisting>
      </example>

      <para>Det neste skrittet er å generere Debian-pakken med <command>equivs-build <replaceable>file</replaceable></command>-kommandoen. Og plutselig er pakken opprettet i den gjeldende katalogen, og kan håndteres som en hver annen Debian-pakke ville blitt.</para>
    </section>
    <section>
      <title>Et enkelt filarkiv</title>

      <para>For å lette utplasseringen av et sett med dokumentasjon på et stort antall maskiner, trenger Falcot Corp administratorene å lage en Debian-pakke. Administratoren med ansvaret for denne oppgaven leser først “New Maintainer's Guide”, og begynner så å jobbe med sin første pakke. <ulink type="block" url="https://www.debian.org/doc/manuals/maint-guide/" /></para>

      <para>Det første skrittet er å lage en <filename>falcot-data-1.0</filename>-mappe som skal inneholde mål-kildepakken. Pakken vil logisk nok få navnet <literal>falcot-data</literal> og bære versjonsnummeret <literal>1.0</literal>. Adminisstratoren plasserer så dokumentaasjonsfilene i en <filename>data</filename>-undermappe. Så påkaller de <command>dh_make</command>-kommandoen  (fra <emphasis role="pkg">dh-make</emphasis>-pakken) for å legge til filene som kreves for pakke-genereringsprosessen, - som alle blir lagret i en <filename>debian</filename>-undermappe:</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>cd falcot-data-1.0</userinput>
<computeroutput>$ </computeroutput><userinput>dh_make --native</userinput>
<computeroutput>
Type of package: single binary, indep binary, multiple binary, library, kernel module, kernel patch?
 [s/i/m/l/k/n] </computeroutput><userinput>i</userinput>
<computeroutput>
Maintainer name : Raphael Hertzog
Email-Address   : hertzog@debian.org
Date            : Fri, 04 Sep 2015 12:09:39 -0400
Package Name    : falcot-data
Version         : 1.0
License         : gpl3
Type of Package : Independent
Hit &lt;enter&gt; to confirm:
Currently there is no top level Makefile. This may require additional tuning.
Done. Please edit the files in the debian/ subdirectory now. You should also
check that the falcot-data Makefiles install into $DESTDIR and not in / .
$</computeroutput>
</screen>

      <para>Den valgte pakketypen (<emphasis>indep binary</emphasis>) indikerer at denne kildepakken vil generere en enkelt binær pakke som kan deles på tvers av alle arkitekturer (<literal>Architecture: all</literal>). <emphasis>single binary</emphasis> virker som en motpart, og fører til en enkelt binærpakke som er avhengig av målarkitekturen (<literal>Architecture: any</literal>). I dette tilfellet er valget mer relevant, siden pakken bare inneholder dokumentasjon og ingen binære programmer, slik at den kan brukes på samme måte på datamaskiner av alle arkitekturer.</para>

      <indexterm><primary>package types</primary></indexterm>
      <indexterm><primary>package</primary><secondary>types</secondary></indexterm>

      <para><emphasis>multiple binary</emphasis>-typen svarer til en kildekodepakke som leder til forskjellige binærpakker. Et spesielt tilfelle,  <emphasis>library</emphasis>,  er nyttig for delte biblioteker, siden de må følge strenge pakkeregler. På lignende måte skal <emphasis>kernel module</emphasis> eller <emphasis>kernel patch</emphasis> begrenses til pakker som inneholder kjernemoduler.</para>

      <sidebar>
        <title><emphasis>TIP</emphasis> Vedlikeholders navn og e-post</title>

	<para>De fleste programmene involvert i pakkevedlikeholdet vil søke etter ditt navn og e-postadresse i <varname>DEBFULLNAME</varname> og <varname>DEBEMAIL</varname> eller <varname>EMAIL</varname>-miljøvariabler. Ved å definere dem en gang for alle, vil du unngå å måtte sortere dem flere ganger. Hvis ditt vanlige skall er <command>bash</command>, er det bare å legge til følgende to linjer i din <filename>~/.bashrc</filename>-file (du vil ganske sikkert erstatte verdiene med noen mer relevante!):</para>

        <programlisting>
export EMAIL="hertzog@debian.org"
export DEBFULLNAME="Raphael Hertzog"
</programlisting>
      </sidebar>

      <para><command>dh_make</command>-kommandoen laget en <filename>debian</filename> undermappe med mange filer. Noen kreves, spesielt <filename>rules</filename>, <filename>control</filename>, <filename>changelog</filename> og <filename>copyright</filename>. Filer mede <filename>.ex</filename>-forlengelsen er eksempelfiler som kan brukes ved å  modifisere dem (og fjerne forlengelsen) når det passer. Når de ikke er nødvendige, anbefales det å fjerne dem. <filename>compat</filename> bør beholdes, ettersom den er nødvendig for riktig funksjon av <emphasis>debhelper</emphasis>-programpakken (som alle begynner med  <command>dh_</command>-forstavelsen), og som brukes på ulike stadier i pakkebyggingsprosessen.</para>

      <para><filename>copyright</filename> må inneholde informasjon om forfatterne av dokumentasjonen som er inkludert i pakken, og den tilhørende lisensen. I vårt tilfelle, er intern dokumentasjon bruken av den er begrenset til til Falcot Corp-selskapet. Standardfilen <filename>changelog</filename> er vanligvis hensiktsmessig; den erstatter "Første utgivelse" med en mer detaljert forklaring og endrer disgtribusjonen fra <literal>unstable</literal> til <literal>internal</literal> er nok. <filename>control</filename>-filen ble også oppdatert: <literal>Section</literal>-feltet er forandret til <emphasis>misc</emphasis> og <literal>Homepage</literal>, <literal>Vcs-Git</literal> og <literal>Vcs-Browser</literal>-feltene ble forandret. <literal>Depends</literal>-feltene ble komplettert med <literal>iceweasel | www-browser</literal> for å sikre tilgjengeligheten for en pålitelig nettleser som kan vise dokumentasjoen i pakken.</para>

      <example>
        <title><filename>control</filename>-filen</title>

        <programlisting>
Source: falcot-data
Section: misc
Priority: optional
Maintainer: Raphael Hertzog &lt;hertzog@debian.org&gt;
Build-Depends: debhelper (&gt;= 9)
Standards-Version: 3.9.5

Package: falcot-data
Architecture: all
Depends: iceweasel | www-browser, ${misc:Depends}
Description: Internal Falcot Corp Documentation
 This package provides several documents describing the internal
 structure at Falcot Corp.  This includes:
  - organization diagram
  - contacts for each department.
 .
 These documents MUST NOT leave the company.
 Their use is INTERNAL ONLY.
</programlisting>
      </example>

      <example>
        <title><filename>changelog</filename>-filen</title>

        <programlisting>
falcot-data (1.0) internal; urgency=low

  * Initial Release.
  * Let's start with few documents:
    - internal company structure;
    - contacts for each department.

 -- Raphael Hertzog &lt;hertzog@debian.org&gt;  Fri, 04 Sep 2015 12:09:39 -0400
</programlisting>
      </example>

      <example>
        <title><filename>copyright</filename>-filen</title>

        <programlisting>
Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
Upstream-Name: falcot-data

Files: *
Copyright: 2004-2015 Falcot Corp
License: 
 All rights reserved.
</programlisting>
      </example>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> <filename>Makefile</filename> file</title>
        <indexterm><primary><filename>Makefile</filename></primary></indexterm>

	<para><filename>Makefile</filename>-filen er et skript som brukes av  <command>make</command>-programmet; Det beskriver regler for hvordan man skal bygge et sett med filer fra hverandre i et tre med avhengigheter (for eksempel, kan et program bygges fra et sett med kildefiler). <filename>Makefile</filename>-filen beskriver disse reglene i det følgende formatet:</para>

        <programlisting>
target: source1 source2 ...
        command1
        command2
</programlisting>

	<para>Tolkningen av slik regel er som følger: Hvis en av <literal>source*</literal>-filene er nyere enn <literal>target</literal>-filen, trenger målet generering ved å bruke <command>command1</command> og <command>command2</command>.</para>

	<para>Merk at kommandolinjene må starte med et TAB-tegn; Merk også at når en kommandolinje starter med en skråstrek (<literal>-</literal>), avbryter ikke feil i kommandoen hele prosessen.</para>
      </sidebar>

      <para>The <filename>rules</filename> file usually contains a set of
      rules used to configure, build and install the software in a
      dedicated subdirectory (named after the generated binary package).
      The contents of this subdirectory is then archived within the Debian
      package as if it were the root of the filesystem. In our case, files
      will be installed in the
      <filename>debian/falcot-data/usr/share/falcot-data/</filename>
      subdirectory, so that installing the generated package will deploy
      the files under <filename>/usr/share/falcot-data/</filename>. The
      <filename>rules</filename> file is used as a
      <filename>Makefile</filename>, with a few standard targets (including
      <literal>clean</literal> and <literal>binary</literal>, used
      respectively to clean the source directory and generate the binary
      package).</para>

      <para>Although this file is the heart of the process, it increasingly
      contains only the bare minimum for running a standard set of commands
      provided by the <command>debhelper</command> tool. Such is the case
      for files generated by <command>dh_make</command>. To install our
      files, we simply configure the behavior of the
      <command>dh_install</command> command by creating the following
      <filename>debian/falcot-data.install</filename> file:</para>

      <programlisting>
data/* usr/share/falcot-data/
</programlisting>

      <para>At this point, the package can be created. We will however add
      a lick of paint. Since the administrators want the documents to be
      easily accessed from the menus of graphical desktop environments,
      we add a <filename>falcot-data.desktop</filename> file and
      get it installed in <filename>/usr/share/applications</filename>
      by adding a second line to <filename>debian/falcot-data.install</filename>.
      </para>

      <example>
        <title>The <filename>falcot-data.desktop</filename> file</title>

        <programlisting>
[Desktop Entry]
Name=Internal Falcot Corp Documentation
Comment=Starts a browser to read the documentation
Exec=x-www-browser /usr/share/falcot-data/index.html
Terminal=false
Type=Application
Categories=Documentation;
</programlisting>
      </example>

      <para>The updated <filename>debian/falcot-data.install</filename> looks
      like this:</para>
      <programlisting>
data/* usr/share/falcot-data/
falcot-data.desktop usr/share/applications/
</programlisting>

      <para>Vår kildepakke er nå klar. Alt som gjenstår å gjøre er å generere den binære pakken, med den samme metoden vi brukte tidligere for å bygge om pakker: vi kjører <command>dpkg-buildpackage -us -uc</command>-kommandoen fra <filename>falcot-data-1.0</filename>-mappen.</para>
    </section>
  </section>
  <section id="sect.setup-apt-package-repository">
    <title>Creating a Package Repository for APT</title>
    <indexterm><primary>package archive</primary></indexterm>
    <indexterm><primary>package</primary><secondary>Debian</secondary><tertiary>archive of</tertiary></indexterm>

    <para>Falcot Corp gradually started maintaining a number of Debian
    packages either locally modified from existing packages or created from
    scratch to distribute internal data and programs.</para>

    <para>To make deployment easier, they want to integrate these packages
    in a package archive that can be directly used by APT. For obvious
    maintenance reasons, they wish to separate internal packages from
    locally-rebuilt packages. The goal is for the matching entries in a
    <filename>/etc/apt/sources.list.d/falcot.list</filename> file to be as
    follows:</para>

    <programlisting>
deb http://packages.falcot.com/ updates/
deb http://packages.falcot.com/ internal/
</programlisting>
    <indexterm><primary><command>mini-dinstall</command></primary></indexterm>

    <para>The administrators therefore configure a virtual host on their
    internal HTTP server, with <filename>/srv/vhosts/packages/</filename>
    as the root of the associated web space. The management of the archive
    itself is delegated to the <command>mini-dinstall</command> command
    (in the similarly-named package). This tool keeps an eye on an
    <filename>incoming/</filename> directory (in our case,
    <filename>/srv/vhosts/packages/mini-dinstall/incoming/</filename>) and
    waits for new packages there; when a package is uploaded, it is
    installed into a Debian archive at
    <filename>/srv/vhosts/packages/</filename>. The
    <command>mini-dinstall</command> command reads the
    <filename>*.changes</filename> file created when the Debian package is
    generated. These files contain a list of all other files associated with
    the version of the package (<filename>*.deb</filename>,
    <filename>*.dsc</filename>,
    <filename>*.diff.gz</filename>/<filename>*.debian.tar.gz</filename>,
    <filename>*.orig.tar.gz</filename>, or their equivalents with other
    compression tools), and these allow <command>mini-dinstall</command> to
    know which files to install. <filename>*.changes</filename> files also
    contain the name of the target distribution (often
    <literal>unstable</literal>) mentioned in the latest
    <filename>debian/changelog</filename> entry, and
    <command>mini-dinstall</command> uses this information to decide where
    the package should be installed. This is why administrators must always
    change this field before building a package, and set it to
    <literal>internal</literal> or <literal>updates</literal>, depending on
    the target location. <command>mini-dinstall</command> then generates
    the files required by APT, such as
    <filename>Packages.gz</filename>.</para>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> <command>apt-ftparchive</command></title>
      <indexterm><primary><command>apt-ftparchive</command></primary></indexterm>

      <para>If <command>mini-dinstall</command> seems too complex for your
      Debian archive needs, you can also use the
      <command>apt-ftparchive</command> command. This tool scans the
      contents of a directory and displays (on its standard output) a
      matching <filename>Packages</filename> file. In the Falcot Corp case,
      administrators could upload the packages directly into
      <filename>/srv/vhosts/packages/updates/</filename> or
      <filename>/srv/vhosts/packages/internal/</filename>, then run the
      following commands to create the <filename>Packages.gz</filename>
      files:</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>cd /srv/vhosts/packages</userinput>
<computeroutput>$ </computeroutput><userinput>apt-ftparchive packages updates &gt;updates/Packages</userinput>
<computeroutput>$ </computeroutput><userinput>gzip updates/Packages</userinput>
<computeroutput>$ </computeroutput><userinput>apt-ftparchive packages internal &gt;internal/Packages</userinput>
<computeroutput>$ </computeroutput><userinput>gzip internal/Packages</userinput>
</screen>

      <para>The <command>apt-ftparchive sources</command> command allows
      creating <filename>Sources.gz</filename> files in a similar
      fashion.</para>
    </sidebar>

    <para>Configuring <command>mini-dinstall</command> requires setting up
    a <filename>~/.mini-dinstall.conf</filename> file; in the Falcot Corp
    case, the contents are as follows:</para>

    <programlisting>
[DEFAULT]
archive_style = flat
archivedir = /srv/vhosts/packages

verify_sigs = 0
mail_to = admin@falcot.com

generate_release = 1
release_origin = Falcot Corp
release_codename = stable

[updates]
release_label = Recompiled Debian Packages

[internal]
release_label = Internal Packages
</programlisting>

    <para>One decision worth noting is the generation of
    <filename>Release</filename> files for each archive. This can help
    manage package installation priorities using the
    <filename>/etc/apt/preferences</filename> configuration file (see
    <xref linkend="sect.apt.priorities" /> for details).</para>

    <sidebar>
      <title><emphasis>SECURITY</emphasis> <command>mini-dinstall</command> and permissions</title>

      <para>Since <command>mini-dinstall</command> has been designed to run
      as a regular user, there's no need to run it as root. The easiest way
      is to configure everything within the user account belonging to the
      administrator in charge of creating the Debian packages. Since only
      this administrator has the required permissions to put files in the
      <filename>incoming/</filename> directory, we can deduce that the
      administrator authenticated the origin of each package prior to
      deployment and <command>mini-dinstall</command> does not need to do
      it again. This explains the <literal>verify_sigs = 0</literal>
      parameter (which means that signatures need not be verified).
      However, if the contents of packages are sensitive, we can reverse
      the setting and elect to authenticate with a keyring containing the
      public keys of persons allowed to create packages (configured with
      the <literal>extra_keyrings</literal> parameter);
      <command>mini-dinstall</command> will then check the origin of each
      incoming package by analyzing the signature integrated to the
      <filename>*.changes</filename> file.</para>
    </sidebar>

    <para>Invoking <command>mini-dinstall</command> actually starts a
    daemon in the background. As long as this daemon runs, it will check
    for new packages in the <filename>incoming/</filename> directory every
    half-hour; when a new package arrives, it will be moved to the archive
    and the appropriate <filename>Packages.gz</filename> and
    <filename>Sources.gz</filename> files will be regenerated. If running a
    daemon is a problem, <command>mini-dinstall</command> can also be
    manually invoked in batch mode (with the <literal>-b</literal> option)
    every time a package is uploaded into the
    <filename>incoming/</filename> directory. Other possibilities provided
    by <command>mini-dinstall</command> are documented in its
    <citerefentry><refentrytitle>mini-dinstall</refentrytitle>
    <manvolnum>1</manvolnum></citerefentry> manual page.</para>

    <sidebar>
      <title><emphasis>EXTRA</emphasis> Generating a signed archive</title>

      <para>The APT suite checks a chain of cryptographic signatures on the
      packages it handles before installing them, in order to ensure
      their authenticity (see <xref linkend="sect.package-authentication" />). Private APT archives can
      then be a problem, since the machines using them will keep displaying
      warnings about unsigned packages. A diligent administrator will
      therefore integrate private archives with the secure APT
      mechanism.</para>

      <para>To help with this process, <command>mini-dinstall</command>
      includes a <literal>release_signscript</literal> configuration option
      that allows specifying a script to use for generating the signature.
      A good starting point is the <filename>sign-release.sh</filename>
      script provided by the <emphasis role="pkg">mini-dinstall</emphasis>
      package in
      <filename>/usr/share/doc/mini-dinstall/examples/</filename>; local
      changes may be relevant.</para>
    </sidebar>
  </section>
  <section id="sect.becoming-package-maintainer">
    <title>Becoming a Package Maintainer</title>
    <section>
      <title>Learning to Make Packages</title>

      <para>Creating a quality Debian package is not always a simple task,
      and becoming a package maintainer takes some learning, both with
      theory and practice. It's not a simple matter of building and
      installing software; rather, the bulk of the complexity comes from
      understanding the problems and conflicts, and more generally the
      interactions, with the myriad of other packages available.</para>
      <section>
        <title>Regler</title>

	<para>A Debian package must comply with the precise rules compiled
	in the Debian policy, and each package maintainer must know them.
	There is no requirement to know them by heart, but rather to know
	they exist and to refer to them whenever a choice presents a
	non-trivial alternative. Every Debian maintainer has made mistakes
	by not knowing about a rule, but this is not a huge problem as long 
	as the error gets fixed when a user reports it as a bug report (which
        tends to happen fairly soon thanks to advanced users).
        <ulink type="block" url="https://www.debian.org/doc/debian-policy/" /></para>
      </section>
      <section>
        <title>Procedures</title>
        <indexterm><primary>Debian Developer's Reference</primary></indexterm>

	<para>Debian is not a simple collection of individual packages.
	Everyone's packaging work is part of a collective project; being a
	Debian developer involves knowing how the Debian project operates
	as a whole. Every developer will, sooner or later, interact with
	others. The Debian Developer's Reference (in the <emphasis role="pkg">developers-reference</emphasis> package) summarizes what
	every developer must know in order to interact as smoothly as
	possible with the various teams within the project, and to take the
	best possible advantages of the available resources. This document
	also enumerates a number of duties a developer is expected to
	fulfill. <ulink type="block" url="https://www.debian.org/doc/manuals/developers-reference/" /></para>
      </section>
      <section>
        <title>Tools</title>

	<para>Many tools help package maintainers in their work. This
	section describes them quickly, but does not give the full details,
	since they all have comprehensive documentation of their
	own.</para>
        <section>
          <title>The <command>lintian</command> Program</title>
          <indexterm><primary><command>lintian</command></primary></indexterm>

	  <para>This tool is one of the most important: it's the Debian
	  package checker. It is based on a large array of tests created
	  from the Debian policy, and detects quickly and automatically
	  many errors that can then be fixed before packages are
	  released.</para>

	  <para>This tool is only a helper, and it sometimes gets it wrong
	  (for instance, since the Debian policy changes over time,
	  <command>lintian</command> is sometimes outdated). It is also not
	  exhaustive: not getting any Lintian error should not be
	  interpreted as a proof that the package is perfect; at most, it
	  avoids the most common errors.</para>
        </section>
        <section>
          <title>The <command>piuparts</command> Program</title>
          <indexterm><primary><command>piuparts</command></primary></indexterm>

	  <para>This is another important tool: it automates the
	  installation, upgrade, removal and purge of a package (in an
	  isolated environment), and checks that none of these
	  operations leads to an error.  It can help in detecting
	  missing dependencies, and it also detects when files are
	  incorrectly left over after the package got purged.</para>
        </section>
        <section>
          <title>devscripts</title>
          <indexterm><primary><emphasis role="pkg">devscripts</emphasis></primary></indexterm>
          <indexterm><primary><command>debuild</command></primary></indexterm>
          <indexterm><primary><command>dch</command></primary></indexterm>
          <indexterm><primary><command>uscan</command></primary></indexterm>
          <indexterm><primary><command>debi</command></primary></indexterm>
          <indexterm><primary><command>debc</command></primary></indexterm>

	  <para>The <emphasis role="pkg">devscripts</emphasis> package
	  contains many programs helping with a wide array of a Debian
	  developer's job:</para>
          <itemizedlist>
            <listitem>
	      <para><command>debuild</command> allows generating a package
	      (with <command>dpkg-buildpackage</command>) and running
	      <command>lintian</command> to check its compliance with the
	      Debian policy afterwards.</para>
            </listitem>
            <listitem>
	      <para><command>debclean</command> cleans a source package
	      after a binary package has been generated.</para>
            </listitem>
            <listitem>
	      <para><command>dch</command> allows quick and easy editing of
	      a <filename>debian/changelog</filename> file in a source
	      package.</para>
            </listitem>
            <listitem>
	      <para><command>uscan</command> checks whether a new version
	      of a software has been released by the upstream author; this
	      requires a <filename>debian/watch</filename> file with a
	      description of the location of such releases.</para>
            </listitem>
            <listitem>
	      <para><command>debi</command> allows installing (with
	      <command>dpkg -i</command>) the Debian package that was just
	      generated without the need to type its full name and path.</para>
            </listitem>
            <listitem>
	      <para>In a similar fashion, <command>debc</command> allows
	      scanning the contents of the recently-generated package (with
	      <command>dpkg -c</command>), without needing to type its full
	      name and path.</para>
            </listitem>
            <listitem>
	      <para><command>bts</command> controls the bug tracking system
	      from the command line; this program automatically generates
	      the appropriate emails.</para>
            </listitem>
            <listitem>
	      <para><command>debrelease</command> uploads a
	      recently-generated package to a remote server, without
	      needing to type the full name and path of the related
	      <filename>.changes</filename> file.</para>
            </listitem>
            <listitem>
	      <para><command>debsign</command> signs the
	      <filename>*.dsc</filename> and <filename>*.changes</filename>
	      files.</para>
            </listitem>
            <listitem>
	      <para><command>uupdate</command> automates the creation of a
	      new revision of a package when a new upstream version has
	      been released.</para>
            </listitem>
          </itemizedlist>
        </section>
        <section>
          <title><emphasis role="pkg">debhelper</emphasis> and <emphasis role="pkg">dh-make</emphasis></title>
          <indexterm><primary><emphasis>debhelper</emphasis></primary></indexterm>
          <indexterm><primary><emphasis>dh-make</emphasis></primary></indexterm>

	  <para>Debhelper is a set of scripts easing the creation of
	  policy-compliant packages; these scripts are invoked from
	  <filename>debian/rules</filename>. Debhelper has been widely
	  adopted within Debian, as evidenced by the fact that it is used
	  by the majority of official Debian packages. All the commands it
          contains have a <command>dh_</command> prefix.</para>

	  <para>The <command>dh_make</command> script (in the
	  <emphasis>dh-make</emphasis> package) creates files required for
	  generating a Debian package in a directory initially containing
	  the sources for a piece of software. As can be guessed from the
	  name of the program, the generated files use debhelper by
	  default.</para>
        </section>
        <section>
          <title><command>dupload</command> and <command>dput</command></title>
          <indexterm><primary><command>dupload</command></primary></indexterm>
          <indexterm><primary><command>dput</command></primary></indexterm>

	  <para>The <command>dupload</command> and <command>dput</command>
	  commands allow uploading a Debian package to a (possibly remote)
	  server. This allows developers to publish their package on the
	  main Debian server (<literal>ftp-master.debian.org</literal>) so
	  that it can be integrated to the archive and distributed by
	  mirrors. These commands take a <filename>*.changes</filename>
	  file as a parameter, and deduce the other relevant files from its
	  contents.</para>
        </section>
      </section>
    </section>
    <section>
      <title>Acceptance Process</title>

      <para>Becoming a “Debian developer” is not a simple administrative
      matter. The process comprises several steps, and is as much an
      initiation as it is a selection process. In any case, it is
      formalized and well-documented, so anyone can track their progression
      on the website dedicated to the new member process.
      <ulink type="block" url="https://nm.debian.org/" /></para>

      <sidebar>
        <title><emphasis>EXTRA</emphasis> Lightweight process for “Debian Maintainers”</title>

        <para>“Debian Maintainer” is another status that gives less
          privileges than “Debian developer” but whose associated process
          is quicker. With this status, the contributors can maintain
          their own packages only. A Debian developer only needs to perform
          a check on an initial upload, and issue a statement to the
          effect that they trust the prospective maintainer with the
          ability to maintain the package on their own.
        </para>
        <indexterm><primary>Debian Maintainer</primary></indexterm>
      </sidebar>
      <section>
        <title>Prerequisites</title>

	<para>All candidates are expected to have at least a working
	knowledge of the English language. This is required at all levels:
	for the initial communications with the examiner, of course, but
	also later, since English is the preferred language for most of the
	documentation; also, package users will be communicating in English
	when reporting bugs, and they will expect replies in
	English.</para>

	<para>The other prerequisite deals with motivation. Becoming a
	Debian developer is a process that only makes sense if the
	candidate knows that their interest in Debian will last for many
	months. The acceptance process itself may last for several months,
	and Debian needs developers for the long haul; each package needs
	permanent maintenance, and not just an initial upload.</para>
      </section>
      <section>
        <title>Registration</title>

	<para>The first (real) step consists in finding a sponsor or
	advocate; this means an official developer willing to state that
	they believe that accepting <emphasis>X</emphasis> would be a good
	thing for Debian. This usually implies that the candidate has
	already been active within the community, and that their work has
	been appreciated. If the candidate is shy and their work is not
	publicly touted, they can try to convince a Debian developer to
	advocate them by showing their work in a private way.</para>

        <indexterm><primary>nøkkelpar</primary></indexterm>
	<para>At the same time, the candidate must generate a
	public/private RSA key pair with GnuPG, which should be signed
	by at least two official Debian developers. The signature
	authenticates the name on the key. Effectively, during a key
	signing party, each participant must show an official
	identification (usually an ID card or passport) together with
	their key identifiers. This step confirms the link between the
	human and the keys. This signature thus requires
	meeting in real life.  If you have not yet met any Debian
	developers in a public free software conference, you can
	explicitly seek developers living nearby using the list on the
	following webpage as a starting point.  <ulink type="block" url="https://wiki.debian.org/Keysigning" /></para>

	<para>Once the registration on <literal>nm.debian.org</literal> has
	been validated by the advocate, an <emphasis>Application
	Manager</emphasis> is assigned to the candidate. The application
	manager will then drive the process through multiple pre-defined
	steps and checks.</para>

	<para>The first verification is an identity check. If you already
	have a key signed by two Debian developers, this step is easy;
	otherwise, the application manager will try and guide you in your
	search for Debian developers close by to organize a meet-up and a
	key signing.</para>
      </section>
      <section>
        <title>Accepting the Principles</title>

	<para>These administrative formalities are followed by
	philosophical considerations. The point is to make sure that the
	candidate understands and accepts the social contract and the
	principles behind Free Software. Joining Debian is only possible if
	one shares the values that unite the current developers, as
	expressed in the founding texts (and summarized in <xref linkend="the-debian-project" />).</para>

	<para>In addition, each candidate wishing to join the Debian ranks is
	expected to know the workings of the project, and how to interact
	appropriately to solve the problems they will doubtless encounter
	as time passes. All of this information is generally documented in
	manuals targeting the new maintainers, and in the Debian
	developer's reference. An attentive reading of this document should
	be enough to answer the examiner's questions. If the answers are
	not satisfactory, the candidate will be informed. They will then have
	to read (again) the relevant documentation before trying again. In
	the cases where the existing documentation does not contain the
	appropriate answer for the question, the candidate can usually
	reach an answer with some practical experience within Debian, or
	potentially by discussing with other Debian developers. This
	mechanism ensures that candidates get involved somewhat in Debian
	before becoming a full part of it. It is a deliberate policy, by
	which candidates who eventually join the project are integrated as
	another piece of an infinitely extensible jigsaw puzzle.</para>

        <indexterm><primary><emphasis>Philosophy &amp; Procedures</emphasis></primary></indexterm>
	<para>This step is usually known as the <emphasis>Philosophy &amp;
	Procedures</emphasis> (P&amp;P for short) in the lingo of the
	developers involved in the new member process.
	</para>
      </section>
      <section>
        <title>Checking Skills</title>

	<para>Each application to become an official Debian developer must
	be justified. Becoming a project member requires showing that this
	status is legitimate, and that it facilitates the candidate's job
	in helping Debian. The most common justification is that being
	granted Debian developer status eases maintenance of a Debian
	package, but it is not the only one. Some developers join the
	project to contribute to porting to a specific architecture, others
	want to improve documentation, and so on.</para>

	<para>This step represents the opportunity for the candidate to
	state what they intend to do within the Debian project and to show
	what they have already done towards that end. Debian is a pragmatic
	project and saying something is not enough, if the actions do not
	match what is announced. Generally, when the intended role within
	the project is related to package maintenance, a first version of
	the prospective package will have to be validated technically and
	uploaded to the Debian servers by a sponsor among the existing
	Debian developers.</para>

        <sidebar>
          <title><emphasis>COMMUNITY</emphasis> Sponsoring</title>
          <indexterm><primary>sponsoring</primary></indexterm>

	  <para>Debian developers can “sponsor” packages prepared by
	  someone else, meaning that they publish them in the official
	  Debian repositories after having performed a careful review. This
	  mechanism enables external persons, who have not yet gone
	  through the new member process, to contribute occasionally to
	  the project. At the same time, it ensures that all packages
	  included in Debian have always been checked by an official
	  member.</para>
        </sidebar>

	<para>Finally, the examiner checks the candidate's technical
	(packaging) skills with a detailed questionnaire. Bad answers are
	not permitted, but the answer time is not limited. All the
	documentation is available and several tries are allowed if the
	first answers are not satisfactory. This step does not intend to
	discriminate, but to ensure at least a modicum of knowledge common
	to new contributors.</para>

        <indexterm><primary><emphasis>Tasks &amp; Skills</emphasis></primary></indexterm>
	<para>This step is known as the <emphasis>Tasks &amp;
	Skills</emphasis> step (T&amp;S for short) in the examiners'
	jargon.</para>
      </section>
      <section>
        <title>Final Approval</title>

	<para>At the very last step, the whole process is reviewed by a DAM
	(<emphasis>Debian Account Manager</emphasis>). The DAM will review
	all the information about the candidate that the examiner
	collected, and makes the decision on whether or not to create an
	account on the Debian servers. In cases where extra information is
	required, the account creation may be delayed. Refusals are rather
	rare if the examiner does a good job of following the process, but
	they sometimes happen. They are never permanent, and the candidate
	is free to try again at a later time.</para>

	<para>The DAM's decision is authoritative and (almost) without
        appeal, which explains why the people in that seat have often been
        criticized in the past.</para>
      </section>
    </section>
  </section>
</chapter>
