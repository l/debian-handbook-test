<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="basic-configuration">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-basic-configuration.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Konfigurasjon</keyword>
      <keyword>Lokalisering</keyword>
      <keyword>Localer</keyword>
      <keyword>Nettverk</keyword>
      <keyword>Navneoppslag</keyword>
      <keyword>Brukere</keyword>
      <keyword>Grupper</keyword>
      <keyword>Kontoer</keyword>
      <keyword>Kommandolinjetolker</keyword>
      <keyword>Skall</keyword>
      <keyword>Utskrift</keyword>
      <keyword>Oppstartslaster</keyword>
      <keyword>Kjernekompilering</keyword>
    </keywordset>
  </chapterinfo>
  <title>Grunnleggende oppsett: Nettverk, kontoer, utskrift...</title>
  <highlights>
    <para>En datamaskin med en ny installasjon laget med <command>debian-installer</command> er ment å være så funksjonelt som mulig, men mange tjenester må fortsatt konfigureres. Videre er det alltid godt å vite hvordan du kan endre visse konfigurasjonselementer etter den første installasjonen.</para>
  </highlights>

  <para>Dette kapitlet gjennomgår alt medregnet i det vi kan kalle den "grunnleggende konfigurasjonen": Nettverk, språk og steder, brukere og grupper, utskrift, monteringspunkter, etc.</para>

  <section id="sect.config-language-support">
    <title>Å konfigurere systemet for et annet språk</title>
    <indexterm><primary>Fransk oversettelse</primary></indexterm>

    <para>Hvis systemet ble installert på fransk, vil maskinen sannsynligvis allerede ha fransk satt som standardspråk. Men det er godt å vite hva den som installerer gjør for å angi språk, slik at senere, hvis behovet oppstår, du kan endre det.</para>

    <sidebar>
      <title><emphasis>TOOL</emphasis>  <command>locale</command>-kommandoen for å vise den gjeldende konfigurasjonen</title>

      <para><command>locale</command>-kommandoen lister et sammendrag av den gjeldende konfigurasjonen med ulike lokale parametere (datoformat, tallformat, etc.), presentert i form av en gruppe med standard miljøvariable dedikert til den dynamisk endringen av disse innstillingene.</para>
    </sidebar>

    <section id="sect.default-language">
      <title>Sette standardspråket</title>
      <indexterm><primary>locales</primary></indexterm>
      <indexterm><primary>språk</primary></indexterm>
      <indexterm><primary><command>locale-gen</command></primary></indexterm>

      <para>En lokalisering er en gruppe av regionale innstillinger. Den omfatter ikke bare språket for teksten, men også hvordan tall, datoer, klokkeslett og pengesummer, samt alfabetiske sammenligningsregler (for å ta høyde for høyde for aksenttegn). Selv om hver av disse parameterne kan velges uavhengig av de andre, vi vanligvis bruker en lokalisering, som er et sammenhengende sett av verdier for disse parametrene tilsvarende en "region" i videste forstand. Disse steder er vanligvis angitt i form, <literal><replaceable>language-code</replaceable>_<replaceable>COUNTRY-CODE</replaceable></literal>, noen ganger med et suffiks for å angi tegnsett og koding som skal brukes. Dette muliggjør å ta hensyn til  idiomatiske eller typografiske forskjeller mellom ulike regioner med et felles språk.</para>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> Tegnsett</title>
        <indexterm><primary>tegnsett</primary></indexterm>
        <indexterm><primary>encoding</primary></indexterm>
        <indexterm><primary>ISO-8859-1</primary></indexterm>
        <indexterm><primary>ISO-8859-15</primary></indexterm>
        <indexterm><primary>Latin 1</primary></indexterm>
        <indexterm><primary>Latin 9</primary></indexterm>

	<para>Historisk har hvert lokaltilpasning har et tilhørende "tegnsett " (gruppe av kjente tegn) og en foretrukket "encoding" (en intern representasjon for tegn i datamaskinen).</para>

	<para>De mest populære kodinger for Latin-baserte språk ble begrenset til 256 tegn, fordi de valgte å bruke en enkelt byte for hvert tegn. Siden 256 tegn var ikke nok til å dekke alle europeiske språk, ble flere kodinger nødvendig, og det er slik vi endte opp med fra <emphasis>ISO-8859-1</emphasis> (også kjent som “Latin 1”) til <emphasis>ISO-8859-15</emphasis> (også kjent som “Latin 9”), blant flere.</para>

	<para>Å arbeide med fremmedspråk ofte medfører faste skifter mellom ulike kodinger og tegnsett . Videre å skrive flerspråklige dokumenter fører til ytterligere, nesten uløselige problemer. Unicode (en super-katalog av nesten alle skriftsystemer fra alle verdens språk) ble opprettet for å omgå dette problemet. En av Unicodes kodinger, UTF-8, beholder alle 128 ASCII symboler (7-bits koder), men håndterer andre tegn på en annen måte. De innledes med en spesifikk sekvens på noen bit, som implisitt definerer lengden på tegnet. Dette gjør det mulig å kode alle Unicode tegn på en sekvens med en eller flere byte. Bruken har blitt populært på grunn av det faktum at det er den standardkoding i XML-dokumenter.</para>
        <indexterm><primary>ASCII</primary></indexterm>
        <indexterm><primary>UTF-8</primary></indexterm>
        <indexterm><primary>Unicode</primary></indexterm>

	<para>Dette er kodingen som i alminnelighet bør 
brukes, og er dermed standarden på Debian-systemer.</para>
      </sidebar>

      <para>The <emphasis role="pkg">locales</emphasis>-pakken inneholder alle elementene som kreves for at "lokaltilpasning" av ulike applikasjoner skal fungere riktig. Under installasjonen vil denne pakken be om valg av et sett med språk som støttes. Dette settet kan endres når som helst ved å kjøre <command>dpkg-reconfigure locales</command> som rot.</para>

      <para>Det første spørsmålet ber deg til å velge "lokaliseringer" som skal støttes. Å velge alle engelske lokaliseringer (som betyr de som begynner med “<literal>en_</literal>”) er et fornuftig valg. Ikke nøl med å også aktivere andre lokaliseringer hvis maskinen vil være vert for brukere fra andre land. Listen over lokaltilpasninger i systemet er lagret i <filename>/etc/locale.gen</filename>-filen. Det er mulig å redigere denne filen for hånd, men du bør kjøre <command>locale-gen</command> etter eventuelle endringer. Den vil generere de nødvendige filene til de ekstra lokaltilpasningene, og eventuelt fjerne utdaterte filer.</para>

      <para>Det andre spørsmålet, med tittelen "Default locale for systemmiljøet", ber om en standard lokaltilpasning. Den anbefalte valet for USA er “<literal>en_US.UTF-8</literal>”. Britisk-engelsk-spårålige fil foretrekke “<literal>en_GB.UTF-8</literal>”, pog Canadiere vil foretrekke enten “<literal>en_CA.UTF-8</literal>” eller, for fransk, “<literal>fr_CA.UTF-8</literal>”. <filename>/etc/default/locale</filename>-filen vil da bli endret for å lagre dette valget. Derfra blir det plukket opp av alle brukersesjoner, siden PAM vil sette inn innholdet i miljøvariabelen <varname>LANG</varname>.</para>
      <indexterm><primary>environment</primary></indexterm>
      <indexterm><primary>locale</primary></indexterm>
      <indexterm><primary><varname>LANG</varname></primary></indexterm>

      <sidebar id="sidebar.intro-pam">
        <title><emphasis>BEHIND THE SCENES</emphasis> <filename>/etc/environment</filename> og <filename>/etc/default/locale</filename></title>

	<para><filename>/etc/environment</filename>-filen gir  <command>login</command>, <command>gdm</command>, eller til og med <command>ssh</command>-programmer slik at de riktige miljøvariablene kan lages.</para>

	<para>Disse programmene lager ikke disse variablene direkte, men gjerne via en PAM (<filename>pam_env.so</filename>)-modul. PAM (Pluggable Authentication Module) er et modulbasert bibliotek som sentraliserer autentiseringsmekanismer, starter  sesjoner, og håndterer passord. Se <xref linkend="sect.config-pam" /> for et eksempel på PAM-konfigurasjon.</para>

	<para><filename>/etc/default/locale</filename>-filen arbeider på samme måte, men inneholder bare <varname>LANG</varname> miljøvariabelen. Takket være denne forskjellen, kan noen PAM-brukere arve et komplett miljø uten lokalisering. Det er imidlertid frarådet å kjøre tjenerprogrammer med lokalisering aktivert. På den annen side er lokalisering og regionale innstillinger anbefalt for programmer som åpner brukersesjoner.</para>
        <indexterm><primary>PAM</primary></indexterm>
        <indexterm><primary><filename>pam_env.so</filename></primary></indexterm>
      </sidebar>
    </section>

    <section id="sect.keyboard-config">
      <title>Å sette opp tastaturet</title>
      <indexterm><primary>tastaturutlegg</primary></indexterm>
      <indexterm><primary>utlegg, tastatur</primary></indexterm>

      <para>Selv om tastaturoppsett forvaltes ulikt i konsollen og i grafisk modus, tilbyr Debian ett konfigurasjonsgrensesnitt som fungerer for begge: Det bygger på debconf og er implementert i <emphasis role="pkg">keyboard-configuration</emphasis>-pakken. Dermed kan  <command>dpkg-reconfigure keyboard-configuration</command>-kommandoen bli brukt når som helst til å resette tastaturoppsettet.</para>

      <indexterm><primary><emphasis>console-data</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>console-tools</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>keyboard-configuration</emphasis></primary></indexterm>

      <para><indexterm><primary><literal>azerty</literal></primary></indexterm> Spørsmålene gjelder det fysiske tastaturoppsettet (et standard PC-tastatur i USA vil være en "Generic 104 key"), deretter oppsettet for å velge (vanligvis "US"), og deretter posisjonen til altgr (høyre Alt). Til slutt kommer spørsmålet om nøkkelen som skal brukes for «Compose key", som åpner for å legge inn spesialtegn ved å kombinere tastetrykk. Skriv i rekkefølge <keycombo action="seq"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> og produce an e-acute (“é”). Alle disse kombinasjonene er beskrevet i <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename>-filen (eller en annen fil, målt i henhold til gjeldende lokaltilpasning, angitt med <filename>/usr/share/X11/locale/compose.dir</filename>).</para>
      <indexterm><primary><literal>Compose</literal>, key</primary></indexterm>
      <indexterm><primary><literal>Meta</literal>, key</primary></indexterm>
      <indexterm><primary>key</primary><secondary><literal>Meta</literal></secondary></indexterm>
      <indexterm><primary>key</primary><secondary><literal>Compose</literal></secondary></indexterm>

      <para>Legg merke til at tastaturkonfigurasjonen for grafisk modus, beskrevet her, bare påvirker standardoppsettet. GNOME og KDE-miljøene, blant andre, gir et tastaturkontrollpanel i sine preferanser, slik at hver enkelt bruker får mulighet til å ha sin egen konfigurasjon. Noen flere alternativer for hvordan noen spesielle taster skal virke, er også tilgjengelige i disse kontrollpanelene.</para>


    </section>
    <section id="sect.utf8-migration">
      <title>Å migrere til UTF-8</title>

      <para>Generaliseringen av UTF-8-kodingen har vært en etterlengtet løsning på flere problemer med interoperabilitet, ettersom det letter internasjonal utveksling og fjerner de vilkårlige begrensninger på tegn som kan brukes i et dokument. En ulempe er at en måtte gå gjennom en ganske vanskelig overgangsfase. Siden den ikke kan være helt gjennomsiktig (det er, det kan ikke skje samtidig over hele verden), kreves  to konverteringsoperasjoner: en for fileinnholdet, og den andre på filnavnet. Heldigvis er mesteparten av denne migreringen fullført, og vi diskuterer dette hovedsakelig for referansen.</para>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> <foreignphrase>Mojibake</foreignphrase> og tolkningsfeil</title>

	<para>Når en tekst blir sendt (eller lagret) uten koding av informasjon, er det ikke alltid mulig for mottakeren å vite med sikkerhet hvilken konvensjon som skal brukes for å bestemme meningen for et sett byte. Du kan vanligvis få en idé ved å få statistikk på fordelingen av verdiene i teksten, men det gir ikke alltid gi et klart svar. Når kodesystemet som er valgt for lesing skiller seg fra den som brukes for skriving til fil, bytene er feiltolket, får du i beste fall feil for enkelte tegn, eller i verste fall noe som er helt uleselig.</para>

	<para>Dermed, hvis en fransk tekst synes normal med unntak av aksentbokstaver og visse symboler som ser ut til å ha blitt erstattet med sekvenser av tegn som "Ã ©" eller " Â§", er det sannsynligvis en fil kodet som UTF-8 som er tolket som ISO-8859-1 eller ISO-8859-15. Dette er et uttrykk for at en lokal installasjon ennå ikke er overført til UTF-8. Hvis du i stedet ser spørsmålstegn i stedet for bokstaver med aksenter - selv om disse spørsmålstegnene også ser ut til å erstatte en karakter som burde ha fulgt bokstaven med aksent - er det sannsynlig at installasjonen er ferdig konfigurert for UTF-8, og at du har blitt sendt et dokument som er kodet i Vest-ISO.</para>

	<para>Så mye om "enkle" saker. Disse tilfellene kun vises i vestlig kultur, siden Unicode (og UTF-8) er designet for å maksimere felles punkter med historiske kodinger for vestlige språk basert på det latinske alfabetet, som anerkjenner deler av teksten selv når noen tegn mangler.</para>

	<para>I mer komplekse konfigurasjoner, som for eksempel involverer to miljøer som tilsvarer to forskjellige språk som ikke bruker det samme alfabetet, får du ofte helt uleselige resultater - en serie abstrakte symboler som ikke har noe å gjøre med hverandre. Dette er spesielt vanlig med asiatiske språk på grunn av sine mange språk og skriftsystemer. Det japanske ordet<foreignphrase>mojibake</foreignphrase> er tatt i bruk for å beskrive dette fenomenet. Når det vises er diagnosen mer kompleks og den enkleste løsningen er ofte bare å gå over til UTF-8 på begge sider.</para>
      </sidebar>

      <para>Når det gjelder filnavn, kan migrasjonen være relativt enkelt. <command>convmv</command>-verktøyet (i pakken med samme navn) ble opprettet spesielt for dette formålet. Det tillater døpe om filer fra en koding til en annen. Bruken av  verktøyet er relativt enkelt, men vi anbefaler å gjøre det i to trinn for å unngå overraskelser. Følgende eksempel illustrerer et UTF-8-miljø med katalognavn kodet i ISO-8859-15, og bruken av <command>convmv</command> for å gi nye navn.</para>

      <screen><computeroutput>$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Ic?nes  ?l?ments graphiques  Textes
$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>Starting a dry run without changes...
mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
No changes to your files done. Use --notest to finally rename the files.
$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
Ready!
$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput>
</screen>

      <para>For filinnholdet, er  konverteringsprosedyrer mer kompliserte på grunn av det enorme utvalg av eksisterende filformater. Noen filformater inkluderer kodeinformasjon som forenkler oppgavene for programvaren som brukes til å behandle dem. Da er det tilstrekkelig for å åpne disse filene og lagre den igjen å spesifisere UTF-8-koding. I andre tilfelle må du spesifisere original kodingen (ISO-8859-1 eller "Western", eller ISO-8859-15 eller "Western (Euro)", i henhold til formuleringene) når du åpner filen.</para>

      <para>For enkle tekstfiler kan du bruke <command>recode</command> (i pakken med samme navn) som registrerer automatisk. Dette verktøyet har mange alternativer, slik at du kan leke med hvordan det virker. Vi anbefaler at du ser i dokumentasjonen, den manuelle siden  <citerefentry> <refentrytitle>recode</refentrytitle> <manvolnum>1</manvolnum> </citerefentry> eller  inforsiden <citerefentry> <refentrytitle>recode</refentrytitle> </citerefentry>.</para>
    </section>
  </section>
  <section id="sect.network-config">
    <title>Å konfigurere nettverket</title>

    <sidebar id="sidebar.networking-basics">
      <title><emphasis>BACK TO BASICS</emphasis> Viktige nettverkskonsepter (Ethernet, IP address, subnet, broadcast)</title>
      <indexterm><primary>Ethernet</primary></indexterm>
      <indexterm><primary>10BASE-T</primary></indexterm>
      <indexterm><primary>100BASE-T</primary></indexterm>
      <indexterm><primary>1000BASE-T</primary></indexterm>
      <indexterm><primary>10GBASE-T</primary></indexterm>
      <indexterm><primary>connector, RJ45</primary></indexterm>
      <indexterm><primary>RJ45 connector</primary></indexterm>

      <para>De fleste moderne lokale nettverk bruker Ethernet-protokollen, der data deles inn i små blokker kalt rammer og sendes på ledningen ett bilde om gangen. Datahastigheten varierer fra 10 Mb/s for eldre Ethernet-kort til 10 Gb/s i de nyeste kortene (med de mest vanlige hastigheten for tiden vokser fra 100 Mb/s til 1 Gb/s). De mest brukte kabler kalles 10BASE-T, 100BASE-T, 1000BASE-T eller 10GBASE-T avhengig av gjennomstrømming de med sikkert kan gi (T står for "twisted pair"). Disse kablene ende i en RJ45-kontakt. Det finnes andre kabeltyper, som mest brukes for hastigheter på 1 Gb/s og oppover.</para>

      <indexterm><primary>address, IP address</primary></indexterm>
      <indexterm><primary>IP address</primary></indexterm>

      <para>En IP-adresse er et nummer som brukes til å identifisere et nettverksgrensesnitt på en datamaskin på et lokalt nettverk, eller på Internett. I den nå mest utbredte versjonen av IP (IPv4), er dette tallet kodet i 32 bits, og er vanligvis representert som 4 tall atskilt med punktum (f.eks<literal>192.168.0.1</literal>), hvert tall er mellom 0 og 255 (inkludert, som tilsvarer 8 bit data). Den neste versjonen av protokollen, utvider dette adresseringsrommet til 128 bits, og adressene generelt er representert som en serie av heksadesimale tall atskilt med kolon (for eksempel 2001:0db8:13bb:0002:0000:0000:0000:0020, eller 2001:db8:13bb:2::20 i korthet).</para>

      <indexterm><primary>subnet</primary></indexterm>
      <indexterm><primary>mask</primary><secondary>subnet mask</secondary></indexterm>
      <indexterm><primary>network</primary><secondary>address</secondary></indexterm>

      <para>I sin binærkode definerer en nettverksmaske (nettmaske) hvilken del av en IP-adresse som samsvarer med nettverket, resten spesifiserer maskinen. I eksemplet med å konfigurere en statisk IPv4-adresse gitt her, nettverksmaske <literal>255.255.255.0</literal> (binært med 24 “1”-ere fulgt av 8 “0”-er) indikerer at de første 24 bit av IP-adressen tilsvarer nettverksadressen, og den andre 8 er spesifikke for maskinen. I IPv6, for lesbarheten, er bare antallet "1"-ere angitt; nettmasken for et IPv6-nettverk kan dermed være <literal>64</literal>.</para>

      <para>Nettverksadressen er en IP-adresse der den delen som beskriver maskinens nummer er 0. Området for IPv4-adresser i et fullstendig nett er ofte angitt med syntaksen <emphasis>a.b.c.d/e</emphasis>, der <emphasis>a.b.c.d</emphasis> er nettverksadressen og <emphasis>e</emphasis> er det antall bits som berører  nettverksdelen i en IP-adresse. Eksempel-nettverket skal da skrives <literal>192.168.0.0/24</literal>. The syntaksen er tilsvarende i IPv6: <literal>2001:db8:13bb:2::/64</literal>.</para>

      <indexterm><primary>ruter</primary></indexterm>
      <indexterm><primary>bridge</primary></indexterm>

      <para>En ruter er en maskin som forbinder flere nettverk med hverandre. All trafikk som kommer via en ruter blir guidet til riktig nettverk. For å gjøre dette, analyserer ruteren innkommende pakker og viderekobler dem ut fra IP-adressen til bestemmelsesstedet. Ruteren er ofte kjent som en innfallsport; i denne konfigurasjonen fungerer den som en maskin som bidrar til å nå utover et lokalt nettverk (mot et utvidet nettverk, slik som internett).</para>

      <indexterm><primary>broadcast</primary></indexterm>

      <para>Den spesielle kringkastingsadressen forbinder alle stasjonene i et nettverk. Nesten aldri "rutet", funger den bare på nettverket det gjelder. Nærmere bestemt betyr dette at en datapakke adressert til kringkastingen aldri passerer gjennom ruteren.</para>

      <para>Dette kapittelet fokuserer på IPv4-adresser, siden de i dag er de mest brukte. Detaljene i IPv6-protokollen kommer nærmere i <xref linkend="sect.ipv6" />, men begrepene forblir de samme.</para>
    </sidebar>

    <para>Siden nettverket er konfigurert automatisk under den første installasjonen, inneholder  <filename>/etc/network/interfaces</filename>-filen allerede en gyldig konfigurasjon. En linje som starter med  <literal>auto</literal> gir en liste med grensesnitt som automatisk blir konfigurert ved oppstart med <emphasis role="pkg">ifupdown</emphasis> og dens  <filename>/etc/init.d/networking</filename> init skript. Dette vil ofte være <literal>eth0</literal>, som referer til det første  Ethernet-kortet.</para>

    <indexterm><primary>network</primary><secondary>configuration</secondary></indexterm>
    <indexterm><primary>configuration</primary><secondary>of the network</secondary></indexterm>
    <indexterm><primary>interface</primary><secondary>network interface</secondary></indexterm>
    <indexterm><primary><literal>eth0</literal></primary></indexterm>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> Network Manager</title>
      <indexterm><primary><emphasis role="pkg">network-manager</emphasis></primary></indexterm>

      
      <para>Hvis Network Manager spesielt er anbefalt i roaming-oppsettene (se <xref linkend="sect.roaming-network-config" />), er den også helt brukbar som standard styringsverktøy for nettverk. Du kan lage "systemtilkoblinger" som brukes så snart datamaskinen starter enten manuelt med en <filename>.ini</filename>-lik fil i <filename>/etc/NetworkManager/system-connections/</filename>, eller med et grafisk verktøy (<command>nm-connection-editor</command>). Bare husk å deaktivere alle oppføringer i <filename>/etc/network/interfaces</filename> hvis du vil at Network Manager skal håndtere dem <ulink type="block" url="https://wiki.gnome.org/Projects/NetworkManager/SystemSettings/jessie" /> <ulink type="block" url="https://developer.gnome.org/NetworkManager/0.9/ref-settings.html" /></para>
    </sidebar>

    <section id="sect.interface-ethernet">
      <title>Grensesnitt for Ethernettet</title>

      <para>Hvis datamaskinen har et Ethernet-kort, må det IP-nettverk som er forbundet med det, bli konfigurert ved å velge blant en av to metoder. Den enkleste metoden er en dynamisk konfigurasjon med DHCP, og det krever en DHCP-tjener i det lokale nettverket. Det kan indikere et ønsket vertsnavn, tilsvarende <literal>hostname</literal>-innstillingen i eksempelet nedenfor. DHCP-tjeneren sender deretter konfigurasjonsinnstillinger for det aktuelle nettverket.</para>

      <indexterm><primary>Ethernet</primary></indexterm>
      <indexterm><primary>DHCP</primary></indexterm>

      <example id="example.config-dhcp">
        <title>DHCP configuration</title>

        <programlisting>
auto eth0
iface eth0 inet dhcp
  hostname arrakis
</programlisting>
      </example>

      <para>En "statisk" konfigurasjon må angi nettverksinnstillinger på en bestemt måte. Dette inkluderer minst IP-adressen og nettverksmasken, og noen ganger er også kringkastingsadresser oppført. En ruter som kobler til omverdenen blir spesifisert som en port.</para>

      <example id="example.static-network">
        <title>Static configuration</title>

        <programlisting>
auto eth0
iface eth0 inet static
  address 192.168.0.3
  netmask 255.255.255.0
  broadcast 192.168.0.255
  network 192.168.0.0
  gateway 192.168.0.1
</programlisting>
      </example>

      <sidebar>
        <title><emphasis>NOTE</emphasis> Multiple addresses</title>

	<para>Det er ikke bare muligå knytte flere grensesnitt til et enkelt, fysisk nettverkskort, men også flere IP-adresser til en enkelt grensesnitt. Merk deg også at en IP-adresse kan tilsvare til hvilket som helst antall navn via DNS, og at et navn også kan tilsvare en hvilken som helst antall numeriske IP-adresser.</para>

	<para>Som du kan gjette, kan konfigurasjoner være nokså komplekse, men disse alternativene er kun brukt i helt spesielle tilfeller. Eksemplene nevnt her er typiske for de vanlige konfigurasjonene.</para>
      </sidebar>
    </section>
    <section id="sect.ppp-rtc">
      <title>Forbinde PPP gjennom et PSTN modem</title>
      <indexterm><primary>PPP</primary></indexterm>
      <indexterm><primary>point to point</primary></indexterm>
      <indexterm><primary>connection</primary><secondary>by PSTN modem</secondary></indexterm>
      <indexterm><primary>modem</primary><secondary>PSTN</secondary></indexterm>

      <para>Et punkt til punkt (PPP) etablerer en periodisk forbindelse. Dette er den mest vanlige løsning for tilkoblinger med et telefonmodem ("PSTN-modem", ettersom forbindelsen går over det offentlige, svitsjede telefonnettet).</para>

      <para>En tilkobling via telefon modem krever en konto med en aksessleverandør, inkludert et telefonnummer, brukernavn, passord, og noen ganger skal det brukes en autentiseringsprotokoll. En slik forbindelse er konfigurert ved hjelp av <command>pppconfig</command>-verktøy i Debian-pakken med samme navn. Som standard setter det opp en forbindelse som heter <literal>provider</literal> (som i Internett-leverandør). Når du er i tvil om autentiseringsprotokollen, velge <emphasis>PAP</emphasis>: Den tilbys av de fleste Internett-leverandører.</para>

      <indexterm><primary><command>pppconfig</command></primary></indexterm>
      <indexterm><primary>PAP</primary></indexterm>

      <para>Etter konfigurasjon, er det mulig å koble til med <command>pon</command>-kommandoen (gi den navnet på tilkoblingen som et parameter, når standardverdien <literal>provider</literal> ikke er hensiktsmessig). Linken blir frakoblet med  <command>poff</command>-kommandoen. Disse to kommandoer kan utføres av rotbrukeren, eller av en annen bruker, forutsatt at de er i <literal>dip</literal>-gruppen.</para>

      <indexterm><primary><command>pon</command></primary></indexterm>
      <indexterm><primary><command>poff</command></primary></indexterm>

    </section>
    <section id="sect.adsl">
      <title>Tilkobling med et ADSL-modem</title>
      <indexterm><primary>connection</primary><secondary>by ADSL modem</secondary></indexterm>
      <indexterm><primary>modem</primary><secondary>ADSL</secondary></indexterm>
      <indexterm><primary>ADSL, modem</primary></indexterm>

      <para>Fellesbetegnelsen "ADSL-modem" dekker en rekke enheter med svært ulike oppgaver. Enklest å bruke med Linux er modemene som har et Ethernet-grensesnitt (og ikke bare et USB-grensesnitt). Disse pleier å være populære. De fleste ADSL Internett-leverandører låner ut (eller leaser) en "boks" med Ethernet grensesnitt. Avhengig av typen modem, varierer den konfigurasjon som kreves mye.</para>
      <section id="sect.adsl-pppoe">
        <title>Modemer som støtter PPPOE</title>
        <indexterm><primary>PPPOE</primary></indexterm>
        <indexterm><primary><command>pppoeconf</command></primary></indexterm>

	<para>Noen Ethernet-modemer arbeider med PPPoE protokollen (Point to Point Protocol over Ethernet).<command>pppoeconf</command>-verktøyet (fra pakken med samme navn) vil konfigurere tilkoblingen. For å gjøre dette, endrer den <filename>/etc/ppp/peers/dsl-provider</filename>-filen med innstillingene gitt og registreret i påloggingsinformasjonen i <filename>/etc/ppp/pap-secrets</filename> og <filename>/etc/ppp/chap-secrets</filename>-filene. Det anbefales å godta alle endringer som det foreslår.</para>

	<para>Så snart denne konfigurasjonen er fullført, kan du åpne ADSL-tilkobling med kommandoen, <command>pon dsl-provider</command> og koble den fra med <command>poff dsl-provider</command>.</para>
        <indexterm><primary><literal>dsl-provider</literal></primary></indexterm>

        <sidebar>
          <title><emphasis>TIP</emphasis> Som starter <command>ppp</command> ved oppstart</title>
          <indexterm><primary><command>systemd</command></primary></indexterm>
          <indexterm><primary><command>init</command></primary></indexterm>

	  <para>PPP-forbindelser over ADSL er, per definisjon, periodiske. Siden de vanligvis ikke faktureres etter tidsbruk, er det få motforestillinger mot å alltid holde dem åpne. Standardmåtene å gjøre det på, er å bruke init-systemet.</para>

          <para>Stanard init-system på <emphasis role="distribution">Jessie</emphasis> er <command>systemd</command>. Å legge til en automatisk omstartsoppgave for ADSL-tilkoblingen er en så enkel sak som å lage en "unit filel", slik som <filename>/etc/systemd/system/adsl-connection.service</filename>, med innhold som det følgende:</para>

<programlisting>[Unit]
Description=ADSL connection

[Service]
Type=forking
ExecStart=/usr/sbin/pppd call dsl-provider
Restart=always

[Install]
WantedBy=multi-user.target</programlisting>

          <para>Så snart denne unit-filen er definert, må den aktiveres med <command>systemctl enable adsl-connection</command>. Så kan sløyfen startes manyelt med <command>systemctl start adsl-connection</command>. Den vil også bli startet automatisk ved oppstart.</para>

          <para>På systemer som ikke bruker <command>systemd</command> (medregnet <emphasis role="distribution">Wheezy</emphasis> og tidligere versjoner av Debian), fungerer standard SystemV init annerledes. I slike systemer, er alt som er nødvendig å legge til en linje som følgende ved slutten av <filename>/etc/inittab</filename>-filen; så, hver gang forbindelsen blir fraboblet vil <command>init</command> åpne den igjen.</para>

          <programlisting>
adsl:2345:respawn:/usr/sbin/pppd call dsl-provider
</programlisting>

	  <para>For ADSL-forbindelser som daglig auto-frakobler, reduserer metoden varigheten av avbruddet.</para>
        </sidebar>
      </section>
      <section id="sect.adsl-pptp">
        <title>Modeer som støtter PPTP</title>
        <indexterm><primary>PPTP</primary></indexterm>

	<para>Protokollen PPTP (Point-to-Point Tunneling Protocol) ble opprettet av Microsoft. I begynnelsen utplassert av ADSL, og ble raskt erstattet av PPPoE. Hvis denne protokollen er tvunget på deg, se <xref linkend="sect.pptp" />.</para>
      </section>
      <section id="sect.adsl-dhcp">
        <title>Modemer som støtter DHCP</title>

	<para>Når et modem er koblet til datamaskinen med en Ethernet-kabel (krysset kabel) du vanligvis konfigurere en nettverkstilkobling med DHCP på datamaskinen. Modemet fungerer automatisk som en systemport som standard, og tar seg av ruting (som betyr at den klarer nettverkstrafikk mellom datamaskinen og Internettet).</para>

        <sidebar>
          <title><emphasis>BACK TO BASICS</emphasis> Krysskabel for en direkte Ethernet-forbindelse</title>
          <indexterm><primary>crossover cable</primary></indexterm>

	  <para>Datamaskinenes nettverkskort forventes å motta data fra bestemte ledninger i kabelen, og sende sine data på andre. Når du kobler en datamaskin til et lokalt nettverk, kobler du vanligvis en kabel (rett eller i kryss) mellom nettverkskortet og en nettverksveksler eller svitsj. Men hvis du vil koble to datamaskiner direkte (uten mellomliggende svitjs eller nettverksbryter), må du rute signalet fra ett kort til mottakersiden av det andre kortet, og vice-versa. Dette er hensikten med en krysset kabel, og grunnen til at den brukes.</para>

          <para>Merk at dette skillet er blitt nesten irrelevant over tid, ettersom moderne nettverkskort er i stand til å oppdage typen kabel og tilpasse seg etter det. Så det vil ikke være uvanlig at begge typer kabel vil virke på et gitt sted.</para>
        </sidebar>

	<para>De fleste "ADSL-rutere" på markedet kan brukes slik, som de fleste av ADSL-modemene som leveres fra Internett-leverandørene.</para>
      </section>
    </section>
    <section id="sect.roaming-network-config">
      <title>Automatisk nettverkoppsett for roaming-brukere</title>
      <indexterm><primary><emphasis role="pkg">network-manager</emphasis></primary></indexterm>
      <indexterm><primary>network</primary><secondary>roaming configuration</secondary></indexterm>

      <para>Mange Falcot ingeniører har en bærbar datamaskin for profesjonell bruk, som de også bruke hjemme. Nettverkskonfigurasjonen avhenger av plasseringen. Hjemme, kan det være en wifi-nettverk (beskyttet av en WPA-nøkkel), mens arbeidsplassen bruker et kablet nettverk for større sikkerhet og mer båndbredde.</para>

      <para>For å unngå å koble manuelt til eller fra det tilhørende nettverksgrensesnittet innstalerte administratorene <emphasis role="pkg">network-manager</emphasis>- pakken på disse flyttbare maskinene. Denne programvaren gjør at brukeren kan enkelt bytte fra ett nettverk til et annet ved hjelp av et lite ikon i systemstatusfeltet på det grafiske skrivebordet. Ved å klikke på dette ikonet vises en liste over tilgjengelige nettverk (både kablet og trådløst), slik at de kan rett og slett velge nettverket de ønsker å bruke. Programmet lagrer konfigurasjonen for nettverkene som brukeren allerede har koblet til, og bytter automatisk til det beste tilgjengelige nettverket når den gjeldende tilkoblingen faller ut.</para>

      <para>For å gjøre dette, er programmet strukturert i to deler: En nisse som kjører som rot håndterer aktivering og konfigurering av nettverksgrensesnitt, og et brukergrensesnitt kontroller denne nissen. PolicyKit håndterer de nødvendige fullmakter til å styre dette programmet og Debian konfigurerte PolicyKit på en slik måte slik at medlemmer i netdev gruppen kan legge til eller endre Network Manager-tilkoblinger.</para>

      <para>Network Manager vet hvordan man skal håndtere ulike typer tilkoblinger (DHCP, manuell konfigurering, lokale nettverk), men bare hvis konfigureringen er stilt inn med programmet selv. Dette er grunnen til at det systematisk vil ignorere alle nettverkgrensesnitt i <filename>/etc/network/interfaces</filename> som det ikke passer for.  Ettersom Network Manager ikke gi detaljer når ingen nettverkstilkoblinger vises, er den enkle måten å slette  alle konfigurasjoner for grensesnitt som må håndteres av Network Manager fra <filename>/etc/network/interfaces</filename>.</para>

      <para>Merk at dette programmet er installert som standard når "Desktop Environment"-oppgaven er valgt ved den første installasjonen.</para>

      <sidebar>
        <title><emphasis>ALTERNATIVE</emphasis> Konfigurering med “network profile”</title>
        <indexterm><primary><emphasis role="pkg">guessnet</emphasis></primary></indexterm>

	<para>Mer avanserte brukere kan ønske å prøve <emphasis role="pkg">guessnet</emphasis>-pakken for automatisk nettverkskonfigurasjon. En gruppe testskript bestemmer hvilken nettverksprofil som skal aktiveres og konfigurerer det fortløpende.</para>

	<para>Brukere som vil velge en nettverksprofil manuelt vil foretrekke <emphasis role="pkg">netenv</emphasis>-programmet, som finnes i pakken med samme navn.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.hostname-name-service">
    <title>Sette vertsnavnet og konfigurere navntjenesten</title>
    <indexterm><primary>name</primary><secondary>attribution and resolution</secondary></indexterm>
    <indexterm><primary>assignment of names</primary></indexterm>

    <para>Formålet med å tildele navn til IP-numre er å gjøre dem lettere for folk å huske. I virkeligheten identifiserer en IP-adresse et nettverksgrensesnitt tilknyttet en enhet, for eksempel et nettverkskort. Siden hver maskin kan ha flere nettverkskort, og flere grensesnitt på hvert kort, kan en enkelt datamaskin ha en rekke navn i domenenavnsystemet.</para>

    <para>Hver maskin er imidlertid identifisert av et hovednavn  (eller "kanonisk") navn, som er lagret i<filename>/etc/hostname</filename>-filen og kommunisert til Linux-kjernen ved initialiseringsskripter med <command>hostname</command>-kommandoen. Den aktuelle verdien er tilgjengelig i et virtuelt filsystem, og du kan få det med <command>cat /proc/sys/kernel/hostname</command>-kommandoen.</para>

    <indexterm><primary><command>hostname</command></primary></indexterm>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> <filename>/proc/</filename> and <filename>/sys/</filename>, virtual filesystems</title>
      <indexterm><primary><filename>/proc/</filename></primary></indexterm>
      <indexterm><primary><filename>proc</filename></primary></indexterm>
      <indexterm><primary><filename>/sys/</filename></primary></indexterm>
      <indexterm><primary><filename>sys</filename></primary></indexterm>

      <para><filename>/proc/</filename> og <filename>/sys/</filename>-trevisninger er generert av "virtuelle" filsystemer. Dette er en praktisk måte å gjenopprette informasjon fra kjernen (ved å liste virtuelle filer) og kommunisere dem til den (ved å skrive til virtuelle filer).</para>

      <para><filename>/sys/</filename> er spesielt utformet for å gi tilgang til interne kjerne|objekter, spesielt de som representerer de forskjellige enhetene i systemet. Kjernen kan dermed dele ulike typer informasjon: Status for hver enhet (for eksempel hvis den er i energisparemodus), enten den er en flyttbar enhet, etc. Merk at <filename>/sys/</filename> bare har eksistert siden kjerneversjon 2.6.</para>
    </sidebar>

    <para>Overraskende nok, domenenavnet håndteres ikke på samme måte, men kommer fra det komplette navnet på maskinen, skaffet gjennom navneoppslag. Du kan endre det i <filename>/etc/hosts</filename>-filen, skriv bare et komplett navn på maskinen i begynnelsen av listen over navn som er knyttet til maskinens adresse, som i følgende eksempel:</para>
    <informalexample>
      <programlisting>
127.0.0.1     localhost
192.168.0.1   arrakis.falcot.com arrakis
</programlisting>
    </informalexample>
    <indexterm><primary><filename>hosts</filename></primary></indexterm>
    <indexterm><primary><filename>/etc/hosts</filename></primary></indexterm>
    <indexterm><primary>domain</primary><secondary>name</secondary></indexterm>
    <indexterm><primary>name</primary><secondary>domain</secondary></indexterm>
    <indexterm><primary>NSS</primary></indexterm>
    <section id="sect.name-resolution">
      <title>Navneoppslag</title>
      <indexterm><primary>resolution</primary><secondary>name</secondary></indexterm>
      <indexterm><primary>name</primary><secondary>resolution</secondary></indexterm>

      <para>Mekanismen for navneoppslag i Linux er modulbasert og kan bruke ulike kilder til informasjon som vises i <filename>/etc/nsswitch.conf</filename>-filen. Oppføringen som gjelder vertsnavnoppslag er <literal>hosts</literal>. Som standard inneholder den <literal>files dns</literal>, som betyr aat systemet konsulterer <filename>/etc/hosts</filename>filen først, deretter DNS-servere. NIS/NIS+ eller LDAP-servere er andre mulige kilder.</para>

      <sidebar>
        <title><emphasis>NOTE</emphasis> NSS and DNS</title>

	<para>Vær oppmerksom på at kommandoene spesielt beregnet til å spørre DNS (spesielt <command>host</command>) ikke bruker den standard navnoppløsningsmekanismen (NSS). Som en konsekvens, har de ikke tar hensyn til <filename>/etc/nsswitch.conf</filename>, and dermed heller ikke <filename>/etc/hosts</filename>.</para>
      </sidebar>
      <section id="sect.dns-server-configuration">
        <title>Å konfigurere DNS-tjenere</title>
        <indexterm><primary>DNS</primary></indexterm>
        <indexterm><primary>Domain Name Service</primary></indexterm>

	<para>DNS (Domain Name Service) er en distribuert og hierarkisk tjeneste som kartlegginger navn til IP-adresser, og vice-versa. Spesielt kan det forandre et menneske-vennlig navn som <literal>www.eyrolles.com</literal> til en en faktisk IP adresse, <literal>213.244.11.247</literal>.</para>

	<para>For å få tilgang til DNS-informasjon, må en DNS-server være tilgjengelig for å videresende forespørsler. Falcot Corp har sin egen, men en enkeltbruker vil sannsynligvis bruke DNS-tjenere levert av deres ISP.</para>

        <indexterm><primary><filename>resolv.conf</filename></primary></indexterm>
        <indexterm><primary><literal>nameserver</literal></primary></indexterm>

	<para>DNS-serverne som skal brukes, er angitt i <filename>/etc/resolv.conf</filename>, en per linje, med <literal>nameserver</literal>nøkkelordet foran en IP-adresse, som i følgende eksempel:</para>

        <programlisting>
nameserver 212.27.32.176
nameserver 212.27.32.177
nameserver 8.8.8.8
</programlisting>

        <para>Noter at <filename>/etc/resolv.conf</filename>-filen kan håndteres automatisk (og overskrives ) når nettverket håndteres av NetworkManager eller konfigureres via DHCP.</para>

      </section>
      <section id="sect.etc-hosts">
        <title>The <filename>/etc/hosts</filename> file</title>
        <indexterm><primary><filename>hosts</filename></primary></indexterm>
        <indexterm><primary><filename>/etc/hosts</filename></primary></indexterm>

	<para>Hvis det ikke er noen navntjener i det lokale nettverket, er det fortsatt mulig å etablere et lite bord som kartlegger IP-adresser og maskinvertsnavn i <filename>/etc/hosts</filename>-filen, vanligvis reservert for lokale nettverkstasjoner. Syntaksen til denne filen er veldig enkel: Hver linje angir en bestemt IP-adresse etterfulgt av listen over eventuelle andre berørte navn (er den første "fullstendig kvalifisert", betyr at den inkluderer domenenavnet).</para>

	<para>Denne filen er tilgjengelig selv under nettverksbrudd eller når DNS-servere er ikke kan nås, men vil egentlig bare være nyttig når den dupliseres på alle maskiner på nettverket. Den minste endring i samsvar vil krever at filen oppdateres overalt. Dette er grunnen til at <filename>/etc/hosts</filename> generelt bare inneholder de aller viktigste inngangene.</para>

	<para>Denne filen vil være tilstrekkelig for et lite nettverk som ikke er koblet til Internett, men med 5 maskiner eller mer, anbefales det å installere en skikkelig DNS server.</para>

        <sidebar>
          <title><emphasis>TIP</emphasis> Å komme forbi DNS</title>

	  <para>Ettersom applikasjoner sjekker <filename>/etc/hosts</filename>-filen før DNS spørres, er det mulig å ha med informasjon her som er forskjellig fra hva DNS vil returnere, og derfor å omgå en normal DNS-basert navneoppløsning.</para>

	  <para>Dette gjør det mulig, i tilfelle DNS-endringer endringene ennå ikke spredt, å teste tilgangen til et nettsted med det tiltenkte navn, selv om dette navnet ikke er skikkelig formidlet til den riktige IP-adressen.</para>

	  <para>En annen mulig bruk er å omdirigere trafikk beregnet for en bestemt vert til lokalverten, og dermed hindre all kommunikasjon med den gitte verten. For eksempel kan vertsnavnet til tjenere som er dedikert til annonsering omkobles, slik at disse annonsene blir omgått, noe som resulterer i en mer flytende og mindre distrahert navigasjon.</para>
        </sidebar>
      </section>
    </section>
  </section>
  <section id="sect.user-group-databases">
    <title>Bruker og gruppers databaser</title>
    <indexterm><primary>user</primary><secondary>database</secondary></indexterm>
    <indexterm><primary>group</primary><secondary>database</secondary></indexterm>
    <indexterm><primary>database</primary><secondary>of users</secondary></indexterm>
    <indexterm><primary>database</primary><secondary>of groups</secondary></indexterm>

    <para>Listen av brukere er vanligvis lagret i  <filename>/etc/passwd</filename>-filen, mens  <filename>/etc/shadow</filename>-filen lagrer krypterte passord. Begge er tekstfiler, i et relativt enkelt format, som kan leses og modifiseres med en tekstredigerer. Der er hver bruker er oppført en linje med flere felt atskilt med et kolon (“<literal>:</literal>”).</para>

    <sidebar>
      <title><emphasis>NOTE</emphasis> Redigere systemfiler</title>

      <para>Systemfilene, som er nevnt i dette kapitlet, er alle rene tekstfiler, og kan redigeres med en tekst redigerer. Tatt i betraktning betydningen deres for kjernesystemets funksjonalitet, er det alltid en god idé å ta ekstra forholdsregler når du redigerer systemfiler. Først, lag alltid en kopi eller backup av en system fil før du åpner eller endrer den. For det andre, på tjenere eller maskiner der mer enn én person som potensielt kan få tilgang til samme fil samtidig, ta ekstra forholdsregler for å beskytte filen mot å bli ødelagt.</para>

      <para>For dette formålet, er det noå å bruke  <command>vipw</command>-kommandoen for å redigere <filename>/etc/passwd</filename>-filen, eller <command>vigr</command> for å redigere <filename>/etc/group</filename>. Disse kommandoene låser den aktuelle filen før du kjører tekstredigereren,(<command>vi</command> som standard, om ikke  <varname>EDITOR</varname> miljøvariabelen har blitt endret). <literal>-s</literal>-valget i disse kommandoene tillater redigering av den overensstemmende <foreignphrase>shadow</foreignphrase>-filen.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Crypt, en enveisfunksjon</title>
      <indexterm><primary>crypt</primary></indexterm>

      <para><command>crypt</command> er en enveisfunksjon som endrer en streng (<varname>A</varname>) til en annen streng (<varname>B</varname>) på en måte som  <varname>A</varname> ikke kan avledes fra <varname>B</varname>. Den eneste måten til å identifisere <varname>A</varname> er å teste alle mulige verdier, og sjekke hver og en for å avgjøre om funksjonsendingen vil produsere <varname>B</varname> eller ikke. Den bruker opp til 8 karakterer som inndata (streng <varname>A</varname>) og genererer en streng på 13, utskriftsbare, ASCII karakterer (streng <varname>B</varname>).</para>
    </sidebar>
    <section id="sect.etc-passwd">
      <title>Brukerliste: <filename>/etc/passwd</filename></title>

      <para>Her er listen med feltene i  <filename>/etc/passwd</filename>-filen:</para>
      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm><primary><filename>/etc/passwd</filename></primary></indexterm>
      <indexterm><primary><literal>uid</literal></primary></indexterm>
      <indexterm><primary><literal>gid</literal></primary></indexterm>
      <indexterm><primary><literal>GECOS</literal></primary></indexterm>
      <indexterm><primary><literal>login</literal></primary></indexterm>
      <itemizedlist>
        <listitem>
	  <para>login, for eksempel <literal>rhertzog</literal>;</para>
        </listitem>
        <listitem>
	  <para>passord: Dette er et passord kryptert med en enveis funksjon (<command>crypt</command>), som støtter seg på <literal>DES</literal>, <literal>MD5</literal>, <literal>SHA-256</literal> eller <literal>SHA-512</literal>. Spesialverdien “<literal>x</literal>” indikerer at de krypterte passordet er lagret i <filename>/etc/shadow</filename>;</para>
        </listitem>
        <listitem>
	  <para><literal>uid</literal>: unikt nummer som identifiserer hver bruker;</para>
        </listitem>
        <listitem>
	  <para><literal>gid</literal>: unikt nummer for brukerens hovedgruppe (Debian lager en bestemt gruppe for hver bruker som standard);</para>
        </listitem>
        <listitem>
	  <para><literal>GECOS</literal>: datafelt som vanligvis inneholder brukerens fulle navn;</para>
        </listitem>
        <listitem>
	  <para>innloggingsmappe, tildelt til brukeren for oppbevaring av sine personlige filer (miljøvariabelen <varname>$HOME</varname> peker generelt hit);</para>
        </listitem>
        <listitem>
	  <para>program som skal kjøres ved pålogging. Dette er vanligvis en kommandofortolker (skall), som gir brukeren frie hender. Hvis du angir <command>/bin/false</command> (som ikke gjør noe og returnerer kontrollen umiddelbart), kan ikke brukeren  logge inn.</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> Unix group</title>
        <indexterm><primary>group</primary></indexterm>

	<para>En Unix-gruppe er en enhet som omfatter flere brukere slik at de enkelt kan dele filer ved hjelp av det integrerte tillatelsesystemets (ved å dra nytte av de samme rettigheter). Man kan også begrense bruken av visse programmer til en bestemt gruppe.</para>
      </sidebar>
    </section>
    <section id="sect.etc-shadow">
      <title>Den skjulte og krypterte passordfilen: <filename>/etc/shadow</filename></title>
      <indexterm><primary><filename>shadow</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/shadow</filename></primary></indexterm>

      <para><filename>/etc/shadow</filename>-filen inneholder de følgende feltene:</para>
      <itemizedlist>
        <listitem>
	  <para>login;</para>
        </listitem>
        <listitem>
	  <para>Krypterte passord;</para>
        </listitem>
        <listitem>
	  <para>flere felt håndterer passordopphør.</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>DOCUMENTATION</emphasis> <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> og <filename>/etc/group</filename>-filformater</title>

	<para>Disse formatene er dokumentert i de følgende manuelle sidene: <citerefentry><refentrytitle>passwd</refentrytitle><manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>shadow</refentrytitle><manvolnum>5</manvolnum></citerefentry>, og <citerefentry><refentrytitle>group</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>SECURITY</emphasis> <filename>/etc/shadow</filename>-filsikkerhet</title>

	<para><filename>/etc/shadow</filename>, ulikt dets alter-ego, <filename>/etc/passwd</filename>, kan ikke leses av vanlige brukere. Et hvilket som helst kryptert passord lagret i <filename>/etc/passwd</filename> kan leses av hvem som helst, en knekker kan forsøke å "bryte" (eller avsløre) et passord ved en av flere "brutale" metoder som, enkelt sagt, å gjette på vanlig brukte kombinasjoner av tegn. Dette angrepet - kalt "ordbokangrep" - er ikke lenger mulig på systemer som bruker <filename>/etc/shadow</filename>.</para>
      </sidebar>
    </section>
    <section id="sect.account-modification">
      <title>Å modifisere en eksisterende konto eller passord</title>
      <indexterm><primary><command>chsh</command></primary></indexterm>
      <indexterm><primary><command>chfn</command></primary></indexterm>
      <indexterm><primary><command>passwd</command></primary></indexterm>
      <indexterm><primary><command>chage</command></primary></indexterm>
      <indexterm><primary>password</primary></indexterm>

      <para>Følgende kommandoer tillater endring av informasjonen som er lagret i bestemte felt i brukerdatabasen: <command>passwd</command> tillater en vanlig bruker å endre passordet sitt, som igjen oppdaterer <filename>/etc/shadow</filename>-filen; <command>chfn</command> (CHange Full Name), er reservert for superbrukeren  (rot), modifiserer <literal>GECOS</literal>-feltet. <command>chsh</command> (CHange SHell) lar brukeren endre sitt login skall, men tilgang til valgene vil være begrenset til dem som er oppført i <filename>/etc/shells</filename>; administratoren, på den annen side, er ikke bundet av denne begrensningen og kan sette skallet til et hvilket som helst program de velger.</para>

      <para>Til slutt, <command>chage</command> (CHange AGE)-kommandoen tillater administratoren å endre passordets utløpsinnstillinger (<literal>-l <replaceable>user</replaceable></literal>-valget vil liste de gjeldende innstillingene). Du kan også tvinge utløpet for et passord ved å bruke <command>passwd -e <replaceable>user</replaceable></command>-kommandoen, som vil kreve at brukerne endrer sitt passord neste gang de logger inn.</para>
    </section>
    <section id="sect.disabling-account">
      <title>Deaktivere en konto</title>
      <indexterm><primary>Disable an account</primary></indexterm>
      <indexterm><primary>account</primary><secondary>disable</secondary></indexterm>

      <para>Du kan finne at du trenger å "deaktivere en konto" (låse ut en bruker), som disiplinærtiltak, i forbindelse med en undersøkelse, eller rett og slett i tilfelle av en langvarig eller definitivt fravær fra en bruker. En deaktivert konto betyr at brukeren ikke kan logge inn eller få tilgang til maskinen. Kontoen er fortsatt intakt på maskinen og ingen filer eller data blir slettet; Den er simpelthen utilgjengelig. Dette oppnås ved hjelp av kommandoen <command>passwd -l <replaceable>user</replaceable></command> (lock). Å reetablere kontoen er gjort på samme måte, med <literal>-u</literal>-valget (unlock).</para>

      <sidebar id="sidebar.intro-nss">
        <title><emphasis>GOING FURTHER</emphasis> NSS og systemdatabasen</title>
        <indexterm><primary>NSS</primary></indexterm>
        <indexterm><primary>Name Service Switch</primary></indexterm>

	<para>I stedet for å bruke de vanlige filene for å administrere lister over brukere og grupper, kan du bruke andre typer databaser, for eksempel LDAP eller <command>db</command>, ved hjelp av en passende NSS (Name Service Switch) modul. Modulene som brukes er oppført i <filename>/etc/nsswitch.conf</filename>-filen, under <literal>passwd</literal>, <literal>shadow</literal> og <literal>group</literal>-inngangene. Se <xref linkend="sect.config-nss" /> for et spesifikt eksempel på at LDAP bruker en NSS-module.</para>
      </sidebar>
    </section>
    <section id="sect.etc-group">
      <title>Gruppeliste: <filename>/etc/group</filename></title>

      <para>Grupper er listet i <filename>/etc/group</filename>-filen, en enkel tekstdatabase i et format som ligner det til <filename>/etc/passwd</filename>-filen, med de følgende feltene:</para>
      <itemizedlist>
        <listitem>
	  <para>gruppenavn;</para>
        </listitem>
        <listitem>
	  <para>passord (valgfritt): Denne brukes bare til å bli med i en gruppe når man ikke er et vanlig medlem (med <command>newgrp</command> eller <command>sg</command>-kommandoer, se sidestolpe <xref linkend="sidebar.working-with-several-groups" />);</para>
        </listitem>
        <listitem>
	  <para><literal>gid</literal>: unikt gruppeidentifikasjonsnummer;</para>
        </listitem>
        <listitem>
	  <para>medlemsliste: liste over navn på brukere som er medlemmer av gruppen, atskilt med komma.</para>
        </listitem>
      </itemizedlist>

      <para></para>

      <sidebar id="sidebar.working-with-several-groups">
        <title><emphasis>BACK TO BASICS</emphasis> Å arbeide med forskjellige grupper</title>
        <indexterm><primary><command>newgrp</command></primary></indexterm>
        <indexterm><primary><command>sg</command></primary></indexterm>
        <indexterm><primary><command>id</command></primary></indexterm>
        <indexterm><primary>group</primary><secondary>change</secondary></indexterm>

	<para>Hver bruker kan være medlem av mange grupper; en av dem er deres "hovedgruppe". En brukers hovedgruppe er, som standard, laget under den første brukerkonfigurasjon. Som standard, tilhører hver fil en bruker oppretter dem, så vel som deres hovedgruppe. Dette er ikke alltid ønskelig; for eksempel når brukeren skal jobbe i en mappe som også deles av en annen enn sin egen hovedgruppe. I dette tilfellet må brukeren endre sin viktigste gruppe ved å bruke en av følgende kommandoer: <command>newgrp</command>, som starter en nytt skall, eller  <command>sg</command>, som bare utfører en kommando ved å bruke den tilveiebrakte alternative gruppen. Disse kommandoene tillater også brukeren å delta i en gruppe som de ikke hører hjemme i. Dersom gruppen er passordbeskyttet, vil må de skaffe det riktige passordet før kommandoen blir utført.</para>

	<para>Alternativt kan brukeren sette <literal>setgid</literal> bit på katalogen, noe som fører til at mappen, slik at filene som er opprettet i den mappen automatisk hører til den riktige gruppen. For mer informasjon, se sidestolpe <xref linkend="sidebar.setgid-dir" />.</para>

	<para><command>id</command>-kommandoen viser brukerens nåværende tilstand med  sin personlig identifikator (<varname>uid</varname> variable), nåværende hovedgruppe (<varname>gid</varname> variabel), og listen med grupper som de hører til (<varname>groups</varname> variable).</para>
      </sidebar>
      <indexterm><primary><filename>group</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/group</filename></primary></indexterm>

      <para>Respektivt, <command>addgroup</command> og <command>delgroup</command>-kommandoene legger til eller sletter en gruppe. <command>groupmod</command>-kommandoen modifiserer en gruppes informasjon (its <literal>gid</literal> or identifier). Kommandoen <command>passwd -g <replaceable>group</replaceable></command> endrer passordet for gruppen, mens, while the <command>passwd -r -g <replaceable>group</replaceable></command>-kommandoen sletter den.</para>
      <indexterm><primary><command>addgroup</command></primary></indexterm>
      <indexterm><primary><command>delgroup</command></primary></indexterm>
      <indexterm><primary><command>groupmod</command></primary></indexterm>
      <indexterm><primary>group</primary><secondary>creation</secondary></indexterm>
      <indexterm><primary>creation</primary><secondary>of groups</secondary></indexterm>
      <indexterm><primary>group</primary><secondary>deletion</secondary></indexterm>
      <indexterm><primary>deletion of a group</primary></indexterm>

      <sidebar>
        <title><emphasis>TIP</emphasis> <command>getent</command></title>
        <indexterm><primary><command>getent</command></primary></indexterm>

	<para><command>getent</command> (få oppføringer)-kommandoen sjekker systemdatabasen på standardmåten, ved hjelp av de aktuelle bibliotekfunksjoner, som igjen kaller på NSS-moduler konfigurert i <filename>/etc/nsswitch.conf</filename>-filen. Kommandoen tar ett eller to argumenter: Navnet på databasen som skal sjekkes, og en mulig søkenøkkel. Således vil kommandoen <command>getent passwd rhertzog</command> gi informasjon fra brukerdatabasen om brukeren <literal>rhertzog</literal>.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.creating-accounts">
    <title>Å lage kontoer</title>
    <indexterm><primary>account</primary><secondary>creation</secondary></indexterm>
    <indexterm><primary>creation</primary><secondary>of user accounts</secondary></indexterm>

    <para>En av de første handlingene en administrator må gjøre når du setter opp en ny maskin, er å opprette brukerkontoer. Dette gjøres vanligvis ved hjelp av <command>adduser</command>-kommandoen som tar et brukernavn for den nye brukeren som skal lages, som et argument.</para>
    <indexterm><primary><command>adduser</command></primary></indexterm>

    <para><command>adduser</command>-kommandoen stiller noen spørsmål før du oppretter kontoen, men bruken er ganske grei. Konfigurasjonsfilen,<filename>/etc/adduser.conf</filename>, omfatter alle de interessante innstillingene: Den kan brukes til å automatisk sette en kvote for hver nye bruker ved å opprette en brukermal, eller til å endre plasseringen av brukerkontoer. Sistnevnte er sjelden nyttig, men er hendig, for eksempel, når du har et stort antall brukere og ønsker å dele kontoene deres over flere disker. Du kan også velge et annet skall.</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Quota</title>
      <indexterm><primary>quota</primary></indexterm>

      <para>Betegnelsen "kvote" refererer til en grense for maskinressurser som en bruker har lov til å bruke. Dette refererer ofte til diskplass.</para>
    </sidebar>

    <para>Opprettelsen av en konto fyller brukerens hjemmekatalog med innholdet i <filename>/etc/skel/</filename>-malen. Dette gir brukeren et sett med standardkataloger og konfigurasjonsfiler.</para>
    <indexterm><primary>group</primary><secondary>add a user</secondary></indexterm>
    <indexterm><primary>add a user to a group</primary></indexterm>

    <para>I noen tilfeller vil det være nyttig å legge til en bruker til en gruppe (annet enn dennes standard "hoved"-gruppe) for å gi dem ytterligere tillatelser. For eksempel, en bruker som er inkludert i <emphasis>audio</emphasis>-gruppen kan få tilgang til lydenheter (se sidestolpe <xref linkend="sidebar.special-files" />). Dette kan oppnås med en kommando som <command>adduser <replaceable>user</replaceable> <replaceable>group</replaceable></command>.</para>

    <sidebar id="sidebar.special-files">
      <title><emphasis>BACK TO BASICS</emphasis> Device access permissions</title>
      <indexterm><primary>device</primary><secondary>access permissions</secondary></indexterm>
      <indexterm><primary>file</primary><secondary>special</secondary></indexterm>
      <indexterm><primary>mode</primary><secondary>character</secondary></indexterm>
      <indexterm><primary>mode</primary><secondary>block</secondary></indexterm>
      <indexterm><primary>block, mode</primary></indexterm>
      <indexterm><primary>character, mode</primary></indexterm>
      <indexterm><primary>special, file</primary></indexterm>
      <indexterm><primary><command>mknod</command></primary></indexterm>

      <para>Hver eksterne maskinvareenhet er representert i Unix med en spesiell fil, vanligvis lagret i filtreet under <filename>/dev/</filename> (DEVices). Det er to typer spesialfiler som forholder seg til hvordan enheten er konstruert: "Tegnmodus"- og "blokk modus"-filer, begge modi tillater bare et begrenset antall operasjoner. Mens tegnmodus begrenser samhandlingen med lese/skriveoperasjoner , tillater blokkmodus også å søke i tilgjengelige data. Til slutt, hver spesialfil er knyttet til to tall ("større" og "mindre") som identifiserer enheten til kjernen på en unik måte. En slik fil, laget av  <command>mknod</command>-kommandoen, inneholder rett og slett et symbolsk (og mer menneskevennlig) navn.</para>

      <para>Tillatelsene for et spesialfil-kart til de nødvendige tillatelsene for å få tilgang til enheten selv. Dermed vil en fil som <filename>/dev/mixer</filename>, som representerer lydmikser, kun har lese/skrivetilgang for rot og medlemmer av <literal>audio</literal>-gruppen. Bare disse brukerne kan betjene lydmikser.</para>

      <para>Merk at kombinasjonen av <emphasis role="pkg">udev</emphasis>, <emphasis role="pkg">consolekit</emphasis> og <emphasis role="pkg">policykit</emphasis> kan legge til flere tillatelser for å tillate brukere som er fysisk koblet til konsollet (og ikke gjennom nettverket) å få tilgang til visse enheter.</para>
    </sidebar>
  </section>
  <section id="sect.shell-environment">
    <title>Skallomgivelser</title>

    <para>Kommandotolker (eller skjell) kan være en brukers første kontaktpunkt med datamaskinen, og de må derfor være ganske vennlige. De fleste av dem bruker initialiseringsskript som tillater konfigurasjon av hvordan de virker (automatisk fullføring, ledetekst, etc.).</para>
    <indexterm><primary>command line interface</primary></indexterm>
    <indexterm><primary>command interpreter</primary></indexterm>
    <indexterm><primary>shell</primary></indexterm>
    <indexterm><primary><command>bash</command></primary></indexterm>

    <para><command>bash</command>, standardskjellet bruker  <filename>/etc/bash.bashrc</filename>-initialiseringskriptet “interaktive” skall, og <filename>/etc/profile</filename> for “login” skall.</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Login skall og (ikke) interaktive skall</title>

      <para>Enkelt sagt, et login skall startes når du logger på til konsollen enten lokalt eller eksternt via <command>ssh</command>, eller når du kjører en eksplisitt <command>bash --login</command>-kommando. Uansett om det er en login-skall eller ikke, kan et skall være interaktivt (i en for eksempel <command>xterm</command>-type terminal); eller ikke-interaktivt (ved å kjøre et skript).</para>
    </sidebar>

    <sidebar>
      <title><emphasis>DISCOVERY</emphasis> Andre skall, andre skripts</title>

      <para>Hver kommando-tolk har en bestemt syntaks og egne konfigurasjonsfiler.  <command>zsh</command> bruker dermed <filename>/etc/zshrc</filename> og <filename>/etc/zshenv</filename>; <command>csh</command> bruker <filename>/etc/csh.cshrc</filename>, <filename>/etc/csh.login</filename> og <filename>/etc/csh.logout</filename>. De manuelle sidene for disse programmene dokumenterer hvilke filer de bruker.</para>
      <indexterm><primary><command>zsh</command></primary></indexterm>
      <indexterm><primary><command>csh</command></primary></indexterm>
    </sidebar>

    <para>For <command>bash</command>, er det nyttig å aktivisere “automatisk fullføring” i <filename>/etc/bash.bashrc</filename>-filen (ganske enkelt avkommentere noen få linjer)</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Automatisk fullføring</title>
      <indexterm><primary>automatic completion</primary></indexterm>

      <para>Mange kommandotolker har en fullføringsfunksjon, som gjør at skallet automatisk fullfører et delvis skrevet kommandonavn eller argument når brukeren treffer <keycap>Tab</keycap> tasten. Dette lar brukerne arbeide mer effektivt og være mindre utsatt for feil.</para>

      
      <para>Denne funksjonen er veldig kraftig og fleksibel. Det er mulig å konfigurere oppførselen  i henhold til hver kommando. Dermed blir det første argumentet som følger etter  <command>apt-get</command> foreslått i henhold til syntaksen til denne kommandoen, selv om den ikke passer til noen fil (i dette tilfellet er de mulige valgene  <literal>install</literal>, <literal>remove</literal>, <literal>upgrade</literal>, etc.).</para>
    </sidebar>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Tilden, et snarvei til HOME</title>
      <indexterm><primary>~</primary></indexterm>
      <indexterm><primary>tilde</primary></indexterm>

      <para>Tilden er ofte brukt for å indikere katalogen som miljøvariabelen peker til <varname>HOME</varname>, (som brukerens hjemmekatalog, for eksempel <filename>/home/rhertzog/</filename>). Kommandotolker lager automatisk erstatningen: <filename>~/hello.txt</filename> blir til <filename>/home/rhertzog/hello.txt</filename>.</para>

      <para>Tilden gir også tilgang til en annen brukers hjemmekatalog . Dermed er <filename>~rmas/bonjour.txt</filename> synonym med <filename>/home/rmas/bonjour.txt</filename>.</para>
    </sidebar>

    <para>I tillegg til disse vanlige skriptene, kan hver bruker opprette sin egen <filename>~/.bashrc</filename> og <filename>~/.bash_profile</filename> for å konfigurere sine skall. De mest vanlige endringer er å tilføye aliaser. Det er ord som automatisk erstattes når en kommando utføres, som gjør det raskere å bruke den kommandoen. For eksempel kan du opprette <literal>la</literal>-aliaset for kommandoen <command>ls -la | less</command>. Så trenger du bare å skrive <command>la</command> for å se igjennom innholdet i en mappe i detalj.</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Environment variables</title>
      <indexterm><primary>environment</primary><secondary>environment variable</secondary></indexterm>
      <indexterm><primary>variable, environment</primary></indexterm>

      <para>Miljøvariabler tillater lagring av globale innstillinger for skall eller diverse andre brukte programmer. De er kontekstuelle (hver prosess har sitt eget sett med miljøvariabler), men kan arves. Denne siste karakteristikken gir muligheten for et login-shell å angi variabler som vil bli formidlet videre til alle programmer den kjører.</para>
    </sidebar>

    <para>Å sette standard miljøvariabler er en viktig del i skallkonfigurasjon. Når vi ser bort fra variablene som er spesifikke for et skall, er det best å plassere dem i  <filename>/etc/environment</filename>-filen, siden den brukes av de ulike programmene som sannsynligvis starter en skalløkt. Variabler som vanligvis er angitt der, inkluderer <varname>ORGANIZATION</varname>, som vanligvis inneholder navnet på et kompani eller en organisasjon, og <varname>HTTP_PROXY</varname>,  som indikerer eksistensen og plasseringen av en HTTP-mellomtjener.</para>

    <sidebar>
      <title><emphasis>TIP</emphasis> Alle skall er konfigurert identisk</title>

      <para>Brukere ønsker ønske å konfigurere sine logg inn og interaktive skjell på samme måte. For å gjøre dette, velger de å tolke (eller "source") innholdet fra <filename>~/.bashrc</filename> i <filename>~/.bash_profile</filename>-filen. Det er mulig å gjøre det samme med filer som er felles for alle brukere (ved å kalle på <filename>/etc/bash.bashrc</filename> fra <filename>/etc/profile</filename>).</para>
    </sidebar>
  </section>
  <section id="sect.config-printing">
    <title>Skriveroppsett</title>
    <indexterm><primary>configuration</primary><secondary>printing</secondary></indexterm>
    <indexterm><primary>printing</primary><secondary>configuration</secondary></indexterm>

    <para>Skriveroppsettet bruker å forårsake mye hodepine for administratorer og brukere. Denne hodepinen er nå stort sett en ting fra fortiden, takket være  <emphasis role="pkg">cups</emphasis>, den frie printertjeneren som bruker IPP protokollen (Internet Printing Protocol).</para>
    <indexterm><primary>IPP</primary></indexterm>
    <indexterm><primary>Internet Printing Protocol</primary></indexterm>
    <indexterm><primary><command>cups</command></primary></indexterm>

    <para>Dette programmet er fordelt over flere Debian-pakker: <emphasis role="pkg">cups</emphasis> er den sentrale skrivertjeneren; <emphasis role="pkg">cups-bsd</emphasis> er et kompatibilitetslag, slik at bruk av kommandoer fra det tradisjonelle BSD utskriftssystemet (<command>lpd</command> daemon, <command>lpr</command> og <command>lpq</command> commands, etc.); <emphasis role="pkg">cups-client</emphasis> inneholder en gruppe programmer til å samhandle med tjeneren (blokkere eller gjenåpne en skriver, vise eller slette utskriftsjobber som pågår, etc.), og til slutt inneholder <emphasis role="pkg">cups-driver-gutenprint</emphasis> en samling med flere skriverdrivere for <command>cups</command>.</para>
    <indexterm><primary><command>lpr</command></primary></indexterm>
    <indexterm><primary><command>lpd</command></primary></indexterm>
    <indexterm><primary><command>lpq</command></primary></indexterm>

    <sidebar>
      <title><emphasis>COMMUNITY</emphasis> CUPS</title>
      <indexterm><primary>CUPS</primary></indexterm>
      <indexterm><primary>Common Unix Printing System</primary></indexterm>

      <para>CUPS (Common Unix Printing System) er et prosjekt (og et varemerke) administrert av Apple, Inc. <ulink type="block" url="http://www.cups.org/" /></para>
    </sidebar>

    <para>Etter installasjon av disse forskjellige pakkene, er <command>cups</command> enkelt administrert via et nettgrensesnitt som er tilgjengelig fra den lokale adressen:<literal>http://localhost:631/</literal>. Der kan du legge til, fjerne og administrere skrivere (inkludert nettverksskrivere). Du kan også administrere <command>cups</command> med grafiske grensesnitt i skrivebordsmiljøet. Til slutt er det også det grafiske grensesnittet <command>system-config-printer</command> (fra Debian pakken med samme navn).</para>
    <indexterm><primary><command>cups</command></primary><secondary>administration</secondary></indexterm>

    <sidebar>
      <title><emphasis>NOTE</emphasis> Obsolescence of <filename>/etc/printcap</filename></title>

      <para><emphasis>cups</emphasis> bruker ikke lenger <filename>/etc/printcap</filename> -filen, som nå er foreldet. Programmer som er avhengige av denne filen for å få en liste over tilgjengelige skrivere, vil dermed mislykkes. For å unngå dette problemet, slett denne filen og gjør den til en symbolsk lenke (se sidefelt <xref linkend="sidebar.symbolic-link" />) til <filename>/var/run/cups/printcap</filename>, som er vedlikeholdt av <emphasis>cups</emphasis> for å sikre samsvar.</para>
      <indexterm><primary><filename>printcap</filename></primary></indexterm>
    </sidebar>
  </section>
  <section id="sect.config-bootloader">
    <title>Konfigurere oppstartslaster</title>
    <indexterm><primary>loader</primary><secondary>bootloader</secondary></indexterm>
    <indexterm><primary>bootloader</primary></indexterm>

    <para>Det virker sannsynligvis allerede, men det er alltid godt å vite hvordan du konfigurerer og installerer oppstartsladeren i tilfelle den forsvinner fra Master Boot Record. Dette kan skje etter installasjon av et annet operativsystem, for eksempel Windows. Den følgende informasjonen kan også hjelpe deg å endre oppstartslastens konfigurasjon hvis nødvendig.</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Master boot record</title>
      <indexterm><primary>MBR</primary></indexterm>
      <indexterm><primary>Master Boot Record</primary></indexterm>

      <para>The Master Boot Record (MBR) inntar de første 512 byte av den første harddisken, og er det første BIOS laster for å overlate kontrollen til et program som kan starte det ønskede operativsystemet. Vanligvis, når en oppstartslaster installeres i MBR, fjernes det tidligere innholdet.</para>
    </sidebar>
    <section id="sect.identify-disks">
      <title>Identifisere diskene</title>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> <emphasis>udev</emphasis> og <filename>/dev/</filename></title>

	<para><filename>/dev/</filename>-mappen omfatter vanligvis såkalte “spesial”-filer, ment å representere systemets tilleggsutstyr (se sidestolpe <xref linkend="sidebar.special-files" />). Det var en gang, da det pleide å inneholde alle spesialfiler som potensielt kunne brukes. Denne tilnærmingen hadde en rekke ulemper blant annet det faktum at det er begrenset hvor mange enheter som man kunne bruke (på grunn av den hardkodede listen med navn), og at det var umulig å vite hvilke spesielle filer som faktisk var nyttige.</para>

	<para>I dag er håndteringen av spesielle filer helt dynamisk og svarer bedre egenskapene til rasktvekslende datamaskinenheter. Kjernen samarbeider med <emphasis>udev</emphasis> for å opprette og slette dem etter behov når de tilsvarende enhetene kommer og forsvinner. Av denne grunn, trenger ikke <filename>/dev/</filename> å være varig og er dermed et RAM-basert filsystem som starter tomt og kun inneholder de relevante oppføringer.</para>

	<para>Kjernen kommuniserer mye informasjon om eventuell nylig tillagt enhet og deler ut et par større/mindre tall for å identifisere den. Med <command>udevd</command> kan en lage  spesialfilen med navn og med de tillatelsene som den ønsker. Den kan også opprette aliaser og utføre flere handlinger (som initialisering eller registreringsoppgaver). <command>udevd</command>-ens virke drives med et større sett med (egendefinerte) regler.</para>

	<para>Med dynamisk tildelte navn, kan du holde på samme navn for en gitt enhet, uavhengig av koblingen som brukes eller rekkefølgen på forbindelsen, noe som er spesielt nyttig når du bruker forskjellig USB-utstyr. Den første partisjonen på den første harddisken kan da bli kalt <filename>/dev/sda1</filename> for samsvar bakover, eller  <filename>/dev/root-partition</filename> hvis du foretrekker det, eller til og med begge samtidig, fordi <command>udevd</command> kan konfigureres til automatisk å lage en symbolsk lenke.</para>

	<para>I gamle dager var det noen kjernemoduler ble lastet automatisk når du prøvde å få tilgang til den tilsvarende filen for enheten. Dette er ikke lenger tilfelle, og det tilleggsenhetens spesielle fil finnes ikke lenger før lasting av modulen. Dette er ikke noe stort poeng, fordi de fleste moduler er lastet på fra oppstart takket være automatisk gjenkjenning av maskinvare. Men for ikke oppsporbare enheter (som svært gamle disker eller PS/2-mus), fungerer dette ikke. Vurder å legge til modulene, <literal>floppy</literal>, <literal>psmouse</literal> og <literal>mousedev</literal> til <filename>/etc/modules</filename> for å tvinge at de lastes ved oppstart.</para>
      </sidebar>

      <indexterm><primary>hard drive, names</primary></indexterm>
      <indexterm><primary>names</primary><secondary>of hard drives</secondary></indexterm>

      <para>Oppsettet av oppstartslasteren må identifisere de ulike harddisker og deres partisjoner. Linux bruker "blokk" spesialfiler lagret i <filename>/dev/</filename>-mappen til dette formålet. Etter Debian <emphasis role="distribution">Squeeze</emphasis>, har  navningsskjemaet for harddisker blitt forent av Linux kjernen, og alle harddisker (IDE/PATA, SATA, SCSI, USB, IEEE 1394) er nå representert nå av <filename>/dev/sd*</filename>.</para>

      <para>Hver partisjon er representert med sitt nummer på disken der den ligger, for eksempel er <filename>/dev/sda1</filename> den første partisjonen på den første disken, og <filename>/dev/sdb3</filename> er den tredje partisjonen på den andre disken.</para>

      <indexterm><primary>partition</primary><secondary>primary</secondary></indexterm>
      <indexterm><primary>partition</primary><secondary>extended</secondary></indexterm>
      <indexterm><primary>partition</primary><secondary>secondary</secondary></indexterm>
      <indexterm><primary>partition table</primary><secondary>MS-DOS format</secondary></indexterm>
      <para>PC-arkitekturen (eller "i386", inkludert sin yngre fetter "amd64") har lenge vært begrenset til å bruke "MS-DOS" partisjonstabellformatet, som bare tillater fire "primære" partisjoner per disk. Å gå utover denne begrensningen under denne ordningen, må en av dem lages som en "utvidet" partisjon, og kan da inneholde flere "sekundære" partisjoner. Disse sekundære partisjonene er nummerert fra 5. Dermed kan den første sekundærpartisjonen være <filename>/dev/sda5</filename>, fulgt av <filename>/dev/sda6</filename>, etc.</para>

      <para>En annen begrensning i partisjonstabellformat MS-DOS, er at det bare tillater disker opp til 2 TiB størrelse, som blir et reelt problem med nyere disker.</para>

      <indexterm><primary>GPT</primary><secondary>partition table format</secondary></indexterm>
      <indexterm><primary>partition table</primary><secondary>GPT format</secondary></indexterm>
      <para>Et ny partisjonstabellformat, kalt GPT, løsner disse begrensningene på antall partisjoner (det tillater opp til 128 partisjoner når du bruker standardinnstillingene) og på størrelsen på diskene (opp til 8 Zib, som er mer enn 8 milliarder terabyte). Hvis du har tenkt å lage mange fysiske partisjoner på samme disk, bør du derfor sørge for at du oppretter partisjonstabellen i GPT-format når disken partisjoneres.</para>

      <para>Det er ikke alltid lett å huske hvilken disk som er koblet til hvilken SATA-kontroll, eller i tredje posisjon i SCSI-kjeden, spesielt når navngivingen av harddisker med høye ytelser (som inkluderer blant annet de fleste SATA disker og eksterne disker) kan endre seg fra en oppstart til en annen. Heldigvis lager <command>udev</command> l, i tillegg til <filename>/dev/sd*</filename>, symbolske lenker med et fast navn, som du deretter kan deretter bruke hvis du ønsket å identifisere en harddisk på en ikke-tvetydig måte. Disse symbolske lenkene er lagret i <filename>/dev/disk/by-id</filename>. På en maskin med to fysiske disker, for eksempel, kan man finne følgende:</para>

      <screen><computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l
</userinput><computeroutput>total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </computeroutput></screen>

      <para>Merk at noen disker er oppført flere ganger (fordi de oppfører seg samtidig som ATA-disker og SCSI-disker), men den relevante informasjonen er hovedsakelig i diskenes modell og serienumre, der du kan finne den perifere filen.</para>

      <para>Eksempel konfigurasjonsfilene som gis dette avsnittet er basert på det samme oppsettet: En enkelt SATA-disk, der den første partisjonen er en gammel Windows-installasjonen og den andre inneholder Debian GNU / Linux.</para>
    </section>
    
    <section id="sect.config-lilo">
      <title>Å konfigurere LILO</title>
      <indexterm><primary>LILO</primary></indexterm>
      <indexterm><primary>Linux Loader</primary></indexterm>

      <para><emphasis>LILO</emphasis> (LInux LOader) er den eldste oppstartslasteren - solid men rustikk. Den skriver den fysiske adressen til kjernen for å starte på MBR, og det er derfor hver oppdatering til LILO (eller dens konfigurasjonsfil) må etterfølges av kommandoen<command>lilo</command>. Å glemme å gjøre dette, vil gi et system som ikke kan starte hvis den gamle kjernen ble fjernet eller erstattet, ettersom den nye ikke vil være på samme sted på disken.</para>

      <para>LILOs konfigursjonsfilen er <filename>/etc/lilo.conf</filename>. En enkel fil for standardkonfigurasjon er illustrert i eksempelet nedenfor.</para>

      <example id="example.lilo.conf">
        <title>LILO konfigurasjonsfil</title>

        <programlisting>
# The disk on which LILO should be installed.
# By indicating the disk and not a partition.
# you order LILO to be installed on the MBR.
boot=/dev/sda
# the partition that contains Debian
root=/dev/sda2
# the item to be loaded by default
default=Linux

# the most recent kernel image
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Old kernel (if the newly installed kernel doesn't boot)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# only for Linux/Windows dual boot
other=/dev/sda1
  label=Windows
</programlisting>
      </example>
    </section>
    <section id="sect.config-grub">
      <title>GRUB 2 Konfigurasjon</title>
      <indexterm><primary>GRUB</primary></indexterm>
      <indexterm><primary>GRUB 2</primary></indexterm>

      <para><emphasis>GRUB</emphasis> (GRand Unified Bootloader) er nyere. Det er ikke nødvendig å ta den i bruk etter hver oppdatering av kjernen;<emphasis>GRUB</emphasis> vet hvordan filsystemene skal leses og selv finne posisjonen til kjernen på disken. For å installere den på MBR i denførste disken, skrive bare <command>grub-install /dev/sda</command>. <indexterm><primary><command>grub-install</command></primary></indexterm></para>

      <sidebar>
        <title><emphasis>NOTE</emphasis> Disknavn for GRUB</title>

	<para>GRUB kan bare identifisere harddisker basert på opplysninger fra BIOS. <literal>(hd0)</literal> samsvarer med den første disken som oppdages, <literal>(hd1)</literal> den andre, etc. I de fleste tilfeller, tilsvarer dette for nøyaktig til den vanlige rekkefølgen av disker under Linux, men problemer kan oppstå når du forbinder SCSI- og IDE-disker. GRUB lagerer overensstemmelser som den avdekker i filen <filename>/boot/grub/device.map</filename>. Hvis du finner feil der (fordi du vet at din BIOS oppdager stasjoner i en annen rekkefølge), korriger dem manuelt og kjør <command>grub-install</command> igjen. <command>grub-mkdevicemap</command> kan hjelpe til med å lage en  <filename>device.map</filename>-fil som det kan startes fra.</para>

	<para>Partisjoner har også et bestemt navn i GRUB. Når du bruker "klassiske" partisjoner i MS-DOS-format, er den første partisjonen på den første disken merket <literal>(hd0,msdos1)</literal>, den andre <literal>(hd0,msdos2)</literal>, osv.</para>
      </sidebar>

      <para>GRUB 2 konfigurasjon er lagret i <filename>/boot/grub/grub.cfg</filename>, men denne filen (i Debian) er generert fra andre. Vær forsiktig med å endre det for hånd, siden slike lokale endringer vil gå tapt neste gang <command>update-grub</command> kjøres (som kan oppstå ved oppdatering av ulike pakker). De vanligste modifikasjoner av <filename>/boot/grub/grub.cfg</filename>-filen (for å legge kommandolinjeparametere til kjernen eller endre hvor lenge menyen vises, for eksempel) er gjort gjennom variabler i <filename>/etc/default/grub</filename>. For å legge til oppføringer i menyen, kan du enten lage en <filename>/boot/grub/custom.cfg</filename>-fil eller modifisere <filename>/etc/grub.d/50_custom</filename>-filen. For mer komplekse konfigurasjoner, kan du modifisere andre filer i <filename>/etc/grub.d</filename>, eller legge til. Disse skriptene skal returnere konfigurasjonssnutter, muligens ved å bruke  eksterne programmer. Disse skriptene er de som vil oppdatere listen over kjerner som kan startes:  <filename>10_linux</filename> tar hensyn til installerte Linux kjerner; <filename>20_linux_xen</filename> tar i betraktning Xen virtual systemer, og <filename>30_os-prober</filename> lister andre operativsystemer (Windows, OS X, Hurd).</para>
    </section>
    
    <section id="sect.config-yaboot">
      <title>For Macintosh Computers (PowerPC): Konfigurere Yaboot</title>
      <indexterm><primary><command>yaboot</command></primary></indexterm>

      <para>Yaboot er oppstartslasteren som gamle Macintosh-maskiner med PowerPC-prosessorer bruker. De starter ikke som PCer, men er avhengige av en partisjon med en "oppstartsprosedyre", som BIOS (eller Openfirmware) starter lasteren fra, og der <command>ybin</command>-programmet installerer <command>yaboot</command> med konfigurasjonsfilen. Du trenger bare å kjøre denne kommandoen på nytt hvis <filename>/etc/yaboot.conf</filename> er endret (den er duplisert på oppstartsfrekevensen, og <command>yaboot</command> vet å finne posisjonen til kjernene på diskene).</para>

      <para>Før <command>ybin</command> kjøres, må du først ha et gyldig  <filename>/etc/yaboot.conf</filename>. Her følger et eksempel på en liten konfigurasjon. <indexterm><primary><command>ybin</command></primary></indexterm></para>

      <example id="example.yaboot.conf">
        <title>Yaboot konfigurasjonsfil</title>

        <programlisting>
# bootstrap partition
boot=/dev/sda2
# the disk
device=hd:
# the Linux partition
partition=3
root=/dev/sda3
# boot after 3 seconds of inactivity
# (timeout is in tenths of seconds)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# last kernel installed
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# old kernel
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# only for Linux/Mac OSX dual-boot
macosx=/dev/sda5

# bsd=/dev/sdaX and macos=/dev/sdaX
# are also possible
</programlisting>
      </example>
    </section>
  </section>
  <section id="sect.config-misc">
    <title>Andre konfigurasjoner: Synkronisering av tid, logger, dele tilgang…</title>

    <para>De mange delene som er listet i denne seksjonen, er nyttig å kjenne til for alle som ønsker å mestre alle aspekter ved konfigurering av GNU/Linux-systemet. De er imidlertid behandlet i korthet, og referer ofte til dokumentasjonen.</para>

    <section id="sect.timezone">
      <title>Tidssone</title>
      <indexterm><primary>timezone</primary></indexterm>

      <sidebar id="sidebar.symbolic-link">
        <title><emphasis>BACK TO BASICS</emphasis> Symbolic links</title>
        <indexterm><primary>link</primary><secondary>symbolic</secondary></indexterm>
        <indexterm><primary>symbolic link</primary></indexterm>
        <indexterm><primary><command>ln</command></primary></indexterm>

	<para>En symbolsk lenke er en peker til en annen fil. Når du åpner den, vil filen som den peker til åpnes. Fjerning av linken, vil ikke slette filen den peker til. Likeledes har den ikke sitt eget sett med tillatelser, men beholder heller rettighetene til sitt mål. Endelig kan den peke til alle typer filer: Kataloger, spesialfiler (kontakter, navnede kanaler, enhetsfiler, etc.), og til og med andre symbolske lenker.</para>

	<para><command>ln -s <replaceable>target</replaceable> <replaceable>link-name</replaceable></command>-kommandoen lager en symbolsk lenke, kalt  <replaceable>link-name</replaceable>, som peker til  <replaceable>target</replaceable>.</para>

	<para>If the target does not exist, then the link is “broken”
	and accessing it will result in an error indicating that the target
	file does not exist. If the link points to another link, you will
	have a “chain” of links that turns into a “cycle” if one of
	the targets points to one of its predecessors. In this case,
	accessing one of the links in the cycle will result in a specific
	error (“too many levels of symbolic links”); this means the
	kernel gave up after several rounds of the cycle.</para>
      </sidebar>

      <para>The timezone, configured during initial installation, is a
      configuration item for the <emphasis role="pkg">tzdata</emphasis>
      package. To modify it, use the <command>dpkg-reconfigure
      tzdata</command> command, which allows you to choose the timezone to
      be used in an interactive manner. Its configuration is stored in the
      <filename>/etc/timezone</filename> file. Additionally, the
      corresponding file in the <filename>/usr/share/zoneinfo</filename>
      directory is copied into <filename>/etc/localtime</filename>; this file
      contains the rules governing the dates where daylight saving time is
      active, for countries that use it.</para>
      <indexterm><primary><filename>timezone</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/timezone</filename></primary></indexterm>
      <indexterm><primary><filename>zoneinfo</filename></primary></indexterm>
      <indexterm><primary><filename>/usr/share/zoneinfo/</filename></primary></indexterm>
      <indexterm><primary>DST</primary></indexterm>
      <indexterm><primary>daylight saving time</primary></indexterm>

      <para>When you need to temporarily change the timezone, use the
      <varname>TZ</varname> environment variable, which takes priority over
      the configured system default:</para>
      <indexterm><primary><varname>TZ</varname></primary></indexterm>

      <screen id="screen.tz">
<computeroutput>$ </computeroutput><userinput>date</userinput>
<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>
<computeroutput>$ </computeroutput><userinput>TZ="Pacific/Honolulu" date</userinput>
<computeroutput>Thu Feb 19 00:25:21 HST 2015</computeroutput></screen>

      <sidebar>
        <title><emphasis>NOTE</emphasis> System clock, hardware clock</title>

	<para>There are two time sources in a computer. A computer's
	motherboard has a hardware clock, called the “CMOS clock”. This
	clock is not very precise, and provides rather slow access times.
	The operating system kernel has its own, the software clock, which
	it keeps up to date with its own means (possibly with the help of
	time servers, see <xref linkend="sect.time-synchronization" />). This
	system clock is generally more accurate, especially since it
	doesn't need access to hardware variables. However, since it only
	exists in live memory, it is zeroed out every time the machine is
	booted, contrary to the CMOS clock, which has a battery and
	therefore “survives” rebooting or halting of the machine. The
	system clock is, thus, set from the CMOS clock during boot, and the
	CMOS clock is updated on shutdown (to take into account possible
	changes or corrections if it has been improperly adjusted).</para>

	<para>In practice, there is a problem, since the CMOS clock is
	nothing more than a counter and contains no information regarding
	the time zone. There is a choice to make regarding its
	interpretation: either the system considers it runs in universal
	time (UTC, formerly GMT), or in local time. This choice could be a
	simple shift, but things are actually more complicated: as a result
	of daylight saving time, this offset is not constant. The result is
	that the system has no way to determine whether the offset is
	correct, especially around periods of time change. Since it is
	always possible to reconstruct local time from universal time and
	the timezone information, we strongly recommend using the CMOS
	clock in universal time.</para>

	<para>Unfortunately, Windows systems in their default configuration
	ignore this recommendation; they keep the CMOS clock on local time,
	applying time changes when booting the computer by trying to guess
	during time changes if the change has already been applied or not.
	This works relatively well, as long as the system has only Windows
	running on it. But when a computer has several systems (whether it
	be a “dual-boot” configuration or running other systems via
	virtual machine), chaos ensues, with no means to determine if the
	time is correct. If you absolutely must retain Windows on a
	computer, you should either configure it to keep the CMOS clock as
	UTC (setting the registry key
	<literal>HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</literal>
	to “1” as a DWORD), or use <command>hwclock --localtime --set</command>
	on the Debian system to set the hardware clock and mark it as tracking
	the local time (and make sure to manually check your clock in spring and
	autumn).</para>
      </sidebar>
    </section>
    <section id="sect.time-synchronization">
      <title>Time Synchronization</title>
      <indexterm><primary>time synchronization</primary></indexterm>
      <indexterm><primary>clock</primary><secondary>synchronization</secondary></indexterm>

      <para>Time synchronization, which may seem superfluous on a computer,
      is very important on a network. Since users do not have permissions
      allowing them to modify the date and time, it is important for this
      information to be precise to prevent confusion. Furthermore, having
      all of the computers on a network synchronized allows better
      cross-referencing of information from logs on different machines.
      Thus, in the event of an attack, it is easier to reconstruct the
      chronological sequence of actions on the various machines involved in
      the compromise. Data collected on several machines for statistical
      purposes won't make a great deal of sense if they are not
      synchronized.</para>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> NTP</title>
        <indexterm><primary>NTP</primary></indexterm>
        <indexterm><primary>Network</primary><secondary>Time Protocol</secondary></indexterm>

	<para>NTP (Network Time Protocol) allows a machine to synchronize
	with others fairly accurately, taking into consideration the delays
	induced by the transfer of information over the network and other
	possible offsets.</para>

	<para>While there are numerous NTP servers on the Internet, the
	more popular ones may be overloaded. This is why we recommend using
	the <emphasis>pool.ntp.org</emphasis> NTP server, which is, in
	reality, a group of machines that have agreed to serve as public
	NTP servers. You could even limit use to a sub-group specific to a
	country, with, for example, <emphasis>us.pool.ntp.org</emphasis>
	for the United States, or <emphasis>ca.pool.ntp.org</emphasis> for
	Canada, etc.</para>

	<para>However, if you manage a large network, it is recommended
	that you install your own NTP server, which will synchronize with
	the public servers. In this case, all the other machines on your
	network can use your internal NTP server instead of increasing the
	load on the public servers. You will also increase homogeneity with
	your clocks, since all the machines will be synchronized on the
	same source, and this source is very close in terms of network
	transfer times.</para>
      </sidebar>
      <section id="sect.ntp-on-workstations">
        <title>For Workstations</title>

	<para>Since work stations are regularly rebooted (even if only to
	save energy), synchronizing them by NTP at boot is enough. To do
	so, simply install the <emphasis role="pkg">ntpdate</emphasis>
	package. You can change the NTP server used if needed by modifying
	the <filename>/etc/default/ntpdate</filename> file.</para>
        <indexterm><primary><filename>ntpdate</filename></primary></indexterm>
        <indexterm><primary><filename>/etc/default/ntpdate</filename></primary></indexterm>
      </section>
      <section id="sect.ntp-on-servers">
        <title>For Servers</title>

        
	<para>Servers are only rarely rebooted, and it is very important
	for their system time to be correct. To permanently maintain
	correct time, you would install a local NTP server, a service
	offered in the <emphasis role="pkg">ntp</emphasis> package. In its
	default configuration, the server will synchronize with
	<emphasis>pool.ntp.org</emphasis> and provide time in response to
	requests coming from the local network. You can configure it by
	editing the <filename>/etc/ntp.conf</filename> file, the most
	significant alteration being the NTP server to which it refers. If
	the network has a lot of servers, it may be interesting to have one
	local time server which synchronizes with the public servers and is
	used as a time source by the other servers of the network.</para>
        <indexterm><primary><emphasis role="pkg">ntp</emphasis></primary></indexterm>
        <indexterm><primary>server</primary><secondary>NTP</secondary></indexterm>
        <indexterm><primary>NTP</primary><secondary>server</secondary></indexterm>

        <sidebar>
          <title><emphasis>GOING FURTHER</emphasis> GPS modules and other time sources</title>
          <indexterm><primary>GPS</primary></indexterm>
          <indexterm><primary>DCF-77</primary></indexterm>

	  <para>If time synchronization is particularly crucial to your
	  network, it is possible to equip a server with a GPS module
	  (which will use the time from GPS satellites) or a DCF-77 module
	  (which will sync time with the atomic clock near Frankfurt,
	  Germany). In this case, the configuration of the NTP server is a
	  little more complicated, and prior consultation of the
	  documentation is an absolute necessity.</para>
        </sidebar>
      </section>
    </section>
    <section id="sect.rotation-logs">
      <title>Rotating Log Files</title>
      <indexterm><primary>file</primary><secondary>logs, rotation</secondary></indexterm>
      <indexterm><primary>logs</primary><secondary>files, rotation</secondary></indexterm>
      <indexterm><primary>rotation of log files</primary></indexterm>
      <indexterm><primary><command>logrotate</command></primary></indexterm>

      <para>Log files can grow, fast, and it is necessary to archive them.
      The most common scheme is a rotating archive: the log file is
      regularly archived, and only the latest <replaceable>X</replaceable>
      archives are retained. <command>logrotate</command>, the program
      responsible for these rotations, follows directives given in the
      <filename>/etc/logrotate.conf</filename> file and all of the files in
      the <filename>/etc/logrotate.d/</filename> directory. The
      administrator may modify these files, if they wish to adapt the log
      rotation policy defined by Debian. The
      <citerefentry><refentrytitle>logrotate</refentrytitle>
      <manvolnum>1</manvolnum></citerefentry> man page describes all of the
      options available in these configuration files. You may want to
      increase the number of files retained in log rotation, or move the
      log files to a specific directory dedicated to archiving them rather
      than delete them. You could also send them by e-mail to archive them
      elsewhere.</para>

      <para>The <command>logrotate</command> program is executed daily by
      the <command>cron</command> scheduling program (described in <xref linkend="sect.task-scheduling-cron-atd" />).</para>
    </section>
    <section id="sect.sharing-admin-rights">
      <title>Sharing Administrator Rights</title>
      <indexterm><primary>konto</primary><secondary>administratorkonto</secondary></indexterm>
      <indexterm><primary>root</primary></indexterm>
      <indexterm><primary><command>sudo</command></primary></indexterm>

      <para>Frequently, several administrators work on the same network.
      Sharing the root passwords is not very elegant, and opens the
      door for abuse due to the anonymity such sharing creates. The
      solution to this problem is the <command>sudo</command> program,
      which allows certain users to execute certain commands with special
      rights. In the most common use case, <command>sudo</command> allows a
      trusted user to execute any command as root. To do so, the user
      simply executes <command>sudo
      <replaceable>command</replaceable></command> and authenticates using
      their personal password.</para>

      <para>When installed, the <emphasis role="pkg">sudo</emphasis>
      package gives full root rights to members of the
      <literal>sudo</literal> Unix group. To delegate other rights, the
      administrator must use the <command>visudo</command> command, which
      allows them to modify the <filename>/etc/sudoers</filename>
      configuration file (here again, this will invoke the
      <command>vi</command> editor, or any other editor indicated in the
      <varname>EDITOR</varname> environment variable). Adding a line with
      <literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal>
      allows the user in question to execute any command as root.</para>
      <indexterm><primary><command>visudo</command></primary></indexterm>
      <indexterm><primary><filename>sudoers</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/sudoers</filename></primary></indexterm>

      <para>More sophisticated configurations allow authorization of only
      specific commands to specific users. All the details of the various
      possibilities are given in the
      <citerefentry><refentrytitle>sudoers</refentrytitle>
      <manvolnum>5</manvolnum></citerefentry> man page.</para>
    </section>
    <section id="sect.fstab-mount-points">
      <title>List of Mount Points</title>
      <indexterm><primary>point, mount</primary></indexterm>
      <indexterm><primary>mount point</primary></indexterm>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> Mounting and unmounting</title>

	<para>In a Unix-like system such as Debian, files are organized in
	a single tree-like hierarchy of directories. The
	<filename>/</filename> directory is called the “root
	directory”; all additional directories are sub-directories within
	this root. “Mounting” is the action of including the content of
	a peripheral device (often a hard drive) into the system's general
	file tree. As a consequence, if you use a separate hard drive to
	store users' personal data, this disk will have to be “mounted”
	in the <filename>/home/</filename> directory. The root filesystem
	is always mounted at boot by the kernel; other devices are often
	mounted later during the startup sequence or manually with the
	<command>mount</command> command.</para>
        <indexterm><primary><command>mount</command></primary></indexterm>

	<para>Some removable devices are automatically mounted when
	connected, especially when using the GNOME, KDE or other graphical
	desktop environments. Others have to be mounted manually by the
	user. Likewise, they must be unmounted (removed from the file
	tree). Normal users do not usually have permission to execute the
	<command>mount</command> and <command>umount</command> commands.
	The administrator can, however, authorize these operations
	(independently for each mount point) by including the
	<literal>user</literal> option in the
	<filename>/etc/fstab</filename> file.</para>

	<para>The <command>mount</command> command can be used without
	arguments (it then lists all mounted filesystems). The following
	parameters are required to mount or unmount a device. For the
	complete list, please refer to the corresponding man pages,
	<citerefentry><refentrytitle>mount</refentrytitle>
	<manvolnum>8</manvolnum></citerefentry> and
	<citerefentry><refentrytitle>umount</refentrytitle>
	<manvolnum>8</manvolnum></citerefentry>. For simple cases, the
	syntax is simple too: for example, to mount the
	<filename>/dev/sdc1</filename> partition, which has an ext3
	filesystem, into the <filename>/mnt/tmp/</filename> directory, you
	would simply run <command>mount -t ext3 /dev/sdc1
	/mnt/tmp/</command>.</para>
      </sidebar>

      <para>The <filename>/etc/fstab</filename> file gives a list of all
      possible mounts that happen either automatically on boot or manually
      for removable storage devices. Each mount point is described by a
      line with several space-separated fields:
      <indexterm><primary><filename>fstab</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm></para>
      <itemizedlist>
        <listitem>
	  <para>device to mount: this can be a local partition (hard drive,
	  CD-ROM) or a remote filesystem (such as NFS).</para>

	  <para>This field is frequently replaced with the unique ID of the
	  filesystem (which you can determine with <command>blkid
	  <userinput>device</userinput></command>) prefixed with
	  <literal>UUID=</literal>. This guards against a change in the
	  name of the device in the event of addition or removal of disks,
	  or if disks are detected in a different order.</para>
        </listitem>
        <listitem>
	  <para>mount point: this is the location on the local filesystem
	  where the device, remote system, or partition will be
	  mounted.</para>
        </listitem>
        <listitem>
	  <para>type: this field defines the filesystem used on the mounted
	  device. <literal>ext4</literal>, <literal>ext3</literal>,
	  <literal>vfat</literal>, <literal>ntfs</literal>,
	  <literal>btrfs</literal>, <literal>xfs</literal> are a few
	  examples.</para>

          <sidebar>
            <title><emphasis>BACK TO BASICS</emphasis> NFS, a network filesystem</title>

	    <para>NFS is a network filesystem; under Linux, it allows
	    transparent access to remote files by including them in the
	    local filesystem.</para>
          </sidebar>

	  <para>A complete list of known filesystems is available in the
	  <citerefentry><refentrytitle>mount</refentrytitle>
	  <manvolnum>8</manvolnum></citerefentry> man page. The
	  <literal>swap</literal> special value is for swap partitions; the
	  <literal>auto</literal> special value tells the
	  <command>mount</command> program to automatically detect the
	  filesystem (which is especially useful for disk readers and USB
	  keys, since each one might have a different filesystem);</para>
        </listitem>
        <listitem>
	  <para>options: there are many of them, depending on the
	  filesystem, and they are documented in the
	  <command>mount</command> man page. The most common are</para>
          <itemizedlist>
            <listitem>
	      <para><literal>rw</literal> or <literal>ro</literal>,
	      meaning, respectively, that the device will be mounted with
	      read/write or read-only permissions.</para>
            </listitem>
            <listitem>
	      <para><literal>noauto</literal> deactivates automatic
	      mounting on boot.</para>
            </listitem>
            <listitem>
              <para>
                <literal>nofail</literal> allows the boot to proceed
                even when the device is not present. Make sure to put this
                option for external drives that might be unplugged
                when you boot, because <command>systemd</command> really
                ensures that all mount points that must be automatically
                mounted are actually mounted before letting the boot
                process continue to its end. Note that you can combine
                this with <literal>x-systemd.device-timeout=5s</literal>
                to tell <command>systemd</command> to not wait more than
                5 seconds for the device to appear (see
                <citerefentry><refentrytitle>systemd.mount</refentrytitle><manvolnum>5</manvolnum></citerefentry>).
	      </para>
            </listitem>
            <listitem>
	      <para><literal>user</literal> authorizes all users to mount
	      this filesystem (an operation which would otherwise be
	      restricted to the root user).</para>
            </listitem>
            <listitem>
	      <para><literal>defaults</literal> means the group of default
	      options: <literal>rw</literal>, <literal>suid</literal>,
	      <literal>dev</literal>, <literal>exec</literal>,
	      <literal>auto</literal>, <literal>nouser</literal> and
	      <literal>async</literal>, each of which can be individually
	      disabled after <literal>defaults</literal> by adding
	      <literal>nosuid</literal>, <literal>nodev</literal> and so on
	      to block <literal>suid</literal>, <literal>dev</literal> and
	      so on. Adding the <literal>user</literal> option reactivates
	      it, since <literal>defaults</literal> includes
	      <literal>nouser</literal>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
	  <para>backup: this field is almost always set to
	  <literal>0</literal>. When it is <literal>1</literal>, it tells
	  the <command>dump</command> tool that the partition contains data
	  that is to be backed up.</para>
        </listitem>
        <listitem>
	  <para>check order: this last field indicates whether the
	  integrity of the filesystem should be checked on boot, and in
	  which order this check should be executed. If it is
	  <literal>0</literal>, no check is conducted. The root filesystem
	  should have the value <literal>1</literal>, while other permanent
	  filesystems get the value <literal>2</literal>.</para>
        </listitem>
      </itemizedlist>

      <example id="example.fstab">
        <title>Example <filename>/etc/fstab</filename> file</title>

        <programlisting>
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
# swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0
</programlisting>
      </example>

      <para>The last entry in this example corresponds to a network
      filesystem (NFS): the <filename>/shared/</filename> directory on the
      <emphasis>arrakis</emphasis> server is mounted at
      <filename>/shared/</filename> on the local machine. The format of the
      <filename>/etc/fstab</filename> file is documented on the
      <citerefentry><refentrytitle>fstab</refentrytitle><manvolnum>5</manvolnum></citerefentry>
      man page.</para>

      <sidebar>
        <title><emphasis>GOING FURTHER</emphasis> Auto-mounting</title>

        
	<para>The <emphasis>am-utils</emphasis> package provides the
	<command>amd</command> auto-mounting utility, able to mount
	removable media on demand when a user attempts to access their
	usual mount point. It will unmount these devices when no process is
	accessing them any longer.</para>
        <indexterm><primary><emphasis>am-utils</emphasis></primary></indexterm>
        <indexterm><primary><command>amd</command></primary></indexterm>
        <indexterm><primary><command>automount</command></primary></indexterm>
        <indexterm><primary><emphasis>autofs</emphasis></primary></indexterm>
        <indexterm><primary>automounter</primary></indexterm>

	<para>Other auto-mounting utilities exist, such as
	<command>automount</command> in the <emphasis>autofs</emphasis>
	package.</para>

	<para>Note also that GNOME, KDE, and other graphical desktop
	environments work together with <emphasis>udisks</emphasis>,
	and can automatically mount removable media when they are connected.</para>
      </sidebar>
    </section>
    <section id="sect.locate-updatedb">
      <title><command>locate</command> and <command>updatedb</command></title>
      <indexterm><primary><command>locate</command></primary></indexterm>
      <indexterm><primary><command>updatedb</command></primary></indexterm>
      <indexterm><primary><command>mlocate</command></primary></indexterm>

      
      <para>The <command>locate</command> command can find the location of
      a file when you only know part of the name. It sends a result almost
      instantaneously, since it consults a database that stores the
      location of all the files on the system; this database is updated
      daily by the <command>updatedb</command> command. There are multiple
      implementations of the <command>locate</command> command and Debian
      picked <emphasis role="pkg">mlocate</emphasis> for its standard
      system.</para>

      <para><command>mlocate</command> is smart enough to only return
      files which are accessible to the user running the command even
      though it uses a database that knows about all files on the system
      (since its <command>updatedb</command> implementation runs with
      root rights). For extra safety, the administrator can use
      <varname>PRUNEDPATHS</varname> in
      <filename>/etc/updatedb.conf</filename> to exclude some directories
      from being indexed.</para>
    </section>
  </section>
  <section id="sect.kernel-compilation">
    <title>Compiling a Kernel</title>
    <indexterm><primary>compilation</primary><secondary>of a kernel</secondary></indexterm>
    <indexterm><primary>kernel</primary><secondary>compilation</secondary></indexterm>

    <para>The kernels provided by Debian include the largest possible
    number of features, as well as the maximum of drivers, in order to
    cover the broadest spectrum of existing hardware configurations. This
    is why some users prefer to recompile the kernel in order to only
    include what they specifically need. There are two reasons for this
    choice. First, it may be to optimize memory consumption, since the
    kernel code, even if it is never used, occupies memory for nothing (and
    never “goes down” on the swap space, since it is actual RAM that it
    uses), which can decrease overall system performance. A locally
    compiled kernel can also limit the risk of security problems since only
    a fraction of the kernel code is compiled and run.</para>

    <sidebar>
      <title><emphasis>NOTE</emphasis> Security updates</title>

      <para>If you choose to compile your own kernel, you must accept the
      consequences: Debian cannot ensure security updates for your custom
      kernel. By keeping the kernel provided by Debian, you benefit from
      updates prepared by the Debian Project's security team.</para>
    </sidebar>

    <para>Recompilation of the kernel is also necessary if you want to use
    certain features that are only available as patches (and not included
    in the standard kernel version).</para>

    <sidebar>
      <title><emphasis>GOING FURTHER</emphasis> The Debian Kernel Handbook</title>
      <indexterm><primary><emphasis role="pkg">debian-kernel-handbook</emphasis></primary></indexterm>

      <para>The Debian kernel teams maintains the “Debian Kernel Handbook”
      (also available in the <emphasis role="pkg">debian-kernel-handbook</emphasis> package) with
      comprehensive documentation about most kernel related tasks and about how
      official Debian kernel packages are handled. This is the first place
      you should look into if you need more information than what is
      provided in this section.
      <ulink type="block" url="http://kernel-handbook.alioth.debian.org" />
      </para>
    </sidebar>

    <section id="sect.kernel-compilation-prerequisites">
      <title>Introduction and Prerequisites</title>

      <para>Unsurprisingly Debian manages the kernel in the form of a
      package, which is not how kernels have traditionally been compiled
      and installed. Since the kernel remains under
      the control of the packaging system, it can then be removed cleanly,
      or deployed on several machines. Furthermore, the scripts associated
      with these packages automate the interaction with the
      bootloader and the initrd generator.</para>

      <para>The upstream Linux sources contain everything needed to build a
      Debian package of the kernel. But you still need to install
      <emphasis role="pkg">build-essential</emphasis> to ensure that you have
      the tools required to build a Debian package. Furthermore, the
      configuration step for the kernel requires the
      <emphasis role="pkg">libncurses5-dev</emphasis> package. Finally, the
      <emphasis role="pkg">fakeroot</emphasis> package will enable creation of the
      Debian package without using administrator's rights.</para>

      
      <sidebar>
        <title><emphasis>CULTURE</emphasis> The good old days of <emphasis role="pkg">kernel-package</emphasis></title>
        <indexterm><primary><emphasis role="pkg">kernel-package</emphasis></primary></indexterm>

	<para>Before the Linux build system gained the ability to build
	proper Debian packages, the recommended way to build such packages
	was to use <command>make-kpkg</command> from the
	<emphasis role="pkg">kernel-package</emphasis> package.</para>
	
      </sidebar>

    </section>
    <section id="sect.kernel-sources">
      <title>Getting the Sources</title>
      <indexterm><primary>Linux kernel sources</primary></indexterm>
      <indexterm><primary>kernel</primary><secondary>sources</secondary></indexterm>
      <indexterm><primary>source</primary><secondary>of the Linux kernel</secondary></indexterm>

      <para>Like anything that can be useful on a Debian system, the Linux
      kernel sources are available in a package. To retrieve them, just
      install the <emphasis role="pkg">linux-source-<replaceable>version</replaceable></emphasis>
      package. The <command>apt-cache search ^linux-source</command>
      command lists the various kernel versions packaged by Debian. The
      latest version is available in the <emphasis role="distribution">Unstable</emphasis> distribution: you can
      retrieve them without much risk (especially if your APT is configured
      according to the instructions of <xref linkend="sect.apt-mix-distros" />). Note that the source code
      contained in these packages does not correspond precisely with that
      published by Linus Torvalds and the kernel developers; like all
      distributions, Debian applies a number of patches, which might (or
      might not) find their way into the upstream version of Linux. These
      modifications include backports of fixes/features/drivers from newer
      kernel versions, new features not yet (entirely) merged in the upstream
      Linux tree, and sometimes even Debian specific changes.</para>

      <para>The remainder of this section focuses on the 3.16 version of
      the Linux kernel, but the examples can, of course, be adapted to the
      particular version of the kernel that you want.</para>

      <para>We assume the <emphasis role="pkg">linux-source-3.16</emphasis> package has been installed.
      It contains
      <filename>/usr/src/linux-source-3.16.tar.xz</filename>, a
      compressed archive of the kernel sources. You must extract these
      files in a new directory (not directly under
      <filename>/usr/src/</filename>, since there is no need for special
      permissions to compile a Linux kernel):
      <filename>~/kernel/</filename> is appropriate.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>
<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-3.16.tar.xz</userinput>
</screen>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> Location of kernel sources</title>

	<para>Traditionally, Linux kernel sources would be placed in
	<filename>/usr/src/linux/</filename> thus requiring root
	permissions for compilation. However, working with administrator
	rights should be avoided when not needed. There is a
	<literal>src</literal> group that allows members to work in this
	directory, but working in <filename>/usr/src/</filename> should be
	avoided nevertheless. By keeping the kernel sources in a personal
	directory, you get security on all counts: no files in
	<filename>/usr/</filename> unknown to the packaging system, and
	no risk of misleading programs that read
	<filename>/usr/src/linux</filename> when trying to gather
	information on the used kernel.</para>
      </sidebar>
    </section>
    <section id="sect.config-kernel">
      <title>Configuring the Kernel</title>
      <indexterm><primary>kernel</primary><secondary>configuration</secondary></indexterm>
      <indexterm><primary>configuration</primary><secondary>of the kernel</secondary></indexterm>
      <indexterm><primary><filename>.config</filename></primary></indexterm>

      <para>The next step consists of configuring the kernel according to
      your needs. The exact procedure depends on the goals.</para>

      <para>When recompiling a more recent version of the kernel (possibly
      with an additional patch), the configuration will most likely be kept
      as close as possible to that proposed by Debian. In this case, and
      rather than reconfiguring everything from scratch, it is sufficient
      to copy the
      <filename>/boot/config-<replaceable>version</replaceable></filename>
      file (the version is that of the kernel currently used, which can be
      found with the <command>uname -r</command> command) into a
      <filename>.config</filename> file in the directory containing the
      kernel sources.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>cp /boot/config-3.16.0-4-amd64 ~/kernel/linux-source-3.16/.config</userinput>
</screen>

      <para>Unless you need to change the configuration, you can stop here
      and skip to <xref linkend="sect.kernel-build" />. If you need to change it, on the other
      hand, or if you decide to reconfigure everything from scratch, you
      must take the time to configure your kernel. There are various
      dedicated interfaces in the kernel source directory that can be used
      by calling the <command>make
      <replaceable>target</replaceable></command> command, where
      <replaceable>target</replaceable> is one of the values described
      below.</para>

      <para><command>make menuconfig</command> compiles and executes a
      text-mode interface (this is where the <emphasis role="pkg">libncurses5-dev</emphasis> package is required) which
      allows navigating the options available in a hierarchical structure.
      Pressing the <keycap>Space</keycap> key changes the value of the
      selected option, and <keycap>Enter</keycap> validates the button
      selected at the bottom of the screen; <guibutton>Select</guibutton>
      returns to the selected sub-menu; <guibutton>Exit</guibutton> closes
      the current screen and moves back up in the hierarchy;
      <guibutton>Help</guibutton> will display more detailed information on
      the role of the selected option. The arrow keys allow moving within the
      list of options and buttons. To exit the configuration program,
      choose <guibutton>Exit</guibutton> from the main menu. The program
      then offers to save the changes you've made; accept if you are
      satisfied with your choices.</para>

      <para>Other interfaces have similar features, but they work within
      more modern graphical interfaces; such as <command>make
      xconfig</command> which uses a Qt graphical interface, and
      <command>make gconfig</command> which uses GTK+. The former requires
      <emphasis role="pkg">libqt4-dev</emphasis>, while the latter
      depends on <emphasis role="pkg">libglade2-dev</emphasis> and
      <emphasis role="pkg">libgtk2.0-dev</emphasis>.</para>

      <para>When using one of those configuration interfaces, it is always
      a good idea to start from a reasonable default configuration. The
      kernel provides such configurations in
      <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename>
      and you can put your selected configuration in place with a command
      like <command>make x86_64_defconfig</command> (in the case of a
      64-bit PC) or <command>make i386_defconfig</command> (in the case of
      a 32-bit PC).</para>

      <sidebar>
        <title><emphasis>TIP</emphasis> Dealing with outdated <filename>.config</filename> files</title>

	<para>When you provide a <filename>.config</filename> file that has been
	generated with another (usually older) kernel version, you will have to
	update it. You can do so with <command>make oldconfig</command>, it will
	interactively ask you the questions corresponding to the new
	configuration options. If you want to use the default answer to
	all those questions you can use <command>make
	olddefconfig</command>. With <command>make oldnoconfig</command>,
	it will assume a negative answer to all questions.</para>
      </sidebar>
    </section>
    <section id="sect.kernel-build">
      <title>Compiling and Building the Package</title>
      <indexterm><primary><command>make deb-pkg</command></primary></indexterm>

      <sidebar>
        <title><emphasis>NOTE</emphasis> Clean up before rebuilding</title>

	<para>If you have already compiled once in the directory and wish
	to rebuild everything from scratch (for example because you substantially
	changed the kernel configuration), you will have to run
	<command>make clean</command> to remove the compiled files.
	<command>make distclean</command> removes even more generated files,
	including your <filename>.config</filename> file too, so make sure to
	backup it first.</para>
      </sidebar>

      <para>Once the kernel configuration is ready, a simple <command>make
      deb-pkg</command> will generate up to 5 Debian packages: <emphasis role="pkg">linux-image-<replaceable>version</replaceable></emphasis>
      that contains the kernel image and the associated modules,
      <emphasis role="pkg">linux-headers-<replaceable>version</replaceable></emphasis>
      which contains the header files required to build external modules,
      <emphasis role="pkg">linux-firmware-image-<replaceable>version</replaceable></emphasis>
      which contains the firmware files needed by some drivers (this package
      might be missing when you build from the kernel sources provided by Debian),
      <emphasis role="pkg">linux-image-<replaceable>version</replaceable>-dbg</emphasis>
      which contains the debugging symbols for the kernel image and its modules,
      and <emphasis role="pkg">linux-libc-dev</emphasis> which contains headers
      relevant to some user-space libraries like GNU glibc.</para>

      <para>The <replaceable>version</replaceable> is defined by the concatenation
      of the upstream version (as defined by the variables <literal>VERSION</literal>,
      <literal>PATCHLEVEL</literal>, <literal>SUBLEVEL</literal> and
      <literal>EXTRAVERSION</literal> in the <filename>Makefile</filename>),
      of the <literal>LOCALVERSION</literal> configuration parameter,
      and of the <literal>LOCALVERSION</literal> environment variable. The package
      version reuses the same version string with an appended revision
      that is regularly incremented (and stored in <filename>.version</filename>),
      except if you override it with the
      <literal>KDEB_PKGVERSION</literal> environment variable.
      </para>

      <screen><computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1
</userinput><computeroutput>[...]
$ </computeroutput><userinput>ls ../*.deb
</userinput><computeroutput>../linux-headers-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb
../linux-image-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb
../linux-image-3.16.7-ckt4-falcot-dbg_3.16.7-1_amd64.deb
../linux-libc-dev_3.16.7-1_amd64.deb
</computeroutput></screen>
    </section>
    <section id="sect.modules-build">
      <title>Compiling External Modules</title>
      <indexterm><primary>kernel</primary><secondary>external modules</secondary></indexterm>
      <indexterm><primary>modules</primary><secondary>external kernel modules</secondary></indexterm>
      <indexterm><primary><command>dkms</command></primary></indexterm>

      <para>Some modules are maintained outside of the official Linux
      kernel. To use them, they must be compiled alongside the
      matching kernel. A number of common third party modules are
      provided by Debian in dedicated packages, such as <emphasis role="pkg">xtables-addons-source</emphasis> (extra modules for
      iptables) or <emphasis role="pkg">oss4-source</emphasis> (Open
      Sound System, some alternative audio drivers).</para>

      <para>These external packages are many and varied and we won't list
      them all here; the <command>apt-cache search source$</command>
      command can narrow down the search field. However, a complete list
      isn't particularly useful since there is no particular reason for
      compiling external modules except when you know you need it. In such
      cases, the device's documentation will typically detail the specific
      module(s) it needs to function under Linux.</para>

      <para>For example, let's look at the <emphasis role="pkg">xtables-addons-source</emphasis> package: after installation, a
      <filename>.tar.bz2</filename> of the module's sources is stored in
      <filename>/usr/src/</filename>. While we could manually extract
      the tarball and build the module, in practice we prefer to automate
      all this using DKMS. Most modules offer the required DKMS integration
      in a package ending with a <literal>-dkms</literal> suffix. In our case,
      installing <emphasis role="pkg">xtables-addons-dkms</emphasis> is all that is
      needed to compile the kernel module for the current kernel provided that
      we have the <emphasis role="pkg">linux-headers-*</emphasis> package
      matching the installed kernel. For instance, if you use
      <emphasis role="pkg">linux-image-amd64</emphasis>, you would
      also install <emphasis role="pkg">linux-headers-amd64</emphasis>.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>
<computeroutput>
[...]
Setting up xtables-addons-dkms (2.6-1) ...
Loading new xtables-addons-2.6 DKMS files...
First Installation: checking all kernels...
Building only for 3.16.0-4-amd64
Building initial module for 3.16.0-4-amd64
Done.

xt_ACCOUNT:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/3.16.0-4-amd64/updates/dkms/
[...]
DKMS: install completed.
$ </computeroutput><userinput>sudo dkms status</userinput>
<computeroutput>xtables-addons, 2.6, 3.16.0-4-amd64, x86_64: installed
$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>
<computeroutput>filename:       /lib/modules/3.16.0-4-amd64/updates/dkms/xt_ACCOUNT.ko
license:        GPL
alias:          ipt_ACCOUNT
author:         Intra2net AG &lt;opensource@intra2net.com&gt;
description:    Xtables: per-IP accounting for large prefixes
[...]
</computeroutput>
</screen>

      <sidebar>
        <title><emphasis>ALTERNATIVE</emphasis> module-assistant</title>
        <indexterm><primary><emphasis role="pkg">module-assistant</emphasis></primary></indexterm>

	<para>Before DKMS, <emphasis role="pkg">module-assistant</emphasis> was the simplest
	solution to build and deploy kernel modules. It can still be
	used, in particular for packages lacking DKMS integration:
	with a simple command like <command>module-assistant
	auto-install xtables-addons</command> (or <command>m-a a-i
	xtables-addons</command> for short), the modules are compiled
	for the current kernel, put in a new Debian package, and that
	package gets installed on the fly.
	</para>
      </sidebar>
    </section>
    <section id="sect.kernel-patch">
      <title>Applying a Kernel Patch</title>
      <indexterm><primary>kernel</primary><secondary>patch</secondary></indexterm>
      <indexterm><primary>patch of the kernel</primary></indexterm>

      <para>Some features are not included in the standard kernel due to a
      lack of maturity or to some disagreement with the kernel maintainers.
      Such features may be distributed as patches that anyone is then free
      to apply to the kernel sources.</para>

      <para>Debian distributes some of these patches in <emphasis role="pkg">linux-patch-*</emphasis> or <emphasis role="pkg">kernel-patch-*</emphasis> packages (for instance,
      <emphasis role="pkg">linux-patch-grsecurity2</emphasis>, which
      tightens some of the kernel's security policies). These packages
      install files in the <filename>/usr/src/kernel-patches/</filename>
      directory.</para>

      <para>To apply one or more of these installed patches, use the
      <command>patch</command> command in the sources directory then start
      compilation of the kernel as described above.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-3.16</userinput>
<computeroutput>$ </computeroutput><userinput>make clean</userinput>
<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.0-3.17.1-201410250027.patch.gz | patch -p1</userinput>
</screen>

      <para>Note that a given patch may not necessarily work with every
      version of the kernel; it is possible for <command>patch</command> to
      fail when applying them to kernel sources. An error message will be
      displayed and give some details about the failure; in this case,
      refer to the documentation available in the Debian package of the
      patch (in the <filename>/usr/share/doc/linux-patch-*/</filename>
      directory). In most cases, the maintainer indicates for which kernel
      versions their patch is intended.</para>
    </section>
  </section>
  <section id="sect.kernel-installation">
    <title>Installing a Kernel</title>
    <indexterm><primary>installation</primary><secondary>of a kernel</secondary></indexterm>
    <indexterm><primary>kernel</primary><secondary>installation</secondary></indexterm>
    <section id="sect.kernel-package">
      <title>Features of a Debian Kernel Package</title>

      <indexterm><primary><filename>vmlinuz</filename></primary></indexterm>

      <para>A Debian kernel package installs the kernel image
      (<filename>vmlinuz-<replaceable>version</replaceable></filename>),
      its configuration
      (<filename>config-<replaceable>version</replaceable></filename>) and
      its symbols table
      (<filename>System.map-<replaceable>version</replaceable></filename>)
      in <filename>/boot/</filename>. The symbols table helps
      developers understand the meaning of a kernel error message; without
      it, kernel “oopses” (an “oops” is the kernel equivalent
      of a segmentation fault for user-space programs, in other
      words messages generated following an invalid pointer dereference)
      only contain numeric memory addresses, which is useless information
      without the table mapping these addresses to symbols and function
      names. The modules are installed in the
      <filename>/lib/modules/<replaceable>version</replaceable>/</filename>
      directory.</para>

      <para>The package's configuration scripts automatically generate an
      initrd image, which is a mini-system designed to be loaded in memory
      (hence the name, which stands for “init ramdisk”) by the
      bootloader, and used by the Linux kernel solely for loading the
      modules needed to access the devices containing the complete Debian
      system (for example, the driver for SATA disks). Finally, the
      post-installation scripts update the symbolic links
      <filename>/vmlinuz</filename>, <filename>/vmlinuz.old</filename>,
      <filename>/initrd.img</filename> and
      <filename>/initrd.img.old</filename> so that they point to the latest
      two kernels installed, respectively, as well as the corresponding
      initrd images.</para>

      <para>Most of those tasks are offloaded to hook scripts in
      the <filename>/etc/kernel/*.d/</filename> directories. For instance,
      the integration with <command>grub</command> relies on
      <filename>/etc/kernel/postinst.d/zz-update-grub</filename>
      and <filename>/etc/kernel/postrm.d/zz-update-grub</filename>
      to call <command>update-grub</command> when kernels
      are installed or removed.</para>
    </section>
    <section id="sect.kernel-installation-with-dpkg">
      <title>Installing with <command>dpkg</command></title>

      <para>Using <command>apt</command> is so convenient that it makes
      it easy to forget about the lower-level tools, but the easiest way of
      installing a compiled kernel is to use a command such as
      <command>dpkg -i <replaceable>package</replaceable>.deb</command>,
      where <literal><replaceable>package</replaceable>.deb</literal> is
      the name of a <emphasis role="pkg">linux-image</emphasis> package
      such as
      <filename>linux-image-3.16.7-ckt4-falcot_1_amd64.deb</filename>.</para>

      <para>The configuration steps described in this chapter are basic and
      can lead both to a server system or a workstation, and it can be
      massively duplicated in semi-automated ways. However, it is not
      enough by itself to provide a fully configured system. A few pieces
      are still in need of configuration, starting with low-level programs
      known as the “Unix services”.</para>
    </section>
  </section>
</chapter>
