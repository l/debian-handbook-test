<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="network-infrastructure">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-network-infrastructure.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Nettverk</keyword>
      <keyword>Innfallsport (gateway)</keyword>
      <keyword>TCP/IP</keyword>
      <keyword>IPv6</keyword>
      <keyword>DNS</keyword>
      <keyword>Bind</keyword>
      <keyword>DHCP</keyword>
      <keyword>QoS</keyword>
    </keywordset>
  </chapterinfo>
  <title id="infrastructure.title">Nettverksinfrastruktur</title>
  <highlights>
    <para>Linux har hele Unix-arven når det gjelder nettverk, og Debian tilbyr hele samlingen av verktøy for å opprette og styre dem. Dette kapittelet gjennomgår disse verktøyene.</para>
  </highlights>
  <section id="sect.gateway">
    <title>Innfallsport (gateway)</title>

    <para>En innfallsport (gateway) er et system som forbinder flere nettverk. Dette begrepet refererer ofte til et lokalt nettverks "exit point" på obligatorisk veien til alle eksterne IP-adresser. Inngangsporten er koblet til hver av de nettverkene den binder sammen, og fungerer som en ruter for å formidle IP-pakker mellom dens ulike grensesnitt.</para>
    <indexterm><primary>gateway</primary></indexterm>
    <indexterm><primary>network</primary><secondary>gateway</secondary></indexterm>
    <indexterm><primary>ruter</primary></indexterm>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> IP pakke</title>
      <indexterm><primary>pakke</primary><secondary>IP</secondary></indexterm>

      <para>De fleste nettverk nå for tiden bruker IP-protokollen (<emphasis>Internettprotokoll</emphasis>).  Denne protokollen deler opp de overført dataene i pakker med begrenset størrelse.  Hver pakke inneholder, i tillegg til nyttedata, en rekke detaljer som trengs for å sende den riktig vei.</para>
    </sidebar>

    <sidebar id="sidebar.tcp-udp">
      <title><emphasis>BACK TO BASICS</emphasis> TCP/UDP</title>
      <indexterm><primary>port</primary><secondary>TCP</secondary></indexterm>
      <indexterm><primary>port</primary><secondary>UDP</secondary></indexterm>
      <indexterm><primary>TCP, port</primary></indexterm>
      <indexterm><primary>UDP, port</primary></indexterm>

      <para>Mange programmer håndterer ikke de enkelte pakker selv, selv om dataene de sender ikke går over IP; ofte bruker de TCP (<emphasis>Transmission Control Protocol</emphasis>). 
TCP er et lag over IP som tillater etablering av øremerkede forbindelser til datastrømmer mellom to punkter. Programmene ser da bare en inngangsport som data kan mates til med garanti for at de samme dataene kommer ut uten tap (og i samme rekkefølge) ved utgangspunktet i den andre enden av forbindelsen. Selv om mange typer feil kan skje i de lavere lagene, er de kompensert av TCP: tapte pakker er sendt igjen, og pakker som kommer i uorden (for eksempel hvis de bruker ulike baner) er reordnet på riktig måte.</para>

      <para>En annen protokoll som setter sin lit til IP er UD (<emphasis>User Datagram Protocol</emphasis>). I motsetning til TCP, er den pakkeorientert. Mål er forskjellige: Formålet med UDP er bare å sende en pakke fra en applikasjon til en annen. Protokollen prøver ikke å kompensere for mulige pakketap underveis, heller ikke at pakker mottas i samme rekkefølge som ble sendt. Den viktigste fordelen til denne protokollen er at tidsforsinkelsen er kraftig redusert, fordi tapet av en enkelt pakke ikke forsinker mottaket av alle påfølgende pakker inntil den tapte blir sendt på nytt.</para>

      <para>TCP og UDP involverer begge porter, som er "forlengelses tall" for å etablere kommunikasjon med en gitt applikasjon på en maskin. Dette konseptet gjør det mulig å uføre flere forskjellige overføringer parallelt i samme korrespondanse, siden denne kommunikasjonen kan kjennetegnes av portnummeret.</para>

      <para>Noen av disse portnumrene  — standardisert av IANA-en (<emphasis>Internet Assigned Numbers Authority</emphasis>) — er "velkjente" for å være knyttet til nettverkstjenester. For eksempel blir TCP-port 25 generelt brukt av e-posttjeneren. <ulink type="block" url="http://www.iana.org/assignments/port-numbers" /></para>
    </sidebar>

    <para>Når et lokalt nettverk bruker et privat adresseområde (ikke rutbare på Internettet), trenger inngangsporten å gjennomføre <emphasis>address masquerading</emphasis> slik at maskinene i nettverket kan kommunisere med omverdenen. Den maskerte operasjon er en slags mellomtjener som opererer på nettverksnivå: hver utgående tilkobling fra en intern maskin er erstattet med en forbindelse fra inngangsporten selv (siden porten har en ekstern, rutbar adresse), dataene går gjennom den maskerte tilkoblingen blir sendt til den nye, og  dataene som kommer tilbake som svar sendes gjennom til den maskerte forbindelsen til den interne maskinen. Inngangsporten bruker en rekke øremerkede TCP-porter til dette formål, vanligvis med meget høye tall (over 60000). Hver tilkobling som kommer fra en intern maskin vises deretter til omverdenen som en forbindelse som kommer fra en av disse reserverte portene.</para>
    <indexterm><primary>masquerading</primary></indexterm>

    <sidebar>
      <title><emphasis>CULTURE</emphasis> Privat adresseområde</title>
      <indexterm><primary>IP address</primary><secondary>private</secondary></indexterm>
      <indexterm><primary>private IP address</primary></indexterm>

      <para>RFC 1918 definerer tre områder for IPv4-adresser som ikke er ment for å bli rutet på Internettet, men bare til bruk i lokale nettverk. Den første, <literal>10.0.0.0/8</literal> (se sidestolpe <xref linkend="sidebar.networking-basics" />), is et A-klasse område (med 2 <superscript>24</superscript>-IP-adresser). Den andre, <literal>172.16.0.0/12</literal>, samler 16 B-klasse områder (<literal>172.16.0.0/16</literal> til <literal>172.31.0.0/16</literal>), hver med 2 <superscript>16</superscript> IP-adresser. Til slutt, <literal>192.168.0.0/16</literal> er et B-klasse-område (som grupperer 256 C-klasse områder, <literal>192.168.0.0/24</literal> til <literal>192.168.255.0/24</literal>, med 256 IP-adresser hver). <ulink type="block" url="http://www.faqs.org/rfcs/rfc1918.html" /></para>
    </sidebar>

    <para>Inngangsporten kan også utføre to typer <emphasis>network address translation</emphasis> (eller i korthet NAT). Den første typen, <emphasis>Destination NAT</emphasis> (DNAT) er en teknikk for å endre IP-adresse-destinasjonen (og/eller TCP eller UDP-porten) til en (vanligvis) innkommende tilkobling. Forbindelsens sporingsmekanisme endrer også følgende pakkene i samme tilknytning for å sikre kontinuitet i kommunikasjonen. Den andre typen NAT er <emphasis>Source NAT</emphasis> (SNAT), der <emphasis>masquerading</emphasis> er et spesielt tilfelle; SNAT endrer kildens IP-adresse (og / eller TCP eller UDP porten) til en (vanligvis) utgående tilkobling. Som for DNAT, er alle pakkene i forbindelsen hensiktsmessig håndtert av forbindelsens sporingsmekanisme. Merk at NAT er kun relevant for IPv4 og dens begrensede adresseområde; i IPv6, reduserer den store tilgjengeligheten av adresser nytten av NAT ved å la alle "interne" adresser være direkte SNAT endrer kilden IP-adresse (og / eller TCP eller UDP port) av en (vanligvis) utgående tilkobling. Som for DNAT, er alle pakkene i den forbindelse hensiktsmessig håndtert av forbindelsen sporingsmekanisme. Merk at NAT er kun relevant for IPv4 og dens begrensede adresseområdet; i IPv6, den store tilgjengeligheten av adresser reduserer nytten av NAT ved å la alle "interne" tar for å være direkte rutes på Internett (dette betyr ikke at interne maskiner er tilgjengelig, siden formidler brannmurer kan filtrere trafikk). på Internettet (dette betyr ikke at interne maskiner er tilgjengelige, siden mellomliggende brannmurer kan filtrere trafikk).</para>
    <indexterm><primary>NAT</primary></indexterm>
    <indexterm><primary>Network</primary><secondary>Address Translation</secondary></indexterm>
    <indexterm><primary>SNAT</primary></indexterm>
    <indexterm><primary>DNAT</primary></indexterm>
    <indexterm><primary>Destination NAT</primary></indexterm>
    <indexterm><primary>Source NAT</primary></indexterm>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Videresendelse av porter</title>
      <indexterm><primary>port forwarding</primary></indexterm>

      <para>En konkret applikasjon hos DNAT er <emphasis>port forwarding</emphasis>. Innkommende tilkoblinger til en gitt port hos en maskin blir videresendt til en port på en annen maskin. Andre løsninger kan oppnå en lignende virkning, men særlig på applikasjonsnivå med <command>ssh</command> (se <xref linkend="sect.ssh-port-forwarding" />) eller <command>redir</command>.</para>
    </sidebar>

    <para>Nok teori, la oss være praktiske. Å snu et Debian-system til en port en så enkel sak som å aktivere det aktuelle valget i Linux-kjernen ved hjelp av <filename>/proc/</filename> virtuelle filsystemet:</para>

    <screen>
<computeroutput># </computeroutput><userinput>echo 1 &gt; /proc/sys/net/ipv4/conf/default/forwarding</userinput>
</screen>

    <para>Dette alternativet kan også aktiveres automatisk ved oppstart hvis <filename>/etc/sysctl.conf</filename> setter  <literal>net.ipv4.conf.default.forwarding</literal>-valget til <literal>1</literal>.</para>

    <example id="example.sysctl.conf">
      <title><filename>/etc/sysctl.conf</filename>-filen</title>

      <programlisting>
net.ipv4.conf.default.forwarding = 1
net.ipv4.conf.default.rp_filter = 1
net.ipv4.tcp_syncookies = 1
</programlisting>
    </example>

    <para>Den samme effekten kan oppnås for IPv6 ved å bytte <literal>ipv4</literal> med <literal>ipv6</literal> i den manuelle kommandoen og bruke <literal>net.ipv6.conf.all.forwarding</literal>-linjen i <filename>/etc/sysctl.conf</filename>.</para>

    <para>Å aktivere IPv4-maskering er en litt mer komplisert operasjon som involverer å konfigurere <emphasis>netfilter</emphasis>-brannmuren.</para>

    <para>Tilsvarende, å bruke NAT (for IPv4), krever konfigureering av <emphasis>netfilter</emphasis>. Siden det primære formålet med denne komponenten er pakkefiltrering, er detaljene oppført i <xref linkend="security" xrefstyle="select: label quotedtitle nopage" /> (se <xref linkend="sect.firewall-packet-filtering" />).</para>
  </section>
  <section id="sect.virtual-private-network">
    <title>Virtuelt Privat Nettverk</title>

    <para>Et <emphasis>Virtual Private Network</emphasis> (VPN for kort) er en måte å koble to forskjellige lokale nettverk via Internett ved hjelp av en tunnel; tunnelen er vanligvis kryptert for konfidensialitet. VPN brukes ofte for å integrere en ekstern maskin i et selskaps lokale nettverk.</para>
    <indexterm><primary>network</primary><secondary>virtual private</secondary></indexterm>
    <indexterm><primary>VPN</primary></indexterm>
    <indexterm><primary>virtual private network</primary></indexterm>

    <para>Flere verktøy har dette. OpenVPN er en effektiv løsning, enkel å implementere og vedlikeholde, basert på SSL/TLS. En annen mulighet er å bruke IPsec for å kryptere IP-trafikk mellom to maskiner; denne krypteringen er gjennomsiktig, hvilket betyr at applikasjoner som kjører på disse vertene ikke behøver modifiseres for å ta hensyn til VPN. SSH kan også brukes for å tilveiebringe en VPN, i tillegg til mer konvensjonelle egenskaper. Endelig kan en VPN etableres ved hjelp av Microsofts PPTP-protokollen. Andre løsninger finnes, men er utenfor siktemålet med denne boken.</para>
    <section id="sect.openvpn">
      <title>OpenVPN</title>
      <indexterm><primary>OpenVPN</primary></indexterm>

      <para>OpenVPN er et stykke programvare med formål å lage virtuelle private nettverk. Oppsettet innebærer å skape virtuelle nettverksgrensesnitt på VPN-tjeneren og på klienten(e); både <literal>tun</literal> (for IP-nivå tunneller) og <literal>tap</literal> (for Ethernet-nivå tunneller) grensesnitt er støttet. I praksis, skal <literal>tun</literal>-grensesnitt oftest brukes unntatt når VPN-klienter er ment til å bli integrert i tjenerens lokale nettverk ved hjelp av en Ethernet-bro.</para>

      <para>OpenVPN avhenger av OpenSSL for all SSL/TLS kryptografi og tilhørende funksjoner (konfidensialitet, autentisering, integritet, ikke-fornekting). Den kan konfigureres enten med en felles privat nøkkel eller ved hjelp av X.509-sertifikater basert på en infrastruktur med fellesnøkler. Sistnevnte konfigurasjonen er sterkt foretrukket fordi den gir større fleksibilitet når den står overfor et økende antall brukere som bruker VPN utenfra.</para>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> SSL og TLS</title>
        <indexterm><primary>SSL</primary></indexterm>
        <indexterm><primary>TLS</primary></indexterm>

	<para>SSL-protokollen (<emphasis>Secure Socket Layer</emphasis>) ble oppfunnet av Netscape for å sikre tilkoblinger til netttjenere. Det ble senere standardisert av IETF under forkortelsen TLS (<emphasis>Transport Layer Security</emphasis>) Siden da har TLS fortsatte utviklingen, og i dag er SSL foreldet fordi det er oppdaget en rekke designfeil.</para>
      </sidebar>
      <section id="sect.easy-rsa">
        <title>Offentlig nøkke-infrastruktur: <emphasis>easy-rsa</emphasis></title>
        <indexterm><primary>PKI (Public Key Infrastructure)</primary></indexterm>
        <indexterm><primary>Public Key Infrastructure</primary></indexterm>
        <indexterm><primary>X.509, certificate</primary></indexterm>
        <indexterm><primary>certificate</primary><secondary>X.509</secondary></indexterm>
        <indexterm><primary><emphasis>easy-rsa</emphasis></primary></indexterm>
        <indexterm><primary>RSA (algorithm)</primary></indexterm>
        <indexterm><primary>key pair</primary></indexterm>

	<para>RSA-algoritmen er mye brukt i offentlig-nøkkel kryptografi. Det innebærer en "nøkkel par", som består av en privat og en offentlig nøkkel. De to nøklene er nært knyttet til hverandre, og deres matematiske egenskaper er slik at en melding som er kryptert med den offentlige nøkkelen kun kan dekrypteres av en person som kjenner den private nøkkelen, noe som sørger for konfidensialitet. I motsatt retning, kan en melding kryptert med den private nøkkelen dekrypteres ved at noen kjenner den offentlige nøkkelen, noe som gjør det mulig å autentisere opprinnelsen til en melding siden bare noen med tilgang til den private nøkkelen kan generere den. Når den er knyttet til en digital nøkkel-funksjon (MD5, SHA1, eller en nyere variant), fører dette til en signaturmekanisme som kan brukes til en hvilken som helst melding.</para>

	<para>Imidlertid kan hvem som helst lage et nøkkelpar, lagre en hvilken som helst identitet på den, og foregir at at detter er den valgte identiteten.  En løsning innebærer konseptet med en <emphasis>Certification Authority</emphasis> (CA), formalisert av X.509-standarden.  Dette konseptet omfatter en enhet som har et pålitelig nøkkelpar kjent som et <emphasis>root certificate</emphasis>. Dette sertifikatet er kun brukt til å signere andre sertifikater (nøkkelpar) etter at riktige skritt er blitt tatt for å sjekke identiteten som er lagret i nøkkelparet. Applikasjoner som bruker X.509 kan da sjekke sertifikatene som blir presentert for dem, hvis de kjenner til de klarerte ette sertifikatet er kun brukt til å signere andre sertifikater (nøkkelpar), etter at riktige tiltak har blitt gjennomført for å sjekke identiteten lagret på nøkkelpar. Applikasjoner ved hjelp av X.509 kan da sjekke sertifikatene presentert for dem, hvis de vet om de klarerte rotsertifikater..</para>

	<para>OpenVPN følger denne regelen. Siden offentlige CAer kun utsteder  sertifikater i bytte for en (heftig) avgift, er det også mulig å opprette en privat sertifiseringsinstans i selskapet. <emphasis role="pkg">easy-rsa</emphasis>-pakken inneholder verktøy for å tjene som en X.509  infrastruktur for sertifisering, implementert som et skriptsett som bruker <command>openssl</command>-kommandoen.</para>

        <sidebar>
          <title><emphasis>NOTE</emphasis> <emphasis>easy-rsa</emphasis> before <emphasis role="distribution">Jessie</emphasis></title>

          <para>I versjoner av Debian opp til <emphasis role="distribution">Wheezy</emphasis>, var <emphasis>easy-rsa</emphasis> distribuert som en dek av <emphasis role="pkg">openvpn</emphasis>-pakken, med skriptene under <filename>/usr/share/doc/openvpn/examples/easy-rsa/2.0/</filename>. Å sette opp en CA omfattet å kopiere den katalogen, i stedet for å bruke <command>make-cadir</command>-kommandoen som dokumentert her.</para>
        </sidebar>

	<para>Falcot Corp-administratorene bruker dette verktøyet for å lage de nødvendige sertifikater, både for serveren og klientene. Dette tillater at konfigurasjonen av alle klienter er lik siden de bare må settes opp til å stole på sertifikater fra Falcots lokale CA. Dette CAet er det første som må lages; til dette formålet, setter administratorene opp en katalog med filene som kreves for CAet på et passende sted, fortrinnsvis på en maskin som ikke er koblet til nettverket for å redusere risikoen for at CAs private nøkkel blir stjålet.</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>make-cadir pki-falcot
</userinput><computeroutput>$ </computeroutput><userinput>cd pki-falcot</userinput>
</screen>

	<para>De lagrer deretter de nødvendige parameterene i <filename>vars</filename>-filen, spesielt de som er navnet med et <literal>KEY_</literal>-prefiks; Disse variablene blir så integrert i miljøet:</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>vim vars
</userinput><computeroutput>$ </computeroutput><userinput>grep KEY_ vars
</userinput><computeroutput>export KEY_CONFIG=`$EASY_RSA/whichopensslcnf $EASY_RSA`
export KEY_DIR="$EASY_RSA/keys"
echo NOTE: If you run ./clean-all, I will be doing a rm -rf on $KEY_DIR
export KEY_SIZE=2048
export KEY_EXPIRE=3650
export KEY_COUNTRY="FR"
export KEY_PROVINCE="Loire"
export KEY_CITY="Saint-Étienne"
export KEY_ORG="Falcot Corp"
export KEY_EMAIL="admin@falcot.com"
export KEY_OU="Certificate authority"
export KEY_NAME="Certificate authority for Falcot Corp"
# If you'd like to sign all keys with the same Common Name, uncomment the KEY_CN export below
# export KEY_CN="CommonName"
$ </computeroutput><userinput>. ./vars
</userinput><computeroutput>NOTE: If you run ./clean-all, I will be doing a rm -rf on /home/roland/pki-falcot/keys
$ </computeroutput><userinput>./clean-all
</userinput>
</screen>

	<para>Det neste trinnet er etableringen av selve CAs nøkkelpar (de to delene av nøkkelparet vil i dette trinnet bli lagret under <filename>keys/ca.crt</filename> og <filename>keys/ca.key</filename>):</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>./build-ca</userinput>
<computeroutput>Generating a 2048 bit RSA private key
...................................................................+++
...+++
writing new private key to 'ca.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [Falcot Corp CA]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:
</computeroutput>
</screen>

	<para>Sertifikatet for VPN-serveren kan nå bli opprettet, så vel som Diffie-Hellman-parameterene som kreves for tjenersiden av en SSL/TLS-tilkobling. VPN-tjeneren er identifisert av sitt DNS-navn <literal>vpn.falcot.com</literal>; dette navnet gjenbrukes for de genererte nøkkelfilerene, (<filename>keys/vpn.falcot.com.crt</filename> for det offentlige sertifikatet, <filename>keys/vpn.falcot.com.key</filename> for den private nøkkelen):</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>./build-key-server vpn.falcot.com
</userinput><computeroutput>Generating a 2048 bit RSA private key
.....................................................................................................................+++
...........+++
writing new private key to 'vpn.falcot.com.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [vpn.falcot.com]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
Using configuration from /home/roland/pki-falcot/openssl-1.0.0.cnf
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
countryName           :PRINTABLE:'FR'
stateOrProvinceName   :PRINTABLE:'Loire'
localityName          :T61STRING:'Saint-\0xFFFFFFC3\0xFFFFFF89tienne'
organizationName      :PRINTABLE:'Falcot Corp'
organizationalUnitName:PRINTABLE:'Certificate authority'
commonName            :PRINTABLE:'vpn.falcot.com'
name                  :PRINTABLE:'Certificate authority for Falcot Corp'
emailAddress          :IA5STRING:'admin@falcot.com'
Certificate is to be certified until Mar  6 14:54:56 2025 GMT (3650 days)
Sign the certificate? [y/n]:</computeroutput><userinput>y
</userinput><computeroutput>

1 out of 1 certificate requests certified, commit? [y/n]</computeroutput><userinput>y
</userinput><computeroutput>Write out database with 1 new entries
Data Base Updated
$ </computeroutput><userinput>./build-dh
</userinput><computeroutput>Generating DH parameters, 2048 bit long safe prime, generator 2
This is going to take a long time
[…]
</computeroutput>
</screen>

	<para>Det neste trinnet oppretter sertifikater for VPN-klienter; ett sertifikat kreves for hver datamaskin eller person som får lov å bruke VPNen:</para>

        <screen>
<computeroutput>$ </computeroutput><userinput>./build-key JoeSmith
</userinput><computeroutput>Generating a 2048 bit RSA private key
................................+++
..............................................+++
writing new private key to 'JoeSmith.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:</computeroutput><userinput>Development unit
</userinput><computeroutput>Common Name (eg, your name or your server's hostname) [JoeSmith]:</computeroutput><userinput>Joe Smith
</userinput><computeroutput>[…]</computeroutput></screen>

	<para>Nå er alle sertifikater blitt opprettet, of de trenger å bli kopiert når det må til: rotsertifikatets offentlige nøkke(<filename>keys/ca.crt</filename>) vil bli lagret på alle maskiner (både server og klienter) som <filename>/etc/ssl/certs/Falcot_CA.crt</filename>. 
Tjenerens sertifikat er bare installert på tjeneren (<filename>keys/vpn.falcot.com.crt</filename> går til <filename>/etc/ssl/vpn.falcot.com.crt</filename>, og  <filename>keys/vpn.falcot.com.key</filename> går til <filename>/etc/ssl/private/vpn.falcot.com.key</filename> med begrensede tillatelser slik at bare administratoren kan lese den), med tilhørende Diffie-Hellman-parametre (<filename>keys/dh2048.pem</filename>) installert til  <filename>/etc/openvpn/dh2048.pem</filename>. Klientsertifikater blir installert på den tilsvarende VPN-klienten på en lignende måte.</para>
      </section>
      <section>
        <title>Å konfigurere OpenVPN-tjeneren</title>

	<para>Som standard, forsøker OpenVPN-initialiseringskript å starte alle virtuelle private nettverk som er definert i <filename>/etc/openvpn/*.conf</filename>. Å sette opp en VPN-tjener er derfor et spørsmål om å lagre en tilsvarende konfigurasjonsfil i denne katalogen. Et godt utgangspunkt er <filename>/usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz</filename>, som leder til en temmelig standard tjener. Selvfølgelig, må noen parametere tilpasses: <literal>ca</literal>, <literal>cert</literal>, <literal>key</literal> og <literal>dh</literal> må  beskrive de valgte stedene (henholdsvis <literal>/etc/ssl/certs/Falcot_CA.crt</literal>, <literal>/etc/ssl/vpn.falcot.com.crt</literal>, <literal>/etc/ssl/private/vpn.falcot.com.key</literal> and <literal>/etc/openvpn/dh2048.pem</literal>). <literal>server 10.8.0.0 255.255.255.0</literal>-direktivet definerer subnettet som skal brukes av VPN; tjeneren bruker den første IP-adressen i dette området (<literal>10.8.0.1</literal>) og resten av adressene er reservert for klienter.</para>

	<para>Med denne konfigurasjonen, lager oppstarten av OpenVPN det virtuelle nettverksgrensesnittet, vanligvis med <literal>tun0</literal>-navnet. 
Imidlertid er brannmurer ofte konfigurert på samme tid som det virkelige nettverksgrensesnittet, og skjer før OpenVPN starter. En god praksis er  derfor å lage et varig virtuelt nettverksgrensesnitt, og konfigurere OpenVPN til å bruke dette varige grensesnittet. Dette tillater videre å velge navnet til dette grensesnittet. For dette formål lager <command>openvpn --mktun --dev vpn --dev-type tun</command> et virtuelt nettverkbrukergrensesnitt med navnet <literal>vpn</literal> med type <literal>tun</literal>; denne kommandoen kan enkelt legges inn i brannmur-konfigurasjonens skript eller i et <literal>up</literal>-direktiv i  <filename>/etc/network/interfaces</filename>-filen. OpenVPN-konfigurasjonsfilen må også oppdateres tilsvarende, med <literal>dev vpn</literal> og <literal>dev-type tun</literal>-direktiver.</para>

	<para>For å sperre ytterligere virksomhet, kan VPN-klienter kun få tilgang til selve VPN-tjeneren ved hjelp av <literal>10.8.0.1</literal>adressen. Å gi klientene tilgang til det lokale nettverket (192.168.0.0/24), krever at en legger til et <literal>push route 192.168.0.0 255.255.255.0</literal>-direktiv til OpenVPN konfigurasjonen slik at VPN-klienter automatisk får en nettverkrute som forteller dem at dette nettverket kan nås ved hjelp av VPN. Videre, maskiner på det lokale nettverket må også informeres om at ruten til VPN går gjennom VPN-tjeneren (dette fungerer automatisk når VPN-serveren er installert i porten). Alternativt kan VPN-serveren konfigureres til å utføre IP-maskering, slik at tilkoblinger fra VPN-klienter ser ut som om de kommer fra VPN-tjeneren i stedet (se <xref linkend="sect.gateway" />).</para>
      </section>
      <section>
        <title>Å konfigurere OpenVPN-klienten</title>

	<para>Å sette opp en OpenVPN klient krever også at en lager en konfigurasjonsfil <filename>/etc/openvpn/</filename>. En standardkonfigurasjon kan fås ved å bruke <filename>/usr/share/doc/openvpn/examples/sample-config-files/client.conf</filename> som et startpunkt. <literal>remote vpn.falcot.com 1194</literal>-direktivet beskriver adressen og porten til OpenVPN-tjeneren; <literal>ca</literal>, <literal>cert</literal> og <literal>key</literal> må også tilpasses til å beskrive plasseringen av de viktigste filene.</para>

	<para>Hvis VPN ikke skal startes automatisk ved oppstart, sett <literal>AUTOSTART</literal>-direktivet til <literal>none</literal> i <filename>/etc/default/openvpn</filename>-filen. Å sstarte eller stoppe en gitt VPN-forbindelse er alltid mulig med kommandoene <command>service openvpn@<replaceable>name</replaceable> start</command> og <command>service openvpn@<replaceable>name</replaceable> stop</command> (der forbindelsen <replaceable>name</replaceable> sammenfaller med en som er definert i <filename>/etc/openvpn/<replaceable>name</replaceable>.conf</filename>).</para>

	<para><emphasis role="pkg">network-manager-openvpn-gnome</emphasis>-pakken inneholder en forlengelse til Network Manager (se <xref linkend="sect.roaming-network-config" />) som tillater håndtering av  OpenVPN virtueller private nettverk. Det tillater hver bruker å sette opp  OpenVPN-tilkoblinger grafisk og styre dem fra nettverksadministrasjons-ikonet. <indexterm><primary><emphasis role="pkg">network-manager-openvpn-gnome</emphasis></primary></indexterm></para>
      </section>
    </section>
    <section id="sect.ssh-vpn">
      <title>Virtuelt privat nettverk med SSH</title>
      <indexterm><primary>SSH</primary></indexterm>
      <indexterm><primary>PPP</primary></indexterm>

      <para>Det er faktisk to måter å lage et virtuelt privat nettverk ved hjelp av SSH. Den historiske innebærer å etablere et PPP-lag over SSH-linken. Denne metoden er beskrevet i et HOWTO-dokument: <ulink type="block" url="http://www.tldp.org/HOWTO/ppp-ssh/" /></para>

      <para>Den andre metoden er av nyere dato, og ble introdusert med OpenSSH 4.3; Det er nå mulig for OpenSSH å opprette virtuelle nettverksgrensesnitt (<literal>tun*</literal>) på begge sider av en SSH-tilkobling, og disse virtuelle grensesnitt kan konfigureres akkurat som om de var fysiske grensesnitt. Tunnelsystemet må først aktiveres ved å sette <literal>PermitTunnel</literal> til “yes” i SSH-tjenerens konfigureringsfil (<filename>/etc/ssh/sshd_config</filename>). Når SSH-tilkoblingen etableres, må det eksplisitt bes om at det lages en tunnel med <literal>-w any:any</literal> valget (<literal>any</literal> kan erstattes med det ønskede <literal>tun</literal> enhetsnummeret). Dette krever at brukeren har administratorprivilegium på begge sider, for å kunne lage nettverksenheten (med andre ord, må forbindelsen etableres som rot).</para>

      <para>Begge måter til å opprette et virtuelt privat nettverk over SSH er ganske greie. Men VPN-en er ikke den mest effektivt tilgjengelige; særlig håndterer den ikke høye trafikknivåer godt.</para>

      <para>Forklaringen er at når en TCP/IP-stakk er innkapslet innenfor en TCP/IP-tilkobling (for SSH), er TCP-protokollen brukt to ganger, en gang for SSH-tilkoblingen og en gang inne i tunnelen. Dette fører til problemer, særlig på grunn av måten TCP tilpasser seg til  nettverksforholdene ved å endre forsinkelser ved tidsavbrudd. Følgende nettsted beskriver problemet i mer detalj:<ulink type="block" url="http://sites.inka.de/sites/bigred/devel/tcp-tcp.html" /> VPNs over SSH bør derfor begrenses til engangstunneler uten ytelsespress.</para>
    </section>
    <section id="sect.ipsec">
      <title>IPsec</title>
      <indexterm><primary>IPsec</primary></indexterm>
      <indexterm><primary><command>strongswan</command></primary></indexterm>
      <indexterm><primary><command>racoon</command></primary></indexterm>

      <para>Til tross for å være standard i IP VPN, er IPsec snarere mer involvert i implementeringen. IPsec-motoren er selv integrert i Linux-kjernen; de nødvendige bruker-plass deler, kontroll- og konfigurasjonsverktøyet, gis av <emphasis role="pkg">ipsec-tools</emphasis>-pakken. Helt konkret inneholder hver vert <filename>/etc/ipsec-tools.conf</filename> parametrene for <emphasis>IPsec tunnels</emphasis> (eller <emphasis>Security Associations</emphasis>, i IPsec terminologien) som angår verten; <command>/etc/init.d/setkey</command>-skriptene gir en måte å starte og stoppe en tunnel (hver tunnel er en sikker kobling til en annen vert koblet til det virtuelle private nettverket). Denne filen kan bygges for hånd fra dokumentasjonen som følger med manualsiden <citerefentry><refentrytitle>setkey</refentrytitle> <manvolnum>8</manvolnum></citerefentry>. 
Imidlertid, å eksplisitt skriver parametrene for alle verter i et ikke-vanlig  sett maskiner, blir fort en krevende oppgave, fordi antall tunneler vokser hurtig. Å installere en IKE-nisse (for <emphasis>IPsec Key Exchange</emphasis>) slik som <emphasis role="pkg">racoon</emphasis> eller <emphasis role="pkg">strongswan</emphasis> gjør prosessen mye enklere ved å bringe administrasjon sammen på et sentralt punkt, og sikrere ved å rotere nøklene med jevne mellomrom.</para>
      <indexterm><primary>IKE</primary></indexterm>
      <indexterm><primary>IPsec</primary><secondary>IPsec Key Exchange</secondary></indexterm>
      <indexterm><primary>key pair</primary></indexterm>
      <indexterm><primary><command>setkey</command></primary></indexterm>

      <para>På tross av sin status som referansen, kompleksiteten ved å sette opp IPsec begrenser bruken i praksis. OpenVPN-baserte løsninger vil vanligvis bli foretrukket når de nødvendige tunnelene verken er for mange eller for dynamiske.</para>

      <sidebar>
        <title><emphasis>CAUTION</emphasis> IPsec og NAT</title>

	<para>NAT brannmurer og IPsec fungerer ikke godt sammen: Ettersom IPsec signerer pakker, vil eventuelle forandringer for disse pakkene som brannmuren måtte utføre, oppheve signaturen, og pakkene vil bli avvist ved bestemmelsesstedet. Ulike IPsec implementasjoner inkluderer nå <emphasis>NAT-T</emphasis>-teknikk (for <emphasis>NAT Traversal</emphasis>), som i utgangspunktet innkapsler IPsec-pakken innenfor en standard UDP-pakke.</para>
        <indexterm><primary>NAT-T</primary></indexterm>
        <indexterm><primary>NAT Traversal</primary></indexterm>
      </sidebar>

      <sidebar>
        <title><emphasis>SECURITY</emphasis> IPsec og brannmurer</title>

	<para>Standardmoduset for drift av IPsec innebærer datautveksling på UDP port 500 for nøkkelutveksling (også på UDP port 4500 i tilfelle NAT-T er i bruk). Videre, bruker IPsec-pakker to øremerkede IP-protokoller som brannmuren må slippe igjennom; Mottakelse av disse pakkene er basert på protokollnummeret deres, 50 (ESP) og 51 (AH).</para>
        <indexterm><primary>ESP, protocol</primary></indexterm>
        <indexterm><primary>AH, protocol</primary></indexterm>
        <indexterm><primary>protocol</primary><secondary>AH</secondary></indexterm>
        <indexterm><primary>protocol</primary><secondary>ESP</secondary></indexterm>
      </sidebar>
    </section>
    <section id="sect.pptp">
      <title>PPTP</title>

      <para>PPTP (for <emphasis>Point-to-Point Tunneling Protocol</emphasis>) bruker to kommunikasjonskanaler, en for styringsdata og en for nyttelastdata; Sistnevnte bruker GRE-protokollen (<emphasis>Generic Routing Encapsulation</emphasis>). En standard PPP-lenke blir da satt opp over datautvekslingskanalen.</para>
      <indexterm><primary>PPTP</primary></indexterm>
      <indexterm><primary>Point-to-Point Tunneling Protocol</primary></indexterm>
      <indexterm><primary>GRE, protocol</primary></indexterm>
      <indexterm><primary>protocol</primary><secondary>GRE</secondary></indexterm>
      <section id="sect.pptp-config-client">
        <title>Å sette opp klienten</title>

	<para><emphasis role="pkg">pptp-linux</emphasis>-pakken inneholder en lett konfigurerbar PPTP-klient for Linux. Følgende instruksjoner er inspirert fra den offisielle dokumentasjonen: <ulink type="block" url="http://pptpclient.sourceforge.net/howto-debian.phtml" /></para>
        <indexterm><primary><emphasis role="pkg">pptp-linux</emphasis></primary></indexterm>

	<para>Falcot-administratorene laget flere filer: <filename>/etc/ppp/options.pptp</filename>, <filename>/etc/ppp/peers/falcot</filename>, <filename>/etc/ppp/ip-up.d/falcot</filename>, og <filename>/etc/ppp/ip-down.d/falcot</filename>.</para>

        <example id="example.ppp-options.pptp">
          <title><filename>/etc/ppp/options.pptp</filename> filen</title>

          <programlisting>
# PPP options used for a PPTP connection
lock
noauth
nobsdcomp
nodeflate
</programlisting>
        </example>

        <example id="example.ppp-peers-falcot">
          <title><filename>/etc/ppp/peers/falcot</filename> filen</title>

          <programlisting>
# vpn.falcot.com is the PPTP server
pty "pptp vpn.falcot.com --nolaunchpppd"
# the connection will identify as the "vpn" user
user vpn
remotename pptp
# encryption is needed
require-mppe-128
file /etc/ppp/options.pptp
ipparam falcot
</programlisting>
        </example>

        <example id="example.ppp-ip-up.d-falcot">
          <title><filename>/etc/ppp/ip-up.d/falcot</filename>-filen</title>

          <programlisting>
# Create the route to the Falcot network
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 is the (remote) Falcot network
  route add -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi
</programlisting>
        </example>

        <example id="example.ppp-ip-down.d-falcot">
          <title><filename>/etc/ppp/ip-down.d/falcot</filename>-filen</title>

          <programlisting>
# Delete the route to the Falcot network
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 is the (remote) Falcot network
  route del -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi
</programlisting>
        </example>

        <sidebar>
          <title><emphasis>SECURITY</emphasis> MPPE</title>

	  <para>Å sikre PPTP innebærer å bruke MPPE-funksjonen  (<emphasis>Microsoft Point-to-Point Encryption</emphasis>), som er tilgjengelig som en modul i offisielle Debian-kjerner.</para>
          <indexterm><primary>MPPE</primary></indexterm>
          <indexterm><primary>Microsoft</primary><secondary>Point-to-Point Encryption</secondary></indexterm>
        </sidebar>
      </section>
      <section id="sect.pptp-config-serveur">
        <title>Å sette opp tjeneren</title>

        <sidebar>
          <title><emphasis>CAUTION</emphasis> PPTP og brannmurer</title>

	  <para>Mellomliggende brannmurer må konfigureres til å slippe gjennom IP-pakker som bruker protokollen 47 (GRE). Videre må PPTP tjenerport 1723 være åpen, slik at kommunikasjonskanalen virker.</para>
        </sidebar>

	<para><command>pptpd</command> er PPTP-tjeneren for Linux. Hovedkonfigurasjonsfilen <filename>/etc/pptpd.conf</filename>, krever svært få endringer: <emphasis>localip</emphasis> (lokal IP-adresse) og <emphasis>remoteip</emphasis> (ekstern IP-adresse). I eksempelet nedenfor, bruker PPTP-tjeneren alltid <literal>192.168.0.199</literal>-adressen, og PPTP-klienter mottar IP-adresser fra <literal>192.168.0.200</literal> til <literal>192.168.0.250</literal>.</para>

        <example id="example.pptpd.conf">
          <title><filename>/etc/pptpd.conf</filename>-filen</title>

          <programlisting>
# TAG: speed
#
#       Specifies the speed for the PPP daemon to talk at.
#
speed 115200

# TAG: option
#
#       Specifies the location of the PPP options file.
#       By default PPP looks in '/etc/ppp/options'
#
option /etc/ppp/pptpd-options

# TAG: debug
#
#       Turns on (more) debugging to syslog
#
# debug

# TAG: localip
# TAG: remoteip
#
#       Specifies the local and remote IP address ranges.
#
#       You can specify single IP addresses separated by commas or you can
#       specify ranges, or both. For example:
#
#               192.168.0.234,192.168.0.245-249,192.168.0.254
#
#       IMPORTANT RESTRICTIONS:
#
#       1. No spaces are permitted between commas or within addresses.
#
#       2. If you give more IP addresses than MAX_CONNECTIONS, it will
#          start at the beginning of the list and go until it gets
#          MAX_CONNECTIONS IPs. Others will be ignored.
#
#       3. No shortcuts in ranges! ie. 234-8 does not mean 234 to 238,
#          you must type 234-238 if you mean this.
#
#       4. If you give a single localIP, that's ok - all local IPs will
#          be set to the given one. You MUST still give at least one remote
#          IP for each simultaneous client.
#
#localip 192.168.0.234-238,192.168.0.245
#remoteip 192.168.1.234-238,192.168.1.245
#localip 10.0.1.1
#remoteip 10.0.1.2-100
localip 192.168.0.199
remoteip 192.168.0.200-250
</programlisting>
        </example>

	<para>OPS-konfigurasjon brukes av PPTP-tjeneren krever også noen endringer i <filename>/etc/ppp/pptpd-options</filename>. Den viktige  parameteren er tjenernavnet (<literal>pptp</literal>), domenenavnet (<literal>falcot.com</literal>), og IP-adressene for DNS og WINS-tjenere.</para>

        <example id="example.ppp-pptpd-options">
          <title>The <filename>/etc/ppp/pptpd-options</filename>-filen</title>

          <programlisting>
## turn pppd syslog debugging on
#debug

## change 'servername' to whatever you specify as your server name in chap-secrets
name pptp
## change the domainname to your local domain
domain falcot.com

## these are reasonable defaults for WinXXXX clients
## for the security related settings
# The Debian pppd package now supports both MSCHAP and MPPE, so enable them
# here. Please note that the kernel support for MPPE must also be present!
auth
require-chap
require-mschap
require-mschap-v2
require-mppe-128

## Fill in your addresses
ms-dns 192.168.0.1
ms-wins 192.168.0.1

## Fill in your netmask
netmask 255.255.255.0

## some defaults
nodefaultroute
proxyarp
lock
</programlisting>
        </example>

	<para>Det siste trinnet innebærer registrering av <literal>vpn</literal>-brukeren (og tilhørende passord) i <filename>/etc/ppp/chap-secrets</filename>-filen. I motsetning til andre tilfeller hvor en asterisk (<literal>*</literal>) ville fungere, må tjenernavnet fylles inn eksplisitt her. Videre identifiserer Windows PPTP-klienter seg med <literal><replaceable>DOMAIN</replaceable>\\<replaceable>USER</replaceable></literal>-formen, i stedet for bare å gi et brukernavn. Dette forklarer hvorfor filen også nevner <literal>FALCOT\\vpn</literal>-brukeren. Det er også mulig å spesifisere individuelle IP-adresser for brukere; En stjerne i dette felt angir at dynamisk adressering skal brukes.</para>

        <example id="example.ppp-chap-secrets">
          <title><filename>/etc/ppp/chap-secrets</filename>-filen</title>

          <programlisting>
# Secrets for authentication using CHAP
# client        server  secret      IP addresses
vpn             pptp    f@Lc3au     *
FALCOT\\vpn     pptp    f@Lc3au     *
</programlisting>
        </example>

        <sidebar>
          <title><emphasis>SECURITY</emphasis> PPTP sårbarheter</title>

	  <para>Microsofts første PPTP-implementering fikk sterk kritikk fordi den hadde mange sikkerhetsproblemer; Siden er de fleste fikset i og med nyere versjoner. Konfigurasjonen som er dokumentert i denne seksjonen
bruker den nyeste versjonen av protokollen. Vær klar over at å fjerne noen av alternativene (for eksempel <literal>require-mppe-128</literal> og <literal>require-mschap-v2</literal>) vil gjøre tjenesten sårbar igjen.</para>
        </sidebar>
      </section>
    </section>
  </section>
  <section id="sect.quality-of-service">
    <title>Tjenestekvalitet</title>
    <section id="sect.qos-principe">
      <title>Prinsipp og mekanisme</title>

      <para><emphasis>Quality of Service</emphasis> (or
      <emphasis>QoS</emphasis> for short) refers to a set of techniques
      that guarantee or improve the quality of the service provided to
      applications. The most popular such technique involves classifying
      the network traffic into categories, and differentiating the handling
      of traffic according to which category it belongs to. The main
      application of this differentiated services concept is
      <emphasis>traffic shaping</emphasis>, which limits the data
      transmission rates for connections related to some services and/or
      hosts so as not to saturate the available bandwidth and starve
      important other services. Traffic shaping is a particularly good fit
      for TCP traffic, since this protocol automatically adapts to
      available bandwidth.</para>
      <indexterm><primary>QoS</primary></indexterm>
      <indexterm><primary>quality of service</primary></indexterm>
      <indexterm><primary>quality</primary><secondary>of service</secondary></indexterm>
      <indexterm><primary>service</primary><secondary>quality</secondary></indexterm>

      <para>It is also possible to alter the priorities on traffic, which
      allows prioritizing packets related to interactive services (such as
      <command>ssh</command> and <command>telnet</command>) or to services
      that only deal with small blocks of data.</para>

      <para>The Debian kernels include the features required for QoS along
      with their associated modules. These modules are many, and each of
      them provides a different service, most notably by way of special
      schedulers for the queues of IP packets; the wide range of available
      scheduler behaviors spans the whole range of possible
      requirements.</para>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> LARTC — <emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis></title>

	<para>The <emphasis>Linux Advanced Routing &amp; Traffic
	Control</emphasis> HOWTO is the reference document covering
	everything there is to know about network quality of service.
	<ulink type="block" url="http://www.lartc.org/howto/" /></para>
        <indexterm><primary>routing</primary><secondary>advanced</secondary></indexterm>
        <indexterm><primary>traffic</primary><secondary>control</secondary></indexterm>
        <indexterm><primary>control of traffic</primary></indexterm>
      </sidebar>
    </section>
    <section id="sect.qos-config">
      <title>Configuring and Implementing</title>

      <para>QoS parameters are set through the <command>tc</command>
      command (provided by the <emphasis role="pkg">iproute</emphasis>
      package). Since its interface is quite complex, using higher-level
      tools is recommended.</para>
      <indexterm><primary><emphasis>iproute</emphasis></primary></indexterm>
      <indexterm><primary><command>tc</command></primary></indexterm>
      <section id="sect.qos-wondershaper">
        <title>Reducing Latencies: <command>wondershaper</command></title>

	<para>The main purpose of <command>wondershaper</command> (in the
	similarly-named package) is to minimize latencies independent of
	network load. This is achieved by limiting total traffic to a value
	that falls just short of the link saturation value.</para>
        <indexterm><primary><command>wondershaper</command></primary></indexterm>
        <indexterm><primary>limitation of traffic</primary></indexterm>
        <indexterm><primary>traffic</primary><secondary>limitation</secondary></indexterm>

	<para>Once a network interface is configured, setting up this
	traffic limitation is achieved by running <command>wondershaper
	<replaceable>interface</replaceable>
	<replaceable>download_rate</replaceable>
	<replaceable>upload_rate</replaceable></command>. The interface can
	be <literal>eth0</literal> or <literal>ppp0</literal> for example,
	and both rates are expressed in kilobits per second. The
	<command>wondershaper remove
	<replaceable>interface</replaceable></command> command disables
	traffic control on the specified interface.</para>

	<para>For an Ethernet connection, this script is best called right
	after the interface is configured. This is done by adding
	<literal>up</literal> and <literal>down</literal> directives to the
	<filename>/etc/network/interfaces</filename> file allowing declared
	commands to be run, respectively, after the interface is configured
	and before it is deconfigured. For example:</para>

        <example id="example.network-interfaces">
          <title>Changes in the <filename>/etc/network/interfaces</filename> file</title>

          <programlisting>
iface eth0 inet dhcp
    up /sbin/wondershaper eth0 500 100
    down /sbin/wondershaper remove eth0
</programlisting>
        </example>

	<para>In the PPP case, creating a script that calls
	<command>wondershaper</command> in
	<filename>/etc/ppp/ip-up.d/</filename> will enable traffic control
	as soon as the connection is up.</para>

        <sidebar>
          <title><emphasis>GOING FURTHER</emphasis> Optimal configuration</title>

	  <para>The
	  <filename>/usr/share/doc/wondershaper/README.Debian.gz</filename>
	  file describes, in some detail, the configuration method
	  recommended by the package maintainer. In particular, it advises
	  measuring the download and upload speeds so as to best evaluate
	  real limits.</para>
        </sidebar>
      </section>
      <section id="sect.qos-config-standard">
        <title>Standard Configuration</title>

	<para>Barring a specific QoS configuration, the Linux kernel uses
	the <literal>pfifo_fast</literal> queue scheduler, which provides a
	few interesting features by itself. The priority of each processed
	IP packet is based on the ToS field (<emphasis>Type of
	Service</emphasis>) of this packet; modifying this field is enough
	to take advantage of the scheduling features. There are five
	possible values:</para>
        <itemizedlist>
          <listitem>
	    <para>Normal-Service (0);</para>
          </listitem>
          <listitem>
	    <para>Minimize-Cost (2);</para>
          </listitem>
          <listitem>
	    <para>Maximize-Reliability (4);</para>
          </listitem>
          <listitem>
	    <para>Maximize-Throughput (8);</para>
          </listitem>
          <listitem>
	    <para>Minimize-Delay (16).</para>
          </listitem>
        </itemizedlist>
        <indexterm><primary>ToS</primary></indexterm>
        <indexterm><primary>Type of Service</primary></indexterm>

	<para>The ToS field can be set by applications that generate IP
	packets, or modified on the fly by <emphasis>netfilter</emphasis>.
	The following rules are sufficient to increase responsiveness for a
	server's SSH service:</para>

        <programlisting role="scale">
iptables -t mangle -A PREROUTING -p tcp --sport ssh -j TOS --set-tos Minimize-Delay
iptables -t mangle -A PREROUTING -p tcp --dport ssh -j TOS --set-tos Minimize-Delay
</programlisting>
      </section>
    </section>
  </section>
  <section id="sect.dynamic-routing">
    <title>Dynamic Routing</title>
    <indexterm><primary>routing</primary><secondary>dynamic</secondary></indexterm>
    <indexterm><primary><command>quagga</command></primary></indexterm>
    <indexterm><primary><command>zebra</command></primary></indexterm>

    <para>The reference tool for dynamic routing is currently
    <command>quagga</command>, from the similarly-named package; it used to
    be <command>zebra</command> until development of the latter stopped.
    However, <command>quagga</command> kept the names of the programs for
    compatibility reasons which explains the <command>zebra</command>
    commands below.</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> Dynamic routing</title>

      <para>Dynamic routing allows routers to adjust, in real time, the
      paths used for transmitting IP packets. Each protocol involves its
      own method of defining routes (shortest path, use routes advertised
      by peers, and so on).</para>

      <para>In the Linux kernel, a route links a network device to a set of
      machines that can be reached through this device. The
      <command>route</command> command defines new routes and displays
      existing ones.</para>
      <indexterm><primary><command>route</command></primary></indexterm>
    </sidebar>

    <para>Quagga is a set of daemons cooperating to define the routing
    tables to be used by the Linux kernel; each routing protocol (most
    notably BGP, OSPF and RIP) provides its own daemon. The
    <command>zebra</command> daemon collects information from other daemons
    and handles static routing tables accordingly. The other daemons are
    known as <command>bgpd</command>, <command>ospfd</command>,
    <command>ospf6d</command>, <command>ripd</command>, 
    <command>ripngd</command>, <command>isisd</command>, and
    <command>babeld</command>.</para>
    <indexterm><primary>OSPF</primary></indexterm>
    <indexterm><primary>BGP</primary></indexterm>
    <indexterm><primary>RIP</primary></indexterm>
    <indexterm><primary>IS-IS</primary></indexterm>
    <indexterm><primary>BABEL wireless mesh routing</primary></indexterm>
    <indexterm><primary><command>bgpd</command></primary></indexterm>
    <indexterm><primary><command>ospfd</command></primary></indexterm>
    <indexterm><primary><command>ospf6d</command></primary></indexterm>
    <indexterm><primary><command>ripd</command></primary></indexterm>
    <indexterm><primary><command>ripngd</command></primary></indexterm>
    <indexterm><primary><command>isisd</command></primary></indexterm>
    <indexterm><primary><command>babeld</command></primary></indexterm>

    <para>Daemons are enabled by editing the
    <filename>/etc/quagga/daemons</filename> file and creating the
    appropriate configuration file in <filename>/etc/quagga/</filename>;
    this configuration file must be named after the daemon, with a
    <filename>.conf</filename> extension, and belong to the
    <literal>quagga</literal> user and the <literal>quaggavty</literal>
    group, in order for the <filename>/etc/init.d/quagga</filename> script
    to invoke the daemon.</para>

    <para>The configuration of each of these daemons requires knowledge of
    the routing protocol in question. These protocols cannot be described
    in detail here, but the <emphasis role="pkg">quagga-doc</emphasis>
    provides ample explanation in the form of an <command>info</command>
    file. The same contents may be more easily browsed as HTML on the
    Quagga website: <ulink type="block" url="http://www.nongnu.org/quagga/docs/docs-info.html" /></para>

    <para>In addition, the
    syntax is very close to a standard router's configuration interface,
    and network administrators will adapt quickly to
    <command>quagga</command>.</para>

    <sidebar>
      <title><emphasis>IN PRACTICE</emphasis> OSPF, BGP or RIP?</title>

      <para>OSPF is generally the best protocol to use for dynamic routing
      on private networks, but BGP is more common for Internet-wide
      routing. RIP is rather ancient, and hardly used anymore.</para>
    </sidebar>
  </section>
  <section id="sect.ipv6">
    <title>IPv6</title>

    <para>IPv6, successor to IPv4, is a new version of the IP protocol
    designed to fix its flaws, most notably the scarcity of available IP
    addresses. This protocol handles the network layer; its purpose is to
    provide a way to address machines, to convey data to their intended
    destination, and to handle data fragmentation if needed (in other
    words, to split packets into chunks with a size that depends on the
    network links to be used on the path and to reassemble the chunks in
    their proper order on arrival).</para>

    <para>Debian kernels include IPv6 handling in the core kernel (with
    the exception of some architectures that have it compiled as a module
    named <literal>ipv6</literal>). Basic tools such as <command>ping</command> and
    <command>traceroute</command> have their IPv6 equivalents in
    <command>ping6</command> and <command>traceroute6</command>, available
    respectively in the <emphasis role="pkg">iputils-ping</emphasis> and
    <emphasis role="pkg">iputils-tracepath</emphasis> packages.</para>
    <indexterm><primary>IPv6</primary></indexterm>
    <indexterm><primary><emphasis role="pkg">iputils-ping</emphasis></primary></indexterm>
    <indexterm><primary><emphasis role="pkg">iputils-tracepath</emphasis></primary></indexterm>

    <para>The IPv6 network is configured similarly to IPv4, in
    <filename>/etc/network/interfaces</filename>. But if you want that
    network to be globally available, you must ensure that you have an
    IPv6-capable router relaying traffic to the global IPv6 network.</para>

    <example id="example.network-interfaces-ipv6">
      <title>Example of IPv6 configuration</title>

      <programlisting>
iface eth0 inet6 static
    address 2001:db8:1234:5::1:1
    netmask 64
    # Disabling auto-configuration
    # autoconf 0
    # The router is auto-configured and has no fixed address
    # (accept_ra 1). If it had:
    # gateway 2001:db8:1234:5::1
</programlisting>
    </example>

    <para>IPv6 subnets usually have a netmask of 64 bits. This means that
    2<superscript>64</superscript> distinct addresses exist within the
    subnet. This allows Stateless Address Autoconfiguration
    (<acronym>SLAAC</acronym>) to pick an address based on the
    network interface's MAC address. By default, if <acronym>SLAAC</acronym>
    is activated in your network and IPv6 on your computer, the kernel will
    automatically find IPv6 routers and configure the network
    interfaces.</para>

    <para>This behavior may have privacy implications. If you switch
    networks frequently, e.g. with a laptop, you might not want your
    <acronym>MAC</acronym> address being a part of your public IPv6
    address. This makes it easy to identify the same device across
    networks. A solution to this are IPv6 privacy extensions (which Debian
    enables by default if IPv6 connectivity is detected during initial
    installation), which will assign an additional randomly generated
    address to the interface,
    periodically change them and prefer them for outgoing connections.
    Incoming connections can still use the address generated by SLAAC.
    The following example, for use in
    <filename>/etc/network/interfaces</filename>, activates these
    privacy extensions.</para>

    <example id="example.network-interface-ipv6-privext">
      <title>IPv6 privacy extensions</title>

      <programlisting>
iface eth0 inet6 auto
    # Prefer the randomly assigned addresses for outgoing connections.
    privext 2
</programlisting>
    </example>

    <sidebar>
      <title><emphasis>TIP</emphasis> Programs built with IPv6</title>

      <para>Many pieces of software need to be adapted to handle IPv6. Most
      of the packages in Debian have been adapted already, but
      not all. If your favorite package does not work with IPv6
      yet, you can ask for help on the <emphasis>debian-ipv6</emphasis>
      mailing-list. They might know about an IPv6-aware replacement
      and could file a bug to get the issue properly tracked.
      <ulink type="block" url="http://lists.debian.org/debian-ipv6/" /></para>
    </sidebar>

    <indexterm><primary>IPv6 firewall</primary></indexterm>
    <indexterm><primary>firewall</primary><secondary>IPv6</secondary></indexterm>
    <indexterm><primary><command>ip6tables</command></primary></indexterm>
    <para>
    IPv6 connections can be restricted, in the same fashion as for IPv4:
    the standard Debian kernels include an adaptation of
    <emphasis>netfilter</emphasis> for IPv6. This IPv6-enabled
    <emphasis>netfilter</emphasis> is configured in a similar fashion to
    its IPv4 counterpart, except the program to use is
    <command>ip6tables</command> instead of
    <command>iptables</command>.</para>

    <section id="sect.ipv6-tunneling">
      <title>Tunneling</title>

      <sidebar>
        <title><emphasis>CAUTION</emphasis> IPv6 tunneling and firewalls</title>

        <para>IPv6 tunneling over IPv4 (as opposed to native IPv6) requires the
        firewall to accept the traffic, which uses IPv4 protocol number 41.</para>
      </sidebar>

      <para>If a native IPv6 connection is not available, the fallback method
      is to use a tunnel over IPv4. Gogo6 is one (free) provider of such
      tunnels: <ulink type="block" url="http://www.gogo6.com/freenet6/tunnelbroker" /></para>
      <indexterm><primary>Freenet6</primary></indexterm>
      <indexterm><primary>Gogo6</primary></indexterm>

      <para>To use a Freenet6 tunnel, you need to register for a Freenet6
      Pro account on the website, then install the <emphasis role="pkg">gogoc</emphasis> package and configure the tunnel. This
      requires editing the <filename>/etc/gogoc/gogoc.conf</filename>
      file: <literal>userid</literal> and <literal>password</literal>
      lines received by e-mail should be added, and
      <literal>server</literal> should be replaced with
      <literal>authenticated.freenet6.net</literal>.</para>

      <para>IPv6 connectivity is proposed to all machines on a local network
      by adding the three following directives to the
      <filename>/etc/gogoc/gogoc.conf</filename> file (assuming the local
      network is connected to the eth0 interface):</para>

      <programlisting>
host_type=router
prefixlen=56
if_prefix=eth0
</programlisting>

      <para>The machine then becomes the access router for a subnet with a
      56-bit prefix. Once the tunnel is aware of this change, the local
      network must be told about it; this implies installing the
      <command>radvd</command> daemon (from the similarly-named package).
      This IPv6 configuration daemon has a role similar to
      <command>dhcpd</command> in the IPv4 world.</para>

      <para>The <filename>/etc/radvd.conf</filename> configuration file must
      then be created (see
      <filename>/usr/share/doc/radvd/examples/simple-radvd.conf</filename> as
      a starting point). In our case, the only required change is the prefix,
      which needs to be replaced with the one provided by Freenet6; it can be
      found in the output of the <command>ifconfig</command> command, in the
      block concerning the <literal>tun</literal> interface.</para>
      <indexterm><primary><command>radvd</command></primary></indexterm>

      <para>Then run <command>service gogoc restart</command> and
      <command>service radvd start</command>, and the IPv6 network should
      work.</para>
    </section>

  </section>
  <section id="sect.domain-name-servers">
    <title>Domain Name Servers (DNS)</title>
    <section id="sect.dns-principe">
      <title>Prinsipp og mekanisme</title>
      <indexterm><primary>DNS</primary></indexterm>
      <indexterm><primary>server</primary><secondary>name</secondary></indexterm>

      <para>The <emphasis>Domain Name Service</emphasis> (DNS) is a
      fundamental component of the Internet: it maps host names to IP
      addresses (and vice-versa), which allows the use of
      <literal>www.debian.org</literal> instead of
      <literal>5.153.231.4</literal> or <literal>2001:41c8:1000:21::21:4</literal>.</para>

      <para>DNS records are organized in zones; each zone matches either a
      domain (or a subdomain) or an IP address range (since IP addresses
      are generally allocated in consecutive ranges). A primary server is
      authoritative on the contents of a zone; secondary servers, usually
      hosted on separate machines, provide regularly refreshed copies of
      the primary zone.</para>
      <indexterm><primary>zone</primary><secondary>DNS</secondary></indexterm>
      <indexterm><primary>DNS</primary><secondary>zone</secondary></indexterm>

      <para>Each zone can contain records of various kinds
      (<emphasis>Resource Records</emphasis>):</para>
      <itemizedlist>
        <listitem>
	  <para><literal>A</literal>: IPv4 address. <indexterm><primary>A,
	  DNS record</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>CNAME</literal>: alias (<emphasis>canonical
	  name</emphasis>). <indexterm><primary>CNAME, DNS
	  record</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>MX</literal>: <emphasis>mail exchange</emphasis>,
	  an email server. This information is used by other email servers
	  to find where to send email addressed to a given address. Each MX
	  record has a priority. The highest-priority server (with the
	  lowest number) is tried first (see sidebar <xref linkend="sidebar.smtp" />); other servers are contacted in order
	  of decreasing priority if the first one does not reply.
	  <indexterm><primary>MX</primary><secondary>DNS
	  record</secondary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>PTR</literal>: mapping of an IP address to a name.
	  Such a record is stored in a “reverse DNS” zone named after
	  the IP address range. For example,
	  <literal>1.168.192.in-addr.arpa</literal> is the zone containing
	  the reverse mapping for all addresses in the
	  <literal>192.168.1.0/24</literal> range. <indexterm><primary>PTR,
	  DNS record</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>AAAA</literal>: IPv6 address.
	  <indexterm><primary>AAAA, DNS record</primary></indexterm></para>
        </listitem>
        <listitem>
	  <para><literal>NS</literal>: maps a name to a name server. Each
	  domain must have at least one NS record. These records point at a
	  DNS server that can answer queries concerning this domain; they
	  usually point at the primary and secondary servers for the
	  domain. These records also allow DNS delegation; for instance,
	  the <literal>falcot.com</literal> zone can include an NS record
	  for <literal>internal.falcot.com</literal>, which means that the
	  <literal>internal.falcot.com</literal> zone is handled by another
	  server. Of course, this server must declare an
	  <literal>internal.falcot.com</literal> zone.
	  <indexterm><primary>NS, DNS record</primary></indexterm></para>
        </listitem>
      </itemizedlist>
      
      <indexterm><primary>record</primary><secondary>DNS</secondary></indexterm>
      <indexterm><primary>DNS record</primary></indexterm>

      <para>The reference name server, Bind, was developed and is
      maintained by ISC (<emphasis>Internet Software
      Consortium</emphasis>). It is provided in Debian by the <emphasis role="pkg">bind9</emphasis> package. Version 9 brings two major
      changes compared to previous versions. First, the DNS server can now
      run under an unprivileged user, so that a security vulnerability in
      the server does not grant root privileges to the attacker (as was
      seen repeatedly with versions 8.x).</para>

      <para>Furthermore, Bind supports the DNSSEC standard for signing (and
      therefore authenticating) DNS records, which allows blocking any
      spoofing of this data during man-in-the-middle attacks.</para>
      <indexterm><primary><emphasis role="pkg">bind9</emphasis></primary></indexterm>
      <indexterm><primary>ISC</primary></indexterm>
      <indexterm><primary>Internet Software Consortium</primary></indexterm>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> DNSSEC</title>
        <indexterm><primary>DNSSEC</primary></indexterm>

	<para>The DNSSEC norm is quite complex; this partly explains why
	it is not in widespread usage yet (even if it perfectly coexists
	with DNS servers unaware of DNSSEC). To understand all the ins and
	outs, you should check the following article. <ulink type="block" url="http://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions" /></para>
      </sidebar>
    </section>
    <section id="sect.dns-config">
      <title>Configuring</title>

      <para>Configuration files for <command>bind</command>, irrespective
      of version, have the same structure.</para>

      <para>The Falcot administrators created a primary
      <literal>falcot.com</literal> zone to store information related to
      this domain, and a <literal>168.192.in-addr.arpa</literal> zone for
      reverse mapping of IP addresses in the local networks.</para>

      <sidebar>
        <title><emphasis>CAUTION</emphasis> Names of reverse zones</title>
        <indexterm><primary>zone</primary><secondary>reverse</secondary></indexterm>
        <indexterm><primary>reverse zone</primary></indexterm>
        <indexterm><primary><literal>in-addr.arpa</literal></primary></indexterm>
        <indexterm><primary><literal>ip6.arpa</literal></primary></indexterm>
	<indexterm><primary>nibble format</primary></indexterm>

	<para>Reverse zones have a particular name. The zone covering the
	<literal>192.168.0.0/16</literal> network needs to be named
	<literal>168.192.in-addr.arpa</literal>: the IP address components
	are reversed, and followed by the <literal>in-addr.arpa</literal>
	suffix.</para>

	<para>For IPv6 networks, the suffix is <literal>ip6.arpa</literal> and
	the IP address components which are reversed are each character in the full
	hexadecimal representation of the IP address. As such, the
	<literal>2001:0bc8:31a0::/48</literal> network would use a zone named
	<literal>0.a.1.3.8.c.b.0.1.0.0.2.ip6.arpa</literal>.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>TIP</emphasis> Testing the DNS server</title>

	<para>The <command>host</command> command (in the <emphasis role="pkg">bind9-host</emphasis> package) queries a DNS
	server, and can be used to test the server configuration. For
	example, <command>host machine.falcot.com localhost</command>
	checks the local server's reply for the
	<literal>machine.falcot.com</literal> query. <command>host
	<replaceable>ipaddress</replaceable> localhost</command> tests
	the reverse resolution.</para>
	<indexterm><primary><command>host</command></primary></indexterm>
      </sidebar>

      <para>The following configuration excerpts, taken from the Falcot
      files, can serve as starting points to configure a DNS server:</para>
      <indexterm><primary><filename>named.conf</filename></primary></indexterm>
      <indexterm><primary><filename>/etc/bind/named.conf</filename></primary></indexterm>

      <example id="example.bind-named.conf.local">
        <title>Excerpt of <filename>/etc/bind/named.conf.local</filename></title>

        <programlisting>
zone "falcot.com" {
        type master;
        file "/etc/bind/db.falcot.com";
        allow-query { any; };
        allow-transfer {
                195.20.105.149/32 ; // ns0.xname.org
                193.23.158.13/32 ; // ns1.xname.org
        };
};

zone "internal.falcot.com" {
        type master;
        file "/etc/bind/db.internal.falcot.com";
        allow-query { 192.168.0.0/16; };
};

zone "168.192.in-addr.arpa" {
        type master;
        file "/etc/bind/db.192.168";
        allow-query { 192.168.0.0/16; };
};
</programlisting>
      </example>

      <example id="example.bind-db.falcot.com">
        <title>Excerpt of <filename>/etc/bind/db.falcot.com</filename></title>

        <programlisting>; falcot.com Zone 
; admin.falcot.com. =&gt; zone contact: admin@falcot.com
$TTL    604800
@       IN      SOA     falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
;
; The @ refers to the zone name ("falcot.com" here)
; or to $ORIGIN if that directive has been used
;
@       IN      NS      ns
@       IN      NS      ns0.xname.org.

internal IN      NS      192.168.0.2

@       IN      A       212.94.201.10
@       IN      MX      5 mail
@       IN      MX      10 mail2

ns      IN      A       212.94.201.10
mail    IN      A       212.94.201.10
mail2   IN      A       212.94.201.11
www     IN      A       212.94.201.11

dns     IN      CNAME   ns
</programlisting>
      </example>

      <sidebar>
        <title><emphasis>CAUTION</emphasis> Syntax of a name</title>

	<para>The syntax of machine names follows strict rules. For
	instance, <literal>machine</literal> implies
	<literal>machine.<replaceable>domain</replaceable></literal>. If
	the domain name should not be appended to a name, said name must be
	written as <literal>machine.</literal> (with a dot as suffix).
	Indicating a DNS name outside the current domain therefore requires
	a syntax such as <literal>machine.otherdomain.com.</literal> (with
	the final dot).</para>
      </sidebar>

      <example id="example.bind-db.192.168">
        <title>Excerpt of <filename>/etc/bind/db.192.168</filename></title>

        <programlisting>; Reverse zone for 192.168.0.0/16
; admin.falcot.com. =&gt; zone contact: admin@falcot.com
$TTL    604800
@       IN      SOA     ns.internal.falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL

        IN      NS      ns.internal.falcot.com.

; 192.168.0.1 -&gt; arrakis
1.0     IN      PTR     arrakis.internal.falcot.com.
; 192.168.0.2 -&gt; neptune
2.0     IN      PTR     neptune.internal.falcot.com.

; 192.168.3.1 -&gt; pau
1.3     IN      PTR     pau.internal.falcot.com.
</programlisting>
      </example>
    </section>
  </section>
  <section id="sect.dhcp">
    <title>DHCP</title>

    <para>DHCP (for <emphasis>Dynamic Host Configuration
    Protocol</emphasis>) is a protocol by which a machine can
    automatically get its network configuration when it boots. This
    allows centralizing the management of network configurations, and
    ensuring that all desktop machines get similar settings.</para>
    <indexterm><primary>DHCP</primary></indexterm>
    <indexterm><primary>Dynamic Host Configuration Protocol</primary></indexterm>
    <indexterm><primary>network</primary><secondary>DHCP configuration</secondary></indexterm>

    <para>A DHCP server provides many network-related parameters. The
    most common of these is an IP address and the network where the
    machine belongs, but it can also provide other information, such as
    DNS servers, WINS servers, NTP servers, and so on.</para>

    <para>The Internet Software Consortium (also involved in developing
    <command>bind</command>) is the main author of the DHCP server. The
    matching Debian package is <emphasis role="pkg">isc-dhcp-server</emphasis>.</para>

    <section id="sect.dhcp-config">
      <title>Configuring</title>

      <para>The first elements that need to be edited in the DHCP server
      configuration file (<filename>/etc/dhcp/dhcpd.conf</filename>) are
      the domain name and the DNS servers. If this server is alone on the
      local network (as defined by the broadcast propagation), the
      <literal>authoritative</literal> directive must also be enabled (or
      uncommented). One also needs to create a <literal>subnet</literal>
      section describing the local network and the configuration
      information to be provided. The following example fits a
      <literal>192.168.0.0/24</literal> local network with a router at
      <literal>192.168.0.1</literal> serving as the gateway. Available IP
      addresses are in the range <literal>192.168.0.128</literal> to
      <literal>192.168.0.254</literal>.</para>

      <example id="example.dhcp-dhcpd.conf">
        <title>Excerpt of <filename>/etc/dhcp/dhcpd.conf</filename></title>

        <programlisting>
#
# Sample configuration file for ISC dhcpd for Debian
#

# The ddns-updates-style parameter controls whether or not the server will
# attempt to do a DNS update when a lease is confirmed. We default to the
# behavior of the version 2 packages ('none', since DHCP v2 didn't
# have support for DDNS.)
ddns-update-style interim;

# option definitions common to all supported networks...
option domain-name "internal.falcot.com";
option domain-name-servers ns.internal.falcot.com;

default-lease-time 600;
max-lease-time 7200;

# If this DHCP server is the official DHCP server for the local
# network, the authoritative directive should be uncommented.
authoritative;

# Use this to send dhcp log messages to a different log file (you also
# have to hack syslog.conf to complete the redirection).
log-facility local7;

# My subnet
subnet 192.168.0.0 netmask 255.255.255.0 {
    option routers 192.168.0.1;
    option broadcast-address 192.168.0.255;
    range 192.168.0.128 192.168.0.254;
    ddns-domainname "internal.falcot.com";
}
</programlisting>
      </example>
    </section>
    <section id="sect.dhcp-dns">
      <title>DHCP and DNS</title>
      <indexterm><primary>DNS</primary><secondary>automated updates</secondary></indexterm>

      <para>A nice feature is the automated registering of DHCP clients in
      the DNS zone, so that each machine gets a significant name (rather
      than something impersonal such as
      <literal>machine-192-168-0-131.internal.falcot.com</literal>). Using
      this feature requires configuring the DNS server to accept updates to
      the <literal>internal.falcot.com</literal> DNS zone from the DHCP
      server, and configuring the latter to submit updates for each
      registration.</para>

      <para>In the <command>bind</command> case, the
      <literal>allow-update</literal> directive needs to be added to each
      of the zones that the DHCP server is to edit (the one for the
      <literal>internal.falcot.com</literal> domain, and the reverse zone).
      This directive lists the IP addresses allowed to perform these
      updates; it should therefore contain the possible addresses of the
      DHCP server (both the local address and the public address, if
      appropriate).</para>

      <programlisting>
allow-update { 127.0.0.1 192.168.0.1 212.94.201.10 !any };
</programlisting>

      <para>Beware! A zone that can be modified <emphasis>will</emphasis>
      be changed by <command>bind</command>, and the latter will overwrite
      its configuration files at regular intervals. Since this automated
      procedure produces files that are less human-readable than
      manually-written ones, the Falcot administrators handle the
      <literal>internal.falcot.com</literal> domain with a delegated DNS
      server; this means the <literal>falcot.com</literal> zone file stays
      firmly under their manual control.</para>

      <para>The DHCP server configuration excerpt above already includes
      the directives required for DNS zone updates: they are the
      <literal>ddns-update-style interim;</literal> and
      <literal>ddns-domain-name "internal.falcot.com";</literal> lines in
      the block describing the subnet.</para>
    </section>
  </section>
  <section id="sect.network-diagnosis-tools">
    <title>Network Diagnosis Tools</title>

    <para>When a network application does not run as expected, it is
    important to be able to look under the hood. Even when everything seems
    to run smoothly, running a network diagnosis can help ensure everything
    is working as it should. Several diagnosis tools exists for this
    purpose; each one operates on a different level.</para>
    <section id="sect.netstat">
      <title>Local Diagnosis: <command>netstat</command></title>
      <indexterm><primary><command>netstat</command></primary></indexterm>

      <para>Let's first mention the <command>netstat</command> command (in
      the <emphasis role="pkg">net-tools</emphasis> package); it displays
      an instant summary of a machine's network activity. When invoked with
      no argument, this command lists all open connections; this list can
      be very verbose since it includes many Unix-domain sockets (widely
      used by daemons) which do not involve the network at all (for
      example, <literal>dbus</literal> communication,
      <literal>X11</literal> traffic, and communications between virtual
      filesystems and the desktop).</para>

      <para>Common invocations therefore use options that alter
      <command>netstat</command>'s behavior. The most frequently used
      options include:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>-t</literal>, which filters the results to only
	  include TCP connections;</para>
        </listitem>
        <listitem>
	  <para><literal>-u</literal>, which works similarly for UDP
	  connections; these options are not mutually exclusive, and one of
	  them is enough to stop displaying Unix-domain connections;</para>
        </listitem>
        <listitem>
	  <para><literal>-a</literal>, to also list listening sockets
	  (waiting for incoming connections);</para>
        </listitem>
        <listitem>
	  <para><literal>-n</literal>, to display the results numerically:
	  IP addresses (no DNS resolution), port numbers (no aliases as
	  defined in <filename>/etc/services</filename>) and user ids (no
	  login names);</para>
        </listitem>
        <listitem>
	  <para><literal>-p</literal>, to list the processes involved; this
	  option is only useful when <command>netstat</command> is run as
	  root, since normal users will only see their own
	  processes;</para>
        </listitem>
        <listitem>
	  <para><literal>-c</literal>, to continuously refresh the list of
	  connections.</para>
        </listitem>
      </itemizedlist>

      <para>Other options, documented in the
      <citerefentry><refentrytitle>netstat</refentrytitle>
      <manvolnum>8</manvolnum></citerefentry> manual page, provide an even
      finer control over the displayed results. In practice, the first five
      options are so often used together that systems and network
      administrators practically acquired <command>netstat -tupan</command>
      as a reflex. Typical results, on a lightly loaded machine, may look
      like the following:</para>

      <screen role="scale">
<computeroutput># </computeroutput><userinput>netstat -tupan</userinput>
<computeroutput>Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      397/rpcbind     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      431/sshd        
tcp        0      0 0.0.0.0:36568           0.0.0.0:*               LISTEN      407/rpc.statd   
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      762/exim4       
tcp        0    272 192.168.1.242:22        192.168.1.129:44452     ESTABLISHED 1172/sshd: roland [
tcp6       0      0 :::111                  :::*                    LISTEN      397/rpcbind     
tcp6       0      0 :::22                   :::*                    LISTEN      431/sshd        
tcp6       0      0 ::1:25                  :::*                    LISTEN      762/exim4       
tcp6       0      0 :::35210                :::*                    LISTEN      407/rpc.statd   
udp        0      0 0.0.0.0:39376           0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:996             0.0.0.0:*                           397/rpcbind     
udp        0      0 127.0.0.1:1007          0.0.0.0:*                           407/rpc.statd   
udp        0      0 0.0.0.0:68              0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:48720           0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:111             0.0.0.0:*                           397/rpcbind     
udp        0      0 192.168.1.242:123       0.0.0.0:*                           539/ntpd        
udp        0      0 127.0.0.1:123           0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:123             0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:5353            0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:39172           0.0.0.0:*                           407/rpc.statd   
udp6       0      0 :::996                  :::*                                397/rpcbind     
udp6       0      0 :::34277                :::*                                407/rpc.statd   
udp6       0      0 :::54852                :::*                                916/dhclient    
udp6       0      0 :::111                  :::*                                397/rpcbind     
udp6       0      0 :::38007                :::*                                451/avahi-daemon: r
udp6       0      0 fe80::5054:ff:fe99::123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:a:123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:5:123 :::*                                539/ntpd        
udp6       0      0 ::1:123                 :::*                                539/ntpd        
udp6       0      0 :::123                  :::*                                539/ntpd        
udp6       0      0 :::5353                 :::*                                451/avahi-daemon: r
</computeroutput></screen>

      <para>As expected, this lists established connections, two SSH
      connections in this case, and applications waiting for incoming
      connections (listed as <literal>LISTEN</literal>), notably the Exim4
      email server listening on port 25.</para>
    </section>
    <section id="sect.nmap">
      <title>Remote Diagnosis: <command>nmap</command></title>
      <indexterm><primary><command>nmap</command></primary></indexterm>

      <para><command>nmap</command> (in the similarly-named package) is, in
      a way, the remote equivalent for <command>netstat</command>. It can
      scan a set of “well-known” ports for one or several remote
      servers, and list the ports where an application is found to answer
      to incoming connections. Furthermore, <command>nmap</command> is able
      to identify some of these applications, sometimes even their version
      number. The counterpart of this tool is that, since it runs remotely,
      it cannot provide information on processes or users; however, it can
      operate on several targets at once.</para>

      <para>A typical <command>nmap</command> invocation only uses the
      <literal>-A</literal> option (so that <command>nmap</command>
      attempts to identify the versions of the server software it finds)
      followed by one or more IP addresses or DNS names of machines to
      scan. Again, many more options exist to finely control the behavior
      of <command>nmap</command>; please refer to the documentation in the
      <citerefentry> <refentrytitle>nmap</refentrytitle>
      <manvolnum>1</manvolnum> </citerefentry> manual page.</para>

      <screen role="scale" width="80">
<computeroutput># </computeroutput><userinput>nmap mirtuel</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET
Nmap scan report for mirtuel (192.168.1.242)
Host is up (0.000013s latency).
rDNS record for 192.168.1.242: mirtuel.internal.placard.fr.eu.org
Not shown: 998 closed ports
PORT    STATE SERVICE
22/tcp  open  ssh
111/tcp open  rpcbind

Nmap done: 1 IP address (1 host up) scanned in 2.41 seconds
# </computeroutput><userinput>nmap -A localhost</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-09 16:46 CET
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000013s latency).
Other addresses for localhost (not scanned): 127.0.0.1
Not shown: 997 closed ports
PORT    STATE SERVICE VERSION
22/tcp  open  ssh     OpenSSH 6.7p1 Debian 3 (protocol 2.0)
|_ssh-hostkey: ERROR: Script execution failed (use -d to debug)
25/tcp  open  smtp    Exim smtpd 4.84
| smtp-commands: mirtuel Hello localhost [127.0.0.1], SIZE 52428800, 8BITMIME, PIPELINING, HELP, 
|_ Commands supported: AUTH HELO EHLO MAIL RCPT DATA NOOP QUIT RSET HELP 
111/tcp open  rpcbind 2-4 (RPC #100000)
| rpcinfo: 
|   program version   port/proto  service
|   100000  2,3,4        111/tcp  rpcbind
|   100000  2,3,4        111/udp  rpcbind
|   100024  1          36568/tcp  status
|_  100024  1          39172/udp  status
Device type: general purpose
Running: Linux 3.X
OS CPE: cpe:/o:linux:linux_kernel:3
OS details: Linux 3.7 - 3.15
Network Distance: 0 hops
Service Info: Host: mirtuel; OS: Linux; CPE: cpe:/o:linux:linux_kernel

OS and Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 11.54 seconds
</computeroutput>
</screen>

      <para>As expected, the SSH and Exim4 applications are listed. Note
      that not all applications listen on all IP addresses; since Exim4 is
      only accessible on the <literal>lo</literal> loopback interface, it
      only appears during an analysis of <literal>localhost</literal> and
      not when scanning <literal>mirtuel</literal> (which maps to the
      <literal>eth0</literal> interface on the same machine).</para>
    </section>
    <section id="sect.sniffers">
      <title>Sniffers: <command>tcpdump</command> and <command>wireshark</command></title>

      <para>Sometimes, one needs to look at what actually goes on the wire,
      packet by packet. These cases call for a “frame analyzer”, more
      widely known as a <emphasis>sniffer</emphasis>. Such a tool observes
      all the packets that reach a given network interface, and displays
      them in a user-friendly way.</para>
      <indexterm><primary><command>tcpdump</command></primary></indexterm>

      <para>The venerable tool in this domain is
      <command>tcpdump</command>, available as a standard tool on a wide
      range of platforms. It allows many kinds of network traffic capture,
      but the representation of this traffic stays rather obscure. We will
      therefore not describe it in further detail.</para>
      <indexterm><primary><command>wireshark</command></primary></indexterm>

      <para>A more recent (and more modern) tool,
      <command>wireshark</command> (in the <emphasis role="pkg">wireshark</emphasis> package), has become the new
      reference in network traffic analysis due to its many decoding
      modules that allow for a simplified analysis of the captured packets.
      The packets are displayed graphically with an organization based on
      the protocol layers. This allows a user to visualize all protocols
      involved in a packet. For example, given a packet containing an HTTP
      request, <command>wireshark</command> displays, separately, the
      information concerning the physical layer, the Ethernet layer, the IP
      packet information, the TCP connection parameters, and finally the
      HTTP request itself.</para>

      <figure id="figure.wireshark">
        <title>The <command>wireshark</command> network traffic analyzer</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/wireshark.png" scalefit="1" width="75%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>In our example, the packets traveling over SSH are filtered
      out (with the <literal>!tcp.port == 22</literal> filter). The packet
      currently displayed was developed at the HTTP layer.</para>

      <sidebar>
        <title><emphasis>TIP</emphasis> <command>wireshark</command> with no graphical interface: <command>tshark</command></title>
        <indexterm><primary><command>tshark</command></primary></indexterm>

	<para>When one cannot run a graphical interface, or does not wish
	to do so for whatever reason, a text-only version of
	<command>wireshark</command> also exists under the name
	<command>tshark</command> (in a separate <emphasis role="pkg">tshark</emphasis> package). Most of the capture and
	decoding features are still available, but the lack of a graphical
	interface necessarily limits the interactions with the program
	(filtering packets after they've been captured, tracking of a given
	TCP connection, and so on). It can still be used as a first
	approach. If further manipulations are intended and require the
	graphical interface, the packets can be saved to a file and this
	file can be loaded into a graphical <command>wireshark</command>
	running on another machine.</para>
      </sidebar>
    </section>
  </section>
</chapter>
