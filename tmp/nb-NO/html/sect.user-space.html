<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.5. Brukerrommet</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-nb-NO-1.0-1" /><meta
        name="keywords"
        content="BIOS, Kjerne, Unix, Prosess, Hierarki, Grunnleggende kommandoer" /><link
        rel="home"
        href="index.html"
        title="Håndbok for Debian-administratoren" /><link
        rel="up"
        href="short-remedial-course.html"
        title="Tillegg B. Kort støttekurs" /><link
        rel="prev"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. Noen oppgaver som håndteres av kjernen" /><link
        rel="next"
        href="backcover.html"
        title="Tillegg C. Håndbok for Debian-administratoren" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/nb-NO/stable/sect.user-space.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Forrige</strong></a></li><li
          class="home">Håndbok for Debian-administratoren</li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Neste</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.user-space"></a>B.5. Brukerrommet</h2></div></div></div><a
          id="id-1.21.8.2"
          class="indexterm"></a><a
          id="id-1.21.8.3"
          class="indexterm"></a><div
          class="para">
			«Brukerområde» refererer til kjøretidsmiljøets normale prosesser (i motsetning til kjerneprosesser). Dette betyr ikke nødvendigvis at disse prosessene faktisk er startet av brukere fordi et standardsystem normalt har flere «nisse»-prosesser (eller bakgrunnsprosesser) som kjører før brukeren selv åpner en økt. Nisse-prosesser regnes også som brukerområdeprosesser.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.process-basics"></a>B.5.1. Prosess</h3></div></div></div><a
            id="id-1.21.8.5.2"
            class="indexterm"></a><div
            class="para">
				Når kjernen kommer forbi, starter den aller første prosessen, <code
              class="command">init</code>. Prosess #1 er alene svært sjelden nyttig i seg selv, og Unix-lignende systemer kjører med mange prosesser i tillegg.
			</div><a
            id="id-1.21.8.5.4"
            class="indexterm"></a><div
            class="para">
				Først av alt kan en prosess klone seg selv (dette er kjent som en<span
              class="emphasis"><em>gaffel</em></span>). Kjernen tildeler et nytt (men identisk) prosessminne, og en annen prosess for å bruke det. På denne tiden er den eneste forskjellen mellom disse to prosessene deres <span
              class="emphasis"><em>pid</em></span>. Den nye prosessen kalles vanligvis en barneprosess, og den opprinnelige prosessen, hvis <span
              class="emphasis"><em>pid</em></span> ikke forandres, kalles foreldreprosessen.
			</div><div
            class="para">
				Noen ganger fortsetter barneprosessen å leve sitt eget liv uavhengig av foreldreprosessen, med sine egne data kopiert fra den overordnede prosessen. I mange tilfeller kjører denne barneprosessen et annet program. Med noen få unntak, er minnet dens bare erstattet av det nye programmet, og gjennomføringen av dette nye programmet starter. Dette er mekanismen som brukes av init-prosessen (med prosess nummer 1) for å starte tilleggstjenester og gjennomføre hele oppstartsekvensen. På et tidspunkt starter en prosess blant <code
              class="command">init</code>s avkom et grafisk grensesnitt som brukerne kan logge seg på (det faktiske hendelsesforløpet er beskrevet mer i detalj i <a
              class="xref"
              href="unix-services.html#sect.system-boot">Seksjon 9.1, «Systemoppstart»</a>).
			</div><div
            class="para">
				Når en prosessen har fullført oppgaven den ble startet for å utføre, så avslutter den. Kjernen tar deretter tilbake minnet som er tilordnet denne prosessen, og slutter å dele ut tidsressurser den kan bruke til å kjøre. Foreldreprosessen blir fortalt at barneprosessen er avsluttet, noe som tillater en prosess å vente på fullføringen av en oppgave den delegerte til en barneprosess. Denne oppførselen vises tydelig i kommandolinjetolker (kjent som <span
              class="emphasis"><em>skall</em></span>). Når en kommando er skrevet inn i et skall, kommer ledeteksten først tilbake når kommandoen er ferdig utført. De fleste skall lar en kjøre en kommando i bakgrunnen, som er bare å legge til <strong
              class="userinput"><code>&amp;</code></strong> på slutten av kommandoen. Ledeteksten vises igjen med en gang, noe som kan føre til problemer hvis kommandoen må skrive ut sitt eget resultat.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.daemons"></a>B.5.2. Nisser</h3></div></div></div><a
            id="id-1.21.8.6.2"
            class="indexterm"></a><a
            id="id-1.21.8.6.3"
            class="indexterm"></a><div
            class="para">
				En «nisse» er en prosess som startet automatisk ved oppstartssekvensen. Den fortsetter å kjøre (i bakgrunnen) for å utføre vedlikeholdsoppgaver, eller yte tjenester til andre prosesser. Denne «bakgrunnsoppgaven» er faktisk tilfeldig, og samsvarer ikke med noe bestemt fra systemets synspunkt. De er bare prosesser, ganske lik andre prosesser, som går igjen når deres tidskvote kommer. Forskjellen er bare i menneskelig språk: En prosess som går uten interaksjon med brukeren (særlig uten grafisk grensesnitt) sies å være kjørt «i bakgrunnen», eller «som en nisse».
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ORDFORRÅD</em></span> Nisse, demon, en nedsettende betegnelse?</strong></p></div></div></div><div
              class="para">
				Selv om <span
                class="emphasis"><em>nisse (daemon)</em></span>-begrepet deler sin greske etymologi med <span
                class="emphasis"><em>demon</em></span>, innebærer førstnevnte ikke noe diabolsk onde, i stedet skal den forstås som en slags hjelpende ånd. Dette skillet er subtilt nok i engelsk, men det er til og med verre i andre språk der samme ordet er brukt for begge betydninger.
			</div></div><div
            class="para">
				Forskjellige slike nisser er beskrevet i detalj i <a
              class="xref"
              href="unix-services.html">Kapittel 9, <em>Unix-tjenester</em></a>.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ipc"></a>B.5.3. Kommunikasjon mellom prosesser
			<a
                    id="id-1.21.8.7.1.1"
                    class="indexterm"></a>
			</h3></div></div></div><a
            id="id-1.21.8.7.2"
            class="indexterm"></a><a
            id="id-1.21.8.7.3"
            class="indexterm"></a><div
            class="para">
				En isolert prosess, enten en nisse eller et interaktivt program, er sjelden nyttig i seg selv, noe som er grunnen til at det er flere metoder som lar separate prosesser kommunisere sammen, enten for å utveksle data, eller for å kontrollere hverandre. Det generiske begrepet for dette er <span
              class="emphasis"><em>inter-process communication</em></span>, eller i kortform IPC.
			</div><div
            class="para">
				Det enkleste IPC-systemet er å bruke filer. Prosessen som ønsker å sende data, skriver den inn i en fil (med et navn kjent på forhånd), mens mottakeren bare har å åpne filen, og lese innholdet.
			</div><a
            id="id-1.21.8.7.6"
            class="indexterm"></a><div
            class="para">
				I tilfeller der du ikke ønsker å lagre data på disken, kan du bruke en <span
              class="emphasis"><em>kanal</em></span> som rett og slett er et objekt med to ender; byte skrevet i den ene enden er lesbar i den andre. Dersom endene er styrt med separate prosesser, fører dette til en enkel og praktisk kommunikasjon mellom prosesser. Kanaler kan deles inn i to kategorier: Navngitte kanaler, og anonyme kanaler. En navngitt kanal er representert ved en oppføring i filsystemet (selv om de overførte data ikke er lagret der), slik at begge prosessene kan åpne det uavhengig om plasseringen av den navngitte kanalen er kjent på forhånd. I tilfeller hvor de kommuniserende prosessene er relatert (for eksempel en foreldre- og dens barneprosess), den overordnede prosessen kan også opprette en anonym kanal før forgreninger, og barnet arver det. Begge prosesser vil da være i stand til å utveksle data gjennom kanalen uten filsystemet.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>I PRAKSIS</em></span> Et konkret eksempel</strong></p></div></div></div><div
              class="para">
				La oss beskrive i detalj hva som skjer når en kompleks kommando (en <span
                class="emphasis"><em>pipeline (kanal)</em></span>) kjøres fra et skall. Vi antar vi har en <code
                class="command">bash</code>-prosess (standard brukerskallet på Debian), med <span
                class="emphasis"><em>pid</em></span> 4374; I dette skallet skriver vi kommandoen:<code
                class="command">ls | sort</code>.
			</div><div
              class="para">
				Skallet tolker første kommandoen skrevet inn. I vårt tilfelle forstår det at det er to programmer (<code
                class="command">ls</code> og <code
                class="command">sort</code>), med en datastrøm som flyter fra den ene til den andre (merket med <strong
                class="userinput"><code>|</code></strong>-tegnet, kjent som <span
                class="emphasis"><em>pipe</em></span>). <code
                class="command">bash</code> oppretter først en ikke navngitt kanal (som i utgangspunktet bare eksisterer i selve <code
                class="command">bash</code>-prosessen).
			</div><div
              class="para">
				Deretter kloner skallet seg selv. Dette fører til en ny <code
                class="command">bash</code>-prosess, med <span
                class="emphasis"><em>pid</em></span> nummer 4521 (<span
                class="emphasis"><em>pid-er</em></span> er abstrakte tall, og har generelt ikke noen bestemt mening). Prosess nummer 4521 arver kanalen/røret, noe som betyr at den er i stand til å skrive på sin «input»-side; <code
                class="command">bash</code> omdirigeringer sin standard utgående strøm til dette rørets/kanalens inngang. Så utfører den (og erstatter seg med) <code
                class="command">ls</code>-programmet, som viser innholdet i den gjeldende katalogen. Ettersom <code
                class="command">ls</code> skriver til sine standard utdata, og denne produksjonen tidligere er omdirigert, blir resultatene effektivt sendt inn i kanalen/røret.
			</div><div
              class="para">
				En lignende operasjon skjer for den andre kommandoen: <code
                class="command">bash</code> kloner seg igjen, noe som fører til en ny <code
                class="command">bash</code>-prosess med pid #4522. Siden den også er en barneprosess fra #4374, arver den også kanalen; <code
                class="command">bash</code> kobler deretter sin standard inngang til kanalens utgang, deretter kjøres (og erstatter seg med) <code
                class="command">sort</code>-kommandoen, som sorterer sine innspill, og viser resultatene.
			</div><div
              class="para">
				Alle bitene i puslespillet er nå satt sammen: <code
                class="command">ls</code> leser den gjeldende katalogen og skriver en liste over filer inn i kanalen; <code
                class="command">sort</code> leser denne listen, sorterer den alfabetisk, og viser resultatene. Så avsluttes prosessnummer #4521 og #4522, og #4374 (som ventet på dem under operasjonen), gjenopptar kontrollen, og viser meldingen for å tillate brukeren å skrive inn en ny kommando.
			</div></div><div
            class="para">
				Ikke all inter-prosesskommunikasjon brukes til å flytte data rundt. I mange situasjoner er den eneste informasjonen som må overføres, kontrollmeldinger som «pause utførelse» eller «gjenoppta kjøring». Unix (og Linux) gir en mekanisme som kalles <span
              class="emphasis"><em>signaler</em></span>, gjennom hvilken en prosess bare kan sende et bestemt signal (valgt fra en forhåndsdefinert liste av signaler) til en annen prosess. Det eneste kravet er å kjenne til målets <span
              class="emphasis"><em>pid</em></span>.
			</div><div
            class="para">
				For mer komplekse kommunikasjoner er det også mekanismer som tillater at en prosess åpner tilgang, eller deler, en del av sitt tildelte minne til andre prosesser. Minnet, som nå er delt mellom dem, kan brukes til å flytte data mellom prosessene.
			</div><div
            class="para">
				Endelig, nettverkstilkoblinger kan også hjelpe prosesser å kommunisere; disse prosessene kan også kjøres på forskjellige datamaskiner, muligens tusenvis av kilometer fra hverandre.
			</div><div
            class="para">
				Det er ganske standard for et typisk Unix-lignende system i ulik grad å gjøre bruk av alle disse mekanismene.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.libraries"></a>B.5.4. Biblioteker</h3></div></div></div><a
            id="id-1.21.8.8.2"
            class="indexterm"></a><div
            class="para">
				Funksjonsbibliotekene spiller en avgjørende rolle i et Unix-lignende operativsystem. De er ikke egentlig programmer, da de ikke kan kjøres på egen hånd, men er samlinger av kodefragmenter som kan brukes av standardprogrammer. Blant de vanligste biblioteker, kan du finne:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						standard C biblioteket (<span
                    class="emphasis"><em>glibc</em></span>), som inneholder grunnleggende funksjoner som det å åpne filer eller nettverkstilkoblinger - og andre som legger til rette for interaksjoner med kjernen;
					</div></li><li
                class="listitem"><div
                  class="para">
						grafiske verktøysett, for eksempel Gtk+ og Qt, som tillater at mange programmer gjenbruker de grafiske objektene de leverer;
					</div></li><li
                class="listitem"><div
                  class="para">
						<span
                    class="emphasis"><em>libpng</em></span>-biblioteket som tillater lasting, tolking og lagring av bilder i PNG-format.
					</div></li></ul></div><div
            class="para">
				Takket være disse bibliotekene kan programmer gjenbruke eksisterende kode. Programutvikling forenkles fordi mange programmer kan bruke de samme funksjonene. Med bibliotekene, ofte utviklet av forskjellige personer, så er den globale utviklingen av systemet nærmere Unixs historiske filosofi.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>KULTUR</em></span> Unix-måten: En ting om gangen</strong></p></div></div></div><div
              class="para">
				Et av de grunnleggende begreper som ligger til grunn for Unix-familiens operativsystemer, er at hvert verktøy bare skal gjøre en ting, og gjøre det bra; programmer kan deretter bruke disse verktøyene for å bygge en mer avansert logikk på toppen. Denne filosofien kan gjenfinnes i mange utgaver. Skall-skript kan være det beste eksemplet: De kan sette sammen komplekse sekvenser av svært enkle verktøy (for eksempel <code
                class="command">grep</code>, <code
                class="command">wc</code>, <code
                class="command">sort</code>, <code
                class="command">uniq</code>, og så videre). En annen implementering av denne filosofien sees i kodebiblioteker: <span
                class="emphasis"><em>libpng</em></span>-biblioteket gjør det mulig å lese og skrive PNG-bilder, med ulike alternativer og på ulike måter, men det gjør bare det; ikke noe spørsmål om å inkludere funksjoner som viser eller redigerer bilder.
			</div></div><div
            class="para">
				Dessuten er disse bibliotekene ofte referert til som «felles biblioteker», ettersom kjernen bare er i stand til å laste dem inn i minnet én gang, selv om flere prosesser benytter samme bibliotek samtidig. Dette tillater å spare lagringsminne, sammenlignet med den motsatte (hypotetisk) situasjonen, hvor koden for et bibliotek ville være lastet like mange ganger som det er prosesser som benytter den.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>Forrige</strong>B.4. Noen oppgaver som håndteres av kjernen</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Opp</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Hjem</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>Neste</strong>Tillegg C. Håndbok for Debian-administratoren</a></li></ul></body></html>
