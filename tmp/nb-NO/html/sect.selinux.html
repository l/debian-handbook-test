<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.5. Introduksjon til SELinux</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-nb-NO-1.0-1" /><meta
        name="keywords"
        content="Brannmur, Nettfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="Håndbok for Debian-administratoren" /><link
        rel="up"
        href="security.html"
        title="Kapittel 14. Sikkerhet" /><link
        rel="prev"
        href="sect.apparmor.html"
        title="14.4. Introduksjon til AppArmor" /><link
        rel="next"
        href="sect.other-security-considerations.html"
        title="14.6. Other Security-Related Considerations" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/nb-NO/stable/sect.selinux.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.apparmor.html"><strong>Forrige</strong></a></li><li
          class="home">Håndbok for Debian-administratoren</li><li
          class="next"><a
            accesskey="n"
            href="sect.other-security-considerations.html"><strong>Neste</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.selinux"></a>14.5. Introduksjon til SELinux</h2></div></div></div><a
          id="id-1.17.8.2"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.selinux-principles"></a>14.5.1. Prinsipper</h3></div></div></div><div
            class="para">
				SELinux (<span
              class="emphasis"><em>Security Enhanced Linux</em></span>) er et <span
              class="emphasis"><em>Mandatory Access Control</em></span>-system som bygger på Linux sin LSM (<span
              class="emphasis"><em>Linux Security Modules</em></span>)-grensesnitt. I praksis spør kjernen SELinux før hver systempåkalling for å vite om prosessen er autorisert til å gjøre den gitte operasjonen.
			</div><div
            class="para">
				SELinux bruker et sett med regler — kollektivt kjent som en <span
              class="emphasis"><em>policy</em></span> — for å godkjenne eller forby operasjoner. Disse reglene er vanskelige å lage. Heldigvis er to standardregler (<span
              class="emphasis"><em>targeted</em></span> og <span
              class="emphasis"><em>strict</em></span>) laget for å unngå mesteparten av konfigurasjonsarbeidet.
			</div><div
            class="para">
				Med SELinux, er nåndteringen av rettighetene helt forskjellig fra tradisjonelle Unix-systemer. Rettighetene til en prosess er avhengig av sin <span
              class="emphasis"><em>security context</em></span>. Denne konteksten er definert av <span
              class="emphasis"><em>identity</em></span> til brukeren som startet prosessen, <span
              class="emphasis"><em>role</em></span> og <span
              class="emphasis"><em>domain</em></span> som brukeren hadde med seg på det tidspunktet. Rettighetene egentlig avhengig av domenet, men overgangene mellom domenene er kontrollert av rollene. Til slutt, de mulige overgangene mellom roller avhenger av identiteten.
			</div><div
            class="figure"><a
              xmlns=""
              id="id-1.17.8.3.5"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/selinux-context.png"
                  alt="Sikkerhetskontekster og Unix-brukere" /></div></div><p
              class="title"><strong>Figur 14.3. Sikkerhetskontekster og Unix-brukere</strong></p></div><div
            class="para">
				I praksis får brukeren, under innlogging, tildelt en standard sikkerhetskontekst (avhengig av hvilke roller de skal være i stand til å støtte). Dette definerer det gjeldende domenet, og dermed domenet som alle nye avleggerprosesser vil ha. Hvis du ønsker å endre nåværende rolle og tilhørende domene, må du påkalle <code
              class="command">newrole -r <em
                class="replaceable">role_r</em> -t <em
                class="replaceable">domain_t</em></code> (Det er vanligvis bare ett enkelt domene som er tillatt for en gitt rolle, <code
              class="literal">-t</code> parameteren kan derfor utelates). Denne kommandoen godkjenner du ved å be deg skrive inn passordet ditt. Denne funksjonen forbyr programmer å automatisk bytte roller. Slike endringer kan bare skje dersom de er uttrykkelig tillatt i Parameteren kan derfor ofte bli utelatt). Denne kommandoen godkjenner du ved å be deg skrive inn passordet ditt. Denne funksjonen forbyr programmer for å automatisk bytte roller. Slike endringer kan bare skje dersom de er uttrykkelig tillatt i SELinux politikk. politikken.
			</div><div
            class="para">
				Sekvsagt gjelder ikke rettighetene for alle <span
              class="emphasis"><em>objects</em></span> (filer, kataloger, stikkontakter, enheter, etc.). De kan variere fra objekt til objekt. For å oppnå dette, blir hvert objekt forbundet til en <span
              class="emphasis"><em>type</em></span> (Dette kalles merking). Domenene sine rettigheter er dermed uttrykt med sett (dis)tillatte operasjoner for disse typene (og, indirekte, for alle objekter som er merket med den gitte typen).
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>EXTRA</em></span> Domener og typer er tilsvarer hverandre</strong></p></div></div></div><div
              class="para">
				Internt er et domene bare en type, men en type som bare gjelder for prosesser. Det er derfor domener er suffikset med <code
                class="literal">_t</code> akkurat likt objektenes typer.
			</div></div><div
            class="para">
				Som standard arver et program sitt domene fra brukeren som startet det, men standard SELinux politikk forventer at mange viktige programmer kjører i øremerkede domener. For å oppnå dette, er disse kjørbare merket med en øremerket type (for eksempel er <code
              class="command">ssh_t</code> merket med <code
              class="literal">ssh_exec_t</code>, og når et program starter, skifter det automatisk til <code
              class="literal">ssh_t</code>-domenet). Denne automatiske domene-overgangsmekanismen gjør det mulig å gi bare de rettigheter som kreves av hvert program. Dette er et grunnleggende prinsipp for SELinux.
			</div><div
            class="figure"><a
              xmlns=""
              id="id-1.17.8.3.10"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/selinux-transitions.png"
                  alt="Automatiske overganger mellom domenter" /></div></div><p
              class="title"><strong>Figur 14.4. Automatiske overganger mellom domenter</strong></p></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>IN PRACTICE</em></span> Å finne sikkerhetskonteksten</strong></p></div></div></div><a
              id="id-1.17.8.3.11.2"
              class="indexterm"></a><a
              id="id-1.17.8.3.11.3"
              class="indexterm"></a><a
              id="id-1.17.8.3.11.4"
              class="indexterm"></a><div
              class="para">
				For å finne sikkerhetskonteksten for en gitt prosess, bør du bruke <code
                class="literal">Z</code> option of <code
                class="command">ps</code>.
			</div><pre
              class="screen"><code
                class="computeroutput">$ </code><strong
                class="userinput"><code>ps axZ | grep vstfpd</code></strong>
<code
                class="computeroutput">system_u:system_r:ftpd_t:s0   2094 ?    Ss  0:00 /usr/sbin/vsftpd</code></pre><div
              class="para">
				Det første feltet inneholder identitet, rolle, domenet og MCS-nivå, atskilt med kolon. MCS-nivået (<span
                class="emphasis"><em>Multi-Category Security</em></span>) er et parameter som griper inn i oppsettet av en taushetsbeskyttelsespolitikk, som regulerer tilgang til filer basert på deres følsomhet. Denne funksjonen blir ikke forklart i denne boken.
			</div><div
              class="para">
				For å finne den gjeldende sikkerhetskonteksten i et skall, bør du påkalle <code
                class="command">id -Z</code>.
			</div><pre
              class="screen"><code
                class="computeroutput">$ </code><strong
                class="userinput"><code>id -Z</code></strong>
<code
                class="computeroutput">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><div
              class="para">
				Til slutt, for å finne en type knyttet til en fil, kan du bruke <code
                class="command">ls -Z</code>.
			</div><pre
              class="screen"><code
                class="computeroutput">$ </code><strong
                class="userinput"><code>ls -Z test /usr/bin/ssh</code></strong>
<code
                class="computeroutput">unconfined_u:object_r:user_home_t:s0 test
     system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</code></pre><div
              class="para">
				Det er verdt å merke seg at identitet og rolle tilordnet til en fil, ikke har noen spesiell betydning (de er aldri brukt), men av hensyn til ensartetheten, blir alle objekter tildelt en komplett sikkerhetskontekst.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.selinux-setup"></a>14.5.2. Å sette opp SELinux</h3></div></div></div><div
            class="para">
				SELinux-støtte er innebygd i standardkjernene som følger med Debian. Kjernen i Unix-verktøyet støtter SELinux uten noen modifikasjoner. Det er dermed relativt enkelt å aktivere SELinux.
			</div><div
            class="para">
				<code
              class="command">apt install selinux-basics selinux-policy-default</code>-kommandoen vil automatisk installere de nødvendige pakkene til å konfigurere et SELinux system.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CAUTION</em></span> Referansepolitikkener er ikke i Jessie</strong></p></div></div></div><div
              class="para">
				Uheldigvis, vedlikeholderne av <span
                class="pkg pkg">refpolicy</span>-kildepakken håndterte ikke utsending av kritiske feil i sin pakke og pakken ble fjernet fra Jessie. Dette betyr at <span
                class="pkg pkg">selinux-policy-*</span>-pakkene for øyeblikket ikke er installerbare i Jessie og må hentes fra et annet sted. Forhåpentligvis vil de komme tilbake i en av punktversjonene eller i Jessie-backports . I mellomtiden kan du hente dem fra ustabil-versjonen.
			</div><div
              class="para">
				Denne trist situasjonen beviser i det minste at SELinux er ikke veldig populær i blant brukere/utviklere som kjører utviklingsversjoner av Debian. Dermed, hvis du velger å bruke SELinux, bør du forvente at standardregelen ikke fungerer perfekt, og at du blir nødt til å investere litt tid for å gjøre den egnet til dine spesifikke behov.
			</div></div><div
            class="para">
				<span
              class="pkg pkg">selinux-policy-default</span>-pakken inneholder et sett med vanlige regler. Som standard begrenser denne politikken kun tilgang til noen allment synlige tjenester. Brukersesjoner er ikke begrenset, og det er derfor usannsynlig at SELinux ville blokkere legitime brukeroperasjoner. Men dette forbedrer sikkerheten i systemtjenester som kjører på maskinen. For å sette opp en politikk som tilsvarer de gamle "strenge" reglene, er det bare å deaktivere <code
              class="literal">unconfined</code>-modulen (modulhåndtering er beskrevet nærmere i denne seksjonen).
			</div><div
            class="para">
				Når politikken er installert, bør du merke alle tilgjengelige filer (som betyr å tildele dem en type). Denne operasjonen må startes manuelt med <code
              class="command">fixfiles relabel</code>.
			</div><div
            class="para">
				SELinux-systemet er nå klart. For å aktivere det, bør du legge <code
              class="literal">selinux=1 security=selinux</code>-parameteret til Linux-kjernen. <code
              class="literal">audit=1</code>-parameteret aktiver SELinux-logging med registrering av alle de nektede operasjonene. Endelig tar <code
              class="literal">enforcing=1</code>-parameteret reglene i bruk: Uten det virker SELinux i sin standard <span
              class="emphasis"><em>permissive</em></span>-modus der avviste handlinger logges, men fremdeles blir utført. Du bør derfor endre GRUBs oppstarskonfigurasjonsfil ved å legge til de ønskede parametere. En enkel måte å gjøre dette på er å modifisere <code
              class="literal">GRUB_CMDLINE_LINUX</code>-variabelen i <code
              class="filename">/etc/default/grub</code> og å kjøre <code
              class="command">update-grub</code>. SELinux vil være aktivert etter en omstart.
			</div><div
            class="para">
				Det er verdt å merke seg at <code
              class="command">selinux-activate</code>-skriptet automatiserer disse operasjonene og tvinger en merking ved neste oppstart (som unngår nye ikke-merkede filer som er opprettet mens SELinux ennå ikke var aktiv og mens merking skjer).
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.selinux-management"></a>14.5.3. Å håndtere SELinux system</h3></div></div></div><a
            id="id-1.17.8.5.2"
            class="indexterm"></a><a
            id="id-1.17.8.5.3"
            class="indexterm"></a><div
            class="para">
				SELinux politikken er et modulbasert sett med regler, og installasjonen oppdager og aktiverer automatisk alle relevante moduler basert på den allerede installerte tjenesten. Systemet er dermed umiddelbart i drift. Men når en tjeneste er installert etter SELinux politikken, må du klare å aktivere den tilsvarende modulen manuelt. Det er hensikten med <code
              class="command">semodule</code>-komandoen. Videre kan du klare å definere rollene som hver bruker kan slutte seg til, og dette kan gjøres med <code
              class="command">semanage</code>-kommandoen.
			</div><div
            class="para">
				De to kommandoer kan dermed brukes til å endre den gjeldende SELinux-konfigurasjonen, lagret i <code
              class="filename">/etc/selinux/default/</code>. I motsetning til andre konfigurasjonsfiler du finner i <code
              class="filename">/etc/</code>, skal ikke alle disse filene endres for hånd. Du bør bruke programmer som er laget til dette formålet.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>GOING FURTHER</em></span> Mer dokumentasjon</strong></p></div></div></div><div
              class="para">
				Ettersom NSA ikke gir noen offisiell dokumentasjon, har community satt opp en wiki for å kompensere. Den bringer sammen en masse informasjon, men du må være klar over at de fleste SELinux-bidragsytere er Fedora-brukere (der SELinux er aktivert som standard). Dokumentasjonen tenderer dermed til å håndtere spesielt den distribusjonen. <div
                xmlns=""
                class="url">→ <a
                  xmlns="http://www.w3.org/1999/xhtml"
                  href="http://www.selinuxproject.org">http://www.selinuxproject.org</a></div>
			</div><div
              class="para">
				Du bør også ta en titt på den dedikerte Debian wiki-siden, samt Russell Cokers blogg, som er en av de mest aktive Debian-utviklere som jobber med SELinux støtte. <div
                xmlns=""
                class="url">→ <a
                  xmlns="http://www.w3.org/1999/xhtml"
                  href="http://wiki.debian.org/SELinux">http://wiki.debian.org/SELinux</a></div> <div
                xmlns=""
                class="url">→ <a
                  xmlns="http://www.w3.org/1999/xhtml"
                  href="http://etbe.coker.com.au/tag/selinux/">http://etbe.coker.com.au/tag/selinux/</a></div>
			</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.5.7"></a>14.5.3.1. Å håndtere SELinux moduler</h4></div></div></div><div
              class="para">
					Tilgjengelige SELinux-moduler er lagret i <code
                class="filename">/usr/share/selinux/default/</code>-mappen. For å aktivere en av disse modulene i den gjeldende konfigurasjonen, bør du bruke <code
                class="command">semodule -i <em
                  class="replaceable">module.pp.bz2</em></code>. <span
                class="emphasis"><em>pp.bz2</em></span>-forlengelsen står for <span
                class="emphasis"><em>policy package</em></span> (compressed with bzip2).
				</div><div
              class="para">
					Å fjerne en modul fra den gjeldende konfigurasjonen gjøres med <code
                class="command">semodule -r <em
                  class="replaceable">module</em></code>. Til slutt, lister <code
                class="command">semodule -l</code>-kommandoen modulene som er installert. De gir også sine også sine versjonsnumre. Moduler kan selektivt aktiveres med <code
                class="command">semodule -e</code> og slås av med <code
                class="command">semodule -d</code>.
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -i /usr/share/selinux/default/abrt.pp.bz2</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -l</code></strong>
<code
                class="computeroutput">abrt    1.5.0   Disabled
accountsd       1.1.0   
acct    1.6.0   
[...]</code>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -e abrt</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -d accountsd</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -l</code></strong>
<code
                class="computeroutput">abrt    1.5.0
accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</code>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -r abrt</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -l</code></strong>
<code
                class="computeroutput">accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</code></pre><div
              class="para">
					<code
                class="command">semodule</code> laster umiddelabart den nye konfigurasjonen om ikke du bruker dens <code
                class="literal">-n</code>-valg. Det er verdt å merke seg at programmet er standard på den gjeldende konfigurasjonen (som er angitt av <code
                class="literal">SELINUXTYPE</code>-variabelen i <code
                class="filename">/etc/selinux/config</code>), men at du kan endre en annen ved å spesifisere den med <code
                class="literal">-s</code>-valget.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.5.8"></a>14.5.3.2. Å håndtere identiteter</h4></div></div></div><div
              class="para">
					Hver gang en bruker logger inn, får de tildelt en SELinux-identitet. Denne identiteten definerer rollene de kan støtte. Disse to adressingene (fra brukeren til identiteten og fra denne identiteten til roller) kan konfigureres med <code
                class="command">semanage</code>-kommandoen.
				</div><div
              class="para">
					Du bør absolutt lese manualsiden <span
                class="citerefentry"><span
                  class="refentrytitle">semanage</span>(8)</span>, selv om kommando-syntaksen tenderer til å være lik for alle begrepene som håndteres. Du vil finne vanlige valg til alle underkommandoer:<code
                class="literal">-a</code> for å legge til, <code
                class="literal">-d</code> for å trekke fra, <code
                class="literal">-m</code> for å modifisere, <code
                class="literal">-l</code> til å liste, og <code
                class="literal">-t</code> for å indikere en type (eller et domene).
				</div><div
              class="para">
					<code
                class="command">semanage login -l</code> lister gjeldende adressering mellom brukeridentifisere og SELinux-identiteter. Brukere som ikke har noen eksplisitt inngang får identiteten angitt i <code
                class="literal">__default__</code>-inngangen. <code
                class="command">semanage login -a -s user_u <em
                  class="replaceable">user</em></code>-kommandoen vil knytte <span
                class="emphasis"><em>user_u</em></span>-identiteten til den gitte brukeren. Tilslutt, <code
                class="command">semanage login -d <em
                  class="replaceable">user</em></code> dropper asdresserings-inngangen knyttet til denne brukeren.
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage login -a -s user_u rhertzog</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage login -l</code></strong>
<code
                class="computeroutput">
Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         SystemLow-SystemHigh *
rhertzog             user_u               SystemLow            *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *
# </code><strong
                class="userinput"><code>semanage login -d rhertzog</code></strong></pre><div
              class="para">
					<code
                class="command">semanage user -l</code> viser adresseringen mellom SELinux-brukeridentiteter og tillatte roller. Å legge til en ny identitet krever å definere både de tilsvarende rollene og en merkingsforstavelse som brukes til å tilordne en type til personlige filer (<code
                class="filename">/home/<em
                  class="replaceable">user</em>/*</code>). Forstavelosen må velges mellom <code
                class="literal">user</code>, <code
                class="literal">staff</code>, og <code
                class="literal">sysadm</code>. “<code
                class="literal">staff</code>”-forstavelsen resulterer i filer av typen “<code
                class="literal">staff_home_dir_t</code>”. Å lage en ny SELinux-brukeridentitet gjøres med <code
                class="command">semanage user -a -R <em
                  class="replaceable">roles</em> -P <em
                  class="replaceable">prefix</em> <em
                  class="replaceable">identity</em></code>. Til slutt, du kan fjerne en SELinux-brukeridentitet med <code
                class="command">semanage user -d <em
                  class="replaceable">identity</em></code>.
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage user -a -R 'staff_r user_r' -P staff test_u</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage user -l</code></strong>
<code
                class="computeroutput">
                Labeling   MLS/       MLS/                          
SELinux User    Prefix     MCS Level  MCS Range             SELinux Roles

root            sysadm     SystemLow  SystemLow-SystemHigh  staff_r sysadm_r system_r
staff_u         staff      SystemLow  SystemLow-SystemHigh  staff_r sysadm_r
sysadm_u        sysadm     SystemLow  SystemLow-SystemHigh  sysadm_r
system_u        user       SystemLow  SystemLow-SystemHigh  system_r
test_u          staff      SystemLow  SystemLow             staff_r user_r
unconfined_u    unconfined SystemLow  SystemLow-SystemHigh  system_r unconfined_r
user_u          user       SystemLow  SystemLow             user_r
# </code><strong
                class="userinput"><code>semanage user -d test_u</code></strong></pre></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.5.9"></a>14.5.3.3. Å håndtere filkontekster, porter og boolske verdier</h4></div></div></div><div
              class="para">
					Hver SELinux-modul har et sett av filmerkingsregler, men det er også mulig å legge til egendefinerte regler for merking for å ta hensyn til et bestemt tilfelle. For eksempel, hvis du vil at nett-tjeneren, for å kunne lese filene i <code
                class="filename">/srv/www/</code>-filhierarkiet, kan du kjøre <code
                class="command">semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"</code> fulgt av <code
                class="command">restorecon -R /srv/www/</code>. Førstnevnte kommando registrerer nye regler for merking, og sistnevnte tilbakestiller filtypene etter gjeldende regler for merking.
				</div><div
              class="para">
					Tilsvarende er TCP/UDP-portene merket på en måte som sikrer at bare de tilsvarende nissene kan lytte til dem. For eksempel, hvis du vil at nett-tjeneren skal kunne lytte på port 8080, bør du kjøre <code
                class="command">semanage port -m -t http_port_t -p tcp 8080</code>.
				</div><div
              class="para">
					Noen SELinux-moduler eksporterer boolske valg som du kan justere for å endre gjøremålene til standardreglene. <code
                class="command">getsebool</code>-verktøyet kan brukes til å inspisere disse valgene (<code
                class="command">getsebool <em
                  class="replaceable">boolean</em></code> viser ett valg, og <code
                class="command">getsebool -a</code> alle). <code
                class="command">setsebool <em
                  class="replaceable">boolean</em> <em
                  class="replaceable">value</em></code>-kommandoen endrer den gjeldende verdien av et boolsk alternativ. <code
                class="literal">-P</code>-valget gjør endringen permanent, det betyr at den nye verdien blir standard og blir beholdt etter restart. Eksempelet nedenfor gir nett-tjenere tilgang til hjemmeområder (dette er nyttig når brukerne har personlige nettsteder i <code
                class="filename">~/public_html/</code>).
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>getsebool httpd_enable_homedirs</code></strong>
<code
                class="computeroutput">httpd_enable_homedirs --&gt; off
# </code><strong
                class="userinput"><code>setsebool -P httpd_enable_homedirs on</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>getsebool httpd_enable_homedirs</code></strong> 
<code
                class="computeroutput">httpd_enable_homedirs --&gt; on</code></pre></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.selinux-custom-rules"></a>14.5.4. Å tilpasse reglene</h3></div></div></div><div
            class="para">
				Siden SELinux-politikken er modulbasert, kan det være interessant å utvikle nye moduler for (muligens tilpassede) programmer som mangler dem. Disse nye modulene vil da komplettere <span
              class="emphasis"><em>reference policy</em></span>.
			</div><div
            class="para">
				For å lage nye moduler, kreves <span
              class="pkg pkg">selinux-policy-dev</span>-pakken så vel som <span
              class="pkg pkg">selinux-policy-doc</span>. Den siste inneholder dokumentasjonen om standardreglene (<code
              class="filename">/usr/share/doc/selinux-policy-doc/html/</code>) og eksempelfiler som kan brukes som maler for å lage nye moduler. Installer disse filene og studer dem nærmere:
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</code></strong>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.fc ./</code></strong>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.if ./</code></strong>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.te ./</code></strong></pre><div
            class="para">
				<code
              class="filename">.te</code>-filen er den viktigste. Den definerer reglene. <code
              class="filename">.fc</code>-filen definerer "filkonteksten", det er typene som er tilordnet filer knyttet til denne modulen. Dataene innenfor <code
              class="filename">.fc</code>-filen brukes under filemerkingstrinnet. Endelig definerer <code
              class="filename">.if</code>-filen modulens grensesnittet: Det er et sett med "offentlige funksjoner" som andre moduler kan bruke til en riktig samhandling med modulen du oppretter.
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.6.6"></a>14.5.4.1. Å skrive en <code
                      class="filename">.fc</code>-fil</h4></div></div></div><div
              class="para">
					Å lese eksemplet nedenfor bør være tilstrekkelig til å forstå strukturen i en slik fil. Du kan bruke vanlige uttrykk for å tilordne den samme sikkerhetskonteksten til flere filer, eller til og med til et helt katalogtre.
				</div><div
              class="example"><a
                xmlns=""
                id="id-1.17.8.6.6.3"></a><p
                class="title"><strong>Eksempel 14.2. <code
                    class="filename">example.fc</code>-file</strong></p><div
                class="example-contents"><pre
                  class="programlisting scale"># myapp executable will have:
# label: system_u:object_r:myapp_exec_t
# MLS sensitivity: s0
# MCS categories: &lt;none&gt;

/usr/sbin/myapp         --      gen_context(system_u:object_r:myapp_exec_t,s0)
</pre></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.6.7"></a>14.5.4.2. Å skrive en <code
                      class="filename">.if</code>-fil</h4></div></div></div><div
              class="para">
					I eksemplet nedenfor, det første grensesnittet (“<code
                class="literal">myapp_domtrans</code>”) kontrollerer hvem som kan kjøre programmet. Det andre (“<code
                class="literal">myapp_read_log</code>”) gir leserettigheter til programmets logg filer.
				</div><div
              class="para">
					Hvert grensesnitt må generere et gyldig sett med regler som kan legges inn i en <code
                class="filename">.te</code>-fil. Du bør derfor formidle alle typene du bruker (med <code
                class="literal">gen_require</code>-makro), og bruke standard-direktiver for å gi rettigheter. Vær imidlertid oppmerksom på at du kan bruke grensesnitt som tilbys av andre moduler. Den neste seksjonen vil gi flere forklaringer om hvordan disse rettighetene skal uttrykkes.
				</div><div
              class="example"><a
                xmlns=""
                id="id-1.17.8.6.7.4"></a><p
                class="title"><strong>Eksempel 14.3. <code
                    class="filename">example.if</code> fil</strong></p><div
                class="example-contents"><pre
                  class="programlisting">## &lt;summary&gt;Myapp example policy&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              More descriptive text about myapp.  The &lt;desc&gt;
##              tag can also use &lt;p&gt;, &lt;ul&gt;, and &lt;ol&gt;
##              html tags for formatting.
##      &lt;/p&gt;
##      &lt;p&gt;
##              This policy supports the following myapp features:
##              &lt;ul&gt;
##              &lt;li&gt;Feature A&lt;/li&gt;
##              &lt;li&gt;Feature B&lt;/li&gt;
##              &lt;li&gt;Feature C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;summary&gt;
##      Execute a domain transition to run myapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to transition.
## &lt;/param&gt;
#
interface(`myapp_domtrans',`
        gen_require(`
                type myapp_t, myapp_exec_t;
        ')

        domtrans_pattern($1,myapp_exec_t,myapp_t)
')

########################################
## &lt;summary&gt;
##      Read myapp log files.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to read the log files.
## &lt;/param&gt;
#
interface(`myapp_read_log',`
        gen_require(`
                type myapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')
</pre></div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DOCUMENTATION</em></span> Forklaringer om <span
                          class="emphasis"><em>reference policy</em></span></strong></p></div></div></div><div
                class="para">
					<span
                  class="emphasis"><em>reference policy</em></span> utvikler seg som alle fri programvare-prosjekt: basert på frivillige bidrag. Tresys er vert for prosjektet, en av de mest aktive selskapene på SELinux-feltet. Wikien deres har forklaringer på hvordan reglene er strukturert og hvordan du kan lage nye. <div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted">https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.writing-a-te-file"></a>14.5.4.3. Å skrive en <code
                      class="filename">.te</code>-fil</h4></div></div></div><div
              class="para">
					Se på <code
                class="filename">example.te</code>-filen:
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> The <code
                          class="command">m4</code> makrospråk</strong></p></div></div></div><div
                class="para">
					For å strukturere politikken riktig, brukte SELinux-utviklerne en makro-kommando-prosessor. I stedet for å duplisere mange lignende <span
                  class="emphasis"><em>allow</em></span>-direktiver, laget de "makrofunksjoner " for å bruke en høyere-nivå logikk, som også resulterer i en mye mer lesbar politikk.
				</div><div
                class="para">
					I praksis blir <code
                  class="command">m4</code> brukt til å sette sammen disse reglene. Den gjør den motsatte operasjonen: det utvider alle disse høyt nivå direktivene inn i en stor database med <span
                  class="emphasis"><em>allow</em></span>-direktiver.
				</div><div
                class="para">
					SELinux-"grensesnittene" er bare makrofunksjoner som vil bli erstattet av et sett med regler på kompileringstidspunktet. På samme måte er noen rettigheter er faktisk sett av rettigheter som er byttet ut med sine verdier på kompileringstidspunktet.
				</div></div><pre
              class="programlisting">policy_module(myapp,1.0.0) <span
                id="example.te.module"><img
                  class="callout"
                  src="Common_Content/images/1.png"
                  alt="1" /></span>

########################################
#
# Declarations
#

type myapp_t; <span
                id="example.te.type"><img
                  class="callout"
                  src="Common_Content/images/2.png"
                  alt="2" /></span>
type myapp_exec_t;
domain_type(myapp_t)
domain_entry_file(myapp_t, myapp_exec_t) <span
                id="example.te.domain"><img
                  class="callout"
                  src="Common_Content/images/3.png"
                  alt="3" /></span>

type myapp_log_t;
logging_log_file(myapp_log_t) <span
                id="example.te.interface"><img
                  class="callout"
                  src="Common_Content/images/4.png"
                  alt="4" /></span>

type myapp_tmp_t;
files_tmp_file(myapp_tmp_t)

########################################
#
# Myapp local policy
#

allow myapp_t myapp_log_t:file { read_file_perms append_file_perms }; <span
                id="example.te.allow"><img
                  class="callout"
                  src="Common_Content/images/5.png"
                  alt="5" /></span>

allow myapp_t myapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(myapp_t,myapp_tmp_t,file)
</pre><div
              class="calloutlist"><table
                border="0"
                summary="Callout list"><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.module"><img
                          class="callout"
                          src="Common_Content/images/1.png"
                          alt="1" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							Modulen må identifiseres med navn og versjonsnummer. Dette direktivet er nødvendig.
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.type"><img
                          class="callout"
                          src="Common_Content/images/2.png"
                          alt="2" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							Hvis modulen introduserer nye typer, må den si ifra om dem med direktiver som dette. Ikke nøl med å lage så mange typer som kreves i stedet for å gi for mange ubrukelige rettigheter.
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.domain"><img
                          class="callout"
                          src="Common_Content/images/3.png"
                          alt="3" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							Those interfaces define the <code
                        class="literal">myapp_t</code> type as a process domain that should be used by any executable labeled with <code
                        class="literal">myapp_exec_t</code>. Implicitly, this adds an <code
                        class="literal">exec_type</code> attribute on those objects, which in turn allows other modules to grant rights to execute those programs: for instance, the <code
                        class="literal">userdomain</code> module allows processes with domains <code
                        class="literal">user_t</code>, <code
                        class="literal">staff_t</code>, and <code
                        class="literal">sysadm_t</code> to execute them. The domains of other confined applications will not have the rights to execute them, unless the rules grant them similar rights (this is the case, for example, of <code
                        class="command">dpkg</code> with its <code
                        class="literal">dpkg_t</code> domain).
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.interface"><img
                          class="callout"
                          src="Common_Content/images/4.png"
                          alt="4" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							<code
                        class="literal">logging_log_file</code> is an interface provided by the reference policy. It indicates that files labeled with the given type are log files which ought to benefit from the associated rules (for example granting rights to <code
                        class="command">logrotate</code> so that it can manipulate them).
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="left"><p><a
                        href="#example.te.allow"><img
                          class="callout"
                          src="Common_Content/images/5.png"
                          alt="5" /></a> </p></td><td
                    valign="top"
                    align="left"><div
                      class="para">
							The <code
                        class="literal">allow</code> directive is the base directive used to authorize an operation. The first parameter is the process domain which is allowed to execute the operation. The second one defines the object that a process of the former domain can manipulate. This parameter is of the form “<em
                        class="replaceable">type</em>:<em
                        class="replaceable">class</em>“ where <em
                        class="replaceable">type</em> is its SELinux type and <em
                        class="replaceable">class</em> describes the nature of the object (file, directory, socket, fifo, etc.). Finally, the last parameter describes the permissions (the allowed operations).
						</div><div
                      class="para">
							Permissions are defined as the set of allowed operations and follow this template: <code
                        class="literal">{ <em
                          class="replaceable">operation1</em> <em
                          class="replaceable">operation2</em> }</code>. However, you can also use macros representing the most useful permissions. The <code
                        class="filename">/usr/share/selinux/devel/include/support/obj_perm_sets.spt</code> lists them.
						</div><div
                      class="para">
							The following web page provides a relatively exhaustive list of object classes, and permissions that can be granted. <div
                        xmlns=""
                        class="url">→ <a
                          xmlns="http://www.w3.org/1999/xhtml"
                          href="http://www.selinuxproject.org/page/ObjectClassesPerms">http://www.selinuxproject.org/page/ObjectClassesPerms</a></div>
						</div></td></tr></table></div><div
              class="para">
					Now you just have to find the minimal set of rules required to ensure that the target application or service works properly. To achieve this, you should have a good knowledge of how the application works and of what kind of data it manages and/or generates.
				</div><div
              class="para">
					However, an empirical approach is possible. Once the relevant objects are correctly labeled, you can use the application in permissive mode: the operations that would be forbidden are logged but still succeed. By analyzing the logs, you can now identify the operations to allow. Here is an example of such a log entry:
				</div><pre
              class="programlisting">avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1
</pre><div
              class="para">
					To better understand this message, let us study it piece by piece.
				</div><div
              class="table"><a
                xmlns=""
                id="id-1.17.8.6.8.10"></a><p
                class="title"><strong>Tabell 14.1. Analysis of an SELinux trace</strong></p><div
                class="table-contents"><table
                  xmlns:d="http://docbook.org/ns/docbook"
                  class="lt-4-cols gt-7-rows"
                  summary="Analysis of an SELinux trace"><colgroup><col /><col /></colgroup><thead><tr><th>Message</th><th>Description</th></tr></thead><tbody><tr><td> <code
                          class="computeroutput">avc: denied</code> </td><td>An operation has been denied.</td></tr><tr><td> <code
                          class="computeroutput">{ read write }</code> </td><td>This operation required the <code
                          class="literal">read</code> and <code
                          class="literal">write</code> permissions.</td></tr><tr><td> <code
                          class="computeroutput">pid=1876</code> </td><td>The process with PID 1876 executed the operation (or tried to execute it).</td></tr><tr><td> <code
                          class="computeroutput">comm="syslogd"</code> </td><td>The process was an instance of the <code
                          class="literal">syslogd</code> program.</td></tr><tr><td> <code
                          class="computeroutput">name="xconsole"</code> </td><td>The target object was named <code
                          class="literal">xconsole</code>. Sometimes you can also have a “path” variable — with the full path — instead.</td></tr><tr><td> <code
                          class="computeroutput">dev=tmpfs</code> </td><td>The device hosting the target object is a <code
                          class="literal">tmpfs</code> (an in-memory filesystem). For a real disk, you could see the partition hosting the object (for example: “sda3”).</td></tr><tr><td> <code
                          class="computeroutput">ino=5510</code> </td><td>The object is identified by the inode number 5510.</td></tr><tr><td> <code
                          class="computeroutput">scontext=system_u:system_r:syslogd_t:s0</code> </td><td>This is the security context of the process who executed the operation.</td></tr><tr><td> <code
                          class="computeroutput">tcontext=system_u:object_r:device_t:s0</code> </td><td>This is the security context of the target object.</td></tr><tr><td> <code
                          class="computeroutput">tclass=fifo_file</code> </td><td>The target object is a FIFO file.</td></tr></tbody></table></div></div><div
              class="para">
					By observing this log entry, it is possible to build a rule that would allow this operation. For example: <code
                class="literal">allow syslogd_t device_t:fifo_file { read write }</code>. This process can be automated, and it's exactly what the <code
                class="command">audit2allow</code> command (of the <span
                class="pkg pkg">policycoreutils</span> package) offers. This approach is only useful if the various objects are already correctly labeled according to what must be confined. In any case, you will have to carefully review the generated rules and validate them according to your knowledge of the application. Effectively, this approach tends to grant more rights than are really required. The proper solution is often to create new types and to grant rights on those types only. It also happens that a denied operation isn't fatal to the application, in which case it might be better to just add a “<code
                class="literal">dontaudit</code>” rule to avoid the log entry despite the effective denial.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>COMPLEMENTS</em></span> No roles in policy rules</strong></p></div></div></div><a
                id="id-1.17.8.6.8.12.2"
                class="indexterm"></a><a
                id="id-1.17.8.6.8.12.3"
                class="indexterm"></a><div
                class="para">
					It might seem weird that roles do not appear at all when creating new rules. SELinux uses only the domains to find out which operations are allowed. The role intervenes only indirectly by allowing the user to switch to another domain. SELinux is based on a theory known as <span
                  class="emphasis"><em>Type Enforcement</em></span> and the type is the only element that matters when granting rights.
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.6.9"></a>14.5.4.4. Compiling the Files</h4></div></div></div><div
              class="para">
					Once the 3 files (<code
                class="filename">example.if</code>, <code
                class="filename">example.fc</code>, and <code
                class="filename">example.te</code>) match your expectations for the new rules, just run <code
                class="command">make NAME=devel</code> to generate a module in the <code
                class="filename">example.pp</code> file (you can immediately load it with <code
                class="command">semodule -i example.pp</code>). If several modules are defined, <code
                class="command">make</code> will create all the corresponding <code
                class="filename">.pp</code> files.
				</div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.apparmor.html"><strong>Forrige</strong>14.4. Introduksjon til AppArmor</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Opp</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Hjem</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.other-security-considerations.html"><strong>Neste</strong>14.6. Other Security-Related Considerations</a></li></ul></body></html>
