<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">Kapittel 9. Unix tjenester</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-nb-NO-1.0-1" /><meta
        name="keywords"
        content="Systemoppstart, Initskript, SSH, Telnet, Rettigheter, Tillatelser, Overvåking, Inetd, Cron, Sikkerhetskopiering, Hot-plugging, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Debian-administratorens håndbok" /><link
        rel="up"
        href="index.html"
        title="Debian-administratorens håndbok" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. Å installere en kjerne" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. Remote Login" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/nb-NO/stable/unix-services.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Forrige</strong></a></li><li
          class="home">Debian-administratorens håndbok</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Neste</strong></a></li></ul><div
        xml:lang="nb-NO"
        class="chapter"
        lang="nb-NO"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  xmlns=""
                  id="unix-services"></a>Kapittel 9. Unix tjenester</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. Systemoppstart</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. Systemd init system</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. The System V init system</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. Remote Login</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. Secure Remote Login: SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. Using Remote Graphical Desktops</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. Managing Rights</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. Administration Interfaces</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. Administrating on a Web Interface: <code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. Configuring Packages: <code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> System Events</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. Principle and Mechanism</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. The Configuration File</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. The <code
                    class="command">inetd</code> Super-Server</a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. Scheduling Tasks with <code
                    class="command">cron</code> and <code
                    class="command">atd</code></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. Format of a <code
                        class="filename">crontab</code> File</a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. Using the <code
                        class="command">at</code> Command</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. Scheduling Asynchronous Tasks: <code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. Quotas</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. Sikkerhetskopiering</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. Backing Up with <code
                        class="command">rsync</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. Restoring Machines without Backups</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. Hot Plugging: <span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. Introduction</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. The Naming Problem</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. How <span
                        class="emphasis"><em>udev</em></span> Works</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. A concrete example</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. Power Management: Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		Dette kapitlet dekker en rekke grunnleggende tjenester felles for mange Unix-systemer. Alle administratorer bør være kjent med dem.
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    xmlns=""
                    id="sect.system-boot"></a>9.1. Systemoppstart</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			Når du starter datamaskinen, vises mange meldinger på konsollskjermen at mange automatiske initialiseringer og konfigurasjoner blir utført. Noen ganger kan du ønske å endre litt på hvordan dette stadiet fungerer, noe som betyr at du må forstå det godt. Det er hensikten med denne seksjonen.
		</div><div
            class="para">
			Først tar BIOS kontroll over datamaskinen, registrerer diskene, laster <span
              class="emphasis"><em>Master Boot Record</em></span>, og starter oppstartslasteren. Oppstartslasteren tar over, finner kjernen på disken, laster og kjører den. Kjernen blir så initialisert, og begynner å søke etter og montere partisjonen som inneholder rotfilsystemet, og til slutt utfører det første programmet - <code
              class="command">init</code>. Ofte er, faktisk, denne “rotpartisjonen” og denne <code
              class="command">init</code> ligger i et virtuelt filsystem som bare finnes i RAM (derav navnet, "initramfs", tidligere kalt "initrd" for "initialisering RAM disk"). Dette filsystem er lastet inn i minnet av oppstartslasteren, ofte fra en fil på en harddisk eller fra nettverket. Den inneholder blotte minimum som kreves av kjernen for å laste det "sanne" rotfilsystemet: Dette kan være drivermoduler for harddisken eller andre enheter uten noe som systemet ikke kan starte opp, eller, oftere, initialiseringsskript og moduler for montering av RAID matriser, åpne krypterte partisjoner, aktivere LVM, etc. Når rotpartisjonen er montert, overlater initramfs kontrollen til den virkelige init-en, og maskinen går tilbake til standard oppstartsprosess.
		</div><div
            class="figure"><a
              xmlns=""
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="Oppstartssekvens med en datamaskin som kjører Linux med systemd" /></div></div><p
              class="title"><strong>Figur 9.1. Oppstartssekvens med en datamaskin som kjører Linux med systemd</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.systemd"></a>9.1.1. Systemd init system</h3></div></div></div><div
              class="para">
				“real init” blir nå levert av <span
                class="pkg pkg">systemd</span> og denne seksjonen dokumenter dette init-systemet.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURE</em></span> Before <code
                          class="command">systemd</code></strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> er et relativt nytt “init system”, og selv om det allerede er tilgjengelig, til en viss grad, i <span
                  class="distribution distribution">Wheezy</span>, er det bare blitt standard i Debian <span
                  class="distribution distribution">Jessie</span>. Tidligere versjoner bygger, som standard, på “System V init” (in the <span
                  class="pkg pkg">sysv-rc</span>-pakken), et mye mer tradisjonelt system. Vi beskriver System V init senere.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> Andre systemer for oppstart</strong></p></div></div></div><div
                class="para">
				Denne boken beskriver oppstartsystemet som brukes som standard i Debian <span
                  class="distribution distribution">Jessie</span> (som implementert av <span
                  class="pkg pkg">systemd</span>-pakken), så vel som den tidligere standarden, <span
                  class="pkg pkg">sysvinit</span>, som er avledet og arvet fra <span
                  class="emphasis"><em>System V</em></span> Unix systemer; det er andre.
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> er et oppstartsystem med en veldig enkel prosess. Det holder prinsippet om kjørenivå, men erstatter mapper og symbolske lenker med en konfigurasjonsfil, som viser til <code
                  class="command">init</code> - prosessene som må startes og lanseringsrekkefølgen deres.
			</div><div
                class="para">
				<code
                  class="command">upstart</code>-systemet er fortsatt ikke helt testet ut på Debian. Det er hendelsesbasert: init skripter utføres ikke lenger i en sekvensiell rekkefølge, men som respons til hendelser som for eksempel fullføring av et annet skript som de er avhengige av. Dette systemet, startet av Ubuntu, er med i Debian <span
                  class="distribution distribution">Jessie</span>, men er ikke i standarden. Det kommer faktisk som en erstatning for <span
                  class="pkg pkg">sysvinit</span>, og en av oppgavene kjørt av <code
                  class="command">upstart</code> er å kjøre de prosedyrer som er skrevet for tradisjonelle systemer, spesielt de fra <span
                  class="pkg pkg">sysv-rc</span>-pakken.
			</div><div
                class="para">
				Det er også andre systemer og andre driftsmodi, for eksempel <code
                  class="command">runit</code> eller <code
                  class="command">minit</code>, men de er relativt spesialiserte og ikke utbredt.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SPECIFIC CASE</em></span> Oppstart fra nettverket</strong></p></div></div></div><div
                class="para">
				I noen konfigurasjoner, kan BIOS bli konfigurert til ikke å utføre MBR, men å søke dens tilsvarende i nettverket, noe som gjør det mulig å bygge datamaskiner uten en harddisk, eller som blir helt reinstallert ved hver oppstart. Dette alternativet er ikke tilgjengelig for alle maskinvarer og det krever vanligvis en egnet kombinasjon av BIOS og nettverkskort.
			</div><div
                class="para">
				Oppstart fra nettverket kan bli brukt til å kjøre <code
                  class="command">debian-installer</code> eller FAI (se <a
                  class="xref"
                  href="installation.html#sect.installation-methods">Seksjon 4.1, «Installasjonsmetoder»</a>).
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BACK TO BASICS</em></span> Prosessen, et programeksempel</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				En prosess er representasjonen av et program som kjører i minnet. Det inkluderer all informasjon som er nødvendig for en forsvarlig kjøring av programvaren (selve koden, men også dataene som den har i minnet, en liste over filer som den har åpnet, nettverksforbindelsene den har etablert, etc.). Et enkelt program kan startes opp i flere prosesser, som ikke nødvendigvis kjører under forskjellige bruker-IDer.
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SECURITY</em></span> Bruke skall som <code
                          class="command">init</code> for å få rotrettingheter</strong></p></div></div></div><div
                class="para">
				Av tradisjon, den første prosessen som starter er <code
                  class="command">init</code> programmet (som er en symbolsk lenke til <code
                  class="filename">/lib/systemd/systemd</code> som standard). Imidlertid er det mulig å sende et <code
                  class="literal">init</code>-valg til kjernen for å indikere et annet program.
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				Alle som er i stand til å få tilgang til datamaskinen kan trykke på <span
                  class="keycap"><strong>Reset</strong></span>-knappen og restarte den. Så, på oppstartslasterens ledetekst, er det mulig å sende <code
                  class="literal">init=/bin/sh</code>-valget til kjernen for å få rottilgang uten å kjenne administratorens passord.
			</div><div
                class="para">
				For å unngå dette, kan du beskytte oppstartslasteren med et passord. Du kan også tenke på å beskytte tilgang til BIOS (en mekanisme for passordbeskyttelse er nesten alltid tilgjengelig). Uten den kan en en ondsinnet inntrenger fortsatt starte maskinen med et flyttbart medium som har sitt eget Linux-system, som de deretter kan bruke til å få tilgang til data på datamaskinens harddisker.
			</div><div
                class="para">
				Til slutt, være klar over at de fleste BIOS-er har en generisk passord tilgjengelig. I utgangspunktet er de tenkt for feilsøking for de som har glemt passordet sitt, disse passordene er nå offentlige og tilgjengelig på Internett (se selv ved å søke etter "generiske BIOS-passord" i en søkemotor). Alle disse beskyttelsene vil dermed hindre uautorisert tilgang til maskinen, men uten å være i stand til å fullstendig hindre det. Det er ingen pålitelig måte å beskytte en datamaskin på hvis angriperen kan få fysisk fysisk tilgang til den; de kan uansett demontere harddisker for å koble dem til en datamaskin under egen kontroll, eller stjele hele maskinen, eller slette BIOS-minnet for å tilbakestille passordet …
			</div></div><div
              class="para">
				Systemd utfører flere prosesser, som svarer for å sette opp systemet: tastatur, drivere, filsystemer, nettverk, tjenester. Den gjør dette mens du holder et overordnet syn på systemet som en helhet, og kravene til komponentene. Hver komponent er beskrevet av en "unit file" (noen ganger mer); den generelle syntaksen er avledet fra det mye brukte "* INI filer" syntaks, med <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code> par gruppert mellom <code
                class="literal">[<em
                  class="replaceable">section</em>]</code> topptekster. "Unit filer" er lagret under <code
                class="filename">/lib/systemd/system/</code> og <code
                class="filename">/etc/systemd/system/</code>. De kommer i flere varianter, men her vil vi fokusere på "tjenester" og "mål".
			</div><div
              class="para">
				En systemd "tjenestefil" beskriver en prosess styrt av systemd. Den inneholder omtrent den samme informasjonen som i et i gammel stil init-skript, men uttrykt på en deklaratorisk (og mye mer konsis) måte. Systemd håndterer mesteparten av de repeterende oppgavene (som starter og stopper prosessen, sjekker statusen, loggingen, dropper privilegier, og så videre), og tjenestefilen trenger bare å fylle ut detaljene i prosessen. For eksempel, her er tjenestefilen for SSH:
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service
</pre><div
              class="para">
				Som du kan se, er det svært lite kode her, bare deklarasjoner. Systemd tar seg av visning av fremdriftsrapporter, holder orden på prosessene, og starter dem selv når det trengs.
			</div><div
              class="para">
				En systemd "target file" beskriver et systems tilstand, hvor et sett av tjenester som er kjent for å være i operasjonelle. Det kan sees på som å tilsvare det gammeldagse kjørenivået. Ett av målene er <code
                class="literal">local-fs.target</code>; Når det er nådd, kan resten av systemet gå ut fra at alle de lokale filsystemer er montert og tilgjengelige. Andre mål inkluderer <code
                class="literal">network-online.target</code> og <code
                class="literal">sound.target</code>. Avhengigheter for et mål kan enten være oppført i målfilen (i <code
                class="literal">Requires=</code>-linjen), eller man kan bruke en symbolsk fil i <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code>-mappen. For eksempel inneholder <code
                class="filename">/etc/systemd/system/printer.target.wants/</code> en link til <code
                class="filename">/lib/systemd/system/cups.service</code>; systemd vil derfor sikre at CUPS kjører, for å nå <code
                class="literal">printer.target</code>.
			</div><div
              class="para">
				Siden enhetsfiler er deklarative heller enn skripter eller programmer, de kan ikke kjøres direkte, og de blir bare tolket av systemd. Flere verktøy tillater derfor administratoren å samhandle med systemd for å kontrollere tilstanden til systemet og for hver komponent.
			</div><div
              class="para">
				Det første slike verktøy er <code
                class="command">systemctl</code>. Kjørt uten argumenter, viser den alle enhetsfiler som er kjent for systemd (bortsett fra de som er blitt deaktivert), samt deres status. <code
                class="command">systemctl status</code> gir en bedre oversikt over tjenestene, samt relaterte prosesser. Hvis gitt navnet på en tjeneste (som i <code
                class="command">systemctl status ntp.service</code>), returnerer den enda flere detaljer, så vel som de få siste logglinjer knyttet til denne tjenesten (mer om det senere).
			</div><div
              class="para">
				Å starte en tjeneste for hånd er en enkel sak, kjør <code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code>. Som man kan gjette seg til, å stoppe tjenesten gjøres med <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code>. Andre underkommandoer inkluderer <code
                class="command">reload</code> og <code
                class="command">restart</code>.
			</div><div
              class="para">
				For å kontrollere om en tjeneste er aktiv (dvs. om det vil komme i gang automatisk ved oppstart), bruk <code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> (eller <code
                class="command">disable</code>). <code
                class="command">is-enabled</code> åpner for å sjekke tjenestens status.
			</div><div
              class="para">
				Et interessant trekk ved systemd er at den inneholder en loggingskomponent som heter <code
                class="command">journald</code>. Den kommer som et supplement til mer tradisjonelle loggingsystemer, for eksempel <code
                class="command">syslogd</code>, men den legger til interessante funksjoner, som en formell kobling mellom en tjeneste og meldingene den genererer, og evnen til å fange opp feilmeldinger generert fra sin initialiseringsekvens. Meldingene kan vises senere, med litt hjelp fra <code
                class="command">journalctl</code>-kommandoen. Uten noen argumenter, avgir den bare alle loggmeldinger som har oppstått etter oppstart av systemet. Det vil sjelden bli brukt på den måten. Mesteparten av tiden, vil den bli brukt med en tjenesteidentifikator:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				En annen nyttig kommandolinjemarkør er <code
                class="command">-f</code>, som instruerer <code
                class="command">journalctl</code> til å fortsette å vise nye meldinger etterhvert som de er sendt ut (mye på samme måte som <code
                class="command">tail -f <em
                  class="replaceable">file</em></code>).
			</div><div
              class="para">
				Hvis en tjeneste ikke ut til å virke som forventet, er første skritt for å løse problemet å kontrollere at tjenesten faktisk kjører, med <code
                class="command">systemctl status</code>. Hvis den ikke kjører, og meldingene er gitt av den første kommandoen ikke er nok til å diagnostisere problemet, sjekk loggene samlet av journald om denne tjenesten. For eksempel, anta SSH server ikke virker:
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				Etter å ha sjekket status på tjenesten (feilet), gikk vi videre til å sjekke loggene. De indikerer en feil i konfigurasjonsfilen. Etter å ha redigert konfigurasjonsfilen og fikset feilen, starter vi tjenesten, og kontroller så at den faktisk kjører.
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> Andre typer enhetsfiler</strong></p></div></div></div><div
                class="para">
				Vi har bare beskrevet de mest grunnleggende av systemd muligheter i denne seksjonen. Den tilbyr mange andre interessante funksjoner og vi vil bare liste noen her:
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <code
                        class="command">inetd</code>. See <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						timers: a “timer” unit file describes events that occur with a fixed frequency or on specific times; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. This allows replicating part of the <code
                        class="command">cron</code> features. See <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span>.
					</div></li><li
                    class="listitem"><div
                      class="para">
						network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up.
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.sysvinit"></a>9.1.2. The System V init system</h3></div></div></div><div
              class="para">
				The System V init system (which we'll call init for brevity) executes several processes, following instructions from the <code
                class="filename">/etc/inittab</code> file. The first program that is executed (which corresponds to the <span
                class="emphasis"><em>sysinit</em></span> step) is <code
                class="command">/etc/init.d/rcS</code>, a script that executes all of the programs in the <code
                class="filename">/etc/rcS.d/</code> directory. <a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a> <a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				Among these, you will find successively programs in charge of:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						configuring the console's keyboard;
					</div></li><li
                  class="listitem"><div
                    class="para">
						loading drivers: most of the kernel modules are loaded by the kernel itself as the hardware is detected; extra drivers are then loaded automatically when the corresponding modules are listed in <code
                      class="filename">/etc/modules</code>;
					</div></li><li
                  class="listitem"><div
                    class="para">
						checking the integrity of filesystems;
					</div></li><li
                  class="listitem"><div
                    class="para">
						mounting local partitions;
					</div></li><li
                  class="listitem"><div
                    class="para">
						configuring the network;
					</div></li><li
                  class="listitem"><div
                    class="para">
						mounting network filesystems (NFS).
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BACK TO BASICS</em></span> Kernel modules and options</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				Kernel modules also have options that can be configured by putting some files in <code
                  class="filename">/etc/modprobe.d/</code>. These options are defined with directives like this: <code
                  class="literal">options <em
                    class="replaceable">module-name</em> <em
                    class="replaceable">option-name</em>=<em
                    class="replaceable">option-value</em></code>. Several options can be specified with a single directive if necessary.
			</div><div
                class="para">
				These configuration files are intended for <code
                  class="command">modprobe</code> — the program that loads a kernel module with its dependencies (modules can indeed call other modules). This program is provided by the <span
                  class="pkg pkg">kmod</span> package.
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				After this stage, <code
                class="command">init</code> takes over and starts the programs enabled in the default runlevel (which is usually runlevel 2). It executes <code
                class="command">/etc/init.d/rc 2</code>, a script that starts all services which are listed in <code
                class="filename">/etc/rc2.d/</code> and whose names start with the “S” letter. The two-figures number that follows had historically been used to define the order in which services had to be started, but nowadays the default boot system uses <code
                class="command">insserv</code>, which schedules everything automatically based on the scripts' dependencies. Each boot script thus declares the conditions that must be met to start or stop the service (for example, if it must start before or after another service); <code
                class="command">init</code> then launches them in the order that meets these conditions. The static numbering of scripts is therefore no longer taken into consideration (but they must always have a name beginning with “S” followed by two digits and the actual name of the script used for the dependencies). Generally, base services (such as logging with <code
                class="command">rsyslog</code>, or port assignment with <code
                class="command">portmap</code>) are started first, followed by standard services and the graphical interface (<code
                class="command">gdm3</code>).
			</div><div
              class="para">
				This dependency-based boot system makes it possible to automate re-numbering, which could be rather tedious if it had to be done manually, and it limits the risks of human error, since scheduling is conducted according to the parameters that are indicated. Another benefit is that services can be started in parallel when they are independent from one another, which can accelerate the boot process.
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> distinguishes several runlevels, so it can switch from one to another with the <code
                class="command">telinit <em
                  class="replaceable">new-level</em></code> command. Immediately, <code
                class="command">init</code> executes <code
                class="command">/etc/init.d/rc</code> again with the new runlevel. This script will then start the missing services and stop those that are no longer desired. To do this, it refers to the content of the <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> (where <em
                class="replaceable">X</em> represents the new runlevel). Scripts starting with “S” (as in “Start”) are services to be started; those starting with “K” (as in “Kill”) are the services to be stopped. The script does not start any service that was already active in the previous runlevel.
			</div><div
              class="para">
				By default, System V init in Debian uses four different runlevels:
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						Level 0 is only used temporarily, while the computer is powering down. As such, it only contains many “K” scripts.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Level 1, also known as single-user mode, corresponds to the system in degraded mode; it includes only basic services, and is intended for maintenance operations where interactions with ordinary users are not desired.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Level 2 is the level for normal operation, which includes networking services, a graphical interface, user logins, etc.
					</div></li><li
                  class="listitem"><div
                    class="para">
						Level 6 is similar to level 0, except that it is used during the shutdown phase that precedes a reboot.
					</div></li></ul></div><div
              class="para">
				Other levels exist, especially 3 to 5. By default they are configured to operate the same way as level 2, but the administrator can modify them (by adding or deleting scripts in the corresponding <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> directories) to adapt them to particular needs.
			</div><div
              class="figure"><a
                xmlns=""
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="Boot sequence of a computer running Linux with System V init" /></div></div><p
                class="title"><strong>Figur 9.2. Boot sequence of a computer running Linux with System V init</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				All the scripts contained in the various <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> directories are really only symbolic links — created upon package installation by the <code
                class="command">update-rc.d</code> program — pointing to the actual scripts which are stored in <code
                class="filename">/etc/init.d/</code>. The administrator can fine tune the services available in each runlevel by re-running <code
                class="command">update-rc.d</code> with adjusted parameters. The <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> manual page describes the syntax in detail. Please note that removing all symbolic links (with the <code
                class="literal">remove</code> parameter) is not a good method to disable a service. Instead you should simply configure it to not start in the desired runlevel (while preserving the corresponding calls to stop it in the event that the service runs in the previous runlevel). Since <code
                class="command">update-rc.d</code> has a somewhat convoluted interface, you may prefer using <code
                class="command">rcconf</code> (from the <span
                class="pkg pkg">rcconf</span> package) which provides a more user-friendly interface.
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN POLICY</em></span> Restarting services</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				The maintainer scripts for Debian packages will sometimes restart certain services to ensure their availability or get them to take certain options into account. The command that controls a service — <code
                  class="command">service <em
                    class="replaceable">service</em> <em
                    class="replaceable">operation</em></code> — doesn't take runlevel into consideration, assumes (wrongly) that the service is currently being used, and may thus initiate incorrect operations (starting a service that was deliberately stopped, or stopping a service that is already stopped, etc.). Debian therefore introduced the <code
                  class="command">invoke-rc.d</code> program: this program must be used by maintainer scripts to run services initialization scripts and it will only execute the necessary commands. Note that, contrary to common usage, the <code
                  class="filename">.d</code> suffix is used here in a program name, and not in a directory.
			</div></div><div
              class="para">
				Finally, <code
                class="command">init</code> starts control programs for various virtual consoles (<code
                class="command">getty</code>). It displays a prompt, waiting for a username, then executes <code
                class="command">login <em
                  class="replaceable">user</em></code> to initiate a session.
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULARY</em></span> Console and terminal</strong></p></div></div></div><div
                class="para">
				The first computers were usually separated into several, very large parts: the storage enclosure and the central processing unit were separate from the peripheral devices used by the operators to control them. These were part of a separate furniture, the “console”. This term was retained, but its meaning has changed. It has become more or less synonymous with “terminal”, being a keyboard and a screen.
			</div><div
                class="para">
				With the development of computers, operating systems have offered several virtual consoles to allow for several independent sessions at the same time, even if there is only one keyboard and screen. Most GNU/Linux systems offer six virtual consoles (in text mode), accessible by typing the key combinations <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> through <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span>.
			</div><div
                class="para">
				By extension, the terms “console” and “terminal” can also refer to a terminal emulator in a graphical X11 session (such as <code
                  class="command">xterm</code>, <code
                  class="command">gnome-terminal</code> or <code
                  class="command">konsole</code>).
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>Forrige</strong>8.11. Å installere en kjerne</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Opp</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Hjem</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>Neste</strong>9.2. Remote Login</a></li></ul></body></html>
