<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">8.9. سایر پیکربندی‌ها: همگام‌سازی زمان، گزارش‌ها، دسترسی اشتراکی...</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-fa-IR-1.0-1" /><meta
        name="keywords"
        content="پیکربندی, بومی‌سازی, مناطق, شبکه, شفافیت نامگذاری, کاربران, گروه‌ها, حساب‌های کاربری, مفسر خط‌-فرمان, پوسته, چاپ, راه‌انداز اولیه, کامپایل کرنل" /><link
        rel="home"
        href="index.html"
        title="راهنمای جامع دبیان" /><link
        rel="up"
        href="basic-configuration.html"
        title="فصل 8. پیکربندی اولیه: شبکه، حساب‌های کاربری، چاپ و ..." /><link
        rel="prev"
        href="sect.config-bootloader.html"
        title="8.8. پیکربندی راه‌انداز اولیه" /><link
        rel="next"
        href="sect.kernel-compilation.html"
        title="8.10. کامپایل یک کرنل" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/fa-IR/stable/sect.config-misc.html" /></head><body
      dir="rtl"><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-bootloader.html"><strong>قبلی</strong></a></li><li
          class="home">راهنمای جامع دبیان</li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-compilation.html"><strong>بعدی</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.config-misc"></a>8.9. سایر پیکربندی‌ها: همگام‌سازی زمان، گزارش‌ها، دسترسی اشتراکی...</h2></div></div></div><div
          class="para">
			عناصر مختلفی که در این قسمت به آن‌ها اشاره می‌شود برای کسانی که می‌خواهند تمام جنبه‌های پیکربندی یک سیستم گنو/لینوکس را بدانند بسیار مفید هستند. اگرچه، تنها به بخش مختصری از آن‌ها می‌پردازیم و ارجاعاتی به مستندات رسمی باقی می‌گذاریم.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.timezone"></a>8.9.1. منطقه‌زمانی</h3></div></div></div><a
            id="id-1.11.13.3.2"
            class="indexterm"></a><div
            class="sidebar"><a
              xmlns=""
              id="sidebar.symbolic-link"></a><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>بازگشت به مقدمات</em></span> پیوندهای نمادین</strong></p></div></div></div><a
              id="id-1.11.13.3.3.2"
              class="indexterm"></a><a
              id="id-1.11.13.3.3.3"
              class="indexterm"></a><a
              id="id-1.11.13.3.3.4"
              class="indexterm"></a><div
              class="para">
				یک پیوند نمادین مانند اشاره‌گر به فایل دیگری است. زمانی که به آن دسترسی دارید، در حقیقت فایل اشاره‌شده باز می‌شود. حذف این پیوند منجر به حذف فیزیکی فایلی که به آن اشاره دارد نمی‌شود. به همین شکل، مجوزهای جداگانه مربوط به خود را ندارد، اما مجوزهای فایل هدف را نمایش می‌دهد. در نهایت، می‌تواند به هر نوع فایلی اشاره کند: دایرکتوری‌ها، فایل‌های ویژه (سوکت، لوله‌های نام‌گذاری‌شده، فایل‌های دستگاه‌ها و الی آخر)، حتی سایر پیوندهای نمادین.
			</div><div
              class="para">
				دستور <code
                class="command">ln -s <em
                  class="replaceable">target</em> <em
                  class="replaceable">link-name</em></code> یک پیوند نمادین با نام <em
                class="replaceable">link-name</em> که اشاره به فایل <em
                class="replaceable">target</em> دارد را ایجاد می‌کند.
			</div><div
              class="para">
				اگر فایل هدف وجود نداشته باشد، آنگاه پیوند به صورت “شکسته” خواهد بود و دسترسی به آن با خطای عدم وجود فایل مقصد مواجه خواهد شد. اگر پیوند به پیوند دیگری اشاره کند، آنگاه دارای “زنجیره‌ای” از پیوندها هستید که هر یک به دیگری اشاره می‌کند و یک “چرخه” را ایجاد می‌کنند. در این مورد، دسترسی به یکی از پیوندهای این چرخه به یک خطای مشخص ختم می‌شود (“too many levels of symbolic links”)؛ به معنی اینکه کرنل پس از چند مرتبه پیموندن این چرخه، عملیات را متوقف کرده است.
			</div></div><div
            class="para">
				منطقه‌زمانی، که در نصب اولیه پیکربندی شده، یک گزینه پیکربندی برای بسته <span
              class="pkg pkg">tzdata</span> است. برای تغییر آن، از دستور <code
              class="command">dpkg-reconfigure tzdata</code> استفاده کنید، که به شما اجازه انتخاب یک منطقه‌زمانی را به صورت تعاملی می‌دهد. پیکربندی آن در فایل <code
              class="filename">/etc/timezone</code> ذخیره شده است. به علاوه، فایل متناظر آن در دایرکتوری <code
              class="filename">/usr/share/zoneinfo</code> در فایل <code
              class="filename">/etc/localtime</code> رونوشت گرفته می‌شود؛ این فایل شامل تاریخ مبتنی بر ساعت تابستانی است که بر بعضی کشورها استفاده می‌شود.
			</div><a
            id="id-1.11.13.3.5"
            class="indexterm"></a><a
            id="id-1.11.13.3.6"
            class="indexterm"></a><a
            id="id-1.11.13.3.7"
            class="indexterm"></a><a
            id="id-1.11.13.3.8"
            class="indexterm"></a><a
            id="id-1.11.13.3.9"
            class="indexterm"></a><a
            id="id-1.11.13.3.10"
            class="indexterm"></a><div
            class="para">
				زمانی که نیاز دارید به صورت موقت منطقه‌زمانی را تغییر دهید، از متغیر محلی <code
              class="varname">TZ</code> استفاده کنید که نسب به پیش‌فرض اولیه سیستم اولویت پیدا می‌کند.
			</div><a
            id="id-1.11.13.3.12"
            class="indexterm"></a><a
            xmlns=""
            id="screen.tz"></a><pre
            class="screen">
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>date</code></strong>
<code
              class="computeroutput">Thu Feb 19 11:25:18 CET 2015</code>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>TZ="Pacific/Honolulu" date</code></strong>
<code
              class="computeroutput">Thu Feb 19 00:25:21 HST 2015</code></pre><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>یادداشت</em></span> ساعت سیستم، ساعت سخت‌افزار</strong></p></div></div></div><div
              class="para">
				دو منبع زمان برای رایانه وجود دارد. برداصلی رایانه دارای یک ساعت سخت‌افزاری است که با نام “ساعت CMOS” شناخته می‌شود. این ساعت خیلی دقیق نیست و دسترسی کندی به زمان ارائه می‌دهد. کرنل سیستم عامل ساعت خود را دارد، ساعت نرم‌افزاری، که با استفاده از ابزار خود بروز نگاه می‌دارد (احتمالا با استفاده از سرورهای زمانی، قسمت <a
                class="xref"
                href="sect.config-misc.html#sect.time-synchronization">
      قسمت 8.9.2, “همگام‌سازی زمان”
    </a> را مشاهده کنید). این ساعت سیستم به طور دقیق‌تری کار می‌کند، به خصوص که به متغیرهای سخت‌افزاری نیازی ندارد. اگرچه، از آنجا که تنها در حافظه اصلی قرار دارد، هر زمان که رایانه راه‌اندازی شود از صفر آعاز می‌گردد، بر خلاف ساعت CMOS که دارای یک باتری است و راه‌اندازی مجدد رایانه باعث “از بین رفتن” آن نمی‌شود. ساعت سیستم، بنابراین با استفاده از ساعت CMOS هنگام راه‌اندازی اولیه تنظیم و ساعت CMOS نیز هنگام خاموش شدن رایانه بروزرسانی می‌گردد (اگر به درستی تنظیم شود تغییرات صحیح را به همراه خواهد داشت).
			</div><div
              class="para">
				در عمل، یک مشکل وجود دارد و آن اینکه ساعت CMOS چیزی بیشتر از یک شمارنده سخت‌افزاری نیست و کوچکترین اطلاعاتی راجع به منظفه‌زمانی ندارد. برای تفسیر این حالت یک انتخاب وجود دارد: یا سیستم تصمیم بگیرد که ساعت به صورت جهانی (UTC که سابق بر این GMT بود) تنظیم گردد یا به صورت محلی. این انتخاب به نظر ساده می‌آید، اما داستان پیچیده‌تر از این است: در نتیجه استفاده از ساعت تابستانی، این اختلاف هیچگاه ثابت نمی‌ماند. نتیجه اینکه سیستم هیچ روشی برای تایید این اختلاف زمانی ندارد، به خصوص هنگامی که این بازه زمانی تغییر می‌کند. از آنجا که همیشه می‌توان با استفاده از زمان جهانی و اطلاعات منطقه‌زمانی به ساعت محلی دسترسی داشت، به شدت توصیه می‌شود که از ساعت CMOS در زمان جهانی استفاده گردد.
			</div><div
              class="para">
				متاسفانه، سیستم‌های ویندوز با پیکربندی اولیه این توصیه را رعایت نمی‌کنند؛ آن‌ها ساعت CMOS را در حالت محلی نگاه داشته و هنگام راه‌اندازی اولیه رایانه اقدام به اعمال تغییرات زمانی با توجه به تغییرات زمانی سابق سیستم می‌نمایند. این کار به نسبت جواب می‌دهد، مادامی که ویندوز تنها سیستم عامل رایانه باشد. اما زمانی که یک رایانه دارای سیستم عامل‌های گوناگونی باشد (خواه یک پیکربندی “dual-boot” یا استفاده از ماشین مجازی) آشوب به پا می‌شود و هیچ روشی برای تایید صحت زمان وجود نخواهد داشت. اگر قصد نگهداری ویندوز روی یک رایانه را دارید، باید آن را به گونه‌ای پیکربندی کنید که ساعت CMOS بز اساس زمان UTC (تنظیم کلید رجیستری <code
                class="literal">HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</code> به “۱” به عنوان DWORD) یا استفاده از دستور <code
                class="command">hwclock --localtime --set</code> در دبیان برای تنظیم ساعت سخت‌افزاری و نشانه‌گذازی آن به عنوان زمان محلی (و اطمینان حاصل کنید که هنگام بهار و پاییز این تغییرات اعمال می‌شود) تنظیم گردد.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.time-synchronization"></a>8.9.2. همگام‌سازی زمان</h3></div></div></div><a
            id="id-1.11.13.4.2"
            class="indexterm"></a><a
            id="id-1.11.13.4.3"
            class="indexterm"></a><div
            class="para">
				همگام‌سازی زمان، که ممکن است عضو زائدی در رایانه به حساب آید، اهمیت بسزایی در یک شبکه دارد. از آنجا که کاربران مجوز کافی برای تغییر و تنظیم تاریخ و ساعت را ندارد، دقیق بودن این اطلاعات از اهمیت خاصی برخوردار است تا باعث سردرگمی نشود. علاوه بر این، همگام‌سازی زمان چند رایانه در شبکه باعث می‌شود که اطلاعات مربوط به گزارش‌های سیستمی به صورت بهتری استفاده گردند. بنابراین، اگر حمله‌ای صورت گیرد، راحت‌تر خواهد بود که ترتیب زمانی وقایع اتفاق افتاده در مجموعه‌ای از رایانه‌های نفوذ شده را تشخیص داد. داده‌هایی که از چندین رایانه مختلف برای تحلیل آماری گردآوری می‌شوند مادامی که همگام‌سازی زمانی نداشته باشند تاثیر خاصی ندارند.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>بازگشت به مقدمات</em></span> NTP</strong></p></div></div></div><a
              id="id-1.11.13.4.5.2"
              class="indexterm"></a><a
              id="id-1.11.13.4.5.3"
              class="indexterm"></a><div
              class="para">
				پروتکل زمان در شبکه یا Network Time Protocol به یک رایانه اجازه می‌دهد که ساعت خود را با سایر رایانه‌های شبکه همگام‌سازی کند. این پروتکل تاخیر بوجود آمده در شبکه و سایر تاثیرات مربوط به آن را نیز در محاسبه این زمان به حساب می‌آورد.
			</div><div
              class="para">
				با اینکه تعداد زیادی سرور NTP در اینترنت وجود دارند، آن‌هایی که محبوب‌تر هستند بیشتر استفاده می‌گردند. به همین دلیل توصیه می‌کنیم که از سرور <span
                class="emphasis"><em>pool.ntp.org</em></span> استفاده کرده که در حقیقت مجموعه‌ای از رایانه‌های عمومی ارائه‌دهنده این پروتکل در اینترنت هستند. حتی می‌توانید بر اساس یک کشور خاص فهرست خود را کوتاه کنید، برای نمونه <span
                class="emphasis"><em>us.pool.ntp.org</em></span> برای ایالات متحده یا <span
                class="emphasis"><em>ca.pool.ntp.org</em></span> برای کانادا.
			</div><div
              class="para">
				اگر یک شبکه بزرگ را مدیریت می‌کنید، توصیه می‌شود که سرور NTP خود را نصب کنید که با استفاده از سرورهای عمومی همگام‌سازی می‌گردد. در این مورد، تمام رایانه‌های شبکه محلی می‌توانند از سرور شما استفاده کنند بجای اینکه ترافیک خود را روی سرورهای عمومی قرار دهند. با اینکار همگن بودن ساعت‌ها را افزایش می‌دهید، چرا که تمام رایانه‌ها بر اساس یک منبع همگام‌سازی زمانی شده‌اند و این منبع با توجه به زمان انتقال در شبکه بسیار نزدیک است.
			</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ntp-on-workstations"></a>8.9.2.1. برای رایانه‌های رومیزی</h4></div></div></div><div
              class="para">
					از آنجا که این رایانه‌ها به صورت مداوم روشن و خاموش می‌گردند (حتی برای صرفه‌جویی در انرژی)، همگام‌سازی زمان در لحظه راه‌اندازی توسط NTP کافی است. به این منظور، تنها کافی است بسته <span
                class="pkg pkg">ntpdate</span> را نصب کنید. با ویرایش فایل <code
                class="filename">/etc/default/ntpdate</code> نیز می‌توانید سرور NTP مورد نظر را تغییر دهید.
				</div><a
              id="id-1.11.13.4.6.3"
              class="indexterm"></a><a
              id="id-1.11.13.4.6.4"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.ntp-on-servers"></a>8.9.2.2. برای سرورها</h4></div></div></div><div
              class="para">
					سرورها به طور خیلی کم راه‌اندازی مجدد می‌گردند و صحیح بودن ساعت سیستم در آن‌ها اهمیت ویژه‌ای دارد. برای این منظور، می‌توانید یک سرور NTP محلی نصب کنید، سرویسی که توسط بسته <span
                class="pkg pkg">ntp</span> ارائه می‌شود. در پیکربندی پیش‌فرض آن، سرور با <span
                class="emphasis"><em>pool.ntp.org</em></span> همگام‌سازی می‌شود و زمان خواسته شده را که توسط شبکه محلی مورد نیاز است فراهم می‌آورد. می‌توانید با ویریش فایل <code
                class="filename">/etc/ntp.conf</code> آن را پیکربندی کنید که مهم‌ترین تغییر در آن مربوط به سرور NTP مورد نیاز است. اگر شبکه دارای سرورهای مختلفی باشد، می‌توان یکی از آن‌ها را با توجه به سرورهای عمومی NTP همگام‌سازی کرد تا باقی سرورهای شبکه از روی آن همگام‌سازی زمانی گردند.
				</div><a
              id="id-1.11.13.4.7.3"
              class="indexterm"></a><a
              id="id-1.11.13.4.7.4"
              class="indexterm"></a><a
              id="id-1.11.13.4.7.5"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>مطالعه بیشتر</em></span> ماژول‌های GPS و سایر منابع زمانی</strong></p></div></div></div><a
                id="id-1.11.13.4.7.6.2"
                class="indexterm"></a><a
                id="id-1.11.13.4.7.6.3"
                class="indexterm"></a><div
                class="para">
					اگر همگام‌سازی زمان برای شبکه شما امری حیاتی است، امکان تجهیز یک سرور به ماژول GPS (که از زمان ماهواره‌های GPS استفاده می‌کند) یا ماژول DCF-77 (که از زمان ساعت اتمی نزدیک به فرانکفورت آلمان استفاده می‌کند) وجود دارد. در این مورد، پیکربندی سرور NTP کمی پیچیده‌تر خواهد بود و مطالعه مستندات قبل از پیاده‌سازی آن یک ضرورت محسوب می‌شود.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.rotation-logs"></a>8.9.3. چرخش فایل‌های گزارش</h3></div></div></div><a
            id="id-1.11.13.5.2"
            class="indexterm"></a><a
            id="id-1.11.13.5.3"
            class="indexterm"></a><a
            id="id-1.11.13.5.4"
            class="indexterm"></a><a
            id="id-1.11.13.5.5"
            class="indexterm"></a><div
            class="para">
				فایل‌های گزارش می‌توانند به سرعت رشد کرده و حجم زیادی اشغال کنند که این امر بایگانی کردن آن‌ها را لازم می‌سازد. متداول‌ترین شیوه استفاده از یک بایگانی چرخشی است: فایل گزارش به صورت مداوم بایگانی می‌شود و تنها آخرین بایگانی <em
              class="replaceable">X</em> به صورت دست نخورده باقی می‌ماند. <code
              class="command">logrotate</code>، برنامه‌ای که مسئول این کار است از دستورات موجود در فایل <code
              class="filename">/etc/logrotate.conf</code> و تمام فایل‌هایی که در دایرکتوری <code
              class="filename">/etc/logrotate.d/</code> وجود دارند، استفاده می‌کند. مدیرسیستم شاید بخواهد این فایل‌ها را ویرایش کند، اگر قصد سازگاری با سیاست تعیین شده چرخش فایل در دبیان را داشته باشد. صفحه راهنمای <span
              class="citerefentry"><span
                class="refentrytitle">logrotate</span>(1)</span> شامل تمام گزینه‌های موجود در این فایل‌های پیکربندی است. شاید بخواهید تعداد فایل‌هایی که در هر چرخش حفظ می‌گردند را افزایش دهید یا فایل‌های چرخانده شده را به یک دایرکتوری خاص که برای بایگانی استفاده می‌شود جابجا کنید بجای آنکه آن‌ها حذف شوند. همچنین می‌توانید آن‌ها را با استفاده از ایمیل جهت بایگانی در جای دیگری ارسال کنید.
			</div><div
            class="para">
				برنامه <code
              class="command">logrotate</code> به صورت روزانه توسط برنامه زمان‌بندی <code
              class="command">cron</code> اجرا می‌شود (که در قسمت <a
              class="xref"
              href="sect.task-scheduling-cron-atd.html">
      قسمت 9.7, “زمان‌بندی وظیفه‌ها با <code
                class="command">cron</code> و <code
                class="command">atd</code>”
    </a> توضیح داده شده است).
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.sharing-admin-rights"></a>8.9.4. اشتراک‌گذاری دسترسی سطح بالا</h3></div></div></div><a
            id="id-1.11.13.6.2"
            class="indexterm"></a><a
            id="id-1.11.13.6.3"
            class="indexterm"></a><a
            id="id-1.11.13.6.4"
            class="indexterm"></a><div
            class="para">
				به طور مداوم، چند مدیرسیستم روی یک شبکه کار می‌کنند. اشتراک‌گذاری گذرواژه حساب root کار معقولی نیست، که باعث بروز سواستفاده با توجه به ماهیت نامشخص بودن کاربر استفاده کننده از این حساب می‌گردد. راه حل این مساله برنامه <code
              class="command">sudo</code> است که به برخی کاربران اجازه می‌دهد برخی برنامه‌ها را با مجوزهای سطح بالا اجرا کنند. در متداول‌ترین کاربرد، <code
              class="command">sudo</code> به کاربر مجاز اجازه استفاده از هر دستوری با مجوز حساب root را می‌دهد. به این منظور، کاربر تنها با وارد کردن دستور <code
              class="command">sudo <em
                class="replaceable">command</em></code> و درج گذرواژه خود می‌تواند دسترسی بالاتری پیدا کند.
			</div><div
            class="para">
				زمانی که نصب گردد، بسته <span
              class="pkg pkg">sudo</span> تمام مجوزهای کاربر root را به اعضای گروه یونیکس <code
              class="literal">sudo</code> اختصاص می‌دهد. برای افزودن سایر مجوزها، مدیرسیستم باید از دستور <code
              class="command">visudo</code> استفاده کرده که به وی اجازه ویرایش فایل <code
              class="filename">/etc/sudoers</code> را می‌دهد (در اینجا نیز ویرایشگر <code
              class="command">vi</code> انتخاب می‌شود، یا هر ویرایشگر دیگری که توسط متغیر محلی <code
              class="varname">EDITOR</code> مشخص شده باشد). افزودن خطی مانند <code
              class="literal"><em
                class="replaceable">username</em> ALL=(ALL) ALL</code> باعث می‌شود که کاربر مورد نظر تمام دستورات را با مجوزهای حساب root اجرا کند.
			</div><a
            id="id-1.11.13.6.7"
            class="indexterm"></a><a
            id="id-1.11.13.6.8"
            class="indexterm"></a><a
            id="id-1.11.13.6.9"
            class="indexterm"></a><div
            class="para">
				پیکربندی‌های پیچیده‌تر تنها اجازه دسترسی برخی دستورات را به کاربران می دهند. تمام جزئیات مربوط به این پیکربندی‌ها در صفحه راهنمای <span
              class="citerefentry"><span
                class="refentrytitle">sudoers</span>(5)</span> آمده است.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.fstab-mount-points"></a>8.9.5. فهرست نقاط اتصال</h3></div></div></div><a
            id="id-1.11.13.7.2"
            class="indexterm"></a><a
            id="id-1.11.13.7.3"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>بازگشت به مقدمات</em></span> قطع و وصل کردن</strong></p></div></div></div><div
              class="para">
				در یک سیستم شبه-یونیکس مانند دبیان، فایل‌ها در یک سلسله‌مراتب درختی از دایرکتوری‌ها سازماندهی شده‌اند. دایرکتوری <code
                class="filename">/</code> با نام “ریشه” شناخته می‌شود؛ تمام دایرکتوری‌های اضافه زیر مجموعه دایرکتوری ریشه به حساب می‌آیند. “متصل‌کردن” به عمل اتصال محتوای یک دستگاه جانبی (اغلب یک هارد درایو) به این ساختار درختی اطلاق می‌شود. به همین دلیل، اگر از هارد درایو جداگانه‌ای برای ذخیره‌سازی محتویات کابران استفاده می‌کنید این دیسک باید در مسیر <code
                class="filename">/home</code> به اصطلاح “mount” شود. فایل‌سیستم ریشه همیشه در زمان راه‌اندازی اولیه توسط کرنل متصل می‌شود؛ سایر دستگاه‌ها در زمان دیگری یا به صورت دستی توسط دستور <code
                class="command">mount</code> متصل می‌گردند.
			</div><a
              id="id-1.11.13.7.4.3"
              class="indexterm"></a><div
              class="para">
				Some removable devices are automatically mounted when connected, especially when using the GNOME, Plasma or other graphical desktop environments. Others have to be mounted manually by the user. Likewise, they must be unmounted (removed from the file tree). Normal users do not usually have permission to execute the <code
                class="command">mount</code> and <code
                class="command">umount</code> commands. The administrator can, however, authorize these operations (independently for each mount point) by including the <code
                class="literal">user</code> option in the <code
                class="filename">/etc/fstab</code> file.
			</div><div
              class="para">
				دستور <code
                class="command">mount</code> می‌تواند بدون پارامتر اجرا گردد (که فهرستی از فایل‌سیستم‌های متصل شده را نمایش می‌دهد). پارامترهای پیش رو برای اتصال یا عدم اتصال یک دستگاه مورد نیاز هستند. برای فهرست کامل‌تر به صفحات راهنمای <span
                class="citerefentry"><span
                  class="refentrytitle">mount</span>(8)</span> و <span
                class="citerefentry"><span
                  class="refentrytitle">umount</span>(8)</span> مراجعه کنید. برای موارد ساده، شیوه نگارش نیز ساده است: برای نمونه، جهت اتصال پارتیشن <code
                class="filename">/dev/sdc1</code>، که یک فایل‌سیستم ext3 دارد، به دایرکتوری <code
                class="filename">/mnt/tmp/</code>، به راحتی می‌توانید دستور <code
                class="command">mount -t ext3 /dev/sdc1 /mnt/tmp/</code> را اجرا کنید.
			</div></div><div
            class="para">
				فایل <code
              class="filename">/etc/fstab</code> فهرستی از تمام اتصال‌های موجود در سیستم که به صورت خودکار یا دستی صورت گرفته‌اند را نمایش می‌دهد. هر نقطه اتصال توسط یک خط به همراه چندین عبارت که با فاصله جدا شده‌اند مشخص است: <a
              id="id-1.11.13.7.5.2"
              class="indexterm"></a> <a
              id="id-1.11.13.7.5.3"
              class="indexterm"></a>
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						file system: this indicates where the filesystem to be mounted can be found, it can be a local device (hard drive partition, CD-ROM) or a remote filesystem (such as NFS).
					</div><div
                  class="para">
						این فیلد معمولا توسط شناسه منحصربفرد فایل‌سیستم جایگزین می‌شود (که می‌توانید با دستور <code
                    class="command">blkid <strong
                      class="userinput"><code>device</code></strong></code> مشخص کنید) که پیشوند <code
                    class="literal">UUID=</code> دارد. این رویکرد درباره تغییرات احتمالی آینده در نام دستگاه یا ترتیبی که در رایانه قرار گرفته است، محافظت می‌کند.
					</div></li><li
                class="listitem"><div
                  class="para">
						نقطه اتصال: دایرکتوری در فایل‌سیستم محلی که دستگاه، سیستم راه‌دور یا پارتیشن در آن قرار می‌گیرد.
					</div></li><li
                class="listitem"><div
                  class="para">
						نوع: این فیلد نشان‌دهنده نوع فایل‌سیستم استفاده شده در روی دستگاه است. <code
                    class="literal">ext4</code>، <code
                    class="literal">ext3</code>، <code
                    class="literal">vfat</code>، <code
                    class="literal">ntfs</code>، <code
                    class="literal">btrfs</code> و <code
                    class="literal">xfs</code> برخی از گزینه‌ها هستند.
					</div><div
                  class="sidebar"><div
                    class="titlepage"><div><div><p
                          class="title"><strong><span
                              class="emphasis"><em>بازگشت به مقدمات</em></span> NFS، یک فایل‌سیستم شبکه</strong></p></div></div></div><div
                    class="para">
						NFS یک فایل‌سیستم تحت شبکه است؛ در لینوکس، اجازه دسترسی بدون واسطه به فایل‌های راه‌دور با درج آن‌ها در فایل‌سیستم محلی را صادر می‌کند.
					</div></div><div
                  class="para">
						فهرست کاملی از فایل‌سیستم‌های شناخته شده در صفحه راهنمای <span
                    class="citerefentry"><span
                      class="refentrytitle">mount</span>(8)</span> وجود دارد. مقدار ویژه <code
                    class="literal">swap</code> برای پارتیشن‌های swap استفاده می‌شود؛ مقدار ویژه <code
                    class="literal">auto</code> به دستور <code
                    class="command">mount</code> می‌گوید که خود نوع فایل‌سیستم را تشخیص دهد (که معمولا برای کارت‌های حافظه و ذخیره‌سازهای USB بسیار مفید است، چرا که هر یک ممکن است فایل‌سیستم جداگانه‌ای داشته باشند)؛
					</div></li><li
                class="listitem"><div
                  class="para">
						گزینه‌ها: تعداد زیادی هستند که بر اساس نوع فایل‌سیستم متفاوت عمل می‌کنند، آن‌ها در صفحه راهنمای <code
                    class="command">mount</code> مستندسازی شده‌اند. متداول‌ترین آن‌ها عبارتند از
					</div><div
                  class="itemizedlist"><ul><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">rw</code> یا <code
                          class="literal">ro</code> که به معنی دسترسی خواندنی/نوشتی یا فقط خواندنی هستند.
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">noauto</code> اتصال خودکار هنگام راه‌اندازی اولیه را غیرفعال می‌کند.
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">nofail</code> به فرآیند راه‌اندای اجازه می‌دهد که در صورت نبودن دستگاه نیز به کار خود ادامه دهد. اطمینان یابید که از این گزینه برای دستگاه‌های خارجی که ممکن است در زمان راه‌اندازی وصل نباشند استفاده می‌کنید، چرا که <code
                          class="command">systemd</code> اطمینان می‌یابد تمام دستگاه‌های مورد نیاز برای اتصال به فایل‌سیستم واقعا وصل شده باشند و اگر این اتفاق نیفتند اجازه پیشروی فرآیند راه‌اندازی سیستم را نمی‌دهد. نکته اینکه می‌توانید آن را با <code
                          class="literal">x-systemd.device-timeout=5s</code> ترکیب کرده که به ... بگویید بیش از ۵ ثانیه برای ظاهرشدن دستگاه منتظر نماند (قسمت <span
                          class="citerefentry"><span
                            class="refentrytitle">systemd.mount</span>(5)</span> را مشاهده کنید).
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">user</code> به تمام کاربران اجازه اتصال به این فایل‌سیستم را می‌دهد (عملیاتی که معمولا محدود به کاربر root است.)
							</div></li><li
                      class="listitem"><div
                        class="para">
								<code
                          class="literal">defaults</code> به معنی گروهی از گزینه‌های پیش‌فرض است: <code
                          class="literal">rw</code>، <code
                          class="literal">suid</code>، <code
                          class="literal">dev</code>، <code
                          class="literal">exec</code>، <code
                          class="literal">auto</code>، <code
                          class="literal">nouser</code> و <code
                          class="literal">async</code>، که هر کدام در ادامه می‌توانند غیرفعال شوند <code
                          class="literal">defaults</code> با اضافه کردن <code
                          class="literal">nosuid</code>، <code
                          class="literal">nodev</code> و به همین شکل به منظور مسدودکردن <code
                          class="literal">suid</code>، <code
                          class="literal">dev</code> و سایر موارد. افزودن گزینه <code
                          class="literal">user</code> آن‌ها را دوباره فعال می‌کند چرا که <code
                          class="literal">defaults</code> شامل <code
                          class="literal">nouser</code> می‌شود.
							</div></li></ul></div></li><li
                class="listitem"><div
                  class="para">
						dump: this field is almost always set to <code
                    class="literal">0</code>. When it is <code
                    class="literal">1</code>, it tells the <code
                    class="command">dump</code> tool that the partition contains data that is to be backed up.
					</div></li><li
                class="listitem"><div
                  class="para">
						pass: this last field indicates whether the integrity of the filesystem should be checked on boot, and in which order this check should be executed. If it is <code
                    class="literal">0</code>, no check is conducted. The root filesystem should have the value <code
                    class="literal">1</code>, while other permanent filesystems get the value <code
                    class="literal">2</code>.
					</div></li></ul></div><div
            class="example"><a
              xmlns=""
              id="example.fstab"></a><p
              class="title"><strong>
      مثال 8.6. نمونه فایل <code
                  class="filename">/etc/fstab</code></strong></p><div
              class="example-contents"><pre
                class="programlisting">
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
# swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0</pre></div></div><div
            class="para">
				آخرین خط این مثال شامل یک فایل‌سیستم NFS می‌باشد: دایرکتوری <code
              class="filename">/shared/</code> از سرور <span
              class="emphasis"><em>arrakis</em></span> به دایرکتوری <code
              class="filename">/shared/</code> در سیستم محلی متصل شده است. قالب فایل <code
              class="filename">/etc/fstab</code> در صفحه راهنمای <span
              class="citerefentry"><span
                class="refentrytitle">fstab</span>(5)</span> آورده شده است.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>مطالعه بیشتر</em></span> اتصال خودکار</strong></p></div></div></div><div
              class="para">
				systemd is able to manage automount points: those are filesystems that are mounted on-demand when a user attempts to access their target mount points. It can also unmount these filesystems when no process is accessing them any longer.
			</div><div
              class="para">
				Like most concepts in systemd, automount points are managed with dedicated units (using the <code
                class="literal">.automount</code> suffix). See <span
                class="citerefentry"><span
                  class="refentrytitle">systemd.automount</span>(5)</span> for their precise syntax.
			</div><a
              id="id-1.11.13.7.9.4"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.5"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.6"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.7"
              class="indexterm"></a><a
              id="id-1.11.13.7.9.8"
              class="indexterm"></a><div
              class="para">
				Other auto-mounting utilities exist, such as <code
                class="command">automount</code> in the <span
                class="pkg pkg">autofs</span> package or <code
                class="command">amd</code> in the <span
                class="pkg pkg">am-utils</span>.
			</div><div
              class="para">
				Note also that GNOME, Plasma, and other graphical desktop environments work together with <span
                class="emphasis"><em>udisks</em></span>, and can automatically mount removable media when they are connected.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.locate-updatedb"></a>8.9.6. <code
                    class="command">locate</code> و <code
                    class="command">updatedb</code></h3></div></div></div><a
            id="id-1.11.13.8.2"
            class="indexterm"></a><a
            id="id-1.11.13.8.3"
            class="indexterm"></a><a
            id="id-1.11.13.8.4"
            class="indexterm"></a><div
            class="para">
				دستور <code
              class="command">locate</code> زمانی که بخشی از نام فایل را بدانید می‌تواند برای یافتن محل آن به شما کمک کند. نتیجه این جستجو تقریبا بدون کوچکترین وقفه‌ای نمایش داده می‌شود چرا که از پایگاه‌داده‌ای استفاده می‌کند که شامل تمام فایل‌های موجود در سیستم است؛ این پایگاه‌داده به صورت روزانه توسط دستور <code
              class="command">updatedb</code> بروزرسانی می‌گردد. پیاده‌سازی‌های گوناگونی از دستور <code
              class="command">locate</code> وجود دارد و دبیان از <span
              class="pkg pkg">mlocate</span> برای سیستم استاندارد خود بهره می‌گیرد.
			</div><div
            class="para">
				<code
              class="command">mlocate</code> به اندازه‌ای هوشمند است که تنها فایل‌هایی را به کاربر نمایش دهد که وی مجاز به مشاهده آن‌ها باشد، با اینکه به تمام فایل‌های موجود روی سیستم دسترسی دارد (از آنجا که پیاده‌سازی <code
              class="command">updatedb</code> آن با مجوزهای root انجام می‌شود). برای امنیت بیشتر، مدیرسیستم می‌تواند از متغیر <code
              class="varname">PRUNEDPATHS</code> در فایل <code
              class="filename">/etc/updatedb.conf</code> به منظور خارج‌سازی برخی دایرکتوری‌ها از فرآیند شاخص‌گذاری استفاده کند.
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.config-bootloader.html"><strong>قبلی</strong>8.8. پیکربندی راه‌انداز اولیه</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>بالا</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>خانه</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.kernel-compilation.html"><strong>بعدی</strong>8.10. کامپایل یک کرنل</a></li></ul></body></html>
