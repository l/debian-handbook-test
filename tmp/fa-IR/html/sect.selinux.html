<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.5. مقدمه‌ای بر SELinux</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-fa-IR-1.0-1" /><meta
        name="keywords"
        content="فایروال, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="راهنمای دبیان برای مدیر سیستم‌ها" /><link
        rel="up"
        href="security.html"
        title="فصل 14. امنیت" /><link
        rel="prev"
        href="sect.apparmor.html"
        title="14.4. مقدمه‌ای بر AppArmor" /><link
        rel="next"
        href="sect.other-security-considerations.html"
        title="14.6. سایر ملاحظات مرتبط با امنیت" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/fa-IR/stable/sect.selinux.html" /></head><body
      dir="rtl"><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.apparmor.html"><strong>قبلی</strong></a></li><li
          class="home">راهنمای دبیان برای مدیر سیستم‌ها</li><li
          class="next"><a
            accesskey="n"
            href="sect.other-security-considerations.html"><strong>بعدی</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.selinux"></a>14.5. مقدمه‌ای بر SELinux</h2></div></div></div><a
          id="id-1.17.8.2"
          class="indexterm"></a><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.selinux-principles"></a>14.5.1. اصول</h3></div></div></div><div
            class="para">
				SELinux که مخفف عبارت <span
              class="emphasis"><em>Security Enhanced Linux</em></span> است، یک سیستم <span
              class="emphasis"><em>Mandatory Access Control</em></span> مبتنی بر رابط LSM یا <span
              class="emphasis"><em>Linux Security Modules</em></span> در لینوکس است. در عمل، کرنل قبل از هر فراخوانی سیستمی از SELinux پرس و جو می‌کند آیا فرآیند جاری مجاز به اجرای عملیات فوق‌الذکر می‌باشد یا خیر.
			</div><div
            class="para">
				SELinux از مجموعه قوانین - که بنام <span
              class="emphasis"><em>policy</em></span> شناخته می‌شوند - استفاده کرده تا عملیات را مجاز یا ممنوع کند. این قوانین به سختی ایجاد می‌شوند. خوشبختانه، دو خط مشی استاندارد <span
              class="emphasis"><em>targeted</em></span> و <span
              class="emphasis"><em>strict</em></span> فراهم شده‌اند که طیف گسترده‌ای از کار را بر عهده می‌گیرند.
			</div><div
            class="para">
				با استفاده از SELinux، مدیریت دسترسی به شیوه‌ای کاملا متفاوت با سیستم‌های سنتی یونیکس انجام می‌شود. دسترسی یک فرآیند کاملا مبتنی بر <span
              class="emphasis"><em>زمینه امنیتی</em></span> آن خواهد بود. این زمینه توسط <span
              class="emphasis"><em>شناسه</em></span> کاربری که فرآیند را آغاز کرده است تعریف می‌شود، همراه با <span
              class="emphasis"><em>نقش</em></span> و <span
              class="emphasis"><em>دامنه</em></span> که کاربر در آن زمان داشته است. این حقوق کاملا مبتنی بر دامنه کار هستند، اما انتقال بین دامنه‌ها توسط نقش‌های کاربری کنترل می‌شود. در نهایت، انتقال‌های احتمالی بین چند نقش مبتنی بر شناسه کاربری خواهد بود.
			</div><div
            class="figure"><a
              xmlns=""
              id="id-1.17.8.3.5"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/selinux-context.png"
                  alt="زمینه‌های امنیتی و کاربران یونیکس" /></div></div><p
              class="title"><strong>
      شكل 14.3. زمینه‌های امنیتی و کاربران یونیکس</strong></p></div><div
            class="para">
				در عمل، حین ورود به سیستم، یک زمینه امنیتی پیشفرض به کاربر اختصاص می‌یابد (با توجه به نقش‌هایی که مجاز به دریافت آن هستند). این عمل دامنه فعلی را تعریف می‌کند که در آن تمام فرآیندهای فرزند نگهداری می‌شوند. اگر قصد تغییر نقش فعلی و دامنه اختصاصی آن را دارید باید از دستور <code
              class="command">newrole -r <em
                class="replaceable">role_r</em> -t <em
                class="replaceable">domain_t</em></code> استفاده کنید (معمولا تنها یک دامنه منفرد برای هر نقش وجود دارد، پس پارامتر <code
              class="literal">-t</code> می‌تواند حذف گردد). این دستور با درخواست گذرواژه، شما را احرازهویت می‌‌کند. این ویژگی باعث می‌شود که برنامه‌ها به صورت خودکار نتوانند بین نقش‌ها تعویض شوند. چنین تغییراتی تنها زمانی اتفاق می‌افتند که به صورت صریح در خط مشی SELinux آمده باشند.
			</div><div
            class="para">
				به طور مشخص این دسترسی‌ها به تمام <span
              class="emphasis"><em>اشیا</em></span> متعلق نیستند (فایل‌ها، دایرکتوری‌ها، سوکت‌ها، دستگاه‌ها و از این قبیل). می‌توانند از هر شی به دیگری متفاوت باشند. برای دستیابی به این منظور، هر شی به یک <span
              class="emphasis"><em>نوع</em></span> اختصاص می‌یابد (اینکار بنام برچسب‌گذاری شناخته می‌شود). دسترسی‌های یک دامنه توسط مجموعه‌ای از عمیات (غیر)مجاز روی این انواع بیان می‌شوند (و به طور غیرمستقیم، روی تمام اشیایی که با این نوع برچسب‌گذاری شده‌اند).
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>اضافی</em></span> دامنه‌ها و انواع برابر هستند</strong></p></div></div></div><div
              class="para">
				در ساختار درونی، یک دامنه تنها یک نوع است که فقط به فرآیندها اختصاص می‌یابد. به همین دلیل است که دامنه‌ها همراه با پسوند <code
                class="literal">_t</code> درست مانند سایر انواع اشیا بکار می‌روند.
			</div></div><div
            class="para">
				به صورت پیشفرض، یک برنامه دامنه خود را از کاربری که فرآیند را آغاز کرده است به ارث می‌برد، اما خطی مشی استاندارد SELinux انتظار دارد که برنامه‌های مهم در دامنه‌های اختصاصی اجرا شوند. برای دستیابی به این منظور، آن برنامه‌های اجرایی همراه با یک نوع اختصاصی برچسب‌گذاری می‌شوند (برای نمونه <code
              class="command">ssh</code> توسط <code
              class="literal">ssh_exec_t</code> برچسب‌گذاری شده و زمانی که برنامه آغاز شود به صورت خودکار به دامنه <code
              class="literal">ssh_t</code> تغییر می‌یابد). این مکانیزم خودکار انتقال دامنه امکان اختصاص دسترسی‌های لازم برای هر بر نامه را فراهم می‌کند. این یک اصل پایه در SELinux به حساب می‌آید.
			</div><div
            class="figure"><a
              xmlns=""
              id="id-1.17.8.3.10"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/selinux-transitions.png"
                  alt="انتقال خودکار بین دامنه‌ها" /></div></div><p
              class="title"><strong>
      شكل 14.4. انتقال خودکار بین دامنه‌ها</strong></p></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>در عمل</em></span> یافتن زمینه امنیتی</strong></p></div></div></div><a
              id="id-1.17.8.3.11.2"
              class="indexterm"></a><a
              id="id-1.17.8.3.11.3"
              class="indexterm"></a><a
              id="id-1.17.8.3.11.4"
              class="indexterm"></a><div
              class="para">
				برای یافتن زمینه امنیتی یک فرآیند، باید از گزینه <code
                class="literal">Z</code> دستور <code
                class="command">ps</code> استفاده کنید.
			</div><pre
              class="screen"><code
                class="computeroutput">$ </code><strong
                class="userinput"><code>ps axZ | grep vstfpd</code></strong>
<code
                class="computeroutput">system_u:system_r:ftpd_t:s0   2094 ?    Ss  0:00 /usr/sbin/vsftpd</code></pre><div
              class="para">
				فیلد اول شامل شناسه، نقش، دامنه و سطح MCS است که با کاما جدا شده‌اند. سطح MCS یا <span
                class="emphasis"><em>Multi-Category Security</em></span> پارامتری است که در برپایی محرمانگی از محافظت خط مشی دخالت دارد، که دسترسی به فایل‌ها را مبتنی بر میزان حساسیت آن‌ها کنترل می‌کند. این ویژگی در کتاب توضیح داده نمی‌شود.
			</div><div
              class="para">
				برای یافتن زمینه امنیتی در یک پوسته، باید <code
                class="command">id -Z</code> را فراخوانی کنید.
			</div><pre
              class="screen"><code
                class="computeroutput">$ </code><strong
                class="userinput"><code>id -Z</code></strong>
<code
                class="computeroutput">unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><div
              class="para">
				در نهایت، برای یافتن نوع اختصاص یافته به یک فایل، می‌توانید از <code
                class="command">ls -Z</code> استفاده کنید.
			</div><pre
              class="screen"><code
                class="computeroutput">$ </code><strong
                class="userinput"><code>ls -Z test /usr/bin/ssh</code></strong>
<code
                class="computeroutput">unconfined_u:object_r:user_home_t:s0 test
     system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</code></pre><div
              class="para">
				شایان ذکر است که شناسه و نقش اختصاص یافته به یک فایل از اهمیت خاصی برخوردار نیستند (هیچگاه استفاده نمی‌شوند)، اما به دلیل یکنواخت بودن، تمام اشیا شامل زمینه امنیتی کاملی خواهند بود.
			</div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.selinux-setup"></a>14.5.2. راه‌اندازی SELinux</h3></div></div></div><div
            class="para">
				پشتیبانی از SELinux درون کرنل‌های استاندارد دبیان قرار دارد. ابزار اصلی یونیکس از SELinux بدون کوچک‌ترین تغییری پشتیبانی می‌کنند. بنابراین فعال‌سازی SELinux کار به نسبت ساده‌ای است.
			</div><div
            class="para">
				دستور <code
              class="command">apt install selinux-basics selinux-policy-default</code> به صورت خودکار تمام بسته‌های مورد نیاز برای پیکربندی یک سیستم SELinux را نصب می‌کند.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>احتیاط</em></span> نبود خط مشی مرجع در توزیع jessie</strong></p></div></div></div><div
              class="para">
				متاسفانه، نگهدارندگان بسته سورس <span
                class="pkg pkg">refpolicy</span> اقدام به رفع باگ‌های حیاتی در بسته خود نکرده و این بسته از jessie حذف شده است. به این معنی که بسته‌های <span
                class="pkg pkg">selinux-policy-*</span> در حال حاضر قادر به نصب در jessie نبوده و باید از منبع دیگری دریافت گردند. امیدواریم که این بسته‌ها در یکی از انتشارهای نقطه‌ای یا jessie-backports قرار گیرند. در حال حاضر، می‌توانید آن‌ها را از قسمت unstable دریافت کنید.
			</div><div
              class="para">
				این موقعیت ناراحت‌کننده حداقل نشان می‌دهد که SELinux در مجموعه کاربران/توسعه‌دهندگان که نسخه‌های در حال توسعه دبیان را اجرا می‌کنند از محبوبیت بالایی برخوردار نیست. پس، اگر مجبور به استفاده از SELinux هستید، باید انتظار داشته باشید که خط مشی پیشفرض آن به درستی کار نکند و شاید نیاز باشد زمان بیشتری را برای برطرف کردن نیاز خاص خود با استفاده از آن در نظر بگیرید.
			</div></div><div
            class="para">
				بسته <span
              class="pkg pkg">selinux-policy-default</span> شامل مجموعه قوانین استاندارد است. به صورت پیشفرض، این خط مشی تنها دسترسی به برخی سرویس‌های مشخص را محدود می‌کند. نشست‌های سمت کاربر محدود نیستند و از این رو بعید بنظر می‌رسد که SELinux عملیات مرتبط با کاربران مجاز را مسدود سازد. با این حال، اینکار منجر به بهبود امنیت سرویس‌های سیستمی می‌شود. برای راه‌انداری خط مشی که برابر با قوانین “strict” قدیمی باشد، تنها باید ماژول <code
              class="literal">unconfined</code> را غیرفعال کنید (مدیریت ماژول‌ها در ادامه آورده می‌شود).
			</div><div
            class="para">
				زمانی که خط مشی مشخص گردد، باید تمام فایل‌های موجود را برچسب‌گذاری کنید (به این معنی که یک نوع به آن‌ها اختصاص دهید). این عملیات باید به صورت دستی توسط <code
              class="command">fixfiles relabel</code> صورت پذیرد.
			</div><div
            class="para">
				اکنون سیستم SELinux آماده است. برای فعال‌سازی آن، باید پارامتر <code
              class="literal">selinux=1 security=selinux</code> را به کرنل لینوکس اضافه کنید. پارامتر <code
              class="literal">enforcing=1</code> امکان ثبت گزارش در SELinux که تمام عملیات غیرمجاز را ثبت می‌کند. در نهایت، پارامتر <code
              class="literal">audit=1</code> قوانین را برای برنامه‌ها اجرایی می‌کند: بدون این پارامتر SELinux در حالت پیشفرض <span
              class="emphasis"><em>permissive</em></span> خود فعالیت کرده به صورتی که عملیات غیرمجاز ثبت شده ولی هنوز اجرا می‌شوند. برای افزودن پارامترهای مورد نیاز باید فایل پیکربندی راه‌انداز GRUB را تغییر دهید. یک روش ساده برای اینکار تغییر متغیر <code
              class="literal">GRUB_CMDLINE_LINUX</code> در <code
              class="filename">/etc/default/grub</code> و اجرای <code
              class="command">update-grub</code> است. SELinux پس از راه‌اندازی مجدد سیستم فعال‌سازی می‌شود.
			</div><div
            class="para">
				شایان ذکر است که اسکریپت <code
              class="command">selinux-activate</code> این عملیات را خودکارسازی کرده و در راه‌اندازی بعدی عملیات برچسب‌گذاری را انجام می‌دهد (که این عمل از ایجاد فایل‌های برچسب‌گذاری نشده در زمان غیرفعال بودن SELinux و زمانی که عملیات برچسب‌گذاری انجام می‌شود، پیشگیری می‌کند).
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.selinux-management"></a>14.5.3. مدیریت یک سیستم SELinux</h3></div></div></div><a
            id="id-1.17.8.5.2"
            class="indexterm"></a><a
            id="id-1.17.8.5.3"
            class="indexterm"></a><div
            class="para">
				خط مشی SELinux مجموعه‌ای از قوانین ماژولار است که نصب آن با شناسایی و فعال‌سازی خودکار تمام ماژول‌های مبتنی بر سرویس‌های نصب شده فعالیت می‌کند. از این رو سیستم بلافاصله قابل استفاده است. با این حال، زمانی که یک سرویس پس از خط مشی SELinux نصب می‌شود، باید قادر باشید تا ماژول مرتبط با آن را فعال‌سازی کنید. هدف دستور <code
              class="command">semodule</code> نیز همین است. علاوه بر این، باید بتوانید نقش‌های مورد نیاز هر کاربر را تعریف کنید که اینکار با استفاده از دستور <code
              class="command">semanage</code> انجام می‌شود.
			</div><div
            class="para">
				این دو دستور می‌توانند به منظور تغییر پیکربندی SELinux، که در <code
              class="filename">/etc/selinux/default/</code> ذخیره‌سازی شده است، بکار روند. برخلاف تمام فایل‌های پیکربندی که می‌توانید در <code
              class="filename">/etc/</code> پیدا کنید، این فایل‌ها نباید به صورت دستی تغییر یابند. باید از برنامه‌های مخصوص برای تغییر آن‌ها استفاده کنید.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>مطالعه بیشتر</em></span> مستندات بیشتر</strong></p></div></div></div><div
              class="para">
				از آنجا که NSA هیچ مستندات رسمی در این حوزه ارائه نمی‌دهد، جامعه کاربری اقدام به برپایی یک ویکی برای جبران این مساله نموده است. اطلاعات زیادی در این ویکی وجود دارد، اما باید آگاه باشید که اغلب مشارکت‌کنندگان به SELinux کاربران فدورا هستند (که SELinux در آن به صورت پیشفرض نصب شده است). از این رو مستندات بیشتر در رابطه با این توزیع گردآوری شده است. <div
                xmlns=""
                class="url">→ <a
                  xmlns="http://www.w3.org/1999/xhtml"
                  href="http://www.selinuxproject.org">http://www.selinuxproject.org</a></div>
			</div><div
              class="para">
				همچنین باید نگاهی به ویکی اختصاصی دبیان همراه با وبلاگ راسل کوکر بیندازید، که یکی از فعال‌ترین توسعه‌دهندگان دبیان در پشتیبانی از SELinux است. <div
                xmlns=""
                class="url">→ <a
                  xmlns="http://www.w3.org/1999/xhtml"
                  href="http://wiki.debian.org/SELinux">http://wiki.debian.org/SELinux</a></div> <div
                xmlns=""
                class="url">→ <a
                  xmlns="http://www.w3.org/1999/xhtml"
                  href="http://etbe.coker.com.au/tag/selinux/">http://etbe.coker.com.au/tag/selinux/</a></div>
			</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.5.7"></a>14.5.3.1. مدیریت ماژول‌های SELinux</h4></div></div></div><div
              class="para">
					ماژول‌های موجود SELinux درون دایرکتوری <code
                class="filename">/usr/share/selinux/default/</code> قرار دارند. برای فعال‌سازی یکی از این ماژول‌ها در پیکربندی فعلی، باید از <code
                class="command">semodule -i <em
                  class="replaceable">module.pp.bz2</em></code> استفاده کنید. پسوند <span
                class="emphasis"><em>pp.bz2</em></span> مخفف عبارت <span
                class="emphasis"><em>policy package</em></span> است (که توسط bzip2 فشرده‌سازی شده است).
				</div><div
              class="para">
					حذف یک ماژول از پیکربندی موجود با استفاده از <code
                class="command">semodule -r <em
                  class="replaceable">module</em></code> صورت می‌پذیرد. در نهایت، دستور <code
                class="command">semodule -l</code> فهرستی از تمام ماژول‌های نصب شده را نشان می‌دهد. همچنین شماره نسخه را نیز نمایش می‌دهد. ماژول‌ها می‌توانند توسط <code
                class="command">semodule -e</code> فعال یا <code
                class="command">semodule -d</code> غیرفعال شوند.
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -i /usr/share/selinux/default/abrt.pp.bz2</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -l</code></strong>
<code
                class="computeroutput">abrt    1.5.0   Disabled
accountsd       1.1.0   
acct    1.6.0   
[...]</code>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -e abrt</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -d accountsd</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -l</code></strong>
<code
                class="computeroutput">abrt    1.5.0
accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</code>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -r abrt</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semodule -l</code></strong>
<code
                class="computeroutput">accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</code></pre><div
              class="para">
					<code
                class="command">semodule</code> بلافاصله پیکربندی جدید را بارگیری می‌کند مگر اینکه از گزینه <code
                class="literal">-n</code> استفاده کنید. شایان ذکر است که برنامه به صورت پیشفرض با پیکربندی فعلی کار می‌کند (که توسط متغیر <code
                class="literal">SELINUXTYPE</code> در <code
                class="filename">/etc/selinux/config</code> مشخص شده است)، اما می‌توانید آن را با استفاده از گزینه <code
                class="literal">-s</code> تغییر دهید.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.5.8"></a>14.5.3.2. مدیریت شناسه‌ها</h4></div></div></div><div
              class="para">
					هر مرتبه که کاربر وارد سیستم می‌شود، یک شناسه SELinux به وی اختصاص می‌یابد. این شناسه مشخص می‌کند کاربر از چه نقش‌هایی می‌تواند استفاده کند. این دو نگاشت (از کاربر به شناسه و از شناسه به نقش‌ها) توسط دستور <code
                class="command">semanage</code> قابل پیکربندی هستند.
				</div><div
              class="para">
					حتی اگر شیوه نگارش دستور با مفاهیم مطرح شده مشابه باشد، باید صفحه راهنمای <span
                class="citerefentry"><span
                  class="refentrytitle">semanage</span>(8)</span> را مطالعه کنید. گزینه‌های مشابهی برای دستورات زیر-مجموعه پیدا خواهید کرد: <code
                class="literal">-a</code> برای افزودن، <code
                class="literal">-d</code> برای حذف، <code
                class="literal">-m</code> برای تغییر، <code
                class="literal">-l</code> برای فهرست کردن و <code
                class="literal">-t</code> برای مشخص کردن یک نوع (یا دامنه).
				</div><div
              class="para">
					<code
                class="command">semanage login -l</code> نگاشت فعلی بین شناسه‌های کاربر و هویت‌های SELinux را فهرست می‌کند. کاربرانی که هیچ مدخل واضحی ندارند از شناسه موجود در مدخل <code
                class="literal">__default__</code> استفاده می‌کنند. دستور <code
                class="command">semanage login -a -s user_u <em
                  class="replaceable">user</em></code> شناسه <span
                class="emphasis"><em>user_u</em></span> را به کاربر مورد نظر اختصاص می‌دهد. در نهایت، <code
                class="command">semanage login -d <em
                  class="replaceable">user</em></code> نگاشت موجود برای کاربر را از بین می‌برد.
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage login -a -s user_u rhertzog</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage login -l</code></strong>
<code
                class="computeroutput">
Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         SystemLow-SystemHigh *
rhertzog             user_u               SystemLow            *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *
# </code><strong
                class="userinput"><code>semanage login -d rhertzog</code></strong></pre><div
              class="para">
					<code
                class="command">semanage user -l</code> نگاشت فعلی بین شناسه‌های کاربری SELinux و نقش‌های مجاز را فهرست می‌کند. افزودن یک شناسه جدید مستلزم تعریف نقش‌های مرتبط با آن همراه با پیشوند برچسب‌گذاری برای اختصاص نوع به فایل‌های شخصی کاربر می‌باشد (<code
                class="filename">/home/<em
                  class="replaceable">user</em>/*</code>). پیشوند باید از میان <code
                class="literal">user</code>، <code
                class="literal">staff</code> یا <code
                class="literal">sysadm</code> انتخاب شود. پیشوند “<code
                class="literal">staff</code>” روی فایل‌هایی از نوع “<code
                class="literal">staff_home_dir_t</code>” تاثیر می‌گذارد. ایجاد یک شناسه کاربری جدید SELinux توسط <code
                class="command">semanage user -a -R <em
                  class="replaceable">roles</em> -P <em
                  class="replaceable">prefix</em> <em
                  class="replaceable">identity</em></code> انجام می‌شود. در نهایت، با استفاده از <code
                class="command">semanage user -d <em
                  class="replaceable">identity</em></code> می‌توانید یک شناسه کاربری SELinux را حذف کنید.
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage user -a -R 'staff_r user_r' -P staff test_u</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>semanage user -l</code></strong>
<code
                class="computeroutput">
                Labeling   MLS/       MLS/                          
SELinux User    Prefix     MCS Level  MCS Range             SELinux Roles

root            sysadm     SystemLow  SystemLow-SystemHigh  staff_r sysadm_r system_r
staff_u         staff      SystemLow  SystemLow-SystemHigh  staff_r sysadm_r
sysadm_u        sysadm     SystemLow  SystemLow-SystemHigh  sysadm_r
system_u        user       SystemLow  SystemLow-SystemHigh  system_r
test_u          staff      SystemLow  SystemLow             staff_r user_r
unconfined_u    unconfined SystemLow  SystemLow-SystemHigh  system_r unconfined_r
user_u          user       SystemLow  SystemLow             user_r
# </code><strong
                class="userinput"><code>semanage user -d test_u</code></strong></pre></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.5.9"></a>14.5.3.3. مدیریت زمینه‌های فایل، درگاه‌ها و شرایط منطقی</h4></div></div></div><div
              class="para">
					هر ماژول SELinux مجموعه‌ای از قوانین برچسب‌گذاری را تعریف می‌کند، اما امکان تعریف قوانین سفارشی برای برچسب‌گذاری نیز وجود دارد. برای نمونه، اگر می‌خواهید که سرور وب قادر باشد فایل‌های درون دایرکتوری <code
                class="filename">/srv/www/</code> را بخواند، می‌توانید دستور <code
                class="command">semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"</code> را همراه با <code
                class="command">restorecon -R /srv/www/</code> اجرا کنید. دستور اول قوانین جدید برچسب‌گذاری را ثبت و دستور دوم انواع فایل را متناسب با قوانین جدید برچسب‌گذاری می‌کند.
				</div><div
              class="para">
					به طور مشابه، درگاه‌های TCP/UDP به شیوه‌ای برچسب‌گذاری می‌شوند که تنها فرآیندهای پس‌زمینه متناسب بتوانند به آن‌ها گوش دهند. برای نمونه، اگر می‌خواهید سرور وب به درگاه ۸۰۸۰ گوش دهد، باید <code
                class="command">semanage port -m -t http_port_t -p tcp 8080</code> را اجرا کنید.
				</div><div
              class="para">
					برخی ماژول‌های SELinux گزینه‌های منطقی‌ای را استخراج می‌کنند که با استفاده از آن‌ها می‌توانید عملکرد قوانین پیشفرض را تغییر دهید. از ابزار <code
                class="command">getsebool</code> می‌توان برای شناسایی این گزینه‌ها استفاده کرد (<code
                class="command">getsebool <em
                  class="replaceable">boolean</em></code> یک گزینه و <code
                class="command">getsebool -a</code> تمام گزینه‌ها را نمایش می‌دهد). دستور <code
                class="command">setsebool <em
                  class="replaceable">boolean</em> <em
                  class="replaceable">value</em></code> مقدار فعلی یک گزینه منطقی را تغییر می‌دهد. گزینه <code
                class="literal">-P</code> باعث می‌شود که این تغییرات به صورت ثابت باقیمانده و در راه‌اندازی‌های بعدی سیستم دچار تغییر نشوند. مثال زیر به یک سرور وب اجازه می‌دهد که با دایرکتوری‌های home دسترسی یابد (در صورتی مفید است که وبسایت کاربران در <code
                class="filename">~/public_html/</code> قرار داشته باشد).
				</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>getsebool httpd_enable_homedirs</code></strong>
<code
                class="computeroutput">httpd_enable_homedirs --&gt; off
# </code><strong
                class="userinput"><code>setsebool -P httpd_enable_homedirs on</code></strong>
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>getsebool httpd_enable_homedirs</code></strong> 
<code
                class="computeroutput">httpd_enable_homedirs --&gt; on</code></pre></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.selinux-custom-rules"></a>14.5.4. انطباق قوانین</h3></div></div></div><div
            class="para">
				از آنجا که خط مشی SELinux ماژولار بوده، توسعه ماژول‌های جدید برای برنامه‌هایی که به آن نیاز دارند (به صورت سفارشی) کار جالبی است. این ماژول‌های جدید <span
              class="emphasis"><em>خط مشی مرجع</em></span> را کامل می‌کنند.
			</div><div
            class="para">
				برای ایجاد ماژول‌های جدید، بسته‌های <span
              class="pkg pkg">selinux-policy-dev</span> و <span
              class="pkg pkg">selinux-policy-doc</span> مورد نیاز هستند. بسته دوم شامل مستندات قوانین استاندارد (<code
              class="filename">/usr/share/doc/selinux-policy-doc/html/</code>) و فایل‌های نمونه است که می‌توانند به عنوان قالب برای ایجاد ماژول‌های جدید بکار روند. این فایل‌ها را نصب کرده و به دقت مطالعه نمایید:
			</div><pre
            class="screen"><code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</code></strong>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.fc ./</code></strong>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.if ./</code></strong>
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>cp /usr/share/doc/selinux-policy-doc/example.te ./</code></strong></pre><div
            class="para">
				فایل <code
              class="filename">.te</code> مهم‌ترین آن‌ها است که قوانین را تعریف می‌کند. فایل <code
              class="filename">.fc</code> “زمینه‌های فایل” را تعریف می‌کند، که همان نوع اختصاص یافته به فایل‌های مرتبط با این ماژول است. از داده موجود درون فایل <code
              class="filename">.fc</code> در گام برچسب‌گذاری استفاده می‌شود. در نهایت، فایل <code
              class="filename">.if</code> رابط مرتبط با ماژول را تعریف می‌کند: یک مجموعه از “توابع عمومی” است که سایر ماژول‌ها می‌توانند به منظور تعامل بهتر با این ماژول از آن‌ها استفاده کنند.
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.6.6"></a>14.5.4.1. نوشتن یک فایل <code
                      class="filename">.fc</code></h4></div></div></div><div
              class="para">
					خواندن مثال زیر برای درک اولیه از محتوای فایل مذکور کافی است. می‌توانید با استفاده از عبارت‌های منظم یک زمینه امنیتی یکسان را برای چندین فایل یا حتی یک دایرکتوری کامل در نظر بگیرید.
				</div><div
              class="example"><a
                xmlns=""
                id="id-1.17.8.6.6.3"></a><p
                class="title"><strong>
      مثال 14.2. فایل <code
                    class="filename">example.fc</code></strong></p><div
                class="example-contents"><pre
                  class="programlisting scale"># myapp executable will have:
# label: system_u:object_r:myapp_exec_t
# MLS sensitivity: s0
# MCS categories: &lt;none&gt;

/usr/sbin/myapp         --      gen_context(system_u:object_r:myapp_exec_t,s0)</pre></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.6.7"></a>14.5.4.2. نوشتن یک فایل <code
                      class="filename">.if</code></h4></div></div></div><div
              class="para">
					در مثال زیر، اولین رابط (“<code
                class="literal">myapp_domtrans</code>”) کنترل می‌کند چه کسی می‌تواند برنامه را اجرا کند. رابط دوم (“<code
                class="literal">myapp_read_log</code>”) اجازه خواندن و نوشتن روی فایل‌های گزارش برنامه را می‌دهد.
				</div><div
              class="para">
					هر رابط باید مجموعه‌ای معتبر از قوانین را که درون فایل <code
                class="filename">.te</code> قرار می‌گیرند تعریف کند. بنابراین باید تمام انواع مورد استفاده خود را تعریف کنید (با استفاده از ماکرو <code
                class="literal">gen_require</code>) و از عبارت‌های استاندارد به منظور تخصیص دسترسی بهره ببرید. با این حال، به یاد داشته باشید که می‌توانید از رابط‌های سایر ماژول‌ها نیز استفاده کنید. قسمت بعد توضیحات بیشتری در مورد چگونگی تخصیص این دسترسی‌ها ارائه می‌دهد.
				</div><div
              class="example"><a
                xmlns=""
                id="id-1.17.8.6.7.4"></a><p
                class="title"><strong>
      مثال 14.3. فایل <code
                    class="filename">example.if</code></strong></p><div
                class="example-contents"><pre
                  class="programlisting">## &lt;summary&gt;Myapp example policy&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              More descriptive text about myapp.  The &lt;desc&gt;
##              tag can also use &lt;p&gt;, &lt;ul&gt;, and &lt;ol&gt;
##              html tags for formatting.
##      &lt;/p&gt;
##      &lt;p&gt;
##              This policy supports the following myapp features:
##              &lt;ul&gt;
##              &lt;li&gt;Feature A&lt;/li&gt;
##              &lt;li&gt;Feature B&lt;/li&gt;
##              &lt;li&gt;Feature C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;summary&gt;
##      Execute a domain transition to run myapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to transition.
## &lt;/param&gt;
#
interface(`myapp_domtrans',`
        gen_require(`
                type myapp_t, myapp_exec_t;
        ')

        domtrans_pattern($1,myapp_exec_t,myapp_t)
')

########################################
## &lt;summary&gt;
##      Read myapp log files.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to read the log files.
## &lt;/param&gt;
#
interface(`myapp_read_log',`
        gen_require(`
                type myapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')</pre></div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>مستندات</em></span> توضیحات درباره <span
                          class="emphasis"><em>خط مشی مرجع</em></span></strong></p></div></div></div><div
                class="para">
					<span
                  class="emphasis"><em>reference policy</em></span> مانند هر پروژه نرم‌افزار آزاد دیگری رشد می‌کند: مبتنی بر مشارکت داوطلبانه. پروژه توسط Tresys، یکی از فعال‌ترین شرکت‌های حوزه SELinux، میزبانی می‌شود. ویکی آن‌ها شامل توضیحاتی درباره چگونگی ساختار قوانین و چگونگی ایجاد قوانین جدید است. <div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted">https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted</a></div>
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.writing-a-te-file"></a>14.5.4.3. نوشتن یک فایل <code
                      class="filename">.te</code></h4></div></div></div><div
              class="para">
					نگاهی به فایل <code
                class="filename">example.te</code> بیندازید:
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>مطالعه بیشتر</em></span> زبان ماکرو <code
                          class="command">m4</code></strong></p></div></div></div><div
                class="para">
					برای ساختاردهی مناسب خط مشی، توسعه‌دهندگان SELinux از یک پردازشگر دستور-ماکرو استفاده کرده‌اند. بجای رونوشت‌گیری از عبارت‌های مشابه <span
                  class="emphasis"><em>allow</em></span>، آن‌ها “توابع ماکرو” را ایجاد کرده‌اند که از یک منطق سطح بالاتر استفاده می‌کند، که این عمل به خوانایی بیشتر خط مشی می‌انجامد.
				</div><div
                class="para">
					در عمل، از <code
                  class="command">m4</code> برای کامپایل کردن این قوانین استفاده می‌شود. این ابزار عملیات را به صورت برعکس انجام می‌دهد: یعنی با بازکردن تمام آن عبارت‌های سطح-بالا به صورت یک پایگاه‌داده بزرگ از عبارت‌های <span
                  class="emphasis"><em>allow</em></span> عمل می‌کند.
				</div><div
                class="para">
					“رابط‌های” موجود در SELinux فقط توابع ماکرو هستند که در زمان کامپایل با یک سری از قوانین جایگزین می‌گردند. به صورت مشابه، برخی دسترسی‌ها در حقیقت مجموعه‌ای از دسترسی‌ها هستند که در زمان کامپایل با مقادیر خود جایگزین می‌شوند.
				</div></div><pre
              class="programlisting">policy_module(myapp,1.0.0) <span
                id="example.te.module"><img
                  class="callout"
                  src="Common_Content/images/1.png"
                  alt="1" /></span>

########################################
#
# Declarations
#

type myapp_t; <span
                id="example.te.type"><img
                  class="callout"
                  src="Common_Content/images/2.png"
                  alt="2" /></span>
type myapp_exec_t;
domain_type(myapp_t)
domain_entry_file(myapp_t, myapp_exec_t) <span
                id="example.te.domain"><img
                  class="callout"
                  src="Common_Content/images/3.png"
                  alt="3" /></span>

type myapp_log_t;
logging_log_file(myapp_log_t) <span
                id="example.te.interface"><img
                  class="callout"
                  src="Common_Content/images/4.png"
                  alt="4" /></span>

type myapp_tmp_t;
files_tmp_file(myapp_tmp_t)

########################################
#
# Myapp local policy
#

allow myapp_t myapp_log_t:file { read_file_perms append_file_perms }; <span
                id="example.te.allow"><img
                  class="callout"
                  src="Common_Content/images/5.png"
                  alt="5" /></span>

allow myapp_t myapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(myapp_t,myapp_tmp_t,file)</pre><div
              class="calloutlist"><table
                border="0"
                summary="Callout list"><tr><td
                    width="5%"
                    valign="top"
                    align="right"><p><a
                        href="#example.te.module"><img
                          class="callout"
                          src="Common_Content/images/1.png"
                          alt="1" /></a> </p></td><td
                    valign="top"
                    align="right"><div
                      class="para">
							ماژول باید توسط نام و شماره نسخه‌اش معرفی شود. این عبارت مورد نیاز است.
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="right"><p><a
                        href="#example.te.type"><img
                          class="callout"
                          src="Common_Content/images/2.png"
                          alt="2" /></a> </p></td><td
                    valign="top"
                    align="right"><div
                      class="para">
							اگر ماژول انواع جدیدی را معرفی کند، باید به شکل عبارت مشابه بالا باشد. از ایجاد انواع مورد نیاز خود دریغ نکنید بجای اینکه تعداد زیادی دسترسی بی‌معنا صادر کنید.
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="right"><p><a
                        href="#example.te.domain"><img
                          class="callout"
                          src="Common_Content/images/3.png"
                          alt="3" /></a> </p></td><td
                    valign="top"
                    align="right"><div
                      class="para">
							این رابط‌ها نوع <code
                        class="literal">myapp_t</code> را به عنوان یک دامنه فرآیند تعریف می‌کنند که باید برای هر برنامه اجرایی برچسب‌گذاری شده با <code
                        class="literal">myapp_exec_t</code> بکار روند. به طور ضمنی، اینکار یک صفت <code
                        class="literal">exec_type</code> روی آن اشیا اضافه می‌کند، که در عوض به سایر ماژول‌ها اجازه می‌دهد برای اجرای برنامه‌ها دسترسی‌های لازم را صادر کنند: برای نمونه، ماژول <code
                        class="literal">userdomain</code> به فرآیندهای موجود در دامنه‌های <code
                        class="literal">user_t</code>، <code
                        class="literal">staff_t</code> و <code
                        class="literal">sysadm_t</code> اجازه اجرا می‌دهد. دامنه‌های سایر برنامه‌های محدود شده اجازه دسترسی برای اجرا را ندارند، مگر اینکه قوانین همان دسترسی‌ها را برایشان تعریف کنند (برای نمونه، در مورد <code
                        class="command">dpkg</code> همراه با دامنه <code
                        class="literal">dpkg_t</code> آن).
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="right"><p><a
                        href="#example.te.interface"><img
                          class="callout"
                          src="Common_Content/images/4.png"
                          alt="4" /></a> </p></td><td
                    valign="top"
                    align="right"><div
                      class="para">
							<code
                        class="literal">logging_log_file</code> رابطی است که توسط خط مشی مرجع فراهم شده است. مشخص می‌کند فایل‌هایی که با این نوع برچسب‌گذاری شده‌اند از نوع گزارش بوده و باید از مزیت قوانین اختصاصی آن بهره‌مند شوند (برای مثال دسترسی دادن به <code
                        class="command">logrotate</code> تا بتواند گزارش‌ها را تغییر دهد).
						</div></td></tr><tr><td
                    width="5%"
                    valign="top"
                    align="right"><p><a
                        href="#example.te.allow"><img
                          class="callout"
                          src="Common_Content/images/5.png"
                          alt="5" /></a> </p></td><td
                    valign="top"
                    align="right"><div
                      class="para">
							<code
                        class="literal">allow</code> عبارت پایه‌ای است که برای احرازهویت یک عملیات استفاده می‌شود. پارامتر اول آن دامنه فرآیندی است که امکان اجرای عملیات را دارد. پارامتر دوم به تعریف یک شی می‌پردازد که فرآیند دامنه قبلی می‌تواند آن را تغییر دهد. این پارامتر به شکل “<em
                        class="replaceable">type</em>:<em
                        class="replaceable">class</em>“ است که در آن <em
                        class="replaceable">type</em> نوع SELinux است و <em
                        class="replaceable">class</em> طبیعت آن شی را تعریف می‌کند (فایل، دایرکتوری، سوکت و از این قبیل). در نهایت، پارامتر آخر به تعریف مجوزها می‌پردازد (همان عملیات مجاز).
						</div><div
                      class="para">
							مجوزها مجموعه‌ای از عملیات مجاز هستند که از قالب رو‌به‌رو تبعیت می‌کنند: <code
                        class="literal">{ <em
                          class="replaceable">operation1</em> <em
                          class="replaceable">operation2</em> }</code>. اگرچه، می‌توانید از ماکروها برای نمایش کاربردی‌ترین مجوزها نیز استفاده کنید. فایل <code
                        class="filename">/usr/share/selinux/devel/include/support/obj_perm_sets.spt</code> فهرستی از آن‌ها را شامل می‌شود.
						</div><div
                      class="para">
							صفحه وب پیش‌رو فهرستی طولانی از کلاس‌های اشیا و مجوزهای مربوط به هر کدام را نمایش می‌دهد. <div
                        xmlns=""
                        class="url">→ <a
                          xmlns="http://www.w3.org/1999/xhtml"
                          href="http://www.selinuxproject.org/page/ObjectClassesPerms">http://www.selinuxproject.org/page/ObjectClassesPerms</a></div>
						</div></td></tr></table></div><div
              class="para">
					اکنون باید حداقل مجموعه قوانین مورد نیاز برای اجرای صحیح برنامه یا سرویس هدف را پیدا کنید. برای دستیابی به این منظور، باید دانش خوبی از چگونگی کارکرد برنامه و انواع داده‌های مدیریتی/تولیدی آن را داشته باشید.
				</div><div
              class="para">
					اگرچه، رویکرد تجربی نیز ممکن است. زمانی که اشیای مربوطه برچسب‌گذاری شده‌اند، می‌توانید از برنامه در حالت permissive استفاده کنید: عملیاتی که ممنوع باشند ثبت گزارش شده ولی هنوز اجرا می‌شوند. با بررسی و تحلیل این گزارش‌ها می‌توانید عملیات مجاز را تشخیص دهید. در اینجا نمونه‌ای از چنین فایل گزارشی آورده شده است:
				</div><pre
              class="programlisting">avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1</pre><div
              class="para">
					برای درک بهتر این پیام بیایید آن را قطعه به قطعه مطالعه کنیم.
				</div><div
              class="table"><a
                xmlns=""
                id="id-1.17.8.6.8.10"></a><p
                class="title"><strong>
      جدول 14.1. بررسی و تحلیل گزارش SELinux</strong></p><div
                class="table-contents"><table
                  xmlns:d="http://docbook.org/ns/docbook"
                  class="lt-4-cols gt-7-rows"
                  summary="بررسی و تحلیل گزارش SELinux"><colgroup><col /><col /></colgroup><thead><tr><th>پیام</th><th>توضیحات</th></tr></thead><tbody><tr><td><code
                          class="computeroutput">avc: denied</code></td><td>عملیات غیرمجاز است.</td></tr><tr><td><code
                          class="computeroutput">{ read write }</code></td><td>این عملیات نیازمند مجوزهای <code
                          class="literal">read</code> و <code
                          class="literal">write</code> است.</td></tr><tr><td><code
                          class="computeroutput">pid=1876</code></td><td>فرآیندی با شناسه ۱۸۷۶ اقدام به اجرای عملیات کرده است.</td></tr><tr><td><code
                          class="computeroutput">comm="syslogd"</code></td><td>فرآیند یک نمونه از برنامه <code
                          class="literal">syslogd</code> بوده است.</td></tr><tr><td><code
                          class="computeroutput">name="xconsole"</code></td><td>شی هدف <code
                          class="literal">xconsole</code> نام دارد. بعضی وقت‌ها می‌توانید یک متغیر “path” داشته باشید - همراه با مسیر کامل-.</td></tr><tr><td><code
                          class="computeroutput">dev=tmpfs</code></td><td>دستگاهی که از شی هدف میزبانی می‌کند یک <code
                          class="literal">tmpfs</code> است (یک فایل سیستم داخل-حافظه‌ای). برای یک دیسک حقیقی، می‌توانید شماره پارتیشن آن را مشاهده کنید (برای مثال: “sda3”).</td></tr><tr><td><code
                          class="computeroutput">ino=5510</code></td><td>شی با inode ۵۵۱۰ شناسایی شده است.</td></tr><tr><td><code
                          class="computeroutput">scontext=system_u:system_r:syslogd_t:s0</code></td><td>این همان زمینه امنیتی فرآیندی است که عملیات را اجرا کرده است.</td></tr><tr><td><code
                          class="computeroutput">tcontext=system_u:object_r:device_t:s0</code></td><td>این همان زمینه امنیتی شی هدف می‌باشد.</td></tr><tr><td><code
                          class="computeroutput">tclass=fifo_file</code></td><td>شی هدف یک فایل FIFO است.</td></tr></tbody></table></div></div><div
              class="para">
					با مشاهده این گزارش، امکان ایجاد یک قانون برای مجاز ساختن این عملیات وجود دارد. برای مثال: <code
                class="literal">allow syslogd_t device_t:fifo_file { read write }</code>. این فرآیند می‌تواند خودکارسازی شده و دقیقا همان کاری است که دستور <code
                class="command">audit2allow</code> (از بسته <span
                class="pkg pkg">policycoreutils</span>) پیشنهاد می‌کند. این رویکرد تنها زمانی موثر است که اشیای گوناگون به شیوه‌ای درست و متناسب با آنچه محدود شده است برچسب‌گذاری شده باشند. در هر صورت، باید به دقت قوانین تولید شده را متناسب با دانش خود از چگونگی کارکرد برنامه بررسی و تحلیل کنید. البته، این رویکرد تمایل دارد تا دسترسی‌های بیشتری را نسبت به آنچه مورد نیاز است صادر کند. راهکار صحیح اغلب ایجاد انواع جدیدی است که دسترسی‌ها می‌توانند به آن‌ها اختصاص یابند. همچنین پیش می‌آید که یک عملیات غیرمجاز برای برنامه مرگبار نباشد، که در این صورت بهتر است به صورت یک قانون “<code
                class="literal">dontaudit</code>” برای پیشگیری از ثبت در فایل گزارش افزوده شود.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>تکمیلی</em></span> عدم وجود نقش‌ها در قوانین خط مشی</strong></p></div></div></div><a
                id="id-1.17.8.6.8.12.2"
                class="indexterm"></a><a
                id="id-1.17.8.6.8.12.3"
                class="indexterm"></a><div
                class="para">
					ممکن است عجیب بنظر آید که در زمان ایجاد قوانین، هیچ نقشی در آن‌ها وجود ندارد. SELinux تنها از دامنه‌ها به منظور یافتن عملیات مجاز استفاده می‌کند. نقش تنها به صورت غیرمستقیم در تعویض کاربر به یک دامنه دیگر دخالت دارد. SELinux مبتنی بر نظریه‌ای بنام <span
                  class="emphasis"><em>Type Enforcement</em></span> است که نوع تنها عنصری است که برای صدور دسترسی‌ها استفاده می‌شود.
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.8.6.9"></a>14.5.4.4. کامپایل‌کردن فایل‌ها</h4></div></div></div><div
              class="para">
					زمانی که سه فایل <code
                class="filename">example.if</code>، <code
                class="filename">example.fc</code> و <code
                class="filename">example.te</code> با انتظارات شما از قوانین جدید سازگار شوند، تنها کافی است دستور <code
                class="command">make NAME=devel</code> را برای تولید یک ماژول در فایل <code
                class="filename">example.pp</code> استفاده کنید (که بلافاصله می‌توانید با دستور <code
                class="command">semodule -i example.pp</code> آن را فعال‌سازی کنید). اگر چندین ماژول تعریف شده باشند، <code
                class="command">make</code> تمام فایل‌های <code
                class="filename">.pp</code> متناسب با آن‌ها را می‌سازد.
				</div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.apparmor.html"><strong>قبلی</strong>14.4. مقدمه‌ای بر AppArmor</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>بالا</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>خانه</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.other-security-considerations.html"><strong>بعدی</strong>14.6. سایر ملاحظات مرتبط با امنیت</a></li></ul></body></html>
