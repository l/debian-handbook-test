<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course" lang="fa-IR">
	<appendixinfo>
		 <keywordset>
			<keyword>بایوس</keyword>
			 <keyword>کرنل</keyword>
			 <keyword>یونیکس</keyword>
			 <keyword>فرآیند</keyword>
			 <keyword>سلسله‌مراتب</keyword>
			 <keyword>دستورات ابتدایی</keyword>

		</keywordset>

	</appendixinfo>
	 <title>درس کاربردی کوتاه</title>
	 <highlights> <para>
		با اینکه مخاطب عمده این کتاب مدیران سیستم و “کاربران حرفه‌ای” هستند، اما قصد نداریم که کاربران تازه‌کار را از این فهرست خارج سازیم. این ضمیمه شامل درس‌های مقدماتی است که برای مدیریت یک رایانه تحت یونیکس باید بدانید.
	</para>
	 </highlights> <section id="sect.shell-and-basic-commands">
		<title>خط فرمان و دستورات ابتدایی</title>
		 <para>
			در دنیای یونیکس، هر مدیر سیستمی دیر یا زود باید با خط فرمان ارتباط برقرار کند؛ برای نمونه، زمانی که سیستم عملکرد صحیح خود را از دست داده و به حالت اضطراری در خط فرمان برده می‌شود. توانایی مدیریت رابط خط فرمان، یک مهارت حیاتی برای نجات سیستم در چنین شرایطی به حساب می‌آید.
		</para>
		 <sidebar> <title><emphasis>نگاه سریع</emphasis> اجرای مفسر دستور</title>
		 <para>
			محیط خط فرمان از طریق میزکار گرافیکی قابل فراخوانی است، توسط برنامه‌ای به نام “ترمینال”. در گنوم، از منوی “فعالیت‌ها” می‌توانید آن را آغاز کنید (زمانی که ماوس را به گوشه بالا و سمت چپ صفحه حرکت می‌دهید) با نوشتن اولین حرف از نام برنامه. در کی‌دی‌ای، می‌توانید آن را از منوی <menuchoice><guimenu>K</guimenu> <guisubmenu>Applications</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice> آغاز کنید.
		</para>
		 </sidebar> <para>
			این قسمت تنها به بررسی اجمالی برخی دستورات می‌پردازد. تمامی آن‌ها شامل گزینه‌هایی هستند که اینجا به آن‌ها نمی‌پردازیم، پس برای جزئیات بیشتر به مستندات موجود در صفحات راهنمای آن‌ها مراجعه کنید.
		</para>
		 <section>
			<title>مرور ساختار درختی و مدیریت فایل‌ها</title>
			 <para>
				زمانی که ترمینال باز می‌شود، دستور <command>pwd</command> (که مخفف <emphasis>print working directory</emphasis> است) مسیر جاری در فایل سیستم را نمایش می‌دهد. این مسیر توسط <command>cd</command> قابل تغییر است (که مخفف <emphasis>change directory</emphasis> است). دایرکتوری پدر همیشه با علامت <literal>..</literal> (دو نقطه) فراخوانده می‌شود، در صورتی که مسیر جاری با علامت <literal>.</literal> (یک نقطه) شناخته می‌شود. دستور <command>ls</command> جهت نمایش محتویات داخل یک دایرکتوری استفاده می‌شود. اگر پارامتری داده نشود، بر روی دایرکتوری جاری عمل می‌کند.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>cd Desktop</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd .</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates
Documents  Music      Public    Videos</computeroutput>
</screen>
			 <para>
				یک دایرکتوری جدید می‌تواند توسط <command>mkdir <replaceable>directory</replaceable></command> ایجاد شود و یک دایرکتوری موجود (خالی) می‌تواند با دستور <command>rmdir <replaceable>directory</replaceable></command> حذف شود. دستور <command>mv</command> <emphasis>امکان جابجایی</emphasis> یا نامگذاری مجدد فایل‌ها و دایرکتوری‌ها را به عهده دارد؛ <emphasis>حذف</emphasis> یک فایل توسط دستور <command>rm</command> انجام می‌شود.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public    test
$ </computeroutput><userinput>mv test new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  new       Public     Videos
Documents  Music      Pictures  Templates
$ </computeroutput><userinput>rmdir new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public</computeroutput>
</screen>

		</section>
		 <section>
			<title>نمایش و تغییر فایل‌های متنی</title>
			 <para>
				دستور <command>cat <replaceable>file</replaceable></command> (که با هدف <emphasis>الحاق</emphasis> فایل‌ها به خروجی استاندارد ایجاد شده) یک فایل را خوانده و محتویاتش را روی ترمینال نمایش می‌دهد. اگر فایل بیش از اندازه بزرگ باشد تا محتویاتش روی یک صفحه قابل نمایش باشند، از یک ابزار صفحه‌بندی مانند <command>less</command> (یا <command>more</command>) استفاده کنید تا محتویات فایل به صورت صفحه‌بندی شده نمایش داده شوند.
			</para>
			 <para>
				دستور <command>editor</command> یک ویرایشگر متن را اجرا می‌کند (مانند <command>vi</command> یا <command>nano</command>) که امکان ایجاد، تغییر و خواندن فایل‌های متنی را می‌دهد. ساده‌ترین فایل‌ها بعضی اوقات می‌توانند با دستوری مانند <command>echo "<replaceable>text</replaceable>" &gt;<replaceable>file</replaceable></command> ایجاد شوند: این دستور منجر به ایجاد فایلی به نام <replaceable>file</replaceable> با محتویات “<replaceable>text</replaceable>” می‌شود. اضافه‌کردن یک خط به انتهای این فایل نیز قابل انجام است، با دستوری مانند <command>echo "<replaceable>moretext</replaceable>" &gt;&gt;<replaceable>file</replaceable></command> . به کاربرد <literal>&gt;&gt;</literal> در این نمونه توجه کنید.
			</para>

		</section>
		 <section>
			<title>جستجو به دنبال فایل‌ها و محتویات آن‌ها</title>
			 <para>
				دستور <command>find <replaceable>directory</replaceable> <replaceable>criteria</replaceable></command> به دنبال فایل‌هایی در سلسه‌مراتب <replaceable>directory</replaceable> بر اساس شرایط گفته شده می‌گردد. پرکاربردترین شرایط مورد استفاده در آن عبارتند از <literal>-name <replaceable>name</replaceable></literal>: که امکان جستجوی فایلی بر اساس نام آن را می‌دهد.
			</para>
			 <para>
				دستور <command>grep <replaceable>expression</replaceable> <replaceable>files</replaceable></command> به جستجوی محتویات داخل یک فایل پرداخته و خط‌هایی را که با عبارت باقاعده (regex) همخوانی دارند استخراج می‌کند (به قسمت کنار صفحه‌ای <xref linkend="sidebar.regexp" /> مراجعه کنید). اضافه‌کردن گزینه <literal>-r</literal> امکان جستجو به صورت بازگشتی درون فایل‌های یک دایرکتوری را می‌دهد که نام آن در انتهای دستور ذکر می‌شود. این امکان به جستجوی فایل‌هایی کمک می‌کند که تنها برخی از محتویات آن‌ها قابل دسترسی هستند.
			</para>

		</section>
		 <section>
			<title>مدیریت فرآیندها (پروسه‌ها)</title>
			 <para>
				دستور <command>ps aux</command> فهرستی از فرآیندهای جاری در سیستم را نمایش می‌دهد و با نمایش <emphasis>pid</emphasis> (شناسه فرآیند) به شناسایی هر چه بهتر آن‌ها یاری می‌رساند. زمانی که <emphasis>pid</emphasis> یک فرآیند شناخته شود، دستور <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> امکان ارسال یک سیگنال را به آن می‌دهد (اگر فرآیند به کاربر جاری تعلق داشته باشد). سیگنال‌های متفاوتی وجود دارند؛ پرکاربردترین آن‌ها عبارتند از <literal>TERM</literal> (درخواست نابودسازی مودبانه) و <literal>KILL</literal> (نابودسازی خشن).
			</para>
			 <para>
				مفسر دستور همچنین می‌تواند برنامه‌ها را در پس‌زمینه اجرا کند در صورتی که عبارت “&amp;” بعد از دستور قرار بگیرد. با استفاده از امپرسند، کاربر کنترل مجدد خط فرمان را بر عهده می‌گیرد با اینکه دستور در پس‌زمینه در حال اجرا است (از دید کاربر مخفی است؛ به عنوان یک فرآیند پس‌زمینه). دستور <command>jobs</command> فهرستی از فرآیندهای موجود در پس‌زمینه را ارائه می‌دهد؛ اجرای دستور <command>fg %<replaceable>job-number</replaceable></command> (برای <emphasis>پیش‌زمینه</emphasis>) یک کار را به پیش‌زمینه منتقل می‌کند. وقتی دستوری در پیش‌زمینه اجرا می‌شود (خواه به صورت معمولی اجرا شده باشد، خواه با فراخوانی دستور <command>fg</command>) ترکیب کلید‌های <keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo> فرآیند را به حالت توقف درآورده و کنترل خط فرمان را به کاربر انتقال می‌دهد. این فرآیند می‌تواند با اجرای دستور <command>bg %<replaceable>job-number</replaceable></command> (برای <foreignphrase>پس‌زمینه</foreignphrase>) به ادامه فعالیت خود بپردازد.
			</para>

		</section>
		 <section>
			<title>اطلاعات سیستم: حافظه، فضای ذخیره‌سازی، هویت</title>
			 <para>
				دستور <command>free</command> اطلاعات مربوط به حافظه را نمایش می‌دهد؛ دستور <command>df</command> (که مخفف <emphasis>disk free</emphasis> است) گزارش میزان فضای باقیمانده روی دیسک در تمام دیسک‌های نصب شده روی فایل سیستم را می‌دهد. گزینه <literal>-h</literal> آن (که مخفف <emphasis>human readble</emphasis> است) اندازه‌ها را به واحد خواناتری تبدیل می‌کند (معمولا مگابایت یا گیگابایت). به روشی مشابه، دستور <command>free</command> از گزینه‌های <literal>-m</literal> و <literal>-g</literal> بهره‌ می‌برد و داده‌ها را به صورت مگابایت یا گیگابایت نمایش می‌دهد.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       used       free     shared    buffers     cached
Mem:       1028420    1009624      18796          0      47404     391804
-/+ buffers/cache:     570416     458004
Swap:      2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda2              9614084   4737916   4387796  52% /
tmpfs                   514208         0    514208   0% /lib/init/rw
udev                     10240       100     10140   1% /dev
tmpfs                   514208    269136    245072  53% /dev/shm
/dev/sda5             44552904  36315896   7784380  83% /home
</computeroutput></screen>
			 <para>
				دستور <command>id</command> هویت کاربری که ترمینال را اجرا کرده است، نمایش می‌دهد، به همراه فهرست گروه‌هایی که کاربر به آن‌ها تعلق دارد. از آنجایی که دسترسی به برخی فایل‌ها یا دستگاه‌ها ممکن است برای اعضای گروه محدود شود، بررسی عضویت در گروه‌های موجود ممکن است مفید واقع شود.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
</screen>

		</section>

	</section>
	 <section id="sect.filesystem-hierarchy">
		<title>سازماندهی سلسله‌مراتب فایل‌سیستم</title>
		 <indexterm>
			<primary>سلسله‌مراتب فایل‌سیستم</primary>
		</indexterm>
		 <section>
			<title>دایرکتوری ریشه</title>
			 <para>
				سیستم دبیان بر اساس <emphasis>استاندارد سلسله‌مراتب فایل‌سیستم</emphasis> یا FHS سازماندهی شده است. این استاندارد هدف از هر دایرکتوری را تعریف می‌کند. برای نمونه، دایرکتوری‌های اصلی سیستم به صورت زیر تعریف می‌شوند:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<filename>/bin/</filename>: برنامه‌های پایه;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/boot/</filename>: فایل‌های کرنل و سایر فایل‌هایی که برای راه‌اندازی اولیه سیستم لازم هستند;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/dev/</filename>: فایل‌های مربوط به دستگاه‌ها;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/etc/</filename>: فایل‌های پیکربندی و تنظیمات;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/home/</filename>: فایل‌های شخصی کاربران;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/lib/</filename>: کتابخانه‌های پایه;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/media/*</filename>: نقاط اتصالی برای دستگاه‌هایی با قابلیت جابجایی (سی‌دی‌رام، یو‌اس‌بی و ...);
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/mnt/</filename>: نقطه اتصال موقتی;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/opt/</filename>: نرم‌افزاهای ثالثی که توسط شرکت‌های دیگر توسعه یافته‌اند;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/root/</filename>: فایل‌های شخصی مدیر اولیه سیستم;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/run/</filename>: (هنوز در این استاندارد گنجانده نشده‌اند)داده‌های فررار زمان اجرا که طی آغاز سیستم باقی نمی‌مانند;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/sbin/</filename>: برنامه‌های سیستمی;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/srv/</filename>: داده‌هایی که توسط سرورهای موجود روی سیستم استفاده می‌شوند;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/tmp/</filename>: فایل‌های موقتی؛ این دایرکتوری معمولا در زمان راه‌اندازی سیستم خالی است;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/usr/</filename>: برنامه‌های کاربردی؛ این دایرکتوری معمولا به زیرمجموعه‌های دیگری مانند <filename>bin</filename> و <filename>lib</filename> و <filename>sbin</filename> تقسیم می‌شود که بر اساس همان منطق دایرکتوری ریشه عمل می‌کنند. به علاوه، <filename>/usr/share/</filename> شامل داده‌های جدای از معماری رایانه است. <filename>/usr/local</filename> به عنوان مکانی جهت نصب برنامه‌های توسط مدیر سیستم به صورت دستی استفاده می‌شود که با مدیر برنامه روی سییستم هیچ دخالتی ندارد.;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/var/</filename>: داده‌های متغیری که توسط دیمن‌ها مدیریت می‌شوند مانند فایل‌های لاگ، صف‌، اسپول مانند ایمیل و پرینتر و ...
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/proc/</filename> و <filename>/sys/</filename> مختص به کرنل لینوکس هستند (و نه قسمتی از FHS). این فایل‌ها توسط کرنل استفاده می‌شوند تا داده‌های فضای کاربر مورد دسترسی قرار گیرند (<xref linkend="sect.userspace-presentation" /> و <xref linkend="sect.user-space" /> را مشاهده کنید).
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section>
			<title>دایرکتوری خانه کاربر</title>
			 <para>
				محتوای داخل دایرکتوری خانه کاربر شامل استاندارد خاصی نمی‌شود، اما برخی قواعد حائز اهمیت وجود دارند. یکی از آن‌ها این است که برای دسترسی به این مسیر می‌توان از (“~”) استفاده کرد. این عمل بسیار مفید است چرا که مفسرهای دستور به صورت خودکار این کاراکتر را بار دایرکتوری صحیح آن تعویض می‌کنند (معمولا <filename>/home/<replaceable>user</replaceable>/</filename>).
			</para>
			 <para>
				بر اساس یک رسم قدیمی، فایل‌های پیکربندی برنامه‌ها معمولاً به صورت مستقیم در دایرکتوری خانه کاربر ذخیره می‌شوند، اما نامشان با یک نقطه آغاز می‌گردد (برای نمونه، نرم‌افزار ایمیل‌خوان <command>mutt</command> تنظیماتش را درون <filename>~/.muttrc</filename> نگاه می‌دارد). نکته اینکه فایل‌هایی که با نقطه آغاز می‌شوند یه صورت پیش‌فرض مخفی هستند؛ و دستور <command>ls</command> تنها در صورتی آن‌ها را نمایش می‌دهد که از گزینه <literal>-a</literal> استفاده شود و مدیر فایل‌های گرافیکی نیز تنظیماتی برای نمایش آن‌ها دارند.
			</para>
			 <para>
				برخی برنامه‌های نیز از چند فایل پیکربندی داخل یک دایرکتوری استفاده می‌کنند (برای نمونه، <filename>~/.ssh/</filename>). برخی برنامه‌ها (مانند مرورگر وب Iceweasel) از دایرکتوری خود برای ذخیره‌سازی فایل‌های cache استفاده می‌کنند. این بدان معنا است که استفاده از این دایرکتوری‌ها می‌توانند حجم قابل توجهی از فضای ذخیره‌سازی دیسک را بگیرد.
			</para>
			 <para>
				این فایل‌های پیکربندی به صورت مستقیم در دایرکتوری خانه کاربر قرار می‌گیرند، که اغلب با نام <emphasis>فایل‌های نقطه‌دار</emphasis> شناخته می‌شوند، به مرور زمان به اندازه‌ای زیاد شده‌اند که ممکن است با یکدیگر تداخل پیدا کنند. خوشبختانه، تلاشی که تحت حمایت پروژه FreeDesktop.org صورت گرفته منجر به ایجاد “قرارداد دایرکتوری مبدا XDG” شده، قراردادی که هدف از آن پاکسازی این فایل‌ها و دایرکتوری‌ها است. این قرارداد تعیین می‌کند که فایل‌های پیکربندی در مسیر <filename>~/.config</filename>، فایل‌های cache در مسیر <filename>~/.cache</filename> و داده‌های مربوط به برنامه‌ها در مسیر <filename>~/.local</filename> (یا زیرمجموعه‌های آن) قرار بگیرند. این قرارداد به آرامی در حال پذیرفته شدن هستند و تعدادی از برنامه‌ها (به خصوص از نوع گرافیکی) استفاده از آن را آعاز کرده‌اند.
			</para>
			 <para>
				میزکارهای گرافیکی معمولاً محتویات دایرکتوری <filename>~/Desktop/</filename> را نمایش می‌دهند (یا هر ترجمه مرتبطی که برای نسخه انگلیسی آن موجود است) روی دسکتاپ نمایش می‌دهند.
			</para>
			 <para>
				در نهایت، سیستم ایمیل گاهی اوقات پیام‌های دریافتی را داخل دایرکتوری <filename>~/Mail/</filename> نگاه می‌دارد.
			</para>

		</section>

	</section>
	 <section id="sect.computer-layers">
		<title>طرزکار داخلی یک رایانه: لایه‌های مختلفی درگیر هستند</title>
		 <para>
			یک رایانه بیشتر به عنوان یک شی انتزاعی در نظر گرفته می‌شود و رابط گرافیکی خروجی بسیار ساده‌تر از پیچیدگی‌های درون آن دارد. این پیچیدگی از قسمت‌هایی می‌آید که با یکدیگر در ارتباط هستند. اگرچه، این قسمت‌ها می‌توانند به عنوان لایه‌های گوناگون دیده شوند، که هر لایه می‌تواند صرفاً با لایه بالا یا پایین خود ارتباط داشته باشد.
		</para>
		 <para>
			یک کاربر نهایی کاری با جزئیات این لایه‌ها ندارد... تا زمانی که همه چیز درست کار می‌کند. وقتی با مشکلاتی مانند “اینترنت کار نمی‌کند!” رو‌به‌رو می‌شویم، اولین کاری که باید کرد شناسایی لایه‌ای است که این مشکل از آن نشات گرفته است. آیا کارت شبکه (سخت‌افزار) کار می‌کند؟ آیا توسط رایانه شناخته شده است؟ آیا کرنل قادر به تعامل با آن است؟ آیا پارامترهای شبکه به درستی تنظیم شده‌اند؟ تمام این پرسش‌ها مربوط به یک لایه خاص می‌باشند و تمرکز خاصی روی موضوع مورد سوال دارند.
		</para>
		 <section id="sect.hardware">
			<title>عمیق‌ترین لایه: سخت‌افزار</title>
			 <indexterm>
				<primary>IDE</primary>
			</indexterm>
			 <indexterm>
				<primary>SCSI</primary>
			</indexterm>
			 <indexterm>
				<primary>Serial ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>Parallel ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>Firewire</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <para>
				بگذارید با یادآوری کوتاهی شروع کنیم که رایانه در حقیقت مجموعه‌ای از عناصر سخت‌افزاری است. معمولاً یک برد اصلی وجود دارد (که با نام <emphasis>motherboard</emphasis> شناخته می‌شود) با یک (یا چند) پردازنده، مقدای حافظه، کنترلرهای دستگاه و کارت‌های توسعه برای سایر بردها (برای سایر کنترلرهای دستگاه). قابل توجه‌ترین این کنترلرها عبارتند از IDE (که Parallel ATA نیز نامیده می‌شود) و SCSI و Serial ATA، برای اتصال به دستگاه‌های ذخیره‌سازی مانند هارددیسک‌ها. سایر کنترلرها عبارتند از USB، که قادر به میزبانی از بسیاری دستگاه‌ها است (از دوربین گرفته تا دستگاه‌های حساس به حرارت، از صفحات کلید تا سیستم‌های خودکارسازی خانه) و IEEE 1394 (یا همان Firewire). این کنترلرها اغلب اجازه اتصال چندین دستگاه را می‌دهند تا جایی که سیستم درونی که این فعالیت‌ها را مدیریت می‌کنند با نام “گذرگاه” شناخته می‌شوند. بردهای دیگر شامل کارت‌های گرافیکی (که نمایشگرها به آن‌ها وصل هستند)، کارت‌های صدا، کارت‌های رابط شبکه و بسیاری دیگر. برخی بردهای اصلی به صورت پیش‌فرض این قابلیت‌ها را دارند و نیازی به سایر بردها وجود ندارد.
			</para>
			 <sidebar> <title><emphasis>در عمل</emphasis> بررسی عملکرد صحیح سخت‌افزار</title>
			 <para>
				بررسی اینکه آیا قطعه‌ای سخت‌افزاری کار می‌کند ممکن است فوت و فن زیادی داشته باشد. از طرف دیگر، اثبات عدم عملکرد صحیح آن بسیار ساده است.
			</para>
			 <para>
				یک درایو هارددیسک از صفحات گردان و قسمت‌های متحرک مغناطیسی تشکیل شده است. وقتی یک هارددیسک روشن می‌شود، موتور صفحه آن غژغژ خاصی را ایجاد می‌کند. گاهی اوقات نیز انرژی مصرف شده را در قالب گرما خارج می‌شود. در نتیجه، یک درایور هارددیسک که سرد و خاموش می‌شود زمانی که این عملکرد اولیه دچار اشکال گردد.
			</para>
			 <para>
				کارت‌های شبکه اغلب شامل چراغ LED هستند که وضعیت ارتباطی را نمایش می‌دهد. اگر کابل شبکه وصل باشد و به یک هاب یا سوئیچ متصل، حداقل یک چراغ روشن می‌شود. اگر هیچ چراغی روشن نشد، خواه کارت شبکه، سخت‌افزار شبکه یا کابل بین آن‌‌ها قطع است. گام بعدی بررسی هر یک از این سخت‌افزارها است.
			</para>
			 <para>
				برخی بردهای اختیاری - به خصوص کارت‌های ویدیوئی ۳ بعدی - شامل دستگاه‌های خنک‌کننده هستند، مانند فن‌ها. اگر فن به چرخش خود ادامه ندهد با وجود اینکه کارت به کارش ادامه دهد، نشان می‌دهد که دچار گرمای بیش از اندازه شده است. این امر شامل پردازنده اصلی واقع در برداصلی نیز می‌شود.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.bios">
			<title>راه‌انداز: BIOS یا UEFI</title>
			 <indexterm>
				<primary>BIOS</primary>
			</indexterm>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>Master Boot Record (MBR)</primary>
			</indexterm>
			 <para>
				سخت‌افزار، به خودی خود، نمی‌تواند بدون ارتباط یک نرم‌افزار که آن را کنترل کند عملکرد مفیدی داشته باشد. کنترل و تعامل با سخت‌افزار از جمله وظایف سیستم عامل و برنامه‌های کاربردی آن است. این عمکرد، نیز متعاقباُ نیاز به عملکرد صحیح سخت‌افزار دارد.
			</para>
			 <para>
				این همزیستی بین سخت‌افزار و نرم‌افزار به خودی خود اتفاق نمی‌افتد. زمانی که رایانه برای اولین بار روشن می‌شود، برخی پیکربندی اولیه مورد نیاز است. این نقش را BIOS یا UEFI بازی می‌کند، نرم‌افزار کوچکی که درون برد اصلی قرار دارد که به صورت خودکار هنگام روشن شدن سیستم اجرا می‌شود. وظیفه اصلی آن یافتن نرم‌افزاری است که ادامه کنترل را به آن بسپارد. معمولاً، در مورد BIOS، به دنبال اولین هارددیسک با سکتور اجرایی آن می‌گردد (که با نام <emphasis>Master Boot Record</emphasis> یا <acronym>MBR</acronym> شناخته می‌شود)، بارگذاری آن سکتور راه‌انداز و در نهایت اجرای آن. از این لحظه، BIOS معمولاً نقش دیگری ندارد (تا راه‌آندازی بعدی سیستم) در مورد UEFI، فرآیند شامل اسکن دیسک‌ها می‌شود تا اولین پارتیشن اختصاصی EFI پیدا شود تا برنامه‌های مربوط به آن را اجرا کند.
			</para>
			 <sidebar> <title><emphasis>ابزار</emphasis> Setup، ابزار پیکربندی BIOS/UEFI</title>
			 <indexterm>
				<primary><emphasis>Setup</emphasis></primary>
			</indexterm>
			 <para>
				مجموعه BIOS/UEFI همچنین شامل نرم‌افزاری به نام Setup است، که برای پیکربندی جنبه‌های مختلف یک رایانه طراحی شده است. به طور خاص، اجازه می‌دهد که دستگاه‌های راه‌انداز را خود انتخاب کنیم (برای نمونه، فلاپی دیسک یا درایو سی‌دی)، تنظیم ساعت سیستم و موارد دیگر. راه‌اندازی Setup شامل فشار دکمه‌ای درست بعد از لحظه‌ای است که سیستم روشن می‌شود. این کلید اغلب <keycap>Del</keycap> یا <keycap>Esc</keycap> است، گاهی اوقات نیز <keycap>F2</keycap> یا <keycap>F10</keycap>. اکثر اوقات، این انتخاب روی نمایشگر به صورت چشمک‌زن نمایان می‌شود.
			</para>
			 </sidebar> <para>
				سکتور راه‌انداز (یا پارتیشن EFI) در عوض، شامل نرم‌افزار دیگری نیز هستند که bootloader نامیده می‌شود که هدف اصلی‌اش جستجو و اجرای سیستم عامل است. از آنجایی که این bootloader داخل برد اصلی قرار ندارد و محتوایش از روی دیسک خوانده می‌شود، عملکرد هوشمندانه‌تری نسبت به BIOS دارد، که توضیح می‌دهد چرا BIOS نمی‌تواند به خودی خود سیستم عامل را راه‌اندازی کند. برای نمونه، bootloader (که اغلب در سیستم‌های لینوکس GRUB نامیده می‌شود) می‌تواند فهرستی از سیستم عامل‌های موجود روی سیستم را به کاربر نمایش داده تا وی انتخاب کند. معمولاً، زمان و گزینه پیش‌فرض انتخاب می‌شود. گاهی اوقات کاربر می‌تواند پارامترهای دیگری به کرنل ارائه دهد و مواردی از این دست. در نهایت، یک کرنل پیدا،‌در حافظه بارگذاری و اجرا می‌شود.
			</para>
			 <sidebar> <title><emphasis>یادداشت</emphasis> UEFI, جایگزینی پیشرفته برای BIOS</title>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>راه‌اندازی امن</primary>
			</indexterm>
			 <para>
				UEFI تقریبا یک توسعه جدید به حساب می‌آید. اکثر رایانه‌های جدید از راه‌اندازی توسط UEFI پشتیبانی می‌کنند، اما معمولاً پشتیبانی خود از BIOS را نیز حفظ کرده‌اند در جهت سازگاری با سیستم عامل‌هایی که آمادگی فراخوانی توسط UEFI را ندارند.
			</para>
			 <para>
				این سیستم از شر برخی محدودیت‌های موجود در BIOS خلاص شده است: با بکارگیری یک پارتیشن اختصاصی، bootloaderها دیگر نیازی به فوت و فن‌های زیادی جهت قرارگیری در یک محفظه کوچک به نام <emphasis>Master Boot Record</emphasis> جهت شناسایی کرنل را ندارند. از این بهتر، با استفاده از یک کرنل لینوکس درست و درمان، UEFI به طور مستقیم می‌تواند آن را فراخوانی کرده بدون اجرای هیچ bootloader دیگر. UEFI پایه و اساس فرآیندی است که به آن <emphasis>راه‌اندازی امن</emphasis> می‌گویند، فناوری که طی آن شما تنها مجاز به اجرای نرم‌افزاری هستید که تولیدکننده سیستم عامل مجوز آن را صادر کرده باشد.
			</para>
			 </sidebar> <para>
				یکی دیگر از کاربردهای BIOS/UEFI شناسایی و بارگذاری اولیه برخی دستگاه‌ها است. به طور مشخص این فرآیند شامل دستگاه‌های IDE/SATA (معمولاً هارددیسک‌ها و درایوهای CD/DVD) و همچنین دستگاه‌های PCI می‌شود. دستگاه‌های شناسایی شده حین فرآیند راه‌اندازی سیستم، روی صفحه نمایش داده می‌شوند. اگر این فهرست به تندی از جلوی چشمتان رد می‌شود می‌توانید با فشردن دکمه <keycap>Pause</keycap> صفحه را برای چند لحظه نگاه دارید و به مطالعه آن بپردازید. دستگاه‌های PCI که نصب شده‌اند اما نمایش داده نمی‌شوند مانند طالعی نحس عمل می‌کنند! در بدترین حالت، خود سخت‌افزار ممکن است مشکل داشته باشد. در بهترین حالت، تنها ناسازگاری آن‌ها با نسخه BIOS یا برد اصلی است. قوانین مربوط به PCI پیشرفت زیادی داشته‌اند، اما بردهای اصلی قدیمی ضمانت اجرای دستگاه‌های PCI جدیدتر را ندارند.
			</para>

		</section>
		 <section id="sect.kernel">
			<title>کرنل</title>
			 <para>
				هر دو ابزار BIOS/UEFI و bootloader تنها برای چند ثانیه اجرا می‌شوند؛ در این مرحله به اولین نرم‌افزاری می‌رسیم که برای مدت طولانی‌تری اجرا می‌شود، کرنل (هسته) سیستم عامل. کرنل نقش یک رهبر ارکستر را بازی می‌کند و ارتباط صحیح بین نرم‌افزار و سخت‌افزار را تضمین می‌نماید. این نقش مستلزم اجرای وظایف گوناگونی است از قبیل: مدیریت سخت‌افزار، مدیریت فرآیندها، کاربران و مجوزهای مربوط به آنان، فایل سیستم و بسیاری موارد دیگر. کرنل یک پایگاه عمومی برای سایر برنامه‌های سیستم ایجاد می‌کند.
			</para>

		</section>
		 <section id="sect.userspace-presentation">
			<title>فضای کاربری</title>
			 <para>
				با اینکه هر آنچه خارج از محیط داخلی کرنل اتفاق می‌افتد با نام “فضای کاربری” شناخته می‌شود، می‌توانیم این قسمت را به لایه‌های مختلف نرم‌افزاری تقسیم کنیم. اگرچه، تعامل بین آن‌ها نسبت به گذشته پیچیده‌تر شده است و طبقه‌بندی آن‌ها کار ساده‌ای نخواهد بود. یک برنامه کابردی به صورت عمومی از کتابخانه‌هایی استفاده می‌کند که برخی عملکردهای کرنل را فراخوانی می‌کنند، اما ارتباط بین آن‌ها می‌تواند منجز به درگیر کردن سایر برنامه‌ها نیز بشود یا حتی کتابخانه‌های بیشتری در این فرآیند فراخوانی گردند.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-role-and-tasks">
		<title>برخی از وظایفی که کرنل به آن‌ها رسیدگی می‌کند</title>
		 <section id="sect.hardware-drivers">
			<title>مدیریت سخت‌افزار</title>
			 <para>
				کرنل، در درجه نخست، وظیفه مدیریت قسمت‌های سخت‌افزاری، شناسایی آن‌ها و فعال‌سازی هنگامی که رایانه روشن می‌شود را بر عهده دارد. همچنین باعث می‌شود که نرم‌افزاری که در لایه بالاتر قرار دارد بتواند از طریق یک رابط برنامه‌نویسی ساده با آن ارتباط برقرار کند تا برنامه‌های کاربردی بتوانند از مزایای آن استفاده کرده بدون آنکه درگیر جزئیات لایه پایین‌تر خود شوند. این رابط برنامه‌نویسی همچنین یک لایه انتزاعی بوجود می‌آورد؛ برای نمونه، باعث می‌شود یک نرم‌افزار ویدیو کنفرانس بدون اطلاع از مدل و شماره وب‌کم، براحتی از آن استفاده کند. نرم‌افزار تنها می‌تواند از <emphasis>Video for Linux</emphasis> یا (V4L) استفاده کرده و کرنل وظیفه ترجمه فراخوانی‌های تابع را دارد که متناظر با دستورات موجود در خود سخت‌افزار وب‌کم باشند.
			</para>
			 <para>
				<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> کرنل بسیاری از جزئیات مربوط به سخت‌افزار را از طریق فایل سیستم‌های مجازی <filename>/proc/</filename> و <filename>/sys/</filename> ارائه می‌دهد. برخی ابزارها نیز قابلیت ارائه این گزارشات را دارند. از میان آن‌ها، دستور <command>lspci</command> (واقع در بسته <emphasis role="pkg">pciutils</emphasis>) فهرستی از دستگاه‌های PCI، دستور <command>lsusb</command> (واقع در بسته <emphasis role="pkg">usbutils</emphasis>) فهرستی از دستگاه‌های USB و دستور <command>lspcmcia</command> (واقع در بسته <emphasis role="pkg">pcmciautils</emphasis>) فهرستی از کارت‌های PCMCIA را نمایش می‌دهند. این ابزارها برای شناسایی مدل دقیق یک سخت‌افزار بسیار کاربردی هستند. این شناسایی دقیق منجر به جستجوهای دقیق‌تری در وب می‌شود که می‌تواند مستندات مرتبطی را نمایان سازد.
			</para>
			 <example>
				<title>نمونه اطلاعاتی که <command>lspci</command> و <command>lsusb</command> ارائه می‌دهند</title>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>

			</example>
			 <para>
				این برنامه‌ها شامل یک گزینه <literal>-v</literal> هستند که اطلاعات بیشتری (البته نه ضروری) را نمایش می‌دهند. در نهایت، دستور <command>lsdev</command> (واقع در بسته <emphasis role="pkg">procinfo</emphasis>) فهرستی از منابع ارتباطی که توسط دستگاه‌ها استفاده می‌شوند را نمایش می‌دهد.
			</para>
			 <para>
				برنامه‌های کاربردی اغلب بوسیله فایل‌های مخصوصی که درون <filename>/dev/</filename> ایجاد می‌شود (به قسمت <xref linkend="sidebar.special-files" /> مراجعه شود) به دستگاه‌های مختلف دسترسی پیدا می‌کنند. فایل‌های مخصوصی هستند که درایوهای دیسک (برای نمونه، <filename>/dev/hda</filename> و <filename>/dev/sda</filename>)، پارتیشن‌ها (<filename>/dev/hda1</filename> یا <filename>/dev/sda1</filename>)، ماوس (<filename>/dev/input/mouse0</filename>)، صفحه کلید (<filename>/dev/input/event0</filename>)، کارت‌ صدا (<filename>/dev/snd/*</filename>)، پورت‌های سریال (<filename>/dev/ttyS*</filename>) و بسیاری موارد دیگر را مشخص می‌کنند.
			</para>

		</section>
		 <section id="sect.filesystems">
			<title>فایل‌سیستم‌ها</title>
			 <indexterm>
				<primary>فایل‌سیستم</primary>
			</indexterm>
			 <indexterm>
				<primary>سیستم، فایل‌سیستم</primary>
			</indexterm>
			 <para>
				فایل‌سیستم‌ها یکی از برجسته‌ترین جنبه‌های کرنل هستند. سیستم‌های یونیکس تمام فایل‌های موجود را داخل یک ساختار درختی قرار می‌دهند، که به کاربران (و برنامه‌های کاربردی) به راحتی این امکان را می‌دهند تا با دانستن مکان فایل‌ها در این ساختار، از منابع آن استفاده کنند.
			</para>
			 <para>
				نقطه آغازین این ساختار درختی، ریشه نام دارد، <filename>/</filename>. این دایرکتوری می‌تواند شامل دایرکتوری‌های فرزند دیگری باشد. برای نمونه، دایرکتوری فرزند <literal>home</literal> از <filename>/</filename> با نام <filename>/home/</filename> شناخته می‌شود. این دایرکتوری فرزند نیز می‌تواند زیر مجموعه‌های خود را داشته باشد و به همین ترتیب. هر دایرکتوری می‌تواند شامل فایل‌های گوناگونی باشد، جایی که داده‌های واقعی ذخیره می‌شوند. بنابراین، <filename>/home/rmas/Desktop/hello.txt</filename> به فایلی با نام <literal>hello.txt</literal> در دایرکتوری فرزند <literal>Desktop</literal> واقع در حساب کاربری <literal>rmas</literal> از <literal>home</literal> قرار دارد که خود زیرمجموعه دایرکتوری ریشه است. کرنل وظیفه ترجمه این مسیرها و آدرس حقیقی رو دیسک را بر عهده دارد.
			</para>
			 <para>
				بر خلاف سایر سیستم‌ها، تنها یک ساختار درختی مانند این وجود دارد، که توانایی همگرائی داده‌ها از دیسک‌های فیزیکی گوناگون را داراست. یکی از این دیسک‌ها به عنوان دایرکتوری ریشه استفاده شده است و دیسک‌های دیگر بر روی سایر دایرکتوری‌های فرزند آن “سوار” شده‌اند (دستور یونیکس آن <command>mount</command> خوانده می‌شود)؛ این دیسک‌ها تحت عبارت “نقاط دسترسی (سوار)” شناخته می‌شوند. این قابلیت، امکان ذخیره‌سازی دایرکتوری‌های مربوط به حساب کاربری افراد (که به صورت سنتی در <filename>/home/</filename> ذخیره می‌شود) را روی دیسک دیگری می‌دهد که شامل <literal>rhertzog</literal> و <literal>rmas</literal> است. زمانی که دیسک روی <filename>/home/</filename> سوار شود، این دایرکتوری‌ها در مکان‌های مورد نظر خود قادر دسترس خواهند شد و مسیرهایی مانند <filename>/home/rmas/Desktop/hello.txt</filename> به درستی کار خواهند کرد.
			</para>
			 <indexterm>
				<primary><command>mkfs</command></primary>
			</indexterm>
			 <para>
				انواع مختلفی از فایل‌سیستم وجود دارد، که هر یک متناسب با یک شیوه ذخیره‌سازی داده روی دیسک هستند. شناخته‌شده‌ترین آن‌ها عبارتند از <emphasis>ext2</emphasis> و <emphasis>ext3</emphasis> و <emphasis>ext4</emphasis> اما موارد دیگری نیز وجود دارد. برای نمونه، <emphasis>vfat</emphasis> سیستمی است که سابق بر این توسط سیستم‌ عامل‌های داس و ویندوز استفاده می‌شد که امکان استفاده همزمان از هارددیسک روی دبیان و ویندوز را می‌دهد. در هر صورت، یک فایل سیستم ابتدا باید روی دیسک آماده شود قبل از اینکه بتوان از آن استفاده کرد که به این فرآیند “فرمت‌کردن” می‌گویند. دستوراتی مانند <command>mkfs.ext3</command> (که <command>mkfs</command> مخفف <emphasis>Make FileSystem</emphasis> است) فرمت‌کردن را بر عهده دارند. این دستورات، به عنوان پارامتر، نیاز به فایلی دارند که نشان‌دهنده پارتیشنی است که باید فرمت شود (برای نمونه، <filename>/dev/sda1</filename>). این عملیات، مخرب است و تنها یکبار باید اجرا شود، مگر در شرایطی که کسی بخواهد به عمد تمام محتویات روی فایل‌سیستم را از بین ببرد.
			</para>
			 <para>
				همچنین فایل‌سیستم‌های شبکه‌ای نیز وجود دارند، مانند <acronym>NFS</acronym> که داده به صورت مستقیم از روی دیسک نصب شده روی رایانه خوانده نمی‌شود. در عوض، داده توسط شبکه به سروری که وظیفه نگهداری و بازنشانی داده را به عهده دارد، منتقل می‌شود. این فایل‌سیستم لایه‌ای انتزاعی برای کاربر بوجود می‌آورد: تمامی فایل‌ها با همان ساختار درختی سابق قابل دسترسی خواهند بود.
			</para>

		</section>
		 <section id="sect.shared-functions">
			<title>توابع اشتراکی</title>
			 <para>
				از آنجایی که تعدادی از عملکردهای پایه در تمام نرم‌افزارها مورد استفاده قرار می‌گیرند، معقول به نظر می‌رسد که یک مکان مرکزی برای آن‌ها در کرنل در نظر بگیریم. برای نمونه، فایل‌سیستم اشتراکی به هر برنامه کاربری این امکان را می‌دهد که تمامی فایل‌ها را با استفاده از نامشان باز کند، بدون نگرانی از اینکه این فایل در کجای دیسک ذخیره شده است. فایل ممکن است در قطاع‌های گوناگونی از دیسک ذخیره شده باشد، یا حتی بین چند دیسک گوناگون تقسیم شده باشد، یا در یک فایل سرور روی شبکه قرار داشته باشد. توابع ارتباطی اشتراکی توسط برنامه‌های کاربردی به منظور تبادل داده مورد استفاده قرار می‌گیرند مستقل از راه و روش انتقال آن. برای نمونه، عملیات انتقال ممکن است با ترکیبی از شبکه‌های محلی یا بیسیم یا حتی خطوط تلفن صورت بگیرد.
			</para>

		</section>
		 <section id="sect.process-management">
			<title>مدیریت فرآیندها (پروسه‌ها)</title>
			 <indexterm>
				<primary><emphasis>pid</emphasis></primary>
			</indexterm>
			 <para>
				یک فرآیند، نمونه اجرایی یک برنامه به حساب می‌آید. این عمل شامل حافظه‌ای است که هم برنامه را شامل شود هم عملیات کنترلی روی آن. کرنل وظیفه ایجاد و ردیابی آن‌ها را برعهده دارد. زمانی که یک برنامه اجرا می‌شود، کرنل در ابتدا مقداری حافظه کنار می‌گذارد، سپس کد اجرایی برنامه از از فایل‌سیستم خوانده و درون حافظه بارگذاری می‌کند و در نهایت به اجرای کد می‌پردازد. اطلاعات مربوط به این فرآیند را ذخیره می‌کند، که مهم‌ترین این اطلاعات یک شناسه عددی به نام <emphasis>pid</emphasis> است (<emphasis>شناسه فرآیند</emphasis>).
			</para>
			 <para>
				کرنل‌های شبه یونیکس (از جمله لینوکس)، مانند سایر سیستم عامل‌های پیشرفته، قابلیت “چند وظیفگی” دارند. به عبارت دیگر، آن‌ها اجازه اجرای بسیاری از فرآیندها را “در یک زمان مشخص” می‌دهند. در حقیقت تنها یک فرآیند در هر واحد زمانی وجود دارد، اما کرنل زمان را به بازه‌های کوچکتری تبدیل می‌کند و به اجرای هر فرآیند می‌پردازد. از آنجایی که این بازه‌های زمانی بسیار کوتاه هستند (در محدوده هزارم ثانیه)، این خیال باطل بوجود می‌آید که گویی همه فرآیندها به صورت موازی اجرا می‌شوند، با اینکه در حقیقت هر یک از آن‌ها طی یک بازه زمانی فعال و در زمان دیگر دیگر بیکار هستند. وظیفه کرنل این است که مکانیزم این جدول زمانی را طوری تنظیم کند که این خیال به ذهن برسد، همزمان با اینکه عملکرد عمومی سیستم را افزایش دهد. اگر این بازه‌های زمانی بسیار طولانی باشند، برنامه کاربردی ممکن است پاسخی از خود نمایش ندهد و اگر بسیار کوتاه باشد سیستم توانایی تعویض این بازه‌ها را از دست خواهد داد. این تصمیمات می‌تواند با استفاده از اولویت‌بندی برای فرآیندها تغییر یایند. فرآیندهای با اولویت بالا برای مدت طولانی و با بازه‌های زمانی مکرر اجرا خواهند شد تا فرآیندهای با اولویت پایین.
			</para>
			 <sidebar> <title><emphasis>یادداشت</emphasis> سیستم‌های چند پردازنده‌ای (و خانواده آن‌ها(</title>
			 <para>
				محدودیت اشاره شده بالا که تنها یک فرآیند در هر زمان قابل اجرا است، همیشه صادق نیست. محدودیت واقعی در حقیقت این است که تنها یک فرآیند در حال اجرا روی <emphasis>هر هسته پردازنده</emphasis> در یک زمان قابل اجرا است. سیستم‌های چندپردازنده‌ای، چندهسته‌ای یا “چند-نخی” اجازه اجرای چندین فرآیند به صورت موازی را می‌دهند. کماکان از همان سیستم تقسیم زمانی استفاده می‌شود، البته، با این تفاوت که فرآیندهای فعال بیشتری روی هسته‌های پردازنده موجود هستند. این حالت اصلاً غیرعادی نیست: یک سیستم پایه، حتی بیکارترین آن‌ها، تقریباً همیشه ده‌ها فرآیند در حال اجرا دارد.
			</para>
			 </sidebar> <para>
				البته، کرنل اجازه اجرای چند نسخه مختلف از یک برنامه را می‌دهد. اما هر یک از آن‌ها تنها می‌تواند به برش زمانی و حافظه خود دسترسی داشته باشد. داده‌های موجود در آن‌ها به صورت جداگانه باقی می‌مانند.
			</para>

		</section>
		 <section id="sect.permissions">
			<title>مدیریت مجوز</title>
			 <para>
				سیستم‌های شبه‌-یونیکس همچنین چند-کاربره نیز هستند. آن‌ها سیستم مدیریت مجوزی را فراهم می‌کنند که از کاربران و گروه‌های کاربری جداگانه، حمایت می‌کند؛ همچنین اجازه کنترل بر اساس نوع فعالیت و مجوز آن را هم می‌دهد. کرنل داده مربوط به هر فرآیند را مدیریت می‌کند و به آن اجازه کنترل مجوزهایش را می‌دهد. در اکثر اوقات، یک فرآیند توسط کاربری که آن را أغاز کرده است شناخته می‌شود. آن فرآیند تنها مجاز به اجرای عملیاتی است که برای آن کاربر مشخص شده است. برای نمونه، تلاش برای باز کردن یک فایل نیازمند بررسی کرنل از شناسه فرآیند در مقابله با مجوزهای مورد نیازش می‌باشد (برای جزئیات بیشتر در این مورد خاص، <xref linkend="sect.rights-management" /> را ببینید).
			</para>

		</section>

	</section>
	 <section id="sect.user-space">
		<title>فضای کاربری</title>
		 <indexterm>
			<primary>فضای کاربر</primary>
		</indexterm>
		 <indexterm>
			<primary>فضای کرنل</primary>
		</indexterm>
		 <para>
			به محیط اجرایی فرآیندهای عادی (بر خلاف کرنل) “فضای کاربر” گفته می‌شود. الزماً به این معنی نیست که این فرآیندها در حقیقت توسط کاربر اجرا می‌شوند چرا که یک سیستم استاندارد شامل چند “daemon” (پس‌زمینه) است که قبل از ورود کاربر به سیستم، فرآیندها را اجرا می‌کنند. این فرآیندها همچنین به عنوان فرآیندهای فضای-کاربر شناخته می‌شوند.
		</para>
		 <section id="sect.process-basics">
			<title>فرآیند</title>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				زمانی که کرنل فاز اولیه خود را می‌گذراند، اولین فرآیند موجود را آغاز می‌کند، <command>init</command>. فرآیند شماره ۱ به خودی خود کاربردی ندارد، به همین دلیل است که سیستم‌های شبه-یونیکس فرآیندهای بسیار دیگری را اجرا می‌کنند.
			</para>
			 <indexterm>
				<primary><emphasis>fork</emphasis></primary>
			</indexterm>
			 <para>
				اول از همه، یک فرآیند می‌تواند خودش را شبیه‌سازی کند (که البته با نام <emphasis>fork</emphasis> شناخته می‌شود). کرنل در این حالت یک فضای حافظه جدید (اما برابر) همچنین فرآیند دیگری که از آن استفاده کند، اختصاص می‌دهد. در این زمان، تنها تفاوت موجود بین این دو فرآیند <emphasis>pid</emphasis> آن‌ها است. فرآیند جدید معمولاً بنام فرزند و فرآیند اصلی که <emphasis>pid</emphasis> آن تغییر نکرده است بنام پدر نامگذاری می‌شوند.
			</para>
			 <para>
				گاهی اوقات، فرآیند فرزند به حیات خود مستقل از فرآیند پدر ادامه می‌دهد، با داده‌های خودش که از فرآیند پدر کپی شده است. در بسیاری موارد، البته، این فرآیند فرزند برنامه دیگری را اجرا می‌کند. بجز موارد خاص، حافظه آن به سادگی با آن برنامه جدید جایگزین می‌شود و اجرای این برنامه جدید آغاز می‌گردد. این مکانیزمی است که فرآیند init (با شماره فرآیند ۱) از آن استفاده می‌کند تا سرویس‌های اضافی را راه‌اندازی کرده و به اجرای تمام مراحل بارگذاری سیستم بپردازد. در برخی نقاط، یک فرآیند از میان فرزندان <command>init</command> مبادرت به اجرای یک رابط گرافیکی می‌کند تا کاربران بتوانند وارد آن شوند (ترتیب دقیق این رویدادها به طور مشروح در <xref linkend="sect.system-boot" /> آمده است).
			</para>
			 <para>
				زمانی که یک فرآیند به اتمام کار خود می‌رسد، نابود می‌گردد. کرنل در این زمان حافظه‌ای که به آن تخصیص داده بود را بازیابی می‌کند و دیگر بازه‌های زمانی در اختیارش قرار نمی‌دهد. همچنین به فرآیند پدر نیز اطلاع داده می‌شود که فرزندش نابود شده است، که این امکان را به یک فرآیندی که تحت فرآیند فرزند اجرا شده است می‌دهد تا عملیات مربوط به خود را قبل از نابودشدن آن انجام دهد. این رفتار به وضوح در مفسرهای خط فرمان (که با نام <emphasis>shell</emphasis> شناخته می‌شوند) قابل رویت است. زمانی که یک دستور درون خط فرمان نوشته می‌شود، کنترل خط فرمان تنها زمانی به کاربر بر می‌گردد که آن دستور تمام شده باشد. اکثر خط‌فرمان‌ها اجازه اجرای دستور در پس‌زمینه را می‌دهند، که این عمل به سادگی با اضافه کردن یک <userinput>&amp;</userinput> به انتهای دستور ممکن است. در این حالت، خط فرمان بلافاصله در اختیار کاربر قرار می‌گیرد، البته ممکن است در شرایطی که دستور نیاز به نمایش برخی داده‌ها داشته باشد مشکل آفرین گردد.
			</para>

		</section>
		 <section id="sect.daemons">
			<title>فرآیندهای پس‌زمینه</title>
			 <indexterm>
				<primary>فرآیند پس‌زمینه</primary>
			</indexterm>
			 <indexterm>
				<primary>فرآیند پس‌زمینه</primary>
			</indexterm>
			 <para>
				یک “daemon” فرآیندی است که به صورت خودکار در زمان راه‌اندازی سیستم اجرا می‌شود. این فرآیند به اجرای خود (در پس‌زمینه) ادامه می‌دهد تا برخی وظایف نگهداری را انجام داده یا برخی سرویس‌ها را در اختیار سایر فرآیندها بگذارد. این “وظیفه پس‌زمینه” در حقیقت نامی دلخواه است که از دید کلی سیستم معنای خاصی نمی‌دهد. آن‌ها به سادگی، همان فرآیندها هستند، درست مانند سایر فرآیندها که هر زمان نوبتشان فرا برسد اجرا می‌شوند. تفاوت تنها در نامگذاری است که ما برایشان انتخاب کردیم: فرآیندی که بدون تعامل کاربر اجرا می‌شود (به طور خاص، بدون هیچ رابط گرافیکی) به عنوان فرآیند “پس‌زمینه” یا “daemon” شناخته می‌شود.
			</para>
			 <sidebar> <title><emphasis>واژگان</emphasis> Daemon, demon, یک عبارت موهن؟</title>
			 <para>
				با اینکه عبارت <emphasis>daemon</emphasis> ریشه‌در لغت یونانی <emphasis>demon</emphasis> دارد، اولی هیچ ارتباطی با شیطان و مظاهر آن ندارد! در عوض، بیشتر باید به عنوان یک روح یاری‌رسان دیده شود. این تفاوت در زبان انگلیسی نامحسوس است؛ حتی در سایر زبان‌ها که این لغت به هر دو معنایش اشاره می‌کند، شرایط بدتر بنظر می‌آید.
			</para>
			 </sidebar> <para>
				تعدادی از این فرآیندهای پس‌زمینه با جزئیات در قسمت <xref linkend="unix-services" /> توضیح داده شده‌اند.
			</para>

		</section>
		 <section id="sect.ipc">
			<title>ارتباطات بین‌-فرآیندی</title>
			 <indexterm>
				<primary>IPC</primary>
			</indexterm>
			 <indexterm>
				<primary>ارتباطات بین‌-فرآیندی</primary>
			</indexterm>
			 <para>
				یک فرآیند جدا شده (ایزوله)، خواه پس‌زمینه باشد یا یک برنامه کاربردی، به خودی خود کاربردی ندارد، به همین دلیل است که روش‌های گوناگونی برای ارتباط و تعامل بین این فرآیندها وجود دارد، خواه برای تبادل داده یا کنترل یکدیگر. عبارت عمومی که به این منظور استفاده می‌شود <emphasis>ارتباط بین‌-فرآیندی</emphasis> یا به طور خلاصه IPC نام دارد.
			</para>
			 <para>
				ساده‌ترین سیستم IPC از فایل‌ها استفاده می‌کند. فرآیندی که طی آن فرستنده، داده را جهت ذخیره‌سازی روی یک فایل (با نامی که در ادامه‌اش می‌آید) ارسال می‌کند و گیرنده تنها باید فایل را باز کرده و محتویات آن را بخواند.
			</para>
			 <indexterm>
				<primary><emphasis>لوله</emphasis></primary>
			</indexterm>
			 <para>
				در صورتی که نخواهید داده را روی دیسک ذخیره کنید، می‌توانید از یک <emphasis>لوله</emphasis> استفاده کنید، که در ساده‌ترین حالت یک مدخل دوطرفه است؛ بایت‌هایی که در یک طرف نوشته می‌شوند در طرف دیگر قابل خواندن هستند. اگر طرفین این لوله توسط فرآیندهای جداگانه‌ای کنترل می‌شوند، این عملیات به یک کانال ارتباط بین‌-فرآیندی ساده تبدیل می‌شود. لوله‌ها می‌توانند به دو طبقه‌بندی تقسیم شوند: لوله‌های نامدار و لوله‌های بی‌نام و نشان. یک لوله نامدار توسط یک مدخل در فایل‌سیستم نمایش داده می‌شود (با اینکه داده تبادل یافته آنجا ذخیره نمی‌شود)، بنابراین هر دو فرآیند می‌توانند آن را جداگانه باز کنند در صورتی که مکان لوله نامدار قبل از آن ذکر شده باشد. در مواردی که فرآیندهای در حال تعامل به یکدیگر مربوط هستند (برای نمونه، یک فرآیند پدر و فرزند)، فرآیند پدر می‌تواند قبل از عملیات شبیه‌سازی یک لوله بی‌نام و نشان ایجاد کند تا فرزندش آن را به ارث ببرد. هر دو فرآیند در این حالت قادر به تبادل داده هستند بدون آنکه به فایل‌سیستم نیازی داشته باشند.
			</para>
			 <sidebar> <title><emphasis>در عمل</emphasis> یک نمونه کاربردی</title>
			 <para>
				بیاید جزئیاتی را تشریح کنیم که هنگام اجرای یک دستور پیچیده (یک <emphasis>pipeline</emphasis>) از خط فرمان اتفاق می‌افتند. فرض می‌کنیم فرآیند <command>bash</command> داریم (خط فرمان استاندارد دبیان) با <emphasis>pid</emphasis> برابر ۴۳۷۴؛ درون این خط فرمان دستور <command>ls | sort</command> را وارد می‌کنیم.
			</para>
			 <para>
				خط فرمان در ابتدا به تفسیر دستور وارد شده می‌پردازد. در این مورد، درک می‌کند که دو برنامه وجود دارند (<command>ls</command> و <command>sort</command>) با جریان داده‌ای که از یکی به دیگری سرازیر می‌شود (که با کاراکتر <userinput>|</userinput> به عنوان <emphasis>لوله</emphasis> نشان داده می‌شود). در ابتدا <command>bash</command> یک لوله بی‌نام و نشان ایجاد می‌کند (که به صورت اولیه در فرآیند خود <command>bash</command> وجود دارد).
			</para>
			 <para>
				آنگاه خط فرمان به شبیه‌سازی خود می‌پردازد؛ که به ایجاد یک فرآیند جدید <command>bash</command> منجر می‌شود با شماره <emphasis>pid</emphasis> ۴۵۲۱ (<emphasis>pid</emphasis> اعداد انتزاعی هستند و در مجموع معنی خاصی نمی‌دهند). فرآیند ۴۵۲۱ از لوله ارث‌بری می‌کند، به این معنا که می‌تواند در قسمت ... آن بنویسد؛ <command>bash</command> جریان خروجی استاندارد خود را به ورودی این لوله سرازیر می‌کند. آنگاه برنامه <command>ls</command> اجرا (و جایگزین) می‌شود ،که وظیفه آن نمایش محتویات موجود در دایرکتوری فعلی است. از آنجایی که <command>ls</command> روی خروجی استاندارد خود می‌نویسد، و این خروجی قبل از این تغییر کرده است، نتایج با موفقیت به لوله فرستاده می‌شوند.
			</para>
			 <para>
				عملیات مشابهی برای دستور دوم اجرا می‌شوند: <command>bash</command> به شبیه‌سازی (کپی) خود می‌پردازد، که منجر به فرآیند <command>bash</command> جدیدی با شماره ۴۵۲۲ می‌شود. از آنجایی که یک فرآیند فرزند برای ۴۳۷۴ به حساب می‌آید، لوله را به ارث می‌برد؛ آنگاه <command>bash</command> ورودی استاندارد خود را به خروجی لوله متصل می‌کند، آنگاه دستور <command>sort</command> را اجرا (و با خود جایگزین) می‌کند، که این دستور ورودی را به صورت مرتب‌شده نمایش می‌دهد.
			</para>
			 <para>
				اکنون تمام قطعه‌های پازل در جای خود قرار گرفته‌اند: <command>ls</command> محتویات دایرکتوری فعلی را می‌خواند و فهرستی از فایل‌ها را روی لوله قرار می‌دهد؛ <command>sort</command> این فهرست را خوانده، به صورت الفبایی مرتب کرده و نتایج را نمایش می‌دهد. شماره فرآیندهای ۴۵۲۱ و ۴۵۲۲ نابود می‌شوند و ۴۳۷۴ (که در طی این مدت منتظر آن‌ها بود) کنترل را ادامه داده و خط فرمان را در اختیار کاربر قرار می‌دهد تا دستور جدیدی وارد کند.
			</para>
			 </sidebar> <para>
				البته، تمام ارتباطات بین‌-فرآیندی جهت تبادل داده بکار نمی‌روند. در شرایط دیگر، تنها اطلاعاتی که نیاز به رد و بدل شدند دارند پیام‌های کنترلی مانند “توقف اجرا” یا “ادامه اجرا” می‌باشند. یونیکس (و لینوکس) مکانیزمی با نام <emphasis>سیگنال</emphasis> فراهم می‌آورد، که از طریق آن یک فرآیند می‌تواند یک سیگنال مشخص (که از فهرست از پیش آماده شده سیگنال‌ها انتخاب شده است) را به فرآیند دیگر ارسال کند. تنها پیشنیاز این ارتباط، دانستن <emphasis>pid</emphasis> فرآیند هدف است.
			</para>
			 <para>
				برای ارتباطات پیچیده‌تر، مکانیزم‌هایی وجود دارند که یه یک فرآیند اجازه دسترسی یا اشتراک‌گذاری برخی از حافظه تخصیص یافته خود را به سایر فرآیندها می‌دهد. اکنون از حافظه اشتراکی بین این دو فرآیند می‌توان به عنوان کانالی جهت تبادل داده استفاده کرد.
			</para>
			 <para>
				در نهایت، ارتباطات شبکه نیز می‌تواند به ارتباط فرآیندها کمک کند؛ این فرآیندها حتی در رایانه‌های مختلف اجرا می‌شوند، که احتمالاً هزاران کیلومتر از یکدیگر فاصله دارند.
			</para>
			 <para>
				تقریباً برای یک سیستم شبه‌-یونیکس بسیار متداول است که بسیاری از این مکانیزم‌ها را در درجات مختلف بکار گیرد.
			</para>

		</section>
		 <section id="sect.libraries">
			<title>کتابخانه‌ها</title>
			 <indexterm>
				<primary>کتابخانه‌ای (از توابع)</primary>
			</indexterm>
			 <para>
				کتابخانه‌های تابعی نقشی حیاتی در سیستم‌های شبه‌-یونیکس ایفا می‌کنند. آن‌ها برنامه‌های آماده نیستند، چرا که به خودی خود قابلیت اجرا شدن ندارند، اما مجموعه‌هایی جدا جدا از کد هستند که قابلیت استفاده توسط برنامه‌های استاندارد را دارند. در میان این کتابخانه‌های عمومی، می‌توانید مواردی زیر را پیدا کنید:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						کتابخانه استاندارد C (<emphasis>glibc</emphasis>)، که شامل توابع پایه مانند بازکردن فایل یا ارتباط شبکه و سایر ابزارهای تعاملی با کرنل است؛
					</para>

				</listitem>
				 <listitem>
					<para>
						ابزارهای گرافیکی، مانند +GTK و Qt به بسیاری از برنامه‌ها این امکان را می‌دهند تا از قسمت‌های مختلف یک محیط گرافیکی استفاده کنند؛
					</para>

				</listitem>
				 <listitem>
					<para>
						کتابخانه <emphasis>libpng</emphasis>، که امکان بارگذاری، تفسیر و ذخیره تصاویر در قالب PNG را فراهم می‌کند.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				به لطف این کتابخانه‌ها، برنامه‌های کاربردی می‌توانند از کد موجود استفاده کنند. توسعه برنامه‌ها آسان‌تر شده است چرا از بسیاری توابع موجود استفاده می‌کنند. با کتابخانه‌هایی که توسط افراد گوناگون توسعه یافته است، توسعه سراسری سیستم به فلسفه تاریخی یونیکس نزدیک‌تر شده است.
			</para>
			 <sidebar> <title><emphasis>فرهنگ</emphasis> راه و روش یونیکس: یک کار در هر زمان</title>
			 <para>
				یکی از بنیادی‌ترین مفاهیمی که در سیستم عامل‌های خانواده یونیکس ریشه دارد این است که هر ابزاری باید تنها یک کار انجام دهد، و آن را درست هم انجام دهد؛ برنامه‌ها می‌توانند از این ابزار استفاده کنند تا منطق پیچیده‌تری را بوجود آورند. این فلسفه می‌تواند حالت‌های گوناگونی به خود بگیرد. اسکریپت‌های خط فرمان شاید بهترین نمونه باشند: آن‌ها با استفاده از ابزار ساده، ترکیبات بسیار پیچیده‌ای بوجود می‌آورند (مانند <command>grep</command> و <command>wc</command> و <command>sort</command> و <command>uniq</command>). نمونه پیاده‌سازی شده دیگر از این فلسفه در کتابخانه‌های کد دیده می‌شود: کتابخانه <emphasis>libpng</emphasis> اجازه خواندن و نوشتن فایل‌های PNG را می‌دهد، با گزینه‌های مختلف و روش‌های گوناگون، اما تنها همین کار را انجام می‌دهد؛ توابعی که باعث نمایش تصاویر یا ویرایش آن‌ها شوند وجود ندارد.
			</para>
			 </sidebar> <para>
				بر این به، أن‌ها اغلب کتابخانه‌های “اشتراکی گفته” می‌شود چرا، که کرنل تنها قادر است علاوه آن‌ها را یکبار در حافظه بارگذاری نماید با اینکه فرآیندهای بسیاری می‌توانند به طور همزمان از آن‌ها استفاده کنند. اینکار امکان صرفه‌جویی در حافظه را فراهم می‌آورد در مقایسه با شرایط عکس آن (به صورت فرضی) که کد موجود در کتابخانه به تعداد دفعاتی که فرآیندها از آن استفاده می‌کنند در حافظه قرار داده شود.
			</para>

		</section>

	</section>
</appendix>

