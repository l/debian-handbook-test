<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="basic-configuration" lang="fa-IR">
	<chapterinfo>
		 <keywordset>
			<keyword>پیکربندی</keyword>
			 <keyword>بومی‌سازی</keyword>
			 <keyword>مناطق</keyword>
			 <keyword>شبکه</keyword>
			 <keyword>شفافیت نامگذاری</keyword>
			 <keyword>کاربران</keyword>
			 <keyword>گروه‌ها</keyword>
			 <keyword>حساب‌های کاربری</keyword>
			 <keyword>مفسر خط‌-فرمان</keyword>
			 <keyword>پوسته</keyword>
			 <keyword>چاپ</keyword>
			 <keyword>راه‌انداز اولیه</keyword>
			 <keyword>کامپایل کرنل</keyword>

		</keywordset>

	</chapterinfo>
	 <title>پیکربندی اولیه: شبکه، حساب‌های کاربری، چاپ و ...</title>
	 <highlights> <para>
		از رایانه‌ای که توسط ابزار <command>debian-installer</command> نصب می‌گردد انتظار می‌رود که تا جای ممکن کارآمد باشد، اما بسیاری از سرویس‌ها باید پیکربندی شوند. علاوه بر این، ایده خوبی است که بدانیم در زمان نصب اولیه کدام گزینه‌ها قابلیت تغییر را دارند.
	</para>
	 </highlights> <para>
		این فصل به بررسی هر آنچه که ما به آن “پیکربندی پایه” می‌گوییم می‌پردازد: تنظیمات شبکه، زبان و منطقه، کاربران و گروه‌ها، چاپ، نگاشت دستگاه‌ها و از این قبیل.
	</para>
	 <section id="sect.config-language-support">
		<title>پیکربندی سیستم برای یک زبان دیگر</title>
		 <indexterm>
			<primary>بومی‌سازی فرانسوی</primary>
		</indexterm>
		 <para>
			اگر سیستم توسط زبان فرانسوی نصب شده باشد، ماشین به احتمال زیاد از همین زبان به صورت پیش‌فرض استفاده می‌کند. خوب است که بدانیم برنامه نصب‌کننده چطور این تغییرات را انجام می‌دهد تا در صورت نیاز بتوان زبان را تغییر داد.
		</para>
		 <sidebar> <title><emphasis>ابزار</emphasis> دستور <command>locale</command> برای نمایش پیکربندی فعلی</title>
		 <para>
			دستور <command>locale</command> فهرست خلاصه‌ای از پیکربندی فعلی سیستم بر اساس پارامترهای منطقه‌ای را نشان می‌دهد (قالب تاریخ، قالب اعداد و ...) که این فهرست به صورت مجموعه‌ای از متغیرهای محلی استاندارد در اختیار سیستم و برنامه‌های آن قرار دارند.
		</para>
		 </sidebar> <section id="sect.default-language">
			<title>تنظیم زبان پیش‌فرض</title>
			 <indexterm>
				<primary>مناطق</primary>
			</indexterm>
			 <indexterm>
				<primary>زبان</primary>
			</indexterm>
			 <indexterm>
				<primary><command>locale-gen</command></primary>
			</indexterm>
			 <para>
				یک locale گروهی از تنظیمات مربوط به آن منطقه است. این گروه نه تنها شامل زبان مورد نیاز برای متن است، بلکه قالب مورد نیاز جهت نمایش اعداد، تاریخ، زمان، پول و همچنین قواعد مقایسه الفبایی مربوط به آن زبان را شامل می‌شود. اگرچه هر یک از این پارامترها می‌توانند جداگانه از یکدیگر تعریف شوند، معمولا از یک locale به منظور گردآوری پارامترهای مورد نیاز در یک منطقه استفاده می‌کنیم. این مناطق معمولا به صورت <literal><replaceable>language-code</replaceable>_<replaceable>COUNTRY-CODE</replaceable></literal> نشان داده می‌شوند، گاهی اوقات به همراه پسوندی که برای مشخص کردن کاراکترها به کار می‌رود. این قابلیت به منظور بهره‌گیری از تفاوت‌های موجود بین عبارت‌های نگارشی بین چند منطقه با زبانی مشترک به کار می‌رود.
			</para>
			 <sidebar> <title><emphasis>فرهنگ</emphasis> مجموعه‌های کاراکتری</title>
			 <indexterm>
				<primary>مجموعه کاراکتری</primary>
			</indexterm>
			 <indexterm>
				<primary>کدگذاری</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-1</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-15</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 1</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 9</primary>
			</indexterm>
			 <para>
				به لحاظ تاریخی، هر منطقه “مجموعه کاراکتری” مربوط به خود را دارد (گروهی از کاراکترهای شناخته شده) به همراه یک “کدگذاری” مشخص (شیوه نمایش داخلی کاراکترها در رایانه).
			</para>
			 <para>
				محبوب‌ترین شیوه‌های کدگذاری برای زبان‌های مبتنی بر لاتین محدود به ۲۵۶ کاراکتر بودند چرا که از هر بایت به منظور ذخیره‌سازی یک کاراکتر استفاده می‌کردند. از آنجایی که ۲۵۶ کاراکتر برای پوشش تمام زبان‌های اروپایی کافی نبود، به شیوه‌های کدگذاری دیگری نیاز بود و این همان دلیلی است که اکنون به <emphasis>ISO-8859-1</emphasis> (که با نام “Latin 1” شناخته می‌شود) تا <emphasis>ISO-8859-15</emphasis> (که با نام “Latin 1” شناخته می‌شود) دست یافته‌ایم.
			</para>
			 <para>
				کار با زبان‌های خارجه اشاره بر تعویض متداول بین شیوه‌های کدگذاری مختلف و مجموعه‌های کاراکتری دارد. علاوه بر این، نگارش اسناد چند زبانه تقریبا منجر به ایجاد مشکلاتی در آینده می‌گردد. یونیکد (یک کاتالوگ عظیم از تمام سیستم‌های نگارش موجود در تمام زبان‌های دنیا) به منظور حل این مشکل بوجود آمده است. یکی از شیوه‌های کدگذاری یونیکد، UTF-8، تمام ۱۲۸ نماد ASCII را حفظ (کدهای ۷ بیتی) اما سایر کاراکترها را به شیوه‌ای دیگر مدیریت می‌کند. این کاراکترها به همراه یک توالی مشخص که نشان‌دهنده طول هر یک از آن‌ها است تعریف می‌شوند. این عملیات امکان رمزگذاری تمام کاراکترهای یونیکد در حالت یک یا دو بایتی را فراهم می‌سازد. کاربرد یونیکد به اندازه‌ای محبوب شده است که هم اکنون شیوه کدگذاری پیش‌فرض در اسناد XML به حساب می‌آید.
			</para>
			 <indexterm>
				<primary>ASCII</primary>
			</indexterm>
			 <indexterm>
				<primary>UTF-8</primary>
			</indexterm>
			 <indexterm>
				<primary>یونیکد</primary>
			</indexterm>
			 <para>
				این شیوه کدگذاری است که باید استفاده شود، که در سیستم‌های دبیان نیز حالت پیش‌فرض است.
			</para>
			 </sidebar> <para>
				بسته <emphasis role="pkg">locales</emphasis> تمام عناصر مورد نیاز برای عملکرد صحیح “بومی‌سازی” بسیاری از برنامه‌ها را شامل می‌شود. هنگام نصب، این بسته مجموعه زبان‌های پشتیبانی شده را از شما می‌پرسد. این تنظیمات در هر لحظه توسط دستور <command>dpkg-reconfigure locales</command> قابل تغییر هستند.
			</para>
			 <para>
				پرسش اول در مورد پشتیبانی از “مناطق” مختلف است. انتخاب تمام مناطق انگلیسی‌زبان (آن‌هایی که با “<literal>en_</literal>” شروع می‌شوند) معقول به نظر می‌رسد. از فعال‌سازی سایر مناطق برای کاربران خارجی زبان خود دریغ نکنید. فهرستی از مناطق که در سیستم فعال هستند در فایل <filename>/etc/locale.gen</filename> ذخیره شده‌اند. امکان ویرایش دستی این فایل وجود دارد اما پس از هر تغییر باید دستور <command>locale-gen</command> را اجرا کنید. این دستور فایل‌های مورد نیاز برای مناطق جدید را اضافه و فایل‌های قدیمی را پاک می‌کند.
			</para>
			 <para>
				پرسش دوم، که عنوان “منطقه پیش‌فرض برای محیط سیستم” را دارد، درخواست یک منطقه پیش‌فرض را می‌کند. انتخاب توصیه‌شده برای U.S.A استفاده از “<literal>en_US.UTF-8</literal>” است. برای انگلیسی‌زبان‌های بریتانیا “<literal>en_GB.UTF-8</literal>” و کانادایی‌ها نیز “<literal>en_CA.UTF-8</literal>” یا “<literal>fr_CA.UTF-8</literal>” را برای زبان فرانسوی انتخاب می‌کنند. فایل <filename>/etc/default/locale</filename> تغییر می‌کند تا انتخاب‌های صورت گرفته را ذخیره سازد. از این لحظه، این تنظیمات توسط PAM درون متعیر محلی <varname>LANG</varname> قرار می‌گیرد تا تمام برنامه‌ها از آن استفاده کنند.
			</para>
			 <indexterm>
				<primary>محیط</primary>
			</indexterm>
			 <indexterm>
				<primary>منطقه</primary>
			</indexterm>
			 <indexterm>
				<primary><varname>LANG</varname></primary>
			</indexterm>
			 <sidebar id="sidebar.intro-pam"> <title><emphasis>پشت صحنه</emphasis> <filename>/etc/environment</filename> و <filename>/etc/default/locale</filename></title>
			 <para>
				فایل <filename>/etc/environment</filename> متغیرهای محلی صحیح را برای برنامه‌های <command>login</command>، <command>gdm</command> یا <command>ssh</command> فراهم می‌کند.
			</para>
			 <para>
				این برنامه‌های به صورت مستقیم این متغیرها را تولید نمی‌کنند، بلکه از طریق یک ماژول PAM (<filename>pam_env.so</filename>) اینکار صورت می‌پذیرد. PAM یا Pluggable Authentication Module کتابخانه‌ای ماژولار با تمرکز اصلی بر احراز هویت، راه‌اندازی نشست و مدیریت گذرواژه است. برای مشاهده نمونه‌ای از پیکربندی آن به قسمت <xref linkend="sect.config-pam" /> مراجعه کنید.
			</para>
			 <para>
				فایل <filename>/etc/default/locale</filename> به شیوه‌ای مشابه کار می‌کند، اما تنها شامل متغیر محلی <varname>LANG</varname> است. به لطف این جداسازی، برخی کاربران PAM می‌توانند یک محیط کامل بدون عوامل بومی‌سازی را اجرا کنند. در حقیقت، اجرای برنامه‌های سمت سرور با قابلیت بومی‌سازی خیلی متداول نیست؛ از طرف دیگر، بومی‌سازی و تنظیمات منطقه‌ای برای برنامه‌هایی که اقدام به بازکردن نشست برای کاربران می‌کنند معنا دارد.
			</para>
			 <indexterm>
				<primary>PAM</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>pam_env.so</filename></primary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.keyboard-config">
			<title>پیکربندی صفحه‌کلید</title>
			 <indexterm>
				<primary>ساختار صفحه‌کلید</primary>
			</indexterm>
			 <indexterm>
				<primary>ساختار، صفحه‌کلید</primary>
			</indexterm>
			 <para>
				حتی اگر ساختار صفحه‌کلید در حالت گرافیکی و غیرگرافیکی به صورت مختلف مدیریت شود، دبیان یک رابط پیکربندی واحد برای هر دوی آن‌ها ارائه می‌دهد: این رابط بر اساس debconf است و در بسته <emphasis role="pkg">keyboard-configuration</emphasis> پیاده‌سازی شده است. بنابراین با استفاده از دستور <command>dpkg-reconfigure keyboard-configuration</command> می‌توان در هر لحظه تنظیمات مربوط به ساختار صفحه‌کلید را تغییر داد.
			</para>
			 <indexterm>
				<primary><emphasis>console-data</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>console-tools</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>keyboard-configuration</emphasis></primary>
			</indexterm>
			 <para>
				<indexterm><primary><literal>azerty</literal></primary></indexterm>پرسش‌ها مرتبط با ساختار صفحه‌کلید فیزیکی هستند (یک صفحه‌کلید استاندارد PC در آمریکا شامل ۱۰۴ کلید عمومی است)، سپس ساختاری که باید انتخاب کرد (معمولا “US”) سپس موقعیت کلید AltGr (Alt سمت راست). در نهایت پرسش مربوط به “کلید ترکیبی” مطرح می‌شود که امکان درج کاراکترهای مخصوص به استفاده از فشردن همزمان چند دکمه را فراهم می‌آورد. برای نمونه اگر تایپ کنید <keycombo action="seq"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> یک e-acute (“é”) تولید می‌شود. تمام این ترکیبات در فایل <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> توضیح داده شده‌اند (یا فایلی دیگر، که توسط منطقه فعلی در مسیر <filename>/usr/share/X11/locale/compose.dir</filename> مشخص شده است).
			</para>
			 <indexterm>
				<primary><literal>ترکیبی</literal>, کلید</primary>
			</indexterm>
			 <indexterm>
				<primary><literal>متا</literal>, کلید</primary>
			</indexterm>
			 <indexterm>
				<primary>کلید</primary>
				<secondary><literal>متا</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary>کلید</primary>
				<secondary><literal>ترکیبی</literal></secondary>
			</indexterm>
			 <para>
				Note that the keyboard configuration for graphical mode described here only affects the default layout; the GNOME and KDE Plasma environments, among others, provide a keyboard control panel in their preferences allowing each user to have their own configuration. Some additional options regarding the behavior of some particular keys are also available in these control panels.
			</para>

		</section>
		 <section id="sect.utf8-migration">
			<title>مهاجرت به UTF-8</title>
			 <para>
				گسترش استفاده از شیوه کدگذاری UTF-8 به عنوان یک راهکار بلند مدت در حل مشکلات مربوط به تبادل حروف در زبان‌های مختلف، مرزهای موجود بین کاراکترهای داخل یک سند متنی را از بین برده است. یکی از نقطه ضعف‌های آن استفاده از شیوه به نسبت دشوار انتقال بین حروف است. از آنجا که به طور کامل نمی‌تواند شفاف عمل کند (به معنای اتفاق افتادن به صورت یکجا در هر نقطه از جهان) به دو عملیات تبدیل نیاز داریم: اولی روی محتوای فایل و دیگری رو نام فایل‌ها. خوشبختانه، قسمت عظیمی از این انتقال انجام شده است که در اینجا به عنوان مرجع از آن‌ها نام می‌بریم.
			</para>
			 <sidebar> <title><emphasis>فرهنگ</emphasis> <foreignphrase>Mojibake</foreignphrase> و خطاهای تفسیر</title>
			 <para>
				زمانی که یک متن بدون اطلاعات کدگذاری حروف ارسال یا ذخیره می‌شود، برای مخاطب یا دریافت‌کننده واضح نیست که از کدام شیوه کدگذاری برای خواندن حروف آن متن باید استفاده کرد. البته می‌توانید با بررسی شیوه توزیع مقادیر موجود در آن به نتیجه‌ای برسید، اما این روش هیچگاه پاسخ قطعی به همراه ندارد. زمانی که شیوه کذگذاری برای خواندن و نوشتن متفاوت باشد، بایت‌های موجود در فایل به صورت اشتباه تفسیر می‌شوند که در بهترین حالت آن کاراکترها نمایش داده نمی‌شوند و در بدترین حالت کل متن ناخوانا می‌گردد.
			</para>
			 <para>
				بنابراین، اگر متنی فرانسوی به جز حروف مشخصی که با کاراکترهایی نظیر “Ã©” یا “Ã§” نمایش داده می‌شوند، به صورت طبیعی بنظر می‌آید، احتمالا فایلی است که با UTF-8 کدگذاری شده ولی با ISO-8859-1 یا ISO-8859-15 تفسیر شده است. این نشانه نصب محلی سیستمی است که هنوز به UTF-8 مهاجرت نکرده است. اگر، در عوض، بجای حروف خاص علامت سوال ببینید - حتی اگر این علامت سوال‌ها بنظر جایگزین حروف مشخصی باشند - نشان‌دهنده این است که نصب محلی شما برای UTF-8 پیکربندی شده است و اینکه شما سندی را با قالب Western ISO کدگذاری کرده‌آید.
			</para>
			 <para>
				این موضوع درباره موارد “ساده” نیز اتفاق می‌افتد. این موارد اغلب در فرهنگ غربی روی می‌دهند، چرا که یونیکد (و UTF-8) برای استفاده حداکثری از نقاط مشترک با کدگذاری‌هایی مناسب زبان‌های غربی بر اساس الفبای لاتین طراحی شده‌اند که این امر به شناسایی بخشی از متن با نبود برخی کاراکترها کمک می‌کند.
			</para>
			 <para>
				در پیکربندی‌های پیچیده‌تر، برای مثال دو محیط که از دو زبان با دو الفبای متفاوت استفاده می‌کنند، معمولا نتایج غیرقابل قبولی بدست می‌آید - مجموعه‌ای از نمادهای انتزاعی که کوچکترین ارتباطی با یکدیگر ندارند. این مورد بیشتر درباره زبان‌های آسیایی که طیف گسترده‌ای از سیستم‌های نگارشی را شامل می‌شوند مرسوم است. کلمه ژاپنی <foreignphrase>mojibake</foreignphrase> برای شرح این پدیده انتخاب شده است. زمانی که مشاهده می‌شود، پیچیدگی بالاتر می‌رود و ساده‌ترین راه حل مهاجرت به UTF-8 در هر دو سمت است.
			</para>
			 </sidebar> <para>
				در مورد نامگذاری فایل‌ها، مهاجرت فرآیند ساده‌تری دارد. ابزار <command>convmv</command> (در بسته‌ای با همین نام) به طور خاص به منظور حل این مشکل بوجود آمده است؛ امکان نامگذاری یک فایل از یک شیوه کدگذاری به دیگری را فراهم می‌آورد. شیوه استفاده از آن نیز بسیار ساده است، توصیه می‌شود که طی دو گام انجام شود. مثال زیر یک محیط UTF-8 را نمایش می‌دهد که شامل دایرکتوری‌هایی با نامگذاری ISO-8859-15 است و استفاده از <command>convmv</command> برای نامگذاری مجدد آن‌ها.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Ic?nes  ?l?ments graphiques  Textes
$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>Starting a dry run without changes...
mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
No changes to your files done. Use --notest to finally rename the files.
$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
Ready!
$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput></screen>
			 <para>
				برای محتوای فایل، فرآیندهای تبدیل با توجه به قالب‌های متنوع فایل بسیار پیچیده‌تر هستند. برخی قالب‌ها شامل اطلاعات کدگذاری حروف می‌باشند تا نرم‌افزار مربوطه از آن‌ها استفاده کند؛ در این مورد ذخیره‌سازی مجدد آن‌ها با کدگذاری UTF-8 کافی بنظر می‌رسد. در سایر موارد، هنگام بازکردن فایل باید کدگذاری مبدا (ISO-8859-1 یا “Western”، ISO-8859-15 یا “Western (Euro)” بر اساس فرمول‌های موجود) را مشخص کنید.
			</para>
			 <para>
				برای فایل‌های متنی ساده، می‌توانید از <command>recode</command> (در بسته‌ای با همین نام) برای کدگذاری خودکار استفاده کنید. این ابزار شامل گزینه‌های بسیاری می‌شود که می‌توانید با آن آشنا شوید. توصیه ما استفاده از مستندات رسمی، صفحه راهنمای <citerefentry> <refentrytitle>recode</refentrytitle>
				 <manvolnum>1</manvolnum> </citerefentry> یا صفحه اطلاعات <citerefentry> <refentrytitle>recode</refentrytitle>
				 </citerefentry> است.
			</para>

		</section>

	</section>
	 <section id="sect.network-config">
		<title>پیکربندی شبکه</title>
		 <sidebar id="sidebar.networking-basics"> <title><emphasis>بازگشت به مقدمات</emphasis> مفاهیم ضروری شبکه (Ethernet, IP address, subnet, broadcast)</title>
		 <indexterm>
			<primary>Ethernet</primary>
		</indexterm>
		 <indexterm>
			<primary>10BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>100BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>1000BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>10GBASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>connector, RJ45</primary>
		</indexterm>
		 <indexterm>
			<primary>RJ45 connector</primary>
		</indexterm>
		 <para>
			اکثر شبکه‌های محلی جدید از پروتکل Ethernet استفاده می‌کنند که داده به صورت بلاک‌های کوچکی بنام frame در می‌آید و در هر لحظه یک frame از خطوط ارتباطی عبور می‌کند. سرعت تبادل داده از 10 Mb/s تا 10 Gb/s متغیر است (با متداول‌ترین نرخ که هم‌اکنون از 100 Mb/s تا 1 Gb/s تغییر می‌کند). متداول‌ترین کابل‌های مورد استفاده 10BASE-T، 100BASE-T، 1000BASE-T یا 10GBASE-T هستند با توجه به مقدار خروجی که می‌توانند فراهم کنند (حرف T مخفف “twisted pair” به معنای زوج سیم است)؛ این کابل‌های به یک کانکتور RJ45 منتهی می‌شوند. انواع دیگری از کابل برای سرعت‌های بیش از 1 Gb/s نیز وجود دارد.
		</para>
		 <indexterm>
			<primary>نشانی، نشانی IP</primary>
		</indexterm>
		 <indexterm>
			<primary>نشانی IP</primary>
		</indexterm>
		 <para>
			یک نشانی IP عددی است که رابط کارت شبکه رایانه را در شبکه محلی یا اینترنت مشخص می‌کند. در نسخه فعلی که بیشترین استفاده را دارد (IPv4) این عدد به صورت ۳۲ بیتی کدگذاری و معمولا به صورت ۴ عدد که توسط . از هم جدا شده‌اند نمایش داده می‌شود (برای نمونه، <literal>192.168.0.1</literal>) هر قسمت عددی بین ۰ تا ۲۵۵ (که نشانگر ۸ بیت از داده است) قرار دارد. نسخه بعدی این پروتکل، IPv6، فضای آدرسی‌دهی را تا ۱۲۸ بیت افزایش می‌دهد که به صورت مجموعه اعداد هگزادسیمال جدا شده با : نمایش می‌یابند (برای نمونه، 2001:0db8:13bb:0002:0000:0000:0000:0020 یا 2001:db8:13bb:2::20 به صورت خلاصه).
		</para>
		 <indexterm>
			<primary>subnet</primary>
		</indexterm>
		 <indexterm>
			<primary>mask</primary>
			<secondary>subnet mask</secondary>
		</indexterm>
		 <indexterm>
			<primary>شبکه</primary>
			<secondary>نشانی</secondary>
		</indexterm>
		 <para>
			یک subnet mask یا netmask به صورت باینری مشخص می‌کند که کدام قسمت از نشانی IP مربوط به یک شبکه و کدام قسمت مربوط به رایانه‌های آن شبکه است. مثالی که درباره پیکربندی کی نشانی IPv4 ایستا در ادامه می‌آید، <literal>255.255.255.0</literal> (۲۴ تا ۱ به همراه ۸ تا ۰ در حالت باینری) نشان می‌دهد که ۲۴ بیت ابتدایی مربوط به نشانی شبکه و ۸ بیت انتهایی مربوط به رایانه‌های آن شبکه است. در IPv6، برای خوانایی بیشتر، تنها تعداد ۱ها شمرده می‌شود؛ netmask یک شبکه IPv6 می‌تواند <literal>64</literal> باشد.
		</para>
		 <para>
			نشانی شبکه قسمتی از نشانی IP است که اعداد ۰ آن نشان‌دهنده تعداد رایانه‌های روی شبکه است. محدوده نشانی‌های IPv4 در یک شبکه کامل معمولا به صورت <emphasis>a.b.c.d/e</emphasis> نمایش داده می‌شود که در آن <emphasis>a.b.c.d</emphasis> به عنوان نشانی شبکه و <emphasis>e</emphasis> به عنوان تعداد بیت‌های موثر در قسمت شبکه نشانی IP بکار می‌رود. برای نمونه، شبکه به صورت <literal>192.168.0.0/24</literal> نمایش می‌یابد. این شیوه نگارش در مورد IPv6 نیز صادق است: <literal>2001:db8:13bb:2::/64</literal>
		</para>
		 <indexterm>
			<primary>router</primary>
		</indexterm>
		 <indexterm>
			<primary>bridge</primary>
		</indexterm>
		 <para>
			router رایانه‌ای است که چندین شبکه را به یکدیگر متصل می‌کند. تمام ترافیکی که از router می‌گذرد به شبکه درستی راهنمایی می‌شود. به این منظور، router بسته‌های دریافتی را تحلیل کرده و بر اساس نشانی IP مقصد آن‌ها را هدایت می‌کند. router همچنین با نام gateway نیز شناخته می‌شود؛ در این پیکربندی، به عنوان رایانه‌ای که ترافیک را در محدوده مرز شبکه محلی هدایت می‌کند شناخته می‌شود (در میان یک شبکه خارجی مانند اینترنت).
		</para>
		 <indexterm>
			<primary>broadcast</primary>
		</indexterm>
		 <para>
			یک نشانی broadcast بخصوص تمام رایانه‌های یک شبکه را یه یکدیگر متصل می‌کند. تقریبا هیچگاه “مسیریابی” نمی‌شود و تنها روی شبکه محلی خود فعالیت می‌کند. به این معنا که بسته داده‌ ارسال شده به نشانی broadcast هیچگاه از router عبور نمی‌کند.
		</para>
		 <para>
			تمرکز این فصل بر روی نشانی‌های IPv4 است چرا که پرکاربردترین شیوه نشانی‌دهی به شمار می‌روند. جزئیات پروتکل IPv6 در <xref linkend="sect.ipv6" /> آمده اما مفاهیم تغییری نکرده است.
		</para>
		 </sidebar> <para>
			The network is automatically configured during the initial installation. If Network Manager gets installed (which is generally the case for full desktop installations), then it might be that no configuration is actually required (for example, if you rely on DHCP on a wired connection and have no specific requirements). If a configuration is required (for example for a WiFi interface), then it will create the appropriate file in <filename>/etc/NetworkManager/system-connections/</filename>.
		</para>
		 <para>
			If Network Manager is not installed, then the installer will configure <emphasis role="pkg">ifupdown</emphasis> by creating the <filename>/etc/network/interfaces</filename> file. A line starting with <literal>auto</literal> gives a list of interfaces to be automatically configured on boot by the <literal>networking</literal> service.
		</para>
		 <para>
			In a server context, <emphasis role="pkg">ifupdown</emphasis> is thus the network configuration tool that you usually get. That is why we will cover it in the next sections.
		</para>
		 <indexterm>
			<primary>شبکه</primary>
			<secondary>پیکربندی</secondary>
		</indexterm>
		 <indexterm>
			<primary>پیکربندی</primary>
			<secondary>شبکه</secondary>
		</indexterm>
		 <indexterm>
			<primary>رابط</primary>
			<secondary>رابط شبکه</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>جایگزین</emphasis> NetworkManager</title>
		 <indexterm>
			<primary><emphasis role="pkg">network-manager</emphasis></primary>
		</indexterm>
		 <para>
			If Network Manager is particularly recommended in roaming setups (see <xref linkend="sect.roaming-network-config" />), it is also perfectly usable as the default network management tool. You can create “System connections” that are used as soon as the computer boots either manually with a <filename>.ini</filename>-like file in <filename>/etc/NetworkManager/system-connections/</filename> or through a graphical tool (<command>nm-connection-editor</command>). Just remember to deactivate all entries in <filename>/etc/network/interfaces</filename> if you want Network Manager to handle them. <ulink type="block" url="https://wiki.gnome.org/Projects/NetworkManager/SystemSettings" /> <ulink type="block" url="https://developer.gnome.org/NetworkManager/1.6/ref-settings.html" />
		</para>
		 </sidebar> <section id="sect.interface-ethernet">
			<title>رابط Ethernet</title>
			 <para>
				اگر رایانه دارای کارت شبکه Ethernet باشد، شبکه IP که با آن منطبق است طبق دو شیوه باید تنظیم گردد. شیوه آسان استفاده از پیکربندی خودکار DHCP است که نیاز به یک DHCP سرور در شبکه محلی دارد. می‌تواند دارای نام مناسبی نیز باشد، مانند تنظیمات <literal>hostname</literal> در مثال زیر. سرور DHCP آنگاه تنظیمات مربوط به کل شبکه را به رایانه‌ها ارسال می‌کند.
			</para>
			 <indexterm>
				<primary>Ethernet</primary>
			</indexterm>
			 <indexterm>
				<primary>DHCP</primary>
			</indexterm>
			 <example id="example.config-dhcp">
				<title>پیکربندی DHCP</title>
				 
<programlisting>
auto enp0s31f6
iface enp0s31f6 inet dhcp
  hostname arrakis
</programlisting>

			</example>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> Names of network interfaces</title>
			 <indexterm>
				<primary><literal>eth0</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>en*</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>wlan0</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>wl*</literal></primary>
			</indexterm>
			 <para>
				By default, the kernel attributes generic names such a <literal>eth0</literal> (for wired Ethernet) or <literal>wlan0</literal> (for WiFi) to the network interfaces. The number in those names is a simple incremental counter representing the order in which they have been detected. With modern hardware, that order might change for each reboot and thus the default names are not reliable.
			</para>
			 <para>
				Fortunately, systemd and udev are able to rename the interfaces as soon as they appear. The default name policy is defined by <filename>/lib/systemd/network/99-default.link</filename> (see <citerefentry><refentrytitle>systemd.link</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> for an explanation of the <literal>NamePolicy</literal> entry in that file). In practice, the names are often based on the device's physical location (as guessed by where they are connected) and you will see names starting with <literal>en</literal> for wired ethernet and <literal>wl</literal> for WiFi. In the example above, the rest of the name indicates, in abbreviated form, a PCI (<literal>p</literal>) bus number (<literal>0</literal>), a slot number (<literal>s31</literal>), a function number (<literal>f6</literal>).
			</para>
			 <para>
				Obviously, you are free to override this policy and/or to complement it to customize the names of some specific interfaces. You can find out the names of the network interfaces in the output of <command>ip addr</command> (or as filenames in <filename>/sys/class/net/</filename>).
			</para>
			 </sidebar> <para>
				یک پیکربندی “ایستا” باید تنظیمات شبکه را به شیوه‌ای ثابت نمایش دهد. حداقل گزینه‌های مورد نیاز نیز نشانی IP و subnet mask هستند؛ گاهی نیز نشانی‌های شبکه و broadcast فهرست می‌شوند. router که به شبکه خارجی متصل است در این پیکربندی با نام gateway شناخته می‌شود.
			</para>
			 <example id="example.static-network">
				<title>پیکربندی ایستا</title>
				 
<programlisting>
auto enp0s31f6
iface enp0s31f6 inet static
  address 192.168.0.3
  netmask 255.255.255.0
  broadcast 192.168.0.255
  network 192.168.0.0
  gateway 192.168.0.1
</programlisting>

			</example>
			 <sidebar> <title><emphasis>یادداشت</emphasis> نشانی‌های مختلف</title>
			 <para>
				نه تنها می‌توان چند رابط مختلف را به یک کارت شبکه فیزیکی نسبت داد بلکه امکان اختصاص چند نشانی IP به یک رابط واحد نیز وجود دارد. به یاد داشته باشید که یک نشانی IP از طریق DNS ممکن است به چندین نام مختلف اختصاص یابد و همچنین این نام می‌تواند در برگیرنده چندین نشانی IP باشد.
			</para>
			 <para>
				همانطور که حدس می‌زنید، پیکربندی در این حالت پیچیده است اما چنین گزینه‌هایی تنها در حالت‌های خاص استفاده می‌شوند. مثالی که در ادامه می‌آید تنها به بررسی کاربردهای عمومی آن می‌پردازد.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.interface-wireless">
			<title>Wireless Interface</title>
			 <indexterm>
				<primary>wireless</primary>
			</indexterm>
			 <para>
				Getting wireless network cards to work can be a bit more challenging. First of all, they often require the installation of proprietary firmwares which are not installed by default in Debian. Then wireless networks rely on cryptography to restrict access to authorized users only, this implies storing some secret key in the network configuration. Let's tackle those topics one by one.
			</para>
			 <section>
				<title>Installing the required firmwares</title>
				 <indexterm>
					<primary>firmware</primary>
				</indexterm>
				 <indexterm>
					<primary>isenkram</primary>
				</indexterm>
				 <para>
					First you have to enable the non-free repository in APT's sources.list file: see <xref linkend="sect.apt-sources.list" /> for details about this file. Many firmware are proprietary and are thus located in this repository. You can try to skip this step if you want, but if the next step doesn't find the required firmware, retry after having enabled the non-free section.
				</para>
				 <para>
					Then you have to install the appropriate <literal>firmware-*</literal> packages. If you don't know which package you need, you can install the <emphasis role="pkg">isenkram</emphasis> package and run its <command>isenkram-autoinstall-firmware</command> command. The packages are often named after the hardware manufacturer or the corresponding kernel module: <emphasis role="pkg">firmware-iwlwifi</emphasis> for Intel wireless cards, <emphasis role="pkg">firmware-atheros</emphasis> for Qualcomm Atheros, <emphasis role="pkg">firmware-ralink</emphasis> for Ralink, etc. A reboot is then recommended because the kernel driver usually looks for the firmware files when it is first loaded and no longer afterwards.
				</para>

			</section>
			 <section>
				<title>Wireless specific entries in <filename>/etc/network/interfaces</filename></title>
				 <indexterm>
					<primary>WPA</primary>
				</indexterm>
				 <para>
					<emphasis>ifupdown</emphasis> is able to manage wireless interfaces but it needs the help of the <emphasis role="pkg">wpasupplicant</emphasis> package which provides the required integration between <emphasis>ifupdown</emphasis> and the <command>wpa_supplicant</command> command used to configure the wireless interfaces (when using WPA/WPA2 encryption). The usual entry in <filename>/etc/network/interfaces</filename> needs to be extended with two supplementary parameters to specify the name of the wireless network (aka its SSID) and the <emphasis>Pre-Shared Key</emphasis> (PSK).
				</para>
				 <example id="example.config-wireless">
					<title>DHCP configuration for a wireless interface</title>
					 
<programlisting>
auto wlp4s0
iface wlp4s0 inet dhcp
  wpa-ssid Falcot
  wpa-psk ccb290fd4fe6b22935cbae31449e050edd02ad44627b16ce0151668f5f53c01b
</programlisting>
				</example>
				 <para>
					The <literal>wpa-psk</literal> parameter can contain either the plain text passphrase or its hashed version generated with <command>wpa_passphrase <replaceable>SSID</replaceable> <replaceable>passphrase</replaceable></command>. If you use an unencrypted wireless connection, then you should put a <literal>wpa-key-mgmt NONE</literal> and no <literal>wpa-psk</literal> entry. For more information about the possible configuration options, have a look at <filename>/usr/share/doc/wpasupplicant/README.Debian.gz</filename>.
				</para>
				 <para>
					At this point, you should consider restricting the read permissions on <filename>/etc/network/interfaces</filename> to the root user only since the file contains a private key that not all users should have access to.
				</para>
				 <sidebar> <title><emphasis>HISTORY</emphasis> WEP encryption</title>
				 <indexterm>
					<primary>WEP</primary>
				</indexterm>
				 <para>
					Usage of the deprecated WEP encryption protocol is possible with the <emphasis role="pkg">wireless-tools</emphasis> package. See <filename>/usr/share/doc/wireless-tools/README.Debian</filename> for instructions.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.ppp-rtc">
			<title>برقراری ارتباط با PPP از طریق مودم PSTN</title>
			 <indexterm>
				<primary>PPP</primary>
			</indexterm>
			 <indexterm>
				<primary>point to point</primary>
			</indexterm>
			 <indexterm>
				<primary>برقراری ارتباط</primary>
				<secondary>با استفاده از مودم PSTN</secondary>
			</indexterm>
			 <indexterm>
				<primary>modem</primary>
				<secondary>PSTN</secondary>
			</indexterm>
			 <para>
				ارتباط نقطه به نقطه (PPP) یک اتصال متناوب بوجود می‌آورد؛ این متداول‌ترین راه حل برای برقراری ارتباط از طریق مودم‌های خطوط تلفن است (“PSTN Modem”، چرا که ارتباط از طریق شبکه عمومی سووچینگ تلفن انجام می‌شود).
			</para>
			 <para>
				چنین ارتباطی مستلزم دارا بودن یک حساب کاربری با دسترسی مشخص است که شامل شماره تلفن، نام کاربری، گذرواژه و گاهی نیز شیوه احزار هویت می‌شود. این ارتباط با استفاده از ابزار <command>pppconfig</command> در بسته‌ای با همین نام پیکربندی می‌گردد. به صورت پیش‌فرض، ارتباطی با نام <literal>provider</literal> ایجاد می‌کند (مانند ارائه‌دهنده خدمات اینترنت). زمانی که درباره پروتکل احراز هویت شک دارید، <emphasis>PAP</emphasis> را انتخاب کنید: این پروتکل توسط اکثر شرکت‌های ارائه‌دهنده خدمات اینترنت پشتیبانی می‌شود.
			</para>
			 <indexterm>
				<primary><command>pppconfig</command></primary>
			</indexterm>
			 <indexterm>
				<primary>PAP</primary>
			</indexterm>
			 <para>
				پس از پیکربندی، امکان برقراری ارتباط با استفاده از دستور <command>pon</command> میسر است (با دادن نام ارتباط به عنوان پارامتر، زمانی که مقدار پیش‌فرض <literal>provider</literal> مناسب نباشد). ارتباط با استفاده از دستور <command>pon</command> قطع می‌شود. این دو دستور می‌توانند توسط کاربر root اجرا شوند یا توسط هر کاربر دیگری که در گروه <literal>dip</literal> قرار داشته باشد.
			</para>
			 <indexterm>
				<primary><command>pon</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>poff</command></primary>
			</indexterm>

		</section>
		 <section id="sect.adsl">
			<title>برقراری ارتباط از طریق مودم ADSL</title>
			 <indexterm>
				<primary>برقراری ارتباط</primary>
				<secondary>با استفاده از مودم ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>modem</primary>
				<secondary>ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>مودم ADSL</primary>
			</indexterm>
			 <para>
				عبارت متداول “مودم ADSL” طیف گسترده‌ای از دستگاه‌ها با قابلیت‌های متفاوت را شامل می‌شود. مودم‌هایی که دارای رابط شبکه Ethernet (و نه تنها رابط USB) باشند به سادگی با لینوکس سازگار هستند. این‌ها گزینه‌های محبوبی بشمار می‌روند؛ اکثر ارائه‌دهندگان خدمات اینترنت ADSL بسته‌ای را با رابط‌های شبکه Ethernet اجاره (lease) می‌دهند. با توجه به نوع مودم، پیکربندی مورد نیاز می‌تواند متفاوت باشد.
			</para>
			 <section id="sect.adsl-pppoe">
				<title>مودم‌هایی که از PPPOE پشتیبانی می‌کنند</title>
				 <indexterm>
					<primary>PPPOE</primary>
				</indexterm>
				 <indexterm>
					<primary><command>pppoeconf</command></primary>
				</indexterm>
				 <para>
					برخی مودم‌های Ethernet با پروتکل PPPOE کار می‌کنند (Point to Point Protocol over Ethernet). ابزار <command>pppoeconf</command> (از بسته‌ای با همین نام) برای پیکربندی چنین ارتباطی استفاده می‌شود. به این منظور، فایل <filename>/etc/ppp/peers/dsl-provider</filename> را تنظیمات موجود تغییر می‌دهد و اطلاعات ورود را در فایل‌های <filename>/etc/ppp/pap-secrets</filename> و <filename>/etc/ppp/chap-secrets</filename> ذخیره می‌کند. توصیه می‌شود که تغییرات پیشنهادی آن را بپذیرید.
				</para>
				 <para>
					زمانی که این پیکربندی به پایان برسد، می‌توانید از دستورهای <command>pon dsl-provider</command> و <command>poff dsl-provider</command> برای برقراری و قطع ارتباط استفاده کنید.
				</para>
				 <indexterm>
					<primary><literal>dsl-provider</literal></primary>
				</indexterm>
				 <sidebar> <title><emphasis>نکته</emphasis> اجرای <command>ppp</command> در زمان راه‌اندازی سیستم</title>
				 <indexterm>
					<primary><command>systemd</command></primary>
				</indexterm>
				 <indexterm>
					<primary><command>init</command></primary>
				</indexterm>
				 <para>
					برقراری ارتباط PPP از طریق ADSL به صورت متناوب صورت می‌گیرد. از آنجا که قیمت آن‌ها بر اساس زمان محاسبه نمی‌شود، باز نگاه داشتن چنین ارتباطی عواقب چندانی ندارد. شیوه استاندارد این کار استفاده از سیستم init است.
				</para>
				 <para>
					With systemd, adding an automatically restarting task for the ADSL connection is a simple matter of creating a “unit file” such as <filename>/etc/systemd/system/adsl-connection.service</filename>, with contents such as the following:
				</para>
				 
<programlisting>[Unit]
Description=ADSL connection

[Service]
Type=forking
ExecStart=/usr/sbin/pppd call dsl-provider
Restart=always

[Install]
WantedBy=multi-user.target</programlisting>
				 <para>
					زمانی که این فایل واحد تعریف شود، باید با استفاده از <command>systemctl enable adsl-connection</command> فعال گردد. آنگاه اولین اجرای آن می‌تواند با <command>systemctl start adsl-connection</command> صورت گیرد؛ از این به بعد، در هر راه‌اندازی سیستم اجرا می‌گردد.
				</para>
				 <para>
					در سیستم‌هایی که از <command>systemd</command> استفاده نمی‌کنند (از جمله <emphasis role="distribution">Wheezy</emphasis> و نسخه‌های پیشین دبیان)، شیوه سنتی SystemV init به گونه‌ای متفاوت عمل می‌کند. در چنین سیستم‌هایی، تمام آنچه مورد نیاز است افزودن خطی به انتهای فایل <filename>/etc/inittab</filename> است، هر زمان ارتباط قطع گردد، <command>init</command> آن را متصل می‌کند.
				</para>
				 
<programlisting>
adsl:2345:respawn:/usr/sbin/pppd call dsl-provider</programlisting>
				 <para>
					برای ارتباطات ADSL که به صورت روزانه قطع می‌گردند، این شیوه وقفه‌های موجود را کاهش می‌دهد.
				</para>
				 </sidebar>
			</section>
			 <section id="sect.adsl-pptp">
				<title>مودم‌هایی که از PPTP پشتیبانی می‌کنند</title>
				 <indexterm>
					<primary>PPTP</primary>
				</indexterm>
				 <para>
					پروتکل PPTP (Point-to-Point Tunneling Protocol) توسط مایکروسافت بوجود آمده است. در زمان رشد فناوری ADSL، به سرعت با PPPOE جایگزین شد. اگر استفاده از این پروتکل برای شما اجباری است، <xref linkend="sect.pptp" /> را مشاهده کنید.
				</para>

			</section>
			 <section id="sect.adsl-dhcp">
				<title>مودم‌هایی که از DHCP پشتیبانی می‌کنند</title>
				 <para>
					زمانی که مودم با استفاده از کابل شبکه (crossover) به رایانه متصل می‌شود معمولا با استفاده از DHCP تنظیمات مربوط به شبکه صورت می‌گیرد؛ مودم به صورت خودکار مانند یک gateway عمل کرده و عملیات مسیریابی بسته‌ها را به عهده می‌گیرد (به این معنا که ترافیک بین رایانه و شبکه اینترنت را مدیریت می‌کند).
				</para>
				 <sidebar> <title><emphasis>بازگشت به مقدمات</emphasis> استفاده از کابل Crossover برای یک ارتباط مستقیم</title>
				 <indexterm>
					<primary>کابل crossover</primary>
				</indexterm>
				 <para>
					کارت‌های شبکه در هر رایانه انتظار ارسال و دریافت اطلاعات روی سیم‌های مختلفی از کابل شبکه را دارند. زمانی که یک رایانه را به شبکه محلی متصل می‌کنید، معمولا از یک کابل straght یا crossover بین کارت شبکه و repeter یا switch استفاده می‌شود. اگر بخواهید دو رایانه را به صورت مستقیم به یکدیگر متصل کنید (بدون هیچ دستگاه واسطه‌ای) باید سیگنال ارسالی از کارب شبکه یکی را به سیگنال دریافتی از کارت شبکه دیگری هدایت کنید و برعکس. این هدف استفاده از کابل crossover است.
				</para>
				 <para>
					نکته اینکه این شیوه به مروز زمان و با پیشرفته‌ترشدن کارت‌های شبکه و قابلیت تشخیص آن‌ها بین طیف گسترده‌ای از کابل‌های شبکه، اهمیت اولیه خود را از دست داده است، پس اگر مشاهده کردید هر دو کابل در یک محیط کار می‌کنند، زیاد تعجب نکنید.
				</para>
				 </sidebar> <para>
					اکثر “مسیریاب‌های ADSL” موجود در بازار به این شیوه می‌توانند استفاده شوند دست مانند اکثر مودم‌های ADSL که توسط ارائه‌دهندگان خدمات اینترنت عرضه می‌شوند.
				</para>

			</section>

		</section>
		 <section id="sect.roaming-network-config">
			<title>پیکربندی خودکار شبکه برای کاربران</title>
			 <indexterm>
				<primary><emphasis role="pkg">network-manager</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>شبکه</primary>
				<secondary>پیکربندی محلی</secondary>
			</indexterm>
			 <para>
				بسیاری از مهندسان فالکوت دارای لپ‌تاپی هستند که به دلایل کاری در خانه نیز از آن استفاده می‌کنند. پیکربندی شبکه مورد استفاده بسته به محل استفاده متفاوت است. در خانه، ممکن است یک شبکه وای‌فای (به همراه گذرواژه WPA) باشد در حالی که در محل کار از یک شبکه کابلی با امنیت و پهنای باند بیشتر استفاده می‌شود.
			</para>
			 <para>
				برای جلوگیری از اتصال و قطع دستی هر یک از رابط‌های شبکه، مدیرسیستم‌ها اقدام به نصب بسته <emphasis role="pkg">network-manager</emphasis> روی این لپ‌تاپ‌ها کرده‌اند. این نرم‌افزار به کاربران امکان می‌دهد با استفاده از یک نماد کوچک در نوار بالایی صفحه بین رابط‌های مختلف شبکه سوئیچ کنند. کلیک روی این نماد منجر به نمایش فهرستی از شبکه‌های موجود (کابلی و بیسیم) می‌شود، تا به راحتی بتوانند به آن‌ها متصل شوند. برنامه پیکربندی مربوط به هر رابط شبکه را ذخیره می‌کند تا در صورت بروز مشکل در هر یک، از بهترین شبکه موجود به صورت جایگزین استفاده شود.
			</para>
			 <para>
				برای این منظور، برنامه به دو قسمت تقسیم شده است: یک فرآیند پس‌زمینه که توسط root فعال‌سای و پیکربندی رابط‌های شبکه را مدیریت و یک رابط کاربری که این فرآیند پس‌زمینه را کنترل می‌کند. PolicyKit احراز هویت مورد نیاز برای کنترل این برنامه را مدیریت کرده و دبیان به صورتی PolicyKit را پیکربندی نموده که اعضای گروه netdev بتوانند اتصالات مربوط به Network Manager را اضافه کنند یا تغییر دهند.
			</para>
			 <para>
				Network Manager می‌داند که چگونه انواع مختلفی از اتصالات را مدیریت کند (DHCP، پیکربندی دستی، شبکه محلی)، اما تنها در صورتی که این پیکربندی‌ها با برنامه همراه باشند. به همین دلیل است که به صورت پیش‌فرض تمام رابط‌های شبکه موجود در فایل <filename>/etc/network/interfaces</filename> را نادیده گرفته که برای آن‌ها راهکاری ندارد. از آنجا که Network Manager جزئیاتی درباره عدم وجود اتصالات شبکه نمی‌دهد، راه ساده حذف خطوطی از فایل <filename>/etc/network/interfaces</filename> است برای تمام رابط‌هایی که باید توسط Network Manager مدیریت شوند.
			</para>
			 <para>
				نکته اینکه این برنامه به صورت پیش‌فرض نصب می‌شود زمانی که گزینه “Desktop Environment” هنگام نصب اولیه انتخاب شده باشد.
			</para>

		</section>

	</section>
	 <section id="sect.hostname-name-service">
		<title>تنظیم Hostname و پیکربندی Name Service</title>
		 <indexterm>
			<primary>نام</primary>
			<secondary>صفت و تخصیص</secondary>
		</indexterm>
		 <indexterm>
			<primary>انتصاب نام‌ها</primary>
		</indexterm>
		 <para>
			هدف از انتصاب نام به نشانی IP آسان کردن یادگیری توسط انسان است. در واقعیت، یک نشانی IP رابط شبکه‌ای را تشخیص می‌دهد که به یک کارت شبکه متصل باشد. از آنجا که هر رایانه می‌تواند چند کارت شبکه داشته باشد، و چند رابط شبکه روی هر کدام، هر رایانه به صورت جداگانه قادر به داشتن چند نام مختلف در سیستم نام دامنه می‌باشد.
		</para>
		 <para>
			هر رایانه، اگرچه، با یک نام اصلی (یا “canonical”) شناخته می‌شود که در فایل <filename>/etc/hostname</filename> ذخیره شده و توسط اسکریپت‌های راه‌اندازی توسط دستور <command>hostname</command> به کرنل لینوکس منتقل می‌شود. مقدار فعلی در فایل‌سیستم مجازی موجود است و می‌توانید با استفاده از دستور <command>cat /proc/sys/kernel/hostname</command> آن را ببینید.
		</para>
		 <indexterm>
			<primary><command>hostname</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>بازگشت به مقدمات</emphasis> فایل‌سیستم‌های مجازی <filename>/proc/</filename> و <filename>/sys/</filename></title>
		 <indexterm>
			<primary><filename>/proc/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>proc</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/sys/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>sys</filename></primary>
		</indexterm>
		 <para>
			ساختار درختی فایل‌های <filename>/proc/</filename> و <filename>/sys/</filename> توسط فایل‌سیستم‌های “مجازی” تولید می‌شود. این یک شیوه عملی برای بازیابی اطلاعات از کرنل (با فهرست‌گیری از فایل‌های مجازی) و ارسال اطلاعات به کرنل (با نوشتن روی فایل‌های مجازی) است.
		</para>
		 <para>
			<filename>/sys/</filename> به طور مشخص برای دسترسی به اجزای درونی کرنل طراحی شده، به خصوص آن‌هایی که دربرگیرنده دستگاه‌های مختلف روی سیستم هستند. بنابراین، کرنل می‌تواند اطلاعات مختلفی را به نمایش بگذارد؛ وضعیت هر دستگاه (برای نمونه، اگر در حالت صرفه‌جویی انرژی به سر می‌برد)، اینکه یک دستگاه قابل حذف سریع باشد یا خیر و از این قبیل. نکته اینکه <filename>/sys/</filename> از کرنل ۲.۶ به بعد وجود دارد.
		</para>
		 </sidebar> <para>
			عجیب اینکه، نام دامنه به شیوه مشابه بالا مدیریت نمی‌شود، بلکه از نام کامل ماشین نشات گرفته که در حین فرآیند تخصیص نام کسب شده است. می‌توانید آن را در فایل <filename>/etc/hosts</filename> تغییر دهید؛ تنها کافی است نشانی و نام مورد نظر خود را مشابه نمونه زیر وارد کنید:
		</para>
		 <informalexample> 
<programlisting>
127.0.0.1     localhost
192.168.0.1   arrakis.falcot.com arrakis</programlisting>
		 </informalexample> <indexterm>
			<primary><filename>hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/etc/hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary>دامنه</primary>
			<secondary>نام</secondary>
		</indexterm>
		 <indexterm>
			<primary>نام</primary>
			<secondary>دامنه</secondary>
		</indexterm>
		 <indexterm>
			<primary>NSS</primary>
		</indexterm>
		 <section id="sect.name-resolution">
			<title>تخصیص نام</title>
			 <indexterm>
				<primary>تخصیص</primary>
				<secondary>نام</secondary>
			</indexterm>
			 <indexterm>
				<primary>نام</primary>
				<secondary>تخصیص</secondary>
			</indexterm>
			 <para>
				مکانیزم تخصیص نام در لینوکس بسیار انعطاف‌پذیر است و می‌تواند از منابع گوناگونی مانند فایل <filename>/etc/nsswitch.conf</filename> بدست آید. خطی که دربردانده تخصیص نام است <literal>hosts</literal> می‌باشد. به صورت پیش‌فرض، شامل <literal>file dns</literal> است، که به معنی دسترسی اولیه سیستم به فایل <filename>/etc/hosts</filename> سپس سرور نام دامنه است. NIS/NIS+ یا سرور LDAP منابع دیگر تخصیص نام هستند.
			</para>
			 <sidebar> <title><emphasis>یادداشت</emphasis> NSS و DNS</title>
			 <para>
				آگاه باشید دستوراتی که به صورت خاص از DNS پرس‌وجو می‌کنند (به خصوص <command>host</command>) از مکانیزم استاندارد تخصیص نام (NSS) استفاده نمی‌کنند. به همین دلیل، محتویات فایل‌های <filename>/etc/nsswitch.conf</filename> و <filename>/etc/hosts</filename> را به حساب نمی‌آورند.
			</para>
			 </sidebar> <section id="sect.dns-server-configuration">
				<title>پیکربندی سرورهای DNS</title>
				 <indexterm>
					<primary>DNS</primary>
				</indexterm>
				 <indexterm>
					<primary>Domain Name Service</primary>
				</indexterm>
				 <para>
					سرویس نام دامنه (Domain Name Server) یک سرویس توزیع‌شده و سلسله‌مراتبی است که نام‌ها را به نشانی‌های IP و برعکس اختصاص می‌دهد. به طور خاص، می‌تواند یک نام مانند <literal>www.eyrolles.com</literal> را به نشانی IP <literal>213.244.11.247</literal> تبدیل کند.
				</para>
				 <para>
					برای دسترسی به اطلاعات DNS، یک سرور به خصوص باید وجود داشته باشد. شرکت فالکات سرور مخصوص به خود را دارد، اما یک شخص به احتمال زیاد از سرورهای ارائه شده توسط ISP خود استفاده می‌کند.
				</para>
				 <indexterm>
					<primary><filename>resolv.conf</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><literal>nameserver</literal></primary>
				</indexterm>
				 <para>
					DNS سرورهای مورد استفاده در فایل <filename>/etc/resolv.conf</filename> تعریف شده‌اند که هر یک در خط جداگانه‌ای به همراه <literal>nameserver</literal> در ابتدا سپس نشانی IP قرار دارند، مانند نمونه زیر:
				</para>
				 
<programlisting>
nameserver 212.27.32.176
nameserver 212.27.32.177
nameserver 8.8.8.8</programlisting>
				 <para>
					نکته اینکه فایل <filename>/etc/resolv.conf</filename> در صورت استفاده از NetworkManager یا پیکربندی DHCP به صورت خودکار بروزرسانی شده و تغییر می‌کند.
				</para>

			</section>
			 <section id="sect.etc-hosts">
				<title>فایل <filename>/etc/hosts</filename></title>
				 <indexterm>
					<primary><filename>hosts</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/hosts</filename></primary>
				</indexterm>
				 <para>
					اگر در شبکه محلی هم nameserver وجود نداشته باشد کماکان این امکان وجود دارد که یک جدول کوچک از نشانی‌های IP به همراه نام ماشین‌ها در فایل <filename>/etc/hosts</filename> ایجاد کرد، که معمولا برای ایستگاه‌های شبکه محلی در نظر گرفته شده است. شیوه دستوری این فایل بسیار ساده است: هر خط شامل یک نشانی IP مخصوص به خود به همراه فهرستی از نام‌های تخصیصی به آن است (که اولین آن‌ها مورد تایید قرار می‌گیرد به این معنی که به عنوان نام دامنه ذکر می‌شود).
				</para>
				 <para>
					این فایل در هنگام قطع ارتباط شبکه یا زمانی که سروهای DNS غیرقابل دسترس باشند نیز موجود است، اما تنها زمانی مفید خواهد بود که روی تمام رایانه‌های شبکه موجود باشد. کوچک‌ترین تغییر در آن نیز باید در تمام رایانه‌ها اعمال گردد. به همین دلیل است که <filename>/etc/hosts</filename> معمولا شامل مهمترین گزینه‌های موجود است.
				</para>
				 <para>
					این فایل برای شبکه‌های کوچکی که به اینترنت متصل نیستند مفید است، اما با افزایش تعداد دستگاه‌ها از ۵ به بالا، توصیه می‌شود که از یک سرور DNS مناسب استفاده گردد.
				</para>
				 <sidebar> <title><emphasis>نکته</emphasis> دورزدن DNS</title>
				 <para>
					از آنجا که برنامه‌ها قبل از پرس و جو DNS ابتدا فایل <filename>/etc/hosts</filename> را بررسی می‌کنند، امکان درج اطلاعات مربوط به برنامه قبل از اینکه از DNS پرس و جو کند وجود دارد، که با این روش می‌توان شیوه متداول استفاده از DNS را دور زد.
				</para>
				 <para>
					زمانی که تغییرات مربوط به DNS اعمال نمی‌شوند، برای بررسی اتصال به یک وبسایت با نام مشخص، می‌توان از این روش استفاده کرد.
				</para>
				 <para>
					یک امکان استفاده دیگر هدایت ترافیک مورد نظر یک دستگاه به سیستم خود است. برای نمونه، نام سرورهایی که دارای خدمات تبلیغاتی هستند به نوعی می‌تواند تغییر کند که این تبلیغات آزاردهنده دیگر به دستگاه کاربر هدایت نشوند.
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.user-group-databases">
		<title>پایگاه‌داده‌های کاربران و گروه‌ها</title>
		 <indexterm>
			<primary>کاربر</primary>
			<secondary>پایگاه‌داده</secondary>
		</indexterm>
		 <indexterm>
			<primary>گروه</primary>
			<secondary>پایگاه‌داده</secondary>
		</indexterm>
		 <indexterm>
			<primary>پایگاه‌داده</primary>
			<secondary>کاربران</secondary>
		</indexterm>
		 <indexterm>
			<primary>پایگاه‌داده</primary>
			<secondary>گروه‌ها</secondary>
		</indexterm>
		 <para>
			فهرست کاربران معمولا در فایل <filename>/etc/passwd</filename> ذخیره می‌شود، در صورتی که فایل <filename>/etc/shadow</filename> گذرواژه‌های رمزگذاری‌شده را ذخیره می‌کند. هر دو فایل، از نوع متنی هستند که به سادگی با استفاده از یک ویرایشگر متن قابل خواندن و تغییر هستند. هر کاربر در خط جداگانه‌ای به همراه فیلد‌هایی که با <literal>:</literal> از یکدیگر جدا شده‌اند، قرار دارد.
		</para>
		 <sidebar> <title><emphasis>یادداشت</emphasis> ویرایش فایل‌های سیستمی</title>
		 <para>
			فایل‌های سیستمی که در این فصل به آن‌ها اشاره شده همگی از نوع متنی بوده که می‌توانند با استفاده از یک ویرایشگر متن تغییر یابند. با در نظر گرفتن اهمیت آن‌ها برای عملکرد صحیح سیستم، ایده خوبی است که هنگام ویرایش آن‌ها برخی نکات را مد نظر قرار دهیم. ابتدا، قبل از ویرایش یک فایل سیستمی، حتما یک رونوشت از آن تهیه کنید. سپس در سرورهایی که بیش از یک کاربر ممکن است در هر لحظه این فایل‌ها را مشاهده یا ویرایش کند، گام‌های دیگری برای جلوگیری از خراب شدن این فایل‌ها باید برداشته شوند.
		</para>
		 <para>
			به این منظور، تنها کافی است از دستور <command>vipw</command> برای ویرایش فایل <filename>/etc/passwd</filename> و از دستور <command>vigr</command> برای ویرایش فایل <filename>/etc/group</filename> استفاده کرد. این دستورات قبل از بازکردن ویرایشگر، فایل را قفل می‌کنند (ویرایشگر متن پیش‌فرض <command>vi</command> است، مگر توسط متغیر محلی <varname>EDITOR</varname> تغییر کرده باشد). گزینه <literal>-s</literal> در این دستورات امکان ویرایش فایل <foreignphrase>shadow</foreignphrase> مربوطه را می‌دهد.
		</para>
		 </sidebar> <sidebar> <title><emphasis>بازگشت به مقدمات</emphasis> Crypt، تابعی یک-طرفه</title>
		 <indexterm>
			<primary>crypt</primary>
		</indexterm>
		 <para>
			<command>crypt</command> یک تابع یک-طرفه است که رشته‌ای مانند <varname>A</varname> را به رشته <varname>B</varname> تبدیل می‌کند به صورتی که رشته <varname>A</varname> از <varname>B</varname> نتواند به دست آید. تنها راه شناسایی <varname>A</varname> بررسی تمام گزینه‌های موجود است تا بتوان تشخیص داد آیا تبدیل انجام شده توسط تابع منجر به تولید <varname>B</varname> می‌شود یا خیر. تا ۸ کاراکتر را در ورودی استفاده کرده (رشته <varname>A</varname> و رشته‌ای شامل ۱۳ کاراکتر قابل چاپ با کد اسکی را تولید می‌کند (رشته <varname>B</varname>).
		</para>
		 </sidebar> <section id="sect.etc-passwd">
			<title>فهرست کاربران: <filename>/etc/passwd</filename></title>
			 <para>
				فیلدهای مورد استفاده در فایل <filename>/etc/passwd</filename> عبارتند از:
			</para>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/passwd</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>uid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>gid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>GECOS</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>login</literal></primary>
			</indexterm>
			 <itemizedlist>
				<listitem>
					<para>
						نام کاربری، برای نمونه <literal>rhertzog</literal>؛
					</para>

				</listitem>
				 <listitem>
					<para>
						گذرواژه: این گذرواژه‌ای است که توسط تابع <command>crypt</command> و مبتنی بر استانداردهای <literal>DES</literal>، <literal>MD5</literal>، <literal>SHA-256</literal> یا <literal>SHA-512</literal> تولید شده است. مقدار ویژه “<literal>x</literal>” به این معنا است که گذرواژه رمزگذاری شده در فایل <filename>/etc/shadow</filename> قرار دارد؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uid</literal>: شناسه منحصربفرد هر کاربر؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: شناسه منحصربفرد گروه هر کاربر (دبیان به صورت پیش‌فرض برای هر کاربر یک گروه خاص قرار می‌دهد)؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>GECOS</literal>: فید داده‌ای که معمولا نام کامل کاربر را شامل می‌شود؛
					</para>

				</listitem>
				 <listitem>
					<para>
						دایرکتروی حساب کاربری، که برای ذخیره‌سازی فایل‌های شخصی هر کاربر اختصاص می‌یابد (متغیر محلی <varname>$HOME</varname> معمولا به اینجا اشاره می‌کند)؛
					</para>

				</listitem>
				 <listitem>
					<para>
						برنامه‌ای که هنگام ورود کاربر اجرا می‌شود. این معمولا یک مفسر خط‌فرمان (پوسته) است که کنترل آزاد را در اختیار کاربر می‌گذارد. اگر گزینه <command>/bin/false</command> را استفاده کنید به این معنا است که کاربر نمی‌تواند لاگین کند.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>بازگشت به مقدمات</emphasis> گروه در یونیکس</title>
			 <indexterm>
				<primary>گروه</primary>
			</indexterm>
			 <para>
				یک گروه یونیکس شامل موجودیتی مستقل از مجموعه کاربرانی است که می‌توانند طبق یک سری مجوزهای خاص عملیات یکسانی را روی سیستم انجام دهند. همچنین می‌توانید استفاده از یک سری برنامه‌ها را برای یک گروه خاص منع کنید.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-shadow">
			<title>فایل رمزگذاری‌شده و مخفی گذرواژه‌ها: <filename>/etc/shadow</filename></title>
			 <indexterm>
				<primary><filename>shadow</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/shadow</filename></primary>
			</indexterm>
			 <para>
				فایل <filename>/etc/shadow</filename> شامل فیلدهای زیر است:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						نام کاربری؛
					</para>

				</listitem>
				 <listitem>
					<para>
						گذرواژه رمزگذاری‌شده؛
					</para>

				</listitem>
				 <listitem>
					<para>
						تعدادی فیلد که مدت زمان اعتبار گذرواژه را تعیین می‌کنند.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>مستندات</emphasis> قالب فایل‌های <filename>/etc/passwd</filename>، <filename>/etc/shadow</filename> و <filename>/etc/group</filename></title>
			 <para>
				این قالب‌ها در صفحات راهنمای مربوط به خود مستندسازی شده‌اند: <citerefentry><refentrytitle>passwd</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> <citerefentry><refentrytitle>shadow</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> و <citerefentry><refentrytitle>group</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>
			</para>
			 </sidebar> <sidebar> <title><emphasis>امنیت</emphasis> امنیت فایل <filename>/etc/shadow</filename></title>
			 <para>
				<filename>/etc/shadow</filename> بر خلاف فایل <filename>/etc/passwd</filename> نمی‌تواند توسط کاربران عادی خوانده شود. هر گذرواژه رمزگذاری شده‌ای در فایل <filename>/etc/passwd</filename> توسط همگان قابل خواندن است؛ یک cracker می‌تواند با استفاده از مجموعه رشته‌های قابل حدس اقدام به “شکستن” (یا نمایان‌کردن) یک گذرواژه با استفاده از روش‌های “brute force” اقدام کند. این نوع حمله - که با نام "dictionary attack" شناخته می‌شود - در سیستم‌هایی که از فایل <filename>/etc/shadow</filename> استفاده می‌کنند غیرقابل استفاده است.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.account-modification">
			<title>تغییر یک حساب کاربری موجود یا گذرواژه آن</title>
			 <indexterm>
				<primary><command>chsh</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chfn</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chage</command></primary>
			</indexterm>
			 <indexterm>
				<primary>گذرواژه</primary>
			</indexterm>
			 <para>
				دستورات زیر امکان تغییر اطلاعات موجود در پایگاه‌داده کاربران و فیلدهای مرتبط با آن را می‌دهند: <command>passwd</command> به یک کاربر عادی اجازه تغییر گذرواژه خود را می‌دهد که این عملیات منجر به بروزرسانی فایل <filename>/etc/shadow</filename> می‌گردد؛ <command>chfn</command> یا CHange Full Name، که مختص به کاربر root است، فیلد <literal>GECOS</literal> را تغییر می‌دهد. <command>chsh</command> یا CHange SHell به کاربران امکان تغییر پوسته یا مفسر خط‌فرمان را می‌دهد، اگرچه گزینه‌های ممکن در فایل <filename>/etc/shells</filename> موجود هستند؛ مدیرسیستم، از طرف دیگر، شامل این محدودیت نمی‌شود و می‌تواند پوسته را به هر برنامه دیگری تغییر دهد.
			</para>
			 <para>
				در نهایت، دستور <command>chage</command> یا CHange AGE به مدیرسیستم امکان تغییر زمان اعتبار گذرواژه را می‌دهد (گزینه <literal>-l <replaceable>user</replaceable></literal> تنظیمات فعلی را نمایش می‌دهد). می‌توانید برای مجبور کردن کاربر به تغییر گذرواژه خود از دستور <command>passwd -e <replaceable>user</replaceable></command> استفاده کنید تا در هنگام ورود بعدی به سیستم، گذرواژه جدید را وارد کند.
			</para>

		</section>
		 <section id="sect.disabling-account">
			<title>غیرفعال‌سازی یک حساب‌کاربری</title>
			 <indexterm>
				<primary>غیرفعال‌سازی یک حساب‌کاربری</primary>
			</indexterm>
			 <indexterm>
				<primary>حساب‌کاربری</primary>
				<secondary>غیرفعال‌سازی</secondary>
			</indexterm>
			 <para>
				ممکن است بخواهید “یک حساب‌کاربری را غیرفعال کنید” (قفل‌کردن یک کاربر)، به عنوان یک عمل انضباطی، به منظور تحقیقات بیشتر روی یک موضوع یا در صورتی که کاربر مدت زمان طولانی حضور نداشته باشد. یک حساب‌کاربری غیرفعال‌شده به این معنی است که وی نمی‌تواند وارد سیستم شود و به آن دسترسی داشته باشد. محتویات این حساب‌کاربری بدون کوچکترین تغییری روی سیستم باقی می‌مانند؛ تنها به سادگی دسترسی به آن وجود ندارد. این کار با استفاده از دستور <command>passwd -l <replaceable>user</replaceable></command> انجام می‌شود (lock). فعال‌سازی مجدد آن نیز با استفاده از گزینه <literal>-u</literal> در همان دستور صورت می‌گیرد (unlock).
			</para>
			 <sidebar id="sidebar.intro-nss"> <title><emphasis>مطالعه بیشتر</emphasis> NSS و پایگاه‌داده‌های سیستم</title>
			 <indexterm>
				<primary>NSS</primary>
			</indexterm>
			 <indexterm>
				<primary>Name Service Switch</primary>
			</indexterm>
			 <para>
				بجای استفاده از فایل‌های معمولی برای ذخیره‌سازی فهرستی از کاربران و گروه‌ها، می‌توانید از سایر پایگاه‌داده‌ها برای اینکار استفاده کنید مانند LDAP یا <command>db</command> با استفاده از یک ماژول NSS مناسب. ماژول‌های مورد استفاده در فایل <filename>/etc/nsswitch.conf</filename> فهرست می‌شوند، درست زیر مدخل‌های <literal>passwd</literal>، <literal>shadow</literal> و <literal>group</literal>. برای یک نمونه مشخص از کاربرد ماژول NSS توسط LDAP قسمت <xref linkend="sect.config-nss" /> را مشاهده کنید.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-group">
			<title>فهرست گروه: <filename>/etc/group</filename></title>
			 <para>
				گروه‌ها در فایل <filename>/etc/group</filename> فهرست می‌شوند، یک پایگاه‌داده ساده متنی درست مانند <filename>/etc/passwd</filename> که شامل فیلدهای زیر است:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						نام گروه؛
					</para>

				</listitem>
				 <listitem>
					<para>
						گذرواژه (اختیاری): این فیلد برای الحاق یک گروه استفاده می‌شود که یک عضو معمولی به حساب نمی‌آید (با دستورات <command>newgrp</command> یا <command>sg</command>، قسمت <xref linkend="sidebar.working-with-several-groups" /> را مشاهده کنید)؛
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: شناسه منحصربفرد هر گروه؛
					</para>

				</listitem>
				 <listitem>
					<para>
						فهرست اعضا: فهرستی از نام کاربرانی که عضو این گروه هستند، که با کاما جدا شده‌اند.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
			</para>
			 <sidebar id="sidebar.working-with-several-groups"> <title><emphasis>بازگشت به مقدمات</emphasis> کار با چندین گروه</title>
			 <indexterm>
				<primary><command>newgrp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sg</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>id</command></primary>
			</indexterm>
			 <indexterm>
				<primary>گروه</primary>
				<secondary>تغییر</secondary>
			</indexterm>
			 <para>
				هر کاربر می‌تواند عضو چندین گروه باشد؛ یکی از آن‌ها “گروه اصلی” است. گروه اصلی هر کاربر، به صورت پیش‌فرض، هنگام پیکربندی اولیه حساب‌کاربری بوجود آمده است. به صورت پیش‌فرض، هر فایلی که کاربر ایجاد می‌کند به وی و گروهش اختصاص دارد. این عمل همیشه مطلوب نیست؛ برای نمونه، زمانی که کاربر باید در دایرکتروی کار کند که شامل گروه دیگری باشد. در این مورد، کاربر باید گروه اصلی‌اش را با استفاده از دستورات <command>newgrp</command>، که یک پوسته جدید را اَغاز می‌کند یا <command>sg</command> یک دستور را با توجه به گروه جایگزین وارد شده اجرا می‌کند. این دستورات یه کاربر امکان می‌دهند که به گروه جدید دیگری اضافه شوند. اگر گروه با استفاده از گذرواژه محافظت شود، باید قبل از اینکه دستور اجرا شود آن را وارد کنند.
			</para>
			 <para>
				به علاوه، کاربر می‌تواند بیت <literal>setgid</literal> را روی دایرکتوری تنظیم کند، که منجر می‌شود فایل‌های ایجاد شده روی آن دایرکتوری به صورت خودکار به گروه درستی اختصاص یابند. برای جزئیات بیشتر، قسمت <xref linkend="sidebar.setgid-dir" /> را مشاهده کنید.
			</para>
			 <para>
				دستور <command>id</command> وضعیت فعلی یک کاربر را نمایش می‌دهد، به همراه شناسه منحربفرد وی (متغیر <varname>uid</varname>)، گروه اصلی فعلی (متغیر <varname>gid</varname>) و فهرستی از گروه‌ها که کاربر به متعلق به آن‌هاست (متغیر <varname>groups</varname>).
			</para>
			 </sidebar> <indexterm>
				<primary><filename>group</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/group</filename></primary>
			</indexterm>
			 <para>
				The <command>addgroup</command> and <command>delgroup</command> commands add or delete a group, respectively. The <command>groupmod</command> command modifies a group's information (its <literal>gid</literal> or identifier). The command <command>gpasswd <replaceable>group</replaceable></command> changes the password for the group, while the <command>gpasswd -r <replaceable>group</replaceable></command> command deletes it.
			</para>
			 <indexterm>
				<primary><command>addgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>delgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>groupmod</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>gpasswd</command></primary>
			</indexterm>
			 <indexterm>
				<primary>گروه</primary>
				<secondary>ایجاد</secondary>
			</indexterm>
			 <indexterm>
				<primary>ایجاد</primary>
				<secondary>گروه‌ها</secondary>
			</indexterm>
			 <indexterm>
				<primary>گروه</primary>
				<secondary>حذف</secondary>
			</indexterm>
			 <indexterm>
				<primary>حذف یک گروه</primary>
			</indexterm>
			 <sidebar> <title><emphasis>نکته</emphasis> <command>getent</command></title>
			 <indexterm>
				<primary><command>getent</command></primary>
			</indexterm>
			 <para>
				دستور <command>getent</command> یا get entries به شیوه‌ای استاندارد به بررسی پایگاه‌داده‌های سیستم می‌پردازد، با استفاده از توابع کتابخانه‌ای مناسب، که در بازگشت با استفاده از فراخوانی ماژول‌های NSS موجود در فایل <filename>/etc/nsswitch.conf</filename> اطلاعات را باز می‌گرداند. دستور یک یا دو پارامتر می‌گیرد: نام پایگاه‌داده‌ای که قصد بررسی دارد و یک کلیدواژه احتمالی برای جستجو. بنابراین، دستور <command>getent passwd rhertzog</command> اطلاعات پایگاه‌داده کاربری را برای کاربر <literal>rhertzog</literal> بدست می‌آورد.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.creating-accounts">
		<title>ایجاد حساب‌های کاربری</title>
		 <indexterm>
			<primary>حساب‌کاربری</primary>
			<secondary>ایجاد</secondary>
		</indexterm>
		 <indexterm>
			<primary>ایجاد</primary>
			<secondary>حساب‌های کاربری</secondary>
		</indexterm>
		 <para>
			یکی از اولین اقدامات مدیرسیستم هنگام برپایی یک سیستم ایجاد حساب‌های کاربری است. این کار با استفاده از دستور <command>adduser</command> صورت می‌گیرد که نام کاربری را به عنوان پارامتر دریافت می‌کند.
		</para>
		 <indexterm>
			<primary><command>adduser</command></primary>
		</indexterm>
		 <para>
			دستور <command>adduser</command> قبل از ایجاد حساب‌کاربری چند سوال می‌پرسد، اما استفاده از آن بسیار ساده است. فایل پیکربندی آن، <filename>/etc/adduser.conf</filename> شامل تمام تنظیمات جالب است: از آن می‌توان برای تنظیم ظرفیت دیسک یا quota برای هر کاربر با استفاده از یک قالب پیش‌فرض یا تغییر مکان حساب‌های کاربری استفاده کرد؛ دومی بسیار مورد استفاده است، اما زمانی کاربرد دارد که تعداد فراوانی کاربر وجود دارند که باید روی دیسک‌های مختلف مدیریت شوند، برای نمونه. همچنین می‌توانید پوسته پیش‌فرض مورد استفاده را نیز تغییر دهید.
		</para>
		 <sidebar> <title><emphasis>بازگشت به مقدمات</emphasis> Quota</title>
		 <indexterm>
			<primary>quota</primary>
		</indexterm>
		 <para>
			عبارت “quota” به محدودیت منابع در یک سیستم گفته می‌شود که یک کاربر می‌تواند از آن‌ها استفاده کند. این عبارت اغلب درباره حجم دیسک استفاده می‌شود.
		</para>
		 </sidebar> <para>
			فرآیند ایجاد یک حساب کاربری محتویات دایرکتوری home کاربر را با استفاده از فایل <filename>/etc/skel/</filename> پر می‌کند. این فایل مجموعه‌ای از فایل‌ها و دایرکتوری‌های استاندارد را بوجود می‌آورد.
		</para>
		 <indexterm>
			<primary>گروه</primary>
			<secondary>افزودن کاربر</secondary>
		</indexterm>
		 <indexterm>
			<primary>افزودن کاربر به یک گروه</primary>
		</indexterm>
		 <para>
			در برخی موارد، افزودن کاربر یه یک گروه کار مفیدی است (به جز گروه اصلی کاربر) به منظور اینکه مجوزهای بیشتری در اختیار کاربر قرار گیرد. برای نمونه، کاربری که در گروه <emphasis>audio</emphasis> قرار دارد می‌تواند به دستگاه‌های صوتی دسترسی داشته باشد (قسمت <xref linkend="sidebar.special-files" /> را مشاهده کنید). این عمل با استفاده از دستور <command>adduser <replaceable>user</replaceable> <replaceable>group</replaceable></command> انجام می‌شود.
		</para>
		 <sidebar id="sidebar.special-files"> <title><emphasis>بازگشت به مقدمات</emphasis> مجوزهای دسترسی به دستگاه</title>
		 <indexterm>
			<primary>دستگاه</primary>
			<secondary>مجوزهای دسترسی</secondary>
		</indexterm>
		 <indexterm>
			<primary>فایل</primary>
			<secondary>ویژه</secondary>
		</indexterm>
		 <indexterm>
			<primary>حالت</primary>
			<secondary>کاراکتر</secondary>
		</indexterm>
		 <indexterm>
			<primary>حالت</primary>
			<secondary>بلاک</secondary>
		</indexterm>
		 <indexterm>
			<primary>بلاک، حالت</primary>
		</indexterm>
		 <indexterm>
			<primary>کاراکتر، حالت</primary>
		</indexterm>
		 <indexterm>
			<primary>فایل، ویژه</primary>
		</indexterm>
		 <indexterm>
			<primary><command>mknod</command></primary>
		</indexterm>
		 <para>
			هر دستگاه سخت‌افزاری در یونیکس با استفاده از یک فایل ویژه نمایش داده می‌شود، که معمولا در ساختار درختی زیر <filename>/dev/</filename> یا (DEVices) قرار می‌گیرد. دو نوع فایل ویژه با توجه به ماهیت دستگاه وجود دارد: “حالت کاراکتری” و “حالت بلاکی”، هر حالت تنها دسترسی تعداد معدودی از عملیات را صادر می‌کند. حالت کاراکتری تنها عملیات خواندن/نوشتن را مجاز می‌داند، حالت بلاک اجازه جستجو بین داده‌های موجود را می‌دهد. در نهایت، هر فایل ویژه با دو عدد متناسب است (“ماژور” و “مینور”) که دستگاه را به شیوه‌ای منحصربفرد برای کرنل قابل شناسایی می‌کنند. چنین فایلی، که با دستور <command>mknod</command> ایجاد می‌شود، تنها شامل یک نام نمادین (و خوانا برای انسان) است.
		</para>
		 <para>
			مجوزهای یک فایل ویژه منطبق با مجوزهای مورد نیاز برای دسترسی به خود دستگاه است. بنابراین، فایلی مانند <filename>/dev/mixer</filename>، که ترکیب‌کننده صوتی را مشخص می‌کند، تنها شامل مجوزهای خواندن/نوشتن کاربر root و اعضای گروه <literal>audio</literal> است. تنها این کاربران هستند که می‌توانند ترکیب‌کننده صوتی را راهبری کنند.
		</para>
		 <para>
			ذکر این نکته ضروری است که ترکیب <emphasis role="pkg">udev</emphasis>، <emphasis role="pkg">consolekit</emphasis> و <emphasis role="pkg">policykit</emphasis> امکان افزودن مجوزهای دیگر به کاربران برای دسترسی مستقیم به دستگاه (نه از طریق شبکه) را فراهم می‌کند.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.shell-environment">
		<title>محیط پوسته</title>
		 <para>
			مفسرهای خط‌فرمان (پوسته‌ها) یکی از اولین راه‌های تعامل کاربر با رایانه هستند و به همین دلیل باید عملکرد ساده و روشنی داشته باشند. بسیاری از آن‌ها امکان فراخوانی اسکریپت‌های راه‌انداز را به منظور پیکربندی محیط خود می‌دهند (کامل‌سازی خودکار، متن روی صفحه و موارد دیگر).
		</para>
		 <indexterm>
			<primary>رابط خط فرمان</primary>
		</indexterm>
		 <indexterm>
			<primary>مفسر خط‌فرمان</primary>
		</indexterm>
		 <indexterm>
			<primary>پوسته</primary>
		</indexterm>
		 <indexterm>
			<primary><command>bash</command></primary>
		</indexterm>
		 <para>
			<command>bash</command> به عنوان پوسته استاندارد از فایل <filename>/etc/bash.bashrc</filename> به عنوان اسکریپ راه‌انداز پوسته‌های “تعاملی” و از فایل <filename>/etc/profile</filename> برای پوسته‌های “ورودی” استفاده می‌کند.
		</para>
		 <sidebar> <title><emphasis>بازگشت به مقدمات</emphasis> پوسته ورودی و پوسته تعاملی</title>
		 <para>
			به عبارت ساده، یک پوسته ورودی زمانی فراخوانی می‌شود که شما به کنسول از طریق محلی یا در محیط شبکه با استفاده از <command>ssh</command> وارد شده باشید، یا زمانی که دستور <command>bash --login</command> را اجرا کنید. جدا از اینکه این یک پوسته ورودی باشد یا نه، یک پوسته می‌تواند تعاملی (برای نمونه در ترمینال مبتنی بر <command>xterm</command>) یا غیرتعاملی (هنگام اجرای یک اسکریپت) باشد.
		</para>
		 </sidebar> <sidebar> <title><emphasis>اکتشاف</emphasis> سایر پوسته‌ها، سایر اسکریپت‌ها</title>
		 <para>
			Each command interpreter has a specific syntax and its own configuration files. Thus, <command>zsh</command> uses <filename>/etc/zshrc</filename> and <filename>/etc/zshenv</filename>; <command>tcsh</command> uses <filename>/etc/csh.cshrc</filename>, <filename>/etc/csh.login</filename> and <filename>/etc/csh.logout</filename>. The man pages for these programs document which files they use.
		</para>
		 <indexterm>
			<primary><command>zsh</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>tcsh</command></primary>
		</indexterm>
		 </sidebar> <para>
			برای <command>bash</command>، فعال‌سازی “کامل‌سازی خودکار” در فایل <filename>/etc/bash.bashrc</filename> بسیار مفید است (با استفاده از فعال‌سازی چند خط).
		</para>
		 <sidebar> <title><emphasis>بازگشت به مقدمات</emphasis> کامل‌سازی خودکار</title>
		 <indexterm>
			<primary>کامل‌سازی خودکار</primary>
		</indexterm>
		 <para>
			بسیازی از مفسرهای خط‌فرمان قابلیت کامل‌کردن کلمات و عبارت‌ها را دارا هستند، که به کاربر این امکان را می‌دهد با فشردن کلید <keycap>Tab</keycap> دستور یا پارامتر مربوط به آن را کامل کند. این امر به کاربران کمک می‌کند به شیوه راحت‌تر و کم خطاتری از پوسته استفاده کنند.
		</para>
		 <para>
			This function is very powerful and flexible. It is possible to configure its behavior according to each command. Thus, the first argument following <command>apt</command> will be proposed according to the syntax of this command, even if it does not match any file (in this case, the possible choices are <literal>install</literal>, <literal>remove</literal>, <literal>upgrade</literal>, etc.).
		</para>
		 </sidebar> <sidebar> <title><emphasis>بازگشت به مقدمات</emphasis> کاراکتر تیلدا، یک میانبر برای HOME</title>
		 <indexterm>
			<primary>~</primary>
		</indexterm>
		 <indexterm>
			<primary>تیلدا</primary>
		</indexterm>
		 <para>
			کاراکتر تیلدا معمولا به متغیر محلی <varname>HOME</varname> اشاره می‌کند (دایرکتوری خانه برای کاربر، مانند <filename>/home/rhertzog/</filename>). مفسرهای خط‌فرمان به صورت خودکار عملیات جایگزینی آن را انجام می‌دهند: <filename>~/hello.txt</filename> به <filename>/home/rhertzog/hello.txt</filename> تغییر می‌یابد.
		</para>
		 <para>
			کاراکتر تیلدا همچنین امکان دسترسی به دایرکتوری خانه یک کاربر دیگر را می‌دهد. بنابراین، <filename>~rmas/bonjour.txt</filename> متناظر با <filename>/home/rmas/bonjour.txt</filename> است.
		</para>
		 </sidebar> <para>
			در کنار این اسکریپت‌های متداول، هر کاربر می‌تواند با استفاده از <filename>~/.bashrc</filename> و <filename>~/.bash_profile</filename> پوسته خود را به صورت جداگانه از سیستم پیکربندی کند. متداول‌ترین این تغییرات افزوده شدن قابلیت نام مستعار است؛ عبارت‌هایی که هنگام اجرا با دستور معادلشان جایگزین می‌شوند که فراخوانی آن دستور بخصوص را سریع‌تر می‌سازند. برای نمونه، شما می‌توانید نام مستعار <literal>la</literal> را برای دستور <command>ls -la | less</command> بکار گیرید؛ تنها کافی است دستور <command>la</command> را وارد کرده تا محتویات یک دایرکتوری را به صورت خواسته شده مشاهده کنید.
		</para>
		 <sidebar> <title><emphasis>بازگشت به مقدمات</emphasis> متغیرهای محلی</title>
		 <indexterm>
			<primary>محیط</primary>
			<secondary>متغیر محلی</secondary>
		</indexterm>
		 <indexterm>
			<primary>متغیر، محلی</primary>
		</indexterm>
		 <para>
			متغیرهای محلی امکان ذخیره‌سازی تنظیمات سراسری برای پوسته یا سایر برنامه‌های سیستم را بوجود می‌آورند. آن‌ها وابسته به محیط (هر فرآیند متغیرهای محلی مربوط به خود را دارد) و قابل ارث‌بری هستند. امکان آخر این اجازه را به یک پوسته می‌دهد تا با تعریف این متغیرها، آن‌ها را در تمام برنامه‌های زیرمجموعه خود قابل دسترس سازد.
		</para>
		 </sidebar> <para>
			تنظیم متغیرهای مخلی پیش‌فرض یکی از مهم‌ترین عنصرهای پیکربندی در پوسته است. بجز متغیرهایی که مربوط به خود پوسته هستند، قرار دادن آن‌ها در فایل <filename>/etc/environment</filename> ترجیح داده می‌شود، چرا که توسط بسیاری از برنامه‌ها که پوسته را راه‌اندای می‌کنند بکار می‌رود. متغیرهایی که در این فایل قرار می‌گیرند شامل <varname>ORGANIZATION</varname>، که معمولا نام شرکت یا سازمان یا <varname>HTTP_PROXY</varname>، که مکان یک پروکسی وب را شامل می‌شود.
		</para>
		 <sidebar> <title><emphasis>نکته</emphasis> تمام پوسته‌ها به یک صورت پیکربندی می‌شوند</title>
		 <para>
			کاربران اغلب می‌خواهند پوسته‌های ورودی و تعاملی خود را به یک صورت پیکربندی کنند. برای اینکار، آن‌ها انتخاب می‌کنند که محتوای فایل <filename>~/.bashrc</filename> در فایل <filename>~/.bash_profile</filename> تفسیر یا “source” گردد. این اقدام برای محتوای فایل <filename>/etc/bash.bashrc</filename> از <filename>/etc/profile</filename> نیز میسر است.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.config-printing">
		<title>پیکربندی چاپگر</title>
		 <indexterm>
			<primary>پیکربندی</primary>
			<secondary>قابلیت چاپ</secondary>
		</indexterm>
		 <indexterm>
			<primary>قابلیت چاپ</primary>
			<secondary>پیکربندی</secondary>
		</indexterm>
		 <para>
			پیکربندی چاپگر سابق بر این سردردهای بسیار شدیدی را برای مدیرسیستم‌ها بوجود می‌آورد. اکنون این دشواری‌ها حل شده‌اند، به لطف <emphasis role="pkg">cups</emphasis>، سرور چاپ رایگانی که از پروتکل IPP یا Internet Printing Protocol استفاده می‌کند.
		</para>
		 <indexterm>
			<primary>IPP</primary>
		</indexterm>
		 <indexterm>
			<primary>Internet Printing Protocol</primary>
		</indexterm>
		 <indexterm>
			<primary><command>cups</command></primary>
		</indexterm>
		 <para>
			This program is divided over several Debian packages: <emphasis role="pkg">cups</emphasis> is the central print server; <emphasis role="pkg">cups-bsd</emphasis> is a compatibility layer allowing use of commands from the traditional BSD printing system (<command>lpd</command> daemon, <command>lpr</command> and <command>lpq</command> commands, etc.); <emphasis role="pkg">cups-client</emphasis> contains a group of programs to interact with the server (block or unblock a printer, view or delete print jobs in progress, etc.); and finally, <emphasis role="pkg">printer-driver-gutenprint</emphasis> contains a collection of additional printer drivers for <command>cups</command>.
		</para>
		 <indexterm>
			<primary><command>lpr</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpq</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>جامعه کاربری</emphasis> CUPS</title>
		 <indexterm>
			<primary>CUPS</primary>
		</indexterm>
		 <indexterm>
			<primary>Common Unix Printing System</primary>
		</indexterm>
		 <para>
			سیستم چاپ متداول یونیکس یا CUPS پروژه (و نام تجاری) است که توسط شرکت اپل مدیریت می‌شود. <ulink type="block" url="http://www.cups.org/" />
		</para>
		 </sidebar> <para>
			پس از نصب این بسته‌های مختلف، <command>cups</command> به راحتی از طریق یک رابط وب از نشانی محلی <literal>http://localhost:631/</literal> مدیریت می‌شود. آنجا می‌توانید چاپگرهای خود را اضافه (از جمله چاپگرهای شبکه) آن‌ها را حذف و مدیریت کنید. همچنین می‌توانید با استفاده از رابط گرافیکی میزکار خود نیز با <command>cups</command> ارتباط برقرار کنید. در نهایت، همچنین رابط گرافیکی <command>system-config-printer</command> در بسته‌ای با همین نام به منظور مدیریت چاپگرها وجود دارد.
		</para>
		 <indexterm>
			<primary><command>cups</command></primary>
			<secondary>مدیریت</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>یادداشت</emphasis> از رده خارج شدن <filename>/etc/printcap</filename></title>
		 <para>
			<emphasis>cups</emphasis> no longer uses the <filename>/etc/printcap</filename> file, which is now obsolete. Programs that rely upon this file to get a list of available printers will, thus, fail. To avoid this problem, delete this file and make it a symbolic link (see sidebar <xref linkend="sidebar.symbolic-link" />) to <filename>/run/cups/printcap</filename>, which is maintained by <emphasis>cups</emphasis> to ensure compatibility.
		</para>
		 <indexterm>
			<primary><filename>printcap</filename></primary>
		</indexterm>
		 </sidebar>
	</section>
	 <section id="sect.config-bootloader">
		<title>پیکربندی راه‌انداز اولیه</title>
		 <indexterm>
			<primary>راه‌انداز</primary>
			<secondary>راه‌انداز اولیه</secondary>
		</indexterm>
		 <indexterm>
			<primary>راه‌انداز اولیه</primary>
		</indexterm>
		 <para>
			این قابلیت هم‌اکنون فعال است، اما دانستن اینکه چطور می‌توان در زمان بروز مشکل در راه‌انداز اولیه یا پاک شدن آن از روی MBR آن را عیب‌زدایی و نصب مجدد کرد بسیار مفید است. این اتفاق زمانی می‌افتد که یک سیستم عامل دیگر مانند ویندوز را نصب کنید. اطلاعات پیش رو به شما کمک می‌کنند که راه‌انداز اولیه را به صورت صحیح پیکربندی کنید.
		</para>
		 <sidebar> <title><emphasis>بازگشت به مقدمات</emphasis> Master Boot Record</title>
		 <indexterm>
			<primary>MBR</primary>
		</indexterm>
		 <indexterm>
			<primary>Master Boot Record</primary>
		</indexterm>
		 <para>
			رکورد راه‌انداز اصلی یا MBR اولین ۵۱۲ بایت اولین هارددیسک موجود را اشغال می‌کند و اولین چیزی است که توسط BIOS برای شناسایی برنامه‌ای که قادر به راه‌اندازی سیستم عامل باشد فراخوانی می‌گردد. به صورت کلی، راه‌انداز اولیه‌ای که در MBR نصب می‌گردد تمام محتوای قبلی را حذف می‌کند.
		</para>
		 </sidebar> <section id="sect.identify-disks">
			<title>شناسایی دیسک‌ها</title>
			 <sidebar> <title><emphasis>فرهنگ</emphasis> <emphasis>udev</emphasis> و <filename>/dev/</filename></title>
			 <para>
				دایرکتوری <filename>/dev/</filename> از قدیم محل نگهداری فایل‌های به اصطلاح “ویژه” بود، که نمایانگر دستگاه‌های جانبی متصل به سیستم بودند (قسمت <xref linkend="sidebar.special-files" /> را مشاهده کنید). در زمان‌های گذشته این دایرکتوری شامل تمام فایل‌های ویژه قابل استفاده بود. این رویکرد نقص‌های فراوانی به همراه داشت از جمله اینکه تعداد دستگاه‌هایی که یک نفر می‌توانست از آن‌ها استفاده کند را محدود می‌ساخت (به دلیل دست‌نویس بودن تمام نام‌ها) و اینکه تقریبا غیرممکن بود بفهمید کدام فایل واقعا کاربردی است.
			</para>
			 <para>
				امروزه، مدیریت فایل‌های ویژه به صورت کامل پویا شده است و با طبیعت دستگاه‌های قابل جداشدن از سیستم بهتر سازگار است. کرنل با <emphasis>udev</emphasis> ارتباط برقرار می‌کند تا این فایل‌های را ایجاد یا حذف کرده تنها زمانی که دستگاه‌های مربوط به آن‌ها در سیستم شناسایی شوند. به این دلیل، <filename>/dev/</filename> نیازی ندارد که یک ساختار ثابت روی دیسک باشد و می‌تواند به عنوان یک فایل سیستم موجود در حافظه اصلی یا RAM برای درج دستگاه‌های مورد نیاز سیستم بکار رود.
			</para>
			 <para>
				کرنل اطلاعات بسیاری را در رابطه با دستگاه‌های جدید رد و بدل می‌کند و از شماره‌های ماژور/مینور برای شناسایی این دستگاه‌ها بهره می‌برد. با این شیوه <command>udevd</command> می‌تواند فایل ویژه مورد نیاز را با توجه به مجوزهای لازم هر دستگاه ایجاد کند. همچنین می‌تواند نام‌های مستعار ایجاد کرده و اقدامات بیشتری را انجام دهد (مانند پیکربندی اولیه یا ثبت فعالیت‌ها). عملکرد <command>udevd</command> توسط مجموعه بزرگی از قوانین (سفارشی‌سازی) هدایت می‌شود.
			</para>
			 <para>
				با نام‌هایی که به صورت خودکار اختصاص می‌یابند، می‌توانید یک نام یکسان برای دستگاه مشخصی تعیین کنید جدا از اینکه توسط چه اتصالی برقرار شده یا ترتیب آن به چه صورت بوده، که این عمل هنگام استفاده از درگاه‌های مختلف USB بسیار مفید است. اولین پارتیشن اولین هارددیسک می‌تواند نام <filename>/dev/sda1</filename> را داشته باشد یا <filename>/dev/root-partition</filename> اگر آن را ترجیح دهید یا استفاده از هر دو در یک زمان چرا که <command>udevd</command> قادر است پیوندهای نمادین از این فایل‌ها بسازد.
			</para>
			 <para>
				در زمان‌های قدیم، برخی ماژول‌های کرنل به صورت خودکار فراخوانی می‌شدند زمانی که شما دستگاه جدیدی را به سیستم معرفی می‌کردید. این مورد دیگر مصداق ندارد و فایل ویژه مربوط به دستگاه دیگر وجود ندارد که ماژولی برای آن فراخوانی گردد؛ این مشکل بزرگی نیست، چرا که اکثر ماژول‌ها هنگام راه‌اندازی اولیه سیستم توسط فاز شناسایی سخت‌افزار فراخوانی و آماده اجرا می‌گردند. اما برای دستگاه‌هایی که شناسایی نمی‌گردند (مانند هارددیسک‌های بسیار قدیمی یا ماوس PS/2)، این اتفاق نمی‌افتد. می‌توان با افزودن ماژول‌های <literal>floppy</literal>، <literal>psmouse</literal> و <literal>mousedev</literal> به فایل <filename>/etc/modules</filename> آن‌ها را هنگام راه‌اندازی اولیه سیستم فراخوانی کرد.
			</para>
			 </sidebar> <indexterm>
				<primary>هارد درایو، نام‌ها</primary>
			</indexterm>
			 <indexterm>
				<primary>نام‌های</primary>
				<secondary>هارد درایوها</secondary>
			</indexterm>
			 <para>
				پیکربندی راه‌انداز اولیه باید هارد درایوهای مختلف با پارتیشن‌های مربوطه را شناسایی کند. لینوکس از فایل‌های ویژه “بلاک” که در <filename>/dev/</filename> ذخیره می‌شوند به این منظور استفاده می‌کند. به این منظور، از دبیان <emphasis role="distribution">Squeeze</emphasis>، شیوه نامگذاری هارد درایوها توسط کرنل لینوکس یکپارچه شده است و تمام هارد درایوها (IDE/SATA، SATA، SCSI، USB، IEEE 1394) اکنون توسط <filename>/dev/sd*</filename> شناخته می‌شوند.
			</para>
			 <para>
				هر پارتیشن با عدد مخصوص به خود روی دیسک شناسایی می‌گردد: برای نمونه، <filename>/dev/sda1</filename> اولین پارتیشن روی اولین دیسک و <filename>/dev/sdb3</filename> سومین پارتیشن روی دومین دیسک است.
			</para>
			 <indexterm>
				<primary>پارتیشن</primary>
				<secondary>اولیه</secondary>
			</indexterm>
			 <indexterm>
				<primary>پارتیشن</primary>
				<secondary>گسترش‌یافته</secondary>
			</indexterm>
			 <indexterm>
				<primary>پارتیشن</primary>
				<secondary>ثانویه</secondary>
			</indexterm>
			 <indexterm>
				<primary>‌جدول پارتیشن‌بندی</primary>
				<secondary>قالب MS-DOS</secondary>
			</indexterm>
			 <para>
				معماری PC (یا “i386” به همراه “amd64”) تنها محدود به استفاده از قالب جدول پارتیشن “MS-DOS” بوده است، که تنها اجازه چهار پارتیشن “اولیه” روی هر دیسک را می‌دهد. برای غلبه بر این محدودیت یکی از پارتیشن‌ها باید به صورت “گسترش‌یافته” درآید و در آنجا می‌تواند شامل پارتیشن‌های “ثانویه” باشد. این پارتیشن‌های ثانویه از شماره ۵ آغاز می‌گردند. بنابراین اولیه پارتیشن ثانویه روی دیسک با <filename>/dev/sda5</filename> شناخته می‌شود و به همین شکل ادامه می‌یابد.
			</para>
			 <para>
				دیگر محدودیت قالب جدول پارتیشن‌بندی MS-DOS این است که تنها قادر به شناسایی دیسک‌های تا ۲ ترابایت حافظه جانبی است که این مشکل امروزه با توجه به افزایش حجم دیسک‌ها جدی شده است.
			</para>
			 <indexterm>
				<primary>GPT</primary>
				<secondary>قالب جدول پارتیشن‌بندی</secondary>
			</indexterm>
			 <indexterm>
				<primary>جدول پارتیشن‌بندی</primary>
				<secondary>قالب GPT</secondary>
			</indexterm>
			 <para>
				قالب جدید پارتیشن‌بندی GPT به محدودیت‌های فعلی غلبه می‌کند که شامل تعداد پارتیشن‌ها (تا ۱۲۸ پارتیشن اصلی هنگام استفاده از تنظیمات استاندارد) و اندازه و حجم دیسک‌های مورد استفاده (بالغ بر ۸ زتابایت، که بیش از ۸ میلیارد ترابایت است) می‌باشد. اگر قصد ایجاد تعداد زیادی پارتیشن فیزیکی روی یک دیسک را دارید، باید اطمینان یابید که از قالب پارتیشن‌بندی GPT هنگام پارتیشن‌بندی دیسک‌ها استفاده می‌کنید.
			</para>
			 <para>
				به خاطر سپردن اینکه کدام دیسک به کدام کنترلر SATA متصل است، یا در کدام موقعیت زنجیره SCSI قرار دارد کار ساده‌ای نیست، به خصوص زمانی که نامگذاری هارد درایوهای جداشونده در هر مرتبه راه‌اندازی اولیه سیستم ممکن است تغییر کند. خوشبختانه، <command>udev</command> علاوه بر <filename>/dev/sd*</filename>، پیوندهای نمادین با نام‌های ثابت ایجاد می‌کند که می‌توانید از آن‌ها برای شناسایی یک هارد درایو به صورت مشخص استفاده کنید. این پیوندهای نمادین در فایل <filename>/dev/disk/by-id</filename> ذخیره می‌شوند. برای نمونه، در رایانه‌ای با دو دیسک فیزیکی می‌توان به اطلاعات زیر دست یافت:
			</para>
			 
<screen><computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l
</userinput><computeroutput>total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </computeroutput></screen>
			 <para>
				برخی از دیسک‌ها چندین بار در این فهرست آورده شده‌اند (چرا که همزمان به صورت دیسک‌های ATA و SCSI رفتار می‌کنند) اما اطلاعات مربوطه در قسمت مدل و شماره سریال هر یک از دیسک‌ها است که از طریق ‌آن‌ها می‌توانید فایل‌های مربوطه را پیدا کنید.
			</para>
			 <para>
				فایل‌های پیکربندی نمونه که در قسمت‌های بعدی به آن‌ها اشاره می‌شود بر اساس یک تنظیم یکسان هستند: یک دیسک SATA واحد، که اولین پارتیشن آن یک نصب قدیمی از ویندوز است و پارتیشن دوم شامل دبیان گنو/لینوکس است.
			</para>

		</section>
		 <section id="sect.config-lilo">
			<title>پیکربندی LILO</title>
			 <indexterm>
				<primary>LILO</primary>
			</indexterm>
			 <indexterm>
				<primary>Linux Loader</primary>
			</indexterm>
			 <para>
				<emphasis>LILO</emphasis> که مخفف LInux LOader است قدیمی‌ترین راه‌انداز اولیه در لینوکس است - قدیمی اما اصیل. نشانی فیزیکی کرنل برای راه‌اندازی را روی MBR می‌نویسد، به همین دلیل هر بروزرسانی LILO یا فایل‌های پیکربندی آن باید به همراه اجرای دستور <command>lilo</command> باشد. فراموش کردن این امر باعث می‌شود سیستم در حالتی قرار بگیرد که نشانی کرنل قبلی پاک شده باشد و کرنل جدید نیز اکنون در MBR موجود نباشد.
			</para>
			 <para>
				فایل پیکربندی LILO با نام <filename>/etc/lilo.conf</filename> شناخته می‌شود؛ یک فایل نمونه برای پیکربندی استاندارد در ادامه آورده می‌شود.
			</para>
			 <example id="example.lilo.conf">
				<title>فایل پیکربندی LILO</title>
				 
<programlisting>
# The disk on which LILO should be installed.
# By indicating the disk and not a partition.
# you order LILO to be installed on the MBR.
boot=/dev/sda
# the partition that contains Debian
root=/dev/sda2
# the item to be loaded by default
default=Linux

# the most recent kernel image
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Old kernel (if the newly installed kernel doesn't boot)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# only for Linux/Windows dual boot
other=/dev/sda1
  label=Windows</programlisting>

			</example>

		</section>
		 <section id="sect.config-grub">
			<title>پیکربندی GRUB2</title>
			 <indexterm>
				<primary>GRUB</primary>
			</indexterm>
			 <indexterm>
				<primary>GRUB 2</primary>
			</indexterm>
			 <para>
				<emphasis>GRUB</emphasis> که مخفف GRand Unified Bootloader نسخه جدید راه‌اندازهای اولیه است. پس از بروزرسانی هر نسخه کرنل الزامی به فراخوانی مجدد آن نیست؛ <emphasis>GRUB</emphasis> خود می‌داند که چطور فایل‌سیستم را بخواند و موقعیت کرنل را روی دیسک تشخیص دهد. برای نصب آن روی MBR اولین دیسک، تنها کافی است دستور <command>grub-install /dev/sda</command> را وارد کنید. <indexterm><primary><command>grub-install</command></primary></indexterm>
			</para>
			 <sidebar> <title><emphasis>یادداشت</emphasis> نام دیسک‌ها برای GRUB</title>
			 <para>
				GRUB تنها قادر به شناسایی هارد درایوهایی است که اطلاعات آن‌ها توسط BIOS فراهم شده باشد. <literal>(hd0)</literal> مطابق با اولین دیسک شناسایی شده است، <literal>(hd1)</literal> دومین دیسک و به همین ترتیب. در بیشتر موارد، این ترتیب دقیقا همان ترتیب دیسک‌ها در لینوکس است و هنگام استفاده از دیسک‌های SCSI و IDE برخی مشکلات ممکن است بروز کنند. GRUB دیسک‌های شناسایی شده را در فایل <filename>/boot/grub/device.map</filename> ذخیره می‌کند. اگر در آنجا خطایی مشاهده کردید (چرا که می‌دانید BIOS به شیوه‌ای متفاوت دیسک‌ها را شناسایی می‌کند)، به صورت دستی خطا را اصلاح کرده و دستور <command>grub-install</command> را مجدد اجرا کنید. دستور <command>grub-mkdevicemap</command> به شما کمک می‌کند تا یک فایل <filename>device.map</filename> برای ذخیره‌سازی این دیسک‌ها بسازید.
			</para>
			 <para>
				پارتیشن‌ها همچنین یک نام مخصوص به خود در GRUB دارند. زمانی که از پارتیشن‌های “کلاسیک” در قالب MS-DOS استفاده می‌کنید، اولین پارتیشن اولین دیسک به صورت <literal>(hd0,msdos1)</literal> برچسب‌گذاری می‌شود، دومین پارتیشن به صورت <literal>(hd0,msdos2)</literal> و الی آخر.
			</para>
			 </sidebar> <para>
				GRUB 2 configuration is stored in <filename>/boot/grub/grub.cfg</filename>, but this file (in Debian) is generated from others. Be careful not to modify it by hand, since such local modifications will be lost the next time <command>update-grub</command> is run (which may occur upon update of various packages). The most common modifications of the <filename>/boot/grub/grub.cfg</filename> file (to add command line parameters to the kernel or change the duration that the menu is displayed, for example) are made through the variables in <filename>/etc/default/grub</filename>. To add entries to the menu, you can either create a <filename>/boot/grub/custom.cfg</filename> file or modify the <filename>/etc/grub.d/40_custom</filename> file. For more complex configurations, you can modify other files in <filename>/etc/grub.d</filename>, or add to them; these scripts should return configuration snippets, possibly by making use of external programs. These scripts are the ones that will update the list of kernels to boot: <filename>10_linux</filename> takes into consideration the installed Linux kernels; <filename>20_linux_xen</filename> takes into account Xen virtual systems, and <filename>30_os-prober</filename> lists other operating systems (Windows, OS X, Hurd).
			</para>

		</section>
		 <section id="sect.config-yaboot">
			<title>برای رایانه‌های مکینتاش (PowerPC): پیکربندی Yaboot</title>
			 <indexterm>
				<primary><command>yaboot</command></primary>
			</indexterm>
			 <para>
				Yaboot راه‌انداز اولیه مورد استفاده در نسخه‌های قدیمی‌تر مکینتاش با استفاده از پردازنده‌های PowerPC است. آن‌ها مانند PC راه‌اندازی نمی‌گردند، بلکه به یک پارتیشن “راه‌انداز” وابسته هستند که از طریق آن BIOS یا OpenFirmware سیستم راه‌انداز را فراخوانی می‌کند و درون آن برنامه <command>ybin</command> اقدام به نصب <command>yaboot</command> و پیکربندی‌های مورد نیاز آن می‌نماید. تنها زمانی نیاز دارید این دستور را اجرا کنید که فایل <filename>/etc/yaboot.conf</filename> ویرایش شده باشد (که در پارتیشن راه‌انداز نیز قرار دارد و <command>yaboot</command> می‌داند چطور موقعیت کرنل‌ها روی دیسک را تشخیص دهد).
			</para>
			 <para>
				قبل از اجرای <command>ybin</command>، ابتدا باید یک فایل معتبر <filename>/etc/yaboot.conf</filename> داشته باشید. مثالی که در ادامه می‌آید حداقل پیکربندی مورد نیاز برای اینکار است. <indexterm><primary><command>ybin</command></primary></indexterm>
			</para>
			 <example id="example.yaboot.conf">
				<title>فایل پیکربندی Yaboot</title>
				 
<programlisting>
# bootstrap partition
boot=/dev/sda2
# the disk
device=hd:
# the Linux partition
partition=3
root=/dev/sda3
# boot after 3 seconds of inactivity
# (timeout is in tenths of seconds)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# last kernel installed
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# old kernel
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# only for Linux/Mac OSX dual-boot
macosx=/dev/sda5

# bsd=/dev/sdaX and macos=/dev/sdaX
# are also possible</programlisting>

			</example>

		</section>

	</section>
	 <section id="sect.config-misc">
		<title>سایر پیکربندی‌ها: همگام‌سازی زمان، گزارش‌ها، دسترسی اشتراکی...</title>
		 <para>
			عناصر مختلفی که در این قسمت به آن‌ها اشاره می‌شود برای کسانی که می‌خواهند تمام جنبه‌های پیکربندی یک سیستم گنو/لینوکس را بدانند بسیار مفید هستند. اگرچه، تنها به بخش مختصری از آن‌ها می‌پردازیم و ارجاعاتی به مستندات رسمی باقی می‌گذاریم.
		</para>
		 <section id="sect.timezone">
			<title>منطقه‌زمانی</title>
			 <indexterm>
				<primary>منطقه‌زمانی</primary>
			</indexterm>
			 <sidebar id="sidebar.symbolic-link"> <title><emphasis>بازگشت به مقدمات</emphasis> پیوندهای نمادین</title>
			 <indexterm>
				<primary>پیوند</primary>
				<secondary>پیوند نمادین</secondary>
			</indexterm>
			 <indexterm>
				<primary>پیوند نمادین</primary>
			</indexterm>
			 <indexterm>
				<primary><command>ln</command></primary>
			</indexterm>
			 <para>
				یک پیوند نمادین مانند اشاره‌گر به فایل دیگری است. زمانی که به آن دسترسی دارید، در حقیقت فایل اشاره‌شده باز می‌شود. حذف این پیوند منجر به حذف فیزیکی فایلی که به آن اشاره دارد نمی‌شود. به همین شکل، مجوزهای جداگانه مربوط به خود را ندارد، اما مجوزهای فایل هدف را نمایش می‌دهد. در نهایت، می‌تواند به هر نوع فایلی اشاره کند: دایرکتوری‌ها، فایل‌های ویژه (سوکت، لوله‌های نام‌گذاری‌شده، فایل‌های دستگاه‌ها و الی آخر)، حتی سایر پیوندهای نمادین.
			</para>
			 <para>
				دستور <command>ln -s <replaceable>target</replaceable> <replaceable>link-name</replaceable></command> یک پیوند نمادین با نام <replaceable>link-name</replaceable> که اشاره به فایل <replaceable>target</replaceable> دارد را ایجاد می‌کند.
			</para>
			 <para>
				اگر فایل هدف وجود نداشته باشد، آنگاه پیوند به صورت “شکسته” خواهد بود و دسترسی به آن با خطای عدم وجود فایل مقصد مواجه خواهد شد. اگر پیوند به پیوند دیگری اشاره کند، آنگاه دارای “زنجیره‌ای” از پیوندها هستید که هر یک به دیگری اشاره می‌کند و یک “چرخه” را ایجاد می‌کنند. در این مورد، دسترسی به یکی از پیوندهای این چرخه به یک خطای مشخص ختم می‌شود (“too many levels of symbolic links”)؛ به معنی اینکه کرنل پس از چند مرتبه پیموندن این چرخه، عملیات را متوقف کرده است.
			</para>
			 </sidebar> <para>
				منطقه‌زمانی، که در نصب اولیه پیکربندی شده، یک گزینه پیکربندی برای بسته <emphasis role="pkg">tzdata</emphasis> است. برای تغییر آن، از دستور <command>dpkg-reconfigure tzdata</command> استفاده کنید، که به شما اجازه انتخاب یک منطقه‌زمانی را به صورت تعاملی می‌دهد. پیکربندی آن در فایل <filename>/etc/timezone</filename> ذخیره شده است. به علاوه، فایل متناظر آن در دایرکتوری <filename>/usr/share/zoneinfo</filename> در فایل <filename>/etc/localtime</filename> رونوشت گرفته می‌شود؛ این فایل شامل تاریخ مبتنی بر ساعت تابستانی است که بر بعضی کشورها استفاده می‌شود.
			</para>
			 <indexterm>
				<primary><filename>timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>zoneinfo</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/usr/share/zoneinfo/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>DST</primary>
			</indexterm>
			 <indexterm>
				<primary>ساعت تابستانی</primary>
			</indexterm>
			 <para>
				زمانی که نیاز دارید به صورت موقت منطقه‌زمانی را تغییر دهید، از متغیر محلی <varname>TZ</varname> استفاده کنید که نسب به پیش‌فرض اولیه سیستم اولویت پیدا می‌کند.
			</para>
			 <indexterm>
				<primary><varname>TZ</varname></primary>
			</indexterm>
			 
<screen id="screen.tz">
<computeroutput>$ </computeroutput><userinput>date</userinput>
<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>
<computeroutput>$ </computeroutput><userinput>TZ="Pacific/Honolulu" date</userinput>
<computeroutput>Thu Feb 19 00:25:21 HST 2015</computeroutput></screen>
			 <sidebar> <title><emphasis>یادداشت</emphasis> ساعت سیستم، ساعت سخت‌افزار</title>
			 <para>
				دو منبع زمان برای رایانه وجود دارد. برداصلی رایانه دارای یک ساعت سخت‌افزاری است که با نام “ساعت CMOS” شناخته می‌شود. این ساعت خیلی دقیق نیست و دسترسی کندی به زمان ارائه می‌دهد. کرنل سیستم عامل ساعت خود را دارد، ساعت نرم‌افزاری، که با استفاده از ابزار خود بروز نگاه می‌دارد (احتمالا با استفاده از سرورهای زمانی، قسمت <xref linkend="sect.time-synchronization" /> را مشاهده کنید). این ساعت سیستم به طور دقیق‌تری کار می‌کند، به خصوص که به متغیرهای سخت‌افزاری نیازی ندارد. اگرچه، از آنجا که تنها در حافظه اصلی قرار دارد، هر زمان که رایانه راه‌اندازی شود از صفر آعاز می‌گردد، بر خلاف ساعت CMOS که دارای یک باتری است و راه‌اندازی مجدد رایانه باعث “از بین رفتن” آن نمی‌شود. ساعت سیستم، بنابراین با استفاده از ساعت CMOS هنگام راه‌اندازی اولیه تنظیم و ساعت CMOS نیز هنگام خاموش شدن رایانه بروزرسانی می‌گردد (اگر به درستی تنظیم شود تغییرات صحیح را به همراه خواهد داشت).
			</para>
			 <para>
				در عمل، یک مشکل وجود دارد و آن اینکه ساعت CMOS چیزی بیشتر از یک شمارنده سخت‌افزاری نیست و کوچکترین اطلاعاتی راجع به منظفه‌زمانی ندارد. برای تفسیر این حالت یک انتخاب وجود دارد: یا سیستم تصمیم بگیرد که ساعت به صورت جهانی (UTC که سابق بر این GMT بود) تنظیم گردد یا به صورت محلی. این انتخاب به نظر ساده می‌آید، اما داستان پیچیده‌تر از این است: در نتیجه استفاده از ساعت تابستانی، این اختلاف هیچگاه ثابت نمی‌ماند. نتیجه اینکه سیستم هیچ روشی برای تایید این اختلاف زمانی ندارد، به خصوص هنگامی که این بازه زمانی تغییر می‌کند. از آنجا که همیشه می‌توان با استفاده از زمان جهانی و اطلاعات منطقه‌زمانی به ساعت محلی دسترسی داشت، به شدت توصیه می‌شود که از ساعت CMOS در زمان جهانی استفاده گردد.
			</para>
			 <para>
				متاسفانه، سیستم‌های ویندوز با پیکربندی اولیه این توصیه را رعایت نمی‌کنند؛ آن‌ها ساعت CMOS را در حالت محلی نگاه داشته و هنگام راه‌اندازی اولیه رایانه اقدام به اعمال تغییرات زمانی با توجه به تغییرات زمانی سابق سیستم می‌نمایند. این کار به نسبت جواب می‌دهد، مادامی که ویندوز تنها سیستم عامل رایانه باشد. اما زمانی که یک رایانه دارای سیستم عامل‌های گوناگونی باشد (خواه یک پیکربندی “dual-boot” یا استفاده از ماشین مجازی) آشوب به پا می‌شود و هیچ روشی برای تایید صحت زمان وجود نخواهد داشت. اگر قصد نگهداری ویندوز روی یک رایانه را دارید، باید آن را به گونه‌ای پیکربندی کنید که ساعت CMOS بز اساس زمان UTC (تنظیم کلید رجیستری <literal>HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</literal> به “۱” به عنوان DWORD) یا استفاده از دستور <command>hwclock --localtime --set</command> در دبیان برای تنظیم ساعت سخت‌افزاری و نشانه‌گذازی آن به عنوان زمان محلی (و اطمینان حاصل کنید که هنگام بهار و پاییز این تغییرات اعمال می‌شود) تنظیم گردد.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.time-synchronization">
			<title>همگام‌سازی زمان</title>
			 <indexterm>
				<primary>همگام‌سازی زمان</primary>
			</indexterm>
			 <indexterm>
				<primary>ساعت</primary>
				<secondary>همگام‌سازی</secondary>
			</indexterm>
			 <para>
				همگام‌سازی زمان، که ممکن است عضو زائدی در رایانه به حساب آید، اهمیت بسزایی در یک شبکه دارد. از آنجا که کاربران مجوز کافی برای تغییر و تنظیم تاریخ و ساعت را ندارد، دقیق بودن این اطلاعات از اهمیت خاصی برخوردار است تا باعث سردرگمی نشود. علاوه بر این، همگام‌سازی زمان چند رایانه در شبکه باعث می‌شود که اطلاعات مربوط به گزارش‌های سیستمی به صورت بهتری استفاده گردند. بنابراین، اگر حمله‌ای صورت گیرد، راحت‌تر خواهد بود که ترتیب زمانی وقایع اتفاق افتاده در مجموعه‌ای از رایانه‌های نفوذ شده را تشخیص داد. داده‌هایی که از چندین رایانه مختلف برای تحلیل آماری گردآوری می‌شوند مادامی که همگام‌سازی زمانی نداشته باشند تاثیر خاصی ندارند.
			</para>
			 <sidebar> <title><emphasis>بازگشت به مقدمات</emphasis> NTP</title>
			 <indexterm>
				<primary>NTP</primary>
			</indexterm>
			 <indexterm>
				<primary>شبکه</primary>
				<secondary>پروتکل زمان</secondary>
			</indexterm>
			 <para>
				پروتکل زمان در شبکه یا Network Time Protocol به یک رایانه اجازه می‌دهد که ساعت خود را با سایر رایانه‌های شبکه همگام‌سازی کند. این پروتکل تاخیر بوجود آمده در شبکه و سایر تاثیرات مربوط به آن را نیز در محاسبه این زمان به حساب می‌آورد.
			</para>
			 <para>
				با اینکه تعداد زیادی سرور NTP در اینترنت وجود دارند، آن‌هایی که محبوب‌تر هستند بیشتر استفاده می‌گردند. به همین دلیل توصیه می‌کنیم که از سرور <emphasis>pool.ntp.org</emphasis> استفاده کرده که در حقیقت مجموعه‌ای از رایانه‌های عمومی ارائه‌دهنده این پروتکل در اینترنت هستند. حتی می‌توانید بر اساس یک کشور خاص فهرست خود را کوتاه کنید، برای نمونه <emphasis>us.pool.ntp.org</emphasis> برای ایالات متحده یا <emphasis>ca.pool.ntp.org</emphasis> برای کانادا.
			</para>
			 <para>
				اگر یک شبکه بزرگ را مدیریت می‌کنید، توصیه می‌شود که سرور NTP خود را نصب کنید که با استفاده از سرورهای عمومی همگام‌سازی می‌گردد. در این مورد، تمام رایانه‌های شبکه محلی می‌توانند از سرور شما استفاده کنند بجای اینکه ترافیک خود را روی سرورهای عمومی قرار دهند. با اینکار همگن بودن ساعت‌ها را افزایش می‌دهید، چرا که تمام رایانه‌ها بر اساس یک منبع همگام‌سازی زمانی شده‌اند و این منبع با توجه به زمان انتقال در شبکه بسیار نزدیک است.
			</para>
			 </sidebar> <section id="sect.ntp-on-workstations">
				<title>برای رایانه‌های رومیزی</title>
				 <para>
					از آنجا که این رایانه‌ها به صورت مداوم روشن و خاموش می‌گردند (حتی برای صرفه‌جویی در انرژی)، همگام‌سازی زمان در لحظه راه‌اندازی توسط NTP کافی است. به این منظور، تنها کافی است بسته <emphasis role="pkg">ntpdate</emphasis> را نصب کنید. با ویرایش فایل <filename>/etc/default/ntpdate</filename> نیز می‌توانید سرور NTP مورد نظر را تغییر دهید.
				</para>
				 <indexterm>
					<primary><filename>ntpdate</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/default/ntpdate</filename></primary>
				</indexterm>

			</section>
			 <section id="sect.ntp-on-servers">
				<title>برای سرورها</title>
				 <para>
					سرورها به طور خیلی کم راه‌اندازی مجدد می‌گردند و صحیح بودن ساعت سیستم در آن‌ها اهمیت ویژه‌ای دارد. برای این منظور، می‌توانید یک سرور NTP محلی نصب کنید، سرویسی که توسط بسته <emphasis role="pkg">ntp</emphasis> ارائه می‌شود. در پیکربندی پیش‌فرض آن، سرور با <emphasis>pool.ntp.org</emphasis> همگام‌سازی می‌شود و زمان خواسته شده را که توسط شبکه محلی مورد نیاز است فراهم می‌آورد. می‌توانید با ویریش فایل <filename>/etc/ntp.conf</filename> آن را پیکربندی کنید که مهم‌ترین تغییر در آن مربوط به سرور NTP مورد نیاز است. اگر شبکه دارای سرورهای مختلفی باشد، می‌توان یکی از آن‌ها را با توجه به سرورهای عمومی NTP همگام‌سازی کرد تا باقی سرورهای شبکه از روی آن همگام‌سازی زمانی گردند.
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">ntp</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary>سرور</primary>
					<secondary>NTP</secondary>
				</indexterm>
				 <indexterm>
					<primary>NTP</primary>
					<secondary>سرور</secondary>
				</indexterm>
				 <sidebar> <title><emphasis>مطالعه بیشتر</emphasis> ماژول‌های GPS و سایر منابع زمانی</title>
				 <indexterm>
					<primary>GPS</primary>
				</indexterm>
				 <indexterm>
					<primary>DCF-77</primary>
				</indexterm>
				 <para>
					اگر همگام‌سازی زمان برای شبکه شما امری حیاتی است، امکان تجهیز یک سرور به ماژول GPS (که از زمان ماهواره‌های GPS استفاده می‌کند) یا ماژول DCF-77 (که از زمان ساعت اتمی نزدیک به فرانکفورت آلمان استفاده می‌کند) وجود دارد. در این مورد، پیکربندی سرور NTP کمی پیچیده‌تر خواهد بود و مطالعه مستندات قبل از پیاده‌سازی آن یک ضرورت محسوب می‌شود.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.rotation-logs">
			<title>چرخش فایل‌های گزارش</title>
			 <indexterm>
				<primary>فایل</primary>
				<secondary>گزارش‌ها، چرخش</secondary>
			</indexterm>
			 <indexterm>
				<primary>گزارش‌ها</primary>
				<secondary>فایل‌ها، چرخش</secondary>
			</indexterm>
			 <indexterm>
				<primary>چرخش فایل‌های گزارش</primary>
			</indexterm>
			 <indexterm>
				<primary><command>logrotate</command></primary>
			</indexterm>
			 <para>
				فایل‌های گزارش می‌توانند به سرعت رشد کرده و حجم زیادی اشغال کنند که این امر بایگانی کردن آن‌ها را لازم می‌سازد. متداول‌ترین شیوه استفاده از یک بایگانی چرخشی است: فایل گزارش به صورت مداوم بایگانی می‌شود و تنها آخرین بایگانی <replaceable>X</replaceable> به صورت دست نخورده باقی می‌ماند. <command>logrotate</command>، برنامه‌ای که مسئول این کار است از دستورات موجود در فایل <filename>/etc/logrotate.conf</filename> و تمام فایل‌هایی که در دایرکتوری <filename>/etc/logrotate.d/</filename> وجود دارند، استفاده می‌کند. مدیرسیستم شاید بخواهد این فایل‌ها را ویرایش کند، اگر قصد سازگاری با سیاست تعیین شده چرخش فایل در دبیان را داشته باشد. صفحه راهنمای <citerefentry><refentrytitle>logrotate</refentrytitle>
				 <manvolnum>1</manvolnum></citerefentry> شامل تمام گزینه‌های موجود در این فایل‌های پیکربندی است. شاید بخواهید تعداد فایل‌هایی که در هر چرخش حفظ می‌گردند را افزایش دهید یا فایل‌های چرخانده شده را به یک دایرکتوری خاص که برای بایگانی استفاده می‌شود جابجا کنید بجای آنکه آن‌ها حذف شوند. همچنین می‌توانید آن‌ها را با استفاده از ایمیل جهت بایگانی در جای دیگری ارسال کنید.
			</para>
			 <para>
				برنامه <command>logrotate</command> به صورت روزانه توسط برنامه زمان‌بندی <command>cron</command> اجرا می‌شود (که در قسمت <xref linkend="sect.task-scheduling-cron-atd" /> توضیح داده شده است).
			</para>

		</section>
		 <section id="sect.sharing-admin-rights">
			<title>اشتراک‌گذاری دسترسی سطح بالا</title>
			 <indexterm>
				<primary>حساب کاربری</primary>
				<secondary>حساب کاربری مدیر</secondary>
			</indexterm>
			 <indexterm>
				<primary>root</primary>
			</indexterm>
			 <indexterm>
				<primary><command>sudo</command></primary>
			</indexterm>
			 <para>
				به طور مداوم، چند مدیرسیستم روی یک شبکه کار می‌کنند. اشتراک‌گذاری گذرواژه حساب root کار معقولی نیست، که باعث بروز سواستفاده با توجه به ماهیت نامشخص بودن کاربر استفاده کننده از این حساب می‌گردد. راه حل این مساله برنامه <command>sudo</command> است که به برخی کاربران اجازه می‌دهد برخی برنامه‌ها را با مجوزهای سطح بالا اجرا کنند. در متداول‌ترین کاربرد، <command>sudo</command> به کاربر مجاز اجازه استفاده از هر دستوری با مجوز حساب root را می‌دهد. به این منظور، کاربر تنها با وارد کردن دستور <command>sudo <replaceable>command</replaceable></command> و درج گذرواژه خود می‌تواند دسترسی بالاتری پیدا کند.
			</para>
			 <para>
				زمانی که نصب گردد، بسته <emphasis role="pkg">sudo</emphasis> تمام مجوزهای کاربر root را به اعضای گروه یونیکس <literal>sudo</literal> اختصاص می‌دهد. برای افزودن سایر مجوزها، مدیرسیستم باید از دستور <command>visudo</command> استفاده کرده که به وی اجازه ویرایش فایل <filename>/etc/sudoers</filename> را می‌دهد (در اینجا نیز ویرایشگر <command>vi</command> انتخاب می‌شود، یا هر ویرایشگر دیگری که توسط متغیر محلی <varname>EDITOR</varname> مشخص شده باشد). افزودن خطی مانند <literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal> باعث می‌شود که کاربر مورد نظر تمام دستورات را با مجوزهای حساب root اجرا کند.
			</para>
			 <indexterm>
				<primary><command>visudo</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>sudoers</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/sudoers</filename></primary>
			</indexterm>
			 <para>
				پیکربندی‌های پیچیده‌تر تنها اجازه دسترسی برخی دستورات را به کاربران می دهند. تمام جزئیات مربوط به این پیکربندی‌ها در صفحه راهنمای <citerefentry><refentrytitle>sudoers</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry> آمده است.
			</para>

		</section>
		 <section id="sect.fstab-mount-points">
			<title>فهرست نقاط اتصال</title>
			 <indexterm>
				<primary>نقطه، اتصال</primary>
			</indexterm>
			 <indexterm>
				<primary>نقطه اتصال</primary>
			</indexterm>
			 <sidebar> <title><emphasis>بازگشت به مقدمات</emphasis> قطع و وصل کردن</title>
			 <para>
				در یک سیستم شبه-یونیکس مانند دبیان، فایل‌ها در یک سلسله‌مراتب درختی از دایرکتوری‌ها سازماندهی شده‌اند. دایرکتوری <filename>/</filename> با نام “ریشه” شناخته می‌شود؛ تمام دایرکتوری‌های اضافه زیر مجموعه دایرکتوری ریشه به حساب می‌آیند. “متصل‌کردن” به عمل اتصال محتوای یک دستگاه جانبی (اغلب یک هارد درایو) به این ساختار درختی اطلاق می‌شود. به همین دلیل، اگر از هارد درایو جداگانه‌ای برای ذخیره‌سازی محتویات کابران استفاده می‌کنید این دیسک باید در مسیر <filename>/home</filename> به اصطلاح “mount” شود. فایل‌سیستم ریشه همیشه در زمان راه‌اندازی اولیه توسط کرنل متصل می‌شود؛ سایر دستگاه‌ها در زمان دیگری یا به صورت دستی توسط دستور <command>mount</command> متصل می‌گردند.
			</para>
			 <indexterm>
				<primary><command>mount</command></primary>
			</indexterm>
			 <para>
				Some removable devices are automatically mounted when connected, especially when using the GNOME, Plasma or other graphical desktop environments. Others have to be mounted manually by the user. Likewise, they must be unmounted (removed from the file tree). Normal users do not usually have permission to execute the <command>mount</command> and <command>umount</command> commands. The administrator can, however, authorize these operations (independently for each mount point) by including the <literal>user</literal> option in the <filename>/etc/fstab</filename> file.
			</para>
			 <para>
				دستور <command>mount</command> می‌تواند بدون پارامتر اجرا گردد (که فهرستی از فایل‌سیستم‌های متصل شده را نمایش می‌دهد). پارامترهای پیش رو برای اتصال یا عدم اتصال یک دستگاه مورد نیاز هستند. برای فهرست کامل‌تر به صفحات راهنمای <citerefentry><refentrytitle>mount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> و <citerefentry><refentrytitle>umount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> مراجعه کنید. برای موارد ساده، شیوه نگارش نیز ساده است: برای نمونه، جهت اتصال پارتیشن <filename>/dev/sdc1</filename>، که یک فایل‌سیستم ext3 دارد، به دایرکتوری <filename>/mnt/tmp/</filename>، به راحتی می‌توانید دستور <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command> را اجرا کنید.
			</para>
			 </sidebar> <para>
				فایل <filename>/etc/fstab</filename> فهرستی از تمام اتصال‌های موجود در سیستم که به صورت خودکار یا دستی صورت گرفته‌اند را نمایش می‌دهد. هر نقطه اتصال توسط یک خط به همراه چندین عبارت که با فاصله جدا شده‌اند مشخص است: <indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						file system: this indicates where the filesystem to be mounted can be found, it can be a local device (hard drive partition, CD-ROM) or a remote filesystem (such as NFS).
					</para>
					 <para>
						این فیلد معمولا توسط شناسه منحصربفرد فایل‌سیستم جایگزین می‌شود (که می‌توانید با دستور <command>blkid <userinput>device</userinput></command> مشخص کنید) که پیشوند <literal>UUID=</literal> دارد. این رویکرد درباره تغییرات احتمالی آینده در نام دستگاه یا ترتیبی که در رایانه قرار گرفته است، محافظت می‌کند.
					</para>

				</listitem>
				 <listitem>
					<para>
						نقطه اتصال: دایرکتوری در فایل‌سیستم محلی که دستگاه، سیستم راه‌دور یا پارتیشن در آن قرار می‌گیرد.
					</para>

				</listitem>
				 <listitem>
					<para>
						نوع: این فیلد نشان‌دهنده نوع فایل‌سیستم استفاده شده در روی دستگاه است. <literal>ext4</literal>، <literal>ext3</literal>، <literal>vfat</literal>، <literal>ntfs</literal>، <literal>btrfs</literal> و <literal>xfs</literal> برخی از گزینه‌ها هستند.
					</para>
					 <sidebar> <title><emphasis>بازگشت به مقدمات</emphasis> NFS، یک فایل‌سیستم شبکه</title>
					 <para>
						NFS یک فایل‌سیستم تحت شبکه است؛ در لینوکس، اجازه دسترسی بدون واسطه به فایل‌های راه‌دور با درج آن‌ها در فایل‌سیستم محلی را صادر می‌کند.
					</para>
					 </sidebar> <para>
						فهرست کاملی از فایل‌سیستم‌های شناخته شده در صفحه راهنمای <citerefentry><refentrytitle>mount</refentrytitle>
						 <manvolnum>8</manvolnum></citerefentry> وجود دارد. مقدار ویژه <literal>swap</literal> برای پارتیشن‌های swap استفاده می‌شود؛ مقدار ویژه <literal>auto</literal> به دستور <command>mount</command> می‌گوید که خود نوع فایل‌سیستم را تشخیص دهد (که معمولا برای کارت‌های حافظه و ذخیره‌سازهای USB بسیار مفید است، چرا که هر یک ممکن است فایل‌سیستم جداگانه‌ای داشته باشند)؛
					</para>

				</listitem>
				 <listitem>
					<para>
						گزینه‌ها: تعداد زیادی هستند که بر اساس نوع فایل‌سیستم متفاوت عمل می‌کنند، آن‌ها در صفحه راهنمای <command>mount</command> مستندسازی شده‌اند. متداول‌ترین آن‌ها عبارتند از
					</para>
					 <itemizedlist>
						<listitem>
							<para>
								<literal>rw</literal> یا <literal>ro</literal> که به معنی دسترسی خواندنی/نوشتی یا فقط خواندنی هستند.
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>noauto</literal> اتصال خودکار هنگام راه‌اندازی اولیه را غیرفعال می‌کند.
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>nofail</literal> به فرآیند راه‌اندای اجازه می‌دهد که در صورت نبودن دستگاه نیز به کار خود ادامه دهد. اطمینان یابید که از این گزینه برای دستگاه‌های خارجی که ممکن است در زمان راه‌اندازی وصل نباشند استفاده می‌کنید، چرا که <command>systemd</command> اطمینان می‌یابد تمام دستگاه‌های مورد نیاز برای اتصال به فایل‌سیستم واقعا وصل شده باشند و اگر این اتفاق نیفتند اجازه پیشروی فرآیند راه‌اندازی سیستم را نمی‌دهد. نکته اینکه می‌توانید آن را با <literal>x-systemd.device-timeout=5s</literal> ترکیب کرده که به ... بگویید بیش از ۵ ثانیه برای ظاهرشدن دستگاه منتظر نماند (قسمت <citerefentry><refentrytitle>systemd.mount</refentrytitle>
								<manvolnum>5</manvolnum></citerefentry> را مشاهده کنید).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>user</literal> به تمام کاربران اجازه اتصال به این فایل‌سیستم را می‌دهد (عملیاتی که معمولا محدود به کاربر root است.)
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>defaults</literal> به معنی گروهی از گزینه‌های پیش‌فرض است: <literal>rw</literal>، <literal>suid</literal>، <literal>dev</literal>، <literal>exec</literal>، <literal>auto</literal>، <literal>nouser</literal> و <literal>async</literal>، که هر کدام در ادامه می‌توانند غیرفعال شوند <literal>defaults</literal> با اضافه کردن <literal>nosuid</literal>، <literal>nodev</literal> و به همین شکل به منظور مسدودکردن <literal>suid</literal>، <literal>dev</literal> و سایر موارد. افزودن گزینه <literal>user</literal> آن‌ها را دوباره فعال می‌کند چرا که <literal>defaults</literal> شامل <literal>nouser</literal> می‌شود.
							</para>

						</listitem>

					</itemizedlist>

				</listitem>
				 <listitem>
					<para>
						dump: this field is almost always set to <literal>0</literal>. When it is <literal>1</literal>, it tells the <command>dump</command> tool that the partition contains data that is to be backed up.
					</para>

				</listitem>
				 <listitem>
					<para>
						pass: this last field indicates whether the integrity of the filesystem should be checked on boot, and in which order this check should be executed. If it is <literal>0</literal>, no check is conducted. The root filesystem should have the value <literal>1</literal>, while other permanent filesystems get the value <literal>2</literal>.
					</para>

				</listitem>

			</itemizedlist>
			 <example id="example.fstab">
				<title>نمونه فایل <filename>/etc/fstab</filename></title>
				 
<programlisting>
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
# swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0</programlisting>

			</example>
			 <para>
				آخرین خط این مثال شامل یک فایل‌سیستم NFS می‌باشد: دایرکتوری <filename>/shared/</filename> از سرور <emphasis>arrakis</emphasis> به دایرکتوری <filename>/shared/</filename> در سیستم محلی متصل شده است. قالب فایل <filename>/etc/fstab</filename> در صفحه راهنمای <citerefentry><refentrytitle>fstab</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> آورده شده است.
			</para>
			 <sidebar> <title><emphasis>مطالعه بیشتر</emphasis> اتصال خودکار</title>
			 <para>
				systemd is able to manage automount points: those are filesystems that are mounted on-demand when a user attempts to access their target mount points. It can also unmount these filesystems when no process is accessing them any longer.
			</para>
			 <para>
				Like most concepts in systemd, automount points are managed with dedicated units (using the <literal>.automount</literal> suffix). See <citerefentry><refentrytitle>systemd.automount</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> for their precise syntax.
			</para>
			 <indexterm>
				<primary><emphasis>am-utils</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><command>amd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>automount</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>autofs</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>automounter</primary>
			</indexterm>
			 <para>
				Other auto-mounting utilities exist, such as <command>automount</command> in the <emphasis role="pkg">autofs</emphasis> package or <command>amd</command> in the <emphasis role="pkg">am-utils</emphasis>.
			</para>
			 <para>
				Note also that GNOME, Plasma, and other graphical desktop environments work together with <emphasis>udisks</emphasis>, and can automatically mount removable media when they are connected.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.locate-updatedb">
			<title><command>locate</command> و <command>updatedb</command></title>
			 <indexterm>
				<primary><command>locate</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>updatedb</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>mlocate</command></primary>
			</indexterm>
			 <para>
				دستور <command>locate</command> زمانی که بخشی از نام فایل را بدانید می‌تواند برای یافتن محل آن به شما کمک کند. نتیجه این جستجو تقریبا بدون کوچکترین وقفه‌ای نمایش داده می‌شود چرا که از پایگاه‌داده‌ای استفاده می‌کند که شامل تمام فایل‌های موجود در سیستم است؛ این پایگاه‌داده به صورت روزانه توسط دستور <command>updatedb</command> بروزرسانی می‌گردد. پیاده‌سازی‌های گوناگونی از دستور <command>locate</command> وجود دارد و دبیان از <emphasis role="pkg">mlocate</emphasis> برای سیستم استاندارد خود بهره می‌گیرد.
			</para>
			 <para>
				<command>mlocate</command> به اندازه‌ای هوشمند است که تنها فایل‌هایی را به کاربر نمایش دهد که وی مجاز به مشاهده آن‌ها باشد، با اینکه به تمام فایل‌های موجود روی سیستم دسترسی دارد (از آنجا که پیاده‌سازی <command>updatedb</command> آن با مجوزهای root انجام می‌شود). برای امنیت بیشتر، مدیرسیستم می‌تواند از متغیر <varname>PRUNEDPATHS</varname> در فایل <filename>/etc/updatedb.conf</filename> به منظور خارج‌سازی برخی دایرکتوری‌ها از فرآیند شاخص‌گذاری استفاده کند.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-compilation">
		<title>کامپایل یک کرنل</title>
		 <indexterm>
			<primary>کامپایل</primary>
			<secondary>یک کرنل</secondary>
		</indexterm>
		 <indexterm>
			<primary>کرنل</primary>
			<secondary>کامپایل‌کردن</secondary>
		</indexterm>
		 <para>
			کرنل‌هایی که توسط دبیان ارائه می‌شوند بیشترین تعداد از ویژگی‌های ممکن را دارا هستند، به همراه بیشترین درایورهای پشتیبانی شده به منظور اینکه پاسحگوی طیف گسترده‌ای از پیکربندی‌های سخت‌افزاری باشند. این همان دلیلی است که برخی کاربران ترجیح می‌دهند تنها نیازهای مربوط به خود در نسخه کامپایل شده از کرنل داشته باشند. برای این انتخاب دو دلیل وجود دارد. نخست اینکه برای بهبود بخشیدن عملکرد سیستم، تنها بخشی از کد کرنل که مورد نیاز است کامپایل می‌شود و این کد حتی اگر استفاده نگردد باز حافظه مربوط به خود را اشغال می‌کند (که این حافظه هیچگاه به swap منتقل نمی‌شود چرا که دقیقا حافظه اصلی یا RAM سیستم است) که این کار می‌تواند به کند شدن عملکرد کلی سیستم منجر گردد. دوم اینکه یک کرنل کامپایل شده با نیازهای خاص احتمال بروز مشکلات امنیتی را کاهش داده چرا که تنها بخش مشخصی از کدهای کرنل کامپایل شده‌اند.
		</para>
		 <sidebar> <title><emphasis>نکته</emphasis> بروزرسانی‌های امنیتی</title>
		 <para>
			اگر تصمیم به کامپایل‌کردن کرنل خود دارید، باید عواقب آن را نیز بپذیرید: دبیان نمی‌تواند بروزرسانی‌های امنیتی برای کرنل سفارشی شما ارائه دهد. با حفظ و استفاده از کرنلی که دبیان ارائه می‌کند، از بروزرسانی‌هایی که توسط تیم امنیتی دبیان انجام می‌شود بهره‌مند می‌گردید.
		</para>
		 </sidebar> <para>
			کامپایل‌مجدد کرنل تنها زمانی لازم است که بخواهید از قابلیت‌های جدید ارائه شده در patchها استفاده کنید (که در نسخه استاندارد کرنل قرار ندارند).
		</para>
		 <sidebar> <title><emphasis>مطالعه بیشتر</emphasis> کتابچه کرنل در دبیان</title>
		 <indexterm>
			<primary><emphasis role="pkg">debian-kernel-handbook</emphasis></primary>
		</indexterm>
		 <para>
			تیم‌های کرنل در دبیان “کتابچه کرنل دببان” را مدیریت می‌کنند (که در بسته <emphasis role="pkg">debian-kernel-handbook</emphasis> نیز موجود است) به همراه مستندات کامل درباره اکثر عملکردهای کرنل و اینکه چطور بسته‌های رسمی از کرنل دبیان تهیه می‌شوند. این اولین جایی است که باید به دنبال اطلاعات تکمیلی درباره کرنل و فرآیند کامپایل آن در این قسمت بگردید. <ulink type="block" url="http://kernel-handbook.alioth.debian.org" />
		</para>
		 </sidebar> <section id="sect.kernel-compilation-prerequisites">
			<title>مقدمه و پیش‌نیاز</title>
			 <para>
				تعجبی ندارد که دبیان کرنل را به مانند سایر بسته‌های نرم‌افزاری مدیریت می‌کند، که با شیوه قدیمی کامپایل و نصب کرنل‌ها تفاوت دارد. از آنجا که کرنل در کنترل سیستم بسته‌بندی قرار دارد، به راحتی می‌تواند حذف یا روی دستگاه‌های دیگری نصب گردد. علاوه بر این، اسکریپت‌های موجود در این بسته‌ها عملیات مربوط به راه‌اندازی اولیه سیستم و تولید initrd را انجام می‌دهند.
			</para>
			 <para>
				سورس کد اصلی لینوکس شامل هر آنچه که برای ساخت یک بسته دبیان لازم است، می‌باشد. اما هنوز نیاز به نصب بسته <emphasis role="pkg">build-essential</emphasis> را دارید تا اطمینان یابید جعبه‌ابزار شما برای ساخت بسته‌های دبیان کامل شده است. علاوه بر این، گام پیکربندی برای کرنل نیازمند بسته <emphasis role="pkg">libncurses5-dev</emphasis> است. در نهایت، بسته <emphasis role="pkg">fakeroot</emphasis> امکان ایجاد بسته دبیان بدون استفاده از مجوزهای سطح بالا را فراهم می‌کند.
			</para>
			 <sidebar> <title><emphasis>فرهنگ</emphasis> روزهای خوب <emphasis role="pkg">kernel-package</emphasis></title>
			 <indexterm>
				<primary><emphasis role="pkg">kernel-package</emphasis></primary>
			</indexterm>
			 <para>
				قبل از اینکه سیستم build در لینوکس قادر به ایجاد بسته‌های دبیان باشد، روش توصیه شده برای ایجاد چنین بسته‌هایی استفاده از ابزار <command>make-kpkg</command> موجود در بسته <emphasis role="pkg">kernel-package</emphasis> بود.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-sources">
			<title>دریافت منابع</title>
			 <indexterm>
				<primary>منابع کرنل لینوکس</primary>
			</indexterm>
			 <indexterm>
				<primary>کرنل</primary>
				<secondary>منابع</secondary>
			</indexterm>
			 <indexterm>
				<primary>منبع</primary>
				<secondary>کرنل لینوکس</secondary>
			</indexterm>
			 <para>
				Like anything that can be useful on a Debian system, the Linux kernel sources are available in a package. To retrieve them, just install the <emphasis role="pkg">linux-source-<replaceable>version</replaceable></emphasis> package. The <command>apt search ^linux-source</command> command lists the various kernel versions packaged by Debian. The latest version is available in the <emphasis role="distribution">Unstable</emphasis> distribution: you can retrieve them without much risk (especially if your APT is configured according to the instructions of <xref linkend="sect.apt-mix-distros" />). Note that the source code contained in these packages does not correspond precisely with that published by Linus Torvalds and the kernel developers; like all distributions, Debian applies a number of patches, which might (or might not) find their way into the upstream version of Linux. These modifications include backports of fixes/features/drivers from newer kernel versions, new features not yet (entirely) merged in the upstream Linux tree, and sometimes even Debian specific changes.
			</para>
			 <para>
				The remainder of this section focuses on the 4.9 version of the Linux kernel, but the examples can, of course, be adapted to the particular version of the kernel that you want.
			</para>
			 <para>
				We assume the <emphasis role="pkg">linux-source-4.9</emphasis> package has been installed. It contains <filename>/usr/src/linux-source-4.9.tar.xz</filename>, a compressed archive of the kernel sources. You must extract these files in a new directory (not directly under <filename>/usr/src/</filename>, since there is no need for special permissions to compile a Linux kernel): <filename>~/kernel/</filename> is appropriate.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>
<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-4.9.tar.xz</userinput></screen>
			 <sidebar> <title><emphasis>فرهنگ</emphasis> محل منابع کرنل</title>
			 <para>
				سابق بر این، منابع کرنل لینوکس در مسیر <filename>/usr/src/linux/</filename> ذخیره می‌شدند که به مجوزهای سطح بالا جهت کامپایل‌شدن نیاز داشت. اگرچه، کار با این مجوزها تا آنجا که ممکن است باید محدود گردد. یک گروه <literal>src</literal> وجود دارد که به اعضا اجازه کار در این دایرکتوری را می‌دهد، اما کار در آن تا آنجا که ممکن است نباید انجام شود. با نگهداری منابع لینوکس در یک دایرکتوری شخصی، از هر جهت امنیت را رعایت کرده‌اید: هیچ فایل ناشناسی در <filename>/usr/src/</filename> برای سیستم بسته‌بندی وجود نخواهد داشت و هیچ روش گمراه‌کننده‌ای برای برنامه‌هایی که می‌خواهند از محتویات <filename>/usr/src/linux</filename> استفاده کنند بوجود نمی‌آید.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.config-kernel">
			<title>پیکربندی کرنل</title>
			 <indexterm>
				<primary>کرنل</primary>
				<secondary>پیکربندی</secondary>
			</indexterm>
			 <indexterm>
				<primary>پیکربندی</primary>
				<secondary>کرنل</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>.config</filename></primary>
			</indexterm>
			 <para>
				گام بعدی پیکربندی کرنل با توجه به نیاز خودتان است که عملیات دقیق آن به اهداف شما بستگی دارد.
			</para>
			 <para>
				زمانی که نسخه‌ای جدیدتر از کرنل را مجدد کامپایل می‌کنید (احتمالا به همراه یک patch اضافه)، پیکربندی تا آنجا که ممکن است به شیوه دبیان نزدیک خواهد بود. در این مورد، و بجای آنکه همه چیز را از ابتدا پیکربندی کنید، تنها کافی است از فایل <filename>/boot/config-<replaceable>version</replaceable></filename> (نسخه‌ای که کرنل کنونی از آن استفاده می‌کند که با استفاده از دستور <command>uname -r</command> قابل خواندن است) در <filename>.config</filename> که در دایرکتوری شامل سورس کد کرنل می‌باشد، رونوشت بگیرید.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cp /boot/config-4.9.0-3-amd64 ~/kernel/linux-source-4.9/.config</userinput></screen>
			 <para>
				اگر قصد تغییر در پیکربندی موجود را ندارید، می‌توانید در این مرحله توقف کرده و به قسمت <xref linkend="sect.kernel-build" /> بروید. اگر می‌خواهید تغییرات را انجام دهید، از طرف دیگر، یا اینکه همه چیز را از اول پیکربندی کنید، باید زمان برای این ییکربندی سفارشی را مد نظر قرار دهید. رابط‌های انحصاری مختلفی در دایرکتوری سورس کد کرنل وجود دارند که می‌توان با استفاده از دستور <command>make <replaceable>target</replaceable></command> فراخوانی کرد، که <replaceable>target</replaceable> یکی از مقادیر موجود در زیر است.
			</para>
			 <para>
				<command>make menuconfig</command> یک رابط متنی (که از بسته <emphasis role="pkg">libncurses5-dev</emphasis> می‌آید) را کامپایل و اجرا می‌کند که اجازه پیمایش گزینه‌های پیکربندی مختلف را به صورت ساختار درختی می‌دهد. فشردن کلید <keycap>Space</keycap> مقدار گزینه انتخابی را تغییر می‌دهد و کلید <keycap>Enter</keycap> دکمه انتهای صفحه را فرا می‌خواهند؛ <guibutton>Select</guibutton> به زیر منو انتخابی باز می‌گردد؛ <guibutton>Exit</guibutton> صفحه جاری را بسته و به ساختار قبلی باز می‌گردد؛ <guibutton>Help</guibutton> نیز راهنمایی بیشتر درباره گزینه‌های موجود را نمایش می‌دهد. کلیدهای جهت‌نما نیز برای پیمایش در صفحه استفاده می‌شوند. برای خروج از برنامه پیکربندی، <guibutton>Select</guibutton> را از منوی اصلی انتخاب کنید. برنامه درخواست ذخیره‌سازی تغییرات شما را می‌دهد؛ در صورت راضی بودن از تغییرات آن‌ها را تایید کنید.
			</para>
			 <para>
				سایر رابط‌ها نیز عملکرد مشترکی دارند، اما به شیوه برنامه‌های گرافیکی مدرن کار می‌کنند؛ مانند <command>make xconfig</command> که از رابط گرافیکی Qt و <command>make gconfig</command> که از رابط گرافیکی +GTK بهره می‌برند. اولی به کتابخانه <emphasis role="pkg">libqt4-dev</emphasis> و دومی به کتابخانه‌های <emphasis role="pkg">libglade2-dev</emphasis> و <emphasis role="pkg">libgtk2.0-dev</emphasis> نیاز دارند.
			</para>
			 <para>
				هنگام استفاده از این رابط‌ها برای پیکربندی، ایده خوبی است که از یک پیکربندی پیش‌فرض آغاز کنید. کرنل چنین پیکربندی‌هایی را در فایل <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename> ارائه داده که می‌توانید آن‌ها را با استفاده از دستور <command>make x86_64_defconfig</command> (در مورد یک رایانه ۶۴ بیتی) یا <command>make i386_defconfig</command> (در مورد یک رایانه ۳۲ بیتی) انتخاب کنید.
			</para>
			 <sidebar> <title><emphasis>نکته</emphasis> مواجهه با فایل‌های قدیمی <filename>.config</filename></title>
			 <para>
				زمانی که با یک فایل <filename>.config</filename> تولید شده توسط نسحه قدیمی‌تر کرنل مواجه می‌شوید، باید آن را بروزرسانی کنید. اینکار را می‌توانید با استفاده از <command>make oldconfig</command> که به صورت تعاملی پرسش‌هایی را درباره پیکربندی جدید از شما می‌پرسد انجام دهید. اگر قصد استفاده از پاسخ پیش‌فرض برای پرسش‌ها را دارید می‌توانید از <command>make olddefconfig</command> استفاده کنید. با استفاده از <command>make olddefconfig</command>، فرض بر این است که پاسخ شما به تمام پرسش‌ها منفی است.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-build">
			<title>کامپایل‌کردن و ساختن بسته</title>
			 <indexterm>
				<primary><command>make deb-pkg</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>یادداشت</emphasis> تمیزکاری قبل از فرآیند ساخت</title>
			 <para>
				اگر پیش از این در دایرکتوری موجود اقدام به کامپایل کرنل کرده باشید و اکنون می‌خواهید همه چیز را از ابتدا آغاز کنید (برای نمونه به دلیل تغییر در پیکربندی کرنل) باید از دستور <command>make clean</command> استفاده کنید تا فایل‌های کامپایل شده قبلی را پاک کند. دستور <command>make distclean</command> حتی فایل‌های تولید شده بیشتری را نیز پاک می‌کند، از جمله فایل <filename>.config</filename> شما، پس بهتر است که از آن یک پشتیبان تهیه کنید.
			</para>
			 </sidebar> <para>
				زمانی که پیکربندی کرنل آماده باشد، یک دستور ساده <command>make deb-pkg</command> تا ۵ بسته دبیان را تولید می‌کند: <emphasis role="pkg">linux-image-<replaceable>version</replaceable></emphasis> که شامل کرنل و ماژول‌های مربوطه است، <emphasis role="pkg">linux-headers-<replaceable>version</replaceable></emphasis> که شامل فایل‌های سرآیند برای ساخت ماژول‌های اضافی است، <emphasis role="pkg">linux-firmware-image-<replaceable>version</replaceable></emphasis> که شامل فایل‌های مورد نیاز برخی درایورها است (این بسته هنگامی که از منابع کرنل دبیان استفاده می‌کنید ممکن است وجود نداشته باشد)، <emphasis role="pkg">linux-image-<replaceable>version</replaceable>-dbg</emphasis> که شامل گزینه‌های عیب‌یابی برای کرنل و ماژول‌های آن است و در نهایت <emphasis role="pkg">linux-libc-dev</emphasis> که شامل فایل‌های سرآیند برخی برنامه‌های سمت کاربر مانند کتابخانه GNU glibc می‌باشد.
			</para>
			 <para>
				<replaceable>version</replaceable> توسط الحاق نسخه توسعه‌دهنده اصلی (که توسط متغیرهای <literal>VERSION</literal>، <literal>PATCHLEVEL</literal>، <literal>SUBLEVEL</literal> و <literal>EXTRAVERSION</literal> در فایل <filename>Makefile</filename> مشخص می‌شود) از <literal>LOCALVERSION</literal> پارامتر پیکربندی و <literal>LOCALVERSION</literal> متغیر محلی است. نسخه بسته از همان رشته تولید شده به همراه یک عدد که به صورت ترتیبی افزایش می‌یابد بهره می‌گیرد (که در فایل <filename>.version</filename> ذخیره می‌شود) مگر آنکه را با استفاده از متغیر محلی <literal>KDEB_PKGVERSION</literal> بی‌تاثیر سازید.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1
</userinput><computeroutput>[...]
$ </computeroutput><userinput>ls ../*.deb
</userinput><computeroutput>../linux-headers-4.9.30-ckt4-falcot_4.9.30-1_amd64.deb
../linux-image-4.9.30-ckt4-falcot_4.9.30-1_amd64.deb
../linux-image-4.9.30-ckt4-falcot-dbg_4.9.30-1_amd64.deb
../linux-libc-dev_4.9.30-1_amd64.deb
</computeroutput></screen>

		</section>
		 <section id="sect.modules-build">
			<title>کامپایل‌کردن ماژول‌های خارجی</title>
			 <indexterm>
				<primary>کرنل</primary>
				<secondary>ماژول‌های خارجی</secondary>
			</indexterm>
			 <indexterm>
				<primary>ماژول‌ها</primary>
				<secondary>ماژول‌های خارجی کرنل</secondary>
			</indexterm>
			 <indexterm>
				<primary><command>dkms</command></primary>
			</indexterm>
			 <para>
				برخی ماژول‌ها خارج از کرنل رسمی لینوکس مدیریت می‌شوند. برای استفاده از آن‌ها، باید همراه با نسخه مربوطه کرنل کامپایل گردند. تعدادی از ماژول‌ها به صورت جداگانه توسط دبیان و در بسته‌های مختص به خود مانند <emphasis role="pkg">xtables-addons-source</emphasis> (ماژول‌های اضافی برای iptables) یا <emphasis role="pkg">oss4-source</emphasis> (سیستم آزاد صوتی، برخی درایورهای مبتنی بر صدا) فراهم آمده‌اند.
			</para>
			 <para>
				تعداد این بسته‌های خارجی بسیار زیاد است و فرصت مطرح کردن آن‌ها را در این قسمت نداریم؛ دستور <command>apt-cache search source$</command> می‌تواند فهرست مختصری از آن‌ها را به شما نمایش دهد. اگرچه، دارا بودن فهرست کاملی از این ماژول‌ها مادامی که ندانید به کدام یک نیاز دارید و کدام یک اضافی است، کاربرد خاصی ندارد. در این موارد، مستندات مربوط به دستگاه یا سخت‌افزاری که می‌خواهید از آن در لینوکس استفاده کنید به این نکات اشاره می‌کنند.
			</para>
			 <para>
				برای نمونه، بیایید نگاهی به بسته <emphasis role="pkg">xtables-addons-source</emphasis> بیندازیم: پس از نصب، فایل <filename>.tar.bz2</filename> از منابع ماژول در مسیر <filename>/usr/src/</filename> قرار می‌گیرد. با اینکه می‌توانیم این فایل را از حالت فشرده خارج ساخته و ماژول مورد نظر را تولید کنیم، در عمل از ابزار DKMS به منظور خودکارسازی این فرآیند استفاده می‌کنیم. اکثر ماژول‌ها انطباق با مکانیزم DMKS را در نام بسته‌هایی که به <literal>-dkms</literal> ختم می‌شوند ارائه می‌دهند. در این مورد، نصب بسته <emphasis role="pkg">xtables-addons-dkms</emphasis> تنها کار مورد نیاز به منظور کامپایل این ماژول برای کرنل فعلی نصب شده است که بسته <emphasis role="pkg">linux-headers-*</emphasis> مختص به آن می‌باشد. برای نمونه، اگر از <emphasis role="pkg">linux-image-amd64</emphasis> استفاده می‌کنید، باید بسته <emphasis role="pkg">linux-headers-amd64</emphasis> را نصب داشته باشید.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>
<computeroutput>
[...]
Setting up xtables-addons-dkms (2.12-0.1) ...
Loading new xtables-addons-2.12 DKMS files...
Building for 4.9.0-3-amd64
Building initial module for 4.9.0-3-amd64
Done.

xt_ACCOUNT:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/4.9.0-3-amd64/updates/dkms/
[...]
DKMS: install completed.
$ </computeroutput><userinput>sudo dkms status</userinput>
<computeroutput>xtables-addons, 2.12, 4.9.0-3-amd64, x86_64: installed
$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>
<computeroutput>filename:       /lib/modules/4.9.0-3-amd64/updates/dkms/xt_ACCOUNT.ko
license:        GPL
alias:          ipt_ACCOUNT
author:         Intra2net AG &lt;opensource@intra2net.com&gt;
description:    Xtables: per-IP accounting for large prefixes
[...]
</computeroutput></screen>
			 <sidebar> <title><emphasis>جایگزین</emphasis> module-assistant</title>
			 <indexterm>
				<primary><emphasis role="pkg">module-assistant</emphasis></primary>
			</indexterm>
			 <para>
				قبل از DKMS، استفاده از <emphasis role="pkg">module-assistant</emphasis> ساده‌ترین روش برای ساخت و توسعه ماژول‌های کرنل بود. اکنون نیز قابلیت استفاده دارد، به خصوص برای بسته‌هایی که سازگار با DKMS نباشند: با دستور ساده‌ای مانند <command>module-assistant auto-install xtables-addons</command> (یا <command>m-a a-i xtables-addons</command> به طور خلاصه) ماژول‌ها برای کرنل فعلی ساخته شده، در بسته جدید دبیان قرار گرفته و آن بسته‌ها به صورت خودکار نصب می‌گردند.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-patch">
			<title>اعمال یک وصله در کرنل</title>
			 <indexterm>
				<primary>کرنل</primary>
				<secondary>وصله</secondary>
			</indexterm>
			 <indexterm>
				<primary>وصله کرنل</primary>
			</indexterm>
			 <para>
				برخی ویژگی‌ها به دلیل مناسب نبودن با استانداردهای کرنل یا عدم تفاهم بین توسعه‌دهندگان آن، در نسخه استاندارد کرنل قرار ندارند. چنین ویژگی‌هایی در قالب وصله یا patch وجود دارند که به صورت آزادانه توسط کاربران می‌توانند به یک نسخه از کرنل اضافه گردند.
			</para>
			 <para>
				Debian sometimes provides some of these patches in <emphasis role="pkg">linux-patch-*</emphasis> packages but they often don't make it into stable releases (sometimes for the very same reasons that they are not merged into the official upstream kernel). These packages install files in the <filename>/usr/src/kernel-patches/</filename> directory.
			</para>
			 <para>
				برای اعمال یک یا چندی از این وصله‌ها، از دستور <command>patch</command> در دایرکتوری اشاره شده استفاده کنید سپس به کامپایل‌ مجدد کرنل طبق روش‌های بالا بپردازید.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-4.9</userinput>
<computeroutput>$ </computeroutput><userinput>make clean</userinput>
<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.1-4.9.11-201702181444.patch.gz | patch -p1</userinput></screen>
			 <para>
				نکته اینکه یک وصله مشخص به طور خاص با تمام نسخه‌های کرنل کار نمی‌کند؛ از این رو امکان ناموفق بودن عملیات همراه با دستور <command>patch</command> وجود دارد. یک پیام خطا هنگام بروز چنین مشکلی همراه با جزئیات آن نمایش داده می‌شود؛ در این مورد، به مستندات موجود در بسته دبیان مربوط به فایل وصله (در دایرکتوری <filename>/usr/share/doc/linux-patch-*/</filename>) مراجعه کنید. در اکثر موارد، نگهدارنده بسته اشاره می‌کند که وصله برای کدام یک از نسخه‌های کرنل کار می‌کند.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-installation">
		<title>نصب یک کرنل</title>
		 <indexterm>
			<primary>نصب</primary>
			<secondary>یک کرنل</secondary>
		</indexterm>
		 <indexterm>
			<primary>کرنل</primary>
			<secondary>نصب</secondary>
		</indexterm>
		 <section id="sect.kernel-package">
			<title>ویژگی‌های یک بسته کرنل در دبیان</title>
			 <indexterm>
				<primary><filename>vmlinuz</filename></primary>
			</indexterm>
			 <para>
				یک بسته کرنل در دبیان اقدام به نصب کرنل (<filename>vmlinuz-<replaceable>version</replaceable></filename>)، پیکربندی آن (<filename>config-<replaceable>version</replaceable></filename>) و جدول نمادین آن (<filename>System.map-<replaceable>version</replaceable></filename>) در مسیر <filename>/boot/</filename> می‌کند. جدول نمادها به توسعه‌دهندگان کمک می‌کند که معنای یک پیام خطا در کرنل را متوجه شوند؛ بدون آن، “oops”‌ها در کرنل (یک “oops” معادل خطای بخش‌بندی برای برنامه‌های سمت-کاربر است، به معنای دیگر پیام‌هایی که پس از یک ارجاع ناموفق اشاره‌گر تولید می‌شوند) تنها شامل نشانی‌های حافظه به صورت عددی هستند، که بدون کمک گرفتن از جدول نمادهای شامل این نشانی‌ها به همراه فراخوانی‌های تابعی ارزش خاصی ندارند. ماژول‌ها در دایرکتوری <filename>/lib/modules/<replaceable>version</replaceable>/</filename> نصب می‌گردند.
			</para>
			 <para>
				اسکریپت‌های پیکربندی موجود در بسته یک فایل initrd تولید می‌کنند، که یک سیستم جمع و جور جهت قرارگفتن در حافظه (که از نام آن نیز پیداست، یعنی “initial ramdisk”) توسط راه‌انداز اولیه است و توسط کرنل به منظور بارگیری ماژول‌های مورد نیاز برای دسترسی به دستگاه‌های کاربردی در سیستم دبیان است (برای نمونه، درایور دیسک‌های SATA). در نهایت، اسکریپت‌های پس از نصب اقدام به بروزرسانی پیوندهای نمادین <filename>/vmlinuz</filename>، <filename>/vmlinuz.old</filename>، <filename>/initrd.img</filename> و <filename>/initrd.img.old</filename> می‌نمایند به منظور اینکه آن‌ها به آخرین دو کرنل نصب شده اشاره کنند، به همراه فایل‌های initrd مربوطه.
			</para>
			 <para>
				اکثر آن فعالیت‌ها توسط اسکریپت‌های موجود در دایرکتوری‌های <filename>/etc/kernel/*.d/</filename> انجام مي‌شوند. برای نمونه، انطباق با <command>grub</command> توسط <filename>/etc/kernel/postinst.d/zz-update-grub</filename> و <filename>/etc/kernel/postrm.d/zz-update-grub</filename> به منظور فراخوانی <command>update-grub</command> هنگام افزودن یا حذف یک کرنل صورت می‌گیرد.
			</para>

		</section>
		 <section id="sect.kernel-installation-with-dpkg">
			<title>نصب با استفاده از <command>dpkg</command></title>
			 <para>
				Using <command>apt</command> is so convenient that it makes it easy to forget about the lower-level tools, but the easiest way of installing a compiled kernel is to use a command such as <command>dpkg -i <replaceable>package</replaceable>.deb</command>, where <literal><replaceable>package</replaceable>.deb</literal> is the name of a <emphasis role="pkg">linux-image</emphasis> package such as <filename>linux-image-4.9.30-ckt4-falcot_1_amd64.deb</filename>.
			</para>
			 <para>
				پیکربندی که گام‌های در فصل به آن‌ها اشاره شد بسیار پایه هستند و می‌توان در هر دو محیط رومیزی و سرور از آن‌ها استفاده کرد و امکان فرآیند خودکارسازی آن‌ها نیز وجود دارد. اگرچه، این کارها به خودی خود یک سیستم کاملا پیکربندی شده را آماده نمی‌کنند. تکه‌های کوچکی هنوز نیاز به پیکربندی دارند، که با برنامه‌های سطح پایینی به نام سرویس‌های یونیکس یا “Unix services” شناخته می‌شوند.
			</para>

		</section>

	</section>
</chapter>

