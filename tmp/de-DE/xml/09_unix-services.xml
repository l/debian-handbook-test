<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="unix-services" lang="de-DE">
	<chapterinfo>
		 <keywordset>
			<keyword>Systemstart</keyword>
			 <keyword>Initialisierungsskripten</keyword>
			 <keyword>SSH</keyword>
			 <keyword>Telnet</keyword>
			 <keyword>Rechte</keyword>
			 <keyword>Berechtigungen</keyword>
			 <keyword>Überwachung</keyword>
			 <keyword>Inetd</keyword>
			 <keyword>Cron</keyword>
			 <keyword>Datensicherung</keyword>
			 <keyword>Wechsel im laufenden Betrieb</keyword>
			 <keyword>PCMCIA</keyword>
			 <keyword>APM</keyword>
			 <keyword>ACPI</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Unix-Dienste</title>
	 <highlights> <para>
		Dieses Kapitel behandelt eine Reihe grundlegender Dienste, die vielen Unix-Systemen gemein sind. Alle Administratoren sollten mit ihnen vertraut sein.
	</para>
	 </highlights> <section id="sect.system-boot">
		<title>Systemstart</title>
		 <indexterm>
			<primary>hochfahren</primary>
			<secondary>das System</secondary>
		</indexterm>
		 <para>
			Beim Hochfahren des Rechners zeigen die zahlreichen Meldungen, die auf der Konsole vorüberrollen, viele selbsttätig ausgeführte Initialisierungen und Konfigurierungen an. Manchmal möchten Sie vielleicht den Ablauf dieser Phase etwas verändern, weshalb Sie sie gut verstehen müssen. Das ist der Zweck dieses Abschnitts.
		</para>
		 <para>
			Zunächst übernimmt das BIOS die Kontrolle über den Rechner, erkennt die Festplatten, lädt den <emphasis>Master Boot Record</emphasis> und führt den Boot-Loader aus. Der Boot-Loader übernimmt, ermittelt den Kernel auf der Festplatte, lädt ihn und führt ihn aus. Der Kernel wird dann initialisiert und beginnt damit, nach der Partition, die das Wurzel-Dateisystem enthält, zu suchen und sie einzuhängen, und führt schließlich das erste Programm aus – <command>init</command>. In vielen Fällen befinden sich diese „Wurzel-Partition“ und der <command>init</command>-Befehl jedoch in einem virtuellen Dateisystem, das nur im Arbeitsspeicher existiert (daher sein Name „initramfs“, früher „initrd“ genannt für „initialization RAM disk“). Dieses Dateisystem wird vom Boot-Loader in den Speicher geladen, häufig aus einer Datei auf einer Festplatte oder aus dem Netzwerk. Es enthält das absolute Minimum dessen, was vom Kernel benötigt wird, um das „wirkliche“ Wurzel-Dateisystem zu laden: dies können Treiber-Module für die Festplatte oder andere Geräte sein, ohne die das System nicht hochfahren kann, oder häufiger Initialisierungsskripten und -module zum Aufbau von RAID-Arrays, zum Öffnen verschlüsselter Partitionen, zur Aktivierung von LVM-Volumes usw. Sobald die Wurzel-Partition eingehängt ist, übergibt initramfs die Kontrolle an das wirkliche init, und der Rechner kehrt zum Standard-Startprozess zurück.
		</para>
		 <figure id="figure.boot-process-systemd">
			<title>Boot-Sequenz eines Rechners, auf dem Linux mit systemd läuft</title>
			 <mediaobject>
				<imageobject>
					<imagedata fileref="images/startup-systemd.png" format="PNG" scalefit="1" width="80%" />
				</imageobject>

			</mediaobject>

		</figure>
		 <section id="sect.systemd">
			<title>Das systemd Initialisierungssystem</title>
			 <para>
				Das "tatsächliche init" wird zur Zeit von <emphasis role="pkg">systemd</emphasis> bereitgestellt und dieser Abschnitt beschreibt das Init-System.
			</para>
			 <sidebar> <title><emphasis>KULTUR</emphasis> Weitere <command>inetd</command> Befehle</title>
			 <para>
				<command>systemd</command> ist ein relativ neues "init-System", und obwohl es bis zu einem gewissen Grad bereits in <emphasis role="distribution">Wheezy</emphasis> verfügbar war, ist es nur der Standard in Debian <emphasis role="distribution">Jessie</emphasis> geworden. Frühere Versionen basierten standardmäßig auf dem "System V init" (im Paket <emphasis role="pkg">sysv-rc</emphasis>), einem viel traditionelleren System. Wir beschreiben das System V init später.
			</para>
			 </sidebar> <sidebar> <title><emphasis>ALTERNATIV</emphasis> Andere Bootsysteme</title>
			 <para>
				Dieses Buch beschreibt das von Debian <emphasis role="distribution">Jessie</emphasis>standardmäßig verwendete Bootsystem (wie es vom Paket <emphasis role="pkg">systemd</emphasis> umgesetzt wird) sowie die bisherige Voreinstellung <emphasis role="pkg">sysvinit</emphasis>, das vom Unix-System <emphasis>System V</emphasis> abgeleitet und übernommen ist; es gibt jedoch auch andere.
			</para>
			 <para>
				<emphasis role="pkg">file-rc</emphasis> ist ein Bootsystem mit einem sehr einfachen Ablauf. Es behält das Prinzip der Runlevel bei, ersetzt jedoch die Verzeichnisse und symbolischen Verknüpfungen durch eine Konfigurationsdatei, die für <command>init</command> die zu startenden Prozesse und ihre Startreihenfolge angibt.
			</para>
			 <para>
				Der Befehl <command>upstart</command> ist auf Debian immer noch nicht vollständig ausgetestet. Es arbeitet ereignisbasiert: Initialisierungsskripten werden nicht mehr der Reihe nach ausgeführt, sondern als Reaktion auf Ereignisse, wie zum Beispiel die Ausführung eines anderen Skripts, von dem sie abhängen. Dieses von Ubuntu eingeführte System ist in Debian <emphasis role="distribution">Jessie</emphasis> vorhanden, aber nicht als Standard eingestellt. Es ist ein Nachfolger für <emphasis role="pkg">sysvinit</emphasis>, und eine der von <command>upstart</command> ausgeführten Aufgaben besteht darin, die für traditionelle Systeme geschriebenen Skripten zu starten, insbesondere die aus dem Paket <emphasis role="pkg">sysv-rc</emphasis>.
			</para>
			 <para>
				Es gibt weitere Systeme und Betriebsarten wie zum Beispiel <command>runit</command> oder <command>minit</command>, die jedoch recht spezialisiert und nicht weit verbreitet sind.
			</para>
			 </sidebar> <sidebar> <title><emphasis>SONDERFALL</emphasis> Aus dem Netzwerk hochfahren</title>
			 <para>
				Bei einigen Konfigurationen kann das BIOS so eingestellt sein, dass es nicht den MBR ausführt, sondern seine Entsprechung im Netzwerk sucht, wodurch es möglich wird, Rechner ohne Festplatte zu bauen oder solche, die bei jedem Neustart vollständig neu installiert werden. Diese Option steht aber nicht auf jeder Hardware zur Verfügung und erfordert im Allgemeinen eine passende Kombination aus BIOS und Netzwerkkarte.
			</para>
			 <para>
				Das Hochfahren aus dem Netzwerk kann dazu verwendet werden, den <command>Debian-Installer</command> oder FAI zu starten (siehe <xref linkend="sect.installation-methods" />).
			</para>
			 </sidebar> <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Der Prozess, eine Programminstanz</title>
			 <indexterm>
				<primary>Prozess</primary>
			</indexterm>
			 <para>
				Ein Prozess ist die Darstellung eines laufenden Programms im Speicher. Er umfasst alle Informationen, die für die ordnungsgemäße Ausführung der Software erforderlich sind (den Code selbst, aber auch die Daten, die er im Speicher hält, die Liste der Dateien, die er geöffnet hat, die Netzwerkverbindungen, die er eingerichtet hat, usw.). Ein einzelnes Programm kann in mehreren Prozessen instanziiert sein, die nicht notwendigerweise unter verschiedenen Benutzerkennungen laufen.
			</para>
			 </sidebar> <sidebar> <title><emphasis>SICHERHEIT</emphasis> Eine Shell als <command>init</command> verwenden, um Administratorrechte zu erlangen</title>
			 <para>
				Vereinbarungsgemäß ist der erste Prozess, der gestartet wird, das Programm <command>init</command> (das ein symbolischer Link zu <filename>/lib/systemd/systemd</filename> ist). Man kann dem Kernel jedoch eine <literal>init</literal>-Option übergeben, die ein anderes Programm angibt.
			</para>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				Jeder mit Zugang zum Rechner kann die <keycap>Reset</keycap>-Taste drücken und ihn so neu starten. Dann ist es an der Eingabeaufforderung des Boot-Loaders möglich, dem Kernel die Option <literal>init=/bin/sh</literal> zu übergeben und so ohne Kenntnis des Administrator-Passworts Root-Rechte zu erlangen.
			</para>
			 <para>
				Um dieses zu verhindern, kann man den Boot-Loader selbst mit einem Passwort absichern. Man könnte auch den Zugang zum BIOS schützen (ein Passwort-Schutzmechanismus ist fast immer verfügbar), ohne den ein böswilliger Eindringling jedoch den Rechner immer noch mit einem Wechseldatenträger, der sein eigenes Linux-System enthält, hochfahren könnte und das er dann dazu benutzen könnte, um auf Daten auf den Festplatten des Rechners zuzugreifen.
			</para>
			 <para>
				Schließlich sollten Sie beachten, dass die meisten BIOS ein voreingestelltes Passwort haben. Ursprünglich dazu gedacht, denen zu helfen, die ihr Passwort vergessen haben, sind diese Passwörter inzwischen öffentlich bekannt und im Internet verfügbar (sehen Sie selbst, indem sie in einer Suchmaschine „Standard-Passwörter“ eingeben). Alle diese Sicherheitsmaßnahmen können daher zwar den unbefugten Zugriff auf den Rechner erschweren, ihn aber nicht vollständig verhindern. Es gibt keinen zuverlässigen Weg, einen Computer zu schützen, falls der Angreifer physisch auf ihn zugreifen kann; er könnte die Festplatten ausbauen, um sie an einen Rechner unter seiner Kontrolle anzuschließen oder das ganze Gerät stehlen oder den BIOS-Speicher löschen, um so das Passwort zurückzusetzen…
			</para>
			 </sidebar> <para>
				Systemd executes several processes, in charge of setting up the system: keyboard, drivers, filesystems, network, services. It does this while keeping a global view of the system as a whole, and the requirements of the components. Each component is described by a “unit file” (sometimes more); the general syntax is derived from the widely-used “*.ini files“ syntax, with <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> pairs grouped between <literal>[<replaceable>section</replaceable>]</literal> headers. Unit files are stored under <filename>/lib/systemd/system/</filename> and <filename>/etc/systemd/system/</filename>; they come in several flavours, but we will focus on “services” and “targets” here.
			</para>
			 <para>
				A systemd “service file” describes a process managed by systemd. It contains roughly the same information as old-style init-scripts, but expressed in a declaratory (and much more concise) way. Systemd handles the bulk of the repetitive tasks (starting and stopping the process, checking its status, logging, dropping privileges, and so on), and the service file only needs to fill in the specifics of the process. For instance, here is the service file for SSH:
			</para>
			 
<programlisting>[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service
</programlisting>
			 <para>
				As you can see, there is very little code in there, only declarations. Systemd takes care of displaying progress reports, keeping track of the processes, and even restarting them when needed.
			</para>
			 <para>
				A systemd “target file” describes a state of the system, where a set of services are known to be operational. It can be thought of as an equivalent of the old-style runlevel. One of the targets is <literal>local-fs.target</literal>; when it is reached, the rest of the system can assume that all local filesystems are mounted and accessible. Other targets include <literal>network-online.target</literal> and <literal>sound.target</literal>. The dependencies of a target can be listed either within the target file (in the <literal>Requires=</literal> line), or using a symbolic link to a service file in the <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal> directory. For instance, <filename>/etc/systemd/system/printer.target.wants/</filename> contains a link to <filename>/lib/systemd/system/cups.service</filename>; systemd will therefore ensure CUPS is running in order to reach <literal>printer.target</literal>.
			</para>
			 <para>
				Since unit files are declarative rather than scripts or programs, they cannot be run directly, and they are only interpreted by systemd; several utilities therefore allow the administrator to interact with systemd and control the state of the system and of each component.
			</para>
			 <para>
				The first such utility is <command>systemctl</command>. When run without any arguments, it lists all the unit files known to systemd (except those that have been disabled), as well as their status. <command>systemctl status</command> gives a better view of the services, as well as the related processes. If given the name of a service (as in <command>systemctl status ntp.service</command>), it returns even more details, as well as the last few log lines related to the service (more on that later).
			</para>
			 <para>
				Starting a service by hand is a simple matter of running <command>systemctl start <replaceable>servicename</replaceable>.service</command>. As one can guess, stopping the service is done with <command>systemctl stop <replaceable>servicename</replaceable>.service</command>; other subcommands include <command>reload</command> and <command>restart</command>.
			</para>
			 <para>
				To control whether a service is active (i.e. whether it will get started automatically on boot), use <command>systemctl enable <replaceable>servicename</replaceable>.service</command> (or <command>disable</command>). <command>is-enabled</command> allows checking the status of the service.
			</para>
			 <para>
				An interesting feature of systemd is that it includes a logging component named <command>journald</command>. It comes as a complement to more traditional logging systems such as <command>syslogd</command>, but it adds interesting features such as a formal link between a service and the messages it generates, and the ability to capture error messages generated by its initialisation sequence. The messages can be displayed later on, with a little help from the <command>journalctl</command> command. Without any arguments, it simply spews all log messages that occurred since system boot; it will rarely be used in such a manner. Most of the time, it will be used with a service identifier:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</computeroutput></screen>
			 <para>
				Another useful command-line flag is <command>-f</command>, which instructs <command>journalctl</command> to keep displaying new messages as they are emitted (much in the manner of <command>tail -f <replaceable>file</replaceable></command>).
			</para>
			 <para>
				If a service doesn't seem to be working as expected, the first step to solve the problem is to check that the service is actually running with <command>systemctl status</command>; if it is not, and the messages given by the first command are not enough to diagnose the problem, check the logs gathered by journald about that service. For instance, assume the SSH server doesn't work:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>vi /etc/ssh/sshd_config
</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service
</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </computeroutput></screen>
			 <para>
				After checking the status of the service (failed), we went on to check the logs; they indicate an error in the configuration file. After editing the configuration file and fixing the error, we restart the service, then verify that it is indeed running.
			</para>
			 <sidebar><title><emphasis>WEITERE SCHRITTE</emphasis> Andere Arten von Unit-Dateien</title>
			 <para>
				We have only described the most basic of systemd's capabilities in this section. It offers many other interesting features; we will only list a few here:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						socket activation: a “socket” unit file can be used to describe a network or Unix socket managed by systemd; this means that the socket will be created by systemd, and the actual service may be started on demand when an actual connection attempt comes. This roughly replicates the feature set of <command>inetd</command>. See <citerefentry><refentrytitle>systemd.socket</refentrytitle>
						<manvolnum>5</manvolnum></citerefentry>.
					</para>
				</listitem>
				 <listitem>
					<para>
						timers: a “timer” unit file describes events that occur with a fixed frequency or on specific times; when a service is linked to such a timer, the corresponding task will be executed whenever the timer fires. This allows replicating part of the <command>cron</command> features. See <citerefentry><refentrytitle>systemd.timer</refentrytitle>
						<manvolnum>5</manvolnum></citerefentry>.
					</para>
				</listitem>
				 <listitem>
					<para>
						network: a “network“ unit file describes a network interface, which allows configuring such interfaces as well as expressing that a service depends on one particular interface being up.
					</para>
				</listitem>

			</itemizedlist>
			</sidebar>
		</section>
		 <section id="sect.sysvinit">
			<title>The System V init system</title>
			 <para>
				Das System V init System (das wir init für Kürze nennen werden) führt mehrere Prozesse aus, indem es Anweisungen aus der Datei <filename>/etc/inittab</filename> befolgt. Das erste Programm, das ausgeführt wird (was dem Schritt <emphasis>sysinit</emphasis> entspricht), ist <command>/etc/init.d/rcS</command>, ein Skript, das alle Programme im Verzeichnis <filename>/etc/rcS.d/</filename> ausführt. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm>
			</para>
			 <para>
				Unter diesen befinden sich nacheinander Programme, die zuständig sind für:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						das Konfigurieren der Konsolentastatur;
					</para>

				</listitem>
				 <listitem>
					<para>
						das Laden von Treibern: die meisten Kernelmodule werden beim Erkennen der Hardware vom Kernel selbst geladen; zusätzliche Treiber werden selbsttätig geladen, wenn die entsprechenden Module in der Datei <filename>/etc/modules</filename> aufgeführt sind;
					</para>

				</listitem>
				 <listitem>
					<para>
						die Integritätsprüfung von Dateisystemen;
					</para>

				</listitem>
				 <listitem>
					<para>
						das Einhängen lokaler Partitionen;
					</para>

				</listitem>
				 <listitem>
					<para>
						das Konfigurieren des Netzwerks;
					</para>

				</listitem>
				 <listitem>
					<para>
						das Einhängen von Netzwerkdateisystemen (NFS).
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Kernelmodule und -optionen</title>
			 <indexterm>
				<primary>Module</primary>
				<secondary>Kernelmodule</secondary>
			</indexterm>
			 <para>
				Kernelmodule verfügen ebenfalls über Optionen, die konfiguriert werden können, indem man Dateien im Verzeichnis <filename>/etc/modprobe.d/</filename> erstellt. Diese Optionen werden durch Anweisungen wie die folgende festgelegt: <literal>options <replaceable>modulname</replaceable> <replaceable>optionsname</replaceable>=<replaceable>optionswert</replaceable></literal>. Falls erforderlich, können mehrere Optionen in einer einzelnen Anweisung gesetzt werden.
			</para>
			 <para>
				Die Konfigurationsdateien sind für das Programm <command>modprobe</command> bestimmt, das ein Kernelmodul mit seinen Abhängigkeiten lädt (Module können auch andere Module aufrufen). Dieses Programm wird durch das Paket <emphasis role="pkg">kmod</emphasis> bereitgestellt.
			</para>
			 <indexterm>
				<primary><command>modprobe</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">kmod</emphasis></primary>
			</indexterm>
			 </sidebar> <para>
				Nach dieser Phase übernimmt <command>init</command> und startet die im Standard-Runlevel (der normalerweise Runlevel 2 ist) aktivierten Programme. Es führt <command>/etc/init.d/rc 2</command> aus, ein Skript, das alle Dienste startet, die in <filename>/etc/rc2.d/</filename> aufgeführt sind und mit dem Buchstaben „S“ beginnen. Die anschließenden zweistelligen Zahlen wurden früher dazu benutzt, die Reihenfolge festzulegen, in der die Dienste gestartet werden mussten, aber heute verwendet das Standard-Bootsystem <command>insserv</command>, das ausgehend von den Abhängigkeiten der Skripten alles selbsttätig zeitlich festlegt. Jedes Boot-Skript legt die Bedingungen fest, die gelten müssen, damit ein Dienst gestartet oder beendet wird (ob er zum Beispiel vor oder nach einem anderen Dienst gestartet werden muss); <command>init</command> startet sie dann in der Reihenfolge, die diese Bedingungen erfüllt. Die feststehende Nummerierung der Skripten wird daher nicht mehr berücksichtigt (sie müssen trotzdem weiterhin einen Namen haben, der mit „S“ beginnt gefolgt von zwei Zahlen und dem Namen des Skripts, das für die Abhängigkeiten verwendet wird). Im Allgemeinen werden grundlegende Dienste (wie das Protokollieren mit <command>rsyslog</command> oder die Portzuweisung mit <command>portmap</command>) als erste gestartet, gefolgt von Standarddiensten und der grafischen Schnittstelle (<command>gdm3</command>).
			</para>
			 <para>
				Dieses Bootsystem auf der Grundlage von Abhängigkeiten ermöglicht es, die Neu-Nummerierung zu automatisieren, die recht mühsam wäre, wenn sie von Hand erledigt werden müsste, und es begrenzt das Risiko menschlichen Versagens, da die Festlegung der zeitlichen Abfolge in Übereinstimmung mit den angegebenen Parametern erfolgt. Ein weiterer Vorteil besteht darin, dass voneinander unabhängige Dienste zeitgleich gestartet werden können, was den Prozess des Hochfahrens beschleunigt.
			</para>
			 <indexterm>
				<primary>Runlevel</primary>
			</indexterm>
			 <indexterm>
				<primary>Level, Runlevel</primary>
			</indexterm>
			 <para>
				<command>init</command> unterscheidet zwischen verschiedenen Runleveln, so dass es mit dem Befehl <command>telinit <replaceable>neuer-level</replaceable></command> von einem zum anderen umschalten kann. <command>init</command> führt bei einem neuen Runlevel unmittelbar ein weiteres Mal <command>/etc/init.d/rc</command> aus. Dieses Skript startet dann die fehlenden Dienste und beendet die nicht mehr benötigten. Hierzu bezieht es sich auf den Inhalt der Datei <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (wobei <replaceable>X</replaceable> den neuen Runlevel bezeichnet). Skripten, deren Namen mit „S“ beginnen (wie in „Start“), verweisen auf zu startende Dienste, solche mit „K“ (wie in „Kill“) auf zu beendende. Das Skript startet keine Dienste, die im vorherigen Runlevel bereits aktiv waren.
			</para>
			 <para>
				Standardmäßig verwendet System V init in Debian vier verschiedene Runlevel:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						Level 0 wird nur vorübergehend beim Herunterfahren des Rechners benutzt. Daher enthält er nur zahlreiche „K“-Skripten.
					</para>

				</listitem>
				 <listitem>
					<para>
						Level 1, auch Single-User Modus genannt, entspricht dem System in rudimentärem Zustand. Er umfasst einzig grundlegende Dienste und ist hauptsächlich für die Systemwartung gedacht, bei dem Interaktionen mit normalen Benutzern nicht erwünscht sind.
					</para>

				</listitem>
				 <listitem>
					<para>
						Level 2 ist der Level für den Normalbetrieb, der Netzwerkdienste, eine grafische Schnittstelle, Benutzeranmeldungen usw. umfasst.
					</para>

				</listitem>
				 <listitem>
					<para>
						Level 6 gleicht Level 0, nur dass er während des Herunterfahrens vor einem Neustart verwendet wird.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Es gibt weitere Level, insbesondere 3 bis 5. Standardmäßig sind sie so konfiguriert, dass sie sich wie Level 2 verhalten. Jedoch kann der Administrator sie verändern (indem er in den entsprechenden Verzeichnissen unter <filename>/etc/rc<replaceable>X</replaceable>.d</filename> Skripten hinzufügt oder löscht), um sie so besonderen Bedürfnissen anzupassen.
			</para>
			 <figure id="figure.boot-process-sysvinit">
				<title>Boot-Sequenz eines Rechners, auf dem Linux mit System V init läuft</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/startup-sysvinit.png" format="PNG" scalefit="1" width="80%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <indexterm>
				<primary>Initialisierungsskript</primary>
			</indexterm>
			 <para>
				Alle in den verschiedenen Verzeichnissen unter <filename>/etc/rc<replaceable>X</replaceable>.d</filename> enthaltenen Skripten sind in Wirklichkeit symbolische Verknüpfungen - bei der Paketinstallation durch das Programm <command>update-rc.d</command> erstellt, die auf die eigentlichen, im Verzeichnis <filename>/etc/init.d/</filename> gespeicherten, Skripten verweisen. Der Administrator kann die in jedem Runlevel verfügbaren Dienste fein einstellen, indem er den Befehl <command>update-rc.d</command> mit angepassten Parametern erneut ausführt. Die Handbuchseite <citerefentry><refentrytitle>update-rc.d</refentrytitle>
				<manvolnum>1</manvolnum></citerefentry> erläutert die Syntax im Detail. Bitte beachten Sie, dass das Entfernen aller symbolischen Verknüpfungen (mit dem Parameter <literal>remove</literal>) kein gutes Verfahren zum Abschalten eines Dienstes ist. Stattdessen sollten Sie ihn einfach so konfigurieren, dass er in dem gewünschten Runlevel nicht startet (und dabei gleichzeitig die entsprechenden Aufrufe zu seinem Abschalten bewahren, für den Fall, dass er im vorhergehenden Runlevel läuft). Da <command>update-rc.d</command> eine etwas verschachtelte Schnittstelle hat, benutzen Sie vielleicht lieber <command>rcconf</command> (aus dem Paket <emphasis role="pkg">rcconf</emphasis>), das eine benutzerfreundlichere Schnittstelle hat.
			</para>
			 <indexterm>
				<primary><command>update-rc.d</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>DEBIAN-RICHTLINIEN</emphasis> Dienste neu starten</title>
			 <indexterm>
				<primary><command>invoke-rc.d</command></primary>
			</indexterm>
			 <indexterm>
				<primary>Dienst</primary>
				<secondary>neu starten</secondary>
			</indexterm>
			 <indexterm>
				<primary>Dienste neu starten</primary>
			</indexterm>
			 <para>
				Die Betreuerskripten für Debian-Pakete starten manchmal bestimmte Dienste neu, um ihre Verfügbarkeit sicherzustellen, oder damit sie bestimmte Optionen berücksichtigen. Der Befehl zur Steuerung eines Dienstes - <command>service<replaceable>dienst</replaceable> <replaceable>vorgang</replaceable></command> - berücksichtigt Runlevel nicht, geht (fälschlicherweise) davon aus, dass der Dienst gerade benutzt wird und kann daher falsche Vorgänge auslösen (einen Dienst starten, der bewusst abgeschaltet worden war, einen Dienst anhalten, der bereits angehalten ist usw.). Deshalb hat Debian das Programm <command>invoke-rc.d</command> eingeführt: dieses Programm muss von Betreuerskripten verwendet werden, um Initialisierungsskripten für Dienste aufzurufen und führt nur die erforderlichen Befehle aus. Man beachte, dass das Suffix <filename>.d</filename> hier, im Gegensatz zu seiner sonst üblichen Verwendung, in einem Programmnamen und nicht in einem Verzeichnis benutzt wird.
			</para>
			 </sidebar> <para>
				Schließlich startet <command>init</command> Steuerprogramme für mehrere virtuelle Konsolen (<command>getty</command>). Es zeigt eine Eingabeaufforderung an, an der es auf einen Benutzernamen wartet, und führt dann <command>login <replaceable>benutzer</replaceable></command> aus, um eine Sitzung zu starten.
			</para>
			 <indexterm>
				<primary><command>getty</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Konsole und Terminal</title>
			 <para>
				Die ersten Computer waren gewöhnlich in mehrere, sehr große Teile unterteilt: das Speichergehäuse und die zentrale Verarbeitungseinheit waren von den Peripheriegeräten getrennt, die von den Bedienern zu ihrer Steuerung benutzt wurden. Letztere waren Teil einer separaten Einrichtung, der „Konsole“. Dieser Begriff wurde beibehalten, aber seine Bedeutung hat sich verändert. Er wurde mehr oder weniger zu einem Synonym für „Terminal“, das aus einer Tastatur und einem Bildschirm besteht.
			</para>
			 <para>
				Im Laufe der Entwicklung der Computer haben Betriebssysteme schließlich mehrere virtuelle Konsolen angeboten, um gleichzeitig mehrere unabhängige Sitzungen zu ermöglichen, selbst wenn es nur eine Tastatur und einen Bildschirm gibt. Die meisten GNU/Linux-Systeme bieten sechs virtuelle Konsolen (im Textmodus) an, die durch die Eingabe der Tastenkombinationen <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> bis <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo> zugänglich sind.
			</para>
			 <para>
				Im weiteren Sinne können die Begriffe „Konsole“ und „Terminal“ sich auch auf einen Terminal-Emulator in einer grafischen X11-Sitzung beziehen (wie zum Beispiel <command>xterm</command>, <command>gnome-terminal</command> oder <command>konsole</command>).
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.remote-login">
		<title>Remoteanmeldung</title>
		 <para>
			Es ist für einen Administrator wichtig, sich aus der Ferne mit einem Rechner verbinden zu können. Server, die in ihrem eigenen Raum eingeschlossen sind, sind selten dauerhaft mit Tastaturen und Bildschirmen ausgestattet - aber sie sind mit dem Netzwerk verbunden.
		</para>
		 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Client, Server</title>
		 <indexterm>
			<primary>Client</primary>
			<secondary>Client/Server-Architektur</secondary>
		</indexterm>
		 <indexterm>
			<primary>Server</primary>
			<secondary>Client/Server-Architektur</secondary>
		</indexterm>
		 <para>
			Ein System, bei dem mehrere Prozesse miteinander kommunizieren. wird häufig mit dem bildlichen Ausdruck „Client-Server“ beschrieben. Der Server ist das Programm, das Anfragen vom Client entgegen nimmt und ausführt. Der Client steuert die Vorgänge, der Server tut nichts aus eigener Initiative.
		</para>
		 </sidebar> <indexterm>
			<primary>Anmelden</primary>
			<secondary>Remoteanmeldung</secondary>
		</indexterm>
		 <indexterm>
			<primary>Remoteanmelden</primary>
		</indexterm>
		 <section id="sect.ssh">
			<title>Sicheres Remoteanmelden: SSH</title>
			 <indexterm>
				<primary>SSH</primary>
			</indexterm>
			 <indexterm>
				<primary>Secure Shell</primary>
			</indexterm>
			 <para>
				Beim <emphasis>SSH</emphasis>-Protokoll (Secure SHell) wurden Sicherheit und Zuverlässigkeit bereits im Entwurf berücksichtigt. Verbindungen auf der Basis von SSH sind sicher: der Partner ist authentifiziert und jeglicher Datenverkehr erfolgt verschlüsselt.
			</para>
			 <sidebar> <title><emphasis>KULTUR</emphasis> Telnet und RSH sind veraltet</title>
			 <indexterm>
				<primary><command>telnet</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>rsh</command></primary>
			</indexterm>
			 <para>
				Vor SSH waren <emphasis>Telnet</emphasis> und <emphasis>RSH</emphasis> die wesentlichen Werkzeuge um sich aus der Ferne anzumelden. Heute sind sie weitestgehend überflüssig und sollten nicht weiter benutzt werden, auch wenn Debian sie immer noch zur Verfügung stellt.
			</para>
			 </sidebar> <sidebar> <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Authentifizierung, Verschlüsselung</title>
			 <para>
				Wenn Sie einem Client die Fähigkeit geben müssen, auf einem Server Aktionen auszuführen oder auszulösen, ist Sicherheit wichtig. Sie müssen die Identität des Clients sicherstellen; dies nennt sich Authentifizierung. Die Identität besteht normalerweise aus einem Passwort, das geheimzuhalten ist, da es sonst von jedem anderen Client erlangt werden könnte. Dies ist der Zweck von Verschlüsselung, einer Art der Kodierung, die es zwei Systemen ermöglicht, vertrauliche Informationen über einen öffentlichen Kanal auszutauschen, ohne dabei für andere lesbar zu sein.
			</para>
			 <para>
				Authentifizierung und Verschlüsselung werden häufig zusammen genannt, weil beide oft gleichzeitig benutzt werden, und weil sie gewöhnlich durch ähnliche mathematische Konzepte umgesetzt werden.
			</para>
			 </sidebar> <para>
				SSH bietet auch zwei Dateiübertragungsdienste an. <command>scp</command> ist ein Befehlszeilenprogramm, das wie <command>cp</command> benutzt werden kann, nur dass jedem Pfad zu einem anderen Rechner der Name dieses Rechners gefolgt von einem Doppelpunkt vorangestellt wird.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput></screen>
			 <para>
				<command>sftp</command> ist ein interaktiver Befehl, ähnlich wie <command>ftp</command>. In einer einzigen Sitzung kann <command>sftp</command> mehrere Dateien übertragen, und es ist möglich, mit ihm Dateien auf einem entfernten Rechner zu bearbeiten (löschen, umbenennen, Berechtigungen ändern usw.).
			</para>
			 <indexterm>
				<primary><command>scp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sftp</command></primary>
			</indexterm>
			 <para>
				Debian verwendet OpenSSH, eine freie Version von SSH, die vom <command>OpenBSD</command>-Projekt betreut wird (einem freien Betriebssystem, das auf dem BSD-Kernel aufbaut und seinen Schwerpunkt auf Sicherheit setzt) und ist ein Fork der ursprünglich vom finnischen Unternehmen SSH Communications Security Corp. entwickelten SSH-Software. Dieses Unternehmen entwickelte SSH ursprünglich als freie Software, entschied sich jedoch schließlich, seine Entwicklung unter einer proprietären Lizenz fortzusetzen. Das OpenBSD-Projekt schuf daraufhin OpenSSH, um eine freie Version von SSH zu bewahren.
			</para>
			 <indexterm>
				<primary>OpenSSH</primary>
			</indexterm>
			 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> <foreignphrase>Fork</foreignphrase></title>
			 <indexterm>
				<primary>Fork</primary>
			</indexterm>
			 <para>
				Ein „Fork“ im Softwarebereich ist ein neues Vorhaben, das als Klon eines bestehenden Vorhabens beginnt und mit ihm konkurriert. Von da an entwickeln sich beide Programme, was neue Entwicklungen angeht, gewöhnlich schnell auseinander. Ein Fork ist häufig die Folge von Meinungsverschiedenheiten innerhalb des Entwicklungsteams.
			</para>
			 <para>
				Die Option, ein Vorhaben zu forken, ist eine direkte Folge der Eigenart freier Software; ein Fork ist ein heilsamer Vorgang, wenn sie die Fortführung eines Vorhabens als freie Software ermöglicht (zum Beispiel im Falle von Lizenzänderungen). Dagegen ist ein Fork, der sich aus technischen oder persönlichen Meinungsverschiedenheiten ergibt, häufig eine Verschwendung menschlicher Ressourcen; eine andere Lösung wäre vorzuziehen. Auch der Zusammenschluss zweier Vorhaben, die früher durch einen Fork gegangen sind, ist nicht gänzlich unbekannt.
			</para>
			 </sidebar> <para>
				OpenSSH ist in zwei Pakete aufgeteilt: der Client-Teil befindet sich im Paket <emphasis role="pkg">openssh-client</emphasis> und der Server-Teil im Paket <emphasis role="pkg">openssh-server</emphasis>. Das Metapaket <emphasis role="pkg">ssh</emphasis> ist von beiden Teilen abhängig und erleichtert die Installation beider (<command>apt install ssh</command>).
			</para>
			 <section id="sect.ssh-key-based-auth">
				<title>Schlüsselbasierte Authentifizierung</title>
				 <para>
					Jedes Mal, wenn sich jemand über SSH anmeldet, fragt der entfernte Server nach einem Passwort zur Authentifizierung des Benutzers. Dies kann problematisch sein, wenn man eine Verbindung automatisieren möchte, oder wenn man ein Hilfsprogramm verwendet, das häufige Verbindungen über SSH benötigt. Daher bietet SSH ein schlüsselbasiertes Authentifizierungssystem.
				</para>
				 <para>
					Der Benutzer erzeugt auf dem Client-Rechner mit dem Befehl <command>ssh-keygen -t rsa</command> ein neues Schlüsselpaar; der öffentliche Schlüssel wird in der Datei <filename>~/.ssh/id_rsa.pub</filename> gespeichert und der dazugehörige private Schlüssel in <filename>~/.ssh/id_rsa</filename>. Der Benutzer verwendet dann den Befehl <command>ssh-copy-id <replaceable>server</replaceable></command>, um seinen öffentlichen Schlüssel auf dem Server zur Datei <filename>~/.ssh/authorized_keys</filename> hinzuzufügen. Falls der private Schlüssel zur Zeit seiner Erzeugung nicht mit einer „Passphrase“ geschützt wurde, funktionieren alle nachfolgenden Anmeldungen auf dem Server ohne Eingabe eines Passworts. Anderenfalls muss der private Schlüssel jedes Mal erneut unter Eingabe der Passphrase entschlüsselt werden. Glücklicherweise ermöglicht es das Programm <command>ssh-agent</command>, private Schlüssel im Speicher zu halten, so dass das Passwort nicht ständig neu eingegeben werden muss. Hierzu verwendet man einfach (einmal pro Sitzung) den Befehl <command>ssh-add</command>, wobei Voraussetzung ist, dass die Sitzung bereits einer funktionsfähigen Instanz von <command>ssh-agent</command> zugeordnet ist. Debian aktiviert dieses Programm standardmäßig beim Start einer grafischen Sitzung, es kann jedoch durch eine Änderung der Datei <filename>/etc/X11/Xsession.options</filename> deaktiviert sein. In einer Konsolensitzung kann es manuell mit dem Befehl <command>eval $(ssh-agent)</command> gestartet werden.
				</para>
				 <sidebar> <title><emphasis>SICHERHEIT</emphasis> Schutz des privaten Schlüssels</title>
				 <para>
					Wer im Besitz des privaten Schlüssels ist, kann sich mit dem entsprechend konfigurierten Konto anmelden. Daher ist der Zugriff auf den privaten Schlüssel durch eine „Passphrase“ geschützt. Selbst wenn jemand in den Besitz eines privaten Schlüssels gelangt (zum Beispiel die Datei <filename>~/.ssh/id_rsa</filename>), muss er zusätzlich noch diese Phrase kennen, um ihn verwenden zu können. Dieser zusätzliche Schutz ist jedoch nicht unüberwindlich, und wenn Sie denken, dass die Sicherheit dieser Datei nicht mehr gewährleistet ist, sollten Sie diesen Schlüssel auf den Rechnern, auf denen er installiert wurde, deaktivieren (indem Sie ihn aus <filename>authorized_keys</filename> entfernen) und durch einen neu erzeugten Schlüssel ersetzen.
				</para>
				 </sidebar> <sidebar> <title><emphasis>KULTUR</emphasis> OpenSSL-Schwachstelle in Debian <emphasis role="distribution">Etch</emphasis></title>
				 <para>
					Die OpenSSL-Bibliothek, die ursprünglich mit Debian <emphasis role="distribution">Etch</emphasis> bereitgestellt wurde, hatte ein gravierendes Problem in ihrem Zufallszahlengenerator (RNG). In der Tat hatte der zuständige Debian-Betreuer eine Änderung vorgenommen, damit Anwendungen, die ihn verwenden, keine Warnmeldungen mehr verursachen, wenn sie von Werkzeugen für das Memory Management wie zum Beispiel <command>valgrind</command> analysiert werden. Leider hatte diese Änderung auch zur Folge, dass der Zufallszahlengenerator nur eine Entropie-Quelle in Abhängigkeit von der Prozesskennung (PID) benutzte, deren 32.000 mögliche Werte keinen ausreichenden Grad an Zufälligkeit boten. <ulink type="block" url="http://www.debian.org/security/2008/dsa-1571" />
				</para>
				 <para>
					Insbesondere, wenn OpenSSL benutzt wurde, um einen Schlüssel zu erzeugen, wurde dieser immer aus einem Satz einiger hunderttausend Schlüssel erstellt (32.000 multipliziert mit einer kleinen Zahl von Schlüssellängen). Hiervon waren SSH-Schlüssel, SSL-Schlüssel und von zahlreichen Anwendungen, wie zum Beispiel OpenVPN, verwendete X.509-Zertifikate betroffen. Ein Eindringling brauchte nur alle Schlüssel auszuprobieren, um unberechtigten Zugriff zu erlangen. Um die Auswirkung des Problems einzuschränken, wurde der SSH-Daemon dahingehend verändert, dass er zweifelhafte Schlüssel, die in den Paketen <emphasis role="pkg">openssh-blacklist</emphasis> und <emphasis role="pkg">openssh-blacklist-extra</emphasis> aufgelistet sind, zurückweist. Darüber hinaus ermöglicht es der Befehl <command>ssh-vulnkey</command>, möglicherweise gefährdete Schlüssel im System zu identifizieren.
				</para>
				 <para>
					A more thorough analysis of this incident brings to light that it is the result of multiple (small) problems, both within the OpenSSL project and with the Debian package maintainer. A widely used library like OpenSSL should — without modifications — not generate warnings when tested by <command>valgrind</command>. Furthermore, the code (especially the parts as sensitive as the RNG) should be better commented to prevent such errors. On Debian's side, the maintainer wanted to validate the modifications with the OpenSSL developers, but simply explained the modifications without providing the corresponding patch to review and failed to mention his role within Debian. Finally, the maintenance choices were sub-optimal: the changes made to the original code were not clearly documented; all the modifications were effectively stored in a Subversion repository, but they ended up all lumped into one single patch during creation of the source package.
				</para>
				 <para>
					It is difficult under such conditions to find the corrective measures to prevent such incidents from recurring. The lesson to be learned here is that every divergence Debian introduces to upstream software must be justified, documented, submitted to the upstream project when possible, and widely publicized. It is from this perspective that the new source package format (“3.0 (quilt)”) and the Debian sources webservice were developed. <ulink type="block" url="http://sources.debian.org" />
				</para>
				 </sidebar>
			</section>
			 <section id="sect.ssh-x11">
				<title>Entfernte X11-Anwendungen benutzen</title>
				 <para>
					Das SSH-Protokoll ermöglicht die Weiterleitung grafischer Daten („X11“-Sitzung, nach dem Namen des am weitesten verbreiteten grafischen Systems in Unix); der Server stellt hierbei einen besonderen Kanal für diese Daten bereit. Konkret bedeutet dies, dass ein aus der Ferne ausgeführtes, grafisches Programm vom X.org-Server auf dem lokalen Bildschirm dargestellt werden kann, und dass die gesamte Sitzung (Eingabe und Anzeige) abgesichert ist. Da entfernte Anwendungen durch diese Funktion das lokale System beeinträchtigen können, ist sie standardmäßig deaktiviert. Sie kann aktiviert werden, indem man in der Serverkonfigurationsdatei (<filename>/etc/ssh/sshd_config</filename>) die Option <literal>X11Forwarding yes</literal> einstellt. Schließlich muss der Benutzer diese Funktion anfordern, indem er die Option <literal>-X</literal> zur Befehlszeile <command>ssh</command> hinzufügt.
				</para>

			</section>
			 <section id="sect.ssh-port-forwarding">
				<title>Verschlüsselte Tunnel mit Port-Weiterleitung einrichten</title>
				 <indexterm>
					<primary>Port-Weiterleitung</primary>
				</indexterm>
				 <para>
					Die Optionen <literal>-R</literal> und <literal>-L</literal> des Befehls <command>ssh</command> ermöglichen es, „verschlüsselte Tunnel“ zwischen zwei Rechnern zu erstellen, und so einen lokalen TCP-Port (siehe <xref linkend="sidebar.tcp-udp" /> in der Seitenleiste) sicher an einen entfernten Rechner weiterzuleiten und umgekehrt.
				</para>
				 <sidebar> <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Tunnel</title>
				 <indexterm>
					<primary>Tunnel (SSH)</primary>
					<seealso>VPN</seealso>
				</indexterm>
				 <indexterm>
					<primary>SSH-Tunnel</primary>
					<seealso>VPN</seealso>
				</indexterm>
				 <para>
					Das Internet und die meisten mit ihm verbundenen LANs arbeiten im Paket-Modus und nicht in einem fest geschalteten Modus. Das heißt, dass ein Paket, das von einem Rechner zu einem anderen verschickt wird, auf dem Weg zu seinem Ziel an mehreren dazwischenliegenden Routern angehalten wird. Dennoch kann man einen fest geschalteten Betrieb nachahmen, indem der Datenstrom in normale IP-Pakete eingeschlossen wird. Diese Pakete laufen über ihren üblichen Weg, jedoch wird der Datenstrom am Ziel dann unverändert rekonstruiert. Man nennt dies einen „Tunnel“ in Analogie zu einem Straßentunnel, bei dem Fahrzeuge direkt vom Eingang (Eingabe) zum Ausgang (Ausgabe) fahren, ohne auf irgendwelche Kreuzungen zu stoßen, im Gegensatz zu einem Weg an der Oberfläche, bei dem es Kreuzungen und Richtungswechsel gibt.
				</para>
				 <para>
					Man kann bei dieser Gelegenheit den Tunnel verschlüsseln: der Datenstrom, der durch ihn hindurchläuft, ist dann von außen unkenntlich, wird aber am Tunnelausgang wieder in eine unverschlüsselte Form zurückgeführt.
				</para>
				 </sidebar> <para>
					<command>ssh -L 8000:server:25 intermediary</command> eröffnet eine SSH-Sitzung mit dem Host <replaceable>intermediary</replaceable> und nimmt am lokalen Port 8000 Verbindungen an (siehe <xref linkend="figure.ssh-L" />). Für jede Verbindung, die zu diesem Port hergestellt wird, baut <command>ssh</command> eine Verbindung vom Rechner <replaceable>intermediary</replaceable> zum Port 25 des <replaceable>server</replaceable> auf und verknüpft beide Verbindungen.
				</para>
				 <para>
					<command>ssh -R 8000:server:25 intermediary</command> eröffnet auch eine SSH-Sitzung zum Rechner <replaceable>intermediary</replaceable>, aber <command>ssh</command> nimmt dann auf diesem Rechner an Port 8000 Verbindungen an (siehe <xref linkend="figure.ssh-R" />). Jede Verbindung, die an diesem Port hergestellt wird, veranlasst <command>ssh</command>, eine Verbindung vom lokalen Rechner zum Port 25 des <replaceable>server</replaceable> zu öffnen und beide Verbindungen miteinander zu verknüpfen.
				</para>
				 <para>
					In both cases, connections are made to port 25 on the <replaceable>server</replaceable> host, which pass through the SSH tunnel established between the local machine and the <replaceable>intermediary</replaceable> machine. In the first case, the entrance to the tunnel is local port 8000, and the data move towards the <replaceable>intermediary</replaceable> machine before being directed to the <replaceable>server</replaceable> on the “public” network. In the second case, the input and output in the tunnel are reversed; the entrance is port 8000 on the <replaceable>intermediary</replaceable> machine, the output is on the local host, and the data are then directed to the <replaceable>server</replaceable>. In practice, the server is usually either the local machine or the intermediary. That way SSH secures the connection from one end to the other.
				</para>
				 <figure id="figure.ssh-L">
					<title>Forwarding a local port with SSH</title>
					 <mediaobject>
						<imageobject>
							<imagedata fileref="images/ssh-L.png" format="PNG" width="35%" />
						</imageobject>

					</mediaobject>

				</figure>
				 <figure id="figure.ssh-R">
					<title>Forwarding a remote port with SSH</title>
					 <mediaobject>
						<imageobject>
							<imagedata fileref="images/ssh-R.png" format="PNG" width="35%" />
						</imageobject>

					</mediaobject>

				</figure>

			</section>

		</section>
		 <section id="sect.remote-desktops">
			<title>Using Remote Graphical Desktops</title>
			 <para>
				VNC (Virtual Network Computing) allows remote access to graphical desktops.
			</para>
			 <indexterm>
				<primary>VNC</primary>
			</indexterm>
			 <indexterm>
				<primary>Virtual Network Computing</primary>
			</indexterm>
			 <indexterm>
				<primary>graphical desktop</primary>
				<secondary>remote</secondary>
			</indexterm>
			 <indexterm>
				<primary>remote graphical desktop</primary>
			</indexterm>
			 <indexterm>
				<primary>desktop, remote graphical desktop</primary>
			</indexterm>
			 <para>
				This tool is mostly used for technical assistance; the administrator can see the errors that the user is facing, and show them the correct course of action without having to stand by them.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vino</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">krfb</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">x11vnc</emphasis></primary>
			</indexterm>
			 <para>
				First, the user must authorize sharing their session. The GNOME graphical desktop environment in <emphasis role="distribution">Jessie</emphasis> includes that option in its configuration panel (contrary to previous versions of Debian, where the user had to install and run <command>vino</command>). KDE still requires using <command>krfb</command> to allow sharing an existing session over VNC. For other graphical desktop environments, the <command>x11vnc</command> command (from the Debian package of the same name) serves the same purpose; you can make it available to the user with an explicit icon.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vinagre</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">tsclient</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">krdc</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">xvnc4viewer</emphasis></primary>
			</indexterm>
			 <para>
				When the graphical session is made available by VNC, the administrator must connect to it with a VNC client. GNOME has <command>vinagre</command> and <command>remmina</command> for that, while KDE includes <command>krdc</command> (in the menu at <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). There are other VNC clients that use the command line, such as <command>xvnc4viewer</command> in the Debian package of the same name. Once connected, the administrator can see what is going on, work on the machine remotely, and show the user how to proceed.
			</para>
			 <sidebar> <title><emphasis>SECURITY</emphasis> VNC over SSH</title>
			 <indexterm>
				<primary>SSH tunnel</primary>
				<secondary>VNC</secondary>
			</indexterm>
			 <para>
				If you want to connect by VNC, and you don't want your data sent in clear text on the network, it is possible to encapsulate the data in an SSH tunnel (see <xref linkend="sect.ssh-port-forwarding" />). You simply have to know that VNC uses port 5900 by default for the first screen (called “localhost:0”), 5901 for the second (called “localhost:1”), etc.
			</para>
			 <para>
				The <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command> command creates a tunnel between local port 5901 in the localhost interface and port 5900 of the <replaceable>machine</replaceable> host. The first “localhost” restricts SSH to listening to only that interface on the local machine. The second “localhost” indicates the interface on the remote machine which will receive the network traffic entering in “localhost:5901”. Thus <command>vncviewer localhost:1</command> will connect the VNC client to the remote screen, even though you indicate the name of the local machine.
			</para>
			 <para>
				When the VNC session is closed, remember to close the tunnel by also quitting the corresponding SSH session.
			</para>
			 </sidebar> <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Display manager</title>
			 <indexterm>
				<primary><command>gdm3</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>kdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>xdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>lightdm</command></primary>
			</indexterm>
			 <indexterm>
				<primary>manager</primary>
				<secondary>display manager</secondary>
			</indexterm>
			 <indexterm>
				<primary>display manager</primary>
			</indexterm>
			 <para>
				<command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, and <command>xdm</command> are Display Managers. They take control of the graphical interface shortly after boot in order to provide the user a login screen. Once the user has logged in, they execute the programs needed to start a graphical work session.
			</para>
			 </sidebar> <para>
				VNC also works for mobile users, or company executives, who occasionally need to login from their home to access a remote desktop similar to the one they use at work. The configuration of such a service is more complicated: you first install the <emphasis role="pkg">vnc4server</emphasis> package, change the configuration of the display manager to accept <literal>XDMCP Query</literal> requests (for <command>gdm3</command>, this can be done by adding <literal>Enable=true</literal> in the “xdmcp” section of <filename>/etc/gdm3/daemon.conf</filename>), and finally, start the VNC server with <command>inetd</command> so that a session is automatically started when a user tries to login. For example, you may add this line to <filename>/etc/inetd.conf</filename>:
			</para>
			 
<programlisting>5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none
</programlisting>
			 <para>
				Redirecting incoming connections to the display manager solves the problem of authentication, because only users with local accounts will pass the <command>gdm3</command> login screen (or equivalent <command>kdm</command>, <command>xdm</command>, etc.). As this operation allows multiple simultaneous logins without any problem (provided the server is powerful enough), it can even be used to provide complete desktops for mobile users (or for less powerful desktop systems, configured as thin clients). Users simply login to the server's screen with <command>vncviewer <replaceable>server</replaceable>:50</command>, because the port used is 5950.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">vnc4server</emphasis></primary>
			</indexterm>

		</section>

	</section>
	 <section id="sect.rights-management">
		<title>Managing Rights</title>
		 <para>
			Linux is definitely a multi-user system, so it is necessary to provide a permission system to control the set of authorized operations on files and directories, which includes all the system resources and devices (on a Unix system, any device is represented by a file or directory). This principle is common to all Unix systems, but a reminder is always useful, especially as there are some interesting and relatively unknown advanced uses.
		</para>
		 <indexterm>
			<primary>rights</primary>
		</indexterm>
		 <indexterm>
			<primary>permissions</primary>
		</indexterm>
		 <indexterm>
			<primary>user</primary>
			<secondary>owner</secondary>
		</indexterm>
		 <indexterm>
			<primary>group</primary>
			<secondary>owner</secondary>
		</indexterm>
		 <indexterm>
			<primary>owner</primary>
			<secondary>user</secondary>
		</indexterm>
		 <indexterm>
			<primary>owner</primary>
			<secondary>group</secondary>
		</indexterm>
		 <para>
			Each file or directory has specific permissions for three categories of users:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					its owner (symbolized by <literal>u</literal> as in “user”);
				</para>

			</listitem>
			 <listitem>
				<para>
					its owner group (symbolized by <literal>g</literal> as in “group”), representing all the members of the group;
				</para>

			</listitem>
			 <listitem>
				<para>
					the others (symbolized by <literal>o</literal> as in “other”).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Three types of rights can be combined:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					reading (symbolized by <literal>r</literal> as in “read”);
				</para>

			</listitem>
			 <listitem>
				<para>
					writing (or modifying, symbolized by <literal>w</literal> as in “write”);
				</para>

			</listitem>
			 <listitem>
				<para>
					executing (symbolized by <literal>x</literal> as in “eXecute”).
				</para>

			</listitem>

		</itemizedlist>
		 <indexterm>
			<primary>read, right</primary>
		</indexterm>
		 <indexterm>
			<primary>write, right</primary>
		</indexterm>
		 <indexterm>
			<primary>modification, right</primary>
		</indexterm>
		 <indexterm>
			<primary>execution, right</primary>
		</indexterm>
		 <para>
			In the case of a file, these rights are easily understood: read access allows reading the content (including copying), write access allows changing it, and execute access allows you to run it (which will only work if it is a program).
		</para>
		 <sidebar> <title><emphasis>SECURITY</emphasis> <literal>setuid</literal> and <literal>setgid</literal> executables</title>
		 <para>
			Two particular rights are relevant to executable files: <literal>setuid</literal> and <literal>setgid</literal> (symbolized with the letter “s”). Note that we frequently speak of “bit”, since each of these boolean values can be represented by a 0 or a 1. These two rights allow any user to execute the program with the rights of the owner or the group, respectively. This mechanism grants access to features requiring higher level permissions than those you would usually have.
		</para>
		 <indexterm>
			<primary><literal>setuid</literal>, right</primary>
		</indexterm>
		 <indexterm>
			<primary><literal>setgid</literal>, right</primary>
		</indexterm>
		 <para>
			Since a <literal>setuid</literal> root program is systematically run under the super-user identity, it is very important to ensure it is secure and reliable. Indeed, a user who would manage to subvert it to call a command of their choice could then impersonate the root user and have all rights on the system.
		</para>
		 </sidebar> <para>
			A directory is handled differently. Read access gives the right to consult the list of its entries (files and directories), write access allows creating or deleting files, and execute access allows crossing through it (especially to go there with the <command>cd</command> command). Being able to cross through a directory without being able to read it gives permission to access the entries therein that are known by name, but not to find them if you do not know their existence or their exact name.
		</para>
		 <sidebar id="sidebar.setgid-dir"> <title><emphasis>SECURITY</emphasis> <literal>setgid</literal> directory and <emphasis>sticky bit</emphasis></title>
		 <indexterm>
			<primary><literal>setgid</literal> directory</primary>
		</indexterm>
		 <para>
			The <literal>setgid</literal> bit also applies to directories. Any newly-created item in such directories is automatically assigned the owner group of the parent directory, instead of inheriting the creator's main group as usual. This setup avoids the user having to change its main group (with the <command>newgrp</command> command) when working in a file tree shared between several users of the same dedicated group.
		</para>
		 <indexterm>
			<primary>sticky bit</primary>
		</indexterm>
		 <para>
			The “sticky” bit (symbolized by the letter “t”) is a permission that is only useful in directories. It is especially used for temporary directories where everybody has write access (such as <filename>/tmp/</filename>): it restricts deletion of files so that only their owner (or the owner of the parent directory) can do it. Lacking this, everyone could delete other users' files in <filename>/tmp/</filename>.
		</para>
		 </sidebar> <para>
			Three commands control the permissions associated with a file:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					<command>chown <replaceable>user</replaceable> <replaceable>file</replaceable></command> changes the owner of the file;
				</para>

			</listitem>
			 <listitem>
				<para>
					<command>chgrp <replaceable>group</replaceable> <replaceable>file</replaceable></command> alters the owner group;
				</para>

			</listitem>
			 <listitem>
				<para>
					<command>chmod <replaceable>rights</replaceable> <replaceable>file</replaceable></command> changes the permissions for the file.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			There are two ways of presenting rights. Among them, the symbolic representation is probably the easiest to understand and remember. It involves the letter symbols mentioned above. You can define rights for each category of users (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), by setting them explicitly (with <literal>=</literal>), by adding (<literal>+</literal>), or subtracting (<literal>-</literal>). Thus the <literal>u=rwx,g+rw,o-r</literal> formula gives the owner read, write, and execute rights, adds read and write rights for the owner group, and removes read rights for other users. Rights not altered by the addition or subtraction in such a command remain unmodified. The letter <literal>a</literal>, for “all”, covers all three categories of users, so that <literal>a=rx</literal> grants all three categories the same rights (read and execute, but not write).
		</para>
		 <indexterm>
			<primary><command>chmod</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>chown</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>chgrp</command></primary>
		</indexterm>
		 <indexterm>
			<primary>octal representation of rights</primary>
		</indexterm>
		 <indexterm>
			<primary>rights</primary>
			<secondary>octal representation</secondary>
		</indexterm>
		 <para>
			The (octal) numeric representation associates each right with a value: 4 for read, 2 for write, and 1 for execute. We associate each combination of rights with the sum of the figures. Each value is then assigned to different categories of users by putting them end to end in the usual order (owner, group, others).
		</para>
		 <para>
			For instance, the <command>chmod 754 <replaceable>file</replaceable></command> command will set the following rights: read, write and execute for the owner (since 7 = 4 + 2 + 1); read and execute for the group (since 5 = 4 + 1); read-only for others. The <literal>0</literal> means no rights; thus <command>chmod 600 <replaceable>file</replaceable></command> allows for read/write rights for the owner, and no rights for anyone else. The most frequent right combinations are <literal>755</literal> for executable files and directories, and <literal>644</literal> for data files.
		</para>
		 <para>
			To represent special rights, you can prefix a fourth digit to this number according to the same principle, where the <literal>setuid</literal>, <literal>setgid</literal> and <literal>sticky</literal> bits are 4, 2 and 1, respectively. <command>chmod 4754</command> will associate the <literal>setuid</literal> bit with the previously described rights.
		</para>
		 <para>
			Note that the use of octal notation only allows to set all the rights at once on a file; you cannot use it to simply add a new right, such as read access for the group owner, since you must take into account the existing rights and compute the new corresponding numerical value.
		</para>
		 <sidebar> <title><emphasis>TIP</emphasis> Recursive operation</title>
		 <para>
			Sometimes we have to change rights for an entire file tree. All the commands above have a <literal>-R</literal> option to operate recursively in sub-directories.
		</para>
		 <para>
			The distinction between directories and files sometimes causes problems with recursive operations. That is why the “X” letter has been introduced in the symbolic representation of rights. It represents a right to execute which applies only to directories (and not to files lacking this right). Thus, <command>chmod -R a+X <replaceable>directory</replaceable></command> will only add execute rights for all categories of users (<literal>a</literal>) for all of the sub-directories and files for which at least one category of user (even if their sole owner) already has execute rights.
		</para>
		 </sidebar> <sidebar> <title><emphasis>TIP</emphasis> Changing the user and group</title>
		 <para>
			Frequently you want to change the group of a file at the same time that you change the owner. The <command>chown</command> command has a special syntax for that: <command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command>
		</para>
		 </sidebar> <sidebar> <title><emphasis>GOING FURTHER</emphasis> <command>umask</command></title>
		 <para>
			When an application creates a file, it assigns indicative permissions, knowing that the system automatically removes certain rights, given by the command <command>umask</command>. Enter <command>umask</command> in a shell; you will see a mask such as <computeroutput>0022</computeroutput>. This is simply an octal representation of the rights to be systematically removed (in this case, the write right for the group and other users).
		</para>
		 <indexterm>
			<primary>umask</primary>
		</indexterm>
		 <indexterm>
			<primary>rights</primary>
			<secondary>mask</secondary>
		</indexterm>
		 <indexterm>
			<primary>mask</primary>
			<secondary>rights mask</secondary>
		</indexterm>
		 <para>
			If you give it a new octal value, the <command>umask</command> command modifies the mask. Used in a shell initialization file (for example, <filename>~/.bash_profile</filename>), it will effectively change the default mask for your work sessions.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.administration-interfaces">
		<title>Administration Interfaces</title>
		 <indexterm>
			<primary>interface</primary>
			<secondary>administration interface</secondary>
		</indexterm>
		 <indexterm>
			<primary>administration, interfaces</primary>
		</indexterm>
		 <para>
			Using a graphical interface for administration is interesting in various circumstances. An administrator does not necessarily know all the configuration details for all their services, and doesn't always have the time to go seeking out the documentation on the matter. A graphical interface for administration can thus accelerate the deployment of a new service. It can also simplify the setup of services which are hard to configure.
		</para>
		 <para>
			Such an interface is only an aid, and not an end in itself. In all cases, the administrator must master its behavior in order to understand and work around any potential problem.
		</para>
		 <para>
			Since no interface is perfect, you may be tempted to try several solutions. This is to be avoided as much as possible, since different tools are sometimes incompatible in their work methods. Even if they all aim to be very flexible and try to adopt the configuration file as a single reference, they are not always able to integrate external changes.
		</para>
		 <section id="sect.webmin">
			<title>Administrating on a Web Interface: <command>webmin</command></title>
			 <indexterm>
				<primary><emphasis>webmin</emphasis></primary>
			</indexterm>
			 <para>
				This is, without a doubt, one of the most successful administration interfaces. It is a modular system managed through a web browser, covering a wide array of areas and tools. Furthermore, it is internationalized and available in many languages.
			</para>
			 <para>
				Sadly, <command>webmin</command> is no longer part of Debian. Its Debian maintainer — Jaldhar H. Vyas — removed the packages he created because he no longer had the time required to maintain them at an acceptable quality level. Nobody has officially taken over, so <emphasis role="distribution">Jessie</emphasis> does not have the <command>webmin</command> package.
			</para>
			 <para>
				There is, however, an unofficial package distributed on the <literal>webmin.com</literal> website. Contrary to the original Debian packages, this package is monolithic; all of its configuration modules are installed and activated by default, even if the corresponding service is not installed on the machine.
			</para>
			 <sidebar> <title><emphasis>SECURITY</emphasis> Changing the root password</title>
			 <para>
				On the first login, identification is conducted with the root username and its usual password. It is recommended to change the password used for <command>webmin</command> as soon as possible, so that if it is compromised, the root password for the server will not be involved, even if this confers important administrative rights to the machine.
			</para>
			 <para>
				Beware! Since <command>webmin</command> has so many features, a malicious user accessing it could compromise the security of the entire system. In general, interfaces of this kind are not recommended for important systems with strong security constraints (firewall, sensitive servers, etc.).
			</para>
			 </sidebar> <para>
				Webmin is used through a web interface, but it does not require Apache to be installed. Essentially, this software has its own integrated mini web server. This server listens by default on port 10000 and accepts secure HTTP connections.
			</para>
			 <para>
				Included modules cover a wide variety of services, among which:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						all base services: creation of users and groups, management of <filename>crontab</filename> files, init scripts, viewing of logs, etc.
					</para>

				</listitem>
				 <listitem>
					<para>
						bind: DNS server configuration (name service);
					</para>

				</listitem>
				 <listitem>
					<para>
						postfix: SMTP server configuration (e-mail);
					</para>

				</listitem>
				 <listitem>
					<para>
						inetd: configuration of the <command>inetd</command> super-server;
					</para>

				</listitem>
				 <listitem>
					<para>
						quota: user quota management;
					</para>

				</listitem>
				 <listitem>
					<para>
						dhcpd: DHCP server configuration;
					</para>

				</listitem>
				 <listitem>
					<para>
						proftpd: FTP server configuration;
					</para>

				</listitem>
				 <listitem>
					<para>
						samba: Samba file server configuration;
					</para>

				</listitem>
				 <listitem>
					<para>
						software: installation or removal of software from Debian packages and system updates.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				The administration interface is available in a web browser at <literal>https://localhost:10000</literal>. Beware! Not all the modules are directly usable. Sometimes they must be configured by specifying the locations of the corresponding configuration files and some executable files (program). Frequently the system will politely prompt you when it fails to activate a requested module.
			</para>
			 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> GNOME control center</title>
			 <indexterm>
				<primary><emphasis role="pkg">gnome-control-center</emphasis></primary>
			</indexterm>
			 <para>
				The GNOME project also provides multiple administration interfaces that are usually accessible via the “Settings” entry in the user menu on the top right. <command>gnome-control-center</command> is the main program that brings them all together but many of the system wide configuration tools are effectively provided by other packages (<emphasis role="pkg">accountsservice</emphasis>, <emphasis role="pkg">system-config-printer</emphasis>, etc.). Although they are easy to use, these applications cover only a limited number of base services: user management, time configuration, network configuration, printer configuration, and so on.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.debconf">
			<title>Configuring Packages: <command>debconf</command></title>
			 <indexterm>
				<primary><command>debconf</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>dpkg-reconfigure</command></primary>
			</indexterm>
			 <para>
				Many packages are automatically configured after asking a few questions during installation through the Debconf tool. These packages can be reconfigured by running <command>dpkg-reconfigure <replaceable>package</replaceable></command>.
			</para>
			 <para>
				For most cases, these settings are very simple; only a few important variables in the configuration file are changed. These variables are often grouped between two “demarcation” lines so that reconfiguration of the package only impacts the enclosed area. In other cases, reconfiguration will not change anything if the script detects a manual modification of the configuration file, in order to preserve these human interventions (because the script can't ensure that its own modifications will not disrupt the existing settings).
			</para>
			 <sidebar> <title><emphasis>DEBIAN POLICY</emphasis> Preserving changes</title>
			 <para>
				The Debian Policy expressly stipulates that everything should be done to preserve manual changes made to a configuration file, so more and more scripts take precautions when editing configuration files. The general principle is simple: the script will only make changes if it knows the status of the configuration file, which is verified by comparing the checksum of the file against that of the last automatically generated file. If they are the same, the script is authorized to change the configuration file. Otherwise, it determines that the file has been changed and asks what action it should take (install the new file, save the old file, or try to integrate the new changes with the existing file). This precautionary principle has long been unique to Debian, but other distributions have gradually begun to embrace it.
			</para>
			 <para>
				The <command>ucf</command> program (from the Debian package of the same name) can be used to implement such a behavior.
			</para>
			 <indexterm>
				<primary><command>ucf</command></primary>
			</indexterm>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.syslog">
		<title><command>syslog</command> System Events</title>
		 <indexterm>
			<primary><command>rsyslogd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>files</primary>
			<secondary>log files</secondary>
		</indexterm>
		 <indexterm>
			<primary>logs</primary>
			<secondary>dispatching</secondary>
		</indexterm>
		 <section id="sect.syslog-principe">
			<title>Principle and Mechanism</title>
			 <para>
				The <command>rsyslogd</command> daemon is responsible for collecting service messages coming from applications and the kernel, then dispatching them into log files (usually stored in the <filename>/var/log/</filename> directory). It obeys the <filename>/etc/rsyslog.conf</filename> configuration file.
			</para>
			 <para>
				Each log message is associated with an application subsystem (called “facility” in the documentation):
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>auth</literal> and <literal>authpriv</literal>: for authentication;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>cron</literal>: comes from task scheduling services, <command>cron</command> and <command>atd</command>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>daemon</literal>: affects a daemon without any special classification (DNS, NTP, etc.);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ftp</literal>: concerns the FTP server;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>kern</literal>: message coming from the kernel;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>lpr</literal>: comes from the printing subsystem;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>mail</literal>: comes from the e-mail subsystem;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>news</literal>: Usenet subsystem message (especially from an NNTP — Network News Transfer Protocol — server that manages newsgroups);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>syslog</literal>: messages from the <command>syslogd</command> server, itself;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>user</literal>: user messages (generic);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uucp</literal>: messages from the UUCP server (Unix to Unix Copy Program, an old protocol notably used to distribute e-mail messages);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>local0</literal> to <literal>local7</literal>: reserved for local use.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Each message is also associated with a priority level. Here is the list in decreasing order:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>emerg</literal>: “Help!” There is an emergency, the system is probably unusable.
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>alert</literal>: hurry up, any delay can be dangerous, action must be taken immediately;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>crit</literal>: conditions are critical;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>err</literal>: error;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>warn</literal>: warning (potential error);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>notice</literal>: conditions are normal, but the message is important;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>info</literal>: informative message;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>debug</literal>: debugging message.
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section id="sect.syslog-config">
			<title>The Configuration File</title>
			 <para>
				The syntax of the <filename>/etc/rsyslog.conf</filename> file is detailed in the <citerefentry><refentrytitle>rsyslog.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> manual page, but there is also HTML documentation available in the <emphasis role="pkg">rsyslog-doc</emphasis> package (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). The overall principle is to write “selector” and “action” pairs. The selector defines all relevant messages, and the actions describes how to deal with them.
			</para>
			 <section id="sect.syslog-selector-syntax">
				<title>Syntax of the Selector</title>
				 <para>
					The selector is a semicolon-separated list of <literal><replaceable>subsystem</replaceable>.<replaceable>priority</replaceable></literal> pairs (example: <literal>auth.notice;mail.info</literal>). An asterisk may represent all subsystems or all priorities (examples: <literal>*.alert</literal> or <literal>mail.*</literal>). Several subsystems can be grouped, by separating them with a comma (example: <literal>auth,mail.info</literal>). The priority indicated also covers messages of equal or higher priority; thus <literal>auth.alert</literal> indicates the <literal>auth</literal> subsystem messages of <literal>alert</literal> or <literal>emerg</literal> priority. Prefixed with an exclamation point (!), it indicates the opposite, in other words the strictly lower priorities; <literal>auth.!notice</literal>, thus, indicates messages issued from <literal>auth</literal>, with <literal>info</literal> or <literal>debug</literal> priority. Prefixed with an equal sign (=), it corresponds to precisely and only the priority indicated (<literal>auth.=notice</literal> only concerns messages from <literal>auth</literal> with <literal>notice</literal> priority).
				</para>
				 <para>
					Each element in the list on the selector overrides previous elements. It is thus possible to restrict a set or to exclude certain elements from it. For example, <literal>kern.info;kern.!err</literal> means messages from the kernel with priority between <literal>info</literal> and <literal>warn</literal>. The <literal>none</literal> priority indicates the empty set (no priorities), and may serve to exclude a subsystem from a set of messages. Thus, <literal>*.crit;kern.none</literal> indicates all the messages of priority equal to or higher than <literal>crit</literal> not coming from the kernel.
				</para>

			</section>
			 <section id="sect.syslog-action-syntax">
				<title>Syntax of Actions</title>
				 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> The named pipe, a persistent pipe</title>
				 <indexterm>
					<primary>named pipe</primary>
				</indexterm>
				 <indexterm>
					<primary>pipe, named pipe</primary>
				</indexterm>
				 <para>
					A named pipe is a particular type of file that operates like a traditional pipe (the pipe that you make with the “|” symbol on the command line), but via a file. This mechanism has the advantage of being able to relate two unrelated processes. Anything written to a named pipe blocks the process that writes until another process attempts to read the data written. This second process reads the data written by the first, which can then resume execution.
				</para>
				 <para>
					Such a file is created with the <command>mkfifo</command> command.
				</para>
				 </sidebar> <para>
					The various possible actions are:
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							add the message to a file (example: <filename>/var/log/messages</filename>);
						</para>

					</listitem>
					 <listitem>
						<para>
							send the message to a remote <command>syslog</command> server (example: <literal>@log.falcot.com</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							send the message to an existing named pipe (example: <literal>|/dev/xconsole</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							send the message to one or more users, if they are logged in (example: <literal>root,rhertzog</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							send the message to all logged in users (example: <literal>*</literal>);
						</para>

					</listitem>
					 <listitem>
						<para>
							write the message in a text console (example: <literal>/dev/tty8</literal>).
						</para>

					</listitem>

				</itemizedlist>
				 <sidebar> <title><emphasis>SECURITY</emphasis> Forwarding logs</title>
				 <indexterm>
					<primary>log</primary>
					<secondary>forwarding</secondary>
				</indexterm>
				 <para>
					It is a good idea to record the most important logs on a separate machine (perhaps dedicated for this purpose), since this will prevent any possible intruder from removing traces of their intrusion (unless, of course, they also compromise this other server). Furthermore, in the event of a major problem (such as a kernel crash), you have the logs available on another machine, which increases your chances of determining the sequence of events that caused the crash.
				</para>
				 <para>
					To accept log messages sent by other machines, you must reconfigure <emphasis>rsyslog</emphasis>: in practice, it is sufficient to activate the ready-for-use entries in <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> and <literal>$UDPServerRun 514</literal>).
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.inetd">
		<title>The <command>inetd</command> Super-Server</title>
		 <para>
			Inetd (often called “Internet super-server”) is a server of servers. It executes rarely used servers on demand, so that they do not have to run continuously.
		</para>
		 <indexterm>
			<primary><command>inetd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>super-server</primary>
		</indexterm>
		 <para>
			The <filename>/etc/inetd.conf</filename> file lists these servers and their usual ports. The <command>inetd</command> command listens to all of them; when it detects a connection to any such port, it executes the corresponding server program.
		</para>
		 <sidebar> <title><emphasis>DEBIAN POLICY</emphasis> Register a server in <filename>inetd.conf</filename></title>
		 <para>
			Packages frequently want to register a new server in the <filename>/etc/inetd.conf</filename> file, but Debian Policy prohibits any package from modifying a configuration file that it doesn't own. This is why the <command>update-inetd</command> script (in the package with the same name) was created: It manages the configuration file, and other packages can thus use it to register a new server to the super-server's configuration.
		</para>
		 </sidebar> <para>
			Each significant line of the <filename>/etc/inetd.conf</filename> file describes a server through seven fields (separated by spaces):
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					The TCP or UDP port number, or the service name (which is mapped to a standard port number with the information contained in the <filename>/etc/services</filename> file).
				</para>

			</listitem>
			 <listitem>
				<para>
					The socket type: <literal>stream</literal> for a TCP connection, <literal>dgram</literal> for UDP datagrams.
				</para>

			</listitem>
			 <listitem>
				<para>
					The protocol: <literal>tcp</literal> or <literal>udp</literal>.
				</para>

			</listitem>
			 <listitem>
				<para>
					The options: two possible values: <literal>wait</literal> or <literal>nowait</literal>, to tell <command>inetd</command> whether it should wait or not for the end of the launched process before accepting another connection. For TCP connections, easily multiplexable, you can usually use <literal>nowait</literal>. For programs responding over UDP, you should use <literal>nowait</literal> only if the server is capable of managing several connections in parallel. You can suffix this field with a period, followed by the maximum number of connections authorized per minute (the default limit is 256).
				</para>

			</listitem>
			 <listitem>
				<para>
					The user name of the user under whose identity the server will run.
				</para>

			</listitem>
			 <listitem>
				<para>
					The full path to the server program to execute.
				</para>

			</listitem>
			 <listitem>
				<para>
					The arguments: this is a complete list of the program's arguments, including its own name (<literal>argv[0]</literal> in C).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			The following example illustrates the most common cases:
		</para>
		 <example id="example.inetd-conf">
			<title>Excerpt from <filename>/etc/inetd.conf</filename></title>
			 
<programlisting>talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd
finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd
ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i
</programlisting>

		</example>
		 <indexterm>
			<primary><command>tcpd</command></primary>
		</indexterm>
		 <para>
			The <command>tcpd</command> program is frequently used in the <filename>/etc/inetd.conf</filename> file. It allows limiting incoming connections by applying access control rules, documented in the <citerefentry><refentrytitle>hosts_access</refentrytitle>
			<manvolnum>5</manvolnum></citerefentry> manual page, and which are configured in the <filename>/etc/hosts.allow</filename> and <filename>/etc/hosts.deny</filename> files. Once it has been determined that the connection is authorized, <command>tcpd</command> executes the real server (like <command>in.fingerd</command> in our example). It is worth noting that <command>tcpd</command> relies on the name under which it was invoked (that is the first argument, <literal>argv[0]</literal>) to identify the real program to run. So you should not start the arguments list with <literal>tcpd</literal> but with the program that must be wrapped.
		</para>
		 <sidebar> <title><emphasis>COMMUNITY</emphasis> Wietse Venema</title>
		 <indexterm>
			<primary>Wietse Venema</primary>
		</indexterm>
		 <indexterm>
			<primary>Venema, Wietse</primary>
		</indexterm>
		 <para>
			Wietse Venema, whose expertise in security has made him a renowned programmer, is the author of the <command>tcpd</command> program. He is also the main creator of Postfix, the modular e-mail server (SMTP, Simple Mail Transfer Protocol), designed to be safer and more reliable than <command>sendmail</command>, which features a long history of security vulnerabilities.
		</para>
		 </sidebar> <sidebar> <title><emphasis>ALTERNATIVE</emphasis> Other <command>inetd</command> commands</title>
		 <para>
			While Debian installs <emphasis role="pkg">openbsd-inetd</emphasis> by default, there is no lack of alternatives: we can mention <emphasis role="pkg">inetutils-inetd</emphasis>, <emphasis role="pkg">micro-inetd</emphasis>, <emphasis role="pkg">rlinetd</emphasis> and <emphasis role="pkg">xinetd</emphasis>.
		</para>
		 <para>
			This last incarnation of a super-server offers very interesting possibilities. Most notably, its configuration can be split into several files (stored, of course, in the <filename>/etc/xinetd.d/</filename> directory), which can make an administrator's life easier.
		</para>
		 <para>
			Last but not least, it is even possible to emulate <command>inetd</command>'s behaviour with <command>systemd</command>'s socket-activation mechanism (see <xref linkend="sect.systemd" />).
		</para>
		 </sidebar>
	</section>
	 <section id="sect.task-scheduling-cron-atd">
		<title>Scheduling Tasks with <command>cron</command> and <command>atd</command></title>
		 <indexterm>
			<primary><command>cron</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>atd</command></primary>
		</indexterm>
		 <indexterm>
			<primary>scheduled commands</primary>
		</indexterm>
		 <indexterm>
			<primary>command scheduling</primary>
		</indexterm>
		 <para>
			<command>cron</command> is the daemon responsible for executing scheduled and recurring commands (every day, every week, etc.); <command>atd</command> is that which deals with commands to be executed a single time, but at a specific moment in the future.
		</para>
		 <para>
			In a Unix system, many tasks are scheduled for regular execution:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					rotating the logs;
				</para>

			</listitem>
			 <listitem>
				<para>
					updating the database for the <command>locate</command> program;
				</para>

			</listitem>
			 <listitem>
				<para>
					back-ups;
				</para>

			</listitem>
			 <listitem>
				<para>
					maintenance scripts (such as cleaning out temporary files).
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			By default, all users can schedule the execution of tasks. Each user has thus their own <emphasis>crontab</emphasis> in which they can record scheduled commands. It can be edited by running <command>crontab -e</command> (its content is stored in the <filename>/var/spool/cron/crontabs/<replaceable>user</replaceable></filename> file).
		</para>
		 <sidebar> <title><emphasis>SECURITY</emphasis> Restricting <command>cron</command> or <command>atd</command></title>
		 <para>
			You can restrict access to <command>cron</command> by creating an explicit authorization file (whitelist) in <filename>/etc/cron.allow</filename>, in which you indicate the only users authorized to schedule commands. All others will automatically be deprived of this feature. Conversely, to only block one or two troublemakers, you could write their username in the explicit prohibition file (blacklist), <filename>/etc/cron.deny</filename>. This same feature is available for <command>atd</command>, with the <filename>/etc/at.allow</filename> and <filename>/etc/at.deny</filename> files.
		</para>
		 </sidebar> <para>
			The root user has their own <emphasis>crontab</emphasis>, but can also use the <filename>/etc/crontab</filename> file, or write additional <emphasis>crontab</emphasis> files in the <filename>/etc/cron.d</filename> directory. These last two solutions have the advantage of being able to specify the user identity to use when executing the command.
		</para>
		 <para>
			The <emphasis>cron</emphasis> package includes by default some scheduled commands that execute:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					programs in the <filename>/etc/cron.hourly/</filename> directory once per hour;
				</para>

			</listitem>
			 <listitem>
				<para>
					programs in <filename>/etc/cron.daily/</filename> once per day;
				</para>

			</listitem>
			 <listitem>
				<para>
					programs in <filename>/etc/cron.weekly/</filename> once per week;
				</para>

			</listitem>
			 <listitem>
				<para>
					programs in <filename>/etc/cron.monthly/</filename> once per month.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Many Debian packages rely on this service: by putting maintenance scripts in these directories, they ensure optimal operation of their services.
		</para>
		 <section id="sect.format-crontab">
			<title>Format of a <filename>crontab</filename> File</title>
			 <indexterm>
				<primary><filename>crontab</filename></primary>
			</indexterm>
			 <sidebar> <title><emphasis>TIP</emphasis> Text shortcuts for <command>cron</command></title>
			 <para>
				<command>cron</command> recognizes some abbreviations which replace the first five fields in a <filename>crontab</filename> entry. They correspond to the most classic scheduling options:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>@yearly</literal>: once per year (January 1, at 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@monthly</literal>: once per month (the 1st of the month, at 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@weekly</literal>: once per week (Sunday at 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@daily</literal>: once per day (at 00:00);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>@hourly</literal>: once per hour (at the beginning of each hour).
					</para>

				</listitem>

			</itemizedlist>
			 </sidebar> <sidebar> <title><emphasis>SPECIAL CASE</emphasis> <command>cron</command> and daylight savings time</title>
			 <para>
				In Debian, <command>cron</command> takes the time change (for Daylight Savings Time, or in fact for any significant change in the local time) into account as best as it can. Thus, the commands that should have been executed during an hour that never existed (for example, tasks scheduled at 2:30 am during the Spring time change in France, since at 2:00 am the clock jumps directly to 3:00 am) are executed shortly after the time change (thus around 3:00 am DST). On the other hand, in autumn, when commands would be executed several times (2:30 am DST, then an hour later at 2:30 am standard time, since at 3:00 am DST the clock turns back to 2:00 am) are only executed once.
			</para>
			 <para>
				Be careful, however, if the order in which the different scheduled tasks and the delay between their respective executions matters, you should check the compatibility of these constraints with <command>cron</command>'s behavior; if necessary, you can prepare a special schedule for the two problematic nights per year.
			</para>
			 </sidebar> <para>
				Each significant line of a <emphasis>crontab</emphasis> describes a scheduled command with the six (or seven) following fields:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						the value for the minute (number from 0 to 59);
					</para>

				</listitem>
				 <listitem>
					<para>
						the value for the hour (from 0 to 23);
					</para>

				</listitem>
				 <listitem>
					<para>
						the value for the day of the month (from 1 to 31);
					</para>

				</listitem>
				 <listitem>
					<para>
						the value for the month (from 1 to 12);
					</para>

				</listitem>
				 <listitem>
					<para>
						the value for the day of the week (from 0 to 7, 1 corresponding to Monday, Sunday being represented by both 0 and 7; it is also possible to use the first three letters of the name of the day of the week in English, such as <literal>Sun</literal>, <literal>Mon</literal>, etc.);
					</para>

				</listitem>
				 <listitem>
					<para>
						the user name under whose identity the command must be executed (in the <filename>/etc/crontab</filename> file and in the fragments located in <filename>/etc/cron.d/</filename>, but not in the users' own crontab files);
					</para>

				</listitem>
				 <listitem>
					<para>
						the command to execute (when the conditions defined by the first five columns are met).
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				All these details are documented in the <citerefentry><refentrytitle>crontab</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry> man page.
			</para>
			 <para>
				Each value can be expressed in the form of a list of possible values (separated by commas). The syntax <literal>a-b</literal> describes the interval of all the values between <literal>a</literal> and <literal>b</literal>. The syntax <literal>a-b/c</literal> describes the interval with an increment of <literal>c</literal> (example: <literal>0-10/2</literal> means <literal>0,2,4,6,8,10</literal>). An asterisk <literal>*</literal> is a wildcard, representing all possible values.
			</para>
			 <example id="example.crontab">
				<title>Sample <filename>crontab</filename> file</title>
				 
<programlisting>#Format
#min hour day mon dow  command

# Download data every night at 7:25 pm
 25  19   *   *   *    $HOME/bin/get.pl

# 8:00 am, on weekdays (Monday through Friday)
 00  08   *   *   1-5  $HOME/bin/dosomething

# Restart the IRC proxy after each reboot
@reboot /usr/bin/dircproxy
</programlisting>

			</example>
			 <sidebar> <title><emphasis>TIP</emphasis> Executing a command on boot</title>
			 <para>
				To execute a command a single time, just after booting the computer, you can use the <literal>@reboot</literal> macro (a simple restart of <command>cron</command> does not trigger a command scheduled with <literal>@reboot</literal>). This macro replaces the first five fields of an entry in the <emphasis>crontab</emphasis>.
			</para>
			 </sidebar> <sidebar> <title><emphasis>ALTERNATIVE</emphasis> Emulating <command>cron</command> with <command>systemd</command></title>
			 <para>
				It is possible to emulate part of <command>cron</command>'s behaviour with <command>systemd</command>'s timer mechanism (see <xref linkend="sect.systemd" />).
			</para>
			 </sidebar>
		</section>
		 <section id="sect.at-command">
			<title>Using the <command>at</command> Command</title>
			 <indexterm>
				<primary><command>at</command></primary>
			</indexterm>
			 <para>
				The <command>at</command> executes a command at a specified moment in the future. It takes the desired time and date as command-line parameters, and the command to be executed in its standard input. The command will be executed as if it had been entered in the current shell. <command>at</command> even takes care to retain the current environment, in order to reproduce the same conditions when it executes the command. The time is indicated by following the usual conventions: <literal>16:12</literal> or <literal>4:12pm</literal> represents 4:12 pm. The date can be specified in several European and Western formats, including <literal>DD.MM.YY</literal> (<literal>27.07.15</literal> thus representing 27 July 2015), <literal>YYYY-MM-DD</literal> (this same date being expressed as <literal>2015-07-27</literal>), <literal>MM/DD/[CC]YY</literal> (ie., <literal>12/25/15</literal> or <literal>12/25/2015</literal> will be December 25, 2015), or simple <literal>MMDD[CC]YY</literal> (so that <literal>122515</literal> or <literal>12252015</literal> will, likewise, represent December 25, 2015). Without it, the command will be executed as soon as the clock reaches the time indicated (the same day, or tomorrow if that time has already passed on the same day). You can also simply write “today” or “tomorrow”, which is self-explanatory.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>
<computeroutput>&gt; </computeroutput><userinput>echo "Don't forget to wish a Happy Birthday to Raphaël!" \</userinput>
<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>
<computeroutput>&gt; </computeroutput><userinput>END</userinput>
<computeroutput>warning: commands will be executed using /bin/sh
job 31 at Mon Jul 27 09:00:00 2015</computeroutput></screen>
			 <para>
				An alternative syntax postpones the execution for a given duration: <command>at now + <replaceable>number</replaceable> <replaceable>period</replaceable></command>. The <replaceable>period</replaceable> can be <literal>minutes</literal>, <literal>hours</literal>, <literal>days</literal>, or <literal>weeks</literal>. The <replaceable>number</replaceable> simply indicates the number of said units that must elapse before execution of the command.
			</para>
			 <para>
				To cancel a task scheduled by <command>cron</command>, simply run <command>crontab -e</command> and delete the corresponding line in the <emphasis>crontab</emphasis> file. For <command>at</command> tasks, it is almost as easy: run <command>atrm <replaceable>task-number</replaceable></command>. The task number is indicated by the <command>at</command> command when you scheduled it, but you can find it again with the <command>atq</command> command, which gives the current list of scheduled tasks.
			</para>
			 <indexterm>
				<primary><command>atrm</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>atq</command></primary>
			</indexterm>

		</section>

	</section>
	 <section id="sect.asynchronous-task-scheduling-anacron">
		<title>Scheduling Asynchronous Tasks: <command>anacron</command></title>
		 <para>
			<command>anacron</command> is the daemon that completes <command>cron</command> for computers that are not on at all times. Since regular tasks are usually scheduled for the middle of the night, they will never be executed if the computer is off at that time. The purpose of <command>anacron</command> is to execute them, taking into account periods in which the computer is not working.
		</para>
		 <indexterm>
			<primary><command>anacron</command></primary>
		</indexterm>
		 <para>
			Please note that <command>anacron</command> will frequently execute such activity a few minutes after booting the machine, which can render the computer less responsive. This is why the tasks in the <filename>/etc/anacrontab</filename> file are started with the <command>nice</command> command, which reduces their execution priority and thus limits their impact on the rest of the system. Beware, the format of this file is not the same as that of <filename>/etc/crontab</filename>; if you have particular needs for <command>anacron</command>, see the <citerefentry><refentrytitle>anacrontab</refentrytitle>
			 <manvolnum>5</manvolnum></citerefentry> manual page.
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Priorities and <command>nice</command></title>
		 <para>
			Unix systems (and thus Linux) are multi-tasking and multi-user systems. Indeed, several processes can run in parallel, and be owned by different users: the kernel mediates access to the resources between the different processes. As a part of this task, it has a concept of priority, which allows it to favor certain processes over others, as needed. When you know that a process can run in low priority, you can indicate so by running it with <command>nice <replaceable>program</replaceable></command>. The program will then have a smaller share of the CPU, and will have a smaller impact on other running processes. Of course, if no other processes needs to run, the program will not be artificially held back.
		</para>
		 <para>
			<command>nice</command> works with levels of “niceness”: the positive levels (from 1 to 19) progressively lower the priority, while the negative levels (from -1 to -20) will increase it — but only root can use these negative levels. Unless otherwise indicated (see the <citerefentry><refentrytitle>nice</refentrytitle>
			 <manvolnum>1</manvolnum></citerefentry> manual page), <command>nice</command> increases the current level by 10.
		</para>
		 <para>
			If you discover that an already running task should have been started with <command>nice</command> it is not too late to fix it; the <command>renice</command> command changes the priority of an already running process, in either direction (but reducing the “niceness” of a process is reserved for the root user).
		</para>
		 </sidebar> <para>
			Installation of the <emphasis role="pkg">anacron</emphasis> package deactivates execution by <command>cron</command> of the scripts in the <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename>, and <filename>/etc/cron.monthly/</filename> directories. This avoids their double execution by <command>anacron</command> and <command>cron</command>. The <command>cron</command> command remains active and will continue to handle the other scheduled tasks (especially those scheduled by users).
		</para>

	</section>
	 <section id="sect.quotas">
		<title>Quotas</title>
		 <indexterm>
			<primary>kontingent</primary>
		</indexterm>
		 <para>
			The quota system allows limiting disk space allocated to a user or group of users. To set it up, you must have a kernel that supports it (compiled with the <varname>CONFIG_QUOTA</varname> option) — as is the case with Debian kernels. The quota management software is found in the <emphasis role="pkg">quota</emphasis> Debian package.
		</para>
		 <para>
			To activate quota in a filesystem, you have to indicate the <literal>usrquota</literal> and <literal>grpquota</literal> options in <filename>/etc/fstab</filename> for the user and group quotas, respectively. Rebooting the computer will then update the quotas in the absence of disk activity (a necessary condition for proper accounting of already used disk space).
		</para>
		 <para>
			The <command>edquota <replaceable>user</replaceable></command> (or <command>edquota -g <replaceable>group</replaceable></command>) command allows you to change the limits while examining current disk space usage.
		</para>
		 <indexterm>
			<primary><command>edquota</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>GOING FURTHER</emphasis> Defining quotas with a script</title>
		 <indexterm>
			<primary><command>setquota</command></primary>
		</indexterm>
		 <para>
			The <command>setquota</command> program can be used in a script to automatically change many quotas. Its <citerefentry><refentrytitle>setquota</refentrytitle>
			 <manvolnum>8</manvolnum></citerefentry> manual page details the syntax to use.
		</para>
		 </sidebar> <para>
			The quota system allows you to set four limits:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					two limits (called “soft” and “hard”) refer to the number of blocks consumed. If the filesystem was created with a block-size of 1 kibibyte, a block contains 1024 bytes from the same file. Unsaturated blocks thus induce losses of disk space. A quota of 100 blocks, which theoretically allows storage of 102,400 bytes, will however be saturated with just 100 files of 500 bytes each, only representing 50,000 bytes in total.
				</para>

			</listitem>
			 <listitem>
				<para>
					two limits (soft and hard) refer to the number of inodes used. Each file occupies at least one inode to store information about it (permissions, owner, timestamp of last access, etc.). It is thus a limit on the number of user files.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			A “soft” limit can be temporarily exceeded; the user will simply be warned that they are exceeding the quota by the <command>warnquota</command> command, which is usually invoked by <command>cron</command>. A “hard” limit can never be exceeded: the system will refuse any operation that will cause a hard quota to be exceeded.
		</para>
		 <sidebar> <title><emphasis>VOCABULARY</emphasis> Blocks and inodes</title>
		 <indexterm>
			<primary>block (disk)</primary>
		</indexterm>
		 <indexterm>
			<primary>inode</primary>
		</indexterm>
		 <para>
			The filesystem divides the hard drive into blocks — small contiguous areas. The size of these blocks is defined during creation of the filesystem, and generally varies between 1 and 8 kibibytes.
		</para>
		 <para>
			A block can be used either to store the real data of a file, or for meta-data used by the filesystem. Among this meta-data, you will especially find the inodes. An inode uses a block on the hard drive (but this block is not taken into consideration in the block quota, only in the inode quota), and contains both the information on the file to which it corresponds (name, owner, permissions, etc.) and the pointers to the data blocks that are actually used. For very large files that occupy more blocks than it is possible to reference in a single inode, there is an indirect block system; the inode references a list of blocks that do not directly contain data, but another list of blocks.
		</para>
		 </sidebar> <indexterm>
			<primary><command>warnquota</command></primary>
		</indexterm>
		 <para>
			With the <command>edquota -t</command> command, you can define a maximum authorized “grace period” within which a soft limit may be exceeded. After this period, the soft limit will be treated like a hard limit, and the user will have to reduce their disk space usage to within this limit in order to be able to write anything to the hard drive.
		</para>
		 <sidebar> <title><emphasis>GOING FURTHER</emphasis> Setting up a default quota for new users</title>
		 <para>
			To automatically setup a quota for new users, you have to configure a template user (with <command>edquota</command> or <command>setquota</command>) and indicate their user name in the <varname>QUOTAUSER</varname> variable in the <filename>/etc/adduser.conf</filename> file. This quota configuration will then be automatically applied to each new user created with the <command>adduser</command> command.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.backup">
		<title>Datensicherung</title>
		 <para>
			Making backups is one of the main responsibilities of any administrator, but it is a complex subject, involving powerful tools which are often difficult to master.
		</para>
		 <indexterm>
			<primary>backup</primary>
		</indexterm>
		 <indexterm>
			<primary>restoration</primary>
		</indexterm>
		 <para>
			Many programs exist, such as <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. Those are client/server system featuring many options, whose configuration is rather difficult. Some of them provide user-friendly web interfaces to mitigate this. But Debian contains dozens of other backup software covering all possible use cases, as you can easily confirm with <command>apt-cache search backup</command>.
		</para>
		 <indexterm>
			<primary><command>amanda</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>bacula</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>BackupPC</command></primary>
		</indexterm>
		 <para>
			Rather than detailing some of them, this section will present the thoughts of the Falcot Corp administrators when they defined their backup strategy.
		</para>
		 <para>
			At Falcot Corp, backups have two goals: recovering erroneously deleted files, and quickly restoring any computer (server or desktop) whose hard drive has failed.
		</para>
		 <section>
			<title>Backing Up with <command>rsync</command></title>
			 <para>
				Backups on tape having been deemed too slow and costly, data will be backed up on hard drives on a dedicated server, on which the use of software RAID (see <xref linkend="sect.raid-soft" />) will protect the data from hard drive failure. Desktop computers are not backed up individually, but users are advised that their personal account on their department's file server will be backed up. The <command>rsync</command> command (from the package of the same name) is used daily to back up these different servers.
			</para>
			 <indexterm>
				<primary><command>rsync</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> The hard link, a second name for the file</title>
			 <indexterm>
				<primary>link</primary>
				<secondary>hard link</secondary>
			</indexterm>
			 <indexterm>
				<primary>hard link</primary>
			</indexterm>
			 <para>
				A hard link, as opposed to a symbolic link, cannot be differentiated from the linked file. Creating a hard link is essentially the same as giving an existing file a second name. This is why the deletion of a hard link only removes one of the names associated with the file. As long as another name is still assigned to the file, the data therein remain present on the filesystem. It is interesting to note that, unlike a copy, the hard link does not take up additional space on the hard drive.
			</para>
			 <para>
				A hard link is created with the <command>ln <replaceable>target</replaceable> <replaceable>link</replaceable></command> command. The <replaceable>link</replaceable> file is then a new name for the <replaceable>target</replaceable> file. Hard links can only be created on the same filesystem, while symbolic links are not subject to this limitation.
			</para>
			 </sidebar> <para>
				The available hard drive space prohibits implementation of a complete daily backup. As such, the <command>rsync</command> command is preceded by a duplication of the content of the previous backup with hard links, which prevents usage of too much hard drive space. The <command>rsync</command> process then only replaces files that have been modified since the last backup. With this mechanism a great number of backups can be kept in a small amount of space. Since all backups are immediately available and accessible (for example, in different directories of a given share on the network), you can quickly make comparisons between two given dates.
			</para>
			 <indexterm>
				<primary>copy, backup copy</primary>
			</indexterm>
			 <indexterm>
				<primary>backup</primary>
				<secondary>copy</secondary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">dirvish</emphasis></primary>
			</indexterm>
			 <para>
				This backup mechanism is easily implemented with the <command>dirvish</command> program. It uses a backup storage space (“bank” in its vocabulary) in which it places timestamped copies of sets of backup files (these sets are called “vaults” in the dirvish documentation).
			</para>
			 <para>
				The main configuration is in the <filename>/etc/dirvish/master.conf</filename> file. It defines the location of the backup storage space, the list of “vaults” to manage, and default values for expiration of the backups. The rest of the configuration is located in the <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> files and contains the specific configuration for the corresponding set of files.
			</para>
			 <example id="example.dirvish-master">
				<title>The <filename>/etc/dirvish/master.conf</filename> file</title>
				 
<programlisting>bank:
    /backup
exclude:
    lost+found/
    core
    *~
Runall:
    root    22:00
expire-default: +15 days
expire-rule:
#   MIN HR    DOM MON       DOW  STRFTIME_FMT
    *   *     *   *         1    +3 months
    *   *     1-7 *         1    +1 year
    *   *     1-7 1,4,7,10  1
</programlisting>

			</example>
			 <para>
				The <literal>bank</literal> setting indicates the directory in which the backups are stored. The <literal>exclude</literal> setting allows you to indicate files (or file types) to exclude from the backup. The <literal>Runall</literal> is a list of file sets to backup with a time-stamp for each set, which allows you to assign the correct date to the copy, in case the backup is not triggered at precisely the assigned time. You have to indicate a time just before the actual execution time (which is, by default, 10:04 pm in Debian, according to <filename>/etc/cron.d/dirvish</filename>). Finally, the <literal>expire-default</literal> and <literal>expire-rule</literal> settings define the expiration policy for backups. The above example keeps forever backups that are generated on the first Sunday of each quarter, deletes after one year those from the first Sunday of each month, and after 3 months those from other Sundays. Other daily backups are kept for 15 days. The order of the rules does matter, Dirvish uses the last matching rule, or the <literal>expire-default</literal> one if no other <literal>expire-rule</literal> matches.
			</para>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> Scheduled expiration</title>
			 <para>
				The expiration rules are not used by <command>dirvish-expire</command> to do its job. In reality, the expiration rules are applied when creating a new backup copy to define the expiration date associated with that copy. <command>dirvish-expire</command> simply peruses the stored copies and deletes those for which the expiration date has passed.
			</para>
			 </sidebar> <example id="example.dirvish-vault">
				<title>The <filename>/backup/root/dirvish/default.conf</filename> file</title>
				 
<programlisting>client: rivendell.falcot.com
tree: /
xdev: 1
index: gzip
image-default: %Y%m%d
exclude:
    /var/cache/apt/archives/*.deb
    /var/cache/man/**
    /tmp/**
    /var/tmp/**
    *.bak
</programlisting>

			</example>
			 <para>
				The above example specifies the set of files to back up: these are files on the machine <emphasis>rivendell.falcot.com</emphasis> (for local data backup, simply specify the name of the local machine as indicated by <command>hostname</command>), especially those in the root tree (<literal>tree: /</literal>), except those listed in <literal>exclude</literal>. The backup will be limited to the contents of one filesystem (<literal>xdev: 1</literal>). It will not include files from other mount points. An index of saved files will be generated (<literal>index: gzip</literal>), and the image will be named according to the current date (<literal>image-default: %Y%m%d</literal>).
			</para>
			 <para>
				There are many options available, all documented in the <citerefentry><refentrytitle>dirvish.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> manual page. Once these configuration files are setup, you have to initialize each file set with the <command>dirvish --vault <replaceable>vault</replaceable> --init</command> command. From there on the daily invocation of <command>dirvish-runall</command> will automatically create a new backup copy just after having deleted those that expired.
			</para>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> Remote backup over SSH</title>
			 <para>
				When dirvish needs to save data to a remote machine, it will use <command>ssh</command> to connect to it, and will start <command>rsync</command> as a server. This requires the root user to be able to automatically connect to it. The use of an SSH authentication key allows precisely that (see <xref linkend="sect.ssh-key-based-auth" />).
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>Restoring Machines without Backups</title>
			 <para>
				Desktop computers, which are not backed up, will be easy to reinstall from custom DVD-ROMs prepared with <emphasis>Simple-CDD</emphasis> (see <xref linkend="sect.simple-cdd" />). Since this performs an installation from scratch, it loses any customization that can have been made after the initial installation. This is fine since the systems are all hooked to a central LDAP directory for accounts and most desktop applications are preconfigured thanks to dconf (see <xref linkend="sect.gnome-desktop" /> for more information about this).
			</para>
			 <para>
				The Falcot Corp administrators are aware of the limits in their backup policy. Since they can't protect the backup server as well as a tape in a fireproof safe, they have installed it in a separate room so that a disaster such as a fire in the server room won't destroy backups along with everything else. Furthermore, they do an incremental backup on DVD-ROM once per week — only files that have been modified since the last backup are included.
			</para>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> Backing up SQL and LDAP services</title>
			 <para>
				Many services (such as SQL or LDAP databases) cannot be backed up by simply copying their files (unless they are properly interrupted during creation of the backups, which is frequently problematic, since they are intended to be available at all times). As such, it is necessary to use an “export” mechanism to create a “data dump” that can be safely backed up. These are often quite large, but they compress well. To reduce the storage space required, you will only store a complete text file per week, and a <command>diff</command> each day, which is created with a command of the type <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command>. The <command>xdelta</command> program produces incremental differences from binary dumps.
			</para>
			 <indexterm>
				<primary><command>xdelta</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>diff</command></primary>
			</indexterm>
			 <indexterm>
				<primary>dump</primary>
			</indexterm>
			 </sidebar> <sidebar> <title><emphasis>CULTURE</emphasis> <emphasis>TAR</emphasis>, the standard for tape backups</title>
			 <indexterm>
				<primary>backup</primary>
				<secondary>on tape</secondary>
			</indexterm>
			 <indexterm>
				<primary>tape, backup</primary>
			</indexterm>
			 <indexterm>
				<primary>TAR</primary>
			</indexterm>
			 <para>
				Historically, the simplest means of making a backup on Unix was to store a <emphasis>TAR</emphasis> archive on a tape. The <command>tar</command> command even got its name from “Tape ARchive”.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.hotplug">
		<title>Hot Plugging: <emphasis>hotplug</emphasis></title>
		 <section>
			<title>Introduction</title>
			 <para>
				The <emphasis>hotplug</emphasis> kernel subsystem dynamically handles the addition and removal of devices, by loading the appropriate drivers and by creating the corresponding device files (with the help of <command>udevd</command>). With modern hardware and virtualization, almost everything can be hotplugged: from the usual USB/PCMCIA/IEEE 1394 peripherals to SATA hard drives, but also the CPU and the memory.
			</para>
			 <para>
				The kernel has a database that associates each device ID with the required driver. This database is used during boot to load all the drivers for the peripheral devices detected on the different buses, but also when an additional hotplug device is connected. Once the device is ready for use, a message is sent to <command>udevd</command> so it will be able to create the corresponding entry in <filename>/dev/</filename>.
			</para>
			 <indexterm>
				<primary><emphasis>hotplug</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>hotplug</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>PCMCIA</primary>
			</indexterm>
			 <indexterm>
				<primary>SATA</primary>
			</indexterm>

		</section>
		 <section>
			<title>The Naming Problem</title>
			 <para>
				Before the appearance of hotplug connections, it was easy to assign a fixed name to a device. It was based simply on the position of the devices on their respective bus. But this is not possible when such devices can come and go on the bus. The typical case is the use of a digital camera and a USB key, both of which appear to the computer as disk drives. The first one connected may be <filename>/dev/sdb</filename> and the second <filename>/dev/sdc</filename> (with <filename>/dev/sda</filename> representing the computer's own hard drive). The device name is not fixed; it depends on the order in which devices are connected.
			</para>
			 <para>
				Additionally, more and more drivers use dynamic values for devices' major/minor numbers, which makes it impossible to have static entries for the given devices, since these essential characteristics may vary after a reboot.
			</para>
			 <para>
				<emphasis>udev</emphasis> was created precisely to solve this problem.
			</para>

		</section>
		 <section>
			<title>How <emphasis>udev</emphasis> Works</title>
			 <para>
				When <emphasis>udev</emphasis> is notified by the kernel of the appearance of a new device, it collects various information on the given device by consulting the corresponding entries in <filename>/sys/</filename>, especially those that uniquely identify it (MAC address for a network card, serial number for some USB devices, etc.).
			</para>
			 <para>
				Armed with all of this information, <emphasis>udev</emphasis> then consults all of the rules contained in <filename>/etc/udev/rules.d/</filename> and <filename>/lib/udev/rules.d/</filename>. In this process it decides how to name the device, what symbolic links to create (to give it alternative names), and what commands to execute. All of these files are consulted, and the rules are all evaluated sequentially (except when a file uses “GOTO” directives). Thus, there may be several rules that correspond to a given event.
			</para>
			 <para>
				The syntax of rules files is quite simple: each row contains selection criteria and variable assignments. The former are used to select events for which there is a need to react, and the latter defines the action to take. They are all simply separated with commas, and the operator implicitly differentiates between a selection criterion (with comparison operators, such as <literal>==</literal> or <literal>!=</literal>) or an assignment directive (with operators such as <literal>=</literal>, <literal>+=</literal> or <literal>:=</literal>).
			</para>
			 <para>
				Comparison operators are used on the following variables:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>KERNEL</literal>: the name that the kernel assigns to the device;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ACTION</literal>: the action corresponding to the event (“add” when a device has been added, “remove” when it has been removed);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>DEVPATH</literal>: the path of the device's <filename>/sys/</filename> entry;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SUBSYSTEM</literal>: the kernel subsystem which generated the request (there are many, but a few examples are “usb”, “ide”, “net”, “firmware”, etc.);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ATTR{<replaceable>attribute</replaceable>}</literal>: file contents of the <replaceable>attribute</replaceable> file in the <filename>/sys/<replaceable>$devpath</replaceable>/</filename> directory of the device. This is where you find the MAC address and other bus specific identifiers;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> and <literal>ATTRS{<replaceable>attributes</replaceable>}</literal> are variations that will try to match the different options on one of the parent devices of the current device;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>PROGRAM</literal>: delegates the test to the indicated program (true if it returns 0, false if not). The content of the program's standard output is stored so that it can be reused by the <literal>RESULT</literal> test;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>RESULT</literal>: execute tests on the standard output stored during the last call to <literal>PROGRAM</literal>.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				The right operands can use pattern expressions to match several values at the same time. For instance, <literal>*</literal> matches any string (even an empty one); <literal>?</literal> matches any character, and <literal>[]</literal> matches the set of characters listed between the square brackets (or the opposite thereof if the first character is an exclamation point, and contiguous ranges of characters are indicated like <literal>a-z</literal>).
			</para>
			 <para>
				Regarding the assignment operators, <literal>=</literal> assigns a value (and replaces the current value); in the case of a list, it is emptied and contains only the value assigned. <literal>:=</literal> does the same, but prevents later changes to the same variable. As for <literal>+=</literal>, it adds an item to a list. The following variables can be changed:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>NAME</literal>: the device filename to be created in <filename>/dev/</filename>. Only the first assignment counts; the others are ignored;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SYMLINK</literal>: the list of symbolic links that will point to the same device;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>OWNER</literal>, <literal>GROUP</literal> and <literal>MODE</literal> define the user and group that owns the device, as well as the associated permission;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>RUN</literal>: the list of programs to execute in response to this event.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				The values assigned to these variables may use a number of substitutions:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>$kernel</literal> or <literal>%k</literal>: equivalent to <literal>KERNEL</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$number</literal> or <literal>%n</literal>: the order number of the device, for example, for <literal>sda3</literal>, it would be “3”;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$devpath</literal> or <literal>%p</literal>: equivalent to <literal>DEVPATH</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$attr{<replaceable>attribute</replaceable>}</literal> or <literal>%s{<replaceable>attribute</replaceable>}</literal>: equivalent to <literal>ATTRS{<replaceable>attribute</replaceable>}</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$major</literal> or <literal>%M</literal>: the kernel major number of the device;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$minor</literal> or <literal>%m</literal>: the kernel minor number of the device;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>$result</literal> or <literal>%c</literal>: the string output by the last program invoked by <literal>PROGRAM</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						and, finally, <literal>%%</literal> and <literal>$$</literal> for the percent and dollar sign, respectively.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				The above lists are not complete (they include only the most important parameters), but the <citerefentry><refentrytitle>udev</refentrytitle>
				<manvolnum>7</manvolnum></citerefentry> manual page should be exhaustive.
			</para>

		</section>
		 <section>
			<title>A concrete example</title>
			 <para>
				Let us consider the case of a simple USB key and try to assign it a fixed name. First, you must find the elements that will identify it in a unique manner. For this, plug it in and run <command>udevadm info -a -n /dev/sdc</command> (replacing <replaceable>/dev/sdc</replaceable> with the actual name assigned to the key).
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>
<computeroutput>[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</computeroutput></screen>
			 <para>
				To create a new rule, you can use tests on the device's variables, as well as those of one of the parent devices. The above case allows us to create two rules like these:
			</para>
			 
<programlisting>KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"
</programlisting>
			 <para>
				Once these rules are set in a file, named for example <filename>/etc/udev/rules.d/010_local.rules</filename>, you can simply remove and reconnect the USB key. You can then see that <filename>/dev/usb_key/disk</filename> represents the disk associated with the USB key, and <filename>/dev/usb_key/part1</filename> is its first partition.
			</para>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> Debugging <emphasis>udev</emphasis>'s configuration</title>
			 <para>
				Like many daemons, <command>udevd</command> stores logs in <filename>/var/log/daemon.log</filename>. But it is not very verbose by default, and it is usually not enough to understand what is happening. The <command>udevadm control --log-priority=info</command> command increases the verbosity level and solves this problem. <command>udevadm control --log-priority=err</command> returns to the default verbosity level.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.power-management">
		<title>Power Management: Advanced Configuration and Power Interface (ACPI)</title>
		 <indexterm>
			<primary>power management</primary>
		</indexterm>
		 <indexterm>
			<primary>management, power management</primary>
		</indexterm>
		 <para>
			The topic of power management is often problematic. Indeed, properly suspending the computer requires that all the computer's device drivers know how to put them to standby, and that they properly reconfigure the devices upon waking. Unfortunately, there are still a few devices unable to sleep well under Linux, because their manufacturers have not provided the required specifications.
		</para>
		 <para>
			Linux supports ACPI (Advanced Configuration and Power Interface) — the most recent standard in power management. The <emphasis role="pkg">acpid</emphasis> package provides a daemon that looks for power management related events (switching between AC and battery power on a laptop, etc.) and that can execute various commands in response.
		</para>
		 <indexterm>
			<primary>ACPI</primary>
		</indexterm>
		 <indexterm>
			<primary>Advanced Configuration and Power Interface</primary>
		</indexterm>
		 <indexterm>
			<primary><command>acpid</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>BEWARE</emphasis> Graphics card and standby</title>
		 <para>
			The graphics card driver is often the culprit when standby doesn't work properly. In that case, it is a good idea to test the latest version of the X.org graphics server.
		</para>
		 </sidebar> <para>
			After this overview of basic services common to many Unix systems, we will focus on the environment of the administered machines: the network. Many services are required for the network to work properly. They will be discussed in the next chapter.
		</para>

	</section>
</chapter>

