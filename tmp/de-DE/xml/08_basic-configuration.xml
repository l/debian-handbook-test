<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="basic-configuration" lang="de-DE">
	<chapterinfo>
		 <keywordset>
			<keyword>Konfigurierung</keyword>
			 <keyword>Lokalisierung</keyword>
			 <keyword>Sprachumgebungen</keyword>
			 <keyword>Netzwerk</keyword>
			 <keyword>Namensauflösung</keyword>
			 <keyword>Benutzer</keyword>
			 <keyword>Gruppen</keyword>
			 <keyword>Benutzerkonten</keyword>
			 <keyword>Befehlszeileninterpreter</keyword>
			 <keyword>Shell</keyword>
			 <keyword>Drucken</keyword>
			 <keyword>Boot-Loader</keyword>
			 <keyword>Kernel-Kompilierung</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Basis-Konfigurierung: Netzwerk, Benutzerkonten, Drucken...</title>
	 <highlights> <para>
		Ein Rechner mit einer neuen Installation, die mit <command>debian-installer</command> erstellt wurde, sollte möglichst weitgehend funktionsfähig sein, aber viele Dienste müssen noch konfiguriert werden. Außerdem ist es immer gut, wenn man weiß, wie bestimmte Konfigurationselemente, die während des ursprünglichen Installationsprozesses festgelegt wurden, geändert werden.
	</para>
	 </highlights> <para>
		In diesem Kapitel wird all das besprochen, was wir „Basis-Konfigurierung“ nennen: Netzwerkbetrieb, Sprache und Sprachumgebungen, Benutzer und Gruppen, Drucken, Einhängepunkte usw.
	</para>
	 <section id="sect.config-language-support">
		<title>Das System für eine andere Sprache konfigurieren</title>
		 <indexterm>
			<primary>Französische Lokalisierung</primary>
		</indexterm>
		 <para>
			Falls das System auf Französisch installiert wurde, wird der Rechner wahrscheinlich schon Französisch als Sprache voreingestellt haben. Aber es ist gut zu wissen, was der Installer macht, um die Sprache einzustellen, so dass Sie sie später, falls nötig, ändern können.
		</para>
		 <sidebar> <title><emphasis>HILFSPROGRAMM</emphasis> Der Befehl <command>locale</command> zur Anzeige der aktuellen Konfiguration</title>
		 <para>
			Der Befehl <command>locale</command> listet eine Zusammenfassung der aktuellen Konfiguration verschiedener lokaler Parameter (Datumsformat, Zahlenformat usw.) auf, dargestellt in Form einer Gruppe von Standardumgebungsvariablen, die der dynamischen Änderung dieser Einstellungen entsprechen.
		</para>
		 </sidebar> <section id="sect.default-language">
			<title>Die Standardsprache einstellen</title>
			 <indexterm>
				<primary>Sprachumgebungen</primary>
			</indexterm>
			 <indexterm>
				<primary>Sprache</primary>
			</indexterm>
			 <indexterm>
				<primary><command>locale-gen</command></primary>
			</indexterm>
			 <para>
				Eine Sprachumgebung ist eine Sammlung regionaler Einstellungen. Diese beinhalten nicht nur die Sprache für den Text, sondern auch das Format für Zahlen, Datumsangaben, Zeiten und Währungsbeträge, sondern auch die Regeln für alphabetische Vergleiche (um Einträge mit Akzenten richtig einzusortieren). Obwohl jeder dieser Parameter unabhängig von den anderen festgelegt werden kann, verwenden wir normalerweise eine Sprachumgebung, die einen kohärenten Satz von Einstellungen zur Verfügung stellt, die einem „Gebiet“ im weiteren Sinne zugeordnet werden kann. Diese Sprachumgebungen werden gewöhnlich in der Form <literal><replaceable>sprachcode</replaceable>_<replaceable>LÄNDERCODE</replaceable></literal> angegeben, manchmal mit einem Suffix zur Festlegung des Zeichensatzes und der zu verwendenden Kodierung. Dies ermöglicht die Berücksichtigung redensartlicher und typografischer Unterschiede zwischen verschiedenen Regionen mit einer gemeinsamen Sprache.
			</para>
			 <sidebar> <title><emphasis>KULTUR</emphasis> Zeichensätze</title>
			 <indexterm>
				<primary>Zeichensatz</primary>
			</indexterm>
			 <indexterm>
				<primary>Kodierung</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-1</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-15</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 1</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 9</primary>
			</indexterm>
			 <para>
				Historisch bedingt hat jede Sprachumgebung einen dazugehörigen „Zeichensatz“ (Gruppe bekannter Zeichen) und eine bevorzugte „Codierung“ (interne Darstellung von Zeichen innerhalb des Rechners).
			</para>
			 <para>
				Die gängigsten Kodierungen für latin-basierte Sprachen waren begrenzt auf 256 Zeichen, weil diese ein einzelnes Byte für jedes Zeichen verwendeten. Da man mit 256 Zeichen nicht alle europäischen Sprachen abdecken konnte, benötigte man mehrere Kodierungen und so kam es unter anderem zu <emphasis>ISO-8859-1</emphasis> (auch bekannt als “Latin 1”) bis <emphasis>ISO-8859-15</emphasis> (auch bekannt als “Latin 9”).
			</para>
			 <para>
				Das Arbeiten mit fremden Sprachen erfordert häufig regelmäßiges Umschalten zwischen verschiedenen Codierungen und Zeichensätzen. Darüber hinaus führte das Schreiben mehrsprachiger Dokumente zu weiteren, fast unlösbaren Problemen. Unicode (ein Superkatalog fast aller Schreibsysteme aller Sprachen der Erde) wurde zur Umgehung dieses Problems entwickelt. Eine der Codierungen von Unicode, UTF-8, behält alle 128 ASCII-Symbole (7-Bit Codes), behandelt weitere Zeichen aber auf andere Weise. Diesen wird spezielle „Escape“-Sequenz mit wenigen Bits vorangestellt, die implizit die Länge des Zeichens festlegt. Dadurch können alle Unicode-Zeichen in einer Folge von einem oder mehreren Bytes kodiert werden. Durch die Voreinstellung in XML-Dokumenten wurde die Verwendung von Unicode populär.
			</para>
			 <indexterm>
				<primary>ASCII</primary>
			</indexterm>
			 <indexterm>
				<primary>UTF-8</primary>
			</indexterm>
			 <indexterm>
				<primary>Unicode</primary>
			</indexterm>
			 <para>
				Diese Kodierung sollte allgemein verwendet werden und ist deshalb auch die Voreinstellung für Debian-Systeme.
			</para>
			 </sidebar> <para>
				Das Paket <emphasis role="pkg">locales</emphasis> enthält alle Elemente, die für das richtige Funktionieren der „Lokalisierung“ verschiedener Anwendungen erforderlich sind. Während des Installierens verlangt dieses Paket einen Satz von unterstützten Sprachen auszuwählen. Dieser Satz kann jederzeit durch das Ausführen von <command>dpkg-reconfigure locales</command> als root geändert werden.
			</para>
			 <para>
				Sie werden zunächst gefragt, welche „Sprachumgebungen“ unterstützt werden sollen. Das Auswählen aller deutschen Sprachumgebungen (das heißt alle, die mit „<literal>de_</literal>“ beginnen) ist eine vernünftige Wahl. Zögern Sie nicht, andere Sprachumgebungen einzurichten, falls der Rechner ausländischen Benutzern zur Verfügung stehen wird. Die Liste der unterstützten Sprachumgebungen des Systems ist in der Datei <filename>/etc/locale.gen</filename> gespeichert. Diese Datei kann von Hand editiert werden, jedoch sollten Sie nach jeder Änderung <command>locale-gen</command> ausführen. Es erzeugt die für die hinzugefügten Sprachumgebungen erforderlichen Dateien und entfernt veraltete.
			</para>
			 <para>
				Die zweite Frage lautet „Default locale for the system environment“ und fordert die Angabe einer Voreinstellung für die Sprachumgebung. In Deutschland ist die empfohlene Auswahl „<literal>de_DE.UTF-8</literal>“. Österreicher werden „<literal>de_AT.UTF-8</literal>“ bevorzugen, Schweizer „<literal>de_CH.UTF-8</literal>“, Belgier „<literal>de_BE.UTF-8</literal>“, Luxemburger „<literal>de_LU.UTF-8</literal>“ und Liechtensteiner „<literal>de_LI.UTF-8</literal>“. Die Datei <filename>/etc/default/locale</filename> wird anschließend geändert, um die Auswahl zu speichern. Von dort wird die Einstellung in alle Benutzersitzungen übernommen, indem PAM den Wert in die Umgebungsvariable <varname>LANG</varname> kopiert.
			</para>
			 <indexterm>
				<primary>Umgebung</primary>
			</indexterm>
			 <indexterm>
				<primary>Sprachumgebung</primary>
			</indexterm>
			 <indexterm>
				<primary><varname>LANG</varname></primary>
			</indexterm>
			 <sidebar id="sidebar.intro-pam"> <title><emphasis>HINTER DEN KULISSEN</emphasis> <filename>/etc/environment</filename> und <filename>/etc/default/locale</filename></title>
			 <para>
				Die Datei <filename>/etc/environment</filename> stellt für die Programme <command>login</command>, <command>gdm</command> und auch <command>ssh</command> die richtigen Umgebungsvariablen bereit, die diese einsetzen sollen.
			</para>
			 <para>
				Diese Anwendungen erzeugen diese Variablen nicht direkt, sondern vielmehr mit Hilfe eines PAM-Moduls (<filename>pam_env.so</filename>). PAM (Pluggable Authentication Module) ist eine modulare Bibliothek, die die Verfahren für die Authentifizierung, die Sitzungseröffnung und die Passwortverwaltung zusammenfasst. Siehe <xref linkend="sect.config-pam" /> für ein Beispiel einer PAM-Konfigurierung.
			</para>
			 <para>
				Die Datei <filename>/etc/default/locale</filename> funktioniert ähnlich, enthält aber nur die Umgebungsvariable <varname>LANG</varname>. Dies bedeutet, dass einige PAM-Benutzer eine Umgebung ohne Lokalisierung erhalten. Es wird allgemein nicht empfohlen, Serverprogramme mit regionalen Einstellungen auszuführen; dagegen ist es bei Programmen, die eine Anwendersitzung eröffnen, empfohlen, regionale Einstellungen zu verwenden.
			</para>
			 <indexterm>
				<primary>PAM</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>pam_env.so</filename></primary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.keyboard-config">
			<title>Die Tastatur einstellen</title>
			 <indexterm>
				<primary>Tastaturbelegung</primary>
			</indexterm>
			 <indexterm>
				<primary>Tastaturbelegung</primary>
			</indexterm>
			 <para>
				Auch wenn das Tastatur-Layout für Konsole und grafisches Interface unterschiedlich verwaltet wird, bietet Debian eine gemeinsame Konfigurationsschnittstelle: sie basiert auf debconf und ist im Paket <emphasis role="pkg">keyboard-configuration</emphasis> enthalten. Deshalb kann man jederzeit den Befehl <command>dpkg-reconfigure keyboard-configuration</command> verwenden um das Tastatur-Layout zurückzusetzen.
			</para>
			 <indexterm>
				<primary><emphasis>console-data</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>console-tools</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>keyboard-configuration</emphasis></primary>
			</indexterm>
			 <para>
				<indexterm><primary><literal>qwertz</literal></primary></indexterm> Die Fragen sind für die physische Tastaturanordnung wichtig (eine gewöhnliche PC-Tastatur in Deutschland und Österreich wird vom Typ „Generische Tastatur mit 105 Tasten (Intl)“ sein), dann für die zu wählende Belegung (normalerweise „DE“) und schließlich für die Position der AltGr-Taste (Alt-Taste rechts der Leertaste). Schließlich stellt sich die Frage, welche Taste als „Compose-Taste“ verwendet werden soll, die es ermöglicht, Sonderzeichen durch die Kombination mehrerer Tastenanschläge einzugeben. Wenn Sie nacheinander <keycombo action="seq"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> eingeben, erhalten Sie ein E-Akut („é“). Alle diese Kombinationen sind in der Datei <filename>/usr/share/X11/locale/en_US.UTF-8/Compose</filename> beschrieben (oder einer anderen Datei in Übereinstimmung mit der aktuellen Sprachumgebung, wie sie in der Datei <filename>/usr/share/X11/locale/compose.dir</filename> festgelegt ist).
			</para>
			 <indexterm>
				<primary><literal>Compose</literal>,-Taste</primary>
			</indexterm>
			 <indexterm>
				<primary><literal>Meta</literal>,-Taste</primary>
			</indexterm>
			 <indexterm>
				<primary>Taste</primary>
				<secondary><literal>Meta-</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary>Taste</primary>
				<secondary><literal>Compose-</literal></secondary>
			</indexterm>
			 <para>
				Beachten Sie, dass die hier beschriebene Tastaturkonfigurierung für den grafischen Modus nur die Standardbelegung beeinflusst; die GNOME- und KDE-Umgebungen stellen, wie andere auch, bei ihren Systemeinstellungen ein Tastaturkonfigurierungsfenster bereit, das es jedem Anwender ermöglicht, seine eigene Konfiguration zu bekommen. Einige zusätzliche Optionen bezüglich des Verhaltens einiger bestimmter Tasten sind ebenfalls in diesen Konfigurierungsfenstern verfügbar.
			</para>

		</section>
		 <section id="sect.utf8-migration">
			<title>Auf UTF-8 umstellen</title>
			 <para>
				Die allgemeine Verbreitung von UTF-8 war eine lang erwartete Lösung für verschiedene Probleme im Bereich der Interoperabilität, da es den internationalen Austausch erleichtert und willkürliche Beschränkungen bei Zeichen, die in einem Dokument verwendet werden können, beseitigt. Die einzige Schattenseite ist, dass es durch eine ziemlich schwierige Übergangsphase gehen musste. Da sie nicht vollständig transparent ablaufen konnte (das heißt, dass sie nicht gleichzeitig weltweit stattfinden konnte), waren zwei Umstellungsvorgänge erforderlich: einer beim Dateiinhalt und der andere bei den Dateinamen. Zum Glück ist der Großteil dieser Umstellung inzwischen erledigt, und wir erwähnen sie nur der Vollständigkeit halber.
			</para>
			 <sidebar> <title><emphasis>KULTUR</emphasis> <foreignphrase>Zeichensalat</foreignphrase> und Interpretationsfehler</title>
			 <para>
				Wenn ein Text ohne Codierungsinformation verschickt (oder gespeichert) wird, kann der Empfänger nicht immer mit Sicherheit sagen, welche Konvention er zur Bestimmung der Bedeutung eines Bytesatzes verwenden soll. Sie können gewöhnlich eine gewisse Vermutung erhalten, indem Sie Statistiken über die Häufigkeit der im Text vorhandenen Werte betrachten, aber das gibt Ihnen nicht immer eine sichere Antwort. Wenn das zum Lesen herangezogene Codierungssystem sich von dem zum Schreiben der Datei verwendeten unterscheidet, werden die Bytes falsch interpretiert, und Sie erhalten bestenfalls bei einigen Zeichen Fehler und schlimmstenfalls etwas völlig Unleserliches.
			</para>
			 <para>
				Wenn zum Beispiel ein französischer Text normal erscheint bis auf die mit Akzenten versehenen Buchstaben und bestimmte Symbole, die stattdessen durch Zeichenfolgen wie „Ã©“, „Ã¨“ oder „Ã§“ angezeigt werden, handelt es sich vermutlich um eine Datei, die in UTF-8 kodiert ist, aber als ISO-8859-1 oder ISO-8859-15 interpretiert wird. Dies ist ein Hinweis auf eine lokale Installation, die noch nicht auf UTF-8 umgestellt ist. Falls Sie dagegen Fragezeichen anstelle von mit Akzenten versehenen Buchstaben sehen - selbst wenn diese Fragezeichen einen Buchstaben zu ersetzen scheinen, der auf einen mit einem Akzent versehenen Buchstaben hätte folgen sollen - ist es wahrscheinlich, dass Ihre Installation bereits für UTF-8 konfiguriert ist, und dass Ihnen ein in Western ISO codiertes Dokument geschickt worden ist.
			</para>
			 <para>
				Soviel zu den „einfachen“ Fällen. Diese treten nur in westlichen Kulturen auf, da Unicode (und UTF-8) entwickelt wurde, um die Gemeinsamkeiten historischer Codierungen in westlichen, auf Latein basierenden Alphabeten zu maximieren, wodurch es möglich ist, Teile des Textes zu erkennen, selbst wenn einige Buchstaben fehlen.
			</para>
			 <para>
				Bei komplexeren Konfigurationen, bei denen es sich zum Beispiel um zwei Umgebungen mit zwei verschiedenen Sprachen handelt, die nicht dasselbe Alphabet verwenden, erhält man häufig völlig unleserliche Ergebnisse - eine Reihe abstrakter Symbole, die nichts miteinander zu tun haben. Dies ist aufgrund ihrer zahlreichen Sprach- und Schriftsysteme vor allem bei asiatischen Sprachen der Fall. Das japanische Wort <foreignphrase>Mojibake</foreignphrase> wird zur Bezeichnung dieses Phänomens verwendet. Wenn es auftritt, ist eine Diagnose schwierig, und die einfachste Lösung besteht dann häufig darin, auf beiden Seiten einfach auf UTF-8 umzustellen.
			</para>
			 </sidebar> <para>
				Bei Dateinamen kann die Umstellung recht einfach sein. Das Hilfsprogramm <command>convmv</command> (im gleichnamigen Paket) ist speziell zu diesem Zweck entwickelt worden; es ermöglicht die Umbenennung von Dateien von einer Codierung in eine andere. Die Benutzung dieses Hilfsprogramms ist recht einfach, wir empfehlen jedoch, in zwei Schritten vorzugehen, um Überraschungen zu vermeiden. Das folgende Beispiel zeigt eine UTF-8-Umgebung, die in ISO-8859-15 codierte Verzeichnisnamen enthält, und die Verwendung von <command>convmv</command> zu ihrer Umbenennung.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Ic?nes  ?l?ments graphiques  Textes
$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>Starting a dry run without changes...
mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
No changes to your files done. Use --notest to finally rename the files.
$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
Ready!
$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput></screen>
			 <para>
				Für Dateiinhalte sind die Umwandlungsverfahren wegen der enormen Vielfalt bestehender Dateiformate aufwändiger. Einige Dateiformate enthalten Codierungsinformationen, die die Aufgabe der zu ihrer Behandlung eingesetzten Software erleichtern; in diesen Fällen genügt es, die Dateien zu öffnen und sie unter Vorgabe der Codierung als UTF-8 erneut zu speichern. In anderen Fällen muss man beim Öffnen der Datei ihre ursprüngliche Codierung angeben (ISO-8859-1 oder „Western“, beziehungsweise ISO-8859-15 oder „Western (Euro)“ je nach Formulierung).
			</para>
			 <para>
				Für einfache Textdateien kann man <command>recode</command> (im gleichnamigen Paket) verwenden, das ein automatisches Umcodieren ermöglicht. Dieses Hilfsprogramm hat zahlreiche Optionen; Sie können daher mit seinem Verhalten herumspielen. Wir empfehlen Ihnen, die Dokumentation zu Rate zu ziehen, entweder die Handbuchseite <citerefentry> <refentrytitle>recode</refentrytitle>
				 <manvolnum>1</manvolnum> </citerefentry> oder die ausführlichere Informationsseite <citerefentry> <refentrytitle>recode</refentrytitle>
				 </citerefentry>.
			</para>

		</section>

	</section>
	 <section id="sect.network-config">
		<title>Konfigurieren des Netzwerks</title>
		 <sidebar id="sidebar.networking-basics"> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Wesentliche Netzwerkkonzepte (Ethernet, IP-Adresse, Subnetz, Broadcast)</title>
		 <indexterm>
			<primary>Ethernet</primary>
		</indexterm>
		 <indexterm>
			<primary>10BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>100BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>1000BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>10GBASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>Steckverbindung, RJ45</primary>
		</indexterm>
		 <indexterm>
			<primary>RJ45-Steckverbindung</primary>
		</indexterm>
		 <para>
			Die meisten modernen lokalen Netzwerke verwenden das Ethernet-Protokoll, bei dem Daten in kleine Abschnitte, sogenannte „Frames“, unterteilt und dann abschnittsweise über das Kabel übertragen werden. Die Übertragungsgeschwindigkeit reicht von 10 MB/s bei älteren Ethernetkarten bis zu 10 Gb/s bei den neuesten (wobei die üblichste Geschwindigkeit zur Zeit von 100 Mb/s auf 1 Gb/s ansteigt). Die am weitesten verbreiteten Kabel heißen 10BASE-T, 100BASE-T, 1000BASE-T oder 10GBASE-T je nach Durchsatz, den sie verlässlich erreichen können (das T steht für „twisted pair“); diese Kabel haben RJ45-Steckverbindungen. Es gibt auch andere meistens für Geschwindigkeiten 1 Gb/s oder mehr verwendete Kabelarten.
		</para>
		 <indexterm>
			<primary>Adresse, IP-Adresse</primary>
		</indexterm>
		 <indexterm>
			<primary>IP-Adresse</primary>
		</indexterm>
		 <para>
			Eine IP-Adresse ist eine Zahl, die zur Identifizierung einer Netzwerkschnittstelle eines Rechners in einem lokalen Netzwerk oder im Internet dient. In der gegenwärtig am weitesten verbreiteten IP-Version (IPv4) ist diese Zahl in 32 Bits codiert und wird gewöhnlich in Form von vier durch Punkte getrennte Zahlen dargestellt (z. B. <literal>192.168.0.1</literal>), wobei jede Zahl von 0 bis 255 reichen kann (was einem Datenumfang von 8 Bits entspricht). Die nächste Version des Protokolls, IPv6, erweitert den Adressenraum auf 128 Bits, und die Adressen werden normalerweise in Form einer Reihe von hexadezimalen durch Doppelpunkte getrennte Zahlen dargestellt (z. B. 2002:58bf:13bb:0002:0000:0000:0020 oder kurz 2002:58bf:13bb:2::20).
		</para>
		 <indexterm>
			<primary>Subnetz</primary>
		</indexterm>
		 <indexterm>
			<primary>Maske</primary>
			<secondary>Subnetzmaske</secondary>
		</indexterm>
		 <indexterm>
			<primary>Netzwerk</primary>
			<secondary>Adresse</secondary>
		</indexterm>
		 <para>
			Eine Subnetzmaske (Netzmaske) legt in ihrem Binärcode fest, welcher Teil einer IP-Adresse sich auf das Netzwerk bezieht, während der Rest den Rechner bezeichnet. In dem hier dargestellten Beispiel der Konfigurierung einer statischen IPv4-Adresse lässt die Subnetzmaske <literal>255.255.255.0</literal> (24 „1“en gefolgt von 8 „0“en in binärer Darstellung) erkennen, dass sich die ersten 24 Bits der IP-Adresse auf die Netzwerkadresse beziehen und die übrigen 8 rechnerspezifisch sind. Bei IPv6 werden der besseren Lesbarkeit halber nur die „1“en dargestellt; die Netzmaske eines IPv6-Netzwerks könnte daher etwa <literal>64</literal> lauten.
		</para>
		 <para>
			Die Netzwerkadresse ist eine IP-Adresse, bei der der Teil, der die Rechnernummer bezeichnet, 0 ist. Der Bereich der IPv4-Adressen in einem vollständigen Netzwerk wird häufig in Form der Syntax <emphasis>a.b.c.d/e</emphasis> angegeben, wobei <emphasis>a.b.c.d</emphasis> die Netzwerkadresse und <emphasis>e</emphasis> die Bezeichnung der Bits ist, auf die sich der Netzwerkteil einer IP-Adresse auswirkt. Das Beispielsnetzwerk würde somit <literal>192.168.0.0/24</literal> geschrieben. In IPv6 ist die Syntax ähnlich: <literal>2002:58bf:13bb:2::/64</literal>.
		</para>
		 <indexterm>
			<primary>Router</primary>
		</indexterm>
		 <indexterm>
			<primary>Bridge</primary>
		</indexterm>
		 <para>
			Ein Router ist ein Gerät, das mehrere Netzwerke miteinander verbindet. Aller durch einen Router laufender Datenverkehr wird dem richtigen Netzwerk zugeleitet. Hierzu analysiert der Router ankommende Pakete und leitet sie in Abhängigkeit von der IP-Adresse ihres Ziels weiter. Der Router wird häufig als „Gateway“ bezeichnet; in dieser Konfigurierung fungiert er als ein Gerät, das dabei hilft, über das lokale Netzwerk hinauszugelangen (in ein erweitertes Netzwerk wie zum Beispiel das Internet).
		</para>
		 <indexterm>
			<primary>Broadcast</primary>
		</indexterm>
		 <para>
			Die spezielle Broadcast-Adresse verbindet alle Stationen eines Netzwerks. Sie wird fast nie „geroutet“ und funktioniert nur innerhalb des betreffenden Netzwerks. Insbesondere bedeutet dies, das ein an den Broadcast adressiertes Datenpaket niemals über den Router läuft.
		</para>
		 <para>
			Dieses Kapitel befasst sich vor allem mit IPv4-Adressen, da sie zur Zeit die am häufigsten verwendeten sind. Die Einzelheiten des IPv6-Protokolls werden in <xref linkend="sect.ipv6" /> dargelegt; das Konzept bleibt jedoch das gleiche.
		</para>
		 </sidebar> <para>
			The network is automatically configured during the initial installation. If Network Manager gets installed (which is generally the case for full desktop installations), then it might be that no configuration is actually required (for example, if you rely on DHCP on a wired connection and have no specific requirements). If a configuration is required (for example for a WiFi interface), then it will create the appropriate file in <filename>/etc/NetworkManager/system-connections/</filename>.
		</para>
		 <para>
			If Network Manager is not installed, then the installer will configure <emphasis role="pkg">ifupdown</emphasis> by creating the <filename>/etc/network/interfaces</filename> file. A line starting with <literal>auto</literal> gives a list of interfaces to be automatically configured on boot by the <literal>networking</literal> service.
		</para>
		 <para>
			In a server context, <emphasis role="pkg">ifupdown</emphasis> is thus the network configuration tool that you usually get. That is why we will cover it in the next sections.
		</para>
		 <indexterm>
			<primary>Netzwerk</primary>
			<secondary>Konfigurierung</secondary>
		</indexterm>
		 <indexterm>
			<primary>Konfigurierung</primary>
			<secondary>des Netzwerks</secondary>
		</indexterm>
		 <indexterm>
			<primary>Schnittstelle</primary>
			<secondary>Netzwerkschnittstelle</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> NetworkManager</title>
		 <indexterm>
			<primary><emphasis role="pkg">network-manager</emphasis></primary>
		</indexterm>
		 <para>
			If Network Manager is particularly recommended in roaming setups (see <xref linkend="sect.roaming-network-config" />), it is also perfectly usable as the default network management tool. You can create “System connections” that are used as soon as the computer boots either manually with a <filename>.ini</filename>-like file in <filename>/etc/NetworkManager/system-connections/</filename> or through a graphical tool (<command>nm-connection-editor</command>). Just remember to deactivate all entries in <filename>/etc/network/interfaces</filename> if you want Network Manager to handle them. <ulink type="block" url="https://wiki.gnome.org/Projects/NetworkManager/SystemSettings" /> <ulink type="block" url="https://developer.gnome.org/NetworkManager/1.6/ref-settings.html" />
		</para>
		 </sidebar> <section id="sect.interface-ethernet">
			<title>Ethernet-Schnittstelle</title>
			 <para>
				Falls der Rechner eine Ethernet-Karte hat, muss das mit ihr verbundene IP-Netzwerk durch eine von zwei möglichen Verfahren konfiguriert werden. Die einfachste Methode besteht in der dynamischen Konfigurierung mit DHCP, und sie erfordert einen DHCP-Server im lokalen Netzwerk. Bei ihr kann der gewünschte Hostname angegeben werden, wie er in unten stehendem Beispiel unter <literal>hostname</literal> angegeben ist. Der DHCP-Server schickt dann die Konfigurierungseinstellungen für das entsprechende Netzwerk.
			</para>
			 <indexterm>
				<primary>Ethernet</primary>
			</indexterm>
			 <indexterm>
				<primary>DHCP</primary>
			</indexterm>
			 <example id="example.config-dhcp">
				<title>DNS-Konfiguration</title>
				 
<programlisting>
auto enp0s31f6
iface enp0s31f6 inet dhcp
  hostname arrakis
</programlisting>

			</example>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> Names of network interfaces</title>
			 <indexterm>
				<primary><literal>eth0</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>en*</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>wlan0</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>wl*</literal></primary>
			</indexterm>
			 <para>
				By default, the kernel attributes generic names such a <literal>eth0</literal> (for wired Ethernet) or <literal>wlan0</literal> (for WiFi) to the network interfaces. The number in those names is a simple incremental counter representing the order in which they have been detected. With modern hardware, that order might change for each reboot and thus the default names are not reliable.
			</para>
			 <para>
				Fortunately, systemd and udev are able to rename the interfaces as soon as they appear. The default name policy is defined by <filename>/lib/systemd/network/99-default.link</filename> (see <citerefentry><refentrytitle>systemd.link</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> for an explanation of the <literal>NamePolicy</literal> entry in that file). In practice, the names are often based on the device's physical location (as guessed by where they are connected) and you will see names starting with <literal>en</literal> for wired ethernet and <literal>wl</literal> for WiFi. In the example above, the rest of the name indicates, in abbreviated form, a PCI (<literal>p</literal>) bus number (<literal>0</literal>), a slot number (<literal>s31</literal>), a function number (<literal>f6</literal>).
			</para>
			 <para>
				Obviously, you are free to override this policy and/or to complement it to customize the names of some specific interfaces. You can find out the names of the network interfaces in the output of <command>ip addr</command> (or as filenames in <filename>/sys/class/net/</filename>).
			</para>
			 </sidebar> <para>
				Eine „statische“ Konfiguration muss die Netzwerkeinstellungen fest vorgeben. Hierzu gehören wenigstens die IP-Adresse und die Subnetzmaske; Netzwerk- und Broadcast-Adressen werden manchmal ebenfalls aufgeführt. Ein mit der Außenwelt verbundener Router wird als Gateway spezifiziert.
			</para>
			 <example id="example.static-network">
				<title>Statische Konfiguration</title>
				 
<programlisting>
auto enp0s31f6
iface enp0s31f6 inet static
  address 192.168.0.3
  netmask 255.255.255.0
  broadcast 192.168.0.255
  network 192.168.0.0
  gateway 192.168.0.1
</programlisting>

			</example>
			 <sidebar> <title><emphasis>HINWEIS</emphasis> Mehrfache Adressen</title>
			 <para>
				Man kann nicht nur mehrere Schnittstellen einer einzelnen physischen Netzwerkkarte zuordnen, sondern auch mehrere IP-Adressen einer Schnittstelle. Wie bereits erwähnt, kann sich eine IP-Adresse per DNS auf eine beliebige Anzahl von Namen beziehen und ein Name auf eine beliebige Anzahl numerischer IP-Adressen.
			</para>
			 <para>
				Wie Sie vermuten, können Konfigurationen recht komplex sein, jedoch werden diese Optionen nur in sehr speziellen Fällen verwendet. Die hier gezeigten Beispiele sind für gewöhnliche Konfigurationen typisch.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.interface-wireless">
			<title>Wireless Interface</title>
			 <indexterm>
				<primary>wireless</primary>
			</indexterm>
			 <para>
				Getting wireless network cards to work can be a bit more challenging. First of all, they often require the installation of proprietary firmwares which are not installed by default in Debian. Then wireless networks rely on cryptography to restrict access to authorized users only, this implies storing some secret key in the network configuration. Let's tackle those topics one by one.
			</para>
			 <section>
				<title>Installing the required firmwares</title>
				 <indexterm>
					<primary>firmware</primary>
				</indexterm>
				 <indexterm>
					<primary>isenkram</primary>
				</indexterm>
				 <para>
					First you have to enable the non-free repository in APT's sources.list file: see <xref linkend="sect.apt-sources.list" /> for details about this file. Many firmware are proprietary and are thus located in this repository. You can try to skip this step if you want, but if the next step doesn't find the required firmware, retry after having enabled the non-free section.
				</para>
				 <para>
					Then you have to install the appropriate <literal>firmware-*</literal> packages. If you don't know which package you need, you can install the <emphasis role="pkg">isenkram</emphasis> package and run its <command>isenkram-autoinstall-firmware</command> command. The packages are often named after the hardware manufacturer or the corresponding kernel module: <emphasis role="pkg">firmware-iwlwifi</emphasis> for Intel wireless cards, <emphasis role="pkg">firmware-atheros</emphasis> for Qualcomm Atheros, <emphasis role="pkg">firmware-ralink</emphasis> for Ralink, etc. A reboot is then recommended because the kernel driver usually looks for the firmware files when it is first loaded and no longer afterwards.
				</para>

			</section>
			 <section>
				<title>Wireless specific entries in <filename>/etc/network/interfaces</filename></title>
				 <indexterm>
					<primary>WPA</primary>
				</indexterm>
				 <para>
					<emphasis>ifupdown</emphasis> is able to manage wireless interfaces but it needs the help of the <emphasis role="pkg">wpasupplicant</emphasis> package which provides the required integration between <emphasis>ifupdown</emphasis> and the <command>wpa_supplicant</command> command used to configure the wireless interfaces (when using WPA/WPA2 encryption). The usual entry in <filename>/etc/network/interfaces</filename> needs to be extended with two supplementary parameters to specify the name of the wireless network (aka its SSID) and the <emphasis>Pre-Shared Key</emphasis> (PSK).
				</para>
				 <example id="example.config-wireless">
					<title>DHCP configuration for a wireless interface</title>
					 
<programlisting>
auto wlp4s0
iface wlp4s0 inet dhcp
  wpa-ssid Falcot
  wpa-psk ccb290fd4fe6b22935cbae31449e050edd02ad44627b16ce0151668f5f53c01b
</programlisting>
				</example>
				 <para>
					The <literal>wpa-psk</literal> parameter can contain either the plain text passphrase or its hashed version generated with <command>wpa_passphrase <replaceable>SSID</replaceable> <replaceable>passphrase</replaceable></command>. If you use an unencrypted wireless connection, then you should put a <literal>wpa-key-mgmt NONE</literal> and no <literal>wpa-psk</literal> entry. For more information about the possible configuration options, have a look at <filename>/usr/share/doc/wpasupplicant/README.Debian.gz</filename>.
				</para>
				 <para>
					At this point, you should consider restricting the read permissions on <filename>/etc/network/interfaces</filename> to the root user only since the file contains a private key that not all users should have access to.
				</para>
				 <sidebar> <title><emphasis>HISTORY</emphasis> WEP encryption</title>
				 <indexterm>
					<primary>WEP</primary>
				</indexterm>
				 <para>
					Usage of the deprecated WEP encryption protocol is possible with the <emphasis role="pkg">wireless-tools</emphasis> package. See <filename>/usr/share/doc/wireless-tools/README.Debian</filename> for instructions.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.ppp-rtc">
			<title>Mit PPP über ein PSTN-Modem verbinden</title>
			 <indexterm>
				<primary>PPP</primary>
			</indexterm>
			 <indexterm>
				<primary>Punkt zu Punkt</primary>
			</indexterm>
			 <indexterm>
				<primary>Verbindung</primary>
				<secondary>durch PSTN-Modem</secondary>
			</indexterm>
			 <indexterm>
				<primary>Modem</primary>
				<secondary>PSTN</secondary>
			</indexterm>
			 <para>
				Eine Punkt-zu-Punkt-Verbindung (PPP) stellt eine zeitweilige Verbindung her; sie ist die üblichste Lösung bei Verbindungen über ein Telefonmodem („PSTN-Modem“, da die Verbindung über das öffentliche Telefonnetz läuft).
			</para>
			 <para>
				Für eine Verbindung über ein Telefonmodem ist ein Konto bei einem Zugangsanbieter erforderlich, einschließlich Telefonnummer, Benutzername, Passwort und manchmal des zu verwendenden Authentifizierungsprotokolls. Eine derartige Verbindung wird mit dem Hilfsprogramm <command>pppconfig</command> aus dem gleichnamigen Debian-Paket konfiguriert. Standardmäßig konfiguriert es eine Verbindung mit dem Namen <literal>provider</literal> (nach dem Zugangsanbieter). Falls Sie sich bezüglich des Authentifizierungsprotokolls nicht sicher sind, wählen Sie <emphasis>PAP</emphasis>: es wird von der Mehrheit der Internetanbieter angeboten.
			</para>
			 <indexterm>
				<primary><command>pppconfig</command></primary>
			</indexterm>
			 <indexterm>
				<primary>PAP</primary>
			</indexterm>
			 <para>
				Nach der Konfigurierung ist es möglich, mit dem Befehl <command>pon</command> eine Verbindung herzustellen (indem man den Namen der Verbindung als Parameter angibt, falls der Standardwert <literal>provider</literal> nicht passt). Die Verbindung wird mit dem Befehl <command>poff</command> beendet. Diese beiden Befehle können vom Root-Benutzer ausgeführt werden oder von jedem anderen Benutzer, der in der <literal>dip</literal>-Gruppe ist.
			</para>
			 <indexterm>
				<primary><command>pon</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>poff</command></primary>
			</indexterm>

		</section>
		 <section id="sect.adsl">
			<title>Über ein ADSL-Modem verbinden</title>
			 <indexterm>
				<primary>Verbindung</primary>
				<secondary>über ADSL-Modem</secondary>
			</indexterm>
			 <indexterm>
				<primary>Modem</primary>
				<secondary>ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>ADSL, Modem</primary>
			</indexterm>
			 <para>
				Der allgemeine Ausdruck „ADSL-Modem“ bezeichnet eine Vielzahl von Geräten mit sehr unterschiedlichen Funktionen. Die am einfachsten mit Linux zu verwendenden Modems sind solche mit einer Ethernet- (und nicht nur mit einer USB-) Schnittstelle. Sie sind recht beliebt. ADSL-Internet-Anbieter verleihen (oder vermieten) eine „Box“ mit Ethernet-Schnittstelle. Je nach Art des Modems unterscheidet sich die Konfiguration deutlich.
			</para>
			 <section id="sect.adsl-pppoe">
				<title>Modems, die PPPOE unterstützen</title>
				 <indexterm>
					<primary>PPPOE</primary>
				</indexterm>
				 <indexterm>
					<primary><command>pppoeconf</command></primary>
				</indexterm>
				 <para>
					Manche Ethernet-Modems arbeiten mit dem PPPOE-Protokoll (Point to Point Protocol over Ethernet). Das Hilfsprogramm <command>pppoeconf</command> (aus dem gleichnamigen Paket) konfiguriert die Verbindung. Hierzu ändert es die Datei <filename>/etc/ppp/peers/dsl-provider</filename> mit den angegebenen Einstellungen und speichert die Anmeldeinformation in den Dateien <filename>/etc/ppp/pap-secrets</filename> und <filename>/etc/ppp/chap-secrets</filename>. Es wird empfohlen, alle vorgeschlagenen Veränderungen zu akzeptieren.
				</para>
				 <para>
					Sobald die Konfigurierung abgeschlossen ist, können Sie die ADSL-Verbindung mit dem Befehl <command>pon dsl-provider</command> herstellen und mit <command>poff dsl-provider</command> wieder trennen.
				</para>
				 <indexterm>
					<primary><literal>DSL-Anbieter</literal></primary>
				</indexterm>
				 <sidebar> <title><emphasis>TIPP</emphasis> <command>Ppp</command> beim Booten starten</title>
				 <indexterm>
					<primary><command>systemd</command></primary>
				</indexterm>
				 <indexterm>
					<primary><command>init</command></primary>
				</indexterm>
				 <para>
					PPP connections over ADSL are, by definition, intermittent. Since they are usually not billed according to time, there are few downsides to the temptation of keeping them always open. The standard means to do so is to use the init system.
				</para>
				 <para>
					With systemd, adding an automatically restarting task for the ADSL connection is a simple matter of creating a “unit file” such as <filename>/etc/systemd/system/adsl-connection.service</filename>, with contents such as the following:
				</para>
				 
<programlisting>[Unit]
Description=ADSL connection

[Service]
Type=forking
ExecStart=/usr/sbin/pppd call dsl-provider
Restart=always

[Install]
WantedBy=multi-user.target</programlisting>
				 <para>
					Once this unit file has been defined, it needs to be enabled with <command>systemctl enable adsl-connection</command>. Then the loop can be started manually with <command>systemctl start adsl-connection</command>; it will also be started automatically on boot.
				</para>
				 <para>
					Auf Systemen ohne <command>systemd</command> (einschließlich <emphasis role="distribution">Wheezy</emphasis> und früheren Versionen von Debian) funktioniert der Standard SystemV init anders. Auf solchen Systemen genügt es, eine Zeile wie die folgende am Ende der Datei <filename>/etc/inittab</filename> hinzuzufügen; jedes Mal, wenn die Verbindung getrennt wird, wird <command>init</command> sie wieder verbinden.
				</para>
				 
<programlisting>
adsl:2345:respawn:/usr/sbin/pppd call dsl-provider</programlisting>
				 <para>
					For ADSL connections that auto-disconnect on a daily basis, this method reduces the duration of the interruption.
				</para>
				 </sidebar>
			</section>
			 <section id="sect.adsl-pptp">
				<title>Modems, die PPTP unterstützen</title>
				 <indexterm>
					<primary>PPTP</primary>
				</indexterm>
				 <para>
					Das Protokoll PPTP (Point-to-Point Tunneling Protocol) wurde von Microsoft entwickelt. Es wurde zu Beginn von ADSL eingesetzt, dann aber schnell durch PPPOE ersetzt. Falls Sie zur Verwendung dieses Protokolls gezwungen werden, schlagen Sie unter <xref linkend="sect.pptp" /> nach.
				</para>

			</section>
			 <section id="sect.adsl-dhcp">
				<title>Modems, die DHCP unterstützen</title>
				 <para>
					Wenn ein Modem über ein Ethernet-Kabel (gekreuztes Kabel) mit dem Rechner verbunden ist, richten Sie normalerweise auf diesem Rechner eine Netzwerkverbindung mit DHCP ein; das Modem fungiert dann automatisch als Gateway und übernimmt das Routing (das heißt, dass es den Netzwerkverkehr zwischen dem Rechner und dem Internet verwaltet).
				</para>
				 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Gekreuztes Kabel für eine direkte Ethernetverbindung</title>
				 <indexterm>
					<primary>gekreuztes Kabel</primary>
				</indexterm>
				 <para>
					Computer-Netzwerkkarten erwarten den Empfang von Daten auf bestimmten Leitungen des Kabels und senden ihre Daten auf anderen. Wenn Sie einen Rechner mit einem lokalen Netzwerk verbinden, schließen Sie normalerweise ein Kabel (gerade oder gekreuzt) zwischen der Netzwerkkarte und einem Repeater oder Schalter an. Wenn Sie jedoch zwei Rechner direkt miteinander verbinden wollen (ohne einen dazwischenliegenden Schalter oder Repeater), müssen Sie das von der einen Karte ausgesendete Signal zur empfangenen Seite der anderen Karte schicken und umgekehrt. Dies ist der Sinn eines gekreuzten Kabels und der Grund, warum es verwendet wird.
				</para>
				 <para>
					Beachten Sie, dass diese Unterscheidung im Laufe der Zeit fast irrelevant geworden ist, weil moderne Netzwerkkarten in der Lage sind, den angeschlossenen Kabeltyp zu erkennen, so dass oft beide an der gegebenen Schnittstelle funktionieren.
				</para>
				 </sidebar> <para>
					Die meisten ADSL-Router auf dem Markt können derart benutzt werden, genauso wie die meisten ADSL-Modems, die von Internetanbietern zur Verfügung gestellt werden.
				</para>

			</section>

		</section>
		 <section id="sect.roaming-network-config">
			<title>Automatische Netzwerkkonfigurierung für mobile Benutzer</title>
			 <indexterm>
				<primary><emphasis role="pkg">network-manager</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>Netzwerk</primary>
				<secondary>Roaming-Konfigurierung</secondary>
			</indexterm>
			 <para>
				Viele Falcot-Ingenieure haben einen tragbaren Rechner, den sie für berufliche Zwecke auch zu Hause benutzen. Die zu verwendende Netzwerk-Konfigurierung ist je nach Ort verschieden. Zu Hause kann es ein (mit einem WPA-Schlüssel geschütztes) WLAN-Netzwerk sein, während am Arbeitsplatz ein kabelgebundenes Netzwerk mit größerer Sicherheit und höherer Bandbreite benutzt wird.
			</para>
			 <para>
				Um zu vermeiden, dass die entsprechenden Netzwerkschnittstellen von Hand verbunden und getrennt werden müssen, haben die Administratoren auf diesen mobilen Rechnern das Paket <emphasis role="pkg">network-manager</emphasis> installiert. Dieses Programm ermöglicht es einem Anwender, auf einfache Weise über ein Symbol im Benachrichtigungsbereich seiner grafischen Arbeitsumgebung von einem Netzwerk zu einem anderen zu wechseln. Bei einem Klick auf dieses Symbol wird eine Liste der verfügbaren Netzwerke (sowohl der verkabelten als auch der kabellosen) angezeigt, so dass man einfach das Netzwerk auswählen kann, das man benutzen möchte. Das Programm speichert die Konfiguration der Netzwerke, mit denen der Anwender bereits verbunden war, und schaltet automatisch auf das beste verfügbare Netzwerk um, wenn die aktuelle Verbindung abbricht.
			</para>
			 <para>
				Hierzu besteht das Programm aus zwei Teilen: ein als Root laufender Daemon ist für die Aktivierung und Konfigurierung des Netzwerks zuständig, während eine Benutzerschnittstelle diesen Daemon steuert. PolicyKit kümmert sich um die benötigten Autorisierungen zur Steuerung des Programm und Debian hat PolicyKit so konfiguriert, dass Mitglieder der Gruppe netdev Network-Manager-Verbindungen anlegen oder ändern können.
			</para>
			 <para>
				Der Network-Manager weiß, wie er mit verschiedenen Verbindungsarten (DHCP, manuelle Konfigurierung, lokales Netzwerk) umzugehen hat, aber nur, wenn die Konfigurierung mit diesem Programm erfolgt ist. Daher ignoriert es systematisch alle Netzwerk-Schnittstellen in der Datei <filename>/etc/network/interfaces</filename>, für die es nicht geeignet ist. Da der Network-Manager keine genaueren Angaben macht, wenn keine Netzwerkverbindungen angezeigt werden, ist es am einfachsten, aus der Datei <filename>/etc/network/interfaces</filename> alle Schnittstellen zu löschen, die vom Network-Manager verwaltet werden sollen.
			</para>
			 <para>
				Beachten Sie, dass dieses Programm standardmäßig installiert wird, wenn während der anfänglichen Installation die Programmgruppe „Desktop-Umgebung“ ausgewählt wurde.
			</para>

		</section>

	</section>
	 <section id="sect.hostname-name-service">
		<title>Den Hostnamen einstellen und den Namensservice konfigurieren</title>
		 <indexterm>
			<primary>Name</primary>
			<secondary>Zuordnung und Auflösung</secondary>
		</indexterm>
		 <indexterm>
			<primary>Zuweisung von Namen</primary>
		</indexterm>
		 <para>
			Der Sinn der Zuweisung von Namen zu IP-Nummern besteht darin, sie für Menschen leichter merkbar zu machen. Eigentlich bestimmt eine IP-Adresse eine Netzwerk-Schnittstelle, die einem Gerät, wie einer Netzwerkkarte, zugeordnet ist. Da jeder Rechner mehrere Netzwerkkarten haben kann, und jede Karte mehrere Schnittstellen, kann ein einzelner Rechner im Domain-Namenssystem mehrere Namen haben.
		</para>
		 <para>
			Jeder Rechner wird jedoch durch einen offiziellen („kanonischen“) Namen identifiziert, der in der Datei <filename>/etc/hostname</filename> gespeichert ist und vom Linux-Kernel mit Hilfe von Initialisierungsskripten durch den Befehl <command>hostname</command> bekanntgegeben wird. Die aktuelle Einstellung ist in einem virtuellen Dateisystem verfügbar und kann mit dem Befehl <command>cat /proc/sys/kernel/hostname</command> abgerufen werden.
		</para>
		 <indexterm>
			<primary><command>Hostname</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> <filename>/proc/</filename> und <filename>/sys/</filename>, virtuelle Dateisysteme</title>
		 <indexterm>
			<primary><filename>/proc/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>proc</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/sys/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>sys</filename></primary>
		</indexterm>
		 <para>
			Die Verzeichnisbäume <filename>/proc/</filename> und <filename>/sys/</filename> werden von „virtuellen“ Dateisystemen erzeugt. Dies ist ein praktisches Verfahren, um (durch das Auflisten virtueller Dateien) Informationen vom Kernel zu erhalten, oder sie (durch das Schreiben in virtuelle Dateien) an ihn zu übermitteln.
		</para>
		 <para>
			Insbesondere <filename>/sys/</filename> ist dazu bestimmt, Zugang zu internen Kernelobjekten zu ermöglichen, vor allem solchen, die verschiedene Geräte des Systems darstellen. Der Kernel kann auf diese Weise verschiedene Arten von Informationen anzeigen: den Status jeden Geräts (ob es zum Beispiel im Energiesparmodus ist), ob es ein abnehmbares Gerät ist usw. Beachten Sie, dass es <filename>/sys/</filename> erst seit der Kernelversion 2.6 gibt.
		</para>
		 </sidebar> <para>
			Überraschenderweise wird der Domain-Name nicht in dieser Weise verwaltet, sondern ergibt sich aus dem vollständigen Namen des Rechners, der durch Namensauflösung erlangt wird. Sie können ihn in der Datei <filename>/etc/hosts</filename> ändern; schreiben Sie einfach einen vollständigen Namen für den Rechner an den Anfang der Liste von Namen, die der Adresse des Rechners zugeordnet sind, wie in dem folgenden Beispiel:
		</para>
		 <informalexample> 
<programlisting>
127.0.0.1     localhost
192.168.0.1   arrakis.falcot.com arrakis</programlisting>
		 </informalexample> <indexterm>
			<primary><filename>hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/etc/hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary>Domain</primary>
			<secondary>Name</secondary>
		</indexterm>
		 <indexterm>
			<primary>Name</primary>
			<secondary>Domain</secondary>
		</indexterm>
		 <indexterm>
			<primary>NSS</primary>
		</indexterm>
		 <section id="sect.name-resolution">
			<title>Namensauflösung</title>
			 <indexterm>
				<primary>Auflösung</primary>
				<secondary>Name</secondary>
			</indexterm>
			 <indexterm>
				<primary>Name</primary>
				<secondary>Auflösung</secondary>
			</indexterm>
			 <para>
				Das Verfahren zur Namensauflösung in Linux ist modular und kann verschiedene in der Datei <filename>/etc/nsswitch.conf</filename> aufgeführte Informationsquellen verwenden. Der Eintrag, der sich auf die Namensauflösung bezieht, ist <literal>hosts</literal>. Standardmäßig enthält es den Ausdruck <literal>files dns</literal>, der bedeutet, dass das System zunächst in der Datei <filename>/etc/hosts</filename> nachsieht und dann bei DNS-Servern. NIS/NIS+ und LDAP-Server sind weitere mögliche Quellen.
			</para>
			 <sidebar> <title><emphasis>HINWEIS</emphasis> NSS und DNS</title>
			 <para>
				Beachten Sie, dass die Befehle, die eigens dafür gedacht sind, DNS abzufragen (insbesondere <command>host</command>), nicht das Standardverfahren zur Namensauflösung (NSS) verwenden. Dies hat zur Folge, dass sie <filename>/etc/nsswitch.conf</filename> nicht berücksichtigen und damit <filename>/etc/hosts</filename> auch nicht.
			</para>
			 </sidebar> <section id="sect.dns-server-configuration">
				<title>DNS-Server konfigurieren</title>
				 <indexterm>
					<primary>DNS</primary>
				</indexterm>
				 <indexterm>
					<primary>Domain Name Service</primary>
				</indexterm>
				 <para>
					DNS (Domain Name Service) ist ein verteilter und hierarchischer Dienst, der für Namen die dazugehörigen IP-Adressen ermittelt und umgekehrt. Insbesondere kann er einen menschengerechten Namen wie zum Beispiel <literal>www.eyrolles.com</literal> in die entsprechende IP-Adresse <literal>213.244.11.247</literal> umwandeln.
				</para>
				 <para>
					Um auf DNS-Informationen zugreifen zu können, muss ein DNS-Server zur Übertragung der Anfragen zur Verfügung stehen. Falcot Corp. hat seinen eigenen, aber ein einzelner Anwender wird eher die DNS-Server seines Internetanbieters nutzen.
				</para>
				 <indexterm>
					<primary><filename>resolv.conf</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><literal>Namensserver</literal></primary>
				</indexterm>
				 <para>
					Die zu verwendenden DNS-Server sind in der Datei <filename>/etc/resolv.conf</filename> aufgeführt, jeweils einer pro Zeile, wobei wie im folgenden Beispiel das Stichwort <literal>nameserver</literal> vor einer IP-Adresse steht:
				</para>
				 
<programlisting>
nameserver 212.27.32.176
nameserver 212.27.32.177
nameserver 8.8.8.8</programlisting>
				 <para>
					Note that the <filename>/etc/resolv.conf</filename> file may be handled automatically (and overwritten) when the network is managed by NetworkManager or configured via DHCP.
				</para>

			</section>
			 <section id="sect.etc-hosts">
				<title>Die Datei <filename>/etc/hosts</filename></title>
				 <indexterm>
					<primary><filename>hosts</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/hosts</filename></primary>
				</indexterm>
				 <para>
					Falls es im lokalen Netzwerk keinen Namensserver gibt, ist es möglich, stattdessen in der Datei <filename>/etc/hosts</filename>, die normalerweise für lokale Netzwerkrechner reserviert ist, eine kleine Tabelle zu erstellen, in der IP-Adressen und Hostnamen von Rechnern einander zugeordnet sind. Die Syntax dieser Datei ist sehr einfach: jede Zeile enthält eine spezifische IP-Adresse gefolgt von der Liste der ihr zugeordneten Namen (von denen der erste „vollständig ausgewiesen“ ist, das heißt, dass er den Domain-Namen enthält).
				</para>
				 <para>
					Diese Datei ist selbst bei Netzwerkausfällen verfügbar, oder wenn DNS-Server nicht erreichbar sind, ist aber nur dann wirklich nützlich, wenn sie auf alle Rechner des Netzwerks kopiert wurde. Bei der kleinsten Veränderung in den Zuordnungen muss die Datei überall aktualisiert werden. Deshalb enthält <filename>/etc/hosts</filename> gewöhnlich nur die wichtigsten Einträge.
				</para>
				 <para>
					Diese Datei reicht für ein kleines nicht mit dem Internet verbundenes Netzwerk aus; ab fünf Rechnern ist es aber empfehlenswert, einen richtigen DNS-Server einzurichten.
				</para>
				 <sidebar> <title><emphasis>TIPP</emphasis> DNS umgehen</title>
				 <para>
					Da Anwendungen vor einer DNS-Anfrage zunächst in der Datei <filename>/etc/hosts</filename> nachsehen, kann man dort Informationen ablegen, die sich von dem unterscheiden, was der DNS ausgeben würde, und so die normale DNS-basierte Namensauflösung umgehen.
				</para>
				 <para>
					Hierdurch ist es möglich, im Falle von DNS-Änderungen, die noch nicht verbreitet sind, den Zugang zu einer Webseite mit dem vorgesehenen Namen zu testen, selbst wenn dieser Name der richtigen IP-Adresse noch nicht ordnungsgemäß zugeordnet ist.
				</para>
				 <para>
					Eine weitere Verwendungsmöglichkeit besteht darin, den für einen bestimmten Rechner gedachten Verkehr zum lokalen Computer (local host) umzuleiten und so jegliche Kommunikation mit dem betreffenden Rechner zu unterbinden. Beispielsweise können die Hostnamen von Servern, die für das Ausliefern von Werbeanzeigen zuständig sind, umgelenkt werden, und so diese Anzeigen zu umgehen, was zu einem flüssigeren und weniger störenden Navigieren führt.
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.user-group-databases">
		<title>Benutzer- und Gruppendatenbanken</title>
		 <indexterm>
			<primary>Benutzer</primary>
			<secondary>Datenbank</secondary>
		</indexterm>
		 <indexterm>
			<primary>Gruppe</primary>
			<secondary>Datenbank</secondary>
		</indexterm>
		 <indexterm>
			<primary>Datenbank</primary>
			<secondary>von Benutzern</secondary>
		</indexterm>
		 <indexterm>
			<primary>Datenbank</primary>
			<secondary>von Gruppen</secondary>
		</indexterm>
		 <para>
			Die Liste der Benutzer ist normalerweise in der Datei <filename>/etc/passwd</filename> gespeichert, während die Datei <filename>/etc/shadow</filename> verschlüsselte Passwörter speichert. Beide sind Textdateien in einem recht einfachen Format, das mit einem Texteditor gelesen und geändert werden kann. Jeder Benutzer ist darin in einer Zeile mit mehreren durch einen Doppelpunkt („<literal>:</literal>“) getrennten Feldern aufgeführt.
		</para>
		 <sidebar> <title><emphasis>HINWEIS</emphasis> Systemdateien editieren</title>
		 <para>
			Die in diesem Kapitel erwähnten Systemdateien sind alle reine Textdateien und können mit einem Texteditor editiert werden. Angesichts ihrer Bedeutung für die Funktionalität des Kernsystems empfiehlt es sich, bei ihrer Bearbeitung besondere Vorsicht walten zu lassen. Erstens sollten Sie eine Systemdatei immer kopieren oder sichern, bevor Sie sie öffnen oder verändern. Und zweitens sollten Sie auf Servern und auf Rechnern, bei denen möglicherweise zur gleichen Zeit mehr als eine Person auf dieselbe Datei zugreifen könnte, besondere Maßnahmen zum Schutz vor Dateibeschädigungen treffen.
		</para>
		 <para>
			Hierzu genügt es, den Befehl <command>vipw</command> zum Editieren der Datei <filename>/etc/passwd</filename> oder <command>vigr</command> zum Editieren der Datei <filename>/etc/group</filename> zu benutzen. Diese Befehle sperren die entsprechende Datei vor dem Start des Texteditors (standardmäßig <command>vi</command>, es sei denn, dass die Umgebungsvariable <varname>EDITOR</varname> verändert worden ist). Durch die Option <literal>-s</literal> ist es bei diesen Befehlen möglich, die entsprechende <foreignphrase>shadow</foreignphrase>-Datei zu editieren.
		</para>
		 </sidebar> <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Crypt, eine Einwegfunktion</title>
		 <indexterm>
			<primary>crypt</primary>
		</indexterm>
		 <para>
			<command>crypt</command> ist eine Einwegfunktion, die eine Zeichenkette (<varname>A</varname>) derart in eine andere Zeichenkette (<varname>B</varname>) umwandelt, dass <varname>A</varname> nicht von <varname>B</varname> abgeleitet werden kann. Der einzige Weg, <varname>A</varname> zu bestimmen, besteht darin, alle möglichen Werte auszuprobieren und jeden dahingehend zu überprüfen, ob seine Umwandlung durch diese Funktion <varname>B</varname> ergibt oder nicht. Sie verwendet als Eingabe 8 Zeichen (Zeichenkette <varname>A</varname>) und erzeugt eine Zeichenkette von 13 druckbaren ASCII-Zeichen (Zeichenkette <varname>B</varname>).
		</para>
		 </sidebar> <section id="sect.etc-passwd">
			<title>Benutzerliste: <filename>/etc/passwd</filename></title>
			 <para>
				Hier ist die Liste der Felder in der Datei <filename>/etc/passwd</filename>:
			</para>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/passwd</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>uid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>gid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>GECOS</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>login</literal></primary>
			</indexterm>
			 <itemizedlist>
				<listitem>
					<para>
						login, zum Beispiel <literal>rhertzog</literal>;
					</para>

				</listitem>
				 <listitem>
					<para>
						password: dies ist ein mit einer Einwegfunktion (<command>crypt</command>) basierend auf <literal>DES</literal>, <literal>MD5</literal>, <literal>SHA-256</literal> or <literal>SHA-512</literal>verschlüsseltes Passwort. Der besondere Wert „<literal>x</literal>" bedeutet, dass das verschlüsselte Passwort in der Datei <filename>/etc/shadow</filename> gespeichert ist;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uid</literal>: eine eindeutige Zahl zur Identifizierung jeden Benutzers;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: eine eindeutige Zahl für die Hauptgruppe des Benutzers (Debian erstellt standardmäßig für jeden Benutzer eine besondere Gruppe);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>GECOS</literal>: Datenfeld, das gewöhnlich den vollständigen Namen des Benutzers enthält;
					</para>

				</listitem>
				 <listitem>
					<para>
						Benutzerverzeichnis, das dem Benutzer zur Speicherung seiner persönlichen Dateien zugewiesen ist (die Umgebungsvariable <varname>$HOME</varname> verweist üblicherweise hierauf);
					</para>

				</listitem>
				 <listitem>
					<para>
						bei der Anmeldung auszuführendes Programm. Dies ist gewöhnlich ein Befehlszeileninterpreter (Shell), der dem Benutzer freie Hand lässt. Falls Sie hier <command>/bin/false</command> angeben (das nichts tut und die Steuerung gleich wieder zurück gibt), kann sich der Benutzer nicht anmelden.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Unix-Gruppen</title>
			 <indexterm>
				<primary>Gruppe</primary>
			</indexterm>
			 <para>
				Eine Unix-Gruppe ist eine Einheit, die mehrere Benutzer umfasst, so dass diese auf einfache Weise Dateien unter Verwendung des integrierten Berechtigungssystems gemeinsam benutzen können (wobei sie von den gleichen Berechtigungen profitieren). Man kann auch die Verwendung bestimmter Programme auf eine besondere Gruppe begrenzen.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-shadow">
			<title>Die versteckte und verschlüsselte Passwortdatei: <filename>/etc/shadow</filename></title>
			 <indexterm>
				<primary><filename>shadow</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/shadow</filename></primary>
			</indexterm>
			 <para>
				Die Datei <filename>/etc/shadow</filename> enthält die folgenden Felder:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						Anmeldung;
					</para>

				</listitem>
				 <listitem>
					<para>
						verschlüsseltes Passwort;
					</para>

				</listitem>
				 <listitem>
					<para>
						mehrere Felder zur Verwaltung des Verfalls der Passwörter.
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>DOKUMENTATION</emphasis> Dateiformate von <filename>/etc/passwd</filename>, <filename>/etc/shadow</filename> und <filename>/etc/group</filename></title>
			 <para>
				Diese Formate sind auf den folgenden Handbuchseiten dokumentiert: <citerefentry><refentrytitle>passwd</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>, <citerefentry><refentrytitle>shadow</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> und <citerefentry><refentrytitle>group</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>.
			</para>
			 </sidebar> <sidebar> <title><emphasis>SICHERHEIT</emphasis> Dateisicherheit von <filename>/etc/shadow</filename></title>
			 <para>
				Im Gegensatz zu ihrem Alter Ego <filename>/etc/passwd</filename> kann die Datei <filename>/etc/shadow</filename> nicht von normalen Benutzern gelesen werden. Jedes in <filename>/etc/passwd</filename> gespeicherte verschlüsselte Passwort kann von jedem gelesen werden; ein Cracker könnte versuchen, durch eine von verschiedenen „Brute-Force-Methoden“, die einfach gesagt häufig verwendete Zeichenkombinationen raten, ein Passwort zu „knacken“ (oder aufzudecken). Diese - „Wörterbuchangriff“ genannte - Attacke ist auf Systemen, die <filename>/etc/shadow</filename> verwenden, nicht mehr möglich.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.account-modification">
			<title>Ein bestehende Konto oder Passwort ändern</title>
			 <indexterm>
				<primary><command>chsh</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chfn</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chage</command></primary>
			</indexterm>
			 <indexterm>
				<primary>Passwort</primary>
			</indexterm>
			 <para>
				Mit den folgenden Befehlen ist es möglich, die in bestimmten Feldern der Benutzerdatenbanken gespeicherten Informationen zu verändern: <command>passwd</command> erlaubt es einem normalen Benutzer, sein Passwort zu ändern, wodurch wiederum die Datei <filename>/etc/shadow</filename> aktualisiert wird; <command>chfn</command> (CHange Full Name) ist für den Superuser (Root) reserviert und verändert das Feld <literal>GECOS</literal>. <command>chsh</command> (CHange SHell) ermöglicht es dem Benutzer, seine Anmelde-Shell zu wechseln, jedoch ist dabei die Auswahl auf diejenigen begrenzt, die in der Datei <filename>/etc/shells</filename> aufgeführt sind; dagegen ist der Administrator nicht an diese Einschränkung gebunden und kann als Shell jedes von ihm gewählte Programm einstellen.
			</para>
			 <para>
				Schließlich ermöglicht der Befehl <command>chage</command> (CHange AGE) es dem Administrator, die Passwort-Verfallseinstellungen zu ändern (mit der Option <literal>-l <replaceable>benutzer</replaceable></literal> werden die aktuellen Einstellungen aufgelistet). Man kann auch den Verfall eines Passworts mit dem Befehl <command>passwd -e <replaceable>benutzer</replaceable></command> erzwingen, wodurch der Benutzer bei der nächsten Anmeldung sein Passwort ändern muss.
			</para>

		</section>
		 <section id="sect.disabling-account">
			<title>Ein Konto sperren</title>
			 <indexterm>
				<primary>Ein Konto sperren</primary>
			</indexterm>
			 <indexterm>
				<primary>Konto</primary>
				<secondary>sperren</secondary>
			</indexterm>
			 <para>
				Es kann sein, dass Sie als Disziplinarmaßnahme, zum Zweck einer Untersuchung oder einfach im Falle einer längeren oder endgültigen Abwesenheit eines Benutzers ein „Konto sperren“ (einen Benutzer ausschließen) müssen. Ein gesperrtes Konto bedeutet, dass sich der Benutzer nicht mehr anmelden und Zugang zum Rechner erhalten kann. Das Konto bleibt unversehrt auf dem Rechner, und weder Dateien noch Daten werden gelöscht; es ist einfach nur nicht mehr zugänglich. Dies wird mit dem Befehl <command>passwd -l <replaceable>benutzer</replaceable></command> erreicht (zum Sperren). Die erneute Freigabe des Kontos geschieht auf ähnliche Weise mit der Option <literal>-u</literal> (zum Entsperren).
			</para>
			 <sidebar id="sidebar.intro-nss"> <title><emphasis>WEITERE SCHRITTE</emphasis> NSS und Systemdatenbanken</title>
			 <indexterm>
				<primary>NSS</primary>
			</indexterm>
			 <indexterm>
				<primary>Name Service Switch</primary>
			</indexterm>
			 <para>
				Anstatt die üblichen Dateien zur Verwaltung der Benutzer- und Gruppenlisten zu benutzen, könnten Sie andere Arten von Datenbanken verwenden, wie zum Beispiel LDAP oder <command>db</command>, indem sie ein passendes NSS-Modul (Name Service Switch) einsetzen. Die verwendeten Module werden in der Datei <filename>/etc/nsswitch.conf</filename> unter den Einträgen <literal>passwd</literal>, <literal>shadow</literal> und <literal>group</literal> aufgeführt. Siehe <xref linkend="sect.config-nss" /> für ein konkretes Beispiel zum Einsatz eines NSS-Moduls durch LDAP.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-group">
			<title>Gruppenliste: <filename>/etc/group</filename></title>
			 <para>
				Gruppen sind in der Datei <filename>/etc/group</filename> aufgelistet, einer einfachen Textdatenbank in einem der Datei <filename>/etc/passwd</filename> ähnlichen Format mit folgenden Feldern:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						Gruppenname;
					</para>

				</listitem>
				 <listitem>
					<para>
						Passwort (optional): Dies wird nur dann zum Beitritt zu einer Gruppe benutzt, wenn jemand dort normalerweise nicht Mitglied ist (mit den Befehlen <command>newgrp</command> oder <command>sg</command>, siehe Seitenleiste <xref linkend="sidebar.working-with-several-groups" />);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>: eindeutige Gruppenidentifikationsnummer;
					</para>

				</listitem>
				 <listitem>
					<para>
						Mitgliederliste: Liste mit den Namen der Benutzer, die Mitglieder der Gruppe sind, getrennt durch Kommata.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
			</para>
			 <sidebar id="sidebar.working-with-several-groups"> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Mit mehreren Gruppen arbeiten</title>
			 <indexterm>
				<primary><command>newgrp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sg</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>id</command></primary>
			</indexterm>
			 <indexterm>
				<primary>Gruppe</primary>
				<secondary>wechseln</secondary>
			</indexterm>
			 <para>
				Jeder Benutzer kann Mitglied zahlreicher Gruppen sein; von diesen ist eine seine „Hauptgruppe“. Die Hauptgruppe eines Benutzers wird standardmäßig während der ursprünglichen Benutzerkonfigurierung erstellt. Gemäß der Voreinstellung gehört jede Datei, die ein Benutzer erstellt, ihm selbst sowie auch seiner Hauptgruppe. Dies ist nicht immer wünschenswert; wenn zum Beispiel der Benutzer in einem Verzeichnis arbeiten muss, das von einer anderen Gruppe als seiner Hauptgruppe gemeinsam genutzt wird. In diesem Fall muss der Benutzer seine Hauptgruppe mit einem der folgenden Befehle wechseln: <command>newgrp</command>, der eine neue Shell startet, oder <command>sg</command>, der einfach einen Befehl unter Verwendung der angegebenen alternativen Gruppe ausführt. Diese Befehle ermöglichen es dem Benutzer also, einer Gruppe beizutreten, der er nicht angehört. Falls die Gruppe durch ein Passwort geschützt ist, muss er das richtige Passwort angeben, bevor der Befehl ausgeführt wird.
			</para>
			 <para>
				Stattdessen kann der Benutzer das <literal>setgid</literal>-Bit auf das Verzeichnis setzen, wodurch in diesem Verzeichnis erstellte Dateien automatisch zur richtigen Gruppe gehören. Zu weiteren Einzelheiten siehe <xref linkend="sidebar.setgid-dir" /> in der Seitenleiste.
			</para>
			 <para>
				Der Befehl <command>id</command> zeigt den aktuellen Status eines Benutzers an mit seiner persönlichen Kennung (Variable <varname>uid</varname>), der aktuellen Hauptgruppe (Variable <varname>gid</varname>) und der Liste der Gruppen, zu denen er gehört (Variable <varname>Gruppen</varname>).
			</para>
			 </sidebar> <indexterm>
				<primary><filename>group</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/group</filename></primary>
			</indexterm>
			 <para>
				The <command>addgroup</command> and <command>delgroup</command> commands add or delete a group, respectively. The <command>groupmod</command> command modifies a group's information (its <literal>gid</literal> or identifier). The command <command>gpasswd <replaceable>group</replaceable></command> changes the password for the group, while the <command>gpasswd -r <replaceable>group</replaceable></command> command deletes it.
			</para>
			 <indexterm>
				<primary><command>addgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>delgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>groupmod</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>gpasswd</command></primary>
			</indexterm>
			 <indexterm>
				<primary>Gruppe</primary>
				<secondary>Erstellung</secondary>
			</indexterm>
			 <indexterm>
				<primary>Erstellung</primary>
				<secondary>von Gruppen</secondary>
			</indexterm>
			 <indexterm>
				<primary>Gruppe</primary>
				<secondary>Löschen</secondary>
			</indexterm>
			 <indexterm>
				<primary>Löschen einer Gruppe</primary>
			</indexterm>
			 <sidebar> <title><emphasis>TIPP</emphasis> <command>getent</command></title>
			 <indexterm>
				<primary><command>getent</command></primary>
			</indexterm>
			 <para>
				Der Befehl <command>getent</command> (get entries) überprüft die Systemdatenbanken auf dem normalen Weg unter Verwendung der passenden Bibliotheksfunktionen, die ihrerseits die in der Datei <filename>/etc/nsswitch.conf</filename> konfigurierten NSS-Module aufrufen. Der Befehl nimmt ein oder zwei Argumente an: den Namen der zu überprüfenden Datenbank und möglicherweise einen Suchbegriff. So zeigt der Befehl <command>getent passwd rhertzog</command> Informationen aus der Benutzerdatenbank über den Benutzer <literal>rhertzog</literal> an.
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.creating-accounts">
		<title>Konten erstellen</title>
		 <indexterm>
			<primary>Konto</primary>
			<secondary>Erstellung</secondary>
		</indexterm>
		 <indexterm>
			<primary>Erstellung</primary>
			<secondary>von Benutzerkonten</secondary>
		</indexterm>
		 <para>
			Eine der ersten Aktionen, die ein Administrator zu erledigen hat, wenn er einen neuen Rechner einrichtet, ist das Erstellen von Benutzerkonten. Dies geschieht normalerweise mit dem Befehl <command>adduser</command>, der einen Benutzernamen für den neu zu erstellenden Benutzer als Argument annimmt.
		</para>
		 <indexterm>
			<primary><command>adduser</command></primary>
		</indexterm>
		 <para>
			Der Befehl <command>adduser</command> stellt einige Fragen, bevor er ein Konto erstellt, aber seine Benutzung ist ziemlich unkompliziert. Seine Konfigurationsdatei <filename>/etc/adduser.conf</filename> enthält alle relevanten Einstellungen: sie kann dazu verwendet werden, durch das Erstellen von Benutzervorlagen automatisch eine Quota für jeden neuen Benutzer zu setzen oder den Ort des Benutzerkontos zu ändern; letzteres wird selten gebraucht, erweist sich aber als nützlich, wenn man eine große Zahl von Benutzern hat und zum Beispiel ihre Konten über mehrere Platten aufteilen will. Man kann hiermit auch eine andere Standardshell auswählen.
		</para>
		 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Quota</title>
		 <indexterm>
			<primary>kontingent</primary>
		</indexterm>
		 <para>
			Der Begriff „Quota“ bezeichnet die Begrenzung der Rechnerressourcen, die ein Benutzer verwenden darf. Es bezieht sich häufig auf den Festplattenplatz.
		</para>
		 </sidebar> <para>
			Bei der Erstellung eines Kontos wird das Home-Verzeichnis des Benutzers mit dem Inhalt der Vorlage <filename>/etc/skel/</filename> befüllt. Hierdurch wird dem Benutzer ein Satz von Standardverzeichnissen und Konfigurationsdateien zur Verfügung gestellt.
		</para>
		 <indexterm>
			<primary>Gruppe</primary>
			<secondary>einen Benutzer hinzufügen</secondary>
		</indexterm>
		 <indexterm>
			<primary>einen Benutzer zu einer Gruppe hinzufügen</primary>
		</indexterm>
		 <para>
			Manchmal ist es nützlich, einen Benutzer einer Gruppe hinzuzufügen (einer anderen als seiner voreingestellten „Hauptgruppe“), um ihm zusätzliche Berechtigungen zu gewähren. So kann zum Beispiel ein Benutzer, der Mitglied der <emphasis>audio</emphasis>-Gruppe ist, auf Audiogeräte zugreifen (siehe Seitenleiste <xref linkend="sidebar.special-files" />). Dies kann durch einen Befehl wie <command>adduser <replaceable>benutzer</replaceable> <replaceable>gruppe</replaceable></command> erreicht werden.
		</para>
		 <sidebar id="sidebar.special-files"> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Zugriffsberechtigungen für Geräte</title>
		 <indexterm>
			<primary>Gerät</primary>
			<secondary>Zugriffsberechtigungen</secondary>
		</indexterm>
		 <indexterm>
			<primary>Datei</primary>
			<secondary>besondere</secondary>
		</indexterm>
		 <indexterm>
			<primary>Modus</primary>
			<secondary>Zeichen</secondary>
		</indexterm>
		 <indexterm>
			<primary>Modus</primary>
			<secondary>Block</secondary>
		</indexterm>
		 <indexterm>
			<primary>Block, Modus</primary>
		</indexterm>
		 <indexterm>
			<primary>Zeichen, Modus</primary>
		</indexterm>
		 <indexterm>
			<primary>besondere, Datei</primary>
		</indexterm>
		 <indexterm>
			<primary><command>mknod</command></primary>
		</indexterm>
		 <para>
			Bei Unix wird jedes Hardware-Peripheriegerät durch eine besondere Datei dargestellt, die gewöhnlich im Verzeichnisbaum unter <filename>/dev/</filename> (DEVices) gespeichert ist. Es gibt in Abhängigkeit von der Art des Gerätes zwei besondere Dateien: Dateien des „Zeichenmodus“ und des „Blockmodus“, von denen jede nur eine begrenzte Anzahl von Operationen ermöglicht. Während der Zeichenmodus die Interaktion mit Lese-/Schreiboperationen beschränkt, ermöglicht der Blockmodus auch die Suche innerhalb der verfügbaren Daten. Jede spezielle Datei ist schließlich zwei Zahlen zugeordnet (einer „Haupt“- und einer „Nebenzahl“), die das Gerät für den Kernel in eindeutiger Weise bezeichnen. Eine derartige Datei, die mit dem Befehl <command>mknod</command> erstellt wird, enthält einfach nur einen symbolischen (und menschenfreundlicheren) Namen.
		</para>
		 <para>
			Die Berechtigungen einer besonderen Datei bilden die für den Zugriff auf das Gerät selbst erforderlichen Berechtigungen ab. So hat eine Datei wie zum Beispiel <filename>/dev/mixer</filename>, die den Audiomixer darstellt, nur Lese-/Schreibberechtigungen für den Root-Benutzer und für Mitglieder der <literal>audio</literal>-Gruppe. Nur diese Benutzer können den Audiomixer bedienen.
		</para>
		 <para>
			Es sei darauf hingewiesen, dass durch die Kombination von <emphasis role="pkg">udev</emphasis>, <emphasis role="pkg">consolekit</emphasis> und <emphasis role="pkg">policykit</emphasis> zusätzliche Berechtigungen vergeben werden können, die es Benutzern, die physisch (und nicht über das Netzwerk) mit dem Terminal verbunden sind, ermöglicht, auf bestimmte Geräte zuzugreifen.
		</para>
		 </sidebar>
	</section>
	 <section id="sect.shell-environment">
		<title>Shell-Umgebung</title>
		 <para>
			Befehlsinterpreter (oder Shells) könen für einen Benutzer der erste Berührungspunkt mit einem Computer sein und sie müssen daher recht bedienerfreundlich sein. Die meisten verwenden Initialisierungsskripten, mit denen ihr Verhalten konfiguriert werden kann (Autovervollständigung, Text an der Eingabeaufforderung usw.).
		</para>
		 <indexterm>
			<primary>Befehlszeilenschnittstelle</primary>
		</indexterm>
		 <indexterm>
			<primary>Kommandointerpreter</primary>
		</indexterm>
		 <indexterm>
			<primary>Shell</primary>
		</indexterm>
		 <indexterm>
			<primary><command>bash</command></primary>
		</indexterm>
		 <para>
			<command>bash</command>, die Standardshell, verwendet das Initialisierungsskript <filename>/etc/bash.bashrc</filename> für „interaktive“ Shells und <filename>/etc/profile</filename> für „Anmelde“-Shells.
		</para>
		 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Anmeldeshell und (nicht) interaktive Shell</title>
		 <para>
			Einfach ausgedrückt wird eine Anmeldeshell aufgerufen, wenn Sie sich entweder lokal oder entfernt via <command>ssh</command> an der Konsole anmelden oder durch einen expliziten Befehl <command>bash --login</command>. Unabhängig davon, ob es sich um eine Anmeldeshell handelt oder nicht, kann eine Shell interaktiv sein (zum Beispiel in einem Terminal des Typs <command>xterm</command>) oder nicht interaktiv (wenn ein Skript ausgeführt wird).
		</para>
		 </sidebar> <sidebar> <title><emphasis>ENTDECKUNG</emphasis> Andere Shells, andere Skripten</title>
		 <para>
			Each command interpreter has a specific syntax and its own configuration files. Thus, <command>zsh</command> uses <filename>/etc/zshrc</filename> and <filename>/etc/zshenv</filename>; <command>tcsh</command> uses <filename>/etc/csh.cshrc</filename>, <filename>/etc/csh.login</filename> and <filename>/etc/csh.logout</filename>. The man pages for these programs document which files they use.
		</para>
		 <indexterm>
			<primary><command>zsh</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>tcsh</command></primary>
		</indexterm>
		 </sidebar> <para>
			Bei <command>bash</command> ist es hilfreich, die „automatische Vervollständigung“ in der Datei <filename>/etc/bash.bashrc</filename> zu aktivieren (einfach bei einigen Zeilen das Kommentarzeichen entfernen).
		</para>
		 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Automatische Vervollständigung</title>
		 <indexterm>
			<primary>automatische Vervollständigung</primary>
		</indexterm>
		 <para>
			Viele Befehlsinterpreter verfügen über eine Vervollständigungsfunktion, durch die die Shell einen teilweise eingegebenen Befehl oder ein Argument automatisch vervollständigen kann, indem der Benutzer die <keycap>Tab</keycap>-Taste drückt. So können Benutzer effizienter arbeiten und sind weniger fehleranfällig.
		</para>
		 <para>
			This function is very powerful and flexible. It is possible to configure its behavior according to each command. Thus, the first argument following <command>apt</command> will be proposed according to the syntax of this command, even if it does not match any file (in this case, the possible choices are <literal>install</literal>, <literal>remove</literal>, <literal>upgrade</literal>, etc.).
		</para>
		 </sidebar> <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Die Tilde, eine Abkürzung für HOME</title>
		 <indexterm>
			<primary>~</primary>
		</indexterm>
		 <indexterm>
			<primary>Tilde</primary>
		</indexterm>
		 <para>
			Die Tilde wird häufig zur Bezeichnung des Verzeichnisses verwendet, auf das die Umgebungsvariable <varname>HOME</varname> verweist (das Home-Verzeichnis des Benutzers, wie zum Beispiel <filename>/home/rhertzog/</filename>). Befehlsinterpreter ersetzen sie selbstständig: <filename>~/hello.txt</filename> wird zu <filename>/home/rhertzog/hello.txt</filename>.
		</para>
		 <para>
			Die Tilde ermöglicht auch den Zugriff auf das Home-Verzeichnis eines anderen Benutzers. So ist <filename>~rmas/bonjour.txt</filename> gleichbedeutend mit <filename>/home/rmas/bonjour.txt</filename>.
		</para>
		 </sidebar> <para>
			Zusätzlich zu diesen gemeinsamen Skripten kann jeder Benutzer zur Konfigurierung seiner Shell seine eigenen <filename>~/.bashrc</filename> und <filename>~/.bash_profile</filename> erstellen. Die häufigsten Veränderungen bestehen im Hinzufügen von Aliassen; dies sind Wörter, die bei der Ausführung eines Befehls automatisch ersetzt werden, was den Aufruf des Befehls beschleunigt. Zum Beispiel können sie den Alias <literal>la</literal> für den Befehl <command>ls -la | less</command> erstellen; dann brauchen Sie nur <command>la</command> einzugeben, um den Inhalt eines Verzeichnisses im Detail zu einzusehen.
		</para>
		 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Umgebungsvariablen</title>
		 <indexterm>
			<primary>Umgebung</primary>
			<secondary>Umgebungsvariable</secondary>
		</indexterm>
		 <indexterm>
			<primary>Variable, Umgebungs-</primary>
		</indexterm>
		 <para>
			Umgebungsvariablen ermöglichen es, globale Einstellungen für die Shell oder verschiedene andere aufgerufene Programme zu speichern. Sie sind zusammenhangsbezogen (jeder Prozess hat seinen eigenen Satz an Umgebungsvariablen) aber auch vererbbar. Letzteres eröffnet die Möglichkeit, für eine Anmeldeshell Variablen zu erklären, die an alle Programme, die sie ausführt, weitergegeben werden.
		</para>
		 </sidebar> <para>
			Das Setzen voreingestellter Umgebungsvariablen ist ein wichtiges Element der Shellkonfigurierung. Abgesehen von den für eine Shell spezifischen Variablen sollte man sie in der Datei <filename>/etc/environment</filename> ablegen, da diese von verschiedenen Programmen, die möglicherweise eine Shellsitzung starten, verwendet wird. Zu den normalerweise hier festgelegte Variablen gehören <varname>ORGANIZATION</varname>, die gewöhnlich den Namen des Unternehmens oder der Organisation enthält, und <varname>HTTP_PROXY</varname>, die das Vorhandensein und den Ort eines HTTP-Proxies anzeigt.
		</para>
		 <sidebar> <title><emphasis>TIPP</emphasis> Alle Shells identisch konfiguriert</title>
		 <para>
			Benutzer möchten häufig ihre Anmeldeshell und ihre interaktive Shell auf gleiche Weise konfigurieren. Hierzu übertragen (oder „sourcen“) sie den Inhalt der Datei <filename>~/.bashrc</filename> in die Datei <filename>~/.bash_profile</filename>. Man kann dasselbe mit Dateien machen, die allen Benutzern gemein sind (indem man <filename>/etc/bash.bashrc</filename> von <filename>/etc/profile</filename> aus aufruft).
		</para>
		 </sidebar>
	</section>
	 <section id="sect.config-printing">
		<title>Druckereinrichtung</title>
		 <indexterm>
			<primary>Einrichtung</primary>
			<secondary>Drucken</secondary>
		</indexterm>
		 <indexterm>
			<primary>Drucken</primary>
			<secondary>Einrichtung</secondary>
		</indexterm>
		 <para>
			Die Druckereinrichtung verursachte gewöhnlich sowohl für Administratoren als auch für Benutzer erhebliche Kopfschmerzen. Diese Kopfschmerzen gehören inzwischen dank <emphasis role="pkg">cups</emphasis>, dem freien Druckserver, der das IPP-Protokoll (Internet Printing Protocol) verwendet, weitgehend der Vergangenheit an.
		</para>
		 <indexterm>
			<primary>IPP</primary>
		</indexterm>
		 <indexterm>
			<primary>Internet Printing Protocol</primary>
		</indexterm>
		 <indexterm>
			<primary><command>cups</command></primary>
		</indexterm>
		 <para>
			This program is divided over several Debian packages: <emphasis role="pkg">cups</emphasis> is the central print server; <emphasis role="pkg">cups-bsd</emphasis> is a compatibility layer allowing use of commands from the traditional BSD printing system (<command>lpd</command> daemon, <command>lpr</command> and <command>lpq</command> commands, etc.); <emphasis role="pkg">cups-client</emphasis> contains a group of programs to interact with the server (block or unblock a printer, view or delete print jobs in progress, etc.); and finally, <emphasis role="pkg">printer-driver-gutenprint</emphasis> contains a collection of additional printer drivers for <command>cups</command>.
		</para>
		 <indexterm>
			<primary><command>lpr</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpq</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>GEMEINSCHAFT</emphasis> CUPS</title>
		 <indexterm>
			<primary>CUPS</primary>
		</indexterm>
		 <indexterm>
			<primary>Common Unix Printing System</primary>
		</indexterm>
		 <para>
			CUPS (Common Unix Printing System) ist ein Projekt (und eine geschützte Handelsmarke) unter der Verwaltung von Apple. <ulink type="block" url="http://www.easysw.com/" />
		</para>
		 </sidebar> <para>
			After installation of these different packages, <command>cups</command> is administered easily through a web interface accessible at the local address: <literal>http://localhost:631/</literal>. There you can add printers (including network printers), remove, and administer them. You can also administer <command>cups</command> with the graphical interface provided by the desktop environment. Finally, there is also the <command>system-config-printer</command> graphical interface (from the Debian package of the same name).
		</para>
		 <indexterm>
			<primary><command>cups</command></primary>
			<secondary>Verwaltung</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>HINWEIS</emphasis> Veralterung von <filename>/etc/printcap</filename></title>
		 <para>
			<emphasis>cups</emphasis> no longer uses the <filename>/etc/printcap</filename> file, which is now obsolete. Programs that rely upon this file to get a list of available printers will, thus, fail. To avoid this problem, delete this file and make it a symbolic link (see sidebar <xref linkend="sidebar.symbolic-link" />) to <filename>/run/cups/printcap</filename>, which is maintained by <emphasis>cups</emphasis> to ensure compatibility.
		</para>
		 <indexterm>
			<primary><filename>printcap</filename></primary>
		</indexterm>
		 </sidebar>
	</section>
	 <section id="sect.config-bootloader">
		<title>Den Boot-Loader konfigurieren</title>
		 <indexterm>
			<primary>Loader</primary>
			<secondary>Boot-Loader</secondary>
		</indexterm>
		 <indexterm>
			<primary>Boot-Loader</primary>
		</indexterm>
		 <para>
			Er funktioniert wahrscheinlich schon, aber trotzdem ist es immer empfehlenswert zu wissen, wie der Boot-Loader konfiguriert und installiert wird für den Fall, dass er aus dem Master Boot Record verschwindet. Dies kann nach der Installierung eines anderen Betriebssystems, wie zum Beispiel Windows, passieren. Die folgenden Informationen können auch dabei helfen, die Konfiguration des Boot-Loaders, falls nötig, zu verändern.
		</para>
		 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Master Boot Record</title>
		 <indexterm>
			<primary>MBR</primary>
		</indexterm>
		 <indexterm>
			<primary>Master Boot Record</primary>
		</indexterm>
		 <para>
			Der Master Boot Record (MBR) belegt die ersten 512 Bytes der ersten Festplatte und ist die erste Sache, die vom BIOS geladen wird, um die Kontrolle an ein Programm zu übergeben, das in der Lage ist, das gewünschte Betriebssystem hochzufahren. Im allgemeinen wird der Boot-Loader in den MBR installiert und damit sein bisheriger Inhalt überschrieben.
		</para>
		 </sidebar> <section id="sect.identify-disks">
			<title>Die Festplatten kennzeichnen</title>
			 <sidebar> <title><emphasis>KULTUR</emphasis> <emphasis>udev</emphasis> und <filename>/dev/</filename></title>
			 <para>
				Traditionell enthält das Verzeichnis <filename>/dev/</filename> sogenannte „spezielle“ (Geräte-)Dateien, die dazu dienten, Peripheriegeräte des Systems zu darzustellen (siehe <xref linkend="sidebar.special-files" /> in der Seitenleiste). Früher enthielt es alle möglicherweise benötigten Gerätedateien. Dieser Ansatz hat eine ganze Reihe von Nachteilen, wobei die Tatsache, dass die Anzahl der Geräte, die man nutzen konnte, (aufgrund der hart verdrahteten Namen in der Liste) beschränkt war und weil man nicht wissen konnte, welche Gerätedateien gebraucht würden.
			</para>
			 <para>
				Heute ist die Verwaltung der Gerätedateien vollständig dynamisch und passt besser zur "Hot-Swap"-Eigenschaft von Peripheriegeräten. Der Kernel kooperiert mit <emphasis>udev</emphasis> um sie zu erzeugen und zu entfernen, wenn die jeweiligen Geräte angeschlossen oder entfernt werden. Aus diesem Grund muss <filename>/dev/</filename> nicht persistent (dauerhaft) sein und ist deshalb ein anfänglich leeres RAM-Dateisystem, das nur die benötigten Elementen enthält.
			</para>
			 <para>
				Der Kernel kommuniziert eine Unmenge von Informationen über jedes neu hinzugefügte Gerät und vergibt ein paar Kennungen um diese zu identifizieren. Mit diesen Informationen kann <command>udevd</command> die Gerätedatei mit dem gewünschten Namen und den benötigten Berechtigungen anlegen. Zusätzlich können Aliase angelegt und zusätzliche Aktionen (wie Initialisierungen oder Registrierungen) durchgeführt werden. Das Verhalten von <command>udevd</command> wird von einer großen Anzahl an Konfigurationsregeln bestimmt.
			</para>
			 <para>
				Mit dynamisch zugewiesenen Namen kann man den selben Namen für ein bestimmtes Gerät beibehalten, egal welcher Anschluss in welcher Reihenfolge verwendet wird, was gerade bei Verwendung verschiedener USB-Geräte besonders hilfreich ist. Die erste Partition auf der ersten Festplatte kann dann <filename>/dev/sda1</filename> benannt werden, um rückwärts kompatibel zu sein, oder <filename>/dev/root-partition</filename> wenn gewünscht oder gar beides zur selben Zeit, da <command>udevd</command> so konfiguriert werden kann, dass eine symbolische Verknüpfung angelegt wird.
			</para>
			 <para>
				In ancient times, some kernel modules did automatically load when you tried to access the corresponding device file. This is no longer the case, and the peripheral's special file no longer exists prior to loading the module; this is no big deal, since most modules are loaded on boot thanks to automatic hardware detection. But for undetectable peripherals (such as very old disk drives or PS/2 mice), this doesn't work. Consider adding the modules, <literal>floppy</literal>, <literal>psmouse</literal> and <literal>mousedev</literal> to <filename>/etc/modules</filename> in order to force loading them on boot.
			</para>
			 </sidebar> <indexterm>
				<primary>Festplatte, Namen</primary>
			</indexterm>
			 <indexterm>
				<primary>Namen</primary>
				<secondary>von Festplatten</secondary>
			</indexterm>
			 <para>
				Die Konfiguration des Bootloaders muss die verschiedenen Festplatten und deren Partitionen identifizieren. Linux verwendet dazu die speziellen "Block"-Dateien, die im Verzeichnis <filename>/dev/</filename> gespeichert sind. Seit Debian <emphasis role="distribution">Squeeze</emphasis> wurde das Namensschema für Festplatten durch den Linux-Kernel vereinheitlicht, und alle Festplatten (IDE/PATA, SATA, SCSI, USB, IEEE 1394) werden nun durch <filename>/dev/sd*</filename> repräsentiert.
			</para>
			 <para>
				Jede Partition wird durch ihre Nummer auf der Platte, auf der sie liegt, dargestellt: so ist zum Beispiel <filename>/dev/sda1</filename> die erste Partition auf der ersten Platte, und <filename>/dev/sdb3</filename> ist die dritte Partition auf der zweiten Platte.
			</para>
			 <indexterm>
				<primary>Partition</primary>
				<secondary>primär</secondary>
			</indexterm>
			 <indexterm>
				<primary>Partition</primary>
				<secondary>erweitert</secondary>
			</indexterm>
			 <indexterm>
				<primary>Partition</primary>
				<secondary>sekundär</secondary>
			</indexterm>
			 <indexterm>
				<primary>Partitionstabelle</primary>
				<secondary>MS-DOS-Format</secondary>
			</indexterm>
			 <para>
				Die PC-Architektur (oder „i386“ und seine jüngere Kusine) war lange Zeit auf die Verwendung des "MS-DOS"-Partitionstabellenformats beschränkt, das nur vier „primäre“ Partitionen je Platte erlaubt. Um über diese Begrenzung hinauszugehen, muss eine von ihnen als „erweiterte“ Partition erstellt werden, die dann weitere „sekundäre“ Partitionen enthalten kann. Diese sekundären Partitionen werden von 5 aufwärts nummeriert werden. So könnte die erste sekundäre Partition <filename>/dev/sda5</filename> sein, gefolgt von <filename>/dev/sda6</filename> usw.
			</para>
			 <para>
				Another restriction of the MS-DOS partition table format is that it only allows disks up to 2 TiB in size, which is becoming a real problem with recent disks.
			</para>
			 <indexterm>
				<primary>GPT</primary>
				<secondary>Partitionstabellenformat</secondary>
			</indexterm>
			 <indexterm>
				<primary>Partitionstabelle</primary>
				<secondary>GPT-Format</secondary>
			</indexterm>
			 <para>
				A new partition table format called GPT loosens these constraints on the number of partitions (it allows up to 128 partitions when using standard settings) and on the size of the disks (up to 8 ZiB, which is more than 8 billion terabytes). If you intend to create many physical partitions on the same disk, you should therefore ensure that you are creating the partition table in the GPT format when partitioning your disk.
			</para>
			 <para>
				Es ist nicht immer leicht sich zu merken, welche Platte mit welchem SATA-Controller verbunden ist, oder welche in der SCSI-Kette an dritter Position steht, vor allem, da sich die Benennung von im laufenden Betrieb austauschbaren Festplatten (zu denen unter anderem die meisten SATA-Platten und externen Platten gehören) von einem Hochfahren zum nächsten ändern kann. Zum Glück erstellt <command>udev</command> zusätzlich zu <filename>/dev/sd*</filename> symbolische Verknüpfungen mit festen Namen, die man dann verwenden kann, wenn man eine Festplatte unmissverständlich kennzeichnen möchte. Diese symbolischen Verknüpfungen sind in der Datei <filename>/dev/disk/by-id</filename> gespeichert. Auf einem Rechner mit zwei physischen Platten könnte man zum Beispiel folgendes finden:
			</para>
			 
<screen><computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l</userinput><computeroutput>total 0
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10 23 jul. 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10 23 jul. 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9 23 jul. 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10 23 jul. 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </computeroutput></screen>
			 <para>
				Beachten Sie, dass einige Platten mehrmals aufgeführt sind (da sie gleichzeitig als ATA-Platten und SCSI-Platten auftreten), aber die relevante Information besteht in erster Linie in den Modell- und Seriennummern der Platten, aufgrund derer man die Peripheriedatei finden kann.
			</para>
			 <para>
				Die in den folgenden Abschnitten als Beispiele benutzten Konfigurationsdateien basieren auf der gleichen Umgebung: eine einzelne SATA-Platte, auf der die erste Partition eine alte Windows-Installation, die zweite ein Debian GNU/Linux enthält.
			</para>

		</section>
		 <section id="sect.config-lilo">
			<title>LILO konfigurieren</title>
			 <indexterm>
				<primary>LILO</primary>
			</indexterm>
			 <indexterm>
				<primary>Linux Loader</primary>
			</indexterm>
			 <para>
				<emphasis>LILO</emphasis> (LInux LOader) ist der älteste Boot-Loader - solide aber derb. Er schreibt die physische Adresse des zu ladenden Kernels in den MBR, weshalb im Anschluss an jede Aktualisierung von LILO (oder seiner Konfigurationsdatei) der Befehl <command>lilo</command> ausgeführt werden muss. Wenn man dies vergisst, ist das System nicht mehr in der Lage hochzufahren, falls der alte Kernel entfernt oder ersetzt worden ist, da sich der neue auf der Platte nicht an derselben Stelle befindet.
			</para>
			 <para>
				LILOs Konfigurationsdatei ist <filename>/etc/lilo.conf</filename>; eine einfache Datei für eine Standardkonfiguration ist in unten stehendem Beispiel wiedergegeben.
			</para>
			 <example id="example.lilo.conf">
				<title>LILO-Konfigurationsdatei</title>
				 
<programlisting>
# The disk on which LILO should be installed.
# By indicating the disk and not a partition.
# you order LILO to be installed on the MBR.
boot=/dev/sda
# the partition that contains Debian
root=/dev/sda2
# the item to be loaded by default
default=Linux

# the most recent kernel image
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# Old kernel (if the newly installed kernel doesn't boot)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# only for Linux/Windows dual boot
other=/dev/sda1
  label=Windows</programlisting>

			</example>

		</section>
		 <section id="sect.config-grub">
			<title>Konfigurierung von GRUB 2</title>
			 <indexterm>
				<primary>GRUB</primary>
			</indexterm>
			 <indexterm>
				<primary>GRUB 2</primary>
			</indexterm>
			 <para>
				<emphasis>GRUB</emphasis> (GRand Unified Bootloader) ist neueren Datums. Man muss ihn nicht nach jeder Kernelaktualisierung aufrufen; <emphasis>GRUB</emphasis> kann die Dateisysteme lesen und die Position des Kernels auf der Platte selbst finden. Um ihn in den MBR der ersten Platte zu installieren, geben Sie einfach <command>grub-install /dev/sda</command> ein. <indexterm><primary><command>grub-install</command></primary></indexterm>
			</para>
			 <sidebar> <title><emphasis>HINWEIS</emphasis> Plattennamen für GRUB</title>
			 <para>
				GRUB kann Festplatten nur aufgrund von Informationen identifizieren, die vom BIOS bereitgestellt werden. <literal>(hd0)</literal> entspricht der ersten so erkannten Festplatte, <literal>(hd1)</literal> der zweiten usw. In den meisten Fällen entspricht diese Reihenfolge genau der üblichen Anordnung der Platten unter Linux, jedoch können Probleme auftreten, wenn man SCSI- und IDE-Platten verbindet. GRUB speichert Übereinstimmungen, die er entdeckt, in der Datei <filename>/boot/grub/device.map</filename>. Falls Sie darin Fehler finden (weil Sie wissen, dass Ihr BIOS Platten in einer anderen Reihenfolge erkennt), korrigieren Sie sie von Hand und führen dann nochmals <command>grub-install</command> aus. <command>grub-mkdevicemap</command> kann helfen, eine <filename>device.map</filename> Datei zu erstellen, von der aus gestartet werden soll.
			</para>
			 <para>
				Partitionen haben in GRUB ebenfalls besondere Namen. Wenn Sie „klassische“ Partitionen im MS-DOS-Format verwenden, wird die erste Partition auf der ersten Platte als <literal>(hd0,msdos1)</literal> gekennzeichnet, die zweite als <literal>(hd0,msdos2)</literal> usw.
			</para>
			 </sidebar> <para>
				GRUB 2 configuration is stored in <filename>/boot/grub/grub.cfg</filename>, but this file (in Debian) is generated from others. Be careful not to modify it by hand, since such local modifications will be lost the next time <command>update-grub</command> is run (which may occur upon update of various packages). The most common modifications of the <filename>/boot/grub/grub.cfg</filename> file (to add command line parameters to the kernel or change the duration that the menu is displayed, for example) are made through the variables in <filename>/etc/default/grub</filename>. To add entries to the menu, you can either create a <filename>/boot/grub/custom.cfg</filename> file or modify the <filename>/etc/grub.d/40_custom</filename> file. For more complex configurations, you can modify other files in <filename>/etc/grub.d</filename>, or add to them; these scripts should return configuration snippets, possibly by making use of external programs. These scripts are the ones that will update the list of kernels to boot: <filename>10_linux</filename> takes into consideration the installed Linux kernels; <filename>20_linux_xen</filename> takes into account Xen virtual systems, and <filename>30_os-prober</filename> lists other operating systems (Windows, OS X, Hurd).
			</para>

		</section>
		 <section id="sect.config-yaboot">
			<title>Für Macintosh-Computer (PowerPC): Yaboot konfigurieren</title>
			 <indexterm>
				<primary><command>yaboot</command></primary>
			</indexterm>
			 <para>
				Yaboot ist der von alten Macintosh-Rechnern mit PowerPC-Prozessoren verwendete Boot-Loader. Sie fahren nicht wie PCs hoch, sondern stützen sich auf eine “Bootstrap“-Partition, von der aus das BIOS (oder OpenFirmware) den Loader ausführt, und auf dem das Programm <command>ybin</command> <command>yaboot</command> und seine Konfigurationsdatei installiert. Man muss diesen Befehl nur ein weiteres Mal ausführen, wenn <filename>/etc/yaboot.conf</filename> verändert wurde (sie liegt in Kopie auf der Bootstrap-Partition, und <command>yaboot</command> kann die Position des Kernels auf den Platten finden).
			</para>
			 <para>
				Bevor <command>ybin</command> ausgeführt wird, muss man zunächst eine gültige Version der Datei <filename>/etc/yaboot.conf</filename> haben. Das Folgende ist ein Beispiel einer minimalen Konfiguration. <indexterm><primary><command>ybin</command></primary></indexterm>
			</para>
			 <example id="example.yaboot.conf">
				<title>Konfigurationsdatei für Yaboot</title>
				 
<programlisting>
# bootstrap partition
boot=/dev/sda2
# the disk
device=hd:
# the Linux partition
partition=3
root=/dev/sda3
# boot after 3 seconds of inactivity
# (timeout is in tenths of seconds)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# last kernel installed
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# old kernel
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# only for Linux/Mac OSX dual-boot
macosx=/dev/sda5

# bsd=/dev/sdaX and macos=/dev/sdaX
# are also possible</programlisting>

			</example>

		</section>

	</section>
	 <section id="sect.config-misc">
		<title>Weitere Konfigurationen: Zeitsynchronisation, Protokolle, Gemeinsamer Zugang…</title>
		 <para>
			Die zahlreichen in diesem Abschnitt aufgeführten Elemente sind für jeden wissenswert, der alle Aspekte der Konfigurierung eines GNU/Linux-Systems beherrschen möchte. Sie werden jedoch nur kurz behandelt, und häufig wird auf die Dokumentation verwiesen.
		</para>
		 <section id="sect.timezone">
			<title>Zeitzone</title>
			 <indexterm>
				<primary>Zeitzone</primary>
			</indexterm>
			 <sidebar id="sidebar.symbolic-link"> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Symbolische Verknüpfungen</title>
			 <indexterm>
				<primary>Verknüpfung</primary>
				<secondary>symbolisch</secondary>
			</indexterm>
			 <indexterm>
				<primary>symbolische Verknüpfung</primary>
			</indexterm>
			 <indexterm>
				<primary><command>ln</command></primary>
			</indexterm>
			 <para>
				Eine symbolische Verknüpfung ist ein Verweis auf eine andere Datei. Wenn man auf sie zugreift, wird die Datei, auf die sie verweist, geöffnet. Die Entfernung der Verknüpfung führt nicht dazu, dass die Datei, auf die sie verweist, gelöscht wird. Ebenso hat sie nicht ihren eigenen Satz von Berechtigungen, sondern behält die Berechtigungen ihres Ziels bei. Und schließlich kann sie auf jede Art von Datei verweisen: Verzeichnisse, spezielle Dateien (Sockets, benannte Pipes, Gerätedateien usw.) und selbst auf andere symbolische Verknüpfungen.
			</para>
			 <para>
				Der Befehl <command>ln -s <replaceable>ziel</replaceable> <replaceable>verknüpfungsname</replaceable></command> erstellt eine symbolische Verknüpfung namens <replaceable>verknüpfungsname</replaceable>, die auf <replaceable>ziel</replaceable> verweist.
			</para>
			 <para>
				Falls das Ziel nicht existiert, ist die Verknüpfung „gebrochen“, und der Zugriff darauf ergibt eine Fehlermeldung, die besagt, dass die Zieldatei nicht existiert. Falls die Verknüpfung auf eine andere Verknüpfung verweist, hat man eine „Kette“ von Verknüpfungen, die zu einem „Kreis“ wird, falls eines der Ziele auf einen seiner Vorgänger verweist. In diesem Fall führt der Zugriff auf eine der Verknüpfungen in diesem Kreis zu einer besonderen Fehlermeldung („too many levels of symbolic links“); das heißt, dass der Kernel nach einigen Runden des Kreises aufgegeben hat.
			</para>
			 </sidebar> <para>
				Die Zeitzone wird während der Erstinstallation eingestellt und ist ein Konfigurationspunkt für das Paket <emphasis role="pkg">tzdata</emphasis>. Sie wird mit <command>dpkg-reconfigure tzdata</command> geändert, der es erlaubt, die gewünschte Zeitzone interaktiv auszuwählen. Seine Konfiguration wird in der Datei <filename>/etc/timezone</filename> gespeichert. Zusätzlich wird die entsprechende Datei aus dem Verzeichnis <filename>/usr/share/zoneinfo</filename> nach <filename>/etc/localtime</filename> kopiert; diese Datei enthält die Regeln, die die Dauer der Sommerzeit für jedes Land, das sie einsetzt, festlegt.
			</para>
			 <indexterm>
				<primary><filename>Zeitzone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>zoneinfo</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/usr/share/zoneinfo/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>DST</primary>
			</indexterm>
			 <indexterm>
				<primary>Sommerzeit</primary>
			</indexterm>
			 <para>
				Wenn man die Zeitzone vorübergehend ändern muss, verwendet man die Umgebungsvariable <varname>TZ</varname>, die Vorrang vor der konfigurierten Voreinstellung des Systems hat:
			</para>
			 <indexterm>
				<primary><varname>TZ</varname></primary>
			</indexterm>
			 
<screen id="screen.tz">
<computeroutput>$ </computeroutput><userinput>date</userinput>
<computeroutput>Thu Feb 19 11:25:18 CET 2015</computeroutput>
<computeroutput>$ </computeroutput><userinput>TZ="Pacific/Honolulu" date</userinput>
<computeroutput>Thu Feb 19 00:25:21 HST 2015</computeroutput></screen>
			 <sidebar> <title><emphasis>HINWEIS</emphasis> System-Uhr, Hardware-Uhr</title>
			 <para>
				Es gibt in einem Rechner zwei Zeitquellen. Die Hauptplatine eines Rechners verfügt über eine Hardware-Uhr, die sogenannte „CMOS-Uhr“. Diese Uhr ist nicht sehr genau und bietet nur recht langsame Zugriffszeiten. Der Kernel des Betriebssystems hat seine eigene Uhr, die sogenannte Software-Uhr, die mit ihren eigenen Mitteln richtig eingestellt bleibt (möglicherweise mit Hilfe von Zeitservern, siehe <xref linkend="sect.time-synchronization" />). Diese System-Uhr ist normalerweise genauer, vor allem da sie keinen Zugang zu Hardware-Variablen benötigt. Da sie jedoch nur im Arbeitsspeicher existiert, wird sie bei jedem Hochfahren des Rechners auf Null zurückgesetzt im Gegensatz zur CMOS-Uhr, die über eine Batterie verfügt und daher den Neustart oder das Abschalten des Rechners „überlebt“. Die System-Uhr wird daher während des Hochfahrens von der CMOS-Uhr gestellt, und die CMOS-Uhr während des Abschaltens aktualisiert (um mögliche Änderungen oder Korrekturen zu berücksichtigen, falls sie falsch eingestellt war).
			</para>
			 <para>
				In der Praxis entsteht ein Problem, da die CMOS-Uhr lediglich ein Zähler ist und keinerlei Informationen zur Zeitzone enthält. Bezüglich ihrer Interpretation ist daher eine Entscheidung zu treffen: entweder geht das System davon aus, dass sie in Weltzeit (UTC, früher GMT) läuft, oder in Ortszeit. Diese Entscheidung könnte zu einer einfachen Verschiebung führen, in Wirklichkeit sind die Dinge jedoch etwas komplizierter: aufgrund der Sommerzeit ist dieser Versatz nicht konstant. Daher hat das System keine Möglichkeit zu entscheiden, ob der Versatz korrekt ist, insbesondere nicht zu Zeiten der Zeitumstellung. Da es immer möglich ist, die Ortszeit aus der Weltzeit und der Information über die Zeitzone abzuleiten, empfehlen wir nachdrücklich, die CMOS-Uhr in Weltzeit zu verwenden.
			</para>
			 <para>
				Leider ignorieren Windows-Systeme in ihrer Standardeinstellung diese Empfehlung; sie halten die CMOS-Uhr auf Ortszeit und ändern beim Hochfahren des Rechners die Zeit, indem sie bei einer Zeitumstellung abschätzen, ob die Umstellung bereits stattgefunden hat oder noch nicht. Dies funktioniert solange relativ gut, wie auf dem System nur Windows läuft. Wenn ein Rechner jedoch mehrere Systeme hat (ob dies nun eine „Dual-Boot“-Konfiguration ist oder andere Systeme als virtuelle Rechner laufen), entsteht Chaos, ohne eine Möglichkeit zu entscheiden, ob die Zeit korrekt ist. Falls Sie Windows unbedingt auf einem Rechner behalten müssen, sollten Sie dieses so einstellen, dass die CMOS-Uhr auf UTC eingestellt wird (durch Einstellen des Registry-Schlüssel <literal>HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</literal> vom Typ DWORD auf "1") oder indem Sie mit <command>hwclock --localtime --set</command> auf dem Debian System die Hardware-Uhr setzen und als Quelle für für die lokale Zeit festlegen (und sorgen Sie dafür, dass Ihre Uhr im Frühjahr und Herbst von Hand umgestellt wird).
			</para>
			 </sidebar>
		</section>
		 <section id="sect.time-synchronization">
			<title>Zeitsynchronisierung</title>
			 <indexterm>
				<primary>Zeitsynchronisierung</primary>
			</indexterm>
			 <indexterm>
				<primary>Uhr</primary>
				<secondary>Synchronisierung</secondary>
			</indexterm>
			 <para>
				Zeitsynchronisierung, die auf einem Rechner überflüssig erscheinen mag, ist in einem Netzwerk sehr wichtig. Da Benutzer keine Berechtigung zur Änderung des Datums und der Zeit haben, ist es wichtig, dass diese Information genau stimmt, um Verwirrung zu vermeiden. Außerdem können Informationen aus den Protokollen verschiedener Rechner besser aufeinander bezogen werden, wenn alle Rechner eines Netzwerks synchronisiert sind. Im Falle eines Angriffs ist es so einfacher, die zeitliche Abfolge der Ereignisse auf verschiedenen von der Störung betroffenen Rechnern zu rekonstruieren. Daten, die auf verschiedenen Rechnern zu statistischen Zwecken gesammelt werden, wären nicht sehr sinnvoll, wenn sie nicht synchronisiert wären.
			</para>
			 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> NTP</title>
			 <indexterm>
				<primary>NTP</primary>
			</indexterm>
			 <indexterm>
				<primary>Netzwerk</primary>
				<secondary>Zeitprotokoll</secondary>
			</indexterm>
			 <para>
				NTP (Network Time Protocol) ermöglicht es einem Rechner, sich mit anderen recht genau zu synchronisieren unter Berücksichtigung der Verzögerungen, die durch die Informationsübertragung über das Netzwerk und andere mögliche Verschiebungen entstehen.
			</para>
			 <para>
				Obwohl es im Internet zahlreiche NTP-Server gibt, können die bekannteren überlastet sein. Daher empfehlen wir, den NTP-Server <emphasis>pool.ntp.org</emphasis> zu benutzen, der in Wirklichkeit eine Gruppe von Rechnern ist, die laut Vereinbarung als öffentliche NTP-Server dienen. Sie können sogar die Benutzung auf eine für ein Land bestimmte Untergruppe beschränken, wie zum Beispiel <emphasis>de.pool.ntp.org</emphasis> für Deutschland oder <emphasis>at.pool.ntp.org</emphasis> für Österreich usw.
			</para>
			 <para>
				Wenn Sie jedoch ein großes Netzwerk verwalten, ist es empfehlenswert, Ihren eigenen NTP-Server zu installieren, der sich mit den öffentlichen Servern synchronisiert. Auf diese Weise können alle anderen Rechner in Ihrem Netzwerk Ihren internen NTP-Server benutzen, statt die Belastung der öffentlichen Server zu erhöhen. Sie steigern so auch die Homogenität Ihrer Uhren, da sich alle Rechner mit derselben Quelle synchronisieren und diese Quelle bezogen auf die Übertragungszeiten sehr nah ist.
			</para>
			 </sidebar> <section id="sect.ntp-on-workstations">
				<title>Für Arbeitsplatzrechner</title>
				 <para>
					Da Arbeitsplatzrechner häufig neu gestartet werden (selbst wenn dies nur zur Energieersparnis dient), genügt es, sie beim Hochfahren über NTP zu synchronisieren. Hierzu installieren Sie einfach das Paket <emphasis role="pkg">ntpdate</emphasis>. Bei Bedarf können Sie den verwendeten NTP-Server durch Änderung der Datei <filename>/etc/default/ntpdate</filename> wechseln.
				</para>
				 <indexterm>
					<primary><filename>ntpdate</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/default/ntpdate</filename></primary>
				</indexterm>

			</section>
			 <section id="sect.ntp-on-servers">
				<title>Für Server</title>
				 <para>
					Server werden nur selten neu gestartet, und es ist sehr wichtig, dass ihre Systemzeit korrekt ist. Um dauerhaft die richtige Zeit beizubehalten, sollten Sie einen lokalen NTP-Server installieren, einen Dienst, der vom Paket <emphasis role="pkg">ntp</emphasis> angeboten wird. In seiner voreingestellten Konfiguration synchronisiert sich dieser Server mit <emphasis>pool.ntp.org</emphasis> und stellt die Zeit auf Anfragen aus dem lokalen Netzwerk hin bereit. Sie können ihn konfigurieren, indem Sie die Datei <filename>/etc/ntp.conf</filename> editieren, wobei die wichtigste Änderung in dem NTP-Server besteht, an den er sich wendet. Falls das Netzwerk viele Server hat, könnte es von Interesse sein, einen lokalen Server einzurichten, der sich mit den öffentlichen Servern synchronisiert und der dann von den anderen Servern des Netzwerks als Quelle benutzt wird.
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">ntp</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary>Server</primary>
					<secondary>NTP</secondary>
				</indexterm>
				 <indexterm>
					<primary>NTP</primary>
					<secondary>Server</secondary>
				</indexterm>
				 <sidebar> <title><emphasis>WEITERE SCHRITTE</emphasis> GPS-Module und andere Zeitquellen</title>
				 <indexterm>
					<primary>GPS</primary>
				</indexterm>
				 <indexterm>
					<primary>DCF-77</primary>
				</indexterm>
				 <para>
					Falls die Zeitsynchronisierung für Ihr Netzwerk besonders kritisch ist, können Sie einen Server mit einem GPS-Modul ausstatten (das die Zeit eines GPS-Satelliten verwendet) oder mit einem DCF-77-Modul (das die Zeit mit der Atomuhr in der Nähe von Frankfurt/Main synchronisiert). In diesen Fällen ist die Konfigurierung des NTP-Servers ein bisschen komplizierter und die vorherige Lektüre der Dokumentation eine absolute Notwendigkeit.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.rotation-logs">
			<title>Protokolldateien rotieren</title>
			 <indexterm>
				<primary>Datei</primary>
				<secondary>Protokolle, Rotation</secondary>
			</indexterm>
			 <indexterm>
				<primary>Protokolle</primary>
				<secondary>Dateien, Rotation</secondary>
			</indexterm>
			 <indexterm>
				<primary>Rotation von Protokolldateien</primary>
			</indexterm>
			 <indexterm>
				<primary><command>logrotate</command></primary>
			</indexterm>
			 <para>
				Protokolldateien können größer werden, und zwar schnell, und es ist wichtig, sie zu archivieren. Das häufigste System besteht in einem rotierenden Archiv: die Protokolldatei wird regelmäßig archiviert, und nur die letzten <replaceable>X</replaceable> Archivdateien aufbewahrt. <command>logrotate</command>, das für diese Rotationen zuständige Programm folgt den Anweisungen, die ihm in der Datei <filename>/etc/logrotate.conf</filename> und in allen im Verzeichnis <filename>/etc/logrotate.d/</filename> befindlichen Dateien gegeben werden. Der Administrator kann diese Dateien verändern, falls er die von Debian festgelegten Richtlinien zur Protokollrotation anpassen möchte. Die Handbuchseite <citerefentry><refentrytitle>logrotate</refentrytitle>
				 <manvolnum>1</manvolnum></citerefentry> beschreibt alle in diesen Konfigurationsdateien verfügbaren Optionen. Sie möchten vielleicht die Anzahl der in der Protokollrotation zurückbehaltenen Dateien erhöhen oder Protokolldateien in ein besonderes Verzeichnis verschieben, um sie zu archivieren statt zu löschen. Sie könnten sie auch per E-Mail verschicken, um sie andernorts zu archivieren.
			</para>
			 <para>
				Das Programm <command>logrotate</command> wird täglich durch das Termimsteuerungssprogramm <command>cron</command> ausgeführt (beschrieben in <xref linkend="sect.task-scheduling-cron-atd" />).
			</para>

		</section>
		 <section id="sect.sharing-admin-rights">
			<title>Administratorrechte gemeinsam nutzen</title>
			 <indexterm>
				<primary>Konto</primary>
				<secondary>Administratorkonto</secondary>
			</indexterm>
			 <indexterm>
				<primary>Root</primary>
			</indexterm>
			 <indexterm>
				<primary><command>sudo</command></primary>
			</indexterm>
			 <para>
				Häufig arbeiten mehrere Administratoren am selben Netzwerk. Die Root-Passwörter gemeinsam zu nutzen, ist nicht sehr elegant und öffnet die Tür zu Missbrauch wegen der Anonymität, die eine derartige gemeinsame Nutzung schafft. Die Lösung dieses Problems besteht in dem Programm <command>sudo</command>, das es bestimmten Benutzern ermöglicht, bestimmte Befehle mit besonderen Rechten auszuführen. Im gewöhnlichsten Fall erlaubt <command>sudo</command> einem vertrauenswürdigen Benutzer die Ausführung jeden Befehls als Root. Hierzu führt der Benutzer einfach <command>sudo <replaceable>befehl</replaceable></command> aus und authentifiziert sich dabei mit seinem persönlichen Passwort.
			</para>
			 <para>
				Wenn es installiert ist, gibt das Paket <emphasis role="pkg">sudo</emphasis> volle Root-Rechte an Mitglieder der Gruppe <literal>sudo</literal>. Um andere Berechtigungen zu vergeben, muss der Administrator mit dem Befehl <command>visudo</command> die Konfigurationsdatei <filename>/etc/sudoers</filename> verändern (auch hier wird der Editor <command>vi</command> aufrufen oder ein anderer in der Umgebungsvariablen <varname>EDITOR</varname> definierter Editor). Das Hinzufügen einer Zeile mit <literal><replaceable>benutzername</replaceable> ALL=(ALL) ALL</literal> ermöglicht es dem betreffenden Benutzer, einen beliebigen Befehl als Root auszuführen.
			</para>
			 <indexterm>
				<primary><command>visudo</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>sudoers</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/sudoers</filename></primary>
			</indexterm>
			 <para>
				Komplexere Konfigurationen ermöglichen es, bestimmte Befehle nur bestimmten Benutzern zu erlauben. Alle Einzelheiten der verschiedenen Möglichkeiten werden auf der Handbuchseite <citerefentry><refentrytitle>sudoers</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry> beschrieben.
			</para>

		</section>
		 <section id="sect.fstab-mount-points">
			<title>Liste der Einhängepunkte</title>
			 <indexterm>
				<primary>Punkt, einhängen</primary>
			</indexterm>
			 <indexterm>
				<primary>Einhängepunkt</primary>
			</indexterm>
			 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Ein- und Aushängen</title>
			 <para>
				In einem unixähnlichen System wie Debian sind Dateien in einer einzelnen baumähnlichen Hierarchie von Verzeichnissen organisiert. Das Verzeichnis <filename>/</filename> wird „Wurzelverzeichnis“ genannt; alle weiteren Verzeichnisse sind Unterverzeichnisse dieser Wurzel. „Einhängen“ ist die Maßnahme, mit der der Inhalt eines Peripheriegerätes (häufig einer Festplatte) in den allgemeinen Dateienbaum des Systems einbezogen wird. Falls man eine separate Festplatte zur Speicherung der persönlichen Daten der Benutzer verwendet, muss diese Platte folglich in das Verzeichnis <filename>/home/</filename> „eingehängt“ werden. Das Wurzelverzeichnis wird vom Kernel beim Hochfahren immer eingehängt; andere Geräte werden häufig später im Verlauf der Startsequenz eingehängt oder von Hand mit dem Befehl <command>mount</command>.
			</para>
			 <indexterm>
				<primary><command>mount</command></primary>
			</indexterm>
			 <para>
				Einige auswechselbare Geräte werden automatisch eingehängt, wenn sie angeschlossen werden, insbesondere wenn die grafischen Arbeitsumgebungen GNOME, KDE oder andere verwendet werden. Andere Geräte müssen durch den Benutzer von Hand eingehängt werden. Sie müssen auch wieder ausgehängt (aus dem Dateibaum entfernt) werden. Normale Benutzer haben im Allgemeinen nicht die Berechtigung, die Befehle <command>mount</command> und <command>umount</command> auszuführen. Der Administrator kann jedoch diese Vorgänge erlauben (unabhängig für jeden einzelnen Einhängepunkt), indem er die Option <literal>user</literal> zur Datei <filename>/etc/fstab</filename> hinzufügt.
			</para>
			 <para>
				Der Befehl <command>mount</command> kann ohne Argumente benutzt werden (er listet dann alle eingehängten Dateisysteme auf). Die nachfolgenden Parameter sind erforderlich, um ein Gerät ein- oder auszuhängen. Entnehmen Sie bitte die vollständige Auflistung den Handbuchseiten <citerefentry><refentrytitle>mount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> und <citerefentry><refentrytitle>umount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry>. Für einfache Fälle ist die Syntax ebenfalls einfach: um zum Beispiel die Partition <filename>/dev/sdc1</filename>, die ein ext3-Dateisystem hat, in das Verzeichnis <filename>/mnt/tmp/</filename> einzuhängen, würden Sie einfach <command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command> eingeben.
			</para>
			 </sidebar> <para>
				Die Datei <filename>/etc/fstab</filename> enthält eine Liste aller möglichen Einhängepunkte, die entweder während des Hochfahrens automatisch eingehängt werden oder bei auswechselbaren Speichergeräten von Hand. Jeder Einhängepunkt wird in einer Zeile mit mehreren durch Leerzeichen getrennten Feldern beschrieben: <indexterm><primary><filename>fstab</filename></primary></indexterm> <indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						file system: this indicates where the filesystem to be mounted can be found, it can be a local device (hard drive partition, CD-ROM) or a remote filesystem (such as NFS).
					</para>
					 <para>
						Dieses Feld wird häufig durch die eindeutige ID des Dateisystems ersetzt (die man mit dem Befehl <command>blkid <userinput>gerät</userinput></command> feststellen kann) mit vorausgestellter <literal>UUID=</literal>. Dies schützt vor einer Änderung des Gerätenamens, falls ein Gerät hinzugefügt oder entfernt wird, oder falls Platten in einer anderen Reihenfolge erkannt werden.
					</para>

				</listitem>
				 <listitem>
					<para>
						mount point: dies ist der Ort innerhalb des lokalen Dateisystems, an dem das Gerät, das entfernte System oder die Partition eingehängt werden.
					</para>

				</listitem>
				 <listitem>
					<para>
						type: dieses Feld legt das auf dem eingehängten Gerät verwendete Dateisystem fest. <literal>ext4</literal>, <literal>ext3</literal>, <literal>vfat</literal>, <literal>ntfs</literal>, <literal>btrfs</literal>, <literal>xfs</literal> sind einige Beispiele.
					</para>
					 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> NFS, ein Netzwerk-Dateisystem</title>
					 <para>
						NFS ist ein Netzwerk-Dateisystem; unter Linux ermöglicht es einen transparenten Zugriff auf entfernte Dateien, indem sie in das lokale Dateisystem einbezogen werden.
					</para>
					 </sidebar> <para>
						Eine vollständige Liste bekannter Dateisysteme steht auf der Handbuchseite <citerefentry><refentrytitle>mount</refentrytitle>
						 <manvolnum>8</manvolnum></citerefentry> zur Verfügung. Der besondere Wert <literal>swap</literal> gilt für Swap-Partitionen; der besondere Wert <literal>auto</literal> weist das Programm <command>mount</command> an, das Dateisystem selbstständig zu ermitteln (was besonders bei Laufwerken und USB-Sticks hilfreich ist, da jedes ein anderes Dateisystem haben kann);
					</para>

				</listitem>
				 <listitem>
					<para>
						options: es gibt viele in Abhängigkeit vom Dateisystem, und sie sind auf der Handbuchseite von <command>mount</command> dokumentiert. Die häufigsten sind
					</para>
					 <itemizedlist>
						<listitem>
							<para>
								<literal>rw</literal> und <literal>ro</literal> bedeuten, dass das Gerät mit den Berechtigungen zum Lesen und Schreiben beziehungsweise nur zum Lesen eingehängt wird.
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>noauto</literal> deaktiviert das automatische Einhängen beim Hochfahren.
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>nofail</literal> allows the boot to proceed even when the device is not present. Make sure to put this option for external drives that might be unplugged when you boot, because <command>systemd</command> really ensures that all mount points that must be automatically mounted are actually mounted before letting the boot process continue to its end. Note that you can combine this with <literal>x-systemd.device-timeout=5s</literal> to tell <command>systemd</command> to not wait more than 5 seconds for the device to appear (see <citerefentry><refentrytitle>systemd.mount</refentrytitle>
								<manvolnum>5</manvolnum></citerefentry>).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>user</literal> erlaubt es allen Benutzern, dieses Dateisystem einzuhängen (ein Vorgang, der sonst nur auf den Root-Benutzer beschränkt wäre).
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>defaults</literal> bezeichnet die Gruppe der voreingestellten Optionen: <literal>rw</literal>, <literal>suid</literal>, <literal>dev</literal>, <literal>exec</literal>, <literal>auto</literal>, <literal>nouser</literal> und <literal>async</literal>, von denen jede einzeln nach <literal>defaults</literal> abgestellt werden kann, indem man <literal>nosuid</literal>, <literal>nodev</literal> und so weiter hinzufügt, um <literal>suid</literal>, <literal>dev</literal> und so weiter zu sperren. Das Hinzufügen der Option <literal>user</literal>reaktiviert diese wieder, da <literal>defaults</literal> die Option <literal>nouser</literal> enthält.
							</para>

						</listitem>

					</itemizedlist>

				</listitem>
				 <listitem>
					<para>
						dump: this field is almost always set to <literal>0</literal>. When it is <literal>1</literal>, it tells the <command>dump</command> tool that the partition contains data that is to be backed up.
					</para>

				</listitem>
				 <listitem>
					<para>
						pass: this last field indicates whether the integrity of the filesystem should be checked on boot, and in which order this check should be executed. If it is <literal>0</literal>, no check is conducted. The root filesystem should have the value <literal>1</literal>, while other permanent filesystems get the value <literal>2</literal>.
					</para>

				</listitem>

			</itemizedlist>
			 <example id="example.fstab">
				<title>Beispiel der Datei <filename>/etc/fstab</filename></title>
				 
<programlisting>
# /etc/fstab: static file system information.
#
# &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;
proc            /proc           proc    defaults        0       0
# / was on /dev/sda1 during installation
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
# swap was on /dev/sda5 during installation
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0</programlisting>

			</example>
			 <para>
				Der letzte Eintrag dieses Beispiels bezieht sich auf ein Netzwerk-Dateisystem (NFS): das Verzeichnis <filename>/shared/</filename> auf dem Server <emphasis>arrakis</emphasis> wird auf dem lokalen Rechner unter <filename>/shared/</filename> eingehängt. Das Format der Datei <filename>/etc/fstab</filename> ist auf der Handbuchseite <citerefentry><refentrytitle>fstab</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> dokumentiert.
			</para>
			 <sidebar> <title><emphasis>WEITERE SCHRITTE</emphasis> Selbstständiges Einhängen</title>
			 <para>
				systemd is able to manage automount points: those are filesystems that are mounted on-demand when a user attempts to access their target mount points. It can also unmount these filesystems when no process is accessing them any longer.
			</para>
			 <para>
				Like most concepts in systemd, automount points are managed with dedicated units (using the <literal>.automount</literal> suffix). See <citerefentry><refentrytitle>systemd.automount</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> for their precise syntax.
			</para>
			 <indexterm>
				<primary><emphasis>am-utils</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><command>amd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>automount</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>autofs</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>Automounter</primary>
			</indexterm>
			 <para>
				Other auto-mounting utilities exist, such as <command>automount</command> in the <emphasis role="pkg">autofs</emphasis> package or <command>amd</command> in the <emphasis role="pkg">am-utils</emphasis>.
			</para>
			 <para>
				Beachten Sie auch, dass GNOME, KDE und andere grafische Arbeitsplatzumgebungen mit dem System <emphasis>udisks</emphasis> zusammenarbeiten und automatisch Wechselmedien einhängen können, wenn diese angeschlossen werden.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.locate-updatedb">
			<title><command>locate</command> und <command>updatedb</command></title>
			 <indexterm>
				<primary><command>locate</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>updatedb</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>mlocate</command></primary>
			</indexterm>
			 <para>
				Der Befehl <command>locate</command> kann den Ort einer Datei finden, wenn Sie nur einen Teil ihres Namens kennen. Er zeigt das Ergebnis fast sofort an, da er in einer Datenbank nachschlägt, die den Ort aller auf dem System befindlichen Dateien speichert; diese Datenbank wird täglich durch den Befehl <command>updatedb</command> aktualisiert. Es gibt -zig Implementierungen des Befehls <command>locate</command> und Debian hat <emphasis role="pkg">mlocate</emphasis> für sein Standard-System gewählt.
			</para>
			 <para>
				<command>mlocate</command> ist so intelligent, dass es nur Dateien zurückliefert, auf die der Anwender Zugriff hat, auch wenn die zugrundeliegende Datenbank alle Dateien auf dem System kennt (weil die Implementierung des zugehörigen <command>updatedb</command> ohne Root-Rechte läuft). Als zusätzliche Absicherung kann der Administrator mit <varname>PRUNEDPATHS</varname> in <filename>/etc/updatedb.conf</filename> einzelne Verzeichnisse von der Indexierung ausschließen.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-compilation">
		<title>Einen Kernel kompilieren</title>
		 <indexterm>
			<primary>Kompilierung</primary>
			<secondary>eines Kernels</secondary>
		</indexterm>
		 <indexterm>
			<primary>Kernel</primary>
			<secondary>Kompilierung</secondary>
		</indexterm>
		 <para>
			Die von Debian bereitgestellten Kernel umfassen die größtmögliche Anzahl an Leistungsmerkmalen wie auch ein Maximum an Treibern, um ein möglichst breites Spektrum der existierenden Hardware-Konfigurationen abzudecken. Daher ziehen es einige Anwender vor, den Kernel neu zu kompilieren, um so genau nur das einzuschließen, was sie wirklich brauchen. Es gibt zwei Gründe für diese Entscheidung. Zum einen kann es darum gehen, den Speicherverbrauch zu optimieren, da der Kernelcode, selbst wenn er niemals gebraucht wird, unnötig Speicher belegt (und niemals in den Swap „hinuntergeht“, da es wirkliches RAM ist, das er benutzt), wodurch sich die Gesamtleistung des Systems verringern kann. Ein lokal kompilierter Kernel kann außerdem das Risiko von Sicherheitsproblemen reduzieren, da nur ein Bruchteil des Kernelcodes kompiliert wird und läuft.
		</para>
		 <sidebar> <title><emphasis>HINWEIS</emphasis> Sicherheitsaktualisierungen</title>
		 <para>
			Wenn Sie es vorziehen, Ihren eigenen Kernel zu kompilieren, müssen Sie auch die Konsequenzen in Kauf nehmen: Debian kann bei Ihrem maßgeschneiderten Kernel nicht für Sicherheitsaktualisierungen sorgen. Wenn Sie dagegen den von Debian bereitgestellten Kernel behalten, profitieren Sie von Aktualisierungen, die vom Sicherheitsteam des Debian-Projekts erstellt werden.
		</para>
		 </sidebar> <para>
			Eine Rekompilierung des Kernels ist auch erforderlich, wenn Sie bestimmte Leistungsmerkmale verwenden möchten, die nur als Patches zur Verfügung stehen (und nicht in der Standardversion des Kernels enthalten sind).
		</para>
		 <sidebar> <title><emphasis>WEITERGEHENDE SCHRITTE</emphasis> Das Debian Kernel Handbuch</title>
		 <indexterm>
			<primary><emphasis role="pkg">debian-kernel-handbook</emphasis></primary>
		</indexterm>
		 <para>
			Das Debian Kernel Team verwaltet "Das Debian Kernel Handbuch" (auch im Paket <emphasis role="pkg">debian-kernel-handbook</emphasis> enthalten) mit umfassender Dokumentation über die meisten Kernel-Aufgaben und darüber, wie offizielle Debian Kernel Pakete behandelt werden. Das ist die erste Adresse für weitergehende Informationen, die über das in diesem Abschnitt Gesagte hinausgehen. <ulink type="block" url="http://kernel-handbook.alioth.debian.org" />
		</para>
		 </sidebar> <section id="sect.kernel-compilation-prerequisites">
			<title>Einführung und Voraussetzungen</title>
			 <para>
				Wenig überraschend verwaltet Debian den Kernel in Form eines Pakets, was nicht der üblichen Art und Weise entspricht, wie Kernel traditionell kompiliert und installiert wurden. Da der Kernel unter der Kontrolle des Paketierungssystems verbleibt, kann er dann sauber entfernt oder auf mehreren Rechnern eingesetzt werden. Darüber hinaus automatisieren die zu diesen Paketen gehörigen Skripten die Interaktion mit dem Boot-Loader und dem initrd-Generator.
			</para>
			 <para>
				Die "Upstream"-Linux-Quellen enthalten alles, was Sie benötigen, um ein Debian Paket des Kernels zu bauen. Aber Sie müssen trotzdem <emphasis role="pkg">build-essential</emphasis> installieren, um zu überprüfen, ob Sie die benötigten Werkzeuge zum Erstellen eines Linux-Kernels haben. Des weiteren benötigt der Schritt zur Konfiguration des Kernels das Paket <emphasis role="pkg">libncurses5-dev</emphasis>. Und schlussendlich erlaubt das Paket <emphasis role="pkg">fakeroot</emphasis> die Erstellung des Debian-Pakets, ohne dabei Administratorrechte zu verwenden.
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> Die guten alten Zeiten des <emphasis role="pkg">kernel-package</emphasis></title>
			 <indexterm>
				<primary><emphasis role="pkg">kernel-package</emphasis></primary>
			</indexterm>
			 <para>
				Bevor die Umgebung zur Erstellung eines Linux-Systems die Fähigkeit erhielt, saubere Debian-Pakete zu bauen, war der empfohlene Weg, <command>make-kpkg</command> aus dem Paket <emphasis role="pkg">kernel-package</emphasis> zur Erzeugung solcher Pakete zu verwenden.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-sources">
			<title>Die Quellen besorgen</title>
			 <indexterm>
				<primary>Linux-Kernelquellen</primary>
			</indexterm>
			 <indexterm>
				<primary>Kernel</primary>
				<secondary>Quellen</secondary>
			</indexterm>
			 <indexterm>
				<primary>Quelle</primary>
				<secondary>des Linux Kernels</secondary>
			</indexterm>
			 <para>
				Like anything that can be useful on a Debian system, the Linux kernel sources are available in a package. To retrieve them, just install the <emphasis role="pkg">linux-source-<replaceable>version</replaceable></emphasis> package. The <command>apt search ^linux-source</command> command lists the various kernel versions packaged by Debian. The latest version is available in the <emphasis role="distribution">Unstable</emphasis> distribution: you can retrieve them without much risk (especially if your APT is configured according to the instructions of <xref linkend="sect.apt-mix-distros" />). Note that the source code contained in these packages does not correspond precisely with that published by Linus Torvalds and the kernel developers; like all distributions, Debian applies a number of patches, which might (or might not) find their way into the upstream version of Linux. These modifications include backports of fixes/features/drivers from newer kernel versions, new features not yet (entirely) merged in the upstream Linux tree, and sometimes even Debian specific changes.
			</para>
			 <para>
				The remainder of this section focuses on the 4.9 version of the Linux kernel, but the examples can, of course, be adapted to the particular version of the kernel that you want.
			</para>
			 <para>
				We assume the <emphasis role="pkg">linux-source-4.9</emphasis> package has been installed. It contains <filename>/usr/src/linux-source-4.9.tar.xz</filename>, a compressed archive of the kernel sources. You must extract these files in a new directory (not directly under <filename>/usr/src/</filename>, since there is no need for special permissions to compile a Linux kernel): <filename>~/kernel/</filename> is appropriate.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>
<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-4.9.tar.xz</userinput></screen>
			 <sidebar> <title><emphasis>KULTUR</emphasis> Ort der Kernelquellen</title>
			 <para>
				Traditionell würden Linux-Kernelquellen in <filename>/usr/src/linux/</filename> abgelegt werden und damit Root-Berechtigungen für die Kompilierung erfordern. Das Arbeiten mit Administratorrechten sollte jedoch vermieden werden, wenn es nicht nötig ist. Es gibt eine Gruppe namens <literal>src</literal>, die es ihren Mitgliedern ermöglicht, in diesem Verzeichnis zu arbeiten, aber die Arbeit in <filename>/usr/src/</filename> sollte dennoch vermieden werden. Indem Sie die Kernel-Quellen in einem persönlichen Verzeichnis halten, sind Sie in jeder Hinsicht sicher: es gibt keine Dateien in <filename>/usr/</filename>, die dem Paketierungssystem unbekannt sind, und es gibt kein Risiko, dass Programme dadurch in die Irre geführt werden, dass sie <filename>/usr/src/linux</filename> lesen, wenn sie versuchen, Informationen über den verwendeten Kernel zu sammeln.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.config-kernel">
			<title>Den Kernel konfigurieren</title>
			 <indexterm>
				<primary>Kernel</primary>
				<secondary>Konfigurierung</secondary>
			</indexterm>
			 <indexterm>
				<primary>Konfigurierung</primary>
				<secondary>des Kernels</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>.config</filename></primary>
			</indexterm>
			 <para>
				Der nächste Schritt besteht darin, den Kernel Ihren Bedürfnissen entsprechend zu kompilieren. Das genaue Vorgehen hängt von den Zielen ab.
			</para>
			 <para>
				Wenn eine neuere Version des Kernels (möglicherweise mit einem zusätzlichen Patch) rekompiliert wird, wird die Konfigurierung höchstwahrscheinlich möglichst nah an der von Debian vorgeschlagenen gehalten werden. In diesem Fall, und anstatt alles von Grund auf neu zu konfigurieren, genügt es, die Datei <filename>/boot/config-<replaceable>version</replaceable></filename> (die Version entspricht der des zur Zeit verwendeten Kernels, die mit dem Befehl <command>uname -r</command> gefunden werden kann) in eine Datei namens <filename>.config</filename> im Verzeichnis, das die Kernelquellen enthält, zu kopieren.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cp /boot/config-4.9.0-3-amd64 ~/kernel/linux-source-4.9/.config</userinput></screen>
			 <para>
				Falls Sie die Konfiguration nicht zu ändern brauchen, können Sie hier aufhören und zu <xref linkend="sect.kernel-build" /> springen. Falls Sie sie dagegen ändern müssen, oder falls Sie sich dazu entschließen, alles von Grund auf neu zu konfigurieren, müssen Sie sich die Zeit nehmen, Ihren Kernel zu konfigurieren. Es gibt in dem Verzeichnis mit den Kernelquellen mehrere speziell hierfür vorgesehene Schnittstellen, die mit dem Aufruf des Befehls <command>make <replaceable>ziel</replaceable></command> verwendet werden können, wobei <replaceable>ziel</replaceable> einer der unten beschriebenen Werte ist.
			</para>
			 <para>
				<command>make menuconfig</command> kompiliert eine Schnittstelle im Textmodus und führt sie aus (an dieser Stelle ist das Paket <emphasis role="pkg">libncurses5-dev</emphasis> erforderlich), die es ermöglicht, durch die in einer hierarchischen Struktur verfügbaren Optionen zu navigieren. Ein Druck auf die <keycap>Leer</keycap>-Taste ändert den Wert der ausgewählten Option, und <keycap>Enter</keycap> bestätigt die am unteren Bildschirmrand ausgewählte Schaltfläche; <guibutton>Select</guibutton> geht zum ausgewählten Untermenü zurück; <guibutton>Exit</guibutton> schließt den aktuellen Bildschirm und kehrt aufwärts in die Hierarchie zurück; <guibutton>Help</guibutton> zeigt ausführlichere Informationen zur Rolle der ausgewählten Option an. Mit den Pfeiltasten ist es möglich, sich innerhalb der Liste von Optionen und Schaltflächen zu bewegen. Um das Konfigurierungsprogramm zu verlassen, wählt man <guibutton>Exit</guibutton> im Hauptmenü. Das Programm bietet dann an, die vorgenommenen Änderungen zu speichern; nehmen Sie diesen Vorschlag an, wenn Sie mit Ihrer Auswahl zufrieden sind.
			</para>
			 <para>
				Andere Schnittstellen verfügen über ähnliche Merkmale, arbeiten jedoch mit moderneren grafischen Schnittstellen, wie zum Beispiel <command>make xconfig</command>, das eine grafische Schnittstelle auf der Basis von Qt verwendet, und <command>make gconfig</command>, das GTK+ benutzt. Ersteres erfordert <emphasis role="pkg">libqt4-dev</emphasis>, während Letzteres von <emphasis role="pkg">libglade2-dev</emphasis> und <emphasis role="pkg">libgtk2.0-dev</emphasis> abhängt.
			</para>
			 <para>
				Beim Benutzen dieser Konfigurationsschnittstellen ist es immer gut, von einer der Standardkonfigurationen auszugehen. Der Kernel stellt solche Konfigurationen in <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename> und Sie können Ihre gewählte Konfiguartion z.B. mit dem Befehl <command>make x86_64_defconfig</command> (im Falle eines 64-bit-Systems) oder mit <command>make i386_defconfig</command> (Im Falle eines 32-bit-PCs) einbinden.
			</para>
			 <sidebar> <title><emphasis>TIP</emphasis> Umgang mit veralteten <filename>.config</filename>-Dateien</title>
			 <para>
				Wenn Sie eine <filename>.config</filename>-Datei verwenden wollen, die mit einer anderen (üblicherweise älteren) Kernel-Version erzeut wurde, müssen sie diese aktualisieren. Das geht entweder mit <command>make oldconfig</command>, wobei Sie interaktiv nach den neuen Konfigurationsoptionen gefragt werden. Wollen sie alle Optionen mit Standardwerten belegen, können Sie das mit <command>make olddefconfig</command> tun. Mit <command>make oldnoconfig</command> werden alle Fragen verneint.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-build">
			<title>Das Paket kompilieren und erstellen</title>
			 <indexterm>
				<primary><command>make deb-pkg</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>HINWEIS</emphasis> Vor der Neuerstellung aufräumen</title>
			 <para>
				Wenn Sie den Inhalt eines Verzeichnisses schon einmal übersetzt hatten und alles noch einmal neu erstellen wollen, vielleicht, weil Sie fundamentale Änderungen der Kernelkonfiguration vorgenommen haben, dann müssen Sie <command>make clean</command> ausführen, um alle übersetzten Dateien zu löschen. <command>make distclean</command> entfernt noch mehr generierte Dateien, einschließlich Ihrer <filename>.config</filename>-Datei, also machen Sie zuvor besser ein Backup.
			</para>
			 </sidebar> <para>
				Once the kernel configuration is ready, a simple <command>make deb-pkg</command> will generate up to 5 Debian packages: <emphasis role="pkg">linux-image-<replaceable>version</replaceable></emphasis> that contains the kernel image and the associated modules, <emphasis role="pkg">linux-headers-<replaceable>version</replaceable></emphasis> which contains the header files required to build external modules, <emphasis role="pkg">linux-firmware-image-<replaceable>version</replaceable></emphasis> which contains the firmware files needed by some drivers (this package might be missing when you build from the kernel sources provided by Debian), <emphasis role="pkg">linux-image-<replaceable>version</replaceable>-dbg</emphasis> which contains the debugging symbols for the kernel image and its modules, and <emphasis role="pkg">linux-libc-dev</emphasis> which contains headers relevant to some user-space libraries like GNU glibc.
			</para>
			 <para>
				Die <replaceable>Version</replaceable> wird definiert durch das Zusammenfügen der "upstream"-Version (wie sie von den Variablen <literal>VERSION</literal>, <literal>PATCHLEVEL</literal>, <literal>SUBLEVEL</literal> and <literal>EXTRAVERSION</literal> in <filename>Makefile</filename>) festgelegt wird, vom Konfigurationsparameter <literal>LOCALVERSION</literal>, und von der Umgebungsvariable <literal>LOCALVERSION</literal>. Die Paket-Version nutzt die gleiche Versionszeichenkette mit einer angehängten Revisionsnummer die regelmäßig erhöht (und in <filename>.version</filename> gespeichert) wird, es sei denn, Sie überschreiben sie mit der Umgebungsvariable <literal>KDEB_PKGVERSION</literal>.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1
</userinput><computeroutput>[...]
$ </computeroutput><userinput>ls ../*.deb
</userinput><computeroutput>../linux-headers-4.9.30-ckt4-falcot_4.9.30-1_amd64.deb
../linux-image-4.9.30-ckt4-falcot_4.9.30-1_amd64.deb
../linux-image-4.9.30-ckt4-falcot-dbg_4.9.30-1_amd64.deb
../linux-libc-dev_4.9.30-1_amd64.deb
</computeroutput></screen>

		</section>
		 <section id="sect.modules-build">
			<title>Externe Module kompilieren</title>
			 <indexterm>
				<primary>Kernel</primary>
				<secondary>externe Module</secondary>
			</indexterm>
			 <indexterm>
				<primary>Module</primary>
				<secondary>externe Kernel Module</secondary>
			</indexterm>
			 <indexterm>
				<primary><command>dkms</command></primary>
			</indexterm>
			 <para>
				Some modules are maintained outside of the official Linux kernel. To use them, they must be compiled alongside the matching kernel. A number of common third party modules are provided by Debian in dedicated packages, such as <emphasis role="pkg">xtables-addons-source</emphasis> (extra modules for iptables) or <emphasis role="pkg">oss4-source</emphasis> (Open Sound System, some alternative audio drivers).
			</para>
			 <para>
				Diese externen Pakete sind zahlreich und vielfältig, und wir werden sie hier nicht alle aufführen; der Befehl <command>apt-cache search source$</command> kann den Suchbereich eingrenzen. Jedoch ist eine vollständige Liste nicht sehr nützlich, da es keinen besonderen Grund gibt, externe Module zu kompilieren, außer wenn Sie wissen, dass Sie sie benötigen. In diesen Fällen führt die Dokumentation des Geräts normalerweise die einzelnen Module auf, die es benötigt, um unter Linux zu funktionieren.
			</para>
			 <para>
				For example, let's look at the <emphasis role="pkg">xtables-addons-source</emphasis> package: after installation, a <filename>.tar.bz2</filename> of the module's sources is stored in <filename>/usr/src/</filename>. While we could manually extract the tarball and build the module, in practice we prefer to automate all this using DKMS. Most modules offer the required DKMS integration in a package ending with a <literal>-dkms</literal> suffix. In our case, installing <emphasis role="pkg">xtables-addons-dkms</emphasis> is all that is needed to compile the kernel module for the current kernel provided that we have the <emphasis role="pkg">linux-headers-*</emphasis> package matching the installed kernel. For instance, if you use <emphasis role="pkg">linux-image-amd64</emphasis>, you would also install <emphasis role="pkg">linux-headers-amd64</emphasis>.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>
<computeroutput>
[...]
Setting up xtables-addons-dkms (2.12-0.1) ...
Loading new xtables-addons-2.12 DKMS files...
Building for 4.9.0-3-amd64
Building initial module for 4.9.0-3-amd64
Done.

xt_ACCOUNT:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/4.9.0-3-amd64/updates/dkms/
[...]
DKMS: install completed.
$ </computeroutput><userinput>sudo dkms status</userinput>
<computeroutput>xtables-addons, 2.12, 4.9.0-3-amd64, x86_64: installed
$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>
<computeroutput>filename:       /lib/modules/4.9.0-3-amd64/updates/dkms/xt_ACCOUNT.ko
license:        GPL
alias:          ipt_ACCOUNT
author:         Intra2net AG &lt;opensource@intra2net.com&gt;
description:    Xtables: per-IP accounting for large prefixes
[...]
</computeroutput></screen>
			 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> module-assistant</title>
			 <indexterm>
				<primary><emphasis role="pkg">module-assistant</emphasis></primary>
			</indexterm>
			 <para>
				Before DKMS, <emphasis role="pkg">module-assistant</emphasis> was the simplest solution to build and deploy kernel modules. It can still be used, in particular for packages lacking DKMS integration: with a simple command like <command>module-assistant auto-install xtables-addons</command> (or <command>m-a a-i xtables-addons</command> for short), the modules are compiled for the current kernel, put in a new Debian package, and that package gets installed on the fly.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-patch">
			<title>Einen Kernel-Patch anwenden</title>
			 <indexterm>
				<primary>Kernel</primary>
				<secondary>Patch</secondary>
			</indexterm>
			 <indexterm>
				<primary>Patchen des Kernel</primary>
			</indexterm>
			 <para>
				Einige Funktionen sind im Standardkernel nicht enthalten, da sie entweder noch nicht ausgereift sind, oder auch wegen fehlender Übereinstimmung mit dem Entwickler. Solche Funktionen können als Patches verteilt werden, die dann jeder auf die Kernelquellen anwenden kann.
			</para>
			 <para>
				Debian sometimes provides some of these patches in <emphasis role="pkg">linux-patch-*</emphasis> packages but they often don't make it into stable releases (sometimes for the very same reasons that they are not merged into the official upstream kernel). These packages install files in the <filename>/usr/src/kernel-patches/</filename> directory.
			</para>
			 <para>
				Um einen oder mehrere dieser installierten Patches anzuwenden, rufen Sie den Befehl <command>patch</command> im Quellenverzeichnis auf und beginnen dann wie oben beschrieben mit der Kompilierung des Kernels.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-4.9</userinput>
<computeroutput>$ </computeroutput><userinput>make clean</userinput>
<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.1-4.9.11-201702181444.patch.gz | patch -p1</userinput></screen>
			 <para>
				Beachten Sie, dass ein bestimmter Patch nicht unbedingt mit jeder Kernelversion funktioniert; <command>patch</command> kann scheitern, wenn sie auf die Kernelquellen angewendet werden. Dann wird eine Fehlermeldung mit Einzelheiten zu diesem Fehlschlag angezeigt; in diesem Fall sollten Sie in der Dokumentation nachsehen, die im Debian-Paket des Patches zur Verfügung steht (im Verzeichnis <filename>/usr/share/doc/linux-patch-*/</filename>). Meistens gibt der Betreuer dort an, für welche Kernelversionen sein Patch gedacht ist.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-installation">
		<title>Einen Kernel installieren</title>
		 <indexterm>
			<primary>Installierung</primary>
			<secondary>eines Kernels</secondary>
		</indexterm>
		 <indexterm>
			<primary>Kernel</primary>
			<secondary>Installierung</secondary>
		</indexterm>
		 <section id="sect.kernel-package">
			<title>Merkmale eines Debian-Kernelpakets</title>
			 <indexterm>
				<primary><filename>vmlinuz</filename></primary>
			</indexterm>
			 <para>
				A Debian kernel package installs the kernel image (<filename>vmlinuz-<replaceable>version</replaceable></filename>), its configuration (<filename>config-<replaceable>version</replaceable></filename>) and its symbols table (<filename>System.map-<replaceable>version</replaceable></filename>) in <filename>/boot/</filename>. The symbols table helps developers understand the meaning of a kernel error message; without it, kernel “oopses” (an “oops” is the kernel equivalent of a segmentation fault for user-space programs, in other words messages generated following an invalid pointer dereference) only contain numeric memory addresses, which is useless information without the table mapping these addresses to symbols and function names. The modules are installed in the <filename>/lib/modules/<replaceable>version</replaceable>/</filename> directory.
			</para>
			 <para>
				The package's configuration scripts automatically generate an initrd image, which is a mini-system designed to be loaded in memory (hence the name, which stands for “init ramdisk”) by the bootloader, and used by the Linux kernel solely for loading the modules needed to access the devices containing the complete Debian system (for example, the driver for SATA disks). Finally, the post-installation scripts update the symbolic links <filename>/vmlinuz</filename>, <filename>/vmlinuz.old</filename>, <filename>/initrd.img</filename> and <filename>/initrd.img.old</filename> so that they point to the latest two kernels installed, respectively, as well as the corresponding initrd images.
			</para>
			 <para>
				Die meisten der Aufgaben werden an "hook scripts" in den <filename>/etc/kernel/*.d/</filename>-Verzeichnissen übergeben. Zum Beispiel fußt die Einbindung von <command>grub</command> darauf, dass <filename>/etc/kernel/postinst.d/zz-update-grub</filename> und <filename>/etc/kernel/postrm.d/zz-update-grub</filename> <command>update-grub</command> aufrufen, wenn ein Kernel installiert oder deinstalliert wird.
			</para>

		</section>
		 <section id="sect.kernel-installation-with-dpkg">
			<title>Mit <command>dpkg</command> installieren</title>
			 <para>
				Using <command>apt</command> is so convenient that it makes it easy to forget about the lower-level tools, but the easiest way of installing a compiled kernel is to use a command such as <command>dpkg -i <replaceable>package</replaceable>.deb</command>, where <literal><replaceable>package</replaceable>.deb</literal> is the name of a <emphasis role="pkg">linux-image</emphasis> package such as <filename>linux-image-4.9.30-ckt4-falcot_1_amd64.deb</filename>.
			</para>
			 <para>
				Die in diesem Kapitel beschriebenen Konfigurierungsschritte sind grundlegend und können sowohl zu einem Server als auch zu einem Arbeitsplatzrechner führen, und sie können in weitem Umfang auf halbautomatisierte Weise dupliziert werden. Dennoch reichen sie nicht aus, um ein vollständig konfiguriertes System bereitzustellen. Einiges bedarf einer weiteren Konfigurierung, beginnend mit den Programmen auf unterer Ebene, die als „Unix-Dienste“ bezeichnet werden.
			</para>

		</section>

	</section>
</chapter>

