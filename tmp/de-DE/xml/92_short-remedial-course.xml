<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course" lang="de-DE">
	<appendixinfo>
		 <keywordset>
			<keyword>BIOS</keyword>
			 <keyword>Kernel</keyword>
			 <keyword>Unix</keyword>
			 <keyword>Prozess</keyword>
			 <keyword>Hierarchie</keyword>
			 <keyword>Grundlegende Befehle</keyword>

		</keywordset>

	</appendixinfo>
	 <title>Kurzer Förderkurs</title>
	 <highlights> <para>
		Obwohl dieses Buch vor allem für Administratoren und „Power-User“ gedacht ist, möchten wir motivierte Einsteiger nicht ausschließen. Dieser Anhang enthält daher einen Schnellkurs, der die grundlegenden Konzepte beschreibt, die mit der Handhabung eines Unix-Rechners verbunden sind.
	</para>
	 </highlights> <section id="sect.shell-and-basic-commands">
		<title>Shell und grundlegende Befehle</title>
		 <para>
			In der Unix-Welt wird jeder Administrator früher oder später die Befehlszeile verwenden müssen; zum Beispiel, wenn das System nicht korrekt startet und nur einen Rettungsmodus mit einer Befehlszeile bereitstellt. Mit einer derartigen Schnittstelle umgehen zu können, stellt daher unter solchen Umständen eine grundlegende Überlebensfertigkeit dar.
		</para>
		 <sidebar> <title><emphasis>KURZER BLICK</emphasis> Den Befehlsinterpreter starten</title>
		 <para>
			A command-line environment can be run from the graphical desktop, by an application known as a “terminal”. In GNOME, you can start it from the “Activities” overview (that you get when you move the mouse in the top-left corner of the screen) by typing the first letters of the application name. In Plasma, you will find it in the <menuchoice><guimenu>K</guimenu> <guisubmenu>Applications</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice> menu.
		</para>
		 </sidebar> <para>
			Dieses Kapitel gibt nur einen kurzen Überblick über die Befehle. Sie alle haben zahlreiche Optionen, bitte lesen Sie dazu auch die ausführliche Dokumentation auf ihren jeweiligen Handbuchseiten.
		</para>
		 <section>
			<title>Den Verzeichnisbaum durchsuchen und Dateien verwalten</title>
			 <para>
				Sobald eine Sitzung gestartet ist, zeigt der Befehl <command>pwd</command> (das steht für <emphasis>print working directory</emphasis>) die derzeitige Position im Dateisystem an. Das aktuelle Verzeichnis kann mit dem Befehl <command>cd <replaceable>verzeichnis</replaceable></command> (<command>cd</command> steht für <emphasis>change directory</emphasis>) gewechselt werden. Das übergeordnete Verzeichnis heißt immer <literal>..</literal> (zwei Punkte), während das aktuelle Verzeichnis auch als <literal>.</literal> (ein Punkt) bekannt ist. Der Befehl <command>ls</command> (<emphasis>list</emphasis>) zeigt den Inhalt eines Verzeichnisses an. Wenn keine zusätzlichen Parameter angegeben werden, wird das aktuelle Verzeichnis angezeigt.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>cd Desktop</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd .</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates
Documents  Music      Public    Videos</computeroutput>
</screen>
			 <para>
				Ein neues Verzeichnis kann mit <command>mkdir <replaceable>Verzeichnis</replaceable></command> erstellt und ein bestehendes (leeres) Verzeichnis mit <command>rmdir <replaceable>Verzeichnis</replaceable></command> entfernt werden. Der Befehl <command>mv</command> (<emphasis>moving</emphasis>) ermöglicht es, Dateien und Verzeichnisse zu verschieben oder umzubenennen. Eine Datei wird mit <command>rm <replaceable>Datei</replaceable></command> (<emphasis>remove</emphasis>) gelöscht.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public    test
$ </computeroutput><userinput>mv test new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  new       Public     Videos
Documents  Music      Pictures  Templates
$ </computeroutput><userinput>rmdir new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public</computeroutput>
</screen>

		</section>
		 <section>
			<title>Textdateien anzeigen und verändern</title>
			 <para>
				Der Befehl <command>cat <replaceable>datei</replaceable></command> (der dazu gedacht ist, Dateien auf seinem Standardausgabegerät zu verketten [= <emphasis>concatenate</emphasis>]) liest eine Datei und zeigt ihren Inhalt im Terminal an. Wenn die Datei zu groß ist, um auf den Bildschirm zu passen, kann man ein Seitenwechselprogramm wie <command>less</command> (oder <command>more</command>) benutzen, um sie Seite für Seite anzuzeigen.
			</para>
			 <para>
				Der Befehl <command>editor</command> startet einen Text-Editor (wie <command>vi</command> oder <command>nano</command>) und ermöglicht es, Textdateien zu erstellen, zu verändern und zu lesen. Sehr einfache Dateien können mitunter direkt im Befehlsinterpreter mithilfe einer Umleitung erstellt werden: <command>echo „<replaceable>text</replaceable>“ &gt;<replaceable>datei</replaceable></command> erstellt eine Datei namens <replaceable>datei</replaceable> mit dem Inhalt „<replaceable>text</replaceable>“. Mit einem Befehl wie <command>echo „<replaceable>mehrText</replaceable>“ &gt;&gt;<replaceable>datei</replaceable></command> kann auch eine Zeile am Ende der Datei hinzugefügt werden. Bitte beachten Sie <literal>&gt;&gt;</literal> in diesem Beispiel.
			</para>

		</section>
		 <section>
			<title>Nach Dateien und in Dateien suchen</title>
			 <para>
				Der Befehl <command>find <replaceable>verzeichnis</replaceable> <replaceable>kriterien</replaceable></command> sucht verschiedenen Kriterien entsprechend in der Verzeichnishierarchie unterhalb von <replaceable>verzeichnis</replaceable> nach Dateien. Das am häufigsten verwendete Kriterium ist <literal>-name <replaceable>name</replaceable></literal>: mit ihm kann eine Datei namentlich gesucht werden.
			</para>
			 <para>
				Der Befehl <command>grep <replaceable>ausdruck</replaceable> <replaceable>dateien</replaceable></command> durchsucht den Inhalt der Dateien und exzerpiert die Zeilen, die dem regulären Ausdruck entsprechen (siehe <xref linkend="sidebar.regexp" /> in der Seitenleiste). Das Hinzufügen der Option <literal>-r</literal> bewirkt eine rekursive Suche in allen Dateien des Verzeichnisses, das als Parameter angegeben wird. So ist es möglich, nach einer Datei zu suchen, wenn nur ein Teil ihres Inhalts bekannt ist.
			</para>

		</section>
		 <section>
			<title>Prozesse verwalten</title>
			 <para>
				Der Befehl <command>ps aux</command> listet die Prozesse auf, die gerade laufen, und hilft dabei, sie anhand ihrer <emphasis>pid</emphasis> (process id) zu identifizieren. Wenn die <emphasis>pid</emphasis> eines Prozesses bekannt ist, kann man ihm mit dem Befehl <command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> ein Signal schicken (falls der Prozess dem aktuellen Benutzer gehört). Es gibt verschiedene Signale; am häufigsten werden <literal>TERM</literal> (eine höfliche Aufforderung aufzuhören) und <literal>KILL</literal> (ein erzwungener Abbruch) verwendet.
			</para>
			 <para>
				Der Befehlsinterpreter kann auch Programme im Hintergrund ausführen, wenn dem Befehl ein „&amp;“ folgt. Durch Verwendung dieses Und-Zeichens übernimmt der Benutzer sofort wieder die Kontrolle über das Terminal, obwohl der Befehl noch läuft (vor dem Benutzer verborgen als Hintergrundprozess). Der Befehl <command>jobs</command> listet die im Hintergrund laufenden Prozesse auf; das Ausführen von <command>fg %<replaceable>job-nummer</replaceable></command> (für <emphasis>foreground</emphasis>) stellt einen Job wieder im Vordergrund her. Wenn ein Befehl im Vordergrund läuft (weil er entweder normal gestartet wurde oder mit <command>fg</command> wieder in den Vordergrund gebracht wurde), hält die Tastenkombination <keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo> den Prozess an und stellt die Kontrolle über die Befehlszeile wieder her. Der Prozess kann dann im Hintergrund mit <command>bg %<replaceable>job-nummer</replaceable></command> (für <foreignphrase>background</foreignphrase>) fortgesetzt werden.
			</para>

		</section>
		 <section>
			<title>Systeminformation: Speicher, Speicherplatz, Identität</title>
			 <para>
				Der Befehl <command>free</command> zeigt Informationen über den Speicher; <command>df</command> (<emphasis>disk free</emphasis>) meldet den verfügbaren Speicherplatz auf jeder im Dateisystem eingehängten Platte. Seine Option <literal>-h</literal> (für <emphasis>human readable</emphasis>) rechnet die Größen in eine leichter lesbare Einheit um (üblicherweise Mebibytes oder Gibibytes). In ähnlicher Weise unterstützt der Befehl <command>free</command> die Optionen <literal>-m</literal> und <literal>-g</literal> und zeigt seine Daten dementsprechend entweder in Mebibytes oder Gibibytes an.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       used       free     shared    buffers     cached
Mem:       1028420    1009624      18796          0      47404     391804
-/+ buffers/cache:     570416     458004
Swap:      2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda2              9614084   4737916   4387796  52% /
tmpfs                   514208         0    514208   0% /lib/init/rw
udev                     10240       100     10140   1% /dev
tmpfs                   514208    269136    245072  53% /dev/shm
/dev/sda5             44552904  36315896   7784380  83% /home
</computeroutput></screen>
			 <para>
				Der Befehl <command>id</command> zeigt die Identität des Benutzers an, der die Sitzung ausführt, zusammen mit einer Liste der Gruppen, denen er angehört. Da der Zugriff auf einige Dateien oder Geräte auf Gruppenmitglieder beschränkt sein kann, kann es nützlich sein, die verfügbaren Gruppenmitgliedschaften zu überprüfen.
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
</screen>

		</section>

	</section>
	 <section id="sect.filesystem-hierarchy">
		<title>Organisation der Dateisystem-Hierarchie</title>
		 <indexterm>
			<primary>Dateisystem-Hierarchie</primary>
		</indexterm>
		 <section>
			<title>Das Wurzelverzeichnis</title>
			 <para>
				Ein Debian-System ist gemäß dem <emphasis>Filesystem Hierarchy Standard</emphasis> (FHS) organisiert. Dieser Standard legt den Zweck jedes Verzeichnisses fest. So sind zum Beispiel die Verzeichnisse der obersten Ebene wie folgt bezeichnet:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<filename>/bin/</filename>: grundlegende Programme;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/boot/</filename>: Linux-Kernel und andere Dateien, die für seinen frühen Startvorgang benötigt werden;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/dev/</filename>: Gerätedateien;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/etc/</filename>: Konfigurationsdateien;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/home/</filename>: persönliche Dateien des Benutzers;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/lib/</filename>: grundlegende Bibliotheken;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/media/*</filename>: Einhängepunkte für entfernbare Geräte (CD-ROM, USB-Sticks und so weiter);
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/mnt/</filename>: vorübergehender Einhängepunkt;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/opt/</filename>: zusätzliche von Dritten bereitgestellte Anwendungen;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/root/</filename>: persönliche Dateien des Administrators (zu Root gehörig);
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/run/</filename>: flüchtige Laufzeitdaten, die Neustarts nicht überstehen (noch nicht in der FHS enthalten);
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/sbin/</filename>: Systemprogramme;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/srv/</filename>: Daten, die von auf diesem System untergebrachten Servern benutzt werden;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/tmp/</filename>: temporäre Dateien; dieses Verzeichnis wird häufig während des Rechnerstarts geleert;
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/usr/</filename>: Anwendungen; dieses Verzeichnis ist weiter unterteilt in <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (nach derselben Logik wie beim Wurzelverzeichnis). Darüber hinaus enthält <filename>/usr/share/</filename> architekturunabhängige Daten. <filename>/usr/local/</filename> soll vom Administrator dazu verwendet werden, von Hand Anwendungen zu installieren, ohne dabei Dateien zu überschreiben, die das Paketsystem (<command>dpkg</command>) verwaltet.
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/var/</filename>: veränderliche Daten, die von Daemons gehandhabt werden. Hierzu gehören Protokolldateien, Warteschlangen, Zwischenspeicher und so weiter.
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/proc/</filename> und <filename>/sys/</filename> sind kernelspezifisch (und nicht Teil der FHS). Sie werden vom Kernel benutzt, um Daten in die Anwenderebene zu exportieren (für Erklärungen dieses Konzepts siehe <xref linkend="sect.userspace-presentation" /> und <xref linkend="sect.user-space" />.
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section>
			<title>Das Home-Verzeichnis des Benutzers</title>
			 <para>
				Der Inhalt des Home-Verzeichnisses eines Benutzers ist nicht standardisiert, es gibt aber einige beachtenswerte Gepflogenheiten. Eine ist, dass das Home-Verzeichnis eines Benutzers oft durch eine Tilde („~“) bezeichnet wird. Das ist nützlich zu wissen, denn Befehlszeileninterpreter ersetzen die Tilde automatisch durch das korrekte Verzeichnis (normalerweise <filename>/home/<replaceable>benutzer</replaceable>/</filename>).
			</para>
			 <para>
				Die Konfigurationsdateien der Anwendungen werden häufig direkt im Home-Verzeichnis des Benutzers gespeichert, jedoch beginnen ihre Namen gewöhnlich mit einem Punkt (zum Beispiel speichert der E-Mail-Client <command>mutt</command> seine Konfiguration in <filename>~/.muttrc</filename>). Achten Sie darauf: Dateinamen, die mit einem Punkt beginnen, sind standardmäßig unsichtbar, und <command>ls</command> führt sie nur auf, wenn die Option <literal>-a</literal> benutzt wird und bei Dateimanagern muß dies auch explizit eingestellt werden.
			</para>
			 <para>
				Einige Programme verwenden auch mehrere in einem Verzeichnis organisierte Konfigurationsdateien (zum Beispiel <filename>~/.ssh/</filename>). Einige Anwendungen (wie zum Beispiel der Web-Browser Iceweasel) benutzen ihr Verzeichnis auch, um einen Cache heruntergeladener Daten zu speichern. Dies bedeutet, dass diese Verzeichnisse schließlich sehr viel Speicherplatz belegen können.
			</para>
			 <para>
				Diese Konfigurationsdateien die direkt im Benutzerverzeichnis gespeichert werden und die oft gemeinschaftlich als <emphasis>Dotfiles</emphasis> bezeichnet werden, haben so stark gewuchert dass diese Verzeichnisse nun vollgestopft davon sind. Glücklicherweise führte führte eine Verbesserung unter dem Schirm der FreeDesktop.org hinaus in die “XDG Base Directory Specification”, ein Abkommen mit dem Ziel diese Dateien und Verzeichnisse aufzuräumen. Diese Spezifikation besagt, dass Konfigurationsdateien unterhalb von <filename>~/.config</filename>, Cache-Dateien unter <filename>~/.cache</filename> und Applikationsdaten unter <filename>~/.local</filename> (oder Unterverzeichnissen davon) gespeichert werden sollen. Dieses Abkommen bekommt so langsam Zugkraft und verschiedene Applikationen (insbesondere grafische) beginnen es nun umzusetzen.
			</para>
			 <para>
				Grafische Arbeitsflächen zeigen normalerweise den Inhalt des Verzeichnisses <filename>~/Desktop/</filename> (oder was immer die entsprechende Übersetzung für Systeme ist, die nicht in Englisch konfiguriert sind) auf der Arbeitsfläche an (das heißt, was auf dem Bildschirm sichtbar ist, wenn alle Anwendungen geschlossen oder zu Piktogrammen minimiert sind).
			</para>
			 <para>
				Schließlich speichert das E-Mail-System ankommende E-Mails manchmal in einem <filename>~/Mail/</filename>-Verzeichnis.
			</para>

		</section>

	</section>
	 <section id="sect.computer-layers">
		<title>Das Innenleben eines Rechners: die verschiedenen beteiligten Schichten</title>
		 <para>
			Ein Rechner wird häufig als etwas ziemlich Abstraktes angesehen, und die äußerlich sichtbare Schnittstelle ist wesentlich einfacher als seine interne Komplexität. Diese Komplexität ergibt sich zum Teil aus der Zahl der beteiligten Teile. Diese Teile können jedoch in Form von Schichten betrachtet werden, wobei eine Schicht nur mit der unmittelbar darüber- und darunterliegenden interagiert.
		</para>
		 <para>
			Ein Endbenutzer kann zurechtkommen, ohne diese Einzelheiten zu kennen... solange alles funktioniert. Wenn man einem Problem wie „Das Internet geht nicht!“ gegenübersteht, besteht der erste Schritt darin herauszufinden, aus welcher Schicht das Problem herrührt. Funktioniert die Netzwerkkarte (Hardware)? Wird sie vom Rechner erkannt? Sieht sie der Linux-Kernel? Sind die Netzwerkparameter richtig eingestellt? All diese Fragen grenzen die zutreffende Schicht ein und richten das Augenmerk auf die mögliche Quelle des Problems.
		</para>
		 <section id="sect.hardware">
			<title>Die unterste Schicht: Die Hardware</title>
			 <indexterm>
				<primary>IDE</primary>
			</indexterm>
			 <indexterm>
				<primary>SCSI</primary>
			</indexterm>
			 <indexterm>
				<primary>Serial ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>Parallel ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>Firewire</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <para>
				Lassen Sie uns mit der grundlegenden Erinnerung beginnen, dass ein Rechner in erster Linie eine Zusammenstellung von Hardwareelementen ist. Es gibt im Allgemeinen eine Hauptplatine (das <emphasis>Motherboard</emphasis>) mit einem (oder mehreren) Prozessor(en), etwas RAM, Gerätesteuerungen und Erweiterungssteckplätze für Optionskarten (für weitere Gerätesteuerungen). Von diesen Steuerungen sind vor allem das IDE (paralleles ATA), das SCSI und das serielle ATA zum Anschluss von Speichergeräten wie Festplatten beachtenswert. Zu den weiteren Steuerungen gehören das USB, das eine große Vielfalt an Geräten (von Webkameras zu Thermometern, von Tastaturen zu Systemen für die Hausautomation) aufnehmen kann, und das IEEE_1394 (Firewire). Diese Steuerungen ermöglichen es häufig, mehrere Geräte anzuschließen. Daher wird das vollständige Subsystem, für das eine Steuerung zuständig ist, gewöhnlich als „Bus“ bezeichnet. Zu den Optionskarten gehören Grafikkarten (an die Bildschirme angeschlossen werden), Soundkarten, Netzwerkschnittstellenkarten und so weiter. Bei einigen Hauptplatinen sind diese Bestandteile bereits fest eingebaut, so dass sie keine Optionskarten benötigen.
			</para>
			 <sidebar> <title><emphasis>IN DER PRAXIS</emphasis> Überprüfen, ob die Hardware funktioniert</title>
			 <para>
				Zu überprüfen, ob ein Hardwareteil funktioniert, kann schwierig sein. Dagegen lässt sich manchmal recht einfach feststellen, dass es nicht funktioniert.
			</para>
			 <para>
				Ein Festplattenlaufwerk besteht aus sich drehenden Platten und sich bewegenden Magnetköpfen. Wenn eine Festplatte angeschaltet wird, erzeugt der Plattenmotor ein charakteristisches Surren. Außerdem gibt er Energie in Form von Hitze ab. Deshalb ist ein Festplattenlaufwerk, das beim Anschalten kalt und still bleibt, defekt.
			</para>
			 <para>
				Netzwerkkarten besitzen häufig LEDs, die den Verbindungsstatus anzeigen. Falls ein Kabel angeschlossen ist und zu einem funktionierenden Netzwerk-Hub oder -Schalter führt, wird zumindest eine LED an sein. Falls keine LED leuchtet, ist entweder die Karte selbst, das Netzwerkgerät oder das Kabel zwischen ihnen defekt. Der nächste Schritt besteht deshalb dann darin, jede Komponente einzeln zu überprüfen.
			</para>
			 <para>
				Einige Optionskarten - insbesondere 3D-Videokarten - enthalten Kühlungen, wie Kühlkörper und Ventilatoren. Wenn sich der Ventilator nicht dreht, obwohl die Karte angeschaltet ist, besteht eine plausible Erklärung darin, dass die Karte überhitzt ist. Das Gleiche gilt auch für den oder die Hauptprozessor(en) auf der Hauptplatine.
			</para>
			 </sidebar>
		</section>
		 <section id="sect.bios">
			<title>Der Starter: das BIOS oder UEFI</title>
			 <indexterm>
				<primary>BIOS</primary>
			</indexterm>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>Master Boot Record (MBR)</primary>
			</indexterm>
			 <para>
				Hardware ist für sich genommen ohne entsprechende Software, die sie steuert, nicht in der Lage, sinnvolle Tätigkeiten auszuführen. Der Zweck des Betriebssystems und der Anwendungen besteht darin, die Hardware zu kontrollieren und mit ihr zu interagieren. Ihrerseits benötigen sie funktionierende Hardware, um zu laufen.
			</para>
			 <para>
				Diese Symbiose zwischen Hardware und Software kommt nicht von allein zustande. Wenn der Rechner zu Anfang hochgefahren wird, muss zunächst einiges eingerichtet werden. Diese Rolle übernimmt das BIOS oder UEFI, ein Stück Software, das in der Hauptplatine eingebettet ist und beim Hochfahren automatisch ausgeführt wird. Seine Hauptaufgabe besteht darin, nach Software Ausschau zu halten, an die es die Kontrolle übergeben kann. Normalerweise bedeutet dies im Falle von BIOS, nach der ersten Festplatte mit einem Boot-Sektor zu suchen (auch <emphasis>Master Boot Record</emphasis> oder <acronym>MBR</acronym> genannt), dann diesen Boot-Sektor zu laden und ihn auszuführen. Von da an ist das BIOS (bis zum nächsten Hochfahren) normalerweise nicht mehr beteiligt. Im Falle von UEFI startet der Prozess die Suche nach einer EFI Partition welche die weiteren zu startenden EFI Applikationen enthält.
			</para>
			 <sidebar> <title><emphasis>HILFSPROGRAMM</emphasis> Setup, das BIOS/UEFI-Konfigurationsprogramm</title>
			 <indexterm>
				<primary><emphasis>Setup</emphasis></primary>
			</indexterm>
			 <para>
				Das BIOS/UEFI enthält auch Software namens Setup, das dazu bestimmt ist, bestimmte Aspekte des Rechners einzustellen. Insbesondere lässt sich mit ihm das bevorzugte Startgerät auswählen (zum Beispiel das Disketten- oder das CD-ROM-Laufwerk), die Systemuhr einstellen und so weiter. Um Setup zu starten, muss normalerweise unmittelbar nach dem Einschalten des Rechners eine Taste gedrückt werden. Diese Taste ist häufig <keycap>Entf</keycap> oder <keycap>Esc</keycap>, manchmal auch <keycap>F2</keycap> oder <keycap>F10</keycap>. Meistens wird die Auswahlmöglichkeit während des Hochfahrens kurz eingeblendet.
			</para>
			 </sidebar> <para>
				Der Bootsektor (oder die UEFI Partition) enthält seinerseits Software, Boot-Loader genannt, dessen Zweck darin besteht, ein Betriebssystem zu finden und auszuführen. Da dieser Boot-Loader nicht auf der Hauptplatine eingebettet ist, sondern von einer Platte geladen wird, kann er intelligenter als das BIOS sein, woraus sich erklärt, warum nicht das BIOS selbst das Betriebssystem lädt. Zum Beispiel kann der Boot-Loader (auf einem Linux-System häufig GRUB) die verfügbaren Betriebssysteme auflisten und den Benutzer bitten, eines auszuwählen. Normalerweise ist dies mit einem Zeitlimit und einer voreingestellten Auswahl versehen. Manchmal kann der Benutzer auch zusätzliche Parameter zur Weiterleitung an den Kernel angeben und so weiter. Schließlich wird ein Kernel gefunden, in den Speicher geladen und ausgeführt.
			</para>
			 <sidebar> <title><emphasis>NOTIZ</emphasis> UEFI, ein moderner BIOS-Ersatz</title>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>Secure Boot</primary>
			</indexterm>
			 <para>
				UEFI ist eine relativ neue Entwicklung. Die meisten neuen Computer unterstützen das Booten mit UEFI, aber in der Regel auch mit BIOS, um durch Rückwärtskompatibilität mit Betriebssystemen booten zu können, die nicht in der Lage sind UEFI zu nutzen.
			</para>
			 <para>
				Dieses neue System enfernt einige Beschränkungen des Bootens mit BIOS: durch Verwendung einer eignenen Partition brauchen die Bootloader keine speziellen Tricks mehr, einen sehr kleinen <emphasis>Master Boot Record</emphasis> unterzubringen, um dann den zu bootenden Kernel zu finden. Besser noch, mit einem passenden Linux Kernel kann UEFI diesen ohne dazwischengeschalteten Bootloader direkt booten. UEFI ist also die Grundlage für <emphasis>Secure Boot</emphasis>, eine Technologie, die sicherstellt, dass Sie nur durch den Betriebbssystemhersteller geprüfte Software laufen lassen.
			</para>
			 </sidebar> <para>
				Das BIOS/UEFI ist auch dafür zuständig, eine Anzahl von Geräten zu finden und zu initialisieren. Offensichtlich gehören hierzu die IDE/SATA-Geräte (normalerweise Festplatten und CD/DVD-ROM-Laufwerke) aber auch PCI-Geräte. Erkannte Geräte werden häufig während des Hochfahrens auf dem Bildschirm angezeigt. Falls diese Liste zu schnell vorbeiläuft, können Sie die <keycap>Pause</keycap>-Taste drücken, um sie zum Lesen anzuhalten. PCI-Geräte, die installiert sind, aber nicht angezeigt werden, sind ein schlechtes Zeichen. Im schlimmsten Fall ist das Gerät defekt. Im besten Fall ist es nur nicht mit der aktuellen Version des BIOS oder der Hauptplatine kompatibel. PCI-Spezifikationen entwickeln sich weiter, und bei alten Hauptplatinen ist nicht gewährleistet, dass sie mit neueren PCI-Geräten umgehen können.
			</para>

		</section>
		 <section id="sect.kernel">
			<title>Der Kernel</title>
			 <para>
				Sowohl das BIOS/UEFI als auch der Boot-Loader laufen jeweils nur für einige Sekunden; wir gelangen nun zur ersten Software, die länger läuft: dem Betriebssystem-Kernel. Dieser Kernel nimmt die Rolle eines Orchesterdirigenten ein und gewährleistet die Koordination zwischen Hardware und Software. Zu dieser Rolle gehören mehrere Aufgaben, unter anderem: Hardware betreiben, Prozesse verwalten, Benutzer und Berechtigungen, das Dateisystem und so weiter. Der Kernel stellt eine gemeinsame Grundlage für alle anderen Programme des Systems zur Verfügung.
			</para>

		</section>
		 <section id="sect.userspace-presentation">
			<title>Die Anwendungsebene</title>
			 <para>
				Obwohl alles, was außerhalb des Kernels geschieht, unter dem Begriff „Anwendungsebene“ zusammengefasst werden kann, können wir sie dennoch in verschiedene Software-Ebenen unterteilen. Ihr Zusammenwirken ist jedoch komplexer als zuvor, und die Unterteilungen sind manchmal nicht gerade einfach. Eine Anwendung verwendet normalerweise Bibliotheken, die wiederum den Kernel einbeziehen, die Kommunikation kann aber auch andere Programme einbeziehen, oder zahlreiche Bibliotheken können sich sogar gegenseitig aufrufen.
			</para>

		</section>

	</section>
	 <section id="sect.kernel-role-and-tasks">
		<title>Einige vom Kernel erledigte Aufgaben</title>
		 <section id="sect.hardware-drivers">
			<title>Die Hardware steuern</title>
			 <para>
				Es ist vor allem Aufgabe des Kernels, die Hardwareelemente zu steuern, sie zu erkennen, sie einzuschalten, wenn der Rechner angeschaltet wird, und so weiter. Er macht sie auch über eine vereinfachte Programmierschnittstelle für die Software auf höherer Ebene verfügbar, so dass Anwendungen Geräte nutzen können, ohne sich um Einzelheiten kümmern zu müssen, wie zum Beispiel, in welchen Erweiterungssteckplatz die Optionsplatine eingesteckt ist. Die Programmierschnittstelle stellt auch eine Abstraktionsschicht zur Verfügung; diese ermöglicht es zum Beispiel einer Videokonferenz-Anwendung, eine Webkamera unabhängig von ihrer Marke und ihrem Modell zu verwenden. Die Anwendung kann einfach die Schnittstelle <emphasis>Video for Linux</emphasis> (V4L) benutzen, und der Kernel übersetzt die Funktionsaufrufe dieser Schnittstelle in die tatsächlichen Hardwarebefehle, die von der konkret verwendeten Webkamera benötigt werden.
			</para>
			 <para>
				<indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> Der Kernel exportiert über die virtuellen Dateisysteme <filename>/proc/</filename> und <filename>/sys/</filename> zahlreiche Einzelheiten über die erkannte Hardware. Verschiedene Hilfsprogramme fassen diese Einzelheiten zusammen. Von ihnen zeigt <command>lspci</command> (im Paket <emphasis role="pkg">pciutils</emphasis>) eine Liste der PCI-Geräte an, <command>lsusb</command> (im Paket <emphasis role="pkg">usbutils</emphasis>) führt USB-Geräte auf und <command>lspcmcia</command> (im Paket <emphasis role="pkg">pcmciautils</emphasis>) PCMCIA-Karten. Diese Hilfsprogramme sind zur Identifizierung des genauen Modells eines Geräts sehr hilfreich. Diese Identifizierung ermöglicht auch ein genaueres Suchen im Web, das wiederum zu relevanteren Dokumenten führt.
			</para>
			 <example>
				<title>Beispiel der von <command>lspci</command> und <command>lsusb</command> angezeigten Informationen</title>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>

			</example>
			 <para>
				Diese Programme haben eine Option <literal>-v</literal>, durch die wesentlich detailliertere (aber gewöhnlich nicht erforderliche) Informationen angezeigt werden. Schließlich listet der Befehl <command>lsdev</command> (im Paket <emphasis role="pkg">procinfo</emphasis>) die von den Geräten benutzten Kommunikationsressourcen auf.
			</para>
			 <para>
				Anwendungen greifen häufig mittels spezieller in <filename>/dev/</filename> erzeugter Dateien auf Geräte zu (siehe Seitenleiste <xref linkend="sidebar.special-files" />). Dies sind besondere Dateien, die Plattenlaufwerke (zum Beispiel <filename>/dev/hda</filename> und <filename>/dev/sdc</filename>), Partitionen (<filename>/dev/hda1</filename> oder <filename>/dev/sdc3</filename>), Mäuse (<filename>/dev/input/mouse0</filename>), Tastaturen (<filename>/dev/input/event0</filename>), Soundkarten (<filename>/dev/snd/*</filename>), serielle Schnittstellen (<filename>/dev/ttyS*</filename>) und so weiter repräsentieren.
			</para>

		</section>
		 <section id="sect.filesystems">
			<title>Dateisysteme</title>
			 <indexterm>
				<primary>Dateisystem</primary>
			</indexterm>
			 <indexterm>
				<primary>System, Dateisystem</primary>
			</indexterm>
			 <para>
				Dateisysteme sind einer der bedeutendsten Aspekte des Kernels. Unix-Systeme vereinen alle Dateispeicher in einer gemeinsamen Hierarchie, die es Benutzern (und Anwendungen) ermöglicht, auf Daten einfach durch Kenntnis ihres Ortes innerhalb dieser Hierarchie zuzugreifen.
			</para>
			 <para>
				Der Ausgangspunkt dieses Hierarchiebaums wird „root“ genannt, <filename>/</filename>. Dieses Verzeichnis kann mit Namen versehene Unterverzeichnisse enthalten. Das Unterverzeichnis <literal>home</literal> von <filename>/</filename> wird beispielsweise <filename>/home/</filename> genannt. Dieses Unterverzeichnis kann wiederum weitere Unterverzeichnisse enthalten und so weiter. Jedes Verzeichnis kann auch Dateien enthalten, in denen die tatsächlichen Daten gespeichert sind. So bezieht sich <filename>/home/rmas/Desktop/hello.txt</filename> auf eine Datei namens <literal>hello.txt</literal>, die im Unterverzeichnis <literal>Desktop</literal> des Unterverzeichnisses <literal>rmas</literal> des Verzeichnisses <literal>home</literal> gespeichert ist, das sich in root befindet. Der Kernel übersetzt zwischen diesem Benennungssystem und dem tatsächlichen, physikalischen Speicherort auf einer Platte.
			</para>
			 <para>
				Im Gegensatz zu anderen Systemen gibt es nur eine derartige Hierarchie, und sie kann Daten verschiedener Speicherplatten einbinden. Eine dieser Platten wird als Wurzelverzeichnis verwendet, und die übrigen werden innerhalb der Hierarchie in Verzeichnissen „eingehängt“ (der entsprechende Unixbefehl heißt <command>mount</command>); diese anderen Platten sind dann unter ihren „Einhängepunkten“ verfügbar. Hierdurch wird es möglich, die Home-Verzeichnisse der Benutzer (üblicherweise in <filename>/home/</filename> gespeichert) auf einer zweiten Festplatte abzuspeichern, die dann Verzeichnisse wie <literal>rhertzog</literal> und <literal>rmas</literal> enthält. Sobald diese Platte auf <filename>/home/</filename> eingehängt ist, sind diese Verzeichnisse an ihren üblichen Orten zugänglich, und Pfade wie <filename>/home/rmas/Desktop/hello.txt</filename> funktionieren weiterhin.
			</para>
			 <indexterm>
				<primary><command>mkfs</command></primary>
			</indexterm>
			 <para>
				Es gibt zahlreiche Dateisystemformate entsprechend den zahlreichen Arten, auf die Daten physisch auf Platten gespeichert werden. Die bekanntesten sind <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> und <emphasis>ext4</emphasis>, es gibt aber auch andere. <emphasis>vfat</emphasis> ist zum Beispiel das System, das ursprünglich von DOS und den Windows-Betriebssystemen verwendet wurde, mit dem es möglich ist, Festplatten sowohl unter Debian als auch unter Windows zu benutzen. In jedem Fall muss auf einer Platte ein Dateisystem eingerichtet werden, bevor sie eingehängt werden kann, und dieser Vorgang wird als „formatieren“ bezeichnet. Befehle wie <command>mkfs.ext3</command> (wobei <command>mkfs</command> für <emphasis>MaKe FileSystem</emphasis> steht) erledigen das Formatieren. Diese Befehle benötigen als einen ihrer Parameter eine Gerätedatei, die die zu formatierende Partition darstellt (zum Beispiel <filename>/dev/sda1</filename>). Dieser Vorgang ist löschend und sollte nur einmal ausgeführt werden, es sei denn, man möchte absichtlich ein Dateisystem unwiederbringlich löschen und von Neuem beginnen.
			</para>
			 <para>
				Es gibt auch Netzwerk-Dateisysteme, wie zum Beispiel <acronym>NFS</acronym>, bei denen Daten nicht auf einer lokalen Platte gespeichert sind. Stattdessen werden Daten über das Netzwerk zu einem Server übertragen, der sie nach Bedarf speichert und abruft. Die Dateisystem-Abstraktion bewahrt Benutzer davor, sich darum kümmern zu müssen: Dateien bleiben in ihrer üblichen hierarchischen Weise zugänglich.
			</para>

		</section>
		 <section id="sect.shared-functions">
			<title>Gemeinsam genutzte Funktionen</title>
			 <para>
				Da eine Anzahl von Funktionen von allen Programmen gemeinsam benutzt wird, macht es Sinn, sie im Kernel zusammenzufassen. Zum Beispiel ermöglicht der Einsatz eines gemeinsam benutzten Dateisystems es jeder Anwendung, einfach eine Datei anhand ihres Namens zu öffnen, ohne sich darum zu kümmern, wo die Datei physisch gespeichert ist. Die Datei kann in mehreren Teilen auf einer Festplatte gespeichert sein, über mehrere Festplatten verteilt sein oder sogar auf einem entfernten Dateiserver abgelegt sein. Gemeinsam genutzte Kommunikationsfunktionen werden von Anwendungen dazu verwendet, Daten unabhängig von der Art auf der sie transportiert werden, auszutauschen. Zum Beispiel könnte der Transport über eine beliebige Kombination aus lokalen und kabellosen Netzwerken oder über eine Festnetztelefonleitung verlaufen.
			</para>

		</section>
		 <section id="sect.process-management">
			<title>Prozesse verwalten</title>
			 <indexterm>
				<primary><emphasis>pid</emphasis></primary>
			</indexterm>
			 <para>
				Ein Prozess führt ein Programm aus. Dies erfordert Speicherplatz, um sowohl das Programm selbst als auch seine Betriebsdaten zu speichern. Es ist die Aufgabe des Kernels, sie zu erzeugen und zu verfolgen. Wenn ein Programm läuft, reserviert der Kernel zunächst Speicherplatz, lädt dann den ausführbaren Code aus dem Dateisystem in den Speicher und beginnt schließlich, den Code auszuführen. Er hält Informationen über diesen Prozess bereit, von denen die am leichtesten erkennbare eine Identifikationsnummer namens <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis>) ist.
			</para>
			 <para>
				Unix-artige Kernel (einschließlich Linux) sind, wie die meisten anderen modernen Betriebssysteme fähig, im „Mehrprozessbetrieb“ zu laufen. Mit anderen Worten ermöglichen sie die Ausführung zahlreicher Prozesse „zur gleichen Zeit“. In Wirklichkeit läuft zu einem bestimmten Zeitpunkt immer nur ein Prozess, aber der Kernel teilt die Zeit in kleine Abschnitte auf und führt reihum jeden Prozess aus. Da diese Zeitabschnitte sehr kurz sind (im Bereich von Tausendstelsekunden), entsteht die Illusion, dass die Prozesse parallel laufen, obwohl sie jeweils nur während bestimmter Zeitabschnitte aktiv sind und im übrigen untätig. Die Aufgabe des Kernels besteht darin, seinen Zeitplanungsmechanismus so anzupassen, dass diese Illusion erhalten bleibt, und gleichzeitig die allgemeine Systemleistung maximiert wird. Wenn die Zeitabschnitte zu lang sind, könnte es der Anwendung nicht so schnell angezeigt werden wie erwünscht. Sind sie zu kurz, verliert das System Zeit durch zu häufiges Umschalten zwischen den Aufgaben. Diese Entscheidungen können mithilfe von Prozessprioritäten optimiert werden. Prozesse mit hoher Priorität laufen länger und häufiger als Prozesse mit niedriger Priorität.
			</para>
			 <sidebar> <title><emphasis>HINWEIS</emphasis> Multiprozessorsysteme (und Varianten)</title>
			 <para>
				Die oben beschriebene Einschränkung, nur einen Prozess gleichzeitig laufen zu lassen, gilt nicht immer. Die tatsächliche Einschränkung besteht darin, dass zu einem gegebenen Zeitpunkt immer nur ein Prozess <emphasis>je Prozessorkern</emphasis> laufen kann. Multiprozessor-, Multikern- oder „Hyper-Threading“-Systeme ermöglichen die parallele Ausführung mehrerer Prozesse. Das gleiche Zeitunterteilungssystem wird zwar weiterhin verwendet, jetzt jedoch dazu, mit Situationen umzugehen, in denen es mehr aktive Prozesse als verfügbare Prozessorkerne gibt. Dies ist nicht ungewöhnlich: ein einfaches System, selbst wenn es weitgehend nichts tut, führt fast ständig Dutzende von Prozessen aus.
			</para>
			 </sidebar> <para>
				Natürlich ermöglicht der Kernel es auch, mehrere unabhängige Instanzen desselben Programms auszuführen. Jedoch kann jede von ihnen nur auf ihre eigenen Zeitabschnitte und ihren eigenen Speicherplatz zugreifen. Ihre Daten bleiben daher voneinander unabhängig.
			</para>

		</section>
		 <section id="sect.permissions">
			<title>Rechteverwaltung</title>
			 <para>
				Unix-artige Systeme sind auch Mehrplatzsysteme. Sie verfügen über ein Rechteverwaltungssystem, das getrennte Gruppen und Benutzer ermöglicht und auf der Basis von Berechtigungen die Auswahl zwischen dem Zulassen und Blockieren von Aktionen. Der Kernel verwaltet für jeden Prozess die Daten, die es ermöglichen, Berechtigungen zu überprüfen. Meistens werden Prozesse anhand der Benutzer, die ihn gestartet haben, identifiziert. Der Prozess kann nur die Aktionen ausführen, die auch dem Besitzer erlaubt sind. Zum Beispiel muss der Kernel beim Versuch, eine Datei zu öffnen, die Identität des Prozesses hinsichtlich der Zugriffsberechtigungen überprüfen (für mehr Einzelheiten zu diesem speziellen Beispiel siehe <xref linkend="sect.rights-management" />).
			</para>

		</section>

	</section>
	 <section id="sect.user-space">
		<title>Die Anwendungsebene</title>
		 <indexterm>
			<primary>Anwendungsebene</primary>
		</indexterm>
		 <indexterm>
			<primary>Kernelebene</primary>
		</indexterm>
		 <para>
			„Anwendungsebene“ bezieht sich auf die Laufzeitumgebung normaler Prozesse (im Gegensatz zu Kernelprozessen). Das bedeutet nicht unbedingt, dass diese Prozesse tatsächlich von Benutzern gestartet wurden, da auf einem Standardsystem üblicherweise bereits mehrere „Daemon“-Prozesse laufen, bevor ein Benutzer überhaupt eine Sitzung eröffnet. Daemon-Prozesse sind Prozesse der Anwendungsebene.
		</para>
		 <section id="sect.process-basics">
			<title>Prozess</title>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				Wenn der Kernel seine Initialisierungsphase beendet hat, startet er den ersten Prozess, <command>init</command>. Prozess #1 ist für sich selbst kaum nützlich und Unix-artige Systeme laufen mit vielen zusätzlichen Prozessen.
			</para>
			 <indexterm>
				<primary><emphasis>Fork</emphasis></primary>
			</indexterm>
			 <para>
				Zunächst einmal kann sich ein Prozess kopieren (dies wird als <emphasis>Fork</emphasis> bezeichnet). Der Kernel teilt einen neuen, aber gleichgroßen Prozess-Speicherplatz zu und einen weiteren Prozess, um ihn zu nutzen. Zu diesem Zeitpunkt besteht der einzige Unterschied zwischen den beiden Prozessen in ihrer <emphasis>PID</emphasis>. Der neue Prozess wird üblicherweise Kindprozess genannt, und der Prozess, dessen <emphasis>PID</emphasis> sich nicht ändert, Elternprozess.
			</para>
			 <para>
				Manchmal fährt der Kindprozess fort, sein eigenes Leben unabhängig vom Elternprozess mit seinen eigenen, vom Elternprozess kopierten Daten zu führen. In vielen Fällen führt der Kindprozess jedoch ein anderes Programm aus. Bis auf wenige Ausnahmen wird sein Speicher einfach durch den Speicher des neuen Programms ersetzt, und die Ausführung dieses neuen Programms beginnt. Dieser Mechanismus wird vom „init“-Prozess (der die Prozessnummer 1 hat) genutzt um weitere Services zu starten und so die gesamte Startsequenz durchzuführen. Zu einem bestimmten Zeitpunkt startet ein Prozess der <command>init</command>-Abkömmlinge dann eine grafische Schnittstelle, über die sich Benutzer anmelden können (der tatsächliche Ablauf der Ereignisse ist in größerer Ausführlichkeit in <xref linkend="sect.system-boot" /> beschrieben.
			</para>
			 <para>
				Wenn ein Prozess die Aufgabe, für die er gestartet wurde, erfüllt hat, beendet er sich. Anschließend nimmt der Kernel den diesem Prozess zugewiesenen Speicher wieder zurück und hört auf, Teile der Prozessorzeit zuzuteilen. Der Elternprozess wird über die Beendigung seines Kindprozesses informiert. Auf diese Weise kann ein Prozess auf den Abschluss einer Aufgabe warten, die er an einen Kindprozess übertragen hat. Dieses Verhalten ist bei Kommandozeileninterpretern (auch als <emphasis>Shells</emphasis> bekannt) deutlich zu sehen. Wenn ein Befehl in eine Shell eingegeben wird, erscheint die Eingabeaufforderung erst dann wieder, wenn die Ausführung des Befehls beendet ist. Die meisten Shells ermöglichen eine Ausführung des Befehls im Hintergrund. Dazu wird einfach ein <userinput>&amp;</userinput> an das Ende des Befehls angehängt. Die Eingabeaufforderung wird dann sofort wieder angezeigt, was jedoch zu Problemen führen kann, wenn das abgesetzte Kommando seine eigenen Daten anzeigen muss.
			</para>

		</section>
		 <section id="sect.daemons">
			<title>Hintergrundprozesse (Dämonprozesse)</title>
			 <indexterm>
				<primary>Daemon</primary>
			</indexterm>
			 <indexterm>
				<primary>Daemon</primary>
			</indexterm>
			 <para>
				Ein „Daemon“ ist ein Prozess, der beim Hochfahren automatisch gestartet wird. Er läuft (im Hintergrund) weiter, um Verwaltungsaufgaben zu erledigen oder Dienste für andere Prozesse bereitzustellen. Diese „Hintergrundaufgabe“ ist genau genommen willkürlich und entspricht aus Sicht des Systems nichts Bestimmtem. Es sind, wie andere Prozesse auch, einfach Prozesse, die reihum laufen, wann immer ihr zugeteilter Zeitabschnitt kommt. Eine Unterscheidung gibt es nur in der menschlichen Sprache: ein Prozess, der ohne eine Interaktion mit einem Benutzer läuft (insbesondere ohne eine grafische Schnittstelle), wird als „im Hintergrund“ laufend oder als „Daemon“ bezeichnet.
			</para>
			 <sidebar> <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Daemon, Dämon, eine abwertende Bezeichnung?</title>
			 <para>
				Obwohl die Bezeichnung <emphasis>Daemon</emphasis> ihren griechischen Ursprung mit <emphasis>Dämon</emphasis> teilt, unterstellt erstere nichts teuflisch Übles, im Gegenteil sollte sie als eine Art hilfreicher Geist verstanden werden. Diese Unterscheidung ist im Englischen bereits recht subtil, in anderen Sprachen ist es jedoch noch schlimmer, in denen dasselbe Wort in beiden Bedeutungen verwendet wird.
			</para>
			 </sidebar> <para>
				Mehrere solcher Daemons sind ausführlich in <xref linkend="unix-services" /> beschrieben.
			</para>

		</section>
		 <section id="sect.ipc">
			<title>Interprozesskommunikationen</title>
			 <indexterm>
				<primary>IPC</primary>
			</indexterm>
			 <indexterm>
				<primary>Interprozesskommunikationen</primary>
			</indexterm>
			 <para>
				Ein einzelner Prozess, ob ein Daemon oder eine interaktive Anwendung, ist selten für sich genommen nützlich. Daher gibt es verschiedene Methoden, um getrennten Prozessen die Kommunikation miteinander zu ermöglichen, entweder um Daten auszutauschen oder um sich gegenseitig zu steuern. Die allgemeine Bezeichnung hierfür lautet <emphasis>Interprozesskommunikation</emphasis> oder abgekürzt IPC.
			</para>
			 <para>
				Das einfachste IPC-System besteht darin, Dateien zu verwenden. Der Prozess, der Daten übersenden möchte, schreibt sie in eine Datei (mit einem zuvor bekannten Namen), während der Empfänger nur die Datei zu öffnen und den Inhalt zu lesen braucht.
			</para>
			 <indexterm>
				<primary><emphasis>Pipe</emphasis></primary>
			</indexterm>
			 <para>
				In den Fällen, in denen man keine Daten auf einer Platte speichern möchte, kann man eine <emphasis>Pipe</emphasis> benutzen, die einfach ein Objekt mit zwei Enden ist; Bytes, die am einen Ende geschrieben werden, können am anderen gelesen werden. Wenn diese Enden von verschiedenen Prozessen kontrolliert werden, führt dies zu einem einfachen und praktischen Interprozesskommunikationskanal. Pipes können in zwei Arten unterschieden werden: benannte Pipes und anonyme Pipes. Eine benannte Pipe wird durch einen Eintrag im Dateisystem dargestellt (obwohl die übermittelten Daten dort nicht gespeichert sind), so dass beide Prozesse sie unabhängig voneinander öffnen können, falls der Ort der benannten Pipe vorab bekannt ist. In Fällen, in denen die Kommunikationsprozesse in Zusammenhang miteinander stehen (zum Beispiel ein Eltern- und sein Kindprozess), kann der Elternprozess auch eine anonyme Pipe erstellen, bevor er sich vervielfältigt, und der Kindprozess übernimmt sie dann. Beide Prozesse können sodann durch diese Pipe Daten miteinander austauschen, ohne das Dateisystem zu benötigen.
			</para>
			 <sidebar> <title><emphasis>IN DER PRAXIS</emphasis> Ein konkretes Beispiel</title>
			 <para>
				Lassen Sie uns beschreiben, was geschieht, wenn ein komplexer Befehl (eine <emphasis>Pipeline</emphasis>) von einer Konsole aus ausgeführt wird. Wir nehmen an, dass wir einen <command>bash</command>-Prozess haben (die standardmäßige Benutzerkonsole bei Debian) mit der <emphasis>PID</emphasis> 4374; in diese Konsole schreiben wir den Befehl: <command>ls | sort</command>.
			</para>
			 <para>
				Die Konsole interpretiert zunächst den eingegebenen Befehl. In unserem Fall versteht sie, dass es zwei Programme gibt (<command>ls</command> und <command>sort</command>) mit einem Datenstrom, der vom einen zum anderen fließt (gekennzeichnet durch das <userinput>|</userinput>-Zeichen, das als <emphasis>Pipe</emphasis> bezeichnet wird). <command>bash</command> erstellt zunächst eine anonyme Pipe (die anfangs nur innerhalb des <command>bash</command>-Prozesses selbst besteht).
			</para>
			 <para>
				Dann vervielfältigt sich die Konsole; dies führt zu einem neuen <command>bash</command>-Prozess mit der <emphasis>PID</emphasis> 4521 (<emphasis>PIDs</emphasis> sind abstrakte Zahlen und haben im Allgemeinen keine besondere Bedeutung). Prozess 4521 übernimmt die Pipe, was bedeutet, das er auf ihrer „Eingabe“-Seite schreiben kann; <command>bash</command> leitet seinen Standardausgabestrom auf die Eingabe dieser Pipe um. Dann führt es das Programm <command>ls</command> aus, das den Inhalt des aktuellen Verzeichnisses auflistet (und ersetzt sich selbst durch dieses Programm). Da <command>ls</command> auf seine Standardausgabe schreibt und diese Ausgabe zuvor umgeleitet wurde, werden die Ergebnisse im Endeffekt in die Pipe geschickt.
			</para>
			 <para>
				Ein ähnlicher Vorgang findet beim zweiten Befehl statt: <command>bash</command> vervielfältigt sich wieder, was zu einem neuen <command>bash</command>-Prozess mit der PID 4522 führt. Da er ebenfalls ein Kindprozess von 4374 ist, übernimmt er auch die Pipe; <command>bash</command> verbindet dann seine Standardeingabe mit der Pipeausgabe und führt danach den Befehl <command>sort</command> aus, der seine Eingabe sortiert und die Ergebnisse anzeigt (und ersetzt sich selbst durch diesen Befehl).
			</para>
			 <para>
				Alle Teile des Puzzles stehen nun bereit: <command>ls</command> liest das aktuelle Verzeichnis ein und schreibt die Liste der Dateien in die Pipe; <command>sort</command> liest diese Liste, sortiert sie alphabetisch und zeigt die Ergebnisse an. Die Prozesse 4521 und 4522 enden dann, und 4374 (der während des Vorgangs auf sie gewartet hatte) übernimmt wieder die Kontrolle und zeigt die Eingabeaufforderung an, die es dem Benutzer ermöglicht, einen neuen Befehl einzugeben.
			</para>
			 </sidebar> <para>
				Not all inter-process communications are used to move data around, though. In many situations, the only information that needs to be transmitted are control messages such as “pause execution” or “resume execution”. Unix (and Linux) provides a mechanism known as <emphasis>signals</emphasis>, through which a process can simply send a specific signal (chosen from a predefined list of signals) to another process. The only requirement is to know the <emphasis>pid</emphasis> of the target.
			</para>
			 <para>
				Für komplexere Kommunikationen gibt es ebenfalls Mechanismen, die es einem Prozess ermöglichen, einem anderen Prozess Zugriff auf einen Teil des ihm zugeteilten Speicherplatzes zu gewähren oder ihn gemeinsam mit ihm zu benutzen. Der nun gemeinsam benutzte Speicherplatz ermöglicht es dann, Daten zwischen den Prozessen hin und her zu schieben.
			</para>
			 <para>
				Schließlich können auch Netzwerkverbindungen Prozessen helfen, miteinander zu kommunizieren; diese Prozesse können sogar auf verschiedenen Rechnern laufen, möglicherweise tausende von Kilometern voneinander entfernt.
			</para>
			 <para>
				Es ist für ein typisches Unix-artiges System recht normal, all diese Mechanismen in wechselndem Umfang zu verwenden.
			</para>

		</section>
		 <section id="sect.libraries">
			<title>Bibliotheken</title>
			 <indexterm>
				<primary>Bibliothek (von Funktionen)</primary>
			</indexterm>
			 <para>
				Programmbibliotheken spielen in einem Unix-artigen Betriebssystem eine entscheidende Rolle. Sie sind nicht wirklich Programme, da sie für sich allein nicht ausgeführt werden können, sondern Ansammlungen von Code-Fragmenten, die von Standardprogrammen verwendet werden können. Unter den gängigen Bibliotheken sind vor allem folgende erwähnenswert:
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						die Standard-C-Bibliothek (<emphasis>glibc</emphasis>), die grundlegende Funktionen enthält wie das Öffnen von Dateien und von Netzwerkverbindungen und andere unterstützende Interaktionen mit dem Kernel;
					</para>

				</listitem>
				 <listitem>
					<para>
						grafische Werkzeugsätze, wie zum Beispiel Gtk+ und Qt, die es vielen Programmen ermöglichen, die grafischen Objekte, die sie bereitstellen, ihrerseits zu verwenden;
					</para>

				</listitem>
				 <listitem>
					<para>
						die <emphasis>libpng</emphasis>-Bibliothek, die das Laden, Interpretieren und Speichern von Bildern im PNG-Format ermöglicht.
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				Thanks to those libraries, applications can reuse existing code. Application development is simplified since many applications can reuse the same functions. With libraries often developed by different persons, the global development of the system is closer to Unix's historical philosophy.
			</para>
			 <sidebar> <title><emphasis>KULTUR</emphasis> Der Unix-Methode: Eins nach dem Anderen</title>
			 <para>
				Eines der wesentlichen Konzepte, das der Unix-Familie von Betriebssystemen zugrunde liegt, ist, dass jedes Werkzeug nur eine Sache erledigen sollte, und dass es diese gut machen sollte; Anwendungen können dann diese Werkzeuge wiederverwenden, um damit eine höhere Logik aufzubauen. Dieses Konzept ist in vielen Verkörperungen zu erkennen. Shellskripte sind vielleicht das beste Beispiel: sie fügen komplexe Folgen sehr einfacher Werkzeuge zusammen (wie zum Beispiel <command>grep</command>, <command>wc</command>, <command>sort</command>, <command>uniq</command> und so weiter). Eine andere Umsetzung dieser Philosophie ist in den Code-Bibliotheken zu erkennen: die Bibliothek <emphasis>libpng</emphasis> ermöglicht es, PNG-Bilder mit verschiedenen Optionen und auf verschiedene Weise zu lesen und zu schreiben, aber sie tut nur das; es kommt nicht infrage, dass ihr Funktionsmerkmale hinzugefügt werden, die Bilder anzeigen oder editieren.
			</para>
			 </sidebar> <para>
				Ferner werden diese Bibliotheken häufig als „gemeinsam benutzte Bibliotheken“ bezeichnet, da der Kernel sie nur einmal in den Speicher laden kann, selbst wenn gleichzeitig mehrere Prozesse dieselbe Bibliothek nutzen. Hierdurch kann im Vergleich zur entgegengesetzten (hypothetischen) Situation, bei der der Bibliothekscode so viele Male geladen würde, wie es Prozesse gibt, die ihn benutzen, Speicherplatz gespart werden.
			</para>

		</section>

	</section>
</appendix>

