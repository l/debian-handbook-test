<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course">
  <appendixinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-short-remedial-course.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>BIOS</keyword>
      <keyword>Kernel</keyword>
      <keyword>Unix</keyword>
      <keyword>Prozess</keyword>
      <keyword>Hierarchie</keyword>
      <keyword>Grundlegende Befehle</keyword>
    </keywordset>
  </appendixinfo>
  <title>Kurzer Förderkurs</title>
  <highlights>
    <para>Obwohl dieses Buch vor allem für Administratoren und „Power-User“ gedacht ist, möchten wir motivierte Einsteiger nicht ausschließen. Dieser Anhang enthält daher einen Schnellkurs, der die grundlegenden Konzepte beschreibt, die mit der Handhabung eines Unix-Rechners verbunden sind.</para>
  </highlights>
  <section id="sect.shell-and-basic-commands">
    <title>Shell und grundlegende Befehle</title>

    <para>In der Unix-Welt wird jeder Administrator früher oder später die Befehlszeile verwenden müssen; zum Beispiel, wenn das System nicht korrekt startet und nur einen Rettungsmodus mit einer Befehlszeile bereitstellt. Mit einer derartigen Schnittstelle umgehen zu können, stellt daher unter solchen Umständen eine grundlegende Überlebensfertigkeit dar.</para>

    <sidebar>
      <title><emphasis>KURZER BLICK</emphasis> Den Befehlsinterpreter starten</title>

      <para>A command-line environment can be run from the graphical
      desktop, by an application known as a “terminal”. In GNOME,
      you can start it from the “Activities” overview (that you get
      when you move the mouse in the top-left corner of the screen) by
      typing the first letters of the application name. In KDE, you will
      find it in the <menuchoice><guimenu>K</guimenu>
      <guisubmenu>Applications</guisubmenu>
      <guisubmenu>System</guisubmenu></menuchoice> menu.</para>
    </sidebar>

    <para>This section only gives a quick peek at the commands. They all
    have many options not described here, so please refer to the
    abundant documentation in their respective manual pages.</para>
    <section>
      <title>Den Verzeichnisbaum durchsuchen und Dateien verwalten</title>

      <para>Sobald eine Sitzung gestartet ist, zeigt der Befehl <command>pwd</command> (das steht für <emphasis>print working directory</emphasis>) die derzeitige Position im Dateisystem an. Das aktuelle Verzeichnis kann mit dem Befehl <command>cd <replaceable>verzeichnis</replaceable></command> (<command>cd</command> steht für <emphasis>change directory</emphasis>) gewechselt werden. Das übergeordnete Verzeichnis heißt immer <literal>..</literal> (zwei Punkte), während das aktuelle Verzeichnis auch als <literal>.</literal> (ein Punkt) bekannt ist. Der Befehl <command>ls</command> (<emphasis>list</emphasis>) zeigt den Inhalt eines Verzeichnisses an. Wenn keine zusätzlichen Parameter angegeben werden, wird das aktuelle Verzeichnis angezeigt.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>cd Desktop</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd .</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/Desktop
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates
Documents  Music      Public    Videos</computeroutput>
      </screen>

      <para>A new directory can be created with <command>mkdir
      <replaceable>directory</replaceable></command>, and an existing
      (empty) directory can be removed with <command>rmdir
      <replaceable>directory</replaceable></command>. The
      <command>mv</command> command allows <emphasis>moving</emphasis>
      and/or renaming files and directories; <emphasis>removing</emphasis>
      a file is achieved with <command>rm
      <replaceable>file</replaceable></command>.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public    test
$ </computeroutput><userinput>mv test new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  new       Public     Videos
Documents  Music      Pictures  Templates
$ </computeroutput><userinput>rmdir new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>Desktop    Downloads  Pictures  Templates  Videos
Documents  Music      Public</computeroutput>
      </screen>
    </section>
    <section>
      <title>Textdateien anzeigen und verändern</title>

      <para>The <command>cat <replaceable>file</replaceable></command>
      command (intended to <emphasis>concatenate</emphasis> files to the
      standard output device) reads a file and displays its contents on the
      terminal. If the file is too big to fit on a screen, use a pager such
      as <command>less</command> (or <command>more</command>) to display it
      page by page.</para>

      <para>The <command>editor</command> command starts a text
      editor (such as <command>vi</command> or <command>nano</command>) and
      allows creating, modifying and reading text files. The simplest files
      can sometimes be created directly from the command interpreter thanks
      to redirection: <command>echo "<replaceable>text</replaceable>"
      &gt;<replaceable>file</replaceable></command> creates a file named
      <replaceable>file</replaceable> with
      “<replaceable>text</replaceable>” as its contents. Adding a line
      at the end of this file is possible too, with a command such as
      <command>echo "<replaceable>moretext</replaceable>"
      &gt;&gt;<replaceable>file</replaceable></command>. Note the
      <literal>&gt;&gt;</literal> in this example.</para>
    </section>
    <section>
      <title>Nach Dateien und in Dateien suchen</title>

      <para>The <command>find <replaceable>directory</replaceable>
      <replaceable>criteria</replaceable></command> command looks for files
      in the hierarchy under <replaceable>directory</replaceable> according
      to several criteria. The most commonly used criterion is
      <literal>-name <replaceable>name</replaceable></literal>: that allows
      looking for a file by its name.</para>

      <para>Der Befehl <command>grep <replaceable>ausdruck</replaceable> <replaceable>dateien</replaceable></command> durchsucht den Inhalt der Dateien und exzerpiert die Zeilen, die dem regulären Ausdruck entsprechen (siehe <xref linkend="sidebar.regexp" /> in der Seitenleiste). Das Hinzufügen der Option <literal>-r</literal> bewirkt eine rekursive Suche in allen Dateien des Verzeichnisses, das als Parameter angegeben wird. So ist es möglich, nach einer Datei zu suchen, wenn nur ein Teil ihres Inhalts bekannt ist.</para>
    </section>
    <section>
      <title>Prozesse verwalten</title>

      <para>The <command>ps aux</command> command lists the processes
      currently running and helps identifying them by showing their
      <emphasis>pid</emphasis> (process id). Once the
      <emphasis>pid</emphasis> of a process is known, the <command>kill
      -<replaceable>signal</replaceable>
      <replaceable>pid</replaceable></command> command allows sending it a
      signal (if the process belongs to the current user). Several signals
      exist; most commonly used are <literal>TERM</literal> (a request to
      terminate gracefully) and <literal>KILL</literal> (a forced kill).</para>

      <para>The command interpreter can also run programs in the background
      if the command is followed by a “&amp;”. By using the ampersand, the
      user resumes control of the shell immediately even though the command
      is still running (hidden from the user; as a background process). The
      <command>jobs</command> command lists the processes running in the
      background; running <command>fg
      %<replaceable>job-number</replaceable></command> (for
      <emphasis>foreground</emphasis>) restores a job to the foreground.
      When a command is running in the foreground (either because it was
      started normally, or brought back to the foreground with
      <command>fg</command>), the <keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>
      key combination pauses the process and resumes control of the command-line.
      The process can then be restarted in the background with <command>bg
      %<replaceable>job-number</replaceable></command> (for
      <foreignphrase>background</foreignphrase>).</para>
    </section>
    <section>
      <title>Systeminformation: Speicher, Speicherplatz, Identität</title>

      <para>The <command>free</command> command displays information on
      memory; <command>df</command> (<emphasis>disk free</emphasis>)
      reports on the available disk space on each of the disks mounted in
      the filesystem. Its <literal>-h</literal> option (for <emphasis>human
      readable</emphasis>) converts the sizes into a more legible unit
      (usually mebibytes or gibibytes). In a similar fashion, the
      <command>free</command> command supports the <literal>-m</literal>
      and <literal>-g</literal> options, and displays its data either in
      mebibytes or in gibibytes, respectively.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       used       free     shared    buffers     cached
Mem:       1028420    1009624      18796          0      47404     391804
-/+ buffers/cache:     570416     458004
Swap:      2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda2              9614084   4737916   4387796  52% /
tmpfs                   514208         0    514208   0% /lib/init/rw
udev                     10240       100     10140   1% /dev
tmpfs                   514208    269136    245072  53% /dev/shm
/dev/sda5             44552904  36315896   7784380  83% /home
</computeroutput></screen>

      <para>Der Befehl <command>id</command> zeigt die Identität des Benutzers an, der die Sitzung ausführt, zusammen mit einer Liste der Gruppen, denen er angehört. Da der Zugriff auf einige Dateien oder Geräte auf Gruppenmitglieder beschränkt sein kann, kann es nützlich sein, die verfügbaren Gruppenmitgliedschaften zu überprüfen.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
      </screen>
    </section>
  </section>
  <section id="sect.filesystem-hierarchy">
    <title>Organisation der Dateisystem-Hierarchie</title>
    <indexterm><primary>Dateisystem-Hierarchie</primary></indexterm>
    <section>
      <title>Das Wurzelverzeichnis</title>

      <para>A Debian system is organized along the <emphasis>Filesystem Hierarchy
      Standard</emphasis> (FHS). This standard defines the purpose of each
      directory. For instance, the top-level directories are described as
      follows:</para>
      <itemizedlist>
        <listitem>
	  <para><filename>/bin/</filename>: grundlegende Programme;</para>
        </listitem>
        <listitem>
	  <para><filename>/boot/</filename>: Linux-Kernel und andere Dateien, die für seinen frühen Startvorgang benötigt werden;</para>
        </listitem>
        <listitem>
	  <para><filename>/dev/</filename>: Gerätedateien;</para>
        </listitem>
        <listitem>
	  <para><filename>/etc/</filename>: Konfigurationsdateien;</para>
        </listitem>
        <listitem>
	  <para><filename>/home/</filename>: persönliche Dateien des Benutzers;</para>
        </listitem>
        <listitem>
	  <para><filename>/lib/</filename>: grundlegende Bibliotheken;</para>
        </listitem>
        <listitem>
	  <para><filename>/media/*</filename>: Einhängepunkte für entfernbare Geräte (CD-ROM, USB-Sticks und so weiter);</para>
        </listitem>
        <listitem>
	  <para><filename>/mnt/</filename>: vorübergehender Einhängepunkt;</para>
        </listitem>
        <listitem>
	  <para><filename>/opt/</filename>: zusätzliche von Dritten bereitgestellte Anwendungen;</para>
        </listitem>
        <listitem>
	  <para><filename>/root/</filename>: persönliche Dateien des Administrators (zu Root gehörig);</para>
        </listitem>
        <listitem>
          <para><filename>/run/</filename>: volatile runtime data that does not
          persist across reboots (not yet included in the FHS);
          </para>
        </listitem>
        <listitem>
	  <para><filename>/sbin/</filename>: Systemprogramme;</para>
        </listitem>
        <listitem>
	  <para><filename>/srv/</filename>: Daten, die von auf diesem System untergebrachten Servern benutzt werden;</para>
        </listitem>
        <listitem>
	  <para><filename>/tmp/</filename>: temporäre Dateien; dieses Verzeichnis wird häufig während des Rechnerstarts geleert;</para>
        </listitem>
        <listitem>
	  <para><filename>/usr/</filename>: Anwendungen; dieses Verzeichnis ist weiter unterteilt in <filename>bin</filename>, <filename>sbin</filename>, <filename>lib</filename> (nach derselben Logik wie beim Wurzelverzeichnis). Darüber hinaus enthält <filename>/usr/share/</filename> architekturunabhängige Daten. <filename>/usr/local/</filename> soll vom Administrator dazu verwendet werden, von Hand Anwendungen zu installieren, ohne dabei Dateien zu überschreiben, die das Paketsystem (<command>dpkg</command>) verwaltet.</para>
        </listitem>
        <listitem>
	  <para><filename>/var/</filename>: veränderliche Daten, die von Daemons gehandhabt werden. Hierzu gehören Protokolldateien, Warteschlangen, Zwischenspeicher und so weiter.</para>
        </listitem>
        <listitem>
	  <para><filename>/proc/</filename> and <filename>/sys/</filename>
	  are specific to the Linux kernel (and not part of the FHS). They
	  are used by the kernel for exporting data to user space
	  (see <xref linkend="sect.userspace-presentation" /> and <xref linkend="sect.user-space" /> for explanations about this
	  concept).</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Das Home-Verzeichnis des Benutzers</title>

      <para>Der Inhalt des Home-Verzeichnisses eines Benutzers ist nicht standardisiert, es gibt aber einige beachtenswerte Gepflogenheiten. Eine ist, dass das Home-Verzeichnis eines Benutzers oft durch eine Tilde („~“) bezeichnet wird. Das ist nützlich zu wissen, denn Befehlszeileninterpreter ersetzen die Tilde automatisch durch das korrekte Verzeichnis (normalerweise <filename>/home/<replaceable>benutzer</replaceable>/</filename>).</para>

      <para>Die Konfigurationsdateien der Anwendungen werden häufig direkt im Home-Verzeichnis des Benutzers gespeichert, jedoch beginnen ihre Namen gewöhnlich mit einem Punkt (zum Beispiel speichert der E-Mail-Client <command>mutt</command> seine Konfiguration in <filename>~/.muttrc</filename>). Achten Sie darauf: Dateinamen, die mit einem Punkt beginnen, sind standardmäßig unsichtbar, und <command>ls</command> führt sie nur auf, wenn die Option <literal>-a</literal> benutzt wird und bei Dateimanagern muß dies auch explizit eingestellt werden.</para>

      <para>Einige Programme verwenden auch mehrere in einem Verzeichnis organisierte Konfigurationsdateien (zum Beispiel <filename>~/.ssh/</filename>). Einige Anwendungen (wie zum Beispiel der Web-Browser Iceweasel) benutzen ihr Verzeichnis auch, um einen Cache heruntergeladener Daten zu speichern. Dies bedeutet, dass diese Verzeichnisse schließlich sehr viel Speicherplatz belegen können.</para>

      <para>Diese Konfigurationsdateien die direkt im Benutzerverzeichnis gespeichert werden und die oft gemeinschaftlich als <emphasis>Dotfiles</emphasis> bezeichnet werden, haben so stark gewuchert dass diese Verzeichnisse nun vollgestopft davon sind. Glücklicherweise führte führte eine Verbesserung unter dem Schirm der FreeDesktop.org hinaus in die “XDG Base Directory Specification”, ein Abkommen mit dem Ziel diese Dateien und Verzeichnisse aufzuräumen. Diese Spezifikation besagt, dass Konfigurationsdateien unterhalb von <filename>~/.config</filename>, Cache-Dateien unter <filename>~/.cache</filename> und Applikationsdaten unter <filename>~/.local</filename> (oder Unterverzeichnissen davon) gespeichert werden sollen. Dieses Abkommen bekommt so langsam Zugkraft und verschiedene Applikationen (insbesondere grafische) beginnen es nun umzusetzen.</para>

      <para>Graphical desktops usually display the contents of the
      <filename>~/Desktop/</filename> directory (or whatever the appropriate
      translation is for systems not configured in English) on the desktop
      (ie, what is visible on screen once all applications are closed or
      iconized).</para>

      <para>Schließlich speichert das E-Mail-System ankommende E-Mails manchmal in einem <filename>~/Mail/</filename>-Verzeichnis.</para>
    </section>
  </section>
  <section id="sect.computer-layers">
    <title>Das Innenleben eines Rechners: die verschiedenen beteiligten Schichten</title>

    <para>Ein Rechner wird häufig als etwas ziemlich Abstraktes angesehen, und die äußerlich sichtbare Schnittstelle ist wesentlich einfacher als seine interne Komplexität. Diese Komplexität ergibt sich zum Teil aus der Zahl der beteiligten Teile. Diese Teile können jedoch in Form von Schichten betrachtet werden, wobei eine Schicht nur mit der unmittelbar darüber- und darunterliegenden interagiert.</para>

    <para>Ein Endbenutzer kann zurechtkommen, ohne diese Einzelheiten zu kennen... solange alles funktioniert. Wenn man einem Problem wie „Das Internet geht nicht!“ gegenübersteht, besteht der erste Schritt darin herauszufinden, aus welcher Schicht das Problem herrührt. Funktioniert die Netzwerkkarte (Hardware)? Wird sie vom Rechner erkannt? Sieht sie der Linux-Kernel? Sind die Netzwerkparameter richtig eingestellt? All diese Fragen grenzen die zutreffende Schicht ein und richten das Augenmerk auf die mögliche Quelle des Problems.</para>
    <section id="sect.hardware">
      <title>Die unterste Schicht: Die Hardware</title>
      <indexterm><primary>IDE</primary></indexterm>
      <indexterm><primary>SCSI</primary></indexterm>
      <indexterm><primary>Serial ATA</primary></indexterm>
      <indexterm><primary>Parallel ATA</primary></indexterm>
      <indexterm><primary>ATA</primary></indexterm>
      <indexterm><primary>IEEE 1394</primary></indexterm>
      <indexterm><primary>Firewire</primary></indexterm>
      <indexterm><primary>USB</primary></indexterm>

      <para>Let us start with a basic reminder that a computer is,
      first and foremost, a set of hardware elements. There is
      generally a main board (known as the
      <emphasis>motherboard</emphasis>), with one (or more)
      processor(s), some RAM, device controllers, and extension slots
      for option boards (for other device controllers).  Most
      noteworthy among these controllers are IDE (Parallel ATA), SCSI
      and Serial ATA, for connecting to storage devices such as hard
      disks.  Other controllers include USB, which is able to host a
      great variety of devices (ranging from webcams to thermometers,
      from keyboards to home automation systems) and IEEE 1394
      (Firewire). These controllers often allow connecting several
      devices so the complete subsystem handled by a controller is
      therefore usually known as a “bus”.  Option boards include
      graphics cards (into which monitor screens will be plugged),
      sound cards, network interface cards, and so on. Some main
      boards are pre-built with these features, and don't need option
      boards.</para>

      <sidebar>
        <title><emphasis>IN DER PRAXIS</emphasis> Überprüfen, ob die Hardware funktioniert</title>

	<para>Zu überprüfen, ob ein Hardwareteil funktioniert, kann schwierig sein. Dagegen lässt sich manchmal recht einfach feststellen, dass es nicht funktioniert.</para>

	<para>Ein Festplattenlaufwerk besteht aus sich drehenden Platten und sich bewegenden Magnetköpfen. Wenn eine Festplatte angeschaltet wird, erzeugt der Plattenmotor ein charakteristisches Surren. Außerdem gibt er Energie in Form von Hitze ab. Deshalb ist ein Festplattenlaufwerk, das beim Anschalten kalt und still bleibt, defekt.</para>

	<para>Netzwerkkarten besitzen häufig LEDs, die den Verbindungsstatus anzeigen. Falls ein Kabel angeschlossen ist und zu einem funktionierenden Netzwerk-Hub oder -Schalter führt, wird zumindest eine LED an sein. Falls keine LED leuchtet, ist entweder die Karte selbst, das Netzwerkgerät oder das Kabel zwischen ihnen defekt. Der nächste Schritt besteht deshalb dann darin, jede Komponente einzeln zu überprüfen.</para>

	<para>Einige Optionskarten - insbesondere 3D-Videokarten - enthalten Kühlungen, wie Kühlkörper und Ventilatoren. Wenn sich der Ventilator nicht dreht, obwohl die Karte angeschaltet ist, besteht eine plausible Erklärung darin, dass die Karte überhitzt ist. Das Gleiche gilt auch für den oder die Hauptprozessor(en) auf der Hauptplatine.</para>
      </sidebar>
    </section>
    <section id="sect.bios">
      <title>The Starter: the BIOS or UEFI</title>
      <indexterm><primary>BIOS</primary></indexterm>
      <indexterm><primary>UEFI</primary></indexterm>
      <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

      <para>Hardware ist für sich genommen ohne entsprechende Software, die sie steuert, nicht in der Lage, sinnvolle Tätigkeiten auszuführen. Der Zweck des Betriebssystems und der Anwendungen besteht darin, die Hardware zu kontrollieren und mit ihr zu interagieren. Ihrerseits benötigen sie funktionierende Hardware, um zu laufen.</para>

      <para>This symbiosis between hardware and software does not happen on
      its own. When the computer is first powered up, some initial setup is
      required. This role is assumed by the BIOS or UEFI, a piece of software
      embedded into the main board that runs automatically upon power-up.
      Its primary task is searching for software it can hand over control
      to. Usually, in the BIOS case, this involves looking for the first
      hard disk with a boot sector (also known as the <emphasis>master
      boot record</emphasis> or <acronym>MBR</acronym>), loading that
      boot sector, and running it. From then on, the BIOS is usually not
      involved (until the next boot). In the case of UEFI, the process
      involves scanning disks to find a dedicated EFI partition containing
      further EFI applications to execute.</para>

      <sidebar>
        <title><emphasis>TOOL</emphasis> Setup, the BIOS/UEFI configuration tool</title>
        <indexterm><primary><emphasis>Setup</emphasis></primary></indexterm>

	<para>The BIOS/UEFI also contains a piece of software called Setup,
	designed to allow configuring aspects of the computer. In
	particular, it allows choosing which boot device is preferred (for
	instance, the floppy disk or CD-ROM drive), setting the system
	clock, and so on. Starting Setup usually involves pressing a key
	very soon after the computer is powered on. This key is often
	<keycap>Del</keycap> or <keycap>Esc</keycap>, sometimes
	<keycap>F2</keycap> or <keycap>F10</keycap>. Most of the time, the
	choice is flashed on screen while booting.</para>
      </sidebar>

      <para>The boot sector (or the EFI partition), in turn, contains another piece of
      software, called the bootloader, whose purpose is to find and run an
      operating system. Since this bootloader is not embedded in the main
      board but loaded from disk, it can be smarter than the BIOS, which
      explains why the BIOS does not load the operating system by itself.
      For instance, the bootloader (often GRUB on Linux systems) can list
      the available operating systems and ask the user to choose one.
      Usually, a time-out and default choice is provided. Sometimes the
      user can also choose to add parameters to pass to the kernel, and so
      on. Eventually, a kernel is found, loaded into memory, and
      executed.</para>

      <sidebar>
        <title><emphasis>NOTE</emphasis> UEFI, a modern replacement to the BIOS</title>
        <indexterm><primary>UEFI</primary></indexterm>
        <indexterm><primary>Secure Boot</primary></indexterm>

        <para>UEFI is a relatively recent development. Most new computers will
        support UEFI booting, but usually they also support BIOS booting alongside
        for backwards compatibility with operating systems that are not ready
        to exploit UEFI.
        </para>
        <para>This new system gets rid of some of the limitations of BIOS
        booting: with the usage of a dedicated partition, the bootloaders no longer
        need special tricks to fit in a tiny <emphasis>master boot record</emphasis>
        and then discover the kernel to boot. Even better, with a suitably
        built Linux kernel, UEFI can directly boot the kernel without any
        intermediary bootloader.  UEFI is also the basic foundation used
        to deliver <emphasis>Secure Boot</emphasis>, a technology ensuring
        that you run only software validated by your operating system
        vendor.
        </para>
      </sidebar>

      <para>The BIOS/UEFI is also in charge of detecting and initializing a
      number of devices. Obviously, this includes the IDE/SATA devices
      (usually hard disk(s) and CD/DVD-ROM drives), but also PCI devices.
      Detected devices are often listed on screen during the boot process.
      If this list goes by too fast, use the <keycap>Pause</keycap> key to
      freeze it for long enough to read. Installed PCI devices that don't
      appear are a bad omen. At worst, the device is faulty. At best, it
      is merely incompatible with the current version of the BIOS or main
      board. PCI specifications evolve, and old main boards are not
      guaranteed to handle newer PCI devices.</para>
    </section>
    <section id="sect.kernel">
      <title>Der Kernel</title>

      <para>Both the BIOS/UEFI and the bootloader only run for a few seconds
      each; now we are getting to the first piece of software that runs for
      a longer time, the operating system kernel. This kernel assumes the
      role of a conductor in an orchestra, and ensures coordination between
      hardware and software. This role involves several tasks including:
      driving hardware, managing processes, users and permissions, the
      filesystem, and so on. The kernel provides a common base to all other
      programs on the system.</para>
    </section>
    <section id="sect.userspace-presentation">
      <title>Die Anwendungsebene</title>

      <para>Although everything that happens outside of the kernel can be
      lumped together under “user space”, we can still separate it into
      software layers. However, their interactions are more complex than
      before, and the classifications may not be as simple. An application
      commonly uses libraries, which in turn involve the kernel, but the
      communications can also involve other programs, or even many
      libraries calling each other.</para>
    </section>
  </section>
  <section id="sect.kernel-role-and-tasks">
    <title>Einige vom Kernel erledigte Aufgaben</title>
    <section id="sect.hardware-drivers">
      <title>Die Hardware steuern</title>

      <para>Es ist vor allem Aufgabe des Kernels, die Hardwareelemente zu steuern, sie zu erkennen, sie einzuschalten, wenn der Rechner angeschaltet wird, und so weiter. Er macht sie auch über eine vereinfachte Programmierschnittstelle für die Software auf höherer Ebene verfügbar, so dass Anwendungen Geräte nutzen können, ohne sich um Einzelheiten kümmern zu müssen, wie zum Beispiel, in welchen Erweiterungssteckplatz die Optionsplatine eingesteckt ist. Die Programmierschnittstelle stellt auch eine Abstraktionsschicht zur Verfügung; diese ermöglicht es zum Beispiel einer Videokonferenz-Anwendung, eine Webkamera unabhängig von ihrer Marke und ihrem Modell zu verwenden. Die Anwendung kann einfach die Schnittstelle <emphasis>Video for Linux</emphasis> (V4L) benutzen, und der Kernel übersetzt die Funktionsaufrufe dieser Schnittstelle in die tatsächlichen Hardwarebefehle, die von der konkret verwendeten Webkamera benötigt werden.</para>

     
      <para><indexterm><primary><command>lspci</command></primary></indexterm> <indexterm><primary><command>lsusb</command></primary></indexterm> <indexterm><primary><command>lsdev</command></primary></indexterm> <indexterm><primary><command>lspcmcia</command></primary></indexterm> Der Kernel exportiert über die virtuellen Dateisysteme <filename>/proc/</filename> und <filename>/sys/</filename> zahlreiche Einzelheiten über die erkannte Hardware. Verschiedene Hilfsprogramme fassen diese Einzelheiten zusammen. Von ihnen zeigt <command>lspci</command> (im Paket <emphasis role="pkg">pciutils</emphasis>) eine Liste der PCI-Geräte an, <command>lsusb</command> (im Paket <emphasis role="pkg">usbutils</emphasis>) führt USB-Geräte auf und <command>lspcmcia</command> (im Paket <emphasis role="pkg">pcmciautils</emphasis>) PCMCIA-Karten. Diese Hilfsprogramme sind zur Identifizierung des genauen Modells eines Geräts sehr hilfreich. Diese Identifizierung ermöglicht auch ein genaueres Suchen im Web, das wiederum zu relevanteren Dokumenten führt.</para>

      <example>
        <title>Beispiel der von <command>lspci</command> und <command>lsusb</command> angezeigten Informationen</title>

        <screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>
      </example>

      <para>Diese Programme haben eine Option <literal>-v</literal>, durch die wesentlich detailliertere (aber gewöhnlich nicht erforderliche) Informationen angezeigt werden. Schließlich listet der Befehl <command>lsdev</command> (im Paket <emphasis role="pkg">procinfo</emphasis>) die von den Geräten benutzten Kommunikationsressourcen auf.</para>

      <para>Anwendungen greifen häufig mittels spezieller in <filename>/dev/</filename> erzeugter Dateien auf Geräte zu (siehe Seitenleiste <xref linkend="sidebar.special-files" />). Dies sind besondere Dateien, die Plattenlaufwerke (zum Beispiel <filename>/dev/hda</filename> und <filename>/dev/sdc</filename>), Partitionen (<filename>/dev/hda1</filename> oder <filename>/dev/sdc3</filename>), Mäuse (<filename>/dev/input/mouse0</filename>), Tastaturen (<filename>/dev/input/event0</filename>), Soundkarten (<filename>/dev/snd/*</filename>), serielle Schnittstellen (<filename>/dev/ttyS*</filename>) und so weiter repräsentieren.</para>
    </section>
    <section id="sect.filesystems">
      <title>Dateisysteme</title>
      <indexterm><primary>Dateisystem</primary></indexterm>
      <indexterm><primary>System, Dateisystem</primary></indexterm>

      <para>Dateisysteme sind einer der bedeutendsten Aspekte des Kernels. Unix-Systeme vereinen alle Dateispeicher in einer gemeinsamen Hierarchie, die es Benutzern (und Anwendungen) ermöglicht, auf Daten einfach durch Kenntnis ihres Ortes innerhalb dieser Hierarchie zuzugreifen.</para>

      <para>Der Ausgangspunkt dieses Hierarchiebaums wird „root“ genannt, <filename>/</filename>. Dieses Verzeichnis kann mit Namen versehene Unterverzeichnisse enthalten. Das Unterverzeichnis <literal>home</literal> von <filename>/</filename> wird beispielsweise <filename>/home/</filename> genannt. Dieses Unterverzeichnis kann wiederum weitere Unterverzeichnisse enthalten und so weiter. Jedes Verzeichnis kann auch Dateien enthalten, in denen die tatsächlichen Daten gespeichert sind. So bezieht sich <filename>/home/rmas/Desktop/hello.txt</filename> auf eine Datei namens <literal>hello.txt</literal>, die im Unterverzeichnis <literal>Desktop</literal> des Unterverzeichnisses <literal>rmas</literal> des Verzeichnisses <literal>home</literal> gespeichert ist, das sich in root befindet. Der Kernel übersetzt zwischen diesem Benennungssystem und dem tatsächlichen, physikalischen Speicherort auf einer Platte.</para>

      <para>Unlike other systems, there is only one such hierarchy, and it
      can integrate data from several disks. One of these disks is used as
      the root, and the others are “mounted” on directories in the
      hierarchy (the Unix command is called <command>mount</command>);
      these other disks are then available under these “mount points”.
      This allows storing users' home directories (traditionally stored
      within <filename>/home/</filename>) on a second hard disk, which will
      contain the <literal>rhertzog</literal> and <literal>rmas</literal>
      directories. Once the disk is mounted on <filename>/home/</filename>,
      these directories become accessible at their usual locations, and
      paths such as <filename>/home/rmas/Desktop/hello.txt</filename> keep
      working.</para>
      <indexterm><primary><command>mkfs</command></primary></indexterm>

      <para>There are many filesystem formats, corresponding to many ways of
      physically storing data on disks. The most widely known are
      <emphasis>ext2</emphasis>, <emphasis>ext3</emphasis> and
      <emphasis>ext4</emphasis>, but others exist. For instance,
      <emphasis>vfat</emphasis> is the system that was historically used by
      DOS and Windows operating systems, which allows using hard disks
      under Debian as well as under Windows. In any case, a filesystem must
      be prepared on a disk before it can be mounted and this operation is
      known as “formatting”. Commands such as
      <command>mkfs.ext3</command> (where <command>mkfs</command> stands
      for <emphasis>MaKe FileSystem</emphasis>) handle formatting. These
      commands require, as a parameter, a device file representing the
      partition to be formatted (for instance,
      <filename>/dev/sda1</filename>). This operation is destructive and
      should only be run once, except if one deliberately wishes to wipe a
      filesystem and start afresh.</para>

      <para>There are also network filesystems, such as
      <acronym>NFS</acronym>, where data is not stored on a local disk.
      Instead, data is transmitted through the network to a server that
      stores and retrieves them on demand. The filesystem abstraction
      shields users from having to care: files remain accessible in their
      usual hierarchical way.</para>
    </section>
    <section id="sect.shared-functions">
      <title>Gemeinsam genutzte Funktionen</title>

      <para>Da eine Anzahl von Funktionen von allen Programmen gemeinsam benutzt wird, macht es Sinn, sie im Kernel zusammenzufassen. Zum Beispiel ermöglicht der Einsatz eines gemeinsam benutzten Dateisystems es jeder Anwendung, einfach eine Datei anhand ihres Namens zu öffnen, ohne sich darum zu kümmern, wo die Datei physisch gespeichert ist. Die Datei kann in mehreren Teilen auf einer Festplatte gespeichert sein, über mehrere Festplatten verteilt sein oder sogar auf einem entfernten Dateiserver abgelegt sein. Gemeinsam genutzte Kommunikationsfunktionen werden von Anwendungen dazu verwendet, Daten unabhängig von der Art auf der sie transportiert werden, auszutauschen. Zum Beispiel könnte der Transport über eine beliebige Kombination aus lokalen und kabellosen Netzwerken oder über eine Festnetztelefonleitung verlaufen.</para>
    </section>
    <section id="sect.process-management">
      <title>Prozesse verwalten</title>
      <indexterm><primary><emphasis>pid</emphasis></primary></indexterm>

      <para>Ein Prozess führt ein Programm aus. Dies erfordert Speicherplatz, um sowohl das Programm selbst als auch seine Betriebsdaten zu speichern. Es ist die Aufgabe des Kernels, sie zu erzeugen und zu verfolgen. Wenn ein Programm läuft, reserviert der Kernel zunächst Speicherplatz, lädt dann den ausführbaren Code aus dem Dateisystem in den Speicher und beginnt schließlich, den Code auszuführen. Er hält Informationen über diesen Prozess bereit, von denen die am leichtesten erkennbare eine Identifikationsnummer namens <emphasis>pid</emphasis> (<emphasis>process identifier</emphasis>) ist.</para>

      <para>Unix-like kernels (including Linux), like most other modern
      operating systems, are capable of “multi-tasking”. In other words,
      they allow running many processes “at the same time”. There is
      actually only one running process at any one time, but the kernel
      cuts time into small slices and runs each process in turn. Since
      these time slices are very short (in the millisecond range), they
      create the illusion of processes running in parallel, although
      they are actually only active during some time intervals and idle the
      rest of the time. The kernel's job is to adjust its scheduling
      mechanisms to keep that illusion, while maximizing the global system
      performance. If the time slices are too long, the application may
      not appear as responsive as desired. Too short, and the system
      loses time switching tasks too frequently. These decisions can be
      tweaked with process priorities. High-priority processes will run for
      longer and with more frequent time slices than low-priority
      processes.</para>

      <sidebar>
        <title><emphasis>HINWEIS</emphasis> Multiprozessorsysteme (und Varianten)</title>

	<para>The limitation described above of only one process being
	able to run at a time, doesn't always apply. The actual
	restriction is that there can only be one
	running process <emphasis>per processor core</emphasis> at a
	time. Multi-processor, multi-core or “hyper-threaded” systems
	allow several processes to run in parallel. The same
	time-slicing system is still used, though, so as to handle
	cases where there are more active processes than available
	processor cores. This is far from unusual: a basic system,
	even a mostly idle one, almost always has tens of running
	processes.</para>
      </sidebar>

      <para>Natürlich ermöglicht der Kernel es auch, mehrere unabhängige Instanzen desselben Programms auszuführen. Jedoch kann jede von ihnen nur auf ihre eigenen Zeitabschnitte und ihren eigenen Speicherplatz zugreifen. Ihre Daten bleiben daher voneinander unabhängig.</para>
    </section>
    <section id="sect.permissions">
      <title>Rechteverwaltung</title>

      <para>Unix-like systems are also multi-user. They provide a
      rights management system that supports separate users and groups;
      it also allows control over actions based on
      permissions. The kernel manages data for each process, allowing
      it to control permissions. Most of the time, a process is identified
      by the user who started it. That process is only permitted
      to take those actions available to its owner. For instance, trying
      to open a file requires the kernel
      to check the process identity against access permissions (for
      more details on this particular example, see <xref linkend="sect.rights-management" />).</para>
    </section>
  </section>
  <section id="sect.user-space">
    <title>Die Anwendungsebene</title>
    <indexterm><primary>Anwendungsebene</primary></indexterm>
    <indexterm><primary>Kernelebene</primary></indexterm>

    <para>“User space” refers to the runtime environment of normal (as
    opposed to kernel) processes. This does not necessarily mean these
    processes are actually started by users because a standard system
    normally has several “daemon” (or background) processes running before the user
    even opens a session. Daemon processes are also considered user-space processes.</para>
    <section id="sect.process-basics">
      <title>Prozess</title>
      <indexterm><primary><command>init</command></primary></indexterm>

      <para>When the kernel gets past its initialization phase, it starts
      the very first process, <command>init</command>. Process #1 alone is
      very rarely useful by itself, and Unix-like systems run with many
      additional processes.</para>
      <indexterm><primary><emphasis>Fork</emphasis></primary></indexterm>

      <para>First of all, a process can clone itself (this is known as a
      <emphasis>fork</emphasis>). The kernel allocates a new (but
      identical) process memory space, and another process to use it. At
      this time, the only difference between these two processes
      is their <emphasis>pid</emphasis>. The new process is usually
      called a child process, and the original process whose
      <emphasis>pid</emphasis> doesn't change, is called the parent
      process.</para>

      <para>Sometimes, the child process continues to lead its own
      life independently from its parent, with its own data copied
      from the parent process. In many cases, though, this child
      process executes another program. With a few exceptions, its
      memory is simply replaced by that of the new program, and
      execution of this new program begins. This is the mechanism
      used by the init process (with process number 1) to start
      additional services and execute the whole startup sequence.
      At some point, one process among <command>init</command>'s offspring
      starts a graphical interface for users to log in to (the actual
      sequence of events is described in more details in
      <xref linkend="sect.system-boot" />).</para>

      <para>Wenn ein Prozess die Aufgabe, für die er gestartet wurde, erfüllt hat, beendet er sich. Anschließend nimmt der Kernel den diesem Prozess zugewiesenen Speicher wieder zurück und hört auf, Teile der Prozessorzeit zuzuteilen. Der Elternprozess wird über die Beendigung seines Kindprozesses informiert. Auf diese Weise kann ein Prozess auf den Abschluss einer Aufgabe warten, die er an einen Kindprozess übertragen hat. Dieses Verhalten ist bei Kommandozeileninterpretern (auch als <emphasis>Shells</emphasis> bekannt) deutlich zu sehen. Wenn ein Befehl in eine Shell eingegeben wird, erscheint die Eingabeaufforderung erst dann wieder, wenn die Ausführung des Befehls beendet ist. Die meisten Shells ermöglichen eine Ausführung des Befehls im Hintergrund. Dazu wird einfach ein <userinput>&amp;</userinput> an das Ende des Befehls angehängt. Die Eingabeaufforderung wird dann sofort wieder angezeigt, was jedoch zu Problemen führen kann, wenn das abgesetzte Kommando seine eigenen Daten anzeigen muss.</para>
    </section>
    <section id="sect.daemons">
      <title>Hintergrundprozesse (Dämonprozesse)</title>
      <indexterm><primary>Daemon</primary></indexterm>
      <indexterm><primary>Daemon</primary></indexterm>

      <para>Ein „Daemon“ ist ein Prozess, der beim Hochfahren automatisch gestartet wird. Er läuft (im Hintergrund) weiter, um Verwaltungsaufgaben zu erledigen oder Dienste für andere Prozesse bereitzustellen. Diese „Hintergrundaufgabe“ ist genau genommen willkürlich und entspricht aus Sicht des Systems nichts Bestimmtem. Es sind, wie andere Prozesse auch, einfach Prozesse, die reihum laufen, wann immer ihr zugeteilter Zeitabschnitt kommt. Eine Unterscheidung gibt es nur in der menschlichen Sprache: ein Prozess, der ohne eine Interaktion mit einem Benutzer läuft (insbesondere ohne eine grafische Schnittstelle), wird als „im Hintergrund“ laufend oder als „Daemon“ bezeichnet.</para>

      <sidebar>
        <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Daemon, Dämon, eine abwertende Bezeichnung?</title>

	<para>Although <emphasis>daemon</emphasis> term shares its
	Greek etymology with <emphasis>demon</emphasis>, the former
	does not imply diabolical evil, instead, it should be
	understood as a kind of helper spirit. This distinction is
	subtle enough in English; it is even worse in other languages
	where the same word is used for both meanings.</para>
      </sidebar>

      <para>Mehrere solcher Daemons sind ausführlich in <xref linkend="unix-services" /> beschrieben.</para>
    </section>
    <section id="sect.ipc">
      <title>Interprozesskommunikationen</title>
      <indexterm><primary>IPC</primary></indexterm>
      <indexterm><primary>Interprozesskommunikationen</primary></indexterm>

      <para>Ein einzelner Prozess, ob ein Daemon oder eine interaktive Anwendung, ist selten für sich genommen nützlich. Daher gibt es verschiedene Methoden, um getrennten Prozessen die Kommunikation miteinander zu ermöglichen, entweder um Daten auszutauschen oder um sich gegenseitig zu steuern. Die allgemeine Bezeichnung hierfür lautet <emphasis>Interprozesskommunikation</emphasis> oder abgekürzt IPC.</para>

      <para>Das einfachste IPC-System besteht darin, Dateien zu verwenden. Der Prozess, der Daten übersenden möchte, schreibt sie in eine Datei (mit einem zuvor bekannten Namen), während der Empfänger nur die Datei zu öffnen und den Inhalt zu lesen braucht.</para>
      <indexterm><primary><emphasis>Pipe</emphasis></primary></indexterm>

      <para>In the case where you do not wish to store data on disk, you
      can use a <emphasis>pipe</emphasis>, which is simply an object with
      two ends; bytes written in one end are readable at the other. If the
      ends are controlled by separate processes, this leads to a simple and
      convenient inter-process communication channel. Pipes can be
      classified into two categories: named pipes, and anonymous pipes. A
      named pipe is represented by an entry on the filesystem (although the
      transmitted data is not stored there), so both processes can open it
      independently if the location of the named pipe is known beforehand.
      In cases where the communicating processes are related (for instance,
      a parent and its child process), the parent process can also create
      an anonymous pipe before forking, and the child inherits it. Both
      processes will then be able to exchange data through the pipe without
      needing the filesystem.</para>

      <sidebar>
        <title><emphasis>IN DER PRAXIS</emphasis> Ein konkretes Beispiel</title>

	<para>Lassen Sie uns beschreiben, was geschieht, wenn ein komplexer Befehl (eine <emphasis>Pipeline</emphasis>) von einer Konsole aus ausgeführt wird. Wir nehmen an, dass wir einen <command>bash</command>-Prozess haben (die standardmäßige Benutzerkonsole bei Debian) mit der <emphasis>PID</emphasis> 4374; in diese Konsole schreiben wir den Befehl: <command>ls | sort</command>.</para>

	<para>Die Konsole interpretiert zunächst den eingegebenen Befehl. In unserem Fall versteht sie, dass es zwei Programme gibt (<command>ls</command> und <command>sort</command>) mit einem Datenstrom, der vom einen zum anderen fließt (gekennzeichnet durch das <userinput>|</userinput>-Zeichen, das als <emphasis>Pipe</emphasis> bezeichnet wird). <command>bash</command> erstellt zunächst eine anonyme Pipe (die anfangs nur innerhalb des <command>bash</command>-Prozesses selbst besteht).</para>

	<para>Dann vervielfältigt sich die Konsole; dies führt zu einem neuen <command>bash</command>-Prozess mit der <emphasis>PID</emphasis> 4521 (<emphasis>PIDs</emphasis> sind abstrakte Zahlen und haben im Allgemeinen keine besondere Bedeutung). Prozess 4521 übernimmt die Pipe, was bedeutet, das er auf ihrer „Eingabe“-Seite schreiben kann; <command>bash</command> leitet seinen Standardausgabestrom auf die Eingabe dieser Pipe um. Dann führt es das Programm <command>ls</command> aus, das den Inhalt des aktuellen Verzeichnisses auflistet (und ersetzt sich selbst durch dieses Programm). Da <command>ls</command> auf seine Standardausgabe schreibt und diese Ausgabe zuvor umgeleitet wurde, werden die Ergebnisse im Endeffekt in die Pipe geschickt.</para>

	<para>Ein ähnlicher Vorgang findet beim zweiten Befehl statt: <command>bash</command> vervielfältigt sich wieder, was zu einem neuen <command>bash</command>-Prozess mit der PID 4522 führt. Da er ebenfalls ein Kindprozess von 4374 ist, übernimmt er auch die Pipe; <command>bash</command> verbindet dann seine Standardeingabe mit der Pipeausgabe und führt danach den Befehl <command>sort</command> aus, der seine Eingabe sortiert und die Ergebnisse anzeigt (und ersetzt sich selbst durch diesen Befehl).</para>

	<para>Alle Teile des Puzzles stehen nun bereit: <command>ls</command> liest das aktuelle Verzeichnis ein und schreibt die Liste der Dateien in die Pipe; <command>sort</command> liest diese Liste, sortiert sie alphabetisch und zeigt die Ergebnisse an. Die Prozesse 4521 und 4522 enden dann, und 4374 (der während des Vorgangs auf sie gewartet hatte) übernimmt wieder die Kontrolle und zeigt die Eingabeaufforderung an, die es dem Benutzer ermöglicht, einen neuen Befehl einzugeben.</para>
      </sidebar>

      <para>Not all inter-process communications are used to move data
      around, though. In many situations, the only information that needs to
      be transmitted are control messages such as “pause execution” or
      “resume execution”. Unix (and Linux) provides a mechanism known
      as <emphasis>signals</emphasis>, through which a process can simply
      send a specific signal (chosen from a predefined list of
      signals) to another process. The only requirement is to know the
      <emphasis>pid</emphasis> of the target.</para>

      <para>For more complex communications, there are also mechanisms
      allowing a process to open access, or share, part of its
      allocated memory to other processes. Memory now shared between them
      can be used to move data between the processes.</para>

      <para>Schließlich können auch Netzwerkverbindungen Prozessen helfen, miteinander zu kommunizieren; diese Prozesse können sogar auf verschiedenen Rechnern laufen, möglicherweise tausende von Kilometern voneinander entfernt.</para>

      <para>Es ist für ein typisches Unix-artiges System recht normal, all diese Mechanismen in wechselndem Umfang zu verwenden.</para>
    </section>
    <section id="sect.libraries">
      <title>Bibliotheken</title>
      <indexterm><primary>Bibliothek (von Funktionen)</primary></indexterm>

      <para>Programmbibliotheken spielen in einem Unix-artigen Betriebssystem eine entscheidende Rolle. Sie sind nicht wirklich Programme, da sie für sich allein nicht ausgeführt werden können, sondern Ansammlungen von Code-Fragmenten, die von Standardprogrammen verwendet werden können. Unter den gängigen Bibliotheken sind vor allem folgende erwähnenswert:</para>
      <itemizedlist>
        <listitem>
	  <para>die Standard-C-Bibliothek (<emphasis>glibc</emphasis>), die grundlegende Funktionen enthält wie das Öffnen von Dateien und von Netzwerkverbindungen und andere unterstützende Interaktionen mit dem Kernel;</para>
        </listitem>
        <listitem>
	  <para>grafische Werkzeugsätze, wie zum Beispiel Gtk+ und Qt, die es vielen Programmen ermöglichen, die grafischen Objekte, die sie bereitstellen, ihrerseits zu verwenden;</para>
        </listitem>
        <listitem>
	  <para>die <emphasis>libpng</emphasis>-Bibliothek, die das Laden, Interpretieren und Speichern von Bildern im PNG-Format ermöglicht.</para>
        </listitem>
      </itemizedlist>

      <para>Thanks to those libraries, applications can reuse existing
      code. Application development is simplified since
      many applications can reuse the same functions. With
      libraries often developed by different persons, the global
      development of the system is closer to Unix's historical
      philosophy.</para>

      <sidebar>
        <title><emphasis>KULTUR</emphasis> Der Unix-Methode: Eins nach dem Anderen</title>

	<para>One of the fundamental concepts that underlies the Unix
	family of operating systems is that each tool should only do one
	thing, and do it well; applications can then reuse these tools to
	build more advanced logic on top. This philosophy can be seen in many
	incarnations. Shell scripts may be the best example: they assemble
	complex sequences of very simple tools (such as
	<command>grep</command>, <command>wc</command>,
	<command>sort</command>, <command>uniq</command> and so on).
	Another implementation of this philosophy can be seen in code
	libraries: the <emphasis>libpng</emphasis> library allows reading
	and writing PNG images, with different options and in different
	ways, but it does only that; no question of including functions
	that display or edit images.</para>
      </sidebar>

      <para>Ferner werden diese Bibliotheken häufig als „gemeinsam benutzte Bibliotheken“ bezeichnet, da der Kernel sie nur einmal in den Speicher laden kann, selbst wenn gleichzeitig mehrere Prozesse dieselbe Bibliothek nutzen. Hierdurch kann im Vergleich zur entgegengesetzten (hypothetischen) Situation, bei der der Bibliothekscode so viele Male geladen würde, wie es Prozesse gibt, die ihn benutzen, Speicherplatz gespart werden.</para>
    </section>
  </section>
</appendix>
