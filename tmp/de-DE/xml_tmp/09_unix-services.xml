<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="unix-services">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-unix-services.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Systemstart</keyword>
      <keyword>Initialisierungsskripten</keyword>
      <keyword>SSH</keyword>
      <keyword>Telnet</keyword>
      <keyword>Rechte</keyword>
      <keyword>Berechtigungen</keyword>
      <keyword>Überwachung</keyword>
      <keyword>Inetd</keyword>
      <keyword>Cron</keyword>
      <keyword>Datensicherung</keyword>
      <keyword>Wechsel im laufenden Betrieb</keyword>
      <keyword>PCMCIA</keyword>
      <keyword>APM</keyword>
      <keyword>ACPI</keyword>
    </keywordset>
  </chapterinfo>
  <title>Unix-Dienste</title>
  <highlights>
    <para>Dieses Kapitel behandelt eine Reihe grundlegender Dienste, die vielen Unix-Systemen gemein sind. Alle Administratoren sollten mit ihnen vertraut sein.</para>
  </highlights>
  <section id="sect.system-boot">
    <title>Systemstart</title>
    <indexterm><primary>hochfahren</primary><secondary>das System</secondary></indexterm>

    <para>Beim Hochfahren des Rechners zeigen die zahlreichen Meldungen, die auf der Konsole vorüberrollen, viele selbsttätig ausgeführte Initialisierungen und Konfigurationen an. Manchmal möchten Sie vielleicht den Ablauf dieser Phase etwas verändern, weshalb Sie sie gut verstehen müssen. Das ist der Zweck dieses Abschnitts.</para>

    
    <para>Zunächst übernimmt das BIOS die Kontrolle über den Rechner, erkennt die Festplatten, lädt den <emphasis>Master Boot Record</emphasis> und führt den Boot-Loader aus. Der Boot-Loader übernimmt, ermittelt den Kernel auf der Festplatte, lädt ihn und führt ihn aus. Der Kernel wird dann initialisiert und beginnt damit, nach der Partition, die das Wurzel-Dateisystem enthält, zu suchen und sie einzuhängen, und führt schließlich das erste Programm aus – <command>init</command>. In vielen Fällen befinden sich diese „Wurzel-Partition“ und der <command>init</command>-Befehl jedoch in einem virtuellen Dateisystem, das nur im Arbeitsspeicher existiert (daher sein Name „initramfs“, früher „initrd“ genannt für „initialization RAM disk“). Dieses Dateisystem wird vom Boot-Loader in den Speicher geladen, häufig aus einer Datei auf einer Festplatte oder aus dem Netzwerk. Es enthält das absolute Minimum dessen, was vom Kernel benötigt wird, um das „wirkliche“ Wurzel-Dateisystem zu laden: dies können Treiber-Module für die Festplatte oder andere Geräte sein, ohne die das System nicht hochfahren kann, oder häufiger Initialisierungsskripten und -module zum Aufbau von RAID-Arrays, zum Öffnen verschlüsselter Partitionen, zur Aktivierung von LVM-Volumes usw. Sobald die Wurzel-Partition eingehängt ist, übergibt initramfs die Kontrolle an das wirkliche init, und der Rechner kehrt zum Standard-Startprozess zurück.</para>

    <figure id="figure.boot-process-systemd">
      <title>Boot-Sequenz eines Rechners, auf dem Linux mit systemd läuft</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/startup-systemd.png" scalefit="1" width="80%" />
        </imageobject>
      </mediaobject>
    </figure>

    <section id="sect.systemd"><title>Das systemd Initialisierungssystem</title>

    <para>Das "tatsächliche init" wird zur Zeit von <emphasis role="pkg">systemd</emphasis> bereitgestellt und dieser Abschnitt beschreibt das Init-System.</para>

    <sidebar>
      <title><emphasis>KULTUR</emphasis> Weitere <command>inetd</command> Befehle</title>

      <para><command>systemd</command> ist ein relativ neues "init-System", und obwohl es bis zu einem gewissen Grad bereits in <emphasis role="distribution">Wheezy</emphasis> verfügbar war, ist es nur der Standard in Debian <emphasis role="distribution">Jessie</emphasis> geworden. Frühere Versionen basierten standardmäßig auf dem "System V init" (im Paket <emphasis role="pkg">sysv-rc</emphasis>), einem viel traditionelleren System. Wir beschreiben das System V init später.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIV</emphasis> Andere Bootsysteme</title>

      <para>Dieses Buch beschreibt das von Debian <emphasis role="distribution">Jessie</emphasis>standardmäßig verwendete Bootsystem (wie es vom Paket <emphasis role="pkg">systemd</emphasis> umgesetzt wird) sowie die bisherige Voreinstellung <emphasis role="pkg">sysvinit</emphasis>, das vom Unix-System <emphasis>System V</emphasis> abgeleitet und übernommen ist; es gibt jedoch auch andere.</para>

      <para><emphasis role="pkg">file-rc</emphasis> ist ein Bootsystem mit einem sehr einfachen Ablauf. Es behält das Prinzip der Runlevel bei, ersetzt jedoch  die Verzeichnisse und symbolischen Verknüpfungen durch eine Konfigurationsdatei, die für <command>init</command> die zu startenden Prozesse und ihre Startreihenfolge angibt.</para>

      <para>Der Befehl <command>upstart</command> ist auf Debian immer noch nicht vollständig ausgetestet. Es arbeitet ereignisbasiert: Initialisierungsskripten werden nicht mehr der Reihe nach ausgeführt, sondern als Reaktion auf Ereignisse, wie zum Beispiel die Ausführung eines anderen Skripts, von dem sie abhängen. Dieses von Ubuntu eingeführte System ist in Debian <emphasis role="distribution">Jessie</emphasis> vorhanden, aber nicht als Standard eingestellt. Es ist ein Nachfolger für <emphasis role="pkg">sysvinit</emphasis>, und eine der von <command>upstart</command> ausgeführten Aufgaben besteht darin, die für traditionelle Systeme geschriebenen Skripten zu starten, insbesondere die aus dem Paket <emphasis role="pkg">sysv-rc</emphasis>.</para>

      <para>Es gibt weitere Systeme und Betriebsarten wie zum Beispiel <command>runit</command> oder <command>minit</command>, die jedoch recht spezialisiert und nicht weit verbreitet sind.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>SONDERFALL</emphasis> Aus dem Netzwerk hochfahren</title>

      <para>Bei einigen Konfigurationen kann das BIOS so eingestellt sein, dass es nicht den MBR ausführt, sondern seine Entsprechung im Netzwerk sucht, wodurch es möglich wird, Rechner ohne Festplatte zu bauen oder solche, die bei jedem Neustart vollständig neu installiert werden. Diese Option steht aber nicht auf jeder Hardware zur Verfügung und erfordert im Allgemeinen eine passende Kombination aus BIOS und Netzwerkkarte.</para>

      <para>Das Hochfahren aus dem Netzwerk kann dazu verwendet werden, den  <command>Debian-Installer</command> oder FAI zu starten (siehe <xref linkend="sect.installation-methods" />).</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Der Prozess, eine Programminstanz</title>
      <indexterm><primary>Prozess</primary></indexterm>

      <para>Ein Prozess ist die Darstellung eines laufenden Programms im Speicher. Er umfasst alle Informationen, die für die ordnungsgemäße Ausführung der Software erforderlich sind (den Code selbst, aber auch die Daten, die er im Speicher hält, die Liste der Dateien, die er geöffnet hat, die Netzwerkverbindungen, die er eingerichtet hat, usw.). Ein einzelnes Programm kann in mehreren Prozessen instanziiert sein, die nicht notwendigerweise unter verschiedenen Benutzerkennungen laufen.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>SICHERHEIT</emphasis> Eine Shell als <command>init</command> verwenden, um Administratorrechte zu erlangen</title>

      <para>Vereinbarungsgemäß ist der erste Prozess, der gestartet wird, das Programm <command>init</command> (das ein symbolischer Link zu <filename>/lib/systemd/systemd</filename> ist). Man kann dem Kernel jedoch eine <literal>init</literal>-Option übergeben, die ein anderes Programm angibt.</para>
      <indexterm><primary><command>init</command></primary></indexterm>

      <para>Jeder mit Zugang zum Rechner kann die <keycap>Reset</keycap>-Taste drücken und ihn so neu starten. Dann ist es an der Eingabeaufforderung des Boot-Loaders möglich, dem Kernel die Option <literal>init=/bin/sh</literal> zu übergeben und so ohne Kenntnis des Administrator-Passworts Root-Rechte zu erlangen.</para>

      <para>Um dieses zu verhindern, kann man den Boot-Loader selbst mit einem Passwort absichern. Man könnte auch den Zugang zum BIOS schützen (ein Passwort-Schutzmechanismus ist fast immer verfügbar), ohne den ein böswilliger Eindringling jedoch den Rechner immer noch mit einem Wechseldatenträger, der sein eigenes Linux-System enthält, hochfahren könnte und das er dann dazu benutzen könnte, um auf Daten auf den Festplatten des Rechners zuzugreifen.</para>

      <para>Schließlich sollten Sie beachten, dass die meisten BIOS ein voreingestelltes Passwort haben. Ursprünglich dazu gedacht, denen zu helfen, die ihr Passwort vergessen haben, sind diese Passwörter inzwischen öffentlich bekannt und im Internet verfügbar (sehen Sie selbst, indem sie in einer Suchmaschine „Standard-Passwörter“ eingeben). Alle diese Sicherheitsmaßnahmen können daher zwar den unbefugten Zugriff auf den Rechner erschweren, ihn aber nicht vollständig verhindern. Es gibt keinen zuverlässigen Weg, einen Computer zu schützen, falls der Angreifer physisch auf ihn zugreifen kann; er könnte die Festplatten ausbauen, um sie an einen Rechner unter seiner Kontrolle anzuschließen oder das ganze Gerät stehlen oder den BIOS-Speicher löschen, um so das Passwort zurückzusetzen…</para>
    </sidebar>


<para>Systemd führt mehrere Prozesse aus, die für die Einrichtung des Systems verantwortlich sind: Tastatur, Treiber, Dateisysteme, Netzwerk, Dienste. Dabei behält er den Überblick über das Gesamtsystem und die Anforderungen der Komponenten. Jede Komponente wird durch eine "Unit-Datei" (manchmal auch mehrere) beschrieben; die allgemeine Syntax ergibt sich aus der weit verbreiteten "*.ini Dateien" Syntax, mit <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> Paare gruppiert zwischen <literal>[<replaceable>section</replaceable>]</literal> headers. Unit-Dateien werden unter <filename>/lib/system/system/</filename> und <filename>/etc/systemd/system/</filename> gespeichert; es gibt sie in verschiedenen Varianten, aber wir werden uns hier auf "services" und "targets" konzentrieren.</para>

<para>Eine systemd "Servicedatei" beschreibt einen von systemd verwalteten Prozess. Es enthält ungefähr die gleichen Informationen wie die alten Initskripte, jedoch in einer deklaratorischen (und viel prägnanteren) Form. Systemd übernimmt den Großteil der sich wiederholenden Aufgaben (Starten und Stoppen des Prozesses, Prüfen seines Status, Protokollieren, Löschen von Berechtigungen, usw.) und die Servicedatei muss nur die Besonderheiten des Prozesses ausfüllen. Hier ist zum Beispiel die Servicedatei für SSH:</para>

<programlisting>[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</programlisting>

<para>Wie Sie sehen können, gibt es dort sehr wenig Code, nur Deklarationen. Systemd kümmert sich um die Anzeige von Fortschrittsberichten, verfolgt die Prozesse und startet sie bei Bedarf sogar neu.</para>

<para>Eine systemd "Target-Datei" beschreibt einen Zustand des Systems, in dem ein Satz von Diensten als funktionsfähig bekannt ist. Es kann als Äquivalent zum alten Runlevel angesehen werden. Eines der Targets ist <literal>local-fs.target</literal>; wenn es erreicht ist, kann der Rest des Systems davon ausgehen, dass alle lokalen Dateisysteme eingebunden und zugänglich sind. Andere Targets sind <literal>network-online.target</literal> und <literal>sound.target</literal>. Die Abhängigkeiten eines Ziels können entweder innerhalb der Zieldatei (in der Zeile <literal>Requires=</literal>) oder über einen symbolischen Link auf eine Servicedatei im Verzeichnis <literal>/lib/systemd/system/<replaceable>Targetname</replaceable>.target.wants/</literal> aufgelistet werden. Zum Beispiel enthält <filename>/etc/systemd/system/printer.target.wants/</filename> einen Link zu <filename>/lib/systemd/system/cups.service</filename>; systemd wird daher sicherstellen, dass CUPS läuft, um <literal>printer.target</literal> zu erreichen.</para>

<para>Da Unit-Dateien, anders als als Skripte oder Programme, eher deklarativ sind, können sie nicht direkt ausgeführt werden und werden von systemd nur interpretiert. Mehrere Dienstprogramme erlauben es dem Administrator daher, mit systemd zu interagieren und den Zustand des Systems und jeder Komponente zu kontrollieren.</para>

<para>Das erste derartige Dienstprogramm ist <command>systemctl</command>. Wenn es ohne Argumente ausgeführt wird, listet es alle dem System bekannten Unit-Dateien (mit Ausnahme derjenigen, die deaktiviert wurden) sowie deren Status auf. <command>systemctl status</command> gibt einen besseren Überblick über die Dienste und die damit verbundenen Prozesse. Wenn der Name eines Dienstes angegeben wird (wie in <command>systemctl status ntp.service</command>), gibt er noch mehr Details zurück, sowie die letzten Log-Zeilen, die sich auf den Dienst beziehen (mehr dazu später).</para>

<para>Das Starten eines Dienstes von Hand ist einfach das Starten von <command>systemctl start <replaceable>servicename</replaceable>.service</command>. Wie man leicht erraten kann, wird der Dienst mit <command>systemctl stop <replaceable>servicename</replaceable>.service</command> beendet; andere Unterbefehle beinhalten <command>reload</command> und <command>restart</command>.</para>

<para>Um zu steuern, ob ein Dienst aktiv ist (d.h. ob er beim Booten automatisch gestartet wird), verwenden Sie <command>systemctl enable <replaceable>servicename</replaceable>.service</command> (oder <command>disable</command>). <command>is-enabled</command> ermöglicht die Überprüfung des Status des Dienstes.</para>

<para>Eine interessante Eigenschaft von systemd ist, dass es eine Protokollierungskomponente namens <command>journald</command> enthält. Es ist eine Ergänzung zu herkömmlichen Protokollierungssystemen wie <command>syslogd</command>, aber es fügt interessante Funktionen hinzu, wie eine formale Verbindung zwischen einem Dienst und den von ihm erzeugten Nachrichten und die Fähigkeit, Fehlermeldungen zu erfassen, die durch seine Initialisierungssequenz erzeugt werden. Die Meldungen können später mit Hilfe des Befehls <command>journalctl</command> angezeigt werden. Ohne Argumente spuckt es einfach alle Logmeldungen aus, die seit dem Systemstart aufgetreten sind; es wird selten so verwendet. Meistens wird es mit einer Service-Kennung verwendet:</para>

<screen><computeroutput># </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</computeroutput></screen>

<para>Ein weiterer nützlicher Kommandozeilenparameter ist <command>-f</command>, der <command>journalctl</command> anweist, neue Nachrichten so anzuzeigen, wie sie ausgegeben werden (ziemlich so wie <command>tail -f <replaceable>file</replaceable></command>).</para>

<para>Wenn ein Dienst nicht wie erwartet funktioniert, ist der erste Schritt zur Lösung des Problems die Überprüfung, ob der Dienst tatsächlich läuft: <command>systemctl status</command>. Wenn dies nicht der Fall ist und die Meldungen des ersten Befehls nicht ausreichen, um das Problem zu diagnostizieren, überprüfen Sie die von journald über diesen Dienst gesammelten Protokolle. Angenommen, der SSH-Server funktioniert nicht:</para>

<screen><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>vi /etc/ssh/sshd_config
</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service
</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </computeroutput></screen>

<para>Nachdem wir den Status des Dienstes überprüft haben (failed), haben wir die Protokolle überprüft; sie zeigen einen Fehler in der Konfigurationsdatei an. Nachdem wir die Konfigurationsdatei bearbeitet und den Fehler behoben haben, starten wir den Dienst neu und überprüfen, ob er tatsächlich läuft.</para>

<sidebar><title><emphasis>WEITERE SCHRITTE</emphasis> Andere Arten von Unit-Dateien</title>

<para>Wir haben in diesem Abschnitt nur die grundlegendsten Fähigkeiten von systemd beschrieben. Es bietet viele weitere interessante Funktionen; wir werden hier nur einige aufzählen:</para>

<itemizedlist>

<listitem><para>Socket-Aktivierung: eine "Socket"-Unitdatei kann verwendet werden, um einen von systemd verwalteten Netzwerk-Socket oder Unix-Socket zu beschreiben; dies bedeutet, dass der Socket von systemd erstellt wird und der eigentliche Dienst bei Bedarf gestartet werden kann, wenn ein tatsächlicher Verbindungsversuch erfolgt. Dies bildet grob den Funktionsumfang von <command>inetd</command> nach. Siehe <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para></listitem>

<listitem><para>Timer: Eine "Timer"-Unitdatei beschreibt Ereignisse, die mit einer festen Frequenz oder zu bestimmten Zeiten auftreten; wenn ein Dienst mit einem solchen Timer verknüpft ist, wird die entsprechende Aufgabe ausgeführt, sobald der Timer ausgelöst wird. Dies erlaubt das Nachbilden eines Teils der Fähigkeiten von <command>cron</command>. Siehe <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry>.</para></listitem>

<listitem><para>network: Eine "network"-Unitdatei beschreibt eine Netzwerkschnittstelle, die es erlaubt, solche Schnittstellen zu konfigurieren und auszudrücken, dass ein Dienst von einer bestimmten Schnittstelle abhängt.</para></listitem>

</itemizedlist>
</sidebar>

</section>

<section id="sect.sysvinit"><title>Das System V Initialisierungssystem</title>
    <para>Das System V init System (das wir init für Kürze nennen werden) führt mehrere Prozesse aus, indem es Anweisungen aus der Datei <filename>/etc/inittab</filename> befolgt. Das erste Programm, das ausgeführt wird (was dem Schritt <emphasis>sysinit</emphasis> entspricht), ist <command>/etc/init.d/rcS</command>, ein Skript, das alle Programme im Verzeichnis <filename>/etc/rcS.d/</filename> ausführt. <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm> <indexterm><primary><filename>rcS</filename></primary></indexterm> <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm> <indexterm><primary><filename>rcS.d</filename></primary></indexterm></para>

    <para>Unter diesen befinden sich nacheinander Programme, die zuständig sind für:</para>
    <itemizedlist>
      <listitem>
	<para>das Konfigurieren der Konsolentastatur;</para>
      </listitem>
      <listitem>
	<para>das Laden von Treibern: die meisten Kernelmodule werden beim Erkennen der Hardware vom Kernel selbst geladen; zusätzliche Treiber werden selbsttätig geladen, wenn die entsprechenden Module in der Datei <filename>/etc/modules</filename> aufgeführt sind;</para>
      </listitem>
      <listitem>
	<para>die Integritätsprüfung von Dateisystemen;</para>
      </listitem>
      <listitem>
	<para>das Einhängen lokaler Partitionen;</para>
      </listitem>
      <listitem>
	<para>das Konfigurieren des Netzwerks;</para>
      </listitem>
      <listitem>
	<para>das Einhängen von Netzwerkdateisystemen (NFS).</para>
      </listitem>
    </itemizedlist>

    <sidebar>
      <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Kernelmodule und -optionen</title>
      <indexterm><primary>Module</primary><secondary>Kernelmodule</secondary></indexterm>

      <para>Kernelmodule verfügen ebenfalls über Optionen, die konfiguriert werden können, indem man Dateien im Verzeichnis <filename>/etc/modprobe.d/</filename> erstellt. Diese Optionen werden durch Anweisungen wie die folgende festgelegt:  <literal>options <replaceable>modulname</replaceable> <replaceable>optionsname</replaceable>=<replaceable>optionswert</replaceable></literal>. Falls erforderlich, können mehrere Optionen in einer einzelnen Anweisung gesetzt werden.</para>

      <para>Die Konfigurationsdateien sind für das Programm <command>modprobe</command> bestimmt, das ein Kernelmodul mit seinen Abhängigkeiten lädt (Module können auch andere Module aufrufen). Dieses Programm wird durch das Paket <emphasis role="pkg">kmod</emphasis> bereitgestellt.</para>
      <indexterm><primary><command>modprobe</command></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">kmod</emphasis></primary></indexterm>
    </sidebar>

    <para>Nach dieser Phase übernimmt <command>init</command> und startet die im Standard-Runlevel (der normalerweise Runlevel 2 ist) aktivierten Programme. Es führt <command>/etc/init.d/rc 2</command> aus, ein Skript, das alle Dienste startet, die in <filename>/etc/rc2.d/</filename> aufgeführt sind und mit dem Buchstaben „S“ beginnen. Die anschließenden zweistelligen Zahlen wurden früher dazu benutzt, die Reihenfolge festzulegen, in der die Dienste gestartet werden mussten, aber heute verwendet das Standard-Bootsystem <command>insserv</command>, das ausgehend von den Abhängigkeiten der Skripten alles selbsttätig zeitlich festlegt. Jedes Boot-Skript legt die Bedingungen fest, die gelten müssen, damit ein Dienst gestartet oder beendet wird (ob er zum Beispiel vor oder nach einem anderen Dienst gestartet werden muss); <command>init</command> startet sie dann in der Reihenfolge, die diese Bedingungen erfüllt. Die feststehende Nummerierung der Skripten wird daher nicht mehr berücksichtigt (sie müssen trotzdem weiterhin einen Namen haben, der mit „S“ beginnt gefolgt von zwei Zahlen und dem Namen des Skripts, das für die Abhängigkeiten verwendet wird). Im Allgemeinen werden grundlegende Dienste (wie das Protokollieren mit <command>rsyslog</command> oder die Portzuweisung mit <command>portmap</command>) als erste gestartet, gefolgt von Standarddiensten und der grafischen Schnittstelle (<command>gdm3</command>).</para>

    <para>Dieses Bootsystem auf der Grundlage von Abhängigkeiten ermöglicht es, die Neu-Nummerierung zu automatisieren, die recht mühsam wäre, wenn sie von Hand erledigt werden müsste, und es begrenzt das Risiko menschlichen Versagens, da die Festlegung der zeitlichen Abfolge in Übereinstimmung mit den angegebenen Parametern erfolgt. Ein weiterer Vorteil besteht darin, dass voneinander unabhängige Dienste zeitgleich gestartet werden können, was den Prozess des Hochfahrens beschleunigt.</para>

    <indexterm><primary>Runlevel</primary></indexterm>
    <indexterm><primary>Level, Runlevel</primary></indexterm>

    <para><command>init</command> unterscheidet zwischen verschiedenen Runleveln, so dass es mit dem Befehl <command>telinit <replaceable>neuer-level</replaceable></command> von einem zum anderen umschalten kann. <command>init</command> führt bei einem neuen Runlevel unmittelbar ein weiteres Mal <command>/etc/init.d/rc</command> aus. Dieses Skript startet dann die fehlenden Dienste und beendet die nicht mehr benötigten. Hierzu bezieht es sich auf den Inhalt der Datei <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (wobei <replaceable>X</replaceable> den neuen Runlevel bezeichnet). Skripten, deren Namen mit „S“ beginnen (wie in „Start“), verweisen auf zu startende Dienste, solche mit „K“ (wie in „Kill“) auf zu beendende. Das Skript startet keine Dienste, die im vorherigen Runlevel bereits aktiv waren.</para>

    <para>Standardmäßig verwendet System V init in Debian vier verschiedene Runlevel:</para>
    <itemizedlist>
      <listitem>
	<para>Level 0 wird nur vorübergehend beim Herunterfahren des Rechners benutzt. Daher enthält er nur zahlreiche „K“-Skripten.</para>
      </listitem>
      <listitem>
	<para>Level 1, auch Single-User Modus genannt, entspricht dem System in rudimentärem Zustand. Er umfasst einzig grundlegende Dienste und ist hauptsächlich für die Systemwartung gedacht, bei dem Interaktionen mit normalen Benutzern nicht erwünscht sind.</para>
      </listitem>
      <listitem>
	<para>Level 2 ist der Level für den Normalbetrieb, der Netzwerkdienste, eine grafische Schnittstelle, Benutzeranmeldungen usw. umfasst.</para>
      </listitem>
      <listitem>
	<para>Level 6 gleicht Level 0, nur dass er während des Herunterfahrens vor einem Neustart verwendet wird.</para>
      </listitem>
    </itemizedlist>

    <para>Es gibt weitere Level, insbesondere 3 bis 5. Standardmäßig sind sie so konfiguriert, dass sie sich wie Level 2 verhalten. Jedoch kann der Administrator sie verändern (indem er in den entsprechenden Verzeichnissen unter <filename>/etc/rc<replaceable>X</replaceable>.d</filename> Skripten hinzufügt oder löscht), um sie so besonderen Bedürfnissen anzupassen.</para>

    <figure id="figure.boot-process-sysvinit">
      <title>Boot-Sequenz eines Rechners, auf dem Linux mit System V init läuft</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/startup-sysvinit.png" scalefit="1" width="80%" />
        </imageobject>
      </mediaobject>
    </figure>
    <indexterm><primary>Initialisierungsskript</primary></indexterm>

    <para>Alle in den verschiedenen Verzeichnissen unter <filename>/etc/rc<replaceable>X</replaceable>.d</filename> enthaltenen Skripten sind in Wirklichkeit symbolische Verknüpfungen - bei der Paketinstallation durch das Programm <command>update-rc.d</command> erstellt, die auf die eigentlichen, im Verzeichnis <filename>/etc/init.d/</filename> gespeicherten, Skripten verweisen. Der Administrator kann die in jedem Runlevel verfügbaren Dienste fein einstellen, indem er den Befehl <command>update-rc.d</command> mit angepassten Parametern erneut ausführt. Die Handbuchseite <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> erläutert die Syntax im Detail. Bitte beachten Sie, dass das Entfernen aller symbolischen Verknüpfungen (mit dem Parameter <literal>remove</literal>) kein gutes Verfahren zum Abschalten eines Dienstes ist. Stattdessen sollten Sie ihn einfach so konfigurieren, dass er in dem gewünschten Runlevel nicht startet (und dabei gleichzeitig die entsprechenden Aufrufe zu seinem Abschalten bewahren, für den Fall, dass er im vorhergehenden Runlevel läuft). Da <command>update-rc.d</command> eine etwas verschachtelte Schnittstelle hat, benutzen Sie vielleicht lieber <command>rcconf</command> (aus dem Paket <emphasis role="pkg">rcconf</emphasis>), das eine benutzerfreundlichere Schnittstelle hat.</para>
    <indexterm><primary><command>update-rc.d</command></primary></indexterm>

    <sidebar>
      <title><emphasis>DEBIAN-RICHTLINIEN</emphasis> Dienste neu starten</title>
      <indexterm><primary><command>invoke-rc.d</command></primary></indexterm>
      <indexterm><primary>Dienst</primary><secondary>neu starten</secondary></indexterm>
      <indexterm><primary>Dienste neu starten</primary></indexterm>

      <para>Die Betreuerskripten für Debian-Pakete starten manchmal bestimmte Dienste neu, um ihre Verfügbarkeit sicherzustellen, oder damit sie bestimmte Optionen berücksichtigen. Der Befehl zur Steuerung eines Dienstes - <command>service<replaceable>dienst</replaceable> <replaceable>vorgang</replaceable></command> - berücksichtigt Runlevel nicht, geht (fälschlicherweise) davon aus, dass der Dienst gerade benutzt wird und kann daher falsche Vorgänge auslösen (einen Dienst starten, der bewusst abgeschaltet worden war, einen Dienst anhalten, der bereits angehalten ist usw.). Deshalb hat Debian das Programm <command>invoke-rc.d</command> eingeführt: dieses Programm muss von Betreuerskripten verwendet werden, um Initialisierungsskripten für Dienste aufzurufen und führt nur die erforderlichen Befehle aus. Man beachte, dass das Suffix <filename>.d</filename> hier, im Gegensatz zu seiner sonst üblichen Verwendung, in einem Programmnamen und nicht in einem Verzeichnis benutzt wird.</para>
    </sidebar>

    <para>Schließlich startet <command>init</command> Steuerprogramme für mehrere virtuelle Konsolen (<command>getty</command>). Es zeigt eine Eingabeaufforderung an, an der es auf einen Benutzernamen wartet, und führt dann <command>login <replaceable>benutzer</replaceable></command> aus, um eine Sitzung zu starten.</para>
    <indexterm><primary><command>getty</command></primary></indexterm>

    <sidebar>
      <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Konsole und Terminal</title>

      <para>Die ersten Computer waren gewöhnlich in mehrere, sehr große Teile unterteilt: das Speichergehäuse und die zentrale Verarbeitungseinheit waren von den Peripheriegeräten getrennt, die von den Bedienern zu ihrer Steuerung benutzt wurden. Letztere waren Teil einer separaten Einrichtung, der „Konsole“. Dieser Begriff wurde beibehalten, aber seine Bedeutung hat sich verändert. Er wurde mehr oder weniger zu einem Synonym für „Terminal“, das aus einer Tastatur und einem Bildschirm besteht.</para>

      <para>Im Laufe der Entwicklung der Computer haben Betriebssysteme schließlich mehrere virtuelle Konsolen angeboten, um gleichzeitig mehrere unabhängige Sitzungen zu ermöglichen, selbst wenn es nur eine Tastatur und einen Bildschirm gibt. Die meisten GNU/Linux-Systeme bieten sechs virtuelle Konsolen (im Textmodus) an, die durch die Eingabe der Tastenkombinationen <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> bis <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo> zugänglich sind.</para>

      <para>Im weiteren Sinne können die Begriffe „Konsole“ und „Terminal“ sich auch auf einen Terminal-Emulator in einer grafischen X11-Sitzung beziehen (wie zum Beispiel <command>xterm</command>, <command>gnome-terminal</command> oder <command>konsole</command>).</para>
    </sidebar>
</section>
  </section>
  <section id="sect.remote-login">
    <title>Remoteanmeldung</title>

    <para>Es ist für einen Administrator wichtig, sich aus der Ferne mit einem Rechner verbinden zu können. Server, die in ihrem eigenen Raum eingeschlossen sind, sind selten dauerhaft mit Tastaturen und Bildschirmen ausgestattet - aber sie sind mit dem Netzwerk verbunden.</para>

    <sidebar>
      <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Client, Server</title>
      <indexterm><primary>Client</primary><secondary>Client/Server-Architektur</secondary></indexterm>
      <indexterm><primary>Server</primary><secondary>Client/Server-Architektur</secondary></indexterm>

      <para>Ein System, bei dem mehrere Prozesse miteinander kommunizieren. wird häufig mit dem bildlichen Ausdruck „Client-Server“ beschrieben. Der Server ist das Programm, das Anfragen vom Client entgegen nimmt und ausführt. Der Client steuert die Vorgänge, der Server tut nichts aus eigener Initiative.</para>
    </sidebar>

    <indexterm><primary>Anmelden</primary><secondary>Remoteanmeldung</secondary></indexterm>
    <indexterm><primary>Remoteanmelden</primary></indexterm>

    <section id="sect.ssh">
      <title>Sicheres Remoteanmelden: SSH</title>
      <indexterm><primary>SSH</primary></indexterm>
      <indexterm><primary>Secure Shell</primary></indexterm>

      <para>Beim <emphasis>SSH</emphasis>-Protokoll (Secure SHell) wurden Sicherheit und Zuverlässigkeit bereits im Entwurf berücksichtigt. Verbindungen auf der Basis von SSH sind sicher: der Partner ist authentifiziert und jeglicher Datenverkehr erfolgt verschlüsselt.</para>

      <sidebar>
        <title><emphasis>KULTUR</emphasis> Telnet und RSH sind veraltet</title>
	<indexterm><primary><command>telnet</command></primary></indexterm>
	<indexterm><primary><command>rsh</command></primary></indexterm>

	<para>Vor SSH waren <emphasis>Telnet</emphasis> und <emphasis>RSH</emphasis> die wesentlichen Werkzeuge um sich aus der Ferne anzumelden. Heute sind sie weitestgehend überflüssig und sollten nicht weiter benutzt werden, auch wenn Debian sie immer noch zur Verfügung stellt.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Authentifizierung, Verschlüsselung</title>

	<para>Wenn Sie einem Client die Fähigkeit geben müssen, auf einem Server Aktionen auszuführen oder auszulösen, ist Sicherheit wichtig. Sie müssen die Identität des Clients sicherstellen; dies nennt sich Authentifizierung. Die Identität besteht normalerweise aus einem Passwort, das geheimzuhalten ist, da es sonst von jedem anderen Client erlangt werden könnte. Dies ist der Zweck von Verschlüsselung, einer Art der Kodierung, die es zwei Systemen ermöglicht, vertrauliche Informationen über einen öffentlichen Kanal auszutauschen, ohne dabei für andere lesbar zu sein.</para>

	<para>Authentifizierung und Verschlüsselung werden häufig zusammen genannt, weil beide oft gleichzeitig benutzt werden, und weil sie gewöhnlich durch ähnliche mathematische Konzepte umgesetzt werden.</para>
      </sidebar>

      <para>SSH bietet auch zwei Dateiübertragungsdienste an. <command>scp</command> ist ein Befehlszeilenprogramm, das wie <command>cp</command> benutzt werden kann, nur dass jedem Pfad zu einem anderen Rechner der Name dieses Rechners gefolgt von einem Doppelpunkt vorangestellt wird.</para>

      <screen><computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput></screen>

      <para><command>sftp</command> ist ein interaktiver Befehl, ähnlich wie <command>ftp</command>. In einer einzigen Sitzung kann <command>sftp</command> mehrere Dateien übertragen, und es ist möglich, mit ihm Dateien auf einem entfernten Rechner zu bearbeiten (löschen, umbenennen, Berechtigungen ändern usw.).</para>
      <indexterm><primary><command>scp</command></primary></indexterm>
      <indexterm><primary><command>sftp</command></primary></indexterm>

      <para>Debian verwendet OpenSSH, eine freie Version von SSH, die vom <command>OpenBSD</command>-Projekt betreut wird (einem freien Betriebssystem, das auf dem BSD-Kernel aufbaut und seinen Schwerpunkt auf Sicherheit setzt) und ist ein Fork der ursprünglich vom finnischen Unternehmen SSH Communications Security Corp. entwickelten SSH-Software. Dieses Unternehmen entwickelte SSH ursprünglich als freie Software, entschied sich jedoch schließlich, seine Entwicklung unter einer proprietären Lizenz fortzusetzen. Das OpenBSD-Projekt schuf daraufhin OpenSSH, um eine freie Version von SSH zu bewahren.</para>
      <indexterm><primary>OpenSSH</primary></indexterm>

      <sidebar>
        <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> <foreignphrase>Fork</foreignphrase></title>
        <indexterm><primary>Fork</primary></indexterm>

	<para>Ein „Fork“ im Softwarebereich ist ein neues Vorhaben, das als Klon eines bestehenden Vorhabens beginnt und mit ihm konkurriert. Von da an entwickeln sich beide Programme, was neue Entwicklungen angeht, gewöhnlich schnell auseinander. Ein Fork ist häufig die Folge von Meinungsverschiedenheiten innerhalb des Entwicklungsteams.</para>

	<para>Die Option, ein Vorhaben zu forken, ist eine direkte Folge der Eigenart freier Software; ein Fork ist ein heilsamer Vorgang, wenn sie die Fortführung eines Vorhabens als freie Software ermöglicht (zum Beispiel im Falle von Lizenzänderungen). Dagegen ist ein Fork, der sich aus technischen oder persönlichen Meinungsverschiedenheiten ergibt, häufig eine Verschwendung menschlicher Ressourcen; eine andere Lösung wäre vorzuziehen. Auch der Zusammenschluss zweier Vorhaben, die früher durch einen Fork gegangen sind, ist nicht gänzlich unbekannt.</para>
      </sidebar>

      <para>OpenSSH ist in zwei Pakete aufgeteilt: der Client-Teil befindet sich im Paket <emphasis role="pkg">openssh-client</emphasis> und der Server-Teil im Paket <emphasis role="pkg">openssh-server</emphasis>. Das Metapaket <emphasis role="pkg">ssh</emphasis> ist von beiden Teilen abhängig und erleichtert die Installation beider (<command>apt install ssh</command>).</para>

      <section id="sect.ssh-key-based-auth">
        <title>Schlüsselbasierte Authentifizierung</title>

	<para>Jedes Mal, wenn sich jemand über SSH anmeldet, fragt der entfernte Server nach einem Passwort zur Authentifizierung des Benutzers. Dies kann problematisch sein, wenn man eine Verbindung automatisieren möchte, oder wenn man ein Hilfsprogramm verwendet, das häufige Verbindungen über SSH benötigt. Daher bietet SSH ein schlüsselbasiertes Authentifizierungssystem.</para>

	<para>Der Benutzer erzeugt auf dem Client-Rechner mit dem Befehl <command>ssh-keygen -t rsa</command> ein neues Schlüsselpaar; der öffentliche Schlüssel wird in  der Datei <filename>~/.ssh/id_rsa.pub</filename> gespeichert und der dazugehörige private Schlüssel in <filename>~/.ssh/id_rsa</filename>. Der Benutzer verwendet dann den Befehl <command>ssh-copy-id <replaceable>server</replaceable></command>, um seinen öffentlichen Schlüssel auf dem Server zur Datei <filename>~/.ssh/authorized_keys</filename> hinzuzufügen. Falls der private Schlüssel zur Zeit seiner Erzeugung nicht mit einer „Passphrase“ geschützt wurde, funktionieren alle nachfolgenden Anmeldungen auf dem Server ohne Eingabe eines Passworts. Anderenfalls muss der private Schlüssel jedes Mal erneut unter Eingabe der Passphrase entschlüsselt werden. Glücklicherweise ermöglicht es das Programm <command>ssh-agent</command>, private Schlüssel im Speicher zu halten, so dass das Passwort nicht ständig neu eingegeben werden muss. Hierzu verwendet man einfach (einmal pro Sitzung) den Befehl <command>ssh-add</command>, wobei Voraussetzung ist, dass die Sitzung bereits einer funktionsfähigen Instanz von <command>ssh-agent</command> zugeordnet ist. Debian aktiviert dieses Programm standardmäßig beim Start einer grafischen Sitzung, es kann jedoch durch eine Änderung der Datei <filename>/etc/X11/Xsession.options</filename> deaktiviert sein. In einer Konsolensitzung kann es manuell mit dem Befehl <command>eval $(ssh-agent)</command> gestartet werden.</para>

        <sidebar>
          <title><emphasis>SICHERHEIT</emphasis> Schutz des privaten Schlüssels</title>

	  <para>Wer im Besitz des privaten Schlüssels ist, kann sich mit dem entsprechend konfigurierten Konto anmelden. Daher ist der Zugriff auf den privaten Schlüssel durch eine „Passphrase“ geschützt. Selbst wenn jemand in den Besitz eines privaten Schlüssels gelangt (zum Beispiel die Datei <filename>~/.ssh/id_rsa</filename>), muss er zusätzlich noch diese Phrase kennen, um ihn verwenden zu können. Dieser zusätzliche Schutz ist jedoch nicht unüberwindlich, und wenn Sie denken, dass die Sicherheit dieser Datei nicht mehr gewährleistet ist, sollten Sie diesen Schlüssel auf den Rechnern, auf denen er installiert wurde, deaktivieren (indem Sie ihn aus <filename>authorized_keys</filename> entfernen) und durch einen neu erzeugten Schlüssel ersetzen.</para>
        </sidebar>

        <sidebar>
          <title><emphasis>KULTUR</emphasis> OpenSSL-Schwachstelle in Debian <emphasis role="distribution">Etch</emphasis></title>

	  <para>Die OpenSSL-Bibliothek, die ursprünglich mit Debian <emphasis role="distribution">Etch</emphasis> bereitgestellt wurde, hatte ein gravierendes Problem in ihrem Zufallszahlengenerator (RNG). In der Tat hatte der zuständige Debian-Betreuer eine Änderung vorgenommen, damit Anwendungen, die ihn verwenden, keine Warnmeldungen mehr verursachen, wenn sie von Werkzeugen für das Memory Management wie zum Beispiel <command>valgrind</command> analysiert werden. Leider hatte diese Änderung auch zur Folge, dass der Zufallszahlengenerator nur eine Entropie-Quelle in Abhängigkeit von der Prozesskennung (PID) benutzte, deren 32.000 mögliche Werte keinen ausreichenden Grad an Zufälligkeit boten. <ulink type="block" url="http://www.debian.org/security/2008/dsa-1571" /></para>

	  <para>Insbesondere, wenn OpenSSL benutzt wurde, um einen Schlüssel zu erzeugen, wurde dieser immer aus einem Satz einiger hunderttausend Schlüssel erstellt (32.000 multipliziert mit einer kleinen Zahl von Schlüssellängen). Hiervon waren SSH-Schlüssel, SSL-Schlüssel und von zahlreichen Anwendungen, wie zum Beispiel OpenVPN, verwendete X.509-Zertifikate betroffen. Ein Eindringling brauchte nur alle Schlüssel auszuprobieren, um unberechtigten Zugriff zu erlangen. Um die Auswirkung des Problems einzuschränken, wurde der SSH-Daemon dahingehend verändert, dass er zweifelhafte Schlüssel, die in den Paketen <emphasis role="pkg">openssh-blacklist</emphasis> und <emphasis role="pkg">openssh-blacklist-extra</emphasis> aufgelistet sind, zurückweist. Darüber hinaus ermöglicht es der Befehl <command>ssh-vulnkey</command>, möglicherweise gefährdete Schlüssel im System zu identifizieren.</para>

	  <para>Eine gründlichere Analyse dieses Vorfalls zeigt, dass er das Ergebnis mehrerer (kleiner) Probleme ist, sowohl innerhalb des OpenSSL-Projekts als auch mit dem Debian-Paketbetreuer. Eine weit verbreitete Bibliothek wie OpenSSL sollte - ohne Änderungen - keine Warnungen erzeugen, wenn sie mit <command>valgrind</command> getestet wird. Außerdem sollte der Code (insbesondere die so empfindlichen Teile wie der RNG) besser kommentiert werden, um solche Fehler zu vermeiden. Auf Debians Seite wollte der Betreuer die Änderungen mit den OpenSSL-Entwicklern validieren, erklärte aber einfach die Änderungen, ohne den entsprechenden Patch zur Verfügung zu stellen, und versäumte es, seine Rolle in Debian zu erwähnen. Schließlich waren die Wartungsoptionen suboptimal: die Änderungen am Originalcode wurden nicht eindeutig dokumentiert; alle Änderungen wurden effektiv in einem Subversion-Repository gespeichert, aber sie endeten alle in einem einzigen Patch während der Erstellung des Quellpakets.</para>

	  <para>It is difficult under such conditions to find the
	  corrective measures to prevent such incidents from recurring. The
	  lesson to be learned here is that every divergence Debian
	  introduces to upstream software must be justified, documented,
	  submitted to the upstream project when possible, and widely
	  publicized. It is from this perspective that the new source
          package format (“3.0 (quilt)”) and the Debian sources webservice
          were developed.
	  <ulink type="block" url="http://sources.debian.org" /></para>
        </sidebar>
      </section>
      <section id="sect.ssh-x11">
        <title>Entfernte X11-Anwendungen benutzen</title>

	<para>Das SSH-Protokoll ermöglicht die Weiterleitung grafischer Daten („X11“-Sitzung, nach dem Namen des am weitesten verbreiteten grafischen Systems in Unix); der Server stellt hierbei einen besonderen Kanal für diese Daten bereit. Konkret bedeutet dies, dass ein aus der Ferne ausgeführtes, grafisches Programm vom X.org-Server auf dem lokalen Bildschirm dargestellt werden kann, und dass die gesamte Sitzung (Eingabe und Anzeige) abgesichert ist. Da entfernte Anwendungen durch diese Funktion das lokale System beeinträchtigen können, ist sie standardmäßig deaktiviert. Sie kann aktiviert werden, indem man in der Serverkonfigurationsdatei (<filename>/etc/ssh/sshd_config</filename>) die Option <literal>X11Forwarding yes</literal> einstellt. Schließlich muss der Benutzer diese Funktion anfordern, indem er die Option <literal>-X</literal> zur Befehlszeile <command>ssh</command> hinzufügt.</para>
      </section>
      <section id="sect.ssh-port-forwarding">
        <title>Verschlüsselte Tunnel mit Port-Weiterleitung einrichten</title>
        <indexterm><primary>Port-Weiterleitung</primary></indexterm>

	<para>Die Optionen <literal>-R</literal> und <literal>-L</literal> des Befehls <command>ssh</command> ermöglichen es, „verschlüsselte Tunnel“ zwischen zwei Rechnern zu erstellen, und so einen lokalen TCP-Port (siehe <xref linkend="sidebar.tcp-udp" /> in der Seitenleiste) sicher an einen entfernten Rechner weiterzuleiten und umgekehrt.</para>

        <sidebar>
          <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Tunnel</title>
          <indexterm><primary>Tunnel (SSH)</primary><seealso>VPN</seealso></indexterm>
          <indexterm><primary>SSH-Tunnel</primary><seealso>VPN</seealso></indexterm>

	  <para>Das Internet und die meisten mit ihm verbundenen LANs arbeiten im Paket-Modus und nicht in einem fest geschalteten Modus. Das heißt, dass ein Paket, das von einem Rechner zu einem anderen verschickt wird, auf dem Weg zu seinem Ziel an mehreren dazwischenliegenden Routern angehalten wird. Dennoch kann man einen fest geschalteten Betrieb nachahmen, indem der Datenstrom in normale IP-Pakete eingeschlossen wird. Diese Pakete laufen über ihren üblichen Weg, jedoch wird der Datenstrom am Ziel dann unverändert rekonstruiert. Man nennt dies einen „Tunnel“ in Analogie zu einem Straßentunnel, bei dem Fahrzeuge direkt vom Eingang (Eingabe) zum Ausgang (Ausgabe) fahren, ohne auf irgendwelche Kreuzungen zu stoßen, im Gegensatz zu einem Weg an der Oberfläche, bei dem es Kreuzungen und Richtungswechsel gibt.</para>

	  <para>Man kann bei dieser Gelegenheit den Tunnel verschlüsseln: der Datenstrom, der durch ihn hindurchläuft, ist dann von außen unkenntlich, wird aber am Tunnelausgang wieder in eine unverschlüsselte Form zurückgeführt.</para>
        </sidebar>

	<para><command>ssh -L 8000:server:25 intermediary</command> eröffnet eine SSH-Sitzung mit dem Host <replaceable>intermediary</replaceable> und nimmt am lokalen Port 8000 Verbindungen an (siehe <xref linkend="figure.ssh-L" />). Für jede Verbindung, die zu diesem Port hergestellt wird, baut <command>ssh</command> eine Verbindung vom Rechner <replaceable>intermediary</replaceable> zum Port 25 des <replaceable>server</replaceable> auf und verknüpft beide Verbindungen.</para>

	<para><command>ssh -R 8000:server:25 intermediary</command> eröffnet auch eine SSH-Sitzung zum Rechner <replaceable>intermediary</replaceable>, aber <command>ssh</command> nimmt dann auf diesem Rechner an Port 8000 Verbindungen an (siehe <xref linkend="figure.ssh-R" />). Jede Verbindung, die an diesem Port hergestellt wird, veranlasst <command>ssh</command>, eine Verbindung vom lokalen Rechner zum Port 25 des <replaceable>server</replaceable> zu öffnen und beide Verbindungen miteinander zu verknüpfen.</para>

	<para>In beiden Fällen werden Verbindungen zu Port 25 auf dem Host <replaceable>server</replaceable> hergestellt, die durch den SSH-Tunnel laufen, der zwischen dem lokalen Rechner und dem Rechner <replaceable>intermediary</replaceable> hergestellt wurde. Im ersten Fall ist der Eingang zum Tunnel der lokale Port 8000, und die Daten laufen zum Rechner <replaceable>intermediary</replaceable>, bevor sie zum <replaceable>server</replaceable> im „öffentlichen“ Netzwerk geleitet werden. Im zweiten Fall sind Ein- und Ausgang im Tunnel vertauscht: der Eingang ist Port 8000 auf dem Rechner <replaceable>intermediary</replaceable>, der Ausgang ist auf dem lokalen Host, und die Daten werden dann zum <replaceable>server</replaceable> geleitet. In der Praxis ist der Server normalerweise entweder der lokale Rechner oder der intermediäre. Auf diese Weise sichert SSH die Verbindung von einem Ende zum anderen.</para>

        <figure id="figure.ssh-L">
          <title>Einen lokalen Port mit SSH weiterleiten</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ssh-L.png" width="35%" />
            </imageobject>
          </mediaobject>
        </figure>

        <figure id="figure.ssh-R">
          <title>Einen entfernten Port mit SSH weiterleiten</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ssh-R.png" width="35%" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>
    <section id="sect.remote-desktops">
      <title>Entfernte grafische Arbeitsflächen benutzen</title>

      <para>VNC (Virtual Network Computing) ermöglicht aus der Ferne Zugriff auf grafische Arbeitsflächen.</para>
      <indexterm><primary>VNC</primary></indexterm>
      <indexterm><primary>Virtual Network Computing</primary></indexterm>
      <indexterm><primary>grafische Arbeitsfläche</primary><secondary>entfernt</secondary></indexterm>
      <indexterm><primary>entfernte grafische Arbeitsfläche</primary></indexterm>
      <indexterm><primary>Arbeitsfläche, entfernte grafische Arbeitsfläche</primary></indexterm>

      <para>Dieses Hilfsprogramm wird vor allem zur technischen Unterstützung eingesetzt; der Administrator kann die Fehler sehen, denen ein Benutzer gegenübersteht, und ihm die richtige Vorgehensweise zeigen, ohne vor Ort sein zu müssen.</para>
      <indexterm><primary><emphasis role="pkg">vino</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">krfb</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">x11vnc</emphasis></primary></indexterm>

      <para>Zuerst muss der Benutzer die Freigabe seiner Sitzung freigeben. Die grafische GNOME-Desktopumgebung in <emphasis role="distribution">Jessie</emphasis> enthält diese Option in ihrer Konfigurationskonsole (im Gegensatz zu früheren Versionen von Debian, wo der Benutzer <command>vino</command> installieren und ausführen musste). KDE benötigt weiterhin <command>krfb</command>, um eine bestehende Sitzung über VNC zu teilen. Für andere grafische Desktop-Umgebungen dient der Befehl <command>x11vnc</command> (aus dem gleichnamigen Debian-Paket) dem gleichen Zweck; Sie können ihn dem Benutzer mit einem expliziten Symbol zur Verfügung stellen.</para>

      <indexterm><primary><emphasis role="pkg">vinagre</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">tsclient</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">krdc</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">xvnc4viewer</emphasis></primary></indexterm>

      <para>Wenn die grafische Sitzung durch VNC freigeschaltet wurde, muss sich der Administrator über einen VNC-Client mit ihr verbinden. GNOME verfügt zu diesem Zweck über <command>vinagre</command> und <command>remmina</command>, während KDE <command>krdc</command> enthält (im Menü unter <menuchoice> <guimenu>K-Menü</guimenu> <guisubmenu>Internet</guisubmenu> <guimenuitem>Krdc - Verbindung zu Fremdrechner</guimenuitem></menuchoice>). Es gibt weitere VNC-Clients, die die Befehlszeile verwenden, wie zum Beispiel <command>xvnc4viewer</command> im gleichnamigen Debian-Paket. Sobald die Verbindung hergestellt ist, kann der Administrator sehen, was vorgeht, aus der Ferne auf dem Rechner arbeiten und dem Benutzer zeigen, wie er vorgehen soll.</para>

      <sidebar>
        <title><emphasis>SICHERHEIT</emphasis> VNC über SSH</title>
        <indexterm><primary>SSH-Tunnel</primary><secondary>VNC</secondary></indexterm>

	<para>Falls Sie über VNC eine Verbindung herstellen, Ihre Daten aber nicht im Klartext über das Netzwerk schicken wollen, können Sie sie in einem SSH-Tunnel verbergen (siehe <xref linkend="sect.ssh-port-forwarding" />). Sie müssen nur wissen, dass VNC standardmäßig den Port 5900 für den ersten Bildschirm („localhost:0“ genannt), 5901 für den zweiten („localhost:1“ genannt) usw. verwendet.</para>

	<para>Der Befehl <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>rechner</replaceable></command> erstellt einen Tunnel zwischen dem lokalen Port 5901 in der localhost-Schnittstelle und Port 5900 auf dem Host <replaceable>rechner</replaceable>. Das erste „localhost“ beschränkt SSH darauf, nur an dieser Schnittstelle des lokalen Rechners auf Anfragen zu warten. Das zweite „localhost“ bezeichnet die Schnittstelle des entfernten Rechners, die den Netzverkehr entgegennehmen wird, der in „localhost:5901“ eintritt. Auf diese Weise verbindet <command>vncviewer localhost:1</command> den VNC-Client mit dem entfernten Bildschirm, obwohl Sie den Namen des lokalen Rechners angeben.</para>

	<para>Wenn die VNC-Sitzung beendet ist, vergessen Sie nicht, den Tunnel zu schließen, indem Sie auch die entsprechende SSH-Sitzung beenden.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Display Manager</title>
        <indexterm><primary><command>gdm3</command></primary></indexterm>
        <indexterm><primary><command>kdm</command></primary></indexterm>
        <indexterm><primary><command>xdm</command></primary></indexterm>
        <indexterm><primary><command>lightdm</command></primary></indexterm>
        <indexterm><primary>Manager</primary><secondary>Display Manager</secondary></indexterm>
        <indexterm><primary>Display Manager</primary></indexterm>

	<para><command>gdm3</command>, <command>kdm</command>, <command>lightdm</command> und <command>xdm</command> sind Display Manager. Sie übernehmen kurz nach dem Hochfahren die Kontrolle über die grafische Schnittstelle, um dem Benutzer einen Anmeldebildschirm bereitzustellen. Sobald der Benutzer sich angemeldet hat, führen sie die zum Starten einer grafischen Arbeitssitzung erforderlichen Programme aus.</para>
      </sidebar>

      <para>VNC funktioniert auch für mobile Anwender oder für Angestellte, die sich gelegentlich von zu Hause aus anmelden müssen, um auf einen entfernten Bildschirm ähnlich dem an ihrem Arbeitsplatz zuzugreifen. Die Konfiguration eines derartigen Dienstes ist komplizierter: zunächst installieren Sie das Paket <emphasis role="pkg">vnc4server</emphasis>, passen die Konfiguration des Display Managers dahingehend an, dass er Anfragen an <literal>XDMCP Query</literal> annimmt (für <command>gdm3</command> kann dies durch Hinzufügen von <literal>Enable=true</literal> im Abschnitt “xdmcp” von <filename>/etc/gdm3/daemon.conf</filename>) und starten schließlich den VNC-Server mit <command>inetd</command>, so dass eine Sitzung automatisch beginnt, wenn ein Benutzer sich anzumelden versucht. Sie können zum Beispiel folgende Zeile zu <filename>/etc/inetd.conf</filename> hinzufügen:</para>

      <programlisting>5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</programlisting>

      <para>Das Umleiten ankommender Verbindungen zum Display Manager löst das Problem der Legitimierung, weil nur Benutzer mit einem lokalen Konto den Anmeldeschirm von <command>gdm3</command> passieren können (oder in gleicher Weise <command>kdm</command>, <command>xdm</command> usw.). Da dieses Verfahren problemlos mehrere gleichzeitige Anmeldungen ermöglicht (vorausgesetzt, dass der Server ausreichend leistungsfähig ist), kann es sogar dazu verwendet werden, vollständige Arbeitsflächen für mobile Benutzer bereitzustellen (oder für weniger leistungsstarke Arbeitsplatzrechner, die als Thin Clients konfiguriert sind). Benutzer melden sich einfach mit <command>vncviewer <replaceable>server</replaceable>:50</command> beim Bildschirm des Servers an, da der verwendete Port 5950 ist.</para>
      <indexterm><primary><emphasis role="pkg">vnc4server</emphasis></primary></indexterm>
    </section>
  </section>
  <section id="sect.rights-management">
    <title>Berechtigungen verwalten</title>

    <para>Linux ist eindeutig ein Mehrbenutzersystem, und daher ist es erforderlich, ein Berechtigungssystem bereitzustellen, um genehmigte Vorgänge an Dateien und Verzeichnissen zu steuern, einschließlich aller Systemressourcen und Laufwerke (in einem Unix-System wird jedes Laufwerk als eine Datei oder ein Verzeichnis dargestellt). Dies ist allen Unix-Systemen gemein, aber ist immer sinnvoll daran zu erinnern, vor allem, da es einige sehr interessante und relativ unbekannte fortgeschrittene Anwendungen davon gibt.</para>
    <indexterm><primary>Rechte</primary></indexterm>
    <indexterm><primary>Berechtigungen</primary></indexterm>
    <indexterm><primary>Benutzer</primary><secondary>Eigentümer</secondary></indexterm>
    <indexterm><primary>Gruppe</primary><secondary>Eigentümer</secondary></indexterm>
    <indexterm><primary>Eigentümer</primary><secondary>Benutzer</secondary></indexterm>
    <indexterm><primary>Eigentümer</primary><secondary>Gruppe</secondary></indexterm>

    <para>Jede Datei und jeder Ordner hat spezifische Berechtigungen für drei Kategorien von Benutzern:</para>
    <itemizedlist>
      <listitem>
	<para>seinen Eigentümer (symbolisiert durch <literal>u</literal> wie in „user“);</para>
      </listitem>
      <listitem>
	<para>seine Eigentümergruppe (symbolisiert durch <literal>g</literal> wie in „group“), die alle Mitglieder der Gruppe repräsentiert;</para>
      </listitem>
      <listitem>
	<para>die Sonstigen (symbolisiert durch <literal>o</literal> wie in „other“).</para>
      </listitem>
    </itemizedlist>

    <para>Drei Arten von Berechtigungen können kombiniert werden:</para>
    <itemizedlist>
      <listitem>
	<para>Lesen (symbolisiert durch <literal>r</literal> wie in „read“);</para>
      </listitem>
      <listitem>
	<para>Schreiben (oder Ändern, symbolisiert durch <literal>w</literal> wie in „write“);</para>
      </listitem>
      <listitem>
	<para>Ausführen (symbolisiert durch <literal>x</literal> wie in „eXecute“).</para>
      </listitem>
    </itemizedlist>
    <indexterm><primary>Lesen, Berechtigung</primary></indexterm>
    <indexterm><primary>Schreiben, Berechtigung</primary></indexterm>
    <indexterm><primary>Ändern, Berechtigung</primary></indexterm>
    <indexterm><primary>Ausführen, Berechtigung</primary></indexterm>

    <para>Bei einer Datei sind diese Berechtigungen leicht zu verstehen: Lesezugriff erlaubt das Lesen des Inhalts (einschließlich des Kopierens), Schreibzugriff erlaubt es, sie zu verändern, und Ausführungszugriff erlaubt es Ihnen, sie auszuführen (was nur funktionieren wird, wenn sie ein Programm ist).</para>

    <sidebar>
      <title><emphasis>SICHERHEIT</emphasis> <literal>setuid</literal> und <literal>setgid</literal> ausführbare Dateien</title>

      <para>Zwei besondere Berechtigungen sind für ausführbare Dateien wichtig: <literal>setuid</literal> und <literal>setgid</literal> (durch den Buchstaben „s“ symbolisiert). Beachten Sie, dass wir häufig von einem „Bit“ sprechen, da jeder dieser booleschen Werte durch eine 0 oder eine 1 dargestellt werden kann. Diese beiden Berechtigungen erlauben es jedem Benutzer, das Programm mit den Rechten des Eigentümers beziehungsweise der Gruppe auszuführen. Dieses Verfahren gewährt Zugriff auf Funktionsmerkmale, die Rechte einer höheren Ebene erfordern, als Sie normalerweise haben würden.</para>
      <indexterm><primary><literal>setuid</literal>, Recht</primary></indexterm>
      <indexterm><primary><literal>setgid</literal>, Recht</primary></indexterm>

      <para>Da ein Root-Programm mit <literal>setuid</literal> durchgängig unter der Identität des Super-Users läuft, ist es sehr wichtig sicherzustellen, dass es sicher und verlässlich ist. Ein Benutzer, dem es gelingt, es zu unterlaufen, um einen Befehl seiner Wahl aufzurufen, könnte sich anschließend als Root-Benutzer ausgeben und so alle Rechte an dem System erlangen.</para>
    </sidebar>

    <para>Ein Verzeichnis wird anders gehandhabt. Lesezugriff gewährt das Recht, die Liste der Einträge (Dateien und Verzeichnisse) durchzugehen, Schreibzugriff erlaubt es, Dateien zu erstellen oder zu löschen, und Ausführungszugriff erlaubt es, es zu durchqueren (insbesondere dorthin mit dem Befehl <command>cd</command> zu gehen). Die Berechtigung, ohne ein Verzeichnis zu lesen auf dessen Inhalt zugreifen zu können, gestattet Zugriff auf namentlich bekannte Dateien, nicht jedoch auf solche von denen man nichts weiß oder deren genauen Namen man nicht kennt.</para>

    <sidebar id="sidebar.setgid-dir">
      <title><emphasis>SICHERHEIT</emphasis> <literal>setgid</literal>-Verzeichnis und <emphasis>Sticky-Bit</emphasis></title>
      <indexterm><primary><literal>setgid</literal> Verzeichnis</primary></indexterm>

      <para>Das <literal>setgid</literal>-Bit gilt auch für Verzeichnisse. Und neu erstellte Einträge in solchen Verzeichnissen werden automatisch der Benutzergruppe des übergeordneten Verzeichnisses zugeordnet, anstatt wie gewöhnlich die Hauptgruppe des Erstellers zu übernehmen. Durch diese Einstellung wird vermieden, dass der Benutzer die Hauptgruppe des Eintrags ändern muss (mit dem Befehl <command>newgrp</command>), wenn er in einem Verzeichnisbaum arbeitet, der von mehreren Benutzern derselben Gruppe gemeinsam genutzt wird.</para>
      <indexterm><primary>Sticky-Bit</primary></indexterm>

      <para>Das „Sticky“-Bit (symbolisiert durch den Buchstaben „t“) ist ein Recht, das nur in Verzeichnissen sinnvoll ist. Es wird vor allem bei temporären Verzeichnissen verwendet, auf die jeder Schreibzugriff hat (wie zum Beispiel bei <filename>/tmp/</filename>): es schränkt das Löschen von Dateien ein, so dass dies nur ihr Eigentümer (oder der Eigentümer des übergeordneten Verzeichnisses) kann. Ohne dieses Recht könnte jeder die Dateien anderer Benutzer in <filename>/tmp/</filename> löschen.</para>
    </sidebar>

    <para>Drei Befehle steuern die einer Datei zugeordneten Berechtigungen:</para>
    <itemizedlist>
      <listitem>
	<para><command>chown <replaceable>Benutzer</replaceable> <replaceable>Datei</replaceable></command> ändert den Eigentümer der Datei;</para>
      </listitem>
      <listitem>
	<para><command>chgrp <replaceable>Gruppe</replaceable> <replaceable>Datei</replaceable></command> ändert die Eigentümergruppe;</para>
      </listitem>
      <listitem>
	<para><command>chmod <replaceable>Rechte</replaceable> <replaceable>Datei</replaceable></command> ändert die Berechtigungen für die Datei.</para>
      </listitem>
    </itemizedlist>

    <para>Es gibt zwei Arten, die Berechtigungen darzustellen, wovon die symbolische Darstellung wohl am einfachsten zu verstehen und zu merken ist. Es geht um die oben erwähnten Buchstabensymbole. Sie können Berechtigungen für jede Kategorie von Benutzern festlegen (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), indem Sie sie entweder ausdrücklich setzen (mit <literal>=</literal>), sie hinzufügen (<literal>+</literal>) oder sie entfernen (<literal>-</literal>). So gewährt die Formel <literal>u=rwx,g+rw,o-r</literal> dem Eigentümer Lese-, Schreib- und Ausführungszugriff, fügt Lese- und Schreibzugriff für die Eigentümergruppe hinzu und entfernt den Lesezugriff für andere Benutzer. Rechte, die in einem solchen Befehl nicht durch Hinzufügen oder Entfernen modifiziert werden, bleiben unverändert. Der Buchstabe <literal>a</literal>, für „all“, deckt alle drei Benutzerkategorien ab, so dass <literal>a=rx</literal> allen drei Kategorien die gleichen Rechte gewährt (Lesen und Ausführen, aber nicht Schreiben).</para>
    <indexterm><primary><command>chmod</command></primary></indexterm>
    <indexterm><primary><command>chown</command></primary></indexterm>
    <indexterm><primary><command>chgrp</command></primary></indexterm>
    <indexterm><primary>Oktale Darstellung von Berechtigungen</primary></indexterm>
    <indexterm><primary>Berechtigungen</primary><secondary>oktale Darstellung</secondary></indexterm>

    <para>Die (oktale) Zahlendarstellung ordnet jeder Berechtigung einen Wert zu: 4 für Lesen, 2 für Schreiben und 1 für Ausführen. Wir verknüpfen jede Kombination von Berechtigungen durch die Summe der Zahlen. Jeder Wert wird dann einer anderen Kategorie von Benutzern zugeordnet, indem sie von vorne nach hinten in der üblichen Reihenfolge (Eigentümer, Gruppe, Sonstige) angeordnet werden.</para>

    <para>So vergibt zum Beispiel der Befehl <command>chmod 754 <replaceable>datei</replaceable></command> die folgenden Berechtigungen: Schreiben, Lesen und Ausführen für den Eigentümer (da 7 = 4 + 2 + 1); Schreiben und Ausführen für die Gruppe (da 5 = 4 + 1); nur Lesen für Sonstige. Die <literal>0</literal> bedeutet keine Berechtigung; so gestattet <command>chmod 600 <replaceable>Datei</replaceable></command> dem Eigentümer Lese-/Schreibzugriff und keine Berechtigung für alle anderen. Die häufigsten Berechtigungskombinationen sind <literal>755</literal> für ausführbare Dateien und Verzeichnisse und <literal>644</literal> für Dateien, die Daten enthalten.</para>

    <para>Um spezielle Berechtigungen darzustellen, können Sie dieser Zahl eine vierte Ziffer nach dem gleichen Prinzip voranstellen, wobei die <literal>setuid</literal>-, <literal>setgid</literal>- und <literal>sticky</literal>-Bits jeweils 4, 2 und 1 entsprechen. <command>chmod 4754</command> fügt das <literal>setuid</literal>-Bit den zuvor beschriebenen Berechtigungen hinzu.</para>

    <para>Beachten Sie, dass die oktale Schreibweise es nur erlaubt, alle Berechtigungen gleichzeitig für eine Datei zu setzen. Sie können sie nicht dazu benutzen, einfach eine neue Berechtigung hinzuzufügen, wie den Lesezugriff für die Eigentümergruppe, da Sie die bestehenden Berechtigungen berücksichtigen und den entsprechenden neuen numerischen Wert berechnen müssen.</para>

    <sidebar>
      <title><emphasis>TIPP</emphasis> Rekursives Verfahren</title>

      <para>Manchmal müssen wir die Berechtigungen für einen ganzen Dateibaum ändern. Alle oben beschriebenen Befehle haben eine <literal>-R</literal>-Option, um rekursiv in Unterverzeichnissen zu agieren.</para>

      <para>Die Unterscheidung zwischen Verzeichnissen und Dateien verursacht manchmal Probleme bei rekursiven Aktionen. Daher wurde für die symbolische Darstellung von Berechtigungen der Buchstabe „X“ eingeführt. Er stellt ein Ausführungsrecht dar, das nur für Verzeichnisse gilt (und nicht für Dateien, die dieses Recht nicht haben). So fügt <command>chmod -R a+X <replaceable>Verzeichnis</replaceable></command> Ausführungsrechte für alle Kategorien von Benutzern (<literal>a</literal>) nur bei allen den Unterverzeichnissen und Dateien hinzu, bei denen wenigstens eine Benutzerkategorie (selbst wenn dies ihr einziger Eigentümer ist) bereits Ausführungsrechte hat.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>TIPP</emphasis> Eigentümer und Gruppe ändern</title>

      <para>Häufig möchten Sie die Gruppe einer Datei und gleichzeitig ihren Eigentümer ändern. Der Befehl <command>chown</command> hat hierfür eine besondere Syntax: <command>chown <replaceable>Eigentümer</replaceable>:<replaceable>Gruppe</replaceable> <replaceable>Datei</replaceable></command></para>
    </sidebar>

    <sidebar>
      <title><emphasis>WEITERE SCHRITTE</emphasis> <command>umask</command></title>

      <para>Wenn eine Anwendung eine Datei erstellt, teilt sie ihr vorläufige Berechtigungen zu, wissend dass das System automatisch bestimmte Berechtigungen entfernt, die mit dem Befehl <command>umask</command> vorgegeben wurden. Geben Sie <command>umask</command> in einer Shell ein, werden Sie eine Maske wie zum Beispiel <computeroutput>0022</computeroutput> sehen. Dies ist eine oktale Darstellung der Berechtigungen, die planmäßig entfernt werden (in diesem Fall die Schreibrechte für die Gruppe und sonstige Benutzer).</para>
      <indexterm><primary>umask</primary></indexterm>
      <indexterm><primary>Berechtigungen</primary><secondary>Maske</secondary></indexterm>
      <indexterm><primary>Maske</primary><secondary>Berechtigungsmaske</secondary></indexterm>

      <para>Wenn Sie einen neuen oktalen Wert eingeben, verändert der Befehl <command>umask</command> die Maske. Bei Verwendung in der Startdatei einer Shell (zum Beispiel <filename>~/.bash_profile</filename>) ändert er grundsätzlich die Standardmaske für Ihre Arbeitssitzungen.</para>
    </sidebar>
  </section>
  <section id="sect.administration-interfaces">
    <title>Administrations-Schnittstellen</title>
    <indexterm><primary>Schnittstelle</primary><secondary>Administrations-Schnittstelle</secondary></indexterm>
    <indexterm><primary>Administration, Schnittstellen</primary></indexterm>

    <para>Eine grafische Schnittstelle für die Administration zu benutzen, ist unter verschiedenen Umständen interessant. Ein Administrator kennt nicht unbedingt alle Konfigurationseinzelheiten für alle seine Dienste, und er hat nicht immer Zeit, sich auf die Suche nach der Dokumentation für ein Thema zu machen. Eine grafische Schnittstelle für die Administration kann daher die Bereitstellung eines neuen Dienstes beschleunigen. Sie kann auch die Einrichtung von Diensten vereinfachen, die schwierig zu konfigurieren sind.</para>

    <para>Eine derartige Schnittstelle ist nur eine Hilfe und kein Selbstzweck. Auf jeden Fall muss der Administrator ihr Verhalten beherrschen, um mögliche Probleme verstehen und umgehen zu können.</para>

    <para>Da keine Schnittstelle vollkommen ist, könnten Sie versucht sein, verschiedene Lösungen auszuprobieren. Dies sollte jedoch möglichst vermieden werden, da verschiedene Programme manchmal in ihren Funktionsweisen zueinander inkompatibel sind. Selbst wenn sie alle darauf abzielen, sehr flexibel zu sein und versuchen, die Konfigurationsdatei als ihren einzigen Bezugspunkt zu verwenden, sind sie nicht immer in der Lage, auch externe Veränderungen einzubeziehen.</para>
    <section id="sect.webmin">
      <title>Über eine Webschnittstelle administrieren: <command>webmin</command></title>
      <indexterm><primary><emphasis>webmin</emphasis></primary></indexterm>

      <para>Dies ist ohne Zweifel eine der erfolgreichsten Administrations-Schnittstellen. Es ist ein modulares System, das mittels eines Webbrowsers bedient wird und ein weites Spektrum an Bereichen und Werkzeugen abdeckt. Darüber hinaus ist es internationalisiert und in vielen Sprachen verfügbar.</para>

      <para>Leider ist <command>webmin</command> nicht mehr in Debian enthalten. Sein Debian-Betreuer - Jaldhar H. Vyas - hat die Pakete, die er erstellt hatte, entfernt, da er nicht mehr die erforderliche Zeit hatte, um sie auf einem akzeptablen Qualitätsniveau zu halten. Kein anderer hat die Aufgabe offiziell übernommen, daher enthält <emphasis role="distribution">Jessie</emphasis> das Paket <command>webmin</command> nicht.</para>

      <para>Auf der Webseite <literal>webmin.com</literal> wird jedoch ein inoffizielles Paket verteilt. Im Gegensatz zu den originalen Debian Paketen, ist dieses Paket monolithisch; alle seine Konfigurationsmodule werden standardmäßig installiert und aktiviert, selbst wenn der dazugehörige Dienst auf dem Rechner nicht installiert ist.</para>

      <sidebar>
        <title><emphasis>SICHERHEIT</emphasis> Das Root-Passwort ändern</title>

	<para>Beim ersten Anmelden dienen der Benutzername  root und sein normales Passwort zur Identifizierung. Es ist empfehlenswert, das für <command>webmin</command> verwendete Passwort so bald wie möglich zu ändern, so dass im Falle eines Angriffsversuchs das Root-Passwort für den Server nicht betroffen ist, selbst wenn hierdurch dem Rechner wichtige Administrationsrechte verliehen werden.</para>

	<para>Vorsicht! Da <command>webmin</command> sehr viele Funktionen hat, könnte ein böswilliger Benutzer bei einem Zugriff die Sicherheit des gesamten Systems gefährden. Im Allgemeinen wird deshalb von der Verwendung derartiger Schnittstellen bei wichtigen Systemen mit starken Sicherheitsauflagen (Firewall, sensible Server usw.) abgeraten.</para>
      </sidebar>

      <para>Webmin wird durch eine Webschnittstelle bedient, es erfordert aber nicht die Installation von Apache. Im Grunde hat diese Software ihren eigenen integrierten Mini-Webserver. Dieser Server wartet an Port 10000 auf Anfragen und nimmt sichere HTTP-Verbindungen an.</para>

      <para>Die mitgelieferten Module decken eine große Vielfalt von Diensten ab, unter anderem:</para>
      <itemizedlist>
        <listitem>
	  <para>alle Basisdienste: Anlegen von Benutzern und Gruppen, Verwaltung von <filename>crontab</filename>-Dateien, Init-Skripten, Betrachtung von Protokolldateien usw.</para>
        </listitem>
        <listitem>
	  <para>bind: Konfiguration eines DNS-Servers (Namensdienst);</para>
        </listitem>
        <listitem>
	  <para>postfix: Konfiguration eines SMTP-Servers (E-Mail);</para>
        </listitem>
        <listitem>
	  <para>inetd: Konfiguration des Superservers <command>inetd</command>;</para>
        </listitem>
        <listitem>
	  <para>quota: Verwaltung der Benutzer-Quota;</para>
        </listitem>
        <listitem>
	  <para>dhcpd: Konfiguration eines DHCP-Servers;</para>
        </listitem>
        <listitem>
	  <para>proftpd: Konfiguration eines FTP-Servers;</para>
        </listitem>
        <listitem>
	  <para>samba: Konfiguration eines Samba-Dateiservers;</para>
        </listitem>
        <listitem>
	  <para>software: Installierung und Entfernung von Software aus Debian-Paketen und Systemaktualisierungen.</para>
        </listitem>
      </itemizedlist>

      <para>Die Administrations-Schnittstelle ist in einem Webbrowser über die Adresse <literal>https://localhost:10000</literal> zu erreichen. Vorsicht! Nicht alle Module sind unmittelbar nutzbar. Manchmal müssen sie durch die Angabe der Speicherorte der jeweiligen Konfigurationsdateien und einiger ausführbarer Dateien (Programme) konfiguriert werden. Häufig wird das System Sie freundlich hierauf hinweisen, wenn es ihm nicht gelingt, ein gewünschtes Modul zu aktivieren.</para>

      <sidebar>
        <title><emphasis>ALTERNATIVE</emphasis> GNOME Control Center</title>
        <indexterm><primary><emphasis role="pkg">gnome-control-center</emphasis></primary></indexterm>

	<para>Das Projekt GNOME stellt vielfache Verwaltungsschnittstellen zur Verfügung, die normalerweise über den Settings-Eintrag im User-Menü oben rechts zugänglich sind. <command>gnome-control-center</command>ist das übergreifende Hauptprogramm, aber viele der systemweiten Konfigrationsswerkzeuge werden tatsächlich von anderen Paketen (<emphasis role="pkg">accountsservice</emphasis>, <emphasis role="pkg">system-config-printer</emphasis>, etc.) zur Verfügung gestellt. Obwohl in der Benutzung einfach gehalten, stellen diese Anwendungen nur eine begrenzte Zahl an Basisdiensten zur Verfügung: Benutzerverwaltung, Zeit-, Netzwerk-, Druckerkonfiguration und so weiter.</para>
      </sidebar>
    </section>
    <section id="sect.debconf">
      <title>Pakete konfigurieren:  <command>debconf</command></title>
      <indexterm><primary><command>debconf</command></primary></indexterm>
      <indexterm><primary><command>dpkg-reconfigure</command></primary></indexterm>

      <para>Viele Pakete werden, durch das Stellen einiger Fragen durch Debconf bei der Installation, automatisch konfiguriert. Diese Pakete können mit dem Befehl <command>dpkg-reconfigure <replaceable>paket</replaceable></command> neu konfiguriert werden.</para>

      <para>In den meisten Fällen sind diese Einstellungen sehr einfach; es werden nur einige wichtige Variablen in der Konfigurationsdatei geändert. Diese Variablen sind häufig zwischen zwei „Begrenzungszeilen“ gruppiert, so dass eine Neukonfiguration des Pakets nur Einfluss auf den eingeschlossenen Bereich hat. In anderen Fällen wird eine Neukonfiguration nichts ändern, falls das Skript eine manuelle Änderung der Konfigurationsdatei entdeckt, um so diese menschlichen Eingriffe zu bewahren (da das Skript nicht sicherstellen kann, dass seine eigenen Veränderungen nicht die vorhandenen Einstellungen stören würden).</para>

      <sidebar>
        <title><emphasis>DEBIAN-RICHTLINIEN</emphasis> Veränderungen bewahren</title>

	<para>Die Debian-Richtlinien legen ausdrücklich fest, dass alles getan werden sollte, um manuelle Veränderungen einer Konfigurationsdatei zu bewahren. Daher treffen immer mehr Skripten Vorsichtsmaßnahmen, wenn sie Konfigurationsdateien editieren. Das allgemeine Prinzip ist einfach: das Skript nimmt nur dann Änderungen vor, wenn es den Status der Konfigurationsdatei kennt, was durch einen Vergleich der Prüfsumme der Datei mit derjenigen der letzten automatisch erzeugten Datei überprüft wird. Falls sie gleich sind, ist es dem Skript erlaubt, die Konfigurationsdatei zu ändern. Anderenfalls entscheidet es, dass die Datei verändert wurde und fragt, welche Aktion es durchführen soll (eine neue Datei installieren, die alte Datei speichern oder zu versuchen, die Änderungen in die bestehende Datei zu integrieren). Dieses Vorsorgeprinzip gab es lange Zeit nur bei Debian, inzwischen haben aber auch andere Distributionen damit begonnen, es sich zu eigen zu machen.</para>

	<para>Das Programm <command>ucf</command> (aus dem gleichnamigen Debian-Paket) kann dazu verwendet werden, ein derartiges Verhalten umzusetzen.</para>
        <indexterm><primary><command>ucf</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.syslog">
    <title><command>syslog</command> Systemereignisse</title>
    <indexterm><primary><command>rsyslogd</command></primary></indexterm>
    <indexterm><primary>Dateien</primary><secondary>Protokolldateien</secondary></indexterm>
    <indexterm><primary>Protokolle</primary><secondary>verteilen</secondary></indexterm>
    <section id="sect.syslog-principe">
      <title>Prinzip und Mechanismus</title>

      <para>Der <command>rsyslogd</command>-Daemon ist für das Sammeln von Meldungen zuständig, die von den Anwendungen und vom Kernel kommen, und für ihre Verteilung auf weitere Protokolldateien (die normalerweise im Verzeichnis <filename>/var/log/</filename> gespeichert werden). Er richtet sich nach der Konfigurationsdatei <filename>/etc/rsyslog.conf</filename>.</para>

      <para>Jede Protokollmeldung ist einem Anwendungsuntersystem zugeordnet (in der Dokumentation „facility“ genannt):</para>
      <itemizedlist>
        <listitem>
	  <para><literal>auth</literal> und <literal>authpriv</literal>: für die Authentifizierung;</para>
        </listitem>
        <listitem>
	  <para><literal>cron</literal>: kommt von den Diensten für die Aufgabenterminierung <command>cron</command> und <command>atd</command>;</para>
        </listitem>
        <listitem>
	  <para><literal>daemon</literal>: betrifft einen nicht näher bestimmten Daemon (DNS, NTP usw.);</para>
        </listitem>
        <listitem>
	  <para><literal>ftp</literal>: bezieht sich auf den FTP-Server;</para>
        </listitem>
        <listitem>
	  <para><literal>kern</literal>: eine vom Kernel kommende Meldung;</para>
        </listitem>
        <listitem>
	  <para><literal>lpr</literal>: kommt vom Druck-Subsystem;</para>
        </listitem>
        <listitem>
	  <para><literal>mail</literal>: kommt vom E-Mail-Subsystem;</para>
        </listitem>
        <listitem>
	  <para><literal>news</literal>: Usenet-Subsystemmeldung (insbesondere von einem NNTP-Server [Network News Transfer Protocol], der Nachrichtenforen verwaltet);</para>
        </listitem>
        <listitem>
	  <para><literal>syslog</literal>: Meldungen vom <command>syslogd</command>-Server selbst;</para>
        </listitem>
        <listitem>
	  <para><literal>user</literal>: Benutzermeldungen (allgemein);</para>
        </listitem>
        <listitem>
	  <para><literal>uucp</literal>: Meldungen vom UUCP-Server (Unix to Unix Copy Program, ein altes vor allem zur Verteilung von E-Mails verwendetes Protokoll);</para>
        </listitem>
        <listitem>
	  <para><literal>local0</literal> bis <literal>local7</literal>: für die lokale Verwendung reserviert.</para>
        </listitem>
      </itemizedlist>

      <para>Jeder Meldung ist auch eine Prioritätsstufe zugeordnet. Hier sind sie in abnehmender Reihenfolge:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>emerg</literal>: „Hilfe!“ Es gibt einen Notfall, das System ist möglicherweise unbrauchbar.</para>
        </listitem>
        <listitem>
	  <para><literal>alert</literal>: Beeilung! Jede Verzögerung kann gefährlich sein, es muss sofort etwas unternommen werden;</para>
        </listitem>
        <listitem>
	  <para><literal>crit</literal>: die Umstände sind kritisch;</para>
        </listitem>
        <listitem>
	  <para><literal>err</literal>: Fehler;</para>
        </listitem>
        <listitem>
	  <para><literal>warn</literal>: Warnung (möglicher Fehler);</para>
        </listitem>
        <listitem>
	  <para><literal>notice</literal>: die Umstände sind normal, aber die Meldung ist wichtig;</para>
        </listitem>
        <listitem>
	  <para><literal>info</literal>: aufschlussreiche Meldung;</para>
        </listitem>
        <listitem>
	  <para><literal>debug</literal>: Fehlerbeseitigungsmeldung.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="sect.syslog-config">
      <title>Die Konfigurationsdatei</title>

      <para>Die Syntax der Datei <filename>/etc/rsyslog.conf</filename> ist auf der Handbuchseite <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> ausführlich erläutert, im Paket <emphasis role="pkg">rsyslog-doc</emphasis> findet sich aber auch eine HTML-Dokumentation (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). Das Grundprinzip besteht darin, Paare von „selector“ und „action“ zu verfassen. Der Selektor bestimmt alle relevanten Meldungen, und die Aktionen beschreiben, wie mit ihnen umzugehen ist.</para>
      <section id="sect.syslog-selector-syntax">
        <title>Syntax des Selektors</title>

	<para>Der Selektor ist eine durch Semikolon getrennte Liste von <literal><replaceable>subsystem</replaceable>.<replaceable>priorität</replaceable></literal>-Paaren (Beispiel: <literal>auth.notice;mail.info</literal>). Ein Stern kann für alle Subsysteme oder alle Prioritäten stehen (Beispiele: <literal>*.alert</literal> oder <literal>mail.*</literal>). Mehrere Subsysteme können in einer Gruppe zusammengefasst werden, indem sie durch ein Komma getrennt werden (Beispiel: <literal>auth,mail.info</literal>). Die angezeigte Priorität bezieht sich auch auf Meldungen gleicher oder höherer Priorität; so bezeichnet <literal>auth.alert</literal> Meldungen des <literal>auth</literal>-Subsystems mit der Priorität <literal>alert</literal> oder <literal>emerg</literal>. Mit einem vorangestellten Ausrufezeichen (!) bezeichnen sie das Gegenteil, mit anderen Worten nur die niedrigeren Prioritäten; so bezeichnet <literal>auth.!notice</literal> Meldungen, die von <literal>auth</literal> mit den Prioritäten <literal>info</literal> oder <literal>debug</literal> verschickt worden sind. Mit einem vorangestellten Gleichheitszeichen (=) beziehen sie sich genau und ausschließlich auf die angegebene Priorität (bei <literal>auth.=notice</literal> handelt es sich ausschließlich um Meldungen von <literal>auth</literal> mit der Priorität <literal>notice</literal>).</para>

	<para>Jedes Element in der Auswahlliste setzt vorhergehende Elemente außer Kraft. Es ist somit möglich, die Menge einzugrenzen oder bestimmte Elemente von ihr auszuschließen. Zum Beispiel bezeichnet <literal>kern.info;kern.!err</literal> Meldungen vom Kernel mit einer Priorität zwischen <literal>info</literal> und <literal>warn</literal>. Die Priorität <literal>none</literal> bezeichnet die leere Menge (keine Prioritäten) und kann dazu dienen, ein Subsystem von einer Menge von Meldungen auszuschließen. So bezeichnet <literal>*.crit;kern.none</literal> alle Meldungen mit der Priorität <literal>crit</literal> oder höher, die nicht vom Kernel kommen.</para>
      </section>
      <section id="sect.syslog-action-syntax">
        <title>Syntax der Aktionen</title>

        <sidebar>
          <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Die benannte Pipe, eine beständige Pipe</title>
          <indexterm><primary>benannte Pipe</primary></indexterm>
          <indexterm><primary>Pipe, benannte Pipe</primary></indexterm>

	  <para>Eine benannte Pipe ist eine besondere Dateiart, die wie eine gewöhnliche Pipe funktioniert (die Pipe, die man mit dem Symbol „|“ auf der Befehlszeile erstellt), aber mittels einer Datei. Dieses Vorgehen hat den Vorteil, dass sich so zwei unzusammenhängende Prozesse verknüpfen lassen. Alles, was in eine benannte Pipe geschrieben wird, hält den schreibenden Prozess an, bis ein anderer Prozess die geschriebenen Daten zu lesen versucht. Dieser zweite Prozess liest die Daten, die vom ersten geschrieben wurden, der daraufhin seinen Ablauf wieder aufnehmen kann.</para>

	  <para>Eine derartige Datei wird durch den Befehl <command>mkfifo</command> erstellt.</para>
        </sidebar>

	<para>Die verschiedenen möglichen Aktionen sind:</para>
        <itemizedlist>
          <listitem>
	    <para>die Meldung zu einer Datei hinzufügen (Beispiel: <filename>/var/log/messages</filename>);</para>
          </listitem>
          <listitem>
	    <para>die Meldung an einen entfernten <command>syslog</command>-Server schicken (Beispiel: <literal>@log.falcot.com</literal>);</para>
          </listitem>
          <listitem>
	    <para>die Meldung an eine bestehende benannte Pipe schicken (Beispiel: <literal>|/dev/xconsole</literal>);</para>
          </listitem>
          <listitem>
	    <para>die Meldung an einen oder mehrere Benutzer schicken, falls sie angemeldet sind (Beispiel: <literal>root,rhertzog</literal>);</para>
          </listitem>
          <listitem>
	    <para>die Meldung an alle angemeldeten Benutzer schicken (Beispiel: <literal>*</literal>);</para>
          </listitem>
          <listitem>
	    <para>die Nachricht in eine Textkonsole schreiben (Beispiel: <literal>/dev/tty8</literal>).</para>
          </listitem>
        </itemizedlist>

        <sidebar>
          <title><emphasis>SICHERHEIT</emphasis> Protokolle weiterleiten</title>
          <indexterm><primary>Protokoll</primary><secondary>weiterleiten</secondary></indexterm>

	  <para>Es empfiehlt sich, die wichtigsten Protokolle auf einem getrennten Rechner aufzuzeichnen (vielleicht auf einem, der speziell diesem Zweck dient), da dies einen möglichen Eindringling daran hindert, Spuren seines Eindringens zu verwischen (es sei denn natürlich, dass er auch diesen anderen Server kompromittiert). Außerdem sind im Falle eines wesentlichen Problems (wie einem Kernel-Crash) die Protokolle auf einem anderen Rechner verfügbar, was die Chancen erhöht, den Ablauf der Ereignisse, die den Crash verursacht haben, zu bestimmen.</para>

	  <para>Für den Empfang von Protokollmeldungen, die von anderen Rechnern geschickt werden, müssen Sie die Konfiguration von <emphasis>rsyslog</emphasis> ändern: im Prinzip reicht es aus, die gebrauchsfertigen Einträge in <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> und <literal>$UDPServerRun 514</literal>) zu aktivieren.</para>
        </sidebar>
      </section>
    </section>
  </section>
  <section id="sect.inetd">
    <title>Der Superserver <command>inetd</command></title>

    <para>Inetd (häufig „Internet-Superserver“ genannt) ist ein Server der Server. Er führt selten genutzte Server nach Bedarf aus, so dass sie nicht ständig laufen müssen.</para>
    <indexterm><primary><command>inetd</command></primary></indexterm>
    <indexterm><primary>Superserver</primary></indexterm>

    <para>Die Datei <filename>/etc/inetd.conf</filename> listet diese Server und ihre üblichen Ports auf. Der Befehl <command>inetd</command> wartet an allen diesen Ports auf Anfragen; wenn er eine Verbindung zu einem dieser Ports entdeckt, führt er das entsprechende Serverprogramm aus.</para>

    <sidebar>
      <title><emphasis>DEBIAN-RICHTLINIEN</emphasis> Einen Server in <filename>inetd.conf</filename> registrieren</title>

      <para>Häufig möchten Pakete einen neuen Server in der Datei <filename>/etc/inetd.conf</filename> registrieren, aber die Debian-Richtlinien verbieten es einem Paket, eine Konfigurationsdatei zu verändern, die ihm nicht gehört. Deshalb wurde das <command>update-inetd</command>-Skript (in dem gleichnamigen Paket) geschaffen: es verwaltet die Konfigurationsdatei, und andere Pakete können es daher benutzen, um einen neuen Server bei der Konfiguration des Superservers zu registrieren.</para>
    </sidebar>

    <para>Jede bedeutende Zeile der Datei <filename>/etc/inetd.conf</filename> beschreibt einen Server in sieben Feldern (getrennt durch Leerzeichen):</para>
    <itemizedlist>
      <listitem>
	<para>Die TCP- oder UDP-Portnummer oder der Dienstname (der einer Standardportnummer mit der Information, die in der Datei <filename>/etc/services</filename> enthalten ist, zugeordnet ist).</para>
      </listitem>
      <listitem>
	<para>Der Socket-Typ: <literal>stream</literal> für eine TCP-Verbindung, <literal>dgram</literal> für UDP-Datagramme.</para>
      </listitem>
      <listitem>
	<para>Das Protokoll: <literal>tcp</literal> oder <literal>udp</literal>.</para>
      </listitem>
      <listitem>
	<para>Die Optionen: zwei mögliche Werte: <literal>wait</literal> oder <literal>nowait</literal>, um <command>inetd</command> mitzuteilen, ob er auf das Ende des gestarteten Prozesses warten soll, bevor er eine andere Verbindung annimmt oder nicht. Für TCP-Verbindungen, die einen Kanal leicht mehrfach nutzen können, können Sie normalerweise <literal>nowait</literal> verwenden. Für Programme, die über UDP antworten, sollten Sie <literal>nowait</literal> nur dann verwenden, wenn der Server in der Lage ist, mehrere Verbindungen parallel zu verwalten. Sie können an dieses Feld einen Punkt anhängen, gefolgt von der Höchstzahl der Verbindungen, die pro Minute erlaubt ist (der Standardgrenzwert ist 256).</para>
      </listitem>
      <listitem>
	<para>Der Benutzername des Benutzers, unter dessen Identität der Server laufen wird.</para>
      </listitem>
      <listitem>
	<para>Der vollständige Pfad zu dem auszuführenden Serverprogramm.</para>
      </listitem>
      <listitem>
	<para>Die Argumente: dies ist eine vollständige Liste der Argumente des Programms einschließlich seines eigenen Namens (<literal>argv[0]</literal> in C).</para>
      </listitem>
    </itemizedlist>

    <para>Das folgende Beispiel illustriert die häufigsten Fälle:</para>

    <example id="example.inetd-conf">
      <title>Auszug aus <filename>/etc/inetd.conf</filename></title>

      <programlisting>talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd
finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd
ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i</programlisting>
    </example>
    <indexterm><primary><command>tcpd</command></primary></indexterm>

    <para>Das Programm <command>tcpd</command> wird in <filename>/etc/inetd.conf</filename> häufig benutzt. Es ermöglicht ankommende Verbindungen durch die Verwendung von Zugangskontrollregeln einzuschränken, die auf der Handbuchseite <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry> dokumentiert sind, und die in den Dateien <filename>/etc/hosts.allow</filename> und <filename>/etc/hosts.deny</filename> konfiguriert sind. Sobald feststeht, dass die Verbindung autorisiert ist, führt <command>tcpd</command> den eigentlich zuständigen Server aus (wie <command>/usr/bin/in.fingerd</command> in unserem Beispiel). Es ist erwähnenswert, dass <command>tcpd</command> auf den Namen zurückgreift, mit welchem es aufgerufen wurde (das ist das erste Argument, <literal>argv[0]</literal>), um das tatsächlich auszuführende Programm zu ermitteln. Sie sollten deshalb die Parameterliste nicht mit <literal>tcpd</literal> beginnen, sondern mit dem Programm, zu dem umgeleitet werden soll.</para>

    <sidebar>
      <title><emphasis>GEMEINSCHAFT</emphasis> Wietse Venema</title>
      <indexterm><primary>Wietse Venema</primary></indexterm>
      <indexterm><primary>Venema, Wietse</primary></indexterm>

      <para>Wietse Venema, dessen Fachkenntnis im Bereich Sicherheit ihn zu einem angesehenen Programmierer gemacht hat, ist der Verfasser des <command>tcpd</command>-Programms. Er ist auch der Haupturheber von Postfix, dem modularen E-Mail-Server (SMTP, Simple Mail Transfer Protocol), der dafür ausgelegt ist, sicherer und verlässlicher zu sein als <command>sendmail</command>, das sich durch eine lange Vorgeschichte von Sicherheitsschwachstellen auszeichnet.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> Weitere <command>inetd</command> Befehle</title>

      <para>Debian installiert zwar standardmäßig <emphasis role="pkg">openbsd-inetd</emphasis>, aber es gibt genügend Alternativen: <emphasis role="pkg">inetutils-inetd</emphasis>, <emphasis role="pkg">micro-inetd</emphasis>, <emphasis role="pkg">rlinetd</emphasis> and <emphasis role="pkg">xinetd</emphasis>, um nur einige zu nennen.</para>

      <para>Diese jüngste Verkörperung eines Superservers bietet sehr interessante Möglichkeiten. Dazu gehört vor allem, dass seine Konfiguration in mehrere Dateien aufgeteilt werden kann (die natürlich im Verzeichnis <filename>/etc/xinetd.d/</filename> gespeichert werden), wodurch das Leben eines Administrators erleichtert werden kann.</para>

      <para>Nicht zuletzt ist es sogar möglich, das Verhalten von <command>inetd</command> mit <command>systemd</command>s Socket-Aktivierungsmechanismus nachzubilden (siehe <xref linkend="sect.systemd" />).</para>
    </sidebar>
  </section>
  <section id="sect.task-scheduling-cron-atd">
    <title>Aufgaben mit <command>cron</command> und <command>atd</command> zeitlich festlegen</title>
    <indexterm><primary><command>cron</command></primary></indexterm>
    <indexterm><primary><command>atd</command></primary></indexterm>
    <indexterm><primary>zeitlich geplante Befehle</primary></indexterm>
    <indexterm><primary>Befehle zeitlich planen</primary></indexterm>

    <para><command>cron</command> ist der für die Ausführung zeitlich geplanter und sich wiederholender Befehle (täglich, wöchentlich usw.) zuständige Daemon; <command>atd</command> erledigt nur einmal auszuführende Befehle, jedoch zu einem bestimmten Zeitpunkt in der Zukunft.</para>

    <para>In einem Unix-System sind viele Aufgaben für eine regelmäßige Ausführung zeitlich geplant:</para>
    <itemizedlist>
      <listitem>
	<para>die Protokolldateien rotieren;</para>
      </listitem>
      <listitem>
	<para>die Datenbank für das Programm <command>locate</command> aktualisieren;</para>
      </listitem>
      <listitem>
	<para>Daten sichern;</para>
      </listitem>
      <listitem>
	<para>Wartungsskripten ausführen (wie das Entfernen temporärer Dateien).</para>
      </listitem>
    </itemizedlist>

    <para>Standardmäßig können alle Benutzer die Ausführung von Aufgaben planen. Daher hat jeder Benutzer sein eigenes <emphasis>crontab</emphasis>, in dem er seine geplanten Befehle eintragen kann. Es kann mit dem Aufruf von <command>crontab -e</command> editiert werden (sein Inhalt ist in der Datei <filename>/var/spool/cron/crontabs/<replaceable>benutzer</replaceable></filename> gespeichert).</para>

    <sidebar>
      <title><emphasis>SICHERHEIT</emphasis> <command>cron</command> und <command>atd</command> einschränken</title>

      <para>Sie können den Zugriff auf <command>cron</command> einschränken, indem Sie eine ausdrückliche Autorisierungsdatei (Whitelist) in <filename>/etc/cron.allow</filename> anlegen, in der Sie nur diejenigen Benutzer angeben, denen es erlaubt ist, Befehle zeitlich zu planen. Allen übrigen wird diese Fähigkeit automatisch entzogen. Um im umgekehrten Fall ein oder zwei Störenfriede auszusperren, können Sie ihre Benutzernamen in die ausdrückliche Verbotsliste (Blacklist) <filename>/etc/cron.deny</filename> eintragen. Das gleiche Merkmal steht auch für <command>atd</command> mit den Dateien <filename>/etc/at.allow</filename> und <filename>/etc/at.deny</filename> zur Verfügung.</para>
    </sidebar>

    <para>Der Root-Benutzer hat sein eigenes <emphasis>crontab</emphasis>, kann aber auch die Datei <filename>/etc/crontab</filename> benutzen oder zusätzliche <emphasis>crontab</emphasis>-Dateien in das Verzeichnis <filename>/etc/cron.d</filename> eintragen. Die beiden letztgenannten Lösungen haben den Vorteil, dass man mit ihnen die Benutzeridentität spezifizieren kann, die bei der Ausführung des Befehls verwendet werden muss.</para>

    <para>Das Paket <emphasis>cron</emphasis> enthält standardmäßig einige zeitlich geplante Befehle, die folgendes ausführen:</para>
    <itemizedlist>
      <listitem>
	<para>stündlich Programme im Verzeichnis <filename>/etc/cron.hourly/</filename>;</para>
      </listitem>
      <listitem>
	<para>täglich Programme in <filename>/etc/cron.daily/</filename>;</para>
      </listitem>
      <listitem>
	<para>wöchentlich Programme in <filename>/etc/cron.weekly/</filename>;</para>
      </listitem>
      <listitem>
	<para>monatlich Programme in <filename>/etc/cron.monthly/</filename>.</para>
      </listitem>
    </itemizedlist>

    <para>Viele Debian-Pakete sind auf diesen Dienst angewiesen: indem sie Wartungsskripten in diese Verzeichnisse legen, stellen sie den optimalen Betrieb ihrer Dienste sicher.</para>
    <section id="sect.format-crontab">
      <title>Aufbau der Datei <filename>crontab</filename></title>
      <indexterm><primary><filename>crontab</filename></primary></indexterm>

      <sidebar>
        <title><emphasis>TIPP</emphasis> Abkürzungen für <command>cron</command></title>

	<para><command>cron</command> erkennt einige Abkürzungen, die die ersten fünf Felder eines <filename>crontab</filename>-Eintrags ersetzen. Sie entsprechen den üblichsten Optionen für die Zeitplanung:</para>
        <itemizedlist>
          <listitem>
	    <para><literal>@yearly</literal>: jährlich (1. Januar um 00:00 Uhr);</para>
          </listitem>
          <listitem>
	    <para><literal>@monthly</literal>: monatlich (am Ersten des Monats um 00:00 Uhr);</para>
          </listitem>
          <listitem>
	    <para><literal>@weekly</literal>: wöchentlich (sonntags um  00:00 Uhr);</para>
          </listitem>
          <listitem>
	    <para><literal>@daily</literal>: täglich (um 00:00 Uhr);</para>
          </listitem>
          <listitem>
	    <para><literal>@hourly</literal>: stündlich (zu Beginn jeder Stunde).</para>
          </listitem>
        </itemizedlist>
      </sidebar>

      <sidebar>
        <title><emphasis>SONDERFALL</emphasis> <command>cron</command> und Sommerzeit</title>

	<para>In Debian berücksichtigt <command>cron</command> die Zeitumstellung (für die Sommerzeit oder genau genommen für jede bedeutende Änderung der Ortszeit) so gut wie möglich. So werden die Befehle, die während einer nicht existenten Stunde hätten ausgeführt werden sollen (zum Beispiel Aufgaben, die für 02:30 Uhr während der Zeitumstellung im Frühjahr geplant waren, da die Uhr um 02:00 Uhr direkt auf 03:00 Uhr springt), kurz nach der Zeitumstellung (das heißt um 03:00 Uhr Sommerzeit) ausgeführt. Andererseits werden Befehle im Herbst, wenn sie mehrmals ausgeführt würden (um 02:30 Uhr Sommerzeit und dann wieder eine Stunde später um 02:30 Uhr Normalzeit, da die Uhr um 03:00 Uhr Sommerzeit auf 02:00 Uhr zurückspringt), nur einmal ausgeführt.</para>

	<para>Seien Sie jedoch vorsichtig: wenn die Reihenfolge, in der verschiedene geplante Aufgaben ausgeführt werden, und die Verzögerung zwischen den jeweiligen Ausführungszeitpunkten eine Rolle spielt, sollten Sie die Kompatibilität dieser Einschränkungen mit dem Verhalten von <command>cron</command> überprüfen; falls erforderlich, können Sie einen speziellen Zeitplan für die beiden problematischen Nächte des Jahres aufstellen.</para>
      </sidebar>

      <para>Jede wesentliche Zeile eines <emphasis>crontab</emphasis> legt einen zeitlich festgelegten Befehl mit den folgenden sechs (oder sieben) Feldern fest:</para>
      <itemizedlist>
        <listitem>
	  <para>den Wert für die Minute (Zahl von 0 bis 59);</para>
        </listitem>
        <listitem>
	  <para>den Wert für die Stunde (von 0 bis 23);</para>
        </listitem>
        <listitem>
	  <para>den Wert für den Tag des Monats (von 1 bis 31);</para>
        </listitem>
        <listitem>
	  <para>den Wert für den Monat (von 1 bis 12);</para>
        </listitem>
        <listitem>
	  <para>den Wert für den Wochentag (von 0 bis 7, wobei 1 dem Montag entspricht und Sonntag sowohl durch 0 als auch durch 7 dargestellt wird; es ist auch möglich, die ersten drei Buchstaben des englischen Namens des Wochentages zu verwenden, wie <literal>Sun</literal>, <literal>Mon</literal>, usw.);</para>
        </listitem>
        <listitem>
	  <para>den Benutzernamen, unter dessen Identität der Befehl ausgeführt werden muss (in der Datei <filename>/etc/crontab</filename> und in den Fragmenten, die sich in <filename>/etc/cron.d/</filename> befinden, aber nicht in den eigenen crontab-Dateien des Benutzers);</para>
        </listitem>
        <listitem>
	  <para>den auszuführenden Befehl (wenn die durch die ersten fünf Spalten festgelegten Bedingungen erfüllt sind).</para>
        </listitem>
      </itemizedlist>

      <para>Alle diese Einzelheiten sind auf der Handbuchseite <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> dokumentiert.</para>

      <para>Jeder Wert kann in Form einer Liste der möglichen Werte (durch Kommata getrennt) angegeben werden. Die Syntax <literal>a-b</literal> bezeichnet das Intervall aller Werte zwischen <literal>a</literal> und <literal>b</literal>. Die Syntax <literal>a-b/c</literal> bezeichnet das Intervall mit einer schrittweisen Erhöhung um <literal>c</literal> (Beispiel: <literal>0-10/2</literal> bedeutet <literal>0,2,4,6,8,10</literal>). Ein Stern <literal>*</literal> ist ein Platzhalter, der alle möglichen Werte vertritt.</para>

      <example id="example.crontab">
        <title>Beispiel einer <filename>crontab</filename>-Datei</title>

        <programlisting>#Format
#Minute Stunde Tag Monat Wochentag  Befehl

# Daten jeden Abend um 19:25 Uhr herunterladen
 25  19   *   *   *    $HOME/bin/get.pl

# Werktags (Montag bis Freitag) um 8:00 Uhr
 00  08   *   *   1-5  $HOME/bin/tu_etwas

# Den IRC-Proxy nach jedem Hochfahren neu starten
@reboot /usr/bin/dircproxy</programlisting>
      </example>

      <sidebar>
        <title><emphasis>TIPP</emphasis> Einen Befehl beim Hochfahren ausführen</title>

	<para>Um einen Befehl unmittelbar nach dem Hochfahren des Rechners einmal auszuführen, können Sie das Makro <literal>@reboot</literal> verwenden (ein einfacher Neustart von <command>cron</command> löst keinen Befehl aus, der mit <literal>@reboot</literal> eingerichtet worden ist). Dieses Makro ersetzt die ersten fünf Felder eines <emphasis>crontab</emphasis>-Eintrags.</para>
      </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> <command>cron</command> mit <command>systemd</command> emulieren</title>

      <para>Es ist möglich, einen Teil des Verhaltens von <command>cron</command> mit <command>systemd</command>s Timermechanismus nachzubilden (siehe <xref linkend="sect.systemd" />).</para>
    </sidebar>

    </section>
    <section id="sect.at-command">
      <title>Verwendung des Befehls <command>at</command></title>
      <indexterm><primary><command>at</command></primary></indexterm>

      <para><command>at</command> führt einen Befehl zu einem festgelegten Zeitpunkt in der Zukunft aus. Es nimmt in seiner Standardeingabe die gewünschte Zeit und das gewünschte Datum sowie den auszuführenden Befehl als Befehlszeilenparameter an. Der Befehl wird dann ausgeführt, als sei er in der aktuellen Shell eingegeben worden. <command>at</command> sorgt sogar dafür, dass die gegenwärtige Umgebungseinstellung festgehalten wird, um die gleichen Bedingungen zu reproduzieren, wenn es den Befehl ausführt. Die Zeit wird nach folgenden Regeln eingegeben: <literal>16:12</literal> oder <literal>4:12pm</literal> bedeuten 16:12 Uhr. Das Datum kann in verschiedenen europäischen und westlichen Formaten angegeben werden, unter anderem als <literal>DD.MM.YY</literal> (<literal>27.07.15</literal>, also dem 27. Juli 2015 entsprechend), <literal>YYYY-MM-DD</literal> (was dasselbe Datum in der Form <literal>2015-07-27</literal> ist), <literal>MM/DD/[CC]YY</literal> (d.h. <literal>12/25/15</literal> oder <literal>12/25/2015</literal> ist der 25. Dezember 2015) oder einfach <literal>MMDD[CC]YY</literal> (so dass <literal>122515</literal> oder <literal>12252015</literal> jeweils den 25. Dezember 2015 darstellen). Ohne diese Angabe wird der Befehl ausgeführt, sobald die Uhr die angegebene Zeit erreicht (am selben Tag oder morgen, falls diese Zeit am selben Tag bereits vorüber ist). Sie können auch einfach „today“ oder „tomorrow“ schreiben, was selbsterklärend ist.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>
<computeroutput>&gt; </computeroutput><userinput>echo "Heute hat Raphaël Geburtstag!" \</userinput>
<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>
<computeroutput>&gt; </computeroutput><userinput>END</userinput>
<computeroutput>warning: commands will be executed using /bin/sh
job 31 at Mon Jul 27 09:00:00 2015</computeroutput></screen>

      <para>Eine andere Syntax verschiebt die Ausführung um eine bestimmte Zeit: <command>at now + <replaceable>Zahl</replaceable> <replaceable>Dauer</replaceable></command>. Die <replaceable>Dauer</replaceable> kann <literal>minutes</literal>, <literal>hours</literal>, <literal>days</literal> oder <literal>weeks</literal> sein. Die <replaceable>Zahl</replaceable> zeigt lediglich die Anzahl der genannten Einheiten an, die vor der Ausführung des Befehls verstrichen sein müssen.</para>

      <para>Um eine mit <command>cron</command> geplante Aufgabe zu annullieren, führen Sie einfach <command>crontab -e</command> aus und löschen die entsprechende Zeile in der <emphasis>crontab</emphasis>-Datei. Für <command>at</command>-Aufgaben ist es fast genauso einfach: Führen Sie <command>atrm <replaceable>Aufgabennummer</replaceable></command> aus. Die Nummer einer Aufgabe wird vom <command>at</command>-Befehl angezeigt, wenn Sie sie planen, aber Sie können sie auch mit dem Befehl <command>atq</command> wiederfinden, der die aktuelle Liste der geplanten Aufgaben ausgibt.</para>
      <indexterm><primary><command>atrm</command></primary></indexterm>
      <indexterm><primary><command>atq</command></primary></indexterm>
    </section>
  </section>
  <section id="sect.asynchronous-task-scheduling-anacron">
    <title>Asynchrone Aufgaben planen: <command>anacron</command></title>

    <para><command>anacron</command> ist ein Daemon, der <command>cron</command> für solche Rechner ergänzt, die nicht ständig laufen. Da regelmäßige Aufgaben normalerweise für die Nacht geplant sind, werden sie nie ausgeführt, falls der Rechner zu dieser Zeit ausgeschaltet ist. Der Zweck von <command>anacron</command> besteht darin, sie unter Berücksichtigung der Zeiten, in denen der Rechner nicht läuft, auszuführen.</para>
    <indexterm><primary><command>anacron</command></primary></indexterm>

    <para>Bitte beachten Sie, dass <command>anacron</command> derartige Aktivitäten häufig einige Minuten nach dem Hochfahren des Rechners ausführen wird, wodurch der Computer langsamer reagieren kann. Daher werden Aufgaben in der Datei <filename>/etc/anacrontab</filename> mit dem Befehl <command>nice</command> gestartet, der ihre Ausführungspriorität reduziert und so ihren Einfluss auf das übrige System begrenzt. Vorsicht, das Format dieser Datei ist nicht das gleiche wie <filename>/etc/crontab</filename>; falls Sie besondere Anforderungen an <command>anacron</command> haben, sehen Sie auf der Handbuchseite <citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> nach.</para>

    <sidebar>
      <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Prioritäten und der Befehl <command>nice</command></title>

      <para>Unix-Systeme (und damit auch Linux) sind Mehrprogramm- und Mehrplatzsysteme. So können mehrere Prozesse parallel laufen und verschiedenen Benutzern gehören: der Kernel vermittelt die Ressourcenzuweisung zwischen den verschiedenen Prozessen. Als Teil dieser Aufgabe verfügt er über ein Prioritätenkonzept, das es ihm erlaubt, je nach Bedarf bestimmte Prozesse gegenüber anderen zu bevorzugen. Wenn Sie wissen, dass ein Prozess mit geringer Priorität laufen kann, können Sie dies angeben, indem Sie ihn mit <command>nice <replaceable>programm</replaceable></command> laufen lassen. Das Programm wird dann einen geringeren Anteil an der CPU-Zeit nutzen und weniger Auswirkungen auf andere laufende Prozesse haben. Natürlich wird das Programm nicht künstlich zurückgehalten, falls kein anderer Prozess laufen muss.</para>

      <para><command>nice</command> arbeitet mit Stufen von „niceness“: die positiven Stufen (von 1 bis 19) verringern zunehmend die Priorität, während die negativen Stufen (von -1 bis -20) sie erhöhen - aber nur Root kann diese negativen Stufen benutzen. Falls nichts anderes angegeben ist (siehe die Handbuchseite <citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry>), erhöht <command>nice</command> die aktuelle Stufe um 10.</para>

      <para>Falls Sie bemerken, dass eine bereits laufende Aufgabe mit <command>nice</command> hätte gestartet werden sollen, ist es nicht zu spät, dies zu korrigieren; der Befehl <command>renice</command> ändert die Priorität eines bereits laufenden Prozesses in die eine oder andere Richtung (es ist jedoch dem Root-Benutzer vorbehalten, die „niceness“ eines Prozesses zu reduzieren).</para>
    </sidebar>

    <para>Installation of the <emphasis role="pkg">anacron</emphasis>
    package deactivates execution by <command>cron</command> of the scripts
    in the <filename>/etc/cron.hourly/</filename>,
    <filename>/etc/cron.daily/</filename>,
    <filename>/etc/cron.weekly/</filename>, and
    <filename>/etc/cron.monthly/</filename> directories. This avoids their
    double execution by <command>anacron</command> and
    <command>cron</command>. The <command>cron</command> command remains
    active and will continue to handle the other scheduled tasks
    (especially those scheduled by users).</para>
  </section>
  <section id="sect.quotas">
    <title>Quotas</title>
    <indexterm><primary>kontingent</primary></indexterm>

    <para>The quota system allows limiting disk space allocated to a user
    or group of users. To set it up, you must have a kernel that supports
    it (compiled with the <varname>CONFIG_QUOTA</varname> option) — as is
    the case with Debian kernels. The quota management software is found in
    the <emphasis role="pkg">quota</emphasis> Debian package.</para>

    <para>To activate quota in a filesystem, you have to indicate the
    <literal>usrquota</literal> and <literal>grpquota</literal> options in
    <filename>/etc/fstab</filename> for the user and group quotas,
    respectively. Rebooting the computer will then update the quotas in the
    absence of disk activity (a necessary condition for proper accounting
    of already used disk space).</para>

    <para>The <command>edquota <replaceable>user</replaceable></command>
    (or <command>edquota -g <replaceable>group</replaceable></command>)
    command allows you to change the limits while examining current disk
    space usage.</para>
    <indexterm><primary><command>edquota</command></primary></indexterm>

    <sidebar>
      <title><emphasis>GOING FURTHER</emphasis> Defining quotas with a script</title>
      <indexterm><primary><command>setquota</command></primary></indexterm>

      <para>The <command>setquota</command> program can be used in a script
      to automatically change many quotas. Its
      <citerefentry><refentrytitle>setquota</refentrytitle>
      <manvolnum>8</manvolnum></citerefentry> manual page details the
      syntax to use.</para>
    </sidebar>

    <para>The quota system allows you to set four limits:</para>
    <itemizedlist>
      <listitem>
	<para>two limits (called “soft” and “hard”) refer to the
	number of blocks consumed. If the filesystem was created with a
	block-size of 1 kibibyte, a block contains 1024 bytes from the
	same file. Unsaturated blocks thus induce losses of disk space. A
	quota of 100 blocks, which theoretically allows storage of 102,400
	bytes, will however be saturated with just 100 files of 500 bytes
	each, only representing 50,000 bytes in total.</para>
      </listitem>
      <listitem>
	<para>two limits (soft and hard) refer to the number of inodes
	used. Each file occupies at least one inode to store information
	about it (permissions, owner, timestamp of last access, etc.). It
	is thus a limit on the number of user files.</para>
      </listitem>
    </itemizedlist>

    <para>A “soft” limit can be temporarily exceeded; the user will
    simply be warned that they are exceeding the quota by the
    <command>warnquota</command> command, which is usually invoked by
    <command>cron</command>. A “hard” limit can never be exceeded: the
    system will refuse any operation that will cause a hard quota to be
    exceeded.</para>

    <sidebar>
      <title><emphasis>VOCABULARY</emphasis> Blocks and inodes</title>
      <indexterm><primary>block (disk)</primary></indexterm>
      <indexterm><primary>inode</primary></indexterm>

      <para>The filesystem divides the hard drive into blocks — small
      contiguous areas. The size of these blocks is defined during creation
      of the filesystem, and generally varies between 1 and 8
      kibibytes.</para>

      <para>A block can be used either to store the real data of a file, or
      for meta-data used by the filesystem. Among this meta-data, you will
      especially find the inodes. An inode uses a block on the hard drive
      (but this block is not taken into consideration in the block quota,
      only in the inode quota), and contains both the information on the
      file to which it corresponds (name, owner, permissions, etc.) and the
      pointers to the data blocks that are actually used. For very large
      files that occupy more blocks than it is possible to reference in a
      single inode, there is an indirect block system; the inode references
      a list of blocks that do not directly contain data, but another list
      of blocks.</para>
    </sidebar>
    <indexterm><primary><command>warnquota</command></primary></indexterm>

    <para>With the <command>edquota -t</command> command, you can define a
    maximum authorized “grace period” within which a soft limit may be
    exceeded. After this period, the soft limit will be treated like a
    hard limit, and the user will have to reduce their disk space usage to
    within this limit in order to be able to write anything to the hard
    drive.</para>

    <sidebar>
      <title><emphasis>GOING FURTHER</emphasis> Setting up a default quota for new users</title>

      <para>To automatically setup a quota for new users, you have to
      configure a template user (with <command>edquota</command> or
      <command>setquota</command>) and indicate their user name in the
      <varname>QUOTAUSER</varname> variable in the
      <filename>/etc/adduser.conf</filename> file. This quota configuration
      will then be automatically applied to each new user created with the
      <command>adduser</command> command.</para>
    </sidebar>
  </section>
  <section id="sect.backup">
    <title>Datensicherung</title>

    <para>Making backups is one of the main responsibilities of any
    administrator, but it is a complex subject, involving powerful tools
    which are often difficult to master.</para>
    <indexterm><primary>backup</primary></indexterm>
    <indexterm><primary>restoration</primary></indexterm>

    <para>Many programs exist, such as <command>amanda</command>,
    <command>bacula</command>, <command>BackupPC</command>. Those
    are client/server system featuring many options, whose configuration is
    rather difficult. Some of them provide user-friendly web interfaces
    to mitigate this. But Debian contains dozens of other
    backup software covering all possible use cases, as you can easily confirm
    with <command>apt-cache search backup</command>.</para>
    <indexterm><primary><command>amanda</command></primary></indexterm>
    <indexterm><primary><command>bacula</command></primary></indexterm>
    <indexterm><primary><command>BackupPC</command></primary></indexterm>

    <para>Rather than detailing some of them, this section will present the
    thoughts of the Falcot Corp administrators when they defined their
    backup strategy.</para>

    <para>At Falcot Corp, backups have two goals: recovering erroneously
    deleted files, and quickly restoring any computer (server or desktop)
    whose hard drive has failed.</para>
    <section>
      <title>Backing Up with <command>rsync</command></title>

      <para>Backups on tape having been deemed too slow and costly, data
      will be backed up on hard drives on a dedicated server, on which the
      use of software RAID (see <xref linkend="sect.raid-soft" />) will
      protect the data from hard drive failure. Desktop computers are not
      backed up individually, but users are advised that their personal
      account on their department's file server will be backed up. The
      <command>rsync</command> command (from the package of the same name)
      is used daily to back up these different servers.</para>
      <indexterm><primary><command>rsync</command></primary></indexterm>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> The hard link, a second name for the file</title>
        <indexterm><primary>link</primary><secondary>hard link</secondary></indexterm>
        <indexterm><primary>hard link</primary></indexterm>

	<para>A hard link, as opposed to a symbolic link, cannot be
	differentiated from the linked file. Creating a hard link is
	essentially the same as giving an existing file a second name. This
	is why the deletion of a hard link only removes one of the names
	associated with the file. As long as another name is still assigned
	to the file, the data therein remain present on the filesystem. It
	is interesting to note that, unlike a copy, the hard link does not
	take up additional space on the hard drive.</para>

	<para>A hard link is created with the <command>ln
	<replaceable>target</replaceable>
	<replaceable>link</replaceable></command> command. The
	<replaceable>link</replaceable> file is then a new name for the
	<replaceable>target</replaceable> file. Hard links can only be
	created on the same filesystem, while symbolic links are not
	subject to this limitation.</para>
      </sidebar>

      <para>The available hard drive space prohibits implementation of a
      complete daily backup. As such, the <command>rsync</command> command
      is preceded by a duplication of the content of the previous backup
      with hard links, which prevents usage of too much hard drive space.
      The <command>rsync</command> process then only replaces files that
      have been modified since the last backup. With this mechanism a great
      number of backups can be kept in a small amount of space. Since all
      backups are immediately available and accessible (for example, in
      different directories of a given share on the network), you can
      quickly make comparisons between two given dates.</para>
      <indexterm><primary>copy, backup copy</primary></indexterm>
      <indexterm><primary>backup</primary><secondary>copy</secondary></indexterm>
      <indexterm><primary><emphasis role="pkg">dirvish</emphasis></primary></indexterm>

      <para>This backup mechanism is easily implemented with the
      <command>dirvish</command> program. It uses a backup storage space
      (“bank” in its vocabulary) in which it places timestamped copies
      of sets of backup files (these sets are called “vaults” in the
      dirvish documentation).</para>

      <para>The main configuration is in the
      <filename>/etc/dirvish/master.conf</filename> file. It defines the
      location of the backup storage space, the list of “vaults” to
      manage, and default values for expiration of the backups. The rest of
      the configuration is located in the
      <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename>
      files and contains the specific configuration for the corresponding
      set of files.</para>

      <example id="example.dirvish-master">
        <title>The <filename>/etc/dirvish/master.conf</filename> file</title>

        <programlisting>bank:
    /backup
exclude:
    lost+found/
    core
    *~
Runall:
    root    22:00
expire-default: +15 days
expire-rule:
#   MIN HR    DOM MON       DOW  STRFTIME_FMT
    *   *     *   *         1    +3 months
    *   *     1-7 *         1    +1 year
    *   *     1-7 1,4,7,10  1
</programlisting>
      </example>

      <para>The <literal>bank</literal> setting indicates the directory in
      which the backups are stored. The <literal>exclude</literal> setting
      allows you to indicate files (or file types) to exclude from the
      backup. The <literal>Runall</literal> is a list of file sets to
      backup with a time-stamp for each set, which allows you to assign the
      correct date to the copy, in case the backup is not triggered at
      precisely the assigned time. You have to indicate a time just before
      the actual execution time (which is, by default, 10:04 pm in Debian,
      according to <filename>/etc/cron.d/dirvish</filename>). Finally, the
      <literal>expire-default</literal> and <literal>expire-rule</literal>
      settings define the expiration policy for backups. The above example
      keeps forever backups that are generated on the first Sunday of each
      quarter, deletes after one year those from the first Sunday of each
      month, and after 3 months those from other Sundays. Other daily
      backups are kept for 15 days. The order of the rules does matter,
      Dirvish uses the last matching rule, or the
      <literal>expire-default</literal> one if no other
      <literal>expire-rule</literal> matches.</para>

      <sidebar>
        <title><emphasis>IN PRACTICE</emphasis> Scheduled expiration</title>

	<para>The expiration rules are not used by
	<command>dirvish-expire</command> to do its job. In reality, the
	expiration rules are applied when creating a new backup copy to
	define the expiration date associated with that copy.
	<command>dirvish-expire</command> simply peruses the stored copies
	and deletes those for which the expiration date has passed.</para>
      </sidebar>

      <example id="example.dirvish-vault">
        <title>The <filename>/backup/root/dirvish/default.conf</filename> file</title>

        <programlisting>client: rivendell.falcot.com
tree: /
xdev: 1
index: gzip
image-default: %Y%m%d
exclude:
    /var/cache/apt/archives/*.deb
    /var/cache/man/**
    /tmp/**
    /var/tmp/**
    *.bak
</programlisting>
      </example>

      <para>The above example specifies the set of files to back up: these
      are files on the machine <emphasis>rivendell.falcot.com</emphasis>
      (for local data backup, simply specify the name of the local machine
      as indicated by <command>hostname</command>), especially those in the
      root tree (<literal>tree: /</literal>), except those listed in
      <literal>exclude</literal>. The backup will be limited to the
      contents of one filesystem (<literal>xdev: 1</literal>). It will not
      include files from other mount points. An index of saved files will
      be generated (<literal>index: gzip</literal>), and the image will be
      named according to the current date (<literal>image-default:
      %Y%m%d</literal>).</para>

      <para>There are many options available, all documented in the
      <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry>
      manual page. Once these configuration files are setup, you have to
      initialize each file set with the <command>dirvish --vault
      <replaceable>vault</replaceable> --init</command> command. From there
      on the daily invocation of <command>dirvish-runall</command> will
      automatically create a new backup copy just after having deleted
      those that expired.</para>

      <sidebar>
        <title><emphasis>IN PRACTICE</emphasis> Remote backup over SSH</title>

	<para>When dirvish needs to save data to a remote machine, it will
	use <command>ssh</command> to connect to it, and will start
	<command>rsync</command> as a server. This requires the root user
	to be able to automatically connect to it. The use of an SSH
	authentication key allows precisely that (see <xref linkend="sect.ssh-key-based-auth" />).</para>
      </sidebar>
    </section>
    <section>
      <title>Restoring Machines without Backups</title>

      <para>Desktop computers, which are not backed up, will be easy to
      reinstall from custom DVD-ROMs prepared with <emphasis>Simple-CDD</emphasis>
      (see <xref linkend="sect.simple-cdd" />). Since this performs
      an installation from scratch, it loses any customization that can have
      been made after the initial installation. This is fine since
      the systems are all hooked to a central LDAP directory for
      accounts and most desktop applications are preconfigured
      thanks to dconf (see <xref linkend="sect.gnome-desktop" />
      for more information about this).</para>

      <para>The Falcot Corp administrators are aware of the limits in their
      backup policy. Since they can't protect the backup server as well as
      a tape in a fireproof safe, they have installed it in a separate room
      so that a disaster such as a fire in the server room won't destroy
      backups along with everything else. Furthermore, they do an
      incremental backup on DVD-ROM once per week — only files that have
      been modified since the last backup are included.</para>

      <sidebar>
        <title><emphasis>GOING FURTHER</emphasis> Backing up SQL and LDAP services</title>

	<para>Many services (such as SQL or LDAP databases) cannot be
	backed up by simply copying their files (unless they are properly
	interrupted during creation of the backups, which is frequently
	problematic, since they are intended to be available at all times).
	As such, it is necessary to use an “export” mechanism to create
	a “data dump” that can be safely backed up. These are often
	quite large, but they compress well. To reduce the storage space
	required, you will only store a complete text file per week, and a
	<command>diff</command> each day, which is created with a command
	of the type <command>diff
	<replaceable>file_from_yesterday</replaceable>
	<replaceable>file_from_today</replaceable></command>. The
	<command>xdelta</command> program produces incremental differences
	from binary dumps.</para>
        <indexterm><primary><command>xdelta</command></primary></indexterm>
        <indexterm><primary><command>diff</command></primary></indexterm>
        <indexterm><primary>dump</primary></indexterm>
      </sidebar>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> <emphasis>TAR</emphasis>, the standard for tape backups</title>
        <indexterm><primary>backup</primary><secondary>on tape</secondary></indexterm>
        <indexterm><primary>tape, backup</primary></indexterm>
        <indexterm><primary>TAR</primary></indexterm>

	<para>Historically, the simplest means of making a backup on Unix
	was to store a <emphasis>TAR</emphasis> archive on a tape. The
	<command>tar</command> command even got its name from “Tape
	ARchive”.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.hotplug">
    <title>Hot Plugging: <emphasis>hotplug</emphasis></title>
    <section>
      <title>Introduction</title>

      <para>The <emphasis>hotplug</emphasis> kernel subsystem dynamically
      handles the addition and removal of devices, by loading the appropriate
      drivers and by creating the corresponding device files (with the
      help of <command>udevd</command>). With modern hardware and virtualization,
      almost everything can be hotplugged: from the usual USB/PCMCIA/IEEE 1394
      peripherals to SATA hard drives, but also the CPU and the memory.</para>

      <para>The kernel has a database that associates each device ID
      with the required driver. This database is used during boot to load
      all the drivers for the peripheral devices detected on the different
      buses, but also when an additional hotplug device is
      connected. Once the device is ready for use, a message is sent to
      <command>udevd</command> so it will be able to create the
      corresponding entry in <filename>/dev/</filename>.</para>

      <indexterm><primary><emphasis>hotplug</emphasis></primary></indexterm>
      <indexterm><primary>hotplug</primary></indexterm>
      <indexterm><primary>USB</primary></indexterm>
      <indexterm><primary>IEEE 1394</primary></indexterm>
      <indexterm><primary>PCMCIA</primary></indexterm>
      <indexterm><primary>SATA</primary></indexterm>
    </section>
    <section>
      <title>The Naming Problem</title>

      <para>Before the appearance of hotplug connections, it was easy to
      assign a fixed name to a device. It was based simply on the position
      of the devices on their respective bus. But this is not possible when
      such devices can come and go on the bus. The typical case is the use
      of a digital camera and a USB key, both of which appear to the
      computer as disk drives. The first one connected may be
      <filename>/dev/sdb</filename> and the second
      <filename>/dev/sdc</filename> (with <filename>/dev/sda</filename>
      representing the computer's own hard drive). The device name is not
      fixed; it depends on the order in which devices are connected.</para>

      <para>Additionally, more and more drivers use dynamic values for
      devices' major/minor numbers, which makes it impossible to have
      static entries for the given devices, since these essential
      characteristics may vary after a reboot.</para>

      <para><emphasis>udev</emphasis> was created precisely to solve this
      problem.</para>
    </section>
    <section>
      <title>How <emphasis>udev</emphasis> Works</title>

      <para>When <emphasis>udev</emphasis> is notified by the kernel of the
      appearance of a new device, it collects various information on the
      given device by consulting the corresponding entries in
      <filename>/sys/</filename>, especially those that uniquely identify
      it (MAC address for a network card, serial number for some USB
      devices, etc.).</para>

      <para>Armed with all of this information, <emphasis>udev</emphasis>
      then consults all of the rules contained in
      <filename>/etc/udev/rules.d/</filename> and
      <filename>/lib/udev/rules.d/</filename>. In this process it decides
      how to name the device, what symbolic links to create (to give it
      alternative names), and what commands to execute. All of these files
      are consulted, and the rules are all evaluated sequentially (except
      when a file uses “GOTO” directives). Thus, there may be several
      rules that correspond to a given event.</para>

      <para>The syntax of rules files is quite simple: each row contains
      selection criteria and variable assignments. The former are used to
      select events for which there is a need to react, and the latter
      defines the action to take. They are all simply separated with
      commas, and the operator implicitly differentiates between a
      selection criterion (with comparison operators, such as
      <literal>==</literal> or <literal>!=</literal>) or an assignment
      directive (with operators such as <literal>=</literal>,
      <literal>+=</literal> or <literal>:=</literal>).</para>

      <para>Comparison operators are used on the following
      variables:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>KERNEL</literal>: the name that the kernel assigns
	  to the device;</para>
        </listitem>
        <listitem>
	  <para><literal>ACTION</literal>: the action corresponding to the
	  event (“add” when a device has been added, “remove” when
	  it has been removed);</para>
        </listitem>
        <listitem>
	  <para><literal>DEVPATH</literal>: the path of the device's
	  <filename>/sys/</filename> entry;</para>
        </listitem>
        <listitem>
	  <para><literal>SUBSYSTEM</literal>: the kernel subsystem which
	  generated the request (there are many, but a few examples are
	  “usb”, “ide”, “net”, “firmware”, etc.);</para>
        </listitem>
        <listitem>
	  <para><literal>ATTR{<replaceable>attribute</replaceable>}</literal>:
	  file contents of the <replaceable>attribute</replaceable> file in
	  the
	  <filename>/sys/<replaceable>$devpath</replaceable>/</filename>
	  directory of the device. This is where you find the MAC address
	  and other bus specific identifiers;</para>
        </listitem>
        <listitem>
	  <para><literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal>
	  and
	  <literal>ATTRS{<replaceable>attributes</replaceable>}</literal>
	  are variations that will try to match the different options on
	  one of the parent devices of the current device;</para>
        </listitem>
        <listitem>
	  <para><literal>PROGRAM</literal>: delegates the test to the
	  indicated program (true if it returns 0, false if not). The
	  content of the program's standard output is stored so that it can
	  be reused by the <literal>RESULT</literal> test;</para>
        </listitem>
        <listitem>
	  <para><literal>RESULT</literal>: execute tests on the standard
	  output stored during the last call to
	  <literal>PROGRAM</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>The right operands can use pattern expressions to match several
      values at the same time. For instance, <literal>*</literal> matches
      any string (even an empty one); <literal>?</literal> matches any
      character, and <literal>[]</literal> matches the set of characters
      listed between the square brackets (or the opposite thereof if the
      first character is an exclamation point, and contiguous ranges of
      characters are indicated like <literal>a-z</literal>).</para>

      <para>Regarding the assignment operators, <literal>=</literal>
      assigns a value (and replaces the current value); in the case of a
      list, it is emptied and contains only the value assigned.
      <literal>:=</literal> does the same, but prevents later changes to
      the same variable. As for <literal>+=</literal>, it adds an item to a
      list. The following variables can be changed:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>NAME</literal>: the device filename to be created
	  in <filename>/dev/</filename>. Only the first assignment counts;
	  the others are ignored;</para>
        </listitem>
        <listitem>
	  <para><literal>SYMLINK</literal>: the list of symbolic links that
	  will point to the same device;</para>
        </listitem>
        <listitem>
	  <para><literal>OWNER</literal>, <literal>GROUP</literal> and
	  <literal>MODE</literal> define the user and group that owns the
	  device, as well as the associated permission;</para>
        </listitem>
        <listitem>
	  <para><literal>RUN</literal>: the list of programs to execute in
	  response to this event.</para>
        </listitem>
      </itemizedlist>

      <para>The values assigned to these variables may use a number of
      substitutions:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>$kernel</literal> or <literal>%k</literal>:
	  equivalent to <literal>KERNEL</literal>;</para>
        </listitem>
        <listitem>
	  <para><literal>$number</literal> or <literal>%n</literal>: the
	  order number of the device, for example, for
	  <literal>sda3</literal>, it would be “3”;</para>
        </listitem>
        <listitem>
	  <para><literal>$devpath</literal> or <literal>%p</literal>:
	  equivalent to <literal>DEVPATH</literal>;</para>
        </listitem>
        <listitem>
	 
	  <para><literal>$attr{<replaceable>attribute</replaceable>}</literal>
	  or <literal>%s{<replaceable>attribute</replaceable>}</literal>:
	  equivalent to
	  <literal>ATTRS{<replaceable>attribute</replaceable>}</literal>;</para>
        </listitem>
        <listitem>
	  <para><literal>$major</literal> or <literal>%M</literal>: the
	  kernel major number of the device;</para>
        </listitem>
        <listitem>
	  <para><literal>$minor</literal> or <literal>%m</literal>: the
	  kernel minor number of the device;</para>
        </listitem>
        <listitem>
	  <para><literal>$result</literal> or <literal>%c</literal>: the
	  string output by the last program invoked by
	  <literal>PROGRAM</literal>;</para>
        </listitem>
        <listitem>
	  <para>and, finally, <literal>%%</literal> and
	  <literal>$$</literal> for the percent and dollar sign,
	  respectively.</para>
        </listitem>
      </itemizedlist>

      <para>The above lists are not complete (they include only the most
      important parameters), but the
      <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry>
      manual page should be exhaustive.</para>
    </section>
    <section>
      <title>A concrete example</title>

      <para>Let us consider the case of a simple USB key and try to assign
      it a fixed name. First, you must find the elements that will identify
      it in a unique manner. For this, plug it in and run <command>udevadm
      info -a -n /dev/sdc</command> (replacing
      <replaceable>/dev/sdc</replaceable> with the actual name assigned to
      the key).</para>

      <screen><computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>
<computeroutput>[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</computeroutput>
</screen>

      <para>To create a new rule, you can use tests on the device's
      variables, as well as those of one of the parent devices. The above
      case allows us to create two rules like these:</para>

      <programlisting>KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"
</programlisting>

      <para>Once these rules are set in a file, named for example
      <filename>/etc/udev/rules.d/010_local.rules</filename>, you can
      simply remove and reconnect the USB key. You can then see that
      <filename>/dev/usb_key/disk</filename> represents the disk associated
      with the USB key, and <filename>/dev/usb_key/part1</filename> is its
      first partition.</para>

      <sidebar>
        <title><emphasis>GOING FURTHER</emphasis> Debugging <emphasis>udev</emphasis>'s configuration</title>

	<para>Like many daemons, <command>udevd</command> stores logs in
	<filename>/var/log/daemon.log</filename>. But it is not very
	verbose by default, and it is usually not enough to understand
	what is happening. The <command>udevadm control
	--log-priority=info</command> command increases the verbosity level
	and solves this problem. <command>udevadm control
	--log-priority=err</command> returns to the default verbosity
	level.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.power-management">
    <title>Power Management: Advanced Configuration and Power Interface (ACPI)</title>
    <indexterm><primary>power management</primary></indexterm>
    <indexterm><primary>management, power management</primary></indexterm>

    <para>The topic of power management is often problematic. Indeed,
    properly suspending the computer requires that all the computer's
    device drivers know how to put them to standby, and that they properly
    reconfigure the devices upon waking. Unfortunately, there are still
    a few devices unable to sleep well under Linux, because their
    manufacturers have not provided the required specifications.</para>

    <para>Linux supports ACPI (Advanced Configuration and Power
    Interface) — the most recent standard in power management. The
    <emphasis role="pkg">acpid</emphasis> package provides a daemon that
    looks for power management related events (switching between AC and
    battery power on a laptop, etc.) and that can execute various commands
    in response.</para>

    <indexterm><primary>ACPI</primary></indexterm>
    <indexterm><primary>Advanced Configuration and Power Interface</primary></indexterm>
    <indexterm><primary><command>acpid</command></primary></indexterm>
    
    <sidebar>
      <title><emphasis>BEWARE</emphasis> Graphics card and standby</title>

      <para>The graphics card driver is often the culprit
      when standby doesn't work properly. In that case, it is a good idea
      to test the latest version of the X.org graphics server.</para>
    </sidebar>

    <para>After this overview of basic services common to many Unix
    systems, we will focus on the environment of the administered machines:
    the network. Many services are required for the network to work
    properly. They will be discussed in the next chapter.</para>
  </section>
</chapter>
