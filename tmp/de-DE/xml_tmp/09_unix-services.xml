<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="unix-services">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-unix-services.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>Systemstart</keyword>
      <keyword>Initialisierungsskripten</keyword>
      <keyword>SSH</keyword>
      <keyword>Telnet</keyword>
      <keyword>Rechte</keyword>
      <keyword>Berechtigungen</keyword>
      <keyword>Überwachung</keyword>
      <keyword>Inetd</keyword>
      <keyword>Cron</keyword>
      <keyword>Datensicherung</keyword>
      <keyword>Wechsel im laufenden Betrieb</keyword>
      <keyword>PCMCIA</keyword>
      <keyword>APM</keyword>
      <keyword>ACPI</keyword>
    </keywordset>
  </chapterinfo>
  <title>Unix-Dienste</title>
  <highlights>
    <para>Dieses Kapitel behandelt eine Reihe grundlegender Dienste, die vielen Unix-Systemen gemein sind. Alle Administratoren sollten mit ihnen vertraut sein.</para>
  </highlights>
  <section id="sect.system-boot">
    <title>Systemstart</title>
    <indexterm><primary>hochfahren</primary><secondary>das System</secondary></indexterm>

    <para>Beim Hochfahren des Rechners zeigen die zahlreichen Meldungen, die auf der Konsole vorüberrollen, viele selbsttätig ausgeführte Initialisierungen und Konfigurierungen an. Manchmal möchten Sie vielleicht den Ablauf dieser Phase etwas verändern, weshalb Sie sie gut verstehen müssen. Das ist der Zweck dieses Abschnitts.</para>

    
    <para>First, the BIOS takes control of the computer, detects the disks,
    loads the <emphasis>Master Boot Record</emphasis>, and executes the
    bootloader. The bootloader takes over, finds the kernel on the disk,
    loads and executes it. The kernel is then initialized, and starts to
    search for and mount the partition containing the root filesystem, and
    finally executes the first program — <command>init</command>.
    Frequently, this “root partition” and this <command>init</command>
    are, in fact, located in a virtual filesystem that only exists in RAM
    (hence its name, “initramfs”, formerly called “initrd” for
    “initialization RAM disk”). This filesystem is loaded in memory by
    the bootloader, often from a file on a hard drive or from the network.
    It contains the bare minimum required by the kernel to load the
    “true” root filesystem: this may be driver modules for the hard
    drive, or other devices without which the system cannot boot, or, more
    frequently, initialization scripts and modules for assembling RAID
    arrays, opening encrypted partitions, activating LVM volumes, etc. Once
    the root partition is mounted, the initramfs hands over control to the
    real init, and the machine goes back to the standard boot
    process.</para>

    <figure id="figure.boot-process-systemd">
      <title>Boot sequence of a computer running Linux with systemd</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/startup-systemd.png" scalefit="1" width="80%" />
        </imageobject>
      </mediaobject>
    </figure>

    <section id="sect.systemd"><title>The systemd init system</title>

    <para>The “real init” is currently provided by <emphasis role="pkg">systemd</emphasis> and this section documents this init
    system. </para>

    <sidebar>
      <title><emphasis>CULTURE</emphasis> Before <command>systemd</command></title>

      <para><command>systemd</command> is a relatively recent “init
      system”, and although it was already available, to a certain
      extent, in <emphasis role="distribution">Wheezy</emphasis>, it
      has only become the default in Debian <emphasis role="distribution">Jessie</emphasis>.  Previous releases
      relied, by default, on the “System V init” (in the <emphasis role="pkg">sysv-rc</emphasis> package), a much more traditional
      system.  We describe the System V init later on.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> Andere Bootsysteme</title>

      <para>This book describes the boot system used by default in
      Debian <emphasis role="distribution">Jessie</emphasis> (as
      implemented by the <emphasis role="pkg">systemd</emphasis>
      package), as well as the previous default, <emphasis role="pkg">sysvinit</emphasis>, which is derived and inherited
      from <emphasis>System V</emphasis> Unix systems; there are
      others.</para>

      <para><emphasis role="pkg">file-rc</emphasis> ist ein Bootsystem mit einem sehr einfachen Ablauf. Es behält das Prinzip der Runlevel bei, ersetzt jedoch  die Verzeichnisse und symbolischen Verknüpfungen durch eine Konfigurationsdatei, die für <command>init</command> die zu startenden Prozesse und ihre Startreihenfolge angibt.</para>

      <para>The <command>upstart</command> system is still not
      perfectly tested on Debian. It is event based: init scripts are
      no longer executed in a sequential order but in response to
      events such as the completion of another script upon which they
      are dependent. This system, started by Ubuntu, is present in
      Debian <emphasis role="distribution">Jessie</emphasis>, but is
      not the default; it comes, in fact, as a replacement for
      <emphasis role="pkg">sysvinit</emphasis>, and one of the tasks
      launched by <command>upstart</command> is to launch the scripts
      written for traditional systems, especially those from the
      <emphasis role="pkg">sysv-rc</emphasis> package.</para>

      <para>There are also other systems and other operating modes, such as
      <command>runit</command> or <command>minit</command>, but they are
      relatively specialized and not widespread.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>SONDERFALL</emphasis> Aus dem Netzwerk hochfahren</title>

      <para>Bei einigen Konfigurationen kann das BIOS so eingestellt sein, dass es nicht den MBR ausführt, sondern seine Entsprechung im Netzwerk sucht, wodurch es möglich wird, Rechner ohne Festplatte zu bauen oder solche, die bei jedem Neustart vollständig neu installiert werden. Diese Option steht aber nicht auf jeder Hardware zur Verfügung und erfordert im Allgemeinen eine passende Kombination aus BIOS und Netzwerkkarte.</para>

      <para>Das Hochfahren aus dem Netzwerk kann dazu verwendet werden, den  <command>Debian-Installer</command> oder FAI zu starten (siehe <xref linkend="sect.installation-methods" />).</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Der Prozess, eine Programminstanz</title>
      <indexterm><primary>Prozess</primary></indexterm>

      <para>Ein Prozess ist die Darstellung eines laufenden Programms im Speicher. Er umfasst alle Informationen, die für die ordnungsgemäße Ausführung der Software erforderlich sind (den Code selbst, aber auch die Daten, die er im Speicher hält, die Liste der Dateien, die er geöffnet hat, die Netzwerkverbindungen, die er eingerichtet hat usw.). Ein einzelnes Programm kann in mehreren Prozessen instanziiert sein, die nicht notwendigerweise unter verschiedenen Benutzerkennungen laufen.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>SICHERHEIT</emphasis> Eine Shell als <command>init</command> verwenden, um Administratorrechte zu erlangen</title>

      <para>By convention, the first process that is booted is the
      <command>init</command> program (which is a symbolic link to
      <filename>/lib/systemd/systemd</filename> by default). However,
      it is possible to pass an <literal>init</literal> option to the
      kernel indicating a different program.</para>
      <indexterm><primary><command>init</command></primary></indexterm>

      <para>Jeder mit Zugang zum Rechner kann die <keycap>Reset</keycap>-Taste drücken und ihn so neu starten. Dann ist es an der Eingabeaufforderung des Boot-Loaders möglich, dem Kernel die Option <literal>init=/bin/sh</literal> zu übergeben und so ohne Kenntnis des Administrator-Passworts Root-Rechte zu erlangen.</para>

      <para>Um dieses zu verhindern, kann man den Boot-Loader selbst mit einem Passwort absichern. Man könnte auch den Zugang zum BIOS schützen (ein Passwort-Schutzmechanismus ist fast immer verfügbar), ohne den ein böswilliger Eindringling jedoch den Rechner immer noch mit einem Wechseldatenträger, der sein eigenes Linux-System enthält, hochfahren könnte, und das er dann dazu benutzen könnte, um auf Daten auf den Festplatten des Rechners zuzugreifen.</para>

      <para>Finally, be aware that most BIOS have a generic password
      available. Initially intended for troubleshooting for those who have
      forgotten their password, these passwords are now public and
      available on the Internet (see for yourself by searching for
      “generic BIOS passwords” in a search engine). All of these
      protections will thus impede unauthorized access to the machine
      without being able to completely prevent it. There is no reliable way
      to protect a computer if the attacker can physically access it; they
      could dismount the hard drives to connect them to a computer under
      their own control anyway, or even steal the entire machine, or erase
      the BIOS memory to reset the password…</para>
    </sidebar>


<para>Systemd executes several processes, in charge of setting up the
system: keyboard, drivers, filesystems, network, services.  It does
this while keeping a global view of the system as a whole, and the
requirements of the components.  Each component is described by a
“unit file” (sometimes more); the general syntax is derived from the
widely-used “*.ini files“ syntax, with
<literal><replaceable>key</replaceable> =
<replaceable>value</replaceable></literal> pairs grouped between
<literal>[<replaceable>section</replaceable>]</literal> headers.  Unit
files are stored under <filename>/lib/systemd/system/</filename> and
<filename>/etc/systemd/system/</filename>; they come in several
flavours, but we will focus on “services” and “targets” here.
</para>

<para>A systemd “service file” describes a process managed by systemd.
It contains roughly the same information as old-style init-scripts,
but expressed in a declaratory (and much more concise) way.
Systemd handles the bulk of the repetitive tasks (starting and
stopping the process, checking its status, logging, dropping
privileges, and so on), and the service file only needs to fill in the
specifics of the process.  For instance, here is the service file for SSH:</para>

<programlisting>[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service
</programlisting>

<para>As you can see, there is very little code in there, only
declarations.  Systemd takes care of displaying progress reports,
keeping track of the processes, and even restarting them when
needed.</para>

<para>A systemd “target file” describes a state of the system, where a
set of services are known to be operational.  It can be thought of as
an equivalent of the old-style runlevel.  One of the targets is
<literal>local-fs.target</literal>; when it is reached, the rest of
the system can assume that all local filesystems are mounted and
accessible.  Other targets include
<literal>network-online.target</literal> and
<literal>sound.target</literal>.  The dependencies of a target can be
listed either within the target file (in the
<literal>Requires=</literal> line), or using a symbolic link to a
service file in the
<literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal>
directory.  For instance,
<filename>/etc/systemd/system/printer.target.wants/</filename>
contains a link to
<filename>/lib/systemd/system/cups.service</filename>; systemd will
therefore ensure CUPS is running in order to reach
<literal>printer.target</literal>.
</para>

<para>Since unit files are declarative rather than scripts or
programs, they cannot be run directly, and they are only interpreted
by systemd; several utilities therefore allow the administrator to
interact with systemd and control the state of the system and of each
component.</para>

<para>The first such utility is <command>systemctl</command>.  When
run without any arguments, it lists all the unit files known to
systemd (except those that have been disabled), as well as their
status.  <command>systemctl status</command> gives a better view of
the services, as well as the related processes.  If given the name of
a service (as in <command>systemctl status ntp.service</command>), it
returns even more details, as well as the last few log lines related
to the service (more on that later).</para>

<para>Starting a service by hand is a simple matter of running
<command>systemctl start
<replaceable>servicename</replaceable>.service</command>.  As one can
guess, stopping the service is done with <command>systemctl stop
<replaceable>servicename</replaceable>.service</command>; other
subcommands include <command>reload</command> and
<command>restart</command>.</para>

<para>To control whether a service is active (i.e. whether it will get
started automatically on boot), use <command>systemctl enable
<replaceable>servicename</replaceable>.service</command> (or
<command>disable</command>).  <command>is-enabled</command> allows
checking the status of the service.</para>

<para>An interesting feature of systemd is that it includes a logging
component named <command>journald</command>.  It comes as a complement
to more traditional logging systems such as
<command>syslogd</command>, but it adds interesting features such as a
formal link between a service and the messages it generates, and the
ability to capture error messages generated by its initialisation
sequence.  The messages can be displayed later on, with a little help
from the <command>journalctl</command> command.  Without any
arguments, it simply spews all log messages that occurred since system
boot; it will rarely be used in such a manner.  Most of the time, it
will be used with a service identifier:</para>

<screen><computeroutput># </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 10:08:49 CEST, end at Tue 2015-03-31 17:06:02 CEST. --
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:08:55 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
Mar 31 10:09:00 mirtuel sshd[430]: Server listening on :: port 22.
Mar 31 10:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
Mar 31 10:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</computeroutput></screen>

<para>Another useful command-line flag is <command>-f</command>, which
instructs <command>journalctl</command> to keep displaying new
messages as they are emitted (much in the manner of <command>tail -f
<replaceable>file</replaceable></command>).</para>

<para>If a service doesn't seem to be working as expected, the first
step to solve the problem is to check that the service is actually
running with <command>systemctl status</command>; if it is not, and
the messages given by the first command are not enough to diagnose the
problem, check the logs gathered by journald about that service.  For
instance, assume the SSH server doesn't work:</para>

<screen><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since Tue 2015-03-31 17:30:36 CEST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
Mar 31 17:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
Mar 31 17:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
Mar 31 17:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
Mar 31 17:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>vi /etc/ssh/sshd_config
</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service
</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since Tue 2015-03-31 17:31:09 CEST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </computeroutput>
</screen>

<para>
After checking the status of the service (failed), we went on to check
the logs; they indicate an error in the configuration file.  After
editing the configuration file and fixing the error, we restart the
service, then verify that it is indeed running.</para>

<sidebar><title><emphasis>GOING FURTHER</emphasis> Other types of unit files</title>

<para>We have only described the most basic of systemd's capabilities in
this section.  It offers many other interesting features; we will only
list a few here:</para>

<itemizedlist>

<listitem><para>socket activation: a “socket” unit file can be used to
describe a network or Unix socket managed by systemd; this means that
the socket will be created by systemd, and the actual service may be
started on demand when an actual connection attempt comes.  This
roughly replicates the feature set of
<command>inetd</command>. See
<citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry>.
</para></listitem>

<listitem><para>timers: a “timer” unit file describes events that
occur with a fixed frequency or on specific times; when a service is linked to such a
timer, the corresponding task will be executed whenever the timer
fires. This allows replicating part of the
<command>cron</command> features. See
<citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry>.
</para></listitem>

<listitem><para>network: a “network“ unit file describes a network
interface, which allows configuring such interfaces as well as
expressing that a service depends on one particular interface being
up. </para></listitem>

</itemizedlist>
</sidebar>

</section>

<section id="sect.sysvinit"><title>The System V init system</title>
    <para>The System V init system (which we'll call init for brevity)
    executes several processes, following instructions from the
    <filename>/etc/inittab</filename> file. The first program that is
    executed (which corresponds to the <emphasis>sysinit</emphasis>
    step) is <command>/etc/init.d/rcS</command>, a script that
    executes all of the programs in the
    <filename>/etc/rcS.d/</filename> directory.
    <indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm>
    <indexterm><primary><filename>rcS</filename></primary></indexterm>
    <indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm>
    <indexterm><primary><filename>rcS.d</filename></primary></indexterm></para>

    <para>Unter diesen befinden sich nacheinander Programme, die zuständig sind für:</para>
    <itemizedlist>
      <listitem>
	<para>das Konfigurieren der Konsolentastatur;</para>
      </listitem>
      <listitem>
	<para>das Laden von Treibern: die meisten Kernelmodule werden beim Erkennen der Hardware vom Kernel selbst geladen; zusätzliche Treiber werden selbsttätig geladen, wenn die entsprechenden Module in der Datei <filename>/etc/modules</filename> aufgeführt sind;</para>
      </listitem>
      <listitem>
	<para>die Überprüfung des Dateisystems auf Integrität;</para>
      </listitem>
      <listitem>
	<para>das Einhängen lokaler Partitionen;</para>
      </listitem>
      <listitem>
	<para>das Konfigurieren des Netzwerks;</para>
      </listitem>
      <listitem>
	<para>das Einhängen von Netzwerkdateisystemen (NFS).</para>
      </listitem>
    </itemizedlist>

    <sidebar>
      <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Kernelmodule und -optionen</title>
      <indexterm><primary>Module</primary><secondary>Kernelmodule</secondary></indexterm>

      <para>Kernelmodule verfügen ebenfalls über Optionen, die konfiguriert werden können, indem man Dateien im Verzeichnis <filename>/etc/modprobe.d/</filename> erstellt. Diese Optionen werden durch Anweisungen wie die folgende festgelegt:  <literal>options <replaceable>modulname</replaceable> <replaceable>optionsname</replaceable>=<replaceable>optionswert</replaceable></literal>. Falls erforderlich, können mehrere Optionen in einer einzelnen Anweisung gesetzt werden.</para>

      <para>Die Konfigurationsdateien sind für das Programm <command>modprobe</command> bestimmt, das ein Kernelmodul mit seinen Abhängigkeiten lädt (Module können auch andere Module aufrufen). Dieses Programm wird durch das Paket <emphasis role="pkg">kmod</emphasis> bereitgestellt.</para>
      <indexterm><primary><command>modprobe</command></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">kmod</emphasis></primary></indexterm>
    </sidebar>

    <para>After this stage, <command>init</command> takes over and starts
    the programs enabled in the default runlevel (which is usually runlevel
    2). It executes <command>/etc/init.d/rc 2</command>, a script that
    starts all services which are listed in
    <filename>/etc/rc2.d/</filename> and whose names start with the “S”
    letter. The two-figures number that follows had historically been used
    to define the order in which services had to be started, but nowadays
    the default boot system uses <command>insserv</command>, which schedules
    everything automatically
    based on the scripts' dependencies. Each boot script thus declares the
    conditions that must be met to start or stop the service (for example,
    if it must start before or after another service);
    <command>init</command> then launches them in the order that meets
    these conditions. The static numbering of scripts is therefore no
    longer taken into consideration (but they must always have a name
    beginning with “S” followed by two digits and the actual name
    of the script used for the dependencies). Generally, base services
    (such as logging with <command>rsyslog</command>, or port assignment
    with <command>portmap</command>) are started first, followed by
    standard services and the graphical interface
    (<command>gdm3</command>).</para>

    <para>Dieses Bootsystem auf der Grundlage von Abhängigkeiten ermöglicht es, die Neu-Nummerierung zu automatisieren, die recht mühsam wäre, wenn sie von Hand erledigt werden müsste, und es begrenzt das Risiko menschlichen Versagens, da die Festlegung der zeitlichen Abfolge in Übereinstimmung mit den angegebenen Parametern erfolgt. Ein weiterer Vorteil besteht darin, dass voneinander unabhängige Dienste zeitgleich gestartet werden können, was den Prozess des Hochfahrens beschleunigt.</para>

    <indexterm><primary>Runlevel</primary></indexterm>
    <indexterm><primary>Level, Runlevel</primary></indexterm>

    <para><command>init</command> unterscheidet zwischen verschiedenen Runleveln, so dass es mit dem Befehl <command>telinit <replaceable>neuer-level</replaceable></command> von einem zum anderen umschalten kann. <command>init</command> führt bei einem neuen Runlevel unmittelbar ein weiteres Mal <command>/etc/init.d/rc</command> aus. Dieses Skript startet dann die fehlenden Diensten und beendet die nicht mehr benötigten. Hierzu bezieht es sich auf den Inhalt der Datei <filename>/etc/rc<replaceable>X</replaceable>.d</filename> (wobei <replaceable>X</replaceable> den neuen Runlevel bezeichnet). Skripten, deren Namen mit „S“ beginnen (wie in „Start“), verweisen auf zu startende Dienste, solche mit „K“ (wie in „Kill“) auf zu beendende. Das Skript startet keine Dienste, die im vorherigen Runlevel bereits aktiv waren.</para>

    <para>By default, System V init in Debian uses four different
    runlevels:</para>
    <itemizedlist>
      <listitem>
	<para>Level 0 wird nur vorübergehend beim Herunterfahren des Rechners benutzt. Daher enthält er nur zahlreiche „K“-Skripten.</para>
      </listitem>
      <listitem>
	<para>Level 1, auch Single-User Modus genannt, entspricht dem System in rudimentärem Zustand. Er umfasst einzig grundlegende Dienste und ist hauptsächlich für den Systemunterhalt gedacht, bei dem Interaktionen mit normalen Benutzern nicht erwünscht sind.</para>
      </listitem>
      <listitem>
	<para>Level 2 ist der Level für den Normalbetrieb, der Netzwerkdienste, eine grafische Schnittstelle, Benutzeranmeldungen usw. umfasst.</para>
      </listitem>
      <listitem>
	<para>Level 6 gleicht Level 0, nur dass er während des Herunterfahrens vor einem Neustart verwendet wird.</para>
      </listitem>
    </itemizedlist>

    <para>Es gibt weitere Level, insbesondere 3 bis 5. Standardmäßig sind sie so konfiguriert, dass sie sich wie Level 2 verhalten. Jedoch kann der Administrator sie verändern (indem er in den entsprechenden Verzeichnissen unter <filename>/etc/rc<replaceable>X</replaceable>.d</filename> Skripten hinzufügt oder löscht), um sie so besonderen Bedürfnissen anzupassen.</para>

    <figure id="figure.boot-process-sysvinit">
      <title>Boot sequence of a computer running Linux with System V init</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/startup-sysvinit.png" scalefit="1" width="80%" />
        </imageobject>
      </mediaobject>
    </figure>
    <indexterm><primary>Initialisierungsskript</primary></indexterm>

    <para>Alle in den verschiedenen Verzeichnissen unter <filename>/etc/rc<replaceable>X</replaceable>.d</filename> enthaltenen Skripten sind in Wirklichkeit symbolische Verknüpfungen - bei der Paketinstallierung durch das Programm <command>update-rc.d</command> erstellt, die auf die eigentlichen im Verzeichnis <filename>/etc/init.d/</filename> gespeicherten Skripten verweisen. Der Administrator kann die in jedem Runlevel verfügbaren Dienste fein einstellen, indem er den Befehl <command>update-rc.d</command> mit angepassten Parametern erneut ausführt. Die Handbuchseite <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> erläutert die Syntax im Detail. Bitte beachten Sie, dass das Entfernen aller symbolischen Verknüpfungen (mit dem Parameter <literal>remove</literal>) kein gutes Verfahren zum Abschalten eines Dienstes ist. Stattdessen sollten Sie ihn einfach so konfigurieren, dass er in dem gewünschten Runlevel nicht startet (und dabei gleichzeitig die entsprechenden Aufrufe zu seinem Abschalten bewahren für den Fall, dass er im vorhergehenden Runlevel läuft). Da <command>update-rc.d</command> eine etwas verschachtelte Schnittstelle hat, benutzen Sie vielleicht lieber <command>rcconf</command> (aus dem Paket  <emphasis role="pkg">rcconf</emphasis>), das eine benutzerfreundlichere Schnittstelle bereitstellt.</para>
    <indexterm><primary><command>update-rc.d</command></primary></indexterm>

    <sidebar>
      <title><emphasis>DEBIAN-RICHTLINIEN</emphasis> Dienste neu starten</title>
      <indexterm><primary><command>invoke-rc.d</command></primary></indexterm>
      <indexterm><primary>Dienst</primary><secondary>neu starten</secondary></indexterm>
      <indexterm><primary>Dienste neu starten</primary></indexterm>

      <para>The maintainer scripts for Debian packages will sometimes
      restart certain services to ensure their availability or get them to
      take certain options into account. The command that controls a
      service — <command>service <replaceable>service</replaceable>
      <replaceable>operation</replaceable></command> — doesn't take
      runlevel into consideration, assumes (wrongly) that the service is
      currently being used, and may thus initiate incorrect operations
      (starting a service that was deliberately stopped, or stopping a
      service that is already stopped, etc.). Debian therefore introduced
      the <command>invoke-rc.d</command> program: this program must be used
      by maintainer scripts to run services initialization scripts and it
      will only execute the necessary commands. Note that, contrary to
      common usage, the <filename>.d</filename> suffix is used here in a
      program name, and not in a directory.</para>
    </sidebar>

    <para>Schließlich startet <command>init</command> Steuerprogramme für mehrere virtuelle Konsolen (<command>getty</command>). Es zeigt eine Eingabeaufforderung an, an der es auf einen Benutzernamen wartet, und führt dann <command>login <replaceable>benutzer</replaceable></command> aus, um eine Sitzung zu eröffnen.</para>
    <indexterm><primary><command>getty</command></primary></indexterm>

    <sidebar>
      <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Konsole und Terminal</title>

      <para>Die ersten Computer waren gewöhnlich in mehrere, sehr große Teile unterteilt: das Speichergehäuse und die zentrale Verarbeitungseinheit waren von den Peripheriegeräten getrennt, die von den Bedienern zu ihrer Steuerung benutzt wurden. Letztere waren Teil einer separaten Einrichtung, der „Konsole“. Dieser Begriff wurde beibehalten, aber seine Bedeutung hat sich verändert. Er wurde mehr oder weniger zu einem Synonym für „Terminal“, das aus einer Tastatur und einem Bildschirm besteht.</para>

      <para>Im Verlaufe der Entwicklung der Computer haben Betriebssysteme schließlich mehrere virtuelle Konsolen angeboten, um gleichzeitig mehrere unabhängige Sitzungen zu ermöglichen, selbst wenn es nur eine Tastatur und einen Bildschirm gibt. Die meisten GNU/Linux-Systeme bieten sechs virtuelle Konsolen (im Textmodus) an, die durch die Eingabe der Tastenkombinationen <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> bis <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo> zugänglich sind.</para>

      <para>Im weiteren Sinne können die Begriffe „Konsole“ und „Terminal“ sich auch auf einen Terminal-Emulator in einer grafischen X11-Sitzung beziehen (wie zum Beispiel <command>xterm</command>, <command>gnome-terminal</command> oder <command>konsole</command>).</para>
    </sidebar>
</section>
  </section>
  <section id="sect.remote-login">
    <title>Anmelden aus der Ferne</title>

    <para>Es ist für einen Administrator wichtig, sich aus der Ferne mit einem Rechner verbinden zu können. Server, die in ihrem eigenen Raum eingeschlossen sind, sind selten dauerhaft mit Tastaturen und Bildschirmen ausgestattet - aber sie sind mit dem Netzwerk verbunden.</para>

    <sidebar>
      <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Client, Server</title>
      <indexterm><primary>client</primary><secondary>client/server Architektur</secondary></indexterm>
      <indexterm><primary>Server</primary><secondary>Client-Server-Architektur</secondary></indexterm>

      <para>Ein System, bei dem mehrere Prozesse miteinander kommunizieren. wird häufig mit dem bildlichen Ausdruck „Client-Server“ beschrieben. Der Server ist das Programm, das Anfragen vom Client entgegen nimmt und ausführt. Der Client steuert die Vorgänge, der Server tut nichts aus eigener Initiative.</para>
    </sidebar>

    <indexterm><primary>Anmelden</primary><secondary>Anmelden aus der Ferne</secondary></indexterm>
    <indexterm><primary>Anmelden</primary></indexterm>

    <section id="sect.ssh">
      <title>Sicheres Anmelden aus der Ferne: SSH</title>
      <indexterm><primary>SSH</primary></indexterm>
      <indexterm><primary>Secure Shell</primary></indexterm>

      <para>Das <emphasis>SSH</emphasis>-Protokoll (Secure SHell) wurden Sicherheit und Zuverlässigkeit bereits im Entwurf berücksichtigt. Verbindungen auf der Basis von SSH sind sicher: der Partner ist authentifiziert und jeglicher Datenverkehr erfolgt verschlüsselt.</para>

      <sidebar>
        <title><emphasis>KULTUR</emphasis> Telnet und RSH sind veraltet</title>
	<indexterm><primary><command>telnet</command></primary></indexterm>
	<indexterm><primary><command>rsh</command></primary></indexterm>

	<para>Vor SSH waren <emphasis>Telnet</emphasis> und <emphasis>RSH</emphasis> die wesentlichen Werkzeuge um sich aus der Ferne einzuloggen. Heute sind sie weitestgehend überflüssig und sollten nicht weiter benutzt werden, auch wenn Debian sie immer noch zur Verfügung stellt.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Authentifizierung, Verschlüsselung</title>

	<para>Wenn Sie einem Client die Fähigkeit geben müssen, auf einem Server Aktionen auszuführen oder auszulösen, ist Sicherheit wichtig. Sie müssen die Identität des Clients sicherstellen; dies heißt Authentifizierung. Die Identität besteht normalerweise aus einem Passwort, das geheimzuhalten ist, da es sonst von jedem anderen Client erlangt werden könnte. Dies ist der Zweck von Verschlüsselung, einer Art der Codierung, die es zwei Systemen ermöglicht, vertrauliche Informationen über einen öffentlichen Kanal auszutauschen, ohne dabei für andere lesbar zu sein.</para>

	<para>Authentifizierung und Verschlüsselung werden häufig zusammen genannt, weil beide oft gleichzeitig benutzt werden, und weil sie gewöhnlich durch ähnliche mathematische Konzepte umgesetzt werden.</para>
      </sidebar>

      <para>SSH bietet auch zwei Dateiübertragungsdienste an. <command>scp</command> ist ein Befehlszeilenprogramm, das wie <command>cp</command> benutzt werden kann, nur dass jedem Pfad zu einem anderen Rechner der Name dieses Rechners gefolgt von einem Doppelpunkt vorangestellt wird.</para>

      <screen><computeroutput>$ </computeroutput><userinput>scp datei rechner:/tmp/</userinput>
</screen>

      <para><command>sftp</command> ist ein interaktiver Befehl, ähnlich wie <command>ftp</command>. In einer einzigen Sitzung kann <command>sftp</command> mehrere Dateien übertragen, und es ist möglich, mit ihm Dateien auf einem entfernten Rechner zu bearbeiten (löschen, umbenennen, Berechtigungen ändern usw.).</para>
      <indexterm><primary><command>scp</command></primary></indexterm>
      <indexterm><primary><command>sftp</command></primary></indexterm>

      <para>Debian verwendet OpenSSH, eine freie Version von SSH, die vom <command>OpenBSD</command>-Projekt betreut wird (einem freien Betriebssystem, das auf dem BSD-Kernel aufbaut und seinen Schwerpunkt auf Sicherheit setzt), und eine Abspaltung der ursprünglich vom finnischen Unternehmen SSH Communications Security Corp. entwickelten SSH-Software. Dieses Unternehmen entwickelte SSH ursprünglich als freie Software, entschied sich jedoch schließlich, seine Entwicklung unter einer proprietären Lizenz fortzusetzen. Das OpenBSD-Projekt schuf daraufhin OpenSSH, um eine freie Version von SSH zu bewahren.</para>
      <indexterm><primary>OpenSSH</primary></indexterm>

      <sidebar>
        <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> <foreignphrase>Abspaltung</foreignphrase></title>
        <indexterm><primary>Abspaltung</primary></indexterm>

	<para>Eine „Abspaltung“ im Softwarebereich ist ein neues Vorhaben, das als Klon eines bestehenden Vorhabens beginnt und mit ihm konkurriert. Von da an entwickeln sich beide Programme, was neue Entwicklungen angeht, gewöhnlich schnell auseinander. Eine Abspaltung ist häufig die Folge von Meinungsverschiedenheiten innerhalb des Entwicklungsteams.</para>

	<para>Die Option, ein Vorhaben abzuspalten, ist eine direkte Folge der Eigenart freier Software; eine Abspaltung ist ein heilsamer Vorgang, wenn sie die Fortführung eines Vorhabens als freie Software ermöglicht (zum Beispiel im Falle von Lizenzänderungen). Dagegen ist eine Abspaltung, die sich aus technischen oder persönlichen Meinungsverschiedenheiten ergibt, häufig eine Verschwendung menschlicher Ressourcen; eine andere Lösung wäre vorzuziehen. Auch der Zusammenschluss zweier Vorhaben, die früher durch eine Abspaltung gegangen sind, ist nicht gänzlich unbekannt.</para>
      </sidebar>

      <para>OpenSSH is split into two packages: the client part is in the <emphasis role="pkg">openssh-client</emphasis> package, and the server is in
      the <emphasis role="pkg">openssh-server</emphasis> package. The
      <emphasis role="pkg">ssh</emphasis> meta-package depends on both
      parts and facilitates installation of both (<command>apt install
      ssh</command>).</para>

      <section id="sect.ssh-key-based-auth">
        <title>Schlüsselbasierte Authentifizierung</title>

	<para>Jedes Mal, wenn sich jemand über SSH anmeldet, fragt der entfernte Server nach einem Passwort zur Authentifizierung des Benutzers. Dies kann problematisch sein, wenn man eine Verbindung automatisieren möchte, oder wenn man ein Hilfsprogramm verwendet, das häufige Verbindungen über SSH benötigt. Daher bietet SSH ein schlüsselbasiertes Authentifizierungssystem.</para>

	<para>Der Benutzer erzeugt auf dem Client-Rechner mit dem Befehl <command>ssh-keygen -t rsa</command> ein neues Schlüsselpaar; der öffentliche Schlüssel wird in  der Datei <filename>~/.ssh/id_rsa.pub</filename> gespeichert und der dazugehörige private Schlüssel in <filename>~/.ssh/id_rsa</filename>. Der Benutzer verwendet dann den Befehl <command>ssh-copy-id <replaceable>server</replaceable></command>, um seinen öffentlichen Schlüssel auf dem Server zur Datei <filename>~/.ssh/authorized_keys</filename> hinzuzufügen. Falls der private Schlüssel zur Zeit seiner Erzeugung nicht mit einer „Passphrase“ geschützt wurde, funktionieren alle nachfolgenden Anmeldungen auf dem Server ohne Eingabe eines Passworts. Anderenfalls muss der private Schlüssel jedes Mal erneut unter Eingabe der Passphrase entschlüsselt werden. Glücklicherweise ermöglicht es das Programm <command>ssh-agent</command>, private Schlüssel im Speicher zu halten, so dass das Passwort nicht ständig neu eingegeben werden muss. Hierzu verwendet man einfach (einmal pro Sitzung) den Befehl <command>ssh-add</command>, wobei Voraussetzung ist, dass die Sitzung bereits einer funktionsfähigen Instanz von <command>ssh-agent</command> zugeordnet ist. Debian aktiviert dieses Programm standardmäßig beim Start einer grafischen Sitzung, es kann jedoch durch eine Änderung der Datei <filename>/etc/X11/Xsession.options</filename> deaktiviert sein. In einer Konsolensitzung kann es manuell mit dem Befehl <command>eval $(ssh-agent)</command> gestartet werden.</para>

        <sidebar>
          <title><emphasis>SICHERHEIT</emphasis> Schutz des privaten Schlüssels</title>

	  <para>Wer immer im Besitz des privaten Schlüssels ist, kann sich auf dem entsprechend konfigurierten Konto anmelden. Daher ist der Zugriff auf den privaten Schlüssel durch eine „Passphrase“ geschützt. Selbst wenn jemand in den Besitz eines privaten Schlüssels gelangt (zum Beispiel die Datei <filename>~/.ssh/id_rsa</filename>), muss er zusätzlich noch diese Phrase kennen, um ihn verwenden zu können. Dieser zusätzliche Schutz ist jedoch nicht unüberwindlich, und wenn Sie denken, dass die Sicherheit dieser Datei nicht mehr gewährleistet ist, sollten Sie diesen Schlüssel auf den Rechnern, auf denen er installiert wurde, deaktivieren (indem Sie ihn aus <filename>authorized_keys</filename> entfernen) und durch einen neu erzeugten Schlüssel ersetzen.</para>
        </sidebar>

        <sidebar>
          <title><emphasis>KULTUR</emphasis> OpenSSL-Schwachstelle in Debian <emphasis role="distribution">Etch</emphasis></title>

	  <para>Die OpenSSL-Bibliothek, die ursprünglich mit Debian <emphasis role="distribution">Etch</emphasis> bereitgestellt wurde, hatte ein gravierendes Problem in ihrem Zufallszahlengenerator (RNG). In der Tat hatte der zuständige Debian-Betreuer eine Änderung vorgenommen, damit Anwendungen, die ihn verwenden, keine Warnmeldungen mehr verursachen, wenn sie von Werkzeugen für das Memory Management wie zum Beispiel <command>valgrind</command> analysiert werden. Leider hatte diese Änderung auch zur Folge, dass der Zufallszahlengenerator nur eine Entropie-Quelle in Abhängigkeit von der Prozesskennung (PID) benutzte, deren 32.000 mögliche Werte keinen ausreichenden Grad an Zufälligkeit boten. <ulink type="block" url="http://www.debian.org/security/2008/dsa-1571" /></para>

	  <para>Insbesondere, wenn OpenSSL benutzt wurde, um einen Schlüssel zu erzeugen, wurde dieser immer aus einem Satz einiger hunderttausend Schlüssel erstellt (32.000 multipliziert mit einer kleinen Zahl von Schlüssellängen). Hiervon waren SSH-Schlüssel, SSL-Schlüssel und von zahlreichen Anwendungen, wie zum Beispiel OpenVPN, verwendete X.509-Zertifikate betroffen. Ein Eindringling brauchte nur alle Schlüssel auszuprobieren, um unberechtigten Zugriff zu erlangen. Um die Auswirkung des Problems einzuschränken, wurde der SSH-Daemon dahingehend verändert, dass er zweifelhafte Schlüssel, die in den Paketen <emphasis role="pkg">openssh-blacklist</emphasis> und <emphasis role="pkg">openssh-blacklist-extra</emphasis> aufgelistet sind, zurückweist. Darüber hinaus ermöglicht es der Befehl <command>ssh-vulnkey</command>, möglicherweise gefährdete Schlüssel im System zu identifizieren.</para>

	  <para>A more thorough analysis of this incident brings to
	  light that it is the result of multiple (small) problems,
	  both within the OpenSSL project and with the Debian package
	  maintainer. A widely used library like OpenSSL should —
	  without modifications — not generate warnings when tested by
	  <command>valgrind</command>. Furthermore, the code
	  (especially the parts as sensitive as the RNG) should be
	  better commented to prevent such errors. On Debian's side,
	  the maintainer wanted to validate the modifications with the
	  OpenSSL developers, but simply explained the modifications
	  without providing the corresponding patch to review and
	  failed to mention his role within Debian. Finally, the
	  maintenance choices were sub-optimal: the changes made to
	  the original code were not clearly documented; all the
	  modifications were effectively stored in a Subversion
	  repository, but they ended up all lumped into one single
	  patch during creation of the source package.</para>

	  <para>It is difficult under such conditions to find the
	  corrective measures to prevent such incidents from recurring. The
	  lesson to be learned here is that every divergence Debian
	  introduces to upstream software must be justified, documented,
	  submitted to the upstream project when possible, and widely
	  publicized. It is from this perspective that the new source
          package format (“3.0 (quilt)”) and the Debian sources webservice
          were developed.
	  <ulink type="block" url="http://sources.debian.net" /></para>
        </sidebar>
      </section>
      <section id="sect.ssh-x11">
        <title>Entfernte X11-Anwendungen benutzen</title>

	<para>Das SSH-Protokoll ermöglicht die Weiterleitung grafischer Daten („X11“-Sitzung, nach dem Namen des am weitesten verbreiteten grafischen Systems in Unix); der Server stellt hierbei einen besonderen Kanal für diese Daten bereit. Konkret bedeutet dies, dass ein aus der Ferne ausgeführtes, grafisches Programm vom X.org-Server auf dem lokalen Bildschirm dargestellt werden kann, und dass die gesamte Sitzung (Eingabe und Anzeige) abgesichert ist. Da entfernte Anwendungen durch diese Funktion das lokale System beeinträchtigen können, ist sie standardmäßig deaktiviert. Sie kann aktiviert werden, indem man in der Serverkonfigurationsdatei (<filename>/etc/ssh/sshd_config</filename>) die Option <literal>X11Forwarding yes</literal> einstellt. Schließlich muss der Benutzer diese Funktion anfordern, indem er die Option <literal>-X</literal> zur Befehlszeile <command>ssh</command> hinzufügt.</para>
      </section>
      <section id="sect.ssh-port-forwarding">
        <title>Verschlüsselte Tunnel mit Port-Weiterleitung einrichten</title>
        <indexterm><primary>Port-Weiterleitung</primary></indexterm>

	<para>Die Optionen <literal>-R</literal> und <literal>-L</literal> des Befehls <command>ssh</command> ermöglichen es, „verschlüsselte Tunnel“ zwischen zwei Rechnern zu erstellen, und so einen lokalen TCP-Port (siehe <xref linkend="sidebar.tcp-udp" /> in der Seitenleiste) sicher an einen entfernten Rechner weiterzuleiten und umgekehrt.</para>

        <sidebar>
          <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Tunnel</title>
          <indexterm><primary>Tunnel (SSH)</primary><seealso>VPN</seealso></indexterm>
          <indexterm><primary>Tunnel SSH</primary><seealso>VPN</seealso></indexterm>

	  <para>Das Internet und die meisten mit ihm verbundenen LANs arbeiten im Paket-Modus und nicht in einem fest geschalteten Modus. Das heißt, dass ein Paket, das von einem Rechner zu einem anderen verschickt wird, auf dem Weg zu seinem Ziel an mehreren dazwischenliegenden Routern angehalten wird. Dennoch kann man einen fest geschalteten Betrieb nachahmen, indem der Datenstrom in normale IP-Pakete eingeschlossen wird. Diese Pakete laufen über ihren üblichen Weg, jedoch wird der Datenstrom am Ziel dann unverändert rekonstruiert. Man nennt dies einen „Tunnel“ in Analogie zu einem Straßentunnel, bei dem Fahrzeuge direkt vom Eingang (Eingabe) zum Ausgang (Ausgabe) fahren, ohne auf irgendwelche Kreuzungen zu stoßen, im Gegensatz zu einem Weg an der Oberfläche, bei dem es Kreuzungen und Richtungswechsel gibt.</para>

	  <para>Man kann bei dieser Gelegenheit den Tunnel verschlüsseln: der Datenstrom, der durch ihn hindurchläuft, ist dann von außen unkenntlich, wird aber am Tunnelausgang wieder in eine unverschlüsselte Form zurückgeführt.</para>
        </sidebar>

	<para><command>ssh -L 8000:server:25 intermediary</command> eröffnet eine SSH-Sitzung mit dem Host <replaceable>intermediary</replaceable> und nimmt am lokalen Port 8000 Verbindungen an (siehe <xref linkend="figure.ssh-L" />). Für jede Verbindung, die an diesem Port hergestellt wird, baut <command>ssh</command> eine Verbindung vom Rechner <replaceable>intermediary</replaceable> zum Port 25 des <replaceable>server</replaceable> auf und verknüpft beide Verbindungen.</para>

	<para><command>ssh -R 8000:server:25 intermediary</command> eröffnet auch eine SSH-Sitzung zum Rechner <replaceable>intermediary</replaceable>, aber <command>ssh</command> nimmt dann auf diesem Rechner an Port 8000 Verbindungen an (siehe <xref linkend="figure.ssh-R" />). Jede Verbindung, die an diesem Port hergestellt wird, veranlasst <command>ssh</command>, eine Verbindung vom lokalen Rechner zum Port 25 des <replaceable>server</replaceable> zu öffnen und beide Verbindungen miteinander zu verknüpfen.</para>

	<para>In beiden Fällen werden Verbindungen zu Port 25 auf dem Host <replaceable>server</replaceable> hergestellt, die durch den SSH-Tunnel laufen, der zwischen dem lokalen Rechner und dem Rechner <replaceable>intermediary</replaceable> hergestellt wurde. Im ersten Fall ist der Eingang zum Tunnel der lokale Port 8000, und die Daten laufen zum Rechner <replaceable>intermediary</replaceable>, bevor sie zum <replaceable>server</replaceable> im „öffentlichen“ Netzwerk geleitet werden. Im zweiten Fall sind Ein- und Ausgang im Tunnel vertauscht: der Eingang ist Port 8000 auf dem Rechner <replaceable>intermediary</replaceable>, der Ausgang ist auf dem lokalen Host, und die Daten werden dann zum <replaceable>server</replaceable> geleitet. In der Praxis ist der Server normalerweise entweder der lokale Rechner oder der intermediäre. Auf diese Weise sichert SSH die Verbindung von einem Ende zum anderen.</para>

        <figure id="figure.ssh-L">
          <title>Einen lokalen Port mit SSH weiterleiten</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ssh-L.png" width="35%" />
            </imageobject>
          </mediaobject>
        </figure>

        <figure id="figure.ssh-R">
          <title>Einen entfernten Port mit SSH weiterleiten</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ssh-R.png" width="35%" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>
    <section id="sect.remote-desktops">
      <title>Entfernte grafische Arbeitsflächen benutzen</title>

      <para>VNC (Virtual Network Computing) ermöglicht aus der Ferne Zugriff auf grafische Arbeitsflächen.</para>
      <indexterm><primary>VNC</primary></indexterm>
      <indexterm><primary>Virtual Network Computing</primary></indexterm>
      <indexterm><primary>grafische Arbeitsfläche</primary><secondary>entfernt</secondary></indexterm>
      <indexterm><primary>entfernte grafische Arbeitsfläche</primary></indexterm>
      <indexterm><primary>Arbeitsfläche, entfernte grafische Arbeitsfläche</primary></indexterm>

      <para>Dieses Hilfsprogramm wird vor allem zur technischen Unterstützung eingesetzt; der Administrator kann die Fehler sehen, denen ein Benutzer gegenübersteht, und ihm die richtige Vorgehensweise zeigen, ohne vor Ort sein zu müssen.</para>
      <indexterm><primary><emphasis role="pkg">vino</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">krfb</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">x11vnc</emphasis></primary></indexterm>

      <para>First, the user must authorize sharing their session.  The
      GNOME graphical desktop environment in <emphasis role="distribution">Jessie</emphasis> includes that option in
      its configuration panel (contrary to previous versions of
      Debian, where the user had to install and run
      <command>vino</command>).  KDE still requires using
      <command>krfb</command> to allow sharing an existing session
      over VNC. For other graphical desktop environments, the
      <command>x11vnc</command> command (from the Debian package of
      the same name) serves the same purpose; you can make it
      available to the user with an explicit icon.</para>

      <indexterm><primary><emphasis role="pkg">vinagre</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">tsclient</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">krdc</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">xvnc4viewer</emphasis></primary></indexterm>

      <para>When the graphical session is made available by VNC, the
      administrator must connect to it with a VNC client. GNOME has
      <command>vinagre</command> and <command>remmina</command> for that,
      while KDE includes <command>krdc</command> (in the menu at
      <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu>
      <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). There
      are other VNC clients that use the command line, such as
      <command>xvnc4viewer</command> in the Debian package of the same
      name. Once connected, the administrator can see what is going on, work
      on the machine remotely, and show the user how to proceed.</para>

      <sidebar>
        <title><emphasis>SICHERHEIT</emphasis> VNC über SSH</title>
        <indexterm><primary>SSH-Tunnel</primary><secondary>VNC</secondary></indexterm>

	<para>Falls Sie über VNC eine Verbindung herstellen, Ihre Daten aber nicht im Klartext über das Netzwerk schicken wollen, können Sie sie in einem SSH-Tunnel verbergen (siehe <xref linkend="sect.ssh-port-forwarding" />). Sie müssen nur wissen, dass VNC standardmäßig den Port 5900 für den ersten Bildschirm („localhost:0“ genannt), 5901 für den zweiten („localhost:1“ genannt) usw. verwendet.</para>

	<para>Der Befehl <command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>rechner</replaceable></command>  erstellt einen Tunnel zwischen dem lokalen Port 5901 in der localhost-Schnittstelle und Port 5900 auf dem Host <replaceable>rechner</replaceable>. Das erste „localhost“ beschränkt SSH darauf, nur an dieser Schnittstelle des lokalen Rechners auf Anfragen zu warten. Das zweite „localhost“ bezeichnet die Schnittstelle des entfernten Rechners, die den Netzverkehr entgegennehmen wird, der in „localhost:5901“ eintritt. Auf diese Weise verbindet <command>vncviewer localhost:1</command> den VNC-Client mit dem entfernten Bildschirm, obwohl Sie den Namen des lokalen Rechners angeben.</para>

	<para>Wenn die VNC-Sitzung beendet ist, vergessen Sie nicht, den Tunnel zu schließen, indem Sie auch die entsprechende SSH-Sitzung beenden.</para>
      </sidebar>

      <sidebar>
        <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Display Manager</title>
        <indexterm><primary><command>gdm3</command></primary></indexterm>
        <indexterm><primary><command>kdm</command></primary></indexterm>
        <indexterm><primary><command>xdm</command></primary></indexterm>
        <indexterm><primary><command>lightdm</command></primary></indexterm>
        <indexterm><primary>Manager</primary><secondary>Display Manager</secondary></indexterm>
        <indexterm><primary>Display Manager</primary></indexterm>

	<para><command>gdm3</command>, <command>kdm</command>, <command>lightdm</command>, and
	<command>xdm</command> are Display Managers. They take control of
	the graphical interface shortly after boot in order to provide the
	user a login screen. Once the user has logged in, they execute the
	programs needed to start a graphical work session.</para>
      </sidebar>

      <para>VNC funktioniert auch für mobile Anwender oder für Angestellte, die sich gelegentlich von zu Hause aus anmelden müssen, um auf einen entfernten Bildschirm ähnlich dem an ihrem Arbeitsplatz zuzugreifen. Die Konfiguration eines derartigen Dienstes ist komplizierter: zunächst installieren Sie das Paket <emphasis role="pkg">vnc4server</emphasis>, passen die Konfiguration des Display Managers dahingehend an, dass er Anfragen an <literal>XDMCP Query</literal> annimmt (für <command>gdm3</command> kann dies durch Hinzufügen von <literal>Enable=true</literal> im Abschnitt “xdmcp” von <filename>/etc/gdm3/daemon.conf</filename>) und starten schließlich den VNC-Server mit <command>inetd</command>, so dass eine Sitzung automatisch beginnt, wenn ein Benutzer sich anzumelden versucht. Sie können zum Beispiel folgende Zeile zu <filename>/etc/inetd.conf</filename> hinzufügen:</para>

      <programlisting>5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none
</programlisting>

      <para>Redirecting incoming connections to the display manager solves
      the problem of authentication, because only users with local accounts
      will pass the <command>gdm3</command> login screen (or equivalent
      <command>kdm</command>, <command>xdm</command>, etc.). As this
      operation allows multiple simultaneous logins without any problem
      (provided the server is powerful enough), it can even be used to
      provide complete desktops for mobile users (or for less powerful
      desktop systems, configured as thin clients). Users simply login to
      the server's screen with <command>vncviewer
      <replaceable>server</replaceable>:50</command>, because the port used
      is 5950.</para>
      <indexterm><primary><emphasis role="pkg">vnc4server</emphasis></primary></indexterm>
    </section>
  </section>
  <section id="sect.rights-management">
    <title>Berechtigungen verwalten</title>

    <para>Linux ist eindeutig ein Mehrbenutzersystem, und daher ist es erforderlich, ein Berechtigungssystem bereitzustellen, um die genehmigten Arbeitsvorgänge an Dateien und Verzeichnissen zu kontrollieren, einschließlich aller Systemressourcen und Laufwerke (in einem Unix-System wird jedes Laufwerk als eine Datei oder ein Verzeichnis dargestellt). Dies ist allen Unix-Systemen gemein, aber eine Erinnerung ist immer sinnvoll, vor allem, da es einige sehr interessante und relativ unbekannte Verwendungen gibt.</para>
    <indexterm><primary>Rechte</primary></indexterm>
    <indexterm><primary>Berechtigungen</primary></indexterm>
    <indexterm><primary>Benutzer</primary><secondary>Eigentümer</secondary></indexterm>
    <indexterm><primary>Gruppe</primary><secondary>Eigentümer</secondary></indexterm>
    <indexterm><primary>Eigentümer</primary><secondary>Benutzer</secondary></indexterm>
    <indexterm><primary>Eigentümer</primary><secondary>Gruppe</secondary></indexterm>

    <para>Jede Datei und jeder Ordner hat spezifische Berechtigungen für drei Kategorien von Benutzern:</para>
    <itemizedlist>
      <listitem>
	<para>seinen Eigentümer (symbolisiert durch <literal>u</literal> wie in „user“);</para>
      </listitem>
      <listitem>
	<para>seine Eigentümergruppe (symbolisiert durch <literal>g</literal> wie in „group“), die alle Mitglieder der Gruppe repräsentiert;</para>
      </listitem>
      <listitem>
	<para>die Sonstigen (symbolisiert durch <literal>o</literal> wie in „other“).</para>
      </listitem>
    </itemizedlist>

    <para>Drei Arten von Berechtigungen können kombiniert werden:</para>
    <itemizedlist>
      <listitem>
	<para>Lesen (symbolisiert durch <literal>r</literal> wie in „read“);</para>
      </listitem>
      <listitem>
	<para>Schreiben (oder Ändern, symbolisiert durch <literal>w</literal> wie in „write“);</para>
      </listitem>
      <listitem>
	<para>Ausführen (symbolisiert durch <literal>x</literal> wie in „eXecute“).</para>
      </listitem>
    </itemizedlist>
    <indexterm><primary>Lesen, Berechtigung</primary></indexterm>
    <indexterm><primary>Schreiben, Berechtigung</primary></indexterm>
    <indexterm><primary>Ändern, Berechtigung</primary></indexterm>
    <indexterm><primary>Ausführen, Berechtigung</primary></indexterm>

    <para>In the case of a file, these rights are easily understood: read
    access allows reading the content (including copying), write access
    allows changing it, and execute access allows you to run it (which will
    only work if it is a program).</para>

    <sidebar>
      <title><emphasis>SICHERHEIT</emphasis> <literal>setuid</literal> und <literal>setgid</literal> bei ausführbaren Dateien</title>

      <para>Zwei besondere Berechtigungen sind für ausführbare Dateien wichtig: <literal>setuid</literal> und <literal>setgid</literal> (durch den Buchstaben „s“ symbolisiert). Beachten Sie, dass wir häufig von einem „Bit“ sprechen, da jeder dieser booleschen Werte durch eine 0 oder eine 1 dargestellt werden kann. Diese beiden Berechtigungen erlauben es jedem Benutzer, das Programm mit den Rechten des Eigentümers beziehungsweise der Gruppe auszuführen. Dieses Verfahren gewährt Zugriff auf Funktionsmerkmale, die Rechte einer höheren Ebene erfordern, als Sie normalerweise haben würden.</para>
      <indexterm><primary><literal>setuid</literal>, Recht</primary></indexterm>
      <indexterm><primary><literal>setgid</literal>, Recht</primary></indexterm>

      <para>Da ein Root-Programm mit <literal>setuid</literal> durchgängig unter der Identität des Super-Users läuft, ist es sehr wichtig sicherzustellen, dass es sicher und verlässlich ist. Ein Benutzer, dem es gelingt, es zu unterlaufen, um einen Befehl seiner Wahl aufzurufen, könnte sich anschließend als Root-Benutzer ausgeben und so alle Rechte an dem System erlangen.</para>
    </sidebar>

    <para>Ein Verzeichnis wird anders gehandhabt. Lesezugriff gewährt das Recht, die Liste der Einträge (Dateien und Verzeichnisse) durchzugehen, Schreibzugriff erlaubt es, Dateien zu erstellen oder zu löschen, und Ausführungszugriff erlaubt es, es zu durchqueren (insbesondere dorthin mit dem Befehl <command>cd</command> zu gehen). Die Berechtigung, ohne ein Verzeichnis zu lesen auf dessen Inhalt zugreifen zu können, gestattet Zugriff auf namentlich bekannte Dateien, nicht jedoch auf solche von denen man nichts weiß oder deren genauen Namen man nicht kennt.</para>

    <sidebar id="sidebar.setgid-dir">
      <title><emphasis>SICHERHEIT</emphasis> <literal>setgid</literal>-Verzeichnis und <emphasis>Sticky-Bit</emphasis></title>
      <indexterm><primary><literal>setgid</literal> Verzeichnis</primary></indexterm>

      <para>Das <literal>setgid</literal>-Bit gilt auch für Verzeichnisse. Und neu erstellte Einträge in solchen Verzeichnissen werden automatisch der Benutzergruppe des übergeordneten Verzeichnisses zugeordnet, anstatt wie gewöhnlich die Hauptgruppe des Erstellers zu übernehmen. Durch diese Einstellung wird vermieden, dass der Benutzer die Hauptgruppe des Eintrags ändern muss (mit dem Befehl <command>newgrp</command>), wenn er in einem Verzeichnisbaum arbeitet, der von mehreren Benutzern derselben Gruppe gemeinsam genutzt wird.</para>
      <indexterm><primary>Sticky-Bit</primary></indexterm>

      <para>Das „Sticky“-Bit (symbolisiert durch den Buchstaben „t“) ist ein Recht, das nur in Verzeichnissen sinnvoll ist. Es wird vor allem bei temporären Verzeichnissen verwendet, bei denen jeder Schreibzugriff hat (wie zum Beispiel bei <filename>/tmp/</filename>): es schränkt das Löschen von Dateien ein, so dass dies nur ihr Eigentümer (oder der Eigentümer des übergeordneten Verzeichnisses) kann. Ohne dieses Recht könnte jeder die Dateien anderer Benutzer in <filename>/tmp/</filename> löschen.</para>
    </sidebar>

    <para>Drei Befehle steuern die einer Datei zugeordneten Berechtigungen:</para>
    <itemizedlist>
      <listitem>
	<para><command>chown <replaceable>benutzer</replaceable> <replaceable>datei</replaceable></command> ändert den Eigentümer der Datei;</para>
      </listitem>
      <listitem>
	<para><command>chgrp <replaceable>gruppe</replaceable> <replaceable>datei</replaceable></command> ändert die Eigentümergruppe;</para>
      </listitem>
      <listitem>
	<para><command>chmod <replaceable>rechte</replaceable> <replaceable>datei</replaceable></command> ändert die Berechtigungen für die Datei.</para>
      </listitem>
    </itemizedlist>

    <para>Es gibt zwei Arten, die Berechtigungen darzustellen. Von ihnen ist die symbolische Darstellung wohl am einfachsten zu verstehen und zu merken. Es geht um die oben erwähnten Buchstabensymbole. Sie können Berechtigungen für jede Kategorie von Benutzern festlegen (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>), indem Sie sie entweder ausdrücklich setzen (mit <literal>=</literal>), sie hinzufügen (<literal>+</literal>) oder sie entfernen (<literal>-</literal>). So gewährt die Formel <literal>u=rwx,g+rw,o-r</literal> dem Eigentümer Lese-, Schreib- und Ausführungszugriff, fügt Lese- und Schreibzugriff für die Eigentümergruppe hinzu und entfernt den Lesezugriff für andere Benutzer. Rechte, die in einem solchen Befehl nicht durch Hinzufügen oder Entfernen modifiziert werden, bleiben unverändert. Der Buchstabe <literal>a</literal>, für „all“, deckt alle drei Benutzerkategorien ab, so dass <literal>a=rx</literal> allen drei Kategorien die gleichen Rechte gewährt (Lesen und Ausführen, aber nicht Schreiben).</para>
    <indexterm><primary><command>chmod</command></primary></indexterm>
    <indexterm><primary><command>chown</command></primary></indexterm>
    <indexterm><primary><command>chgrp</command></primary></indexterm>
    <indexterm><primary>Oktale Darstellung von Berechtigungen</primary></indexterm>
    <indexterm><primary>Berechtigungen</primary><secondary>oktale Darstellung</secondary></indexterm>

    <para>Die (oktale) Zahlendarstellung ordnet jeder Berechtigung einen Wert zu: 4 für Lesen, 2 für Schreiben und 1 für Ausführen. Wir verknüpfen jede Kombination von Berechtigungen durch die Summe der Zahlen. Jeder Wert wird dann einer anderen Kategorie von Benutzern zugeordnet, indem sie von vorne nach hinten in der üblichen Reihenfolge (Eigentümer, Gruppe, Sonstige) angeordnet werden.</para>

    <para>So vergibt zum Beispiel der Befehl <command>chmod 754 <replaceable>datei</replaceable></command> die folgenden Berechtigungen: Schreiben, Lesen und Ausführen für den Eigentümer (da 7 = 4 + 2 + 1); Schreiben und Ausführen für die Gruppe (da 5 = 4 + 1); nur Lesen für Sonstige. Die <literal>0</literal> bedeutet keine Berechtigung; so gestattet <command>chmod 600 <replaceable>datei</replaceable></command> dem Eigentümer Lese-/Schreibzugriff, und keine Berechtigungen für alle anderen. Die häufigsten Berechtigungskombinationen sind <literal>755</literal> für ausführbare Dateien und Verzeichnisse und <literal>644</literal> für Dateien, die Daten enthalten.</para>

    <para>Um spezielle Berechtigungen darzustellen, können Sie dieser Zahl eine vierte Ziffer nach dem gleichen Prinzip voranstellen, wobei die <literal>setuid</literal>-, <literal>setgid</literal>- und <literal>sticky</literal>-Bits jeweils 4, 2 und 1 sind. <command>chmod 4754</command> fügt das <literal>setuid</literal>-Bit den zuvor beschriebenen Berechtigungen hinzu.</para>

    <para>Note that the use of octal notation only allows to set all the
    rights at once on a file; you cannot use it to simply add a new right,
    such as read access for the group owner, since you must take into
    account the existing rights and compute the new corresponding numerical
    value.</para>

    <sidebar>
      <title><emphasis>TIPP</emphasis> Rekursives Verfahren</title>

      <para>Manchmal müssen wir die Berechtigungen für einen ganzen Dateibaum ändern. Alle oben beschriebenen Befehle haben eine <literal>-R</literal>-Option, um rekursiv in Unterverzeichnissen zu agieren.</para>

      <para>The distinction between directories and files sometimes causes
      problems with recursive operations. That is why the “X” letter has
      been introduced in the symbolic representation of rights. It
      represents a right to execute which applies only to directories (and
      not to files lacking this right). Thus, <command>chmod -R a+X
      <replaceable>directory</replaceable></command> will only add execute
      rights for all categories of users (<literal>a</literal>) for all of
      the sub-directories and files for which at least one category of user
      (even if their sole owner) already has execute rights.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>TIPP</emphasis> Den Eigentümer und die Gruppe wechseln</title>

      <para>Frequently you want to change the group of a file at the
      same time that you change the owner. The
      <command>chown</command> command has a special syntax for that:
      <command>chown
      <replaceable>user</replaceable>:<replaceable>group</replaceable>
      <replaceable>file</replaceable></command></para>
    </sidebar>

    <sidebar>
      <title><emphasis>WEITERE SCHRITTE</emphasis> <command>umask</command></title>

      <para>Wenn eine Anwendung eine Datei erstellt, teilt sie ihr vorläufige Berechtigungen zu, wissend dass das System automatisch bestimmte Berechtigungen entfernt, die mit dem Befehl <command>umask</command> vorgegeben wurden. Geben Sie <command>umask</command> in einer Shell ein; Sie werden eine Maske wie zum Beispiel <computeroutput>0022</computeroutput> sehen. Dies ist eine oktale Darstellung der Berechtigungen, die planmäßig entfernt werden (in diesem Fall die Schreibrechte für die Gruppe und sonstige Benutzer).</para>
      <indexterm><primary>umask</primary></indexterm>
      <indexterm><primary>Berechtigungen</primary><secondary>Maske</secondary></indexterm>
      <indexterm><primary>Maske</primary><secondary>Berechtigungsmaske</secondary></indexterm>

      <para>Wenn Sie einen neuen oktalen Wert eingeben, verändert der Befehl <command>umask</command> die Maske. Bei Verwendung in der Startdatei einer Shell (zum Beispiel <filename>~/.bash_profile</filename>) ändert er grundsätzlich die Standardmaske für Ihre Arbeitssitzungen.</para>
    </sidebar>
  </section>
  <section id="sect.administration-interfaces">
    <title>Administrations-Schnittstellen</title>
    <indexterm><primary>Schnittstelle</primary><secondary>Administrations-Schnittstelle</secondary></indexterm>
    <indexterm><primary>Administration, Schnittstellen</primary></indexterm>

    <para>Eine grafische Schnittstelle für die Administration zu benutzen, ist unter verschiedenen Umständen interessant. Ein Administrator kennt nicht unbedingt alle Konfigurationseinzelheiten für alle seine Dienste, und er hat nicht immer Zeit, auf die Suche nach der Dokumentation für eine Angelegenheit zu gehen. Eine grafische Schnittstelle für die Administration kann daher die Bereitstellung eines neuen Dienstes beschleunigen. Sie kann auch die Einrichtung von Diensten vereinfachen, die schwierig zu konfigurieren sind.</para>

    <para>Eine derartige Schnittstelle ist nur eine Hilfe und kein Selbstzweck. Auf jeden Fall muss der Administrator ihr Verhalten beherrschen, um mögliche Probleme verstehen und umgehen zu können.</para>

    <para>Since no interface is perfect, you may be tempted to try several
    solutions. This is to be avoided as much as possible, since different
    tools are sometimes incompatible in their work methods. Even if they
    all aim to be very flexible and try to adopt the configuration file
    as a single reference, they are not always able to integrate external
    changes.</para>
    <section id="sect.webmin">
      <title>Administrieren über eine Webschnittstelle: <command>webmin</command></title>
      <indexterm><primary><emphasis>webmin</emphasis></primary></indexterm>

      <para>Dies ist ohne Zweifel eine der erfolgreichsten Administrations-Schnittstellen. Es ist ein modulares System, das mittels eines Webbrowsers bedient wird und ein weites Spektrum an Bereichen und Werkzeugen abdeckt. Darüber hinaus ist es internationalisiert und in vielen Sprachen verfügbar.</para>

      <para>Sadly, <command>webmin</command> is no longer part of Debian.
      Its Debian maintainer — Jaldhar H. Vyas — removed the packages he created
      because he no longer had the time required to maintain them at an
      acceptable quality level. Nobody has officially taken over, so
      <emphasis role="distribution">Jessie</emphasis> does not have the
      <command>webmin</command> package.</para>

      <para>Auf der Webseite <literal>webmin.com</literal> ist jedoch ein inoffizielles Paket veröffentlicht. Im Gegensatz zu den originalen Debian Paketen, ist dieses Paket monolithisch; alle seine Konfigurationsmodule werden standardmäßig installiert und aktiviert, selbst wenn der dazugehörige Dienst auf dem Rechner nicht installiert ist.</para>

      <sidebar>
        <title><emphasis>SICHERHEIT</emphasis> Das Root-Passwort ändern</title>

	<para>On the first login, identification is conducted with the root
	username and its usual password. It is recommended to change the
	password used for <command>webmin</command> as soon as possible, so
	that if it is compromised, the root password for the server will
	not be involved, even if this confers important administrative
	rights to the machine.</para>

	<para>Vorsicht! Da <command>webmin</command> sehr viele Funktionen hat, könnte ein böswilliger Benutzer bei einem Zugriff die Sicherheit des gesamten Systems gefährden. Im Allgemeinen wird deshalb von der Verwendung derartiger Schnittstellen bei wichtigen Systemen mit starken Sicherheitsauflagen (Firewall, sensible Server usw.) abgeraten.</para>
      </sidebar>

      <para>Webmin wird durch eine Webschnittstelle bedient, es erfordert aber nicht die Installation von Apache. Im Grunde hat diese Software ihren eigenen integrierten Mini-Webserver. Dieser Server wartet an Port 10000 auf Anfragen und nimmt sichere HTTP-Verbindungen an.</para>

      <para>Die mitgelieferten Module decken eine große Vielfalt von Diensten ab, unter anderem:</para>
      <itemizedlist>
        <listitem>
	  <para>alle Basisdienste: Anlegen von Benutzern und Gruppen, Verwaltung von <filename>crontab</filename>-Dateien, Init-Skripten, Betrachtung von Protokolldateien usw.</para>
        </listitem>
        <listitem>
	  <para>bind: Konfigurierung eines DNS-Servers (Namensdienst);</para>
        </listitem>
        <listitem>
	  <para>postfix: Konfigurierung eines SMTP-Servers (E-Mail);</para>
        </listitem>
        <listitem>
	  <para>inetd: Konfigurierung des Superservers <command>inetd</command>;</para>
        </listitem>
        <listitem>
	  <para>quota: Verwaltung der Benutzer-Quota;</para>
        </listitem>
        <listitem>
	  <para>dhcpd: Konfigurierung eines DHCP-Servers;</para>
        </listitem>
        <listitem>
	  <para>proftpd: Konfigurierung eines FTP-Servers;</para>
        </listitem>
        <listitem>
	  <para>samba: Konfigurierung eines Samba-Dateiservers;</para>
        </listitem>
        <listitem>
	  <para>software: Installierung und Entfernung von Software aus Debian-Paketen und Systemaktualisierungen.</para>
        </listitem>
      </itemizedlist>

      <para>Die Administrations-Schnittstelle ist in einem Webbrowser über die Adresse <literal>https://localhost:10000</literal> zu erreichen. Vorsicht! Nicht alle Module sind unmittelbar nutzbar. Manchmal müssen sie durch die Angabe der Speicherorte der jeweiligen Konfigurationsdateien und einiger ausführbarer Dateien (Programme) konfiguriert werden. Häufig wird das System Sie freundlich hierauf hinweisen, wenn es ihm nicht gelingt, ein gewünschtes Modul zu aktivieren.</para>

      <sidebar>
        <title><emphasis>ALTERNATIVE</emphasis> GNOME control center</title>
        <indexterm><primary><emphasis role="pkg">gnome-control-center</emphasis></primary></indexterm>

	<para>The GNOME project also provides multiple administration
	interfaces that are usually accessible via the “Settings”
	entry in the user menu on the top right.
	<command>gnome-control-center</command> is the main program
	that brings them all together but many of the system wide
	configuration tools are effectively provided by other packages
	(<emphasis role="pkg">accountsservice</emphasis>, <emphasis role="pkg">system-config-printer</emphasis>, etc.).  Although
	they are easy to use, these applications cover only a limited
	number of base services: user management, time configuration,
	network configuration, printer configuration, and so
	on.</para>
      </sidebar>
    </section>
    <section id="sect.debconf">
      <title>Pakete konfigurieren:  <command>debconf</command></title>
      <indexterm><primary><command>debconf</command></primary></indexterm>
      <indexterm><primary><command>dpkg-reconfigure</command></primary></indexterm>

      <para>Viele Pakete werden automatisch konfiguriert, nachdem während der Installierung einige Fragen durch das Programm Debconf gestellt wurden. Diese Pakete können mit dem Befehl <command>dpkg-reconfigure <replaceable>paket</replaceable></command> neu konfiguriert werden.</para>

      <para>In den meisten Fällen sind diese Einstellungen sehr einfach; es werden nur einige wichtige Variablen in der Konfigurationsdatei geändert. Diese Variablen sind häufig zwischen zwei „Begrenzungszeilen“ gruppiert, so dass eine Neukonfigurierung des Pakets nur Einfluss auf den eingeschlossenen Bereich hat. In anderen Fällen wird eine Neukonfigurierung nichts ändern, falls das Skript eine manuelle Änderung der Konfigurationsdatei entdeckt, um so diese menschlichen Eingriffe zu bewahren (da das Skript nicht sicherstellen kann, dass seine eigenen Veränderungen nicht die vorhandenen Einstellungen stören würden).</para>

      <sidebar>
        <title><emphasis>DEBIAN-RICHTLINIEN</emphasis> Veränderungen bewahren</title>

	<para>Die Debian-Richtlinien legen ausdrücklich fest, dass alles getan werden sollte, um manuelle Veränderungen einer Konfigurationsdatei zu bewahren. Daher treffen immer mehr Skripten Vorsichtsmaßnahmen, wenn sie Konfigurationsdateien editieren. Das allgemeine Prinzip ist einfach: das Skript nimmt nur dann Änderungen vor, wenn es den Status der Konfigurationsdatei kennt, was durch einen Vergleich der Prüfsumme der Datei mit derjenigen der letzten automatisch erzeugten Datei überprüft wird. Falls sie gleich sind, ist es dem Skript erlaubt, die Konfigurationsdatei zu ändern. Anderenfalls entscheidet es, dass die Datei verändert wurde und fragt, welche Aktion es durchführen soll (eine neue Datei installieren, die alte Datei speichern oder zu versuchen, die Änderungen in die bestehende Datei zu integrieren). Dieses Vorsorgeprinzip gab es lange Zeit nur bei Debian, inzwischen haben aber auch andere Distributionen damit begonnen, es sich zu eigen zu machen.</para>

	<para>Das Programm <command>ucf</command> (aus dem gleichnamigen Debian-Paket) kann dazu verwendet werden, ein derartiges Verhalten umzusetzen.</para>
        <indexterm><primary><command>ucf</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.syslog">
    <title><command>syslog</command> Systemereignisse</title>
    <indexterm><primary><command>rsyslogd</command></primary></indexterm>
    <indexterm><primary>Dateien</primary><secondary>Protokolldateien</secondary></indexterm>
    <indexterm><primary>Protokolle</primary><secondary>verteilen</secondary></indexterm>
    <section id="sect.syslog-principe">
      <title>Prinzip und Mechanismus</title>

      <para>Der <command>rsyslogd</command>-Daemon ist für das Sammeln von Meldungen zuständig, die von den Anwendungen und vom Kernel kommen, und für ihre Verteilung auf weitere Protokolldateien (die normalerweise im Verzeichnis <filename>/var/log/</filename> gespeichert werden). Er richtet sich nach der Konfigurationsdatei <filename>/etc/rsyslog.conf</filename>.</para>

      <para>Jede Protokollmeldung ist einem Anwendungsuntersystem zugeordnet (in der Dokumentation „facility“ genannt):</para>
      <itemizedlist>
        <listitem>
	  <para><literal>auth</literal> und <literal>authpriv</literal>: für die Authentifizierung;</para>
        </listitem>
        <listitem>
	  <para><literal>cron</literal>: kommt von den Diensten für die Aufgabenterminierung <command>cron</command> und <command>atd</command>;</para>
        </listitem>
        <listitem>
	  <para><literal>daemon</literal>: betrifft einen nicht näher bestimmten Daemon (DNS, NTP usw.);</para>
        </listitem>
        <listitem>
	  <para><literal>ftp</literal>: bezieht sich auf den FTP-Server;</para>
        </listitem>
        <listitem>
	  <para><literal>kern</literal>: eine vom Kernel kommende Meldung;</para>
        </listitem>
        <listitem>
	  <para><literal>lpr</literal>: kommt vom Druck-Subsystem;</para>
        </listitem>
        <listitem>
	  <para><literal>mail</literal>: kommt vom E-Mail-Subsystem;</para>
        </listitem>
        <listitem>
	  <para><literal>news</literal>: Usenet-Subsystemmeldung (insbesondere von einem NNTP-Server [Network News Transfer Protocol], der Nachrichtenforen verwaltet);</para>
        </listitem>
        <listitem>
	  <para><literal>syslog</literal>: Meldungen vom <command>syslogd</command>-Server selbst;</para>
        </listitem>
        <listitem>
	  <para><literal>user</literal>: Benutzermeldungen (allgemein);</para>
        </listitem>
        <listitem>
	  <para><literal>uucp</literal>: Meldungen vom UUCP-Server (Unix to Unix Copy Program, ein altes vor allem zur Verteilung von E-Mails verwendetes Protokoll);</para>
        </listitem>
        <listitem>
	  <para><literal>local0</literal> bis <literal>local7</literal>: für die lokale Verwendung reserviert.</para>
        </listitem>
      </itemizedlist>

      <para>Jeder Meldung ist auch eine Prioritätsstufe zugeordnet. Hier sind sie in abnehmender Reihenfolge:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>emerg</literal>: “Help!” There is an emergency,
	  the system is probably unusable.</para>
        </listitem>
        <listitem>
	  <para><literal>alert</literal>: Beeilung! Jede Verzögerung kann gefährlich sein, es muss sofort etwas unternommen werden;</para>
        </listitem>
        <listitem>
	  <para><literal>crit</literal>: die Umstände sind kritisch;</para>
        </listitem>
        <listitem>
	  <para><literal>err</literal>: Fehler;</para>
        </listitem>
        <listitem>
	  <para><literal>warn</literal>: Warnung (möglicher Fehler);</para>
        </listitem>
        <listitem>
	  <para><literal>notice</literal>: die Umstände sind normal, aber die Meldung ist wichtig;</para>
        </listitem>
        <listitem>
	  <para><literal>info</literal>: aufschlussreiche Meldung;</para>
        </listitem>
        <listitem>
	  <para><literal>debug</literal>: Fehlerbeseitigungsmeldung.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="sect.syslog-config">
      <title>Die Konfigurationsdatei</title>

      <para>Die Syntax der Datei <filename>/etc/rsyslog.conf</filename> ist auf der Handbuchseite <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> ausführlich erläutert, im Paket <emphasis role="pkg">rsyslog-doc</emphasis> findet sich aber auch eine HTML-Dokumentation (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>). Das Grundprinzip besteht darin, Paare von „selector“ und „action“ zu verfassen. Der Selektor bestimmt alle relevanten Meldungen, und die Aktionen beschreiben, wie mit ihnen umzugehen ist.</para>
      <section id="sect.syslog-selector-syntax">
        <title>Syntax des Selektors</title>

	<para>Der Selektor ist eine durch Semikolon getrennte Liste von <literal><replaceable>subsystem</replaceable>.<replaceable>priorität</replaceable></literal>-Paaren (Beispiel: <literal>auth.notice;mail.info</literal>). Ein Stern kann für alle Subsysteme oder alle Prioritäten stehen (Beispiele: <literal>*.alert</literal> oder <literal>mail.*</literal>). Mehrere Subsysteme können in einer Gruppe zusammengefasst werden, indem sie durch ein Komma getrennt werden (Beispiel: <literal>auth,mail.info</literal>). Die angezeigte Priorität bezieht sich auch auf Meldungen gleicher oder höherer Priorität; so bezeichnet <literal>auth.alert</literal> Meldungen des <literal>auth</literal>-Subsystems mit der Priorität <literal>alert</literal> oder <literal>emerg</literal>. Mit einem vorangestellten Ausrufezeichen (!) bezeichnen sie das Gegenteil, mit anderen Worten nur die niedrigeren Prioritäten; so bezeichnet <literal>auth.!notice</literal> Meldungen, die von <literal>auth</literal> mit den Prioritäten <literal>info</literal> oder <literal>debug</literal> verschickt worden sind. Mit einem vorangestellten Gleichheitszeichen (=) beziehen sie sich genau und ausschließlich auf die angegebene Priorität (bei <literal>auth.=notice</literal> handelt es sich ausschließlich um Meldungen von <literal>auth</literal> mit der Priorität <literal>notice</literal>).</para>

	<para>Jedes Element in der Selektorliste setzt vorhergehende Elemente außer Kraft. Es ist somit möglich, eine Menge einzugrenzen oder bestimmte Elemente von ihr auszuschließen. Zum Beispiel bezeichnet <literal>kern.info;kern.!err</literal> Meldungen vom Kernel mit einer Priorität zwischen <literal>info</literal> und <literal>warn</literal>. Die Priorität <literal>none</literal> bezeichnet die leere Menge (keine Prioritäten) und kann dazu dienen, ein Subsystem von einer Menge von Meldungen auszuschließen. So bezeichnet <literal>*.crit;kern.none</literal> alle Meldungen mit der Priorität <literal>crit</literal> oder höher, die nicht vom Kernel kommen.</para>
      </section>
      <section id="sect.syslog-action-syntax">
        <title>Syntax der Aktionen</title>

        <sidebar>
          <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Die benannte Pipe, eine beständige Pipe</title>
          <indexterm><primary>benannte Pipe</primary></indexterm>
          <indexterm><primary>Pipe, benannte Pipe</primary></indexterm>

	  <para>Eine benannte Pipe ist eine besondere Dateiart, die wie eine gewöhnliche Pipe funktioniert (die Pipe, die man mit dem Symbol „|“ auf der Befehlszeile erstellt), aber mittels einer Datei. Dieses Vorgehen hat den Vorteil, dass sich so zwei unzusammenhängende Prozesse verknüpfen lassen. Alles, was in eine benannte Pipe geschrieben wird, hält den schreibenden Prozess an, bis ein anderer Prozess die geschriebenen Daten zu lesen versucht. Dieser zweite Prozess liest die Daten, die vom ersten geschrieben wurden, der daraufhin seinen Ablauf wieder aufnehmen kann.</para>

	  <para>Eine derartige Datei wird durch den Befehl <command>mkfifo</command> erstellt.</para>
        </sidebar>

	<para>Die verschiedenen möglichen Aktionen sind:</para>
        <itemizedlist>
          <listitem>
	    <para>die Meldung zu einer Datei hinzufügen (Beispiel: <filename>/var/log/messages</filename>);</para>
          </listitem>
          <listitem>
	    <para>die Meldung an einen entfernten <command>syslog</command>-Server schicken (Beispiel: <literal>@log.falcot.com</literal>);</para>
          </listitem>
          <listitem>
	    <para>die Meldung an eine bestehende benannte Pipe schicken (Beispiel: <literal>|/dev/xconsole</literal>);</para>
          </listitem>
          <listitem>
	    <para>die Meldung an einen oder mehrere Benutzer schicken, falls sie angemeldet sind (Beispiel: <literal>root,rhertzog</literal>);</para>
          </listitem>
          <listitem>
	    <para>die Meldung an alle angemeldeten Benutzer schicken (Beispiel: <literal>*</literal>);</para>
          </listitem>
          <listitem>
	    <para>die Nachricht in eine Textkonsole schreiben (Beispiel: <literal>/dev/tty8</literal>).</para>
          </listitem>
        </itemizedlist>

        <sidebar>
          <title><emphasis>SICHERHEIT</emphasis> Protokolle weiterleiten</title>
          <indexterm><primary>Protokoll</primary><secondary>weiterleiten</secondary></indexterm>

	  <para>Es empfiehlt sich, die wichtigsten Protokolle auf einem getrennten Rechner aufzuzeichnen (vielleicht auf einem, der speziell diesem Zweck dient), da dies einen möglichen Eindringling daran hindert, Spuren seines Eindringens zu verwischen (es sei denn natürlich, dass er auch diesen anderen Server kompromittiert). Außerdem sind im Falle eines wesentlichen Problems (wie einem Kernel-Crash) die Protokolle auf einem anderen Rechner verfügbar, was die Chancen erhöht, den Ablauf der Ereignisse, die den Crash verursacht haben, zu bestimmen.</para>

	  <para>Für den Empfang von Protokollmeldungen, die von anderen Rechnern geschickt werden, müssen Sie die Konfiguration von <emphasis>rsyslog</emphasis> ändern: im Prinzip reicht es aus, die gebrauchsfertigen Einträge in <filename>/etc/rsyslog.conf</filename> (<literal>$ModLoad imudp</literal> und <literal>$UDPServerRun 514</literal>) zu aktivieren.</para>
        </sidebar>
      </section>
    </section>
  </section>
  <section id="sect.inetd">
    <title>Der Superserver <command>inetd</command></title>

    <para>Inetd (häufig „Internet-Superserver“ genannt) ist ein Server der Server. Er führt selten genutzte Server nach Bedarf aus, so dass sie nicht ständig laufen müssen.</para>
    <indexterm><primary><command>inetd</command></primary></indexterm>
    <indexterm><primary>Superserver</primary></indexterm>

    <para>Die Datei <filename>/etc/inetd.conf</filename> listet diese Server und ihre üblichen Ports auf. Der Befehl <command>inetd</command> wartet an allen diesen Ports auf Anfragen; wenn er eine Verbindung zu einem dieser Ports entdeckt, führt er das entsprechende Serverprogramm aus.</para>

    <sidebar>
      <title><emphasis>DEBIAN-RICHTLINIEN</emphasis> Einen Server in <filename>inetd.conf</filename> registrieren</title>

      <para>Packages frequently want to register a new server in the
      <filename>/etc/inetd.conf</filename> file, but Debian Policy
      prohibits any package from modifying a configuration file that it
      doesn't own. This is why the <command>update-inetd</command> script
      (in the package with the same name) was created: It manages the
      configuration file, and other packages can thus use it to register a
      new server to the super-server's configuration.</para>
    </sidebar>

    <para>Jede signifikante Zeile der Datei <filename>/etc/inetd.conf</filename> beschreibt einen Server in sieben Feldern (getrennt durch Leerzeichen):</para>
    <itemizedlist>
      <listitem>
	<para>Die TCP- oder UDP-Portnummer, oder der Dienstname (der einer Standardportnummer mit der Information, die in der Datei <filename>/etc/services</filename> enthalten ist, zugeordnet ist).</para>
      </listitem>
      <listitem>
	<para>Der Socket-Typ: <literal>stream</literal> für eine TCP-Verbindung, <literal>dgram</literal> für UDP-Datagramme.</para>
      </listitem>
      <listitem>
	<para>Das Protokoll: <literal>tcp</literal> oder <literal>udp</literal>.</para>
      </listitem>
      <listitem>
	<para>Die Optionen: zwei mögliche Werte: <literal>wait</literal> oder <literal>nowait</literal>, um <command>inetd</command> mitzuteilen, ob er auf das Ende des gestarteten Prozesses warten soll, bevor er eine andere Verbindung annimmt, oder nicht. Für TCP-Verbindungen, die einen Kanal leicht mehrfach nutzen können, können Sie normalerweise <literal>nowait</literal> verwenden. Für Programme, die über UDP antworten, sollten Sie <literal>nowait</literal> nur dann verwenden, wenn der Server in der Lage ist, mehrere Verbindungen parallel zu verwalten. Sie können an dieses Feld einen Punkt anhängen, gefolgt von der Höchstzahl der Verbindungen, die pro Minute erlaubt ist (der Standardgrenzwert ist 256).</para>
      </listitem>
      <listitem>
	<para>Der Benutzername des Benutzers, unter dessen Identität der Server laufen wird.</para>
      </listitem>
      <listitem>
	<para>Der vollständige Pfad zu dem auszuführenden Serverprogramm.</para>
      </listitem>
      <listitem>
	<para>Die Argumente: dies ist eine vollständige Liste der Argumente des Programms einschließlich seines eigenen Namens (<literal>argv[0]</literal> in C).</para>
      </listitem>
    </itemizedlist>

    <para>Das folgende Beispiel illustriert die häufigsten Fälle:</para>

    <example id="example.inetd-conf">
      <title>Auszug aus <filename>/etc/inetd.conf</filename></title>

      <programlisting>talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd
finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd
ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i
</programlisting>
    </example>
    <indexterm><primary><command>tcpd</command></primary></indexterm>

    <para>Das Programm <command>tcpd</command> wird in <filename>/etc/inetd.conf</filename> häufig benutzt. Es ermöglicht es, ankommende Verbindungen durch die Verwendung von Zugangskontrollregeln einzuschränken, die auf der Handbuchseite <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry> dokumentiert sind, und die in den Dateien <filename>/etc/hosts.allow</filename> und <filename>/etc/hosts.deny</filename> konfiguriert sind. Sobald feststeht, dass die Verbindung autorisiert ist, führt <command>tcpd</command>  den eigentlich zuständigen Server aus (wie <command>/usr/bin/in.fingerd</command> in unserem Beispiel). Es ist wichtig anzumerken, dass <command>tcpd</command> auf den Namen zurückgreift, mit welchem es aufgerufen wurde (das ist das erste Argument, <literal>argv[0]</literal>), um das tatsächlich auszuführende Programm zu ermitteln. Sie sollten deshalb die Parameterliste nicht mit <literal>tcpd</literal> beginnen, sondern mit dem Programm, zu dem umgeleitet werden soll.</para>

    <sidebar>
      <title><emphasis>GEMEINSCHAFT</emphasis> Wietse Venema</title>
      <indexterm><primary>Wietse Venema</primary></indexterm>
      <indexterm><primary>Venema, Wietse</primary></indexterm>

      <para>Wietse Venema, dessen Fachkenntnis im Bereich Sicherheit ihn zu einem angesehenen Programmierer gemacht hat, ist der Verfasser des <command>tcpd</command>-Programms. Er ist auch der Haupturheber von Postfix, dem modularen E-Mail-Server (SMTP, Simple Mail Transfer Protocol), der dafür ausgelegt ist, sicherer und verlässlicher zu sein als <command>sendmail</command>, das sich durch eine lange Vorgeschichte von Sicherheitsschwachstellen auszeichnet.</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> Weitere <command>inetd</command> Befehle</title>

      <para>Debian installiert zwar standardmäßig <emphasis role="pkg">openbsd-inetd</emphasis>, aber es gibt genügend Alternativen: <emphasis role="pkg">inetutils-inetd</emphasis>, <emphasis role="pkg">micro-inetd</emphasis>, <emphasis role="pkg">rlinetd</emphasis> and <emphasis role="pkg">xinetd</emphasis> um nur einige zu nennen.</para>

      <para>Diese jüngste Verkörperung eines Superservers bietet sehr interessante Möglichkeiten. Dazu gehört vor allem, dass seine Konfiguration in mehrere Dateien aufgeteilt werden kann (die natürlich im Verzeichnis <filename>/etc/xinetd.d/</filename> gespeichert werden), wodurch das Leben eines Administrators erleichtert werden kann.</para>

      <para>Last but not least, it is even possible to emulate <command>inetd</command>'s
      behaviour with <command>systemd</command>'s socket-activation
      mechanism (see <xref linkend="sect.systemd" />).</para>
    </sidebar>
  </section>
  <section id="sect.task-scheduling-cron-atd">
    <title>Aufgaben mit <command>cron</command> und <command>atd</command> zeitlich festlegen</title>
    <indexterm><primary><command>cron</command></primary></indexterm>
    <indexterm><primary><command>atd</command></primary></indexterm>
    <indexterm><primary>zeitlich festgelegte Befehle</primary></indexterm>
    <indexterm><primary>Befehle zeitlich festlegen</primary></indexterm>

    <para><command>cron</command> ist der für die Ausführung zeitlich festgelegter und sich wiederholender Befehle (täglich, wöchentlich usw.) zuständige Daemon; <command>atd</command> erledigt nur einmal auszuführende Befehle, jedoch zu einem bestimmten Zeitpunkt in der Zukunft.</para>

    <para>In einem Unix-System sind viele Aufgaben für eine regelmäßige Ausführung zeitlich festgelegt:</para>
    <itemizedlist>
      <listitem>
	<para>die Protokolldateien rotieren;</para>
      </listitem>
      <listitem>
	<para>die Datenbank für das Programm <command>locate</command> aktualisieren;</para>
      </listitem>
      <listitem>
	<para>Daten sichern;</para>
      </listitem>
      <listitem>
	<para>Wartungsskripten ausführen (wie das Entfernen temporärer Dateien).</para>
      </listitem>
    </itemizedlist>

    <para>Standardmäßig können alle Benutzer die Ausführung von Aufgaben planen. Daher hat jeder Benutzer sein eigenes <emphasis>crontab</emphasis>, in dem er seine geplanten Befehle eintragen kann. Es kann mit dem Aufruf von <command>crontab -e</command> editiert werden (sein Inhalt ist in der Datei <filename>/var/spool/cron/crontabs/<replaceable>benutzer</replaceable></filename> gespeichert).</para>

    <sidebar>
      <title><emphasis>SICHERHEIT</emphasis> <command>cron</command> und <command>atd</command> einschränken</title>

      <para>Sie können den Zugriff auf <command>cron</command> einschränken, indem Sie eine ausdrückliche Autorisierungsdatei (Whitelist) in <filename>/etc/cron.allow</filename> anlegen, in der Sie nur diejenigen Benutzer angeben, denen es erlaubt ist, Befehle zeitlich festzulegen. Allen übrigen wird diese Fähigkeit automatisch entzogen. Um im umgekehrten Fall ein oder zwei Störenfriede auszusperren, können Sie ihre Benutzernamen in die ausdrückliche Verbotsliste (Blacklist) <filename>/etc/cron.deny</filename> eintragen. Das gleiche Merkmal steht auch für <command>atd</command> mit den Dateien <filename>/etc/at.allow</filename> und <filename>/etc/at.deny</filename> zur Verfügung.</para>
    </sidebar>

    <para>Der Root-Benutzer hat sein eigenes <emphasis>crontab</emphasis>, kann aber auch die Datei <filename>/etc/crontab</filename> benutzen oder zusätzliche <emphasis>crontab</emphasis>-Dateien in das Verzeichnis <filename>/etc/cron.d</filename> eintragen. Die beiden letztgenannten Lösungen haben den Vorteil, dass man mit ihnen die Benutzeridentität spezifizieren kann, die bei der Ausführung des Befehls verwendet werden muss.</para>

    <para>Das Paket <emphasis>cron</emphasis> enthält standardmäßig einige zeitlich festgelegte Befehle, die folgendes ausführen:</para>
    <itemizedlist>
      <listitem>
	<para>stündlich Programme im Verzeichnis <filename>/etc/cron.hourly/</filename>;</para>
      </listitem>
      <listitem>
	<para>täglich Programme in <filename>/etc/cron.daily/</filename>;</para>
      </listitem>
      <listitem>
	<para>wöchentlich Programme in <filename>/etc/cron.weekly/</filename>;</para>
      </listitem>
      <listitem>
	<para>monatlich Programme in <filename>/etc/cron.monthly/</filename>.</para>
      </listitem>
    </itemizedlist>

    <para>Viele Debian-Pakete sind auf diesen Dienst angewiesen: indem sie Wartungsskripten in diese Verzeichnisse legen, stellen sie den optimalen Betrieb ihrer Dienste sicher.</para>
    <section id="sect.format-crontab">
      <title>Aufbau der Datei <filename>crontab</filename></title>
      <indexterm><primary><filename>crontab</filename></primary></indexterm>

      <sidebar>
        <title><emphasis>TIPP</emphasis> Abkürzungen für <command>cron</command></title>

	<para><command>cron</command> erkennt einige Abkürzungen, die die ersten fünf Felder eines <filename>crontab</filename>-Eintrags ersetzen. Sie entsprechen den üblichsten Optionen für die Zeitplanung:</para>
        <itemizedlist>
          <listitem>
	    <para><literal>@yearly</literal>: jährlich (1. Januar um 00:00 Uhr);</para>
          </listitem>
          <listitem>
	    <para><literal>@monthly</literal>: monatlich (am Ersten des Monats um 00:00 Uhr);</para>
          </listitem>
          <listitem>
	    <para><literal>@weekly</literal>: wöchentlich (sonntags um  00:00 Uhr);</para>
          </listitem>
          <listitem>
	    <para><literal>@daily</literal>: täglich (um 00:00 Uhr);</para>
          </listitem>
          <listitem>
	    <para><literal>@hourly</literal>: stündlich (zu Beginn jeder Stunde).</para>
          </listitem>
        </itemizedlist>
      </sidebar>

      <sidebar>
        <title><emphasis>SPECIAL CASE</emphasis> <command>cron</command> and daylight savings time</title>

	<para>In Debian berücksichtigt <command>cron</command> die Zeitumstellung (für die Sommerzeit oder genau genommen für jede bedeutende Änderung der Ortszeit) so gut wie möglich. So werden die Befehle, die während einer nicht existenten Stunde hätten ausgeführt werden sollen (zum Beispiel Aufgaben, die für 02:30 Uhr während der Zeitumstellung im Frühjahr geplant waren, da die Uhr um 02:00 Uhr direkt auf 03:00 Uhr springt), kurz nach der Zeitumstellung (das heißt um 03:00 Uhr Sommerzeit) ausgeführt. Andererseits werden Befehle im Herbst, wenn sie mehrmals ausgeführt würden (um 02:30 Uhr Sommerzeit und dann wieder eine Stunde später um 02:30 Uhr Normalzeit, da die Uhr um 03:00 Uhr Sommerzeit auf 02:00 Uhr zurückspringt), nur einmal ausgeführt.</para>

	<para>Seien Sie jedoch vorsichtig: wenn die Reihenfolge, in der verschiedene geplante Aufgaben ausgeführt werden, und die Verzögerung zwischen den jeweiligen Ausführungszeitpunkten eine Rolle spielt, sollten Sie die Kompatibilität dieser Einschränkungen mit dem Verhalten von <command>cron</command> überprüfen; falls erforderlich, können Sie einen speziellen Zeitplan für die beiden problematischen Nächte des Jahres aufstellen.</para>
      </sidebar>

      <para>Jede wesentliche Zeile eines <emphasis>crontab</emphasis> legt einen zeitlich festgelegten Befehl mit den folgenden sechs (oder sieben) Feldern fest:</para>
      <itemizedlist>
        <listitem>
	  <para>den Wert für die Minute (Zahl von 0 bis 59);</para>
        </listitem>
        <listitem>
	  <para>den Wert für die Stunde (von 0 bis 23);</para>
        </listitem>
        <listitem>
	  <para>den Wert für den Tag des Monats (von 1 bis 31);</para>
        </listitem>
        <listitem>
	  <para>den Wert für den Monat (von 1 bis 12);</para>
        </listitem>
        <listitem>
	  <para>den Wert für den Wochentag (von 0 bis 7, wobei 1 dem Montag entspricht und Sonntag sowohl durch 0 als auch durch 7 dargestellt wird; es ist auch möglich, die ersten drei Buchstaben des englischen Namens des Wochentages zu verwenden, wie <literal>Sun</literal>, <literal>Mon</literal> usw.);</para>
        </listitem>
        <listitem>
	  <para>den Benutzernamen, unter dessen Identität der Befehl ausgeführt werden muss (in der Datei <filename>/etc/crontab</filename> und in den Fragmenten, die sich in <filename>/etc/cron.d/</filename> befinden, aber nicht in den eigenen crontab-Dateien des Benutzers);</para>
        </listitem>
        <listitem>
	  <para>den auszuführenden Befehl (wenn die durch die ersten fünf Spalten festgelegten Bedingungen erfüllt sind).</para>
        </listitem>
      </itemizedlist>

      <para>Alle diese Einzelheiten sind auf der Handbuchseite <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> dokumentiert.</para>

      <para>Jeder Wert kann in Form einer Liste der möglichen Werte (durch Kommata getrennt) angegeben werden. Die Syntax <literal>a-b</literal> bezeichnet das Intervall aller Werte zwischen <literal>a</literal> und <literal>b</literal>. Die Syntax <literal>a-b/c</literal> bezeichnet das Intervall mit einer schrittweisen Erhöhung um <literal>c</literal> (Beispiel: <literal>0-10/2</literal> bedeutet <literal>0,2,4,6,8,10</literal>). Ein Stern <literal>*</literal> ist ein Platzhalter, der alle möglichen Werte vertritt.</para>

      <example id="example.crontab">
        <title>Beispiel einer <filename>crontab</filename>-Datei</title>

        <programlisting>#Format
#Minute Stunde Tag Monat Wochentag  Befehl

# Daten jeden Abend um 19:25 Uhr herunterladen
 25  19   *   *   *    $HOME/bin/get.pl

# Werktags (Montag bis Freitag) um 8:00 Uhr
 00  08   *   *   1-5  $HOME/bin/tu_etwas

# Den IRC-Proxy nach jedem Hochfahren neu starten
@reboot /usr/bin/dircproxy
</programlisting>
      </example>

      <sidebar>
        <title><emphasis>TIPP</emphasis> Einen Befehl beim Hochfahren ausführen</title>

	<para>Um einen Befehl unmittelbar nach dem Hochfahren des Rechners einmal auszuführen, können Sie das Makro <literal>@reboot</literal> verwenden (ein einfacher Neustart von <command>cron</command> löst keinen Befehl aus, der mit <literal>@reboot</literal> eingerichtet worden ist). Dieses Makro ersetzt die ersten fünf Felder eines <emphasis>crontab</emphasis>-Eintrags.</para>
      </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> Emulating <command>cron</command> with <command>systemd</command></title>

      <para>It is possible to emulate part of
      <command>cron</command>'s behaviour with
      <command>systemd</command>'s timer mechanism (see <xref linkend="sect.systemd" />).</para>
    </sidebar>

    </section>
    <section id="sect.at-command">
      <title>Verwendung des Befehls <command>at</command></title>
      <indexterm><primary><command>at</command></primary></indexterm>

      <para>The <command>at</command> executes a command at a specified
      moment in the future. It takes the desired time and date as
      command-line parameters, and the command to be executed in its
      standard input. The command will be executed as if it had been
      entered in the current shell. <command>at</command> even takes care
      to retain the current environment, in order to reproduce the same
      conditions when it executes the command. The time is indicated by
      following the usual conventions: <literal>16:12</literal> or
      <literal>4:12pm</literal> represents 4:12 pm. The date can be
      specified in several European and Western formats, including
      <literal>DD.MM.YY</literal> (<literal>27.07.15</literal> thus
      representing 27 July 2015), <literal>YYYY-MM-DD</literal> (this same
      date being expressed as <literal>2015-07-27</literal>),
      <literal>MM/DD/[CC]YY</literal> (ie., <literal>12/25/15</literal> or
      <literal>12/25/2015</literal> will be December 25, 2015), or simple
      <literal>MMDD[CC]YY</literal> (so that <literal>122515</literal> or
      <literal>12252015</literal> will, likewise, represent December 25,
      2015). Without it, the command will be executed as soon as the clock
      reaches the time indicated (the same day, or tomorrow if that time
      has already passed on the same day). You can also simply write
      “today” or “tomorrow”, which is self-explanatory.</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>
<computeroutput>&gt; </computeroutput><userinput>echo "Don't forget to wish a Happy Birthday to Raphaël!" \</userinput>
<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>
<computeroutput>&gt; </computeroutput><userinput>END</userinput>
<computeroutput>warning: commands will be executed using /bin/sh
job 31 at Mon Jul 27 09:00:00 2015</computeroutput>
</screen>

      <para>Eine andere Syntax verschiebt die Ausführung um eine bestimmte Zeit: <command>at now + <replaceable>zahl</replaceable> <replaceable>dauer</replaceable></command>. Die <replaceable>dauer</replaceable> kann <literal>minutes</literal>, <literal>hours</literal>, <literal>days</literal> oder <literal>weeks</literal> sein. Die <replaceable>zahl</replaceable> zeigt lediglich die Anzahl der genannten Einheiten an, die vor der Ausführung des Befehls verstrichen sein müssen.</para>

      <para>Um eine mit <command>cron</command> geplante Aufgabe zu annullieren, führen Sie einfach <command>crontab -e</command> aus und löschen die entsprechende Zeile in der <emphasis>crontab</emphasis>-Datei. Für <command>at</command>-Aufgaben ist es fast genauso einfach: Führen Sie <command>atrm <replaceable>aufgabennummer</replaceable></command> aus. Die Nummer einer Aufgabe wird vom <command>at</command>-Befehl angezeigt, wenn Sie sie planen, aber Sie können sie auch mit dem Befehl <command>atq</command> wiederfinden, der die aktuelle Liste der geplanten Aufgaben ausgibt.</para>
      <indexterm><primary><command>atrm</command></primary></indexterm>
      <indexterm><primary><command>atq</command></primary></indexterm>
    </section>
  </section>
  <section id="sect.asynchronous-task-scheduling-anacron">
    <title>Asynchrone Aufgaben planen: <command>anacron</command></title>

    <para><command>anacron</command> ist ein Daemon, der <command>cron</command> für solche Rechner ergänzt, die nicht ständig laufen. Da regelmäßige Aufgaben normalerweise für die Nacht geplant sind, werden sie nie ausgeführt, falls der Rechner zu dieser Zeit ausgeschaltet ist. Der Zweck von <command>anacron</command> besteht darin, sie unter Berücksichtigung der Zeiten, in denen der Rechner nicht läuft, auszuführen.</para>
    <indexterm><primary><command>anacron</command></primary></indexterm>

    <para>Bitte beachten Sie, dass <command>anacron</command> derartige Aktivitäten häufig einige Minuten nach dem Hochfahren des Rechners ausführen wird, wodurch der Computer langsamer reagieren kann. Daher werden Aufgaben in der Datei <filename>/etc/anacrontab</filename> mit dem Befehl <command>nice</command> gestartet, der ihre Ausführungspriorität reduziert und so ihren Einfluss auf das übrige System begrenzt. Vorsicht, das Format dieser Datei ist nicht das gleiche wie <filename>/etc/crontab</filename>; falls Sie besondere Anforderungen an <command>anacron</command> haben, sehen Sie auf der Handbuchseite <citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> nach.</para>

    <sidebar>
      <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Prioritäten und der Befehl <command>nice</command></title>

      <para>Unix-Systeme (und damit auch Linux) sind Mehrprogramm- und Mehrplatzsysteme. So können mehrere Prozesse parallel laufen und verschiedenen Benutzern gehören: der Kernel vermittelt den Ressourcenzugang zwischen den verschiedenen Prozessen. Als Teil dieser Aufgabe verfügt er über ein Prioritätenkonzept, das es ihm erlaubt, je nach Bedarf bestimmte Prozesse gegenüber anderen zu begünstigen. Wenn Sie wissen, dass ein Prozess mit geringer Priorität laufen kann, können Sie dies anzeigen, indem Sie ihn mit <command>nice <replaceable>programm</replaceable></command> laufen lassen. Das Programm wird dann einen geringeren Anteil an der CPU einnehmen und weniger Auswirkungen auf andere laufende Prozesse haben. Falls kein anderer Prozess laufen muss, wird das Programm natürlich nicht künstlich zurückgehalten.</para>

      <para><command>nice</command> arbeitet mit Stufen von „niceness“: die positiven Stufen (von 1 bis 19) verringern zunehmend die Priorität, während die negativen Stufen (von -1 bis -20) sie erhöhen - aber nur Root kann diese negativen Stufen benutzen. Falls nichts anderes angegeben ist (siehe die Handbuchseite <citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry>), erhöht <command>nice</command> die aktuelle Stufe um 10.</para>

      <para>If you discover that an already running task should have been
      started with <command>nice</command> it is not too late to fix it;
      the <command>renice</command> command changes the priority of an
      already running process, in either direction (but reducing the
      “niceness” of a process is reserved for the root user).</para>
    </sidebar>

    <para>Das Installieren des Pakets <emphasis role="pkg">anacron</emphasis> deaktiviert die Ausführung der Skripten in den Verzeichnissen <filename>/etc/cron.hourly/</filename>, <filename>/etc/cron.daily/</filename>, <filename>/etc/cron.weekly/</filename> und <filename>/etc/cron.monthly/</filename> durch <command>cron</command>. Hierdurch wird eine doppelte Ausführung durch <command>anacron</command> und <command>cron</command> vermieden. Der Befehl <command>cron</command> bleibt jedoch aktiv und führt die übrigen geplanten Aufgaben aus (vor allem die von den Benutzern geplanten).</para>
  </section>
  <section id="sect.quotas">
    <title>Quoten</title>
    <indexterm><primary>quota</primary></indexterm>

    <para>The quota system allows limiting disk space allocated to a user
    or group of users. To set it up, you must have a kernel that supports
    it (compiled with the <varname>CONFIG_QUOTA</varname> option) — as is
    the case with Debian kernels. The quota management software is found in
    the <emphasis role="pkg">quota</emphasis> Debian package.</para>

    <para>To activate quota in a filesystem, you have to indicate the
    <literal>usrquota</literal> and <literal>grpquota</literal> options in
    <filename>/etc/fstab</filename> for the user and group quotas,
    respectively. Rebooting the computer will then update the quotas in the
    absence of disk activity (a necessary condition for proper accounting
    of already used disk space).</para>

    <para>Der Befehl <command>edquota <replaceable>benutzer</replaceable></command> (oder <command>edquota -g <replaceable>gruppe</replaceable></command>) ermöglicht es Ihnen, die Grenzwerte zu ändern und zugleich die aktuelle Verwendung des Speicherplatzes zu überprüfen.</para>
    <indexterm><primary><command>edquota</command></primary></indexterm>

    <sidebar>
      <title><emphasis>WEITERE SCHRITTE</emphasis> Quota mit einem Skript festlegen</title>
      <indexterm><primary><command>setquota</command></primary></indexterm>

      <para>Das Programm <command>setquota</command> kann dazu verwendet werden, mithilfe eines Skripts selbsttätig zahlreiche Quota zu ändern. Seine Handbuchseite <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry> beschreibt ausführlich die zu verwendende Syntax.</para>
    </sidebar>

    <para>Das Quota-System ermöglicht es Ihnen, vier Grenzen zu setzen:</para>
    <itemizedlist>
      <listitem>
	<para>zwei Grenzen („weich“ und „hart“ genannt) beziehen sich auf die Anzahl der verwendeten Blöcke. Falls das Dateisystem mit einer Blockgröße von 1 Kilobyte erstellt wurde, enthält ein Block 1024 Bytes derselben Datei. Unvollständig gefüllte Blöcke führen daher zu einem Verlust an Speicherplatz. Eine Quota von 100 Blöcken, die es theoretisch erlaubt, 102.400 Bytes zu speichern, ist mit nur 100 Dateien zu je 500 Bytes vollständig gefüllt, was insgesamt nur 50.000 Bytes entspricht.</para>
      </listitem>
      <listitem>
	<para>zwei Grenzen (weich und hart) beziehen sich auf die Anzahl der verwendeten Inodes. Jede Datei belegt wenigstens einen Inode, um Informationen über sich zu speichern (Berechtigungen, Eigentümer, Zeitstempel des letzten Zugriffs usw.). Sie sind daher Grenzen für die Anzahl von Benutzerdateien.</para>
      </listitem>
    </itemizedlist>

    <para>Eine „weiche“ Grenze kann vorübergehend überschritten werden; der Benutzer wird lediglich durch den Befehl <command>warnquota</command>, der gewöhnlich durch <command>cron</command> aufgerufen wird, gewarnt, dass er die Quota überschreitet. Eine „harte“ Grenze kann niemals überschritten werden; das System weist jede Operation ab, die zu einem Überschreiten einer harten Quota führen würde.</para>

    <sidebar>
      <title><emphasis>WÖRTERVERZEICHNIS</emphasis> Blöcke und Inodes</title>
      <indexterm><primary>Block (Speicherplatte)</primary></indexterm>
      <indexterm><primary>Inode</primary></indexterm>

      <para>Das Dateisystem unterteilt die Festplatte in Blöcke - kleine zusammenhängende Bereiche. Die Größe dieser Blöcke wird während der Erstellung des Dateisystems festgelegt und variiert normalerweise zwischen 1 und 8 Kilobytes.</para>

      <para>Ein Block kann entweder dazu genutzt werden, die tatsächlichen Daten einer Datei zu speichern oder die vom Dateisystem verwendeten Meta-Daten. Zu diesen Meta-Daten gehören insbesondere die Inodes. Ein Inode belegt einen Block auf der Festplatte (aber dieser Block wird bei der Block-Quota nicht berücksichtigt, sondern nur bei der Inode-Quota) und enthält sowohl Informationen über die Datei, zu der er gehört (Name, Eigentümer, Berechtigungen usw.), als auch die Zeiger zu den Datenblöcken, die tatsächlich genutzt werden. Für sehr große Dateien, die mehr Blöcke belegen, als in einem einzelnen Inode referenziert werden können, gibt es ein indirektes Blocksystem; der Inode verweist auf eine Liste von Blöcken, die nicht direkt Daten enthalten, sondern eine Liste anderer Blöcke.</para>
    </sidebar>
    <indexterm><primary><command>warnquota</command></primary></indexterm>

    <para>Mit dem Befehl <command>edquota -t</command> können Sie eine höchstens erlaubte „Schonfrist“ festlegen, bis zu der eine weiche Grenze überschritten werden darf. Nach Ablauf dieser Frist wird die weiche Grenze wie eine harte behandelt, und der Benutzer muss seinen Speicherplatzverbrauch auf diese Grenze zurückführen, um etwas auf die Festplatte schreiben zu können.</para>

    <sidebar>
      <title><emphasis>WEITERE SCHRITTE</emphasis> Eine Standardquota für neue Benutzer einrichten</title>

      <para>Um automatisch eine Quota für neue Benutzer festzulegen, müssen Sie (mit <command>edquota</command> oder <command>setquota</command>) einen Muster-Benutzer konfigurieren und seinen Benutzernamen in der <varname>QUOTAUSER</varname>-Variablen der Datei <filename>/etc/adduser.conf</filename> angeben. Diese Quota-Konfiguration wird dann selbsttätig auf jeden Benutzer angewendet, der mit dem Befehl <command>adduser</command> erstellt wird.</para>
    </sidebar>
  </section>
  <section id="sect.backup">
    <title>Datensicherung</title>

    <para>Das Erstellen von Sicherheitskopien ist eine der Hauptaufgaben eines Administrators, aber es ist ein kompliziertes Thema mit mächtigen Werkzeugen, die häufig schwierig zu bedienen sind.</para>
    <indexterm><primary>Sicherheitskopie</primary></indexterm>
    <indexterm><primary>Wiederherstellung</primary></indexterm>

    <para>Es gibt viele Programme, wie zum Beispiel <command>amanda</command>, <command>bacula</command>, <command>BackupPC</command>. Das sind Client/Server-Systeme mit vielen Optionen, deren Konfiguration ziemlich schwierig ist. Einige davon bieten benutzerfreundliche Webschnittstellen, um das zu vereinfachen. Debian enthält dutzende weitere Backup-Pakete die alle möglichen Anwendungsfälle abdecken, wie man leicht mit dem Befehl <command>apt-cache search backup</command> feststellen kann.</para>
    <indexterm><primary><command>amanda</command></primary></indexterm>
    <indexterm><primary><command>bacula</command></primary></indexterm>
    <indexterm><primary><command>BackupPC</command></primary></indexterm>

    <para>Anstatt einige von ihnen im Einzelnen zu erklären, werden in diesem Abschnitt die Überlegungen der Administratoren von Falcot Corp. bei der Festlegung ihrer Backup-Strategie vorgestellt.</para>

    <para>Bei Falcot Corp. haben Datensicherungen zwei Ziele: versehentlich gelöschte Dateien wiederherzustellen und schnell jeden Rechner (Server oder Arbeitsplatzrechner) wiederherzustellen, dessen Festplatte versagt hat.</para>
    <section>
      <title>Datensicherung mit <command>rsync</command></title>

      <para>Da Bandsicherungen als zu langsam und teuer erachtet wurden, werden die Daten auf den Festplatten eines speziell hierfür bestimmten Servers gesichert, auf dem die Verwendung eines Software-RAIDs (siehe <xref linkend="sect.raid-soft" />) die Daten vor einem Festplattenausfall schützt. Arbeitsplatzrechner werden nicht individuell gesichert, sondern Benutzer darüber informiert, dass ihr persönliches Konto auf dem Dateiserver ihrer Abteilung gesichert wird. Der Befehl <command>rsync</command> (aus dem gleichnamigen Paket) wird täglich zur Sicherung dieser verschiedenen Server benutzt.</para>
      <indexterm><primary><command>rsync</command></primary></indexterm>

      <sidebar>
        <title><emphasis>ZURÜCK ZU DEN GRUNDLAGEN</emphasis> Die feste Verknüpfung, ein zweiter Name für die Datei</title>
        <indexterm><primary>Dateiverknüpfung</primary><secondary>feste Verknüpfung</secondary></indexterm>
        <indexterm><primary>feste Verknüpfung</primary></indexterm>

	<para>A hard link, as opposed to a symbolic link, cannot be
	differentiated from the linked file. Creating a hard link is
	essentially the same as giving an existing file a second name. This
	is why the deletion of a hard link only removes one of the names
	associated with the file. As long as another name is still assigned
	to the file, the data therein remain present on the filesystem. It
	is interesting to note that, unlike a copy, the hard link does not
	take up additional space on the hard drive.</para>

	<para>Eine feste Verknüpfung wird durch den Befehl <command>ln <replaceable>ziel</replaceable> <replaceable>verknüpfung</replaceable></command> erstellt. Die Datei <replaceable>verknüpfung</replaceable> ist dann ein neuer Name für die Datei <replaceable>ziel</replaceable>. Feste Verknüpfungen können nur auf demselben Dateisystem erstellt werden, während symbolische Verknüpfungen dieser Einschränkung nicht unterliegen.</para>
      </sidebar>

      <para>Der verfügbare Festplattenspeicherplatz lässt die Durchführung einer vollständigen täglichen Datensicherung nicht zu. Daher geht dem Befehl <command>rsync</command> eine Duplizierung des Inhalts der vorherigen Datensicherung mittels fester Verknüpfungen voraus, die den Verbrauch von zu viel Festplattenspeicherplatz verhindert. Der <command>rsync</command>-Prozess ersetzt dann nur die Dateien, die seit der vorherigen Datensicherung verändert wurden. Auf diese Weise kann eine große Anzahl von Datensicherungen auf relativ kleinem Raum untergebracht werden. Da alle Datensicherungen unmittelbar verfügbar und zugänglich sind (zum Beispiel in verschiedenen Verzeichnissen eines bestimmten Netzlaufwerks), können Sie schnell Vergleiche zwischen zwei bestimmten Zeitpunkten anstellen.</para>
      <indexterm><primary>Kopie, Sicherungskopie</primary></indexterm>
      <indexterm><primary>Datensicherung</primary><secondary>Kopie</secondary></indexterm>
      <indexterm><primary><emphasis role="pkg">dirvish</emphasis></primary></indexterm>

      <para>Dieser Datensicherungsvorgang kann mit dem Programm <command>dirvish</command> leicht umgesetzt werden. Es verwendet einen Sicherungsspeicherplatz („bank“ in seiner Sprache), in den er mit Zeitstempeln versehene Kopien eines Satzes von Sicherungsdateien ablegt (diese Sätze werden in der dirvish-Dokumentation „vaults“ genannt).</para>

      <para>Die Hauptkonfiguration befindet sich in der Datei <filename>/etc/dirvish/master.conf</filename>. Sie legt den Ort des Speicherplatzes für die Dateisicherung fest, die Liste der zu verwaltenden „vaults“ und Standardwerte für den Verfallstermin der Dateisicherungen. Der Rest der Konfiguration befindet sich in den Dateien <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> und enthält die spezifische Konfiguration des jeweiligen Dateisatzes.</para>

      <example id="example.dirvish-master">
        <title>Die Datei  <filename>/etc/dirvish/master.conf</filename></title>

        <programlisting>bank:
    /backup
exclude:
    lost+found/
    core
    *~
Runall:
    root    22:00
expire-default: +15 days
expire-rule:
#   MIN HR    DOM MON       DOW  STRFTIME_FMT
    *   *     *   *         1    +3 months
    *   *     1-7 *         1    +1 year
    *   *     1-7 1,4,7,10  1
</programlisting>
      </example>

      <para>Die <literal>bank</literal>-Einstellung bezeichnet das Verzeichnis, in dem die Dateisicherungen gespeichert werden. Die <literal>exclude</literal>-Einstellung ermöglicht es, Dateien oder Dateitypen von der Sicherung auszuschließen. Das <literal>Runall</literal> ist eine Liste von Dateisätzen, die mit einem Zeitstempel für jeden Satz gesichert werden sollen, wodurch es möglich ist, der Kopie das korrekte Datum zuzuordnen für den Fall, dass die Dateisicherung nicht genau zu der vorgesehenen Zeit ausgelöst wird. Sie müssen eine Zeit kurz vor dem tatsächlichen Ausführungszeitpunkt angeben (was in Debian standardmäßig 22:04 h ist in Übereinstimmung mit <filename>/etc/cron.d/dirvish</filename>). Schließlich bestimmen die Einstellungen <literal>expire-default</literal> und <literal>expire-rule</literal> die Verfallsregeln für Dateisicherungen. Das obenstehende Beispiel behält Dateisicherungen unbefristet, die am ersten Sonntag jeden Quartals erstellt worden sind, löscht diejenigen vom ersten Sonntag jeden Monats nach einem Jahr und die von den übrigen Sonntagen nach drei Monaten. Sonstige tägliche Dateisicherungen werden 15 Tage lang aufbewahrt. Die Reihenfolge der Regeln ist wichtig. Dirvish verwendet die letzte passende Regel oder die <literal>expire-default</literal>-Regel, falls keine andere <literal>expire-rule</literal> passt.</para>

      <sidebar>
        <title><emphasis>IN DER PRAXIS</emphasis> Planmäßiger Verfall</title>

	<para>Die Verfallsregeln werden nicht von <command>dirvish-expire</command> benutzt, um seine Aufgabe zu erledigen. Vielmehr werden die Verfallsregeln angewendet, wenn eine neue Sicherungskopie erstellt wird, um das Verfallsdatum zu bestimmen, das dieser Kopie zugeordnet wird. <command>dirvish-expire</command> geht einfach die gespeicherten Kopien durch und löscht diejenigen, deren Verfallsdatum bereits vergangen ist.</para>
      </sidebar>

      <example id="example.dirvish-vault">
        <title>Die Datei <filename>/backup/root/dirvish/default.conf</filename></title>

        <programlisting>client: rivendell.falcot.com
tree: /
xdev: 1
index: gzip
image-default: %Y%m%d
exclude:
    /var/cache/apt/archives/*.deb
    /var/cache/man/**
    /tmp/**
    /var/tmp/**
    *.bak
</programlisting>
      </example>

      <para>Das oben stehende Beispiel legt den Satz der zu sichernden Dateien fest: dies sind Dateien auf dem Rechner <emphasis>rivendell.falcot.com</emphasis> (für eine lokale Dateisicherung legen Sie einfach den Namen des örtlichen Rechners fest, wie er von <command>hostname</command> angezeigt wird), genauer gesagt, diejenigen im Wurzelverzeichnis (<literal>tree: /</literal>) außer denen, die unter <literal>exclude</literal> aufgelistet sind. Die Dateisicherung ist auf den Inhalt eines Dateisystems (<literal>xdev: 1</literal>) beschränkt. Sie schließt Dateien von anderen Einhängepunkten nicht ein. Ein Index der gesicherten Dateien wird erzeugt (<literal>index: gzip</literal>), und das Abbild wird nach Maßgabe des aktuellen Datums benannt (<literal>image-default: %Y%m%d</literal>).</para>

      <para>Es gibt zahlreiche Optionen, die alle auf der Handbuchseite <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> dokumentiert sind. Sobald die Konfigurationsdateien erstellt sind, müssen Sie jeden Dateisatz mit dem Befehl <command>dirvish --vault <replaceable>vault</replaceable> --init</command> initialisieren. Von da an erstellt der tägliche Aufruf von <command>dirvish-runall</command> selbsttätig eine neue Sicherungskopie, nachdem die verfallenen gelöscht worden sind.</para>

      <sidebar>
        <title><emphasis>IN DER PRAXIS</emphasis> Dateisicherung aus der Ferne über SSH</title>

	<para>Wenn dirvish Daten auf einen entfernten Rechner sichern muss, verwendet es <command>ssh</command>, um sich mit ihm zu verbinden, und startet <command>rsync</command> als Server. Dies setzt voraus, dass der Root-Benutzer sich automatisch mit ihm verbinden kann. Genau dies ist bei der Verwendung eines SSH-Legitimierungsschlüssels möglich (siehe <xref linkend="sect.ssh-key-based-auth" />).</para>
      </sidebar>
    </section>
    <section>
      <title>Rechner ohne Sicherheitskopien wiederherstellen</title>

      <para>Desktop-Computer die nicht gesichert werden, können sehr einfach neuinstalliert werden mit Hilfe einer mit <emphasis>Simple-CDD</emphasis> vorbereiteten, angepassten DVD-ROM (siehe <xref linkend="sect.simple-cdd" />). Da dies eine Neuinstallation ist, gehen alle Anpassungen verloren, die eventuell nach der Erstinstallation vorgenommen worden waren. Das macht aber nichts, weil die Systeme alle mit einem zentralen LDAP-Verzeichnis für Benutzerkonten verknüpft sind und die meisten Desktop-Anwendungen sind dank dconf vorkonfiguriert (siehe <xref linkend="sect.gnome-desktop" /> für mehr Information dazu).</para>

      <para>Die Falcot Corp. Administratoren sind sich der Grenzen ihrer Dateisicherungsstrategie bewusst. Da sie weder den Dateisicherungsserver noch ein Band in einem feuersicheren Tresor schützen können, haben sie ihn in einem getrennten Raum aufgestellt, so dass ein Unglück, wie ein Feuer im Serverraum, nicht die Dateisicherungen zusammen mit allem anderen zerstören würde. Darüber hinaus führen sie wöchentlich eine inkrementelle Dateisicherung auf CD-ROM durch - nur Dateien, die seit der letzten Dateisicherung verändert wurden, sind hierin einbezogen.</para>

      <sidebar>
        <title><emphasis>WEITERE SCHRITTE</emphasis> SQL- und LDAP-Dienste sichern</title>

	<para>Many services (such as SQL or LDAP databases) cannot be
	backed up by simply copying their files (unless they are properly
	interrupted during creation of the backups, which is frequently
	problematic, since they are intended to be available at all times).
	As such, it is necessary to use an “export” mechanism to create
	a “data dump” that can be safely backed up. These are often
	quite large, but they compress well. To reduce the storage space
	required, you will only store a complete text file per week, and a
	<command>diff</command> each day, which is created with a command
	of the type <command>diff
	<replaceable>file_from_yesterday</replaceable>
	<replaceable>file_from_today</replaceable></command>. The
	<command>xdelta</command> program produces incremental differences
	from binary dumps.</para>
        <indexterm><primary><command>xdelta</command></primary></indexterm>
        <indexterm><primary><command>diff</command></primary></indexterm>
        <indexterm><primary>Dump</primary></indexterm>
      </sidebar>

      <sidebar>
        <title><emphasis>KULTUR</emphasis> <emphasis>TAR</emphasis>, der Standard für Bandsicherungen</title>
        <indexterm><primary>Dateisicherung</primary><secondary>auf Band</secondary></indexterm>
        <indexterm><primary>Band, Dateisicherung</primary></indexterm>
        <indexterm><primary>TAR</primary></indexterm>

	<para>Früher bestand der einfachste Weg, eine Dateisicherung in Unix durchzuführen, darin, ein <emphasis>TAR</emphasis>-Archiv auf einem Band zu speichern. Der <command>tar</command>-Befehl erhielt sogar seinen Namen von „TapeARchive“.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.hotplug">
    <title>Wechsel im laufenden Betrieb: <emphasis>hotplug</emphasis></title>
    <section>
      <title>Einführung</title>

      <para>Das Kernel-Subsystem <emphasis>hotplug</emphasis> steuert das Anschließen und Wegnehmen von Geräten, indem die passenden Treiber geladen und die zugehörigen Gerätedateien (mit Hilfe von <command>udevd</command>) erzeugt werden. Mit moderner Hardware und Virtualisierung kann fast alles im Betrieb angeschlossen und entfernt werden: peripherals, sondern auch SATA-Festplatten genauso wie die CPU und der Hauptspeicher.</para>

      <para>Der Kernel verfügt über eine Datenbank, die jeder Geräte-ID den erforderlichen Treiber zuordnet. Diese Datenbank wird während des Hochfahrens dazu benutzt, alle Treiber für die Peripheriegeräte zu laden, die auf den verschiedenen oben genannten Bussen erkannt wurden, aber auch wenn ein zusätzliches Hotplug-Gerät verbunden wird. Sobald das Gerät einsatzbereit ist, wird eine Nachricht an <command>udevd</command> geschickt, so dass es einen entsprechenden Eintrag in <filename>/dev/</filename> erstellen kann.</para>

      <indexterm><primary><emphasis>hotplug</emphasis></primary></indexterm>
      <indexterm><primary>hotplug</primary></indexterm>
      <indexterm><primary>USB</primary></indexterm>
      <indexterm><primary>IEEE 1394</primary></indexterm>
      <indexterm><primary>PCMCIA</primary></indexterm>
      <indexterm><primary>SATA</primary></indexterm>
    </section>
    <section>
      <title>Das Namensproblem</title>

      <para>Vor dem Aufkommen von Hotplug-Verbindungen war es leicht, einem Gerät einen festen Namen zuzuordnen. Er beruhte einfach auf der Position des Gerätes auf seinem jeweiligen Bus. Dies ist jedoch nicht möglich, wenn solche Geräte auf dem Bus kommen und gehen können. Der typische Fall ist die Benutzung einer Digitalkamera und eines USB-Sticks, die dem Rechner beide als Plattenlaufwerke erscheinen. Das als erstes angeschlossene könnte <filename>/dev/sdb</filename> sein und das zweite <filename>/dev/sdc</filename> (während <filename>/dev/sda</filename> die eigene Festplatte des Rechners darstellt). Der Gerätename ist nicht festgelegt; er hängt von der Reihenfolge ab, in der die Geräte angeschlossen werden.</para>

      <para>Zusätzlich verwenden Treiber in zunehmendem Maße dynamische Werte für die Haupt- und Nebennummern der Geräte, wodurch es unmöglich wird, feststehende Einträge für bestimmte Geräte zu verwenden, da diese wesentlichen Kennzeichen sich nach einem Neustart ändern können.</para>

      <para><emphasis>udev</emphasis> wurde entwickelt, um genau dieses Problem zu lösen.</para>

      <sidebar>
        <title><emphasis>IN DER PRAXIS</emphasis> Verwaltung von Netzwerkkarten</title>

	<para>Many computers have multiple network cards (sometimes
	two wired interfaces and a wifi interface), and with
	<emphasis>hotplug</emphasis> support on most bus types, the Linux kernel
	does not guarantee fixed naming of
	network interfaces. But users who want to configure their
	network in <filename>/etc/network/interfaces</filename> need
	a fixed name!</para>

	<para>Es wäre schwierig, jeden Benutzer zu bitten, seine eigenen <emphasis>udev</emphasis>-Regeln zu erstellen, um dieses Problem anzugehen. Deshalb wurde <emphasis>udev</emphasis> in einer recht eigenartigen Weise konfiguriert; beim ersten Hochfahren (und überhaupt jedes Mal, wenn eine neue Netzwerkkarte erscheint) verwendet es den Namen der Netzwerkschnittstelle und ihre MAC-Adresse, um neue Regeln zu erstellen, die denselben Namen bei nachfolgenden Rechnerstarts wieder zuweisen. Diese Regeln sind in <filename>/etc/udev/rules.d/70-persistent-net.rules</filename> abgespeichert.</para>

        
	<para>This mechanism has some side effects that you should know
	about. Let's consider the case of a computer that has only one PCI
	network card. The network interface is named
	<literal>eth0</literal>, logically. Now say the card breaks down,
	and the administrator replaces it; the new card will have a new MAC
	address. Since the old card was assigned the name,
	<literal>eth0</literal>, the new one will be assigned
	<literal>eth1</literal>, even though the <literal>eth0</literal>
	card is gone for good (and the network will not be functional
	because <filename>/etc/network/interfaces</filename> likely
	configures an <literal>eth0</literal> interface). In this case, it
	is enough to simply delete the
	<filename>/etc/udev/rules.d/70-persistent-net.rules</filename> file
	before rebooting the computer. The new card will then be given the
	expected <literal>eth0</literal> name.</para>
      </sidebar>
    </section>
    <section>
      <title>Wie <emphasis>udev</emphasis> funktioniert</title>

      <para>Wenn <emphasis>udev</emphasis> vom Kernel über das Erscheinen eines neuen Gerätes informiert wird, sammelt es verschiedene Informationen über das betreffende Gerät, indem es die entsprechenden Einträge in <filename>/sys/</filename> zurate zieht, vor allem diejenigen, die es eindeutig identifizieren (MAC-Adresse bei einer Netzwerkkarte, Seriennummer bei einigen USB-Geräten usw.).</para>

      <para>Mit all diesen Informationen versehen konsultiert <emphasis>udev</emphasis> dann alle in <filename>/etc/udev/rules.d/</filename> und <filename>/lib/udev/rules.d/</filename> enthaltenen Regeln. Im Verlauf dieses Vorgangs entscheidet es, wie das Gerät bezeichnet werden soll, welche symbolische Verknüpfung erstellt werden soll (um ihm einen alternativen Namen zu geben), und welche Befehle ausgeführt werden sollen. All diese Dateien werden der Reihe nach konsultiert und alle Regeln nacheinander ausgewertet (außer wenn eine Datei „GOTO“-Anweisungen verwendet). So kann es mehrere Regeln geben, die sich auf einen bestimmten Vorgang beziehen.</para>

      <para>Die Syntax von Regeldateien ist recht einfach: jede Zeile enthält Auswahlkriterien und die Festsetzung von Variablen. Erstere werden gebraucht, um Vorgänge auszuwählen, auf die reagiert werden muss, und letztere bestimmen die zu ergreifenden Maßnahmen. Sie sind alle einfach durch Kommata getrennt, und der Operator teilt sie implizit in Auswahlkriterien (durch Vergleichsoperatoren wie <literal>==</literal> oder <literal>!=</literal>) und Zuordnungsanweisungen ein (durch Operatoren wie <literal>=</literal>, <literal>+=</literal> oder <literal>:=</literal>).</para>

      <para>Vergleichsoperatoren werden bei den folgenden Variablen verwendet:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>KERNEL</literal>: die Bezeichnung, die der Kernel dem Gerät gibt;</para>
        </listitem>
        <listitem>
	  <para><literal>ACTION</literal>: die dem Vorgang entsprechende Aktion („add“, wenn ein Gerät hinzugefügt wurde, „remove“, wenn es entfernt worden ist);</para>
        </listitem>
        <listitem>
	  <para><literal>DEVPATH</literal>: der Pfad zum <filename>/sys/</filename>-Eintrag des Geräts;</para>
        </listitem>
        <listitem>
	  <para><literal>SUBSYSTEM</literal>: das Kernel-Subsystem, das die Anfrage gestellt hat (es gibt viele, einige Beispiele sind „usb“, „ide“, „net“, “firmware“ usw.);</para>
        </listitem>
        <listitem>
	  <para><literal>ATTR{<replaceable>attribute</replaceable>}</literal>:
	  file contents of the <replaceable>attribute</replaceable> file in
	  the
	  <filename>/sys/<replaceable>$devpath</replaceable>/</filename>
	  directory of the device. This is where you find the MAC address
	  and other bus specific identifiers;</para>
        </listitem>
        <listitem>
	  <para><literal>KERNELS</literal>, <literal>SUBSYSTEMS</literal> und <literal>ATTRS{<replaceable>attributes</replaceable>}</literal> sind Varianten, die versuchen, den verschiedenen Optionen auf einem der übergeordneten Geräte des vorliegenden Geräts zu entsprechen;</para>
        </listitem>
        <listitem>
	  <para><literal>PROGRAM</literal>: delegiert den Test an das angegebene Programm (wahr, falls es 0 ausgibt, unwahr, falls nicht). Der Inhalt der Standardausgabe des Programms wird gespeichert, so dass er vom <literal>RESULT</literal>-Test erneut verwendet werden kann;</para>
        </listitem>
        <listitem>
	  <para><literal>RESULT</literal>: führt Tests auf der Standardausgabe durch, die während des letzten Aufrufs von <literal>PROGRAM</literal> gespeichert wurden.</para>
        </listitem>
      </itemizedlist>

      <para>Die richtigen Operanden können Strukturausdrücke benutzen, um mehreren Werten gleichzeitig zu entsprechen. Zum Beispiel entspricht <literal>*</literal> jeder Zeichenkette (selbst einer leeren); <literal>?</literal> entspricht jedem Zeichen und <literal>[]</literal> entspricht dem Zeichensatz zwischen den eckigen Klammern (oder seinem Gegenteil, falls das erste Zeichen ein Ausrufezeichen ist und zusammenhängende Reihen von Zeichen, wie <literal>a-z</literal>, angegeben sind).</para>

      <para>Was die Zuweisungsoperatoren betrifft, so weist <literal>=</literal> einen Wert zu (und ersetzt den gegenwärtigen Wert); im Falle einer Liste wird sie geleert und enthält dann nur den zugewiesenen Wert. <literal>:=</literal> macht dasselbe, aber unterbindet spätere Veränderungen derselben Variablen. <literal>+=</literal> fügt einer Liste eine Position hinzu. Die folgenden Variablen können verändert werden:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>NAME</literal>: der Dateiname des Geräts, der in <filename>/dev/</filename> erstellt wird. Nur die erste Zuweisung zählt; die übrigen werden ignoriert;</para>
        </listitem>
        <listitem>
	  <para><literal>SYMLINK</literal>: die Liste symbolischer Verknüpfungen, die auf dasselbe Gerät zeigen;</para>
        </listitem>
        <listitem>
	  <para><literal>OWNER</literal>, <literal>GROUP</literal> und <literal>MODE</literal> legen den Eigentümer und die Gruppe fest, denen das Gerät gehört, sowie die dazugehörige Berechtigung;</para>
        </listitem>
        <listitem>
	  <para><literal>RUN</literal>: die Liste der als Reaktion auf dieses Ereignis auszuführenden Programme.</para>
        </listitem>
      </itemizedlist>

      <para>Die Werte, die diesen Variablen zugewiesen werden, können eine Reihe von Ersetzungen benutzen:</para>
      <itemizedlist>
        <listitem>
	  <para><literal>$kernel</literal> oder <literal>%k</literal>: entspricht <literal>KERNEL</literal>;</para>
        </listitem>
        <listitem>
	  <para><literal>$number</literal> or <literal>%n</literal>: die Ordnungszahl des Geräts, zum Beispiel wäre dies „3“ für <literal>sda3</literal>;</para>
        </listitem>
        <listitem>
	  <para><literal>$devpath</literal> oder <literal>%p</literal>: entspricht <literal>DEVPATH</literal>;</para>
        </listitem>
        <listitem>
	 
	  <para><literal>$attr{<replaceable>attribute</replaceable>}</literal> oder <literal>%s{<replaceable>attribute</replaceable>}</literal>: entspricht <literal>ATTRS{<replaceable>attribute</replaceable>}</literal>;</para>
        </listitem>
        <listitem>
	  <para><literal>$major</literal> oder <literal>%M</literal>: die Hauptgerätenummer im Kernel;</para>
        </listitem>
        <listitem>
	  <para><literal>$minor</literal> oder <literal>%m</literal>: die Nebengerätenummer im Kernel;</para>
        </listitem>
        <listitem>
	  <para><literal>$result</literal> oder <literal>%c</literal>: die Zeichenkettenausgabe des letzten von <literal>PROGRAM</literal> aufgerufenen Programms;</para>
        </listitem>
        <listitem>
	  <para>und schließlich <literal>%%</literal> und <literal>$$</literal> für das Prozent- beziehungsweise Dollarzeichen.</para>
        </listitem>
      </itemizedlist>

      <para>The above lists are not complete (they include only the most
      important parameters), but the
      <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry>
      manual page should be exhaustive.</para>
    </section>
    <section>
      <title>Ein konkretes Beispiel</title>

      <para>Lassen Sie uns den Fall eines einfachen USB-Sticks betrachten und versuchen, ihm eine feststehende Bezeichnung zu geben. Zunächst müssen Sie die Elemente finden, die ihn eindeutig identifizieren. Hierzu stecken Sie ihn ein und führen den Befehl <command>udevadm info -a -n /dev/sdc</command> aus (wobei Sie <replaceable>/dev/sdc</replaceable> durch den Namen ersetzen, der dem Stick tatsächlich zugewiesen ist).</para>

      <screen><computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>
<computeroutput>[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</computeroutput>
</screen>

      <para>Um eine neue Regel zu erstellen, können Sie Tests für die Variablen des Geräts wie auch für die eines übergeordneten Geräts durchführen. Der oben stehende Fall ermöglicht es uns, zwei Regeln wie die folgenden zu erstellen:</para>

      <programlisting>KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"
</programlisting>

      <para>Sobald diese Regeln in einer Datei festgehalten sind, die zum Beispiel <filename>/etc/udev/rules.d/010_local.rules</filename> heißt, können Sie den USB-Stick einfach entfernen und wieder einstecken. Sie sehen dann, dass <filename>/dev/usb_key/disk</filename> die dem USB-Stick entsprechende Platte ist und <filename>/dev/usb_key/part1</filename> ihre erste Partition.</para>

      <sidebar>
        <title><emphasis>WEITERE SCHRITTE</emphasis> Fehlersuche in <emphasis>udev</emphasis>s Konfiguration</title>

	<para>Like many daemons, <command>udevd</command> stores logs in
	<filename>/var/log/daemon.log</filename>. But it is not very
	verbose by default, and it is usually not enough to understand
	what is happening. The <command>udevadm control
	--log-priority=info</command> command increases the verbosity level
	and solves this problem. <command>udevadm control
	--log-priority=err</command> returns to the default verbosity
	level.</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.power-management">
    <title>Modernes Energiemanagement: Advanced Configuration and Power Interface (ACPI)</title>
    <indexterm><primary>Energieverwaltung</primary></indexterm>
    <indexterm><primary>Verwaltung, Energieverwaltung</primary></indexterm>

    <para>Das Thema Energieverwaltung ist häufig mit Problemen verbunden. So erfordert das ordnungsgemäße Versetzen des Rechners in den Bereitschaftsbetrieb, dass alle Gerätetreiber des Rechners wissen, wie die Geräte in Stand-by versetzt werden, und dass sie sie bei der erneuten Betriebsaufnahme wieder ordnungsgemäß konfigurieren. Leider gibt es noch einige wenige Geräte, die unter Linux nicht korrekt in den Wartebetrieb übergehen, da ihre Hersteller die erforderlichen Spezifikationen nicht bereitgestellt haben.</para>

    <para>Linux unterstützt ACPI (Advanced Configuration and Power Interface) - den jüngsten Standard für Powermanagement. Das Paket <emphasis role="pkg">acpid</emphasis> stellt einen Dämon zur Verfügung, der nach Ereignissen im Zusammenhang mit dem Powermanagement Ausschau hält (das Umschalten zwischen Netz- und Batteriebetrieb bei einem Laptop usw.), und der diverse Befehle als Reaktion darauf ausführen kann.</para>

    <indexterm><primary>ACPI</primary></indexterm>
    <indexterm><primary>Advanced Configuration and Power Interface</primary></indexterm>
    <indexterm><primary><command>acpid</command></primary></indexterm>
    
    <sidebar>
      <title><emphasis>VORSICHT</emphasis> Grafikkarte und Bereitschaftsbetrieb</title>

      <para>Der Grafikkartentreiber ist häufig die Ursache, wenn der  Bereitschaftsbetrieb nicht sauber funktioniert. In diesem Fall empfiehlt es sich, die jüngste Version des X.org-Grafikservers auszuprobieren.</para>
    </sidebar>

    <para>Nach diesem Überblick über wesentliche Dienste, die vielen Unix-Systemen gemein sind, werden wir unsere Aufmerksamkeit auf das Umfeld der verwalteten Rechner richten: das Netzwerk. Damit das Netzwerk ordnungsgemäß funktioniert, sind viele Dienste erforderlich. Sie werden im nächsten Kapitel erörtert.</para>
  </section>
</chapter>
