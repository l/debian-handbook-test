<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.3. Überwachung: Vorbeugung, Entdeckung, Abschreckung</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-9-de-DE-1.0-1" /><meta
        name="keywords"
        content="Firewall, Netzfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="Das Debian Administrationshandbuch" /><link
        rel="up"
        href="security.html"
        title="Kapitel 14. Sicherheit" /><link
        rel="prev"
        href="sect.firewall-packet-filtering.html"
        title="14.2. Firewall oder Paketfilter" /><link
        rel="next"
        href="sect.apparmor.html"
        title="14.4. Introduction to AppArmor" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/de-DE/stable/sect.supervision.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Zurück</strong></a></li><li
          class="home">Das Debian Administrationshandbuch</li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Weiter</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.supervision"></a>14.3. Überwachung: Vorbeugung, Entdeckung, Abschreckung</h2></div></div></div><a
          id="id-1.17.6.2"
          class="indexterm"></a><div
          class="para">
			Monitoring is an integral part of any security policy for several reasons. Among them, that the goal of security is usually not restricted to guaranteeing data confidentiality, but it also includes ensuring availability of the services. It is therefore imperative to check that everything works as expected, and to detect in a timely manner any deviant behavior or change in quality of the service(s) rendered. Monitoring activity can help detecting intrusion attempts and enable a swift reaction before they cause grave consequences. This section reviews some tools that can be used to monitor several aspects of a Debian system. As such, it completes <a
            class="xref"
            href="sect.monitoring.html">Abschnitt 12.4, „Überwachung“</a>.
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.logcheck"></a>14.3.1. Protokolle mit <code
                    class="command">logcheck</code> verfolgen</h3></div></div></div><a
            id="id-1.17.6.4.2"
            class="indexterm"></a><a
            id="id-1.17.6.4.3"
            class="indexterm"></a><a
            id="id-1.17.6.4.4"
            class="indexterm"></a><div
            class="para">
				Das Programm <code
              class="command">logcheck</code> überwacht Protokolldateien standardmäßig jede Stunde. Es schickt E-Mails mit ungewöhnlichen Protokollmeldungen zur weiteren Analyse an den Administrator.
			</div><div
            class="para">
				Die Liste der überwachten Dateien wird in <code
              class="filename">/etc/logcheck/logcheck.logfiles</code> gespeichert; die Standardeinstellungen eignen sich gut, solange die Datei <code
              class="filename">/etc/rsyslog.conf</code> nicht vollständig verändert worden ist.
			</div><div
            class="para">
				<code
              class="command">logcheck</code> kann in drei mehr oder weniger detaillierten Modi laufen: <span
              class="emphasis"><em>Paranoid</em></span>, <span
              class="emphasis"><em>Server</em></span> und <span
              class="emphasis"><em>Arbeitsplatzrechner</em></span>. Der erste ist <span
              class="emphasis"><em>sehr</em></span> ausführlich und sollte wohl eher auf besondere Server, wie zum Beispiel Firewalls, beschränkt bleiben. Der zweite (voreingestellte) Modus wird für die meisten Server empfohlen. Der letzte ist für Arbeitsplatzrechner bestimmt und ist noch knapper (er unterdrückt mehr Meldungen).
			</div><div
            class="para">
				In allen drei Fällen sollte <code
              class="command">logcheck</code> wohl so angepasst werden, dass es einige zusätzliche Meldungen ausschließt (in Abhängigkeit von den installierten Diensten), es sei denn, dass der Administrator tatsächlich jede Stunde stapelweise lange uninteressante E-Mails empfangen möchte. Da das Verfahren zur Auswahl der Meldungen recht kompliziert ist, ist es notwendig - wenn auch schwierig - die Datei <code
              class="filename">/usr/share/doc/logcheck-database/README.logcheck-database.gz</code> durchzulesen.
			</div><div
            class="para">
				Die eingesetzten Regeln können in mehrere Arten unterteilt werden:
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						solche, die eine Meldung als einen Einbruchsversuch einstufen (in einer Datei im Verzeichnis <code
                    class="filename">/etc/logcheck/cracking.d/</code> gespeichert);
					</div></li><li
                class="listitem"><div
                  class="para">
						solche, die eine derartige Einstufung aufheben (<code
                    class="filename">/etc/logcheck/cracking.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						solche, die eine Meldung als Sicherheitswarnung einordnen (<code
                    class="filename">/etc/logcheck/violations.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						solche, die diese Einordnung aufheben (<code
                    class="filename">/etc/logcheck/violations.ignore.d/</code>);
					</div></li><li
                class="listitem"><div
                  class="para">
						und schließlich solche, die auf die übrigen Meldungen zutreffen (als sogenannte <span
                    class="emphasis"><em>Systemvorfälle</em></span> angesehen werden).
					</div></li></ul></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VORSICHT</em></span> Eine Meldung ignorieren</strong></p></div></div></div><div
              class="para">
				Eine Meldung, die als Einbruchsversuch oder als Sicherheitswarnung markiert worden ist (aufgrund einer Regel, die in einer Datei namens <code
                class="filename">/etc/logcheck/violations.d/meine_datei</code> gespeichert ist), kann nur mit einer Regel in den Dateien <code
                class="filename">/etc/logcheck/violations.ignore.d/meine_datei</code> oder <code
                class="filename">/etc/logcheck/violations.ignore.d/meine_datei-<em
                  class="replaceable">erweiterung</em></code> ignoriert werden.
			</div></div><div
            class="para">
				Ein Systemvorfall wird immer angezeigt, es sei denn, eine Regel in einem der Verzeichnisse des Typs <code
              class="filename">/etc/logcheck/ignore.d.{paranoid,server,arbeitsplatzrechner}/</code> bestimmt, dass der Vorfall ignoriert werden soll. Es werden natürlich nur die Verzeichnisse berücksichtigt, deren Ausführlichkeitsgrad gleich dem oder höher als der ausgewählte Betriebsmodus ist.
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.monitoring-activity"></a>14.3.2. Aktivitäten überwachen</h3></div></div></div><a
            id="id-1.17.6.5.2"
            class="indexterm"></a><a
            id="id-1.17.6.5.3"
            class="indexterm"></a><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.real-time-monitoring"></a>14.3.2.1. In Echtzeit</h4></div></div></div><div
              class="para">
					<code
                class="command">top</code> ist ein interaktives Hilfsprogramm, das eine Liste der gegenwärtig laufenden Prozesse anzeigt. Die voreingestellte Reihenfolge hängt vom momentanen Umfang der Prozessornutzung ab und kann mithilfe der <span
                class="keycap"><strong>P</strong></span>-Taste abgerufen werden. Andere Sortierreihenfolgen sind unter anderem nach belegtem Speicher (<span
                class="keycap"><strong>M</strong></span>-Taste), nach gesamter Prozessorzeit (<span
                class="keycap"><strong>T</strong></span>-Taste) und nach Prozesskennung (<span
                class="keycap"><strong>N</strong></span>-Taste). Mit der <span
                class="keycap"><strong>k</strong></span>-Taste kann ein Prozess abgebrochen werden, indem seine Kennung eingegeben wird. Die <span
                class="keycap"><strong>r</strong></span>-Taste ermöglicht das <span
                class="emphasis"><em>renicing</em></span> eines Prozesses, das heißt, die Änderung seiner Priorität.
				</div><a
              id="id-1.17.6.5.4.3"
              class="indexterm"></a><div
              class="para">
					Wenn das System überlastet zu sein scheint, ist <code
                class="command">top</code> ein großartiges Instrument, um zu sehen, welche Prozesse um die Prozessorzeit konkurrieren oder zu viel Speicher verbrauchen. Insbesondere ist es häufig interessant zu überprüfen, ob die Prozesse, die Ressourcen verbrauchen, den tatsächlichen Diensten entsprechen, die der Rechner bekanntermaßen beherbergt. Ein unbekannter Prozess, der unter dem Benutzernamen www-data läuft, sollte wirklich hervorstechen und kann untersucht werden, da er möglicherweise ein Programm ist, das durch eine Schwachstelle in einer Web-Anwendung auf dem System installiert wurde und ausgeführt wird.
				</div><div
              class="para">
					<code
                class="command">top</code> ist ein sehr flexibles Hilfsprogramm, und seine Handbuchseite beschreibt ausführlich, wie seine Anzeige individuell eingerichtet und an persönliche Bedürfnisse und Gewohnheiten angepasst werden kann.
				</div><div
              class="para">
					The <code
                class="command">gnome-system-monitor</code> graphical tool is similar to <code
                class="command">top</code> and it provides roughly the same features.
				</div><a
              id="id-1.17.6.5.4.7"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.monitoring-history"></a>14.3.2.2. Verlauf</h4></div></div></div><a
              id="id-1.17.6.5.5.2"
              class="indexterm"></a><div
              class="para">
					Prozessorauslastung, Netzwerkverkehr und freier Plattenplatz sind Informationen, die sich ständig ändern. Es ist häufig nützlich, den Verlauf ihrer Entwicklung festzuhalten, um genau feststellen zu können, wie der Rechner genutzt wird.
				</div><a
              id="id-1.17.6.5.5.4"
              class="indexterm"></a><a
              id="id-1.17.6.5.5.5"
              class="indexterm"></a><div
              class="para">
					Für diese Aufgabe gibt es zahlreiche spezialisierte Hilfsprogramme. Die meisten von ihnen können Daten über SNMP (<span
                class="emphasis"><em>Simple Network Management Protocol</em></span>) einholen, um diese Informationen an einer Stelle zusammenzufassen. Ein weiterer Nutzen besteht darin, dass auf diese Weise Daten von Netzwerkelementen eingeholt werden können, die keine Universalrechner sind, wie spezialisierte Netzwerkrouter oder -schalter.
				</div><div
              class="para">
					Dieses Buch behandelt Munin ausführlich als Teil von <a
                class="xref"
                href="advanced-administration.html">Kapitel 12: „<em>Erweiterte Verwaltung</em>“</a> (siehe <a
                class="xref"
                href="sect.monitoring.html#sect.munin">Abschnitt 12.4.1, „Munin einrichten“</a>). Debian stellt ebenfalls ein ähnliches Hilfsprogramm bereit: <span
                class="pkg pkg">cacti</span>. Sein Einsatz ist etwas komplizierter, da es ausschließlich auf SNMP beruht. Obwohl es eine Web-Schnittstelle hat, benötigt das Verständnis der Konzepte, die für die Konfigurierung verwendet werden, noch einige Anstrengung. Die Lektüre der HTML-Dokumentation (<code
                class="filename">/usr/share/doc/cacti/html/index.html</code>) ist daher als Voraussetzung anzusehen.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> <code
                          class="command">mrtg</code></strong></p></div></div></div><a
                id="id-1.17.6.5.5.8.2"
                class="indexterm"></a><div
                class="para">
					<code
                  class="command">mrtg</code> (in dem Paket ähnlichen Namens) ist ein älteres Hilfsprogramm. Trotz einiger Ecken und Kanten kann es Verlaufsdaten zusammenfassen und als Diagramme anzeigen. Es enthält eine Reihe spezieller Skripte zur Sammlung der am häufigsten überprüften Daten wie Prozessorlast, Netzwerkverkehr, Webseitenzugriffe und so weiter.
				</div><div
                class="para">
					Die Pakete <span
                  class="pkg pkg">mrtg-contrib</span> und <span
                  class="pkg pkg">mrtgutils</span> enthalten Beispielskripte, die direkt verwendet werden können.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.17.6.6"></a>14.3.3. Änderungen erkennen</h3></div></div></div><div
            class="para">
				Nachdem das System installiert und konfiguriert ist, gibt es, abgesehen von Sicherheitsaktualisierungen, normalerweise keinen Grund, dass Dateien und Verzeichnisse sich weiterentwickeln, Daten ausgenommen. Es ist daher interessant sicherzustellen, dass Dateien sich in der Tat nicht ändern: jede unerwartete Veränderung wäre daher eine Untersuchung wert. Dieser Abschnitt stellt einige Hilfsprogramme vor, die Dateien überwachen und den Administrator warnen können, wenn eine unerwartete Veränderung auftritt (oder einfach derartige Veränderungen auflisten).
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.dpkg-verify"></a>14.3.3.1. Auditing Packages with <code
                      class="command">dpkg --verify</code></h4></div></div></div><a
              id="id-1.17.6.6.3.2"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>WEITERE SCHRITTE</em></span> Schutz vor vorgelagerten Veränderungen</strong></p></div></div></div><div
                class="para">
					<code
                  class="command">dpkg --verify</code> is useful in detecting changes to files coming from a Debian package, but it will be useless if the package itself is compromised, for instance if the Debian mirror is compromised. Protecting against this class of attacks involves using APT's digital signature verification system (see <a
                  class="xref"
                  href="sect.package-authentication.html">Abschnitt 6.5, „Die Echtheit eines Paketes prüfen“</a>), and taking care to only install packages from a certified origin.
				</div></div><div
              class="para">
					<code
                class="command">dpkg --verify</code> (or <code
                class="command">dpkg -V</code>) is an interesting tool since it allows finding what installed files have been modified (potentially by an attacker), but this should be taken with a grain of salt. To do its job it relies on checksums stored in dpkg's own database which is stored on the hard disk (they can be found in <code
                class="filename">/var/lib/dpkg/info/<em
                  class="replaceable">package</em>.md5sums</code>); a thorough attacker will therefore update these files so they contain the new checksums for the subverted files.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BACK TO BASICS</em></span> File fingerprint</strong></p></div></div></div><a
                id="id-1.17.6.6.3.5.2"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.3"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.4"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.5"
                class="indexterm"></a><div
                class="para">
					As a reminder: a fingerprint is a value, often a number (even though in hexadecimal notation), that contains a kind of signature for the contents of a file. This signature is calculated with an algorithm (MD5 or SHA1 being well-known examples) that more or less guarantee that even the tiniest change in the file contents implies a change in the fingerprint; this is known as the “avalanche effect”. This allows a simple numerical fingerprint to serve as a litmus test to check whether the contents of a file have been altered. These algorithms are not reversible; in other words, for most of them, knowing a fingerprint doesn't allow finding the corresponding contents. Recent mathematical advances seem to weaken the absoluteness of these principles, but their use is not called into question so far, since creating different contents yielding the same fingerprint still seems to be quite a difficult task.
				</div></div><div
              class="para">
					Running <code
                class="command">dpkg -V</code> will verify all installed packages and will print out a line for each file with a failing test. The output format is the same as the one of <code
                class="command">rpm -V</code> where each character denotes a test on some specific meta-data. Unfortunately <code
                class="command">dpkg</code> does not store the meta-data needed for most tests and will thus output question marks for them. Currently only the checksum test can yield a "5" on the third character (when it fails).
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>dpkg -V</code></strong>
<code
                class="computeroutput">??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</code></pre><div
              class="para">
					In the sample above, dpkg reports a change to SSH's service file that the administrator made to the packaged file instead of using an appropriate <code
                class="filename">/etc/systemd/system/ssh.service</code> override (which would be stored below <code
                class="filename">/etc</code> like any configuration change should be). It also lists multiple configuration files (identified by the "c" letter on the second field) that had been legitimately modified.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.debsums"></a>14.3.3.2. Pakete auditieren: <code
                      class="command">debsums</code> und seine Grenzen</h4></div></div></div><a
              id="id-1.17.6.6.4.2"
              class="indexterm"></a><div
              class="para">
					<code
                class="command">debsums</code> is the ancestor of <code
                class="command">dpkg -V</code> and is thus mostly obsolete. It suffers from the same limitations than dpkg. Fortunately, some of the limitations can be worked-around (whereas dpkg does not offer similar work-arounds).
				</div><div
              class="para">
					Since the data on the disk cannot be trusted, <code
                class="command">debsums</code> offers to do its checks based on <code
                class="filename">.deb</code> files instead of relying on dpkg's database. To download trusted <code
                class="filename">.deb</code> files of all the packages installed, we can rely on APT's authenticated downloads. This operation can be slow and tedious, and should therefore not be considered a proactive technique to be used on a regular basis.
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</code></strong>
<code
                class="computeroutput">[ ... ]
# </code><strong
                class="userinput"><code>debsums -p /var/cache/apt/archives --generate=all</code></strong></pre><div
              class="para">
					Man beachte, dass in diesem Beispiel der Befehl <code
                class="command">grep-status</code> aus dem Paket <span
                class="pkg pkg">grep-dctrl</span> verwendet wird, das nicht standardmäßig installiert ist.
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.6.6.5"></a>14.3.3.3. Dateien überwachen: AIDE</h4></div></div></div><a
              id="id-1.17.6.6.5.2"
              class="indexterm"></a><div
              class="para">
					Das Hilfsprogramm AIDE (<span
                class="emphasis"><em>Advanced Intrusion Detection Environment</em></span>) ermöglicht es, die Unversehrtheit von Dateien zu überprüfen und jede Veränderung durch einen Vergleich mit einem zuvor festgehaltenen Abbild des intakten Systems zu entdecken. Dieses Abbild ist als Datenbank (<code
                class="filename">/var/lib/aide/aide.db</code>) abgespeichert, die relevante Informationen über alle Dateien des Systems enthält (Fingerabdrücke, Berechtigungen, Zeitstempel und so weiter). Diese Datenbank wird erstmals mit dem Befehl <code
                class="command">aideinit</code> initialisiert; sie wird dann täglich (mit dem Skript <code
                class="filename">/etc/cron.daily/aide</code>) genutzt, um nachzuprüfen, dass sich nichts Relevantes verändert hat. Wenn Veränderungen entdeckt werden, hält AIDE diese in Protokolldateien fest (<code
                class="filename">/var/log/aide/*.log</code>) und sendet seine Befunde per E-Mail an den Administrator.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>IN DER PRAXIS</em></span> Die Datenbank schützen</strong></p></div></div></div><div
                class="para">
					Da AIDE eine lokale Datenbank nutzt, um den Status der Dateien zu vergleichen, ist die Gültigkeit seiner Ergebnisse direkt an die Gültigkeit der Datenbank gebunden. Falls ein Angreifer auf einem kompromittierten System Administratorrechte erlangt, ist er in der Lage, die Datenbank auszutauschen und so seine Spuren zu verwischen. Eine mögliche Behelfslösung könnte darin bestehen, die Referenzdaten auf einem schreibgeschützten Medium zu speichern.
				</div></div><div
              class="para">
					Viele Optionen in <code
                class="filename">/etc/default/aide</code> können dazu verwendet werden, das Verhalten des Pakets <span
                class="pkg pkg">aide</span> zu justieren. AIDEs eigentliche Konfiguration ist in <code
                class="filename">/etc/aide/aide.conf</code> und <code
                class="filename">/etc/aide/aide.conf.d/</code> gespeichert (diese Dateien werden genau genommen nur von <code
                class="command">update-aide.conf</code> dazu benutzt, die Datei <code
                class="filename">/var/lib/aide/aide.conf.autogenerated</code> zu erstellen). Die Konfiguration gibt an, welche Eigenschaften welcher Dateien überprüft werden sollen. Der Inhalt von Protokolldateien verändert sich zum Beispiel regelmäßig, und derartige Veränderungen können ignoriert werden, solange die Berechtigungen dieser Dateien die gleichen bleiben. Aber sowohl der Inhalt als auch die Berechtigungen von ausführbaren Dateien müssen unverändert bleiben. Obwohl die Konfigurationssyntax nicht sehr komplex ist, ist sie nicht völlig intuitiv. Daher wird empfohlen, die Handbuchseite <span
                class="citerefentry"><span
                  class="refentrytitle">aide.conf</span>(5)</span> zu lesen.
				</div><div
              class="para">
					Eine neue Version der Datenbank wird täglich in <code
                class="filename">/var/lib/aide/aide.db.new</code> erstellt; falls alle aufgenommenen Veränderungen legitim waren, kann sie als Ersatz für die Referenzdatenbank verwendet werden.
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> Tripwire und Samhain</strong></p></div></div></div><div
                class="para">
					Tripwire ist AIDE sehr ähnlich; selbst die Syntax der Konfigurationsdatei ist fast die gleiche. Die Hauptergänzung, die von <span
                  class="pkg pkg">tripwire</span> bereitgestellt wird, ist ein Verfahren, die Konfigurationsdatei zu signieren, so dass ein Angreifer mit ihr nicht auf eine andere Version der Referenzdatenbank verweisen kann.
				</div><div
                class="para">
					Samhain also offers similar features, as well as some functions to help detecting rootkits (see the sidebar <a
                  class="xref"
                  href="sect.supervision.html#sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"><span
                    class="emphasis"><em>KURZER BLICK</em></span> Die Pakete <span
                    class="pkg pkg">checksecurity</span> und <span
                    class="pkg pkg">chkrootkit</span>/<span
                    class="pkg pkg">rkhunter</span></a>). It can also be deployed globally on a network, and record its traces on a central server (with a signature).
				</div></div><div
              class="sidebar"><a
                xmlns=""
                id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"></a><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>KURZER BLICK</em></span> Die Pakete <span
                          class="pkg pkg">checksecurity</span> und <span
                          class="pkg pkg">chkrootkit</span>/<span
                          class="pkg pkg">rkhunter</span></strong></p></div></div></div><a
                id="id-1.17.6.6.5.8.2"
                class="indexterm"></a><div
                class="para">
					Das erste dieser Pakete enthält verschiedene kleine Skripte, die grundlegende Prüfungen des Systems durchführen (leere Passwörter, neue setuid-Dateien usw.) und den Administrator, falls nötig, warnen. Allerdings sollte sich trotz seines eindeutigen Namens kein Administrator nur auf dieses Paket verlassen, wenn er dafür sorgen möchte, dass ein Linux-System sicher ist.
				</div><div
                class="para">
					Die Pakete <span
                  class="pkg pkg">chkrootkit</span> und <span
                  class="pkg pkg">rkhunter</span> ermöglichen es, nach möglicherweise auf dem System installierten <span
                  class="emphasis"><em>Rootkits</em></span> Ausschau zu halten. Zur Erinnerung: dies sind Programme, die dazu bestimmt sind, die Kompromittierung eines Systems zu verbergen und gleichzeitig diskret den Rechner im Griff zu halten. Die Tests sind nicht zu 100% zuverlässig, aber sie können gewöhnlich die Aufmerksamkeit des Administrators auf die möglichen Probleme lenken.
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.intrusion-detection"></a>14.3.4. Eindringen entdecken (IDS/NIDS)</h3></div></div></div><a
            id="id-1.17.6.7.2"
            class="indexterm"></a><a
            id="id-1.17.6.7.3"
            class="indexterm"></a><a
            id="id-1.17.6.7.4"
            class="indexterm"></a><a
            id="id-1.17.6.7.5"
            class="indexterm"></a><a
            id="id-1.17.6.7.6"
            class="indexterm"></a><a
            id="id-1.17.6.7.7"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>ZURÜCK ZU DEN GRUNDLAGEN</em></span> Denial of Service</strong></p></div></div></div><a
              id="id-1.17.6.7.8.2"
              class="indexterm"></a><div
              class="para">
				Ein „Denial-of-Service“-Angriff hat nur ein Ziel: einen Dienst nicht verfügbar zu machen. Ob ein solcher Angriff nun darin besteht, den Server mit Anfragen zu überlasten oder einen Fehler auszunutzen, das Ergebnis ist das gleiche: der Dienst ist nicht mehr funktionsfähig. Die normalen Benutzer sind unzufrieden, und der Ruf der Organisation, die den angegriffenen Netzwerkdienst bereitstellt, erleidet Schaden (und verliert möglicherweise Einnahmen, falls zum Beispiel der Dienst eine E-Commerce-Website war).
			</div><div
              class="para">
				Such an attack is sometimes “distributed”; this usually involves overloading the server with large numbers of queries coming from many different sources so that the server becomes unable to answer the legitimate queries. These types of attacks have gained well-known acronyms: <acronym
                class="acronym">DDoS</acronym> and <acronym
                class="acronym">DoS</acronym> (depending on whether the denial of service attack is distributed or not).
			</div></div><div
            class="para">
				<code
              class="command">suricata</code> (in the Debian package of the same name) is a NIDS — a <span
              class="emphasis"><em>Network Intrusion Detection System</em></span>. Its function is to listen to the network and try to detect infiltration attempts and/or hostile acts (including denial of service attacks). All these events are logged in multiple files in <code
              class="filename">/var/log/suricata</code>. There are third party tools (Kibana/logstash) to better browse all the data collected. <div
              xmlns=""
              class="url">→ <a
                xmlns="http://www.w3.org/1999/xhtml"
                href="http://suricata-ids.org">http://suricata-ids.org</a></div> <div
              xmlns=""
              class="url">→ <a
                xmlns="http://www.w3.org/1999/xhtml"
                href="https://www.elastic.co/products/kibana">https://www.elastic.co/products/kibana</a></div>
			</div><a
            id="id-1.17.6.7.10"
            class="indexterm"></a><a
            id="id-1.17.6.7.11"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VORSICHT</em></span> Wirkungsbereich</strong></p></div></div></div><div
              class="para">
				The effectiveness of <code
                class="command">suricata</code> is limited by the traffic seen on the monitored network interface. It will obviously not be able to detect anything if it cannot observe the real traffic. When plugged into a network switch, it will therefore only monitor attacks targeting the machine it runs on, which is probably not the intention. The machine hosting <code
                class="command">suricata</code> should therefore be plugged into the “mirror” port of the switch, which is usually dedicated to chaining switches and therefore gets all the traffic.
			</div></div><div
            class="para">
				Configuring suricata involves reviewing and editing <code
              class="filename">/etc/suricata/suricata-debian.yaml</code>, which is very long because each parameter is abundantly commented. A minimal configuration requires describing the range of addresses that the local network covers (<code
              class="literal">HOME_NET</code> parameter). In practice, this means the set of all potential attack targets. But getting the most of it requires reading it in full and adapting it to the local situation.
			</div><div
            class="para">
				On top of this, you should also edit <code
              class="filename">/etc/default/suricata</code> to define the network interface to monitor and to enable the init script (by setting <code
              class="literal">RUN=yes</code>). You might also want to set <code
              class="literal">LISTENMODE=pcap</code> because the default <code
              class="literal">LISTENMODE=nfqueue</code> requires further configuration to work properly (the netfilter firewall must be configured to pass packets to some user-space queue handled by suricata via the <code
              class="literal">NFQUEUE</code> target).
			</div><div
            class="para">
				To detect bad behaviour, <code
              class="command">suricata</code> needs a set of monitoring rules: you can find such rules in the <span
              class="pkg pkg">snort-rules-default</span> package. <code
              class="command">snort</code> is the historical reference in the IDS ecosystem and <code
              class="command">suricata</code> is able to reuse rules written for it. Unfortunately that package is missing from <span
              class="distribution distribution">Debian Jessie</span> and should be retrieved from another Debian release like <span
              class="distribution distribution">Testing</span> or <span
              class="distribution distribution">Unstable</span>.
			</div><div
            class="para">
				Alternatively, <code
              class="command">oinkmaster</code> (in the package of the same name) can be used to download Snort rulesets from external sources.
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>WEITERE SCHRITTE</em></span> Integration mit <code
                        class="command">prelude</code></strong></p></div></div></div><div
              class="para">
				Prelude ermöglicht eine zentralisierte Überwachung von Sicherheitsinformationen. Seine modulare Architektur enthält einen Server (den <span
                class="emphasis"><em>Manager</em></span> im Paket <span
                class="pkg pkg">prelude-manager</span>), der Alarmmeldungen sammelt, die von verschiedenen Arten von <span
                class="emphasis"><em>Sensoren</em></span> erzeugt werden.
			</div><div
              class="para">
				Suricata can be configured as such a sensor. Other possibilities include <span
                class="emphasis"><em>prelude-lml</em></span> (<span
                class="emphasis"><em>Log Monitor Lackey</em></span>) which monitors log files (in a manner similar to <code
                class="command">logcheck</code>, described in <a
                class="xref"
                href="sect.supervision.html#sect.logcheck">Abschnitt 14.3.1, „Protokolle mit <code
                  class="command">logcheck</code> verfolgen“</a>).
			</div><a
              id="id-1.17.6.7.17.4"
              class="indexterm"></a></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>Zurück</strong>14.2. Firewall oder Paketfilter</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>Nach oben</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>Zum Anfang</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>Weiter</strong>14.4. Introduction to AppArmor</a></li></ul></body></html>
