<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">5.2. パッケージのメタ情報</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ja-JP-1.0-1" /><meta
        name="keywords"
        content="バイナリパッケージ, ソースパッケージ, dpkg, 依存関係, 衝突" /><link
        rel="home"
        href="index.html"
        title="Debian 管理者ハンドブック" /><link
        rel="up"
        href="packaging-system.html"
        title="第 5 章 パッケージシステム、ツールと基本原則" /><link
        rel="prev"
        href="packaging-system.html"
        title="第 5 章 パッケージシステム、ツールと基本原則" /><link
        rel="next"
        href="sect.source-package-structure.html"
        title="5.3. ソースパッケージの構造" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/ja-JP/stable/sect.package-meta-information.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="packaging-system.html"><strong>戻る</strong></a></li><li
          class="home">Debian 管理者ハンドブック</li><li
          class="next"><a
            accesskey="n"
            href="sect.source-package-structure.html"><strong>次へ</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.package-meta-information"></a>5.2. パッケージのメタ情報</h2></div></div></div><a
          id="id-1.8.6.2"
          class="indexterm"></a><a
          id="id-1.8.6.3"
          class="indexterm"></a><div
          class="para">
			Debian パッケージはインストールされるファイルのアーカイブというだけではありません。Debian パッケージには他の Debian パッケージとの関係性 (依存関係、衝突、提案) を表す情報が含まれています。さらに Debian パッケージにはスクリプトも含まれています。このスクリプトはパッケージライフサイクルのある時点 (インストール、削除、アップグレード) にコマンドを実行するためのものです。これらのデータはパッケージ管理ツールによって使われますが、パッケージングされたソフトウェアの一部ではありません。しかし、これらのデータはパッケージの「メタ情報」(ソフトウェア以外の情報のデータ) と呼ばれて、パッケージに含まれています。
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.control"></a>5.2.1. 説明、<code
                    class="filename">control</code> ファイル</h3></div></div></div><a
            id="id-1.8.6.5.2"
            class="indexterm"></a><a
            id="id-1.8.6.5.3"
            class="indexterm"></a><a
            id="id-1.8.6.5.4"
            class="indexterm"></a><div
            class="para">
				<code
              class="filename">control</code> ファイルは (RFC 2822 の定義する) 電子メールヘッダとよく似た構造を使っています。たとえば、<span
              class="pkg pkg">apt</span> の <code
              class="filename">control</code> ファイルは以下のような内容を持っています。
			</div><pre
            class="screen">
<code
              class="computeroutput">$ </code><strong
              class="userinput"><code>apt-cache show apt</code></strong>
<code
              class="computeroutput">Package: apt
Version: 1.0.9.6
Installed-Size: 3788
Maintainer: APT Development Team &lt;deity@lists.debian.org&gt;
Architecture: amd64
Replaces: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0)
Depends: libapt-pkg4.12 (&gt;= 1.0.9.6), libc6 (&gt;= 2.15), libgcc1 (&gt;= 1:4.1.1), libstdc++6 (&gt;= 4.9), debian-archive-keyring, gnupg
Suggests: aptitude | synaptic | wajig, dpkg-dev (&gt;= 1.17.2), apt-doc, python-apt
Conflicts: python-apt (&lt;&lt; 0.7.93.2~)
Breaks: manpages-it (&lt;&lt; 2.80-4~), manpages-pl (&lt;&lt; 20060617-3~), openjdk-6-jdk (&lt;&lt; 6b24-1.11-0ubuntu1~), sun-java5-jdk (&gt;&gt; 0), sun-java6-jdk (&gt;&gt; 0)
Description-ja: コマンドラインパッケージマネージャ
 本パッケージは、パッケージを検索、管理したりパッケージの情報を照会できるコ
 マンドラインツールを提供します。libapt-pkg ライブラリの全機能に低レベルアク
 セスできます。
 .
 次のツールが含まれます。
  * apt-get: 信頼されたソースからパッケージやパッケージの情報を取得したり、
    パッケージとその依存関係をまとめてインストール、アップグレード、および削
    除できます
  * apt-cache: インストールしたパッケージやインストール可能なパッケージに関
    して利用できる情報を検索できます
  * apt-cdrom: リムーバブルメディアをパッケージの取得ソースとして利用できます
  * apt-config: 構成設定へのインターフェース
  * apt-key: 信頼できる鍵を管理するインターフェース
Description-md5: 9fb97a88cb7383934ef963352b53b4a7
Tag: admin::package-management, devel::lang:ruby, hardware::storage,
 hardware::storage:cd, implemented-in::c++, implemented-in::perl,
 implemented-in::ruby, interface::commandline, network::client,
 protocol::ftp, protocol::http, protocol::ipv6, role::program,
 role::shared-lib, scope::application, scope::utility, sound::player,
 suite::debian, use::downloading, use::organizing, use::searching,
 works-with::audio, works-with::software:package, works-with::text
Section: admin
Priority: important
Filename: pool/main/a/apt/apt_1.0.9.6_amd64.deb
Size: 1107560
MD5sum: a325ccb14e69fef2c50da54e035a4df4
SHA1: 635d09fcb600ec12810e3136d51e696bcfa636a6
SHA256: 371a559ce741394b59dbc6460470a9399be5245356a9183bbeea0f89ecaabb03</code></pre><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BACK TO BASICS</em></span> RFC — インターネット標準</strong></p></div></div></div><a
              id="id-1.8.6.5.7.2"
              class="indexterm"></a><a
              id="id-1.8.6.5.7.3"
              class="indexterm"></a><div
              class="para">
				RFC は「Request For Comments」の略称です。RFC は一般的にインターネット標準になり得る技術の仕様を説明した技術文書です。標準化と決定の前に、これらの文書は公開レビューされます (そんなわけでこの名前が付いています)。IETF (インターネット技術タスクフォース) はこれらの文書の状態の進化 (標準化への提唱、標準化への草稿、標準) を決定します。
			</div><div
              class="para">
				RFC 2026 ではインターネットプロトコル標準化の手続きが定義されています。<div
                xmlns=""
                class="url">→ <a
                  xmlns="http://www.w3.org/1999/xhtml"
                  href="http://www.faqs.org/rfcs/rfc2026.html">http://www.faqs.org/rfcs/rfc2026.html</a></div>
			</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.8.6.5.8"></a>5.2.1.1. 依存関係、<code
                      class="literal">Depends</code> フィールド</h4></div></div></div><a
              id="id-1.8.6.5.8.2"
              class="indexterm"></a><a
              id="id-1.8.6.5.8.3"
              class="indexterm"></a><a
              id="id-1.8.6.5.8.4"
              class="indexterm"></a><div
              class="para">
					依存関係はパッケージヘッダの <code
                class="literal">Depends</code> フィールドで定義されています。依存関係はパッケージを正しく動かすために必要な条件を定義しています。すなわち <code
                class="command">apt</code> などのツールはこの情報を使ってインストールしたいパッケージの依存関係を満たすために必要なバージョンのライブラリをインストールします。それぞれの依存パッケージについて、要求を満たすパッケージのバージョン範囲を指定することが可能です。言い換えれば、バージョン「2.15」以上の <span
                class="pkg pkg">libc6</span> パッケージが必要という条件を表現する (「<code
                class="command">libc6 (&gt;= 2.15)</code>」と表記する) ことが可能です。バージョン比較演算子は次の通りです。
				</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
							<code
                      class="command">&lt;&lt;</code> はより低いことを意味します。
						</div></li><li
                  class="listitem"><div
                    class="para">
							<code
                      class="command">&lt;=</code> は以下を意味します。
						</div></li><li
                  class="listitem"><div
                    class="para">
							<code
                      class="command">=</code> は等しいことを意味します (「<code
                      class="literal">2.6.1</code>」は「<code
                      class="literal">2.6.1-1</code>」と等しくありません)。
						</div></li><li
                  class="listitem"><div
                    class="para">
							<code
                      class="command">&gt;=</code> は以上を意味します。
						</div></li><li
                  class="listitem"><div
                    class="para">
							<code
                      class="command">&gt;&gt;</code> はより高いことを意味します。
						</div></li></ul></div><div
              class="para">
					満足すべき条件リストの中で使われるコンマは条件同士の区切りです。このコンマは論理「and」に解釈されます。条件リストの中で使われる垂直棒 (「|」) は論理「or」に解釈されます (これは「包含的論理和」で、「排他的論理和」ではありません)。「or」は「and」より高い優先度を持っており、必要に応じて何度でも使えます。このため、「(A or B) and C」は <code
                class="command">A | B, C</code> のように表記できます。これに対して、「A or (B and C)」は「(A or B) and (A or C)」のように表記してください。なぜなら、<code
                class="literal">Depends</code> フィールドでは括弧を使って論理演算子「or」と「and」の優先度の順位を変えることができないからです。このため、これは <code
                class="command">A | B, A | C</code> のように表記できます。<div
                xmlns=""
                class="url">→ <a
                  xmlns="http://www.w3.org/1999/xhtml"
                  href="http://www.debian.org/doc/debian-policy/ch-relationships.html">http://www.debian.org/doc/debian-policy/ch-relationships.html</a></div>
				</div><a
              id="id-1.8.6.5.8.8"
              class="indexterm"></a><div
              class="para">
					依存関係システムはプログラムの動作を保証する良いメカニズムですが、「メタパッケージ」を使う手もあります。メタパッケージは依存関係を表記するだけの空のパッケージです。メタパッケージはメンテナが事前に選んだ一連のプログラムグループのインストールを楽にします。すなわち <code
                class="command">apt install <em
                  class="replaceable">meta-package</em></code> はメタパッケージが依存するすべてのプログラムを自動的にインストールします。<span
                class="pkg pkg">gnome</span>、<span
                class="pkg pkg">kde-full</span>、<span
                class="pkg pkg">linux-image-amd64</span> パッケージはメタパッケージの例です。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN POLICY</em></span> <code
                          class="literal">Pre-Depends</code>、<code
                          class="literal">Depends</code> よりも厳しい要求</strong></p></div></div></div><a
                id="id-1.8.6.5.8.10.2"
                class="indexterm"></a><a
                id="id-1.8.6.5.8.10.3"
                class="indexterm"></a><div
                class="para">
					「先行依存」はパッケージヘッダの「<code
                  class="literal">Pre-Depends</code>」フィールドに書かれており、通常の依存関係を完全なものにします。条件の書式は <code
                  class="literal">Depends</code> フィールドと同じです。通常の依存関係とは、依存関係が記述されたパッケージの設定前に、依存関係にあるパッケージの展開および設定を行わなければいけないことを示しています。先行依存とは、先行依存関係が記述されたパッケージのインストール前スクリプトの実行前 (インストールの前) に、先行依存関係にあるパッケージの展開および設定を行わなければいけないことを規定しています。
				</div><div
                class="para">
					先行依存は <code
                  class="command">apt</code> にとってとても重要です。なぜなら、先行依存関係はパッケージをインストールする順番を厳しく制約するからです。先行依存関係それ自体は、絶対に必要でない限り勧められません。先行依存関係を追加する前に、<code
                  class="email"><a
                    class="email"
                    href="mailto:debian-devel@lists.debian.org">debian-devel@lists.debian.org</a></code> の他の開発者に相談することをお勧めします。通常、次善策として別の解決策を見つけることが可能です。
				</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN POLICY</em></span> <code
                          class="literal">Recommends</code>、<code
                          class="literal">Suggests</code>、<code
                          class="literal">Enhances</code> フィールド</strong></p></div></div></div><a
                id="id-1.8.6.5.8.11.2"
                class="indexterm"></a><a
                id="id-1.8.6.5.8.11.3"
                class="indexterm"></a><div
                class="para">
					<code
                  class="literal">Recommends</code> (推奨) と <code
                  class="literal">Suggests</code> (提案) フィールドは必須ではない依存関係を表すためのものです。最も重要な「推奨」依存関係のパッケージは、パッケージの提供する機能を大幅に改善するけれども、動作に必要不可欠ではないパッケージです。2 番目に重要な「提案」依存関係のパッケージは、そのユーティリティの機能を補完したり強化する可能性があり、他のパッケージではなくこのパッケージをインストールするのが極めて合理的であるようなパッケージです。
				</div><div
                class="para">
					「推奨」パッケージは、それを必要としない理由を理解している場合を除いて、常にインストールされるべきです。逆に「提案」パッケージは、それを必要とする理由を理解している場合を除いて、インストールしなくても構いません。
				</div><a
                id="id-1.8.6.5.8.11.6"
                class="indexterm"></a><div
                class="para">
					<code
                  class="literal">Enhances</code> フィールドは <code
                  class="literal">Recommends</code> や <code
                  class="literal">Suggests</code> フィールドと同様にパッケージを提案するためのものですが、使用法が少し違います。自分があるパッケージから利益を得る場合は Suggests フィールドにそのパッケージを追加し、自分があるパッケージに利益を与える場合は Enhances フィールドにそのパッケージを追加します。Enhances フィールドの良いところは、提案される側のパッケージを変更せずにそのパッケージにとって自分が有用であるという提案を追加できる、という点です。つまり、あるソフトウェアのアドオン、プラグイン、機能拡張のパッケージはそのソフトウェアを Enhances フィールドに載せることが可能です。数年前から存在したにも関わらず、Enhances フィールドはいまだに <code
                  class="command">apt</code> や <code
                  class="command">synaptic</code> など多くのプログラムから無視されています。<code
                  class="literal">Enhances</code> フィールドの目的とは、<code
                  class="literal">Suggests</code> フィールドによる伝統的な提案ではカバーできない提案をユーザに示すことです。
				</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.8.6.5.9"></a>5.2.1.2. 衝突、<code
                      class="literal">Conflicts</code> フィールド</h4></div></div></div><a
              id="id-1.8.6.5.9.2"
              class="indexterm"></a><a
              id="id-1.8.6.5.9.3"
              class="indexterm"></a><a
              id="id-1.8.6.5.9.4"
              class="indexterm"></a><div
              class="para">
					<code
                class="literal">Conflicts</code> フィールドでは、同時にインストールできないパッケージを指定します。このフィールドが使われるケースで最も多いのは、両方のパッケージが同名のファイルを含む場合、同種のサービスを同じ TCP ポートで提供する場合、互いの動作を妨げる場合です。
				</div><div
              class="para">
					<code
                class="command">dpkg</code> は、あるパッケージがインストール済みのパッケージと衝突を引き起こす場合、新しいパッケージがインストール済みのパッケージを「置換」するものでない限り、そのパッケージのインストールを拒否するでしょう (「置換」するものの場合、<code
                class="command">dpkg</code> はインストール済みパッケージを新パッケージで置換します)。これに対して <code
                class="command">apt</code> は常にあなたの指示に従います。つまり、もし <code
                class="command">apt</code> に新しいパッケージをインストールするよう指示したのなら、<code
                class="command">apt</code> は新しいパッケージをインストールする際に障害となるインストール済みパッケージを自動的にアンインストールします。
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.8.6.5.10"></a>5.2.1.3. 不適合性、<code
                      class="literal">Breaks</code> フィールド</h4></div></div></div><a
              id="id-1.8.6.5.10.2"
              class="indexterm"></a><a
              id="id-1.8.6.5.10.3"
              class="indexterm"></a><a
              id="id-1.8.6.5.10.4"
              class="indexterm"></a><div
              class="para">
					<code
                class="literal">Breaks</code> フィールドは <code
                class="literal">Conflicts</code> フィールドとよく似た効果を持っていますが、特別な意味があります。すなわち、<code
                class="literal">Breaks</code> フィールドを持つパッケージは <code
                class="literal">Breaks</code> フィールドに指定された他のパッケージ (または他のパッケージの特定バージョン) を「破壊する」という意味があります。一般的に、このような 2 つのパッケージの不適合性は一時的なもので、<code
                class="literal">Breaks</code> フィールドでは不適合性がある特定のバージョンだけを指定します。
				</div><div
              class="para">
					<code
                class="command">dpkg</code> はインストール済みのパッケージを破壊するようなパッケージのインストールを拒否します。<code
                class="command">apt</code> は破壊されるパッケージを新しいバージョンに更新することで (新しいバージョンではこの問題が修正され、両パッケージが適合すると期待されます) この問題の解決を試みます。
				</div><div
              class="para">
					この手の状況は更新によって後方互換性がなくなる場合に起こりうるかもしれません。具体的に言えば、新しいバージョンが古いバージョンと同時に動かない場合、特別な設定をしないと別のプログラムがうまく動かない場合です。<code
                class="literal">Breaks</code> フィールドはユーザがこのような問題に遭遇することがないようにしています。
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.8.6.5.11"></a>5.2.1.4. 提供されるアイテム、<code
                      class="literal">Provides</code> フィールド</h4></div></div></div><a
              id="id-1.8.6.5.11.2"
              class="indexterm"></a><div
              class="para">
					<code
                class="literal">Provides</code> フィールドはとても興味深い「仮想パッケージ」の構想を生み出しました。<code
                class="literal">Provides</code> フィールドは多くの役割を持っていますが、特に重要な 2 つを説明します。最初の役割は、<code
                class="literal">Provides</code> フィールドを持つパッケージは <code
                class="literal">Provides</code> フィールドに指定された一般的なサービスを意味する仮想パッケージに関連付けられている (サービスを「提供する」のは <code
                class="literal">Provides</code> フィールドを持つパッケージ自身です)、という意味を持たせる役割です。2 番目の役割は、<code
                class="literal">Provides</code> フィールドを持つパッケージは <code
                class="literal">Provides</code> フィールドに指定されたパッケージの機能を完全に置き換えており、<code
                class="literal">Provides</code> フィールドに指定されたパッケージの代替として <code
                class="literal">Provides</code> フィールドに指定されたパッケージに依存する他のパッケージの依存関係を満足できる、という意味を持たせる役割です。そのため、あるパッケージの機能を代替する別パッケージを必ずしも同じパッケージ名を使わずに作ることが可能です。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULARY</em></span> メタパッケージと仮想パッケージ</strong></p></div></div></div><a
                id="id-1.8.6.5.11.4.2"
                class="indexterm"></a><a
                id="id-1.8.6.5.11.4.3"
                class="indexterm"></a><a
                id="id-1.8.6.5.11.4.4"
                class="indexterm"></a><div
                class="para">
					メタパッケージと仮想パッケージを明確に区別することは絶対に不可欠です。メタパッケージは真のパッケージで (真の <code
                  class="filename">.deb</code> ファイルを含んでいます)、その目的は依存関係を表現するだけです。
				</div><div
                class="para">
					これに対して、仮想パッケージは実体がありません。そして、仮想パッケージの目的は、一般的で論理的な基準 (提供するサービス、一般的なプログラムまたは既存のパッケージなどとの互換性) に従って複数の実体を持つパッケージを同一視することです。
				</div></div><div
              class="section"><div
                class="titlepage"><div><div><h5
                      class="title"><a
                        xmlns=""
                        id="id-1.8.6.5.11.5"></a>5.2.1.4.1. 「サービス」の提供</h5></div></div></div><div
                class="para">
						最初の場合について、例を挙げて詳細に議論しましょう。すなわち、すべてのメールサーバ、たとえば <span
                  class="pkg pkg">postfix</span> や <span
                  class="pkg pkg">sendmail</span> などは <span
                  class="pkg pkg">mail-transport-agent</span> 仮想パッケージ「提供」しています。このため、動作にメールサービスを必要とするパッケージ (たとえば <span
                  class="pkg pkg">smartlist</span> や <span
                  class="pkg pkg">sympa</span> などのメーリングリストマネージャ) は、おそらくメールサービスを提供するであろうパッケージをたくさん依存関係に宣言する (たとえば、<code
                  class="command">postfix | sendmail | exim4 | …</code>のように宣言する) のではなく、たった 1 つ <span
                  class="pkg pkg">mail-transport-agent</span> を宣言するだけで十分です。さらに、1 台のマシンに 2 つのメールサーバをインストールすることは無駄なため、メールサーバの機能を提供するパッケージは <span
                  class="pkg pkg">mail-transport-agent</span> 仮想パッケージとの衝突を宣言します。例外的にあるパッケージとそれ自身との衝突はシステムによって無視されます。この手法により、2 つのメールサーバを同時にインストールできなくなります。
					</div><div
                class="sidebar"><div
                  class="titlepage"><div><div><p
                        class="title"><strong><span
                            class="emphasis"><em>DEBIAN POLICY</em></span> 仮想パッケージのリスト</strong></p></div></div></div><a
                  id="id-1.8.6.5.11.5.3.2"
                  class="indexterm"></a><div
                  class="para">
						仮想パッケージを有益なものにするためには、全員がその名前に同意しなければいけません。このため、仮想パッケージの名前は Debian ポリシーで標準化されています。メールサーバ用に <span
                    class="pkg pkg">mail-transport-agent</span>、C 言語コンパイラ用に <span
                    class="pkg pkg">c-compiler</span>、ウェブブラウザ用に <span
                    class="pkg pkg">www-browser</span>、ウェブサーバ用に <span
                    class="pkg pkg">httpd</span>、FTP サーバ用に <span
                    class="pkg pkg">ftp-server</span>、グラフィカルモードのターミナルエミュレータ (<code
                    class="command">xterm</code>) 用に <span
                    class="pkg pkg">x-terminal-emulator</span>、ウィンドウマネージャ用に <span
                    class="pkg pkg">x-window-manager</span> などが定められています。
					</div><div
                  class="para">
						完全なリストはウェブの情報を参照してください。<div
                    xmlns=""
                    class="url">→ <a
                      xmlns="http://www.w3.org/1999/xhtml"
                      href="http://www.debian.org/doc/packaging-manuals/virtual-package-names-list.txt">http://www.debian.org/doc/packaging-manuals/virtual-package-names-list.txt</a></div>
					</div></div></div><div
              class="section"><div
                class="titlepage"><div><div><h5
                      class="title"><a
                        xmlns=""
                        id="id-1.8.6.5.11.6"></a>5.2.1.4.2. 他のパッケージとの互換性</h5></div></div></div><div
                class="para">
						パッケージの内容が巨大なパッケージに統合された場合に、<code
                  class="literal">Provides</code> フィールドはさらに興味深い役割を果たします。たとえば、<span
                  class="pkg pkg">libdigest-md5-perl</span> Perl モジュールは Perl 5.6 では任意選択モジュールでしたが、Perl 5.8 (および <span
                  class="distribution distribution">Jessie</span> に含まれる 5.20 などのその後のバージョン) では標準モジュールに組み込まれました。このため、<span
                  class="pkg pkg">perl</span> パッケージはバージョン 5.8 から <code
                  class="literal">Provides: libdigest-md5-perl</code> を宣言しています。そうすれば、ユーザが Perl 5.8 (とそれより新しいバージョン) を持っている場合、<span
                  class="pkg pkg">libdigest-md5-perl</span> に依存するパッケージの依存関係を満足させることができるからです。そして最終的に実体を持つ <span
                  class="pkg pkg">libdigest-md5-perl</span> パッケージは削除されました。なぜなら、古い Perl バージョンが削除されたことで実体を持つ <span
                  class="pkg pkg">libdigest-md5-perl</span> パッケージはもはや存在意義がなくなったからです。
					</div><div
                class="figure"><a
                  xmlns=""
                  id="id-1.8.6.5.11.6.3"></a><div
                  class="figure-contents"><div
                    class="mediaobject"><img
                      src="images/virtual-package.png"
                      alt="依存関係を壊さないための Provides フィールドの使い方" /></div></div><p
                  class="title"><strong>図 5.1 依存関係を壊さないための <code
                      class="literal">Provides</code> フィールドの使い方</strong></p></div><div
                class="para">
						この機能はとても役立ちます。なぜなら、開発方向性の変化を予測することは絶対に不可能ですし、パッケージ名を変更したり他の時代遅れのソフトウェアを自動に置き換えたりすることを可能な状態にしておくことが必要だからです。
					</div><div
                class="sidebar"><div
                  class="titlepage"><div><div><p
                        class="title"><strong><span
                            class="emphasis"><em>BACK TO BASICS</em></span> Perl、プログラミング言語</strong></p></div></div></div><a
                  id="id-1.8.6.5.11.6.5.2"
                  class="indexterm"></a><a
                  id="id-1.8.6.5.11.6.5.3"
                  class="indexterm"></a><div
                  class="para">
						Perl (Practical Extraction and Report Language) はとても人気の高いプログラミング言語です。Perl にはすぐに使えるモジュールが数多くあります。これらのモジュールは非常に広い分野における応用をカバーし、Perl パッケージの包括的ネットワークである CPAN (Comprehensive Perl Archive Network) サーバで配布されています。<div
                    xmlns=""
                    class="url">→ <a
                      xmlns="http://www.w3.org/1999/xhtml"
                      href="http://www.perl.org/">http://www.perl.org/</a></div><div
                    xmlns=""
                    class="url">→ <a
                      xmlns="http://www.w3.org/1999/xhtml"
                      href="http://www.cpan.org/">http://www.cpan.org/</a></div>
					</div><div
                  class="para">
						Perl はインタプリタ型言語であるため、Perl で書かれたプログラムは実行前にコンパイルする必要がありません。このためプログラムは「Perl スクリプト」と呼ばれています。
					</div></div></div><div
              class="section"><div
                class="titlepage"><div><div><h5
                      class="title"><a
                        xmlns=""
                        id="id-1.8.6.5.11.7"></a>5.2.1.4.3. 過去に設けられていた制限</h5></div></div></div><div
                class="para">
						かつて仮想パッケージにはいくつかの制限がありました。最も重要な制限はバージョン番号がなかったことでした。先に挙げた例に戻ると、Perl 5.10 が存在する場合、<code
                  class="literal">Depends: libdigest-md5-perl (&gt;= 1.6)</code> という依存関係は満足されています (正しく言えば、十中八九は満足されています)。しかしながら、パッケージシステムはこの依存関係が満足されていることに気が付きませんでした。そして、パッケージシステムは指定されたバージョンが一致しないと仮定して最もリスクの低いオプションを選んでいました。
					</div><div
                class="para">
						この制限は <span
                  class="pkg pkg">dpkg</span> 1.17.11 で撤廃され、Jessie ではもはや関係のない話です。パッケージは自分自身が提供する仮想パッケージにバージョン番号を付けることが可能です。これを行うには <code
                  class="literal">Provides: libdigest-md5-perl (= 1.8)</code> などのようにします。
					</div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.8.6.5.12"></a>5.2.1.5. ファイルの置き換え、<code
                      class="literal">Replaces</code> フィールド</h4></div></div></div><a
              id="id-1.8.6.5.12.2"
              class="indexterm"></a><a
              id="id-1.8.6.5.12.3"
              class="indexterm"></a><a
              id="id-1.8.6.5.12.4"
              class="indexterm"></a><div
              class="para">
					<code
                class="literal">Replaces</code> フィールドは、<code
                class="literal">Replaces</code> フィールドを持つパッケージが <code
                class="literal">Replaces</code> フィールドに指定された他のパッケージからも提供されるファイルを含んでおり、合法的に <code
                class="literal">Replaces</code> フィールドに指定されたパッケージから提供されたファイルを置き換える権利を持っていることを示すためのものです。<code
                class="literal">Replaces</code> フィールドがなければ、<code
                class="command">dpkg</code> は別パッケージから提供されたファイルをインストール中のパッケージに含まれるファイルで置き換えることはできません。すなわちこれは他のパッケージのファイルは上書きできないことを意味しています (技術的に言えば、<code
                class="literal">--force-overwrite</code> オプションを付けることで強制的に上書き可能ですが、これは一般に認められていません)。このような <code
                class="command">dpkg</code> の挙動により潜在的な問題を識別できるようになりますし、メンテナはこのフィールドを追加する前に問題の原因を追及できるようになります。
				</div><div
              class="para">
					<code
                class="literal">Replaces</code> フィールドはパッケージ名が変更された時やパッケージが別のパッケージに統合された時に使われます。この状況はメンテナが同じソースパッケージから複数のバイナリパッケージを作成し、各バイナリパッケージから異なるファイルを配布するように方針を決めた場合に発生します。つまり、古いパッケージに含まれていたファイルがソースパッケージは同じでもバイナリパッケージの名前が異なる新しいパッケージに含まれるようになった場合に発生します。
				</div><div
              class="para">
					インストール済みパッケージのすべてのファイルが置き換えられたら、このパッケージは削除されたとみなされます。最後に、<code
                class="literal">Replaces</code> フィールドは衝突がある場合に <code
                class="command">dpkg</code> に置き換えられたパッケージを削除させる際に使われます。
				</div><div
              class="sidebar"><a
                xmlns=""
                id="sidebar.debtags"></a><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> <code
                          class="literal">Tag</code> フィールド</strong></p></div></div></div><div
                class="para">
					例として上に挙げた <span
                  class="pkg pkg">apt</span> の control ファイルには、まだ説明していない <code
                  class="literal">Tag</code> フィールドがあります。<code
                  class="literal">Tag</code> フィールドはパッケージ間の関連性を説明するものではなく、単純にテーマ分類に基づいてパッケージを分類するものです。昔からパッケージはいくつかの基準 (インターフェースの種類、プログラミング言語、アプリケーションの分野など) に基づいて分類されていました。これにも関わらず、適切なタグがすべてのパッケージに付けられているわけではありませんし、まだすべての Debian ツールがタグを使えるわけではありません。たとえば <code
                  class="command">aptitude</code> はこれらのタグを表示しますし、検索条件としてタグを使うことも可能です。<code
                  class="command">aptitude</code> の検索条件に嫌悪感を抱く人は、以下のウェブサイトを使ってタグのデータベースを見ることが可能です。<div
                  xmlns=""
                  class="url">→ <a
                    xmlns="http://www.w3.org/1999/xhtml"
                    href="http://debtags.alioth.debian.org/">http://debtags.alioth.debian.org/</a></div>
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.configuration-scripts"></a>5.2.2. 設定スクリプト</h3></div></div></div><a
            id="id-1.8.6.6.2"
            class="indexterm"></a><a
            id="id-1.8.6.6.3"
            class="indexterm"></a><a
            id="id-1.8.6.6.4"
            class="indexterm"></a><a
            id="id-1.8.6.6.5"
            class="indexterm"></a><a
            id="id-1.8.6.6.6"
            class="indexterm"></a><div
            class="para">
				それぞれの Debian パッケージには <code
              class="filename">control</code> ファイルだけでなく <code
              class="filename">control.tar.gz</code> アーカイブが含まれており、<code
              class="filename">control.tar.gz</code> には <code
              class="command">dpkg</code> がパッケージ処理の各段階で呼び出す多数のスクリプトが含まれているかもしれません。Debian ポリシーでは、呼び出されるスクリプトとスクリプトが受け取る引数を明記することで、スクリプトの使われ方が詳しく説明されています。スクリプトが呼び出される順番はわかりにくいかもしれません。なぜなら、スクリプトのうち 1 つでも失敗したら、<code
              class="command">dpkg</code> はインストールを中止するか (可能ならば) 進行中の削除を中止することでシステムを整合性のある状態に戻そうとするからです。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>GOING FURTHER</em></span> <code
                        class="command">dpkg</code> データベース</strong></p></div></div></div><a
              id="id-1.8.6.6.8.2"
              class="indexterm"></a><a
              id="id-1.8.6.6.8.3"
              class="indexterm"></a><div
              class="para">
				インストール済みパッケージの設定スクリプトはすべて <code
                class="filename">/var/lib/dpkg/info/</code> ディレクトリに、ファイル名がパッケージ名から始まるファイルの形で保存されています。このディレクトリには、ファイル名がパッケージ名に <code
                class="filename">.list</code> 拡張子を付けたファイルが含まれています。このファイルの内容はパッケージに含まれるファイルのリストです。
			</div><div
              class="para">
				<code
                class="filename">/var/lib/dpkg/status</code> ファイルは (有名なメールヘッダ、RFC 2822、の形で) 一連のデータブロックを含んでおり、各データブロックは各パッケージの状態に対応します。この情報はインストール済みのパッケージの <code
                class="filename">control</code> ファイルから複製されています。
			</div></div><div
            class="para">
				一般的に言って、<code
              class="filename">preinst</code> スクリプトはパッケージのインストール前に実行され、<code
              class="filename">postinst</code> はインストール後に実行されます。同様に、<code
              class="filename">prerm</code> はパッケージの削除前に実行され、<code
              class="filename">postrm</code> は削除後に実行されます。パッケージの更新とは、パッケージの古いバージョンを削除して新しいバージョンをインストールすることと等価です。ここで起こりうるすべてのシナリオを詳細に説明することは不可能なので、最も一般的なケースを 2 種類だけ挙げます。具体的に言えば、インストール/更新と削除について説明します。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CAUTION</em></span> スクリプト名の表記規則</strong></p></div></div></div><div
              class="para">
				この節の説明文では、<code
                class="command">old-prerm</code> や <code
                class="command">new-postinst</code> などの特定の名前を持つ設定スクリプトが登場します。<code
                class="command">old-prerm</code> はパッケージの (更新の前にインストールされていた) 古いバージョンに含まれる <code
                class="command">prerm</code> スクリプト、<code
                class="command">new-postinst</code> は (更新によってインストールされる) 新しいバージョンに含まれる <code
                class="command">postinst</code> スクリプトを指します。
			</div></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>TIP</em></span> 状態遷移図</strong></p></div></div></div><div
              class="para">
				<code
                class="command">dpkg</code> がどのように設定スクリプトを呼び出すかを説明する図が Manoj Srivastava によって作成されました。同様の図は Debian Women プロジェクトによっても作成されましたが、Debian Women プロジェクトの作った図は理解しやすいように少し単純化されており、Manoj Srivastava の作った図に比べると正確ではありません。<div
                xmlns=""
                class="url">→ <a
                  xmlns="http://www.w3.org/1999/xhtml"
                  href="https://people.debian.org/~srivasta/MaintainerScripts.html">https://people.debian.org/~srivasta/MaintainerScripts.html</a></div><div
                xmlns=""
                class="url">→ <a
                  xmlns="http://www.w3.org/1999/xhtml"
                  href="https://wiki.debian.org/MaintainerScripts">https://wiki.debian.org/MaintainerScripts</a></div>
			</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.8.6.6.12"></a>5.2.2.1. パッケージのインストールとアップグレード</h4></div></div></div><a
              id="id-1.8.6.6.12.2"
              class="indexterm"></a><div
              class="para">
					以下にパッケージのインストール中 (または更新中) に何が起きるかを説明します。
				</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="orderedlist"><ol><li
                  class="listitem"><div
                    class="para">
							更新する場合、<code
                      class="command">dpkg</code> は <code
                      class="command">old-prerm upgrade <em
                        class="replaceable">new-version</em></code> を呼び出します。
						</div></li><li
                  class="listitem"><div
                    class="para">
							更新する場合、引き続き <code
                      class="command">dpkg</code> は <code
                      class="command">new-preinst upgrade <em
                        class="replaceable">old-version</em></code> を実行します。これに対して、初めてインストールする場合、<code
                      class="command">new-preinst install</code> を実行します。過去にもしパッケージがインストールされてさらに削除されていた場合 (完全削除されていない場合、古い設定ファイルがまだ残っている場合)、最後の引数に古いバージョンを追加します。
						</div></li><li
                  class="listitem"><div
                    class="para">
							そして新しいパッケージのファイルが展開されます。あるファイルが既に存在した場合、そのファイルは置換されますが、一時的にバックアップコピーが作られます。
						</div></li><li
                  class="listitem"><div
                    class="para">
							更新する場合、<code
                      class="command">dpkg</code> は <code
                      class="command">old-postrm upgrade <em
                        class="replaceable">new-version</em></code> を実行します。
						</div></li><li
                  class="listitem"><div
                    class="para">
							<code
                      class="command">dpkg</code> はすべての内部データ (ファイルリスト、設定スクリプトなど) を更新し、置換されたファイルのバックアップを削除します。これ以降はもう後戻りできません。つまり、前の状態に戻るために必要な情報がすべて失われたため、<code
                      class="command">dpkg</code> は状態を復元できません。
						</div></li><li
                  class="listitem"><div
                    class="para">
							<code
                      class="command">dpkg</code> は設定ファイルを更新します。自動的にこの作業を完了できない場合にはユーザにどうするか尋ねます。この作業の詳細は<a
                      class="xref"
                      href="sect.package-meta-information.html#sect.conffiles">第 5.2.3 節「チェックサム、設定ファイルのリスト」</a>をご覧ください。
						</div></li><li
                  class="listitem"><div
                    class="para">
							最後に、<code
                      class="command">dpkg</code> は <code
                      class="command">new-postinst configure <em
                        class="replaceable">last-version-configured</em></code> を実行して、パッケージを設定します。
						</div></li></ol></div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.8.6.6.13"></a>5.2.2.2. パッケージの削除</h4></div></div></div><div
              class="para">
					以下にパッケージの削除中に何が起きるかを説明します。
				</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="orderedlist"><ol><li
                  class="listitem"><div
                    class="para">
							<code
                      class="command">dpkg</code> は <code
                      class="command">prerm remove</code> を呼び出します。
						</div></li><li
                  class="listitem"><div
                    class="para">
							<code
                      class="command">dpkg</code> は設定ファイルと設定スクリプトを除くすべてのパッケージのファイルを削除します。
						</div></li><li
                  class="listitem"><div
                    class="para">
							<code
                      class="command">dpkg</code> は <code
                      class="command">postrm remove</code> を実行します。すべての設定スクリプトは <code
                      class="filename">postrm</code> を除いて削除されます。ユーザが「purge」オプションを指定しない限り、作業はここで終了します。
						</div></li><li
                  class="listitem"><div
                    class="para">
							パッケージを完全削除する (<code
                      class="command">dpkg --purge</code> または <code
                      class="command">dpkg -P</code> が実行された) 場合、設定ファイルおよびそのコピー (<code
                      class="filename">*.dpkg-tmp</code>、<code
                      class="filename">*.dpkg-old</code>、<code
                      class="filename">*.dpkg-new</code>) と一時ファイルも削除されます。さらに <code
                      class="command">dpkg</code> は <code
                      class="command">postrm purge</code> を実行します。
						</div></li></ol></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULARY</em></span> Purge、完全削除</strong></p></div></div></div><a
                id="id-1.8.6.6.13.4.2"
                class="indexterm"></a><div
                class="para">
					Debian パッケージが削除されても、パッケージの設定ファイルは後々の再インストールを楽にするために削除されません。同様に、デーモンが作成したデータ (LDAP サーバディレクトリの内容、SQL サーバのデータベースの内容など) も削除されません。
				</div><div
                class="para">
					パッケージに関連するすべてのデータを削除するには、<code
                  class="command">dpkg -P <em
                    class="replaceable">package</em></code>、<code
                  class="command">apt-get remove --purge <em
                    class="replaceable">package</em></code>、<code
                  class="command">aptitude purge <em
                    class="replaceable">package</em></code> などのコマンドを使ってパッケージを「完全削除」する必要があります。
				</div><div
                class="para">
					「完全削除」によって削除されるデータに含まれる内容を考慮すると、安易に完全削除を実行するべきではありません。
				</div></div><a
              id="id-1.8.6.6.13.5"
              class="indexterm"></a><div
              class="para">
					上で詳細を述べた 4 つのスクリプトの実行を補助するのが <code
                class="filename">config</code> スクリプトです。<code
                class="filename">config</code> スクリプトはパッケージから提供され、<code
                class="command">debconf</code> を用いて設定に必要な情報をユーザに入力させるために使われます。ユーザからの情報は <code
                class="command">debconf</code> データベースに保存され、後から利用されます。このスクリプトは通常 <code
                class="command">apt</code> によって各パッケージインストールの前に実行され、処理が始まるとすべての質問をまとめてユーザに尋ねます。インストール前後に実行されるスクリプトは、ユーザの希望を反映させるために、<code
                class="command">debconf</code> データベースに保存された情報を利用します。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>TOOL</em></span> <code
                          class="command">debconf</code></strong></p></div></div></div><a
                id="id-1.8.6.6.13.7.2"
                class="indexterm"></a><div
                class="para">
					<code
                  class="command">debconf</code> は Debian で繰り返し発生する問題を解決するために作られました。その昔、最低限の設定なしにはうまく動作しないすべての Debian パッケージは、最低限の設定を行うために <code
                  class="filename">postinst</code> シェルスクリプト (と同様の別のスクリプト) の中で <code
                  class="command">echo</code> や <code
                  class="command">read</code> コマンドを呼び出すことにより、設定内容について質問していました。しかしこの方法では、ユーザは長時間かかるインストールや更新の最中、いつあるかわからないさまざまな質問に答えるために、コンピュータの前に居続けなければいけませんでした。<code
                  class="command">debconf</code> ツールのおかげで、今やほとんどの場合、このような手動設定法を採る必要はなくなりました。
				</div><div
                class="para">
					<code
                  class="command">debconf</code> には多くの興味深い機能があります。具体的に言えば <code
                  class="command">debconf</code> を使うことで開発者は、ユーザに入力させる内容を規定したり、ユーザに向けて表示されるすべての文字列を地域化したり (すべての翻訳は入力内容を説明している <code
                  class="filename">templates</code> ファイルに保存されます)、ユーザに質問を表示するためのさまざまなフロントエンド (テキストモード、グラフィカルモード、非対話型モード) に自前で対応させる必要がなくなり、複数のコンピュータで同じ設定を共有するためにユーザが入力した内容の中央データベースを作成したり、することが可能になります。しかし <code
                  class="command">debconf</code> の最も重要な機能はユーザに対するすべての質問が長時間かかるインストールや更新作業の前に行われる点です。ユーザはシステムがインストールを行っている間に自分の仕事をできます。質問に答えるために画面の前に居続ける必要はありません。
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.conffiles"></a>5.2.3. チェックサム、設定ファイルのリスト</h3></div></div></div><a
            id="id-1.8.6.7.2"
            class="indexterm"></a><a
            id="id-1.8.6.7.3"
            class="indexterm"></a><a
            id="id-1.8.6.7.4"
            class="indexterm"></a><a
            id="id-1.8.6.7.5"
            class="indexterm"></a><a
            id="id-1.8.6.7.6"
            class="indexterm"></a><div
            class="para">
				前の節で既に説明したメンテナスクリプトと管理情報に加えて、Debian パッケージの <code
              class="filename">control.tar.gz</code> アーカイブは興味深いファイルを含んでいる場合があります。1 つ目は <code
              class="filename">md5sums</code> です。<code
              class="filename">md5sums</code> にはパッケージに含まれる全ファイルの MD5 チェックサムが列挙されています。<code
              class="filename">md5sums</code> のおかげで <code
              class="command">dpkg --verify</code> はインストール以降ファイルが変更されたか否かを判断できるようになります (詳しくは<a
              class="xref"
              href="sect.supervision.html#sect.dpkg-verify">第 14.3.3.1 節「<code
                class="command">dpkg --verify</code> を使ったパッケージ監視」</a>を参照してください)。パッケージが <code
              class="filename">md5sums</code> を提供しない場合、<code
              class="command">dpkg</code> がインストール時に動的に <code
              class="filename">md5sums</code> を生成します (そして他の管理情報ファイルと同様に dpkg データベースに内容を保存します)。
			</div><div
            class="para">
				<code
              class="filename">conffiles</code> では、設定ファイルとして取り扱われるべきパッケージファイルが指定されています。管理者は設定ファイルを変更でき、<code
              class="command">dpkg</code> はパッケージの更新中に設定ファイルの変更を保存しようとします。
			</div><div
            class="para">
				実際のところ、システムに現存する設定ファイルをパッケージから提供された設定ファイルで更新する際に <code
              class="command">dpkg</code> はできるだけ賢明に振る舞います。以下に <code
              class="command">dpkg</code> のデフォルトの設定ファイル更新処理規則を述べます。パッケージの更新前後でパッケージから提供される標準設定ファイルの内容が同じ場合、<code
              class="command">dpkg</code> は何もしません。しかしながら、パッケージの更新前後でパッケージから提供される標準設定ファイルの内容が違う場合、<code
              class="command">dpkg</code> はシステムに現存する設定ファイルを更新しようとします。ここでさらに 2 つの場合が考えられます。システムに現存する設定ファイルと古いバージョンのパッケージから提供される標準設定ファイルの内容が同じ場合、<code
              class="command">dpkg</code> は自動的に新しいパッケージから提供される標準設定ファイルをパッケージ更新完了後の設定ファイルとして採用します。一方で、システムに現存する設定ファイルと古いバージョンのパッケージから提供される標準設定ファイルの内容が違う場合、<code
              class="command">dpkg</code> は管理者に対してシステムに現存する設定ファイルまたは新しいバージョンのパッケージから提供される標準設定ファイルのどちらを更新後の設定ファイルとして採用するかを尋ねます。この判断を手助けするために、<code
              class="command">dpkg</code> は「<code
              class="command">diff</code>」を使って 2 つの設定ファイルの内容の違いを表示します。管理者が現存する設定ファイルを選んだ場合、新しいバージョンのパッケージから提供される標準設定ファイルは同じ場所にファイル名の末尾に <code
              class="filename">.dpkg-dist</code> を追加して保存されます。管理者が新しいバージョンのパッケージから提供される標準設定ファイルを選んだ場合、現存する設定ファイルは同じ場所にファイル名の末尾に <code
              class="filename">.dpkg-old</code> を追加して保存されます。この段階では、一時的に <code
              class="command">dpkg</code> の処理を中断してファイルを編集したり、もう一度バージョン間の違いを表示したり (先と同様に <code
              class="command">diff</code> コマンドを実行する) することも可能です。
			</div><div
            class="sidebar"><a
              xmlns=""
              id="sidebar.questions-conffiles"></a><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>GOING FURTHER</em></span> 設定ファイルの更新に関連する質問を回避する</strong></p></div></div></div><div
              class="para">
				<code
                class="command">dpkg</code> は設定ファイルの更新を担当しますが、更新中に管理者からの入力を要求するため、更新作業は定期的に中断されます。この状況は非対話的に更新作業を行いたいと思う管理者にとって都合がよいとは言えません。そのため、<code
                class="command">dpkg</code> には設定ファイル更新処理規則を指定して自動的に処理を進めるオプションが用意されています。具体的に言えば、<code
                class="command">--force-confold</code> を使った場合はいかなる状況でも常にシステムに現存する設定ファイルがパッケージ更新完了後の設定ファイルとして採用され、<code
                class="command">--force-confnew</code> を使った場合はいかなる状況でも常に新しいバージョンのパッケージから提供される標準設定ファイルが採用されます (これらのオプションを単独で使った場合、システムに現存する設定ファイルおよび更新前後のバージョンのパッケージから提供される標準設定ファイルの互いの内容の違いは一切考慮されないので、期待通りの結果を得られないことが多いです)。上記オプションに加えて <code
                class="command">--force-confdef</code> オプションを使うと、<code
                class="command">dpkg</code> は設定ファイル更新処理時に管理者の判断を仰ぐ必要が生じた場合に限り (言い換えれば、システムに現存する設定ファイルの内容が更新前後のどちらのバージョンのパッケージから提供される標準設定ファイルの内容とも違う場合に限り) 管理者からの入力を待つ代わりに <code
                class="command">--force-confnew</code> または <code
                class="command">--force-confold</code> に従って設定ファイルを更新し、それ以外の場合はデフォルトの設定ファイル更新処理規則に従って設定ファイルを更新するようになります。
			</div><div
              class="para">
				<code
                class="command">--force-confold</code>、<code
                class="command">--force-confnew</code>、<code
                class="command">--force-confdef</code> は <code
                class="command">dpkg</code> のオプションです。しかしながらほとんどの場合、管理者は <code
                class="command">aptitude</code> または <code
                class="command">apt-get</code> プログラムを使って作業を行います。そのため、<code
                class="command">aptitude</code> または <code
                class="command">apt-get</code> プログラムから <code
                class="command">dpkg</code> コマンドにオプションを渡すための構文を知らなければいけません (<code
                class="command">aptitude</code> および <code
                class="command">apt-get</code> プログラムのコマンドラインインターフェースはとてもよく似ています)。
			</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>apt -o DPkg::options::="--force-confdef" -o DPkg::options::="--force-confold" full-upgrade</code></strong></pre><div
              class="para">
				<code
                class="command">dpkg</code> に渡すオプションを <code
                class="command">apt</code> の設定に直接保存しておくことも可能です。これを行うには、<code
                class="filename">/etc/apt/apt.conf.d/local</code> ファイルに以下の行を追加してください。
			</div><div
              class="informalexample"><pre
                class="programlisting">
DPkg::options { "--force-confdef"; "--force-confold"; }</pre></div><div
              class="para">
				<code
                class="command">dpkg</code> に渡すオプションを <code
                class="command">apt</code> の設定ファイルに保存した場合、<code
                class="command">aptitude</code> のようなグラフィカルインターフェースでもここで指定したオプションが使われるようになります。
			</div></div><div
            class="sidebar"><a
              xmlns=""
              id="sidebar.questions-conffiles-bis"></a><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>GOING FURTHER</em></span> 設定ファイルの更新に関連する質問を強制する</strong></p></div></div></div><div
              class="para">
				<code
                class="command">--force-confask</code> オプションを使うと、<code
                class="command">dpkg</code> は通常は質問の必要がない場合でも設定ファイルの更新に関する質問を表示します。このため、<code
                class="command">--force-confask</code> を付けてパッケージを再インストールすると、<code
                class="command">dpkg</code> は管理者が修正したすべての設定ファイルの更新に関してもう一度質問します。特にこれはインストール済みパッケージの設定ファイルが削除され、コピーも残っていない状態でパッケージから提供される設定ファイルを再インストールしたい場合にとても便利です。つまり、通常の再インストールでは駄目な場合にこれを使います。なぜなら、<code
                class="command">dpkg</code> は設定ファイルの削除を意味のある変更の一種とみなしており、<code
                class="command">--force-confask</code> が使われていなければシステムに現存する設定ファイルの状態 (削除状態) を維持してパッケージから提供される設定ファイルをインストールしないからです。
			</div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="packaging-system.html"><strong>戻る</strong>第 5 章 パッケージシステム、ツールと基本原則</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上に戻る</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>ホーム</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.source-package-structure.html"><strong>次へ</strong>5.3. ソースパッケージの構造</a></li></ul></body></html>
