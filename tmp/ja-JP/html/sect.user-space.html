<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">B.5. ユーザ空間</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ja-JP-1.0-1" /><meta
        name="keywords"
        content="BIOS, カーネル, Unix, プロセス, 階層構造, 基本コマンド" /><link
        rel="home"
        href="index.html"
        title="Debian 管理者ハンドブック" /><link
        rel="up"
        href="short-remedial-course.html"
        title="付録 B 簡単な補習講座" /><link
        rel="prev"
        href="sect.kernel-role-and-tasks.html"
        title="B.4. カーネルが担当している一部の操作" /><link
        rel="next"
        href="backcover.html"
        title="付録 C Debian 管理者ハンドブック" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/ja-JP/stable/sect.user-space.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>戻る</strong></a></li><li
          class="home">Debian 管理者ハンドブック</li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>次へ</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.user-space"></a>B.5. ユーザ空間</h2></div></div></div><a
          id="id-1.21.8.2"
          class="indexterm"></a><a
          id="id-1.21.8.3"
          class="indexterm"></a><div
          class="para">
			「ユーザ空間」とは通常 (カーネルに対するという意味) プロセスの実行環境を意味します。「ユーザ空間」プロセスとは実際にユーザによって開始されたプロセスという意味ではありません。なぜなら、標準的なシステムでは通常、ユーザがセッションを開始する前から実行されている複数の「デーモン」(またはバックグラウンド) プロセスが存在するからです。デーモンプロセスもまたユーザ空間プロセスと考えられます。
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.process-basics"></a>B.5.1. プロセス</h3></div></div></div><a
            id="id-1.21.8.5.2"
            class="indexterm"></a><div
            class="para">
				カーネルはその初期化終了後に、最初のプロセスである <code
              class="command">init</code> を開始します。最初のプロセスである <code
              class="command">init</code> それ自身が役に立つことはほとんどなく、Unix 系システムは多くの追加的プロセスと一緒に動いています。
			</div><a
            id="id-1.21.8.5.4"
            class="indexterm"></a><div
            class="para">
				第一に、プロセスは自分自身を複製することが可能です (これは<span
              class="emphasis"><em>フォーク</em></span>として知られています)。カーネルは新しい (全く同じ) プロセスメモリ空間とそれを使うもう一つ別のプロセスを割り当てます。この時点で、2 つのプロセスの違いは <span
              class="emphasis"><em>pid</em></span> だけです。新しいプロセスは通常子プロセスと呼ばれています。そして <span
              class="emphasis"><em>pid</em></span> が変わらなかったプロセスは親プロセスと呼ばれています。
			</div><div
            class="para">
				しばしば、子プロセスは親プロセスからコピーされたデータを持った状態で、親プロセスから独立して引き続き実行されます。とは言うものの、子プロセスは他のプログラムを実行する場合が多いです。この場合、いくつかの例外を除いて、子プロセスのメモリは単純に新しいプログラムで置き換えられ、新しいプログラムの実行が始まります。このメカニズムを使用して、init プロセス (プロセス ID が 1 のプロセス) は追加的サービスを起動し起動シーケンスの全体を実行します。同時に、<code
              class="command">init</code> の子プロセスの 1 つがログイン機能を提供するユーザ用のグラフィカルインターフェースを開始します (実際のイベントの順番は<a
              class="xref"
              href="unix-services.html#sect.system-boot">第 9.1 節「システム起動」</a>に詳しく書かれています)。
			</div><div
            class="para">
				プロセスは自分が開始したタスクを完了したら、終了します。その後、カーネルがこのプロセスに割り当てられたメモリを回収し、カーネルはプロセスに実行時間を与えることを停止します。親プロセスは子プロセスが終了したことについて通知を受けます。このおかげで、親プロセスは子プロセスに委託したタスクの完了を待つことが可能になります。コマンドラインインタプリタ (<span
              class="emphasis"><em>シェル</em></span>として知られています) ではこの挙動がはっきりと見えます。コマンドがシェルに入力された場合、コマンドの実行が終了するまでプロンプトは戻って来ません。多くのシェルでは、コマンドをバックグラウンドで実行することが可能です。これを行うには、コマンドの最後に <strong
              class="userinput"><code>&amp;</code></strong> を追加するだけです。この場合、プロンプトはすぐに戻ってきます。バックグラウンドで実行されるコマンドがデータを表示する場合、このやり方は問題を引き起こすかもしれません。
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.daemons"></a>B.5.2. デーモン</h3></div></div></div><a
            id="id-1.21.8.6.2"
            class="indexterm"></a><a
            id="id-1.21.8.6.3"
            class="indexterm"></a><div
            class="para">
				「デーモン」は起動シーケンスによって自動的に開始されるプロセスです。「デーモン」はメンテナンス作業を実行したり他のプロセスにサービスを提供するために (バックグラウンドで) 実行され続けます。ここで実際の「バックグラウンドタスク」はどんなものでも構いませんし、システムの観点から何か特別なタスクを意味しているわけでもありません。「バックグラウンドタスク」は単なるプロセスで、他のプロセスとよく似ており、自分に割り当てられたタイムスライスが来た時に動きます。プロセスの区別は人間の言葉に過ぎません。そして、ユーザと対話せずに実行される (特にグラフィカルインターフェースを持たない) プロセスは「バックグラウンドで実行される」とか「デーモンとして実行される」などと表現されます。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>VOCABULARY</em></span> Daemon (守り神)、demon (悪魔)、軽蔑語?</strong></p></div></div></div><div
              class="para">
				<span
                class="emphasis"><em>daemon</em></span> という用語はギリシャ神話の <span
                class="emphasis"><em>demon</em></span> を起源とするにも関わらず、<span
                class="emphasis"><em>daemon</em></span> は暗に残虐な悪魔を意味するものではなく、その代わりに <span
                class="emphasis"><em>daemon</em></span> は守り神のようなものとして理解されています。この区別は英語ではかなりわかりにくいものです。さらに、両方の意味を同じ言葉で表している他の言語ではもっとわかりにくいです。
			</div></div><div
            class="para">
				いくつかのデーモンは<a
              class="xref"
              href="unix-services.html">第 9 章「<em>Unix サービス</em>」</a>で詳細に説明されています。
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.ipc"></a>B.5.3. プロセス間通信</h3></div></div></div><a
            id="id-1.21.8.7.2"
            class="indexterm"></a><a
            id="id-1.21.8.7.3"
            class="indexterm"></a><div
            class="para">
				デーモンでも対話型アプリケーションでも、単独のプロセスでは役に立たない場合が多いです。このため、異なるプロセス同士がデータを交換したり、相互に制御し合うためのさまざまな通信方法があります。これを意味する一般的な用語が<span
              class="emphasis"><em>プロセス間通信</em></span> (略して IPC) です。
			</div><div
            class="para">
				最も簡単な IPC システムではファイルを使います。データ送信側のプロセスが送信内容をファイルに書き込み (事前にファイル名を決めておく必要があります)、受信側はファイルを開いてその内容を読むだけです。
			</div><a
            id="id-1.21.8.7.6"
            class="indexterm"></a><div
            class="para">
				データをディスクに保存したくないと思っているならば、<span
              class="emphasis"><em>パイプ</em></span>を使うことが可能です。<span
              class="emphasis"><em>パイプ</em></span>は 2 つの端を持つ単純なオブジェクトです。そして、片側に書き込まれたデータを逆側から読み出すことが可能です。パイプの一方の端が別のプロセスによって制御されている場合、パイプは単純で便利なプロセス間通信チャネルになります。パイプは 2 種類に分類分けされます。すなわち名前付きパイプと無名パイプに分類分けされます。名前付きパイプはファイルシステム上のエントリによって表現されます (転送されたデータは保存されません)。このため、事前に名前付きパイプの場所がわかっていれば、2 つのプロセスが独立に名前付きパイプを開くことが可能です。通信プロセス同士に関連性がある場合 (たとえば、親と子プロセス)、親プロセスはフォークの前に無名パイプを作成し、子プロセスがこれを継承するだけで済みます。両方のプロセスはパイプを通じてデータを交換することが可能です。ファイルシステムは必要ありません。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>IN PRACTICE</em></span> 具体例</strong></p></div></div></div><div
              class="para">
				それでは、複雑なコマンド (<span
                class="emphasis"><em>パイプライン</em></span>) がシェルから実行された場合に何が起きるか詳しく説明しましょう。<span
                class="emphasis"><em>pid</em></span> #4374 の <code
                class="command">bash</code> プロセス (Debian の標準的なユーザシェル) があると仮定します。このシェルの中で、次のコマンドを入力します。<code
                class="command">ls | sort</code>。
			</div><div
              class="para">
				最初にシェルは入力されたコマンドを解釈します。今回の場合、シェルは 2 種類のプログラム (<code
                class="command">ls</code> と <code
                class="command">sort</code>) が存在して、一方からもう一方へ流れるデータストリーム (<strong
                class="userinput"><code>|</code></strong> 文字によって表されます。これは<span
                class="emphasis"><em>パイプ</em></span>としても知られています) があると理解します。<code
                class="command">bash</code> は最初に無名パイプ (これは <code
                class="command">bash</code> プロセス自身の中だけに存在します) を作成します。
			</div><div
              class="para">
				その後、シェルは自分自身の複製を作ります。そしてこれは新しい <code
                class="command">bash</code> プロセスで <span
                class="emphasis"><em>pid</em></span> #4521 を持っています (<span
                class="emphasis"><em>pid</em></span> は抽象的な数で、一般に特別な意味はありません)。プロセス #4521 はパイプを継承します。これは「入力」側に書き込むことが可能ということを意味しています。さらに <code
                class="command">bash</code> は自分の標準出力ストリームをパイプの入力にリダイレクトします。その後、<code
                class="command">bash</code> は <code
                class="command">ls</code> プログラムを実行します (さらに自分自身を <code
                class="command">ls</code> で置き換えます)。<code
                class="command">ls</code> は現在のディレクトリの内容をリストします。<code
                class="command">ls</code> の書き込み先は標準出力で、この出力はあらかじめリダイレクトされていたため、結果はパイプに送られます。
			</div><div
              class="para">
				2 番目のコマンドについても同様の操作が行われます。つまり <code
                class="command">bash</code> はもう一度自分自身の複製を作り、これにより pid #4522 の新しい <code
                class="command">bash</code> プロセスが作成されます。pid #4522 の新しい <code
                class="command">bash</code> プロセスは #4374 の子プロセスで、パイプを継承します。さらに <code
                class="command">bash</code> は自分の標準入力をパイプの出力に接続し、その後 <code
                class="command">sort</code> コマンドを実行します (さらに自分自身を <code
                class="command">sort</code> で置き換えます)。<code
                class="command">sort</code> コマンドは自分への入力をソートして結果を表示します。
			</div><div
              class="para">
				これで、パズルのすべてのピースがそろった状態になります。つまり <code
                class="command">ls</code> は現在のディレクトリを読み込んで、ファイルのリストをパイプに書き込みます。さらに <code
                class="command">sort</code> はファイルのリストを読み込んで、アルファベット順にソートして、結果を表示します。プロセス ID が #4521 と #4522 のプロセスは終了し、#4374 (これは実行中の他プロセスが終了するのを待っていました) は制御を取り戻し、ユーザが新しいコマンドを入力するためのプロンプトを表示します。
			</div></div><div
            class="para">
				しかしながら、すべてのプロセス間通信がデータを移動させるために使われるわけではありません。多くの状況で、送信する必要のある情報は「実行を一時停止」や「実行を再開」などの制御メッセージです。Unix (と Linux) は<span
              class="emphasis"><em>シグナル</em></span>として知られているメカニズムを提供します。このメカニズムを使って、あるプロセスは別のプロセスに対して簡単に特定のシグナルを送信することが可能です (送信するシグナルは事前に定義されたシグナルのリストから選びます)。送信に必要な情報は送信先の <span
              class="emphasis"><em>pid</em></span> だけです。
			</div><div
            class="para">
				さらに複雑な通信を行うには、プロセスが他のプロセスに対して自分が割り当てられたメモリの一部へのアクセス制限を解除したり、共有したりするメカニズムを使います。これで、プロセス間で共有されたメモリをデータ交換のために使うことが可能になります。
			</div><div
            class="para">
				最後に、ネットワーク接続を使ってプロセス同士を通信させることが可能です。そして数千キロ離れた異なるコンピュータで動いているプロセス同士でも通信することが可能です。
			</div><div
            class="para">
				典型的な Unix 系システムでは、さまざまなレベルでこれらのメカニズムを使っており、かなり標準的な手法になっています。
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.libraries"></a>B.5.4. ライブラリ</h3></div></div></div><a
            id="id-1.21.8.8.2"
            class="indexterm"></a><div
            class="para">
				関数ライブラリは Unix 系オペレーティングシステムで重要な役割を果たします。関数ライブラリは厳密な意味のプログラムではありません。なぜなら、関数ライブラリ自体は実行できず、標準的なプログラムで使用されるコードの断片に過ぎないからです。よく使われるライブラリの中でも特に以下のものが有名です。
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						標準 C ライブラリ (<span
                    class="emphasis"><em>glibc</em></span>)。これにはファイルやネットワーク接続を開く関数やカーネルとの通信を容易にする関数などの基本的な関数が含まれます。
					</div></li><li
                class="listitem"><div
                  class="para">
						Gtk+ と Qt などのグラフィカルツールキット。これを使うことで、多くのプログラムはツールキットの提供するグラフィカルオブジェクトを再利用することが可能です。
					</div></li><li
                class="listitem"><div
                  class="para">
						<span
                    class="emphasis"><em>libpng</em></span> ライブラリ。これを使うことで、PNG フォーマットイメージを読み込み、編集、保存することが可能になります。
					</div></li></ul></div><div
            class="para">
				これらのライブラリのおかげで、アプリケーションは既存のコードを再利用することが可能です。多くのアプリケーションは同じ関数を再利用できるため、アプリケーションの開発は単純化されます。また、通常それぞれのライブラリは別の人によって開発されているため、アプリケーションの大域的な開発は Unix の歴史的哲学に近いものになります。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CULTURE</em></span> Unix 流、一度に一つのことをせよ</strong></p></div></div></div><div
              class="para">
				Unix 系オペレーティングシステムの根底にある基本的概念の一つとして、それぞれのツールがたった 1 つのことを担当し、それをうまくこなす、というものがあります。そしてアプリケーションはこれらのツールを再利用して、より高度な論理を作り上げることが可能です。この根本原理はさまざまな形で具現化されています。シェルスクリプトは最良の例かもしれません。具体的に言えば、シェルスクリプトは極めて簡単なツール (たとえば <code
                class="command">grep</code>、<code
                class="command">wc</code>、<code
                class="command">sort</code>、<code
                class="command">uniq</code> など) を複雑に並べたものです。コードライブラリも基本的概念を具現化したものとみなすことが可能です。すなわち <span
                class="emphasis"><em>libpng</em></span> ライブラリを使うことで、さまざまなオプションとさまざまな方法を使って、PNG イメージの読み込みと書き込みを行うことが可能です。しかし、<span
                class="emphasis"><em>libpng</em></span> ライブラリはそれ以上のことを行いません。従って、イメージを表示したり編集する関数は全く含まれません。
			</div></div><div
            class="para">
				さらに、これらのライブラリは「共有ライブラリ」とも呼ばれています。なぜなら、複数のプロセスが同じライブラリを同時に使う場合、カーネルはライブラルの読み込みを 1 回だけで済ませることが可能だからです。プロセスが使うライブラリのコードを何度も読み込むような逆の (仮想的な) 状況に比べて、これはメモリを節約することになります。
			</div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-role-and-tasks.html"><strong>戻る</strong>B.4. カーネルが担当している一部の操作</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上に戻る</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>ホーム</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="backcover.html"><strong>次へ</strong>付録 C Debian 管理者ハンドブック</a></li></ul></body></html>
