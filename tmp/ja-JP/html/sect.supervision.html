<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">14.3. 監督、防止、検出、監査</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ja-JP-1.0-1" /><meta
        name="keywords"
        content="ファイアウォール, Netfilter, IDS/NIDS" /><link
        rel="home"
        href="index.html"
        title="Debian 管理者ハンドブック" /><link
        rel="up"
        href="security.html"
        title="第 14 章 セキュリティ" /><link
        rel="prev"
        href="sect.firewall-packet-filtering.html"
        title="14.2. ファイアウォールとパケットフィルタリング" /><link
        rel="next"
        href="sect.apparmor.html"
        title="14.4. AppArmor の紹介" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/ja-JP/stable/sect.supervision.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>戻る</strong></a></li><li
          class="home">Debian 管理者ハンドブック</li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>次へ</strong></a></li></ul><div
        class="section"><div
          class="titlepage"><div><div><h2
                class="title"><a
                  xmlns=""
                  id="sect.supervision"></a>14.3. 監督、防止、検出、監査</h2></div></div></div><a
          id="id-1.17.6.2"
          class="indexterm"></a><div
          class="para">
			監視はいくつかの理由によっていかなるセキュリティポリシーにおいても不可欠な要素になっています。最たる理由はセキュリティの目標には通常データの機密性を保証するだけでなく、サービスの可用性を保証することも含まれているという理由です。そのため、すべてが想定通りに稼働しているかを確認したり、さまざまな逸脱した挙動や提供しているサービス品質の変化をタイミング良く検出したりすることが不可欠です。監視活動のおかげで、危機的状況に陥る前に不正侵入の試行を検出し迅速に対応することが可能です。この節では、Debian システムのさまざまな側面を監視するために使えるいくつかのツールを概説します。この節は<a
            class="xref"
            href="sect.monitoring.html">第 12.4 節「監視」</a>を補完する節です。
		</div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.logcheck"></a>14.3.1. <code
                    class="command">logcheck</code> を使ったログ監視</h3></div></div></div><a
            id="id-1.17.6.4.2"
            class="indexterm"></a><a
            id="id-1.17.6.4.3"
            class="indexterm"></a><a
            id="id-1.17.6.4.4"
            class="indexterm"></a><div
            class="para">
				<code
              class="command">logcheck</code> プログラムはデフォルトでは毎時間ログファイルを監視します。<code
              class="command">logcheck</code> は不審なログメッセージを電子メールで管理者に送信し、さらなる解析を促します。
			</div><div
            class="para">
				監視対象ファイルのリストは <code
              class="filename">/etc/logcheck/logcheck.logfiles</code> に保存されています。<code
              class="filename">/etc/rsyslog.conf</code> ファイルが完全に書き換えられていない限り、デフォルト値でうまく動作します。
			</div><div
            class="para">
				<code
              class="command">logcheck</code> の動作モードには 3 種類あり、そのうちの 1 つを選びます。具体的に言えば、<span
              class="emphasis"><em>paranoid</em></span>、<span
              class="emphasis"><em>server</em></span>、<span
              class="emphasis"><em>workstation</em></span> から 1 つ選びます。<span
              class="emphasis"><em>paranoid</em></span> モードは<span
              class="emphasis"><em>とても</em></span>詳細で、<span
              class="emphasis"><em>paranoid</em></span> モードを使うのはファイアウォールなどの特定のサーバに限定するべきです。<span
              class="emphasis"><em>server</em></span> モードはデフォルトで、多くのサーバでは <span
              class="emphasis"><em>server</em></span> モードを使うことを推奨します。<span
              class="emphasis"><em>workstation</em></span> モードはワークステーション用に設計されており、かなり簡潔です (より多くのメッセージを除外します)。
			</div><div
            class="para">
				どの動作モードを選んだ場合でも、管理者は毎時間のバッチ処理のたびに長くてつまらない電子メールを受け取ることを本当に望むのでなければ、<code
              class="command">logcheck</code> を (インストール済みサービスに基づき) カスタマイズしていくつかの余分なメッセージを除外するべきです。メッセージ選択ルールはかなり複雑なので、もし挑戦するなら <code
              class="filename">/usr/share/doc/logcheck-database/README.logcheck-database.gz</code> を読むと良いでしょう。
			</div><div
            class="para">
				メッセージに対して適用されるルールは以下に示す種類に分類されます。
			</div><div
            xmlns:d="http://docbook.org/ns/docbook"
            class="itemizedlist"><ul><li
                class="listitem"><div
                  class="para">
						クラッキングの試行として分類するメッセージのルール (<code
                    class="filename">/etc/logcheck/cracking.d/</code> ディレクトリ内のファイルに保存します)。
					</div></li><li
                class="listitem"><div
                  class="para">
						クラッキングの試行として分類されたメッセージの分類を解除するメッセージのルール (<code
                    class="filename">/etc/logcheck/cracking.ignore.d/</code> ディレクトリ内のファイルに保存します)。
					</div></li><li
                class="listitem"><div
                  class="para">
						セキュリティ警告として分類するメッセージのルール (<code
                    class="filename">/etc/logcheck/violations.d/</code> ディレクトリ内のファイルに保存します)。
					</div></li><li
                class="listitem"><div
                  class="para">
						セキュリティ警告として分類されたメッセージの分類を解除するメッセージのルール (<code
                    class="filename">/etc/logcheck/violations.ignore.d/</code> ディレクトリ内のファイルに保存します)。
					</div></li><li
                class="listitem"><div
                  class="para">
						その他のメッセージに適用するルール (<span
                    class="emphasis"><em>システムイベント</em></span>として分類されます)。
					</div></li></ul></div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CAUTION</em></span> メッセージの無視</strong></p></div></div></div><div
              class="para">
				<code
                class="filename">/etc/logcheck/violations.d/myfile</code> ファイルに保存されているルールに基づいてクラッキング試行やセキュリティ警告として分類されたメッセージの分類を解除するには、<code
                class="filename">/etc/logcheck/violations.ignore.d/myfile</code> または <code
                class="filename">/etc/logcheck/violations.ignore.d/myfile-<em
                  class="replaceable">extension</em></code> ファイルを使います。
			</div></div><div
            class="para">
				<code
              class="filename">/etc/logcheck/ignore.d.{paranoid,server,workstation}/</code> ディレクトリ内のルールの 1 つによってシステムイベントが無視されなかった場合を除いて、常にシステムイベントは通知されます。もちろん、ここで考慮されるディレクトリは選択された動作モードの冗長性レベル以上の冗長性レベルに対応するディレクトリです。
			</div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.monitoring-activity"></a>14.3.2. 監視活動</h3></div></div></div><a
            id="id-1.17.6.5.2"
            class="indexterm"></a><a
            id="id-1.17.6.5.3"
            class="indexterm"></a><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.real-time-monitoring"></a>14.3.2.1. リアルタイム監視</h4></div></div></div><div
              class="para">
					<code
                class="command">top</code> は現在実行中のプロセスのリストを表示する対話型ツールです。デフォルトでは現在のプロセッサ使用量に基づいてソートされ、<span
                class="keycap"><strong>P</strong></span> キーを押すことで内容を更新することが可能です。他のソート基準として、専有メモリ量 (<span
                class="keycap"><strong>M</strong></span> キー)、総プロセッサ時間 (<span
                class="keycap"><strong>T</strong></span> キー)、プロセス ID (<span
                class="keycap"><strong>N</strong></span> キー) などがあります。<span
                class="keycap"><strong>k</strong></span> キーに続けてプロセス ID を入力することで、識別子に対応するプロセスを殺すことが可能です。<span
                class="keycap"><strong>r</strong></span> キーを使ってプロセスの <span
                class="emphasis"><em>renicing</em></span> を行うことが可能です、つまり優先度を変更することが可能です。
				</div><a
              id="id-1.17.6.5.4.3"
              class="indexterm"></a><div
              class="para">
					システムの負荷が高過ぎる場合、<code
                class="command">top</code> はプロセッサ時間を奪っていたりメモリを大量に消費しているプロセスを調査する素晴らしいツールになります。特に、リソースを消費しているプロセスがそのマシンでホストされる本物のサービスにふさわしいものであるか否かを確認することは興味深い作業と言えます。www-data ユーザとして実行されている不明なプロセスは特に警戒して調査するべきです。なぜなら、その不明なプロセスはウェブアプリケーションの脆弱性を利用してシステムにインストールおよび実行されたソフトウェアのインスタンスかもしれないからです。
				</div><div
              class="para">
					<code
                class="command">top</code> はとても柔軟性の高いツールで、<code
                class="command">top</code> のマニュアルページでは表示をカスタマイズする方法とそのカスタマイズの結果を個人的なニーズや習慣に反映させる方法が詳細に説明されています。
				</div><div
              class="para">
					<code
                class="command">gnome-system-monitor</code> グラフィカルツールは <code
                class="command">top</code> とよく似ており、大ざっぱに言って <code
                class="command">top</code> と同じ機能を備えています。
				</div><a
              id="id-1.17.6.5.4.7"
              class="indexterm"></a></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.monitoring-history"></a>14.3.2.2. 履歴</h4></div></div></div><a
              id="id-1.17.6.5.5.2"
              class="indexterm"></a><div
              class="para">
					プロセッサの負荷、ネットワークトラフィック、空きディスク領域などの情報は絶えず変化します。これらの情報の経時変化を保存しておけば、コンピュータの使われ方を明らかにする際に役立ちます。
				</div><a
              id="id-1.17.6.5.5.4"
              class="indexterm"></a><a
              id="id-1.17.6.5.5.5"
              class="indexterm"></a><div
              class="para">
					時間変化する情報の保存には専用のツールがたくさんあります。多くのツールは、この種の情報を一元管理するために、SNMP (<span
                class="emphasis"><em>Simple Network Management Protocol</em></span>) を介してデータを取得します。SNMP を使うことで、汎用的なコンピュータを除くネットワーク要素 (たとえば専用ネットワークルータやスイッチ) からデータを取得することが可能になるという恩恵があります。
				</div><div
              class="para">
					本書では、<a
                class="xref"
                href="advanced-administration.html">第 12 章: 「<em>高度な管理</em>」</a>の中で Munin が詳細に取り上げられています (<a
                class="xref"
                href="sect.monitoring.html#sect.munin">第 12.4.1 節「Munin のセットアップ」</a>を参照してください)。さらに Debian には類似のツールである <span
                class="pkg pkg">cacti</span> が含まれます。cacti の配備は Munin よりも少し複雑です。なぜなら cacti は SNMP だけに基づいているからです。cacti にはウェブインターフェースが用意されていますが、設定に必要な概念を理解するには少し努力が必要です。事前に HTML 文書 (<code
                class="filename">/usr/share/doc/cacti/html/index.html</code>) を読んでおくことを推奨します。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> <code
                          class="command">mrtg</code></strong></p></div></div></div><a
                id="id-1.17.6.5.5.8.2"
                class="indexterm"></a><div
                class="para">
					<code
                  class="command">mrtg</code> (同名のパッケージに含まれます) は古いツールです。荒削りな面もありますが、<code
                  class="command">mrtg</code> は時系列データを集計し、これをグラフとして表示することが可能です。<code
                  class="command">mrtg</code> は最も一般的に監視されるデータ (たとえばプロセッサの負荷、ネットワークトラフィック、ウェブページのヒットなどの情報) を収集する多数の専用スクリプトを備えています。
				</div><div
                class="para">
					<span
                  class="pkg pkg">mrtg-contrib</span> と <span
                  class="pkg pkg">mrtgutils</span> パッケージには、直接使うことができるスクリプトの例が含まれます。
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="id-1.17.6.6"></a>14.3.3. 変更検出</h3></div></div></div><div
            class="para">
				システムのインストールと設定が完了したら、セキュリティアップグレードを行わない限りデータ以外のほとんどのファイルとディレクトリが変化する理由はありません。このため、ファイルが変化していないことを確認することは興味深いです。すなわち、ファイルに対する予想外の変化は調査に値します。この節では、ファイルに対する予想外の変化に備えて、ファイルを監視して管理者に警告する (または単純に変更をリストする) いくつかのツールを紹介します。
			</div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.dpkg-verify"></a>14.3.3.1. <code
                      class="command">dpkg --verify</code> を使ったパッケージ監視</h4></div></div></div><a
              id="id-1.17.6.6.3.2"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> Debian 並びにソフトウェア開発元に対する攻撃から手元のシステムを守る</strong></p></div></div></div><div
                class="para">
					Debian パッケージの提供するファイルに対する変化を検出する場合には <code
                  class="command">dpkg --verify</code> は役に立ちますが、たとえば Debian アーカイブミラーが不正アクセスを受けたことによりパッケージ自体が不正に改竄された場合には <code
                  class="command">dpkg --verify</code> は役に立ちません。この種の攻撃に対抗するには、APT のデジタル署名照合システムを使い (<a
                  class="xref"
                  href="sect.package-authentication.html">第 6.5 節「パッケージ信頼性の確認」</a>を参照してください)、認証された発行元からのパッケージだけをインストールするように気を付けることが必要です。
				</div></div><div
              class="para">
					<code
                class="command">dpkg --verify</code> (または <code
                class="command">dpkg -V</code>) は興味深いツールで、(潜在的には攻撃者によって) 変更を加えられたインストール済みファイルを見つけることが可能です。しかしながら、<code
                class="command">dpkg --verify</code> の結果は疑ってかかるべきです。なぜなら <code
                class="command">dpkg --verify</code> は変更されたファイルを検出するために dpkg 自身のデータベースに保存されたチェックサムを使っており、このデータベースはハードディスク上 (<code
                class="filename">/var/lib/dpkg/info/<em
                  class="replaceable">package</em>.md5sums</code>) に保存されているからです。このため、完璧主義の攻撃者なら改竄したファイルに対応する新しいチェックサムを使ってデータベースファイルを更新するでしょう。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BACK TO BASICS</em></span> ファイルの指紋</strong></p></div></div></div><a
                id="id-1.17.6.6.3.5.2"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.3"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.4"
                class="indexterm"></a><a
                id="id-1.17.6.6.3.5.5"
                class="indexterm"></a><div
                class="para">
					備忘録的になりますが、ここで指紋とはファイルの内容に対するある種の署名を含む値です (通常は 16 進数で表記された数です)。この署名はあるアルゴリズムを使って計算されます。指紋計算に使われるアルゴリズムはファイルに対して行われた小さな変化により指紋が変化することがおおよそ保証されているアルゴリズムです (MD5 や SHA1 がよく知られているアルゴリズムです)。そしてこの特徴は「アバランシェ効果」として知られています。アバランシェ効果のおかげで、簡単な数字で表される指紋がファイルの内容の変化を検出するためのリトマス試験として機能することになります。指紋計算に使われるアルゴリズムは不可逆です。言い換えれば、ほとんどの指紋計算アルゴリズムに対して指紋からその指紋が得られる内容を発見することは不可能であることが知られています。最近の数学的な進歩により、アルゴリズムの原理の絶対性が揺らいでいるように見えます。しかしこれはアルゴリズムを使うことに対して疑問を投げかけるものではありません。なぜなら、同じ指紋を持つ異なる内容を作成することはまだかなり難しい作業だからです。
				</div></div><div
              class="para">
					<code
                class="command">dpkg -V</code> を実行すると、すべてのインストール済みパッケージが検証され、テストに失敗したファイルが行ごとに表示されます。出力フォーマットは <code
                class="command">rpm -V</code> が採用しているフォーマットと同じで、行頭の各文字は特定のメタデータに対するテストの結果を意味しています。残念なことに <code
                class="command">dpkg</code> は多くのテストに必要なメタデータを保存しません。これらのメタデータを必要とするテストの結果は常に疑問符が出力されることになります。今のところ実行できるテストはチェックサムテストだけで、チェックサムテストに失敗した場合、左から 3 番目の文字が「5」になります。
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>dpkg -V</code></strong>
<code
                class="computeroutput">??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</code></pre><div
              class="para">
					上の例では、dpkg は Debian パッケージから提供された SSH の service ファイルが直接編集されていることを報告しています。一般に管理者は Debian パッケージから提供された設定ファイル以外のファイルを直接編集するべきではありません。今回の場合ならば、もう一度 <code
                class="filename">/etc/systemd/system/ssh.service</code> を作成し、これを編集するべきです (このファイルは一般に設定変更を配置すべき場所である <code
                class="filename">/etc</code> ディレクトリの下に配置されます)。さらに、dpkg は設定ファイルとみなされた複数のファイルが修正されていることを報告しています (この場合、左から 2 番目のフィールドが「c」という文字になります)。設定ファイルに対する修正は合法的と言えます。
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="sect.debsums"></a>14.3.3.2. パッケージの監査、<code
                      class="command">debsums</code> とその限界</h4></div></div></div><a
              id="id-1.17.6.6.4.2"
              class="indexterm"></a><div
              class="para">
					<code
                class="command">debsums</code> は <code
                class="command">dpkg -V</code> の祖先です。このため、<code
                class="command">debsums</code> はほとんど使われていません。<code
                class="command">debsums</code> と dpkg は同じ制限に悩まされています。幸いなことに、<code
                class="command">debsums</code> はいくつかの制限を回避することが可能です (一方で dpkg には同様の回避策がありません)。
				</div><div
              class="para">
					ディスク上のデータは信頼できないため、<code
                class="command">debsums</code> は dpkg データベースではなく <code
                class="filename">.deb</code> ファイルに基づいてテストを行う機能を提供しています。すべてのインストール済みパッケージに対応する信頼できる <code
                class="filename">.deb</code> ファイルをダウンロードするには、APT の認証付きダウンロード機構を使います。この操作は遅くて退屈ですから、この操作を定期的かつ積極的に使う手法として考えるべきではありません。
				</div><pre
              class="screen">
<code
                class="computeroutput"># </code><strong
                class="userinput"><code>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</code></strong>
<code
                class="computeroutput">[ ... ]
# </code><strong
                class="userinput"><code>debsums -p /var/cache/apt/archives --generate=all</code></strong></pre><div
              class="para">
					この例の中で、デフォルトではインストールされない <span
                class="pkg pkg">dctrl-tools</span> パッケージに含まれる <code
                class="command">grep-status</code> コマンドが使われている点に注意してください。
				</div></div><div
            class="section"><div
              class="titlepage"><div><div><h4
                    class="title"><a
                      xmlns=""
                      id="id-1.17.6.6.5"></a>14.3.3.3. ファイル監視、AIDE</h4></div></div></div><a
              id="id-1.17.6.6.5.2"
              class="indexterm"></a><div
              class="para">
					AIDE ツール (<span
                class="emphasis"><em>Advanced Intrusion Detection Environment</em></span>、<span
                class="pkg pkg">aide</span> パッケージに含まれます) を使うことで、ファイルの完全性を確認したり、事前に保存された正当なシステムのイメージに対する変更を検出したりすることが可能です。このイメージはシステムのすべてのファイルに対して関連する情報 (指紋、パーミッション、タイムスタンプなど) を記録するデータベース (<code
                class="filename">/var/lib/aide/aide.db</code>) に保存されます。このデータベースは最初に <code
                class="command">aideinit</code> を使って初期化されます。そして毎日、関係のある情報が何も変更されていないことを確認するために、このデータベースは <code
                class="filename">/etc/cron.daily/aide</code> スクリプトから使われます。変更が検出されたら、AIDE は変更内容をログファイル (<code
                class="filename">/var/log/aide/*.log</code>) に記録し、検出された変更内容を管理者にメールで送信します。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>IN PRACTICE</em></span> データベースの保護</strong></p></div></div></div><div
                class="para">
					AIDE はファイルの状態を比較するためにローカルデータベースを使います。結果の信頼性は直接的にデータベースの信頼性と結び付いています。攻撃者が不正アクセスされたシステムの root 権限を取得した場合、攻撃者はデータベースを置き換えて自分の行動の形跡を隠すことが可能です。可能な次善策は参照データを読み込み専用のストレージメディアに保存することです。
				</div></div><div
              class="para">
					<code
                class="filename">/etc/default/aide</code> に含まれる多くのオプションを使って <span
                class="pkg pkg">aide</span> パッケージの挙動を微調整します。AIDE 設定は <code
                class="filename">/etc/aide/aide.conf</code> と <code
                class="filename">/etc/aide/aide.conf.d/</code> に保存されています (実質的に言えば、これらのファイルは <code
                class="command">update-aide.conf</code> が <code
                class="filename">/var/lib/aide/aide.conf.autogenerated</code> を生成するためだけに使われます)。設定は確認する必要のあるファイルの属性の種類を指定します。たとえば、ログファアイルの内容は定期的に変わりますが、この種の変更はファイルのパーミッションが同じなら無視することが可能です。しかし、実行プログラムの内容とパーミッションの両方は必ず同じでなければいけません。設定の構文は、とても複雑というわけではありませんが、十分に直感的というわけでもありません。<span
                class="citerefentry"><span
                  class="refentrytitle">aide.conf</span>(5)</span> マニュアルページを読むことを推奨します。
				</div><div
              class="para">
					データベースの新しいバージョンは毎日生成され、<code
                class="filename">/var/lib/aide/aide.db.new</code> に保存されます。そして、すべての記録された変更が正当ならば、参照データベースを新しいデータベースに置き換えることが可能です。
				</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> Tripwire と Samhain</strong></p></div></div></div><div
                class="para">
					Tripwire は AIDE とよく似ており、Tripwire の設定ファイルの構文も AIDE の設定ファイルの構文とほとんど同じです。AIDE に対する <span
                  class="pkg pkg">tripwire</span> の主な追加点は <span
                  class="pkg pkg">tripwire</span> には設定ファイルを署名するメカニズムが追加されている点です。設定ファイルを署名することで、参照データベースの示す先を異なるバージョンに差し替えることが不可能になります。
				</div><div
                class="para">
					Samhain も類似の機能を提供しますが、Samhain は rootkit の検出に役立ついくつかの機能を備えています (補注<a
                  class="xref"
                  href="sect.supervision.html#sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages">「<span
                    class="emphasis"><em>QUICK LOOK</em></span> <span
                    class="pkg pkg">checksecurity</span> と <span
                    class="pkg pkg">chkrootkit</span>/<span
                    class="pkg pkg">rkhunter</span> パッケージ」</a>を参照してください)。Samhain はネットワークを使って広範囲に配備され、中央サーバ上に履歴を (署名と一緒に) 記録することが可能です。
				</div></div><div
              class="sidebar"><a
                xmlns=""
                id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages"></a><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>QUICK LOOK</em></span> <span
                          class="pkg pkg">checksecurity</span> と <span
                          class="pkg pkg">chkrootkit</span>/<span
                          class="pkg pkg">rkhunter</span> パッケージ</strong></p></div></div></div><a
                id="id-1.17.6.6.5.8.2"
                class="indexterm"></a><div
                class="para">
					<span
                  class="pkg pkg">checksecurity</span> パッケージには、システムの基本的な確認項目 (空のパスワード、新しい setuid ファイルなど) について確認を行い、必要ならば管理者に警告するための、複数の小さなスクリプトが含まれます。checksecurity という明快な名前にも関わらず、管理者が Linux システムが安全であることを保証するためには checksecurity だけでは不十分です。
				</div><div
                class="para">
					<span
                  class="pkg pkg">chkrootkit</span> と <span
                  class="pkg pkg">rkhunter</span> パッケージを使うことで、システムに潜在的にインストールされた <span
                  class="emphasis"><em>rootkit</em></span> を探し出すことが可能です。備忘録的になりますが、<span
                  class="emphasis"><em>rootkit</em></span> はシステムの不正侵入を隠すために設計されたソフトウェアで、マシンをこっそりと操作できる状態にし続けます。<span
                  class="pkg pkg">chkrootkit</span> と <span
                  class="pkg pkg">rkhunter</span> パッケージを使ったテストは 100% 信頼できるものではありませんが、管理者はテストにより潜在的な問題に対して注意を払うようになります。
				</div></div></div></div><div
          class="section"><div
            class="titlepage"><div><div><h3
                  class="title"><a
                    xmlns=""
                    id="sect.intrusion-detection"></a>14.3.4. 侵入検知 (IDS/NIDS)</h3></div></div></div><a
            id="id-1.17.6.7.2"
            class="indexterm"></a><a
            id="id-1.17.6.7.3"
            class="indexterm"></a><a
            id="id-1.17.6.7.4"
            class="indexterm"></a><a
            id="id-1.17.6.7.5"
            class="indexterm"></a><a
            id="id-1.17.6.7.6"
            class="indexterm"></a><a
            id="id-1.17.6.7.7"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>BACK TO BASICS</em></span> サービス妨害</strong></p></div></div></div><a
              id="id-1.17.6.7.8.2"
              class="indexterm"></a><div
              class="para">
				「サービス妨害」攻撃の目的は 1 つしかありません。すなわち、サービスを使用不能にすることです。「サービス妨害」攻撃は問い合わせを使ってサーバに大きな負荷を加えたり、バグを不正に活用したりすることで実行されますが、どんな方法で実行されても最終結果は同じです。すなわち、サービスがもはや使用できなくなります。正規のユーザは迷惑しますし、標的にされたネットワークサービスをホストしている事業者の評価が落ちます (たとえばサービスが電子商取引サイトの場合、収入も落ちます)。
			</div><div
              class="para">
				「サービス妨害」攻撃はしばしば「分散」されることがあります。通常の「分散」された攻撃は数多くの異なる送信元から数多くの問い合わせを送信することにより、サーバに負荷を加えます。こうすることで、サーバは正規の問い合わせに応答できなくなります。この種の攻撃には、よく知られている頭字語が与えられています。具体的に言えば、<acronym
                class="acronym">DDoS</acronym> と <acronym
                class="acronym">DoS</acronym> です (サービス妨害攻撃が分散型か否かで区別します)。
			</div></div><div
            class="para">
				<code
              class="command">suricata</code> (同名の Debian パッケージに含まれます) は NIDS すなわち<span
              class="emphasis"><em>ネットワーク型侵入検知システム</em></span>です。NIDS の機能はネットワークをリッスンして侵入試行および敵対行為 (サービス妨害攻撃も含まれます) を検出しようとします。すべてのイベントは <code
              class="filename">/var/log/suricata</code> 内の複数のファイルに記録されます。収集されたすべてのデータを閲覧するためのサードパーティツール (Kibana/logstash) が存在します。<div
              xmlns=""
              class="url">→ <a
                xmlns="http://www.w3.org/1999/xhtml"
                href="http://suricata-ids.org">http://suricata-ids.org</a></div><div
              xmlns=""
              class="url">→ <a
                xmlns="http://www.w3.org/1999/xhtml"
                href="https://www.elastic.co/products/kibana">https://www.elastic.co/products/kibana</a></div>
			</div><a
            id="id-1.17.6.7.10"
            class="indexterm"></a><a
            id="id-1.17.6.7.11"
            class="indexterm"></a><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>CAUTION</em></span> 動作範囲</strong></p></div></div></div><div
              class="para">
				<code
                class="command">suricata</code> の有効性は監視対象のネットワークインターフェース上を流れるトラフィックによって制限されます。<code
                class="command">suricata</code> が真のトラフィックを観察することができない場合、当然ながら <code
                class="command">suricata</code> は何も検出しません。<code
                class="command">suricata</code> が実行されているマシンをネットワークスイッチに接続した場合、<code
                class="command">suricata</code> が実行されているマシンを対象にした攻撃だけを検出することが可能です。この挙動は意図するものではないかもしれません。このため <code
                class="command">suricata</code> が実行されているマシンはネットワークスイッチの「ミラー」ポートに接続されるべきです。通常「ミラー」ポートはスイッチをカスケード接続するために使われるため、すべてのトラフィックを取得することが可能です。
			</div></div><div
            class="para">
				suricata を設定するには <code
              class="filename">/etc/suricata/suricata-debian.yaml</code> をよく読んで編集します。それぞれのパラメータはこのファイルの中で詳細に説明されているため、このファイルはとても長いものです。最低限の設定を行うには、<code
              class="literal">HOME_NET</code> パラメータでローカルネットワークのカバーするアドレス範囲を指定する必要があります。実際のところ <code
              class="literal">HOME_NET</code> パラメータは潜在的に攻撃される可能性を持つすべてのネットワークを意味しています。しかし設定パラメータのほとんどを理解するには、パラメータの説明をすべて読み、パラメータをそれぞれの状況に適応させることが必要です。
			</div><div
            class="para">
				加えて、監視対象のネットワークインターフェースを定義して init スクリプトを有効化する (<code
              class="literal">RUN=yes</code> と設定する) ために、<code
              class="filename">/etc/default/suricata</code> を編集するべきです。また、管理者は <code
              class="literal">LISTENMODE=pcap</code> のように設定したいと思うかもしれません。なぜなら、デフォルト設定である <code
              class="literal">LISTENMODE=nfqueue</code> を適切に動かすためには、さらに設定を行う必要があるからです (netfilter ファイアウォールの <code
              class="literal">NFQUEUE</code> 動作を使って suricata が取り扱う一部のユーザ空間キュー宛のパケットを通過するように、ファイアウォールを設定しなければいけません)。
			</div><div
            class="para">
				不正行為を検出するためには、<code
              class="command">suricata</code> に一連の監視規則を設定する必要があります。いくつかの監視規則は <span
              class="pkg pkg">snort-rules-default</span> パッケージに含まれています。<code
              class="command">snort</code> は IDS エコシステムにおける歴史的な基準ソフトウェアで、<code
              class="command">suricata</code> は <code
              class="command">snort</code> 向けに書かれた監視規則を再利用することが可能です。残念なことに <span
              class="pkg pkg">snort-rules-default</span> パッケージは <span
              class="distribution distribution">Debian Jessie</span> には含まれません。このため、<span
              class="pkg pkg">snort-rules-default</span> パッケージを入手するには<span
              class="distribution distribution">テスト版</span>か<span
              class="distribution distribution">不安定版</span>などの他の Debian リリースを使ってください。
			</div><div
            class="para">
				代案として、<code
              class="command">oinkmaster</code> (同名のパッケージに含まれます) を使って外部ソースから Snort の監視規則をダウンロードすることも可能です。
			</div><div
            class="sidebar"><div
              class="titlepage"><div><div><p
                    class="title"><strong><span
                        class="emphasis"><em>GOING FURTHER</em></span> <code
                        class="command">prelude</code> との統合</strong></p></div></div></div><div
              class="para">
				prelude を使うことでセキュリティ情報の中央集中型監視が可能になります。prelude のモジュール式設計には、サーバ (<span
                class="pkg pkg">prelude-manager</span> に含まれる<span
                class="emphasis"><em>マネージャ</em></span>) が含まれ、サーバはさまざまな種類の<span
                class="emphasis"><em>センサー</em></span>によって生成された警告を収集します。
			</div><div
              class="para">
				Suricata を prelude のセンサーとして設定することが可能です。他の可能性には <span
                class="emphasis"><em>prelude-lml</em></span> (<span
                class="emphasis"><em>Log Monitor Lackey</em></span>) があります。これは (<a
                class="xref"
                href="sect.supervision.html#sect.logcheck">第 14.3.1 節「<code
                  class="command">logcheck</code> を使ったログ監視」</a>で説明されている <code
                class="command">logcheck</code> と同様のやり方で) ログファイルを監視します。
			</div><a
              id="id-1.17.6.7.17.4"
              class="indexterm"></a></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.firewall-packet-filtering.html"><strong>戻る</strong>14.2. ファイアウォールとパケットフィルタリング</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上に戻る</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>ホーム</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.apparmor.html"><strong>次へ</strong>14.4. AppArmor の紹介</a></li></ul></body></html>
