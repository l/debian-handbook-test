<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
    xmlns="http://www.w3.org/1999/xhtml"><head><meta
        http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /><title
        xmlns:d="http://docbook.org/ns/docbook">第 9 章 Unix サービス</title><link
        rel="stylesheet"
        type="text/css"
        href="Common_Content/css/default.css" /><link
        rel="stylesheet"
        media="print"
        href="Common_Content/css/print.css"
        type="text/css" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="generator"
        content="publican v4.3.2" /><meta
        xmlns:d="http://docbook.org/ns/docbook"
        name="package"
        content="Debian-debian-handbook-8-ja-JP-1.0-1" /><meta
        name="keywords"
        content="システム起動, 初期化スクリプト, SSH, Telnet, 権限, パーミッション, 管理, inetd, cron, バックアップ, ホットプラグ, PCMCIA, APM, ACPI" /><link
        rel="home"
        href="index.html"
        title="Debian 管理者ハンドブック" /><link
        rel="up"
        href="index.html"
        title="Debian 管理者ハンドブック" /><link
        rel="prev"
        href="sect.kernel-installation.html"
        title="8.11. カーネルのインストール" /><link
        rel="next"
        href="sect.remote-login.html"
        title="9.2. リモートログイン" /><meta
        xmlns=""
        name="flattr:id"
        content="4pz9jq" /><link
        xmlns=""
        rel="canonical"
        href="https://debian-handbook.info/browse/ja-JP/stable/unix-services.html" /></head><body><div
        id="banner"><a
          href="http://debian-handbook.info/get/"><span
            class="text">Download the ebook</span></a></div><p
        id="title"><a
          class="left"
          href="http://www.debian.org"><img
            alt="Product Site"
            src="Common_Content/images//image_left.png" /></a><a
          class="right"
          href="index.html"><img
            alt="Documentation Site"
            src="Common_Content/images//image_right.png" /></a></p><ul
        class="docnav top"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>戻る</strong></a></li><li
          class="home">Debian 管理者ハンドブック</li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>次へ</strong></a></li></ul><div
        xml:lang="ja-JP"
        class="chapter"
        lang="ja-JP"><div
          class="titlepage"><div><div><h1
                class="title"><a
                  xmlns=""
                  id="unix-services"></a>第 9 章 Unix サービス</h1></div></div></div><div
          class="toc"><dl
            class="toc"><dt><span
                class="section"><a
                  href="unix-services.html#sect.system-boot">9.1. システム起動</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="unix-services.html#sect.systemd">9.1.1. systemd init システム</a></span></dt><dt><span
                    class="section"><a
                      href="unix-services.html#sect.sysvinit">9.1.2. System V init システム</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.remote-login.html">9.2. リモートログイン</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.ssh">9.2.1. 安全なリモートログイン、SSH</a></span></dt><dt><span
                    class="section"><a
                      href="sect.remote-login.html#sect.remote-desktops">9.2.2. リモートグラフィカルデスクトップの利用</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.rights-management.html">9.3. 権限の管理</a></span></dt><dt><span
                class="section"><a
                  href="sect.administration-interfaces.html">9.4. 管理インターフェース</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.webmin">9.4.1. ウェブインターフェースを使った管理、<code
                        class="command">webmin</code></a></span></dt><dt><span
                    class="section"><a
                      href="sect.administration-interfaces.html#sect.debconf">9.4.2. パッケージの設定、<code
                        class="command">debconf</code></a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.syslog.html">9.5. <code
                    class="command">syslog</code> システムイベント</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-principe">9.5.1. 原理とメカニズム</a></span></dt><dt><span
                    class="section"><a
                      href="sect.syslog.html#sect.syslog-config">9.5.2. 設定ファイル</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.inetd.html">9.6. <code
                    class="command">inetd</code> スーパーサーバ</a></span></dt><dt><span
                class="section"><a
                  href="sect.task-scheduling-cron-atd.html">9.7. <code
                    class="command">cron</code> と <code
                    class="command">atd</code> を使ったスケジューリングタスク</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.format-crontab">9.7.1. <code
                        class="filename">crontab</code> ファイルの書式</a></span></dt><dt><span
                    class="section"><a
                      href="sect.task-scheduling-cron-atd.html#sect.at-command">9.7.2. <code
                        class="command">at</code> コマンドの利用</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.asynchronous-task-scheduling-anacron.html">9.8. 非同期タスクのスケジューリング、<code
                    class="command">anacron</code></a></span></dt><dt><span
                class="section"><a
                  href="sect.quotas.html">9.9. クォータ</a></span></dt><dt><span
                class="section"><a
                  href="sect.backup.html">9.10. バックアップ</a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.11">9.10.1. <code
                        class="command">rsync</code> を使ったバックアップ</a></span></dt><dt><span
                    class="section"><a
                      href="sect.backup.html#id-1.12.13.12">9.10.2. バックアップなしのマシンの復元</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.hotplug.html">9.11. ホットプラグ機能、<span
                    class="emphasis"><em>hotplug</em></span></a></span></dt><dd><dl><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.2">9.11.1. 前書き</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.3">9.11.2. 命名問題</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.4">9.11.3. <span
                        class="emphasis"><em>udev</em></span> の動作原理</a></span></dt><dt><span
                    class="section"><a
                      href="sect.hotplug.html#id-1.12.14.5">9.11.4. 具体例</a></span></dt></dl></dd><dt><span
                class="section"><a
                  href="sect.power-management.html">9.12. 電源管理、Advanced Configuration and Power Interface (ACPI)</a></span></dt></dl></div><div
          class="highlights"><div
            class="para">
		この章では、多くの Unix システムに共通する数多くの基本的なサービスをカバーします。すべての管理者はこれらの基本的なサービスに精通しているべきです。
	</div></div><div
          class="section"><div
            class="titlepage"><div><div><h2
                  class="title"><a
                    xmlns=""
                    id="sect.system-boot"></a>9.1. システム起動</h2></div></div></div><a
            id="id-1.12.4.2"
            class="indexterm"></a><div
            class="para">
			コンピュータを起動する際、コンソール画面にスクロールされる多くのメッセージには、実行されている多くの自動初期化と自動設定に関する情報が表示されます。この段階の挙動を少し変えたいと思うことがあるかもしれません。これは起動処理をよく理解する必要があることを意味しています。この節の目的は起動処理をよく理解することにあります。
		</div><div
            class="para">
			最初に BIOS がコンピュータを制御し、ディスクを検出し、<span
              class="emphasis"><em>マスターブートレコード</em></span>を読み込み、ブートローダを実行します。以降、ブートローダが引き継ぎ、ディスクからカーネルを見つけ、カーネルを読み込んで実行します。そして、カーネルが初期化され、ルートファイルシステムを含むパーティションの検索とマウントを開始し、最後に最初のプログラムである <code
              class="command">init</code> を実行します。「ルートパーティション」と <code
              class="command">init</code> は RAM の中にだけ存在する仮想ファイルシステム (これは現在「initramfs」と呼ばれていますが、以前は「初期化 RAM ディスク」という意味で「initrd」と呼ばれていました) 上に置かれていることが多いです。多くの場合、initramfs はハードドライブのファイルかネットワークから、ブートローダによってメモリに読み込まれます。initramfs には、カーネルが「真の」ルートファイルシステムを読み込むために必要な最低限の要素が含まれています。具体的に言えば、ハードドライブやそれなしではシステムが起動できないその他のデバイスのドライバモジュール、より頻繁にあるのが、RAID アレイを組み立て、暗号化されたパーティションを開き、LVM ボリュームを有効化するなどの初期化スクリプトとモジュールが含まれています。一度ルートパーティションがマウントされたら、initramfs は制御を真の init に渡し、マシンは標準的な起動処理に戻ります。
		</div><div
            class="figure"><a
              xmlns=""
              id="figure.boot-process-systemd"></a><div
              class="figure-contents"><div
                class="mediaobject"><img
                  src="images/startup-systemd.png"
                  alt="systemd を使う Linux の動くコンピュータの起動シーケンス" /></div></div><p
              class="title"><strong>図 9.1 systemd を使う Linux の動くコンピュータの起動シーケンス</strong></p></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.systemd"></a>9.1.1. systemd init システム</h3></div></div></div><div
              class="para">
				「init の実体」は現在 <span
                class="pkg pkg">systemd</span> によって提供されています。この節ではこの init システムに関して説明します。
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>CULTURE</em></span> <code
                          class="command">systemd</code> 以前</strong></p></div></div></div><div
                class="para">
				<code
                  class="command">systemd</code> は比較的最近の「init システム」で、既に <span
                  class="distribution distribution">Wheezy</span> ではある程度利用できましたが、Debian <span
                  class="distribution distribution">Jessie</span> からデフォルトに採用されました。以前のリリースはデフォルトで「System V init」(<span
                  class="pkg pkg">sysv-rc</span> パッケージに含まれます) を採用していました。System V init はより伝統的なシステムです。System V init については後で説明します。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>ALTERNATIVE</em></span> 他の起動システム</strong></p></div></div></div><div
                class="para">
				本書は Debian <span
                  class="distribution distribution">Jessie</span> のデフォルト起動システム (<span
                  class="pkg pkg">systemd</span> パッケージによる実装) および以前のデフォルト起動システム <span
                  class="pkg pkg">sysvinit</span> について説明します。<span
                  class="pkg pkg">sysvinit</span> は <span
                  class="emphasis"><em>System V</em></span> Unix システムから派生し受け継がれたものです。また、他の起動システムも存在します。
			</div><div
                class="para">
				<span
                  class="pkg pkg">file-rc</span> は極めて単純なやり方を使う起動システムです。<span
                  class="pkg pkg">file-rc</span> はランレベルの原則を守りますが、ディレクトリとシンボリックリンクを設定ファイルで置換します。この設定ファイルを使って <code
                  class="command">init</code> に対して起動するプロセスとその起動順を伝えます。
			</div><div
                class="para">
				Debian 上の <code
                  class="command">upstart</code> システムはまだ完全にテストされていません。<code
                  class="command">upstart</code> はイベントに基づく起動システムです。すなわち init スクリプトはもはや逐次的順序でなく、スクリプトの完了などのイベントに応じてそのスクリプトに依存していた別のスクリプトが起動されます。Ubuntu の始めた <code
                  class="command">upstart</code> システムは Debian <span
                  class="distribution distribution">Jessie</span> に含まれますが、デフォルトではありません。実際のところ、<code
                  class="command">upstart</code> は <span
                  class="pkg pkg">sysvinit</span> の代替として始まり、<code
                  class="command">upstart</code> の起動するタスクの 1 つが <span
                  class="pkg pkg">sysv-rc</span> パッケージの提供する伝統的なシステム向けに書かれたスクリプトを起動するようになっています。
			</div><div
                class="para">
				他の起動システムや他の動作モードも存在します。たとえば <code
                  class="command">runit</code> や <code
                  class="command">minit</code> などです。しかしこれらは比較的特殊で広く使われていません。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SPECIFIC CASE</em></span> ネットワークからの起動</strong></p></div></div></div><div
                class="para">
				一部の設定では、BIOS が MBR を実行しないように設定され、その代わり MBR に相当するものをネットワークから探すように設定されているかもしれません。こうすることで、ハードドライブなしでコンピュータを組み立てたり、起動するたびに完全に再インストールすることが可能になります。このオプションは、すべてのハードウェアで利用できるというわけではありませんし、通常 BIOS とネットワークカードの適切な組み合わせが必要です。
			</div><div
                class="para">
				ネットワークからの起動は <code
                  class="command">debian-installer</code> や FAI (<a
                  class="xref"
                  href="installation.html#sect.installation-methods">第 4.1 節「インストール方法」</a>を参照してください) を起動するために使われます。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BACK TO BASICS</em></span> プロセス、プログラムインスタンス</strong></p></div></div></div><a
                id="id-1.12.4.6.6.2"
                class="indexterm"></a><div
                class="para">
				プロセスとは実行中のプログラムのメモリ内表現です。プロセスにはソフトウェアを適切に実行するために必要なすべての情報が含まれます (これにはソフトウェアのコードだけでなく、ソフトウェアが所有するメモリ内のデータ、ソフトウェアが開いたファイルのリスト、ソフトウェアが確立したネットワーク接続などが含まれます)。単独のプログラムが複数のプロセスを生成するかもしれませんし、ユーザはこの単独のプログラムを複数実行することも可能です。
			</div></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>SECURITY</em></span> <code
                          class="command">init</code> にシェルを実行させて root 権限を獲得する</strong></p></div></div></div><div
                class="para">
				慣例によれば、起動される最初のプロセスは <code
                  class="command">init</code> プログラムです (これはデフォルトで <code
                  class="filename">/lib/systemd/systemd</code> へのシンボリックリンクです)。しかしながら、カーネルに <code
                  class="literal">init</code> オプションを渡して別のプログラムを開始することも可能です。
			</div><a
                id="id-1.12.4.6.7.3"
                class="indexterm"></a><div
                class="para">
				コンピュータに触ることができる人は誰でも <span
                  class="keycap"><strong>Reset</strong></span> ボタンを押してコンピュータを再起動することが可能です。そして、ブートローダプロンプトでカーネルに <code
                  class="literal">init=/bin/sh</code> オプションを渡せば、管理者パスワードを知らなくても root 権限を取得できます。
			</div><div
                class="para">
				これを避けるため、パスワードでブートローダを保護することが可能です。さらに BIOS へのアクセスも保護したいと考えるかもしれません (BIOS に対するパスワード保護機能はほぼ必ず付いています)。BIOS に対するパスワード保護機能がなければ、悪意ある侵入者が自分の Linux システムを含むリムーバブルメディアからマシンを起動して、コンピュータのハードドライブのデータにアクセスするかもしれません。
			</div><div
                class="para">
				最後に、多くの BIOS では汎用的なパスワードが使えるという点に注意してください。当初、汎用パスワードはパスワードを忘れた人向けのトラブルシューティングを意図していましたが、今や汎用パスワードは公開されインターネットから入手できます (ご自分の手で、検索エンジンで「generic BIOS passwords」を検索してみてください)。前述した保護機能を使えば、マシンへの不正アクセスを完全に防ぐことはできないにせよ、それを遅らせることは可能でしょう。しかしながら、攻撃者が物理的にコンピュータにアクセスできる場合、確実にコンピュータを保護する方法は存在しません。すなわち、攻撃者は対象のコンピュータからハードドライブを取り外してそれを自分の制御下にあるコンピュータに接続したり、マシン本体ごと盗んだり、パスワードをリセットするために BIOS メモリを消去することも可能ということです。…
			</div></div><div
              class="para">
				Systemd はシステムの設定を担当している複数のプロセスを実行します。具体的に言えば、キーボード、ドライバ、ファイルシステム、ネットワーク、サービスなどの要素が設定されます。Systemd はシステム全体におよぶ包括的視点と各要素の要求条件を満足させながらプロセスを実行します。各要素は「ユニットファイル」によって定義されています (「ユニットファイル」以外のファイルが必要な場合もあります)。ユニットファイルの一般的な構文は広く使われている「*.ini ファイル」の構文から派生したもので、<code
                class="literal">[<em
                  class="replaceable">section</em>]</code> ヘッダでグループ化された <code
                class="literal"><em
                  class="replaceable">key</em> = <em
                  class="replaceable">value</em></code> ペアを使います。ユニットファイルは <code
                class="filename">/lib/systemd/system/</code> と <code
                class="filename">/etc/systemd/system/</code> の下に保存されます。ユニットファイルにはいくつかの形式がありますが、ここでは「service」型と「target」型に注目します。
			</div><div
              class="para">
				systemd の「service ファイル」は systemd が管理するプロセスを設定するファイルです。「service ファイル」には大ざっぱに言って古いスタイルの init スクリプトと同じ情報が含まれていますが、宣言的な方法 (そしてより簡潔な方法) を使ってその情報が記述されています。systemd は大半の繰り返しタスク (プロセスの開始と停止、状態確認、ログ記録、特権の取り消しなど) を処理しますので、service ファイルに記入する情報は対象プロセスに特有の情報だけで十分です。たとえば以下は SSH 用の service ファイルです。
			</div><pre
              class="programlisting">[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</pre><div
              class="para">
				ご覧の通り、コードはとても少なく宣言だけで構成されています。systemd は作業進行状況を表示したり、プロセスを監視したり、必要な時にプロセスを再起動することを担当します。
			</div><div
              class="para">
				systemd の「target ファイル」はシステムの状態を記述するファイルで、管理者はこのファイルを使って利用できる状態にされていなければならないサービス群を指定します。「target ファイル」は昔ながらのランレベルに相当するものとして考えることが可能です。target ファイルの 1 つに <code
                class="literal">local-fs.target</code> があります。<code
                class="literal">local-fs.target</code> で定義された状態に到達した場合、残りのシステムはすべてのローカルファイルシステムがマウントされアクセスできるようになっている状態を仮定することが可能です。また別の target ファイルに <code
                class="literal">network-online.target</code> と <code
                class="literal">sound.target</code> があります。ある target ファイルの依存関係は対象の target ファイルの中 (<code
                class="literal">Requires=</code> 行) に依存関係にある service ファイルを記述するか、対象の <code
                class="literal">/lib/systemd/system/<em
                  class="replaceable">targetname</em>.target.wants/</code> ディレクトリの中に依存関係にある service ファイルを指すシンボリックリンクを作ることで指定します。たとえば、<code
                class="filename">/etc/systemd/system/printer.target.wants/</code> には <code
                class="filename">/lib/systemd/system/cups.service</code> へのリンクが含まれます。そしてこのため systemd は <code
                class="literal">printer.target</code> を処理する前に CUPS が実行されていることを保証するでしょう。
			</div><div
              class="para">
				ユニットファイルは宣言型の設定ファイルでありスクリプトやプログラムではないため、ユニットファイルを直接実行することは不可能で、ユニットファイルは systemd によってのみ解釈されます。いくつかのユーティリティを使うことで、管理者は systemd と情報をやり取りして、システムおよびシステム部品の状態を制御することが可能です。
			</div><div
              class="para">
				systemd と情報をやり取りする 1 番目のユーティリティとして <code
                class="command">systemctl</code> が挙げられます。<code
                class="command">systemctl</code> を引数なしで実行した場合、systemd が把握しているすべてのユニットファイル (無効化されているものを除きます) およびその状態が表示されます。<code
                class="command">systemctl status</code> を使うことで、サービスおよび関連するプロセスをよりわかりやすく表示することが可能です。サービスの名前を指定した場合 (<code
                class="command">systemctl status ntp.service</code> のように指定した場合)、<code
                class="command">systemctl</code> はさらに詳しい情報および指定したサービスに関連するログの最後の数行を表示します (後から詳しく説明します)。
			</div><div
              class="para">
				手作業でサービスを開始するのは簡単で、<code
                class="command">systemctl start <em
                  class="replaceable">servicename</em>.service</code> を実行するだけです。予想通り、サービスを停止するには <code
                class="command">systemctl stop <em
                  class="replaceable">servicename</em>.service</code> を使います。また、他のサブコマンドには <code
                class="command">reload</code> と <code
                class="command">restart</code> があります。
			</div><div
              class="para">
				サービスを有効化するには (たとえば起動時に自動的にサービスを開始するには)、<code
                class="command">systemctl enable <em
                  class="replaceable">servicename</em>.service</code> を使います (無効化するには <code
                class="command">disable</code> を使います)。<code
                class="command">is-enabled</code> を使えば、サービスの状態を確認することが可能です。
			</div><div
              class="para">
				systemd が備える興味深い機能として、<code
                class="command">journald</code> と名付けられたログ記録機能が挙げられます。<code
                class="command">journald</code> は <code
                class="command">syslogd</code> などのより伝統的なログ記録システムを補完するために誕生しましたが、サービスとサービスが生成したメッセージを正しく関連付けたり初期化シーケンスが生成するエラーメッセージを保存する能力などの興味深い機能を追加しています。<code
                class="command">journalctl</code> コマンドの助けを少し借りるだけで、メッセージを後から表示することが可能になります。引数なしで実行した場合、<code
                class="command">journalctl</code> は起動後に発生したすべてのログメッセージを表示しますが、引数を与えずに実行することはほとんどないでしょう。ほとんどの場合、以下のようにサービス識別子を与えて <code
                class="command">journalctl</code> を実行します。
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at 火 2015-03-31 17:08:49 JST, end at 水 2015-04-01 00:06:02 JST. --
 3月 31 17:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
 3月 31 17:08:55 mirtuel sshd[430]: Server listening on :: port 22.
 3月 31 17:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
 3月 31 17:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
 3月 31 17:09:00 mirtuel sshd[430]: Server listening on :: port 22.
 3月 31 17:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
 3月 31 17:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</code></pre><div
              class="para">
				その他の役に立つコマンドラインオプションとして <code
                class="command">-f</code> が挙げられます。これを使った場合、<code
                class="command">journalctl</code> は新しいメッセージを受け取ったらそのメッセージを表示し続けます (これは <code
                class="command">tail -f <em
                  class="replaceable">file</em></code> とほぼ同じやり方です)。
			</div><div
              class="para">
				サービスが期待通りに動いていないように見える場合、問題解決に向けて手始めに <code
                class="command">systemctl status</code> を実行し、今現在サービスが動いているか否かを確認します。サービスが実行されておらず、<code
                class="command">systemctl status</code> の表示したメッセージが問題の原因を解明するのに十分でない場合、journald が収集したサービスに関連するログを確認します。たとえば、SSH サービスが動いていないと仮定すると、以下の手順で状況を確認します。
			</div><pre
              class="screen"><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since 水 2015-04-01 00:30:36 JST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

 4月  1 00:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
 4月  1 00:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>journalctl -u ssh.service
</code></strong><code
                class="computeroutput">-- Logs begin at 水 2015-04-01 00:29:27 JST, end at 水 2015-04-01 00:30:36 JST. --
 4月  1 00:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
 4月  1 00:29:27 mirtuel sshd[424]: Server listening on :: port 22.
 4月  1 00:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
 4月  1 00:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
 4月  1 00:29:29 mirtuel sshd[424]: Server listening on :: port 22.
 4月  1 00:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
 4月  1 00:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
 4月  1 00:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
 4月  1 00:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </code><strong
                class="userinput"><code>vi /etc/ssh/sshd_config
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl start ssh.service
</code></strong><code
                class="computeroutput"># </code><strong
                class="userinput"><code>systemctl status ssh.service
</code></strong><code
                class="computeroutput">● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since 水 2015-04-01 00:31:09 JST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </code></pre><div
              class="para">
				ここでは SSH サービスの状態が失敗状態であることを確認した後、ログの確認作業に進みました。その結果、ログは設定ファイル内にエラーがあることを示しています。そこで設定ファイルを編集してエラーを修正した後、SSH サービスを再起動し、SSH サービスが本当に動いていることを確認しました。
			</div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>GOING FURTHER</em></span> ユニットファイルの他の型</strong></p></div></div></div><div
                class="para">
				この節では、systemd の最も基本的な機能だけを説明しました。systemd は他にも多くの興味深い機能を備えていますが、ここでは一部だけを紹介します。
			</div><div
                xmlns:d="http://docbook.org/ns/docbook"
                class="itemizedlist"><ul><li
                    class="listitem"><div
                      class="para">
						ソケットの活性化。「socket」型のユニットファイルを使えば、systemd が管理するネットワークや Unix ソケットを表現することが可能です。これは systemd がソケットを作成し、実際のサービスは実際の接続要求を受信した時に要求に応じて開始されることを意味しています。この機能は大ざっぱに言って <code
                        class="command">inetd</code> の機能群を再現するものです。詳しくは <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.socket</span>(5)</span> を参照してください。
					</div></li><li
                    class="listitem"><div
                      class="para">
						タイマ。「timer」型のユニットファイルを使えば、固定周期および特定時刻に発動するイベントを表現することが可能です。さらにサービスをタイマに関連付けた場合、タイマが発動するたびにサービスに対応するタスクを実行します。これを使うことで、<code
                        class="command">cron</code> 機能の一部を置き換えることが可能です。詳しくは <span
                        class="citerefentry"><span
                          class="refentrytitle">systemd.timer</span>(5)</span> を参照してください。
					</div></li><li
                    class="listitem"><div
                      class="para">
						ネットワーク。「network」型のユニットファイルを使えば、ネットワークインターフェースを表現することが可能です。これを使うことで、ネットワークインターフェースを設定したり、サービスが特定のネットワークインターフェースの状態に依存することを表現することが可能です。
					</div></li></ul></div></div></div><div
            class="section"><div
              class="titlepage"><div><div><h3
                    class="title"><a
                      xmlns=""
                      id="sect.sysvinit"></a>9.1.2. System V init システム</h3></div></div></div><div
              class="para">
				System V init システム (これを短縮して init と呼びます) は <code
                class="filename">/etc/inittab</code> ファイルの指示に従って複数のプロセスを実行します。実行される最初のプログラム (<span
                class="emphasis"><em>sysinit</em></span> 段階に相当します) は <code
                class="command">/etc/init.d/rcS</code> で、これは <code
                class="filename">/etc/rcS.d/</code> ディレクトリに含まれるすべてのプログラムを起動するスクリプトです。<a
                id="id-1.12.4.7.2.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.2.6"
                class="indexterm"></a><a
                id="id-1.12.4.7.2.7"
                class="indexterm"></a><a
                id="id-1.12.4.7.2.8"
                class="indexterm"></a>
			</div><div
              class="para">
				<code
                class="filename">/etc/rcS.d/</code> ディレクトリに含まれるスクリプトは特に以下の点を担当します。
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						コンソールキーボードの設定。
					</div></li><li
                  class="listitem"><div
                    class="para">
						ドライバの読み込み。ほとんどのカーネルモジュールはハードウェアを検出した時にカーネル自身によって読み込まれます。追加のドライバはそれに対応するモジュールが <code
                      class="filename">/etc/modules</code> にリストされている場合に読み込まれます。
					</div></li><li
                  class="listitem"><div
                    class="para">
						ファイルシステムの整合性確認。
					</div></li><li
                  class="listitem"><div
                    class="para">
						ローカルパーティションのマウント。
					</div></li><li
                  class="listitem"><div
                    class="para">
						ネットワークの設定。
					</div></li><li
                  class="listitem"><div
                    class="para">
						ネットワークファイルシステム (NFS) のマウント。
					</div></li></ul></div><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>BACK TO BASICS</em></span> カーネルモジュールとオプション</strong></p></div></div></div><a
                id="id-1.12.4.7.5.2"
                class="indexterm"></a><div
                class="para">
				カーネルモジュールにオプションを指定するには、<code
                  class="filename">/etc/modprobe.d/</code> にファイルを追加してください。カーネルモジュールのオプションは <code
                  class="literal">options <em
                    class="replaceable">module-name</em> <em
                    class="replaceable">option-name</em>=<em
                    class="replaceable">option-value</em></code> のような指示文を使って定義します。場合によっては、いくつかのオプションは単独の指示文で指定することも可能です。
			</div><div
                class="para">
				<code
                  class="filename">/etc/modprobe.d/</code> 内の設定ファイルは <code
                  class="command">modprobe</code> によって使われます。すなわち <code
                  class="command">modprobe</code> が依存関係に従ってカーネルモジュールを読み込みます (モジュールは他のモジュールを呼ぶことができます)。<code
                  class="command">modprobe</code> は <span
                  class="pkg pkg">kmod</span> パッケージに含まれています。
			</div><a
                id="id-1.12.4.7.5.5"
                class="indexterm"></a><a
                id="id-1.12.4.7.5.6"
                class="indexterm"></a></div><div
              class="para">
				<code
                class="command">/etc/init.d/rcS</code> の完了後、<code
                class="command">init</code> が起動処理を引き継いで、デフォルトランレベル (通常ランレベル 2) で有効化されたプログラムを起動します。<code
                class="command">init</code> は <code
                class="command">/etc/init.d/rc 2</code> を実行します。これは <code
                class="filename">/etc/rc2.d/</code> に置かれて「S」で始まる名前のすべてのサービスを開始するコマンドです。歴史的なことを言えば、「S」の後に続く 2 桁の数字は起動するサービスの順番を定義するために使われていました。しかし現在では、デフォルトの起動システムは <code
                class="command">insserv</code> を使ってスクリプト同士の依存関係に従った起動順を自動的に決定します。このため、各起動スクリプトはサービスを起動または終了させる時に満足しなければいけない条件を宣言します (たとえば、あるサービスは他のサービスの前または後に起動しなければいけないなどの条件を宣言します)。そして、<code
                class="command">init</code> は条件を満足するようにサービスを起動します。このため、スクリプトの静的な番号付けはもはや考慮されません (しかしスクリプトの名前は必ず「S」で始まり、その後ろに 2 桁の番号と条件を宣言する際に使われる実際のスクリプトの名前を付けなければいけません)。一般に、基盤サービス (ログ記録を担当している <code
                class="command">rsyslog</code> やポート割り当てを担当している <code
                class="command">portmap</code>) が最初に起動され、その後に標準的なサービスとグラフィカルインターフェース (<code
                class="command">gdm3</code>) が起動されます。
			</div><div
              class="para">
				この依存関係に基づく起動システムのおかげで、起動順を自動的に再定義することが可能になります。これは手作業でやるにはちょっと退屈な作業で、人的ミスの危険性があります。なぜなら、起動順は宣言された依存関係に従って定義されるからです。他の長所として、他のサービスに依存しないサービスは並列して開始できるという点があります。このことにより、起動処理を加速できます。
			</div><a
              id="id-1.12.4.7.8"
              class="indexterm"></a><a
              id="id-1.12.4.7.9"
              class="indexterm"></a><div
              class="para">
				<code
                class="command">init</code> はランレベルを見分けて処理を分岐させます。ランレベルを切り替えるには <code
                class="command">telinit <em
                  class="replaceable">new-level</em></code> コマンドを使います。このコマンドを実行すると <code
                class="command">init</code> は即座に新しいランレベルを引数にして <code
                class="command">/etc/init.d/rc</code> を再実行します。<code
                class="command">/etc/init.d/rc</code> は欠けているサービスを開始し、既に不要となったサービスを停止します。これを行うために、<code
                class="command">/etc/init.d/rc</code> は <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> ディレクトリの内容を参照します (ここで <em
                class="replaceable">X</em> は新しいランレベルです)。このディレクトリに含まれる (「Start」の)「S」で始まるスクリプトは開始されるサービスで、(「Kill」の)「K」で始まるスクリプトは停止されるサービスです。<code
                class="command">/etc/init.d/rc</code> は切り替え前のランレベルで既に起動されているサービスは開始しません。
			</div><div
              class="para">
				デフォルトで、Debian の System V init は 4 種類のランレベルを使います。
			</div><div
              xmlns:d="http://docbook.org/ns/docbook"
              class="itemizedlist"><ul><li
                  class="listitem"><div
                    class="para">
						レベル 0。これはコンピュータの電源を切る際に一時的に使われるだけです。このため「K」スクリプトしか含まれません。
					</div></li><li
                  class="listitem"><div
                    class="para">
						レベル 1。これはシングルユーザモードとしても知られ、システムの機能抑制モードに相当します。このモードは基本的なサービスだけを提供し、一般ユーザがマシンを利用していないメンテナンスの際に使われることを意図しています.
					</div></li><li
                  class="listitem"><div
                    class="para">
						レベル 2。これは通常動作用のモードで、ネットワークサービス、グラフィカルインターフェース、ユーザログインなどの機能を使うことが可能です。
					</div></li><li
                  class="listitem"><div
                    class="para">
						レベル 6。これはレベル 0 と似ていますが、再起動前のシャットダウン段階中に使われる点が異なります。
					</div></li></ul></div><div
              class="para">
				その他のレベル。レベル 3 からレベル 5 までも存在します。デフォルトでこれらのランレベルはレベル 2 と同様に動作しますが、管理者はこれらのレベルを特定の要求に順応させるためのレベルに書き換えることが可能です (ランレベルに対応する <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> ディレクトリにスクリプトを追加したりおよび削除したりする必要があります)。
			</div><div
              class="figure"><a
                xmlns=""
                id="figure.boot-process-sysvinit"></a><div
                class="figure-contents"><div
                  class="mediaobject"><img
                    src="images/startup-sysvinit.png"
                    alt="System V init を使う Linux の動くコンピュータの起動シーケンス" /></div></div><p
                class="title"><strong>図 9.2 System V init を使う Linux の動くコンピュータの起動シーケンス</strong></p></div><a
              id="id-1.12.4.7.15"
              class="indexterm"></a><div
              class="para">
				各 <code
                class="filename">/etc/rc<em
                  class="replaceable">X</em>.d</code> ディレクトリに含まれるすべてのスクリプトは <code
                class="filename">/etc/init.d/</code> に格納されたスクリプトの実体を指すシンボリックリンクに過ぎません (シンボリックリンクはパッケージのインストール時に <code
                class="command">update-rc.d</code> プログラムによって作られます)。各ランレベルで利用できるサービスを微調整するには、管理者が調整パラメータを与えて <code
                class="command">update-rc.d</code> を再実行する必要があります。<code
                class="command">update-rc.d</code> の構文は <span
                class="citerefentry"><span
                  class="refentrytitle">update-rc.d</span>(1)</span> マニュアルページに詳しく説明されています。サービスを無効化したい場合に (<code
                class="literal">remove</code> パラメータを与えて) すべてのシンボリックリンクを削除するのは悪い方法であるという点に注意してください。<code
                class="literal">remove</code> パラメータを使う代わりに、単純に希望するランレベルでそのサービスを起動しないよう <code
                class="literal">disable</code> を使って設定するべきです (同時に、万が一切り替え前のランレベルで対象のサービスが実行されている場合に備えて、切り替え後のランレベルでサービスを停止するために必要なシンボリックリンクを確保しておくべきです)。<code
                class="command">update-rc.d</code> は複雑なインターフェースを持っているため、<code
                class="command">rcconf</code> (<span
                class="pkg pkg">rcconf</span> パッケージに含まれます) を使いたいと思うかもしれません。<code
                class="command">rcconf</code> はユーザにとってさらに使い勝手の良いインターフェースを提供します。
			</div><a
              id="id-1.12.4.7.17"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>DEBIAN POLICY</em></span> サービスの再起動</strong></p></div></div></div><a
                id="id-1.12.4.7.18.2"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.3"
                class="indexterm"></a><a
                id="id-1.12.4.7.18.4"
                class="indexterm"></a><div
                class="para">
				Debian パッケージのメンテナスクリプトはサービスを確実に利用できるようにしたりサービスに特定のオプションを考慮させるためにそのサービスを再起動することがあります。サービスを操作するコマンドである <code
                  class="command">service <em
                    class="replaceable">service</em> <em
                    class="replaceable">operation</em></code> はランレベルを考慮しません。このコマンドはサービスが現在使用中であると (間違って) 仮定し、間違った操作 (故意に停止されたサービスの開始や既に停止されたサービスの停止など) を開始するかもしれません。このため Debian は <code
                  class="command">invoke-rc.d</code> プログラムを導入しました。すなわち、メンテナスクリプト内でサービス初期化スクリプトを実行する場合は、必ず <code
                  class="command">invoke-rc.d</code> プログラムを使わなければいけません。<code
                  class="command">invoke-rc.d</code> プログラムは必要なコマンドだけを実行します。通常の使い方と異なり、ディレクトリではなくプログラム名に <code
                  class="filename">.d</code> サフィックスが使われている点に注意してください。
			</div></div><div
              class="para">
				最後に、<code
                class="command">init</code> はさまざまな仮想コンソール用の制御プログラム (<code
                class="command">getty</code>) を開始します。<code
                class="command">getty</code> はプロンプトを表示し、ユーザ名の入力を待ち、セッションを開始するために <code
                class="command">login <em
                  class="replaceable">user</em></code> を実行します。
			</div><a
              id="id-1.12.4.7.20"
              class="indexterm"></a><div
              class="sidebar"><div
                class="titlepage"><div><div><p
                      class="title"><strong><span
                          class="emphasis"><em>VOCABULARY</em></span> コンソールと端末</strong></p></div></div></div><div
                class="para">
				草創期のコンピュータは通常複数のとても大きな部品に分かれていました。すなわち、ストレージ収納装置と中央処理装置はそれらを操作するオペレータが使う周辺装置から離れた場所にありました。オペレータが使う周辺装置は分離された周辺装置「コンソール」の部分でした。現在「コンソール」という用語は意味を変えて残されています。「コンソール」はキーボードと画面を備える「端末」とほぼ同義語になっています。
			</div><div
                class="para">
				コンピュータの開発とともに、オペレーティングシステムは、たとえもしマシンに 1 台のキーボードと画面しか接続されていなかったとしても、複数の独立したセッションを同時に処理する目的で複数の仮想コンソールを提供するようになりました。多くの GNU/Linux システムでは (テキストモード時に)、<span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F1</strong></span> から <span
                  class="keycap"><strong>Control</strong></span>+<span
                  class="keycap"><strong>Alt</strong></span>+<span
                  class="keycap"><strong>F6</strong></span> までのキーの組み合わせを入力することで 6 つの仮想コンソールを切り替えられます。
			</div><div
                class="para">
				転じて、「コンソール」と「端末」という用語はグラフィカル X11 セッションで使われる端末エミュレータ (<code
                  class="command">xterm</code>、<code
                  class="command">gnome-terminal</code>、<code
                  class="command">konsole</code> など) でも使われています。
			</div></div></div></div></div><ul
        class="docnav"><li
          class="previous"><a
            accesskey="p"
            href="sect.kernel-installation.html"><strong>戻る</strong>8.11. カーネルのインストール</a></li><li
          class="up"><a
            accesskey="u"
            href="#"><strong>上に戻る</strong></a></li><li
          class="home"><a
            accesskey="h"
            href="index.html"><strong>ホーム</strong></a></li><li
          class="next"><a
            accesskey="n"
            href="sect.remote-login.html"><strong>次へ</strong>9.2. リモートログイン</a></li></ul></body></html>
