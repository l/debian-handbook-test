<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="unix-services">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-unix-services.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>システム起動</keyword>
      <keyword>初期化スクリプト</keyword>
      <keyword>SSH</keyword>
      <keyword>Telnet</keyword>
      <keyword>権限</keyword>
      <keyword>パーミッション</keyword>
      <keyword>管理</keyword>
      <keyword>inetd</keyword>
      <keyword>cron</keyword>
      <keyword>バックアップ</keyword>
      <keyword>ホットプラグ</keyword>
      <keyword>PCMCIA</keyword>
      <keyword>APM</keyword>
      <keyword>ACPI</keyword>
    </keywordset>
  </chapterinfo>
  <title>Unix サービス</title>
  <highlights>
    <para>この章では、多くの Unix システムに共通する数多くの基本的なサービスをカバーします。すべての管理者はこれらの基本的なサービスに精通しているべきです。</para>
  </highlights>
  <section id="sect.system-boot">
    <title>システム起動</title>
    <indexterm><primary>起動</primary><secondary>システムの起動</secondary></indexterm>

    <para>コンピュータを起動する際、コンソール画面にスクロールされる多くのメッセージには、実行されている多くの自動初期化と自動設定に関する情報が表示されます。この段階の挙動を少し変えたいと思うことがあるかもしれません。これは起動処理をよく理解する必要があることを意味しています。この節の目的は起動処理をよく理解することにあります。</para>

    
    <para>最初に BIOS がコンピュータを制御し、ディスクを検出し、<emphasis>マスターブートレコード</emphasis>を読み込み、ブートローダを実行します。以降、ブートローダが引き継ぎ、ディスクからカーネルを見つけ、カーネルを読み込んで実行します。そして、カーネルが初期化され、ルートファイルシステムを含むパーティションの検索とマウントを開始し、最後に最初のプログラムである <command>init</command> を実行します。「ルートパーティション」と <command>init</command> は RAM の中にだけ存在する仮想ファイルシステム (これは現在「initramfs」と呼ばれていますが、以前は「初期化 RAM ディスク」という意味で「initrd」と呼ばれていました) 上に置かれていることが多いです。多くの場合、initramfs はハードドライブのファイルかネットワークから、ブートローダによってメモリに読み込まれます。initramfs には、カーネルが「真の」ルートファイルシステムを読み込むために必要な最低限の要素が含まれています。具体的に言えば、ハードドライブやそれなしではシステムが起動できないその他のデバイスのドライバモジュール、より頻繁にあるのが、RAID アレイを組み立て、暗号化されたパーティションを開き、LVM ボリュームを有効化するなどの初期化スクリプトとモジュールが含まれています。一度ルートパーティションがマウントされたら、initramfs は制御を真の init に渡し、マシンは標準的な起動処理に戻ります。</para>

    <figure id="figure.boot-process-systemd">
      <title>systemd を使う Linux の動くコンピュータの起動シーケンス</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/startup-systemd.png" scalefit="1" width="80%" />
        </imageobject>
      </mediaobject>
    </figure>

    <section id="sect.systemd"><title>systemd init システム</title>

    <para>「init の実体」は現在 <emphasis role="pkg">systemd</emphasis> によって提供されています。この節ではこの init システムに関して説明します。</para>

    <sidebar>
      <title><emphasis>CULTURE</emphasis> <command>systemd</command> 以前</title>

      <para><command>systemd</command> は比較的最近の「init システム」で、既に <emphasis role="distribution">Wheezy</emphasis> ではある程度利用できましたが、Debian <emphasis role="distribution">Jessie</emphasis> からデフォルトに採用されました。以前のリリースはデフォルトで「System V init」(<emphasis role="pkg">sysv-rc</emphasis> パッケージに含まれます) を採用していました。System V init はより伝統的なシステムです。System V init については後で説明します。</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> 他の起動システム</title>

      <para>本書は Debian <emphasis role="distribution">Jessie</emphasis> のデフォルト起動システム (<emphasis role="pkg">systemd</emphasis> パッケージによる実装) および以前のデフォルト起動システム <emphasis role="pkg">sysvinit</emphasis> について説明します。<emphasis role="pkg">sysvinit</emphasis> は <emphasis>System V</emphasis> Unix システムから派生し受け継がれたものです。また、他の起動システムも存在します。</para>

      <para><emphasis role="pkg">file-rc</emphasis> は極めて単純なやり方を使う起動システムです。<emphasis role="pkg">file-rc</emphasis> はランレベルの原則を守りますが、ディレクトリとシンボリックリンクを設定ファイルで置換します。この設定ファイルを使って <command>init</command> に対して起動するプロセスとその起動順を伝えます。</para>

      <para>Debian 上の <command>upstart</command> システムはまだ完全にテストされていません。<command>upstart</command> はイベントに基づく起動システムです。すなわち init スクリプトはもはや逐次的順序でなく、スクリプトの完了などのイベントに応じてそのスクリプトに依存していた別のスクリプトが起動されます。Ubuntu の始めた <command>upstart</command> システムは Debian <emphasis role="distribution">Jessie</emphasis> に含まれますが、デフォルトではありません。実際のところ、<command>upstart</command> は <emphasis role="pkg">sysvinit</emphasis> の代替として始まり、<command>upstart</command> の起動するタスクの 1 つが <emphasis role="pkg">sysv-rc</emphasis> パッケージの提供する伝統的なシステム向けに書かれたスクリプトを起動するようになっています。</para>

      <para>他の起動システムや他の動作モードも存在します。たとえば <command>runit</command> や <command>minit</command> などです。しかしこれらは比較的特殊で広く使われていません。</para>
    </sidebar>

    <sidebar>
      <title><emphasis>SPECIFIC CASE</emphasis> ネットワークからの起動</title>

      <para>一部の設定では、BIOS が MBR を実行しないように設定され、その代わり MBR に相当するものをネットワークから探すように設定されているかもしれません。こうすることで、ハードドライブなしでコンピュータを組み立てたり、起動するたびに完全に再インストールすることが可能になります。このオプションは、すべてのハードウェアで利用できるというわけではありませんし、通常 BIOS とネットワークカードの適切な組み合わせが必要です。</para>

      <para>ネットワークからの起動は <command>debian-installer</command> や FAI (<xref linkend="sect.installation-methods" />を参照してください) を起動するために使われます。</para>
    </sidebar>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> プロセス、プログラムインスタンス</title>
      <indexterm><primary>プロセス</primary></indexterm>

      <para>プロセスとは実行中のプログラムのメモリ内表現です。プロセスにはソフトウェアを適切に実行するために必要なすべての情報が含まれます (これにはソフトウェアのコードだけでなく、ソフトウェアが所有するメモリ内のデータ、ソフトウェアが開いたファイルのリスト、ソフトウェアが確立したネットワーク接続などが含まれます)。単独のプログラムが複数のプロセスを生成するかもしれませんし、ユーザはこの単独のプログラムを複数実行することも可能です。</para>
    </sidebar>

    <sidebar>
      <title><emphasis>SECURITY</emphasis> <command>init</command> にシェルを実行させて root 権限を獲得する</title>

      <para>慣例によれば、起動される最初のプロセスは <command>init</command> プログラムです (これはデフォルトで <filename>/lib/systemd/systemd</filename> へのシンボリックリンクです)。しかしながら、カーネルに <literal>init</literal> オプションを渡して別のプログラムを開始することも可能です。</para>
      <indexterm><primary><command>init</command></primary></indexterm>

      <para>コンピュータに触ることができる人は誰でも <keycap>Reset</keycap> ボタンを押してコンピュータを再起動することが可能です。そして、ブートローダプロンプトでカーネルに <literal>init=/bin/sh</literal> オプションを渡せば、管理者パスワードを知らなくても root 権限を取得できます。</para>

      <para>これを避けるため、パスワードでブートローダを保護することが可能です。さらに BIOS へのアクセスも保護したいと考えるかもしれません (BIOS に対するパスワード保護機能はほぼ必ず付いています)。BIOS に対するパスワード保護機能がなければ、悪意ある侵入者が自分の Linux システムを含むリムーバブルメディアからマシンを起動して、コンピュータのハードドライブのデータにアクセスするかもしれません。</para>

      <para>最後に、多くの BIOS では汎用的なパスワードが使えるという点に注意してください。当初、汎用パスワードはパスワードを忘れた人向けのトラブルシューティングを意図していましたが、今や汎用パスワードは公開されインターネットから入手できます (ご自分の手で、検索エンジンで「generic BIOS passwords」を検索してみてください)。前述した保護機能を使えば、マシンへの不正アクセスを完全に防ぐことはできないにせよ、それを遅らせることは可能でしょう。しかしながら、攻撃者が物理的にコンピュータにアクセスできる場合、確実にコンピュータを保護する方法は存在しません。すなわち、攻撃者は対象のコンピュータからハードドライブを取り外してそれを自分の制御下にあるコンピュータに接続したり、マシン本体ごと盗んだり、パスワードをリセットするために BIOS メモリを消去することも可能ということです。</para>
    </sidebar>


<para>Systemd はシステムの設定を担当している複数のプロセスを実行します。具体的に言えば、キーボード、ドライバ、ファイルシステム、ネットワーク、サービスなどの要素が設定されます。Systemd はシステム全体におよぶ包括的視点と各要素の要求条件を満足させながらプロセスを実行します。各要素は「ユニットファイル」によって定義されています (「ユニットファイル」以外のファイルが必要な場合もあります)。ユニットファイルの一般的な構文は広く使われている「*.ini ファイル」の構文から派生したもので、<literal>[<replaceable>section</replaceable>]</literal> ヘッダでグループ化された <literal><replaceable>key</replaceable> = <replaceable>value</replaceable></literal> ペアを使います。ユニットファイルは <filename>/lib/systemd/system/</filename> と <filename>/etc/systemd/system/</filename> の下に保存されます。ユニットファイルにはいくつかの形式がありますが、ここでは「service」型と「target」型に注目します。</para>

<para>systemd の「service ファイル」は systemd が管理するプロセスを設定するファイルです。「service ファイル」には大ざっぱに言って古いスタイルの init スクリプトと同じ情報が含まれていますが、宣言的な方法 (そしてより簡潔な方法) を使ってその情報が記述されています。systemd は大半の繰り返しタスク (プロセスの開始と停止、状態確認、ログ記録、特権の取り消しなど) を処理しますので、service ファイルに記入する情報は対象プロセスに特有の情報だけで十分です。たとえば以下は SSH 用の service ファイルです。</para>

<programlisting>[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=sshd.service</programlisting>

<para>ご覧の通り、コードはとても少なく宣言だけで構成されています。systemd は作業進行状況を表示したり、プロセスを監視したり、必要な時にプロセスを再起動することを担当します。</para>

<para>systemd の「target ファイル」はシステムの状態を記述するファイルで、管理者はこのファイルを使って利用できる状態にされていなければならないサービス群を指定します。「target ファイル」は昔ながらのランレベルに相当するものとして考えることが可能です。target ファイルの 1 つに <literal>local-fs.target</literal> があります。<literal>local-fs.target</literal> で定義された状態に到達した場合、残りのシステムはすべてのローカルファイルシステムがマウントされアクセスできるようになっている状態を仮定することが可能です。また別の target ファイルに <literal>network-online.target</literal> と <literal>sound.target</literal> があります。ある target ファイルの依存関係は対象の target ファイルの中 (<literal>Requires=</literal> 行) に依存関係にある service ファイルを記述するか、対象の <literal>/lib/systemd/system/<replaceable>targetname</replaceable>.target.wants/</literal> ディレクトリの中に依存関係にある service ファイルを指すシンボリックリンクを作ることで指定します。たとえば、<filename>/etc/systemd/system/printer.target.wants/</filename> には <filename>/lib/systemd/system/cups.service</filename> へのリンクが含まれます。そしてこのため systemd は <literal>printer.target</literal> を処理する前に CUPS が実行されていることを保証するでしょう。</para>

<para>ユニットファイルは宣言型の設定ファイルでありスクリプトやプログラムではないため、ユニットファイルを直接実行することは不可能で、ユニットファイルは systemd によってのみ解釈されます。いくつかのユーティリティを使うことで、管理者は systemd と情報をやり取りして、システムおよびシステム部品の状態を制御することが可能です。</para>

<para>systemd と情報をやり取りする 1 番目のユーティリティとして <command>systemctl</command> が挙げられます。<command>systemctl</command> を引数なしで実行した場合、systemd が把握しているすべてのユニットファイル (無効化されているものを除きます) およびその状態が表示されます。<command>systemctl status</command> を使うことで、サービスおよび関連するプロセスをよりわかりやすく表示することが可能です。サービスの名前を指定した場合 (<command>systemctl status ntp.service</command> のように指定した場合)、<command>systemctl</command> はさらに詳しい情報および指定したサービスに関連するログの最後の数行を表示します (後から詳しく説明します)。</para>

<para>手作業でサービスを開始するのは簡単で、<command>systemctl start <replaceable>servicename</replaceable>.service</command> を実行するだけです。予想通り、サービスを停止するには <command>systemctl stop <replaceable>servicename</replaceable>.service</command> を使います。また、他のサブコマンドには <command>reload</command> と <command>restart</command> があります。</para>

<para>サービスを有効化するには (たとえば起動時に自動的にサービスを開始するには)、<command>systemctl enable <replaceable>servicename</replaceable>.service</command> を使います (無効化するには <command>disable</command> を使います)。<command>is-enabled</command> を使えば、サービスの状態を確認することが可能です。</para>

<para>systemd が備える興味深い機能として、<command>journald</command> と名付けられたログ記録機能が挙げられます。<command>journald</command> は <command>syslogd</command> などのより伝統的なログ記録システムを補完するために誕生しましたが、サービスとサービスが生成したメッセージを正しく関連付けたり初期化シーケンスが生成するエラーメッセージを保存する能力などの興味深い機能を追加しています。<command>journalctl</command> コマンドの助けを少し借りるだけで、メッセージを後から表示することが可能になります。引数なしで実行した場合、<command>journalctl</command> は起動後に発生したすべてのログメッセージを表示しますが、引数を与えずに実行することはほとんどないでしょう。ほとんどの場合、以下のようにサービス識別子を与えて <command>journalctl</command> を実行します。</para>

<screen><computeroutput># </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at 火 2015-03-31 17:08:49 JST, end at 水 2015-04-01 00:06:02 JST. --
 3月 31 17:08:55 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
 3月 31 17:08:55 mirtuel sshd[430]: Server listening on :: port 22.
 3月 31 17:09:00 mirtuel sshd[430]: Received SIGHUP; restarting.
 3月 31 17:09:00 mirtuel sshd[430]: Server listening on 0.0.0.0 port 22.
 3月 31 17:09:00 mirtuel sshd[430]: Server listening on :: port 22.
 3月 31 17:09:32 mirtuel sshd[1151]: Accepted password for roland from 192.168.1.129 port 53394 ssh2
 3月 31 17:09:32 mirtuel sshd[1151]: pam_unix(sshd:session): session opened for user roland by (uid=0)
</computeroutput></screen>

<para>その他の役に立つコマンドラインオプションとして <command>-f</command> が挙げられます。これを使った場合、<command>journalctl</command> は新しいメッセージを受け取ったらそのメッセージを表示し続けます (これは <command>tail -f <replaceable>file</replaceable></command> とほぼ同じやり方です)。</para>

<para>サービスが期待通りに動いていないように見える場合、問題解決に向けて手始めに <command>systemctl status</command> を実行し、今現在サービスが動いているか否かを確認します。サービスが実行されておらず、<command>systemctl status</command> の表示したメッセージが問題の原因を解明するのに十分でない場合、journald が収集したサービスに関連するログを確認します。たとえば、SSH サービスが動いていないと仮定すると、以下の手順で状況を確認します。</para>

<screen><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: failed (Result: start-limit) since 水 2015-04-01 00:30:36 JST; 1s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
  Process: 1188 ExecStart=/usr/sbin/sshd -D $SSHD_OPTS (code=exited, status=255)
 Main PID: 1188 (code=exited, status=255)

 4月  1 00:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
 4月  1 00:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>journalctl -u ssh.service
</userinput><computeroutput>-- Logs begin at 水 2015-04-01 00:29:27 JST, end at 水 2015-04-01 00:30:36 JST. --
 4月  1 00:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
 4月  1 00:29:27 mirtuel sshd[424]: Server listening on :: port 22.
 4月  1 00:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
 4月  1 00:29:29 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
 4月  1 00:29:29 mirtuel sshd[424]: Server listening on :: port 22.
 4月  1 00:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
 4月  1 00:30:10 mirtuel sshd[1147]: pam_unix(sshd:session): session opened for user roland by (uid=0)
 4月  1 00:30:35 mirtuel sshd[1180]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:35 mirtuel sshd[1182]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:35 mirtuel sshd[1184]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:35 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:35 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:36 mirtuel sshd[1186]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:36 mirtuel sshd[1188]: /etc/ssh/sshd_config line 28: unsupported option "yess".
 4月  1 00:30:36 mirtuel systemd[1]: ssh.service: main process exited, code=exited, status=255/n/a
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
 4月  1 00:30:36 mirtuel systemd[1]: ssh.service start request repeated too quickly, refusing to start.
 4月  1 00:30:36 mirtuel systemd[1]: Failed to start OpenBSD Secure Shell server.
 4月  1 00:30:36 mirtuel systemd[1]: Unit ssh.service entered failed state.
# </computeroutput><userinput>vi /etc/ssh/sshd_config
</userinput><computeroutput># </computeroutput><userinput>systemctl start ssh.service
</userinput><computeroutput># </computeroutput><userinput>systemctl status ssh.service
</userinput><computeroutput>● ssh.service - OpenBSD Secure Shell server
   Loaded: loaded (/lib/systemd/system/ssh.service; enabled)
   Active: active (running) since 水 2015-04-01 00:31:09 JST; 2s ago
  Process: 1023 ExecReload=/bin/kill -HUP $MAINPID (code=exited, status=0/SUCCESS)
 Main PID: 1222 (sshd)
   CGroup: /system.slice/ssh.service
           └─1222 /usr/sbin/sshd -D
# </computeroutput></screen>

<para>ここでは SSH サービスの状態が失敗状態であることを確認した後、ログの確認作業に進みました。その結果、ログは設定ファイル内にエラーがあることを示しています。そこで設定ファイルを編集してエラーを修正した後、SSH サービスを再起動し、SSH サービスが本当に動いていることを確認しました。</para>

<sidebar><title><emphasis>GOING FURTHER</emphasis> ユニットファイルの他の型</title>

<para>この節では、systemd の最も基本的な機能だけを説明しました。systemd は他にも多くの興味深い機能を備えていますが、ここでは一部だけを紹介します。</para>

<itemizedlist>

<listitem><para>ソケットの活性化。「socket」型のユニットファイルを使えば、systemd が管理するネットワークや Unix ソケットを表現することが可能です。これは systemd がソケットを作成し、実際のサービスは実際の接続要求を受信した時に要求に応じて開始されることを意味しています。この機能は大ざっぱに言って <command>inetd</command> の機能群を再現するものです。詳しくは <citerefentry><refentrytitle>systemd.socket</refentrytitle><manvolnum>5</manvolnum></citerefentry> を参照してください。</para></listitem>

<listitem><para>タイマ。「timer」型のユニットファイルを使えば、固定周期および特定時刻に発動するイベントを表現することが可能です。さらにサービスをタイマに関連付けた場合、タイマが発動するたびにサービスに対応するタスクを実行します。これを使うことで、<command>cron</command> 機能の一部を置き換えることが可能です。詳しくは <citerefentry><refentrytitle>systemd.timer</refentrytitle><manvolnum>5</manvolnum></citerefentry> を参照してください。</para></listitem>

<listitem><para>ネットワーク。「network」型のユニットファイルを使えば、ネットワークインターフェースを表現することが可能です。これを使うことで、ネットワークインターフェースを設定したり、サービスが特定のネットワークインターフェースの状態に依存することを表現することが可能です。</para></listitem>

</itemizedlist>
</sidebar>

</section>

<section id="sect.sysvinit"><title>System V init システム</title>
    <para>System V init システム (これを短縮して init と呼びます) は <filename>/etc/inittab</filename> ファイルの指示に従って複数のプロセスを実行します。実行される最初のプログラム (<emphasis>sysinit</emphasis> 段階に相当します) は <command>/etc/init.d/rcS</command> で、これは <filename>/etc/rcS.d/</filename> ディレクトリに含まれるすべてのプログラムを起動するスクリプトです。<indexterm><primary><filename>/etc/init.d/rcS</filename></primary></indexterm><indexterm><primary><filename>rcS</filename></primary></indexterm><indexterm><primary><filename>/etc/init.d/rcS.d/</filename></primary></indexterm><indexterm><primary><filename>rcS.d</filename></primary></indexterm></para>

    <para><filename>/etc/rcS.d/</filename> ディレクトリに含まれるスクリプトは特に以下の点を担当します。</para>
    <itemizedlist>
      <listitem>
	<para>コンソールキーボードの設定。</para>
      </listitem>
      <listitem>
	<para>ドライバの読み込み。ほとんどのカーネルモジュールはハードウェアを検出した時にカーネル自身によって読み込まれます。追加のドライバはそれに対応するモジュールが <filename>/etc/modules</filename> にリストされている場合に読み込まれます。</para>
      </listitem>
      <listitem>
	<para>ファイルシステムの整合性確認。</para>
      </listitem>
      <listitem>
	<para>ローカルパーティションのマウント。</para>
      </listitem>
      <listitem>
	<para>ネットワークの設定。</para>
      </listitem>
      <listitem>
	<para>ネットワークファイルシステム (NFS) のマウント。</para>
      </listitem>
    </itemizedlist>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> カーネルモジュールとオプション</title>
      <indexterm><primary>モジュール</primary><secondary>カーネルモジュール</secondary></indexterm>

      <para>カーネルモジュールにオプションを指定するには、<filename>/etc/modprobe.d/</filename> にファイルを追加してください。カーネルモジュールのオプションは <literal>options <replaceable>module-name</replaceable> <replaceable>option-name</replaceable>=<replaceable>option-value</replaceable></literal> のような指示文を使って定義します。場合によっては、いくつかのオプションは単独の指示文で指定することも可能です。</para>

      <para><filename>/etc/modprobe.d/</filename> 内の設定ファイルは <command>modprobe</command> によって使われます。すなわち <command>modprobe</command> が依存関係に従ってカーネルモジュールを読み込みます (モジュールは他のモジュールを呼ぶことができます)。<command>modprobe</command> は <emphasis role="pkg">kmod</emphasis> パッケージに含まれています。</para>
      <indexterm><primary><command>modprobe</command></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">kmod</emphasis></primary></indexterm>
    </sidebar>

    <para><command>/etc/init.d/rcS</command> の完了後、<command>init</command> が起動処理を引き継いで、デフォルトランレベル (通常ランレベル 2) で有効化されたプログラムを起動します。<command>init</command> は <command>/etc/init.d/rc 2</command> を実行します。これは <filename>/etc/rc2.d/</filename> に置かれて「S」で始まる名前のすべてのサービスを開始するコマンドです。歴史的なことを言えば、「S」の後に続く 2 桁の数字は起動するサービスの順番を定義するために使われていました。しかし現在では、デフォルトの起動システムは <command>insserv</command> を使ってスクリプト同士の依存関係に従った起動順を自動的に決定します。このため、各起動スクリプトはサービスを起動または終了させる時に満足しなければいけない条件を宣言します (たとえば、あるサービスは他のサービスの前または後に起動しなければいけないなどの条件を宣言します)。そして、<command>init</command> は条件を満足するようにサービスを起動します。このため、スクリプトの静的な番号付けはもはや考慮されません (しかしスクリプトの名前は必ず「S」で始まり、その後ろに 2 桁の番号と条件を宣言する際に使われる実際のスクリプトの名前を付けなければいけません)。一般に、基盤サービス (ログ記録を担当している <command>rsyslog</command> やポート割り当てを担当している <command>portmap</command>) が最初に起動され、その後に標準的なサービスとグラフィカルインターフェース (<command>gdm3</command>) が起動されます。</para>

    <para>この依存関係に基づく起動システムのおかげで、起動順を自動的に再定義することが可能になります。これは手作業でやるにはちょっと退屈な作業で、人的ミスの危険性があります。なぜなら、起動順は宣言された依存関係に従って定義されるからです。他の長所として、他のサービスに依存しないサービスは並列して開始できるという点があります。このことにより、起動処理を加速できます。</para>

    <indexterm><primary>ランレベル</primary></indexterm>
    <indexterm><primary>レベル、ランレベル</primary></indexterm>

    <para><command>init</command> はランレベルを見分けて処理を分岐させます。ランレベルを切り替えるには <command>telinit <replaceable>new-level</replaceable></command> コマンドを使います。このコマンドを実行すると <command>init</command> は即座に新しいランレベルを引数にして <command>/etc/init.d/rc</command> を再実行します。<command>/etc/init.d/rc</command> は欠けているサービスを開始し、既に不要となったサービスを停止します。これを行うために、<command>/etc/init.d/rc</command> は <filename>/etc/rc<replaceable>X</replaceable>.d</filename> ディレクトリの内容を参照します (ここで <replaceable>X</replaceable> は新しいランレベルです)。このディレクトリに含まれる (「Start」の)「S」で始まるスクリプトは開始されるサービスで、(「Kill」の)「K」で始まるスクリプトは停止されるサービスです。<command>/etc/init.d/rc</command> は切り替え前のランレベルで既に起動されているサービスは開始しません。</para>

    <para>デフォルトで、Debian の System V init は 4 種類のランレベルを使います。</para>
    <itemizedlist>
      <listitem>
	<para>レベル 0。これはコンピュータの電源を切る際に一時的に使われるだけです。このため「K」スクリプトしか含まれません。</para>
      </listitem>
      <listitem>
	<para>レベル 1。これはシングルユーザモードとしても知られ、システムの機能抑制モードに相当します。このモードは基本的なサービスだけを提供し、一般ユーザがマシンを利用していないメンテナンスの際に使われることを意図しています。</para>
      </listitem>
      <listitem>
	<para>レベル 2。これは通常動作用のモードで、ネットワークサービス、グラフィカルインターフェース、ユーザログインなどの機能を使うことが可能です。</para>
      </listitem>
      <listitem>
	<para>レベル 6。これはレベル 0 と似ていますが、再起動前のシャットダウン段階中に使われる点が異なります。</para>
      </listitem>
    </itemizedlist>

    <para>その他のレベル。レベル 3 からレベル 5 までも存在します。デフォルトでこれらのランレベルはレベル 2 と同様に動作しますが、管理者はこれらのレベルを特定の要求に順応させるためのレベルに書き換えることが可能です (ランレベルに対応する <filename>/etc/rc<replaceable>X</replaceable>.d</filename> ディレクトリにスクリプトを追加したりおよび削除したりする必要があります)。</para>

    <figure id="figure.boot-process-sysvinit">
      <title>System V init を使う Linux の動くコンピュータの起動シーケンス</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/startup-sysvinit.png" scalefit="1" width="80%" />
        </imageobject>
      </mediaobject>
    </figure>
    <indexterm><primary>初期化スクリプト</primary></indexterm>

    <para>各 <filename>/etc/rc<replaceable>X</replaceable>.d</filename> ディレクトリに含まれるすべてのスクリプトは <filename>/etc/init.d/</filename> に格納されたスクリプトの実体を指すシンボリックリンクに過ぎません (シンボリックリンクはパッケージのインストール時に <command>update-rc.d</command> プログラムによって作られます)。各ランレベルで利用できるサービスを微調整するには、管理者が調整パラメータを与えて <command>update-rc.d</command> を再実行する必要があります。<command>update-rc.d</command> の構文は <citerefentry><refentrytitle>update-rc.d</refentrytitle><manvolnum>1</manvolnum></citerefentry> マニュアルページに詳しく説明されています。サービスを無効化したい場合に (<literal>remove</literal> パラメータを与えて) すべてのシンボリックリンクを削除するのは悪い方法であるという点に注意してください。<literal>remove</literal> パラメータを使う代わりに、単純に希望するランレベルでそのサービスを起動しないよう <literal>disable</literal> を使って設定するべきです (同時に、万が一切り替え前のランレベルで対象のサービスが実行されている場合に備えて、切り替え後のランレベルでサービスを停止するために必要なシンボリックリンクを確保しておくべきです)。<command>update-rc.d</command> は複雑なインターフェースを持っているため、<command>rcconf</command> (<emphasis role="pkg">rcconf</emphasis> パッケージに含まれます) を使いたいと思うかもしれません。<command>rcconf</command> はユーザにとってさらに使い勝手の良いインターフェースを提供します。</para>
    <indexterm><primary><command>update-rc.d</command></primary></indexterm>

    <sidebar>
      <title><emphasis>DEBIAN POLICY</emphasis> サービスの再起動</title>
      <indexterm><primary><command>invoke-rc.d</command></primary></indexterm>
      <indexterm><primary>サービス</primary><secondary>再起動</secondary></indexterm>
      <indexterm><primary>サービスの再起動</primary></indexterm>

      <para>Debian パッケージのメンテナスクリプトはサービスを確実に利用できるようにしたりサービスに特定のオプションを考慮させるためにそのサービスを再起動することがあります。サービスを操作するコマンドである <command>service <replaceable>service</replaceable> <replaceable>operation</replaceable></command> はランレベルを考慮しません。このコマンドはサービスが現在使用中であると (間違って) 仮定し、間違った操作 (故意に停止されたサービスの開始や既に停止されたサービスの停止など) を開始するかもしれません。このため Debian は <command>invoke-rc.d</command> プログラムを導入しました。すなわち、メンテナスクリプト内でサービス初期化スクリプトを実行する場合は、必ず <command>invoke-rc.d</command> プログラムを使わなければいけません。<command>invoke-rc.d</command> プログラムは必要なコマンドだけを実行します。通常の使い方と異なり、ディレクトリではなくプログラム名に <filename>.d</filename> サフィックスが使われている点に注意してください。</para>
    </sidebar>

    <para>最後に、<command>init</command> はさまざまな仮想コンソール用の制御プログラム (<command>getty</command>) を開始します。<command>getty</command> はプロンプトを表示し、ユーザ名の入力を待ち、セッションを開始するために <command>login <replaceable>user</replaceable></command> を実行します。</para>
    <indexterm><primary><command>getty</command></primary></indexterm>

    <sidebar>
      <title><emphasis>VOCABULARY</emphasis> コンソールと端末</title>

      <para>草創期のコンピュータは通常複数のとても大きな部品に分かれていました。すなわち、ストレージ収納装置と中央処理装置はそれらを操作するオペレータが使う周辺装置から離れた場所にありました。オペレータが使う周辺装置は分離された周辺装置「コンソール」の部分でした。現在「コンソール」という用語は意味を変えて残されています。「コンソール」はキーボードと画面を備える「端末」とほぼ同義語になっています。</para>

      <para>コンピュータの開発とともに、オペレーティングシステムは、たとえもしマシンに 1 台のキーボードと画面しか接続されていなかったとしても、複数の独立したセッションを同時に処理する目的で複数の仮想コンソールを提供するようになりました。多くの GNU/Linux システムでは (テキストモード時に)、<keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F1</keycap> </keycombo> から <keycombo action="simul"> <keycap>Control</keycap> <keycap>Alt</keycap> <keycap>F6</keycap> </keycombo> までのキーの組み合わせを入力することで 6 つの仮想コンソールを切り替えられます。</para>

      <para>転じて、「コンソール」と「端末」という用語はグラフィカル X11 セッションで使われる端末エミュレータ (<command>xterm</command>、<command>gnome-terminal</command>、<command>konsole</command> など) でも使われています。</para>
    </sidebar>
</section>
  </section>
  <section id="sect.remote-login">
    <title>リモートログイン</title>

    <para>管理者にとってコンピュータにリモートから接続できることは不可欠な要素です。専用の部屋に閉じ込められているサーバにキーボードとモニタが常設されていることはめったにありません。しかしサーバはネットワークにつながっています。</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> クライアント、サーバ</title>
      <indexterm><primary>クライアント</primary><secondary>クライアント/サーバアーキテクチャ</secondary></indexterm>
      <indexterm><primary>サーバ</primary><secondary>クライアント/サーバアーキテクチャ</secondary></indexterm>

      <para>複数のプロセスが互いに通信しているシステムはよく「クライアント/サーバ」に例えられます。サーバはクライアントからの要求に応じて、その要求を実行するプログラムです。操作を制御するのがクライアントで、サーバは制御の主導権を握りません。</para>
    </sidebar>

    <indexterm><primary>ログイン</primary><secondary>リモートログイン</secondary></indexterm>
    <indexterm><primary>リモートログイン</primary></indexterm>

    <section id="sect.ssh">
      <title>安全なリモートログイン、SSH</title>
      <indexterm><primary>SSH</primary></indexterm>
      <indexterm><primary>Secure Shell</primary></indexterm>

      <para><emphasis>SSH</emphasis> (Secure SHell) プロトコルは安全性と信頼性を念頭に置いて設計されました。SSH を使う接続は安全です。つまり、通信相手は認証され、交換されるデータはすべて暗号化されます。</para>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> Telnet と RSH は時代遅れです</title>
	<indexterm><primary><command>telnet</command></primary></indexterm>
	<indexterm><primary><command>rsh</command></primary></indexterm>

	<para>SSH 以前、<emphasis>Telnet</emphasis> と <emphasis>RSH</emphasis> がリモートからログインするために使われる主なツールでした。両者は今や大幅に時代遅れです。両者がまだ Debian から配布されているとしても、もはやそれを使うべきではありません。</para>
      </sidebar>

      <sidebar>
        <title><emphasis>VOCABULARY</emphasis> 認証、暗号化</title>

	<para>クライアントに対してサーバ上で作業を実行したり作業を自動的に開始したりすることを許可する必要がある場合、安全性が重要です。クライアントは必ず本人であることを確認されなければいけません。これが認証です。通常、本人確認はパスワードを使って行います。パスワードは人目に触れさせてはいけません。そうでなければ、他のクライアントがパスワードを取得できてしまうからです。これが暗号化の目的です。暗号化は符号化の形をしています。暗号化することで、2 つのシステムが公衆回線を使って秘密の情報を他人に読まれないように保護した状態でやり取りすることが可能になります。</para>

	<para>認証と暗号化はしばしば一緒に言及されます。なぜなら両者は同時に使われることが多く、よく似た数学的概念を基に実行されることが多いからです。</para>
      </sidebar>

      <para>さらに SSH は 2 種類のファイル転送サービスを提供します。<command>scp</command> は <command>cp</command> のように使えるコマンドラインツールです。ただし、他のマシンへのパスを表記するにはパスの前にそのマシンの名前とコロンを付ける点が <command>cp</command> と異なります。</para>

      <screen><computeroutput>$ </computeroutput><userinput>scp file machine:/tmp/</userinput></screen>

      <para><command>sftp</command> は対話型コマンドで <command>ftp</command> に似ています。<command>sftp</command> は単一のセッションの中で複数のファイルを転送したり、リモートのファイルを操作 (削除、リネーム、パーミッション変更など) したりすることが可能です。</para>
      <indexterm><primary><command>scp</command></primary></indexterm>
      <indexterm><primary><command>sftp</command></primary></indexterm>

      <para>Debian は OpenSSH を使います。OpenSSH は SSH のフリーソフトウェア版で <command>OpenBSD</command> (BSD カーネルに基づき、安全性を重要視する自由なオペレーティングシステム) プロジェクトによってメンテナンスされており、フィンランドの SSH Communications Security Corp が開発した元祖 SSH ソフトウェアのフォークです。SSH Communications Security Corp は当初 SSH をフリーソフトウェアとして開発していましたが、結局プロプライエタリライセンスで開発を続けることを決定しました。そして OpenBSD プロジェクトが SSH のフリーソフトウェア版としてメンテナンスするために OpenSSH を作成しました。</para>
      <indexterm><primary>OpenSSH</primary></indexterm>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> <foreignphrase>フォーク</foreignphrase></title>
        <indexterm><primary>フォーク</primary></indexterm>

	<para>ソフトウェアの分野で「フォーク」とは、既存のプロジェクトのクローンとして始まった新しいプロジェクトを意味しており、既存のプロジェクトの対抗馬です。通常、両方のソフトウェアは新しい開発という観点ですぐに別のものになっていきます。フォークは開発チーム内の意見の不一致によって起こることが多いです。</para>

	<para>プロジェクトをフォークするという選択肢はフリーソフトウェアの本質そのものから生じた直接的な結果です。フリーソフトウェアとしてのプロジェクトの存続を可能にするための (たとえばライセンスが変更された場合などの) フォークは健全な出来事です。技術的および個人的な意見の不一致によって起こるフォークは通常人的資源の無駄です。従って別の解決策が望まれます。過去にフォークした 2 つのプロジェクトの合併はいまだ前例がありません。</para>
      </sidebar>

      <para>OpenSSH は 2 つのパッケージに分割されています。すなわち、クライアント部分は <emphasis role="pkg">openssh-client</emphasis> パッケージ、サーバ部分は <emphasis role="pkg">openssh-server</emphasis> パッケージに分割されています。<emphasis role="pkg">ssh</emphasis> メタパッケージは両方のパッケージに依存しており、これを使えば両方のインストールが簡単になります (<command>apt install ssh</command> だけでクライアントとサーバの両方がインストールされます)。</para>

      <section id="sect.ssh-key-based-auth">
        <title>鍵認証方式</title>

	<para>リモートサーバはユーザを認証するために SSH でログインする人に対して毎回パスワードを尋ねます。これは、接続を自動化したい場合や SSH 経由で頻繁に接続を行うツールを使う場合に問題です。このため、SSH は鍵認証システムを提供しています。</para>

	<para>ユーザはクライアントマシンで <command>ssh-keygen -t rsa</command> を使って鍵ペアを生成します。この時公開鍵は <filename>~/.ssh/id_rsa.pub</filename> に保存され、一方で公開鍵に対応する秘密鍵は <filename>~/.ssh/id_rsa</filename> に保存されます。その後ユーザは <command>ssh-copy-id <replaceable>server</replaceable></command> を使って、自分の公開鍵をサーバの <filename>~/.ssh/authorized_keys</filename> ファイルに追加登録します。秘密鍵を生成した際に「パスフレーズ」で保護しなかった場合、公開鍵を登録したサーバに対する以降すべてのログインでパスワードは不要です。そうでなければ、秘密鍵を使う際は毎回パスフレーズを入力して秘密鍵を復号化しなければいけません。幸いにも、<command>ssh-agent</command> を使えば復号化された秘密鍵がメモリ内に保存され、パスワードをきちんと再入力する必要がなくなります。これを実現するには、セッションが既に機能する <command>ssh-agent</command> のインスタンスに関連付けられている条件下で、単純に (作業セッションごとに 1 回) <command>ssh-add</command> を使ってください。Debian はグラフィカルセッションではデフォルトで <command>ssh-agent</command> を有効化しますが、<filename>/etc/X11/Xsession.options</filename> を変更すれば無効化することも可能です。コンソールセッションでは手作業で <command>eval $(ssh-agent)</command> を実行することで <command>ssh-agent</command> を開始できます。</para>

        <sidebar>
          <title><emphasis>SECURITY</emphasis> 秘密鍵の保護</title>

	  <para>秘密鍵を持っていれば、誰でも対応する公開鍵を登録したアカウントにログインすることが可能です。このため、秘密鍵の利用は「パスフレーズ」で保護されています。秘密鍵ファイル (たとえば <filename>~/.ssh/id_rsa</filename>) のコピーを不正に入手した人が秘密鍵を使うためには、パスフレーズを知らなければいけません。しかしながら、「パスフレーズ」による追加的な保護は堅固なものではありません。秘密鍵ファイルが不正に使われていると感じたなら、その秘密鍵に対応する公開鍵をインストールしたコンピュータでその公開鍵の使用を停止し (<filename>authorized_keys</filename> ファイルから公開鍵を削除し)、新しく生成した鍵で公開鍵を置き換えるのが最良の対応策です。</para>
        </sidebar>

        <sidebar>
          <title><emphasis>CULTURE</emphasis> Debian <emphasis role="distribution">Etch</emphasis> における OpenSSL の脆弱性</title>

	  <para>当初 Debian <emphasis role="distribution">Etch</emphasis> から配布されていた OpenSSL ライブラリは乱数発生器 (RNG) に深刻な問題がありました。はっきり言うと、Debian メンテナによって <command>valgrind</command> などのメモリテストツールで OpenSSL ライブラリを使うアプリケーションを解析した際に警告を出さなくなるような変更が行われました。不幸なことに、この変更により RNG はエントロピーソースを 1 つしか使わなくなりました。ここで使われたエントロピーソースはプロセス ID (PID) に相当するもので、PID の取りうる値は 32,000 程度しかないため PID をソースとして用いたことにより十分な乱数度が得られなくなりました。<ulink type="block" url="http://www.debian.org/security/2008/dsa-1571" /></para>

	  <para>具体的に言えば、OpenSSL を使って鍵を生成した場合、生成された鍵は常に数十万 (鍵長種数の 32,000 倍) の既知の範囲内にある鍵のうちの 1 つになります。この脆弱性は、たとえば OpenVPN など数多くのアプリケーションが使う SSH 鍵、SSL 鍵、X.509 証明書に影響をおよぼしました。クラッカーは全種類の鍵を試すだけで不正アクセスを実行することが可能でした。この問題の影響を減らす目的で、SSH デーモンは <emphasis role="pkg">openssh-blacklist</emphasis> と <emphasis role="pkg">openssh-blacklist-extra</emphasis> パッケージにリストされている問題のある鍵を拒否するように変更されました。さらに、<command>ssh-vulnkey</command> コマンドを使えば、システム内からこの脆弱性の影響を受けているかもしれない鍵を識別することが可能です。</para>

	  <para>この出来事をいっそう詳しく調べると、これは OpenSSL プロジェクト内と Debian パッケージメンテナ双方にあった多数の (小さな) 問題の結果であるということが、明らかになります。OpenSSL のように広く使われるライブラリは (修正せずとも) <command>valgrind</command> でテストした時に警告を出すべきではありません。さらに、コード (特に RNG と同様に慎重に取り扱われるべき部分) はこのような誤解を避ける目的で詳しい注釈を付けられるべきです。Debian 側について言えば、メンテナは OpenSSL 開発者から修正に対する検証を受けることを望んでいながら、修正の検証に必要なパッチを OpenSSL 開発者に提供することもせずに自分の修正について簡単に説明しただけで、Debian 内における自分の役割を口にすることもしませんでした。そして最後に、メンテナンス方針が最適なものではありませんでした。具体的に言えば、元のコードに対して行った修正が文書中で明らかにされず、さらにすべての修正は Subversion リポジトリに効果的に保存されていましたが、最終的にすべての修正はソースパッケージの作成中に 1 つのパッチにまとめられていました。</para>

	  <para>このような状況下では、これと同様の出来事が繰り返されることを避けるための適切な矯正措置を見つけるのは難しいです。ここで覚えておくべき教訓は Debian が上流開発ソフトウェアに対して導入したすべての変更は正当化され、文書化され、可能であれば上流プロジェクトに提出され、広く公開されなければいけないということです。この視点から、新しいソースパッケージフォーマット (「3.0 (quilt)」) と Debian ソースウェブサービスが開発されました。<ulink type="block" url="http://sources.debian.org" /></para>
        </sidebar>
      </section>
      <section id="sect.ssh-x11">
        <title>リモートの X11 アプリケーションを使う</title>

	<para>SSH プロトコルを使うと、グラフィカルデータ (「X11」セッション、Unix で最も広く使われているグラフィカルシステム) を転送することが可能です。サーバはこれらのデータ専用の経路を開いたままにします。具体的に言うと、リモートで実行されたグラフィカルプログラムはローカル画面の X.org サーバ上に表示され、すべてのセッション (入力と表示) は保護されます。X11 転送機能によりリモートアプリケーションがローカルシステムに干渉することになるため、X11 転送機能はデフォルトで無効化されています。X11 転送機能を有効化するには、SSH サーバの設定ファイル (<filename>/etc/ssh/sshd_config</filename>) で <literal>X11Forwarding yes</literal> と指定してください。さらにユーザは <command>ssh</command> コマンドラインに <literal>-X</literal> オプションを追加して転送を要求しなければいけません。</para>
      </section>
      <section id="sect.ssh-port-forwarding">
        <title>ポート転送を使った暗号化トンネルの作成</title>
        <indexterm><primary>ポート転送</primary></indexterm>

	<para><command>ssh</command> の <literal>-R</literal> と <literal>-L</literal> オプションを使うと、<command>ssh</command> が 2 台のマシン間で「暗号化トンネル」を作成することが可能です。「暗号化トンネル」を使えば、ローカル TCP ポート (補注<xref linkend="sidebar.tcp-udp" />を参照してください) をリモートのマシンに安全に転送したりその逆を行うことも可能です。</para>

        <sidebar>
          <title><emphasis>VOCABULARY</emphasis> トンネル</title>
          <indexterm><primary>トンネル (SSH)</primary><seealso>VPN</seealso></indexterm>
          <indexterm><primary>SSH トンネル</primary><seealso>VPN</seealso></indexterm>

	  <para>インターネットとインターネットに接続されている多くの LAN はパケットモードで動作しており、接続モードで動作していません。これは、一方のコンピュータから他方のコンピュータに向かって送信されたパケットは、宛先への経路を見つけるために複数の中間ルータで足止めされることを意味しています。とは言っても、接続モードを模倣することも可能です。接続モードではストリームを普通の IP パケットの中にカプセル化します。これらのパケットは通常の経路を通過しますが、ストリームは宛先を変えられることなく再構成されます。これは道路のトンネルにかけて「トンネル」と呼ばれています。道路のトンネルでは車両が入口 (入力) から出口 (出力) まで交差点に遭遇することなくまっすぐ進むのに対し、地上の経路を使うと車両は交差点を通過したり右折左折を繰り返しながら目的地まで進むことになります。</para>

	  <para>トンネルに暗号化機能を追加することが可能です。すなわち、トンネルの中を流れるストリームは外から認識できませんが、トンネルの出口で復号化された形で返されます。</para>
        </sidebar>

	<para><command>ssh -L 8000:server:25 intermediary</command> を使うことで、ローカルの <command>ssh</command> に <replaceable>intermediary</replaceable> との SSH セッションを確立させ、ローカルの <command>ssh</command> にローカルのポート 8000 番をリッスンさせます (<xref linkend="figure.ssh-L" />を参照してください)。ローカルのポート 8000 番を経由して接続が開始されたら、<replaceable>intermediary</replaceable> の <command>ssh</command> は <replaceable>intermediary</replaceable> から <replaceable>server</replaceable> のポート 25 番に接続し、ローカルから <replaceable>server</replaceable> への接続を中継します。</para>

	<para><command>ssh -R 8000:server:25 intermediary</command> を使うことで、ローカルの <command>ssh</command> に <replaceable>intermediary</replaceable> との SSH セッションを確立させ、<replaceable>intermediary</replaceable> の <command>ssh</command> に <replaceable>intermediary</replaceable> のポート 8000 番をリッスンさせます (<xref linkend="figure.ssh-R" />を参照してください)。<replaceable>intermediary</replaceable> のポート 8000 番を経由して接続が開始されたら、ローカルの <command>ssh</command> はローカルから <replaceable>server</replaceable> のポート 25 番に接続し、<replaceable>intermediary</replaceable> から <replaceable>server</replaceable> への接続を中継します。</para>

	<para>どちらの場合も、ローカルと <replaceable>intermediary</replaceable> の間に確立した SSH トンネルを介して、<replaceable>server</replaceable> のポート 25 番に接続します。最初の例の場合、トンネルの入口はローカルのポート 8000 番で、データはまず <replaceable>intermediary</replaceable> を目指し、その後に「公開」ネットワークを経由して <replaceable>server</replaceable> に向かいます。2 番目の例の場合、トンネルの入口と出口が逆になります。トンネルの入口は <replaceable>intermediary</replaceable> のポート 8000 番で、出口はローカルにあります。出口から出たデータは <replaceable>server</replaceable> に向かいます。現実的な話をすると、ここで使われている <replaceable>server</replaceable> にはローカルまたは <replaceable>intermediary</replaceable> を指定することが多いです。このようにして SSH は端から端までの接続を保護します。</para>

        <figure id="figure.ssh-L">
          <title>SSH を使ったローカルポートの転送</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ssh-L.png" width="35%" />
            </imageobject>
          </mediaobject>
        </figure>

        <figure id="figure.ssh-R">
          <title>SSH を使ったリモートポートの転送</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="images/ssh-R.png" width="35%" />
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>
    <section id="sect.remote-desktops">
      <title>リモートグラフィカルデスクトップの利用</title>

      <para>VNC (Virtual Network Computing) を使うとグラフィカルデスクトップにリモートからアクセスすることが可能になります。</para>
      <indexterm><primary>VNC</primary></indexterm>
      <indexterm><primary>Virtual Network Computing</primary></indexterm>
      <indexterm><primary>グラフィカルデスクトップ</primary><secondary>リモート</secondary></indexterm>
      <indexterm><primary>リモートグラフィカルデスクトップ</primary></indexterm>
      <indexterm><primary>デスクトップ、リモートグラフィカルデスクトップ</primary></indexterm>

      <para>VNC は技術支援に使われることが多いです。なぜなら、管理者はユーザが直面しているエラーを見ることが可能で、ユーザの側にいなくても正しい行動の仕方をユーザに示すことが可能だからです。</para>
      <indexterm><primary><emphasis role="pkg">vino</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">krfb</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">x11vnc</emphasis></primary></indexterm>

      <para>First, the user must authorize sharing their session.  The
      GNOME graphical desktop environment in <emphasis role="distribution">Jessie</emphasis> includes that option in
      its configuration panel (contrary to previous versions of
      Debian, where the user had to install and run
      <command>vino</command>).  KDE Plasma still requires using
      <command>krfb</command> to allow sharing an existing session
      over VNC. For other graphical desktop environments, the
      <command>x11vnc</command> command (from the Debian package of
      the same name) serves the same purpose; you can make it
      available to the user with an explicit icon.</para>

      <indexterm><primary><emphasis role="pkg">vinagre</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">tsclient</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">krdc</emphasis></primary></indexterm>
      <indexterm><primary><emphasis role="pkg">xvnc4viewer</emphasis></primary></indexterm>

      <para>When the graphical session is made available by VNC, the
      administrator must connect to it with a VNC client. GNOME has
      <command>vinagre</command> and <command>remmina</command> for that,
      while the KDE project provides <command>krdc</command> (in the menu at
      <menuchoice> <guimenu>K</guimenu> <guisubmenu>Internet</guisubmenu>
      <guimenuitem>Remote Desktop Client</guimenuitem></menuchoice>). There
      are other VNC clients that use the command line, such as
      <command>xvnc4viewer</command> in the Debian package of the same
      name. Once connected, the administrator can see what is going on, work
      on the machine remotely, and show the user how to proceed.</para>

      <sidebar>
        <title><emphasis>SECURITY</emphasis> VNC over SSH</title>
        <indexterm><primary>SSH トンネル</primary><secondary>VNC</secondary></indexterm>

	<para>VNC で接続したいけれども、データを平文でネットワークに流したくない場合、SSH トンネルでデータをカプセル化することが可能です (<xref linkend="sect.ssh-port-forwarding" />を参照してください)。この時知っておかなければいけない点は、デフォルトで VNC は最初の画面 (「localhost:0」と呼ばれます) にポート 5900 番、2 番目の画面 (「localhost:1」と呼ばれます) にポート 5901 番を使うという点だけです。</para>

	<para><command>ssh -L localhost:5901:localhost:5900 -N -T <replaceable>machine</replaceable></command> コマンドを使うことで、localhost インターフェースのポート 5901 番と <replaceable>machine</replaceable> のポート 5900 番の間にトンネルが作られます。最初の「localhost」はローカルのインターフェースのみをリッスンするように SSH を制限します。2 番目の「localhost」は「localhost:5901」に入ってきたネットワークトラフィックを受け取るリモート側のインターフェースを表します。そんなわけで、<command>vncviewer localhost:1</command> はローカルの名前を使っているにも関わらず VNC クライアントをリモートの画面に接続します。</para>

	<para>VNC セッションを閉じたら、対応する SSH セッションを終了してトンネルを閉じることも忘れないでください。</para>
      </sidebar>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> ディスプレイマネージャ</title>
        <indexterm><primary><command>gdm3</command></primary></indexterm>
        <indexterm><primary><command>kdm</command></primary></indexterm>
        <indexterm><primary><command>xdm</command></primary></indexterm>
        <indexterm><primary><command>lightdm</command></primary></indexterm>
        <indexterm><primary>マネージャ</primary><secondary>ディスプレイマネージャ</secondary></indexterm>
        <indexterm><primary>ディスプレイマネージャ</primary></indexterm>

	<para><command>gdm3</command>、<command>kdm</command>、<command>lightdm</command>、<command>xdm</command> はディスプレイマネージャです。ディスプレイマネージャは起動直後にログイン画面をユーザに提供する目的でグラフィカルインターフェースを制御します。ユーザがログインしたら、ディスプレイマネージャはグラフィカルの作業セッションを始めるために必要なプログラムを実行します。</para>
      </sidebar>

      <para>また、モバイルユーザや会社幹部のような自分が仕事場で使っているのとよく似たリモートデスクトップにアクセスするために時々自宅からログインする必要があるユーザにとって、VNC は都合の良いものです。そのようなサービス用の設定はより複雑です。具体的に言えば、管理者は最初に <emphasis role="pkg">vnc4server</emphasis> パッケージをインストールし、<literal>XDMCP Query</literal> 要求を受け入れるようにディスプレイマネージャの設定を変更し (<command>gdm3</command> の場合、<filename>/etc/gdm3/daemon.conf</filename> の「xdmcp」セクションに <literal>Enable=true</literal> を追加し)、そして最後に <command>inetd</command> を使って VNC サーバを起動するように設定します。こうすることで、ユーザがログインを試行したらセッションが自動的に開始されるようになります。たとえば、以下の行を <filename>/etc/inetd.conf</filename> に追加します。</para>

      <programlisting>5950  stream  tcp  nowait  nobody.tty  /usr/bin/Xvnc Xvnc -inetd -query localhost -once -geometry 1024x768 -depth 16 securitytypes=none</programlisting>

      <para>入ってくる接続をディスプレイマネージャに転送することにより、認証の問題が解決されます。なぜなら、ローカルアカウントを持つユーザだけが <command>gdm3</command> (または同等の <command>kdm</command>、<command>xdm</command> など) のログイン画面を突破できるからです。このやり方は (サーバの性能が十分高いなら) なんの問題もなく複数の同時ログインを許すため、完全なデスクトップをモバイルユーザに対して (またはシンクライアントとして設定された非力なデスクトップシステムに対して) 提供するという用途にも応用できます。ユーザは単純に <command>vncviewer <replaceable>server</replaceable>:50</command> でサーバの画面にログインするだけです。なぜなら、使われているポートは 5950 番だからです。</para>
      <indexterm><primary><emphasis role="pkg">vnc4server</emphasis></primary></indexterm>
    </section>
  </section>
  <section id="sect.rights-management">
    <title>権限の管理</title>

    <para>Linux は完全なマルチユーザシステムです。このため、ユーザの権限に基づいてファイルやディレクトリに対する操作を制御するためにパーミッションシステムを提供することが必要です。このパーミッションシステムはすべてのシステムリソースとデバイスに対して適用されます (Unix システムではすべてのデバイスはファイルまたはディレクトリとして表現されます)。この原理はすべての Unix システムで共通ですが、特に興味深く比較的知られていない上級の使い方があるので、注意は常に必要です。</para>
    <indexterm><primary>権限</primary></indexterm>
    <indexterm><primary>パーミッション</primary></indexterm>
    <indexterm><primary>ユーザ</primary><secondary>所有者</secondary></indexterm>
    <indexterm><primary>グループ</primary><secondary>所有者</secondary></indexterm>
    <indexterm><primary>所有者</primary><secondary>ユーザ</secondary></indexterm>
    <indexterm><primary>所有者</primary><secondary>グループ</secondary></indexterm>

    <para>ファイルとディレクトリには 3 種類のユーザ別に特定のパーミッションが付けられます。以下に 3 種類のユーザを挙げます。</para>
    <itemizedlist>
      <listitem>
	<para>所有者 (「user」の <literal>u</literal> で表記されます)。</para>
      </listitem>
      <listitem>
	<para>所有グループ (「group」の <literal>g</literal> で表記されます)。これはグループに所属する全ユーザを意味しています。</para>
      </listitem>
      <listitem>
	<para>その他 (「other」の <literal>o</literal> で表記されます)。</para>
      </listitem>
    </itemizedlist>

    <para>3 種類の権限は組み合わせて使うことが可能です。以下に 3 種類の権限を挙げます。</para>
    <itemizedlist>
      <listitem>
	<para>読み込み (「read」の <literal>r</literal> で表記されます)。</para>
      </listitem>
      <listitem>
	<para>書き込み (または変更。「write」の <literal>w</literal> で表記されます)。</para>
      </listitem>
      <listitem>
	<para>実行 (「eXecute」の <literal>x</literal> で表記されます)。</para>
      </listitem>
    </itemizedlist>
    <indexterm><primary>読み込み、権限</primary></indexterm>
    <indexterm><primary>書き込み、権限</primary></indexterm>
    <indexterm><primary>変更、権限</primary></indexterm>
    <indexterm><primary>実行、権限</primary></indexterm>

    <para>ファイルの場合、これらの権限は簡単に理解できます。すなわち、読み込み権限があれば、内容を読むことが可能です (コピーも可能です)。書き込み権限があれば、内容を変更することが可能です。実行権限があれば、内容を実行することが可能です (実行権限に意味があるのは対象がプログラムの場合に限ります)。</para>

    <sidebar>
      <title><emphasis>SECURITY</emphasis> <literal>setuid</literal> と <literal>setgid</literal> 実行ファイル</title>

      <para><literal>setuid</literal> と <literal>setgid</literal> (「s」で表記されます) は実行ファイルに関係する 2 種類の特別な権限です。<literal>setuid</literal> と <literal>setgid</literal> は 0 か 1 で表されるブール値のため、「ビット」と呼ばれることが多い点に注意してください。<literal>setuid</literal> および <literal>setgid</literal> 権限を使うと、実行されたプログラムは所有者および所有グループの権限で動くことになります。このメカニズムを使うと、プログラムはプログラムを実行したユーザが通常持っているよりも高位のパーミッションを要求する機能にアクセスできるようになります。</para>
      <indexterm><primary><literal>setuid</literal>、権限</primary></indexterm>
      <indexterm><primary><literal>setgid</literal>、権限</primary></indexterm>

      <para>root が所有者の <literal>setuid</literal> されたプログラムは一貫してスーパーユーザとして実行されるため、この種のプログラムが安全で信頼できるプログラムか否かという点はとても重要です。実際、好きなコマンドを呼び出すために root が所有者の <literal>setuid</literal> されたプログラムを破壊することで、ユーザは root ユーザになりすまし、システムのすべての権限を掌握することが可能です。</para>
    </sidebar>

    <para>ディレクトリは別のやり方で取り扱われます。読み込み権限があれば、そのエントリ (ファイルとディレクトリ) のリストを閲覧することが可能です。書き込み権限があれば、ファイルを作成および削除することが可能です。実行権限があれば、そのディレクトリを横断することが可能です (<command>cd</command> コマンドでそのディレクトリに移動できます)。ディレクトリの読み込み権限がなくてもディレクトリを横断できるならば、ディレクトリ内の名前を知っているエントリにアクセスすることが可能です。ただし、エントリの存在を知らないかエントリの完全な名前を知らない場合、そのエントリを見つけることはできません。</para>

    <sidebar id="sidebar.setgid-dir">
      <title><emphasis>SECURITY</emphasis> <literal>setgid</literal> ディレクトリと<emphasis>スティッキービット</emphasis></title>
      <indexterm><primary><literal>setgid</literal> ディレクトリ</primary></indexterm>

      <para><literal>setgid</literal> ビットはディレクトリにも適用されます。<literal>setgid</literal> ビットが適用されたディレクトリの中に新しく作成されたアイテムは、作成者のメイングループを継承するのではなく、自動的に親ディレクトリの所有グループを割り当てられます。こうすることで、ユーザが同じ専用グループに所属する複数のユーザの間で共有されているファイルツリーの中で作業をしている場合、(<command>newgrp</command> コマンドを使って) 自分のメイングループを変更する必要がなくなります。</para>
      <indexterm><primary>スティッキービット</primary></indexterm>

      <para>「スティッキー」ビット (「t」で表記されます) とはディレクトリだけに有効なパーミッションです。これは特に誰もが書き込み権限を持つ一時ディレクトリ (<filename>/tmp/</filename> など) に使われます。すなわち、スティッキービットを付けられたディレクトリ以下に含まれるファイルの削除を制限できます。ファイルは所有者 (または親ディレクトリの所有者) だけが削除できるようになります。<filename>/tmp/</filename> にスティッキービットがなければ、<filename>/tmp/</filename> ディレクトリ以下にある他のユーザのファイルを誰でも削除できることになります。</para>
    </sidebar>

    <para>以下はファイルのパーミッションを制御する 3 種類のコマンドです。</para>
    <itemizedlist>
      <listitem>
	<para><command>chown <replaceable>user</replaceable> <replaceable>file</replaceable></command>。これはファイルの所有者を変更します。</para>
      </listitem>
      <listitem>
	<para><command>chgrp <replaceable>group</replaceable> <replaceable>file</replaceable></command>。これはファイルの所有グループを変更します。</para>
      </listitem>
      <listitem>
	<para><command>chmod <replaceable>rights</replaceable> <replaceable>file</replaceable></command>。これはファイルのパーミッションを変更します。</para>
      </listitem>
    </itemizedlist>

    <para>権限の指定方法には 2 種類あります。それらの中でも、記号指定が最もわかりやすく覚えやすいでしょう。これは上で述べた文字記号を使います。ユーザのカテゴリ (<literal>u</literal>/<literal>g</literal>/<literal>o</literal>) に対する権限を (<literal>=</literal> で) 明示したり、(<literal>+</literal> で) 追加したり、(<literal>-</literal> で) 取り除いたりできます。そんなわけで、<literal>u=rwx,g+rw,o-r</literal> 式は、所有者に読み込み、書き込み、実行権限を与え、所有グループに読み込み、書き込み権限を追加し、その他のユーザから読み込み権限を奪います。追加と削除によって変更されない権限はそのままです。「all」を意味する文字 <literal>a</literal> は 3 つのユーザカテゴリすべてを表現します。このため、<literal>a=rx</literal> はすべてのカテゴリのユーザに対して同じ権限を与えます (読み込みと実行権限を与え、書き込み権限を与えません)。</para>
    <indexterm><primary><command>chmod</command></primary></indexterm>
    <indexterm><primary><command>chown</command></primary></indexterm>
    <indexterm><primary><command>chgrp</command></primary></indexterm>
    <indexterm><primary>権限の 8 進数表記</primary></indexterm>
    <indexterm><primary>権限</primary><secondary>8 進数表記</secondary></indexterm>

    <para>数値表記は各権限を値 (8 進数) で表現します。具体的に言えば、読み込みは 4、書き込みは 2、実行権限は 1 で表現します。権限を組み合わせるには組み合わせたい権限に対応する数字を合計します。ユーザの各カテゴリ (所有者、グループ、その他) に対して与える権限を同じ順番で連結して、それぞれの権限を表現します。</para>

    <para>たとえば、<command>chmod 754 <replaceable>file</replaceable></command> コマンドは以下の権限を設定します。すなわち、所有者に書き込み、読み込み、実行権限を設定し (7 = 4 + 2 + 1 なので)、さらに所有グループに読み込み、実行権限を設定し (5 = 4 + 1 なので)、さらにその他のユーザに読み込み権限を設定します。<literal>0</literal> はいかなる権限も与えないことを意味します。このため <command>chmod 600 <replaceable>file</replaceable></command> は所有者に読み込み、書き込み権限を設定し、所有者以外のユーザにはいかなる権限も与えません。最もよく使われる権限の組み合わせは、実行ファイルやディレクトリの場合 <literal>755</literal> で、データファイルの場合 <literal>644</literal> です。</para>

    <para>同じ原則に従って特別な権限を表す 4 番目の桁は先に説明した 3 桁の権限表記の前に付けます。<literal>setuid</literal>、<literal>setgid</literal>、<literal>sticky</literal> ビットがそれぞれ 4、2、1 に対応します。<command>chmod 4754</command> は前に説明した権限に加えて、<literal>setuid</literal> ビットを設定します。</para>

    <para>8 進数表記で権限を指定すると、対象のファイルに対するすべての権限が同じものに設定されます。すなわち、たとえば所有グループに読み込み権限を与えるなどの新しい権限を追加したい場合、8 進数表記は使えません。なぜなら、既に設定されている権限を考慮した新しい権限の数値表記が対象のファイルすべてで同じ数値表記になるとは限らないからです。</para>

    <sidebar>
      <title><emphasis>TIP</emphasis> 再帰的操作</title>

      <para>しばしばファイルツリー全体の権限を変更しなければいけない場合があります。<command>chown</command>、<command>chgrp</command>、<command>chmod</command> には、サブディレクトリ内で再帰的に操作を行うための <literal>-R</literal> オプションが用意されています。</para>

      <para>再帰的な操作を行う場合、ディレクトリとファイルの違いが原因で時々問題が起こることがあります。このため、「X」文字が権限の記号表記に導入されました。「X」文字はディレクトリ (と誰かが実行権限を持つファイル) だけに適用される実行権限を表します。このため、<command>chmod -R a+X <replaceable>directory</replaceable></command> は、すべてのサブディレクトリと少なくとも 1 つのカテゴリのユーザ (所有者、所有グループ、その他のユーザのうちの誰か一人) が既に実行権限を持っているすべてのファイルに対して、すべてのカテゴリのユーザ (<literal>a</literal>) の実行権限を追加します。</para>
    </sidebar>

    <sidebar>
      <title><emphasis>TIP</emphasis> ユーザとグループの変更</title>

      <para>しばしば、ファイルのグループと所有者を同時に変更したい場合があります。この用途向けに <command>chown</command> コマンドには特別な構文があります。具体的に言えば、<command>chown <replaceable>user</replaceable>:<replaceable>group</replaceable> <replaceable>file</replaceable></command> です。</para>
    </sidebar>

    <sidebar>
      <title><emphasis>GOING FURTHER</emphasis> <command>umask</command></title>

      <para>アプリケーションがファイルを作成する際、ファイルには目安となるパーミッションが割り当てられます。このパーミッションは <command>umask</command> コマンドで表示される特定の権限を削除したパーミッションです。シェルで <command>umask</command> を実行すると、<computeroutput>0022</computeroutput> などのマスクが表示されます。これは権限の単純な 8 進数表記で、これで表される権限が体系的に削除されます (<computeroutput>0022</computeroutput> の場合、所有グループとその他のユーザに対する書き込み権限が削除されます)。</para>
      <indexterm><primary>umask</primary></indexterm>
      <indexterm><primary>権限</primary><secondary>マスク</secondary></indexterm>
      <indexterm><primary>マスク</primary><secondary>権限マスク</secondary></indexterm>

      <para>新しい 8 進数値でマスクを再設定したければ、<command>umask</command> コマンドでマスクを変更できます。シェル初期化ファイル (たとえば、<filename>~/.bash_profile</filename>) の中で <command>umask</command> コマンドを使った場合、作業セッション内で有効なデフォルトのマスクを変更します。</para>
    </sidebar>
  </section>
  <section id="sect.administration-interfaces">
    <title>管理インターフェース</title>
    <indexterm><primary>インターフェース</primary><secondary>管理インターフェース</secondary></indexterm>
    <indexterm><primary>管理、インターフェース</primary></indexterm>

    <para>管理にグラフィカルインターフェースを使うことはさまざまな状況で興味深いです。管理者はすべてのサービスのすべての設定の詳細を知る必要はありませんし、常に問題に関連する文書を探し出すための時間があるというわけでもありません。管理用のグラフィカルインターフェースを使うと、新しいサービスを素早く配備できるようになります。さらに、設定の難しいサービスのセットアップを単純に行うことが可能です。</para>

    <para>グラフィカルインターフェースは補助でしかなく、インターフェース自身は目的ではありません。どんな場合でも管理者は、さまざまな潜在的問題を理解して対処するために、サービスの挙動に精通しなければいけません。</para>

    <para>どんなインターフェースも完璧ではありませんから、さまざまなインターフェースを試したくなるかもしれません。これは可能な限り避けるべきです。なぜなら、ツールが違えばそのやり方に互換性がないこともあるからです。すべてのツールが高い柔軟性を持つことを心がけ、特定の設定ファイルを基準に選ぼうとしている場合であっても、あるツールが自分以外のツールによって行われた変更を必ず統合できるとは限りません。</para>
    <section id="sect.webmin">
      <title>ウェブインターフェースを使った管理、<command>webmin</command></title>
      <indexterm><primary><emphasis>webmin</emphasis></primary></indexterm>

      <para><command>webmin</command> が最も成功した管理インターフェースの 1 つであることは間違いないでしょう。<command>webmin</command> はウェブブラウザを介したモジュールシステムで、幅広い領域とツールをカバーしています。さらに、<command>webmin</command> は国際化されており、多くの言語で利用できます。</para>

      <para>残念なことに、<command>webmin</command> はもはや Debian に含まれません。<command>webmin</command> の Debian メンテナを務めていた Jaldhar H. Vyas は自分の作ったパッケージを削除しました。なぜなら、彼にはもはや品質合格基準に達するだけの品質でメンテナンス作業を行うのに必要な時間がなかったからです。公式にパッケージを引き継ぐ人がいなかったため、<emphasis role="distribution">Jessie</emphasis> には <command>webmin</command> パッケージが含まれません。</para>

      <para>しかしながら、非公式パッケージが <literal>webmin.com</literal> ウェブサイトから配布されています。元の Debian パッケージと異なり、このパッケージは柔軟性に欠けています。さらに対応するサービスがマシンにインストールされているか否かに関わらず、すべての設定モジュールがインストールされデフォルトで有効化されます。</para>

      <sidebar>
        <title><emphasis>SECURITY</emphasis> <command>webmin</command> の root パスワードの変更</title>

	<para><command>webmin</command> の管理インターフェースに初めてログインする際には、root というユーザ名とサーバの root のパスワードを使って身分証明します。そして可能な限り早く <command>webmin</command> の root パスワードをサーバの root パスワードと違うものにしておくことを推奨します。なぜなら、たとえ <command>webmin</command> の root パスワードを使うことでサーバに対する重要な管理上の権限が必要な操作が可能になるとしても、両者を違うものにしておけば <command>webmin</command> が不正アクセスを受けた場合でもサーバの root パスワードを守ることが可能だからです。</para>

	<para>注意してください! <command>webmin</command> は多くの機能を持っていますから、悪意あるユーザが <command>webmin</command> を使って全システムのセキュリティを侵害することが可能です。一般に、この種のインターフェースを強固なセキュリティを要求される重要なシステム (ファイアウォール、外部向けサーバなど) で使うのは推奨されません。</para>
      </sidebar>

      <para>webmin はウェブインターフェースを介して使われますが、Apache をインストールする必要はありません。元から webmin には統合された小さなウェブサーバが含まれています。このサーバはデフォルトでポート 10000 番をリッスンし、安全な HTTP 接続を受け入れます。</para>

      <para><command>webmin</command> に導入されているモジュールは多種多様なサービスをカバーしています。たとえば以下はそのリストです。</para>
      <itemizedlist>
        <listitem>
	  <para>すべての基盤サービス。このモジュールはユーザとグループの作成、<filename>crontab</filename> ファイルの管理、init スクリプト、ログの閲覧などを担当します。</para>
        </listitem>
        <listitem>
	  <para>bind。このモジュールは DNS サーバの設定 (ネームサービス) を担当します。</para>
        </listitem>
        <listitem>
	  <para>postfix。このモジュールは SMTP サーバの設定 (電子メール) を担当します。</para>
        </listitem>
        <listitem>
	  <para>inetd。このモジュールは <command>inetd</command> スーパーサーバの設定を担当します。</para>
        </listitem>
        <listitem>
	  <para>quota。このモジュールはユーザクォータの管理を担当します。</para>
        </listitem>
        <listitem>
	  <para>dhcpd。このモジュールは DHCP サーバの設定を担当します。</para>
        </listitem>
        <listitem>
	  <para>proftpd。このモジュールは FTP サーバの設定を担当します。</para>
        </listitem>
        <listitem>
	  <para>samba。このモジュールは Samba ファイルサーバの設定を担当します。</para>
        </listitem>
        <listitem>
	  <para>ソフトウェア。このモジュールは Debian パッケージを使ったソフトウェアのインストールと削除およびシステム更新を担当します。</para>
        </listitem>
      </itemizedlist>

      <para>ウェブブラウザで <literal>https://localhost:10000</literal> にアクセスすれば管理インターフェースを使えます。注意してください! すべてのモジュールがすぐに使えるわけではありません。対応する設定ファイルと一部の実行ファイル (プログラム) の場所を指定して、モジュールを設定しなければいけない場合もあります。webmin システムが要求されたモジュールの有効化に失敗した場合、webmin システムは丁寧な指示を表示するでしょう。</para>

      <sidebar>
        <title><emphasis>ALTERNATIVE</emphasis> GNOME コントロールセンター</title>
        <indexterm><primary><emphasis role="pkg">gnome-control-center</emphasis></primary></indexterm>

	<para>GNOME プロジェクトは、通常右上に位置するシステムメニューの「設定」エントリから利用できる、複数の管理インターフェースを提供します。<command>gnome-control-center</command> は複数の管理インターフェースをひとまとめにしたメインプログラムですが、システム共通設定ツールの多くは他のパッケージによって提供されています (たとえば <emphasis role="pkg">accountsservice</emphasis>、<emphasis role="pkg">system-config-printer</emphasis> などが提供されています)。これらのアプリケーションは使いやすいのですが、基盤サービスの一部だけしかカバーされません。たとえば、ユーザ管理、時間設定、ネットワーク設定、プリンタ設定などがカバーされます。</para>
      </sidebar>
    </section>
    <section id="sect.debconf">
      <title>パッケージの設定、<command>debconf</command></title>
      <indexterm><primary><command>debconf</command></primary></indexterm>
      <indexterm><primary><command>dpkg-reconfigure</command></primary></indexterm>

      <para>多くのパッケージが、インストール中 Debconf ツールを使ってわずかな質問をした後に、自動的に設定されるようになっています。この種のパッケージは <command>dpkg-reconfigure <replaceable>package</replaceable></command> を実行すれば再設定できます。</para>

      <para>多くの場合、これらの設定はとても簡素です。すなわち、設定ファイル中のわずかな重要変数だけが変更されます。これらの重要変数は多くの場合 2 つの「境界」線で挟まれています。そうすれば、パッケージを再設定する際に影響をおよぼす箇所を境界線で挟まれた範囲だけに限定できるからです。「境界」線で挟まれていない場合、スクリプトが手作業で設定ファイルが変更されたことを検出したら、人間による設定変更を上書きしないよう、再設定しても何も変更されません (なぜなら、スクリプトは自分の修正が既存の設定を破壊しないことを保証できないからです)。</para>

      <sidebar>
        <title><emphasis>DEBIAN POLICY</emphasis> 変更の保存</title>

	<para>Debian ポリシーには、スクリプトは設定ファイルに対して行われた手作業の変更を保護するように作業を実行しなければいけないことが明確に規定されています。このため、ますます多くのスクリプトが設定ファイルを編集する際に事前注意を出します。一般的な原則は単純です。すなわち、スクリプトが修正を行うのは、設定ファイルの状態を検証して、修正しても問題ないと判断した場合だけです。設定ファイルの状態検証は、最後に自動的に生成された設定ファイルのチェックサムと現在の設定ファイルのチェックサムを比較することで行います。両者のチェックサムが同じ場合、スクリプトは設定ファイルを変更する権限を与えられます。チェックサムが違った場合、設定ファイルが変更されたと判断し、対応 (新しいファイルをインストールする、古いファイルを保存する、新しい変更を既存のファイルと統合しようとする) を尋ねます。この事前注意の原則は長きにわたり Debian に固有の原則でしたが、他のディストリビューションでも徐々にこの原則が採用され始めています。</para>

	<para><command>ucf</command> プログラム (同名の Debian パッケージに含まれます) はこの原則を実行に移すために使われます。</para>
        <indexterm><primary><command>ucf</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.syslog">
    <title><command>syslog</command> システムイベント</title>
    <indexterm><primary><command>rsyslogd</command></primary></indexterm>
    <indexterm><primary>ファイル</primary><secondary>ログファイル</secondary></indexterm>
    <indexterm><primary>ログ</primary><secondary>配送</secondary></indexterm>
    <section id="sect.syslog-principe">
      <title>原理とメカニズム</title>

      <para><command>rsyslogd</command> デーモンはアプリケーションおよびカーネルからのサービスメッセージの収集を担当し、サービスメッセージをログファイルに配送します (通常 <filename>/var/log/</filename> ディレクトリに保存します)。<command>rsyslogd</command> デーモンは <filename>/etc/rsyslog.conf</filename> ファイルの設定に従います。</para>

      <para>各ログメッセージはアプリケーションサブシステム (文書中では「facility」と呼ばれます) に関連付けられます。</para>
      <itemizedlist>
        <listitem>
	  <para><literal>auth</literal> と <literal>authpriv</literal>。認証に関連するメッセージです。</para>
        </listitem>
        <listitem>
	  <para><literal>cron</literal>。タスクスケジューリングサービスである <command>cron</command> と <command>atd</command> から受け取ったメッセージです。</para>
        </listitem>
        <listitem>
	  <para><literal>daemon</literal>。特に分類されていないデーモン (DNS、NTP など) から受け取ったメッセージです。</para>
        </listitem>
        <listitem>
	  <para><literal>ftp</literal>。FTP サーバから受け取ったメッセージです。</para>
        </listitem>
        <listitem>
	  <para><literal>kern</literal>。カーネルから受け取ったメッセージです。</para>
        </listitem>
        <listitem>
	  <para><literal>lpr</literal>。印刷サブシステムから受け取ったメッセージです。</para>
        </listitem>
        <listitem>
	  <para><literal>mail</literal>。電子メールサブシステムから受け取ったメッセージです。</para>
        </listitem>
        <listitem>
	  <para><literal>news</literal>。Usenet サブシステム (特にニュースグループを管理する NNTP (Network News Transfer Protocol) サーバ) から受け取ったメッセージです。</para>
        </listitem>
        <listitem>
	  <para><literal>syslog</literal>。<command>syslogd</command> サーバ (自分) から受け取ったメッセージです。</para>
        </listitem>
        <listitem>
	  <para><literal>user</literal>。ユーザメッセージ (一般的なメッセージ) に関連するメッセージです。</para>
        </listitem>
        <listitem>
	  <para><literal>uucp</literal>。UUCP (Unix to Unix Copy Program、とりわけ昔は電子メールメッセージの配送に使われていた古いプロトコル) サーバから受け取ったメッセージです。</para>
        </listitem>
        <listitem>
	  <para><literal>local0</literal> から <literal>local7</literal>。ローカル利用向けに予約されているサブシステムから受け取ったメッセージです。</para>
        </listitem>
      </itemizedlist>

      <para>さらに各メッセージは優先度と関連付けられます。以下は優先度の高い順に挙げたリストです。</para>
      <itemizedlist>
        <listitem>
	  <para><literal>emerg</literal>。システムが「助けてください!」と言っていることを示しています。これは非常事態で、おそらくシステムが不安定になっていることを示しています。</para>
        </listitem>
        <listitem>
	  <para><literal>alert</literal>。システムが大至急対応を必要としており、遅れると危険な状態になることを示しています。この場合、すぐに何らかの措置を講じてください。</para>
        </listitem>
        <listitem>
	  <para><literal>crit</literal>。システムが危機的状態に陥っていることを示しています。</para>
        </listitem>
        <listitem>
	  <para><literal>err</literal>。システムにエラーが発生していることを示しています。</para>
        </listitem>
        <listitem>
	  <para><literal>warn</literal>。システムが警告 (潜在的エラー) を発していることを示しています。</para>
        </listitem>
        <listitem>
	  <para><literal>notice</literal>。システムが正常な状態とは言うものの、重要なメッセージを発していることを示しています。</para>
        </listitem>
        <listitem>
	  <para><literal>info</literal>。システムが有益なメッセージを発していることを示しています。</para>
        </listitem>
        <listitem>
	  <para><literal>debug</literal>。システムがデバッグメッセージを発していることを示しています。</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="sect.syslog-config">
      <title>設定ファイル</title>

      <para><filename>/etc/rsyslog.conf</filename> ファイルの構文は <citerefentry><refentrytitle>rsyslog.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> マニュアルページで詳しく説明されています。しかし、<emphasis role="pkg">rsyslog-doc</emphasis> パッケージから提供される HTML 文書 (<filename>/usr/share/doc/rsyslog-doc/html/index.html</filename>) も利用できます。全般的な原則は「セレクタ」と「アクション」の組を書くことです。セレクタはすべての関連するメッセージを定義し、アクションはそれらのメッセージをどのように取り扱うかを定義します。</para>
      <section id="sect.syslog-selector-syntax">
        <title>セレクタの構文</title>

	<para>セレクタは <literal><replaceable>subsystem</replaceable>.<replaceable>priority</replaceable></literal> の組からなるセミコロン区切りリストです (たとえば <literal>auth.notice;mail.info</literal> などです)。アスタリスクはすべてのサブシステムまたはすべての優先度を表します (たとえば <literal>*.alert</literal>、<literal>mail.*</literal> などのように使います)。コンマで区切れば複数のサブシステムをグループ化することが可能です (たとえば <literal>auth,mail.info</literal> などのように使います)。優先度は指定した優先度と同じかより高い優先度を持つメッセージを意味しています。このため <literal>auth.alert</literal> は <literal>alert</literal> および <literal>emerg</literal> 優先度を持つ <literal>auth</literal> サブシステムメッセージを表現します。優先度の前に感嘆符 (!) を付けると否定を表します。言い換えれば、その優先度より低い優先度です。このため <literal>auth.!notice</literal> は <literal>auth</literal> サブシステムメッセージの内 <literal>info</literal> および <literal>debug</literal> 優先度を持つメッセージを表現します。優先度の前に等号 (=) を付けると、指定した優先度だけを表します (<literal>auth.=notice</literal> は <literal>auth</literal> サブシステムメッセージの内 <literal>notice</literal> 優先度を持つメッセージを表現します)。</para>

	<para>セレクタリスト内の各要素は前の要素を上書きします。このため、セレクタリストからある組を制限したり、特定の要素だけを除外することが可能です。たとえば、<literal>kern.info;kern.!err</literal> はカーネルから受け取った <literal>info</literal> 以上 <literal>warn</literal> 以下の優先度を持つメッセージを意味します。<literal>none</literal> 優先度は空の組を意味し (優先度を指定しないことを意味し)、あるサブシステムだけをメッセージの組から除外するのに役立つかもしれません。そんなわけで、<literal>*.crit;kern.none</literal> はカーネルから受け取った <literal>crit</literal> 以上の優先度を持つメッセージを意味します。</para>
      </section>
      <section id="sect.syslog-action-syntax">
        <title>アクションの構文</title>

        <sidebar>
          <title><emphasis>BACK TO BASICS</emphasis> 名前付きパイプ、永続的なパイプ</title>
          <indexterm><primary>名前付きパイプ</primary></indexterm>
          <indexterm><primary>パイプ、名前付きパイプ</primary></indexterm>

	  <para>名前付きパイプは特殊なファイル型で、古典的なパイプ (コマンドラインで「|」文字を使って表すパイプ) のように振る舞いますが、ファイルを経由します。名前付きパイプのメカニズムは 2 つの別々のプロセスを関連付けることが可能という利点を持っています。別のプロセスが名前付きパイプに書き込まれるデータを読む準備を整えるまで、名前付きパイプに書き込むプロセスはブロックされます。読み込み側のプロセスが書き込み側のプロセスの書き込んだデータを読み込むと、書き込み側のプロセスのブロックが解除されます。</para>

	  <para>名前付きパイプは <command>mkfifo</command> コマンドで作成します。</para>
        </sidebar>

	<para>以下に指定できるさまざまなアクションを挙げます。</para>
        <itemizedlist>
          <listitem>
	    <para>ファイルにメッセージを追記します (たとえば <filename>/var/log/messages</filename> などのように指定します)。</para>
          </listitem>
          <listitem>
	    <para>メッセージをリモートの <command>syslog</command> サーバに送信します (たとえば <literal>@log.falcot.com</literal> などのように指定します)。</para>
          </listitem>
          <listitem>
	    <para>既存の名前付きパイプにメッセージを送信します (たとえば <literal>|/dev/xconsole</literal> などのように指定します)。</para>
          </listitem>
          <listitem>
	    <para>ログイン中の個人または複数人のユーザにメッセージを送信します (たとえば <literal>root,rhertzog</literal> などのように指定します)。</para>
          </listitem>
          <listitem>
	    <para>ログイン中の全ユーザにメッセージを送信します (たとえば <literal>*</literal> などのように指定します)。</para>
          </listitem>
          <listitem>
	    <para>テキストコンソールにメッセージを書き込みます (たとえば <literal>/dev/tty8</literal> などのように指定します)。</para>
          </listitem>
        </itemizedlist>

        <sidebar>
          <title><emphasis>SECURITY</emphasis> ログの転送</title>
          <indexterm><primary>ログ</primary><secondary>転送</secondary></indexterm>

	  <para>最重要のログを別のマシン (ログ記録専用マシン) に記録することは良い考えです。なぜなら、そうすることで侵入者に不正侵入の形跡を削除されないようにすることが可能だからです (形跡を削除するにはもちろん、ログ記録専用の別のマシンに不正アクセスするしかありません)。さらに、深刻な問題 (カーネルクラッシュなど) が起きた場合に、別のマシンにログを記録しておけば、クラッシュを引き起こす一連の出来事を決定できる可能性を増やすことが可能です。</para>

	  <para>他のマシンから送信されたログメッセージを受け入れるには、<emphasis>rsyslog</emphasis> を再設定しなければいけません。具体的に言えば、<filename>/etc/rsyslog.conf</filename> の中ですぐに利用できる状態になっているエントリ (<literal>$ModLoad imudp</literal> と <literal>$UDPServerRun 514</literal>) を有効化するだけで十分です。</para>
        </sidebar>
      </section>
    </section>
  </section>
  <section id="sect.inetd">
    <title><command>inetd</command> スーパーサーバ</title>

    <para>inetd (通常「インターネットスーパーサーバ」と呼ばれます) はサーバのサーバです。inetd は要求に応じてまれに使われるサーバを実行します。そうすれば、まれにしか使われないサーバを常に実行しておく必要がなくなります。</para>
    <indexterm><primary><command>inetd</command></primary></indexterm>
    <indexterm><primary>スーパーサーバ</primary></indexterm>

    <para><filename>/etc/inetd.conf</filename> ファイルには、要求に応じて起動するサーバとサーバの使うポート番号が書かれています。<command>inetd</command> コマンドはここで書かれたすべてのポートをリッスンします。さらに、<command>inetd</command> はポートに対する接続を検出したら、対応するサーバプログラムを実行します。</para>

    <sidebar>
      <title><emphasis>DEBIAN POLICY</emphasis> <filename>inetd.conf</filename> へのサーバの登録</title>

      <para>多くの場合 inetd を使うサーバのパッケージは <filename>/etc/inetd.conf</filename> ファイルに自分を登録することを望むのですが、Debian ポリシーはパッケージが自分の持ち物でない設定ファイルを修正することを禁止しています。このため、<command>update-inetd</command> スクリプト (同名のパッケージに含まれます) が作成されました。すなわち <command>update-inetd</command> スクリプトが設定ファイルを管理し、他のパッケージは <command>update-inetd</command> を使ってスーパーサーバの設定に新しいサーバを登録します。</para>
    </sidebar>

    <para><filename>/etc/inetd.conf</filename> ファイルの有効な各行は (空白で区切られた) 7 つのフィールドで 1 つのサーバを表現します。各フィールドの意味は以下の通りです。</para>
    <itemizedlist>
      <listitem>
	<para>TCP か UDP のポート番号、またはサービス名 (この場合、<filename>/etc/services</filename> ファイルに含まれる情報を使って標準的なポート番号に置換されます)。</para>
      </listitem>
      <listitem>
	<para>ソケットタイプ。このフィールドは TCP 接続の場合 <literal>stream</literal>、UDP データグラムの場合 <literal>dgram</literal> を指定します。</para>
      </listitem>
      <listitem>
	<para>プロトコル。このフィールドは <literal>tcp</literal> または <literal>udp</literal> を指定します。</para>
      </listitem>
      <listitem>
	<para>オプション。このフィールドに指定できる値は <literal>wait</literal> または <literal>nowait</literal> の 2 種類です。これらの値を使って、<command>inetd</command> に対して他の接続を受け入れる前に既に起動中のプロセスの終了を待つ (<literal>wait</literal>) か待たない (<literal>nowait</literal>) かを指定します。簡単に多重送信対応できる TCP 接続の場合、通常 <literal>nowait</literal> を使います。UDP を使って応答するプログラムに対しては、サーバが複数接続の並列化を管理する機能を持っている場合に限り <literal>nowait</literal> を使うべきです。この後にピリオドで区切りながら子プロセスの最大数、さらに 1 分間に認められる接続の最大数 (デフォルトの値は 256) を指定することが可能です。</para>
      </listitem>
      <listitem>
	<para>ユーザ名。サーバはこのユーザの権限で実行されます。</para>
      </listitem>
      <listitem>
	<para>実行するサーバプログラムのフルパス。</para>
      </listitem>
      <listitem>
	<para>引数。このフィールドはプログラムの引数の完全なリストを指定し、サーバプログラムの名前 (C 言語で言えば <literal>argv[0]</literal>) を含みます。</para>
      </listitem>
    </itemizedlist>

    <para>最も一般的な場合、以下の例のようになります。</para>

    <example id="example.inetd-conf">
      <title><filename>/etc/inetd.conf</filename> からの抜粋</title>

      <programlisting>talk   dgram  udp wait    nobody.tty /usr/sbin/in.talkd in.talkd
finger stream tcp nowait  nobody     /usr/sbin/tcpd     in.fingerd
ident  stream tcp nowait  nobody     /usr/sbin/identd   identd -i</programlisting>
    </example>
    <indexterm><primary><command>tcpd</command></primary></indexterm>

    <para><filename>/etc/inetd.conf</filename> ファイルの中では <command>tcpd</command> プログラムを使うことが多いです。<command>tcpd</command> プログラムを使うと、アクセス制御ルールを適用して到着する接続を制限することが可能です。アクセス制御ルールは <citerefentry><refentrytitle>hosts_access</refentrytitle><manvolnum>5</manvolnum></citerefentry> マニュアルページで説明されており、<filename>/etc/hosts.allow</filename> と <filename>/etc/hosts.deny</filename> ファイルの中で設定されます。<command>tcpd</command> は接続を確認し、認証が済んだら実際のサーバを実行します (以下の例では <command>in.fingerd</command> を実行しています)。<command>tcpd</command> はそれが実行された時の名前 (1 番目の引数 <literal>argv[0]</literal>) を頼りに実際に実行するプログラムを識別します。この点に注意してください。そのため、引数リストは <literal>tcpd</literal> で始めるのではなく、ラップされなければいけないプログラムの名前で始めるべきです。</para>

    <sidebar>
      <title><emphasis>COMMUNITY</emphasis> Wietse Venema</title>
      <indexterm><primary>Wietse Venema</primary></indexterm>
      <indexterm><primary>Venema, Wietse</primary></indexterm>

      <para>Wietse Venema は <command>tcpd</command> プログラムの作者で、セキュリティ分野における専門知識によって名を挙げたプログラマです。彼はまた Postfix の主な創案者でもあります。Postfix はモジュール式電子メールサーバ (SMTP、Simple Mail Transfer Protocol) で、セキュリティ脆弱性の長い歴史を特徴付ける <command>sendmail</command> よりも安全で信頼性が高くなるように設計されました。</para>
    </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> 他の <command>inetd</command> コマンド</title>

      <para>Debian はデフォルトで <emphasis role="pkg">openbsd-inetd</emphasis> をインストールしますが、他にも数多くの代替品があります。たとえば <emphasis role="pkg">inetutils-inetd</emphasis>、<emphasis role="pkg">micro-inetd</emphasis>、<emphasis role="pkg">rlinetd</emphasis>、<emphasis role="pkg">xinetd</emphasis> などの代替品が存在します。</para>

      <para><emphasis role="pkg">xinetd</emphasis> は大変興味深い機能を持っています。中でも注目すべきは、<emphasis role="pkg">xinetd</emphasis> の設定を複数のファイル (これはもちろん <filename>/etc/xinetd.d/</filename> ディレクトリの中に保存されています) に分割できるという点です。このおかげで、管理がもっと楽になります。</para>

      <para>最後に重要なことですが、<command>systemd</command> のソケット有効化メカニズムを使えば、<command>inetd</command> の挙動をエミュレートすることも可能です (<xref linkend="sect.systemd" />を参照してください)。</para>
    </sidebar>
  </section>
  <section id="sect.task-scheduling-cron-atd">
    <title><command>cron</command> と <command>atd</command> を使ったスケジューリングタスク</title>
    <indexterm><primary><command>cron</command></primary></indexterm>
    <indexterm><primary><command>atd</command></primary></indexterm>
    <indexterm><primary>スケジュールされたコマンド</primary></indexterm>
    <indexterm><primary>コマンドのスケジューリング</primary></indexterm>

    <para><command>cron</command> は定期的に (毎日、毎週など) 実行するよう予定されたコマンドの実行を担当しているデーモンです。また、<command>atd</command> は未来の特定の時間に 1 回だけ実行するよう予定されたコマンドの実行を担当しているデーモンです。</para>

    <para>Unix システムでは、以下に挙げる多くのタスクが定期的に実行されるよう予定されています。</para>
    <itemizedlist>
      <listitem>
	<para>ログの循環。</para>
      </listitem>
      <listitem>
	<para><command>locate</command> プログラムの使うデータベースの更新。</para>
      </listitem>
      <listitem>
	<para>バックアップ。</para>
      </listitem>
      <listitem>
	<para>メンテナンススクリプト (これは一時ファイルの掃除を行うスクリプトなどを指します)。</para>
      </listitem>
    </itemizedlist>

    <para>デフォルトで、すべてのユーザはタスク実行の予定を入れることが可能です。各ユーザは自分専用の <emphasis>crontab</emphasis> を持っており、これを使ってコマンド実行の予定を登録することが可能です。<emphasis>crontab</emphasis> を編集するには <command>crontab -e</command> を実行します (<emphasis>crontab</emphasis> は <filename>/var/spool/cron/crontabs/<replaceable>user</replaceable></filename> ファイルに保存されます)。</para>

    <sidebar>
      <title><emphasis>SECURITY</emphasis> <command>cron</command> または <command>atd</command> の使用制限</title>

      <para>実行を許可するユーザを明示するファイル (ホワイトリスト) <filename>/etc/cron.allow</filename> の中にコマンドの予定を入れることを許可するユーザを書けば、<command>cron</command> へのアクセスを制限することが可能です。その他のユーザは自動的にスケジューリングタスク機能を使えなくなります。反対に、実行を禁止するユーザを明示するファイル (ブラックリスト) <filename>/etc/cron.deny</filename> の中にユーザ名を書けば、1 人か 2 人の問題児だけをブロックすることが可能です。<command>atd</command> に対しても <filename>/etc/at.allow</filename> と <filename>/etc/at.deny</filename> ファイルを使って同等の機能が利用できます。</para>
    </sidebar>

    <para>root ユーザは自分専用の <emphasis>crontab</emphasis> を持っていますが、<filename>/etc/crontab</filename> ファイルを使ったり、追加的な <emphasis>crontab</emphasis> ファイルを <filename>/etc/cron.d</filename> ディレクトリに置くことが可能です。最後の 2 つの解決策には、コマンドを実行するユーザを明示できるという利点があります。</para>

    <para>デフォルトで <emphasis>cron</emphasis> パッケージには、いくつかのスケジュール済みコマンドが含まれています。</para>
    <itemizedlist>
      <listitem>
	<para><filename>/etc/cron.hourly/</filename> ディレクトリ内のプログラムは 1 時間に 1 回実行されます。</para>
      </listitem>
      <listitem>
	<para><filename>/etc/cron.daily/</filename> ディレクトリ内のプログラムは 1 日に 1 回実行されます。</para>
      </listitem>
      <listitem>
	<para><filename>/etc/cron.weekly/</filename> ディレクトリ内のプログラムは 1 週間に 1 回実行されます。</para>
      </listitem>
      <listitem>
	<para><filename>/etc/cron.monthly/</filename> ディレクトリ内のプログラムは 1 カ月に 1 回実行されます。</para>
      </listitem>
    </itemizedlist>

    <para>多くの Debian パッケージは cron のサービスに頼っています。すなわち、メンテナンススクリプトをこれらのディレクトリに入れて、サービスの最適な動作を保証しています。</para>
    <section id="sect.format-crontab">
      <title><filename>crontab</filename> ファイルの書式</title>
      <indexterm><primary><filename>crontab</filename></primary></indexterm>

      <sidebar>
        <title><emphasis>TIP</emphasis> <command>cron</command> のテキストショートカット</title>

	<para><command>cron</command> はいくつかの略語を認識します。略語は <filename>crontab</filename> エントリの最初の 5 つのフィールドを置き換えます。略語は最も古典的なスケジューリングオプションに対応します。</para>
        <itemizedlist>
          <listitem>
	    <para><literal>@yearly</literal>。この略語は 1 年に 1 回 (1 月 1 日の 00:00) を意味しています。</para>
          </listitem>
          <listitem>
	    <para><literal>@monthly</literal>。この略語は 1 カ月に 1 回 (毎月 1 日の 00:00) を意味しています。</para>
          </listitem>
          <listitem>
	    <para><literal>@weekly</literal>。この略語は 1 週間に 1 回 (日曜日の 00:00) を意味しています。</para>
          </listitem>
          <listitem>
	    <para><literal>@daily</literal>。この略語は 1 日 1 回 (00:00) を意味しています。</para>
          </listitem>
          <listitem>
	    <para><literal>@hourly</literal>。この略語は 1 時間に 1 回 (毎時 0 分) を意味しています。</para>
          </listitem>
        </itemizedlist>
      </sidebar>

      <sidebar>
        <title><emphasis>SPECIAL CASE</emphasis> <command>cron</command> と夏時間</title>

	<para>Debian では、<command>cron</command> は可能な限り正確に時刻変化 (夏時間、実質的にはローカル時間の大幅な変更) に追従します。このため、決して存在しない 1 時間内に実行されるべきコマンド (たとえば、フランスで夏時間開始日の午前 2:30 に予定されているタスクです。夏時間に切り替わると標準時の午前 2:00 は夏時間の午後 3:00 になります) は時刻が変わった後すぐに実行されます (つまり夏時間で午前 3:00 頃に実行されます)。一方で、夏時間終了日に複数回実行されると思われるコマンド (夏時間の午前 2:30 とその 1 時間後の標準時の午前 2:30 に予定されているコマンド。標準時に戻ると夏時間の午前 3:00 は標準時の午前 2:00 になります) は 1 回だけ実行されます。</para>

	<para>しかしながら気を付けてください、別にスケジュールされたタスクとの順番とそれぞれのタスク実行間の遅延が重要な問題の場合、それらの制約の互換性と <command>cron</command> の挙動を照合するべきです。必要ならば、夏時間開始日と夏時間終了日の夜専用の特別なスケジュールを用意することも可能です。</para>
      </sidebar>

      <para><emphasis>crontab</emphasis> の有効な各行は以下の 6 つ (または 7 つ) のフィールドを含むスケジュールされたコマンド表します。</para>
      <itemizedlist>
        <listitem>
	  <para>分 (0 から 59 までの数字を指定します)。</para>
        </listitem>
        <listitem>
	  <para>時間 (0 から 23 までの数字を指定します)。</para>
        </listitem>
        <listitem>
	  <para>月の日付 (1 から 31 までの数字を指定します)。</para>
        </listitem>
        <listitem>
	  <para>月 (1 から 12 までの数字を指定します)。</para>
        </listitem>
        <listitem>
	  <para>曜日 (0 から 7 までの数字、月曜日は 1、日曜日は 0 と 7 の両方、さらに英語で書いた曜日の最初の 3 文字 <literal>Sun</literal>、<literal>Mon</literal> などを使うことも可能です)。</para>
        </listitem>
        <listitem>
	  <para>コマンドを実行するユーザ名 (<filename>/etc/crontab</filename> ファイルと <filename>/etc/cron.d/</filename> にある分割されたファイルでは必要ですが、各ユーザ専用のファイルでは不要です)。</para>
        </listitem>
        <listitem>
	  <para>実行するコマンド (最初の 5 つのフィールドで定義された条件が満足されたら実行します)。</para>
        </listitem>
      </itemizedlist>

      <para>すべての詳細は <citerefentry><refentrytitle>crontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> man ページに書かれています。</para>

      <para>各値は設定できる値の (コンマ区切り) リストの形で表現することが可能です。<literal>a-b</literal> 構文は <literal>a</literal> と <literal>b</literal> の間にあるすべての値を表現します。<literal>a-b/c</literal> 構文は <literal>a</literal> から <literal>c</literal> ずつ増加させて <literal>b</literal> までのすべての値を表現します (たとえば <literal>0-10/2</literal> は <literal>0,2,4,6,8,10</literal> を意味します)。アスタリスク <literal>*</literal> はワイルドカードで、とり得るすべての値を意味します。</para>

      <example id="example.crontab">
        <title>単純な <filename>crontab</filename> ファイル</title>

        <programlisting>#フォーマット
#分 時 日付 月 曜日  コマンド

# 毎日深夜午前 7 時 25 分にデータをダウンロード
 25  19   *   *   *    $HOME/bin/get.pl

# 平日 (月曜日から金曜日) 午前 8 時 0 分
 00  08   *   *   1-5  $HOME/bin/dosomething

# 起動直後に IRC プロキシを再始動
@reboot /usr/bin/dircproxy</programlisting>
      </example>

      <sidebar>
        <title><emphasis>TIP</emphasis> 起動時にコマンドを実行</title>

	<para>コンピュータを起動した後に毎回コマンドを実行するためには、<literal>@reboot</literal> マクロを使ってください (<command>cron</command> を単純に再起動しただけでは <literal>@reboot</literal> でスケジュールされたコマンドは実行されません)。<literal>@reboot</literal> マクロを使うには <emphasis>crontab</emphasis> 内の最初の 5 つのフィールドを <literal>@reboot</literal> で置換してください。</para>
      </sidebar>

    <sidebar>
      <title><emphasis>ALTERNATIVE</emphasis> <command>systemd</command> を使った <command>cron</command> のエミュレート</title>

      <para><command>systemd</command> のタイマメカニズムを使えば <command>cron</command> の挙動の一部をエミュレートすることが可能です (<xref linkend="sect.systemd" />を参照してください)。</para>
    </sidebar>

    </section>
    <section id="sect.at-command">
      <title><command>at</command> コマンドの利用</title>
      <indexterm><primary><command>at</command></primary></indexterm>

      <para><command>at</command> は未来の特定の時点にコマンドを実行します。<command>at</command> は時刻と日付をコマンドラインパラメータで受け取り、実行するコマンドを標準入力で受け取ります。<command>at</command> を使って実行予約を登録したコマンドはあたかも <command>at</command> を実行した現在のシェルで実行されたかのように実行されます。<command>at</command> はコマンドを実行する際に現在と同じ状況を再現するために、現在の環境を保存するように気を付けます。時刻は以下のように普通の慣例に従って表現されます。すなわち <literal>16:12</literal> または <literal>4:12pm</literal> は午後 4 時 12 分を意味します。日付はヨーロッパと西洋で使われるいくつかの書式で指定します。<literal>DD.MM.YY</literal> (<literal>27.07.15</literal> は 2015 年 7 月 27 日を意味します)、<literal>YYYY-MM-DD</literal> (<literal>2015-07-27</literal> は上と同じ日付を意味します)、<literal>MM/DD/[CC]YY</literal> (<literal>12/25/15</literal> や <literal>12/25/2015</literal> は 2015 年 12 月 25 日を意味します)、または単純な <literal>MMDD[CC]YY</literal> (<literal>122515</literal> や <literal>12252015</literal> は同様に 2015 年 12 月 25 日を意味します) などです。日付の指定がなければ、コマンドは最も早く到達した指定時刻に実行されます (当日、または指定時刻が既に過ぎていれば明日に実行されます)。読んで字の通り「today」(今日)、「tomorrow」(明日) などと簡単に書くことも可能です。</para>

      <screen>
<computeroutput>$ </computeroutput><userinput>at 09:00 27.07.15 &lt;&lt;END</userinput>
<computeroutput>&gt; </computeroutput><userinput>echo "Don't forget to wish a Happy Birthday to Raphaël!" \</userinput>
<computeroutput>&gt; </computeroutput><userinput>  | mail lolando@debian.org</userinput>
<computeroutput>&gt; </computeroutput><userinput>END</userinput>
<computeroutput>warning: commands will be executed using /bin/sh
job 31 at Mon Jul 27 09:00:00 2015</computeroutput></screen>

      <para>与えられた期間だけ実行を先延ばしにする構文もあります。たとえば <command>at now + <replaceable>number</replaceable> <replaceable>period</replaceable></command> です。<replaceable>period</replaceable> には <literal>minutes</literal>、<literal>hours</literal>、<literal>days</literal>、<literal>weeks</literal> を指定することが可能です。<replaceable>number</replaceable> は単純に <replaceable>period</replaceable> で指定した単位の量を表し、この量だけコマンドの実行が先延ばしされます。</para>

      <para><command>cron</command> でスケジュールされたタスクを中止するには、単純に <command>crontab -e</command> を実行し、<emphasis>crontab</emphasis> ファイルから対応する行を削除してください。<command>at</command> タスクの場合、削除はとても簡単です。すなわち <command>atrm <replaceable>task-number</replaceable></command> を実行してください。タスク番号は <command>at</command> コマンドで予定を登録した際に表示されたものです。もう一度確認するには <command>atq</command> コマンドを実行してください。これはスケジュールされたタスクの現在のリストを表示します。</para>
      <indexterm><primary><command>atrm</command></primary></indexterm>
      <indexterm><primary><command>atq</command></primary></indexterm>
    </section>
  </section>
  <section id="sect.asynchronous-task-scheduling-anacron">
    <title>非同期タスクのスケジューリング、<command>anacron</command></title>

    <para><command>anacron</command> はデーモンで、常に起動されていないコンピュータの <command>cron</command> を完成させるものです。定期的なタスクは通常真夜中に予定されているため、その時間にコンピュータの電源が切れていればタスクは決して実行されません。<command>anacron</command> の目的は、コンピュータの電源が切れている期間を考慮して、その期間中に予定されていたタスクを実行することです。</para>
    <indexterm><primary><command>anacron</command></primary></indexterm>

    <para><command>anacron</command> は通常そのようなタスクをマシンの起動数分後に実行します。このことにより、コンピュータの反応が遅くなります。このため、<filename>/etc/anacrontab</filename> ファイルに載せられたタスクは <command>nice</command> コマンドと一緒に開始されます。こうすることで、タスクの優先度を低くして実行できるので、システムの残りの部分に対する影響を減らすことが可能です。<filename>/etc/anacrontab</filename> ファイルの書式は <filename>/etc/crontab</filename> と異なる点に注意してください。さらに <command>anacron</command> を使う特別な理由がある場合、<citerefentry><refentrytitle>anacrontab</refentrytitle> <manvolnum>5</manvolnum></citerefentry> マニュアルページをご覧ください。</para>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> 実行優先度と <command>nice</command></title>

      <para>Unix システム (および Linux) はマルチタスクのマルチユーザシステムです。実際、複数のプロセスは並行して実行され別のユーザに所有されます。そして、カーネルは異なるプロセス間でリソースへのアクセスを仲介します。このタスクの一部として、カーネルは実行優先度という概念を持ちます。実行優先度に基づき、カーネルは必要に応じてあるプロセスを特別扱いします。あるプログラムを低い優先度で実行しても構わないと分かっている場合、そのプログラムに低い優先度を与えて実行を開始するには <command>nice <replaceable>program</replaceable></command> を使います。<command>nice</command> を使って実行を開始されたプログラムは CPU への負担を低く設定され、他の実行中プロセスに対する影響を低く抑えられるでしょう。もちろん、他に実行中のプロセスがない場合、このプログラムの実行は妨げられません。</para>

      <para><command>nice</command> は「niceness」と呼ばれる優先度と連動します。ここで正の優先度 (1 から 19) は低い優先度、これに対して、負の優先度 (-1 から -20) は高い優先度を意味します。負の (高い) 優先度を使えるのは root だけです。「niceness」を与えなければ (<citerefentry><refentrytitle>nice</refentrytitle> <manvolnum>1</manvolnum></citerefentry> マニュアルページを参照してください)、<command>nice</command> は現在の優先度を正方向に 10 だけ増加します (優先度を下げます)。</para>

      <para>既に実行中のタスクの中に <command>nice</command> で開始するべきプロセスを発見した場合、今からでも優先度を修正することが可能です。<command>renice</command> コマンドは実行中のプロセスの優先度を変更します。優先度を低くすることも高くすることも可能です (ただし、「niceness」を減らす (優先度を高くする) ことができるのは root だけです)。</para>
    </sidebar>

    <para><emphasis role="pkg">anacron</emphasis> パッケージをインストールすることにより、<command>cron</command> は <filename>/etc/cron.hourly/</filename>、<filename>/etc/cron.daily/</filename>、<filename>/etc/cron.weekly/</filename>、<filename>/etc/cron.monthly/</filename> ディレクトリに含まれるスクリプトを実行しなくなります。これは <command>anacron</command> と <command>cron</command> がスクリプトを二重に実行することを避けるためです。<command>cron</command> コマンドはまだ有効で、他のスケジュールされたタスク (特にユーザがスケジュールしたタスク) を取り扱うことが可能です。</para>
  </section>
  <section id="sect.quotas">
    <title>クォータ</title>
    <indexterm><primary>クォータ</primary></indexterm>

    <para>クォータシステムを使うことで、ユーザまたはユーザグループに割り当てられたディスク領域を制限することが可能です。クォータを設定するには、クォータをサポートする (<varname>CONFIG_QUOTA</varname> オプションを有効化してコンパイルされた) カーネルを使わなければいけません。Debian カーネルはクォータをサポートしています。クォータ管理ソフトウェアは <emphasis role="pkg">quota</emphasis> Debian パッケージに含まれています。</para>

    <para>あるファイルシステムでクォータを有効化するには、<filename>/etc/fstab</filename> の中で <literal>usrquota</literal> (ユーザ用クォータ) および <literal>grpquota</literal> (グループ用クォータ) オプションを指定します。この後コンピュータを再起動すると、ディスク活動のない時にクォータが更新されます (これは使用済みディスク領域を適切に計量する必要条件です)。</para>

    <para><command>edquota <replaceable>user</replaceable></command> (または <command>edquota -g <replaceable>group</replaceable></command>) コマンドを使うと、現在のディスク領域使用量を検査している最中に、制限を変更することが可能です。</para>
    <indexterm><primary><command>edquota</command></primary></indexterm>

    <sidebar>
      <title><emphasis>GOING FURTHER</emphasis> スクリプトを使ったクォータの定義</title>
      <indexterm><primary><command>setquota</command></primary></indexterm>

      <para><command>setquota</command> プログラムを使うことで、スクリプトの中で自動的に多くのクォータを変更することが可能です。構文の使い方は <citerefentry><refentrytitle>setquota</refentrytitle> <manvolnum>8</manvolnum></citerefentry> マニュアルページをご覧ください。</para>
    </sidebar>

    <para>クォータシステムを使うと以下の 4 種類の制限を設定することが可能です。</para>
    <itemizedlist>
      <listitem>
	<para>消費ブロック数に対する 2 種類の制限 (「ソフト」と「ハード」と呼ばれます)。もしファイルシステムが 1 キロバイトのブロックサイズで作られた場合、1 ブロックには、あるファイルの 1024 バイト分を入れることが可能です。飽和していないブロックがあると、ディスク領域の損失が生じます。100 ブロックのクォータは理論的には 102,400 バイトを保存できることを意味しますが、500 バイトのファイル 100 個 (合計 50,000 バイト) で上限に達することになります。</para>
      </listitem>
      <listitem>
	<para>i ノード数に対する 2 種類の制限 (ソフトとハード)。各ファイルはファイルの情報 (パーミッション、所有者、最後にアクセスされた時間など) を保存するために少なくとも 1 つの i ノードを専有します。この性質を使うことで、ユーザファイルの数を制限することが可能です。</para>
      </listitem>
    </itemizedlist>

    <para>「ソフト」リミットは一時的に超過できます。しかし、ユーザは <command>warnquota</command> コマンドからクォータを超過していることに対して簡単な警告を受けます。<command>warnquota</command> コマンドは通常 <command>cron</command> コマンドによって呼び出されます。「ハード」リミットは決して超過できません。すなわち、システムはハードクォータを超過するような操作をすべて拒否します。</para>

    <sidebar>
      <title><emphasis>VOCABULARY</emphasis> ブロックと i ノード</title>
      <indexterm><primary>ブロック (ディスク)</primary></indexterm>
      <indexterm><primary>i ノード</primary></indexterm>

      <para>ファイルシステムはハードドライブをブロック (小さく連続した領域) に分割します。ブロックのサイズはファイルシステムの作成時に定義され、一般的に 1 から 8 キロバイトまでの範囲を取ります。</para>

      <para>ブロックはファイルの実データまたはファイルシステムが使うメタデータのどちらか一方を保存するために使われます。メタデータの中でも特に、i ノードについて説明します。1 つの i ノードはハードドライブ上の 1 ブロックを使い (i ノードを保存するブロックはブロッククォータに考慮されず、i ノードクォータだけに考慮されます)、その i ノードに対応するファイルの情報 (名前、所有者、パーミッションなど) と実際に使われるデータブロックへのポインタ情報の両方を含みます。単一の i ノードで対応できないくらい多くのブロックを専有するとても大きなファイルのために、間接ブロックシステムがあります。この場合の i ノードは、実データではなく別のブロックのリストを保存しているブロックのリストを参照します。</para>
    </sidebar>
    <indexterm><primary><command>warnquota</command></primary></indexterm>

    <para><command>edquota -t</command> コマンドを使えば、ソフトリミットの超過を許す「猶予期間」の最長値を定義することが可能です。この期間の後、ソフトリミットはハードリミットと同様に扱われます。ユーザがハードドライブに何かを書き込むには、ディスク領域の使用量を減らしてクォータの制限内に収めなければいけません。</para>

    <sidebar>
      <title><emphasis>GOING FURTHER</emphasis> 新規ユーザのデフォルトクォータを設定する</title>

      <para>新規ユーザ向けにクォータを自動設定するには、(<command>edquota</command> または <command>setquota</command> を使って) テンプレートユーザに対してクォータを設定し、<filename>/etc/adduser.conf</filename> ファイルの <varname>QUOTAUSER</varname> 変数にテンプレートユーザの名前をいれなければいけません。この後 <command>adduser</command> コマンドを使って新規ユーザを作成すれば、テンプレートユーザと同じクォータ設定が自動的に適用されます。</para>
    </sidebar>
  </section>
  <section id="sect.backup">
    <title>バックアップ</title>

    <para>バックアップを取ることは管理者の主要な責任の 1 つです。しかし、これは通常極めるのが難しい強力なツールを使う複雑な問題です。</para>
    <indexterm><primary>バックアップ</primary></indexterm>
    <indexterm><primary>復元</primary></indexterm>

    <para>バックアップ作業に関して言えば <command>amanda</command>、<command>bacula</command>、<command>BackupPC</command> などの多くのプログラムが存在します。これらは多くの機能を備えるクライアント/サーバシステムで、その設定はかなり難しいです。いくつかのプログラムは難しさを和らげるためのユーザフレンドリーなウェブインターフェースを提供しています。しかし Debian には、すべての考え得る使用事例に対応できる、他の数多くのバックアップソフトウェアが含まれています。ソフトウェアを確認するには <command>apt-cache search backup</command> を使ってください。</para>
    <indexterm><primary><command>amanda</command></primary></indexterm>
    <indexterm><primary><command>bacula</command></primary></indexterm>
    <indexterm><primary><command>BackupPC</command></primary></indexterm>

    <para>この節ではプログラムの使い方を詳細に説明するのではなく、Falcot Corp の管理者がバックアップ戦略を定義する際にどのように考えたかを説明します。</para>

    <para>Falcot Corp では、バックアップには 2 つの目標があります。具体的に言えば、誤って削除したファイルを回復することと、ハードドライブに障害が起きた際にコンピュータ (サーバおよびデスクトップ) を素早く復元することです。</para>
    <section>
      <title><command>rsync</command> を使ったバックアップ</title>

      <para>テープへのバックアップは遅くて費用がかかりすぎるとみなされ、データは専用サーバのハードドライブにバックアップされることになりました。専用サーバはソフトウェア RAID (<xref linkend="sect.raid-soft" />を参照してください) を使ってデータをハードウェア障害から守っています。デスクトップコンピュータは個別にバックアップされませんが、ユーザは部署のファイルサーバの個人アカウントはバックアップされると知らされています。毎日異なるサーバにバックアップを行う目的で、<command>rsync</command> コマンド (同名のパッケージに含まれます) が使われています。</para>
      <indexterm><primary><command>rsync</command></primary></indexterm>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> ハードリンク、ファイルの別名</title>
        <indexterm><primary>リンク</primary><secondary>ハードリンク</secondary></indexterm>
        <indexterm><primary>ハードリンク</primary></indexterm>

	<para>ハードリンクはシンボリックリンクと異なり、リンクされたファイルと区別できません。本質的に、ハードリンクの作成は既存のファイルに別名を与えることと同義です。そのため、ハードリンクの削除はそのファイルに関連する名前を削除するに過ぎません。他の名前がまだそのファイルに関連付けられている場合、データの実体はファイルシステムから削除されません。コピーと異なり、ハードリンクはハードドライブ上に追加的な領域を必要としない点について注意することは興味深いです。</para>

	<para>ハードリンクは <command>ln <replaceable>target</replaceable> <replaceable>link</replaceable></command> コマンドで作成されます。ここで <replaceable>link</replaceable> ファイルは <replaceable>target</replaceable> ファイルの新しい名前です。ハードリンクは <replaceable>target</replaceable> と <replaceable>link</replaceable> が同じファイルシステム上にある場合に限り作成できます。対してシンボリックリンクはこの制限を受けません。</para>
      </sidebar>

      <para>利用できるハードドライブの空き領域によっては、完全な日次バックアップができない場合があります。このため、まず <command>rsync</command> コマンドは今回のバックアップの内容を前回のバックアップの内容へのハードリンクの形で複製します。このおかげで、ハードドライブ領域を無駄に消費することがなくなります。そして <command>rsync</command> プロセスは前回のバックアップ以降に変更されたファイルだけを置き換えていきます。このメカニズムにより、多くのバックアップを少ない領域に保存することが可能です。すべてのバックアップは即座に利用できる上に即座にアクセスできるので (たとえば、ネットワーク共有されたディレクトリの中に置かれるので)、ある日付同士の違いを素早く比較できます。</para>
      <indexterm><primary>コピー、バックアップコピー</primary></indexterm>
      <indexterm><primary>バックアップ</primary><secondary>コピー</secondary></indexterm>
      <indexterm><primary><emphasis role="pkg">dirvish</emphasis></primary></indexterm>

      <para><command>dirvish</command> プログラムを使えば、このバックアップメカニズムを簡単に実現できます。<command>dirvish</command> プログラムはバックアップストレージ領域 (dirvish 用語で「bank」) を使い、「bank」の中に一連のバックアップファイルのタイムスタンプを付けたコピー (dirvish の文書ではこれらを「vault」と呼びます) を置きます。</para>

      <para>主要な設定は <filename>/etc/dirvish/master.conf</filename> ファイルに書かれています。<filename>/etc/dirvish/master.conf</filename> ファイルでは、バックアップストレージ領域の場所、管理する「vault」のリスト、バックアップの保存期限のデフォルト値を定義します。残りの設定、すなわち <replaceable>vault</replaceable> でバックアップするファイルセットに固有の設定は <filename><replaceable>bank</replaceable>/<replaceable>vault</replaceable>/dirvish/default.conf</filename> ファイルに書かれています。</para>

      <example id="example.dirvish-master">
        <title><filename>/etc/dirvish/master.conf</filename> ファイル</title>

        <programlisting>bank:
    /backup
exclude:
    lost+found/
    core
    *~
Runall:
    root    22:00
expire-default: +15 days
expire-rule:
#   分  時    日  月        曜日 保存期限
    *   *     *   *         1    +3 months
    *   *     1-7 *         1    +1 year
    *   *     1-7 1,4,7,10  1</programlisting>
      </example>

      <para><literal>bank</literal> 設定はバックアップが保存されるディレクトリを表します。<literal>exclude</literal> 設定を使うと、バックアップからファイル (またはファイルタイプ) を除外することが可能です。<literal>Runall</literal> はタイムスタンプを付けてバックアップするファイルセットのリストです。これにより、万が一割り当てられた時間に正確にバックアップが実行されない場合でも、バックアップコピーに正確な時刻を割り当てることが可能です。ここで指定する時刻は実際の実行時刻の直前の時刻でなければいけません (<filename>/etc/cron.d/dirvish</filename> によれば、Debian では実際の実行時間はデフォルトで午後 10 時 4 分です)。最後に <literal>expire-default</literal> と <literal>expire-rule</literal> 設定でバックアップ保存期限ポリシーを定義します。上の例は、各四半期の最初の日曜日に作成されたバックアップを永久に保存し、それに当てはまらない各月の最初の日曜日に作成されたバックアップを 1 年経過後に削除し、それに当てはまらない日曜日に作成されたバックアップを 3 カ月経過後に削除します。その他の日次バックアップは 15 日間保存されます。ルールが適用される順番が問題です。Dirvish は最後にマッチしたルールを使い、<literal>expire-rule</literal> にマッチするものがなければ <literal>expire-default</literal> を使います。</para>

      <sidebar>
        <title><emphasis>IN PRACTICE</emphasis> 削除スケジュール</title>

	<para>削除を担当している <command>dirvish-expire</command> は削除ルールを使いません。削除ルールが適用されるのは新しいバックアップコピーの作成時であり、バックアップコピーを削除する日付が削除ルールによって定義されます。<command>dirvish-expire</command> は保存されたコピーを単純に調べて、期限の過ぎているコピーを削除します。</para>
      </sidebar>

      <example id="example.dirvish-vault">
        <title><filename>/backup/root/dirvish/default.conf</filename> ファイル</title>

        <programlisting>client: rivendell.falcot.com
tree: /
xdev: 1
index: gzip
image-default: %Y%m%d
exclude:
    /var/cache/apt/archives/*.deb
    /var/cache/man/**
    /tmp/**
    /var/tmp/**
    *.bak</programlisting>
      </example>

      <para>上の例では、バックアップするファイルセットを指定しています。具体的に言えば、バックアップ対象は <emphasis>rivendell.falcot.com</emphasis> マシン (ローカルデータをバックアップするには、単純に <command>hostname</command> の出力するローカルマシンの名前を指定します) にあるルートツリーの内容 (<literal>tree: /</literal>) から <literal>exclude</literal> で指定したものを除外したファイルです。さらに、バックアップ対象は <literal>tree</literal> と同一のファイルシステムの内容 (<literal>xdev: 1</literal>) に制限されます。他のマウントポイントのファイルはバックアップされません。保存されたファイルのインデックス (<literal>index: gzip</literal>) が生成され、イメージには現在の日付に関連する名前 (<literal>image-default: %Y%m%d</literal>) が付けられます。</para>

      <para>多くのオプションがあり、すべては <citerefentry><refentrytitle>dirvish.conf</refentrytitle><manvolnum>5</manvolnum></citerefentry> マニュアルページに書かれています。一度これらの設定ファイルを作ったら、<command>dirvish --vault <replaceable>vault</replaceable> --init</command> コマンドを使って、各ファイルセットを初期化します。ここまでが済むと、毎日の <command>dirvish-runall</command> 実行時に期限切れになったバックアップコピーが削除され、その直後に自動的に新しいバックアップコピーが作成されます。</para>

      <sidebar>
        <title><emphasis>IN PRACTICE</emphasis> SSH を使ったリモートバックアップ</title>

	<para>dirvish はリモートマシンにデータをバックアップする場合、<command>ssh</command> を使ってリモートマシンに接続し、<command>rsync</command> をサーバとして開始します。この場合、root ユーザとして自動的にリモートマシンに接続できなければいけません。これを実現するには、SSH 認証鍵を使ってください (<xref linkend="sect.ssh-key-based-auth" />を参照してください)。</para>
      </sidebar>
    </section>
    <section>
      <title>バックアップなしのマシンの復元</title>

      <para>バックアップされていないデスクトップコンピュータに対しては <emphasis>Simple-CDD</emphasis> でカスタマイズされた DVD-ROM からシステムを再インストールするのが簡単でしょう (<xref linkend="sect.simple-cdd" />を参照してください)。インストールを最初からやり直すので、初回インストール後に行われたすべての設定は失われます。これは問題ではありません。なぜなら、アカウントに関して言えばシステムはすべて中央 LDAP ディレクトリの情報を参照しており、多くのデスクトップアプリケーションに関して言えば dconf のおかげで事前設定されているからです (詳しい情報は<xref linkend="sect.gnome-desktop" />を参照してください)。</para>

      <para>Falcot Corp の管理者は自分たちのバックアップポリシーの限界を理解しています。テープを耐火金庫に入れるかのようにバックアップサーバを保護することができないため、管理者はバックアップサーバを他のサーバと別の部屋に設置しました。そうすればサーバルームの火事などの災害が起きてもその他のサーバと一緒にバックアップも破壊されることを避けられるからです。さらに、管理者は 1 週間に 1 回 DVD-ROM に増分バックアップ (最後のバックアップ以降に修正されたファイルだけのバックアップ) をとるようにしています。</para>

      <sidebar>
        <title><emphasis>GOING FURTHER</emphasis> SQL と LDAP サービスのバックアップ</title>

	<para>多くのサービス (SQL や LDAP データベースなど) は単純にファイルをコピーするだけではバックアップできません (それらのサービスをバックアップの作成中に適切に中断しない限りバックアップできません。サービスの中断は通常問題です。なぜなら、サービスが常に利用できることを意図されているからです)。そのような場合、安全にバックアップできる「データダンプ」を作るために「エクスポート」メカニズムを使うことが必要です。データダンプは通常サイズのとても大きいファイルですが、データダンプのサイズは圧縮によってかなり小さくなります。要求されるストレージ領域を減らすために、完全なテキストファイルを保存するのを 1 週間に 1 回、<command>diff</command> を保存するのを毎日に制限しています。差分は <command>diff <replaceable>file_from_yesterday</replaceable> <replaceable>file_from_today</replaceable></command> で生成されます。バイナリダンプから増分差分を作成するには <command>xdelta</command> プログラムを使ってください。</para>
        <indexterm><primary><command>xdelta</command></primary></indexterm>
        <indexterm><primary><command>diff</command></primary></indexterm>
        <indexterm><primary>ダンプ</primary></indexterm>
      </sidebar>

      <sidebar>
        <title><emphasis>CULTURE</emphasis> <emphasis>TAR</emphasis>、テープバックアップ用の標準規格</title>
        <indexterm><primary>バックアップ</primary><secondary>テープへの</secondary></indexterm>
        <indexterm><primary>テープ、バックアップ</primary></indexterm>
        <indexterm><primary>TAR</primary></indexterm>

	<para>歴史的に言って、Unix で最も簡単にバックアップを作成する手段は <emphasis>TAR</emphasis> アーカイブをテープに保存する方法でした。<command>tar</command> コマンドは「Tape ARchive」から命名されています。</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.hotplug">
    <title>ホットプラグ機能、<emphasis>hotplug</emphasis></title>
    <section>
      <title>前書き</title>

      <para><emphasis>hotplug</emphasis> カーネルサブシステムはデバイスの追加と削除を、<command>udevd</command> の助けを借りて適切なドライバを読み込んだり関連するデバイスファイルを作成することで、動的に取り扱います。現代的なハードウェアと仮想化を使えば、ほとんどすべてのデバイスはホットプラグ対応と言ってよいでしょう。具体的に言えば、USB/PCMCIA/IEEE 1394 周辺機器から SATA ハードドライブ、さらには CPU やメモリにいたるまでのほとんどすべてがホットプラグに対応しています。</para>

      <para>カーネルは必要なドライバとデバイス ID を関連付けるデータベースを持っています。このデータベースは起動中にさまざまなバスで検出された周辺機器用のすべてのドライバを読み込んだりする際、追加的なホットプラグデバイスが接続された際に使われます。デバイスの使用準備が整ったら、メッセージが <command>udevd</command> に送信され、<command>udevd</command> は対応するエントリを <filename>/dev/</filename> 内に作成します。</para>

      <indexterm><primary><emphasis>ホットプラグ</emphasis></primary></indexterm>
      <indexterm><primary>ホットプラグ</primary></indexterm>
      <indexterm><primary>USB</primary></indexterm>
      <indexterm><primary>IEEE 1394</primary></indexterm>
      <indexterm><primary>PCMCIA</primary></indexterm>
      <indexterm><primary>SATA</primary></indexterm>
    </section>
    <section>
      <title>命名問題</title>

      <para>ホットプラグ接続の出現前、デバイスに固定された名前を割り当てることは簡単でした。名前は単純にデバイスが接続されたバスの位置を基にしていました。しかしこのやり方はデバイスが接続されるバスの位置が決まっていない場合に問題となります。典型的な例は、コンピュータがディスクドライブとして認識するデジタルカメラや USB メモリを使う場合です。最初に接続されたデバイスは <filename>/dev/sdb</filename>、2 番目に接続されたデバイスは <filename>/dev/sdc</filename> と名付けられるかもしれません (<filename>/dev/sda</filename> はコンピュータのハードドライブを表します)。デバイスに対するデバイス名は固定されませんし、デバイス名はデバイスが接続された順番に依存します。</para>

      <para>さらに、デバイスのメジャー/マイナー番号に動的な値を使うドライバが増えています。動的なメジャー/マイナー番号を使うことで、あるデバイスに対する静的なエントリを持つことが不可能になります。なぜなら、これらのエントリは再起動の後に変化するかもしれないからです。</para>

      <para><emphasis>udev</emphasis> はまさにこの問題を解決するために作られました。</para>
    </section>
    <section>
      <title><emphasis>udev</emphasis> の動作原理</title>

      <para><emphasis>udev</emphasis> は新しいデバイスの出現についてカーネルから通知を受けると、<filename>/sys/</filename> 内の対応するエントリを調べて、与えられたデバイスに関するさまざまな情報 (特にデバイスを一意に識別する情報 (ネットワークカードの MAC アドレス、USB デバイスのシリアル番号など)) を収集します。</para>

      <para>この情報を武器にして、<emphasis>udev</emphasis> は <filename>/etc/udev/rules.d/</filename> と <filename>/lib/udev/rules.d/</filename> に含まれるすべてのルールを調査します。この過程で <emphasis>udev</emphasis> はデバイスに割り当てる名前、作成するシンボリックリンクの名前 (シンボリックリンクはデバイスに別名を与えるために作成されます)、実行するコマンドを決定します。上記ディレクトリに含まれるすべてのファイルが調査され、すべてのルールが順番に評価されます (「GOTO」指示文を使う場合を除きます)。そのため、与えられたイベントに対応する複数のルールがあるかもしれません。</para>

      <para>ルールの構文はとても単純です。つまり各行には、選択基準と変数代入命令が含まれます。選択基準は反応を必要とするイベントを選ぶのに使われ、変数代入命令はイベントに対して行う動作を定義します。選択基準と変数代入命令は単純にコンマで区切られており、演算子を使って選択基準 (<literal>==</literal> または <literal>!=</literal> などの比較演算子を付ける) と変数代入命令 (<literal>=</literal>、<literal>+=</literal>、<literal>:=</literal> などの演算子を付ける) を暗黙のうちに区別します。</para>

      <para>比較演算子は以下の変数に使われます。</para>
      <itemizedlist>
        <listitem>
	  <para><literal>KERNEL</literal>。カーネルがデバイスに割り当てた名前を意味します。</para>
        </listitem>
        <listitem>
	  <para><literal>ACTION</literal>。イベントに対する動作を意味します (デバイスが追加されたら「add」で、デバイスが取り外されたら「remove」です)。</para>
        </listitem>
        <listitem>
	  <para><literal>DEVPATH</literal>。デバイスの <filename>/sys/</filename> エントリのパスを意味します。</para>
        </listitem>
        <listitem>
	  <para><literal>SUBSYSTEM</literal>。要求を生成したカーネルサブシステムを意味します (たくさんの種類がありますが、「usb」、「ide」、「net」、「firmware」などがその例です)。</para>
        </listitem>
        <listitem>
	  <para><literal>ATTR{<replaceable>attribute</replaceable>}</literal>。デバイスの <filename>/sys/<replaceable>$devpath</replaceable>/</filename> ディレクトリ内の <replaceable>attribute</replaceable> ファイルの内容を意味します。これで MAC アドレスやその他のバス固有識別子がわかります。</para>
        </listitem>
        <listitem>
	  <para><literal>KERNELS</literal>、<literal>SUBSYSTEMS</literal>、<literal>ATTRS{<replaceable>attributes</replaceable>}</literal>。対象のデバイスの親デバイスの 1 つに対するさまざまなオプションに対して一致を検査します。</para>
        </listitem>
        <listitem>
	  <para><literal>PROGRAM</literal>。指定されたプログラムを使ってテストを実行することを意味します (プログラムが 0 を返したら真、それ以外を返したら偽になります)。プログラムの標準出力の内容は保存され、<literal>RESULT</literal> テストによって再利用されます。</para>
        </listitem>
        <listitem>
	  <para><literal>RESULT</literal>。<literal>PROGRAM</literal> が最後に呼び出された時に保存された標準出力に対してテストを実行することを意味します。</para>
        </listitem>
      </itemizedlist>

      <para>演算子の右側引数には、複数の値に同時にマッチするようなパターン式を使うことが可能です。たとえば、<literal>*</literal> は任意の文字列に (空文字列にも) マッチします。そして <literal>?</literal> は任意の文字にマッチし、<literal>[]</literal> は角括弧の間にリストされた文字セットにマッチします (最初の文字が <literal>!</literal> の場合は、その否定にマッチします。また、文字の連続範囲は <literal>a-z</literal> のように表記します)。</para>

      <para>代入演算子に関して、<literal>=</literal> は値を代入します (そして現在の値を入れ替えます)。さらに、リストに代入する場合、リストを空にした後、割り当てた値だけを代入します。<literal>:=</literal> は同じことをしますが、後から値を変更できなくなります。<literal>+=</literal> はリストにアイテムを追加します。代入演算子を使って変更できる変数は以下です。</para>
      <itemizedlist>
        <listitem>
	  <para><literal>NAME</literal>。<filename>/dev/</filename> 内に作成するデバイスファイル名を意味します。最初に代入された値だけが考慮され、他は無視されます。</para>
        </listitem>
        <listitem>
	  <para><literal>SYMLINK</literal>。同じデバイスを指すシンボリックリンクのリストです。</para>
        </listitem>
        <listitem>
	  <para><literal>OWNER</literal>、<literal>GROUP</literal>、<literal>MODE</literal>。デバイスを所有するユーザとグループおよびパーミッションを定義します。</para>
        </listitem>
        <listitem>
	  <para><literal>RUN</literal>。イベントに応答する際に実行するプログラムのリストを意味します。</para>
        </listitem>
      </itemizedlist>

      <para>これらの変数に割り当てる値の中で、以下の置換変数を使うことが可能な場合があります。</para>
      <itemizedlist>
        <listitem>
	  <para><literal>$kernel</literal> または <literal>%k</literal>。<literal>KERNEL</literal> と同じ値です。</para>
        </listitem>
        <listitem>
	  <para><literal>$number</literal> または <literal>%n</literal>。デバイスの割り当て番号を意味します。たとえば、<literal>sda3</literal> の場合「3」です。</para>
        </listitem>
        <listitem>
	  <para><literal>$devpath</literal> または <literal>%p</literal>。<literal>DEVPATH</literal> と同じ値です。</para>
        </listitem>
        <listitem>
	 
	  <para><literal>$attr{<replaceable>attribute</replaceable>}</literal> または <literal>%s{<replaceable>attribute</replaceable>}</literal>。<literal>ATTRS{<replaceable>attribute</replaceable>}</literal> と同じ値です。</para>
        </listitem>
        <listitem>
	  <para><literal>$major</literal> または <literal>%M</literal>。デバイスのカーネルメジャー番号を意味します。</para>
        </listitem>
        <listitem>
	  <para><literal>$minor</literal> または <literal>%m</literal>。デバイスのカーネルマイナー番号を意味します。</para>
        </listitem>
        <listitem>
	  <para><literal>$result</literal> または <literal>%c</literal>。<literal>PROGRAM</literal> によって起動された最後のプログラムの出力文字列を意味します。</para>
        </listitem>
        <listitem>
	  <para>そして最後に、<literal>%%</literal> と <literal>$$</literal>。それぞれパーセントとドル記号を意味します。</para>
        </listitem>
      </itemizedlist>

      <para>上のリストは完全なものではありません (最も重要なパラメータの抜粋です)。完全なリストは <citerefentry><refentrytitle>udev</refentrytitle><manvolnum>7</manvolnum></citerefentry> マニュアルページをご覧ください。</para>
    </section>
    <section>
      <title>具体例</title>

      <para>単純な USB メモリに固定された名前を割り当てる場合を考えましょう。最初に、一意的な方法で USB メモリを識別するために必要な要素を見つけなければいけません。このために、USB メモリを取り付け、<command>udevadm info -a -n /dev/sdc</command> を実行してください (ここで、<replaceable>/dev/sdc</replaceable> は USB メモリに割り当てられた実際のデバイス名で置き換えてください)。</para>

      <screen><computeroutput># </computeroutput><userinput>udevadm info -a -n /dev/sdc</userinput>
<computeroutput>[...]
  looking at device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0/block/sdc':
    KERNEL=="sdc"
    SUBSYSTEM=="block"
    DRIVER==""
    ATTR{range}=="16"
    ATTR{ext_range}=="256"
    ATTR{removable}=="1"
    ATTR{ro}=="0"
    ATTR{size}=="126976"
    ATTR{alignment_offset}=="0"
    ATTR{capability}=="53"
    ATTR{stat}=="      51      100     1208      256        0        0        0        0        0      192      25        6"
    ATTR{inflight}=="       0        0"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2/1-2.2:1.0/host9/target9:0:0/9:0:0:0':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="scsi"
    DRIVERS=="sd"
    ATTRS{device_blocked}=="0"
    ATTRS{type}=="0"
    ATTRS{scsi_level}=="3"
    ATTRS{vendor}=="I0MEGA  "
    ATTRS{model}=="UMni64MB*IOM2C4 "
    ATTRS{rev}=="    "
    ATTRS{state}=="running"
[...]
    ATTRS{max_sectors}=="240"
[...]
  looking at parent device '/devices/pci0000:00/0000:00:10.3/usb1/1-2/1-2.2':
    KERNELS=="9:0:0:0"
    SUBSYSTEMS=="usb"
    DRIVERS=="usb"
    ATTRS{configuration}=="iCfg"
    ATTRS{bNumInterfaces}==" 1"
    ATTRS{bConfigurationValue}=="1"
    ATTRS{bmAttributes}=="80"
    ATTRS{bMaxPower}=="100mA"
    ATTRS{urbnum}=="398"
    ATTRS{idVendor}=="4146"
    ATTRS{idProduct}=="4146"
    ATTRS{bcdDevice}=="0100"
[...]
    ATTRS{manufacturer}=="USB Disk"
    ATTRS{product}=="USB Mass Storage Device"
    ATTRS{serial}=="M004021000001"
[...]
</computeroutput></screen>

      <para>新しいルールを作るために、デバイスの変数および親デバイスの変数に対するテストを行います。上の例から、以下のような 2 つのルールを作成します。</para>

      <programlisting>KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="M004021000001", SYMLINK+="usb_key/part%n"</programlisting>

      <para>これらのルールをたとえば <filename>/etc/udev/rules.d/010_local.rules</filename> という 1 つのファイルに書き込んだら、USB メモリを取り外し、もう一度取り付けてください。この USB キーに関連付けられたディスクを表す <filename>/dev/usb_key/disk</filename> と第 1 パーティションを表す <filename>/dev/usb_key/part1</filename> が生成されたことと思います。</para>

      <sidebar>
        <title><emphasis>GOING FURTHER</emphasis> <emphasis>udev</emphasis> 設定のデバッグ</title>

	<para>多くのデーモンと同様に、<command>udevd</command> は <filename>/var/log/daemon.log</filename> にログを保存します。しかしデフォルトの状態だとログはそれほど詳細でなく、何が起きているかを理解するには不十分な場合が多いです。<command>udevadm control --log-priority=info</command> コマンドを使ってログの詳細度を上げることで、この問題は解決されます。デフォルトの詳細度に戻すには、<command>udevadm control --log-priority=err</command> を使ってください。</para>
      </sidebar>
    </section>
  </section>
  <section id="sect.power-management">
    <title>電源管理、Advanced Configuration and Power Interface (ACPI)</title>
    <indexterm><primary>電源管理</primary></indexterm>
    <indexterm><primary>管理、電源管理</primary></indexterm>

    <para>電源管理は問題のある場合が多いです。実際、適切にコンピュータを一時停止するには、コンピュータのすべてのデバイスドライバがデバイスをスタンバイ状態にする方法を知り、デバイスドライバがデバイスを再始動する際に適切に再設定できなければいけません。不幸なことに、Linux の下ではうまくスタンバイ状態にできないデバイスが多いです。なぜなら、デバイスの製造業者が必要な仕様を公開しないからです。</para>

    <para>Linux は ACPI (Advanced Configuration and Power Interface) つまり最新の標準的な電源管理規格をサポートします。<emphasis role="pkg">acpid</emphasis> パッケージは電源管理に関するイベント (ラップトップで交流電源とバッテリ電源の切り替えに対するイベントなど) を待ち受けたり、イベントに応答してさまざまなコマンドを実行するデーモンを提供します。</para>

    <indexterm><primary>ACPI</primary></indexterm>
    <indexterm><primary>Advanced Configuration and Power Interface</primary></indexterm>
    <indexterm><primary><command>acpid</command></primary></indexterm>
    
    <sidebar>
      <title><emphasis>BEWARE</emphasis> グラフィックカードとスタンバイ</title>

      <para>グラフィックカードドライバはスタンバイがうまくできない問題の原因になることが多いです。この場合、X.org グラフィックサーバの最新版を試してみるのが良いアイディアです。</para>
    </sidebar>

    <para>この章では多くの Unix システムで共通の基本的サービスの概要を述べました。次の章では管理されているマシンの環境に焦点を合わせます。すなわちネットワークに焦点を合わせます。多くのサービスはネットワークを正しく動作させることを必要とします。次の章ではこれについて議論します。</para>
  </section>
</chapter>
