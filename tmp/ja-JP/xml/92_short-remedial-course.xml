<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE appendix PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<appendix id="short-remedial-course" lang="ja-JP">
	<appendixinfo>
		 <keywordset>
			<keyword>BIOS</keyword>
			 <keyword>カーネル</keyword>
			 <keyword>Unix</keyword>
			 <keyword>プロセス</keyword>
			 <keyword>階層構造</keyword>
			 <keyword>基本コマンド</keyword>

		</keywordset>

	</appendixinfo>
	 <title>簡単な補習講座</title>
	 <highlights> <para>
		本書は主として管理者と「パワーユーザ」を対象にしているとは言うものの、やる気のある初心者を仲間はずれにしたくはありません。そのため、この付録は Unix コンピュータを取り扱う際に求められる基礎的な概念を説明する集中講座になるでしょう。
	</para>
	 </highlights> <section id="sect.shell-and-basic-commands">
		<title>シェルと基本コマンド</title>
		 <para>
			Unix 世界では、管理者全員が遅かれ早かれコマンドラインを使わなければいけません。たとえば、システムが正常な起動に失敗して、コマンドラインのレスキューモードだけが提供される場合です。それゆえ、このような状況下ではコマンドラインインターフェースを取り扱う技術を身に付けているということが基本的なサバイバル技術です。
		</para>
		 <sidebar> <title><emphasis>QUICK LOOK</emphasis> コマンドインタプリタの起動</title>
		 <para>
			A command-line environment can be run from the graphical desktop, by an application known as a “terminal”. In GNOME, you can start it from the “Activities” overview (that you get when you move the mouse in the top-left corner of the screen) by typing the first letters of the application name. In Plasma, you will find it in the <menuchoice><guimenu>K</guimenu> <guisubmenu>Applications</guisubmenu> <guisubmenu>System</guisubmenu></menuchoice> menu.
		</para>
		 </sidebar> <para>
			この節では、コマンドを簡単に見ていきます。ここで挙げたコマンドには多くのオプションが用意されていますが、ここでは説明しませんので、各コマンドに対応するマニュアルページに書かれているたくさんの文書を参照してください。
		</para>
		 <section>
			<title>ディレクトリツリーの閲覧とファイル管理</title>
			 <para>
				セッションが開始されたら、<command>pwd</command> コマンドでファイルシステム上の現在の場所を表示することが可能です (<command>pwd</command> は <emphasis>print working directory</emphasis> の略語です)。現在のディレクトリを変更するには、<command>cd <replaceable>directory</replaceable></command> コマンドを使います (<command>cd</command> は <emphasis>change directory</emphasis> の略語です)。親ディレクトリは常に <literal>..</literal> (ドット 2 つ) で表します。これに対して、現在のディレクトリは <literal>.</literal> (ドット 1 つ) で表します。<command>ls</command> コマンドは指定したディレクトリの内容を <emphasis>listing (表示)</emphasis> します。パラメータを与えなかった場合、<command>ls</command> コマンドは現在のディレクトリの内容を表示します。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>cd デスクトップ</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/デスクトップ
$ </computeroutput><userinput>cd .</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog/デスクトップ
$ </computeroutput><userinput>cd ..</userinput>
<computeroutput>$ </computeroutput><userinput>pwd</userinput>
<computeroutput>/home/rhertzog
$ </computeroutput><userinput>ls</userinput>
<computeroutput>ダウンロード  デスクトップ  ビデオ  画像
テンプレート  ドキュメント  音楽    公開</computeroutput>
</screen>
			 <para>
				新しいディレクトリを作成するには <command>mkdir <replaceable>directory</replaceable></command> を使い、既存の (空) ディレクトリを削除するには <command>rmdir <replaceable>directory</replaceable></command> を使います。<command>mv</command> コマンドを使うことでファイルとディレクトリの <emphasis>moving (移動)</emphasis> および名前変更が可能です。一方で、ファイルを <emphasis>removing (削除)</emphasis> するには <command>rm <replaceable>file</replaceable></command> を実行します。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir test</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>test          テンプレート  ドキュメント  音楽  公開
ダウンロード  デスクトップ  ビデオ        画像
$ </computeroutput><userinput>mv test new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>new           テンプレート  ドキュメント  音楽  公開
ダウンロード  デスクトップ  ビデオ        画像
$ </computeroutput><userinput>rmdir new</userinput>
<computeroutput>$ </computeroutput><userinput>ls</userinput>
<computeroutput>ダウンロード  デスクトップ  ビデオ  画像
テンプレート  ドキュメント  音楽    公開</computeroutput>
</screen>

		</section>
		 <section>
			<title>テキストファイルの表示と編集</title>
			 <para>
				<command>cat <replaceable>file</replaceable></command> コマンド (ファイルを標準出力デバイスに <emphasis>concatenate (連結)</emphasis> する) はファイルを読み込んで内容を端末に表示します。ファイルが一画面に表示するには大きすぎる場合、<command>less</command> (および <command>more</command>) などのページャーを使い、ページごとに内容を表示します。
			</para>
			 <para>
				<command>editor</command> コマンドを使えばテキストエディタ (<command>vi</command> や <command>nano</command> など) が起動し、テキストファイルの作成や編集や読み込みを行うことが可能です。単純なファイルならば、リダイレクト機能を使ってコマンドインタプリタから作ることも可能です。たとえば <command>echo "<replaceable>text</replaceable>" &gt;<replaceable>file</replaceable></command> は「<replaceable>text</replaceable>」という内容で <replaceable>file</replaceable> と名付けられたファイルを作成します。<command>echo "<replaceable>moretext</replaceable>" &gt;&gt;<replaceable>file</replaceable></command> などのコマンドを使えば、ファイルの最後に行を追加することも可能です。この例で示した <literal>&gt;&gt;</literal> に注意してください。
			</para>

		</section>
		 <section>
			<title>ファイルとファイル内容の検索</title>
			 <para>
				<command>find <replaceable>directory</replaceable> <replaceable>criteria</replaceable></command> コマンドは <replaceable>directory</replaceable> の下にあるファイルから <replaceable>criteria</replaceable> という条件に一致するものを探します。最もよく使われる条件は <literal>-name <replaceable>name</replaceable></literal> です。すなわちこれは名前を基にしてファイルを探すという条件です。
			</para>
			 <para>
				<command>grep <replaceable>expression</replaceable> <replaceable>files</replaceable></command> コマンドは <replaceable>files</replaceable> で指定したファイルの内容を検索して、<replaceable>expression</replaceable> で指定した正規表現 (補注<xref linkend="sidebar.regexp" />を参照してください) に一致する行を抽出します。<literal>-r</literal> オプションを追加すれば、パラメータとして指定されたディレクトリに含まれるすべてのファイルに対して再帰的に検索することが可能です。<literal>-r</literal> オプションを使うことで、内容の一部を元にファイルを探すことが可能です。
			</para>

		</section>
		 <section>
			<title>プロセス管理</title>
			 <para>
				<command>ps aux</command> コマンドは現在実行中のプロセスをリストし、プロセスの <emphasis>pid</emphasis> (プロセス ID) を表示することでプロセスを識別する手助けになります。プロセスの <emphasis>pid</emphasis> がわかったら、<command>kill -<replaceable>signal</replaceable> <replaceable>pid</replaceable></command> コマンドを使ってプロセスにシグナルを送信することが可能です (シグナルを送信するユーザ自身が対象のプロセスの所有者である場合に限ります)。シグナルにはさまざまな種類があります。しかし、最もよく使われるのが <literal>TERM</literal> (処理の終了を丁寧に依頼する) と <literal>KILL</literal> (強制的に終了する) です。
			</para>
			 <para>
				コマンドの最後に「&amp;」を付けた場合、コマンドインタプリタはバックグラウンドでプログラムを実行します。アンパサンドを使うことで、ユーザは、コマンドがまだ実行中であっても、すぐにシェルの制御を再開することが可能です (ここで実行したコマンドはユーザから見えなくなり、バックグラウンドプロセスになります)。<command>jobs</command> コマンドはバックグラウンドで実行中のプロセスをリストします。さらに <command>fg %<replaceable>job-number</replaceable></command> (<emphasis>foreground</emphasis> の略語) は指定したジョブをフォアグラウンドに復活させます。コマンドがフォアグラウンドで実行されている場合 (通常通り開始した場合や <command>fg</command> でフォアグラウンドに復活した場合)、<keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo> キーの組み合わせでフォアグラウンドプロセスを一時停止してコマンドラインの制御を再開することが可能です。プロセスをバックグラウンドで再開するには、<command>bg %<replaceable>job-number</replaceable></command> (<foreignphrase>background</foreignphrase> の略語) を使います。
			</para>

		</section>
		 <section>
			<title>システム情報、メモリ、ディスク領域、識別情報</title>
			 <para>
				<command>free</command> コマンドはメモリに関する情報を表示します。一方、<command>df</command> (<emphasis>disk free</emphasis>) はファイルシステムにマウントされた各ディスクの利用できるディスク領域を報告します。<literal>-h</literal> オプション (<emphasis>human readable</emphasis> の意味) はサイズをわかりやすい単位 (通常メガバイトやギガバイト) で変換します。同様に、<command>free</command> コマンドは <literal>-m</literal> と <literal>-g</literal> オプションをサポートしており、データはそれぞれメガバイトとギガバイト単位のどちらか一方で表示されます。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>free</userinput>
<computeroutput>             total       used       free     shared    buffers     cached
Mem:       1028420    1009624      18796          0      47404     391804
-/+ buffers/cache:     570416     458004
Swap:      2771172     404588    2366584
$ </computeroutput><userinput>df</userinput>
<computeroutput>ファイルシス       1K-ブロック      使用    使用可 使用% マウント位置
/dev/sda2              9614084   4737916   4387796   52% /
tmpfs                   514208         0    514208    0% /lib/init/rw
udev                     10240       100     10140    1% /dev
tmpfs                   514208    269136    245072   53% /dev/shm
/dev/sda5             44552904  36315896   7784380   83% /home
</computeroutput></screen>
			 <para>
				<command>id</command> コマンドはセッションを実行しているユーザのユーザ名をユーザが所属するグループのリストと一緒に表示します。一部のファイルやデバイスへのアクセスはグループメンバーだけに制限されているかもしれませんので、ユーザの所属するグループを確認することが役に立つ場合があります。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>id</userinput>
<computeroutput>uid=1000(rhertzog) gid=1000(rhertzog) groups=1000(rhertzog),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev),109(bluetooth),115(scanner)</computeroutput>
</screen>

		</section>

	</section>
	 <section id="sect.filesystem-hierarchy">
		<title>ファイルシステム階層の構成</title>
		 <indexterm>
			<primary>ファイルシステム階層</primary>
		</indexterm>
		 <section>
			<title>ルートディレクトリ</title>
			 <para>
				Debian システムは<emphasis>ファイルシステム階層標準</emphasis> (FHS) に沿って構成されています。ファイルシステム階層標準ではそれぞれのディレクトリの目的が定義されています。たとえば、最上位ディレクトリに含まれるディレクトリの目的は以下の通り定義されています。
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<filename>/bin/</filename>。これは基本プログラムを格納するディレクトリです。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/boot/</filename>。これは Linux カーネルおよび起動処理の初期に要求されるその他のファイルを格納するディレクトリです。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/dev/</filename>。これはデバイスファイルを格納するディレクトリです。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/etc/</filename>。これは設定ファイルを格納するディレクトリです。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/home/</filename>。これはユーザの個人ファイルを格納するディレクトリです。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/lib/</filename>。これは基本ライブラリを格納するディレクトリです。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/media/*</filename>。これはリムーバブルデバイス (CD-ROM、USB メモリなど) 用のマウントポイントです。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/mnt/</filename>。これは一時的なマウントポイントです。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/opt/</filename>。これはサードパーティが提供する追加アプリケーションを格納するディレクトリです。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/root/</filename>。これは管理者 (root) の個人ファイルを格納するディレクトリです。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/run/</filename>。再起動後に保持されない揮発性のランタイムデータ (FHS にはまだ含まれていません)。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/sbin/</filename>。これはシステムプログラムを格納するディレクトリです。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/srv/</filename>。これは自システム上で運用されているサーバが使うデータを格納するディレクトリです。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/tmp/</filename>。これは一時ファイルを格納するディレクトリです。このディレクトリの内容は起動時に削除されます。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/usr/</filename>。これはアプリケーションを格納するディレクトリです。このディレクトリは <filename>bin</filename>、<filename>sbin</filename>、<filename>lib</filename> のようにさらに細分されます (各ディレクトリの目的はルートディレクトリにこれらのディレクトリが含まれる場合と同じです)。さらに、<filename>/usr/share/</filename> にはアーキテクチャに依存しないデータが含まれます。<filename>/usr/local/</filename> は管理者が手作業でアプリケーションをインストールする場所として用意されています。こうすることで、パッケージングシステム (<command>dpkg</command>) によって取り扱われるファイルを上書きしなくても済むようになります。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/var/</filename>。これはデーモンの取り扱う可変データを格納するディレクトリです。これには、ログファイル、キュー、スプール、キャッシュなどが含まれます。
					</para>

				</listitem>
				 <listitem>
					<para>
						<filename>/proc/</filename> と <filename>/sys/</filename> は Linux カーネルに特有のディレクトリです (FHS で定義されていません)。カーネルはユーザ空間にデータを書き出すためにこれらのディレクトリを使います (この概念に関する説明は<xref linkend="sect.userspace-presentation" />と<xref linkend="sect.user-space" />を参照してください)。
					</para>

				</listitem>

			</itemizedlist>

		</section>
		 <section>
			<title>ユーザのホームディレクトリ</title>
			 <para>
				ユーザのホームディレクトリの内容は標準化されていませんが、特筆すべき慣習が存在します。1 つ目は、ユーザのホームディレクトリはチルダ (「~」) で表される場合が多いということです。これを知っておくと役に立ちます。なぜなら、コマンドラインインタプリタは自動的にチルダを正しいディレクトリ (通常 <filename>/home/<replaceable>user</replaceable>/</filename>) に置き換えるからです。
			</para>
			 <para>
				伝統的に、アプリケーション設定ファイルはユーザのホームディレクトリの下に直接保存されている場合が多く、設定ファイルの名前は通常ドットで始まります (たとえば、<command>mutt</command> 電子メールクライアントの設定は <filename>~/.muttrc</filename> に保存されます)。通常、ドットで始まるファイル名は表示されない点に注意してください。<command>ls</command> を使ってドットから始まるファイル名を持つファイルを表示するには、<literal>-a</literal> オプションを付けてください。グラフィカルファイルマネージャでこの種の隠しファイルを表示するには、それぞれのアプリケーションの設定を変更してください。
			</para>
			 <para>
				一部のプログラムは 1 つのディレクトリ (たとえば <filename>~/.ssh/</filename> など) に複数の設定ファイルを保存します。また、一部のアプリケーション (Iceweasel ウェブブラウザなど) はダウンロードデータをキャッシュする目的で自分の設定ディレクトリを使います。このため、アプリケーション設定ディレクトリによって大量のディスク領域が消費される可能性があります。
			</para>
			 <para>
				これらの設定ファイルはユーザのホームディレクトリ直下に保存され、まとめて<emphasis>ドットファイル</emphasis>と呼ばれており、増え続けることでユーザのホームディレクトリを散らかす原因となっています。幸いなことに、FreeDesktop.org の傘下で行われた努力により「XDG 基本ディレクトリ仕様」が生まれました。これは設定ファイルと設定ディレクトリを一掃することを目的とする仕様です。XDG 基本ディレクトリ仕様によれば、設定ファイルは <filename>~/.config</filename> に、キャッシュファイルは <filename>~/.cache</filename> に、アプリケーションデータファイルは <filename>~/.local</filename> (およびそのサブディレクトリ) に保存すると決められています。XDG 基本ディレクトリ仕様はゆっくりと勢いを増しつつあり、一部のアプリケーション (特にグラフィカルアプリケーション) はこの仕様に従うようになっています。
			</para>
			 <para>
				通常グラフィカルデスクトップは <filename>~/デスクトップ/</filename> ディレクトリ (日本語で設定されていないシステムの場合、適切に翻訳された名前のディレクトリ) の内容をデスクトップ (つまり、すべてのアプリケーションを閉じるかアイコン化した時の画面) に表示します。
			</para>
			 <para>
				最後に、電子メールシステムは受信した電子メールを <filename>~/Mail/</filename> ディレクトリに保存する場合があります。
			</para>

		</section>

	</section>
	 <section id="sect.computer-layers">
		<title>コンピュータ内部の仕組み、さまざまな層の関係性</title>
		 <para>
			コンピュータはどちらかと言えば抽象的なものとして考えられる場合が多く、外から見えるインターフェースは内部の複雑さに比べてずっと簡単なものです。この複雑さの原因は関連する要素が多いことです。しかしながら、これらの要素は層状構造とみなすことが可能で、ある層が影響をおよぼしたり影響を受けたりするのはその層の真上と真下の層に限られています。
		</para>
		 <para>
			すべてがうまく動作している限り、エンドユーザは各層の詳細を理解する必要はありません。「インターネットにつながらない!」などの問題に直面した場合、真っ先にやるべきは、問題の原因になっている層を特定することです。ネットワークカード (ハードウェア) は動いていますか? コンピュータはネットワークカードを認識していますか? Linux カーネルはネットワークカードを認識していますか? ネットワークパラメータは適切に設定されていますか? これらの質問により、コンピュータは適切な層に分割され、問題の本質的な原因になっている層を特定することが可能です。
		</para>
		 <section id="sect.hardware">
			<title>最下層、ハードウェア</title>
			 <indexterm>
				<primary>IDE</primary>
			</indexterm>
			 <indexterm>
				<primary>SCSI</primary>
			</indexterm>
			 <indexterm>
				<primary>シリアル ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>パラレル ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>ATA</primary>
			</indexterm>
			 <indexterm>
				<primary>IEEE 1394</primary>
			</indexterm>
			 <indexterm>
				<primary>Firewire</primary>
			</indexterm>
			 <indexterm>
				<primary>USB</primary>
			</indexterm>
			 <para>
				基本的なことを思い出すことから始めましょう。何よりもまず、コンピュータはハードウェア部品の集合体である、という点です。ほとんどの場合、主要基板 (<emphasis>マザーボード</emphasis>として知られています) があり、主要基板に 1 台 (または複数台) のプロセッサ、RAM、デバイスコントローラ、(他のデバイスコントローラを搭載する) 拡張カードを差し込む拡張スロットが取り付けられています。最も注目すべきコントローラはハードディスクなどのストレージデバイスを接続する IDE (パラレル ATA)、SCSI、シリアル ATA です。その他のコントローラには、多くのさまざまなデバイス (ウェブカメラから温度計、キーボードからホームオートメーションシステムなど) をホストすることが可能な USB と IEEE 1394 (Firewire) があります。これらのコントローラには複数のデバイスを接続することが可能です。このため、コントローラによって取り扱われる完全なサブシステムは「バス」と呼ばれます。拡張カードにはグラフィックカード (モニタ画面をここに接続します)、サウンドカード、ネットワークインターフェースカードなどがあります。一部のマザーボードはいくつかの機能をあらかじめ備えており、拡張カードを必要としません。
			</para>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> ハードウェアが動作していることの確認</title>
			 <para>
				ハードウェアの一部が動作していることを確認することは難しいです。逆に、ハードウェアが動作していないことを証明することはとても簡単です。
			</para>
			 <para>
				ハードディスクドライブは回転する円盤と移動する磁気ヘッドから構成されています。ハードディスクの電源を入れると、円盤モータから特徴的な音が聞こえます。さらに円盤モータはエネルギーを熱として放出します。従って、電源を入れても冷たいままで、音が聞こえないハードディスクドライブは故障しています。
			</para>
			 <para>
				ネットワークカードは多くの場合リンク状態を示す LED を備えています。ケーブルが装着されており、そのケーブルが動いているネットワークハブまたはスイッチにつなげられている場合、少なくとも 1 つの LED が点灯しているはずです。すべての LED が消灯している場合、ネットワークカード本体、ネットワーク機器、両者をつなげるケーブルのどれかが壊れています。それ故、次の段階では各要素を個別にテストします。
			</para>
			 <para>
				一部の拡張カード (特に 3D ビデオカード) はヒートシンクやファンなどの冷却装置を備えています。カードの電源が入っているにも関わらずファンが回転していない場合、もっともらしい状況はカードが過熱している状況です。マザーボードに装着されているプロセッサにも同じことが言えます。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.bios">
			<title>スタート係、BIOS や UEFI</title>
			 <indexterm>
				<primary>BIOS</primary>
			</indexterm>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>マスターブートレコード (MBR)</primary>
			</indexterm>
			 <para>
				ハードウェアはひとりでに動くものではありません。ハードウェアを制御するソフトウェアがなければ、ハードウェアをまともに動作させることはできません。オペレーティングシステムとアプリケーションはハードウェアを制御したりハードウェアと情報をやり取りする機能を提供します。そしてこれを行うためにはハードウェアを正常に機能させる必要があります。
			</para>
			 <para>
				ハードウェアとソフトウェアの共生関係はひとりでに発生するものではありません。コンピュータ起動時には、いくつかの初期設定が必要です。この初期設定を担当しているのが BIOS および UEFI です。BIOS と UEFI はマザーボードに組み込まれた小さなソフトウェアで、起動中に自動的に実行されます。BIOS と UEFI の最も重要な役割に、ハードウェアの制御を引き継ぐソフトウェアを検索する役割があります。BIOS の場合、通常これはブートセクタ (<emphasis>マスターブートレコード</emphasis>や <acronym>MBR</acronym> として知られています) を備えた最初のハードディスクを検索し、ブートセクタを読み込んで、ブートセクタに収められているソフトウェアを実行することに相当します。BIOS の関与する動作はここまでです (次回起動時まで関与しません)。UEFI の場合、後に起動する EFI アプリケーションが収められている専用の EFI パーティションを見つけるためにディスクをスキャンします。
			</para>
			 <sidebar> <title><emphasis>TOOL</emphasis> Setup、BIOS/UEFI 設定ツール</title>
			 <indexterm>
				<primary><emphasis>Setup</emphasis></primary>
			</indexterm>
			 <para>
				BIOS/UEFI には、Setup と呼ばれるソフトウェアが含まれます。Setup はコンピュータを設定する目的で設計されています。特に、Setup を使うことで優先する起動デバイス (たとえば、フロッピーディスクや CD-ROM ドライブなど) を選択したり、システム時計を設定したりすることが可能です。Setup を開始するには、コンピュータ起動直後の非常に早い時期に特定のキーを押します。多くの場合このキーは <keycap>Del</keycap> か <keycap>Esc</keycap> で、時々 <keycap>F2</keycap> や <keycap>F10</keycap> の場合もあります。ほとんどの場合、Setup を開始するキーは起動画面に一瞬表示されます。
			</para>
			 </sidebar> <para>
				ブートセクタ (または EFI パーティション) には別のソフトウェアが保存されています。これはブートローダと呼ばれ、オペレーティングシステムを探して実行するためのものです。ブートローダはマザーボードに組み込まれているのではなく、ディスクから読み込まれます。このため、BIOS よりも多くの機能を持っています。BIOS 自身がオペレーティングシステムを読み込まないのはこれが理由です。たとえば、ブートローダ (Linux システムでは GRUB を使うことが多いです) は利用できるオペレーティングシステムを表示し、ユーザに起動するオペレーティングシステムを尋ねることが可能です。通常、タイムアウトとデフォルトの回答が設定されています。ここでユーザはカーネルに渡すパラメータを追加したりすることも可能です。最終的に、カーネルが見つかり、メモリに読み込まれ、実行されます。
			</para>
			 <sidebar> <title><emphasis>NOTE</emphasis> UEFI、BIOS の現代的な置き換え</title>
			 <indexterm>
				<primary>UEFI</primary>
			</indexterm>
			 <indexterm>
				<primary>セキュアブート</primary>
			</indexterm>
			 <para>
				UEFI は比較的最近開発されたものです。多くの新しいコンピュータは UEFI 起動をサポートしますが、UEFI を活用する準備を整えていないオペレーティングシステムに対する後方互換性を確保するために、BIOS 起動もサポートしていることが多いです。
			</para>
			 <para>
				UEFI 起動という新しいシステムは BIOS 起動にあった制限の一部を克服しています。具体的に言えば、ブートローダ専用パーティションを利用することにより、ブートローダを小さな<emphasis>マスターブートレコード</emphasis>に収めたり、ブートローダに起動するカーネルを見つけさせたりするために特別な策を講じる必要はなくなります。さらに良いことに、適切にビルドされた Linux カーネルを利用することで、中間ブートローダを使わずに UEFI から直接 Linux カーネルを起動することが可能です。また UEFI は<emphasis>セキュアブート</emphasis>を実行するために使われる基盤技術です。<emphasis>セキュアブート</emphasis>技術を使うことで、オペレーティングシステム業者が正当性を認めたソフトウェアだけが実行されることを保証することが可能です。
			</para>
			 </sidebar> <para>
				また、BIOS/UEFI は多数のデバイスを検出して初期化します。言うまでもなくこのデバイスには、IDE/SATA デバイス (通常ハードディスクおよび CD/DVD-ROM デバイス) だけでなく PCI デバイスも含まれます。検出されたデバイスは起動処理中に画面に表示されます。デバイスリストがすぐに消えてしまう場合、<keycap>Pause</keycap> キーを押せば表示を中止して内容を読むことが可能です。インストールされた PCI デバイスがリストに含まれないのは悪い兆しです。最悪の場合、デバイスは欠陥品ということになります。良くても、デバイスは BIOS またはマザーボードの現在のバージョンと互換性がないということになります。PCI 仕様は進化しており、古いマザーボードで新しい PCI デバイスを使える保証はありません。
			</para>

		</section>
		 <section id="sect.kernel">
			<title>カーネル</title>
			 <para>
				BIOS/UEFI とブートローダはそれぞれ数秒間だけ実行されます。これでついに、長時間実行するソフトウェアであるオペレーティングシステムカーネルに到達します。カーネルはオーケストラで言えば指揮者の役割を果たし、ハードウェアとソフトウェア間の調整を行います。カーネルは複数の作業を担当しています。具体的に言えば、ハードウェアの駆動、プロセスの管理、ユーザとパーミッションの管理、ファイルシステムの管理などを担当しています。カーネルはシステム上のすべての他のプログラムに共通基盤を提供するものです。
			</para>

		</section>
		 <section id="sect.userspace-presentation">
			<title>ユーザ空間</title>
			 <para>
				カーネル以外のすべては「ユーザ空間」の意味でひとくくりにされますが、「ユーザ空間」をさらにいくつかのソフトウェア層に分割することが可能です。しかしながら、ソフトウェア層同士の相互作用は以前に比べてさらに複雑化しており、ソフトウェア層の分類分けは単純ではありません。アプリケーションは一般にライブラリを使います。ライブラリはカーネルと通信しますが、通信には他のプログラムまたはさらに多くのライブラリが必要です。
			</para>

		</section>

	</section>
	 <section id="sect.kernel-role-and-tasks">
		<title>カーネルが担当している一部の操作</title>
		 <section id="sect.hardware-drivers">
			<title>ハードウェアの操作</title>
			 <para>
				カーネルの責務は何を差し置いてもまず、ハードウェア部分を制御したり、検出したり、コンピュータ起動時にハードウェア部分のスイッチを ON にしたりすることです。さらにカーネルは単純化されたプログラミングインターフェースを使った高レベルソフトウェアからハードウェアを利用できるようにします。こうすることで、アプリケーションは拡張カードがどの拡張スロットに接続されているかなどの詳細を気にすることなくデバイスをうまく活用することが可能になります。さらにこのプログラミングインターフェースは抽象化レイヤを提供します。そして抽象化レイヤを使うことで、たとえばビデオ会議ソフトウェアは種類やモデル番号を気にせずにウェブカメラを使うことが可能です。すなわち、ビデオ会議ソフトウェアは <emphasis>Video for Linux</emphasis> (V4L) インターフェースを使うだけでよいのです。そしてカーネルが V4L インターフェースの機能呼び出しを特定のウェブカメラを制御するために必要な実際のハードウェアコマンドに変換します。
			</para>
			 <para>
				<indexterm><primary><command>lspci</command></primary></indexterm><indexterm><primary><command>lsusb</command></primary></indexterm><indexterm><primary><command>lsdev</command></primary></indexterm><indexterm><primary><command>lspcmcia</command></primary></indexterm>カーネルは検出されたハードウェアに関する多くの詳細を <filename>/proc/</filename> と <filename>/sys/</filename> 仮想ファイルシステムを通じて書き出します。ハードウェアの詳細をまとめて表示するツールも存在します。中でも、<command>lspci</command> (<emphasis role="pkg">pciutils</emphasis> パッケージに含まれます) は PCI デバイスをリストし、<command>lsusb</command> (<emphasis role="pkg">usbutils</emphasis> パッケージに含まれます) は USB デバイスをリストし、<command>lspcmcia</command> (<emphasis role="pkg">pcmciautils</emphasis> パッケージに含まれます) は PCMCIA カードをリストします。これらのツールはデバイスの正確なモデル番号を識別するのに役立ちます。デバイスの正確なモデル番号を使えば、より的確に検索したり、より関連性の高い文書を見つけることが可能です。
			</para>
			 <example>
				<title><command>lspci</command> と <command>lsusb</command> で提供される情報の一例</title>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>lspci</userinput>
<computeroutput>[...]
00:02.1 Display controller: Intel Corporation Mobile 915GM/GMS/910GML Express Graphics Controller (rev 03)
00:1c.0 PCI bridge: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1 (rev 03)
00:1d.0 USB Controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 03)
[...]
01:00.0 Ethernet controller: Broadcom Corporation NetXtreme BCM5751 Gigabit Ethernet PCI Express (rev 01)
02:03.0 Network controller: Intel Corporation PRO/Wireless 2200BG Network Connection (rev 05)
$ </computeroutput><userinput>lsusb</userinput>
<computeroutput>Bus 005 Device 004: ID 413c:a005 Dell Computer Corp.
Bus 005 Device 008: ID 413c:9001 Dell Computer Corp.
Bus 005 Device 007: ID 045e:00dd Microsoft Corp.
Bus 005 Device 006: ID 046d:c03d Logitech, Inc.
[...]
Bus 002 Device 004: ID 413c:8103 Dell Computer Corp. Wireless 350 Bluetooth
</computeroutput></screen>

			</example>
			 <para>
				これらのプログラムは <literal>-v</literal> オプションを用意しています。<literal>-v</literal> オプションを使うことで、より詳しい (通常は不要な) 情報が表示されます。最後に、<command>lsdev</command> コマンド (<emphasis role="pkg">procinfo</emphasis> に含まれます) はデバイスによって使われている通信リソースをリストします。
			</para>
			 <para>
				アプリケーションは <filename>/dev/</filename> 内に作られた特殊ファイル (補注<xref linkend="sidebar.special-files" />を参照してください) を介してデバイスにアクセスする場合が多いです。<filename>/dev/</filename> 内には特殊ファイルがあり、これらはディスクドライブ (たとえば <filename>/dev/hda</filename> や <filename>/dev/sdc</filename>)、パーティション (<filename>/dev/hda1</filename> や <filename>/dev/sdc3</filename>)、マウス (<filename>/dev/input/mouse0</filename>)、キーボード (<filename>/dev/input/event0</filename>)、サウンドカード (<filename>/dev/snd/*</filename>)、シリアルポート (<filename>/dev/ttyS*</filename>) などを表しています。
			</para>

		</section>
		 <section id="sect.filesystems">
			<title>ファイルシステム</title>
			 <indexterm>
				<primary>ファイルシステム</primary>
			</indexterm>
			 <indexterm>
				<primary>システム、ファイルシステム</primary>
			</indexterm>
			 <para>
				ファイルシステムはカーネルの最も卓越した側面の 1 つです。Unix システムはすべてのファイル保存領域を単独の階層構造の中に融合させます。こうすることで、ユーザ (とアプリケーション) は階層構造の中のファイルの場所を知るだけでデータにアクセスすることが可能です。
			</para>
			 <para>
				階層構造ツリーの基点はルート、<filename>/</filename>、と呼ばれています。ルートディレクトリには名前を付けられたサブディレクトリが含まれます。たとえば、<filename>/</filename> の <literal>home</literal> サブディレクトリは <filename>/home/</filename> と呼ばれます。このサブディレクトリには、さらに別のサブディレクトリを含めることが可能です。各ディレクトリには、実際のデータが保存されるファイルを含めることも可能です。そんなわけで、<filename>/home/rmas/Desktop/hello.txt</filename> ファイルはルートディレクトリ内の <literal>home</literal> サブディレクトリ内の <literal>rmas</literal> サブディレクトリ内の <literal>Desktop</literal> サブディレクトリ内の <literal>hello.txt</literal> と名付けられたファイルを表します。カーネルはこの命名システムと実際のディスク上の物理的な保存領域を変換します。
			</para>
			 <para>
				他のシステムと異なり、階層構造は 1 つしかありません。そしてこの単独の階層構造は複数のディスクに保存されたデータを統合できます。1 台のディスクがルートディレクトリとして使われ、他のディスクは階層構造中のディレクトリに「マウント」されます (これを行う Unix コマンドは <command>mount</command> と呼ばれます)。マウントされたディスクは「マウントポイント」の下から利用できるようになります。これのおかげで、2 台目のハードディスクに <literal>rhertzog</literal> や <literal>rmas</literal> ディレクトリなどのユーザホームディレクトリ (伝統的に <filename>/home/</filename> の中に保存されます) を保存することが可能になります。2 台目のハードディスクを <filename>/home/</filename> にマウントすると、ユーザのホームディレクトリの通常の場所からこれらのディレクトリにアクセスできるようになり、<filename>/home/rmas/Desktop/hello.txt</filename> などのパスが動作するようになります。
			</para>
			 <indexterm>
				<primary><command>mkfs</command></primary>
			</indexterm>
			 <para>
				ディスク上にデータを保存する物理的な方法の違いに対応して、多くのファイルシステムが存在します。最も広く知られているファイルシステムは <emphasis>ext2</emphasis>、<emphasis>ext3</emphasis>、<emphasis>ext4</emphasis> ですが、他にも存在します。たとえば、<emphasis>vfat</emphasis> は歴史的に DOS と Windows オペレーティングシステムで使われていたファイルシステムで、<emphasis>vfat</emphasis> ファイルシステムを使っているハードディスクは Debian および Windows 環境下で使うことが可能です。いかなる場合でも、ディスクをマウントする前に必ずディスク上にファイルシステムを準備しなければいけません。この準備作業は「フォーマット」として知られています。フォーマットを行うには <command>mkfs.ext3</command> (ここで <command>mkfs</command> は <emphasis>MaKe FileSystem</emphasis> の略語です) などのコマンドを使います。<command>mkfs.ext3</command> などのコマンドには、フォーマットされるパーティションを指すデバイスファイル (たとえば <filename>/dev/sda1</filename>) をパラメータとして渡す必要があります。ファイルシステムの作成作業は破壊的なものです。意図的にファイルシステムを完全に消去して、最初からやり直したい場合を除いて、2 回やってはいけません。
			</para>
			 <para>
				さらに <acronym>NFS</acronym> などのネットワークファイルシステムも存在します。ネットワークファイルシステムを使った場合、データはローカルディスクに保存されません。その代わり、データはネットワークを介してサーバに送信されます。サーバは要求に応じてデータを書き込んだり、読み出したりします。ファイルシステムを抽象化したことにより、ユーザが特に心がける点はなくなります。すなわち、ファイルは通常の階層構造的な方法を使ってアクセスできます。
			</para>

		</section>
		 <section id="sect.shared-functions">
			<title>機能の共有</title>
			 <para>
				数多くの同じ機能がすべてのソフトウェアで使われますから、これらの機能をカーネルに集中させることは合理的です。たとえば、共有のファイルシステム操作機能を使うことで、名前から簡単にファイルを開くことが可能になります。ファイルが物理的に保存されている場所を気にする必要はありません。ファイルは 1 台のハードディスクの複数の異なる部分に保存したり、複数のハードディスクにわたって分割保存したり、リモートファイルサーバに保存することが可能です。アプリケーションはデータを交換するために共有の通信機能を使います。アプリケーション側からするとデータを転送する方法を意識する必要はありません。たとえば、データ転送はローカル、ワイヤレスネットワーク、固定電話回線の任意の組み合わせを通じて行われるかもしれません。
			</para>

		</section>
		 <section id="sect.process-management">
			<title>プロセス管理</title>
			 <indexterm>
				<primary><emphasis>pid</emphasis></primary>
			</indexterm>
			 <para>
				プロセスとはプログラムの実行中インスタンスです。プロセスはプログラム自身とその動作データを保存するためのメモリを要求します。カーネルはプロセスの作成と追跡を担当します。プログラムが実行されると、カーネルは最初に幾らかのメモリを確保し、次にファイルシステムから確保したメモリに実行コードを読み込み、次にコードの実行を開始します。カーネルはプロセスに関する情報を保持します。中でも最もよく目にする情報は <emphasis>pid</emphasis> (<emphasis>プロセス ID</emphasis>) として知られる識別番号です。
			</para>
			 <para>
				Unix 系カーネル (Linux を含めて) は、多くの他の現代的なオペレーティングシステムと同様、「マルチタスク」機能を備えています。言い換えれば、Unix 系カーネルは多くのプロセスを「同時に」実行することが可能です。ある時点で動いているのは 1 つのプロセスだけですが、カーネルは時間を小さな単位に切り分け、順繰りにそれぞれのプロセスを実行しています。これらの時分割単位は極めて短い (ミリ秒程度) ので、プロセスが並列実行されているような錯覚を起こさせます。しかし実際のところプロセスはある時間周期で活動しており、残りの時間は動いていません。カーネルの作業はこの錯覚を保つためにスケジューリングメカニズムを調節し、同時にシステム全体の性能を最大化することです。時分割単位が長すぎる場合、アプリケーションが要求通りの反応をしていないように感じるかもしれません。時分割単位が短すぎる場合、タスク切り替えが頻繁に起こるようになり、システムは処理時間を損することになります。プロセス優先度を使えば、時分割単位を微調整することが可能です。優先度の高いプロセスは優先度の低いプロセスに比べて長くそしてより頻繁な時分割単位で実行されます。
			</para>
			 <sidebar> <title><emphasis>NOTE</emphasis> マルチプロセッサシステム (とその亜種)</title>
			 <para>
				ある時点に実行できるプロセスはたった 1 つという上で説明した制限は必ずしも適用できるとは限りません。実用上の制限としては、同時に実行されるプロセスの数は<emphasis>プロセッサのコア 1 つ当たり</emphasis> 1 つという制限です。マルチプロセッサ、マルチコア、「ハイパースレッディング」システムを使うことで、複数のプロセスを並列実行することが可能です。ここでも同じ時分割システムを使いますが、このシステムは利用できるプロセッサコアの数よりも多くのプロセスを実行させるようなケースを取り扱うことが可能です。これは決して珍しいことではありません。すなわち、基本システムはほとんど動いていませんが、ほとんど常時数十個の実行中プロセスを抱えています。
			</para>
			 </sidebar> <para>
				もちろん、カーネルは同じプログラムの複数の独立したインスタンスも取り扱うことが可能です。しかし各プロセスは自分自身以外の時分割単位とメモリにアクセスすることは不可能です。このため、プロセスごとのデータは独立に管理されています。
			</para>

		</section>
		 <section id="sect.permissions">
			<title>権限管理</title>
			 <para>
				Unix 系システムはマルチユーザに対応しています。Unix 系システムはグループとユーザの別々な管理をサポートする権限管理システムを提供しています。さらに、パーミッションに基づいて動作を制御することも可能です。カーネルは各プロセスに対するデータを管理し、そのデータを使ってパーミッションを制御します。ほとんどの場合、プロセスはプロセスを開始したユーザと同じユーザ ID を持ちます。そして、プロセスは自分を開始した所有者が実行できる動作だけを実行することが可能です。たとえば、プロセスがファイルを開くためには、カーネルによってそのプロセスのユーザ ID が対象のファイルへのアクセスパーミッションを持つことが確認されなければいけません (具体的な例についてのより詳しい情報は<xref linkend="sect.rights-management" />をご覧ください)。
			</para>

		</section>

	</section>
	 <section id="sect.user-space">
		<title>ユーザ空間</title>
		 <indexterm>
			<primary>ユーザ空間</primary>
		</indexterm>
		 <indexterm>
			<primary>カーネル空間</primary>
		</indexterm>
		 <para>
			「ユーザ空間」とは通常 (カーネルに対するという意味) プロセスの実行環境を意味します。「ユーザ空間」プロセスとは実際にユーザによって開始されたプロセスという意味ではありません。なぜなら、標準的なシステムでは通常、ユーザがセッションを開始する前から実行されている複数の「デーモン」(またはバックグラウンド) プロセスが存在するからです。デーモンプロセスもまたユーザ空間プロセスと考えられます。
		</para>
		 <section id="sect.process-basics">
			<title>プロセス</title>
			 <indexterm>
				<primary><command>init</command></primary>
			</indexterm>
			 <para>
				カーネルはその初期化終了後に、最初のプロセスである <command>init</command> を開始します。最初のプロセスである <command>init</command> それ自身が役に立つことはほとんどなく、Unix 系システムは多くの追加的プロセスと一緒に動いています。
			</para>
			 <indexterm>
				<primary><emphasis>フォーク</emphasis></primary>
			</indexterm>
			 <para>
				第一に、プロセスは自分自身を複製することが可能です (これは<emphasis>フォーク</emphasis>として知られています)。カーネルは新しい (全く同じ) プロセスメモリ空間とそれを使うもう一つ別のプロセスを割り当てます。この時点で、2 つのプロセスの違いは <emphasis>pid</emphasis> だけです。新しいプロセスは通常子プロセスと呼ばれています。そして <emphasis>pid</emphasis> が変わらなかったプロセスは親プロセスと呼ばれています。
			</para>
			 <para>
				しばしば、子プロセスは親プロセスからコピーされたデータを持った状態で、親プロセスから独立して引き続き実行されます。とは言うものの、子プロセスは他のプログラムを実行する場合が多いです。この場合、いくつかの例外を除いて、子プロセスのメモリは単純に新しいプログラムで置き換えられ、新しいプログラムの実行が始まります。このメカニズムを使用して、init プロセス (プロセス ID が 1 のプロセス) は追加的サービスを起動し起動シーケンスの全体を実行します。同時に、<command>init</command> の子プロセスの 1 つがログイン機能を提供するユーザ用のグラフィカルインターフェースを開始します (実際のイベントの順番は<xref linkend="sect.system-boot" />に詳しく書かれています)。
			</para>
			 <para>
				プロセスは自分が開始したタスクを完了したら、終了します。その後、カーネルがこのプロセスに割り当てられたメモリを回収し、カーネルはプロセスに実行時間を与えることを停止します。親プロセスは子プロセスが終了したことについて通知を受けます。このおかげで、親プロセスは子プロセスに委託したタスクの完了を待つことが可能になります。コマンドラインインタプリタ (<emphasis>シェル</emphasis>として知られています) ではこの挙動がはっきりと見えます。コマンドがシェルに入力された場合、コマンドの実行が終了するまでプロンプトは戻って来ません。多くのシェルでは、コマンドをバックグラウンドで実行することが可能です。これを行うには、コマンドの最後に <userinput>&amp;</userinput> を追加するだけです。この場合、プロンプトはすぐに戻ってきます。バックグラウンドで実行されるコマンドがデータを表示する場合、このやり方は問題を引き起こすかもしれません。
			</para>

		</section>
		 <section id="sect.daemons">
			<title>デーモン</title>
			 <indexterm>
				<primary>デーモン</primary>
			</indexterm>
			 <indexterm>
				<primary>デーモン</primary>
			</indexterm>
			 <para>
				「デーモン」は起動シーケンスによって自動的に開始されるプロセスです。「デーモン」はメンテナンス作業を実行したり他のプロセスにサービスを提供するために (バックグラウンドで) 実行され続けます。ここで実際の「バックグラウンドタスク」はどんなものでも構いませんし、システムの観点から何か特別なタスクを意味しているわけでもありません。「バックグラウンドタスク」は単なるプロセスで、他のプロセスとよく似ており、自分に割り当てられたタイムスライスが来た時に動きます。プロセスの区別は人間の言葉に過ぎません。そして、ユーザと対話せずに実行される (特にグラフィカルインターフェースを持たない) プロセスは「バックグラウンドで実行される」とか「デーモンとして実行される」などと表現されます。
			</para>
			 <sidebar> <title><emphasis>VOCABULARY</emphasis> Daemon (守り神)、demon (悪魔)、軽蔑語?</title>
			 <para>
				<emphasis>daemon</emphasis> という用語はギリシャ神話の <emphasis>demon</emphasis> を起源とするにも関わらず、<emphasis>daemon</emphasis> は暗に残虐な悪魔を意味するものではなく、その代わりに <emphasis>daemon</emphasis> は守り神のようなものとして理解されています。この区別は英語ではかなりわかりにくいものです。さらに、両方の意味を同じ言葉で表している他の言語ではもっとわかりにくいです。
			</para>
			 </sidebar> <para>
				いくつかのデーモンは<xref linkend="unix-services" />で詳細に説明されています。
			</para>

		</section>
		 <section id="sect.ipc">
			<title>プロセス間通信</title>
			 <indexterm>
				<primary>IPC</primary>
			</indexterm>
			 <indexterm>
				<primary>プロセス間通信</primary>
			</indexterm>
			 <para>
				デーモンでも対話型アプリケーションでも、単独のプロセスでは役に立たない場合が多いです。このため、異なるプロセス同士がデータを交換したり、相互に制御し合うためのさまざまな通信方法があります。これを意味する一般的な用語が<emphasis>プロセス間通信</emphasis> (略して IPC) です。
			</para>
			 <para>
				最も簡単な IPC システムではファイルを使います。データ送信側のプロセスが送信内容をファイルに書き込み (事前にファイル名を決めておく必要があります)、受信側はファイルを開いてその内容を読むだけです。
			</para>
			 <indexterm>
				<primary><emphasis>パイプ</emphasis></primary>
			</indexterm>
			 <para>
				データをディスクに保存したくないと思っているならば、<emphasis>パイプ</emphasis>を使うことが可能です。<emphasis>パイプ</emphasis>は 2 つの端を持つ単純なオブジェクトです。そして、片側に書き込まれたデータを逆側から読み出すことが可能です。パイプの一方の端が別のプロセスによって制御されている場合、パイプは単純で便利なプロセス間通信チャネルになります。パイプは 2 種類に分類分けされます。すなわち名前付きパイプと無名パイプに分類分けされます。名前付きパイプはファイルシステム上のエントリによって表現されます (転送されたデータは保存されません)。このため、事前に名前付きパイプの場所がわかっていれば、2 つのプロセスが独立に名前付きパイプを開くことが可能です。通信プロセス同士に関連性がある場合 (たとえば、親と子プロセス)、親プロセスはフォークの前に無名パイプを作成し、子プロセスがこれを継承するだけで済みます。両方のプロセスはパイプを通じてデータを交換することが可能です。ファイルシステムは必要ありません。
			</para>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> 具体例</title>
			 <para>
				それでは、複雑なコマンド (<emphasis>パイプライン</emphasis>) がシェルから実行された場合に何が起きるか詳しく説明しましょう。<emphasis>pid</emphasis> #4374 の <command>bash</command> プロセス (Debian の標準的なユーザシェル) があると仮定します。このシェルの中で、次のコマンドを入力します。<command>ls | sort</command>。
			</para>
			 <para>
				最初にシェルは入力されたコマンドを解釈します。今回の場合、シェルは 2 種類のプログラム (<command>ls</command> と <command>sort</command>) が存在して、一方からもう一方へ流れるデータストリーム (<userinput>|</userinput> 文字によって表されます。これは<emphasis>パイプ</emphasis>としても知られています) があると理解します。<command>bash</command> は最初に無名パイプ (これは <command>bash</command> プロセス自身の中だけに存在します) を作成します。
			</para>
			 <para>
				その後、シェルは自分自身の複製を作ります。そしてこれは新しい <command>bash</command> プロセスで <emphasis>pid</emphasis> #4521 を持っています (<emphasis>pid</emphasis> は抽象的な数で、一般に特別な意味はありません)。プロセス #4521 はパイプを継承します。これは「入力」側に書き込むことが可能ということを意味しています。さらに <command>bash</command> は自分の標準出力ストリームをパイプの入力にリダイレクトします。その後、<command>bash</command> は <command>ls</command> プログラムを実行します (さらに自分自身を <command>ls</command> で置き換えます)。<command>ls</command> は現在のディレクトリの内容をリストします。<command>ls</command> の書き込み先は標準出力で、この出力はあらかじめリダイレクトされていたため、結果はパイプに送られます。
			</para>
			 <para>
				2 番目のコマンドについても同様の操作が行われます。つまり <command>bash</command> はもう一度自分自身の複製を作り、これにより pid #4522 の新しい <command>bash</command> プロセスが作成されます。pid #4522 の新しい <command>bash</command> プロセスは #4374 の子プロセスで、パイプを継承します。さらに <command>bash</command> は自分の標準入力をパイプの出力に接続し、その後 <command>sort</command> コマンドを実行します (さらに自分自身を <command>sort</command> で置き換えます)。<command>sort</command> コマンドは自分への入力をソートして結果を表示します。
			</para>
			 <para>
				これで、パズルのすべてのピースがそろった状態になります。つまり <command>ls</command> は現在のディレクトリを読み込んで、ファイルのリストをパイプに書き込みます。さらに <command>sort</command> はファイルのリストを読み込んで、アルファベット順にソートして、結果を表示します。プロセス ID が #4521 と #4522 のプロセスは終了し、#4374 (これは実行中の他プロセスが終了するのを待っていました) は制御を取り戻し、ユーザが新しいコマンドを入力するためのプロンプトを表示します。
			</para>
			 </sidebar> <para>
				しかしながら、すべてのプロセス間通信がデータを移動させるために使われるわけではありません。多くの状況で、送信する必要のある情報は「実行を一時停止」や「実行を再開」などの制御メッセージです。Unix (と Linux) は<emphasis>シグナル</emphasis>として知られているメカニズムを提供します。このメカニズムを使って、あるプロセスは別のプロセスに対して簡単に特定のシグナルを送信することが可能です (送信するシグナルは事前に定義されたシグナルのリストから選びます)。送信に必要な情報は送信先の <emphasis>pid</emphasis> だけです。
			</para>
			 <para>
				さらに複雑な通信を行うには、プロセスが他のプロセスに対して自分が割り当てられたメモリの一部へのアクセス制限を解除したり、共有したりするメカニズムを使います。これで、プロセス間で共有されたメモリをデータ交換のために使うことが可能になります。
			</para>
			 <para>
				最後に、ネットワーク接続を使ってプロセス同士を通信させることが可能です。そして数千キロ離れた異なるコンピュータで動いているプロセス同士でも通信することが可能です。
			</para>
			 <para>
				典型的な Unix 系システムでは、さまざまなレベルでこれらのメカニズムを使っており、かなり標準的な手法になっています。
			</para>

		</section>
		 <section id="sect.libraries">
			<title>ライブラリ</title>
			 <indexterm>
				<primary>関数ライブラリ</primary>
			</indexterm>
			 <para>
				関数ライブラリは Unix 系オペレーティングシステムで重要な役割を果たします。関数ライブラリは厳密な意味のプログラムではありません。なぜなら、関数ライブラリ自体は実行できず、標準的なプログラムで使用されるコードの断片に過ぎないからです。よく使われるライブラリの中でも特に以下のものが有名です。
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						標準 C ライブラリ (<emphasis>glibc</emphasis>)。これにはファイルやネットワーク接続を開く関数やカーネルとの通信を容易にする関数などの基本的な関数が含まれます。
					</para>

				</listitem>
				 <listitem>
					<para>
						Gtk+ と Qt などのグラフィカルツールキット。これを使うことで、多くのプログラムはツールキットの提供するグラフィカルオブジェクトを再利用することが可能です。
					</para>

				</listitem>
				 <listitem>
					<para>
						<emphasis>libpng</emphasis> ライブラリ。これを使うことで、PNG フォーマットイメージを読み込み、編集、保存することが可能になります。
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				これらのライブラリのおかげで、アプリケーションは既存のコードを再利用することが可能です。多くのアプリケーションは同じ関数を再利用できるため、アプリケーションの開発は単純化されます。また、通常それぞれのライブラリは別の人によって開発されているため、アプリケーションの大域的な開発は Unix の歴史的哲学に近いものになります。
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> Unix 流、一度に一つのことをせよ</title>
			 <para>
				Unix 系オペレーティングシステムの根底にある基本的概念の一つとして、それぞれのツールがたった 1 つのことを担当し、それをうまくこなす、というものがあります。そしてアプリケーションはこれらのツールを再利用して、より高度な論理を作り上げることが可能です。この根本原理はさまざまな形で具現化されています。シェルスクリプトは最良の例かもしれません。具体的に言えば、シェルスクリプトは極めて簡単なツール (たとえば <command>grep</command>、<command>wc</command>、<command>sort</command>、<command>uniq</command> など) を複雑に並べたものです。コードライブラリも基本的概念を具現化したものとみなすことが可能です。すなわち <emphasis>libpng</emphasis> ライブラリを使うことで、さまざまなオプションとさまざまな方法を使って、PNG イメージの読み込みと書き込みを行うことが可能です。しかし、<emphasis>libpng</emphasis> ライブラリはそれ以上のことを行いません。従って、イメージを表示したり編集する関数は全く含まれません。
			</para>
			 </sidebar> <para>
				さらに、これらのライブラリは「共有ライブラリ」とも呼ばれています。なぜなら、複数のプロセスが同じライブラリを同時に使う場合、カーネルはライブラルの読み込みを 1 回だけで済ませることが可能だからです。プロセスが使うライブラリのコードを何度も読み込むような逆の (仮想的な) 状況に比べて、これはメモリを節約することになります。
			</para>

		</section>

	</section>
</appendix>

