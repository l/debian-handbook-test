<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="network-infrastructure" lang="ja-JP">
	<chapterinfo>
		 <keywordset>
			<keyword>ネットワーク</keyword>
			 <keyword>ゲートウェイ</keyword>
			 <keyword>TCP/IP</keyword>
			 <keyword>IPv6</keyword>
			 <keyword>DNS</keyword>
			 <keyword>Bind</keyword>
			 <keyword>DHCP</keyword>
			 <keyword>QoS</keyword>

		</keywordset>

	</chapterinfo>
	 <title id="infrastructure.title">ネットワークインフラ</title>
	 <highlights> <para>
		Linux はネットワークに関する Unix の財産すべてを受け継ぎ、Debian はネットワークを作成および管理する完全なツールセットを提供します。この章では、これらのツールを説明します。
	</para>
	 </highlights> <section id="sect.gateway">
		<title>ゲートウェイ</title>
		 <para>
			ゲートウェイは複数のネットワークを連結するシステムです。ゲートウェイという用語は外部 IP アドレスに向かう経路に出るために必須のローカルネットワークの「出口」を意味する場合が多いです。ゲートウェイは相互に連結する各ネットワークに接続されており、複数のインターフェース間で IP パケットを相互に伝送するためのルータとして振る舞います。
		</para>
		 <indexterm>
			<primary>ゲートウェイ</primary>
		</indexterm>
		 <indexterm>
			<primary>ネットワーク</primary>
			<secondary>ゲートウェイ</secondary>
		</indexterm>
		 <indexterm>
			<primary>ルータ</primary>
		</indexterm>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> IP パケット</title>
		 <indexterm>
			<primary>パケット</primary>
			<secondary>IP パケット</secondary>
		</indexterm>
		 <para>
			今日、多くのネットワークは IP プロトコル (<emphasis>インターネットプロトコル</emphasis>) を使います。IP プロトコルは転送するデータを適当なサイズのパケットに分割します。それぞれのパケットには、実データ本体に加えて、適切な経路選択に必要な数々のデータが含まれます。
		</para>
		 </sidebar> <sidebar id="sidebar.tcp-udp"> <title><emphasis>BACK TO BASICS</emphasis> TCP/UDP</title>
		 <indexterm>
			<primary>ポート</primary>
			<secondary>TCP</secondary>
		</indexterm>
		 <indexterm>
			<primary>ポート</primary>
			<secondary>UDP</secondary>
		</indexterm>
		 <indexterm>
			<primary>TCP、ポート</primary>
		</indexterm>
		 <indexterm>
			<primary>UDP、ポート</primary>
		</indexterm>
		 <para>
			IP を使ってデータを送信する場合であっても、プログラムが個々のパケットそれ自体を処理することはほとんどありません。多くのプログラムは TCP (<emphasis>Transmission Control Protocol</emphasis>) を使います。TCP は IP 上のレイヤで、2 点間にデータストリーム専用の接続を確立することが可能です。TCP を使うプログラムはデータを送り込むための入口を考慮するだけです。この入口から送信されたデータは接続の別の側にある出口から損失なく同じデータが (同じ順番で) 出てくると保証されます。TCP よりも下層のレイヤで起きるさまざまなエラーは TCP によって補正されます。具体的に言えば、損失したパケットはもう一度転送され、順番が狂って到着したパケット (たとえば、異なる経路で到着したために) は適切な順番にそろえられます。
		</para>
		 <para>
			IP に依存するもう 1 つのプロトコルが UDP (<emphasis>User Datagram Protocol</emphasis>) です。TCP と対照的に、UDP はパケット重視です。UDP の目標は TCP と異なります。すなわち、UDP の目標は 1 個のパケットをあるアプリケーションから別のアプリケーションに転送するだけです。UDP を使った場合、転送中のパケット損失は補償されませんし、パケットが送信順と同じ順番で受信されることも保証されません。UDP の主な利点は遅延が大きく改善される点です。なぜなら、1 パケットを損失しても、損失したパケットの再転送要求を出さないかぎり、損失したパケット以降に続くパケットの受信は遅延しないからです。
		</para>
		 <para>
			TCP と UDP はどちらもポート番号を使います。ポート番号とは、マシン上で動くあるアプリケーションと通信を確立するための「内線番号」と言えます。この概念を使うことで、同一のマシンに対して複数の異なる通信を並列して保つことが可能になります。なぜなら、通信はポート番号で区別されるからです。
		</para>
		 <para>
			IANA (<emphasis>Internet Assigned Numbers Authority</emphasis>) が標準化したいくつかのポート番号は「well-known」とされ、ネットワークサービスに関連付けられています。たとえば、TCP ポート 25 番は一般に電子メールサーバが使うポート番号として標準化されています。<ulink type="block" url="http://www.iana.org/assignments/port-numbers" />
		</para>
		 </sidebar> <para>
			ローカルネットワークがプライベートアドレス (インターネットにルーティングされないアドレス) 範囲を使う場合、ゲートウェイは<emphasis>アドレスマスカレード</emphasis>を実行する必要があります。<emphasis>アドレスマスカレード</emphasis>を使うことで、ローカルネットワーク上のマシンが外部と通信することが可能になります。マスカレード動作とはネットワークレベルのプロキシ動作のようなものです。すなわち、内部のマシンからの外部宛接続はゲートウェイ自身からの接続に置き替えられます (なぜなら、ゲートウェイは外部にルーティングできるアドレスを持っているからです)。マスカレード接続を通過するデータは外部に送信され、応答として戻ってくるデータはマスカレード接続を通過して内部のマシンに送信されます。ゲートウェイはこの目的に専用の TCP ポート範囲を使います。この範囲は通常とても大きな番号 (60000 番より大きい番号) です。内部マシンからの接続はこれらの予約されたポート番号の 1 つから送信された接続として外部に送信されます。
		</para>
		 <indexterm>
			<primary>マスカレード</primary>
		</indexterm>
		 <sidebar> <title><emphasis>CULTURE</emphasis> プライベートアドレス範囲</title>
		 <indexterm>
			<primary>IP アドレス</primary>
			<secondary>プライベート</secondary>
		</indexterm>
		 <indexterm>
			<primary>プライベート IP アドレス</primary>
		</indexterm>
		 <para>
			RFC 1918 では、インターネットにルーティングされずローカルネットワークにのみ使うことができる、IPv4 アドレスの範囲が定義されています。1 番目の <literal>10.0.0.0/8</literal> (補注<xref linkend="sidebar.networking-basics" />を参照してください) は 1 個のクラス A 範囲です (クラス A には 2<superscript>24</superscript> 個の IP アドレスが含まれます)。2 番目の <literal>172.16.0.0/12</literal> は 16 個のクラス B 範囲です (<literal>172.16.0.0/16</literal> から <literal>172.31.0.0/16</literal> まで)。クラス B には 2<superscript>16</superscript> 個の IP アドレスが含まれます。3 番目の <literal>192.168.0.0/16</literal> は 1 個のクラス B 範囲です (<literal>192.168.0.0/24</literal> から <literal>192.168.255.0/24</literal> までの 256 個のクラス C 範囲とも考えられます)。クラス C には 256 個の IP アドレスが含まれます。<ulink type="block" url="http://www.faqs.org/rfcs/rfc1918.html" />
		</para>
		 </sidebar> <para>
			ゲートウェイでは 2 種類の<emphasis>ネットワークアドレス変換</emphasis> (略して NAT) が実行されます。1 種類目は <emphasis>Destination NAT</emphasis> (DNAT) で、(通常は) 到着した接続の宛先 IP アドレス (および TCP や UDP ポート) を書き換える手法です。接続追跡メカニズムによって、通信の継続性を保証するために同じ接続でそれ以降に使われるパケットの宛先が書き換えられます。NAT の 2 種類目は <emphasis>Source NAT</emphasis> (SNAT) で、<emphasis>マスカレード</emphasis>は SNAT の特別な場合です。SNAT は (通常は) 出て行く接続のソース IP アドレス (および TCP や UDP ポート) を書き換えます。DNAT に関して言えば、出て行く接続の全パケットが接続追跡メカニズムによって適切に取り扱われます。NAT は IPv4 と IPv4 の制限されたアドレス空間だけに関連します。一方で IPv6 では、アドレス空間が広くなったことにより、すべての「内部」アドレスは直接インターネットにルーティングできるようになるため、NAT の有用性が減ります (これは内部マシンにアクセスできるようになることを意味しているのではありません。なぜなら、中間ファイアウォールがトラフィックをフィルタするからです)。
		</para>
		 <indexterm>
			<primary>NAT</primary>
		</indexterm>
		 <indexterm>
			<primary>ネットワーク</primary>
			<secondary sortas="アドレスヘンカン">アドレス変換</secondary>
		</indexterm>
		 <indexterm>
			<primary>SNAT</primary>
		</indexterm>
		 <indexterm>
			<primary>DNAT</primary>
		</indexterm>
		 <indexterm>
			<primary>Destination NAT</primary>
		</indexterm>
		 <indexterm>
			<primary>Source NAT</primary>
		</indexterm>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> ポート転送</title>
		 <indexterm>
			<primary sortas="ポートテンソウ">ポート転送</primary>
		</indexterm>
		 <para>
			DNAT の具体的な応用例が<emphasis>ポート転送</emphasis>です。マシンのあるポートに到着する接続が他のマシンのあるポートに転送されます。特にアプリケーションレベルでは <command>ssh</command> (<xref linkend="sect.ssh-port-forwarding" />を参照してください) や <command>redir</command> などを使うことで、同じ効果を果たす別の解決策が存在するかもしれません。
		</para>
		 </sidebar> <para>
			理論はここまでにして、具体的な例を説明します。Debian システムをゲートウェイとして機能させるには、以下に示す通り <filename>/proc/</filename> 仮想ファイルシステムを使って、Linux カーネルの適切なオプションを有効化するだけです。
		</para>
		 
<screen>
<computeroutput># </computeroutput><userinput>echo 1 &gt; /proc/sys/net/ipv4/conf/default/forwarding</userinput></screen>
		 <para>
			このオプションを起動時に自動的に有効化するには、<filename>/etc/sysctl.conf</filename> の <literal>net.ipv4.conf.default.forwarding</literal> オプションを <literal>1</literal> に設定してください。
		</para>
		 <example id="example.sysctl.conf">
			<title><filename>/etc/sysctl.conf</filename> ファイル</title>
			 
<programlisting>
net.ipv4.conf.default.forwarding = 1
net.ipv4.conf.default.rp_filter = 1
net.ipv4.tcp_syncookies = 1</programlisting>

		</example>
		 <para>
			IPv6 に対して同様の効果を与えるには、IPv4 に対して手作業で行ったコマンドの <literal>ipv4</literal> を単純に <literal>ipv6</literal> へ置換して実行するか、<filename>/etc/sysctl.conf</filename> 中の <literal>net.ipv6.conf.all.forwarding</literal> オプションを <literal>1</literal> に設定してください。
		</para>
		 <para>
			IPv4 マスカレードを設定するには少し複雑な作業が必要です。すなわち <emphasis>netfilter</emphasis> ファイアウォールを設定する必要があります。
		</para>
		 <para>
			同様に、(IPv4 で) NAT を使うには <emphasis>netfilter</emphasis> の設定が必要です。<emphasis>netfilter</emphasis> の基本目的はパケットフィルタリングですから、詳細は<xref linkend="security" xrefstyle="select: label quotedtitle nopage" />に書かれています (<xref linkend="sect.firewall-packet-filtering" />を参照してください)。
		</para>

	</section>
	 <section id="sect.virtual-private-network">
		<title>仮想プライベートネットワーク</title>
		 <para>
			<emphasis>仮想プライベートネットワーク</emphasis> (略して VPN) は 2 つの異なるローカルネットワークをインターネットに作ったトンネルを経由してつなげる方法です。さらに、トンネルは通常機密を守るために暗号化されます。VPN はリモートマシンを会社のローカルネットワークの中に参加させるために使われることが多いです。
		</para>
		 <indexterm>
			<primary>ネットワーク</primary>
			<secondary sortas="カソウプライベート">仮想プライベート</secondary>
		</indexterm>
		 <indexterm>
			<primary>VPN</primary>
		</indexterm>
		 <indexterm>
			<primary sortas="カソウプライベートネットワーク">仮想プライベートネットワーク</primary>
		</indexterm>
		 <para>
			VPN 機能を提供するツールにはさまざまなものがあります。OpenVPN は効果的な解決策で、設置とメンテナンスが簡単で、SSL/TLS に基づいています。別の可能性は IPsec を使って 2 台のマシン間の IP トラフィックを暗号化することです。IPsec の暗号化は透過的で、ホスト上で実行されているアプリケーションは VPN の存在を気にする必要がありません。SSH は伝統的な機能に加えて、VPN を提供するために使われる場合もあります。最後に、Microsoft の PPTP プロトコルを使って VPN を作ることも可能です。他にも解決策は存在しますが、本書では解説しません。
		</para>
		 <section id="sect.openvpn">
			<title>OpenVPN</title>
			 <indexterm>
				<primary>OpenVPN</primary>
			</indexterm>
			 <para>
				OpenVPN は仮想プライベートネットワーク作成専用ソフトウェアの一種です。OpenVPN をセットアップするには VPN サーバ上とクライアント上に仮想ネットワークインターフェースの作成が必要です。さらに、OpenVPN は <literal>tun</literal> (IP レベルトンネル用) と <literal>tap</literal> (イーサネットレベルトンネル用) インターフェースをサポートします。実際には、VPN クライアントをイーサネットブリッジ経由でサーバのローカルネットワークに参加させる場合を除いて、<literal>tun</literal> インターフェースが最もよく使われます。
			</para>
			 <para>
				OpenVPN は SSL/TLS 暗号化と関連する機能 (機密性、認証、整合性、否認防止) を使うために OpenSSL に依存しています。OpenVPN は共有秘密鍵または公開鍵基盤に基づく X.509 証明書を使うように設定できます。公開鍵基盤に基づく X.509 証明書を使うよう設定することをお勧めします。なぜなら、公開鍵基盤に従えば VPN にアクセスするローミングユーザの数が増えた場合も大きな自由度を保つことが可能だからです。
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> SSL と TLS</title>
			 <indexterm>
				<primary>SSL</primary>
			</indexterm>
			 <indexterm>
				<primary>TLS</primary>
			</indexterm>
			 <para>
				SSL (<emphasis>Secure Socket Layer</emphasis>) プロトコルはウェブサーバとの安全な接続を確立する目的で Netscape によって考案されました。SSL は後に TLS (<emphasis>Transport Layer Security</emphasis>) の下で IETF によって標準化されました。その後 TLS は進化を続けました。対して SSL は構造的欠陥を見つけられたため SSL を使うことは推奨されません。
			</para>
			 </sidebar> <section id="sect.easy-rsa">
				<title>公開鍵基盤、<emphasis>easy-rsa</emphasis></title>
				 <indexterm>
					<primary sortas="PKI (コウカイカギキバン)">PKI (公開鍵基盤)</primary>
				</indexterm>
				 <indexterm>
					<primary sortas="コウカイカギキバン">公開鍵基盤</primary>
				</indexterm>
				 <indexterm>
					<primary>X.509</primary>
					<secondary sortas="ショウメイショ">証明書</secondary>
				</indexterm>
				 <indexterm>
					<primary sortas="ショウメイショ">証明書</primary>
					<secondary>X.509</secondary>
				</indexterm>
				 <indexterm>
					<primary><emphasis>easy-rsa</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary>RSA (アルゴリズム)</primary>
				</indexterm>
				 <indexterm>
					<primary sortas="カギペア">鍵ペア</primary>
				</indexterm>
				 <para>
					公開鍵暗号では RSA アルゴリズムが広く使われています。公開鍵暗号は秘密鍵と公開鍵からなる「鍵ペア」を使います。2 種類の鍵は互いに密接な関係を持っており、公開鍵で暗号化されたメッセージは秘密鍵を知っている人だけが復号化できるという数学的特徴によって機密性が保証されます。逆に、秘密鍵を使って暗号化されたメッセージは公開鍵を持っている人なら誰でも復号化できます。この特徴を使うことで、メッセージの出自が本物であることを確認することが可能です。なぜなら、秘密鍵を持つものだけがその暗号化メッセージを生成できるからです。デジタルハッシュ関数 (MD5、SHA1、最近の亜種など) を組み合わせることで、これはいかなるメッセージにも適用できる署名メカニズムになります。
				</para>
				 <para>
					しかしながら、鍵ペアを作り、鍵ペアに任意の識別情報を保存し、自由に識別情報を偽ることは誰でも可能です。これに対する 1 つの解決策が X.509 標準によって体系化された<emphasis>認証局</emphasis> (CA) の概念です。<emphasis>認証局</emphasis>という用語には、<emphasis>ルート証明書</emphasis>として知られる信頼された鍵ペアに保存された識別情報の実体の意味も含まれています。<emphasis>ルート証明書</emphasis>は他の証明書 (鍵ペア) を署名するためにのみ使われ、署名したい鍵ペアに保存される識別情報を確認するために適切な手順を経た後に署名が行われます。こうすることで X.509 を使うアプリケーションは自分に提示された証明書の識別情報を確認し、提示された証明書が信頼されたルート証明書によって署名されたかを判断できます。
				</para>
				 <para>
					OpenVPN はこの識別情報確認ルールに従います。パブリック認証局は (高額な) 料金と引き換えに証明書を発行しているに過ぎません。OpenVPN を使えば会社内のプライベート認証局を作成することが可能です。<emphasis role="pkg">easy-rsa</emphasis> パッケージは X.509 証明書基盤としての機能を果たすツールを提供し、このツールは <command>openssl</command> コマンドを使うスクリプト群として実装されています。
				</para>
				 <sidebar> <title><emphasis>NOTE</emphasis> <emphasis role="distribution">Jessie</emphasis> 以前の <emphasis>easy-rsa</emphasis></title>
				 <para>
					<emphasis role="distribution">Wheezy</emphasis> までの Debian のバージョンでは、<emphasis>easy-rsa</emphasis> は <emphasis role="pkg">openvpn</emphasis> パッケージの一部として配布されており、<emphasis>easy-rsa</emphasis> のスクリプトは <filename>/usr/share/doc/openvpn/examples/easy-rsa/2.0/</filename> 以下に含まれていました。認証局を設定するには、ここで説明されているように <command>make-cadir</command> コマンドを使うのではなく、このディレクトリをコピーする必要がありました。
				</para>
				 </sidebar> <para>
					Falcot Corp の管理者は <emphasis>easy-rsa</emphasis> ツールを使い、サーバおよびクライアントに必要な証明書を作ります。<emphasis>easy-rsa</emphasis> ツールを使うことで、すべてのクライアントの設定を同様にすることが可能です。クライアントは Falcot のプライベート認証局から発行された証明書を信頼するようにセットアップしなければいけません。最初に Falcot のプライベート認証局用の証明書を発行します。この目的を達成するために、管理者は認証局に必要なファイルを含むディレクトリを適切な場所にセットアップします。セットアップする場所は、認証局の秘密鍵が盗まれる危険性を和らげるために、ネットワークに接続されていないマシンが好ましいです。
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>make-cadir pki-falcot
</userinput><computeroutput>$ </computeroutput><userinput>cd pki-falcot</userinput></screen>
				 <para>
					<emphasis>easy-rsa</emphasis> ツールは必要なパラメータを <filename>vars</filename> ファイルに保存します。パラメータには特に <literal>KEY_</literal> 接頭辞が付けられています。これらの変数は環境変数に組み込まれます。
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>vim vars
</userinput><computeroutput>$ </computeroutput><userinput>grep KEY_ vars
</userinput><computeroutput>export KEY_CONFIG=`$EASY_RSA/whichopensslcnf $EASY_RSA`
export KEY_DIR="$EASY_RSA/keys"
echo NOTE: If you run ./clean-all, I will be doing a rm -rf on $KEY_DIR
export KEY_SIZE=2048
export KEY_EXPIRE=3650
export KEY_COUNTRY="FR"
export KEY_PROVINCE="Loire"
export KEY_CITY="Saint-Étienne"
export KEY_ORG="Falcot Corp"
export KEY_EMAIL="admin@falcot.com"
export KEY_OU="Certificate authority"
export KEY_NAME="Certificate authority for Falcot Corp"
# If you'd like to sign all keys with the same Common Name, uncomment the KEY_CN export below
# export KEY_CN="CommonName"
$ </computeroutput><userinput>. ./vars
</userinput><computeroutput>NOTE: If you run ./clean-all, I will be doing a rm -rf on /home/roland/pki-falcot/keys
$ </computeroutput><userinput>./clean-all
</userinput></screen>
				 <para>
					次にプライベート認証局の鍵ペアを作成します (この最中に、鍵ペアの 2 つの部分が <filename>keys/ca.crt</filename> と <filename>keys/ca.key</filename> に保存されます)。
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>./build-ca</userinput>
<computeroutput>Generating a 2048 bit RSA private key
...................................................................+++
...+++
writing new private key to 'ca.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [Falcot Corp CA]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:
</computeroutput></screen>
				 <para>
					これで VPN サーバの証明書および SSL/TLS 接続のサーバ側に必要な Diffie-Hellman パラメータを作ることが可能になりました。VPN サーバは DNS 名 <literal>vpn.falcot.com</literal> で識別されます。ここで指定した DNS 名は作成される鍵ファイルの名前としても使われます (<filename>keys/vpn.falcot.com.crt</filename> は公開鍵証明書、<filename>keys/vpn.falcot.com.key</filename> は秘密鍵です)。
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>./build-key-server vpn.falcot.com
</userinput><computeroutput>Generating a 2048 bit RSA private key
.....................................................................................................................+++
...........+++
writing new private key to 'vpn.falcot.com.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:
Common Name (eg, your name or your server's hostname) [vpn.falcot.com]:
Name [Certificate authority for Falcot Corp]:
Email Address [admin@falcot.com]:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
Using configuration from /home/roland/pki-falcot/openssl-1.0.0.cnf
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
countryName           :PRINTABLE:'FR'
stateOrProvinceName   :PRINTABLE:'Loire'
localityName          :T61STRING:'Saint-\0xFFFFFFC3\0xFFFFFF89tienne'
organizationName      :PRINTABLE:'Falcot Corp'
organizationalUnitName:PRINTABLE:'Certificate authority'
commonName            :PRINTABLE:'vpn.falcot.com'
name                  :PRINTABLE:'Certificate authority for Falcot Corp'
emailAddress          :IA5STRING:'admin@falcot.com'
Certificate is to be certified until Mar  6 14:54:56 2025 GMT (3650 days)
Sign the certificate? [y/n]:</computeroutput><userinput>y
</userinput><computeroutput>

1 out of 1 certificate requests certified, commit? [y/n]</computeroutput><userinput>y
</userinput><computeroutput>Write out database with 1 new entries
Data Base Updated
$ </computeroutput><userinput>./build-dh
</userinput><computeroutput>Generating DH parameters, 2048 bit long safe prime, generator 2
This is going to take a long time
[…]
</computeroutput></screen>
				 <para>
					以下では、VPN クライアント用の証明書を作成します。VPN を利用するコンピュータ 1 台ごとおよび人間 1 人ずつに 1 つの証明書が必要です。
				</para>
				 
<screen>
<computeroutput>$ </computeroutput><userinput>./build-key JoeSmith
</userinput><computeroutput>Generating a 2048 bit RSA private key
................................+++
..............................................+++
writing new private key to 'JoeSmith.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [FR]:
State or Province Name (full name) [Loire]:
Locality Name (eg, city) [Saint-Étienne]:
Organization Name (eg, company) [Falcot Corp]:
Organizational Unit Name (eg, section) [Certificate authority]:</computeroutput><userinput>Development unit
</userinput><computeroutput>Common Name (eg, your name or your server's hostname) [JoeSmith]:</computeroutput><userinput>Joe Smith
</userinput><computeroutput>[…]</computeroutput></screen>
				 <para>
					すべての証明書を作ったら、証明書を適切な場所にコピーする必要があります。すなわち、ルート証明書の公開鍵 (<filename>keys/ca.crt</filename>) はすべてのマシン (サーバもクライアントも) に <filename>/etc/ssl/certs/Falcot_CA.crt</filename> という名前で保存されます。サーバの証明書はサーバにだけインストールされます (<filename>keys/vpn.falcot.com.crt</filename> は <filename>/etc/ssl/vpn.falcot.com.crt</filename> へ、<filename>keys/vpn.falcot.com.key</filename> は管理者だけが読めるようなパーミッション制限を掛けるために <filename>/etc/ssl/private/vpn.falcot.com.key</filename> へインストールされます)。同時に、対応する Diffie-Hellman パラメータ (<filename>keys/dh2048.pem</filename>) は <filename>/etc/openvpn/dh2048.pem</filename> へインストールされます。クライアント証明書は対応する VPN クライアントに同様の方法でインストールされます。
				</para>

			</section>
			 <section>
				<title>OpenVPN サーバの設定</title>
				 <para>
					デフォルトで、OpenVPN 初期化スクリプトは <filename>/etc/openvpn/*.conf</filename> で定義されたすべての仮想プライベートネットワークを開始します。このため、VPN サーバをセットアップする場合、このディレクトリ内に対応する設定ファイルを配置することになります。設定ファイルの良い足掛かりとして <filename>/usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz</filename> が用意されています。これはどちらかと言えば標準的なサーバを作るためのものです。もちろん、一部のパラメータを適切に設定しなければいけません。具体的に言えば、<literal>ca</literal>、<literal>cert</literal>、<literal>key</literal>、<literal>dh</literal> パラメータを対応するファイルが設置されている場所に設定する必要があります (それぞれ、<literal>/etc/ssl/certs/Falcot_CA.crt</literal>、<literal>/etc/ssl/vpn.falcot.com.crt</literal>、<literal>/etc/ssl/private/vpn.falcot.com.key</literal>、<literal>/etc/openvpn/dh2048.pem</literal> に設定します)。<literal>server 10.8.0.0 255.255.255.0</literal> 指示文は VPN によって使われるサブネットを定義します。サーバにはこの範囲に含まれる最初の IP アドレス (<literal>10.8.0.1</literal>) が割り当てられ、クライアントには残りの IP アドレスが割り当てられます。
				</para>
				 <para>
					この設定で OpenVPN を開始すると、通常 <literal>tun0</literal> という名前の仮想ネットワークインターフェースが作成されます。しかしながら、ファイアウォールは OpenVPN の開始前に実ネットワークインターフェースと同時に設定される場合が多いです。このため、永続的な仮想ネットワークインターフェースを作成し、OpenVPN が事前に作成された仮想インターフェースを使うように設定することを推奨します。この追加的設定により、インターフェースの名前を選ぶことが可能になります。この目的を達成するには、<command>openvpn --mktun --dev vpn --dev-type tun</command> を使って <literal>tun</literal> 型の <literal>vpn</literal> と名付けられた仮想ネットワークインターフェースを作成します。さらに、このコマンドをファイアウォール設定スクリプトの中で使えば、簡単に設定を統合できます。つまり <filename>/etc/network/interfaces</filename> ファイルの <literal>up</literal> 指示文を使います。OpenVPN 設定ファイルをファイアウォール設定に対応させるためには <literal>dev vpn</literal> と <literal>dev-type tun</literal> 指示文を使います。
				</para>
				 <para>
					これ以上の設定を追加しなければ、VPN クライアントは <literal>10.8.0.1</literal> アドレスの VPN サーバにアクセスできるだけです。クライアントをローカルネットワーク (192.168.0.0/24) へアクセスできる状態にするには、<literal>push route 192.168.0.0 255.255.255.0</literal> 指示文を OpenVPN 設定に追加します。こうすることで、VPN クライアントは自動的にネットワーク経路を取得し、VPN 経由でローカルネットワークに到達できるようになります。さらに、ローカルネットワークにいるマシンに対して VPN サーバに通じる VPN への経路を知らせる必要もあります (VPN サーバがゲートウェイにインストールされている場合、これは自動的に動きます)。別の方法として、VPN サーバが IP マスカレードを動かすように設定する方法があります。そうすれば、VPN クライアントからの接続はあたかもクライアントが VPN サーバからアクセスしたかのように見えます (<xref linkend="sect.gateway" />を参照してください)。
				</para>

			</section>
			 <section>
				<title>OpenVPN クライアントの設定</title>
				 <para>
					OpenVPN クライアントを設定する場合にも、<filename>/etc/openvpn/</filename> に設定ファイルを置きます。標準的な設定の良い足掛かりとして <filename>/usr/share/doc/openvpn/examples/sample-config-files/client.conf</filename> が用意されています。<literal>remote vpn.falcot.com 1194</literal> 指示文は OpenVPN サーバのアドレスとポート番号を表します。さらに <literal>ca</literal>、<literal>cert</literal>、<literal>key</literal> も鍵ファイルの場所に合わせて設定が必要です。
				</para>
				 <para>
					起動時に VPN を自動的に開始したくない場合、<filename>/etc/default/openvpn</filename> ファイルの <literal>AUTOSTART</literal> 指示文に <literal>none</literal> を設定してください。VPN 接続の開始と停止は <command>service openvpn@<replaceable>name</replaceable> start</command> と <command>service openvpn@<replaceable>name</replaceable> stop</command> コマンドを使えばいつでも可能です (ここで、接続名 <replaceable>name</replaceable> は <filename>/etc/openvpn/<replaceable>name</replaceable>.conf</filename> で定義したものにマッチします)。
				</para>
				 <para>
					<emphasis role="pkg">network-manager-openvpn-gnome</emphasis> パッケージには、NetworkManager (<xref linkend="sect.roaming-network-config" />を参照してください) の拡張が含まれ、これを使うことで OpenVPN 仮想プライベートネットワークを管理することが可能です。誰もがグラフィカルに OpenVPN 接続を設定し、ネットワーク管理アイコンからこれを制御することが可能です。<indexterm><primary><emphasis role="pkg">network-manager-openvpn-gnome</emphasis></primary></indexterm>
				</para>

			</section>

		</section>
		 <section id="sect.ssh-vpn">
			<title>SSH を使った仮想プライベートネットワーク</title>
			 <indexterm>
				<primary>SSH</primary>
			</indexterm>
			 <indexterm>
				<primary>PPP</primary>
			</indexterm>
			 <para>
				SSH を使った仮想プライベートネットワークの作成法には、2 種類の方法があります。歴史的に見て重要な方法が SSH リンクの上で PPP レイヤを確立する方法です。この方法は HOWTO 文書で説明されています。<ulink type="block" url="http://www.tldp.org/HOWTO/ppp-ssh/" />
			</para>
			 <para>
				2 番目の方法はより最近の方法で、OpenSSH 4.3 で導入されました。その結果今や、OpenSSH は SSH 接続のサーバおよびクライアント側に仮想ネットワークインターフェース (<literal>tun*</literal>) を作り、仮想インターフェースをあたかも物理インターフェースのように設定することが可能です。このトンネルシステムを有効化するにはまず、SSH サーバの設定ファイル (<filename>/etc/ssh/sshd_config</filename>) の中で <literal>PermitTunnel</literal> を「yes」に設定しなければいけません。SSH 接続を確立する際には、<literal>-w any:any</literal> オプションを使って明示的にトンネルの作成を要求しなければいけません (ここで <literal>any</literal> は必要な <literal>tun</literal> デバイス番号で置き替えます)。トンネルを作成するには、サーバおよびクライアント側でそのユーザが管理者権限を持っていることが必要です。そうすればネットワークデバイスを作成することが可能です (言い換えれば、接続は root で確立されなければいけません)。
			</para>
			 <para>
				SSH を使って仮想プライベートネットワークを作成する方法は、どちらもかなり直接的なものです。しかしながら、SSH の提供する VPN は最も効率のよい方法ではありません。特に、高レベルのトラフィックをうまく取り扱うことができません。
			</para>
			 <para>
				つまり、TCP/IP スタックが TCP/IP 接続 (SSH) の中にカプセル化される場合、TCP プロトコルは 2 回使われるという点です。1 回は SSH 接続で、もう 1 回がトンネル内です。TCP はタイムアウト遅延を変更することでネットワークの状態に接続状態を適合させる機能があるため、これは特に問題になります。以下のサイトがこの問題についてより詳しく説明しています。<ulink type="block" url="http://sites.inka.de/sites/bigred/devel/tcp-tcp.html" />このため、VPN over SSH はパフォーマンスに制約のない単発のトンネルに留めるべきです。
			</para>

		</section>
		 <section id="sect.ipsec">
			<title>IPsec</title>
			 <indexterm>
				<primary>IPsec</primary>
			</indexterm>
			 <indexterm>
				<primary><command>strongswan</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>racoon</command></primary>
			</indexterm>
			 <para>
				IPsec は IP VPN の標準的ツールになりつつあるにも関わらず、IPsec の実装は複雑です。IPsec エンジンそれ自身は Linux カーネルに統合されています。ユーザ空間部分で必要となる制御と設定ツールは <emphasis role="pkg">ipsec-tools</emphasis> パッケージに含まれています。具体的には、それぞれのホストの <filename>/etc/ipsec-tools.conf</filename> にはホストが接続する <emphasis>IPsec トンネル</emphasis> (IPsec 用語で <emphasis>Security Association</emphasis>) のパラメータが含まれます。<command>/etc/init.d/setkey</command> スクリプトを使うことで、トンネルを開始したり停止することが可能です (それぞれのトンネルは仮想ネットワークに接続された他のホストと安全なリンクを確立しています)。このファイルは <citerefentry><refentrytitle>setkey</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> マニュアルページに含まれる文書を使って手作業で作ることも可能です。しかしながら、多数のマシン群にすべてのホスト用のパラメータを明示的に書くことはすぐに難しい作業になります。なぜなら、トンネルの数はすぐに増えるからです。たとえば <emphasis role="pkg">racoon</emphasis> や <emphasis role="pkg">strongswan</emphasis> などの IKE (<emphasis>IPsec Key Exchange</emphasis> の略語) デーモンをインストールすることで、一元管理による作業の簡素化と鍵の定期的な切り替えによる作業の安全化が可能になります。
			</para>
			 <indexterm>
				<primary>IKE</primary>
			</indexterm>
			 <indexterm>
				<primary>IPsec</primary>
				<secondary>IPsec Key Exchange</secondary>
			</indexterm>
			 <indexterm>
				<primary sortas="カギペア">鍵ペア</primary>
			</indexterm>
			 <indexterm>
				<primary><command>setkey</command></primary>
			</indexterm>
			 <para>
				IPsec は標準規格という地位があるにも関わらず、その設定が複雑なことが原因で実際にはあまり使われていません。必要なトンネルが少なくて静的な場合は、OpenVPN に基づく解決策が通常好まれます。
			</para>
			 <sidebar> <title><emphasis>CAUTION</emphasis> IPsec と NAT</title>
			 <para>
				ファイアウォールの NAT は IPsec とうまく共存しません。なぜなら、IPsec はパケットを署名しますが、ファイアウォールがパケットを書き換えることで IPsec による署名は無効化され、無効な署名のパケットは受け取り側で拒否されるからです。今やさまざまな IPsec 実装が <emphasis>NAT-T</emphasis> (<emphasis>NAT Traversal</emphasis> の略語) 技術をサポートしています。これは基本的に IPsec パケットを標準的な UDP パケットにカプセル化するものです。
			</para>
			 <indexterm>
				<primary>NAT-T</primary>
			</indexterm>
			 <indexterm>
				<primary>NAT Traversal</primary>
			</indexterm>
			 </sidebar> <sidebar> <title><emphasis>SECURITY</emphasis> IPsec とファイアウォール</title>
			 <para>
				IPsec の動作の標準的モードは鍵交換に UDP ポート 500 番 (NAT-T を使用する場合 UDP ポート 4500 番) を使います。さらに、IPsec パケットは 2 種類の専用 IP プロトコルを使います。ファイアウォールはこのプロトコルを通過させなければいけません。さらに、これらのパケットの受け入れ可否はプロトコル番号 (ESP は 50 番、AH は 51 番) に基づきます。
			</para>
			 <indexterm>
				<primary>ESP、プロトコル</primary>
			</indexterm>
			 <indexterm>
				<primary>AH、プロトコル</primary>
			</indexterm>
			 <indexterm>
				<primary>プロトコル</primary>
				<secondary>AH</secondary>
			</indexterm>
			 <indexterm>
				<primary>プロトコル</primary>
				<secondary>ESP</secondary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.pptp">
			<title>PPTP</title>
			 <para>
				PPTP (<emphasis>Point-to-Point Tunneling Protocol</emphasis> の略語) は 2 種類の通信チャンネルを使います。1 つは制御データ用で、もう 1 つがペイロードデータ用です。ペイロードデータ用チャンネルは GRE プロトコル (<emphasis>Generic Routing Encapsulation</emphasis>) を使います。標準的な PPP リンクはペイロードデータ交換用チャンネル上に確立されます。
			</para>
			 <indexterm>
				<primary>PPTP</primary>
			</indexterm>
			 <indexterm>
				<primary>Point-to-Point Tunneling Protocol</primary>
			</indexterm>
			 <indexterm>
				<primary>GRE、プロトコル</primary>
			</indexterm>
			 <indexterm>
				<primary>プロトコル</primary>
				<secondary>GRE</secondary>
			</indexterm>
			 <section id="sect.pptp-config-client">
				<title>クライアントの設定</title>
				 <para>
					<emphasis role="pkg">pptp-linux</emphasis> パッケージには Linux 用に簡単に設定できる PPTP クライアントが含まれています。以下の説明は公式文書からヒントを得て作ったものです。<ulink type="block" url="http://pptpclient.sourceforge.net/howto-debian.phtml" />
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">pptp-linux</emphasis></primary>
				</indexterm>
				 <para>
					Falcot の管理者はいくつかのファイルを作成しました。すなわち <filename>/etc/ppp/options.pptp</filename>、<filename>/etc/ppp/peers/falcot</filename>、<filename>/etc/ppp/ip-up.d/falcot</filename>、<filename>/etc/ppp/ip-down.d/falcot</filename> を作成しました。
				</para>
				 <example id="example.ppp-options.pptp">
					<title><filename>/etc/ppp/options.pptp</filename> ファイル</title>
					 
<programlisting>
# PPTP 接続時に利用する PPP オプション
lock
noauth
nobsdcomp
nodeflate</programlisting>

				</example>
				 <example id="example.ppp-peers-falcot">
					<title><filename>/etc/ppp/peers/falcot</filename> ファイル</title>
					 
<programlisting>
# vpn.falcot.com は PPTP サーバです
pty "pptp vpn.falcot.com --nolaunchpppd"
# "vpn" ユーザで本人確認して接続します
user vpn
remotename pptp
# 暗号化を有効にします
require-mppe-128
file /etc/ppp/options.pptp
ipparam falcot</programlisting>

				</example>
				 <example id="example.ppp-ip-up.d-falcot">
					<title><filename>/etc/ppp/ip-up.d/falcot</filename> ファイル</title>
					 
<programlisting>
# Falcot ネットワークへの経路を作成します
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 is the (remote) Falcot network
  route add -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi</programlisting>

				</example>
				 <example id="example.ppp-ip-down.d-falcot">
					<title><filename>/etc/ppp/ip-down.d/falcot</filename> ファイル</title>
					 
<programlisting>
# Falcot ネットワークへの経路を削除します
if [ "$6" = "falcot" ]; then
  # 192.168.0.0/24 is the (remote) Falcot network
  route del -net 192.168.0.0 netmask 255.255.255.0 dev $1
fi</programlisting>

				</example>
				 <sidebar> <title><emphasis>SECURITY</emphasis> MPPE</title>
				 <para>
					PPTP を安全なものにするには MPPE 機能 (<emphasis>Microsoft Point-to-Point Encryption</emphasis>) を使います。MPPE はモジュールとして公式の Debian カーネルで利用できます。
				</para>
				 <indexterm>
					<primary>MPPE</primary>
				</indexterm>
				 <indexterm>
					<primary>Microsoft</primary>
					<secondary>Point-to-Point Encryption</secondary>
				</indexterm>
				 </sidebar>
			</section>
			 <section id="sect.pptp-config-serveur">
				<title>サーバの設定</title>
				 <sidebar> <title><emphasis>CAUTION</emphasis> PPTP とファイアウォール</title>
				 <para>
					中間ファイアウォールはプロトコル 47 番 (GRE) を使っている IP パケットを通過させるように設定されなければいけません。さらに、通信チャンネルを開くために PPTP サーバのポート 1723 番を開けることが必要です。
				</para>
				 </sidebar> <para>
					<command>pptpd</command> は Linux 用の PPTP サーバです。主設定ファイル <filename>/etc/pptpd.conf</filename> にはいくつかの変更が必要です。すなわち <emphasis>localip</emphasis> (ローカル IP アドレス) と <emphasis>remoteip</emphasis> (リモート IP アドレス) を変更する必要があります。以下の例では、PPTP サーバは常に <literal>192.168.0.199</literal> アドレスを使い、PPTP クライアントは <literal>192.168.0.200</literal> から <literal>192.168.0.250</literal> までの IP アドレスを受け取ります。
				</para>
				 <example id="example.pptpd.conf">
					<title><filename>/etc/pptpd.conf</filename> ファイル</title>
					 
<programlisting>
# TAG: speed
#
#       PPTP デーモンの通信速度を指定します。
#
speed 115200

# TAG: option
#
#       PPP オプションファイルの場所を指定します。
#       PPP はデフォルトで '/etc/ppp/options' を使います
#
option /etc/ppp/pptpd-options

# TAG: debug
#
#       syslog に詳細なデバッグ情報を出力します
#
# debug

# TAG: localip
# TAG: remoteip
#
#       ローカルとリモートの IP アドレス範囲を指定します。
#
#       コンマで区切ることで、単独の IP アドレスおよび
#       IP アドレス範囲を指定できます。以下は利用例です。
#
#               192.168.0.234,192.168.0.245-249,192.168.0.254
#
#       以下の重要な制約事項に注意してください。
#
#       1. コンマ間およびアドレス内部で空白文字を使わないでください。
#
#       2. MAX_CONNECTIONS よりも多くの IP アドレス を指定した場合、
#          使われる IP アドレスはリストの先頭から MAX_CONNECTIONS
#          個までの IP アドレスです。それ以外は使われません。
#
#       3. アドレス範囲を略記しないでください! たとえば 234 から 238 の範囲を指定するために
#          234-8 と記述するのは間違いです。その代わり 234-238 と記述してください。
#
#       4. ローカル IP は 1 つだけでも構いません。この場合、すべてのローカル IP は
#          指定したものになります。しかしながら、同時接続中のクライアントには
#          必ず異なるリモート IP を割り振らなければいけません。
#
#localip 192.168.0.234-238,192.168.0.245
#remoteip 192.168.1.234-238,192.168.1.245
#localip 10.0.1.1
#remoteip 10.0.1.2-100
localip 192.168.0.199
remoteip 192.168.0.200-250</programlisting>

				</example>
				 <para>
					さらに <filename>/etc/ppp/pptpd-options</filename> を編集して、PPTP サーバの使う PPP 設定を変更します。重要なパラメータはサーバ名 (<literal>pptp</literal>)、ドメイン名 (<literal>falcot.com</literal>)、DNS と WINS サーバの IP アドレスです。
				</para>
				 <example id="example.ppp-pptpd-options">
					<title><filename>/etc/ppp/pptpd-options</filename> ファイル</title>
					 
<programlisting>
## pppd の syslog デバッグを有効化します
#debug

## 「サーバ名」を chap-secrets 内の自分のサーバ名として指定したものに変更します
name pptp
## ドメイン名をローカルドメインに変更します
domain falcot.com

## 以下は WinXXXX クライアントに対して
## 適当とされるデフォルトセキュリティ関連設定です
# Debian の pppd パッケージは MSCHAP と MPPE の両方をサポートしています。そのため
# ここでは両方を有効化しています。カーネルの MPPE サポートが必須という点にも注意してください!
auth
require-chap
require-mschap
require-mschap-v2
require-mppe-128

## サービスに対応するアドレスを指定してください
ms-dns 192.168.0.1
ms-wins 192.168.0.1

## ネットマスクを指定してください
netmask 255.255.255.0

## 一部のデフォルト設定
nodefaultroute
proxyarp
lock</programlisting>

				</example>
				 <para>
					最後に、<literal>vpn</literal> ユーザ (と対応するパスワード) を <filename>/etc/ppp/chap-secrets</filename> ファイルに登録します。サーバ名だけは、アスタリスク (<literal>*</literal>) を使える他のインスタンスと異なり、明示的に指定しなければいけません。さらに、Windows PPTP クライアントはユーザ名ではなく <literal><replaceable>DOMAIN</replaceable>\\<replaceable>USER</replaceable></literal> という形を認証を行います。このため、<filename>/etc/ppp/chap-secrets</filename> ファイルに <literal>FALCOT\\vpn</literal> ユーザが追加されています。ユーザに割り当てる IP アドレスを明記することも可能です。IP アドレスフィールドのアスタリスクは動的にアドレスを割り当てることを意味します。
				</para>
				 <example id="example.ppp-chap-secrets">
					<title><filename>/etc/ppp/chap-secrets</filename> ファイル</title>
					 
<programlisting>
# CHAP 認証用のログイン情報
# クライアント  サーバ  秘密情報    IP アドレス
vpn             pptp    f@Lc3au     *
FALCOT\\vpn     pptp    f@Lc3au     *</programlisting>

				</example>
				 <sidebar> <title><emphasis>SECURITY</emphasis> PPTP 脆弱性</title>
				 <para>
					Microsoft の最初の PPTP 実装は多くのセキュリティ脆弱性を残していたためにさまざまな非難を浴びました。しかし、最近のバージョンではその多くが修正されています。この節で説明されている設定は PPTP プロトコルの最新のバージョンを使っています。いくつかのオプション (<literal>require-mppe-128</literal> や <literal>require-mschap-v2</literal> など) を無効化すると、サービスに脆弱性が生まれるという点に注意してください。
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.quality-of-service">
		<title>Quality of Service</title>
		 <section id="sect.qos-principe">
			<title>原理とメカニズム</title>
			 <para>
				<emphasis>Quality of Service (サービスの品質)</emphasis> (略して <emphasis>QoS</emphasis>) はアプリケーションに提供されるサービスの品質を向上させる技術群を指します。最もよく使われる技術はネットワークトラフィックをカテゴリ分けして、トラフィックの所属するカテゴリごとにその取り扱いに違いを付ける技術です。サービスを差別化するという概念の主な用途が<emphasis>トラフィックシェーピング</emphasis>です。これは一部のサービスおよびホストに関連する接続のデータの転送率を制限します。これを使うことで、利用できる帯域幅が飽和することを避け、重要な他のサービスに支障が出ないようにします。トラフィックシェーピングは TCP トラフィックに対して特に有効です。なぜなら、TCP は利用できる帯域幅に自動的に適応するからです。
			</para>
			 <indexterm>
				<primary>QoS</primary>
			</indexterm>
			 <indexterm>
				<primary sortas="サービスノヒンシツ">サービスの品質</primary>
			</indexterm>
			 <indexterm>
				<primary sortas="ヒンシツ">品質</primary>
				<secondary sortas="サービスノヒンシツ">サービスの品質</secondary>
			</indexterm>
			 <indexterm>
				<primary>サービス</primary>
				<secondary sortas="ヒンシツ">品質</secondary>
			</indexterm>
			 <para>
				トラフィックの優先度を変更し、対話型サービス (<command>ssh</command> や <command>telnet</command> など) や小さなブロックのデータだけを取り扱うサービスに関連するパケットに高い優先度を付けることも可能です。
			</para>
			 <para>
				Debian カーネルには、QoS 関連モジュールと一緒に QoS に必要な機能が含まれています。多くのモジュールが存在し、各モジュールが異なるサービスを提供します。中でも注目すべきは IP パケットの待ち行列用の特別なスケジューラです。このスケジューラはさまざまな用途に利用できるため、考え得るさまざまな要求に対応できます。
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> LARTC (<emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis>)</title>
			 <para>
				<emphasis>Linux Advanced Routing &amp; Traffic Control</emphasis> HOWTO はネットワークのサービス品質に関して知っておくべきすべての内容をカバーする基礎的な文書です。<ulink type="block" url="http://www.lartc.org/howto/" />
			</para>
			 <indexterm>
				<primary>ルーティング</primary>
				<secondary sortas="ジョウキュウルーティング">上級ルーティング</secondary>
			</indexterm>
			 <indexterm>
				<primary>トラフィック</primary>
				<secondary sortas="セイギョ">制御</secondary>
			</indexterm>
			 <indexterm>
				<primary sortas="セイギョ">制御</primary>
				<secondary>トラフィック</secondary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.qos-config">
			<title>設定と実践</title>
			 <para>
				QoS パラメータは <command>tc</command> コマンド (<emphasis role="pkg">iproute</emphasis> パッケージに含まれます) を使って設定します。<command>tc</command> コマンドはインターフェースがかなり複雑なので、高レベルツールを使うことを推奨します。
			</para>
			 <indexterm>
				<primary><emphasis>iproute</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><command>tc</command></primary>
			</indexterm>
			 <section id="sect.qos-wondershaper">
				<title>待ち時間の低減、<command>wondershaper</command></title>
				 <para>
					<command>wondershaper</command> (同名のパッケージに含まれます) の主目的はネットワーク負荷とは無関係に待ち時間を最小化することです。全トラフィックをある値に制限することにより、これは実現されます。この値には帯域を飽和させるよりほんの少しだけ小さな値を設定します。
				</para>
				 <indexterm>
					<primary><command>wondershaper</command></primary>
				</indexterm>
				 <indexterm>
					<primary sortas="セイゲン">制限</primary>
					<secondary>トラフィック</secondary>
				</indexterm>
				 <indexterm>
					<primary>トラフィック</primary>
					<secondary sortas="セイゲン">制限</secondary>
				</indexterm>
				 <para>
					ネットワークインターフェースを設定した後、<command>wondershaper <replaceable>interface</replaceable> <replaceable>download_rate</replaceable> <replaceable>upload_rate</replaceable></command> を実行することでトラフィックが制限されます。ここで <replaceable>interface</replaceable> はたとえば <literal>eth0</literal> または <literal>ppp0</literal> などのインターフェース名で、<replaceable>download_rate</replaceable> および <replaceable>upload_rate</replaceable> はキロビット毎秒単位の値です。特定のインターフェースで実施されているトラフィック制限を無効化するには <command>wondershaper remove <replaceable>interface</replaceable></command> コマンドを使います。
				</para>
				 <para>
					イーサネット接続の場合、<command>wondershaper</command> をインターフェースが設定された直後に呼び出すのが最良です。これを行うには、<filename>/etc/network/interfaces</filename> ファイルに <literal>up</literal> と <literal>down</literal> 指示文を追加して、それぞれインターフェースが開始された後と停止される前に実行するコマンドを宣言します。以下にその例を示します。
				</para>
				 <example id="example.network-interfaces">
					<title><filename>/etc/network/interfaces</filename> ファイルの修正</title>
					 
<programlisting>
iface eth0 inet dhcp
    up /sbin/wondershaper eth0 500 100
    down /sbin/wondershaper remove eth0</programlisting>

				</example>
				 <para>
					PPP の場合、<filename>/etc/ppp/ip-up.d/</filename> 内に <command>wondershaper</command> を呼び出すスクリプトを作成することで、接続が開始された後の可能な限り早い時期にトラフィック制御を行うように設定できます。
				</para>
				 <sidebar> <title><emphasis>GOING FURTHER</emphasis> 最適な設定</title>
				 <para>
					<filename>/usr/share/doc/wondershaper/README.Debian.gz</filename> ファイルでは、パッケージメンテナの推奨する設定方法が少し詳しく説明されています。特に、ダウンロードとアップロード速度を計測することを勧めています。実際の速度を計測することで、制限を適切に見積もることが可能です。
				</para>
				 </sidebar>
			</section>
			 <section id="sect.qos-config-standard">
				<title>標準的な設定</title>
				 <para>
					明示的に QoS 設定を行わない場合、Linux カーネルは <literal>pfifo_fast</literal> キュースケジューラを使います。これは興味深い機能を提供します。各 IP パケットの優先度はパケットの ToS フィールド (<emphasis>Type of Service</emphasis>) によって決まります。スケジューリング機能を活用するには、このフィールドを修正するだけで十分です。ToS フィールドの取り得る値は以下の 5 種類です。
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							通常のサービス (0)。
						</para>

					</listitem>
					 <listitem>
						<para>
							コストの最小化 (2)。
						</para>

					</listitem>
					 <listitem>
						<para>
							信頼度の最大化 (4)。
						</para>

					</listitem>
					 <listitem>
						<para>
							速度の最大化 (8)。
						</para>

					</listitem>
					 <listitem>
						<para>
							遅延の最小化 (16)。
						</para>

					</listitem>

				</itemizedlist>
				 <indexterm>
					<primary>ToS</primary>
				</indexterm>
				 <indexterm>
					<primary>Type of Service</primary>
				</indexterm>
				 <para>
					ToS フィールドは IP パケットを生成するアプリケーションによって設定されるか、<emphasis>netfilter</emphasis> によってその場で修正されます。以下のルールを使うだけで、サーバの SSH サービスに対する応答性を増加させることが可能です。
				</para>
				 
<programlisting role="scale">
iptables -t mangle -A PREROUTING -p tcp --sport ssh -j TOS --set-tos Minimize-Delay
iptables -t mangle -A PREROUTING -p tcp --dport ssh -j TOS --set-tos Minimize-Delay</programlisting>

			</section>

		</section>

	</section>
	 <section id="sect.dynamic-routing">
		<title>動的ルーティング</title>
		 <indexterm>
			<primary>ルーティング</primary>
			<secondary sortas="ドウテキ">動的</secondary>
		</indexterm>
		 <indexterm>
			<primary><command>quagga</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>zebra</command></primary>
		</indexterm>
		 <para>
			現在の動的ルーティングの標準ツールは <command>quagga</command> で、<command>quagga</command> は同名のパッケージに含まれます。以前の標準ツールは <command>zebra</command> でしたが、<command>zebra</command> は開発中止となったため <command>quagga</command> に取って代わられました。しかしながら、<command>quagga</command> は互換性の理由からプログラムの名前に <command>zebra</command> を使っています。
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> 動的ルーティング</title>
		 <para>
			動的ルーティングを使うことで、ルータは IP パケットの送信経路をリアルタイムで調整することが可能になります。プロトコルごとに経路を定義する方法 (最短経路、各装置が希望する経路など) は違います。
		</para>
		 <para>
			Linux カーネルでは、ネットワークデバイスとそのデバイスを通過して到達できるマシン群を関連付けることで経路を定義します。<command>route</command> コマンドは新しい経路を定義したり、既存の経路を表示するために使われます。
		</para>
		 <indexterm>
			<primary><command>route</command></primary>
		</indexterm>
		 </sidebar> <para>
			Quagga は複数のデーモン群で、これらが協力して Linux カーネルの使うルーティングテーブルを定義します。各ルーティングプロトコル (中でも注目すべきは BGP、OSPF、RIP) に対して専用のデーモンがあります。<command>zebra</command> デーモンは他のデーモンから情報を収集し、その情報に基づき静的ルーティングテーブルを操作します。ここで他のデーモンとは、<command>bgpd</command>、<command>ospfd</command>、<command>ospf6d</command>、<command>ripd</command>、<command>ripngd</command>、<command>isisd</command>、<command>babeld</command> として知られています。
		</para>
		 <indexterm>
			<primary>OSPF</primary>
		</indexterm>
		 <indexterm>
			<primary>BGP</primary>
		</indexterm>
		 <indexterm>
			<primary>RIP</primary>
		</indexterm>
		 <indexterm>
			<primary>IS-IS</primary>
		</indexterm>
		 <indexterm>
			<primary>BABEL wireless mesh routing</primary>
		</indexterm>
		 <indexterm>
			<primary><command>bgpd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ospfd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ospf6d</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ripd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>ripngd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>isisd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>babeld</command></primary>
		</indexterm>
		 <para>
			これらのデーモンを有効化するには、<filename>/etc/quagga/daemons</filename> ファイルを編集し、適切な設定ファイルを <filename>/etc/quagga/</filename> の中に作成してください。さらに、この設定ファイルはデーモンにちなんで命名され、<filename>.conf</filename> 拡張子を付けられ、<literal>quagga</literal> ユーザと <literal>quaggavty</literal> グループに所有されなければいけません。これは <filename>/etc/init.d/quagga</filename> スクリプトが対象のデーモンを呼び出せるようにするためです。
		</para>
		 <para>
			デーモンを設定するには、対象のルーティングプロトコルに関する知識が必要です。ここではそれぞれのプロトコルの詳細を説明できませんが、<emphasis role="pkg">quagga-doc</emphasis> パッケージに含まれる <command>info</command> ファイルで十分な説明が行われています。また、同じ内容を Quagga のウェブサイト上で HTML として閲覧するほうが簡単かもしれません。<ulink type="block" url="http://www.nongnu.org/quagga/docs/docs-info.html" />
		</para>
		 <para>
			加えて、設定構文は標準的なルータの設定インターフェースととても似ているため、ネットワーク管理者は <command>quagga</command> に素早く順応するでしょう。
		</para>
		 <sidebar> <title><emphasis>IN PRACTICE</emphasis> OSPF、BGP、RIP?</title>
		 <para>
			一般に、OSPF はプライベートネットワークの動的ルーティングに使われる最良のプロトコルです。BGP はインターネット全体のルーティングに使われることが多いプロトコルです。RIP は比較的古典的で、ほとんど使われません。
		</para>
		 </sidebar>
	</section>
	 <section id="sect.ipv6">
		<title>IPv6</title>
		 <para>
			IPv6 は IPv4 の後継で、IP プロトコルの新しいバージョンで、IPv4 の欠点 (中でも注目すべきは利用できる IP アドレスの枯渇) を解決するために設計されました。IPv6 はネットワーク層で動きます。そして IPv6 の目的はマシンをアドレス指定する方法を提供すること、目標の宛先にデータを伝達すること、必要ならばデータの断片化を取り扱うことです (言い換えれば、経路で使われるネットワークリンクに従ってパケットをあるサイズのチャンクに分割し、到着した時に適切な順番にチャンクを再構築することです)。
		</para>
		 <para>
			Debian カーネルは IPv6 をコアカーネルでサポートします (<literal>ipv6</literal> という名前でコンパイルされたモジュールを使って IPv6 をサポートする一部のアーキテクチャを除きます)。<command>ping</command>、<command>traceroute</command> などの基本ツールには IPv6 用の <command>ping6</command>、<command>traceroute6</command> などの代替品があり、これらはそれぞれ <emphasis role="pkg">iputils-ping</emphasis>、<emphasis role="pkg">iputils-tracepath</emphasis> パッケージに含まれます。
		</para>
		 <indexterm>
			<primary>IPv6</primary>
		</indexterm>
		 <indexterm>
			<primary><emphasis role="pkg">iputils-ping</emphasis></primary>
		</indexterm>
		 <indexterm>
			<primary><emphasis role="pkg">iputils-tracepath</emphasis></primary>
		</indexterm>
		 <para>
			IPv6 ネットワークは IPv4 と同様に <filename>/etc/network/interfaces</filename> で設定します。しかし、ネットワークをグローバルに利用できるようにしたい場合、グローバル IPv6 ネットワークへのトラフィックを中継するための IPv6 を取り扱うことができるルータを持っていなければいけません。
		</para>
		 <example id="example.network-interfaces-ipv6">
			<title>IPv6 設定の例</title>
			 
<programlisting>
iface eth0 inet6 static
    address 2001:db8:1234:5::1:1
    netmask 64
    # 自動設定の無効化
    # autoconf 0
    # ルータが自動設定されており、ルータが固定アドレスを持っていない場合は
    # accept_ra 1 を有効化してください。それ以外の場合は以下を有効化してください。
    # gateway 2001:db8:1234:5::1</programlisting>

		</example>
		 <para>
			IPv6 サブネットのネットマスクは通常 64 ビットです。これは、サブネットの中に 2<superscript>64</superscript> 個の異なるアドレスが存在することを意味します。この特徴のおかげで、インターフェースの MAC アドレスに基づいたアドレスを選ぶステートレスアドレス自動設定 (<acronym>SLAAC</acronym>) を使うことが可能です。ネットワークで <acronym>SLAAC</acronym> が有効化されコンピュータで IPv6 が有効化された場合、デフォルトでカーネルは自動的に IPv6 ルータを探してネットワークインターフェースを設定します。
		</para>
		 <para>
			SLAAC の挙動はプライバシーを推測される危険性をはらんでいます。たとえばラップトップでネットワークを頻繁に切り替える場合、公開 IPv6 アドレスの一部に <acronym>MAC</acronym> アドレスを含めたくないかもしれません。SLAAC のせいで、異なるネットワーク上の同じデバイスを容易に識別できるようになります。この問題に対する解決策が IPv6 プライバシー拡張です (初回インストール時に IPv6 接続が検出された場合、Debian は IPv6 プライバシー拡張をデフォルトで有効化します)。IPv6 プライバシー拡張を使うとインターフェースにランダムに生成されたアドレスを割り当て、定期的にこれを変更し、外部に出る接続にはこのアドレスを使うようになります。外部から入ってくる接続は SLAAC で生成されたアドレスを使うことも可能です。以下の例では <filename>/etc/network/interfaces</filename> の中で IPv6 プライバシー拡張を有効化しています。
		</para>
		 <example id="example.network-interface-ipv6-privext">
			<title>IPv6 プライバシー拡張</title>
			 
<programlisting>
iface eth0 inet6 auto
    # 外部へ接続する際にランダムに割り当てられたアドレスを使います。
    privext 2</programlisting>

		</example>
		 <sidebar> <title><emphasis>TIP</emphasis> プログラムの IPv6 対応</title>
		 <para>
			多くのソフトウェアを IPv6 に対応させる必要があります。Debian に含まれるほとんどのパッケージは既に IPv6 に対応済みですが、すべてではありません。もしお気に入りのパッケージがまだ IPv6 に対応していない場合、<emphasis>debian-ipv6</emphasis> メーリングリストで助けを求めることも可能です。彼らは IPv6 に対応している代替ソフトウェアを知っているかもしれませんし、この問題について適切な追跡が行えるようなバグ報告を投稿できるかもしれません。<ulink type="block" url="http://lists.debian.org/debian-ipv6/" />
		</para>
		 </sidebar> <indexterm>
			<primary>IPv6 ファイアウォール</primary>
		</indexterm>
		 <indexterm>
			<primary>ファイアウォール</primary>
			<secondary>IPv6</secondary>
		</indexterm>
		 <indexterm>
			<primary><command>ip6tables</command></primary>
		</indexterm>
		 <para>
			IPv6 接続は IPv4 と同様の方法で制限することが可能です。すなわち 標準的な Debian カーネルは IPv6 用の <emphasis>netfilter</emphasis> に対応しています。IPv6 対応の <emphasis>netfilter</emphasis> を設定するには IPv4 でやったのと同様の方法を使います。ただし、<command>iptables</command> の代わりに <command>ip6tables</command> を使います。
		</para>
		 <section id="sect.ipv6-tunneling">
			<title>トンネル</title>
			 <sidebar> <title><emphasis>CAUTION</emphasis> IPv6 トンネルとファイアウォール</title>
			 <para>
				IPv4 上に IPv6 トンネルを作るには (ネイティブ IPv6 とは対照的に) IPv4 プロトコル 41 番を使うトラフィックを受け入れるファイアウォールが必要です。
			</para>
			 </sidebar> <para>
				ネイティブ IPv6 接続が利用できない場合、IPv4 上のトンネルを経由する代替法が使われます。gogo6 はこのようなトンネルの (無料) プロバイダです。<ulink type="block" url="http://www.gogo6.com/freenet6/tunnelbroker" />
			</para>
			 <indexterm>
				<primary>Freenet6</primary>
			</indexterm>
			 <indexterm>
				<primary>gogo6</primary>
			</indexterm>
			 <para>
				Freenet6 トンネルを使うには、ウェブサイトから Freenet6 Pro アカウントを登録し、<emphasis role="pkg">gogoc</emphasis> パッケージをインストールし、トンネルを設定します。<filename>/etc/gogoc/gogoc.conf</filename> ファイルを編集する必要があります。具体的に言えば、電子メールで受け取った <literal>userid</literal> と <literal>password</literal> 行を追加し、<literal>server</literal> を <literal>authenticated.freenet6.net</literal> に置き替えます。
			</para>
			 <para>
				IPv6 接続をローカルネットワークのすべてのマシンに提供するには、以下の 3 つの指示文を <filename>/etc/gogoc/gogoc.conf</filename> ファイルに追加します (ここで、ローカルネットワークは eth0 インターフェースに接続されていると仮定します)。
			</para>
			 
<programlisting>
host_type=router
prefixlen=56
if_prefix=eth0</programlisting>
			 <para>
				これでマシンは 56 ビットのプレフィックスを持つサブネット用のアクセスルータになります。Freenet6 トンネルが設定変更を検出したら、ローカルネットワークに設定変更を通知しなければいけません。これを行うには <command>radvd</command> デーモン (同名のパッケージに含まれます) をインストールします。<command>radvd</command> IPv6 設定デーモンは IPv4 で言うところの <command>dhcpd</command> と同様の役割を果たします。
			</para>
			 <para>
				<filename>/etc/radvd.conf</filename> 設定ファイルを作成しなければいけません (ひな形の <filename>/usr/share/doc/radvd/examples/simple-radvd.conf</filename> を参照してください)。Freenet6 を使う場合、プレフィックス設定を Freenet6 から提供されたものに変更するだけで十分です。プレフィックスを探すには <command>ifconfig</command> コマンドの出力から <literal>tun</literal> インターフェースを含むブロックを参照します。
			</para>
			 <indexterm>
				<primary><command>radvd</command></primary>
			</indexterm>
			 <para>
				この後 <command>service gogoc restart</command> と <command>service radvd start</command> を実行すれば、IPv6 ネットワークが使えるはずです。
			</para>

		</section>

	</section>
	 <section id="sect.domain-name-servers">
		<title>ドメインネームサーバ (DNS)</title>
		 <section id="sect.dns-principe">
			<title>原理とメカニズム</title>
			 <indexterm>
				<primary>DNS</primary>
			</indexterm>
			 <indexterm>
				<primary>サーバ</primary>
				<secondary>ネームサーバ</secondary>
			</indexterm>
			 <para>
				<emphasis>ドメインネームサービス</emphasis> (DNS) はインターネットの基礎要素です。つまり DNS はホスト名を IP アドレスに対応付け (逆に IP アドレスをホスト名に対応付けることも行います)、<literal>5.153.231.4</literal> や <literal>2001:41c8:1000:21::21:4</literal> の代わりに <literal>www.debian.org</literal> を使えるようにします。
			</para>
			 <para>
				DNS レコードはゾーン分けされています。それぞれのゾーンはドメイン (またはサブドメイン) か IP アドレス範囲に対応付けられます (なぜなら、ゾーンは通常連続した IP アドレス範囲を割り当てられるからです)。プライマリサーバはあるゾーンに含まれる内容の情報を提供する権威的なサーバです。さらに、セカンダリサーバは通常プライマリサーバとは別のマシン上でホストされ、定期的にプライマリゾーンのコピーをとるサーバです。
			</para>
			 <indexterm>
				<primary>ゾーン</primary>
				<secondary>DNS</secondary>
			</indexterm>
			 <indexterm>
				<primary>DNS</primary>
				<secondary>ゾーン</secondary>
			</indexterm>
			 <para>
				各ゾーンには、さまざまな種類のレコード (<emphasis>リソースレコード</emphasis>) が含まれます。
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>A</literal>。IPv4 アドレスを意味します。<indexterm><primary>A、DNS レコード</primary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>CNAME</literal>。別名 (<emphasis>canonical name</emphasis>) を意味します。<indexterm><primary>CNAME、DNS レコード</primary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>MX</literal>。<emphasis>mail exchange</emphasis> つまり電子メールサーバを意味します。MX レコードは電子メールサーバが自分の管理下にないアドレス宛の電子メールの送信先を見つけるために使われます。それぞれの MX レコードには優先度があります。最も優先度の高いサーバ (最も低い番号のサーバ) に対する送信を最初に試行します (補注<xref linkend="sidebar.smtp" />を参照してください)。さらに、最初のサーバからの応答がなかった場合、他のサーバを優先度の高い順に試行します。<indexterm><primary>MX</primary><secondary>DNS レコード</secondary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>PTR</literal>。ある IP アドレスに対する名前の対応付けを意味します。<literal>PTR</literal> レコードはある IP アドレス範囲に対応付けられた「逆引き DNS」ゾーンに保存されます。たとえば、<literal>1.168.192.in-addr.arpa</literal> は <literal>192.168.1.0/24</literal> 範囲に含まれる全アドレスの逆引き対応が保存されているゾーンです。<indexterm><primary>PTR、DNS レコード</primary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>AAAA</literal>。IPv6 アドレスを意味します。<indexterm><primary>AAAA、DNS レコード</primary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>NS</literal>。名前とネームサーバの対応付けを意味します。それぞれのドメインは最低 1 つの NS レコードを持っています。NS レコードでは、このドメインに対する問い合わせに答えることができる DNS サーバを指定します。これは通常そのドメインに対するプライマリおよびセカンダリサーバです。NS レコードを使って DNS の権限委譲を指定することも可能です。たとえば、<literal>falcot.com</literal> ゾーンの NS レコードには <literal>internal.falcot.com</literal> が含まれます。これは <literal>internal.falcot.com</literal> ゾーンは別のサーバが担当していることを意味します。もちろん、このサーバは <literal>internal.falcot.com</literal> ゾーンを宣言しなければいけません。<indexterm><primary>NS、DNS レコード</primary></indexterm>
					</para>

				</listitem>

			</itemizedlist>
			 <indexterm>
				<primary>レコード</primary>
				<secondary>DNS</secondary>
			</indexterm>
			 <indexterm>
				<primary>DNS レコード</primary>
			</indexterm>
			 <para>
				標準的なネームサーバである Bind は ISC (<emphasis>Internet Software Consortium</emphasis>) によって開発およびメンテナンスされています。Debian において Bind を提供するパッケージは <emphasis role="pkg">bind9</emphasis> です。Bind バージョン 9 では、前のバージョンに比べて 2 種類の大きな変更が導入されました。1 番目は DNS サーバを非特権ユーザとして実行するという変更です。これにより、サーバのセキュリティ脆弱性によって攻撃者に root 権限を渡してしまうことがなくなりました (バージョン 8.x ではこのようなことがよくありました)。
			</para>
			 <para>
				2 番目は Bind が DNS レコードの署名 (すなわち DNS レコードの認証) に DNSSEC 標準をサポートするようになった変更です。これにより、中間者攻撃で DNS レコードが偽装された場合に、偽装された DNS レコードを遮断することが可能になりました。
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">bind9</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>ISC</primary>
			</indexterm>
			 <indexterm>
				<primary>Internet Software Consortium</primary>
			</indexterm>
			 <sidebar> <title><emphasis>CULTURE</emphasis> DNSSEC</title>
			 <indexterm>
				<primary>DNSSEC</primary>
			</indexterm>
			 <para>
				DNSSEC の規格はかなり複雑です。さらに DNSSEC はその複雑さにより、まだ広く使われている規格ではありません (DNSSEC に未対応の DNS サーバと完全に共存するにも関わらず使われていません)。一部始終を理解するには、以下の記事を参照してください。<ulink type="block" url="http://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions" />
			</para>
			 </sidebar>
		</section>
		 <section id="sect.dns-config">
			<title>設定</title>
			 <para>
				バージョンによらず <command>bind</command> の設定ファイルは同じ構造をしています。
			</para>
			 <para>
				Falcot の管理者は <literal>falcot.com</literal> ドメインに関連する情報を保存するためにプライマリ <literal>falcot.com</literal> ゾーンを作成し、ローカルネットワーク内の IP アドレスとの逆引き対応を付けるために <literal>168.192.in-addr.arpa</literal> ゾーンを作成しました。
			</para>
			 <sidebar> <title><emphasis>CAUTION</emphasis> 逆引きゾーンの名前</title>
			 <indexterm>
				<primary>ゾーン</primary>
				<secondary sortas="ギャクビキ">逆引き</secondary>
			</indexterm>
			 <indexterm>
				<primary sortas="ギャクビキゾーン">逆引きゾーン</primary>
			</indexterm>
			 <indexterm>
				<primary><literal>in-addr.arpa</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>ip6.arpa</literal></primary>
			</indexterm>
			 <indexterm>
				<primary>ニブルフォーマット</primary>
			</indexterm>
			 <para>
				逆引きゾーンには特定の名前が付けられています。<literal>192.168.0.0/16</literal> ネットワークに対する逆引きゾーンは <literal>168.192.in-addr.arpa</literal> のように名付けなければいけません。具体的に言えば、IP アドレス部分の順序を逆にして、その後ろに <literal>in-addr.arpa</literal> サフィックスを付けます。
			</para>
			 <para>
				IPv6 ネットワークの場合、IP アドレスを完全に 16 進数表記した時の文字を逆順にして、その後ろに <literal>ip6.arpa</literal> サフィックスを付けます。つまり、<literal>2001:0bc8:31a0::/48</literal> ネットワークはゾーン名として <literal>0.a.1.3.8.c.b.0.1.0.0.2.ip6.arpa</literal> を使います。
			</para>
			 </sidebar> <sidebar> <title><emphasis>TIP</emphasis> DNS サーバのテスト</title>
			 <para>
				<command>host</command> コマンド (<emphasis role="pkg">bind9-host</emphasis> パッケージに含まれます) は引数に DNS サーバを与えることができ、DNS サーバの設定をテストするために使うことも可能です。たとえば <command>host machine.falcot.com localhost</command> を使うと、<literal>localhost</literal> 上の DNS サーバに <literal>machine.falcot.com</literal> を問い合わせた際の応答を確認することが可能です。<command>host <replaceable>ipaddress</replaceable> localhost</command> を使うと逆引き設定をテストすることが可能です。
			</para>
			 <indexterm>
				<primary><command>host</command></primary>
			</indexterm>
			 </sidebar> <para>
				以下に Falcot のファイルから抜粋した設定を載せます。これは DNS サーバの設定の足掛かりになります。
			</para>
			 <indexterm>
				<primary><filename>named.conf</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/bind/named.conf</filename></primary>
			</indexterm>
			 <example id="example.bind-named.conf.local">
				<title><filename>/etc/bind/named.conf.local</filename> の抜粋</title>
				 
<programlisting>
zone "falcot.com" {
        type master;
        file "/etc/bind/db.falcot.com";
        allow-query { any; };
        allow-transfer {
                195.20.105.149/32 ; // ns0.xname.org
                193.23.158.13/32 ; // ns1.xname.org
        };
};

zone "internal.falcot.com" {
        type master;
        file "/etc/bind/db.internal.falcot.com";
        allow-query { 192.168.0.0/16; };
};

zone "168.192.in-addr.arpa" {
        type master;
        file "/etc/bind/db.192.168";
        allow-query { 192.168.0.0/16; };
};</programlisting>

			</example>
			 <example id="example.bind-db.falcot.com">
				<title><filename>/etc/bind/db.falcot.com</filename> の抜粋</title>
				 
<programlisting>; falcot.com ゾーン
; admin.falcot.com. でゾーン連絡先アドレスに admin@falcot.com を指定したことになります
$TTL    604800
@       IN      SOA     falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
;
; @ はゾーン名 (ここでは "falcot.com") または
; $ORIGIN 指示文が使われていた場合 $ORIGIN を意味します
;
@       IN      NS      ns
@       IN      NS      ns0.xname.org.

internal IN      NS      192.168.0.2

@       IN      A       212.94.201.10
@       IN      MX      5 mail
@       IN      MX      10 mail2

ns      IN      A       212.94.201.10
mail    IN      A       212.94.201.10
mail2   IN      A       212.94.201.11
www     IN      A       212.94.201.11

dns     IN      CNAME   ns</programlisting>

			</example>
			 <sidebar> <title><emphasis>CAUTION</emphasis> 名前の構文</title>
			 <para>
				マシン名の構文には厳密なルールがあります。たとえば、<literal>machine</literal> は <literal>machine.<replaceable>domain</replaceable></literal> を意味します。名前にこのドメイン名を加えるべきでない場合、名前を <literal>machine.</literal> のように表記 (ドットを後置) しなければいけません。このため、現在のドメインの外部にある DNS 名を表すには <literal>machine.otherdomain.com.</literal> のような構文 (最後にドットを後置) が必要です。
			</para>
			 </sidebar> <example id="example.bind-db.192.168">
				<title><filename>/etc/bind/db.192.168</filename> の抜粋</title>
				 
<programlisting>; 192.168.0.0/16 用の逆引きゾーン
; admin.falcot.com. でゾーン連絡先アドレスに admin@falcot.com を指定したことになります
$TTL    604800
@       IN      SOA     ns.internal.falcot.com. admin.falcot.com. (
                        20040121        ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL

        IN      NS      ns.internal.falcot.com.

; 192.168.0.1 を arrakis に対応付けます
1.0     IN      PTR     arrakis.internal.falcot.com.
; 192.168.0.2 を neptune に対応付けます
2.0     IN      PTR     neptune.internal.falcot.com.

; 192.168.3.1 を pau に対応付けます
1.3     IN      PTR     pau.internal.falcot.com.</programlisting>

			</example>

		</section>

	</section>
	 <section id="sect.dhcp">
		<title>DHCP</title>
		 <para>
			DHCP (<emphasis>Dynamic Host Configuration Protocol</emphasis> の略語) はマシンが起動時にネットワーク設定を自動的に取得することを可能にするプロトコルです。DHCP のおかげでネットワーク設定の管理を中央集権化し、すべてのデスクトップマシンに類似した設定を行うことが可能になります。
		</para>
		 <indexterm>
			<primary>DHCP</primary>
		</indexterm>
		 <indexterm>
			<primary>Dynamic Host Configuration Protocol</primary>
		</indexterm>
		 <indexterm>
			<primary>ネットワーク</primary>
			<secondary sortas="DHCP セッテイ">DHCP 設定</secondary>
		</indexterm>
		 <para>
			DHCP サーバは多くのネットワーク関連パラメータを提供します。DHCP サーバが提供する最も一般的なパラメータは IP アドレスとマシンの所属するネットワークです。しかしながら、DHCP サーバは DNS サーバ、WINS サーバ、NTP サーバなどの情報を提供することも可能です。
		</para>
		 <para>
			(<command>bind</command> の開発にも参加している) Internet Software Consortium は DHCP サーバの主開発者です。彼らの開発した DHCP サーバを含む Debian パッケージは <emphasis role="pkg">isc-dhcp-server</emphasis> です。
		</para>
		 <section id="sect.dhcp-config">
			<title>設定</title>
			 <para>
				DHCP サーバの設定ファイル (<filename>/etc/dhcp/dhcpd.conf</filename>) で最初に編集する必要がある場所はドメイン名と DNS サーバです。DHCP サーバがローカルネットワーク (ブロードキャストが届く範囲として定義されます) に 1 台しかない場合、<literal>authoritative</literal> 指示文を有効化しなければいけません (コメントを外さなければいけません)。また、<literal>subnet</literal> セクションを作成し、そこに通知先のローカルネットワークと設定情報を記述する必要があります。以下は <literal>192.168.0.1</literal> にゲートウェイを担当しているルータが存在する <literal>192.168.0.0/24</literal> ローカルネットワーク用の設定例です。配布される IP アドレスは <literal>192.168.0.128</literal> から <literal>192.168.0.254</literal> までの範囲です。
			</para>
			 <example id="example.dhcp-dhcpd.conf">
				<title><filename>/etc/dhcp/dhcpd.conf</filename> の抜粋</title>
				 
<programlisting>
#
# Debian の ISC dhcpd 用設定ファイルの見本
#

# ddns-update-style パラメータは IP アドレスのリースが確認されたら
# このサーバが DNS 更新を試行するか否かを制御します。
# デフォルト設定値はバージョン 2 パッケージの挙動です
# ('none'。なぜなら DHCP v2 は DDNS をサポートしていなかったからです)。
ddns-update-style interim;

# すべてのネットワークに共通のオプションを定義します。
option domain-name "internal.falcot.com";
option domain-name-servers ns.internal.falcot.com;

default-lease-time 600;
max-lease-time 7200;

# この DHCP サーバがローカルネットワークの公式 DHCP サーバならば、
# authoritative 指示文を有効化するべきです。
authoritative;

# dhcp ログメッセージを別のログファイルへ送信するには以下の設定を使います
# (これを正しく動作させるには syslog.conf の設定も必要です)。
log-facility local7;

# 自分のサブネット
subnet 192.168.0.0 netmask 255.255.255.0 {
    option routers 192.168.0.1;
    option broadcast-address 192.168.0.255;
    range 192.168.0.128 192.168.0.254;
    ddns-domainname "internal.falcot.com";
}</programlisting>

			</example>

		</section>
		 <section id="sect.dhcp-dns">
			<title>DHCP と DNS</title>
			 <indexterm>
				<primary>DNS</primary>
				<secondary sortas="ジドウコウシン">自動更新</secondary>
			</indexterm>
			 <para>
				DNS ゾーン内に DHCP クライアントを自動登録するという便利な機能を使うことが可能です。自動登録機能を使えば、各マシンの意味のある名前を使ってアクセスできるようになります (自動登録機能を使わない場合、<literal>machine-192-168-0-131.internal.falcot.com</literal> などの匿名性のある名前を使ってアクセスすることになります)。自動登録機能を使うには、DHCP サーバから <literal>internal.falcot.com</literal> DNS ゾーンの更新を受け入れるように DNS サーバを設定して、各クライアントの登録情報の更新を DNS サーバに送信するように DHCP サーバを設定します。
			</para>
			 <para>
				<command>bind</command> の場合、DHCP サーバから更新を受け入れる各ゾーンに <literal>allow-update</literal> 指示文を追加する必要があります (<literal>internal.falcot.com</literal> ドメインと逆引きゾーンの両方に追加する必要があります)。<literal>allow-update</literal> 指示文は更新を受け入れる IP アドレスをリストします。つまり、考え得る DHCP サーバの全アドレスを列挙します (必要に応じて、ローカルアドレスと公開アドレスの両方を指定します)。
			</para>
			 
<programlisting>
allow-update { 127.0.0.1 192.168.0.1 212.94.201.10 !any };</programlisting>
			 <para>
				注意してください! 更新を受け入れることを許可したゾーンは <command>bind</command> により<emphasis>変更され</emphasis>、設定ファイルは定期的に上書きされます。この自動手続きにより作成されるファイルは手作業で書かれたものよりも人間にとって読みづらいため、Falcot の管理者は権限委譲された DNS サーバを使って <literal>internal.falcot.com</literal> ドメインを管理しています。これは <literal>falcot.com</literal> ゾーンファイルは手作業で管理されることを意味します。
			</para>
			 <para>
				上で引用した DHCP サーバの設定には、既に DNS ゾーンの更新に必要な指示文が含まれています。すなわちその指示文とは <literal>ddns-update-style interim;</literal> とサブネットを表すブロック中の <literal>ddns-domain-name "internal.falcot.com";</literal> です。
			</para>

		</section>

	</section>
	 <section id="sect.network-diagnosis-tools">
		<title>ネットワーク診断ツール</title>
		 <para>
			ネットワークアプリケーションが期待通りに動かない場合、中身を確かめることが重要です。すべてが問題なく動いているように見える場合でも、ネットワーク診断を実行すればすべてがあるべき姿で動いていることを確かめる手助けになります。この目的で複数の診断ツールが存在します。そして、各ツールは異なるレベルを診断します。
		</para>
		 <section id="sect.netstat">
			<title>ローカルの診断、<command>netstat</command></title>
			 <indexterm>
				<primary><command>netstat</command></primary>
			</indexterm>
			 <para>
				最初に <command>netstat</command> コマンド (<emphasis role="pkg">net-tools</emphasis> パッケージに含まれます) を紹介しましょう。<command>netstat</command> コマンドはマシンのその瞬間のネットワーク活動に関する要約を表示します。何も引数を渡さずに実行した場合、<command>netstat</command> コマンドは開かれた接続をリストします。このリストはとても長くなる場合があります。なぜなら、このリストには多くの Unix ドメインソケットが含まれるからです (Unix ドメインソケットはデーモンによって広く使われています)。Unix ドメインソケットはネットワークに関与するものではありません (<literal>dbus</literal> 通信、<literal>X11</literal> トラフィック、仮想ファイルシステムとデスクトップ間の通信などに関与するものです)。
			</para>
			 <para>
				一般的に <command>netstat</command> を実行する際には標準の挙動を変更するオプションを使います。最も頻繁に使われるオプションを以下に挙げます。
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>-t</literal>。TCP 接続だけが表示されます。
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-u</literal>。UDP 接続だけが表示されます。<literal>-t</literal> と <literal>-u</literal> オプションは同時に使えます。Unix ドメインソケットの表示を抑制するにはどちらか一方を使うだけで十分です。
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-a</literal>。リッスンしている (接続を待ち受けている) ソケットも表示されます。
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-n</literal>。結果が数値的に表示されます。すなわち、IP アドレス (DNS で名前解決しません)、ポート番号 (<filename>/etc/services</filename> の定義する別名を使いません)、ユーザ id (ログイン名を使いません) を使って表示されます。
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-p</literal>。関連付けられたプロセスが表示されます。<command>netstat</command> を root 権限で実行した場合にのみ、このオプションは役に立ちます。なぜなら、普通のユーザは自分のプロセス以外を見ることができないからです。
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>-c</literal>。継続的に接続リストを更新します。
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				<citerefentry><refentrytitle>netstat</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> マニュアルページに書かれている他のオプションを使えば、表示される結果をさらに細かく制御することが可能です。実質的には上に挙げたオプションのうち最初の 5 種類を組み合わせて使うことが多いため、結果としてシステムとネットワークの管理者は <command>netstat -tupan</command> を身に付けることが多いです。負荷の高くないマシンでは、以下のような典型的な結果を返します。
			</para>
			 
<screen role="scale">
<computeroutput># </computeroutput><userinput>netstat -tupan</userinput>
<computeroutput>稼働中のインターネット接続 (サーバと確立)
Proto 受信-Q 送信-Q 内部アドレス            外部アドレス            状態        PID/Program name
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      397/rpcbind     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      431/sshd        
tcp        0      0 0.0.0.0:36568           0.0.0.0:*               LISTEN      407/rpc.statd   
tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      762/exim4       
tcp        0    272 192.168.1.242:22        192.168.1.129:44452     ESTABLISHED 1172/sshd: roland [
tcp6       0      0 :::111                  :::*                    LISTEN      397/rpcbind     
tcp6       0      0 :::22                   :::*                    LISTEN      431/sshd        
tcp6       0      0 ::1:25                  :::*                    LISTEN      762/exim4       
tcp6       0      0 :::35210                :::*                    LISTEN      407/rpc.statd   
udp        0      0 0.0.0.0:39376           0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:996             0.0.0.0:*                           397/rpcbind     
udp        0      0 127.0.0.1:1007          0.0.0.0:*                           407/rpc.statd   
udp        0      0 0.0.0.0:68              0.0.0.0:*                           916/dhclient    
udp        0      0 0.0.0.0:48720           0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:111             0.0.0.0:*                           397/rpcbind     
udp        0      0 192.168.1.242:123       0.0.0.0:*                           539/ntpd        
udp        0      0 127.0.0.1:123           0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:123             0.0.0.0:*                           539/ntpd        
udp        0      0 0.0.0.0:5353            0.0.0.0:*                           451/avahi-daemon: r
udp        0      0 0.0.0.0:39172           0.0.0.0:*                           407/rpc.statd   
udp6       0      0 :::996                  :::*                                397/rpcbind     
udp6       0      0 :::34277                :::*                                407/rpc.statd   
udp6       0      0 :::54852                :::*                                916/dhclient    
udp6       0      0 :::111                  :::*                                397/rpcbind     
udp6       0      0 :::38007                :::*                                451/avahi-daemon: r
udp6       0      0 fe80::5054:ff:fe99::123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:a:123 :::*                                539/ntpd        
udp6       0      0 2001:bc8:3a7e:210:5:123 :::*                                539/ntpd        
udp6       0      0 ::1:123                 :::*                                539/ntpd        
udp6       0      0 :::123                  :::*                                539/ntpd        
udp6       0      0 :::5353                 :::*                                451/avahi-daemon: r
</computeroutput></screen>
			 <para>
				予想通り、確立された接続 (2 つの SSH 接続) と接続を待ち受けているアプリケーション (<literal>LISTEN</literal> と記載されます。特に 25 番をリッスンしている Exim4 電子メールサーバ) が表示されます。
			</para>

		</section>
		 <section id="sect.nmap">
			<title>リモートの診断、<command>nmap</command></title>
			 <indexterm>
				<primary><command>nmap</command></primary>
			</indexterm>
			 <para>
				<command>nmap</command> (同名のパッケージに含まれます) はある意味でリモートに対する <command>netstat</command> に相当します。<command>nmap</command> は 1 台または数台のリモートサーバに対して「well-known」ポート群をスキャンし、入ってきた接続に応答したアプリケーションの見つかったポートをリストします。さらに、<command>nmap</command> は一部のアプリケーションを識別することが可能です。場合によってはアプリケーションのバージョン番号さえも識別することが可能です。<command>nmap</command> は <command>netstat</command> と対照的にリモートから実行されるため、プロセスやユーザの情報を提供できません。しかしながら、<command>nmap</command> は複数のリモートサーバに対して一気に実行できます。
			</para>
			 <para>
				<command>nmap</command> を実行する際の典型例は <literal>-A</literal> オプション (<command>nmap</command> は見つかったサーバソフトウェアのバージョンを識別しようとします) だけを使い、その後ろにスキャンする 1 つか複数の IP アドレスまたは DNS 名を渡すことです。繰り返しになりますが、他にも多くのオプションが存在し、<command>nmap</command> の挙動をさらに細かく制御することが可能です。<citerefentry> <refentrytitle>nmap</refentrytitle>
				 <manvolnum>1</manvolnum> </citerefentry> マニュアルページを参照してください。
			</para>
			 
<screen role="scale" width="80">
<computeroutput># </computeroutput><userinput>nmap mirtuel</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-10 00:46 JST
Nmap scan report for mirtuel (192.168.1.242)
Host is up (0.000013s latency).
rDNS record for 192.168.1.242: mirtuel.internal.placard.fr.eu.org
Not shown: 998 closed ports
PORT    STATE SERVICE
22/tcp  open  ssh
111/tcp open  rpcbind

Nmap done: 1 IP address (1 host up) scanned in 2.41 seconds
# </computeroutput><userinput>nmap -A localhost</userinput>
<computeroutput>
Starting Nmap 6.47 ( http://nmap.org ) at 2015-03-10 00:46 JST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.000013s latency).
Other addresses for localhost (not scanned): 127.0.0.1
Not shown: 997 closed ports
PORT    STATE SERVICE VERSION
22/tcp  open  ssh     OpenSSH 6.7p1 Debian 3 (protocol 2.0)
|_ssh-hostkey: ERROR: Script execution failed (use -d to debug)
25/tcp  open  smtp    Exim smtpd 4.84
| smtp-commands: mirtuel Hello localhost [127.0.0.1], SIZE 52428800, 8BITMIME, PIPELINING, HELP, 
|_ Commands supported: AUTH HELO EHLO MAIL RCPT DATA NOOP QUIT RSET HELP 
111/tcp open  rpcbind 2-4 (RPC #100000)
| rpcinfo: 
|   program version   port/proto  service
|   100000  2,3,4        111/tcp  rpcbind
|   100000  2,3,4        111/udp  rpcbind
|   100024  1          36568/tcp  status
|_  100024  1          39172/udp  status
Device type: general purpose
Running: Linux 3.X
OS CPE: cpe:/o:linux:linux_kernel:3
OS details: Linux 3.7 - 3.15
Network Distance: 0 hops
Service Info: Host: mirtuel; OS: Linux; CPE: cpe:/o:linux:linux_kernel

OS and Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 11.54 seconds
</computeroutput></screen>
			 <para>
				予想通り、SSH と Exim4 アプリケーションが表示されます。すべてのアプリケーションがすべての IP アドレスをリッスンしているわけではない点に注意してください。すなわち、Exim4 は <literal>lo</literal> ループバックインターフェースからのみアクセスできますから、<literal>localhost</literal> の解析にのみ表示され <literal>mirtuel</literal> (これは同じマシンの <literal>eth0</literal> インターフェースに対応付けられています) をスキャンした時には表示されません。
			</para>

		</section>
		 <section id="sect.sniffers">
			<title>スニファ、<command>tcpdump</command> と <command>wireshark</command></title>
			 <para>
				しばしば実際にワイヤを行き来する情報をパケットごとに見る必要がある場合があります。この際に使われるツールは「フレームアナライザ」と呼ばれ、<emphasis>スニファ</emphasis>としても広く知られています。この種のツールは指定したネットワークに到達したすべてのパケットを観察し、ユーザにわかりやすい方法でパケットを表示します。
			</para>
			 <indexterm>
				<primary><command>tcpdump</command></primary>
			</indexterm>
			 <para>
				ネットワークトラフィック解析分野における由緒あるツールが <command>tcpdump</command> です。<command>tcpdump</command> は広範囲のプラットフォームで利用できる標準的なツールです。<command>tcpdump</command> を使うと多くの種類のネットワークトラフィックをキャプチャできますが、<command>tcpdump</command> のトラフィックの表現は決してわかりやすいものではありません。このため <command>tcpdump</command> に関しては詳しく説明しません。
			</para>
			 <indexterm>
				<primary><command>wireshark</command></primary>
			</indexterm>
			 <para>
				より最近の (そしてより現代的な) ツールである <command>wireshark</command> (<emphasis role="pkg">wireshark</emphasis> パッケージに含まれます) はキャプチャされたパケットの解析を単純化する多くのデコーディングモジュールのおかげでネットワークトラフィック解析分野における新しい標準的なツールになりつつあります。パケットはプロトコル層に基づいてグラフィカルに表示されます。<command>wireshark</command> を使うと、ユーザはあるパケットに関わるすべてのプロトコルを可視化することが可能です。たとえば、HTTP リクエストを含むパケットに対して、<command>wireshark</command> は物理層、イーサネット層、IP パケット情報、TCP 接続パラメータ、最後に HTTP リクエスト自身に関連する情報を別々に表示します。
			</para>
			 <figure id="figure.wireshark">
				<title><command>wireshark</command> ネットワークトラフィックアナライザ</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/wireshark.png" format="PNG" scalefit="1" width="75%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <para>
				上の例では、SSH を通じて移動するパケットを (<literal>!tcp.port == 22</literal> フィルタを使って) 除去しています。ここで詳細を表示されているパケットは HTTP 層で作られたものです。
			</para>
			 <sidebar> <title><emphasis>TIP</emphasis> グラフィカルインターフェースを持たない <command>wireshark</command>、<command>tshark</command></title>
			 <indexterm>
				<primary><command>tshark</command></primary>
			</indexterm>
			 <para>
				グラフィカルインターフェースを実行できない場合や何らかの理由で実行したくない場合に備えて、<command>wireshark</command> のテキスト版 <command>tshark</command> (<emphasis role="pkg">tshark</emphasis> パッケージに分割されています) が存在します。キャプチャとデコード機能のほとんどを利用できますが、グラフィカルインターフェースがないことでプログラムとのやり取りが制限されます (たとえば、パケットがキャプチャされた後にフィルタをかけたり、特定の TCP 接続を追跡したりすることが不可能です)。しかし <command>tshark</command> を足掛かりとして使うことが可能です。さらなる操作が必要だったりグラフィカルインターフェースが必要な操作を行う場合、パケットをファイルに保存してそのファイルを別のマシンで実行されているグラフィカルな <command>wireshark</command> で読み込むことが可能です。
			</para>
			 </sidebar>
		</section>

	</section>
</chapter>

