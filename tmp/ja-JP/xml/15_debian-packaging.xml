<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="debian-packaging" lang="ja-JP">
	<chapterinfo>
		 <keywordset>
			<keyword>バックポート</keyword>
			 <keyword>再ビルド</keyword>
			 <keyword>ソースパッケージ</keyword>
			 <keyword>アーカイブ</keyword>
			 <keyword>メタパッケージ</keyword>
			 <keyword>Debian 開発者</keyword>
			 <keyword>メンテナ</keyword>

		</keywordset>

	</chapterinfo>
	 <title>Debian パッケージの作成</title>
	 <highlights> <para>
		Debian パッケージを標準的な方法で取り扱ってきた管理者がいずれは自分自身のパッケージを作成したり、既存のパッケージを変更したりする必要性を感じるということは極めて普通のことです。この章ではパッケージングに関する最も一般的な質問に答えたり、最良のやり方で Debian インフラをうまく使うために必要な要素を提供したりすることを目標にしています。運が良ければ、ローカルパッケージを取り扱った後、さらに進んで Debian プロジェクト自体に参加する必要性を感じるかもしれません。
	</para>
	 </highlights> <section id="sect.rebuilding-package">
		<title>ソースを使ったパッケージの再ビルド</title>
		 <para>
			いくつかの状況下では、バイナリパッケージの再ビルドが必要です。たとえば、管理者は特定のコンパイルオプションを付けてソフトウェアをソースからコンパイルすることで導入されるソフトウェアの機能を必要とする場合があります。そしてまた、インストール済みの Debian のバージョン用にパッケージングされたソフトウェアのバージョンが古い場合があります。ソフトウェアのバージョンが古い場合、管理者は<emphasis role="distribution">テスト版</emphasis>や<emphasis role="distribution">不安定版</emphasis>などの Debian の新しいバージョンから取得したより新しいパッケージをビルドすることが多いです。こうすることで、新しいパッケージを<emphasis role="distribution">安定版</emphasis>ディストリビューションで動かすことが可能です。この操作は「バックポート」と呼ばれています。いつも通り、バックポート作業の前に既にバックポートパッケージが公開されているか否かを注意深く確認するべきです。対象のパッケージに対する Debian Package Tracker を一読するだけでこの種の情報が明らかになります。<ulink type="block" url="https://tracker.debian.org/" /><indexterm><primary>バックポート</primary></indexterm>
		</para>
		 <section>
			<title>ソースの取得</title>
			 <para>
				Debian パッケージの再ビルドはパッケージのソースコードを取得することから始まります。最も簡単な方法は <command>apt-get source <replaceable>source-package-name</replaceable></command> コマンドを使うことです。このコマンドを実行するには <filename>/etc/apt/sources.list</filename> ファイルの中に <literal>deb-src</literal> 行が必要で、さらに最新のインデックスファイルが必要です (たとえば <command>apt-get update</command> を実行する必要があります)。管理者が APT 設定を取り扱う章で説明した内容 (<xref linkend="sect.apt-sources.list" />を参照してください) に従っている場合、これらの状況は既に満足されているはずです。しかしながら、<command>apt-get source <replaceable>source-package-name</replaceable></command> コマンドは <literal>deb-src</literal> 行で言及されている Debian バージョンのソースパッケージをダウンロードする点に注意してください。もし他のバージョンのソースパッケージが必要な場合、Debian アーカイブミラーや Debian のウェブサイトから手作業でダウンロードする必要があるかもしれません。この場合には 2、3 個のファイルをダウンロードする必要があります (<emphasis>Debian Source Control</emphasis> 用に <filename>*.dsc</filename> 拡張子を持つファイル、<filename>*.tar.<replaceable>comp</replaceable></filename> としばしば <filename>*.diff.gz</filename> や <filename>*.debian.tar.<replaceable>comp</replaceable></filename> 拡張子を持つファイル、ここで <replaceable>comp</replaceable> は使われている圧縮ツールに応じて <literal>gz</literal>、<literal>bz2</literal>、<literal>xz</literal> のうちのどれか 1 つです)。その後、<command>dpkg-source -x <replaceable>file.dsc</replaceable></command> コマンドを実行します。<filename>*.dsc</filename> ファイルがある URL から直接利用できるならば、<command>dget <replaceable>URL</replaceable></command> コマンドを使えばより簡単にすべてを取得することが可能です。dget コマンドは (<emphasis role="pkg">devscripts</emphasis> パッケージに含まれます) 指定したアドレスから <filename>*.dsc</filename> ファイルを取得し、内容を解析し、ファイル内で参照されている単一もしくは複数のファイルを自動的に取得します。すべてのダウンロードが完了したら、dget コマンドはソースパッケージを展開します (これは <literal>-d</literal> または <literal>--download-only</literal> オプションが使われていない場合に限ります)。
			</para>

		</section>
		 <section>
			<title>修正を行う</title>
			 <para>
				これでパッケージのソースがソースパッケージとバージョンを基に名付けられたディレクトリ (たとえば <emphasis>samba-4.1.17+dfsg</emphasis> など) の中で利用できるようになりました。修正作業はこのディレクトリ内で行われます。
			</para>
			 <para>
				最初にパッケージのバージョン番号を変更します。こうすることで、再ビルドされたパッケージを Debian の提供する元パッケージと区別することが可能です。現在のバージョンが <literal>2:4.1.17+dfsg-2</literal> の場合、バージョン <literal>2:4.1.17+dfsg-2falcot1</literal> を作成することが可能です。これはパッケージの出自を明らかに示しています。このパッケージのバージョン番号は Debian が提供する元パッケージのバージョン番号よりも大きいため、このパッケージを元パッケージの更新として簡単にインストールできます。このような作業を極めて効果的に行うには、<emphasis role="pkg">devscripts</emphasis> パッケージの提供する <command>dch</command> コマンド (<emphasis>Debian CHangelog</emphasis>) を <command>dch --local falcot</command> のように使います。これは最良の効果を発揮します。<command>dch</command> コマンドはテキストエディタ (<command>sensible-editor</command>。このエディタは <varname>VISUAL</varname> または <varname>EDITOR</varname> 環境変数で定義されているお気に入りのエディタです。そうでなければデフォルトエディタです) を起動します。ここで、再ビルドによって導入される変更の内容を記述してください。このエディタは <command>dch</command> が <filename>debian/changelog</filename> ファイルを変更したことを示します。
			</para>
			 <para>
				ビルドオプションの変更が必要な場合、<filename>debian/rules</filename> を修正します。<filename>debian/rules</filename> はパッケージビルド作業の各段階を動作させるものです。<filename>debian/rules</filename> が最も単純に書かれている場合、初期設定 (<literal>./configure …</literal>) や実際のビルド (<literal>$(MAKE) …</literal> や <literal>make …</literal>) を実行するコマンドを簡単に見つけられるでしょう。ファイル内にこれらのコマンドが明示的に書かれていない場合、このファイルの内容は別のコマンドに対する作用を書いているのかもしれません。このような場合、デフォルト挙動を変える方法をより詳細に学ぶために文書を参照してください。<command>dh</command> を使っているパッケージのビルドオプションを変更する場合、<command>dh_auto_configure</command> や <command>dh_auto_build</command> コマンドを再定義する必要があるかもしれません (これを行う方法に関する説明は各コマンドのマニュアルページをご覧ください)。
			</para>
			 <para>
				パッケージに対して行った変更の内容によっては、<filename>debian/control</filename> ファイルの内容もまた更新する必要があります。<filename>debian/control</filename> ファイルには生成されるパッケージの説明が含まれます。特に、<filename>debian/control</filename> ファイルにはパッケージのビルド時点で満足されなければいけない依存関係のリストを制御する <literal>Build-Depends</literal> 行が含まれます。<literal>Build-Depends</literal> 行で指定されているパッケージのバージョンはソースパッケージが提供されるディストリビューションに含まれるパッケージのバージョンと一致している場合が多いです。しかし、再ビルドを行うディストリビューションではここで指定されているバージョンが利用できないかもしれません。依存関係が本物か、それともビルド時にライブラリの最新版を試すことを保証するためだけ指定されているかを決定する自動的な方法はありません。<literal>Build-Depends</literal> 行を使うことが<emphasis>自動ビルドロボット</emphasis>にビルド中に与えられたパッケージバージョンを使うことを強制するための唯一の方法なので、Debian メンテナはバージョンを厳しく指定したビルド依存関係を使うことが多いです。
			</para>
			 <para>
				もしあなたが、指定されているビルド依存関係を緩めても問題ないと確信できる場合、手元で自由に依存関係を緩和することが可能です。対象のソフトウェアをビルドする標準的な方法について説明しているファイル (<filename>INSTALL</filename> と名付けられていることが多いです) を読むことは適切な依存関係を明らかにする助けになります。理想的に言えば、再ビルドに使うディストリビューションの要素を使ってすべての依存関係を満足させるべきです。しかしそれが無理ならば、対象のパッケージをバックポートする前に、再帰的に <literal>Build-Depends</literal> フィールドで言及されているパッケージを必ずバックポートしなければいけません。一部のパッケージはバックポートの必要がなく、ビルド作業中に現状のままインストールできます (特筆すべき例は <emphasis role="pkg">debhelper</emphasis> です)。バックポート作業は気を付けないとすぐに複雑になる点に注意してください。それゆえ、バックポートは可能な限り厳密に必要最低限に留めるべきです。
			</para>
			 <sidebar> <title><emphasis>TIP</emphasis> <literal>Build-Depends</literal> のインストール</title>
			 <indexterm>
				<primary><literal>Build-Depends</literal>、コントロールフィールド</primary>
			</indexterm>
			 <para>
				<command>apt-get</command> を使うことで、あるソースパッケージの <literal>Build-Depends</literal> フィールドに指定されているすべてのパッケージをインストールすることが可能です。<command>apt-get</command> は <filename>/etc/apt/sources.list</filename> ファイルの <literal>deb-src</literal> 行で指定されているディストリビューションに含まれるソースパッケージの <literal>Build-Depends</literal> フィールドに指定されているパッケージをインストールします。これを行うには、<command>apt-get build-dep <replaceable>source-package</replaceable></command> コマンドを実行するだけです。
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>再ビルドの開始</title>
			 <para>
				ソースに対するすべての必要な変更が完了したら、実際のバイナリパッケージ (<filename>.deb</filename> ファイル) を生成します。すべてのプロセスは <command>dpkg-buildpackage</command> コマンドで管理されます。
			</para>
			 <example>
				<title>パッケージの再ビルド</title>
				 
<screen><computeroutput>$ </computeroutput><userinput>dpkg-buildpackage -us -uc
</userinput><computeroutput>[...]
</computeroutput></screen>

			</example>
			 <sidebar id="sidebar.fakeroot"> <title><emphasis>TOOL</emphasis> <command>fakeroot</command></title>
			 <para>
				基本的に、パッケージ作成作業とは存在する (ビルドされた) ファイル群を 1 つのアーカイブにまとめるという単純な作業に過ぎません。さらにほとんどのファイルは最終的にアーカイブ中で <emphasis>root</emphasis> によって所有されることになります。しかしながら、パッケージ全体を root で作ると暗黙のうちにリスクが増加します。しかし幸いなことに、<command>fakeroot</command> コマンドを使うことでこれを避けることが可能です。<command>fakeroot</command> 環境を使うことで、プログラムを実行したり、プログラムに自分の実行者が <emphasis>root</emphasis> であり任意の所有者とパーミッションを持つファイルを作成することが可能であると認識させたりすることが可能になります。<command>fakeroot</command> 環境下で Debian パッケージとなるアーカイブを作成した場合、<command>fakeroot</command> プログラムは <emphasis>root</emphasis> およびその他のユーザに所有されるファイルを含むアーカイブを作成します。<command>dpkg-buildpackage</command> がパッケージをビルドする際にデフォルトで <command>fakeroot</command> を使っていることからも分かる通り、<command>fakeroot</command> 環境下でパッケージをビルドすることはとても便利な方法です。
			</para>
			 <para>
				<command>fakeroot</command> 環境下で動作するプログラムはだまされて特権アカウントとして操作するように「信じこまされる」だけです。プロセスは <command>fakeroot <replaceable>program</replaceable></command> を実行しているユーザの権限で実行されます (作成されるファイルはそのユーザのパーミッションを与えられます)。fakeroot が実際に root 権限を取得してそれを乱用することは決してありません。
			</para>
			 </sidebar> <para>
				<literal>Build-Depends</literal> フィールドが更新されていなかったり、関連するパッケージがインストールされていなかった場合、<command>dpkg-buildpackage</command> コマンドは失敗します。そのような場合、<command>dpkg-buildpackage</command> に <literal>-d</literal> オプションを指定して、依存関係確認を行わないようにすることも可能です。しかしながら、依存関係を明示的に無視すると後々の段階でビルド作業が失敗する恐れがあります。さらに悪いことに、パッケージが正常にビルドされたように見えても正しく動かない可能性があります。なぜなら一部のプログラムは必要なライブラリがビルド時に利用できない場合に一部の機能を自動的に無効化するからです。
			</para>
			 <para>
				しばしば、Debian 開発者は <command>debuild</command> などの高レベルプログラムを使います。<command>debuild</command> は通常通り <command>dpkg-buildpackage</command> を実行するだけでなく、生成されたパッケージの Debian ポリシーに対する妥当性を確認するプログラムも実行します。<command>debuild</command> スクリプトは、手元の環境変数がパッケージビルドを「汚染」しないように、ビルド環境を整えます。<command>debuild</command> コマンドは <emphasis>devscripts</emphasis> スイートに含まれるツールの 1 つで、メンテナの作業を簡単にするためのいくつかの一貫性と設定を共有します。
			</para>
			 <sidebar> <title><emphasis>QUICK LOOK</emphasis> <command>pbuilder</command></title>
			 <indexterm>
				<primary><command>pbuilder</command></primary>
			</indexterm>
			 <para>
				<command>pbuilder</command> プログラム (同名のパッケージに含まれます) を使うことで、<emphasis>chroot された</emphasis>環境の中で Debian パッケージをビルドすることが可能になります。<command>pbuilder</command> プログラムは最初にパッケージをビルドするために必要な最低限のシステム (と <emphasis>Build-Depends</emphasis> フィールドで指定されているパッケージ) を含む一時ディレクトリを作成します。このディレクトリは <command>chroot</command> コマンドビルド中に使うルートディレクトリ (<filename>/</filename>) として使われます。
			</para>
			 <para>
				<command>pbuilder</command> ツールを使うことで、ビルド作業をユーザの操作によって変更されない環境の中で行うことが可能になります。さらに、<command>pbuilder</command> ツールを使うことで、言及されていないビルド依存関係を素早く検出することが可能になります (なぜなら、適切な依存関係が指定されていなければビルドは失敗するからです)。最後に、<command>pbuilder</command> ツールを使うことで、システム用に使われている Debian バージョン以外の Debian バージョン向けのパッケージをビルドすることが可能になります。つまり、マシンは通常の作業用に<emphasis role="distribution">安定版</emphasis>を使うことが可能です。そして、同じマシン上で動作する <command>pbuilder</command> はパッケージビルド専用に<emphasis role="distribution">不安定版</emphasis>を使うことが可能です。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.building-first-package">
		<title>最初のパッケージのビルド</title>
		 <section>
			<title>メタパッケージやフェイクパッケージ</title>
			 <para>
				フェイクパッケージとメタパッケージは似ています。両者は自分のメタデータをパッケージ取り扱いスタックに置いておくためだけに存在する抜け殻です。
			</para>
			 <para>
				フェイクパッケージの目的は <command>dpkg</command> と <command>apt</command> をだまして、抜け殻に過ぎないいくつかのパッケージがインストールされていると信じこませることにあります。フェイクパッケージを使うことで、あるソフトウェアの依存関係を満足させるために必要なソフトウェアがパッケージシステムの管轄外にインストールされている場合に、そのソフトウェアの依存関係を満足させることが可能です。フェイクパッケージを使うことで、依存関係の問題は解決されますが、これはできる限り避けるべき方法です。なぜなら、手作業でインストールされたソフトウェアが対応するパッケージと全く同様に振る舞う保証はありませんし、手作業でインストールされたソフトウェアに依存する他のパッケージが適切に動く保証もないからです。
			</para>
			 <para>
				逆に、メタパッケージはメタパッケージをインストールするだけで一連の他のパッケージをインストールすることが可能になる依存関係の集合体として使われます。
			</para>
			 <para>
				フェイクパッケージとメタパッケージは <command>equivs-control</command> と <command>equivs-build</command> コマンド (<emphasis role="pkg">equivs</emphasis> パッケージに含まれます) を使って作成されます。<command>equivs-control <replaceable>file</replaceable></command> コマンドは Debian パッケージヘッダファイルを作成します。Debian パッケージヘッダファイルには、パッケージの名前、バージョン番号、メンテナ、依存関係、説明を含めるように編集します。デフォルト値を持たない他のフィールドは任意で、削除することも可能です。<literal>Copyright</literal>、<literal>Changelog</literal>、<literal>Readme</literal>、<literal>Extra-Files</literal> フィールドは Debian パッケージの標準的なフィールドではありません。さらに、これらのフィールドは <command>equivs-build</command> を使う限りにおいて意味を持つものであり、生成されるパッケージのヘッダから削除されます。
			</para>
			 <example>
				<title><emphasis>libxml-libxml-perl</emphasis> フェイクパッケージのヘッダファイル</title>
				 
<programlisting>
Section: perl
Priority: optional
Standards-Version: 3.9.6

Package: libxml-libxml-perl
Version: 2.0116-1
Maintainer: Raphael Hertzog &lt;hertzog@debian.org&gt;
Depends: libxml2 (&gt;= 2.7.4)
Architecture: all
Description: Fake package - module manually installed in site_perl
 This is a fake package to let the packaging system
 believe that this Debian package is installed. 
 .
 In fact, the package is not installed since a newer version
 of the module has been manually compiled &amp; installed in the
 site_perl directory.</programlisting>

			</example>
			 <para>
				次のステップでは、<command>equivs-build <replaceable>file</replaceable></command> コマンドを使って Debian パッケージを生成します。さぁこれでパッケージは現在のディレクトリに作成され、他の Debian パッケージと同様に取り扱うことが可能になります。
			</para>

		</section>
		 <section>
			<title>単純なファイルアーカイブ</title>
			 <para>
				Falcot Corp の管理者は大量のマシン上に一連の文書を配備することを簡単に行うために Debian パッケージを作成する必要があります。この作業を担当している管理者は最初に「新メンテナーガイド」を読み、その後最初のパッケージに対する作業に着手します。<ulink type="block" url="https://www.debian.org/doc/manuals/maint-guide/" />
			</para>
			 <para>
				最初に、対象のソースパッケージを含める <filename>falcot-data-1.0</filename> ディレクトリを作成します。こうしておけば、パッケージは必然的に <literal>falcot-data</literal> と名付けられ、バージョン番号は <literal>1.0</literal> になります。その後、管理者は文書ファイルを <filename>data</filename> サブディレクトリに置きます。その後、管理者は <command>dh_make</command> コマンド (<emphasis role="pkg">dh-make</emphasis> パッケージに含まれます) を実行し、パッケージ生成作業に必要なファイルを追加します。ここで追加されるファイルは <filename>debian</filename> サブディレクトリに保存されます。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cd falcot-data-1.0</userinput>
<computeroutput>$ </computeroutput><userinput>dh_make --native</userinput>
<computeroutput>
Type of package: single binary, indep binary, multiple binary, library, kernel module, kernel patch?
 [s/i/m/l/k/n] </computeroutput><userinput>i</userinput>
<computeroutput>
Maintainer name : Raphael Hertzog
Email-Address   : hertzog@debian.org
Date            : Sat, 05 Sep 2015 01:09:39 +0900
Package Name    : falcot-data
Version         : 1.0
License         : gpl3
Type of Package : Independent
Hit &lt;enter&gt; to confirm:
Currently there is no top level Makefile. This may require additional tuning.
Done. Please edit the files in the debian/ subdirectory now. You should also
check that the falcot-data Makefiles install into $DESTDIR and not in / .
$</computeroutput></screen>
			 <para>
				パッケージの種類で <emphasis>indep binary</emphasis> を選ぶと、ソースパッケージから単一のバイナリパッケージを生成します。ここで生成されるバイナリパッケージはすべてのアーキテクチャで共有されます (<literal>Architecture: all</literal>)。<emphasis>single binary</emphasis> はその逆の振る舞いで、対象のアーキテクチャに依存する (<literal>Architecture: any</literal>) 単一のバイナリを生成します。今回作成するパッケージの場合、<emphasis>indep binary</emphasis> がより適切です。なぜなら、このパッケージは文書だけを含みバイナリプログラムを含まないからです。このため、すべてのアーキテクチャのコンピュータで同様に使うことが可能です。
			</para>
			 <indexterm>
				<primary sortas="パッケージノシュルイ">パッケージの種類</primary>
			</indexterm>
			 <indexterm>
				<primary>パッケージ</primary>
				<secondary sortas="シュルイ">種類</secondary>
			</indexterm>
			 <para>
				<emphasis>multiple binary</emphasis> を選ぶと、ソースパッケージから複数のバイナリパッケージを作成することになります。<emphasis>library</emphasis> は特別な場合で、共有ライブラリ用に用意されています。なぜなら、共有ライブラリは厳しいパッケージング規則に従う必要があるからです。同様に、<emphasis>kernel module</emphasis> および <emphasis>kernel patch</emphasis> はカーネルモジュールを含むパッケージ用に用意されています。
			</para>
			 <sidebar> <title><emphasis>TIP</emphasis> メンテナの名前と電子メールアドレス</title>
			 <para>
				パッケージメンテナンスに関わるほとんどのプログラムはメンテナの名前と電子メールアドレスを <varname>DEBFULLNAME</varname> と <varname>DEBEMAIL</varname> または <varname>EMAIL</varname> 環境変数から取得します。たった 1 回これらの環境変数を定義するだけで、毎回これらの情報を打ち込む必要がなくなります。通常のシェルが <command>bash</command> の場合、<filename>~/.bashrc</filename> ファイルに以下の 2 行 (当然ですが、値を自分のものに変えてください!) を追加するだけで簡単にこれを行うことが可能です。
			</para>
			 
<programlisting>
export EMAIL="hertzog@debian.org"
export DEBFULLNAME="Raphael Hertzog"</programlisting>
			 </sidebar> <para>
				<command>dh_make</command> コマンドによって <filename>debian</filename> サブディレクトリと各種ファイルが作成されました。特に <filename>rules</filename>、<filename>control</filename>、<filename>changelog</filename>、<filename>copyright</filename> などの一部のファイルは必須です。<filename>.ex</filename> 拡張子を持つファイルは例ファイルで、必要ならばこれらのファイルをひな形として (拡張子を削除して) 使うことが可能です。必要なければ例ファイルを削除することを推奨します。<filename>compat</filename> ファイルはそのままにしておくべきです。なぜなら、<filename>compat</filename> ファイルはパッケージビルド作業のさまざまな段階で使われる <emphasis>debhelper</emphasis> プログラムスイート (<command>dh_</command> から始まるプログラム群) を適切に動作させるために必要だからです。
			</para>
			 <para>
				<filename>copyright</filename> ファイルには必ずパッケージに含まれる文書の著者と対応するライセンスに関する情報を含めなければいけません。今回の場合、パッケージには内部文書が含まれ、その使用は Falcot Corp の社内だけに制限されています。デフォルトの <filename>changelog</filename> ファイルはほとんどの場合に適切です。「Initial release」をより詳しい説明に置き換えたり、<literal>unstable</literal> を <literal>internal</literal> に変えるだけで十分です。<filename>control</filename> ファイルも更新します。具体的に言えば、<literal>Section</literal> フィールドの値を <emphasis>misc</emphasis> に変更し、<literal>Homepage</literal>、<literal>Vcs-Git</literal>、<literal>Vcs-Browser</literal> を削除しました。<literal>Depends</literal> フィールドの値には <literal>iceweasel | www-browser</literal> を加えました。これはパッケージ内の文書を表示するために必要なウェブブラウザがインストールされていることを保証するためです。
			</para>
			 <example>
				<title><filename>control</filename> ファイル</title>
				 
<programlisting>
Source: falcot-data
Section: misc
Priority: optional
Maintainer: Raphael Hertzog &lt;hertzog@debian.org&gt;
Build-Depends: debhelper (&gt;= 9)
Standards-Version: 3.9.5

Package: falcot-data
Architecture: all
Depends: iceweasel | www-browser, ${misc:Depends}
Description: Internal Falcot Corp Documentation
 This package provides several documents describing the internal
 structure at Falcot Corp.  This includes:
  - organization diagram
  - contacts for each department.
 .
 These documents MUST NOT leave the company.
 Their use is INTERNAL ONLY.</programlisting>

			</example>
			 <example>
				<title><filename>changelog</filename> ファイル</title>
				 
<programlisting>
falcot-data (1.0) internal; urgency=low

  * Initial Release.
  * Let's start with few documents:
    - internal company structure;
    - contacts for each department.

 -- Raphael Hertzog &lt;hertzog@debian.org&gt;  Sat, 05 Sep 2015 01:09:39 +0900</programlisting>

			</example>
			 <example>
				<title><filename>copyright</filename> ファイル</title>
				 
<programlisting>
Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
Upstream-Name: falcot-data

Files: *
Copyright: 2004-2015 Falcot Corp
License: 
 All rights reserved.</programlisting>

			</example>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> <filename>Makefile</filename> ファイル</title>
			 <indexterm>
				<primary><filename>Makefile</filename></primary>
			</indexterm>
			 <para>
				<filename>Makefile</filename> ファイルは <command>make</command> プログラムによって使われるスクリプトであり、互いに依存関係を持つファイル群をビルドする規則を指定します (たとえば、複数のソースファイル群から 1 つのプログラムをビルドする規則を指定します)。<filename>Makefile</filename> ファイルはビルド規則を以下のフォーマットで指定します。
			</para>
			 
<programlisting>
target: source1 source2 ...
        command1
        command2</programlisting>
			 <para>
				ビルド規則の解釈は以下の通り行われます。すなわち、<literal>source*</literal> ファイルの 1 つが <literal>target</literal> ファイルよりも新しい場合、<command>command1</command> と <command>command2</command> を使って target を生成します。
			</para>
			 <para>
				コマンド行は必ずタブ文字で開始しなければいけない点に注意してください。さらに、コマンド行がダッシュ文字 (<literal>-</literal>) で始まる場合、そのコマンドが失敗しても全体のプロセスは停止されなくなる点に注意してください。
			</para>
			 </sidebar> <para>
				<filename>rules</filename> ファイルには、(生成されるバイナリパッケージにちなんで名付けられた) 専用のサブディレクトリ内で対象のソフトウェアを設定、ビルド、インストールするために使われる一連の規則が定義されています。このサブディレクトリの内容はあたかもサブディレクトリがファイルシステムのルートであるかのように Debian パッケージの中に保存されます。今回の場合、ファイルは <filename>debian/falcot-data/usr/share/falcot-data/</filename> サブディレクトリにインストールされます。こうすることで、生成されたパッケージをインストールするとファイルが <filename>/usr/share/falcot-data/</filename> の下に配備されます。<filename>rules</filename> ファイルはいくつかの標準的なターゲットが定義されている <filename>Makefile</filename> として使われます (定義済みターゲットの <literal>clean</literal> と <literal>binary</literal> はそれぞれソースディレクトリを削除する場合とバイナリパッケージを生成する場合に使います)。
			</para>
			 <para>
				<filename>rules</filename> ファイルはビルド作業の核心で、<command>debhelper</command> ツールによって提供される標準的なコマンド群を実行するために必要な最低限の要素だけを含みます。<filename>rules</filename> ファイルが面倒を見るのは <command>dh_make</command> によって生成されたファイルだけです。自分のファイルをインストールするためには、以下の <filename>debian/falcot-data.install</filename> ファイルを作成して、<command>dh_install</command> コマンドの挙動を単純に設定します。
			</para>
			 
<programlisting>
data/* usr/share/falcot-data/</programlisting>
			 <para>
				この時点でパッケージを作成することも可能ですが、パッケージにもう少しファイルを追加します。管理者はグラフィカルデスクトップ環境のメニューから文書へ簡単にアクセスできるようにしたいので、パッケージに <filename>falcot-data.desktop</filename> ファイルを追加します。さらに <filename>debian/falcot-data.install</filename> に例に示した 2 行目を追加して、<filename>/usr/share/applications</filename> の中に <filename>falcot-data.desktop</filename> ファイルをインストールします。
			</para>
			 <example>
				<title><filename>falcot-data.desktop</filename> ファイル</title>
				 
<programlisting>
[Desktop Entry]
Name=Internal Falcot Corp Documentation
Comment=Starts a browser to read the documentation
Exec=x-www-browser /usr/share/falcot-data/index.html
Terminal=false
Type=Application
Categories=Documentation;</programlisting>

			</example>
			 <para>
				編集後の <filename>debian/falcot-data.install</filename> は以下のようになります。
			</para>
			 
<programlisting>
data/* usr/share/falcot-data/
falcot-data.desktop usr/share/applications/</programlisting>
			 <para>
				これでソースパッケージの準備が整いました。最後に残された作業は以前パッケージを再ビルドした際に使った方法と同じ方法を使ってバイナリパッケージを生成することです。具体的に言えば、バイナリパッケージを生成するには、<filename>falcot-data-1.0</filename> ディレクトリの中で、<command>dpkg-buildpackage -us -uc</command> コマンドを実行します。
			</para>

		</section>

	</section>
	 <section id="sect.setup-apt-package-repository">
		<title>APT 用のパッケージリポジトリの作成</title>
		 <indexterm>
			<primary>パッケージアーカイブ</primary>
		</indexterm>
		 <indexterm>
			<primary>パッケージ</primary>
			<secondary>Debian</secondary>
			<tertiary>アーカイブ</tertiary>
		</indexterm>
		 <para>
			Falcot Corp のメンテナンスする Debian パッケージの数は次第に増えました。この中には既存のパッケージから手元で修正したパッケージや、内部データとプログラムを配布するために最初から作成したパッケージなどがあります。
		</para>
		 <para>
			パッケージの配備を簡単にするために、管理者はこれらのパッケージを APT から直接使うことが可能なパッケージアーカイブに組み込みたいと思っています。明らかなメンテナンス上の理由により、管理者は内部パッケージと手元で再ビルドしたパッケージを別にしたいと思っています。すなわち、最終的に <filename>/etc/apt/sources.list.d/falcot.list</filename> ファイル内のエントリを以下のようにしたいと思っています。
		</para>
		 
<programlisting>
deb http://packages.falcot.com/ updates/
deb http://packages.falcot.com/ internal/</programlisting>
		 <indexterm>
			<primary><command>mini-dinstall</command></primary>
		</indexterm>
		 <para>
			このため、管理者は内部 HTTP サーバ上に仮想ホストを設定して、APT リポジトリのルートとして <filename>/srv/vhosts/packages/</filename> を割り当てます。パッケージアーカイブ自体の管理は <command>mini-dinstall</command> コマンド (同名のパッケージに含まれます) に委託されます。<command>mini-dinstall</command> ツールは <filename>incoming/</filename> ディレクトリ (今回の場合、<filename>/srv/vhosts/packages/mini-dinstall/incoming/</filename>) を監視して、新しいパッケージがこのディレクトリにアップロードされることを待ちます。そしてパッケージがアップロードされたら、<command>mini-dinstall</command> は <filename>/srv/vhosts/packages/</filename> のパッケージアーカイブにパッケージをインストールします。<command>mini-dinstall</command> コマンドは Debian パッケージが生成された時に作成される <filename>*.changes</filename> ファイルを読みます。<filename>*.changes</filename> ファイルには、パッケージのバージョンに対応するその他のファイル (<filename>*.deb</filename>、<filename>*.dsc</filename>、<filename>*.diff.gz</filename>/<filename>*.debian.tar.gz</filename>、<filename>*.orig.tar.gz</filename>、その他の圧縮ツールを使った場合の同等ファイル) のリストが書かれており、<command>mini-dinstall</command> はこのリストに従ってインストールするファイルを把握します。さらに <filename>*.changes</filename> ファイルの <literal>Distribution</literal> ヘッダフィールドには、<filename>debian/changelog</filename> ファイル内の最新エントリに書かれた対象ディストリビューションの名前 (通常 <literal>unstable</literal>) が書かれており、<command>mini-dinstall</command> はこの名前に従ってパッケージのインストール先を決めます。このため、管理者は対象パッケージをビルドする前に <filename>debian/changelog</filename> ファイル内の最新エントリに書かれた対象ディストリビューションの名前を必ず変更し、対象パッケージのインストール先に従ってその名前を <literal>internal</literal> または <literal>updates</literal> に設定しなければいけません。この後、<command>mini-dinstall</command> は APT が必要とする <filename>Packages.gz</filename> などのファイルを生成します。
		</para>
		 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> <command>apt-ftparchive</command></title>
		 <indexterm>
			<primary><command>apt-ftparchive</command></primary>
		</indexterm>
		 <para>
			必要なパッケージアーカイブが <command>mini-dinstall</command> を使うほど複雑なパッケージアーカイブではない場合、<command>apt-ftparchive</command> コマンドを使うことも可能です。<command>apt-ftparchive</command> ツールは指定したディレクトリの内容を調査して、その内容に対応する <filename>Packages</filename> ファイルを (標準出力に) 表示します。<command>apt-ftparchive</command> を使う場合、Falcot Corp の管理者はパッケージを直接 <filename>/srv/vhosts/packages/updates/</filename> や <filename>/srv/vhosts/packages/internal/</filename> にアップロードすることが可能です。その後以下のコマンドを実行して <filename>Packages.gz</filename> ファイルを作成します。
		</para>
		 
<screen>
<computeroutput>$ </computeroutput><userinput>cd /srv/vhosts/packages</userinput>
<computeroutput>$ </computeroutput><userinput>apt-ftparchive packages updates &gt;updates/Packages</userinput>
<computeroutput>$ </computeroutput><userinput>gzip updates/Packages</userinput>
<computeroutput>$ </computeroutput><userinput>apt-ftparchive packages internal &gt;internal/Packages</userinput>
<computeroutput>$ </computeroutput><userinput>gzip internal/Packages</userinput></screen>
		 <para>
			<command>apt-ftparchive sources</command> コマンドを使えば、同様の方法で <filename>Sources.gz</filename> ファイルを作成することが可能です。
		</para>
		 </sidebar> <para>
			<command>mini-dinstall</command> を設定するには、<filename>~/.mini-dinstall.conf</filename> ファイルをセットアップする必要があります。Falcot Corp では以下の通り設定しました。
		</para>
		 
<programlisting>
[DEFAULT]
archive_style = flat
archivedir = /srv/vhosts/packages

verify_sigs = 0
mail_to = admin@falcot.com

generate_release = 1
release_origin = Falcot Corp
release_codename = stable

[updates]
release_label = Recompiled Debian Packages

[internal]
release_label = Internal Packages</programlisting>
		 <para>
			各パッケージアーカイブに対して <filename>Release</filename> ファイルを作成することに決めた点は注目に値します。これは <filename>/etc/apt/preferences</filename> 設定ファイルを使ってパッケージインストール優先度を管理する場合に役立ちます (詳細は<xref linkend="sect.apt.priorities" />を参照してください)。
		</para>
		 <sidebar> <title><emphasis>SECURITY</emphasis> <command>mini-dinstall</command> とパーミッション</title>
		 <para>
			<command>mini-dinstall</command> は標準的なユーザとして実行されるように設計されています。root で実行される必要はありません。最も簡単な方法は Debian パッケージ作成担当の管理者グループに所属するユーザアカウントを使ってすべてを設定することです。<filename>incoming/</filename> ディレクトリへファイルを追加するために必要な権限を与えられているのは Debian パッケージ作成担当の管理者だけなので、パッケージを追加する前に各パッケージの出自の確認は済んでいると考えられますし、<command>mini-dinstall</command> を使ってもう一度パッケージの出自を確認する必要もなくなります。この理由により、パラメータ <literal>verify_sigs = 0</literal> が設定されています (これは <command>mini-dinstall</command> が署名を確認する必要がないことを意味します)。しかしながら、パッケージの内容が機密に関わるものであれば、この設定を逆にして、パッケージ作成担当者の公開鍵を含む鍵束 (<literal>extra_keyrings</literal> パラメータを使って設定されます) を使ってパッケージの出自を確認するように設定することが可能です。そしてこのように設定した場合、<command>mini-dinstall</command> は <filename>*.changes</filename> ファイルに統合された署名を解析することによってアップロードされた各パッケージの出自を確認します。
		</para>
		 </sidebar> <para>
			<command>mini-dinstall</command> を実行すると、バックグラウンドでデーモンが開始されます。<command>mini-dinstall</command> デーモンが実行されている限り、デーモンは 30 分ごとに <filename>incoming/</filename> ディレクトリにアップロードされた新しいパッケージを確認します。そして新しいパッケージがアップロードされると、パッケージはパッケージアーカイブに移動され、適切な <filename>Packages.gz</filename> と <filename>Sources.gz</filename> ファイルが再生成されます。デーモンの実行に問題がある場合、<filename>incoming/</filename> ディレクトリにパッケージをアップロードしたら毎回、手作業で <command>mini-dinstall</command> をバッチモードで実行します (<literal>-b</literal> オプションを付けます)。<command>mini-dinstall</command> 他の使い方は <citerefentry><refentrytitle>mini-dinstall</refentrytitle>
			 <manvolnum>1</manvolnum></citerefentry> マニュアルページで説明されています。
		</para>
		 <sidebar> <title><emphasis>EXTRA</emphasis> 署名済みパッケージアーカイブの生成</title>
		 <para>
			APT スイートは対象のパッケージをインストールする前にそのパッケージに含まれる一連の暗号署名を確認し、そのパッケージの信頼性を確かめます (<xref linkend="sect.package-authentication" />を参照してください)。この挙動はプライベートパッケージアーカイブにとって問題です。なぜなら、プライベートパッケージアーカイブを使うマシンでは署名されていないパッケージに関する警告が表示され続けるからです。プライベートパッケージアーカイブを安全な APT メカニズムに適合させるのが真面目な管理者の仕事と言えます。
		</para>
		 <para>
			パッケージアーカイブの署名作業を助けるために、<command>mini-dinstall</command> には <filename>Release</filename> に対する署名の生成に使うスクリプトを指定する <literal>release_signscript</literal> 設定オプションが含まれます。ここでは <emphasis role="pkg">mini-dinstall</emphasis> パッケージによって提供された <filename>/usr/share/doc/mini-dinstall/examples/</filename> 内に含まれる <filename>sign-release.sh</filename> スクリプトが良い足掛かりとなるでしょう。しかし、このスクリプトを使うには手元で修正が必要になるかもしれません。
		</para>
		 </sidebar>
	</section>
	 <section id="sect.becoming-package-maintainer">
		<title>パッケージメンテナになる</title>
		 <section>
			<title>パッケージを作るための知識</title>
			 <para>
				上質な Debian パッケージを作成する作業が常に簡単な作業であるとは限りません。パッケージメンテナになるためには理論と実践の両方の知識が必要です。上質な Debian パッケージを作成する作業は単純にソフトウェアをビルドしたりインストールするだけの簡単な作業ではありません。むしろ複雑さの大部分は他の無数の利用できるパッケージとの問題と対立 (より一般には相関性) を理解することに由来します。
			</para>
			 <section>
				<title>規則</title>
				 <para>
					Debian パッケージは必ず Debian ポリシーにまとめられた明確な規則に従わなければいけません。各パッケージメンテナはこの規則を知らなければいけません。規則を暗記する必要はありませんが、規則の存在を知り、重要な判断を下す局面では常に規則を参照する必要があります。すべての Debian メンテナは規則をよく知らないことが原因で間違いを犯した経験がありますが、その間違いがバグ報告として報告されて修正される限り (熟練ユーザのおかげでバグ報告はかなり素早く報告されることが多いです)、これは大きな問題ではありません。<ulink type="block" url="https://www.debian.org/doc/debian-policy/" />
				</para>

			</section>
			 <section>
				<title>手続き</title>
				 <indexterm>
					<primary sortas="Debian カイハツシャリファレンス">Debian 開発者リファレンス</primary>
				</indexterm>
				 <para>
					Debian は各パッケージを単純に収集しているだけではありません。全員のパッケージング作業は共同プロジェクトの一部です。そして Debian 開発者になるには、Debian プロジェクトが全体としてどのように運営されているかを知る必要があります。すべての Debian 開発者は遅かれ早かれ他人と協力して行動することになるでしょう。Debian 開発者リファレンス (<emphasis role="pkg">developers-reference</emphasis> パッケージに含まれます) では、プロジェクト内のさまざまなチームと可能な限り円滑に一緒に作業を行ったり利用できる資源を大いに活用するためにすべての開発者が必ず知らなければいけないことを要約しています。また、Debian 開発者リファレンスは管理者が果たすべき数多くの義務も列挙しています。<ulink type="block" url="https://www.debian.org/doc/manuals/developers-reference/" />
				</para>

			</section>
			 <section>
				<title>ツール</title>
				 <para>
					パッケージメンテナの作業を手助けする数多くのツールが存在します。この節では、それらのツールを簡単に説明します (詳細は説明しません)。なぜなら、これらのツールには自分自身を解説する総合的な文書が用意されているからです。
				</para>
				 <section>
					<title><command>lintian</command> プログラム</title>
					 <indexterm>
						<primary><command>lintian</command></primary>
					</indexterm>
					 <para>
						<command>lintian</command> は最も重要なツールの 1 つです。すなわち、<command>lintian</command> は Debian パッケージをチェックするツールです。<command>lintian</command> は Debian ポリシーから作成された大量のテスト群に基づき、多くのエラーを素早く自動的に検出します。<command>lintian</command> を使うことで、パッケージのリリース前に多くのエラーを修正することが可能となります。
					</para>
					 <para>
						<command>lintian</command> の情報は参考程度にしかならず、間違いを犯すこともあります (たとえば、Debian ポリシーは常に変わるものなので、しばしば <command>lintian</command> は時代遅れになることがあります)。また、<command>lintian</command> は徹底的な調査を行いません。すなわち、<command>lintian</command> がエラーを出さないことを理由に対象のパッケージが完全であると結論付けてはいけません。<command>lintian</command> を使ってわかることはせいぜい最も一般的な間違いを犯していないことだけです。
					</para>

				</section>
				 <section>
					<title><command>piuparts</command> プログラム</title>
					 <indexterm>
						<primary><command>piuparts</command></primary>
					</indexterm>
					 <para>
						<command>piuparts</command> もまた重要なツールの 1 つです。すなわち、<command>piuparts</command> は (隔離環境の中で) パッケージのインストール、アップグレード、削除、完全削除の作業を自動化し、これらの作業中にエラーが起きないことを確認します。<command>piuparts</command> は不足している依存関係を検出したり、パッケージが完全削除された後にファイルが誤って残されたことを検出したりする際にも役立ちます。
					</para>

				</section>
				 <section>
					<title>devscripts</title>
					 <indexterm>
						<primary><emphasis role="pkg">devscripts</emphasis></primary>
					</indexterm>
					 <indexterm>
						<primary><command>debuild</command></primary>
					</indexterm>
					 <indexterm>
						<primary><command>dch</command></primary>
					</indexterm>
					 <indexterm>
						<primary><command>uscan</command></primary>
					</indexterm>
					 <indexterm>
						<primary><command>debi</command></primary>
					</indexterm>
					 <indexterm>
						<primary><command>debc</command></primary>
					</indexterm>
					 <para>
						<emphasis role="pkg">devscripts</emphasis> パッケージには、Debian 開発者が行う作業の大部分に対する手助けを行う数多くのプログラムが含まれます。
					</para>
					 <itemizedlist>
						<listitem>
							<para>
								<command>debuild</command> を使うことで、(<command>dpkg-buildpackage</command> から) パッケージを生成したり、Debian ポリシーへの遵守を確認するために後から <command>lintian</command> を実行することが可能です。
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>debclean</command> を使うことで、バイナリパッケージを生成した後にソースパッケージの後片付けをすることが可能です。
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>dch</command> を使うことで、素早く簡単にソースパッケージ中の <filename>debian/changelog</filename> ファイルを編集することが可能です。
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>uscan</command> を使うことで、上流開発者がソフトウェアの新しいバージョンをリリースしたか否かを確認することが可能です。確認を行うにはリリースの場所が書かれた <filename>debian/watch</filename> ファイルが必要です。
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>debi</command> を使うことで、Debian パッケージを生成した直後に (<command>dpkg -i</command> を使って) そのパッケージをインストールすることが可能になります。パッケージの完全な名前やパスを指定する必要はありません。
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>debc</command> を使うことで、Debian パッケージを生成した直後に (<command>dpkg -c</command> を使って) そのパッケージの内容を調査することが可能です。パッケージの完全な名前やパスを指定する必要はありません。
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>bts</command> を使うことで、コマンドラインからバグ追跡システムを制御することが可能です。<command>bts</command> プログラムは適切なメールを自動的に生成します。
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>debrelease</command> を使うことで、Debian パッケージを生成した直後にそのパッケージをリモートサーバにアップロードすることが可能です。関連する <filename>.changes</filename> ファイルの完全な名前やパスを指定する必要はありません。
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>debsign</command> を使うことで、<filename>*.dsc</filename> と <filename>*.changes</filename> ファイルに署名することが可能です。
							</para>

						</listitem>
						 <listitem>
							<para>
								<command>uupdate</command> を使うことで、新しい上流開発版がリリースされた場合にパッケージの新しい修正版の作成を自動化することが可能です。
							</para>

						</listitem>

					</itemizedlist>

				</section>
				 <section>
					<title><emphasis role="pkg">debhelper</emphasis> と <emphasis role="pkg">dh-make</emphasis></title>
					 <indexterm>
						<primary><emphasis>debhelper</emphasis></primary>
					</indexterm>
					 <indexterm>
						<primary><emphasis>dh-make</emphasis></primary>
					</indexterm>
					 <para>
						debhelper はポリシーを遵守するパッケージの作成を簡単にするスクリプト群です。これらのスクリプトは <filename>debian/rules</filename> から呼び出されます。大多数の公式 Debian パッケージが debhelper を使っているという事実からも分かる通り、debhelper は Debian の中で広く採用されています。debhelper から提供されるすべてのコマンドは名前の頭に <command>dh_</command> が付けられています。
					</para>
					 <para>
						<command>dh_make</command> スクリプト (<emphasis>dh-make</emphasis> パッケージに含まれます) はソフトウェアのソースが含まれるディレクトリ内に Debian パッケージを生成するために必要なファイルを作成します。<command>dh_make</command> という名前から推測される通り、生成されたファイルはデフォルトで debhelper を使います。
					</para>

				</section>
				 <section>
					<title><command>dupload</command> と <command>dput</command></title>
					 <indexterm>
						<primary><command>dupload</command></primary>
					</indexterm>
					 <indexterm>
						<primary><command>dput</command></primary>
					</indexterm>
					 <para>
						<command>dupload</command> と <command>dput</command> コマンドを使うことで、Debian パッケージを (場合によってはリモート) サーバにアップロードすることが可能です。<command>dupload</command> と <command>dput</command> コマンドを使うことで、開発者は主たる Debian サーバ (<literal>ftp-master.debian.org</literal>) 上に自分のパッケージを公開することが可能です。こうすることで、パッケージはパッケージアーカイブに組み込まれ、アーカイブミラーによって配布されます。<command>dupload</command> と <command>dput</command> コマンドは <filename>*.changes</filename> ファイルをパラメータとして受け取り、<filename>*.changes</filename> ファイルの内容から他の関連するファイルを推測します。
					</para>

				</section>

			</section>

		</section>
		 <section>
			<title>受け入れ過程</title>
			 <para>
				「Debian 開発者」になることは単なる管理上の手続きを経るだけの問題ではありません。受け入れ過程は複数の段階から成り、選考過程に匹敵する入会儀式と言えます。いかなる場合も、受け入れ過程は形式化され明確に文書化されています。そのため、誰でも新メンバー過程専用のウェブサイト上で進み具合を追跡することが可能です。<ulink type="block" url="https://nm.debian.org/" />
			</para>
			 <sidebar> <title><emphasis>EXTRA</emphasis> 「Debian メンテナ」向けの簡単なプロセス</title>
			 <para>
				「Debian メンテナ」とはもう一つの地位です。「Debian メンテナ」に与えられる特権は「Debian 開発者」よりも低いものですが、「Debian メンテナ」になるためのプロセスは「Debian 開発者」になるためのものよりも短い時間ですみます。「Debian メンテナ」の地位を持っている貢献者がメンテナンスできるのは自分自身のパッケージだけです。あなたが「Debian メンテナ」になりたいならば、少なくとも一人以上の Debian 開発者から最初のアップロードに対する確認を受ける必要があります。そして、あなたが自ら進んでパッケージをメンテナンスする能力を持つ見込みあるメンテナであるという点について、その Debian 開発者から信用されなければいけません。さらに、Debian 開発者があなたを信用するということについて声明を発表する必要があります。
			</para>
			 <indexterm>
				<primary>Debian メンテナ</primary>
			</indexterm>
			 </sidebar> <section>
				<title>必要条件</title>
				 <para>
					すべての候補者は少なくとも実務に役立つ英語力を持つことを期待されます。英語力はすべての段階で要求されます。たとえば試験官に対する最初の連絡はもちろんその後も必要です。なぜなら、英語はほとんどの文書で推奨される言語だからです。また、パッケージのユーザはバグを報告する際に英語で連絡を取るでしょうし、ユーザは英語で返信をもらうことを期待するでしょう。
				</para>
				 <para>
					もう一つの必要条件は意欲です。Debian 開発者の受け入れ過程に出願することが合理的な行為と考えられるのは候補者が Debian に対する自分の関心が何カ月も続くことを理解している場合に限ります。受け入れ過程は数カ月間続き、開発者として受け入れられた暁には Debian から長期にわたる苦労を要求されます。すなわち、それぞれのパッケージに対する永久的なメンテナンスが要求され、一回だけアップロードすればメンテナンスを終わらせられるというわけではありません。
				</para>

			</section>
			 <section>
				<title>登録</title>
				 <para>
					候補者が最初に (現実的な意味で) やることは保証人か支持者を見つけることです。そしてこれは公式の開発者が<emphasis>候補者</emphasis>を受け入れることが Debian のためになると信じていると喜んで宣言すること意味します。通常これは候補者が既にコミュニティ内で活発に活動し続けており、候補者の業績が受け入れられ続けていることを暗黙的に意味します。候補者が遠慮がちで候補者の業績が公に注目されていなければ、候補者は Debian 開発者に対して個人的な方法で自分の業績を明らかにして自分を支持することを納得するように試みることが可能です。
				</para>
				 <indexterm>
					<primary sortas="カギペア">鍵ペア</primary>
				</indexterm>
				 <para>
					同時に、候補者は GnuPG を使って RSA 公開鍵と秘密鍵のペアを生成しなければいけません。候補者の公開鍵は少なくとも 2 人の公式 Debian 開発者の秘密鍵によって署名されるべきです。この署名は候補者の公開鍵に書かれた名前が本物であることを証明するものです。実質的なことを言えば、候補者はキーサインパーティで公式 Debian 開発者に直接会って、自分の公開鍵を公式 Debian 開発者の秘密鍵によって署名してもらう必要があります。キーサインパーティの参加者は鍵 ID と一緒に必ず公式の身分証明書 (通常 ID カードかパスポート) を提示しなければいけません。これは人と鍵の関連付けを確認するために必要な措置です。候補者が公のフリーソフトウェアカンファレンスで公式 Debian 開発者に直接会っていない場合、候補者は以下のウェブページに載っているリストを足掛かりとして、近くに住んでいる開発者を探すことが可能です。<ulink type="block" url="https://wiki.debian.org/Keysigning" />
				</para>
				 <para>
					候補者の支持者が <literal>nm.debian.org</literal> 上の登録内容の正当性を認めたら、対象の候補者に対して 1 人の<emphasis>応募管理者</emphasis>が割り当てられます。応募管理者は複数の事前に定義された段階と確認を通じて作業を進めます。
				</para>
				 <para>
					最初の妥当性確認事項は候補者の本人確認です。既に 2 人の Debian 開発者が自分の秘密鍵で候補者の公開鍵に署名しているならば、この段階は簡単です。そうでなければ、応募管理者はあなたに対して、近くにいる Debian 開発者を探し、直接会ってキーサインする段取りを付けるように指導するでしょう。
				</para>

			</section>
			 <section>
				<title>原則の受け入れ</title>
				 <para>
					次の管理上の手続きでは哲学の検討を行います。ここで、候補者は社会契約とフリーソフトウェアの背後にある原理を理解して受け入れることに対して確認を取られます。Debian に参加するには、必ず創設理念 (および<xref linkend="the-debian-project" />) で述べられている現在の開発者を団結させている価値に共感する必要があります。
				</para>
				 <para>
					加えて、Debian に参加したいと思っている各候補者はプロジェクトの仕組みと時間がたてば間違いなく直面するであろう問題を解決する際に適切に相互協力する方法を知ることを期待されます。これらに関するすべての情報は新しいメンテナ向けのマニュアルと Debian 開発者リファレンスの中で大ざっぱに説明されています。応募管理者からの質問に答えるには、これらの文書を注意深く読むだけで十分です。回答が不十分な場合、候補者はその旨通知されます。候補者は再試験を受ける前に関連する文書を (もう一度) 読まなければいけません。既存の文書に質問に対する適切な回答が含まれなかった場合、候補者は Debian 内の実務経験を使うか他の Debian 開発者との議論を通じて回答を作成しても構いません。このメカニズムによって、候補者が Debian のすべての部分に参加する前に一部分だけに参加することが保証されます。これは慎重な方針です。この方針によって最終的に Debian プロジェクトに参加する候補者は永久的に広がるジグソーパズルにそのピースの 1 つとして組み込まれます。
				</para>
				 <indexterm>
					<primary><emphasis>Philosophy &amp; Procedures</emphasis></primary>
				</indexterm>
				 <para>
					この段階は新メンバー過程に参加する開発者の間で使われる用語の <emphasis>Philosophy &amp; Procedures</emphasis> (略して P&amp;P、哲学と手順) として知られています。
				</para>

			</section>
			 <section>
				<title>能力の確認</title>
				 <para>
					公式 Debian 開発者の受け入れ過程への出願は理に適ったものでなければいけません。プロジェクトメンバーになるには、候補者はプロジェクトメンバーの地位を得ることが合理的な要求であり、プロジェクトメンバーの地位を得ることで Debian の手助けに関する自分の作業が容易になることを示す必要があります。最も一般的な理由付けは Debian 開発者の地位が Debian パッケージのメンテナンスを簡単にするというものです。しかしこれは唯一の理由ではありません。特定のアーキテクチャへの移植に貢献するためにプロジェクトに参加している開発者もいれば、文書を改良したいと思ってプロジェクトに参加している開発者もいます。
				</para>
				 <para>
					この段階で、候補者は Debian プロジェクトの中で自分が何をしたいと思っているのか宣言し、その目的のために自分がこれまで何をしてきたか示す機会を与えられます。Debian は実用主義的なプロジェクトで、やっていることが言っていることと食い違っている場合、言うだけでは不十分です。一般的に言って、プロジェクト内で希望する役割がパッケージメンテナンスに関連する場合、候補となっているパッケージの最初のバージョンは必ず技術的な正当性を確認され、既存の Debian 開発者から選ばれた保証人によって Debian サーバにアップロードされることでしょう。
				</para>
				 <sidebar> <title><emphasis>COMMUNITY</emphasis> パッケージの支援</title>
				 <indexterm>
					<primary sortas="パッケージノシエン">パッケージの支援</primary>
				</indexterm>
				 <para>
					Debian 開発者は誰かによって用意されたパッケージを「支援」することが可能です。これは注意深く調査した後に Debian 開発者が公式の Debian リポジトリの中でパッケージを公開することを意味します。このメカニズムのおかげで、まだ新メンバー過程を通過していない外部の人も時折 Debian プロジェクトに貢献することが可能になります。同時に、Debian に含まれるすべてのパッケージは常に公式メンバーによって確認されていることが保証されます。
				</para>
				 </sidebar> <para>
					最後に、応募管理者は詳細な質問を投げかけて技術的な (パッケージング) スキルを確認します。間違った回答は許されませんが、回答時間に制限はありません。どんな文書を参考にしても構いませんし、最初の回答が不十分ならば何度も回答を作っても構いません。この段階は候補者を不当に冷遇するためのものではなく、新しい貢献者が共通に認識しておくべき最低限のわずかな知識を保証するためのものです。
				</para>
				 <indexterm>
					<primary><emphasis>Tasks &amp; Skills</emphasis></primary>
				</indexterm>
				 <para>
					この段階は応募管理者によって使われる隠語の <emphasis>Tasks &amp; Skills</emphasis> (略して T&amp;S、作業と技能) として知られています。
				</para>

			</section>
			 <section>
				<title>最後の承認</title>
				 <para>
					最後の段階で、DAM (<emphasis>Debian アカウントマネージャ</emphasis>) がすべてのプロセスを再確認します。DAM は応募管理者が集めた候補者に関するすべての情報を再確認し、Debian サーバにアカウントを作成するか否かについて決断を下します。追加的情報が必要な場合、アカウントの作成が遅れるかもしれません。応募管理者がプロセスに従って良い作業をしていれば、この段階で不合格になることはほとんどありません。しかし、不合格なる場合も時々あります。不合格は永久的なものではありません。候補者はしばらくの後に再試験を受けることが可能です。
				</para>
				 <para>
					DAM の決定は権威あるもので (ほとんど) 覆されません。このおかげで、DAM の役職に就く人はこれまでずっと批判され続けています。
				</para>

			</section>

		</section>

	</section>
</chapter>

