<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="apt" lang="ja-JP">
	<chapterinfo>
		 <keywordset>
			<keyword>apt</keyword>
			 <keyword>apt-get</keyword>
			 <keyword>apt-cache</keyword>
			 <keyword>aptitude</keyword>
			 <keyword>synaptic</keyword>
			 <keyword>sources.list</keyword>
			 <keyword>apt-cdrom</keyword>

		</keywordset>

	</chapterinfo>
	 <title>メンテナンスと更新、APT ツール</title>
	 <highlights> <para>
		Debian が管理者に人気がある理由は、ソフトウェアのインストールが簡単で、システム全体の更新が簡単だからです。この比類なき長所は、主として <emphasis>APT</emphasis> プログラムが担っており、Falcot Corp の管理者はこれについて熱心に学びました。
	</para>
	 </highlights> <para>
		<indexterm><primary>APT</primary></indexterm><indexterm><primary>Advanced Package Tool</primary></indexterm>APT は Advanced Package Tool の略称です。APT を「先進的」たらしめているものとは、パッケージの取り扱い方です。APT はパッケージを独立なものとして単純に評価するのではなく、パッケージ全体を考慮し、(依存関係に従って) 利用できて相性の良いパッケージを選び出すことで、実現できる最適なパッケージの組み合わせを作り出します。
	</para>
	 <sidebar> <title><emphasis>VOCABULARY</emphasis> パッケージソースとソースパッケージ</title>
	 <para>
		<emphasis>ソース</emphasis> という言葉を使うと意味が曖昧になる場合があります。ソースパッケージ — プログラムのソースコードを含んだパッケージ — をパッケージソース — パッケージが保存されているリポジトリ (ウェブサイト、FTP サーバ、CD-ROM、ローカルディレクトリなど) — と混同してはいけません。
	</para>
	 </sidebar> <para>
		APT には「パッケージソースのリスト」を与える必要があります。つまり <filename>/etc/apt/sources.list</filename> には Debian パッケージを公開しているさまざまなリポジトリ (つまり「ソース」) が記載されています。APT はそれぞれのソースで公開されているパッケージのリストを取り込みます。具体的に言うと、バイナリパッケージソースの場合は <filename>Packages.xz</filename> ファイルまたは別の方法で圧縮されたファイル (<filename>Packages.gz</filename> や <filename>Packages.bz2</filename>)、ソースパッケージソースの場合は <filename>Sources.xz</filename> ファイルまたは別の方法で圧縮されたファイルをダウンロードして、内容を解析して、パッケージのリストを取り込みます。これらのファイルの古いコピーが既にあるのなら、APT は差分だけをダウンロードしてファイルを更新することも可能です (補注<xref linkend="sidebar.apt-pdiff" />を参照してください)。
	</para>
	 <indexterm>
		<primary><filename>Packages.xz</filename></primary>
	</indexterm>
	 <indexterm>
		<primary><filename>Sources.xz</filename></primary>
	</indexterm>
	 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> <command>gzip</command>、<command>bzip2</command>、<command>LZMA</command>、<command>XZ</command> 圧縮</title>
	 <indexterm>
		<primary><command>gzip</command></primary>
	</indexterm>
	 <indexterm>
		<primary><command>bzip2</command></primary>
	</indexterm>
	 <indexterm>
		<primary><command>lzma</command></primary>
	</indexterm>
	 <indexterm>
		<primary><command>xz</command></primary>
	</indexterm>
	 <para>
		<filename>.gz</filename> 拡張子は <command>gzip</command> ユーティリティで圧縮されたファイルを意味しています。<command>gzip</command> は高速かつ効率的にファイルを圧縮する伝統的 Unix ユーティリティです。新しいツールを使えば圧縮効率は高くなるのですが、その代わりにファイルを圧縮および展開するために多くのリソース (計算時間とメモリ) が必要になります。新しいツールには、登場順に <command>bzip2</command> (<filename>.bz2</filename> 拡張子のファイルを生成)、<command>lzma</command> (<filename>.lzma</filename> ファイル)、<command>xz</command> (<filename>.xz</filename> ファイル) などがあります。
	</para>
	 </sidebar> <section id="sect.apt-sources.list">
		<title><filename>sources.list</filename> ファイルの内容</title>
		 <indexterm>
			<primary><filename>sources.list</filename></primary>
		</indexterm>
		 <indexterm>
			<primary>ソース</primary>
			<secondary>パッケージのソース</secondary>
		</indexterm>
		 <indexterm>
			<primary>パッケージ</primary>
			<secondary>パッケージのソース</secondary>
		</indexterm>
		 <indexterm>
			<primary><filename>/etc/apt/sources.list</filename></primary>
		</indexterm>
		 <section>
			<title>構文</title>
			 <para>
				<filename>/etc/apt/sources.list</filename> ファイルの有効な各行にはソースの説明が含まれ、ソースの説明は空白で分割された 3 つのフィールドからなります。
			</para>
			 <para>
				1 番目のフィールドはソースタイプです。
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						「<literal>deb</literal>」はバイナリパッケージ用です。
					</para>

				</listitem>
				 <listitem>
					<para>
						「<literal>deb-src</literal>」はソースパッケージ用です。
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				2 番目のフィールドはパッケージソースの基点 URL です (基点 URL は <filename>Packages.xz</filename> ファイル内のファイル名と組み合わせて使われます。さらに基点 URL は完全で有効な URL でなければいけません)。基点 URL には Debian アーカイブミラーまたはサードパーティが提供する他のパッケージアーカイブを指定できます。基点 URL はシステムのファイル階層構造の中にあるローカルソースを表す <literal>file://</literal>、ウェブサーバにあるソースを示す <literal>http://</literal>、FTP サーバにあるソースを示す <literal>ftp://</literal> で始めることも可能です。さらに基点 URL は CD-ROM/DVD-ROM/Blu-ray ディスクからインストールしたことを表す <literal>cdrom:</literal> で始めることも可能です。しかし基点 URL に <literal>cdrom:</literal> を設定する場合はそれほど多くありません。なぜなら、ネットワークを使ったインストール方法がずっと一般的だからです。
			</para>
			 <para>
				最後のフィールドの構文はリポジトリの構造に依存します。最も単純な場合、このフィールドにはソースから見たサブディレクトリ (末尾スラッシュ必須) を指定します (サブディレクトリがない、つまりパッケージが指定された URL の直下にあることを示す単純な「<filename>./</filename>」を指定する場合が多いです)。しかし最も多く見られるのは、リポジトリが Debian アーカイブミラーのように構造化されている、つまり複数のコンポーネントを持つ複数のディストリビューションを配布している場合です。この場合、そのマシンのディストリビューションの名前 (「コードネーム」(補注<xref linkend="sidebar.bruce-perens" />を参照してください) または対応する「スイート」つまり <literal>stable</literal>、<literal>testing</literal>、<literal>unstable</literal>) を指定し、その後に有効化するコンポーネント (またはセクション) を指定します (典型的な Debian アーカイブミラーでは <literal>main</literal>、<literal>contrib</literal>、<literal>non-free</literal> などを指定します)。
			</para>
			 <sidebar id="sidebar.sections"> <title><emphasis>VOCABULARY</emphasis> <literal>main</literal>、<literal>contrib</literal>、<literal>non-free</literal> アーカイブ</title>
			 <indexterm>
				<primary>セクション</primary>
				<secondary><literal>main</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary><literal>main</literal>、セクション</primary>
			</indexterm>
			 <indexterm>
				<primary>セクション</primary>
				<secondary><literal>contrib</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary><literal>contrib</literal>、セクション</primary>
			</indexterm>
			 <indexterm>
				<primary>セクション</primary>
				<secondary><literal>non-free</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary><literal>non-free</literal>、セクション</primary>
			</indexterm>
			 <indexterm>
				<primary>(リポジトリの) コンポーネント</primary>
			</indexterm>
			 <para>
				Debian では、ソフトウェアの作者が決めたライセンスを基準に、パッケージを 3 つのセクションに分類しています。<literal>main</literal> には Debian フリーソフトウェアガイドラインに完全に適合するすべてのパッケージが収録されています。
			</para>
			 <para>
				これに対して、<literal>non-free</literal> アーカイブには、Debian フリーソフトウェアガイドラインに適合しない (または完全に適合するわけではない) ものの制限なく配布することを許されたソフトウェアが収録されています。<literal>non-free</literal> アーカイブは公式には Debian の一部ではなく、これらのプログラムを必要としているユーザ向けのサービスです。しかし Debian は常にフリーソフトウェアを重点的に使うことを推奨します。<literal>non-free</literal> セクションの存在は Richard M. Stallman にとって無視できない問題であり、フリーソフトウェア財団は <literal>non-free</literal> セクションの存在を理由に Debian をユーザに推奨していません。
			</para>
			 <para>
				<literal>contrib</literal> (貢献) には、自由ではない要素を使わなければ動かないオープンソースソフトウェアが収録されています。自由ではない要素とは <literal>non-free</literal> セクションに収録されたソフトウェア、およびたとえばゲーム ROM、コンソールの BIOS などの自由ではないファイルを指します。また、<literal>contrib</literal> にはコンパイルの際にプロプライエタリな要素を必要とするフリーソフトウェアが収録されています。当初このようなフリーソフトウェアにはプロプライエタリな Java 環境を必要としていた OpenOffice.org オフィススイートなどがありました。
			</para>
			 </sidebar> <sidebar> <title><emphasis>TIP</emphasis> <filename>/etc/apt/sources.list.d/*.list</filename> ファイル</title>
			 <para>
				多数のパッケージソースを利用する場合、これらを複数のファイルに分割すると役に立つかもしれません。この場合、各パッケージソースを <filename>/etc/apt/sources.list.d/<replaceable>filename</replaceable>.list</filename> に保存します (補注<xref linkend="sidebar.directory.d" />を参照してください)。
			</para>
			 </sidebar> <indexterm>
				<primary><command>apt-cdrom</command></primary>
			</indexterm>
			 <para>
				<literal>cdrom</literal> エントリはあなたの持っている CD/DVD-ROM を表しています。他のエントリと異なり、CD-ROM は常に利用できるわけではありません。なぜなら、ディスクをドライブに挿入しなければいけませんし、一度に 1 つのディスクしか読めないからです。このような理由で、CD-ROM ソースは少し違う方法で管理されます。ソースを追加するには通常 <command>apt-cdrom</command> プログラムに <literal>add</literal> パラメータを付けて実行します。このようにプログラムを実行すると、ドライブにディスクを挿入するよう要求されます。<command>apt-cdrom</command> プログラムはディスクの内容を閲覧して <filename>Packages</filename> ファイルを探します。<filename>Packages</filename> ファイルは利用できるパッケージに関する APT のデータベースを更新するために利用されます (更新作業は <command>apt update</command> コマンドで実行されます)。そして、APT はディスクに含まれるパッケージが必要になったらディスクを挿入するように要求します。
			</para>

		</section>
		 <section>
			<title><emphasis role="distribution">安定版</emphasis> ユーザ用リポジトリ</title>
			 <para>
				下に示すのは、Debian の<emphasis role="distribution">安定版</emphasis>を動かしているシステムで標準的な <filename>sources.list</filename> です。
			</para>
			 <example id="example.stable-sources-list">
				<title>Debian 安定版ユーザ向けの <filename>/etc/apt/sources.list</filename> ファイル</title>
				 
<programlisting># セキュリティ更新
deb http://security.debian.org/ stretch/updates main contrib non-free
deb-src http://security.debian.org/ stretch/updates main contrib non-free

## Debian アーカイブミラー

# ベースリポジトリ
deb http://deb.debian.org/debian stretch main contrib non-free
deb-src http://deb.debian.org/debian stretch main contrib non-free

# 安定版更新
deb http://deb.debian.org/debian stretch-updates main contrib non-free
deb-src http://deb.debian.org/debian stretch-updates main contrib non-free

# 安定版バックポート
deb http://deb.debian.org/debian stretch-backports main contrib non-free
deb-src http://deb.debian.org/debian stretch-backports main contrib non-free</programlisting>

			</example>
			 <para>
				このファイルは Debian <emphasis role="distribution">Stretch</emphasis> (これを書いている時点の <emphasis role="distribution">安定版</emphasis>) に関連するパッケージの全ソースをリストしています。ここでディストリビューション名に「stretch」を使い、対応する「stable」(<literal>stable</literal>、<literal>stable-updates</literal>、<literal>stable-backports</literal>) という別名を使わなかったのには理由があります。それは、新しい安定版が公開されることにより自動的にディストリビューションのバージョンが変わることを避けるためです。
			</para>
			 <para>
				多くのパッケージは「ベースリポジトリ」から取得されます。「ベースリポジトリ」にはすべてのパッケージが収録されていますが、<emphasis role="distribution">安定版</emphasis>の「ベースリポジトリ」はめったに更新されません (約 2 カ月に 1 度の「ポイントリリース」で更新されます)。「ベースリポジトリ」以外のリポジトリには一部のパッケージだけが収録されており (すべてパッケージが収録されているわけではありません)、「ベースリポジトリ」以外のリポジトリに更新 (「ベースリポジトリ」に含まれるパッケージの新しいバージョン) が収録されていた場合、APT は更新をインストールします。以下の節ではそれぞれのリポジトリの目的とリポジトリの運営ルールについて説明します。
			</para>
			 <para>
				あるパッケージの希望したバージョンが複数のリポジトリから取得できる場合、<filename>sources.list</filename> ファイルにリストされた最初のリポジトリから取得されることに注意してください。この理由から、非公式ソースは通常最後に追加されます。
			</para>
			 <para>
				ちなみに、この節で<emphasis role="distribution">安定版</emphasis>に関して述べていることのほとんどは<emphasis role="distribution">旧安定版</emphasis>に関しても同じことが言えます。なぜなら、<emphasis role="distribution">旧安定版</emphasis>とは並行してメンテナンスされている古い<emphasis role="distribution">安定版</emphasis>に過ぎないからです。
			</para>
			 <section id="sect.security-updates">
				<title>セキュリティ更新</title>
				 <indexterm>
					<primary><literal>security.debian.org</literal></primary>
				</indexterm>
				 <indexterm>
					<primary>セキュリティ更新</primary>
				</indexterm>
				 <indexterm>
					<primary>更新</primary>
					<secondary>セキュリティ更新</secondary>
				</indexterm>
				 <para>
					セキュリティ更新リポジトリは Debian アーカイブミラーの通常のネットワーク上ではなく、<literal>security.debian.org</literal> (<link linkend="dsa-team">Debian システム管理者</link>が管理する少数のマシン) でホストされています。セキュリティ更新アーカイブには、<emphasis role="distribution">安定版</emphasis>ディストリビューション用の (Debian セキュリティチームまたはパッケージメンテナが用意した) セキュリティ更新が含まれています。
				</para>
				 <para>
					<literal>security.debian.org</literal> は<emphasis role="distribution">テスト版</emphasis>用のセキュリティ更新もホストしていますが、実際にこれがホストされることはめったにありません。なぜなら、<emphasis role="distribution">テスト版</emphasis>に対するセキュリティ更新は<emphasis role="distribution">不安定版</emphasis>対する通常の更新手順を通じて行われることが多いからです。
				</para>

			</section>
			 <section id="sect.stable-updates">
				<title>安定版更新</title>
				 <indexterm>
					<primary>安定版更新</primary>
				</indexterm>
				 <indexterm>
					<primary><literal>stable-updates</literal></primary>
				</indexterm>
				 <indexterm>
					<primary>更新</primary>
					<secondary>安定版更新</secondary>
				</indexterm>
				 <para>
					安定版更新リポジトリにはセキュリティに影響をおよぼすパッケージは含まれませんが、その重要性により次回の安定版ポイントリリースよりも前にユーザに提供するだけの価値があるとみなされた更新が含まれています。
				</para>
				 <para>
					通常、安定版更新リポジトリにはリリースの前に修正できなかったり後続の更新によって生まれた重要なバグの修正が含まれています。さらに緊急度に応じて、時間とともに進化させる必要のあるパッケージの更新を含めることも可能です。これに該当するのはたとえば <emphasis role="pkg">spamassassin</emphasis> のスパム検出ルール、<emphasis role="pkg">clamav</emphasis> のウイルスデータベース、すべてのタイムゾーンの夏時間ルール (<emphasis role="pkg">tzdata</emphasis>) などがあります。
				</para>
				 <para>
					実質的には、安定版更新リポジトリは内容を <literal>proposed-updates</literal> リポジトリからの一部抜粋したものです。安定版更新リポジトリの内容は安定版リリースマネージャが注意深く選んでいます。
				</para>

			</section>
			 <section id="sect.proposed-updates">
				<title>提案された更新</title>
				 <indexterm>
					<primary><literal>proposed-updates</literal></primary>
				</indexterm>
				 <indexterm>
					<primary><literal>stable-proposed-updates</literal></primary>
				</indexterm>
				 <para>
					<emphasis role="distribution">安定版</emphasis> ディストリビューションはひとたび公開されたら、約 2 カ月に 1 回だけ更新されます。<literal>proposed-updates</literal> リポジトリとは (安定版リリースマネージャの指揮の下で) 今後予定されている更新を準備するためのリポジトリです。
				</para>
				 <para>
					前の節で説明したセキュリティ更新と安定版更新は、常に <literal>proposed-updates</literal> リポジトリに加えられますが、更新は他にもあります。なぜなら、パッケージメンテナは素早くリリースすることもないけれど重要と思われるバグを修正する機会があるからです。
				</para>
				 <para>
					正式公開前に更新をテストするためには <literal>proposed-updates</literal> リポジトリを使います。以下で引用した例は <literal>stretch-proposed-updates</literal> という別名を使っています。このような、より明白でより一貫性のある別名を使っている理由は、(<emphasis role="distribution">旧安定版</emphasis> に対する更新用のリポジトリとして) <literal>jessie-proposed-updates</literal> という別名が存在するからです。
				</para>
				 
<programlisting>deb http://ftp.debian.org/debian stretch-proposed-updates main contrib non-free</programlisting>

			</section>
			 <section id="sect.backports">
				<title>安定版バックポート</title>
				 <indexterm>
					<primary><literal>stable-backports</literal></primary>
				</indexterm>
				 <indexterm>
					<primary>バックポート</primary>
				</indexterm>
				 <indexterm>
					<primary>更新</primary>
					<secondary>安定版バックポート</secondary>
				</indexterm>
				 <para>
					<literal>stable-backports</literal> リポジトリは「パッケージのバックポート」をホストしています。「パッケージのバックポート」という用語は古いディストリビューション (通常は<emphasis role="distribution">安定版</emphasis>) 用に再コンパイルした最新ソフトウェアのパッケージを指す言葉です。
				</para>
				 <para>
					<emphasis role="distribution">安定版</emphasis>ディストリビューションの公開から少し時間が経っただけで、多くのソフトウェアプロジェクトが新バージョンをリリースします。しかしながら、ソフトウェアの新バージョンは現在の<emphasis role="distribution">安定版</emphasis>に組み込まれません (<emphasis role="distribution">安定版</emphasis>に組み込まれるのはセキュリティ問題などの最も重要な問題に対する修正に限られています)。安定性の観点から<emphasis role="distribution">テスト版</emphasis>や<emphasis role="distribution">不安定版</emphasis>ディストリビューションを使うのは危険過ぎると考える安定版のユーザ向けに、パッケージメンテナはしばしば<emphasis role="distribution">安定版</emphasis>向けに最新のソフトウェアアプリケーションを再コンパイルして提供することがあります。バックポートされたパッケージを使うことにより、安定版のユーザはシステムの不安定性をバックポートされたパッケージに起因する不安定性だけに制限することが可能です。<ulink type="block" url="http://backports.debian.org" />
				</para>
				 <indexterm>
					<primary><literal>backports.debian.org</literal></primary>
				</indexterm>
				 <para>
					<literal>stable-backports</literal> に収録されているバックポートは常に<emphasis role="distribution">テスト版</emphasis>で利用できるパッケージから作成されます。このおかげで、次の Debian 安定版リリースが利用できるようになったら、すべてのインストール済みバックポートパッケージはそれに対応する安定版から提供されたパッケージにアップグレードできることが保証されています。
				</para>
				 <para>
					<literal>stable-backports</literal> リポジトリはパッケージの新しいバージョンを提供しますが、APT は以下に示すように明確な指示を出さない限り (または以前に同じバックポートの古いバージョンをインストールしていない限り) バックポートパッケージをインストールしません。
				</para>
				 
<screen><computeroutput>$ </computeroutput><userinput>sudo apt-get install <replaceable>package</replaceable>/stretch-backports
</userinput><computeroutput>$ </computeroutput><userinput>sudo apt-get install -t stretch-backports <replaceable>package</replaceable>
</userinput></screen>

			</section>

		</section>
		 <section>
			<title><emphasis role="distribution">テスト版</emphasis>/<emphasis role="distribution">不安定版</emphasis>ユーザ向けリポジトリ</title>
			 <para>
				以下に示すのは、Debian の<emphasis role="distribution">テスト版</emphasis>や<emphasis role="distribution">不安定版</emphasis>を動かしているシステムで標準的な <filename>sources.list</filename> です。
			</para>
			 <example id="example.testing-sources-list">
				<title>Debian <emphasis role="distribution">テスト版</emphasis>/<emphasis role="distribution">不安定版</emphasis>ユーザ向けの <filename>/etc/apt/sources.list</filename> ファイル</title>
				 
<programlisting>
# 不安定版
deb http://deb.debian.org/debian unstable main contrib non-free
deb-src http://deb.debian.org/debian unstable main contrib non-free

# テスト版
deb http://deb.debian.org/debian testing main contrib non-free
deb-src http://deb.debian.org/debian testing main contrib non-free

# 安定版
deb http://deb.debian.org/debian stable main contrib non-free
deb-src http://deb.debian.org/debian stable main contrib non-free

# セキュリティ更新
deb http://security.debian.org/ stable/updates main contrib non-free
deb http://security.debian.org/ testing/updates main contrib non-free
deb-src http://security.debian.org/ stable/updates main contrib non-free
deb-src http://security.debian.org/ testing/updates main contrib non-free</programlisting>

			</example>
			 <para>
				この <filename>sources.list</filename> ファイルを使う場合、APT は<emphasis role="distribution">不安定版</emphasis>からパッケージをインストールします。これを望まない場合、<literal>APT::Default-Release</literal> 設定を使って (<xref linkend="sect.apt-upgrade" />をご覧ください) APT に他のディストリビューションから (今回の場合<emphasis role="distribution">テスト版</emphasis>から) パッケージを取得するよう伝えます。
			</para>
			 <para>
				ここで指定するリポジトリは 1 種類のバージョンに対するリポジトリだけでも十分なのに、3 種類のバージョンに対するリポジトリを含めているのには正当な理由があります。<emphasis role="distribution">テスト版</emphasis>のユーザなら、あるパッケージの<emphasis role="distribution">テスト版</emphasis>に含まれるバージョンが厄介なバグの影響を受けている場合、そのパッケージを<emphasis role="distribution">不安定版</emphasis>に含まれる修正済みバージョンにアップグレードできればうれしいでしょう。逆に、<emphasis role="distribution">不安定版</emphasis>のユーザなら、あるパッケージの<emphasis role="distribution">不安定版</emphasis>に含まれるバージョンに前のバージョンになかった不具合がある場合、そのパッケージを<emphasis role="distribution">テスト版</emphasis>に含まれる (おそらく動く) バージョンにダウングレードすることも可能です。
			</para>
			 <para>
				ここに<emphasis role="distribution">安定版</emphasis>用のリポジトリが含まれている点については異論があるかもしれませんが、こうすることで開発版から削除されたパッケージを入手できるようになります。また、最新安定版リリース以降に変更さていないパッケージの最新更新を手に入れることも保証されます。
			</para>
			 <section>
				<title><emphasis role="distribution">実験版</emphasis>リポジトリ</title>
				 <indexterm>
					<primary><emphasis role="distribution">実験版</emphasis></primary>
				</indexterm>
				 <para>
					<emphasis role="distribution">実験版</emphasis>パッケージのアーカイブはすべての Debian アーカイブミラーに存在し、品質基準を満たしていないためにまだ<emphasis role="distribution">不安定版</emphasis>に収録されていないパッケージを含んでいます。すなわち、<emphasis role="distribution">実験版</emphasis>に含まれるパッケージはソフトウェアの開発版バージョンか先行バージョン (アルファ、ベータ、リリース候補など) であることが多いです。パッケージに対する一連の修正によって問題が引き起こされる可能性がある場合も、パッケージは<emphasis role="distribution">実験版</emphasis>に送られます。メンテナは、重要な問題を取り扱う能力を持つ熟練ユーザの助けを借りて、その問題を明らかにしようとします。この最初のステージの後、パッケージは<emphasis role="distribution">不安定版</emphasis>に移動されます。<emphasis role="distribution">不安定版</emphasis>に移動されたパッケージはより多くのユーザに配布され、より詳細にテストされます。
				</para>
				 <para>
					<emphasis role="distribution">実験版</emphasis>リポジトリを使うのは通常、システムを破壊したり修復することを気にしないユーザです。<emphasis role="distribution">実験版</emphasis>リポジトリを使うユーザは必要に応じて試してみたいか使ってみたいと思ったパッケージを<emphasis role="distribution">実験版</emphasis>からシステムに取り込むことができます。これはまさに Debian が<emphasis role="distribution">実験版</emphasis>を活用する時の方法です。なぜなら、<emphasis role="distribution">実験版</emphasis>リポジトリを APT の <filename>sources.list</filename> ファイルに追加しても、実験版パッケージを体系的に利用することにはならないからです。<emphasis role="distribution">実験版</emphasis>リポジトリを追加するには以下を <filename>sources.list</filename> ファイルに追加します。
				</para>
				 <informalexample> 
<programlisting>deb http://deb.debian.org/debian experimental main contrib non-free</programlisting>
				 </informalexample>
			</section>

		</section>
		 <section>
			<title>代替ミラーの利用</title>
			 <indexterm>
				<primary><literal>deb.debian.org</literal></primary>
			</indexterm>
			 <para>
				本章で載せた <filename>sources.list</filename> の例は <literal>deb.debian.og</literal> でホストされているパッケージリポジトリを使っています。これらの URL を使うことで、ユーザは自分に近いサーバへ転送されます。転送先のサーバはコンテンツデリバリネットワーク (<acronym>CDN</acronym>) によって管理されています。コンテンツデリバリネットワークの主な役割は世界中にファイルのコピーを複数保存し、それらをユーザに可能な限り素早く配送することです。Debian に協力している CDN 会社は Debian パートナーであり、Debian に自社のサービスを無償提供しています。Debian はこれらのサーバを 1 つも管理していませんが、すべてのアーカイブは GPG 署名で保護されているために、この点は問題ではありません。
			</para>
			 <indexterm>
				<primary>ミラーリスト</primary>
			</indexterm>
			 <indexterm>
				<primary>ミラーのリスト</primary>
			</indexterm>
			 <para>
				あなたがこだわるタイプで <literal>deb.debian.org</literal> の性能に満足できないなら、以下の公式ミラーリストから更に良いミラーを探してみてください: <ulink type="block" url="https://www.debian.org/mirror/list" />
			</para>
			 <para>
				どのミラーを選べばよいかわからないなら、公式のミラーリストは役に立ちません。そんな人のために、Debian は <literal>ftp.<replaceable>country-code</replaceable>.debian.org</literal> という (例: USA 用に <literal>ftp.us.debian.org</literal>、フランス用に <literal>ftp.fr.debian.org</literal> など) DNS エントリを整備しています。数多くの国に対するエントリが用意されていますし、その国の中で最良のミラー (複数個の場合もあります) に転送されます。
			</para>
			 <indexterm>
				<primary><literal>httpredir.debian.org</literal></primary>
			</indexterm>
			 <para>
				<literal>deb.debian.org</literal> の代替として、過去に <literal>httpredir.debian.org</literal> がありました。このサービスはユーザに近いミラーを見極め (主に GeoIP を使って公式ミラーの中から選び)、APT リクエストをそのミラーに転送するものでした。このサービスは信頼性の懸念が原因ですでに停止しており、<literal>httpredir.debian.org</literal> では <literal>deb.debian.org</literal> と同じ CDN に基づくサービスが提供されています。
			</para>

		</section>
		 <section>
			<title>非公式リソース、<literal>mentors.debian.net</literal></title>
			 <indexterm>
				<primary><literal>mentors.debian.net</literal></primary>
			</indexterm>
			 <para>
				Debian パッケージの非公式ソースはたくさんあります。非公式ソースはソフトウェアを再コンパイルした熟練ユーザ (Ubuntu は Personal Package Archive サービスを提供することで熟練ユーザの提供する非公式ソースを普及させました)、自分の創作物を誰でも利用できる状態にするプログラマ、自分のパッケージの先行バージョンをオンラインで提供する Debian 開発者によって提供されています。
			</para>
			 <para>
				<literal>mentors.debian.net</literal> サイトは興味深いものです (ただしこのサイトが配布しているのはソースパッケージだけです)。なぜなら <literal>mentors.debian.net</literal> には、パッケージの組み込み過程を経ずに、公式 Debian 開発者の候補者や Debian パッケージを作りたいと望むボランティアが作成したパッケージが集められているからです。<literal>mentors.debian.net</literal> に集められたパッケージは、品質保証のないまま、利用できるようになっています。このため、起源と整合性を必ず確認し、稼働中のシステムでパッケージを使う前にパッケージを必ずテストしてください。
			</para>
			 <sidebar> <title><emphasis>COMMUNITY</emphasis> <literal>debian.net</literal> サイト</title>
			 <indexterm>
				<primary><emphasis>debian.net</emphasis></primary>
			</indexterm>
			 <para>
				<emphasis>debian.net</emphasis> ドメインは Debian プロジェクトの公式所有物ではありません。それぞれの Debian 開発者は自分用に <emphasis>debian.net</emphasis> ドメイン名を使うことが許されています。そのようなウェブサイトには、Debian プロジェクトに所属せず Debian 開発者が設けたマシンでホストされている非公式サービス (個人サイト) や今まさに <emphasis>debian.org</emphasis> に移動されようとしているサービスの試作品が含まれています。一部のサービスの試作品が <emphasis>debian.net</emphasis> に残されている理由は 2 つあります。すなわち、誰もそのサービスを公式化する (<emphasis>debian.org</emphasis> ドメインでホストしてメンテナンスを保証する) のに必要な作業を行わなかったか、そのサービスを公式化するのはあまりに議論の余地がありすぎるかのどちらかです。
			</para>
			 </sidebar> <para>
				あるパッケージをインストールすることは、パッケージの作者に root 権限を与えることを意味しています。なぜなら、パッケージ作者は root 権限で実行される初期化スクリプトの内容を決定するからです。公式 Debian パッケージは、パッケージの起源と整合性が確認できるように、選出され審査を受けたボランティアとパッケージの内容の責任を請け負うことができるボランティアによって作成されます。
			</para>
			 <para>
				一般に、出自が不明で公式 Debian サーバの 1 つでホストされていないパッケージには警戒してください。つまり、作者の信頼度を評価し、パッケージの整合性を確認してください。<ulink type="block" url="http://mentors.debian.net/" />
			</para>
			 <sidebar id="sidebar.snapshot.debian.org"> <title><emphasis>GOING FURTHER</emphasis> パッケージの古いバージョン、<literal>snapshot.debian.org</literal></title>
			 <indexterm>
				<primary><literal>snapshot.debian.org</literal></primary>
			</indexterm>
			 <para>
				2010 年 4 月に登場した <literal>snapshot.debian.org</literal> サービスにより、「時間を逆行」したり、パッケージの古いバージョンを見つけることが可能になりました。<literal>snapshot.debian.org</literal> サービスは、たとえばパッケージのどのバージョンで前のバージョンになかった不具合が発生したかを特定するために、より正確に言えば、不具合が修正されるまでの期間中に古いバージョンを利用するために、使えます。
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>Debian パッケージのキャッシュプロキシ</title>
			 <indexterm>
				<primary>プロキシキャッシュ</primary>
			</indexterm>
			 <indexterm>
				<primary>キャッシュ、プロキシ</primary>
			</indexterm>
			 <para>
				マシンのネットワーク全体で、同じ更新済みパッケージをダウンロードするために同じリモートサーバを使うよう設定されている場合、管理者はネットワークのローカルキャッシュとして振る舞う中間プロキシを用意するのは有益なことであると知っています (補注<xref linkend="sidebar.cache" />を参照してください)。
			</para>
			 <para>
				APT が「標準的な」プロキシを使うように設定することも可能です (APT 側は<xref linkend="sect.apt-config" />、プロキシ側は<xref linkend="sect.http-ftp-proxy" />を参照してください)。しかしながら、Debian にはこの問題に対するより優れた選択肢が準備されています。この節で取り上げる専用ソフトウェアは単純なプロキシキャッシュよりも賢いです。なぜなら、このソフトウェアは APT リポジトリの特定の構造を頼りにできるからです (たとえば、個々のファイルが時代遅れになるタイミングがわかるので、ファイルを保存しておく時間を調整できます)。
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">apt-cacher</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis role="pkg">apt-cacher-ng</emphasis></primary>
			</indexterm>
			 <para>
				<emphasis role="pkg">apt-cacher</emphasis> と <emphasis role="pkg">apt-cacher-ng</emphasis> は普通のプロキシキャッシュサーバのように振る舞います。APT の <filename>sources.list</filename> を変更する必要はありませんが、APT の外部リクエスト用のプロキシ設定をこれらのプロキシキャッシュサーバに変更する必要があります。
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">approx</emphasis></primary>
			</indexterm>
			 <para>
				これに対して、<emphasis role="pkg">approx</emphasis> は基点 URL の下にある複数のリモートリポジトリを「ミラー」する HTTP サーバのように振る舞います。最上位ディレクトリの名前とリモート側リポジトリの基点 URL の対応関係は <filename>/etc/approx/approx.conf</filename> に保存されています。
			</para>
			 
<programlisting>
# &lt;最上位ディレクトリの名前&gt; &lt;リモート側リポジトリの基点 URL&gt;
debian   http://deb.debian.org/debian
security http://security.debian.org</programlisting>
			 <para>
				<emphasis role="pkg">approx</emphasis> のデフォルト設定では、systemd ソケット経由でポート 9999 番を使います。ユーザは基点 URL が approx サーバを指すように <filename>sources.list</filename> ファイルを書き換えなければいけません。
			</para>
			 
<programlisting># ローカル approx サーバを利用する設定を施した sources.list の見本
deb http://apt.falcot.com:9999/security stretch/updates main contrib non-free
deb http://apt.falcot.com:9999/debian stretch main contrib non-free
</programlisting>

		</section>

	</section>
	 <section id="sect.apt-get">
		<title><command>aptitude</command>、<command>apt-get</command>、<command>apt</command> コマンド</title>
		 <indexterm>
			<primary><command>apt</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>apt-get</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>aptitude</command></primary>
		</indexterm>
		 <para>
			APT は巨大なプロジェクトで、当初の予定ではグラフィカルインターフェースを含んでいました。APT はライブラリに基づいており、そのライブラリにはコアアプリケーションが含まれています。<command>apt-get</command> は最初のコマンドラインベースフロントエンドで、APT プロジェクト内で開発されました。<command>apt</command> は APT から提供されているもう一つのコマンドラインベースフロントエンドで、<command>apt-get</command> の持っていた設計上のミスを克服しています。
		</para>
		 <para>
			どちらのツールも同じライブラリから構築されているため、非常によく似ています。しかしながら、<command>apt</command> のデフォルトの挙動は対話的利用の観点から改善され、多くのユーザの予想通りに動作します。APT の開発者は更にこれを改善するために <command>apt</command> のユーザ向けインターフェイスを変更する権利を保有しています。逆に、<command>apt-get</command> のユーザ向けインターフェイスは明確に定義されており後方互換性が無くなることはないでしょう。このため、スクリプトでパッケージをインストールする場合には <command>apt-get</command> を使うと良いでしょう。
		</para>
		 <para>
			APT の数多くのグラフィカルインターフェースは外部プロジェクトとして生まれました。たとえば <command>synaptic</command>、<command>aptitude</command> (テキストとグラフィカルモードインターフェースの両方があり、グラフィカルモードインターフェースはまだ完成していません)、<command>wajig</command> などが生まれました。最も推奨されるインターフェースは <command>apt</command> で、この節では <command>apt</command> を例に使います。<command>apt</command> のコマンドライン構文と <command>apt-get</command> や <command>aptitude</command> のコマンドライン構文はよく似ていることに注意してください。<command>apt</command>、<command>apt-get</command>、<command>aptitude</command> の間に大きな違いがある場合は、その違いを詳しく述べます。
		</para>
		 <section>
			<title>初期設定</title>
			 <para>
				APT を使う作業では、事前に利用できるパッケージのリストを更新しなければいけません。パッケージリストを更新するには <command>apt update</command> を使ってください。ネットワークのスピードに依存しますが、パッケージリストの更新操作には少し時間がかかります。なぜなら、<filename>Packages</filename>/<filename>Sources</filename>/<filename>Translation-<replaceable>language-code</replaceable></filename> などのファイルをダウンロードするからです。ここでダウンロードされるファイルは Debian の開発が進むにつれて徐々に大きくなります (<literal>main</literal> セクションの場合、データのサイズは少なく見積もっても 10 MB です)。もちろん CD-ROM セットからインストールする場合はダウンロードに時間は必要ありません。この場合、パッケージリストの更新操作はとても速くなります。
			</para>
			 <indexterm>
				<primary><command>apt update</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>apt-get update</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>aptitude update</command></primary>
			</indexterm>

		</section>
		 <section>
			<title>インストールと削除</title>
			 <indexterm>
				<primary>パッケージ</primary>
				<secondary>インストール</secondary>
			</indexterm>
			 <indexterm>
				<primary>パッケージ</primary>
				<secondary>削除</secondary>
			</indexterm>
			 <indexterm>
				<primary>インストール</primary>
				<secondary>パッケージのインストール</secondary>
			</indexterm>
			 <indexterm>
				<primary>パッケージの削除</primary>
			</indexterm>
			 <para>
				APT を使うと、システムからパッケージを追加したり削除したりできます。追加は <command>apt install <replaceable>package</replaceable></command>、削除は <command>apt remove <replaceable>package</replaceable></command> のようにして行います。どちらの場合も APT は自動的に、追加するパッケージの動作に必要なパッケージをインストールし、削除対象のパッケージの削除後に不要になるパッケージを削除します。<command>apt purge <replaceable>package</replaceable></command> コマンドを実行すれば完全にアンインストール、つまり設定ファイルも削除します。
			</para>
			 <indexterm>
				<primary><command>apt install</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>apt remove</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>apt purge</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>apt-get install</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>apt-get remove</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>apt-get purge</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>aptitude install</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>aptitude remove</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>aptitude purge</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>TIP</emphasis> 複数のマシンに同じ構成でパッケージをインストール</title>
			 <para>
				複数のコンピュータに同じパッケージ群を体系的にインストールすると役に立つ場合があります。これは簡単にできます。
			</para>
			 <para>
				最初に、以下の操作でコンピュータにインストールされたパッケージのリストを取得し、これをパッケージ構成の「ひな形」とします。
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>dpkg --get-selections &gt;pkg-list</userinput></screen>
			 <para>
				<filename>pkg-list</filename> ファイルはインストールされたパッケージのリストです。次に、パッケージ群をインストールしたいコンピュータに <filename>pkg-list</filename> ファイルを移動し、以下のコマンドを実行します。
			</para>
			 
<screen>## dpkg が把握しているパッケージのデータベースを更新
# <userinput>avail=`mktemp`</userinput>
# <userinput>apt-cache dumpavail &gt; "$avail"</userinput>
# <userinput>dpkg --merge-avail "$avail"</userinput>
# <userinput>rm -f "$avail"</userinput>
## dpkg のパッケージ選択リストを更新する
# <userinput>dpkg --set-selections &lt; pkg-list</userinput>
## apt-get を使ってパッケージ選択リストに基づいてインストールを行う
# <userinput>apt-get dselect-upgrade</userinput></screen>
			 <para>
				最初のコマンド群で dpkg データベースで利用できるパッケージのリストを記録し、<command>dpkg --set-selections</command> でインストールしたいパッケージ群を選択し、<command>apt-get</command> でインストール作業を実行します。<command>aptitude</command> には dselect-upgrade が用意されていないので、最後のインストール作業を行うことは不可能です。
			</para>
			 </sidebar> <sidebar> <title><emphasis>TIP</emphasis> 同時に削除とインストールを行う</title>
			 <para>
				<command>apt</command> (および <command>apt-get</command> や <command>aptitude</command>) を使ってパッケージのインストールと削除を同時に命令するには、パッケージ名の末尾にサフィックスを付け加えます。<command>apt install</command> コマンドでパッケージ名の末尾に「<literal>-</literal>」を付けると削除になります。<command>apt remove</command> コマンドでパッケージ名の末尾に「<literal>+</literal>」を付けるとインストールになります。
			</para>
			 <para>
				次の例は <replaceable>package1</replaceable> をインストール、<replaceable>package2</replaceable> を削除する 2 種類の方法です。
			</para>
			 
<screen># <userinput>apt install <replaceable>package1</replaceable> <replaceable>package2-</replaceable></userinput>
[...]
# <userinput>apt remove <replaceable>package1+</replaceable> <replaceable>package2</replaceable></userinput>
[...]</screen>
			 <para>
				これはたとえば <literal>Recommends</literal> に指定されているなどの原因でインストールされてしまうパッケージをインストールさせないようにするために使うことも可能です。一般に、依存関係解決ソフトウェアは代替解決策を探すための手掛かりとしてこの情報を使います。
			</para>
			 </sidebar> <sidebar> <title><emphasis>TIP</emphasis> <command>apt --reinstall</command> と <command>aptitude reinstall</command></title>
			 <indexterm>
				<primary>再インストール</primary>
			</indexterm>
			 <para>
				パッケージから提供されたファイルを削除したり変更したりした場合、システムが被害を受けることがあります。パッケージから提供されたファイルを再取得する最も簡単な方法は、対象のファイルが含まれるパッケージを再インストールすることです。残念なことに、パッケージングシステムはパッケージが既にインストール済みで、再インストールできないことを丁寧に教えてくれます。インストール済みパッケージを再インストールするには、<command>apt</command> および <command>apt-get</command> コマンドの <literal>--reinstall</literal> オプションを使います。以下は、既にインストール済みの <emphasis role="pkg">postfix</emphasis> を再インストールするコマンドです。
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>apt --reinstall install postfix</userinput></screen>
			 <para>
				<command>aptitude</command> のコマンドラインは少し違いますが、<command>aptitude reinstall postfix</command> でインストール済みパッケージを再インストールできます。
			</para>
			 <para>
				<command>dpkg</command> を使えばインストール済みパッケージの再インストールを拒否されることはありませんが、管理者が直接 <command>dpkg</command> を使うことはまれです。
			</para>
			 <para>
				注意してください! 攻撃を受けている最中に、変更されたパッケージを修復する目的で <command>apt --reinstall</command> を使っても、システムを以前の状態に回復することは絶対に不可能でしょう。不正侵入を受けたシステムでパッケージを修復するために必要な手順の詳細は<xref linkend="sect.dealing-with-compromised-machine" />を参照してください。
			</para>
			 </sidebar> <para>
				<filename>sources.list</filename> に複数のディストリビューション用リポジトリが含まれる場合、パッケージのバージョンを指定してインストールすることも可能です。特定のバージョンを指定するには、<command>apt install <replaceable>package</replaceable>=<replaceable>version</replaceable></command> を使いますが、<command>apt install <replaceable>package</replaceable>/<replaceable>distribution</replaceable></command> のようにして、ディストリビューション (<emphasis role="distribution">安定版</emphasis>、<emphasis role="distribution">テスト版</emphasis>、<emphasis role="distribution">不安定版</emphasis>) を指定するやり方のほうが通常好まれます。<filename>sources.list</filename> ファイルに書かれたどこかのソースから古いバージョンをまだ入手できるなら、このコマンドを使ってパッケージを古いバージョンに戻すことも可能です (これはたとえば古いバージョンがうまく動作すると知っている場合などに有効です)。古いバージョンを入手する別の方法として <literal>snapshot.debian.org</literal> アーカイブを使うことも可能です (補注<xref linkend="sidebar.snapshot.debian.org" />を参照してください)。
			</para>
			 <example>
				<title><emphasis role="pkg">spamassassin</emphasis> の<emphasis role="distribution">不安定版</emphasis>バージョンをインストール</title>
				 
<screen><computeroutput># </computeroutput><userinput>apt install spamassassin/unstable</userinput></screen>

			</example>
			 <para>
				インストールするパッケージが単純な <filename>.deb</filename> ファイルの形になっており、関連するパッケージリポジトリがないなら、APT を使って依存関係を満足させつつパッケージを簡単にインストールできます (設定済みのリポジトリを使って依存関係を満足できる場合に限ります): <command>apt install ./<replaceable>path-to-the-package.deb</replaceable></command>。ここで先頭に付けた <literal>./</literal> は重要です。こうすることで引数がファイル名であり、リポジトリから利用できるパッケージの名前ではないことを明確にできるからです。
			</para>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> <filename>.deb</filename> ファイルのキャッシュ</title>
			 <para>
				APT はダウンロード済み <filename>.deb</filename> ファイルのコピーを <filename>/var/cache/apt/archives/</filename> ディレクトリに保存します。頻繁に更新を行う場合、<filename>/var/cache/apt/archives/</filename> ディレクトリにはパッケージの複数のバージョンが保存され多くのディスク領域が消費されるため、日常的にこのディレクトリの内容を調べたほうがよいでしょう。<filename>/var/cache/apt/archives/</filename> ディレクトリの内容を管理するために 2 つのコマンドが用意されています。たとえば <command>apt-get clean</command> はこのディレクトリを完全に空にします。一方で <command>apt-get autoclean</command> は (Debian アーカイブミラーから削除されたために) もはやダウンロードできない、明らかに無駄なパッケージだけを削除します (設定パラメータ <literal>APT::Clean-Installed</literal> を使って現在インストール済みパッケージの <filename>.deb</filename> は削除しないようにすることも可能です)。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.apt-upgrade">
			<title>システムのアップグレード</title>
			 <indexterm>
				<primary>アップグレード</primary>
				<secondary>システムのアップグレード</secondary>
			</indexterm>
			 <indexterm>
				<primary><command>apt upgrade</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>apt-get upgrade</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>aptitude safe-upgrade</command></primary>
			</indexterm>
			 <para>
				最新のセキュリティ更新を入手するために、定期的にアップグレードを行うことをお勧めします。アップグレードを行うには (もちろん <command>apt update</command> を実行した後に) <command>apt upgrade</command>、<command>apt-get upgrade</command>、<command>aptitude safe-upgrade</command> を実行してください。これらのコマンドは他のパッケージを削除せずにアップグレードできるインストール済みパッケージだけを探します。言い換えれば、最低限可能なアップグレードを行います。<command>apt-get</command> のアップグレードパッケージの選択規則は <command>aptitude</command> や <command>apt</command> よりも少し条件が厳しいです。なぜなら <command>apt-get upgrade</command> は現在のパッケージ構成を変えないからです。つまりパッケージの新パージョンで導入された新しい依存関係により現在インストールされていないパッケージをインストールする必要が生じた場合はパッケージの新パージョンをインストールしないからです。
			</para>
			 <sidebar id="sidebar.apt-pdiff"> <title><emphasis>TIP</emphasis> 増分アップグレード</title>
			 <para>
				先に説明した通り、<command>apt update</command> コマンドは、複数のパッケージソースから対応する <filename>Packages</filename> (または <filename>Sources</filename>) ファイルをダウンロードします。しかしながら、これらのファイルのサイズは <command>xz</command> 圧縮してもまだ大きいです (<emphasis role="distribution">Stretch</emphasis> の <foreignphrase>main</foreignphrase> セクションの <filename>Packages.xz</filename> は 6 MB 以上です)。日常的にアップグレードしたい場合、ダウンロードに時間がかかるということです。
			</para>
			 <para>
				APT は作業を高速に進めるために、ファイル全体をダウンロードするのではなく、前回の更新以降の変更を含む「差分」をダウンロードすることも可能です。これを実現するために、公式の Debian アーカイブミラーはある時点の <filename>Packages</filename> ファイルと各回の更新に対応する「差分」を配布しています。「差分」はアーカイブが更新されるたびに生成され、1 週間分の「差分」が保存されています。1 個の「差分」ファイルのサイズは<emphasis role="distribution">不安定版</emphasis>の場合でもたった数十キロバイトです。そのため、毎週 1 回 <command>apt update</command> を実行する場合にダウンロードされるデータ量は 10 分の 1 程度になります。より更新頻度の低い<emphasis role="distribution">安定版</emphasis>や<emphasis role="distribution">テスト版</emphasis>などのディストリビューションをアップグレードする場合、差分ファイルを使うことによるダウンロードデータ量の削減効果はより顕著なものになります。
			</para>
			 <para>
				しかしながら、特に長期間アップグレード作業を行っていなかった場合や増分アップグレードの効果が薄い場合、<filename>Packages</filename> ファイルの全体を強制的にダウンロードしたいと思うかもしれません。これはまた、ネットワークがとても高速でマシンの処理がとても遅い場合に興味深いです。なぜなら、全体をダウンロードすることで節約される時間よりも、コンピュータがファイルの新しいバージョンを計算する時間 (ローカルにある <filename>Packages</filename> ファイルにダウンロードされた差分を適用していく時間) の方が長いからです。強制的に <filename>Packages</filename> ファイル全体をダウンロードさせるには、設定パラメータ <literal>Acquire::Pdiffs</literal> を <literal>false</literal> に設定してください。
			</para>
			 </sidebar> <para>
				通常 <command>apt</command> は最新のバージョンをインストールします (ただし<emphasis role="distribution">実験版</emphasis>と<emphasis role="distribution">安定版バックポート</emphasis>のパッケージはバージョン番号に関わらず明示的に指定しない限りインストールされません)。<filename>sources.list</filename> の中で<emphasis role="distribution">テスト版</emphasis>や<emphasis role="distribution">不安定版</emphasis>を指定した場合、<command>apt upgrade</command> は<emphasis role="distribution">安定版</emphasis>システムのほとんどを<emphasis role="distribution">テスト版</emphasis>や<emphasis role="distribution">不安定版</emphasis>に変更します。これはあなたが望んでいないことかもしれません。
			</para>
			 <para>
				<command>apt</command> がアップグレードされたパッケージを検索する際に、特定のディストリビューションからパッケージを検索させるには、<literal>-t</literal> または <literal>--target-release</literal> オプションにディストリビューションの名前を付けてください (たとえば <command>apt -t stable upgrade</command> のようにしてください)。<command>apt</command> を使う時に毎回このオプションを指定するのを避けるには、<filename>/etc/apt/apt.conf.d/local</filename> ファイルに <literal>APT::Default-Release "stable";</literal> を追加してください。
			</para>
			 <indexterm>
				<primary><command>apt full-upgrade</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>apt dist-upgrade</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>apt-get dist-upgrade</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>aptitude dist-upgrade</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>aptitude full-upgrade</command></primary>
			</indexterm>
			 <para>
				より重要なアップグレード、たとえば Debian のメジャーバージョンをアップグレードするなどの場合、<command>apt full-upgrade</command> を使ってください。<command>apt full-upgrade</command> を実行した場合、<command>apt</command> はアップグレードに伴う新しい依存関係により不要となったパッケージを削除します。また、<command>apt full-upgrade</command> は Debian <emphasis role="distribution">不安定版</emphasis> リリースを日常的に使い、毎日開発進化を追いかけているユーザが使うコマンドです。これは説明がほとんど必要ないくらいとても単純です。そして APT の評判はこの偉大なる機能性が担っています。
			</para>
			 <para>
				<command>apt</command> と異なり、<command>aptitude</command> および <command>apt-get</command> では <command>full-upgrade</command> コマンドを使うことができません。その代わり、<command>apt-get dist-upgrade</command> (「ディストリビューションアップグレード」) を使ってください。dist-upgrade コマンドは歴史的かつよく知られており、<command>apt</command> と <command>aptitude</command> はユーザの利便性を考慮して dist-upgrade を受け付けます。
			</para>

		</section>
		 <section id="sect.apt-config">
			<title>設定オプション</title>
			 <indexterm>
				<primary>APT</primary>
				<secondary>設定</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>apt.conf.d/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/apt/apt.conf.d/</filename></primary>
			</indexterm>
			 <para>
				既に説明した設定項目に加えて、<filename>/etc/apt/apt.conf.d/</filename> ディレクトリに指示文を書いたファイルを追加して APT の特定の機能を設定できます。たとえば、APT に <command>dpkg</command> がファイルの衝突によるエラーを無視するよう設定するには、<literal>DPkg::options { "--force-overwrite"; }</literal> のように書いたファイルを <filename>/etc/apt/apt.conf.d/</filename> ディレクトリに追加します。
			</para>
			 <para>
				ウェブにアクセスするには必ずプロキシを介す必要がある場合、<literal>Acquire::http::proxy "http://<replaceable>yourproxy</replaceable>:3128"</literal> の行を追加してください。FTP プロキシは <literal>Acquire::ftp::proxy "ftp://<replaceable>yourproxy</replaceable>"</literal> のように追加してください。より多くの設定オプションを確認するには、<command>man apt.conf</command> コマンドで <citerefentry><refentrytitle>apt.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> マニュアルページをご覧ください (マニュアルページの詳細は<xref linkend="sect.manual-pages" />をご覧ください)。
			</para>
			 <sidebar id="sidebar.directory.d"> <title><emphasis>BACK TO BASICS</emphasis> <filename>.d</filename> で終わるディレクトリ</title>
			 <indexterm>
				<primary><filename>.d</filename></primary>
			</indexterm>
			 <para>
				名前に <filename>.d</filename> サフィックスが付けられたディレクトリは頻繁に使われます。それぞれのディレクトリは複数ファイルにわたって分割された設定ファイルを表しています。この意味において、<filename>/etc/apt/apt.conf.d/</filename> 内のすべてのファイルには APT に対する設定が含まれています。APT はこれらをアルファベット順に読み込みます。つまり、読み込まれる順番が遅いファイルの設定が早いファイルの設定を上書きするということです。
			</para>
			 <para>
				この体制により、マシンの管理者とパッケージメンテナは設定にいくつかの自由度を持つことが可能です。実際、管理者は出来合いのファイルをこのディレクトリに追加することによって、既存のファイルを編集せずにソフトウェアの設定を簡単に修正できます。パッケージメンテナはこれと同じやり方で、自分のパッケージとうまく共存させながら、他のソフトウェアの設定を変更します。あるパッケージが自分以外のパッケージから提供された設定ファイルを変更することは Debian ポリシーによって禁止されています。すなわち設定ファイルを変更できるのはユーザだけです。パッケージのアップグレード中に設定ファイルの変更が検出されたら、ユーザは設定ファイルのどのバージョンを保存するか聞かれることを忘れないでください。外部から設定ファイルが変更されれば必ず聞かれます。これは何も変えたくない管理者にとって煩わしいかもしれません。
			</para>
			 <para>
				<filename>.d</filename> ディレクトリがない場合、設定ファイルを提供するパッケージ以外が、その設定ファイルを書き換えずにプログラムの設定を変更するのは不可能です。その代わり、ユーザに自分で設定ファイルを書き換えるよう案内し、そのやり方を <filename>/usr/share/doc/<replaceable>package</replaceable>/README.Debian</filename> ファイルに記載しなければいけません。
			</para>
			 <para>
				アプリケーションに依存しますが、<filename>.d</filename> ディレクトリは直接またはすべてのファイルを連結して設定ファイルを作成する外部スクリプトを介して使われます。最新の変更を反映させるため、ディレクトリ内のファイルを変更した後にスクリプトを実行することが重要です。同様に、自動的に生成された設定ファイルを直接編集しないことが重要です。なぜなら、スクリプトを実行すれば生成された設定ファイルに行ったすべての変更が失われるからです。どちらの方法をとるか (<filename>.d</filename> ディレクトリを直接使うかディレクトリからファイルを生成するか) は通常実装に依存します。しかし、どちらの場合でも設定の柔軟性が増えるのに対して、設定の複雑さは少ししか増加しません。Exim 4 メールサーバはファイルを生成する方針をとるアプリケーションの例です。具体的に言えば、ファイル (<filename>/etc/exim4/conf.d/*</filename>) に設定を書き込み、<command>update-exim4.conf</command> コマンドがこれらを連結して <filename>/var/lib/exim4/config.autogenerated</filename> を生成します。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.apt.priorities">
			<title>パッケージ優先度の管理</title>
			 <para>
				APT の設定で最も重要な側面の 1 つに各パッケージソースに対する優先度の管理があります。たとえば、<emphasis role="distribution">テスト版</emphasis>、<emphasis role="distribution">不安定版</emphasis>、<emphasis role="distribution">実験版</emphasis>から入手できる新しいパッケージを 1 つか 2 つあるディストリビューションにインストールしたいと思うかもしれません。利用できるパッケージに対してそれぞれ別の優先度を割り当てることが可能です (同じパッケージに対してバージョンやそれを提供しているディストリビューションに依存する異なる優先度を設定することも可能です)。優先度の設定は APT の挙動に影響をおよぼします。すなわち、各パッケージについて、APT は常に最も優先度の高いバージョンをインストールします (例外は、最も優先度の高いバージョンがインストール済みのバージョンよりも古い場合か 1000 より低い優先度を持っている場合です)。
			</para>
			 <indexterm>
				<primary>APT</primary>
				<secondary><foreignphrase>pinning</foreignphrase></secondary>
			</indexterm>
			 <indexterm>
				<primary>pinning、APT pinning</primary>
			</indexterm>
			 <indexterm>
				<primary>パッケージ</primary>
				<secondary>優先度</secondary>
			</indexterm>
			 <indexterm>
				<primary>優先度</primary>
				<secondary>パッケージ優先度</secondary>
			</indexterm>
			 <indexterm>
				<primary>APT</primary>
				<secondary>設定</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>preferences</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/apt/preferences</filename></primary>
			</indexterm>
			 <para>
				APT はいくつかのデフォルト優先度を定義しています。インストール済みパッケージのバージョンは優先度 100 です。インストールされていないパッケージのバージョンはデフォルトで優先度 500 ですが、ターゲットリリース (<literal>-t</literal> コマンドラインオプションか <literal>APT::Default-Release</literal> の設定指示文によって定義します) に含まれるバージョンの場合、優先度 990 になります。
			</para>
			 <para>
				優先度を変更するには、<filename>/etc/apt/preferences</filename> ファイルに、影響を受けるパッケージの名前、バージョン、パッケージの提供者、新しい優先度を指定するエントリを追加してください。
			</para>
			 <para>
				APT は優先度が 1000 より高い場合を除いて、パッケージの古いバージョン (言い換えれば、現在インストールされているバージョンよりバージョン番号が低いパッケージ) をインストールしません。APT は常にこの制限に基づいて最も高い優先度のパッケージをインストールします。2 つのバージョンが同じ優先度の場合、APT は最新の (バージョン番号が最も高い) バージョンをインストールします。バージョンと優先度が同じで、パッケージの内容が異なる場合、APT はインストールされていないバージョンをインストールします (このルールはあるパッケージがリビジョン番号を変化させずに更新された場合に対応させるために作られました。通常はリビジョン番号を増加させなければいけません)。
			</para>
			 <para>
				より具体的に言えば、0 より低い優先度を持つパッケージは決してインストールされません。0 より大きく 100 より少ない優先度を持つパッケージは、他のバージョンがインストールされていない場合に限り、インストールされます。100 以上で 500 より少ない優先度を持つパッケージは、インストール済みバージョンまたはターゲットリリース以外のディストリビューションに含まれるバージョンが自分のバージョンよりも新しい場合に限り、インストールされます。500 以上で 990 より少ない優先度を持つパッケージは、インストール済みのバージョンまたはターゲットリリースに含まれるバージョンが自分のバージョンよりも新しい場合に限り、インストールされます。990 以上で 1000 より少ない優先度を持つパッケージは、インストール済みバージョンが自分のバージョンよりも新しい場合を除いて、インストールされます。1000 以上の優先度を持つパッケージは、自分をインストールすることでパッケージのバージョンが低くなる場合でも、常にインストールされます。
			</para>
			 <para>
				<filename>/etc/apt/preferences</filename> の設定を評価する際、APT は最初に最も具体的なエントリ (明示的に対象のパッケージを指定しているエントリ)、その後に一般的なエントリ (たとえばあるディストリビューションのすべてのパッケージを対象にするエントリ) を評価します。一般的なエントリが複数存在する場合、最初にマッチしたものを使います。利用できる選択基準としてパッケージの名前とパッケージを配布しているパッケージソースがあります。各パッケージソースは APT が <filename>Packages</filename> と一緒にダウンロードする <filename>Release</filename> ファイルに含まれる情報によって区別されます。<filename>Release</filename> ファイルには、パッケージ供給元の名前 (公式ミラーのパッケージの場合、通常「Debian」ですが、人名やサードパーティリポジトリの組織名になる場合もあります)、ディストリビューションの名前 (Debian の提供する標準的なディストリビューションの場合、通常 <emphasis role="distribution">Stable</emphasis> (安定版)、<emphasis role="distribution">Testing</emphasis> (テスト版)、<emphasis role="distribution">Unstable</emphasis> (不安定版)、<emphasis role="distribution">Experimental</emphasis> (実験版))、バージョンの名前 (たとえば Debian <emphasis role="distribution">Stretch</emphasis> なら 9) が書かれています。このメカニズムの実際のケーススタディを通じて、構文を見てみましょう。
			</para>
			 <sidebar> <title><emphasis>SPECIFIC CASE</emphasis> <emphasis role="distribution">実験版</emphasis>の優先度</title>
			 <indexterm>
				<primary><emphasis role="distribution">実験版</emphasis></primary>
			</indexterm>
			 <para>
				<emphasis role="distribution">実験版</emphasis>のリポジトリが <filename>sources.list</filename> ファイルに書かれていたとしても、<emphasis role="distribution">実験版</emphasis>に含まれるパッケージは決してインストールされません。なぜなら<emphasis role="distribution">実験版</emphasis>に含まれるパッケージの優先度は 1 だからです。これはもちろん特例措置で、誤って<emphasis role="distribution">実験版</emphasis>に含まれるパッケージをインストールするのを避けるためにこうなっています。<emphasis role="distribution">実験版</emphasis>に含まれるパッケージをインストールする唯一の方法は <command>aptitude install <replaceable>package</replaceable>/experimental</command> と実行することです。こうすることでこのコマンドを実行するユーザは嫌でもリスクをとることに気付かされるでしょう。<emphasis role="distribution">実験版</emphasis>に含まれるパッケージの優先度を 500 にして他のディストリビューションのパッケージと同列に扱うことも不可能ではありません (ただしこれは<emphasis>お勧めできません</emphasis>)。これを実現するには <filename>/etc/apt/preferences</filename> に以下のエントリを含めてください。
			</para>
			 <informalexample> 
<programlisting>Package: *
Pin: release a=experimental
Pin-Priority: 500</programlisting>
			 </informalexample> </sidebar> <para>
				Debian の安定版バージョンに含まれるパッケージだけを使いたいと仮定します。安定版以外のバージョンに含まれるパッケージは、明示的に要求されない限り、インストールされるべきではありません。この場合、<filename>/etc/apt/preferences</filename> ファイルに以下のエントリを書きます。
			</para>
			 <informalexample> 
<programlisting>Package: *
Pin: release a=stable
Pin-Priority: 900

Package: *
Pin: release o=Debian
Pin-Priority: -10</programlisting>
			 </informalexample> <para>
				<literal>a=stable</literal> の含まれるエントリはディストリビューションの名前が stable のパッケージの優先度を 900 にしています。<literal>o=Debian</literal> の含まれるエントリは、自分よりも前に評価されたエントリにマッチしなかった、共有元が「Debian」のパッケージの優先度を -10 にしています。
			</para>
			 <para>
				さらにここで、サーバには Perl バージョン 5.24 に依存するローカルプログラムがあり、アップグレードによって Perl の他のバージョンがインストールされないことを保証したいと仮定しましょう。この場合、以下のエントリを使います。
			</para>
			 <informalexample> 
<programlisting>Package: perl
Pin: version 5.24*
Pin-Priority: 1001</programlisting>
			 </informalexample> <para>
				マニュアルページ <citerefentry><refentrytitle>apt_preferences</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> には <filename>/etc/apt/preferences</filename> の記載方法に対する関連文書があります。これを表示するには <command>man apt_preferences</command> を使ってください。
			</para>
			 <sidebar> <title><emphasis>TIP</emphasis> <filename>/etc/apt/preferences</filename> 内のコメント</title>
			 <indexterm>
				<primary><literal>Explanation</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>Pin</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>Pin-Priority</literal></primary>
			</indexterm>
			 <para>
				<filename>/etc/apt/preferences</filename> ファイルにコメントを記入する公式のやり方はありませんが、それぞれのエントリの前の行に「<literal>Explanation</literal>」フィールドを付けるとテキスト説明を記入できます。
			</para>
			 <informalexample> 
<programlisting>Explanation: 実験版に含まれる xserver-xorg-video-intel
Explanation: パッケージは安全にお使いいただけます
Package: xserver-xorg-video-intel
Pin: release a=experimental
Pin-Priority: 500</programlisting>
			 </informalexample> </sidebar>
		</section>
		 <section id="sect.apt-mix-distros">
			<title>複数ディストリビューションの利用</title>
			 <para>
				<command>apt</command> は素晴らしいツールであり、他のディストリビューションに含まれるパッケージをインストールする際に力を発揮します。たとえば、<emphasis role="distribution">安定版</emphasis>システムをインストールした後に<emphasis role="distribution">テスト版</emphasis>や<emphasis role="distribution">不安定版</emphasis>に含まれるソフトウェアのパッケージを試したいが、システムを最初の状態から大きく変更したくないという場合に力を発揮します。
			</para>
			 <para>
				パッケージごとに取得元ディストリビューションを変えていると、時々システムに問題が起きるかもしれませんが、<command>apt</command> はシステム内に複数のディストリビューションをうまく共存させ、危険のおよぶ範囲をうまく限定します。進むべき最善の道は、<filename>/etc/apt/sources.list</filename> に共存させるすべてのディストリビューションを書いて (常に 3 つのディストリビューションを書いている人もいますが、<emphasis role="distribution">不安定版</emphasis>は経験豊富なユーザ向けであることを忘れないでください)、<literal>APT::Default-Release</literal> パラメータで基準ディストリビューションを定義することです (<xref linkend="sect.apt-upgrade" />を参照してください)。
			</para>
			 <para>
				<emphasis role="distribution">安定版</emphasis>を基準ディストリビューションと仮定し、併せて<emphasis role="distribution">テスト版</emphasis>と<emphasis role="distribution">不安定版</emphasis>用のリポジトリも <filename>sources.list</filename> ファイルに書かれていると仮定します。この場合、<emphasis role="distribution">テスト版</emphasis>に含まれるパッケージをインストールするには <command>apt install <replaceable>package</replaceable>/testing</command> を使います。依存関係の解決に失敗してインストールできなかった場合、<literal>-t testing</literal> パラメータを付けて<emphasis role="distribution">テスト版</emphasis>を使って依存関係を解決させることが可能です。<emphasis role="distribution">不安定版</emphasis>でも同じことが言えます。
			</para>
			 <para>
				この状況では、アップグレード (<command>upgrade</command> と <command>full-upgrade</command>) は、アップグレード対象のパッケージが既に他のディストリビューションからインストールされている場合を除き、<emphasis role="distribution">安定版</emphasis>のパッケージを使います。他のディストリビューションからインストールされたパッケージは、自分が含まれていたディストリビューションに利用できる更新がある場合に限り、アップグレードされます。以下では、APT によって設定されたデフォルト優先度の助けを借りてこの挙動を説明します。パッケージの優先度を確認するには、遠慮なく <command>apt-cache policy</command> を使ってください (補注<xref linkend="sidebar.apt-cache-policy" />を参照してください)。
			</para>
			 <para>
				APT はインストール済みのパッケージに比べてバージョンが高いか同じのパッケージだけを考慮するという事実を知れば、すべてを理解できます (ここでは <filename>/etc/apt/preferences</filename> の中に一部のパッケージに対して 1000 より高い優先度を強制する設定がないと仮定します)。
			</para>
			 <sidebar id="sidebar.apt-cache-policy"> <title><emphasis>TIP</emphasis> <command>apt-cache policy</command></title>
			 <para>
				優先度のメカニズムをさらに良く理解するためには、<command>apt-cache policy</command> を実行し、各パッケージソースに対して設定されているデフォルトの優先度を確認してください。また、あるパッケージの利用できるバージョンすべてに対する優先度を表示するために <command>apt-cache policy <replaceable>package</replaceable></command> を使うことも可能です。
			</para>
			 </sidebar> <para>
				あるパッケージの、<emphasis role="distribution">安定版</emphasis>に含まれるバージョン 1 がインストール済みで、<emphasis role="distribution">テスト版</emphasis>と<emphasis role="distribution">不安定版</emphasis>に含まれるバージョン 2 と 3 が利用できると仮定しましょう。インストール済みバージョンの優先度は 100 ですが、<emphasis role="distribution">安定版</emphasis>に含まれるバージョン (インストール済みのバージョンと全く同じバージョン) の (ターゲットリリースに含まれるバージョンの) 優先度は 990 です。<emphasis role="distribution">テスト版</emphasis>と<emphasis role="distribution">不安定版</emphasis>に含まれるバージョンの優先度 (インストールされていないバージョンに対するデフォルト優先度) は 500 です。この場合、インストール済みのバージョン 1 が最も高い優先度 990 を持ちます。パッケージは「<emphasis role="distribution">安定版</emphasis>のまま」です。
			</para>
			 <para>
				<emphasis role="distribution">テスト版</emphasis>に含まれるバージョン 2 がインストール済みの場合について見てみましょう。<emphasis role="distribution">安定版</emphasis>に含まれるバージョン 1 と<emphasis role="distribution">不安定版</emphasis>に含まれるバージョン 3 が利用できます。バージョン 1 (優先度は 990。つまり 1000 より低いです) は、インストール済みバージョンよりもバージョンが低いため、無視されます。残るのはバージョン 2 か 3 ですが、両者の優先度は 500 です。優先度が同じ場合、APT は最も新しいバージョン、つまり<emphasis role="distribution">不安定版</emphasis>に含まれるバージョン、を選択します。<emphasis role="distribution">テスト版</emphasis>に含まれていたインストール済みバージョンを<emphasis role="distribution">不安定版</emphasis>に含まれるバージョンに移行したくない場合、<emphasis role="distribution">不安定版</emphasis>に含まれるバージョンに 500 よりも低い優先度 (たとえば 490 など) を割り当てないといけません。これを行うには、<filename>/etc/apt/preferences</filename> を以下のように修正してください。
			</para>
			 
<programlisting>Package: *
Pin: release a=unstable
Pin-Priority: 490</programlisting>

		</section>
		 <section id="sect.automatic-tracking">
			<title>自動的にインストールされたパッケージの追跡</title>
			 <para>
				<command>apt</command> の本質的な機能の 1 つに、依存関係によってのみインストールされたパッケージの追跡があります。これらのパッケージは「自動」と呼ばれ、たとえばライブラリなどがその一例です。
			</para>
			 <para>
				あるパッケージを削除する際に、パッケージマネージャは、この追跡情報を元に、既に不要となった自動パッケージを選び出すことができます (なぜなら、依存関係によってインストールされたパッケージのうち、「手作業でインストール」されていないパッケージは不要と判断できるからです)。不要になった自動パッケージを削除するには <command>apt-get autoremove</command> または <command>apt autoremove</command> を使います。<command>aptitude</command> にはこのコマンドがありません。なぜなら <command>aptitude</command> は不要な自動パッケージを見つけ次第自動的に削除するからです。どのプログラムを使った場合も、不要になった自動パッケージは分かりやすく表示されます。
			</para>
			 <indexterm>
				<primary><command>apt-mark auto</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>apt-mark manual</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>aptitude markauto</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>aptitude unmarkauto</command></primary>
			</indexterm>
			 <para>
				直接的に使うわけではないパッケージを自動パッケージとしてマークするのは良い癖です。こうすれば、そのパッケージがいらなくなった時に自動的に削除されます。<command>apt-mark auto <replaceable>package</replaceable></command> はパッケージを自動パッケージとしてマークし、逆に <command>apt-mark manual <replaceable>package</replaceable></command> は手動パッケージとしてマークします。<command>aptitude markauto</command> と <command>aptitude unmarkauto</command> は同様に動きますが、多くのパッケージを同時にマークする機能を持っています (<xref linkend="sect.aptitude" />を参照してください)。<command>aptitude</command> のコンソールベース対話型インターフェースを使うと、多くのパッケージの「自動パッケージフラグ」を容易に確認できます。
			</para>
			 <indexterm>
				<primary><command>aptitude why</command></primary>
			</indexterm>
			 <para>
				自動的にインストールされたパッケージがシステムに存在する理由を知りたい場合があるかもしれません。この情報をコマンドラインから得るには、<command>aptitude why <replaceable>package</replaceable></command> を使ってください (<command>apt</command> および <command>apt-get</command> に同様の機能はありません)。
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>aptitude why python-debian
</userinput><computeroutput>i   aptitude         推奨 apt-xapian-index         
i A apt-xapian-index 依存 python-debian (&gt;= 0.1.15)
</computeroutput></screen>
			 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> <command>deborphan</command> と <command>debfoster</command></title>
			 <indexterm>
				<primary><command>deborphan</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>debfoster</command></primary>
			</indexterm>
			 <para>
				<command>apt</command>、<command>apt-get</command>、<command>aptitude</command> にまだ自動パッケージを追跡する機能がなかった時代、不要なパッケージをリストアップするユーティリティが 2 つありました。具体的に言えば、<command>deborphan</command> と <command>debfoster</command> です。
			</para>
			 <para>
				<command>deborphan</command> は最も原始的なツールです。<command>deborphan</command> は単純に (他に指示のない限り) <literal>libs</literal> と <literal>oldlibs</literal> セクションを調べ、現在インストール済みで他のどのパッケージからも必要とされていないパッケージを探します。この結果は必要ないパッケージを削除するためのたたき台になります。
			</para>
			 <para>
				<command>debfoster</command> は APT とよく似たより複雑なアプローチを取ります。具体的に言えば、<command>debfoster</command> は明示的にインストールされたパッケージのリストを保存し、毎回起動される度に本当に必要なパッケージを記録します。<command>debfoster</command> が新しいパッケージをシステムに検出し、そのパッケージが必要か分からなかった場合、そのパッケージを依存関係のリストと一緒に画面に表示します。そして、選択肢を表示します。この選択肢の中には、パッケージを削除する (そのパッケージが依存するパッケージも一緒に削除するかもしれません)、明示的に必要とマークする、一時的にこれを無視するなどがあります。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.apt-cache">
		<title><command>apt-cache</command> コマンド</title>
		 <indexterm>
			<primary><command>apt-cache</command></primary>
		</indexterm>
		 <indexterm>
			<primary>APT</primary>
			<secondary>パッケージ検索</secondary>
		</indexterm>
		 <indexterm>
			<primary>APT</primary>
			<secondary>ヘッダ表示</secondary>
		</indexterm>
		 <indexterm>
			<primary>パッケージの検索</primary>
		</indexterm>
		 <indexterm>
			<primary>パッケージ</primary>
			<secondary>検索</secondary>
		</indexterm>
		 <para>
			<command>apt-cache</command> コマンドは APT の内部データベースに保存された情報の多くを表示できます。この情報は一種のキャッシュのようなもので、<filename>sources.list</filename> ファイル内のさまざまなソースから収集されます。収集は <command>apt update</command> の実行ごとに行われます。
		</para>
		 <sidebar id="sidebar.cache"> <title><emphasis>VOCABULARY</emphasis> キャッシュ</title>
		 <para>
			キャッシュとは (パフォーマンスの観点から) 通常のアクセス方法が高くつく場合に、頻繁なデータアクセスを高速化する目的で使われる一時的な保存システムです。キャッシュの概念は、数多くの状況と異なる規模に対して、たとえばマイクロプロセッサのコアや高性能のストレージシステムにさえも、応用できます。
		</para>
		 <para>
			APT の場合、基準になる <filename>Packages</filename> ファイルは Debian アーカイブミラーから提供されます。ですから、利用できるパッケージのデータベース内を検索する際に、毎回ネットワークを使うのはとても非効率的です。このため、APT は (<filename>/var/lib/apt/lists/</filename> に) データベースのコピーを保存し、このコピーを使って検索します。同様に、<filename>/var/cache/apt/archives/</filename> にはこれまでにダウンロードしたパッケージのキャッシュを保存しています。これは削除後の再インストール時に同じファイルをダウンロードするのを避けるためです。
		</para>
		 </sidebar> <indexterm>
			<primary><command>apt show</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>apt search</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>apt-cache show</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>apt-cache search</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>aptitude show</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>aptitude search</command></primary>
		</indexterm>
		 <para>
			<command>apt-cache</command> コマンドを <command>apt-cache search <replaceable>keyword</replaceable></command> のように使うことで、キーワードを元にパッケージを検索することが可能です。さらに、<command>apt-cache show <replaceable>package</replaceable></command> のように使うことで、利用できるバージョンのパッケージヘッダを表示することも可能です。このコマンドで、パッケージの説明、依存関係、メンテナの名前などの情報が表示されます。また、<command>apt search</command>、<command>apt show</command>、<command>aptitude search</command>、<command>aptitude show</command> も同様の機能を持っている点に注意してください。
		</para>
		 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> <command>axi-cache</command></title>
		 <indexterm>
			<primary><command>axi-cache</command></primary>
		</indexterm>
		 <indexterm>
			<primary><emphasis role="pkg">apt-xapian-index</emphasis></primary>
		</indexterm>
		 <para>
			<command>apt-cache search</command> はとても基本的なツールで、簡単に言ってしまえばパッケージ説明の <command>grep</command> 実装です。その結果の数は通常多すぎるか、逆にキーワードが多すぎれば全くないかのどちらかです。
		</para>
		 <para>
			一方、<command>axi-cache search <replaceable>term</replaceable></command> は関連度順により良い結果を提供します。このコマンドは <emphasis>Xapian</emphasis> 検索エンジンを使い、全パッケージの情報 (とすべての Debian パッケージから提供される <filename>.desktop</filename> ファイル) をインデックス化している <emphasis role="pkg">apt-xapian-index</emphasis> パッケージの一部です。<command>axi-cache</command> はタグ (補注<xref linkend="sidebar.debtags" />を参照してください) に関しても知っており、わずか数ミリ秒で結果を返します。
		</para>
		 
<screen>$ <userinput>axi-cache search package use::searching</userinput>
100 results found.
Results 1-20:
100% packagesearch - GUI for searching packages and viewing package information
100% apt-utils - package management related utility programs
99% dpkg-awk - Gawk script to parse /var/lib/dpkg/{status,available} and Packages
98% migemo - Transitional package for migemo
95% apt-file - search for files within Debian packages (command-line interface)
[...]
79% apt-xapian-index - maintenance and search tools for a Xapian index of Debian packages
More terms: paquets debian pour debtags recherche gift gnuift
More tags: suite::debian works-with::software:package role::program admin::package-management interface::commandline scope::utility field::biology:bioinformatics
`axi-cache more' will give more results
</screen>
		 </sidebar> <indexterm>
			<primary><command>apt-cache policy</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>apt-cache dumpavail</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>apt-cache pkgnames</command></primary>
		</indexterm>
		 <para>
			<command>apt-cache</command> にはあまり使われない機能もあります。たとえば、<command>apt-cache policy</command> はパッケージソースの優先度や、それぞれのパッケージの優先度を表示します。もう一つの例は <command>apt-cache dumpavail</command> で、これは全パッケージの利用できるバージョンのヘッダを表示します。<command>apt-cache pkgnames</command> は少なくとも 1 回キャッシュされた全パッケージのリストを表示します。
		</para>

	</section>
	 <section id="sect.apt-frontends">
		<title>フロントエンド、<command>aptitude</command>、<command>synaptic</command></title>
		 <indexterm>
			<primary><command>aptitude</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>synaptic</command></primary>
		</indexterm>
		 <indexterm>
			<primary>APT</primary>
			<secondary>インターフェース</secondary>
		</indexterm>
		 <para>
			APT は C++ プログラムで、<command>libapt-pkg</command> 共有ライブラリがその機能の多くを担っています。共有ライブラリを使うとユーザインターフェース (フロントエンド) の作成が楽になります。なぜなら、ライブラリに含まれるコードは簡単に再利用できるからです。歴史的に言って、<command>apt-get</command> は <command>libapt-pkg</command> のテスト用フロントエンドとして設計されましたが、成功を収めたためにその事実は曖昧にされがちです。
		</para>
		 <section id="sect.aptitude">
			<title><command>aptitude</command></title>
			 <para>
				<command>aptitude</command> は対話型プログラムで、コンソールの準グラフィカルモードを備えています。<command>aptitude</command> を使うと、インストール済みや利用できるパッケージのリストを閲覧したり、すべての利用できる情報を調べたり、インストールや削除するパッケージを選択できます。<command>aptitude</command> は特に管理者が使うように設計されました。そのため、<command>aptitude</command> のデフォルトの挙動は <command>apt-get</command> よりもずっと合理的で、インターフェースはより理解されやすいものになっています。
			</para>
			 <figure>
				<title><command>aptitude</command> パッケージマネージャ</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/aptitude.png" format="PNG" scalefit="1" width="75%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <para>
				<command>aptitude</command> は起動すると、状態ごとに分類したパッケージのリストを表示します (インストール済み、未インストール、インストール済みだがミラーから利用不可、タスク、仮想パッケージ、最近ミラーに登場した新しいパッケージなどの状態ごとに分類されます)。さらに、パッケージリストをテーマ別に簡便に閲覧できるビューも用意されています。すべての場合について、<command>aptitude</command> はカテゴリとパッケージを併せたリストを画面に表示します。カテゴリは木構造を使って系統付けられ、木構造の枝は <keycombo><keycap>Enter</keycap></keycombo>、<keycombo><keycap>[</keycap></keycombo>、<keycombo><keycap>]</keycap></keycombo> キーで開いたり閉じたりできます。<keycombo><keycap>+</keycap></keycombo> はインストールマーク、<keycombo><keycap>-</keycap></keycombo> は削除マーク、<keycombo><keycap>_</keycap></keycombo> は完全削除マークをパッケージに対して付け加えるのに使われます (マーク操作はカテゴリに対しても適用できる点に注意してください。この場合、カテゴリ内のすべてのパッケージに対して対応するマーク操作を行います)。<keycombo><keycap>u</keycap></keycombo> は利用できるパッケージのリストを更新、<keycombo action="simul"><keycap>Shift</keycap><keycap>u</keycap></keycombo> はシステム全体のアップグレードを準備します。<keycombo><keycap>g</keycap></keycombo> は要求された変更操作の要約ビューに切り替えます (もう一度 <keycombo><keycap>g</keycap></keycombo> を打てば変更を適用します)。<keycombo><keycap>q</keycap></keycombo> は現在のビューを閉じます (ビューが一つしか残っていない場合 <command>aptitude</command> を閉じます)。
			</para>
			 <sidebar> <title><emphasis>DOCUMENTATION</emphasis> <command>aptitude</command></title>
			 <para>
				この節では <command>aptitude</command> の詳細な使い方を述べるのではなく、<command>aptitude</command> を活用して生き残るための知恵を与えることに注力します。<command>aptitude</command> の文書は比較的詳しく書かれており、<emphasis role="pkg">aptitude-doc-ja</emphasis> パッケージから利用できるプログラムの完全なマニュアルを使うことをお勧めします (<filename>/usr/share/doc/aptitude/html/ja/index.html</filename> をご覧ください)。
			</para>
			 </sidebar> <para>
				<command>aptitude</command> でパッケージを検索するには、<keycombo><keycap>/</keycap></keycombo> を押して、検索パターンを入力してください。この検索パターンはパッケージの名前に対して検索を行いますが、説明文 (<literal>~d</literal> を先頭に付けた場合)、セクション (<literal>~s</literal>)、その他の属性の内容に対してを検索を行うことも可能です。詳しくは文書を参照してください。同じ検索パターンを使って、表示されるパッケージを選別することも可能です。これを行うには、<keycombo><keycap>l</keycap></keycombo> キー (<foreignphrase>limit</foreignphrase> の意味) を押して検索パターンを入力してください。
			</para>
			 <para>
				<command>aptitude</command> を使えば簡単に Debian パッケージの「自動フラグ」を管理できます (<xref linkend="sect.automatic-tracking" />を参照してください)。<command>aptitude</command> を使えば、インストール済みパッケージのリストを閲覧したり、<keycombo action="simul"><keycap>Shift</keycap> <keycap>m</keycap></keycombo> キーでパッケージに自動マークを付けたり、<keycombo><keycap>m</keycap></keycombo> キーでそのマークを消したりすることが可能です。「自動的にインストールされたパッケージ」はパッケージリスト上で「A」を付けて表示されています。「自動フラグ」管理機能により、マシンで利用されている全パッケージから、全く関心のないライブラリと依存関係を除外したパッケージのリストを簡単に表示できます。これを行うには <keycombo><keycap>l</keycap></keycombo> (フィルタモードを有効化する) を押して検索パターン <literal>~i!~M</literal> を入力します。これはインストール済みパッケージ (<literal>~i</literal>) から自動パッケージとしてマークされたパッケージを除外 (<literal>!~M</literal>) して表示することを意味しています。
			</para>
			 <sidebar> <title><emphasis>TOOL</emphasis> コマンドラインインターフェースで <command>aptitude</command> を使う</title>
			 <para>
				<command>aptitude</command> の機能のほとんどは対話型インターフェースだけでなくコマンドラインインターフェースからも利用できます。コマンドラインは <command>apt-get</command> と <command>apt-cache</command> を日常的に使っているユーザにとって身近なものでしょう。
			</para>
			 <para>
				<command>aptitude</command> の先進的な機能はコマンドラインからも使えます。パッケージ検索パターンは対話型インターフェースの場合と同じです。たとえば、「手作業でインストールされた」パッケージのリストを整理整頓したい場合、インストール済みでパッケージ管理下にないプログラムが特定のライブラリと Perl モジュールに依存していないと知っていれば、たった 1 つのコマンドで関連するパッケージを自動パッケージとしてマークすることが可能です。
			</para>
			 
<screen><computeroutput># </computeroutput><userinput>aptitude markauto '~slibs|~sperl'</userinput></screen>
			 <para>
				この検索パターンは、<literal>libs</literal> と <literal>perl</literal> セクションに含まれる全パッケージを簡単に選択するものであり、<command>aptitude</command> で使える検索パターンシステムの力を明確に表しています。
			</para>
			 <para>
				<command>aptitude</command> は、自動パッケージとしてマークされているパッケージが他のパッケージから依存関係に指定されていない場合、その自動パッケージをすぐに (削除要求を確認した後に) 削除します。この点に気を付けてください。
			</para>
			 </sidebar> <section>
				<title>推奨パッケージ、提案パッケージ、タスクの管理</title>
				 <para>
					<command>aptitude</command> が提供するもう 1 つの興味深い特徴は、パッケージ間の推奨関係を尊重する点です。とは言うものの、個々の場合に応じて、推奨パッケージをインストールしないようにすることも可能です。たとえば、<emphasis role="pkg">gnome</emphasis> パッケージは (数ある中でも特に) <emphasis role="pkg">brasero</emphasis> のインストールを推奨しています。<emphasis role="pkg">gnome</emphasis> をインストールするよう選んだ場合、同時に <emphasis role="pkg">brasero</emphasis> も選ばれます (既にシステムにインストール済みでない限り、自動パッケージとしてマークされます)。保留中の操作を確認するには、<keycombo><keycap>g</keycap></keycombo> と入力してください。そうすると、依存関係を満足させる目的で自動的にインストールされたパッケージがまとめられているリスト中に <emphasis role="pkg">brasero</emphasis> が表示されます。しかしながら、操作の承認前にインストールマークを外すことで、パッケージをインストールしないようにできます。
				</para>
				 <para>
					<command>aptitude</command> を使ってパッケージのアップグレードを行う場合、上で述べた推奨関係を追跡してインストールパッケージを自動選択する機能が作動しない点に注意してください。たとえば、<emphasis role="pkg">gnome</emphasis> の新バージョンが、以前推奨していなかったパッケージを推奨している場合、推奨されているパッケージは選択されません。しかしながら、管理者がインストールの可否を選択できるように、新しい推奨パッケージはアップグレード画面に表示されます。
				</para>
				 <para>
					さらに、<command>aptitude</command> はパッケージ間の提案関係を考慮しますが、そのやり方はパッケージを特定の表示状態にするだけです。たとえば、<emphasis role="pkg">gnome</emphasis> は <emphasis role="pkg">empathy</emphasis> を提案しているので、<emphasis role="pkg">empathy</emphasis> は保留中の操作の要約画面 (他のパッケージによって提案されたパッケージのセクションの中) に表示されるでしょう。このように、提案されたパッケージは一覧に表示され、管理者はこの提案に従ってインストールするか否かを決めます。パッケージ間の提案関係とは依存関係でも推奨関係でもないので、提案されたパッケージは自動的にインストールマークを付けられません。つまり、ユーザがインストールするか否かを手作業で選択します (このため、提案されたパッケージは自動パッケージとしてマークされません)。
				</para>
				 <para>
					同様の観点から <command>aptitude</command> はタスクの概念をうまく取り扱うことにも触れておきます。タスクはパッケージリストの画面内にカテゴリとして表示されるため、ユーザはタスクのインストールおよび削除を、タスク全体に対して適用するか、タスクのパッケージの一部を選択してそれらに適用するかを選ぶことが可能です。
				</para>

			</section>
			 <section>
				<title>より良い解決アルゴリズム</title>
				 <para>
					この節を締め括るにあたり、<command>aptitude</command> は <command>apt-get</command> に比べてより複雑なアルゴリズム使って難しい状況を解決するという点に触れておきます。一連の操作のすべての操作を適用するとシステムの整合性が失われる場合、<command>aptitude</command> はいくつかの解決策を検討し、適用後の整合性が高い順に解決策を提示します。しかしながら、このアルゴリズムは単なるケアレスミスの予防策ではありません。幸いなことに、ユーザは常に手作業で適用する操作を選択できます。現在選択された操作によってシステムの整合性が失われる場合、画面の上の方に「壊れた」パッケージの数が表示されます (手作業で「壊れた」パッケージに移動するには <keycombo><keycap>b</keycap></keycombo> を押してください)。そして、見つかった問題を手作業で解決することも可能です。具体的に言うと、<keycombo><keycap>Enter</keycap></keycombo> でパッケージを選択すれば、利用できる複数のバージョンを確認できます。複数のバージョンから 1 つ選ぶだけで問題が解決されるなら、迷わずこの機能を使うべきです。壊れたパッケージの数がゼロになったら、操作適用前の最終確認のために、保留中の操作の要約画面に問題なく移動できるはずです。
				</para>
				 <sidebar> <title><emphasis>NOTE</emphasis> <command>aptitude</command> のログ</title>
				 <para>
					<command>dpkg</command> と同様に、<command>aptitude</command> は実行した操作をログファイル (<filename>/var/log/aptitude</filename>) に記録します。しかしながら、<command>dpkg</command> と <command>aptitude</command> は全く異なる階層で動いているので、それぞれのログファイルには異なる情報が含まれます。<command>dpkg</command> が各パッケージに対して行ったすべての操作を 1 つずつ記録するのに対し、<command>aptitude</command> はシステム全体のアップグレードなどの高レベル操作に対するより全体的な情報を記録します。
				</para>
				 <para>
					<filename>/var/log/aptitude</filename> には、<command>aptitude</command> が実行した操作の要約だけが含まれる点に注意してください。途中で他のフロントエンド (または <command>dpkg</command> 自身) が使われた場合、<command>aptitude</command> のログには、操作全体の一部分しか記録されません。このため、信頼できるシステムの履歴を確認したい場合に、<filename>/var/log/aptitude</filename> は頼りになりません。
				</para>
				 </sidebar>
			</section>

		</section>
		 <section>
			<title><command>synaptic</command></title>
			 <para>
				<command>synaptic</command> は Debian 用のグラフィカルパッケージマネージャで、GTK+/GNOME を使った簡便で効率的なグラフィカルインターフェースです。数多くのすぐに使えるフィルタのおかげで、新しく利用できるようになったパッケージ、インストール済みパッケージ、アップグレードできるパッケージ、時代遅れのパッケージなどを素早く確認できます。これらのリストを通じてパッケージを閲覧しているならば、閲覧中のパッケージに対して実行する操作 (インストール、アップグレード、削除、完全削除) を選択できます。さらに、これらの操作はすぐに実行されるのではなく、まずは操作リストに追加されます。ボタンを一度クリックするだけで、操作の正当性が検証され、操作は一度に実行されます。
			</para>
			 <figure>
				<title><command>synaptic</command> パッケージマネージャ</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/synaptic.png" format="PNG" scalefit="1" width="75%" />
					</imageobject>

				</mediaobject>

			</figure>

		</section>

	</section>
	 <section id="sect.package-authentication">
		<title>パッケージ信頼性の確認</title>
		 <indexterm>
			<primary>パッケージ</primary>
			<secondary>信頼性確認</secondary>
		</indexterm>
		 <indexterm>
			<primary>パッケージ</primary>
			<secondary>封印</secondary>
		</indexterm>
		 <indexterm>
			<primary>パッケージ</primary>
			<secondary>署名</secondary>
		</indexterm>
		 <indexterm>
			<primary>署名</primary>
			<secondary>パッケージ署名</secondary>
		</indexterm>
		 <indexterm>
			<primary>信頼性</primary>
			<secondary>パッケージ信頼性</secondary>
		</indexterm>
		 <para>
			Falcot Corp の管理者にとって、セキュリティはとても重要です。つまり管理者は、パッケージが途中で改竄されていないこと、確かに Debian から提供されていることを確認し、確認のとれたパッケージだけをインストールしなければいけません。コンピュータクラッカーは、他の合法的なパッケージに悪意あるコードを追加しようと試みます。そのようなパッケージがインストールされた場合、クラッカーが設計したことは何でも、たとえばパスワードや機密情報の漏洩などでも、実行されます。この危険性を回避するために、Debian は不正改竄を防ぐ封印を提供し、インストール時にそのパッケージが公式メンテナから提供されたものと本当に同じこと、第三者によって変更されていないことを保証しています。
		</para>
		 <para>
			この封印は一連の暗号学的ハッシュと署名を使って行われます。署名されたファイルは <filename>Release</filename> ファイルで、Debian アーカイブミラーから提供されます。<filename>Release</filename> ファイルには、<filename>Packages</filename> ファイル (<filename>Packages.gz</filename>、<filename>Packages.xz</filename>、そして増分バージョンの圧縮形式など) のリストおよびそれが改竄されていないことを保証するための MD5、SHA1、SHA256 ハッシュが含まれています。<filename>Packages</filename> ファイルには、ミラーで提供されている Debian パッケージのリストおよびパッケージの内容が変更されていないことを保証するハッシュが含まれています。
		</para>
		 <indexterm>
			<primary><command>apt-key</command></primary>
		</indexterm>
		 <indexterm>
			<primary><emphasis role="pkg">debian-archive-keyring</emphasis></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/etc/apt/trusted.gpg.d/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>Release.gpg</filename></primary>
		</indexterm>
		 <para>
			APT needs a set of trusted GnuPG public keys to verify signatures in the <filename>Release.gpg</filename> files available on the mirrors. It gets them from files in <filename>/etc/apt/trusted.gpg.d/</filename> and from the <filename>/etc/apt/trusted.gpg</filename> keyring (managed by the <command>apt-key</command> command). The official Debian keys are provided and kept up-to-date by the <emphasis role="pkg">debian-archive-keyring</emphasis> package which puts them in <filename>/etc/apt/trusted.gpg.d/</filename>. Note however that the first installation of this particular package requires caution: even if the package is signed like any other, the signature cannot be verified externally. Cautious administrators should therefore check the fingerprints of imported keys before trusting them to install new packages:
		</para>
		 
<screen role="scale"># <userinput>apt-key fingerprint</userinput>
/etc/apt/trusted.gpg.d/debian-archive-jessie-automatic.gpg
----------------------------------------------------------
pub   rsa4096 2014-11-21 [SC] [expires: 2022-11-19]
      126C 0D24 BD8A 2942 CC7D  F8AC 7638 D044 2B90 D010
uid           [ unknown] Debian Archive Automatic Signing Key (8/jessie) &lt;ftpmaster@debian.org&gt;

/etc/apt/trusted.gpg.d/debian-archive-jessie-security-automatic.gpg
-------------------------------------------------------------------
pub   rsa4096 2014-11-21 [SC] [expires: 2022-11-19]
      D211 6914 1CEC D440 F2EB  8DDA 9D6D 8F6B C857 C906
uid           [ unknown] Debian Security Archive Automatic Signing Key (8/jessie) &lt;ftpmaster@debian.org&gt;

/etc/apt/trusted.gpg.d/debian-archive-jessie-stable.gpg
-------------------------------------------------------
pub   rsa4096 2013-08-17 [SC] [expires: 2021-08-15]
      75DD C3C4 A499 F1A1 8CB5  F3C8 CBF8 D6FD 518E 17E1
uid           [ unknown] Jessie Stable Release Key &lt;debian-release@lists.debian.org&gt;

/etc/apt/trusted.gpg.d/debian-archive-stretch-automatic.gpg
-----------------------------------------------------------
pub   rsa4096 2017-05-22 [SC] [expires: 2025-05-20]
      E1CF 20DD FFE4 B89E 8026  58F1 E0B1 1894 F66A EC98
uid           [ unknown] Debian Archive Automatic Signing Key (9/stretch) &lt;ftpmaster@debian.org&gt;
sub   rsa4096 2017-05-22 [S] [expires: 2025-05-20]

/etc/apt/trusted.gpg.d/debian-archive-stretch-security-automatic.gpg
--------------------------------------------------------------------
pub   rsa4096 2017-05-22 [SC] [expires: 2025-05-20]
      6ED6 F5CB 5FA6 FB2F 460A  E88E EDA0 D238 8AE2 2BA9
uid           [ unknown] Debian Security Archive Automatic Signing Key (9/stretch) &lt;ftpmaster@debian.org&gt;
sub   rsa4096 2017-05-22 [S] [expires: 2025-05-20]

/etc/apt/trusted.gpg.d/debian-archive-stretch-stable.gpg
--------------------------------------------------------
pub   rsa4096 2017-05-20 [SC] [expires: 2025-05-18]
      067E 3C45 6BAE 240A CEE8  8F6F EF0F 382A 1A7B 6500
uid           [ unknown] Debian Stable Release Key (9/stretch) &lt;debian-release@lists.debian.org&gt;

/etc/apt/trusted.gpg.d/debian-archive-wheezy-automatic.gpg
----------------------------------------------------------
pub   rsa4096 2012-04-27 [SC] [expires: 2020-04-25]
      A1BD 8E9D 78F7 FE5C 3E65  D8AF 8B48 AD62 4692 5553
uid           [ unknown] Debian Archive Automatic Signing Key (7.0/wheezy) &lt;ftpmaster@debian.org&gt;

/etc/apt/trusted.gpg.d/debian-archive-wheezy-stable.gpg
-------------------------------------------------------
pub   rsa4096 2012-05-08 [SC] [expires: 2019-05-07]
      ED6D 6527 1AAC F0FF 15D1  2303 6FB2 A1C2 65FF B764
uid           [ unknown] Wheezy Stable Release Key &lt;debian-release@lists.debian.org&gt;</screen>
		 <sidebar> <title><emphasis>IN PRACTICE</emphasis> 信頼された鍵の追加</title>
		 <indexterm>
			<primary>信頼された鍵</primary>
		</indexterm>
		 <indexterm>
			<primary>鍵</primary>
			<secondary>APT の認証鍵</secondary>
		</indexterm>
		 <para>
			第三者のパッケージソースを <filename>sources.list</filename> に追加したら、APT に対してパッケージソースに対応する GPG 認証鍵を信頼することを伝える必要があります (そうでなければ、APT はそのパッケージソースから提供されるパッケージの信頼性を保証できないとエラーを出し続けます)。最初のステップはもちろん公開鍵を手に入れることです。大抵の場合、公開鍵は小さなテキストファイルの形で配布されています。以降の例ではこの公開鍵を <filename>key.asc</filename> と呼びます。
		</para>
		 <para>
			この鍵を信頼する鍵束に追加するには、管理者は <filename>*.asc</filename> ファイルに含まれる鍵を <filename>/etc/apt/trusted.gpg.d/</filename> に配置します。これは Debian <emphasis role="distribution">Stretch</emphasis> からサポートされました。古いリリースでは <command>apt-key add &lt; key.asc</command> を実行してください。
		</para>
		 <indexterm>
			<primary><emphasis role="pkg">gui-apt-key</emphasis></primary>
		</indexterm>
		 <para>
			専用のアプリケーションを使いたかったり、信頼された鍵の詳細を知りたい人は <command>gui-apt-key</command> (同名のパッケージに含まれます) を使うことも可能です。<command>gui-apt-key</command> は質素なユーザインターフェースで信頼された鍵束を管理します。
		</para>
		 </sidebar> <para>
			適切な鍵を鍵束の中に追加すれば、APT は危険性の高い操作の前に署名を確認します。こうすることで、信頼性が確定できないパッケージをインストールするよう要求された場合に、フロントエンドは警告を表示するようになります。
		</para>

	</section>
	 <section id="sect.dist-upgrade">
		<title>安定版から次のディストリビューションへのアップグレード</title>
		 <para>
			Debian の最もよく知られた特色の 1 つに、インストールされたシステムを安定版から次の安定版にアップグレードできることが挙げられます。そして有名なサブコマンドである <foreignphrase>dist-upgrade</foreignphrase> はプロジェクトの評判に大きく寄与し続けています。いくつかの事前準備に必要な時間を含めても、コンピュータのアップグレードに必要な時間はパッケージリポジトリからのダウンロード速度に依存してわずか数分から数十分です。
		</para>
		 <section>
			<title>推奨手順</title>
			 <para>
				Debian の安定版は次のリリースまでの間にかなり長い時間をかけて大きく進化するので、アップグレードの前にリリースノートを読むべきです。
			</para>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> リリースノート</title>
			 <para>
				オペレーティングシステムの (より一般的に言えば、ソフトウェアの) リリースノートはソフトウェアの概観と、あるバージョンに固有な点の詳細を説明する文書です。リリースノートは通常、完全な文書に比べて短く、前のバージョン以降導入された機能をリストアップしています。加えて、アップグレード手順の詳細、以前のバージョンのユーザに対する警告、そして時々正誤表を含んでいます。
			</para>
			 <para>
				Debian のリリースノートはオンライン上で利用できます。すなわち、現在の安定版に対するリリースノートには専用の URL が割り当てられ、古いリリースに対するリリースノートにはコードネームを含んだ URL が割り当てられています。<ulink type="block" url="http://www.debian.org/releases/stable/releasenotes" /><ulink type="block" url="http://www.debian.org/releases/jessie/releasenotes" />
			</para>
			 </sidebar> <para>
				この節では、特に <emphasis role="distribution">Jessie</emphasis> システムを <emphasis role="distribution">Stretch</emphasis> にアップグレードを行う場合について解説します。システムのアップグレードはシステムに甚大な変更を加えます。このため、危険が全くないわけではありません。アップグレードを行う前に、必ずすべての重要なデータをバックアップしてください。
			</para>
			 <para>
				アップグレードを簡単に (短時間で) 実行するために身に付けるべき良い癖の 1 つに、インストール済みパッケージを整理整頓し、本当に必要なものだけを残すことがあります。これを行う便利なツールが <command>aptitude</command>、<command>deborphan</command>、<command>debfoster</command> です (<xref linkend="sect.automatic-tracking" />を参照してください)。たとえば以下のコマンドを実行した後、<command>aptitude</command> の対話型モードで削除予定としてマークされたパッケージの再確認と微調整を行うことができます。
			</para>
			 
<screen># <userinput>deborphan | xargs aptitude --schedule-only remove</userinput></screen>
			 <para>
				次にシステムのアップグレードを行います。最初に <filename>/etc/apt/sources.list</filename> ファイルを書き換えて、APT にパッケージの取得先を <emphasis role="distribution">Jessie</emphasis> から <emphasis role="distribution">Stretch</emphasis> に変更するよう伝えます。<filename>/etc/apt/sources.list</filename> ファイルの中でコードネームではなく<emphasis role="distribution">安定版</emphasis>へのリファレンスを使っている場合、この変更は必要ありません。なぜなら、<emphasis role="distribution">安定版</emphasis>は常に Debian の最新リリース版を指しているからです。どちらの場合でも、利用できるパッケージのデータベースを更新してください (<command>apt update</command> コマンドを実行するか <command>synaptic</command> の更新ボタンを押してください)。
			</para>
			 <para>
				新しいパッケージソースが登録されたら、真っ先に <command>apt upgrade</command> を使い、最小アップグレードを実行するべきです。アップグレードを 2 段階に分けて行うことにより、パッケージ管理ツールの作業が軽減されますし、パッケージ管理ツールが最新のバージョンになっていることが保証されます。また、最新のパッケージ管理ツールには、多くのバグ修正がなされているかもしれませんし、ディストリビューション全体のアップグレードを完了させるために必要な改善が含まれているかもしれません。
			</para>
			 <para>
				最小アップグレードが終了したら、<command>apt full-upgrade</command>、<command>aptitude</command>、<command>synaptic</command> のうちどれか 1 つを使って、ディストリビューション全体のアップグレードを行います。提案された操作を適用する前に注意深く確認するべきです。具体的に言えば、提案パッケージを追加したい場合や、推奨されたけれども使いにくいと知っているパッケージを除外したい場合があるかもしれません。いかなる場合でもフロントエンドは、整合性が保たれて最新の <emphasis role="distribution">Stretch</emphasis> システムになるような、解決策を用意します。管理者に要求されるのは、パッケージがダウンロードされるまで待って、Debconf とマシンに合わせて変更された設定ファイルの保存可否に関する質問に答え、APT が作業を終えるまで見ているだけです。
			</para>

		</section>
		 <section>
			<title>アップグレードの後から問題を取り扱う</title>
			 <para>
				Debian メンテナの最大限の努力にも関わらず、システムのメジャーアップグレードは常に望んだ通りに順調に進むわけではありません。新しいソフトウェアバージョンは古いものと互換性がないかもしれません (たとえば、デフォルト動作やデータフォーマットが変わっているかもしれません)。また、いくつかのバグは Debian リリース前のテスト段階を経たにも関わらず見過ごされているかもしれません。
			</para>
			 <para>
				いくつかの問題を未然に防ぐために、<emphasis role="pkg">apt-listchanges</emphasis> パッケージをインストールすることが可能です。<emphasis role="pkg">apt-listchanges</emphasis> は、あるパッケージのアップグレード作業の開始時に、このパッケージのアップグレードを行うことで生じる可能性のある問題の情報を表示します。この情報はパッケージメンテナがまとめたもので、ユーザが内容を確認できるように <filename>/usr/share/doc/<replaceable>package</replaceable>/NEWS.Debian</filename> ファイルに含まれています。これらのファイルを (場合によっては <emphasis role="pkg">apt-listchanges</emphasis> を通じて) 読めば、予期しない状況に驚かされることがなくなるでしょう。
			</para>
			 <para>
				あるソフトウェアの新しいバージョンが全く動かない場合があるかもしれません。これは通常、そのアプリケーションがそれほど人気ではない場合や十分にテストされていない場合に起こります。さらに、リリース直前の更新はそれまでに存在しなかった不具合を発生させる場合があり、この種の不具合は安定版がリリースされた後に見つかります。どちらの場合でも、最初にやることはバグ追跡システム <literal>https://bugs.debian.org/<replaceable>package</replaceable></literal> でこの問題が既に報告されているか確認することです。まだ報告されていなければ、<command>reportbug</command> を使って自分で報告するべきです。既に報告されていれば、バグ報告と関連メッセージがバグに関連する情報の素晴らしいソースになります。
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						パッチが既に存在し、バグ報告からそれを入手できる場合もあります。この場合、壊れたパッケージの修正されたバージョンを再コンパイルすることが可能です (<xref linkend="sect.rebuilding-package" />をご覧ください)。
					</para>

				</listitem>
				 <listitem>
					<para>
						バグ報告には問題に対する次善策が報告されており、報告に対する返信から問題の本質を理解できる場合もあります。
					</para>

				</listitem>
				 <listitem>
					<para>
						さらに、メンテナが修正されたパッケージを用意して既に公開している場合もあります。
					</para>

				</listitem>

			</itemizedlist>
			 <para>
				バグの重要度に依存して、パッケージの新しいバージョンが安定版リリースに対する新しい改訂版として用意されている場合もあります。この場合、修正されたパッケージは Debian アーカイブミラーの <literal>proposed-updates</literal> セクションから提供されます (<xref linkend="sect.proposed-updates" />を参照してください)。対応するエントリを一時的に <filename>sources.list</filename> に追加すれば、更新されたパッケージを <command>apt</command> や <command>aptitude</command> からインストールすることが可能です。
			</para>
			 <para>
				修正されたパッケージがまだ <literal>proposed-updates</literal> セクションから提供されていないこともあります。これは、安定版リリースマネージャによる妥当性の確認が終わっていないからです。パッケージが公開待ち状態にあるかをウェブページから確認できます。このウェブページに載せられたパッケージはまだ利用できませんが、少なくとも公開待ち状態であるか否かを確認できます。<ulink type="block" url="https://release.debian.org/proposed-updates/stable.html" />
			</para>

		</section>

	</section>
	 <section id="sect.regular-upgrades">
		<title>システムを最新の状態に保つ</title>
		 <para>
			Debian ディストリビューションは活動的で、絶えず変化しています。変更のほとんどは<emphasis role="distribution">テスト版</emphasis>と<emphasis role="distribution">不安定版</emphasis>バージョンに対するものが多いですが、<emphasis role="distribution">安定版</emphasis>も多くの場合セキュリティ関連の修正によって時々更新されます。システムでどんな Debian のバージョンを使っていたとしても、システムを最新の状態に保つのが通常得策です。そうすれば、最新の進化とバグ修正の恩恵を受けることが可能です。
		</para>
		 <para>
			利用できる更新を確認してアップグレードを実行するために日常的にツールを実行することはもちろん可能ですが、特に複数のマシンでこれを行う必要がある場合、このような反復作業は面白くありません。幸いなことに、多くの反復作業と同様この作業もある程度自動化が可能で、効果的な一連のツールが開発されています。
		</para>
		 <para>
			更新作業の自動化を担うツールの 1 つ目は <command>apticron</command> で、同名のパッケージに含まれます。<command>apticron</command> の主たる挙動は (<command>cron</command> を使って) 毎日スクリプトを実行することです。スクリプトは利用できるパッケージのリストを更新し、インストール済みパッケージが入手できる最新バージョンと異なる場合、そのようなパッケージのリストと新しいバージョンにおける修正点をメールで送信します。<command>apticron</command> の挙動は明らかに Debian <emphasis role="distribution">安定版</emphasis>のユーザを対象にしています。なぜなら、より頻繁にパッケージが更新される Debian の他のディストリビューションでは毎日のメールがとても長くなるからです。更新が利用できるようになったら、<command>apticron</command> は自動的にそれらをダウンロードします。<command>apticron</command> はインストール作業を行いません。すなわち管理者が手作業でインストールを実行する必要があります。しかしながら、パッケージをダウンロードして手元 (APT のキャッシュ) に保存しておくことで、管理者は作業を迅速に行うことが可能です。
		</para>
		 <para>
			コンピュータを複数担当している管理者が保留中アップグレードの通知に対する重要性を理解しているのは間違いありません。しかしながら、システムのアップグレードは相変わらずまだ退屈なものです。定期的にアップグレードするには、<command>systemd</command> タイマユニットもしくは <command>cron</command> を使います。<emphasis role="pkg">systemd</emphasis> が未インストールの状態なら、<filename>/etc/cron.daily/apt-compat</filename> スクリプト (<emphasis role="pkg">apt</emphasis> パッケージに含まれます) が役に立ちます。<filename>/etc/cron.daily/apt-compat</filename> スクリプトは <command>cron</command> によって毎日 (非対話的に) 実行されます。スクリプトの挙動を制御するためには APT 設定変数を使います (このため変数は <filename>/etc/apt/apt.conf.d/10periodic</filename> 内のファイルに記載されます)。以下に主な変数を示します。
		</para>
		 <variablelist>
			<varlistentry>
				<term><literal>APT::Periodic::Update-Package-Lists</literal></term>
				 <listitem>
					<para>
						このオプションを使えば、パッケージリストを更新する頻度 (日単位) を設定することが可能です。<command>apticron</command> ユーザならこの変数を設定しなくても大丈夫です。なぜなら <command>apticron</command> が設定するからです。
					</para>

				</listitem>

			</varlistentry>
			 <varlistentry>
				<term><literal>APT::Periodic::Download-Upgradeable-Packages</literal></term>
				 <listitem>
					<para>
						このオプションを使えば、パッケージをダウンロードする頻度 (日単位) を設定することが可能です。<command>apticron</command> ユーザはこの変数を設定する必要はありません。
					</para>

				</listitem>

			</varlistentry>
			 <varlistentry>
				<term><literal>APT::Periodic::AutocleanInterval</literal></term>
				 <listitem>
					<para>
						これは <command>apticron</command> が備えていない機能を担うオプションです。このオプションはどの程度の頻度で時代遅れのパッケージ (どのディストリビューションにも含まれないパッケージ) を APT キャッシュから削除するかを制御します。このオプションを使うことで APT キャッシュを合理的なサイズに保ち、キャッシュの削除作業について心配する必要がなくなります。
					</para>

				</listitem>

			</varlistentry>
			 <varlistentry>
				<term><literal>APT::Periodic::Unattended-Upgrade</literal></term>
				 <listitem>
					<indexterm><primary><emphasis role="pkg">unattended-upgrades</emphasis></primary></indexterm> <para>
						このオプションが有効化されると、毎日のスクリプトで <command>unattended-upgrade</command> (<emphasis role="pkg">unattended-upgrades</emphasis> パッケージに含まれます) が実行さるようになります。これはその名前が示す通りいくつかのパッケージのアップグレード作業を自動化します (デフォルトでは、セキュリティ更新だけを処理しますが <filename>/etc/apt/apt.conf.d/50unattended-upgrades</filename> で挙動をカスタマイズできます)。このオプションを設定するには <command>dpkg-reconfigure -plow unattended-upgrades</command> を実行して debconf の助けを借りることに注意してください。
					</para>

				</listitem>

			</varlistentry>

		</variablelist>
		 <para>
			上記以外のオプションを使うことで、さらに精密なキャッシュ消去挙動を制御できます。それらのオプションをここに載せることはしませんが、詳しい説明は <filename>/usr/lib/apt/apt.systemd.daily</filename> スクリプトを参照してください。
		</para>
		 <indexterm>
			<primary><emphasis role="pkg">gnome-packagekit</emphasis></primary>
		</indexterm>
		 <para>
			サーバではこれらのツールがとてもうまく動きますが、通常デスクトップユーザはより対話的なシステムを好みます。<emphasis role="pkg">gnome-packagekit</emphasis> パッケージは、更新が利用できるようになった時、デスクトップ環境の通知エリアにアイコンを表示します。さらに、表示されたアイコンをクリックすると <command>gpk-update-viewer</command> が実行されます。これは更新を実行する簡易化されたインターフェースです。利用できる更新を閲覧したり、関連するパッケージと対応する <filename>changelog</filename> エントリの短い説明文を読んだり、個々の場合に応じてその更新を適用するか否かを選択したりできます。
		</para>
		 <figure>
			<title><command>gpk-update-viewer</command> を使ったアップグレード</title>
			 <mediaobject>
				<imageobject>
					<imagedata fileref="images/gnome-packagekit.png" format="PNG" scalefit="1" width="70%" />
				</imageobject>

			</mediaobject>

		</figure>
		 <para>
			現在では <command>gpk-update-viewer</command> はデフォルトの GNOME デスクトップにインストールされません。新しい原則に従うなら、セキュリティアップデートは自動インストールされるべきであり、これはバックグラウンドで行われるか、起動中のアプリケーションに対する無用の混乱を避けるためにコンピュータをシャットダウンする際に行われるべきです。
		</para>

	</section>
	 <section id="sect.automatic-upgrades">
		<title>自動アップグレード</title>
		 <indexterm>
			<primary>アップグレード</primary>
			<secondary>自動的なシステムアップグレード</secondary>
		</indexterm>
		 <indexterm>
			<primary>自動アップグレード</primary>
		</indexterm>
		 <para>
			Falcot Corp は多くのコンピュータを使っているものの人手は不足しているため、管理者は可能な限り自動でアップグレードを行うように努力しています。アップグレード作業を担当しているプログラムは人間の介在がなくても実行されなければいけません。
		</para>
		 <section>
			<title><command>dpkg</command> の設定</title>
			 <para>
				既に言及した通り (補注<xref linkend="sidebar.questions-conffiles" />を参照してください)、<command>dpkg</command> は設定ファイルの交換時に確認を行わないように設定できます (<literal>--force-confdef --force-confold</literal> オプションを使います)。しかしながら、人間が入力する必要が生じる状況は 3 種類考えられます。具体的に言えば、APT からの入力要求、<command>debconf</command> からの入力要求、コマンドラインを介したパッケージ設定スクリプトからの入力要求です。
			</para>

		</section>
		 <section>
			<title>APT の設定</title>
			 <para>
				APT からの入力要求に自動回答する設定は簡単です。つまり <literal>-y</literal> オプション (または <literal>--assume-yes</literal>) を使えば、APT の出すすべての質問に「yes」と答えたことになります。
			</para>

		</section>
		 <section>
			<title><command>debconf</command> の設定</title>
			 <para>
				<command>debconf</command> からの入力要求に自動回答する設定はさらに詳細な説明が必要です。設計当初から <command>debconf</command> はユーザに対する質問の妥当性と分量を調整し、同時に質問の表示方法を制御することを目標に設計されました。そのため、debconf データベースに質問を登録する際には各質問に対して表示の妥当性を制御するための優先度を設定する必要があります。現在の優先度が質問に設定された優先度を超える場合、その質問が表示されます。<command>debconf</command> はユーザが回答しなかった質問は、(パッケージメンテナが定義した) デフォルトと同様に回答されたと仮定します。
			</para>
			 <para>
				自動回答に関連する残りの設定項目がフロントエンドの使うインターフェースです。数あるインターフェースの中でも <literal>noninteractive</literal> を選んだ場合、ユーザからの入力は完全に使用不能にされます。パッケージが有益な注意を表示しようとした場合、管理者にメールで通知されます。
			</para>
			 <para>
				<command>debconf</command> を再設定するには、<emphasis role="pkg">debconf</emphasis> パッケージから提供される <command>dpkg-reconfigure</command> ツールを使ってください。<command>debconf</command> を再設定するコマンドは <command>dpkg-reconfigure debconf</command> です。ここで設定した値は、必要ならば環境変数を使って一時的に上書きできる点に注意してください (たとえば、<varname>DEBIAN_FRONTEND</varname> 環境変数は、<citerefentry><refentrytitle>debconf</refentrytitle>
				<manvolnum>7</manvolnum></citerefentry> マニュアルページで説明されている通り、インターフェースを制御します)。
			</para>

		</section>
		 <section>
			<title>コマンドラインインターフェースの制御</title>
			 <para>
				ユーザに入力を要求する最後の要素は <command>dpkg</command> が実行する設定スクリプトで、これは制御することが最も難しいものです。残念なことに設定スクリプトからの入力要求に自動回答するための標準的な解決策はありませんし、無回答以外に良い解決策はありません。
			</para>
			 <para>
				設定スクリプトからの入力要求に自動回答するための一般的な解決策は、<command><replaceable>command</replaceable> &lt;/dev/null</command> のように標準入力を <filename>/dev/null</filename> の空内容にリダイレクトすることで標準入力を抑制するか、プログラムに改行文字を送り続けるかです。どちらの解決策も完全に信頼できるわけではありませんが、通常はこれらの解決策を取ればデフォルト回答が使われることになります。なぜなら、多くのスクリプトでは、応答のない場合はデフォルト回答を選択したことになるからです。
			</para>

		</section>
		 <section>
			<title>奇跡の組み合わせ</title>
			 <para>
				上記の要素を組み合わせれば、小規模で比較的信頼できるスクリプトを設計することが可能です。これで自動アップグレードが可能になります。
			</para>
			 <example id="example.non-interactive-upgrade">
				<title>非対話型のアップグレードスクリプト</title>
				 
<programlisting>export DEBIAN_FRONTEND=noninteractive
yes '' | apt-get -y -o DPkg::options::="--force-confdef" -o DPkg::options::="--force-confold" dist-upgrade</programlisting>

			</example>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> Falcot Corp の場合</title>
			 <para>
				Falcot のコンピュータはさまざまな機種が混在するシステムで、それぞれのマシンが異なる役目を果たしています。そのため、管理者はそれぞれのコンピュータに対して最も適切な解決策を選択できます。
			</para>
			 <para>
				実際のところ、<emphasis role="distribution">Stretch</emphasis> が動いているサーバでは上に挙げた「奇跡の組み合わせ」を設定して、システムを自動的に最新の状態に保っています。最も重要なサーバ (たとえばファイアウォール) では <command>apticron</command> を設定しています。そうすればアップグレードは管理者の監視の下で実行されるからです。
			</para>
			 <para>
				管理部局で使われるオフィスワークステーションでは <emphasis role="distribution">Stretch</emphasis> が動いています。しかしながらこのワークステーションでは <emphasis role="pkg">gnome-packagekit</emphasis> を使っています。そうすればユーザが自分でアップグレードを動作させることができるからです。このように設定した根拠は、明確な指示なしにアップグレードが実行された場合、コンピュータの挙動が突然変わってしまうかもしれないからです。こうなるとワークステーションの主なユーザは混乱するでしょう。
			</para>
			 <para>
				研究所では、最新のソフトウェアバージョンを駆使するために一部のコンピュータで<emphasis role="distribution">テスト版</emphasis>を使っています。これらのコンピュータは自動的にアップグレードされません。管理者は APT を設定してアップグレードを準備するだけで、アップグレードを適用しません。従って、管理者が (手作業で) アップグレードを行う際には、パッケージリストの更新とパッケージのダウンロードという退屈な作業が終わっている状態であり、本当に必要なところだけに集中できます。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.searching-packages">
		<title>パッケージの検索</title>
		 <para>
			Debian には数多くのソフトウェアが含まれ、その数はさらに増加し続けています。このことが原因でパラドックスが生じます。すなわち Debian には通常多くの作業に適したツールが用意されているにも関わらず、無数のパッケージからその作業に適したツールを見つけることがとても難しくなります。適切なツールを検索する (発見する) ための良い方法がない点は長い間問題とされていました。幸いなことに、現在ではこの問題はほぼ解決されています。
		</para>
		 <para>
			最も平凡な検索方法は正確なパッケージ名を調べることです。<command>apt show <replaceable>package</replaceable></command> で結果が返されたら、パッケージが存在するということです。不幸なことにこの方法では、パッケージ名を知っているか推測する必要があり、それは常に可能とは限りません。
		</para>
		 <sidebar> <title><emphasis>TIP</emphasis> パッケージ命名規則</title>
		 <para>
			いくつかのカテゴリに含まれるパッケージは慣習的な命名規則に基づいて命名されます。従って、この規則を知っておけば、正確なパッケージ名を推測できる場合があります。たとえば、Perl モジュールに関して言えば、<literal>XML::Handler::Composer</literal> と呼ばれるモジュールは命名規則に従うと <emphasis role="pkg">libxml-handler-composer-perl</emphasis> のようにパッケージングされるべきであると定められています。また、Python から <command>gconf</command> システムを扱うためのライブラリは <emphasis role="pkg">python-gconf</emphasis> としてパッケージングされています。不幸なことに、たとえパッケージメンテナが通常は上流開発者の選択に従おうとするとしても、すべてのパッケージに対する完全に一般的な命名規則を定義することは不可能です。
		</para>
		 </sidebar> <para>
			もう少しうまい検索パターンはパッケージ名の中をプレーンテキスト検索することですが、この方法も大きな制約を受けます。通常、パッケージ説明を検索すれば何らかの結果が得られるでしょう。すなわち、大体のパッケージはパッケージ名だけでなく詳細さに違いはあるものの詳しい説明文を備えているため、パッケージ説明文のキーワード検索はしばしば役に立ちます。<command>apt-cache</command> と <command>axi-cache</command> はパッケージ説明のキーワード検索を行う際に選ぶツールです。従って、たとえば <command>apt-cache search video</command> は「video」というキーワードがパッケージ説明に含まれるすべてのパッケージのリストを返します。
		</para>
		 <para>
			より複雑な検索を行うには、<command>aptitude</command> などのより強力なツールが必要です。<command>aptitude</command> を使うことで、パッケージのメタ情報フィールドを指定した論理演算表現を使って検索できます。たとえば、以下のコマンドはパッケージ名に <literal>kino</literal> が含まれ、パッケージの説明文に<literal>ビデオ</literal>が含まれ、メンテナの名前に <literal>paul</literal> が含まれるパッケージを検索します。
		</para>
		 
<screen>$ <userinput>aptitude search kino~dビデオ~mpaul</userinput>
p   kino  - デジタルビデオデータ用ノンリニア編集ツール
$ <userinput>aptitude show kino</userinput>
パッケージ: kino
バージョン: 1.3.4-2.2+b2
状態: インストールされていません
優先度: 特別
セクション: video
メンテナ: Paul Brossier &lt;piem@debian.org&gt;
アーキテクチャ: amd64
展開サイズ: 8,300 k
依存: libasound2 (&gt;= 1.0.16), libatk1.0-0 (&gt;= 1.12.4), libavc1394-0
    (&gt;= 0.5.3), libavcodec57 (&gt;= 7:3.2.4) | libavcodec-extra57 (&gt;=
    7:3.2.4), libavformat57 (&gt;= 7:3.2.4), libavutil55 (&gt;= 7:3.2.4),
    libc6 (&gt;= 2.14), libcairo2 (&gt;= 1.2.4), libdv4 (&gt;= 1.0.0),
    libfontconfig1 (&gt;= 2.11), libfreetype6 (&gt;= 2.2.1), libgcc1 (&gt;=
    1:3.0), libgdk-pixbuf2.0-0 (&gt;= 2.22.0), libglade2-0 (&gt;=
    1:2.6.4-2~), libglib2.0-0 (&gt;= 2.16.0), libgtk2.0-0 (&gt;= 2.24.0),
    libice6 (&gt;= 1:1.0.0), libiec61883-0 (&gt;= 1.2.0), libpango-1.0-0 (&gt;=
    1.14.0), libpangocairo-1.0-0 (&gt;= 1.14.0), libpangoft2-1.0-0 (&gt;=
    1.14.0), libquicktime2 (&gt;= 2:1.2.2), libraw1394-11, libsamplerate0
    (&gt;= 0.1.7), libsm6, libstdc++6 (&gt;= 5.2), libswscale4 (&gt;= 7:3.2.4),
    libx11-6, libxext6, libxml2 (&gt;= 2.7.4), libxv1, zlib1g (&gt;=
    1:1.1.4)
推奨: ffmpeg, curl
提案: udev | hotplug, vorbis-tools, sox, mjpegtools, lame,
    ffmpeg2theora
競合: kino-dvtitler, kino-timfx, kinoplus
置換: kino-dvtitler, kino-timfx, kinoplus
提供: kino-dvtitler, kino-timfx, kinoplus
説明: デジタルビデオデータ用ノンリニア編集ツール
 Kino で、DV
 カメラで録画された動画を記録、作成、編集、再生できるようになり
 ます。このプログラムには多くのキーボードコマンドがあり、動画内を高速
 に移動 し編集できます。

 プラグイン集 kino-timfx, kino-dvtitler, kinoplus
 は、以前は個別のパッケージ として配布していましたが、現在は Kino
 に同梱しています。
ホームページ: http://www.kinodv.org/
タグ: field::arts, hardware::camera, implemented-in::c,
      implemented-in::c++, interface::graphical, interface::x11,
      role::program, scope::application, suite::gnome, uitoolkit::gtk,
      use::editing, use::learning, works-with::video, x11::application</screen>
		 <para>
			この検索は、3 つの基準すべてを満足するパッケージ、<emphasis role="pkg">kino</emphasis>、を 1 つだけ返します。
		</para>
		 <para>
			このように複数条件を指定する検索はちょっと扱いにくいことが理由であまり使われません。そんなわけで、新しいタグ付けシステムが開発され、このシステムによって新しい検索方法が提供されました。パッケージには、「ファセット分類」として知られているさまざまな側面に従ってテーマ別に分類された、タグが付けられています。上に挙げた <emphasis role="pkg">kino</emphasis> の場合、パッケージのタグによれば、Kino は Gnome ベースのソフトウェアで、動画データの処理に有用であり、主用途は編集であることがわかります。
		</para>
		 <para>
			ファセット分類されたタグは既知の必要性に関連するパッケージを検索するのに便利です。さらにたとえ大量の (少しの) パッケージがヒットした場合でも、残りの検索は手作業でできます。タグに基づく検索を行うには <command>aptitude</command> で <literal>~G</literal> 検索パターンを使いますが、タグを管理しているサイトを見て回るほうがおそらく簡単です。<ulink type="block" url="https://debtags.debian.org/" />
		</para>
		 <indexterm>
			<primary><emphasis role="pkg">debtags</emphasis></primary>
		</indexterm>
		 <indexterm>
			<primary>タグ</primary>
		</indexterm>
		 <para>
			<literal>works-with::video</literal> と <literal>use::editing</literal> タグを選ぶと、<emphasis role="pkg">kino</emphasis> と <emphasis role="pkg">pitivi</emphasis> 動画編集ソフトウェアを含む、一握りのパッケージがヒットします。タグ付けシステムは時間がたてばたつほど必ず使われるようになるでしょう。そしてパッケージマネージャはタグに基づく効率的な検索インターフェースを少しずつ提供するでしょう。
		</para>
		 <para>
			要約すると、検索したい内容の複雑さに依存して、最良の検索ツールも変わりうるということです。
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					数個のキーワードにマッチする特定のパッケージを探す場合、パッケージ名とパッケージ説明だけを検索対象にしている <command>apt-cache</command> がとても便利です。
				</para>

			</listitem>
			 <listitem>
				<para>
					検索条件にパッケージ間の関連性やたとえばメンテナの名前などのメタ情報を含めたい場合には、<command>synaptic</command> が役に立つでしょう。
				</para>

			</listitem>
			 <listitem>
				<para>
					タグに基づいて検索したい場合、<command>packagesearch</command> が良いツールです。これは複数の条件 (パッケージに含まれるファイルの名前も含みます) に基づいて利用できるパッケージを検索する専用のグラフィカルインターフェースです。コマンドラインで使う場合は、<command>axi-cache</command> がぴったりでしょう。
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">packagesearch</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary><command>axi-cache</command></primary>
				</indexterm>

			</listitem>
			 <listitem>
				<para>
					最後に、論理演算を組み合わせた複雑な表現で検索したい場合、<command>aptitude</command> の検索パターン構文を使うことになるでしょう。これはいささか分かりにくいですが非常に強力です。さらに、<command>aptitude</command> はコマンドラインと対話型モードの両方で使えます。
				</para>

			</listitem>

		</itemizedlist>

	</section>
</chapter>

