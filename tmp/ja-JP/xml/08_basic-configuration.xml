<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="basic-configuration" lang="ja-JP">
	<chapterinfo>
		 <keywordset>
			<keyword>設定</keyword>
			 <keyword>地域化</keyword>
			 <keyword>ロケール</keyword>
			 <keyword>ネットワーク</keyword>
			 <keyword>名前解決</keyword>
			 <keyword>ユーザ</keyword>
			 <keyword>グループ</keyword>
			 <keyword>アカウント</keyword>
			 <keyword>コマンドラインインタプリタ</keyword>
			 <keyword>シェル</keyword>
			 <keyword>印刷</keyword>
			 <keyword>ブートローダ</keyword>
			 <keyword>カーネルのコンパイル</keyword>

		</keywordset>

	</chapterinfo>
	 <title>基本設定、ネットワーク、アカウント、印刷...</title>
	 <highlights> <para>
		<command>debian-installer</command> を使って新規にインストールしたコンピュータは可能な限り実用的に設定されます。とは言うものの、多くのサービスには設定の余地が残っています。さらに、管理者は最初のインストール中に設定された特定の項目の内容を変更する方法も必ず知っておくべきです。
	</para>
	 </highlights> <para>
		この章では「基本設定」と呼ばれている内容についてすべてを見直します。具体的に言えば、ネットワーク、言語とロケール、ユーザとグループ、印刷、マウントポイントなどの設定を見直します。
	</para>
	 <section id="sect.config-language-support">
		<title>他の言語用にシステムを設定</title>
		 <indexterm>
			<primary>日本語化</primary>
		</indexterm>
		 <para>
			日本語を使ってシステムをインストールした場合、既に日本語がデフォルト言語になっているかもしれません。しかし、インストーラが言語を設定する際にやっていることを知っておくべきです。こうしておくことで、後から必要になった際に言語を切り替えることが可能になります。
		</para>
		 <sidebar> <title><emphasis>TOOL</emphasis> 現在の設定を表示する <command>locale</command> コマンド</title>
		 <para>
			<command>locale</command> コマンドは、ロケールの設定を動的に変更するために設けられた標準的な環境変数の形で、さまざまなロケール関連パラメータ (日付フォーマット、番号フォーマットなど) の現在の設定の概要を表示します。
		</para>
		 </sidebar> <section id="sect.default-language">
			<title>デフォルト言語の設定</title>
			 <indexterm>
				<primary>ロケール</primary>
			</indexterm>
			 <indexterm>
				<primary>言語</primary>
			</indexterm>
			 <indexterm>
				<primary><command>locale-gen</command></primary>
			</indexterm>
			 <para>
				ロケールとは地域に関する設定項目全体を指します。ロケールの内容には表示言語だけでなく、番号、日付、時間、通貨の表示書式、アルファベット比較則 (アクセント付き文字を使う言語では適切な設定が必要) が含まれます。各パラメータは独立に設定できますが、通常は同じロケールを使います。こうすることで、広い意味で「地域」に関連するパラメータに一貫性を持たせることが可能になります。ロケールは通常 <literal><replaceable>language-code</replaceable>_<replaceable>COUNTRY-CODE</replaceable></literal> の書式で表され、文字セットとエンコーディングを表すためにサフィックスを付けられる場合もあります。こうすることで、共通の言語を異なる地域で使う場合の、慣習や書体の違いを考慮することが可能になります。
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> 文字セット</title>
			 <indexterm>
				<primary>文字セット</primary>
			</indexterm>
			 <indexterm>
				<primary>エンコーディング</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-1</primary>
			</indexterm>
			 <indexterm>
				<primary>ISO-8859-15</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 1</primary>
			</indexterm>
			 <indexterm>
				<primary>Latin 9</primary>
			</indexterm>
			 <para>
				歴史的に言って、各ロケールは関連する「文字セット」(既知の文字のグループ) と推奨される「エンコーディング」(コンピュータにおける文字の内部表現) を持っていました。
			</para>
			 <para>
				ラテン語由来の言語で最も人気のあるエンコーディングの文字数は 256 文字に制限されています。なぜなら、それらのエンコーディングでは 1 文字を 1 バイトで表現するよう定めているからです。256 文字ではすべてのヨーロッパ系言語をカバーできなかったため、複数のエンコーディングが必要になり、<emphasis>ISO-8859-1</emphasis> (「Latin 1」としても知られる) から <emphasis>ISO-8859-15</emphasis> (「Latin 9」としても知られる) までが定められました。
			</para>
			 <para>
				外国語を使って仕事することは日常的に複数のエンコーディングと文字セットを切り替えることを意味していました。さらに、多言語文書を書くことはさらに難しく、ほとんど手に負えない問題でした。この問題に対処するために Unicode (全世界の言語のほぼすべての表記体系の巨大なカタログ) が作られました。Unicode エンコーディングの 1 つである UTF-8 は 128 ASCII 文字 (7 ビットコード) と互換性を保ちながら、他の文字を別のやり方で取り扱います。非 ASCII 文字は数ビットの特殊なエスケープシーケンスで始まり、このエスケープシーケンスが文字の長さを暗黙のうちに定義します。このことにより、1 バイトから数バイトのシーケンスで全 Unicode 文字の符号化が可能になります。UTF-8 は XML 文書のデフォルトエンコーディングだったため広く使われています。
			</para>
			 <indexterm>
				<primary>ASCII</primary>
			</indexterm>
			 <indexterm>
				<primary>UTF-8</primary>
			</indexterm>
			 <indexterm>
				<primary>Unicode</primary>
			</indexterm>
			 <para>
				通常のエンコーディングは UTF-8 を使うべきで、Debian システムでは UTF-8 をデフォルトエンコーディングとしています。
			</para>
			 </sidebar> <para>
				<emphasis role="pkg">locales</emphasis> パッケージには、さまざまなアプリケーションの「地域化」を適切に動作させるために必要なすべての要素が含まれます。インストールの最中、<emphasis role="pkg">locales</emphasis> パッケージはシステムがサポートする言語を選択するよう求めます。システムがサポートする言語を変更するには、root で <command>dpkg-reconfigure locales</command> を実行してください。
			</para>
			 <para>
				<emphasis role="pkg">locales</emphasis> パッケージのインストール中、最初の質問でサポートしたい「ロケール」を選択します。すべての英語ロケール (つまり「<literal>en_</literal>」で始まるロケール) を有効化するのが合理的です。外国人ユーザがマシンを使う場合、ためらわずに他の言語も有効化してください。システムがサポートするロケールのリストは <filename>/etc/locale.gen</filename> ファイルに保存されています。<filename>/etc/locale.gen</filename> ファイルを手作業で編集することも可能ですが、変更が終わったら <command>locale-gen</command> を実行するべきです。<command>locale-gen</command> は追加されたロケールを動作させるために必要なファイルを生成し、古いファイルを削除します。
			</para>
			 <para>
				2 番目の質問は「システム環境のデフォルトロケール」と銘打たれ、ここでデフォルトロケールを選択します。アメリカ合衆国では「<literal>en_US.UTF-8</literal>」を選ぶことを推奨します。イギリス英語話者は「<literal>en_GB.UTF-8</literal>」、カナダ人は「<literal>en_CA.UTF-8</literal>」またはフランス語の「<literal>fr_CA.UTF-8</literal>」のどちらかを好むでしょう。その後、デフォルトロケールを保存する <filename>/etc/default/locale</filename> ファイルが修正されます。これ以降、設定されたデフォルトロケールがすべてのユーザセッションに適用されます。なぜなら、PAM が <varname>LANG</varname> 環境変数内に <filename>/etc/default/locale</filename> ファイルの内容を代入するからです。
			</para>
			 <indexterm>
				<primary>環境</primary>
			</indexterm>
			 <indexterm>
				<primary>ロケール</primary>
			</indexterm>
			 <indexterm>
				<primary><varname>LANG</varname></primary>
			</indexterm>
			 <sidebar id="sidebar.intro-pam"> <title><emphasis>BEHIND THE SCENES</emphasis> <filename>/etc/environment</filename> と <filename>/etc/default/locale</filename></title>
			 <para>
				<filename>/etc/environment</filename> ファイルには <command>login</command>、<command>gdm</command>、<command>ssh</command> プログラムが設定する正しい環境変数が含まれています。
			</para>
			 <para>
				これらのアプリケーションは環境変数を直接設定するものではありませんが、PAM (<filename>pam_env.so</filename>) モジュール経由で環境変数を設定します。PAM (Pluggable Authentication Module) は認証、セッション初期化、パスワード管理のメカニズムを一元管理化するモジュール式のライブラリです。PAM 設定の例は<xref linkend="sect.config-pam" />をご覧ください。
			</para>
			 <para>
				<filename>/etc/default/locale</filename> ファイルも同様に動作しますが、ファイルに含まれているのは <varname>LANG</varname> 環境変数だけです。このようにファイルを分離しているおかげで、一部の PAM ユーザは地域化せずに完全な環境を継承できます。実際のところ、サーバプログラムを地域化した状態で実行することは推奨されません。その一方で、ユーザセッションを開くプログラムが地域化と地域設定を行うことは推奨されます。
			</para>
			 <indexterm>
				<primary>PAM</primary>
			</indexterm>
			 <indexterm>
				<primary><filename>pam_env.so</filename></primary>
			</indexterm>
			 </sidebar>
		</section>
		 <section id="sect.keyboard-config">
			<title>キーボードの設定</title>
			 <indexterm>
				<primary>キーボードレイアウト</primary>
			</indexterm>
			 <indexterm>
				<primary>レイアウト、キーボード</primary>
			</indexterm>
			 <para>
				キーボードレイアウトの管理方法がコンソールとグフラフィカルモードで違っていたとしても、Debian には両方を設定できる単一の設定インターフェースが提供されています。設定インターフェースは debconf に基づいており、<emphasis role="pkg">keyboard-configuration</emphasis> パッケージに実装されています。キーボードレイアウトをリセットする際には、<command>dpkg-reconfigure keyboard-configuration</command> を使います。
			</para>
			 <indexterm>
				<primary><emphasis>console-data</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>console-tools</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>keyboard-configuration</emphasis></primary>
			</indexterm>
			 <para>
				<indexterm><primary><literal>QWERTY</literal></primary></indexterm>ここでは、キーボードモデル (日本で使われる一般的な PC キーボードの場合「標準 105 キー (国際) PC」)、キーボードレイアウト (通常「日本語」)、AltGr キーの場所 (「キーボード配置のデフォルト」) について質問されます。最後に「Compose キー」として使うキーが質問されます (「コンポーズキーなし」)。Compose キーはキーストロークを組み合わせて特殊文字を入力する際に使われます。<keycombo action="seq"><keycap>Compose</keycap><keycap>'</keycap><keycap>e</keycap></keycombo> を入力すると、アクセント付き e「é」が入力できるはずです。キーストロークの組み合わせは <filename>/usr/share/X11/locale/ja_JP.UTF-8/Compose</filename> ファイル (または、<filename>/usr/share/X11/locale/compose.dir</filename> に書かれた現在のロケールに従って定義された別ファイル) に記述されています。
			</para>
			 <indexterm>
				<primary><literal>Compose</literal>、キー</primary>
			</indexterm>
			 <indexterm>
				<primary><literal>メタ</literal>、キー</primary>
			</indexterm>
			 <indexterm>
				<primary>キー</primary>
				<secondary><literal>メタ</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary>キー</primary>
				<secondary><literal>Compose</literal></secondary>
			</indexterm>
			 <para>
				ここで述べたグラフィカルモードのキーボード設定によって影響を受けるのはデフォルトレイアウトだけです。特に GNOME と KDE 環境では、環境設定の中にキーボードコントロールパネルがあり、これを使うことで各ユーザが固有のキーボードを設定することが可能です。特別なキーの挙動に関する追加的オプションもこのコントロールパネルから設定できます。
			</para>

		</section>
		 <section id="sect.utf8-migration">
			<title>UTF-8 への移行</title>
			 <para>
				UTF-8 エンコーディングのような一般化は、相互運用性の多くの困難を解決できるとして、長く待ち望まれていました。なぜなら、一般化することで、国際交流が簡単になり、文書で使うことのできる文字を好き勝手に制限する必要がなくなるからです。こうすることによる欠点の 1 つが、厳しい移行期間を切り抜けなければいけない点です。移行期間は完全に透過的にできない (つまり、全世界で同時に移行することはできない) ため、2 つの変換操作が必要です。具体的に言えば、ファイル内容とファイル名のエンコーディングを変換する必要があります。幸いなことに、この移行はほとんど完了していますが、参考までに大筋を議論します。
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> <foreignphrase>文字化け</foreignphrase>と解釈エラー</title>
			 <para>
				エンコーディング情報なしにテキストが送信 (または保存) された場合、受信者にとって、どのような変換を使えばバイトセットの意味を決定できるかを確定することは、常に可能なことではありません。通常、テキスト内に存在する値の分布の統計を取ることで、変換に必要な情報を得ることができますが、常に確定的な答えを得られるわけではありません。読み出し時に使ったエンコーディングシステムが書き込み時に使ったものと異なる場合、バイトセットは間違って解釈され、良くてもいくつかの文字が間違って表示され、悪ければ全く判読できなくなります。
			</para>
			 <para>
				そんなわけで、フランス語テキストが「Ã©」、「Ã¨」、「Ã§」などの文字列で置き換えらたアクセント付き文字と若干の記号を除いて正常に表示された場合、これはおそらく UTF-8 にエンコードされたファイルを ISO-8859-1 または ISO-8859-15 で解釈して表示したということでしょう。この状況は、ローカル設定がまだ UTF-8 に移行されていないことの証です。逆に、アクセント付き文字ではなく疑問符が表示され、さらにその疑問符をアクセント付き文字とその後に続く適当な文字に置き換えることができそうな場合、ローカル設定は既に UTF-8 に移行されていて西欧の ISO でエンコードされていたファイルを UTF-8 で解釈して表示したということかもしれません。
			</para>
			 <para>
				「単純な」場合はそんなところです。西欧言語圏ではこれだけで済むかもしれません。なぜなら、Unicode (と UTF-8) はラテンアルファベットに基づく西欧言語向けの歴史的なエンコーディングとの共通点を最大化するように設計されたからです。このため、いくつかの文字が欠落してもテキストの一部を理解できるのです。
			</para>
			 <para>
				より複雑な構成の場合、たとえば異なる文字体系を使う 2 つの異なる言語向けの 2 つの環境の間で情報をやり取りする場合、全く判読できない結果 (互いに関連性のない抽象記号) が表示されることが多いです。アジア圏では、言語と表記体系が数多くあるために、このような状況が良く起こります。<foreignphrase>文字化け</foreignphrase>という日本の言葉がこの状況を言い表すために使われ続けています。<foreignphrase>文字化け</foreignphrase>した場合、原因分析はさらに複雑です。<foreignphrase>文字化け</foreignphrase>に対する元も単純な解決策は双方が UTF-8 に移行することです。
			</para>
			 </sidebar> <para>
				ファイル名だけについて言えば、移行は比較的単純です。<command>convmv</command> ツール (同名のパッケージに含まれます) はこの目的専用に作られました。従って、これはファイル名をあるエンコーディングから他のエンコーディングに変更します。このツールの使い方は比較的単純ですが、意図しない変換を避けるために 2 段階に分けて行うことを推奨します。以下の例では、ISO-8859-15 でエンコードされたディレクトリ名を含む UTF-8 環境で、<command>convmv</command> を使ってディレクトリ名をリネームする方法を示しています。
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Ic?nes  ?l?ments graphiques  Textes
$ </computeroutput><userinput>convmv -r -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>Starting a dry run without changes...
mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
No changes to your files done. Use --notest to finally rename the files.
$ </computeroutput><userinput>convmv -r --notest -f iso-8859-15 -t utf-8 travail/</userinput>
<computeroutput>mv "travail/�l�ments graphiques"        "travail/Éléments graphiques"
mv "travail/Ic�nes"     "travail/Icônes"
Ready!
$ </computeroutput><userinput>ls travail/</userinput>
<computeroutput>Éléments graphiques  Icônes  Textes</computeroutput></screen>
			 <para>
				ファイル内容について言えば、既存のファイルフォーマットにはたくさんの種類があるため、変換手順はさらに複雑になります。いくつかのファイルフォーマットにはエンコーディング情報が含まれているため、そのフォーマットを取り扱うソフトウェアは適切にエンコーディング情報を取り扱うことが可能です。さらにこの場合、ファイルを開いて UTF-8 エンコーディングを指定して再保存するだけ十分です。その他の場合、そのファイルを開く際に元のエンコーディングを指定 (形式に従って ISO-8859-1 や「西欧」、ISO-8859-15 や「西欧 (ユーロ)」など) しなければいけません。
			</para>
			 <para>
				単純なテキストファイルの場合、<command>recode</command> (同名のパッケージに含まれます) を使えば自動的にエンコーディングを変換できます。このツールは数多くのオプションを備えていますので、いろいろと試してみてください。<citerefentry> <refentrytitle>recode</refentrytitle>
				 <manvolnum>1</manvolnum> </citerefentry> man ページ、<citerefentry> <refentrytitle>recode</refentrytitle>
				 </citerefentry> info ページ (より詳しい) などの文書を調べることもお勧めします。
			</para>

		</section>

	</section>
	 <section id="sect.network-config">
		<title>ネットワークの設定</title>
		 <sidebar id="sidebar.networking-basics"> <title><emphasis>BACK TO BASICS</emphasis> ネットワークの本質的概念 (イーサネット、IP アドレス、サブネット、ブロードキャスト)</title>
		 <indexterm>
			<primary>イーサネット</primary>
		</indexterm>
		 <indexterm>
			<primary>10BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>100BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>1000BASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>10GBASE-T</primary>
		</indexterm>
		 <indexterm>
			<primary>コネクタ、RJ45</primary>
		</indexterm>
		 <indexterm>
			<primary>RJ45 コネクタ</primary>
		</indexterm>
		 <para>
			多くの現代的なローカルネットワークがイーサネットプロトコルを使っています。データはフレームと呼ばれる小さなブロックに分割され、一度に 1 つのフレームがワイヤ上で転送されます。データ転送速度は古いイーサネットカードの 10 Mb/s から新しいカードの 10 Gb/s (現在最も一般的な速度は 100 Mb/s から 1 Gb/s) までさまざまあります。最も広く使われているケーブルは、確実に保証される転送速度に依存して 10BASE-T、100BASE-T、1000BASE-T、10GBASE-T と呼ばれています(T は「ツイストペア」を意味しています)。ケーブルの終端には RJ45 コネクタが付いています。他のケーブル型もあり、それらは 1 Gb/s 以上の速度で使われています。
		</para>
		 <indexterm>
			<primary>アドレス、IP アドレス</primary>
		</indexterm>
		 <indexterm>
			<primary>IP アドレス</primary>
		</indexterm>
		 <para>
			IP アドレスは、ローカルネットワークやインターネットでコンピュータのネットワークインターフェースを識別するために使われる番号です。IP の現在最も広く使われているバージョン (IPv4) では、IP アドレスは 32 ビットにエンコードされ、通常ピリオドで区切った 4 個の数字で表現されます (例 <literal>192.168.0.1</literal>)、それぞれの数字は 0 以上 255 以下です (8 ビットのデータに対応します)。IP の次期バージョン IPv6 では、アドレス空間を 128 ビットに拡張し、IP アドレスは通常コロンで区切られた 16 進数列で表されます (たとえば 2001:0db8:13bb:0002:0000:0000:0000:0020 などで、これは短縮形の場合 2001:db8:13bb:2::20 と表されます)。
		</para>
		 <indexterm>
			<primary>サブネット</primary>
		</indexterm>
		 <indexterm>
			<primary>マスク</primary>
			<secondary>サブネットマスク</secondary>
		</indexterm>
		 <indexterm>
			<primary>ネットワーク</primary>
			<secondary>アドレス</secondary>
		</indexterm>
		 <para>
			サブネットマスク (ネットマスク) は 2 進コードの形で、ある IP アドレスのネットワークに相当する部分を定義します。残りの部分はマシンに相当する部分を定義します。ここで挙げる静的 IPv4 アドレスの設定例では、サブネットマスク <literal>255.255.255.0</literal> (2 進数表記では 24 個の「1」の後に 8 個の「0」が並ぶ) は IP アドレスの最初の 24 ビット分がネットワークアドレスに対応し、残りの 8 ビット分がマシンに固有のアドレスであることを意味しています。IPv6 では可読性を高めるためにネットマスクを 2 進数表記した際に「1」となるビットの個数で表すので、ネットマスクは <literal>64</literal> のように書けます。
		</para>
		 <para>
			ネットワークアドレスは IP アドレスの一種で、マシン番号を表現する部分は 0 で表されます。完全なネットワークにおける IPv4 アドレスの範囲は通常 <emphasis>a.b.c.d/e</emphasis> という構文で表現されます。ここで、<emphasis>a.b.c.d</emphasis> はネットワークアドレスで <emphasis>e</emphasis> は IP アドレスのネットワーク部分を表すビット数です。つまり例のネットワークは <literal>192.168.0.0/24</literal> のように表現されます。IPv6 の場合も構文は似ており、<literal>2001:db8:13bb:2::/64</literal> のように表現されます。
		</para>
		 <indexterm>
			<primary>ルータ</primary>
		</indexterm>
		 <indexterm>
			<primary>ブリッジ</primary>
		</indexterm>
		 <para>
			ルータとは、複数のネットワークを相互に接続するマシンです。ルータを通過するすべてのトラフィックは接続されたネットワークに誘導されます。これを行うために、ルータは着信パケットを解析し、宛先の IP アドレスに従ってパケットを転送します。ルータは通常ゲートウェイとしても知られています。ルータがゲートウェイの役割を果たす場合、ルータはローカルネットワークを越える (インターネットなどの外部ネットワークに向かう) ためのマシンとして機能します。
		</para>
		 <indexterm>
			<primary>ブロードキャスト</primary>
		</indexterm>
		 <para>
			ブロードキャストアドレスは特殊なアドレスでネットワークにいるすべてのマシンに対応付けられています。ブロードキャストアドレスは、ほとんど「転送され」ませんし、当該のネットワークだけを対象に働きます。具体的に言うと、ブロードキャスト宛のデータパケットはルータを通過しないことを意味しています。
		</para>
		 <para>
			この章では IPv4 アドレスだけに注目します。なぜなら IPv4 アドレスは現在最も一般的に利用されているからです。IPv6 プロトコルの詳細は<xref linkend="sect.ipv6" />で説明されていますが、その概念は IPv4 と同じです。
		</para>
		 </sidebar> <para>
			ネットワークは初回インストール時に自動設定されますので、<filename>/etc/network/interfaces</filename> ファイルには既にさまざまな設定が含まれています。<literal>auto</literal> で始まる行は、起動時に <emphasis role="pkg">ifupdown</emphasis> と <filename>/etc/init.d/networking</filename> init スクリプトで自動的に設定したい、インターフェースのリストです。通常 <literal>eth0</literal> は自動設定したいインターフェースで、1 つ目のイーサネットカードを意味しています。
		</para>
		 <indexterm>
			<primary>ネットワーク</primary>
			<secondary>設定</secondary>
		</indexterm>
		 <indexterm>
			<primary>設定</primary>
			<secondary>ネットワークの設定</secondary>
		</indexterm>
		 <indexterm>
			<primary>インターフェース</primary>
			<secondary>ネットワークインターフェース</secondary>
		</indexterm>
		 <indexterm>
			<primary><literal>eth0</literal></primary>
		</indexterm>
		 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> NetworkManager</title>
		 <indexterm>
			<primary><emphasis role="pkg">network-manager</emphasis></primary>
		</indexterm>
		 <para>
			NetworkManager はマシンを移動して使う場合に特に推奨され (<xref linkend="sect.roaming-network-config" />を参照してください)、デフォルトのネットワーク管理ツールとしても極めて便利です。コンピュータの起動の可能な限り早い段階で使われる「システム接続」を作るには、<filename>/etc/NetworkManager/system-connections/</filename> 内の <filename>.ini</filename> 系ファイルを手作業で編集するか、またはグラフィカルツール (<command>nm-connection-editor</command>) を使います。NetworkManager でネットワーク接続を管理する場合、<filename>/etc/network/interfaces</filename> に含まれるすべてのエントリを無効化するのを忘れないでください。<ulink type="block" url="https://wiki.gnome.org/Projects/NetworkManager/SystemSettings/jessie" /><ulink type="block" url="https://developer.gnome.org/NetworkManager/0.9/ref-settings.html" />
		</para>
		 </sidebar> <section id="sect.interface-ethernet">
			<title>イーサネットインターフェース</title>
			 <para>
				コンピュータにイーサネットカードが付けられている場合、イーサネットカードに関連付けられる IP ネットワークは 1 つか 2 つの方法で必ず設定されなければいけません。最も簡単な方法は DHCP を使う動的設定で、これにはローカルネットワークで DHCP サーバを動かす必要があります。動的設定では、以下の例で <literal>hostname</literal> 設定に対応する、希望ホスト名を示すことが可能です。そして、DHCP サーバは適切なネットワーク設定を送信します。
			</para>
			 <indexterm>
				<primary>イーサネット</primary>
			</indexterm>
			 <indexterm>
				<primary>DHCP</primary>
			</indexterm>
			 <example id="example.config-dhcp">
				<title>DHCP 設定</title>
				 
<programlisting>
auto eth0
iface eth0 inet dhcp
  hostname arrakis</programlisting>

			</example>
			 <para>
				「静的」設定の場合、必ず決められた方法でネットワーク設定を定義しなければいけません。「静的」設定には少なくとも IP アドレスとサブネットマスクが含まれます。さらに場合によってはネットワークとブロードキャストアドレスが含まれることがあります。ゲートウェイには外部に接続しているルータを指定します。
			</para>
			 <example id="example.static-network">
				<title>静的設定</title>
				 
<programlisting>
auto eth0
iface eth0 inet static
  address 192.168.0.3
  netmask 255.255.255.0
  broadcast 192.168.0.255
  network 192.168.0.0
  gateway 192.168.0.1</programlisting>

			</example>
			 <sidebar> <title><emphasis>NOTE</emphasis> 複数アドレス</title>
			 <para>
				複数のインターフェースに 1 つの物理ネットワークカードを関連付けることだけでなく、1 つのインターフェースに複数の IP アドレスを関連付けることも可能です。ある IP アドレスは DNS 経由で複数の名前に関連付けられているかもしれませんし、ある名前は複数の数値 IP アドレスに関連付けられているかもしれません。この点も忘れないでください。
			</para>
			 <para>
				お察しの通り、この設定はちょっと複雑で、この設定が必要になるのはとても特殊な場合だけです。ここで引用しているのは、典型的な通常設定の例です。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.ppp-rtc">
			<title>PSTN モデム経由の PPP 接続</title>
			 <indexterm>
				<primary>PPP</primary>
			</indexterm>
			 <indexterm>
				<primary>2 点間</primary>
			</indexterm>
			 <indexterm>
				<primary>接続</primary>
				<secondary>PSTN モデムを使った接続</secondary>
			</indexterm>
			 <indexterm>
				<primary>モデム</primary>
				<secondary>PSTN</secondary>
			</indexterm>
			 <para>
				2 点間 (PPP) 接続は断続的な接続を確立します。さらに PPP 接続は電話モデム (「PSTN モデム」とも呼ばれます。この名前は公衆交換電話網を経由して接続するところから付けられました) を使って接続する場合の最も一般的な接続方法です。
			</para>
			 <para>
				電話モデムを使って接続する場合、アクセスプロバイダのアカウント (電話番号、ユーザ名、パスワード) が必要で、認証プロトコルを使うこともあります。PPP 接続は <command>pppconfig</command> ツール (同名の Debian パッケージに含まれます) を使って設定されます。デフォルトで、<command>pppconfig</command> ツールは <literal>provider</literal> (インターネットサービスプロバイダのように) と名付けられた接続を設定します。認証プロトコルがよく分からなければ、<emphasis>PAP</emphasis> を使ってください。大多数のインターネットサービスプロバイダは <emphasis>PAP</emphasis> を提供しています。
			</para>
			 <indexterm>
				<primary><command>pppconfig</command></primary>
			</indexterm>
			 <indexterm>
				<primary>PAP</primary>
			</indexterm>
			 <para>
				設定が完了したら、<command>pon</command> コマンドを使って接続することが可能です (デフォルト接続名である <literal>provider</literal> が適切でない場合、接続名をパラメータとして与えてください)。リンクを切断するには <command>poff</command> コマンドを使ってください。これら 2 つのコマンドを実行できるのは、root ユーザと <literal>dip</literal> グループに所属するユーザだけです。
			</para>
			 <indexterm>
				<primary><command>pon</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>poff</command></primary>
			</indexterm>

		</section>
		 <section id="sect.adsl">
			<title>ADSL モデム経由の接続</title>
			 <indexterm>
				<primary>接続</primary>
				<secondary>ADSL モデムによる接続</secondary>
			</indexterm>
			 <indexterm>
				<primary>モデム</primary>
				<secondary>ADSL</secondary>
			</indexterm>
			 <indexterm>
				<primary>ADSL、モデム</primary>
			</indexterm>
			 <para>
				「ADSL モデム」という一般名称の意味には、全く違う機能を持つ数多くの装置が含まれています。Linux で使うのが最も簡単なモデムはイーサネットインターフェースを持つものです (USB インターフェースではありません)。この種のモデムは人気になりつつあります。さらに、多くの ADSL インターネットサービスプロバイダはイーサネットインターフェース付きの「ボックス」を貸与します (またはリースします)。モデムの種類に依存して、必要な設定は広範囲にわたります。
			</para>
			 <section id="sect.adsl-pppoe">
				<title>PPPOE をサポートするモデム</title>
				 <indexterm>
					<primary>PPPOE</primary>
				</indexterm>
				 <indexterm>
					<primary><command>pppoeconf</command></primary>
				</indexterm>
				 <para>
					一部のイーサネットモデムは PPPOE プロトコル (Point to Point Protocol over Ethernet) に対応しています。PPPOE 接続を設定するには、<command>pppoeconf</command> ツール (同名のパッケージに含まれます) を使います。PPPOE 接続を設定するために、<command>pppoeconf</command> ツールは与えられた設定で <filename>/etc/ppp/peers/dsl-provider</filename> ファイルを修正し、ログイン情報を <filename>/etc/ppp/pap-secrets</filename> と <filename>/etc/ppp/chap-secrets</filename> ファイルに記録します。<command>pppoeconf</command> ツールが提案したすべての変更を受け入れることを推奨します。
				</para>
				 <para>
					この設定が完了したら、<command>pon dsl-provider</command> で ADSL 接続を開始、<command>poff dsl-provider</command> で切断できます。
				</para>
				 <indexterm>
					<primary><literal>dsl-provider</literal></primary>
				</indexterm>
				 <sidebar> <title><emphasis>TIP</emphasis> 起動時に <command>ppp</command> を開始</title>
				 <indexterm>
					<primary><command>systemd</command></primary>
				</indexterm>
				 <indexterm>
					<primary><command>init</command></primary>
				</indexterm>
				 <para>
					定義によれば、ADSL 上の PPP 接続は断続的なものです。しかしながら、通常サービスプロバイダは時間に依存して従量課金しないので、常に接続状態を保つという誘惑に対して、ほとんど不利な点はありません。常時接続状態を保つ標準的な方法は init システムを使うことです。
				</para>
				 <para>
					<emphasis role="distribution">Jessie</emphasis> のデフォルト init システムは <command>systemd</command> です。ADSL 接続用の自動再開タスクを追加するには、以下の内容を含む <filename>/etc/systemd/system/adsl-connection.service</filename> などの「ユニットファイル」を作成するだけで簡単に行うことが可能です。
				</para>
				 
<programlisting>[Unit]
Description=ADSL connection

[Service]
Type=forking
ExecStart=/usr/sbin/pppd call dsl-provider
Restart=always

[Install]
WantedBy=multi-user.target</programlisting>
				 <para>
					このユニットファイルの配置を完了したら、<command>systemctl enable adsl-connection</command> を実行してこれを有効化する必要があります。その後手作業で <command>systemctl start adsl-connection</command> を実行してループを開始します。起動時にはこれが自動的に実行されます。
				</para>
				 <para>
					<command>systemd</command> を使っていないシステム (Debian <emphasis role="distribution">Wheezy</emphasis> およびそれ以前のバージョンのシステム) では、標準的な SystemV init を別の方法で設定します。このようなシステムでは、<filename>/etc/inittab</filename> ファイルの最後に以下の 1 行を追加するだけで設定は完了します。このように設定することで、接続が切断されたらいつでも、<command>init</command> が再接続を試行するようになります。
				</para>
				 
<programlisting>
adsl:2345:respawn:/usr/sbin/pppd call dsl-provider</programlisting>
				 <para>
					ADSL 接続が 1 日に 1 回自動切断されるような場合、この方法を取ることで、通信が遮断される期間を短くすることが可能です。
				</para>
				 </sidebar>
			</section>
			 <section id="sect.adsl-pptp">
				<title>PPTP をサポートするモデム</title>
				 <indexterm>
					<primary>PPTP</primary>
				</indexterm>
				 <para>
					PPTP (Point-to-Point Tunneling Protocol) プロトコルは Microsoft によって作られました。PPTP は 初期の ADSL で使われましたが、すぐに PPPOE によって置き換えられました。PPTP を使わなければいけない場合は、<xref linkend="sect.pptp" />をご覧ください。
				</para>

			</section>
			 <section id="sect.adsl-dhcp">
				<title>DHCP をサポートするモデム</title>
				 <para>
					モデムとコンピュータがイーサネットケーブル (クロスケーブル) で接続されている場合、通常は DHCP でコンピュータのネットワーク接続を設定します。さらにそのようなモデムは自動的にデフォルトでゲートウェイとして働き、ルーティングを処理します (これは、モデムがコンピュータとインターネットの間のネットワークトラフィックを管理することを意味しています)。
				</para>
				 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> 直接イーサネット接続用のクロスケーブル</title>
				 <indexterm>
					<primary>クロスケーブル</primary>
				</indexterm>
				 <para>
					コンピュータネットワークカードはケーブルの特定のワイヤからデータを受信し、別のワイヤからデータを送信します。コンピュータをローカルネットワークに接続する場合、通常ネットワークカードとリピータまたはスイッチの間をケーブル (ストレートまたはクロスケーブル) で接続します。しかしながら、2 台のコンピュータを直接 (中間にスイッチやリピータを介さずに) 接続したい場合、必ず送信側カードからみた送信ワイヤに伝わる信号を受信側カードからみた受信ワイヤに (その逆も) 伝送させなければいけません。これがクロスケーブルの目的であり、クロスケーブルが使われる理由です。
				</para>
				 <para>
					ケーブルの種類を区別して用途に合わせて使うという作業は、時間とともにほとんど無意味な作業になりつつある点に注意してください。なぜなら、最近のネットワークカードはケーブルの種類を検出して適切に適用できるからです。従って、ある場所で両方の種類のケーブルが使えるというのは異常ではありません。
				</para>
				 </sidebar> <para>
					市場に出ている多くの「ADSL ルータ」とインターネットサービスプロバイダによって提供されるほとんどの ADSL モデムはこのような方法で使われます。
				</para>

			</section>

		</section>
		 <section id="sect.roaming-network-config">
			<title>ローミングユーザ向けの自動ネットワーク設定</title>
			 <indexterm>
				<primary><emphasis role="pkg">network-manager</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>ネットワーク</primary>
				<secondary>ローミング設定</secondary>
			</indexterm>
			 <para>
				Falcot の多くのエンジニアはラップトップコンピュータを持っており、自宅でも職務上の目的を果たすためにそれを使います。使用するネットワーク設定は場所によって異なります。自宅では wifi ネットワーク (WPA 鍵で保護されている) を使っているかもしれませんし、その一方で職場ではセキュリティと帯域幅を向上させるために有線ネットワークを使っています。
			</para>
			 <para>
				対応するネットワークインターフェースを手作業で接続したり切断するのを避けるために、管理者はローミングマシンに <emphasis role="pkg">network-manager</emphasis> パッケージをインストールしました。NetworkManager を使うと、ユーザはグラフィカルデスクトップの通知エリアに表示された小さなアイコンを使って、あるネットワークから別のネットワークに簡単に切り替えることが可能です。NetworkManager のアイコンをクリックすると、利用できるネットワーク (有線と無線の両方) のリストが表示されます。このためユーザは単純に使いたいネットワークを選ぶだけです。NetworkManager は接続済みのネットワークの設定を保存します。そして現在の接続が切断された場合、利用できるネットワークから最適なものを選んで、自動的に切り替えます。
			</para>
			 <para>
				これを行うために、NetworkManager プログラムは 2 つに分割されています。すなわち、ネットワークインターフェースの有効化と設定を担当している root として動くデーモンと、このデーモンを操作するユーザインターフェースの 2 つに分割されています。PolicyKit は NetworkManager プログラムを操作する際に要求される認証を取り扱います。Debian は PolicyKit を設定して、netdev グループが NetworkManager の接続を追加したり、変えることができるようにしています。
			</para>
			 <para>
				NetworkManager はさまざまな種類の接続 (DHCP、手作業設定、ローカルネットワーク) をサポートしていますが、設定をうまく動作させるには NetworkManager プログラム以外を使ってはいけません。このため、NetworkManager は <filename>/etc/network/interfaces</filename> に含まれるすべてのネットワークインターフェースのうち、不適切なものを系統的に無視します。NetworkManager はネットワーク接続が見つからない場合にその詳細を教えてくれないので、<filename>/etc/network/interfaces</filename> から NetworkManager で管理されるすべてのインターフェースに関する設定を削除するのが簡単です。
			</para>
			 <para>
				NetworkManager は最初のインストール中に「デスクトップ環境」タスクを選んだ場合にデフォルトでインストールされることに注意してください。
			</para>
			 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> 「ネットワークプロファイル」を使った設定</title>
			 <indexterm>
				<primary><emphasis role="pkg">guessnet</emphasis></primary>
			</indexterm>
			 <para>
				さらに熟練したユーザは、自動的にネットワークを設定するために <emphasis role="pkg">guessnet</emphasis> パッケージを試したくなるかもしれません。<emphasis role="pkg">guessnet</emphasis> パッケージは臨機応変に有効化および設定すべきネットワークプロファイルがどれかを判断する一連のテストスクリプト集です。
			</para>
			 <para>
				ネットワークプロファイルを手作業で選択するのを好むユーザは <emphasis role="pkg">netenv</emphasis> プログラムを好むかもしれません。このプログラムは同名のパッケージに含まれます。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.hostname-name-service">
		<title>ホスト名と名前解決サービスの設定</title>
		 <indexterm>
			<primary>名前</primary>
			<secondary>特定と解決</secondary>
		</indexterm>
		 <indexterm>
			<primary>名前割り当て</primary>
		</indexterm>
		 <para>
			IP 番号に名前を割り当てることで、マシンを識別する情報は覚えやすくなります。実際には、IP アドレスはネットワークカードなどのデバイスと関連付けられたネットワークインターフェースを識別するものです。それぞれのマシンは複数のネットワークカードを持つことが可能ですし、それぞれのカードに複数のインターフェースを持つことが可能ですので、1 台のコンピュータはドメインネームシステムに複数の名前を持つことが可能です。
		</para>
		 <para>
			しかしながら、それぞれのマシンは本名 (または「canonical」名) で識別されます。この名前は <filename>/etc/hostname</filename> ファイルに保存され、<command>hostname</command> コマンドを通じた初期化スクリプトを使って Linux カーネルに伝えられます。マシン名の現在の値は仮想ファイルシステムの中に保存されており、<command>cat /proc/sys/kernel/hostname</command> コマンドで値を確認できます。
		</para>
		 <indexterm>
			<primary><command>hostname</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> <filename>/proc/</filename> と <filename>/sys/</filename>、仮想ファイルシステム</title>
		 <indexterm>
			<primary><filename>/proc/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>proc</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/sys/</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>sys</filename></primary>
		</indexterm>
		 <para>
			<filename>/proc/</filename> と <filename>/sys/</filename> ファイルツリーは「仮想」ファイルシステムによって生成されます。仮想ファイルシステムは (仮想ファイルの内容を表示することで) カーネルから情報を回収したり、(仮想ファイルに書き込むことで) カーネルと情報をやり取りするための実用的な手段です。
		</para>
		 <para>
			具体的に言うと <filename>/sys/</filename> はシステム内のさまざまなデバイスを表現する内部カーネルオブジェクトにアクセスする方法を提供するために設計されました。そんなわけで、カーネルはこの情報の塊を共有します。ここで情報の塊とは、それぞれのデバイスの状態 (たとえば、省エネルギーモードか否か) やリムーバブルデバイスがあるかなどを指します。<filename>/sys/</filename> を使えるのはカーネルバージョン 2.6 以降である点に注意してください。
		</para>
		 </sidebar> <para>
			意外にもドメイン名は別の方法で管理されています。ドメイン名は名前解決を通じて得られるマシンの完全な名前で管理されています。マシンの完全な名前を変更するには <filename>/etc/hosts</filename> ファイルを使います。さらに以下の例に示す通り、マシンの完全な名前を <filename>/etc/hosts</filename> ファイルに書き込みます。マシン名のリストの最初に、そのマシンのアドレスに関連付けられた完全な名前を書きます。
		</para>
		 <informalexample> 
<programlisting>
127.0.0.1     localhost
192.168.0.1   arrakis.falcot.com arrakis</programlisting>
		 </informalexample> <indexterm>
			<primary><filename>hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary><filename>/etc/hosts</filename></primary>
		</indexterm>
		 <indexterm>
			<primary>ドメイン</primary>
			<secondary>名</secondary>
		</indexterm>
		 <indexterm>
			<primary>名</primary>
			<secondary>ドメイン名</secondary>
		</indexterm>
		 <indexterm>
			<primary>NSS</primary>
		</indexterm>
		 <section id="sect.name-resolution">
			<title>名前解決</title>
			 <indexterm>
				<primary>解決</primary>
				<secondary>名前解決</secondary>
			</indexterm>
			 <indexterm>
				<primary>名前</primary>
				<secondary>解決</secondary>
			</indexterm>
			 <para>
				Linux における名前解決のメカニズムはモジュール式であり <filename>/etc/nsswitch.conf</filename> ファイルに宣言されたさまざまな情報源を取り扱うことが可能です。ホスト名解決に関連するエントリは <literal>hosts</literal> です。デフォルトでこのエントリには <literal>files dns</literal> が含まれています。これは名前解決の際にシステムは最初に <filename>/etc/hosts</filename> ファイルを、次に DNS サーバを参照することを意味しています。NIS/NIS+ や LDAP サーバも情報源として使うことが可能です。
			</para>
			 <sidebar> <title><emphasis>NOTE</emphasis> NSS と DNS</title>
			 <para>
				DNS 問い合わせ専用のコマンド (特に <command>host</command>) は標準的な名前解決メカニズム (NSS) を使わないということに注意してください。結果として、そのようなコマンドは <filename>/etc/nsswitch.conf</filename> を考慮しませんし、<filename>/etc/hosts</filename> も考慮しません。
			</para>
			 </sidebar> <section id="sect.dns-server-configuration">
				<title>DNS サーバの設定</title>
				 <indexterm>
					<primary>DNS</primary>
				</indexterm>
				 <indexterm>
					<primary>ドメインネームサービス</primary>
				</indexterm>
				 <para>
					DNS (ドメインネームサービス) は IP アドレスと名前を双方向に対応付ける分散型の階層的サービスです。具体的に言うと、このサービスは人間に都合の良い名前、たとえば <literal>www.eyrolles.com</literal> を実際の IP アドレス <literal>213.244.11.247</literal> に変換します。
				</para>
				 <para>
					DNS 情報にアクセスするには、DNS サーバが要求を中継するよう設定されていなければいけません。Falcot Corp は自分の DNS サーバを持っていますが、各ユーザは自分の ISP から提供された DNS サーバを使う傾向にあります。
				</para>
				 <indexterm>
					<primary><filename>resolv.conf</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><literal>nameserver</literal></primary>
				</indexterm>
				 <para>
					以下の例のように、使われる DNS サーバは <filename>/etc/resolv.conf</filename> に書かれています。1 行につき 1 台の DNS サーバを書き、DNS サーバの IP アドレスの前に <literal>nameserver</literal> キーワードを書きます。
				</para>
				 
<programlisting>
nameserver 212.27.32.176
nameserver 212.27.32.177
nameserver 8.8.8.8</programlisting>
				 <para>
					NetworkManager がネットワークを管理していたり DHCP でネットワークを設定する場合、<filename>/etc/resolv.conf</filename> ファイルは自動的に取り扱われる (そして上書きされる) ことがある点に注意してください。
				</para>

			</section>
			 <section id="sect.etc-hosts">
				<title><filename>/etc/hosts</filename> ファイル</title>
				 <indexterm>
					<primary><filename>hosts</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/hosts</filename></primary>
				</indexterm>
				 <para>
					ローカルネットワーク内にネームサーバがない場合、<filename>/etc/hosts</filename> ファイルの中にローカルネットワークの機器向けに通常予約されている IP アドレスとマシンのホスト名の対応表を書くことで名前解決させることが可能です。<filename>/etc/hosts</filename> ファイルの構文はとても単純です。すなわち、各行は特定の IP アドレスとそれに関連する名前のリスト (リストの先頭に書く名前は「完全修飾名」でドメイン名を含みます) を表します。
				</para>
				 <para>
					<filename>/etc/hosts</filename> ファイルはネットワークが停止している場合や DNS サーバに到達できない場合にも利用できますが、ネットワーク上のすべてのマシンに <filename>/etc/hosts</filename> ファイルのコピーを配置できる場合を除けば役に立ちません。つまり、このファイルをほんの少しでも変更すれば、すべてのマシンでファイルの内容を更新しなければいけません。このため、通常 <filename>/etc/hosts</filename> には最重要のエントリだけが含まれています。
				</para>
				 <para>
					<filename>/etc/hosts</filename> ファイルによる名前管理は、インターネットに接続されていない小さなネットワークでは十分ですが、5 台以上のマシンで構成されるネットワークでは、適切な DNS サーバをインストールすることを推奨します。
				</para>
				 <sidebar> <title><emphasis>TIP</emphasis> DNS の迂回</title>
				 <para>
					アプリケーションは DNS 問い合わせの前に <filename>/etc/hosts</filename> ファイルを確認しますので、通常の DNS 問い合わせで返される結果とは違う情報をこのファイルに書いておくことで、通常の DNS に基づいた名前解決を迂回することが可能です。
				</para>
				 <para>
					つまり DNS の変更がまだ伝搬されておらず、まだ名前が正しい IP アドレスに適切に対応付けられていない場合でも、その名前で運用される予定のウェブサイトへのアクセスをテストすることが可能になります。
				</para>
				 <para>
					<filename>/etc/hosts</filename> ファイルのもう 1 つの使われ方としては、特定のホストに向けられたトラフィックをローカルホストにリダイレクトすることです。これで特定のホストとの通信を避けることができます。たとえば、広告を提供する専用サーバのホスト名をリダイレクトすれば広告を迂回することが可能です。こうすることでトラフィックが改善され、気をそらされることなくウェブサイトを巡回することが可能です。
				</para>
				 </sidebar>
			</section>

		</section>

	</section>
	 <section id="sect.user-group-databases">
		<title>ユーザとグループのデータベース</title>
		 <indexterm>
			<primary>ユーザ</primary>
			<secondary>データベース</secondary>
		</indexterm>
		 <indexterm>
			<primary>グループ</primary>
			<secondary>データベース</secondary>
		</indexterm>
		 <indexterm>
			<primary>データベース</primary>
			<secondary>ユーザのデータベース</secondary>
		</indexterm>
		 <indexterm>
			<primary>データベース</primary>
			<secondary>グループのデータベース</secondary>
		</indexterm>
		 <para>
			ユーザのリストは通常 <filename>/etc/passwd</filename> ファイルに保存されており、<filename>/etc/shadow</filename> ファイルには暗号化されたパスワードが保存されています。どちらのファイルもテキストファイルで、比較的単純なフォーマットで書かれており、テキストエディタを使って読んだり変更することが可能です。各ユーザはこれらのファイルにリストされ、各行はコロン (「<literal>:</literal>」) で区切られたいくつかのフィールドを含んでいます。
		</para>
		 <sidebar> <title><emphasis>NOTE</emphasis> システムファイルの編集</title>
		 <para>
			この章で述べるシステムファイルはすべてプレーンテキストファイルで、テキストエディタを使って編集することが可能です。システムファイルが中核システムの機能性に対して重要な役割を担っている点を考慮すると、システムファイルを編集する際に特別な注意を払うことはどんな場合でも良い考えです。最初に、システムファイルを開くか変更する前には必ず、そのコピーかバックアップを作ってください。2 番目に、潜在的に 1 人以上が同じファイルに同時にアクセスする可能性のあるサーバおよびマシンでは、ファイルの破壊を防ぐために特別な手順を踏んでください。
		</para>
		 <para>
			この目的を達成するには、<filename>/etc/passwd</filename> ファイルを編集する際に <command>vipw</command> コマンドを使ったり <filename>/etc/group</filename> ファイルを編集する際に <command>vigr</command> コマンドを使ったりするだけで十分です。これらのコマンドはテキストエディタ (デフォルトで <command>vi</command>。エディタを設定するには <varname>EDITOR</varname> 環境変数を使います) を実行する前に対象のファイルをロックします。これらのコマンドに <literal>-s</literal> オプションを付けることで、対応する <foreignphrase>shadow</foreignphrase> ファイルを編集することも可能です。
		</para>
		 </sidebar> <sidebar> <title><emphasis>BACK TO BASICS</emphasis> crypt、一方向性関数</title>
		 <indexterm>
			<primary>crypt</primary>
		</indexterm>
		 <para>
			<command>crypt</command> は一方向性関数で、ある文字列 (<varname>A</varname>) を別の文字列 (<varname>B</varname>) に変換します。変換の際には <varname>B</varname> から <varname>A</varname> を得ることが不可能な方法を使います。<varname>A</varname> を得るにはすべての可能性をテストするしかありません。テストは各可能性を <command>crypt</command> で変換して得られた結果が <varname>B</varname> か否かで判断されます。<command>crypt</command> は入力 (文字列 <varname>A</varname>) として 8 文字目までを受け付け、13 文字の表示できる ASCII 文字 (文字列 <varname>B</varname>) を生成します。
		</para>
		 </sidebar> <section id="sect.etc-passwd">
			<title>ユーザリスト、<filename>/etc/passwd</filename></title>
			 <para>
				以下は <filename>/etc/passwd</filename> ファイルに含まれるフィールドのリストです。
			</para>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/passwd</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>uid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>gid</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>GECOS</literal></primary>
			</indexterm>
			 <indexterm>
				<primary><literal>login</literal></primary>
			</indexterm>
			 <itemizedlist>
				<listitem>
					<para>
						ログイン名。これはたとえば <literal>rhertzog</literal> です。
					</para>

				</listitem>
				 <listitem>
					<para>
						パスワード、これは一方向性関数 (<command>crypt</command>) によって暗号化されたパスワードです。使われる暗号化アルゴリズムは <literal>DES</literal>、<literal>MD5</literal>、<literal>SHA-256</literal>、<literal>SHA-512</literal> などです。このフィールドの値が特別な値「<literal>x</literal>」だった場合、これは暗号化されたパスワードが <filename>/etc/shadow</filename> に保存されていることを意味しています。
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>uid</literal>。これは各ユーザを識別する一意的な番号です。
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>。これはユーザのメイングループを示す一意的な番号です (Debian はデフォルトで各ユーザに固有のグループを作成します)。
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>GECOS</literal>。通常これはユーザの氏名を含むデータフィールドです。
					</para>

				</listitem>
				 <listitem>
					<para>
						ログインディレクトリ。これはユーザが個人ファイルを保存するために割り当てられたディレクトリです (環境変数 <varname>$HOME</varname> は通常このディレクトリを指します)。
					</para>

				</listitem>
				 <listitem>
					<para>
						ログイン時に実行されるプログラム。通常これはユーザに行動の自由を与えるコマンドインタプリタ (シェル) です。<command>/bin/false</command> (何もせずすぐにコントロールを返すプログラム) が指定された場合、ユーザはログインできません。
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> Unix グループ</title>
			 <indexterm>
				<primary>グループ</primary>
			</indexterm>
			 <para>
				Unix グループには複数のユーザが所属します。ユーザは統合されたパーミッションシステムを使って簡単にファイルを共有できます (あるグループに所属するユーザはそのグループに与えられた権限を執行できます)。また、あるプログラムの使用を特定のグループに制限することも可能です。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-shadow">
			<title>隠された暗号化パスワードファイル、<filename>/etc/shadow</filename></title>
			 <indexterm>
				<primary><filename>shadow</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/shadow</filename></primary>
			</indexterm>
			 <para>
				<filename>/etc/shadow</filename> ファイルには以下のフィールドが含まれます。
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						ログイン名。
					</para>

				</listitem>
				 <listitem>
					<para>
						暗号化されたパスワード。
					</para>

				</listitem>
				 <listitem>
					<para>
						パスワードの有効期限を管理するいくつかのフィールド。
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>DOCUMENTATION</emphasis> <filename>/etc/passwd</filename>、<filename>/etc/shadow</filename>、<filename>/etc/group</filename> ファイルのフォーマット</title>
			 <para>
				これらのファイルのフォーマットの説明は以下の man ページに書かれています。すなわち <citerefentry><refentrytitle>passwd</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>、<citerefentry><refentrytitle>shadow</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry>、<citerefentry><refentrytitle>group</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> に書かれています。
			</para>
			 </sidebar> <sidebar> <title><emphasis>SECURITY</emphasis> <filename>/etc/shadow</filename> ファイルのセキュリティ</title>
			 <para>
				一般ユーザが <filename>/etc/shadow</filename> を読むことは不可能ですが、その分身である <filename>/etc/passwd</filename> を読むことは可能です。すなわち <filename>/etc/passwd</filename> に保存されている暗号化パスワードは誰でも読むことが可能です。さらにクラッカーは、いくつかの「総当り」法の 1 つを使って、簡単に言えばよく使われる文字の組み合わせを推測することで、パスワードを「破壊」(または明らかに) しようと試みることが可能です。<filename>/etc/shadow</filename> を使っているシステムではもはや、「辞書攻撃」と呼ばれるこの種の攻撃方法は不可能です。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.account-modification">
			<title>既存のアカウントやパスワードの変更</title>
			 <indexterm>
				<primary><command>chsh</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chfn</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>passwd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>chage</command></primary>
			</indexterm>
			 <indexterm>
				<primary>パスワード</primary>
			</indexterm>
			 <para>
				以下のコマンドはユーザデータベースの特定のフィールドに保存されている情報を変更します。すなわち <command>passwd</command> を使うと、一般ユーザは自分のパスワードを変更できます。つまり <filename>/etc/shadow</filename> ファイルが更新されます。さらに <command>chfn</command> (CHange Full Name) を使うと <literal>GECOS</literal> フィールドが変更されます。このコマンドはスーパーユーザ (root) 専用です。<command>chsh</command> (CHange SHell) を使うと、一般ユーザはログインシェルを変更できます。しかしながら、ここで設定できるのは <filename>/etc/shells</filename> に書かれたシェルだけです。その一方で、管理者はこの制限に縛られず、シェルにどんなプログラムを設定することも可能です。
			</para>
			 <para>
				最後に、<command>chage</command> (CHange AGE) コマンドを使うと、管理者はパスワードの有効期限設定を変更できます (<literal>-l <replaceable>user</replaceable></literal> オプションで現在の設定を表示します)。<command>passwd -e <replaceable>user</replaceable></command> コマンドを使うと、パスワードを強制的に失効させることが可能です。ユーザは次回のログイン時にパスワード変更を要求されます。
			</para>

		</section>
		 <section id="sect.disabling-account">
			<title>アカウントの失効</title>
			 <indexterm>
				<primary>アカウントの失効</primary>
			</indexterm>
			 <indexterm>
				<primary>アカウント</primary>
				<secondary>失効</secondary>
			</indexterm>
			 <para>
				「アカウントを失効」する (ユーザを締め出す) 必要が出てくるかもしれません。これが必要になるのは、ユーザの懲戒処分、調査目的、単純に長期にわたって明らかにログインしていない場合などが考えられます。失効されたアカウントとは、ユーザがログインできないかマシンへのアクセスを獲得できないことを意味しています。アカウントは単にアクセスできない状態になっているだけで、アカウントがマシンから削除されるわけでもなければファイルおよびデータが削除されるわけでもありません。アカウントを失効するには <command>passwd -l <replaceable>user</replaceable></command> (lock) を使ってください。再度アカウントを有効化するには同様の方法で <literal>-u</literal> オプション (unlock) を付けてください。
			</para>
			 <sidebar id="sidebar.intro-nss"> <title><emphasis>GOING FURTHER</emphasis> NSS とシステムデータベース</title>
			 <indexterm>
				<primary>NSS</primary>
			</indexterm>
			 <indexterm>
				<primary>Name Service Switch</primary>
			</indexterm>
			 <para>
				ユーザやグループのリストを管理する際に適切な NSS (Name Service Switch) モジュールを使えば、通常のファイルを使う代わりに LDAP や <command>db</command> などの他の種類のデータベースを使うことも可能です。<filename>/etc/nsswitch.conf</filename> ファイルの <literal>passwd</literal>、<literal>shadow</literal>、<literal>group</literal> エントリにはデータベースとして使われるモジュールがリストされています。LDAP で NSS モジュールを使う方法の具体例は<xref linkend="sect.config-nss" />をご覧ください。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.etc-group">
			<title>グループリスト、<filename>/etc/group</filename></title>
			 <para>
				グループは <filename>/etc/group</filename> ファイルにリストされています。<filename>/etc/group</filename> ファイルは単純なテキストデータベースで、フォーマットは <filename>/etc/passwd</filename> ファイルとよく似ており、以下のフィールドを持っています。
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						グループ名。
					</para>

				</listitem>
				 <listitem>
					<para>
						パスワード (任意)。これはグループメンバーでないユーザがそのグループに参加する際に使われます (<command>newgrp</command> および <command>sg</command> コマンドを使います。補注<xref linkend="sidebar.working-with-several-groups" />を参照してください)。
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>gid</literal>。これはグループを識別する一意的な番号です。
					</para>

				</listitem>
				 <listitem>
					<para>
						メンバーのリスト。これはグループに所属するユーザ名のコンマ区切りリストです。
					</para>

				</listitem>

			</itemizedlist>
			 <para>
			</para>
			 <sidebar id="sidebar.working-with-several-groups"> <title><emphasis>BACK TO BASICS</emphasis> 複数のグループに所属する</title>
			 <indexterm>
				<primary><command>newgrp</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>sg</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>id</command></primary>
			</indexterm>
			 <indexterm>
				<primary>グループ</primary>
				<secondary>変更</secondary>
			</indexterm>
			 <para>
				ユーザは複数のグループに所属することが可能です。そして所属グループの 1 つが「メイングループ」です。ユーザのメイングループはデフォルトで最初のユーザ設定中に作成されます。デフォルトで、ユーザが作成したファイルは本人とそのメイングループの所有物になります。この状態が望ましくない場合もあります。たとえば、ユーザが自分のメイングループではないグループ用に共有されたディレクトリ内で仕事をする必要がある場合を考えてみましょう。この場合、ユーザは以下のコマンドのどちらかを使ってメイングループを変更する必要があります。具体的に言えば、新しいシェルを開始する <command>newgrp</command> か、与えられた別グループでコマンドを実行する <command>sg</command> を使う必要があります。これらのコマンドを使うと、ユーザは自分が所属していないグループに参加することが可能です。グループがパスワードで保護されていた場合、ユーザはコマンドを実行する前に適切なパスワードを入力する必要があります。
			</para>
			 <para>
				別の方法として、ディレクトリに <literal>setgid</literal> ビットを設定することが可能です。こうすることで、そのディレクトリの下に作成されたファイルのグループを自動的に適切なものにすることが可能です。詳細は補注<xref linkend="sidebar.setgid-dir" />をご覧ください。
			</para>
			 <para>
				<command>id</command> コマンドはユーザのユーザ名 (<varname>uid</varname> 変数)、現在のメイングループ (<varname>gid</varname> 変数)、所属するグループのリスト (<varname>groups</varname> 変数) を表示します。
			</para>
			 </sidebar> <indexterm>
				<primary><filename>group</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/group</filename></primary>
			</indexterm>
			 <para>
				<command>addgroup</command> コマンドはグループを追加、<command>delgroup</command> コマンドはグループを削除します。<command>groupmod</command> コマンドは指定したグループの情報 (<literal>gid</literal> またはグループ名など) を変更します。<command>passwd -g <replaceable>group</replaceable></command> は <replaceable>group</replaceable> で指定したグループのパスワードを変更し、一方で <command>passwd -r -g <replaceable>group</replaceable></command> コマンドは <replaceable>group</replaceable> で指定したグループを削除します。
			</para>
			 <indexterm>
				<primary><command>addgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>delgroup</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>groupmod</command></primary>
			</indexterm>
			 <indexterm>
				<primary>グループ</primary>
				<secondary>作成</secondary>
			</indexterm>
			 <indexterm>
				<primary>作成</primary>
				<secondary>グループの作成</secondary>
			</indexterm>
			 <indexterm>
				<primary>グループ</primary>
				<secondary>削除</secondary>
			</indexterm>
			 <indexterm>
				<primary>グループの削除</primary>
			</indexterm>
			 <sidebar> <title><emphasis>TIP</emphasis> <command>getent</command></title>
			 <indexterm>
				<primary><command>getent</command></primary>
			</indexterm>
			 <para>
				<command>getent</command> (get entries) コマンドは、適当なライブラリ関数を使い <filename>/etc/nsswitch.conf</filename> ファイルで設定された NSS モジュールを呼び出すという標準的な方法で、システムデータベースを確認します。<command>getent</command> コマンドは 1 つか 2 つの引数を取ります。具体的に言えば、引数としてデータベースの名前と検索キーを取ります。そんなわけで、<command>getent passwd rhertzog</command> コマンドはユーザデータベースから <literal>rhertzog</literal> ユーザに関する情報を表示します。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.creating-accounts">
		<title>アカウントの作成</title>
		 <indexterm>
			<primary>アカウント</primary>
			<secondary>作成</secondary>
		</indexterm>
		 <indexterm>
			<primary>作成</primary>
			<secondary>ユーザアカウントの作成</secondary>
		</indexterm>
		 <para>
			新しいマシンをセットアップする際に、管理者が最初にする作業の 1 つにユーザアカウントの作成作業があります。典型的に、ユーザアカウントの作成作業は <command>adduser</command> コマンドを使って行われます。このコマンドは作成する新しいユーザのユーザ名を引数に取ります。
		</para>
		 <indexterm>
			<primary><command>adduser</command></primary>
		</indexterm>
		 <para>
			<command>adduser</command> コマンドはアカウントを作成する前にいくつかの質問を尋ねますが、その使い方はかなり簡単です。<command>adduser</command> コマンドの設定ファイル <filename>/etc/adduser.conf</filename> には興味深い設定が含まれます。すなわち、この設定ファイルは、ユーザテンプレートを作成することで自動的に新しいユーザにクォータを課したり、ユーザアカウントの場所を変更するために使われます。ユーザアカウントの場所を変更することが役に立つ場面は少ないですが、たとえば多くのユーザを管理していて、各アカウントを複数のディスクに分散させたい場合には、役立ちます。また、デフォルトシェルを別のシェルに変えることも可能です。
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> クォータ</title>
		 <indexterm>
			<primary>クォータ</primary>
		</indexterm>
		 <para>
			「クォータ」という用語はユーザが使えるマシンリソースの制限値を意味しています。マシンリソースとは通常ディスク領域を指します。
		</para>
		 </sidebar> <para>
			アカウントが作成されると、<filename>/etc/skel/</filename> テンプレートの内容がユーザのホームディレクトリにコピーされます。<filename>/etc/skel/</filename> テンプレートには標準的なディレクトリと設定ファイルが含まれます。
		</para>
		 <indexterm>
			<primary>グループ</primary>
			<secondary>ユーザの追加</secondary>
		</indexterm>
		 <indexterm>
			<primary>グループにユーザを追加する</primary>
		</indexterm>
		 <para>
			あるユーザに追加のパーミッションを与える目的で、そのユーザを (デフォルトの「メイン」グループ以外の) あるグループに所属させると便利な場合があります。たとえば、<emphasis>audio</emphasis> グループに属するユーザは音声デバイスにアクセスできます (補注<xref linkend="sidebar.special-files" />を参照してください)。これは <command>adduser <replaceable>user</replaceable> <replaceable>group</replaceable></command> コマンドで達成されます。
		</para>
		 <sidebar id="sidebar.special-files"> <title><emphasis>BACK TO BASICS</emphasis> デバイスアクセスパーミッション</title>
		 <indexterm>
			<primary>デバイス</primary>
			<secondary>アクセスパーミッション</secondary>
		</indexterm>
		 <indexterm>
			<primary>ファイル</primary>
			<secondary>スペシャルファイル</secondary>
		</indexterm>
		 <indexterm>
			<primary>モード</primary>
			<secondary>キャラクタモード</secondary>
		</indexterm>
		 <indexterm>
			<primary>モード</primary>
			<secondary>ブロックモード</secondary>
		</indexterm>
		 <indexterm>
			<primary>ブロック、モード</primary>
		</indexterm>
		 <indexterm>
			<primary>キャラクタ、モード</primary>
		</indexterm>
		 <indexterm>
			<primary>スペシャル、ファイル</primary>
		</indexterm>
		 <indexterm>
			<primary><command>mknod</command></primary>
		</indexterm>
		 <para>
			Unix はハードウェア周辺機器デバイスをスペシャルファイルとして表します。スペシャルファイルは通常 <filename>/dev/</filename> (DEVices) ツリーの下に格納されます。デバイスの性質に依存して、2 種類のスペシャルファイルが存在します。具体的に言えば「キャラクタモード」と「ブロックモード」ファイルです、それぞれのモードでは行える操作が限定されています。キャラクタモードの場合、許可されている操作は読み/書きだけですが、ブロックモードの場合、読み/書き操作に加えて利用できるデータのシークも許可されています。最後に、それぞれのスペシャルファイルは (「メジャー」と「マイナー」の) 2 つの番号に関連付けられており、カーネルはこの番号を使って一意的な方法でデバイスを識別します。スペシャルファイルは <command>mknod</command> コマンドで作成され、シンボリック名 (人間にとって使いやすい名前) を付けられます。
		</para>
		 <para>
			スペシャルファイルのパーミッションは関連付けられたデバイスへのアクセスに必要なパーミッションを意味します。そのため、音声ミキサを表す <filename>/dev/mixer</filename> などのファイルには、root と <literal>audio</literal> グループに所属するユーザの読み/書きを許可するパーミッションが設定されています。音声ミキサを操作できるのは、これらのユーザだけです。
		</para>
		 <para>
			<emphasis role="pkg">udev</emphasis>、<emphasis role="pkg">consolekit</emphasis>、<emphasis role="pkg">policykit</emphasis> を組み合わせて使うことで、コンソールに物理的に接続された (ネットワーク経由でない) ユーザに対して一部のデバイスへのアクセスを許可する追加的なパーミッションを設定できるという点に注意してください。
		</para>
		 </sidebar>
	</section>
	 <section id="sect.shell-environment">
		<title>シェル環境</title>
		 <para>
			コマンドインタプリタ (シェル) はコンピュータのユーザが最初に触れるものですから、かなり使いやすくなければいけません。ほとんどのシェルは、挙動 (自動補完、プロンプトテキストなど) を設定する初期化スクリプトを使います。
		</para>
		 <indexterm>
			<primary>コマンドラインインターフェース</primary>
		</indexterm>
		 <indexterm>
			<primary>コマンドインタプリタ</primary>
		</indexterm>
		 <indexterm>
			<primary>シェル</primary>
		</indexterm>
		 <indexterm>
			<primary><command>bash</command></primary>
		</indexterm>
		 <para>
			標準的なシェルである <command>bash</command> は「対話型」シェル用に <filename>/etc/bash.bashrc</filename> 初期化スクリプトを使い、「ログイン」シェル用に <filename>/etc/profile</filename> を使います。
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> ログインシェルと (非) 対話型シェル</title>
		 <para>
			簡単に言うと、ログインシェルはローカルおよびリモートの <command>ssh</command> 経由でコンソールにログインするか、明確に <command>bash --login</command> コマンドを実行してログインする際に実行されます。ログインシェルか否かに関わらず、シェルは対話的 (たとえば <command>xterm</command> 系ターミナルの中で実行される場合) にもなれば、一方で非対話的 (スクリプトとして実行される場合) にもなります。
		</para>
		 </sidebar> <sidebar> <title><emphasis>DISCOVERY</emphasis> シェルを変えれば設定スクリプトも変わります</title>
		 <para>
			各コマンドラインインタプリタには、特別な構文が決められており、専用の設定ファイルがあります。たとえば <command>zsh</command> は <filename>/etc/zshrc</filename> と <filename>/etc/zshenv</filename> を使います。一方で <command>csh</command> は <filename>/etc/csh.cshrc</filename>、<filename>/etc/csh.login</filename>、<filename>/etc/csh.logout</filename> を使います。それぞれのプログラムの man ページでは、そのプログラムがどの設定ファイルを使うかについて説明されています。
		</para>
		 <indexterm>
			<primary><command>zsh</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>csh</command></primary>
		</indexterm>
		 </sidebar> <para>
			<command>bash</command> では、<filename>/etc/bash.bashrc</filename> ファイルを使って「自動補完」を有効化する (通常いくつかの行のコメントを外す) と便利です。
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> 自動補完</title>
		 <indexterm>
			<primary>自動補完</primary>
		</indexterm>
		 <para>
			多くのコマンドラインインタプリタには補完機能があります。補完機能を使うと、コマンド名や引数の一部を入力した後に <keycap>Tab</keycap> キーを押すことで、残りの部分が自動的に入力されます。補完機能のおかげで、ユーザはより効率的に作業を行い、より間違いを起こしにくくなります。
		</para>
		 <para>
			補完機能はとても強力で柔軟です。補完機能の挙動をそれぞれのコマンドに対して設定することが可能です。従って、<command>apt-get</command> に続く 1 番目の引数は、それがどのファイル名にもマッチしなかったとしても、<command>apt-get</command> コマンドの構文に従って提案されます (この場合、<literal>install</literal>、<literal>remove</literal>、<literal>upgrade</literal> などが候補として挙げられます)。
		</para>
		 </sidebar> <sidebar> <title><emphasis>BACK TO BASICS</emphasis> チルダ記号、ホームディレクトリへのショートカット</title>
		 <indexterm>
			<primary>~</primary>
		</indexterm>
		 <indexterm>
			<primary>チルダ記号</primary>
		</indexterm>
		 <para>
			チルダ記号は通常、環境変数 <varname>HOME</varname> の指すディレクトリ (ユーザのホームディレクトリ、<filename>/home/rhertzog/</filename> など) を表すために使われます。コマンドインタプリタはチルダ記号を自動的に置換します。すなわち <filename>~/hello.txt</filename> は <filename>/home/rhertzog/hello.txt</filename> のように置換されます。
		</para>
		 <para>
			チルダ記号は他のユーザのホームディレクトリを表す場合にも使えます。従って、<filename>~rmas/bonjour.txt</filename> は <filename>/home/rmas/bonjour.txt</filename> と同じ意味になります。
		</para>
		 </sidebar> <para>
			これらの共用スクリプトに加えて、各ユーザは自分のシェルを設定するために <filename>~/.bashrc</filename> と <filename>~/.bash_profile</filename> を作ることが可能です。最もよくある変更は、別名の追加です。別名とはコマンドの実行時に自動的に置換される単語で、別名を登録することでコマンドを素早く実行できます。たとえば、<command>ls -la | less</command> コマンドの別名として <literal>la</literal> を作成することが可能です。こうしておけば、ディレクトリの内容を細かく調査する場合に <command>la</command> を入力するだけで済みます。
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> 環境変数</title>
		 <indexterm>
			<primary>環境</primary>
			<secondary>環境変数</secondary>
		</indexterm>
		 <indexterm>
			<primary>変数、環境</primary>
		</indexterm>
		 <para>
			環境変数を使うことで、呼び出されたシェルや他のプログラムに対して大域的な設定を行うことが可能です。環境変数はその場限りのものです (それぞれのプロセスは自身の環境変数を持っています)。しかしながら、環境変数は継承されます。環境変数の継承という性質のおかげで、すべてのプログラムの実行時に伝えられる変数をログインシェルで宣言できます。
		</para>
		 </sidebar> <para>
			デフォルト環境変数の設定はシェルを設定する上で重要な要素です。あるシェルに固有の変数はさておき、デフォルト環境変数の設定は <filename>/etc/environment</filename> ファイルで行うことが好まれます。なぜなら、シェルセッションを起動するさまざまなプログラムが <filename>/etc/environment</filename> ファイルを使うからです。典型的に言って <filename>/etc/environment</filename> では会社や組織の名前を設定する <varname>ORGANIZATION</varname>、HTTP プロキシの存在とその場所を設定する <varname>HTTP_PROXY</varname> などの環境変数を設定します。
		</para>
		 <sidebar> <title><emphasis>TIP</emphasis> すべてのシェルを同様に設定する</title>
		 <para>
			多くの場合、ユーザはログインシェルと対話型シェルの設定を同じにしたいと思うでしょう。これを行うには、<filename>~/.bash_profile</filename> ファイルの中で <filename>~/.bashrc</filename> の内容を実行 (または「source」) します。すべてのユーザに共通のファイルで同じことをすることも可能です (<filename>/etc/profile</filename> の中で <filename>/etc/bash.bashrc</filename> を呼び出します)。
		</para>
		 </sidebar>
	</section>
	 <section id="sect.config-printing">
		<title>プリンタ設定</title>
		 <indexterm>
			<primary>設定</primary>
			<secondary>印刷</secondary>
		</indexterm>
		 <indexterm>
			<primary>印刷</primary>
			<secondary>設定</secondary>
		</indexterm>
		 <para>
			以前、管理者およびユーザにとってプリンタ設定は大きな悩みの種でした。IPP プロトコル (Internet Printing Protocol) を使う自由な印刷サーバである <emphasis role="pkg">cups</emphasis> のおかげで、これらの悩みの種は今やほとんど過去の物です。
		</para>
		 <indexterm>
			<primary>IPP</primary>
		</indexterm>
		 <indexterm>
			<primary>Internet Printing Protocol</primary>
		</indexterm>
		 <indexterm>
			<primary><command>cups</command></primary>
		</indexterm>
		 <para>
			cups プログラムは複数の Debian パッケージに分割されています。たとえば <emphasis role="pkg">cups</emphasis> は主要な印刷サーバです。そして <emphasis role="pkg">cups-bsd</emphasis> は互換レイヤであり、古典的な BSD 印刷システム (<command>lpd</command> デーモン、<command>lpr</command>、<command>lpq</command> コマンドなど) からのコマンドを使えるようにします。そして <emphasis role="pkg">cups-client</emphasis> にはサーバと通信する (プリンタをブロックしたりブロック解除する、進行中の印刷ジョブを表示したり削除する) ための一連のプログラムが含まれます。そして最後に、<emphasis role="pkg">cups-driver-gutenprint</emphasis> には <command>cups</command> 用の追加的なプリンタドライバが含まれます。
		</para>
		 <indexterm>
			<primary><command>lpr</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpd</command></primary>
		</indexterm>
		 <indexterm>
			<primary><command>lpq</command></primary>
		</indexterm>
		 <sidebar> <title><emphasis>COMMUNITY</emphasis> CUPS</title>
		 <indexterm>
			<primary>CUPS</primary>
		</indexterm>
		 <indexterm>
			<primary>Common Unix Printing System</primary>
		</indexterm>
		 <para>
			CUPS (Common Unix Printing System) は Apple, Inc. の管理するプロジェクトです (さらに商標でもあります)。<ulink type="block" url="http://www.cups.org/" />
		</para>
		 </sidebar> <para>
			前述したさまざまなパッケージをインストールすれば、ローカルアドレスからアクセスできるウェブインターフェース (<literal>http://localhost:631/</literal>) を通じて <command>cups</command> を簡単に管理することが可能です。このインターフェースを使えばプリンタ (ネットワークプリンタも含みます) を追加、削除、管理することが可能です。また、デスクトップ環境が提供するグラフィカルインターフェースを使っても <command>cups</command> を管理することが可能です。最後に、<command>system-config-printer</command> グラフィカルインターフェース (同名の Debian パッケージに含まれます) を使うことも可能です。
		</para>
		 <indexterm>
			<primary><command>cups</command></primary>
			<secondary>管理</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>NOTE</emphasis> <filename>/etc/printcap</filename> の陳腐化</title>
		 <para>
			<emphasis>cups</emphasis> は今や時代遅れになった <filename>/etc/printcap</filename> ファイルを使っていません。このため、利用できるプリンタのリストを得る目的で <filename>/etc/printcap</filename> ファイルを利用するプログラムは機能しません。この問題を避けるには、<filename>/etc/printcap</filename> ファイルを削除し、<filename>/var/run/cups/printcap</filename> へのシンボリックリンクに変えてください (補注<xref linkend="sidebar.symbolic-link" />を参照してください)。<emphasis>cups</emphasis> は互換性を保つために <filename>/var/run/cups/printcap</filename> を管理しています。
		</para>
		 <indexterm>
			<primary><filename>printcap</filename></primary>
		</indexterm>
		 </sidebar>
	</section>
	 <section id="sect.config-bootloader">
		<title>ブートローダの設定</title>
		 <indexterm>
			<primary>ローダ</primary>
			<secondary>ブートローダ</secondary>
		</indexterm>
		 <indexterm>
			<primary>ブートローダ</primary>
		</indexterm>
		 <para>
			ブートローダは既に機能しているかもしれませんが、ブートローダがマスターブートレコードから消えてしまった状況に備えて、ブートローダの設定方法とイントール方法を知っておくのは常に良い考えです。この状況は Windows などの他のオペレーティングシステムをインストールした後に起こる場合があります。以下の情報はブートローダ設定の変更が必要になった際にそれを変更するための助けになるでしょう。
		</para>
		 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> マスターブートレコード</title>
		 <indexterm>
			<primary>MBR</primary>
		</indexterm>
		 <indexterm>
			<primary>マスターブートレコード</primary>
		</indexterm>
		 <para>
			マスターブートレコード (MBR) は最初のハードディスクの最初の 512 バイトを専有し、BIOS は対象のオペレーティングシステムを起動できるプログラムに操作を受け渡すために真っ先に MBR を読み込みます。一般にブートローダは MBR にインストールされ、その前に MBR にあった情報は削除されます。
		</para>
		 </sidebar> <section id="sect.identify-disks">
			<title>ディスクの識別</title>
			 <sidebar> <title><emphasis>CULTURE</emphasis> <emphasis>udev</emphasis> と <filename>/dev/</filename></title>
			 <para>
				伝統的に、<filename>/dev/</filename> ディレクトリはシステムの周辺機器を表す目的でいわゆる「スペシャル」ファイルを保存する場所でした (補注<xref linkend="sidebar.special-files" />を参照してください)。昔 <filename>/dev/</filename> ディレクトリには、潜在的に利用する可能性のあるすべてのスペシャルファイルが含まれていました。このやり方には多くの欠点がありました。特に使うことのできるデバイスの数が制限されていた点 (名前リストがハードコードされていた点)、実際に使えるスペシャルファイルがどれなのか分からない点が問題でした。
			</para>
			 <para>
				今日、スペシャルファイルの管理は完全に動的に行われるようになっており、ホットスワップできるコンピュータデバイスの性質とうまく合っています。カーネルは <emphasis>udev</emphasis> と協力し、対応するデバイスが取り付けられたり取り外された際に、スペシャルファイルを作成したり削除したりします。この理由により <filename>/dev/</filename> を保存しておく必要はなくなり、RAM ベースのファイルシステムでは最初 <filename>/dev/</filename> ディレクトリを空にしておいて関連するエントリだけを含めるようにしています。
			</para>
			 <para>
				カーネルは新たに追加されたデバイスに関する多くの情報をやり取りして、そのデバイスを識別するメジャー/マイナー番号の組を配布します。<command>udevd</command> はデバイスに必要なパーミッション設定と命名を行ったスペシャルファイルを作成します。さらに <command>udevd</command> は別名を作成し、追加的操作 (デバイスの初期化や登録作業など) を実行することも可能です。<command>udevd</command> の挙動は (カスタマイズが可能な) 巨大ルール群によって決定されます。
			</para>
			 <para>
				動的に名前を付けることで、あるデバイスに常に同じ名前を持たせることが可能になります。名前は接続するコネクタや接続順に依存しないので、特に複数の USB 周辺機器を使う場合に便利です。1 台目のハードドライブの最初のパーティションは後方互換性を保つために <filename>/dev/sda1</filename> と呼ばれます。しかしあなたがそう望むなら <filename>/dev/root-partition</filename> と呼ぶことも可能ですし、両方の名前を同時に使うことも可能です。なぜなら <command>udevd</command> を設定すれば自動的にシンボリックリンクを作成するようにできるからです。
			</para>
			 <para>
				古くは、一部のカーネルモジュールはユーザが関連するデバイスファイルにアクセスを試行した時点で自動的に読み込まれていました。今現在この方針は使われておらず、モジュールを読み込む前に周辺機器のスペシャルファイルが存在することはありません。しかしこれは大きな問題ではありません。なぜなら、自動ハードウェア検出のおかげで多くのモジュールは起動時に読み込まれるからです。しかし、検出できない周辺機器 (非常に古いディスクドライブや PS/2 マウスなど) ではこの挙動が問題になります。<literal>floppy</literal>、<literal>psmouse</literal>、<literal>mousedev</literal> モジュールを <filename>/etc/modules</filename> に追加して、起動時に強制的にこれらのモジュールを読み込むことを検討してください。
			</para>
			 </sidebar> <indexterm>
				<primary>ハードドライブ、名前</primary>
			</indexterm>
			 <indexterm>
				<primary>名前</primary>
				<secondary>ハードドライブの名前</secondary>
			</indexterm>
			 <para>
				ブートローダを設定するには、必ずさまざまなハードドライブとそのパーティションを識別しなければいけません。Linux はこの目的のために <filename>/dev/</filename> ディレクトリ内で「ブロック」スペシャルファイルを使います。Debian <emphasis role="distribution">Squeeze</emphasis> 以降、ハードドライブの命名規則は Linux カーネルによって統一化されました。現在、すべてのハードドライブ (IDE/PATA、SATA、SCSI、USB、IEEE 1394) は <filename>/dev/sd*</filename> と表されます。
			</para>
			 <para>
				それぞれのパーティションは自分が存在するディスク上の番号で表されます。たとえば、<filename>/dev/sda1</filename> は 1 台目のディスクの最初のパーティションで、<filename>/dev/sdb3</filename> は 2 台目のディスクの 3 番目のパーティションです。
			</para>
			 <indexterm>
				<primary>パーティション</primary>
				<secondary>プライマリ</secondary>
			</indexterm>
			 <indexterm>
				<primary>パーティション</primary>
				<secondary>拡張</secondary>
			</indexterm>
			 <indexterm>
				<primary>パーティション</primary>
				<secondary>セカンダリ</secondary>
			</indexterm>
			 <indexterm>
				<primary>パーティションテーブル</primary>
				<secondary>MS-DOS フォーマット</secondary>
			</indexterm>
			 <para>
				PC アーキテクチャ (つまり「i386」およびその年下のいとこである「amd64」) では、長い間「MS-DOS」パーティションテーブルフォーマットを使うよう制限を受けていました。このフォーマットはディスク 1 台当たりに作れる「プライマリ」パーティションの数を 4 つに制限していました。この制限を乗り越えるためには、プライマリパーティションの 1 つを「拡張」パーティションとして作成します。拡張パーティションには追加的な「セカンダリ」パーティションを含めることが可能です。このようなセカンダリパーティションには 5 以上の番号が割り振られます。従って、最初のセカンダリパーティションは <filename>/dev/sda5</filename>、2 番目は <filename>/dev/sda6</filename> などのように割り振られるでしょう。
			</para>
			 <para>
				MS-DOS パーティションテーブルフォーマットのもう一つの制限は、2 TiB を超えるサイズのディスクを取り扱うことができないという点です。近年のディスクではこの制限が現実的な問題になりつつあります。
			</para>
			 <indexterm>
				<primary>GPT</primary>
				<secondary>パーティションテーブルフォーマット</secondary>
			</indexterm>
			 <indexterm>
				<primary>パーティションテーブル</primary>
				<secondary>GPT フォーマット</secondary>
			</indexterm>
			 <para>
				GPT と呼ばれる新しいパーティションテーブルフォーマットを使うことで上に挙げた制限が緩和されます。GPT では、パーティション数は最大で 128 個に制限され (標準的な設定を使った場合)、ディスクサイズは最大で 8 ZiB (80 億テラバイト以上) に制限されます。1 台のディスクに多くの物理パーティションを作成する場合、ディスクのパーティショニングを行う際に必ず GPT フォーマットでパーティションテーブルを作成するよう注意してください。
			</para>
			 <para>
				どのディスクがどの SATA コントローラに (たとえば SCSI チェーンの 3 番目に) 接続されているかを記憶するのは常に簡単というわけではありません。なぜなら、特にホットプラグ対応のハードドライブ (これには多くの SATA ディスクや外部ディスクが含まれます) の名前は起動の度に変わるからです。幸いなことに、<command>udev</command> は <filename>/dev/sd*</filename> に加えて、固有名のシンボリックリンクを作成します。曖昧でない方法でハードドライブを識別したい場合にはこのシンボリックリンクを使うことが可能です。これらのシンボリックリンクは <filename>/dev/disk/by-id</filename> に保存されています。たとえば 2 台の物理ディスクを備えるマシンでは以下のようなシンボリックリンクが見つかります。
			</para>
			 
<screen><computeroutput>mirexpress:/dev/disk/by-id# </computeroutput><userinput>ls -l
</userinput><computeroutput>合計 0
lrwxrwxrwx 1 root root  9  7月 23 08:58 ata-STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10  7月 23 08:58 ata-STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10  7月 23 08:58 ata-STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9  7月 23 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10  7月 23 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10  7月 23 08:58 ata-WDC_WD5001AALS-00L3B2_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9  7月 23 08:58 scsi-SATA_STM3500418AS_9VM3L3KP -&gt; ../../sda
lrwxrwxrwx 1 root root 10  7月 23 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part1 -&gt; ../../sda1
lrwxrwxrwx 1 root root 10  7月 23 08:58 scsi-SATA_STM3500418AS_9VM3L3KP-part2 -&gt; ../../sda2
[...]
lrwxrwxrwx 1 root root  9  7月 23 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697 -&gt; ../../sdb
lrwxrwxrwx 1 root root 10  7月 23 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part1 -&gt; ../../sdb1
lrwxrwxrwx 1 root root 10  7月 23 08:58 scsi-SATA_WDC_WD5001AALS-_WD-WCAT00241697-part2 -&gt; ../../sdb2
[...]
lrwxrwxrwx 1 root root  9  7月 23 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0 -&gt; ../../sdc
lrwxrwxrwx 1 root root 10  7月 23 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part1 -&gt; ../../sdc1
lrwxrwxrwx 1 root root 10  7月 23 16:48 usb-LaCie_iamaKey_3ed00e26ccc11a-0:0-part2 -&gt; ../../sdc2
[...]
lrwxrwxrwx 1 root root  9  7月 23 08:58 wwn-0x5000c50015c4842f -&gt; ../../sda
lrwxrwxrwx 1 root root 10  7月 23 08:58 wwn-0x5000c50015c4842f-part1 -&gt; ../../sda1
[...]
mirexpress:/dev/disk/by-id# </computeroutput></screen>
			 <para>
				いくつかのディスクは複数回リストされています (なぜなら、それらは ATA ディスクであり同時に SCSI ディスクとしても振る舞うからです)。しかしながら、ディスクに固有の情報は主にディスクの製品番号とシリアル番号であるという点に注意してください。ここから、目的の周辺機器のシンボリックリンクを見つけることが可能です。
			</para>
			 <para>
				以降の節で挙げる設定ファイルの例はこれと同じディスク構成のマシンに対する設定です。具体的に言えば、1 台の SATA ディスクがあり、最初のパーティションに古い Windows がインストールされており、2 番目のパーティションに Debian GNU/Linux がインストールされている状態です。
			</para>

		</section>
		 <section id="sect.config-lilo">
			<title>LILO の設定</title>
			 <indexterm>
				<primary>LILO</primary>
			</indexterm>
			 <indexterm>
				<primary>Linux Loader</primary>
			</indexterm>
			 <para>
				<emphasis>LILO</emphasis> (LInux LOader) は最も古い (実直だが素朴な) ブートローダです。<emphasis>LILO</emphasis> は MBR に起動するカーネルの物理アドレスを書くため、LILO および LILO の設定ファイルを更新した際にはその後に必ず <command>lilo</command> コマンドを使わなければいけません。このルールを忘れて、古いカーネルを削除したり、置き換えた新しいカーネルを古いカーネルがあった場所と同じディスクの場所に置かなかったりすると、システムが起動できないと表示されます。
			</para>
			 <para>
				LILO の設定ファイルは <filename>/etc/lilo.conf</filename> です。標準的な設定を行う単純なファイルは以下の例のように書けます。
			</para>
			 <example id="example.lilo.conf">
				<title>LILO の設定ファイル</title>
				 
<programlisting>
# このディスクに LILO をインストールします。
# ここではパーティションではなくディスクを指定してください。
# LILO は MBR にインストールされます。
boot=/dev/sda
# Debian がインストールされているパーティション
root=/dev/sda2
# デフォルトで起動させるアイテム
default=Linux

# 最新のカーネルイメージ
image=/vmlinuz
  label=Linux
  initrd=/initrd.img
  read-only

# 古いカーネル (最新のカーネルが起動しなかった際に使います)
image=/vmlinuz.old
  label=LinuxOLD
  initrd=/initrd.img.old
  read-only
  optional

# Linux と Windows のデュアルブート用
other=/dev/sda1
  label=Windows</programlisting>

			</example>

		</section>
		 <section id="sect.config-grub">
			<title>GRUB 2 の設定</title>
			 <indexterm>
				<primary>GRUB</primary>
			</indexterm>
			 <indexterm>
				<primary>GRUB 2</primary>
			</indexterm>
			 <para>
				<emphasis>GRUB</emphasis> (GRand Unified Bootloader) はより新しいブートローダです。カーネル更新の後に GRUB を実行する必要はありません。それどころか <emphasis>GRUB</emphasis> はファイルシステムを読む方法とディスクからカーネルを探し出す方法を知っています。GRUB を最初のディスクの MBR にインストールするためには、<command>grub-install /dev/sda</command> を実行してください。<indexterm><primary><command>grub-install</command></primary></indexterm>
			</para>
			 <sidebar> <title><emphasis>NOTE</emphasis> GRUB におけるディスク名の命名規則</title>
			 <para>
				GRUB は BIOS から提供される情報に従ってハードドライブを識別します。<literal>(hd0)</literal> は最初に検出されたディスクに対応し、<literal>(hd1)</literal> は 2 番目に対応します。多くの場合、この順番は Linux 上でディスクが検出される普通の順番と完全に一致しますが、SCSI や IDE ディスクを使っている場合、問題が起きるかもしれません。GRUB は検出した対応関係を <filename>/boot/grub/device.map</filename> ファイルの中に保存します。管理者がこの対応関係に間違いを見つけた場合 (BIOS が Linux と違う順番でドライブを検出するということを知っている場合)、対応関係を修正して、再度 <command>grub-install</command> を実行してください。<command>grub-mkdevicemap</command> を使えば、<filename>device.map</filename> ファイルのたたき台を作成することが可能です。
			</para>
			 <para>
				GRUB はパーティションを識別する名前も使います。MS-DOS フォーマットの「標準的な」パーティションを使っている場合、最初のディスクの最初のパーティションは <literal>(hd0,msdos1)</literal>、2 番目のパーティションは <literal>(hd0,msdos2)</literal> です。
			</para>
			 </sidebar> <para>
				GRUB 2 の設定は <filename>/boot/grub/grub.cfg</filename> に保存されていますが、このファイルは (Debian の場合) 別のファイルから生成されます。<filename>/boot/grub/grub.cfg</filename> を直接変更しないでください。なぜなら、<command>update-grub</command> が実行されたら (さまざまなパッケージの更新時に実行されることがあります) そのようなその場限りの変更は失われるからです。<filename>/boot/grub/grub.cfg</filename> ファイルに対して最も一般的な変更を加える (たとえば、カーネルに渡すコマンドラインパラメータを追加したり、メニューの表示される時間を変える) には <filename>/etc/default/grub</filename> に含まれる変数を使います。メニューにエントリを追加するには <filename>/boot/grub/custom.cfg</filename> ファイルを作成するか、<filename>/etc/grub.d/50_custom</filename> ファイルを変更してください。より複雑な設定をするには <filename>/etc/grub.d</filename> にある他のファイルを変更するか、このディレクトリにファイルを追加してください。<filename>/etc/grub.d</filename> ディレクトリに含まれるスクリプトは設定スニペットを返すスクリプトであり、場合によっては外部プログラムを使用するかもしれません。これらのスクリプトは起動したいカーネルのリストを更新するためのものです。すなわち <filename>10_linux</filename> はインストール済み Linux カーネルをリストアップします。そして <filename>20_linux_xen</filename> は Xen 仮想システムをリストアップし、<filename>30_os-prober</filename> は他のオペレーティングシステム (Windows、OS X、Hurd) をリストアップします。
			</para>

		</section>
		 <section id="sect.config-yaboot">
			<title>Macintosh コンピュータ (PowerPC) の場合、Yaboot の設定</title>
			 <indexterm>
				<primary><command>yaboot</command></primary>
			</indexterm>
			 <para>
				Yaboot は PowerPC プロセッサを搭載する古い Macintosh コンピュータ用のブートローダです。古い Macintosh コンピュータは PC のように起動せず、「bootstrap」パーティションを使って起動します。「bootstrap」パーティションには、BIOS (または OpenFirmware) が実行する Yaboot が含まれ、さらに <command>ybin</command> プログラムがインストールする <command>yaboot</command> と設定ファイルも含まれています。設定ファイル <filename>/etc/yaboot.conf</filename> (このファイルは bootstrap パーティションにコピーされ、<command>yaboot</command> がディスク上からカーネルのパーティションを見つける方法を指定するファイルです) を変更したら、<command>ybin</command> コマンドを再度実行する必要があります。
			</para>
			 <para>
				<command>ybin</command> を実行する前に、適切な <filename>/etc/yaboot.conf</filename> を作らなければいけません。以下は最低限の設定例です。<indexterm><primary><command>ybin</command></primary></indexterm>
			</para>
			 <example id="example.yaboot.conf">
				<title>Yaboot の設定ファイル</title>
				 
<programlisting>
# bootstrap パーティション
boot=/dev/sda2
# ディスク
device=hd:
# Linux パーティション
partition=3
root=/dev/sda3
# 3 秒間何もしなければ起動します
# (timeout は 10 倍の値を設定してください)
timeout=30

install=/usr/lib/yaboot/yaboot
magicboot=/usr/lib/yaboot/ofboot
enablecdboot

# 最近インストールされたカーネル
image=/vmlinux
        label=linux
        initrd=/initrd.img
        read-only

# 古いカーネル
image=/vmlinux.old
        label=old
        initrd=/initrd.img.old
        read-only

# Linux と Mac OSX のデュアルブート用
macosx=/dev/sda5

# bsd=/dev/sdaX および macos=/dev/sdaX
# の可能性もあります</programlisting>

			</example>

		</section>

	</section>
	 <section id="sect.config-misc">
		<title>その他の設定: 時刻同期、ログ、共有アクセス…</title>
		 <para>
			この節にリストされている多くの要素は、GNU/Linux システムの設定のあらゆる側面を極めたいと思う人なら誰でも、知っておくと良い知識です。しかしながらここでは、各要素を簡単に紹介し、頻繁に文書を参照するだけに留めます。
		</para>
		 <section id="sect.timezone">
			<title>タイムゾーン</title>
			 <indexterm>
				<primary>タイムゾーン</primary>
			</indexterm>
			 <sidebar id="sidebar.symbolic-link"> <title><emphasis>BACK TO BASICS</emphasis> シンボリックリンク</title>
			 <indexterm>
				<primary>リンク</primary>
				<secondary>シンボリック</secondary>
			</indexterm>
			 <indexterm>
				<primary>シンボリックリンク</primary>
			</indexterm>
			 <indexterm>
				<primary><command>ln</command></primary>
			</indexterm>
			 <para>
				シンボリックリンクは他のファイルへのポインタです。シンボリックリンクにアクセスすると、シンボリックリンクの指すファイルが開かれます。シンボリックリンクを削除しても、シンボリックリンクの指すファイルは削除されません。同様に、シンボリックリンクに対してパーミッションを設定することは不可能であり、シンボリックリンクはシンボリックリンクの指すファイルと同じパーミッションを持つとみなされます。最後に、シンボリックリンクはいかなる種類のファイルを指すことも可能です。具体的に言えば、ディレクトリ、スペシャルファイル (ソケット、名前付きパイプ、デバイスファイルなど)、さらには他のシンボリックリンクでさえ指すことが可能です。
			</para>
			 <para>
				<command>ln -s <replaceable>target</replaceable> <replaceable>link-name</replaceable></command> コマンドは <replaceable>link-name</replaceable> と名付けられ <replaceable>target</replaceable> を指すシンボリックリンクを作成します。
			</para>
			 <para>
				シンボリックリンクのリンク先が存在しない場合リンクは「壊れて」おり、壊れたシンボリックリンクにアクセスするとリンク先のファイルが存在しないことを示すエラーが返されます。別のシンボリックリンクにシンボリックリンクを張るとシンボリックリンクが「連鎖」し、リンク先がリンク元を指していた場合にはリンクの「循環」状態になります。この状態で、循環鎖に含まれるリンクの 1 つにアクセスした場合、特定のエラー (「シンボリックリンクの階層が多すぎます」) が返されます。すなわちこれは、カーネルが何回か循環鎖を巡った後にそうすることを諦めたことを意味しています。
			</para>
			 </sidebar> <para>
				タイムゾーンは初回インストール時に設定され、<emphasis role="pkg">tzdata</emphasis> パッケージを使って設定されます。タイムゾーンを変更するには、<command>dpkg-reconfigure tzdata</command> コマンドを使ってください。このコマンドを使えば、対話的に変更したいタイムゾーンを選ぶことが可能です。タイムゾーンの設定は <filename>/etc/timezone</filename> ファイルに保存されます。さらに、<filename>/usr/share/zoneinfo</filename> ディレクトリに含まれるタイムゾーンに対応するファイルが <filename>/etc/localtime</filename> の中にコピーされます。さらに <filename>/etc/localtime</filename> には、夏時間を使う国向けに夏時間が有効な場所で日付を処理するためのルールが含まれています。
			</para>
			 <indexterm>
				<primary><filename>timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/timezone</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>zoneinfo</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/usr/share/zoneinfo/</filename></primary>
			</indexterm>
			 <indexterm>
				<primary>DST</primary>
			</indexterm>
			 <indexterm>
				<primary>夏時間</primary>
			</indexterm>
			 <para>
				一時的にタイムゾーンを変更したい場合、<varname>TZ</varname> 環境変数を使ってください。<varname>TZ</varname> 環境変数に設定した値はシステムデフォルトで設定された値よりも優先されます。
			</para>
			 <indexterm>
				<primary><varname>TZ</varname></primary>
			</indexterm>
			 
<screen id="screen.tz">
<computeroutput>$ </computeroutput><userinput>date</userinput>
<computeroutput>2015年  2月 19日 木曜日 19:25:18 JST</computeroutput>
<computeroutput>$ </computeroutput><userinput>TZ="Pacific/Honolulu" date</userinput>
<computeroutput>2015年  2月 19日 木曜日 00:25:18 HST</computeroutput></screen>
			 <sidebar> <title><emphasis>NOTE</emphasis> システムクロック、ハードウェアクロック</title>
			 <para>
				コンピュータには 2 種類の時間ソースがあります。コンピュータのマザーボードには「CMOS クロック」と呼ばれるハードウェアクロックがあります。ハードウェアクロックは極めて正確なものというわけではありませんし、比較的アクセスに時間がかかります。また、オペレーティングシステムカーネルにはシステムクロック (ソフトウェアクロック) があります。システムクロックは独自の方法を使って最新の状態に保たれています (タイムサーバの助けを借りているかもしれません。<xref linkend="sect.time-synchronization" />をご覧ください)。システムクロックを使えば、CMOS クロックにアクセスする必要がないため、さらに正確な値を得られます。しかしながら、システムクロックは揮発性メモリの中にあるため、マシンが起動する際に毎回ゼロに設定されます。それに対して、CMOS クロックは電池を持っているので、マシンを再起動や停止しても値を「残す」ことが可能です。そんなわけで、システムクロックは起動中に CMOS クロックの値を使って設定され、CMOS クロックはシャットダウンの際に更新されます (CMOS クロックが不適切に調整されていた場合、変更または訂正された場合を考慮して更新します)。
			</para>
			 <para>
				実際のところ、このやり方には問題があります。なぜなら、CMOS クロックは単なるカウンタに過ぎず、タイムゾーンに関する情報を持たないからです。CMOS クロックの値を解釈する際には選択の余地が残されています。すなわち、システムは CMOS クロックを協定世界時 (UTC、旧 GMT) またはローカル時間のどちらで解釈するかを選ばなければいけません。両者は単純な補正定数の違いに過ぎないように見えますが、しかし実際はより複雑な違いがあります。たとえば夏時間がある場合、この補正量は定数ではありません。その結果、特に夏時間が適用される期間中には、補正量の正しさを決定する術がありません。協定世界時とタイムゾーン情報からローカル時間を再構成することは常に可能ですから、CMOS クロックを協定世界時として扱うことを推奨します。
			</para>
			 <para>
				不幸なことに、Windows システムのデフォルト設定はこの推奨に従いません。すなわち Windows システムは CMOS クロックをローカル時間に保ち、コンピュータの起動時には夏時間中の時間変更が既に適用されているか否かを推測して時間変更を適用します。マシン上で Windows だけが動いている場合、このやり方は比較的うまく動作します。しかしコンピュータに複数のシステムがある場合 (「デュアルブート」設定や仮想マシンを通じて他のシステムを動かす場合)、時間が正確か決定する方法は存在せず、時間設定はめちゃくちゃになります。どうしてもコンピュータに Windows を残さなければいけない場合、Windows を設定して CMOS クロックを UTC に保つ (<literal>HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal</literal> レジストリキーを DWORD の「1」に設定する) か、Debian システムで <command>hwclock --localtime --set</command> を使いハードウェアクロックをローカル時間に保つ (そして春と秋に手作業で時計を確認する) かのどちらか一方を設定してください。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.time-synchronization">
			<title>時刻同期</title>
			 <indexterm>
				<primary>時刻同期</primary>
			</indexterm>
			 <indexterm>
				<primary>時計</primary>
				<secondary>同期</secondary>
			</indexterm>
			 <para>
				時刻同期は、コンピュータ上では不必要の操作のようにも見えますが、ネットワーク上では極めて重要です。ユーザは日付と時間を変更することを許可されていないので、混乱を防ぐためには時刻情報を正確に保つことがとても重要です。さらに、ネットワーク上のすべてのコンピュータの時刻を同期させておけば、異なるマシン間でログからの情報を相互参照しやすくなります。従って、攻撃を受けた際に不正アクセスを受けた複数のマシンで時系列順に操作を再構成することが簡単になります。時刻が同期されていなかった場合、統計目的で複数のマシンからデータを集めても、意味を成しません。
			</para>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> NTP</title>
			 <indexterm>
				<primary>NTP</primary>
			</indexterm>
			 <indexterm>
				<primary>Network</primary>
				<secondary>Time Protocol</secondary>
			</indexterm>
			 <para>
				NTP (Network Time Protocol) を使うことで、あるマシンが他のマシンとかなり正確に時刻同期することが可能になります。ここで正確とは NTP がネットワーク上で情報を移動することで起こる遅延および予想される補正を考慮しているという意味です。
			</para>
			 <para>
				インターネット上には数多くの NTP サーバがありますが、よく知られている NTP サーバは混んでいるかもしれません。このため、NTP サーバには <emphasis>pool.ntp.org</emphasis> を使うことを推奨します。実際のところ、<emphasis>pool.ntp.org</emphasis> は公開 NTP サーバとしての機能を果たすことに同意したマシン群です。さらに、国を限定したサブグループに制限することが可能です。たとえば、アメリカ合衆国は <emphasis>us.pool.ntp.org</emphasis>、日本は <emphasis>jp.pool.ntp.org</emphasis> などです。
			</para>
			 <para>
				しかしながら、巨大なネットワークを管理する場合、公開サーバに同期している自前の NTP サーバを用意することを推奨します。この場合、自分のネットワークに所属する他のマシンはすべて、公開サーバの負荷を増やす代わりに、内部の NTP サーバを使うことが可能です。さらにこうすることで時刻同期の均一性が高められます。なぜなら、すべてのマシンが同じ内部 NTP サーバを使って時刻同期しますし、公開 NTP サーバに比べて内部 NTP サーバのほうがネットワーク転送にかかる時間が短いからです。
			</para>
			 </sidebar> <section id="sect.ntp-on-workstations">
				<title>ワークステーション向けの設定</title>
				 <para>
					ワークステーションは (エネルギーを節約するためだけだったとしても) 日常的に再起動されますから、NTP と同期するのは起動時だけで十分です。これを行うには、<emphasis role="pkg">ntpdate</emphasis> パッケージをインストールします。必要なら <filename>/etc/default/ntpdate</filename> ファイルを変更して NTP サーバを変更することも可能です。
				</para>
				 <indexterm>
					<primary><filename>ntpdate</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/default/ntpdate</filename></primary>
				</indexterm>

			</section>
			 <section id="sect.ntp-on-servers">
				<title>サーバ向けの設定</title>
				 <para>
					サーバはめったに再起動されませんし、サーバのシステム時間を正確にすることはとても重要です。恒久的に正確な時間を保つためには、<emphasis role="pkg">ntp</emphasis> パッケージの提供する NTP サーバをローカルにインストールするべきです。デフォルトの設定では、NTP サーバは <emphasis>pool.ntp.org</emphasis> と同期し、ローカルネットワークからの要求に対して時刻を提供します。<filename>/etc/ntp.conf</filename> ファイルを編集すれば NTP サーバを設定することも可能です。最も重大な影響をおよぼす設定項目は、この NTP サーバがどの NTP サーバを参照するかです。ネットワークに多くのサーバがある場合、公開 NTP サーバと同期するのは 1 台のローカルタイムサーバだけにして、そのローカルタイムサーバを他のサーバに対する時間ソースとして使ってみると良いかもしれません。
				</para>
				 <indexterm>
					<primary><emphasis role="pkg">ntp</emphasis></primary>
				</indexterm>
				 <indexterm>
					<primary>サーバ</primary>
					<secondary>NTP</secondary>
				</indexterm>
				 <indexterm>
					<primary>NTP</primary>
					<secondary>サーバ</secondary>
				</indexterm>
				 <sidebar> <title><emphasis>GOING FURTHER</emphasis> GPS モジュールと他の時刻ソース</title>
				 <indexterm>
					<primary>GPS</primary>
				</indexterm>
				 <indexterm>
					<primary>DCF-77</primary>
				</indexterm>
				 <para>
					時刻同期がネットワークで決定的に重要な要素の場合、GPS モジュール (GPS 衛星からの時刻を使う) または DCF-77 モジュール (ドイツのフランクフルト近郊の原子時計と時刻を同期する) をサーバに装備することも可能です。この場合、NTP サーバの設定はもう少し複雑です。そのため必ず事前に文書を調査してください。
				</para>
				 </sidebar>
			</section>

		</section>
		 <section id="sect.rotation-logs">
			<title>ログファイルの循環</title>
			 <indexterm>
				<primary>ファイル</primary>
				<secondary>ログ、循環</secondary>
			</indexterm>
			 <indexterm>
				<primary>ログ</primary>
				<secondary>ファイル、循環</secondary>
			</indexterm>
			 <indexterm>
				<primary>ログファイルの循環</primary>
			</indexterm>
			 <indexterm>
				<primary><command>logrotate</command></primary>
			</indexterm>
			 <para>
				ログファイルのサイズは素早く増加しますから、ログファイルをアーカイブに保管することが必要です。これを実現する最も一般的なやり方はアーカイブを循環させることです。つまり、ログファイルは日常的にアーカイブに保管され、最新の <replaceable>X</replaceable> 個のアーカイブが保存されます。<command>logrotate</command> はログファイルの循環を担当しているプログラムであり、<filename>/etc/logrotate.conf</filename> ファイルと <filename>/etc/logrotate.d/</filename> ディレクトリ内に含まれるすべてのファイルに書かれた指示に従います。管理者が Debian の定義するログ循環ポリシーを改変したい場合、これらの設定ファイルを変更するかもしれません。<citerefentry><refentrytitle>logrotate</refentrytitle>
				 <manvolnum>1</manvolnum></citerefentry> man ページでは、これらの設定ファイルで利用できるすべてのオプションが説明されています。ログ循環で保存されるファイルの数を増加させたかったり、削除せずにアーカイブ専用の特定のディレクトリにログファイルを移動させたいと思うかもしれません。また、電子メールでログを送信してログを別の場所にアーカイブすることも可能です。
			</para>
			 <para>
				<command>logrotate</command> プログラムは <command>cron</command> スケジューリングプログラム (<xref linkend="sect.task-scheduling-cron-atd" />で説明されています) によって毎日実行されます。
			</para>

		</section>
		 <section id="sect.sharing-admin-rights">
			<title>管理者権限の共有</title>
			 <indexterm>
				<primary>アカウント</primary>
				<secondary>管理者アカウント</secondary>
			</indexterm>
			 <indexterm>
				<primary>root</primary>
			</indexterm>
			 <indexterm>
				<primary><command>sudo</command></primary>
			</indexterm>
			 <para>
				しばしば、複数の管理者が同じネットワーク上で仕事をする場合があります。root パスワードの共有は的確なやり方ではありません。root パスワードを共有することでコマンドの実行者が隠匿されるため、root 権限を乱用される危険性が生まれます。この種の問題に対する解決策が <command>sudo</command> プログラムです。<command>sudo</command> プログラムは特定のユーザに特別な権限で特定のコマンドを実行することを可能にします。<command>sudo</command> の最も一般的な用途として、信頼できるユーザが root 権限でコマンドを実行できるようにするという用途があります。これを行うには、ユーザは単純に <command>sudo <replaceable>command</replaceable></command> を実行し、自分のパスワードを使って認証するだけです。
			</para>
			 <para>
				<emphasis role="pkg">sudo</emphasis> パッケージがインストールされると、<literal>sudo</literal> Unix グループのメンバーは完全な root 権限を与えられます。他の権利を委譲するには、管理者は <command>visudo</command> コマンドを用いなければいけません。<command>visudo</command> コマンドを使うことで、管理者は <filename>/etc/sudoers</filename> 設定ファイルを変更することが可能です (繰り返しになりますが、これは <command>vi</command> エディタまたは <varname>EDITOR</varname> 環境変数で表されるその他のエディタを実行します)。<literal><replaceable>username</replaceable> ALL=(ALL) ALL</literal> のような行を追加することで、指定されたユーザは root としてコマンドを実行することが可能になります。
			</para>
			 <indexterm>
				<primary><command>visudo</command></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>sudoers</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/sudoers</filename></primary>
			</indexterm>
			 <para>
				より洗練された設定を使うことで、特定のコマンドに必要な権限を特定のユーザに与えることも可能です。設定できる要素のすべての詳細を確認するには <citerefentry><refentrytitle>sudoers</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry> man ページをご覧ください。
			</para>

		</section>
		 <section id="sect.fstab-mount-points">
			<title>マウントポイントのリスト</title>
			 <indexterm>
				<primary>ポイント、マウント</primary>
			</indexterm>
			 <indexterm>
				<primary>マウントポイント</primary>
			</indexterm>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> マウントとアンマウント</title>
			 <para>
				Debian などの Unix 系システムでは、ファイルはディレクトリの単一樹状階層構造でまとめられています。<filename>/</filename> ディレクトリは「ルートディレクトリ」と呼ばれています。そして、すべての追加的なディレクトリはこのルートディレクトリの中のサブディレクトリです。「マウント」とは周辺機器デバイス (通常はハードドライブ) の内容をシステムの一般的なファイルツリーに含める操作です。結果として、ユーザの個人データを保存するために別のハードドライブを使う場合、このディスクは <filename>/home/</filename> ディレクトリに「マウント」されなければいけません。ルートファイルシステムはカーネルによって起動時に常にマウントされます。そして、他のデバイスはしばしばその後に続くスタートアップシーケンス中か <command>mount</command> コマンドを使って手作業でマウントされます。
			</para>
			 <indexterm>
				<primary><command>mount</command></primary>
			</indexterm>
			 <para>
				いくつかのリムーバブルデバイスは接続時に自動的にマウントされます。特に GNOME、KDE、その他のグラフィカルデスクトップ環境を使っている場合には自動的にマウントされます。他のデバイスについてはユーザが手作業でマウントしなければいけません。同様に、アンマウント (ファイルツリーから削除) も手動で行わなければいけません。普通のユーザは通常 <command>mount</command> や <command>umount</command> コマンドを実行する権限を持っていません。しかしながら、<literal>user</literal> オプションを <filename>/etc/fstab</filename> ファイルに含めることで、管理者はユーザに (マウントポイント別に) これらの操作を行う権限を与えることも可能です。
			</para>
			 <para>
				<command>mount</command> コマンドは引数なしで使うことも可能です (すべてのマウントされたファイルシステムを表示します)。デバイスをマウントおよびアンマウントする場合はパラメータが必要です。すべてのパラメータを見るには、対応する man ページである <citerefentry><refentrytitle>mount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> と <citerefentry><refentrytitle>umount</refentrytitle>
				 <manvolnum>8</manvolnum></citerefentry> を参照してください。単純なマウントの場合、構文もまた単純です。たとえば、ext3 ファイルシステムの <filename>/dev/sdc1</filename> パーティションを <filename>/mnt/tmp/</filename> ディレクトリにマウントするには、<command>mount -t ext3 /dev/sdc1 /mnt/tmp/</command> のように実行してください。
			</para>
			 </sidebar> <para>
				<filename>/etc/fstab</filename> ファイルには、起動時に自動マウントされるものやリムーバブルストレージデバイス用の手作業でマウントするものを含めて、すべての考え得るマウントポイントがリストされています。それぞれのマウントポイントは空白区切りフィールドを持つ各行によって表現されます。<indexterm><primary><filename>fstab</filename></primary></indexterm><indexterm><primary><filename>/etc/fstab</filename></primary></indexterm>
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						マウントするデバイス。このフィールドにはローカルパーティション (ハードドライブ、CD-ROM) またはリモートファイルシステム (NFS など) を指定します。
					</para>
					 <para>
						このフィールドではしばしば、<literal>UUID=</literal> を前に付けたファイルシステムの一意的な ID が使われることがあります (ID は <command>blkid <userinput>device</userinput></command> を使えばわかります)。一意的な ID を使うことで、ディスクを取り付けたり取り外したことや異なる順番でディスクが検出されたことによりデバイスの名前が変わっても問題がなくなります。
					</para>

				</listitem>
				 <listitem>
					<para>
						マウントポイント。このフィールドではデバイス、リモートシステム、パーティションがマウントされるローカルファイルシステムの場所を指定します。
					</para>

				</listitem>
				 <listitem>
					<para>
						ファイルシステムタイプ。このフィールドではマウントされたデバイスで使われているファイルシステムを定義します。<literal>ext4</literal>、<literal>ext3</literal>、<literal>vfat</literal>、<literal>ntfs</literal>、<literal>btrfs</literal>、<literal>xfs</literal> などがその例です。
					</para>
					 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> NFS、ネットワークファイルシステム</title>
					 <para>
						NFS はネットワークファイルシステムです。Linux の下では、NFS を使ってローカルファイルシステムにリモートファイルを含めることにより、リモートファイルへの透過的なアクセスが可能になります。
					</para>
					 </sidebar> <para>
						既知のファイルシステムの完全なリストは <citerefentry><refentrytitle>mount</refentrytitle>
						 <manvolnum>8</manvolnum></citerefentry> man ページに書かれています。<literal>swap</literal> は swap パーティション専用の特殊値です。そして <literal>auto</literal> は <command>mount</command> プログラムに自動的にファイルシステムを検出させるための特殊値です (この値はディスクリーダと USB メモリで特に便利です。なぜなら、機器ごとに異なるファイルシステムを使っている可能性があるからです)。
					</para>

				</listitem>
				 <listitem>
					<para>
						オプション。ファイルシステムごとに多くのオプションがあり、これらの値は <command>mount</command> man ページに書かれています。最もよく使われるものを以下に挙げます。
					</para>
					 <itemizedlist>
						<listitem>
							<para>
								<literal>rw</literal> または <literal>ro</literal>。これはデバイスが読み書き可能状態または読み取り専用でマウントされることを意味しています。
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>noauto</literal>。これは起動時の自動マウントを無効化します。
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>nofail</literal>。<literal>nofail</literal> オプションを使えば、デバイスが見つからなかった場合にも起動処理が中断されなくなります。<literal>nofail</literal> オプションを使うデバイスは起動中に取り外されている可能性のある外付けドライブ上のデバイスだけにしてください。なぜなら、<command>systemd</command> は起動処理を続行する前に自動的にマウントされなければならないすべてのマウントポイントが実際にマウントされていることを確認するからです。<literal>nofail</literal> オプションは <literal>x-systemd.device-timeout=5s</literal> オプションと併用することが可能であるという点に注意してください。両者を併用することで、<command>systemd</command> は 5 秒間だけデバイスを探索し、その後起動処理を続行するようになります (<citerefentry><refentrytitle>systemd.mount</refentrytitle>
								<manvolnum>5</manvolnum></citerefentry> を参照してください)。
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>user</literal>。<literal>user</literal> オプションを使うことですべてのユーザが対象のファイルシステムをマウント可能になります (<literal>user</literal> オプションを指定しなければ、マウントおよびアンマウント操作をできるのは root ユーザだけに限られます)。
							</para>

						</listitem>
						 <listitem>
							<para>
								<literal>defaults</literal>。<literal>defaults</literal> オプションを使うとデフォルトオプション群を指定したことになります。デフォルトオプション群とは <literal>rw</literal>、<literal>suid</literal>、<literal>dev</literal>、<literal>exec</literal>、<literal>auto</literal>、<literal>nouser</literal>、<literal>async</literal> です。<literal>defaults</literal> の後に <literal>nosuid</literal>、<literal>nodev</literal> などを付ければ、<literal>suid</literal>、<literal>dev</literal> をブロックし、これらのオプションを無効化することも可能です。<literal>user</literal> オプションを追加すればこれが再有効化されます。なぜなら <literal>defaults</literal> は <literal>nouser</literal> を含むからです。
							</para>

						</listitem>

					</itemizedlist>

				</listitem>
				 <listitem>
					<para>
						バックアップ。このフィールドにはほぼ必ず <literal>0</literal> を設定します。<literal>1</literal> を設定した場合、<command>dump</command> ツールに対してこのパーティションにはバックアップされるデータが含まれることが伝えられます。
					</para>

				</listitem>
				 <listitem>
					<para>
						ファイルシステムのチェック順。このフィールドは起動時にファイルシステムの完全性がチェックされるか否かと、チェックが実行される順番を意味します。<literal>0</literal> の場合、完全性はチェックされません。ルートファイルシステムに対しては <literal>1</literal> を設定するべきです。他の恒久的なファイルシステムに対しては <literal>2</literal> を設定するべきです。
					</para>

				</listitem>

			</itemizedlist>
			 <example id="example.fstab">
				<title><filename>/etc/fstab</filename> ファイルの例</title>
				 
<programlisting>
# /etc/fstab: 固定ファイルシステムの情報。
#
# &lt;ファイルシステム&gt; &lt;マウントポイント&gt; &lt;タイプ&gt; &lt;オプション&gt; &lt;ダンプ&gt; &lt;チェック順&gt;
proc            /proc           proc    defaults        0       0
# インストール中に / は /dev/sda1 にありました
UUID=c964222e-6af1-4985-be04-19d7c764d0a7 / ext3 errors=remount-ro 0 1
# インストール中に swap は /dev/sda5 にありました
UUID=ee880013-0f63-4251-b5c6-b771f53bd90e none swap sw  0       0
/dev/scd0       /media/cdrom0   udf,iso9660 user,noauto 0       0
/dev/fd0        /media/floppy   auto    rw,user,noauto  0       0
arrakis:/shared /shared         nfs     defaults        0       0</programlisting>

			</example>
			 <para>
				この例の最後のエントリはネットワークファイルシステム (NFS) を表しています。すなわち <emphasis>arrakis</emphasis> サーバの <filename>/shared/</filename> ディレクトリがローカルマシンの <filename>/shared/</filename> にマウントされます。<filename>/etc/fstab</filename> ファイルのフォーマットは <citerefentry><refentrytitle>fstab</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> man ページに書かれています。
			</para>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> 自動マウント</title>
			 <para>
				<emphasis>am-utils</emphasis> パッケージは <command>amd</command> 自動マウントユーティリティを提供します。<command>amd</command> ユーティリティを使うと、通常のマウントポイントを通じてリムーバブルメディアにアクセスすれば、リムーバブルメディアをマウントできます。<command>amd</command> はリムーバブルメディアにアクセスしているプロセスがなくなればそのメディアをアンマウントします。
			</para>
			 <indexterm>
				<primary><emphasis>am-utils</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><command>amd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>automount</command></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>autofs</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>自動マウントユーティリティ</primary>
			</indexterm>
			 <para>
				他の自動マウントユーティリティも存在します。たとえば <emphasis>autofs</emphasis> パッケージに含まれる <command>automount</command> です。
			</para>
			 <para>
				GNOME、KDE、その他のグラフィカルデスクトップ環境は <emphasis>udisks</emphasis> と協調して、リムーバブルメディアが接続されたらそれを自動的にマウントします。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.locate-updatedb">
			<title><command>locate</command> と <command>updatedb</command></title>
			 <indexterm>
				<primary><command>locate</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>updatedb</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>mlocate</command></primary>
			</indexterm>
			 <para>
				<command>locate</command> コマンドを使うと、名前の一部を知っているだけのファイルの場所を見つけ出すことが可能です。結果はほぼ一瞬で返されます。なぜなら <command>locate</command> コマンドはシステムのファイルのすべての場所を保存するデータベースを参照しているからです。さらにこのデータベースは <command>updatedb</command> コマンドを使って毎日更新されます。<command>locate</command> コマンドには複数の実装があり、Debian は標準的なシステム向けに <emphasis role="pkg">mlocate</emphasis> を選んでいます。
			</para>
			 <para>
				<command>mlocate</command> は賢明なので、システムのすべてのファイルについて知っているデータベースを使っている (なぜなら、<command>mlocate</command> の <command>updatedb</command> 実装は root 権限で実行されるからです) にも関わらず、コマンドを実行したユーザがアクセスできるファイルだけを返します。さらなる安全性のために、管理者は <filename>/etc/updatedb.conf</filename> の中で <varname>PRUNEDPATHS</varname> を使って、いくつかのディレクトリのインデックス化を避けることが可能です。
			</para>

		</section>

	</section>
	 <section id="sect.kernel-compilation">
		<title>カーネルのコンパイル</title>
		 <indexterm>
			<primary>コンパイル</primary>
			<secondary>カーネルのコンパイル</secondary>
		</indexterm>
		 <indexterm>
			<primary>カーネル</primary>
			<secondary>コンパイル</secondary>
		</indexterm>
		 <para>
			Debian の提供するカーネルは、既存のハードウェア構成の広い領域をカバーするために、できる限り多くの機能およびドライバを組み込んでいます。このため、一部のユーザにとっては本当に必要なものだけを含める目的でカーネルを再コンパイルするほうが良い場合もあります。カーネルを再コンパイルする理由は 2 つあります。1 つ目は、メモリ消費量を最適化できるかもしれないからです。全く使われないカーネルコードは無駄にメモリを専有するため (カーネルコードは決してスワップ領域に「移動」されません。なぜなら、カーネルコードがスワップ用の RAM 領域を管理しているからです)、システム全体のパフォーマンスを低下させます。2 つ目は、カーネルを自前でコンパイルすればカーネルコードのごく一部をコンパイルして実行することになり、セキュリティ問題の危険性を限定することが可能だからです。
		</para>
		 <sidebar> <title><emphasis>NOTE</emphasis> セキュリティ更新</title>
		 <para>
			自前でカーネルをコンパイルする場合、以下の点に同意しなければいけません。それは、Debian は自前でコンパイルしたカスタムカーネルに対するセキュリティ更新を保証できないという点です。Debian が提供するカーネルを使うことにすれば、Debian プロジェクトのセキュリティチームが用意した更新の恩恵を受けることができます。
		</para>
		 </sidebar> <para>
			さらに、パッチの形でしか供給されていない (標準的なカーネルのバージョンに含まれていない) 特定の機能を使いたい場合もカーネルの再コンパイルが必要です。
		</para>
		 <sidebar> <title><emphasis>GOING FURTHER</emphasis> Debian カーネルハンドブック</title>
		 <indexterm>
			<primary><emphasis role="pkg">debian-kernel-handbook</emphasis></primary>
		</indexterm>
		 <para>
			Debian カーネルチームは「Debian カーネルハンドブック」をメンテナンスしています (「Debian カーネルハンドブック」は <emphasis role="pkg">debian-kernel-handbook</emphasis> パッケージからも入手できます)。「Debian カーネルハンドブック」ではカーネルに関連する多くの作業と公式 Debian カーネルパッケージの取り扱い方法が包括的に説明されています。「Debian カーネルハンドブック」はこの節で提供される情報よりも詳しい情報が必要になった場合に最初に調べるべき文書です。<ulink type="block" url="http://kernel-handbook.alioth.debian.org" />
		</para>
		 </sidebar> <section id="sect.kernel-compilation-prerequisites">
			<title>前置きと前提条件</title>
			 <para>
				当然ながら、Debian はパッケージの形でカーネルを管理します。このやり方はカーネルをコンパイルおよびインストールする伝統的な方法とは異なります。しかしながら、カーネルをパッケージングシステムの制御下に置くことで、カーネルを完全に削除したり複数のマシンに配備したりすることが可能になります。さらに、カーネルのパッケージに関連付けられたスクリプトのおかげで、ブートローダと initrd ジェネレータとの連動が自動化されます。
			</para>
			 <para>
				上流開発の Linux ソースには、カーネルの Debian パッケージをビルドするために必要な要素のすべてが含まれています。しかし、Debian パッケージをビルドするのに必要なツールを確実にそろえるためには <emphasis role="pkg">build-essential</emphasis> のインストールも必要です。さらに、カーネルを設定するためには <emphasis role="pkg">libncurses5-dev</emphasis> パッケージも必要です。最後に、<emphasis role="pkg">fakeroot</emphasis> パッケージを使えば管理者権限を使わずに Debian パッケージを作成することも可能になります。
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> <emphasis role="pkg">kernel-package</emphasis> の古き良き時代</title>
			 <indexterm>
				<primary><emphasis role="pkg">kernel-package</emphasis></primary>
			</indexterm>
			 <para>
				Linux ビルドシステムに適切な Debian パッケージをビルドする能力がなかった時代、Debian パッケージをビルドするのに推奨されていた方法は <emphasis role="pkg">kernel-package</emphasis> パッケージに含まれる <command>make-kpkg</command> を使うやり方でした。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-sources">
			<title>ソースの取得</title>
			 <indexterm>
				<primary>Linux カーネルソース</primary>
			</indexterm>
			 <indexterm>
				<primary>カーネル</primary>
				<secondary>ソース</secondary>
			</indexterm>
			 <indexterm>
				<primary>ソース</primary>
				<secondary>Linux カーネルのソース</secondary>
			</indexterm>
			 <para>
				Debian システム上で便利に使えるプログラムと同様に、Linux カーネルソースはパッケージとして提供されています。Linux カーネルソースを手に入れるには、<emphasis role="pkg">linux-source-<replaceable>version</replaceable></emphasis> パッケージをインストールしてください。Debian がパッケージングしたカーネルのさまざまなバージョンを確認するには <command>apt-cache search ^linux-source</command> コマンドを使ってください。最新のバージョンは<emphasis role="distribution">不安定版</emphasis>ディストリビューションに含まれています。すなわち、大して危険性を伴わずにカーネルの最新バージョンを入手できます (特に APT が<xref linkend="sect.apt-mix-distros" />の説明に従って設定されている場合、大きな危険性はないと言えます)。Debian のカーネルソースパッケージに含まれるソースコードは Linus Torvalds とカーネル開発者が公開したソースコードと全く同じものではないという点に注意してください。すべてのディストリビューションと同様に、Debian もまたカーネルソースに数多くのパッチを適用します。このパッチは今後 Linux の上流開発版に取り込まれるかもしれません (取り込まれない場合もあります)。これらの変更には新しいカーネルバージョンに追加された修正/機能/ドライバのバックポート、まだ上流開発の Linux ツリーに (完全に) マージされていない新機能、場合によっては Debian 特有の変更が含まれます。
			</para>
			 <para>
				この節のこれ以降の説明では、Linux カーネルのバージョン 3.16 を例に挙げます。しかしながら、この例はもちろん他のカーネルの特定のバージョンにも適用できます。
			</para>
			 <para>
				<emphasis role="pkg">linux-source-3.16</emphasis> パッケージがインストール済みと仮定します。<emphasis role="pkg">linux-source-3.16</emphasis> パッケージには、カーネルソースの圧縮アーカイブである <filename>/usr/src/linux-source-3.16.tar.xz</filename> が含まれます。この圧縮アーカイブを新しいディレクトリに展開してください (<filename>/usr/src/</filename> の下のディレクトリに展開しないよう注意してください。なぜなら、Linux カーネルをコンパイルするのに特別なパーミッションは必要ないからです)。すなわち <filename>~/kernel/</filename> に展開することが適切です。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>mkdir ~/kernel; cd ~/kernel</userinput>
<computeroutput>$ </computeroutput><userinput>tar -xaf /usr/src/linux-source-3.16.tar.xz</userinput></screen>
			 <sidebar> <title><emphasis>CULTURE</emphasis> カーネルソースの場所</title>
			 <para>
				伝統的に、Linux カーネルソースは <filename>/usr/src/linux/</filename> に置かれているので、カーネルをコンパイルするには root 権限が必要です。しかしながら、その必要がないにも関わらず管理者権限を使って作業するべきではありません。<literal>src</literal> グループのメンバーは <filename>/usr/src/</filename> ディレクトリの中で作業することを許されていますが、それでもなおこのディレクトリの中で作業するべきではありません。カーネルソースを個人ディレクトリに置けば、あらゆる点でセキュリティを確保できます。つまり <filename>/usr/</filename> 以下に存在するファイルはパッケージングシステムの知っているファイルだけになりますし、使用中のカーネルの情報を収集しようとして <filename>/usr/src/linux</filename> を読むプログラムを間違った方向に導く危険性もなくなります。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.config-kernel">
			<title>カーネルの設定</title>
			 <indexterm>
				<primary>カーネル</primary>
				<secondary>設定</secondary>
			</indexterm>
			 <indexterm>
				<primary>設定</primary>
				<secondary>カーネルの設定</secondary>
			</indexterm>
			 <indexterm>
				<primary><filename>.config</filename></primary>
			</indexterm>
			 <para>
				次の段階で、必要性に応じてカーネルを設定します。完全な手順はその目標に依存します。
			</para>
			 <para>
				より最近のカーネルのバージョンを再コンパイルする場合 (おそらく追加的パッチを適用する場合)、その設定は Debian の提案する設定と可能な限り似たものになるでしょう。この場合、すべてを最初から再設定するのではなく、<filename>/boot/config-<replaceable>version</replaceable></filename> ファイル (ここで version は現在使っているカーネルで、<command>uname -r</command> コマンドでわかります) をカーネルソースに含まれるディレクトリ内の <filename>.config</filename> ファイルにコピーするだけで十分です。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cp /boot/config-3.16.0-4-amd64 ~/kernel/linux-source-3.16/.config</userinput></screen>
			 <para>
				設定を変更する必要がなければ、ここまでで止めて<xref linkend="sect.kernel-build" />に進むことも可能です。一方で、設定を変更する必要があったり最初からすべてを再設定する場合、時間をかけてカーネルを設定しなければいけません。カーネルソースディレクトリには <command>make <replaceable>target</replaceable></command> コマンドを呼び出して使うさまざまな専用のインターフェースがあります。ここで <replaceable>target</replaceable> は以下に説明するものの 1 つです。
			</para>
			 <para>
				<command>make menuconfig</command> は階層構造でオプションを案内するテキストモードインターフェースをコンパイルして実行します (コンパイルおよび実行には <emphasis role="pkg">libncurses5-dev</emphasis> パッケージが必要です)。<keycap>Space</keycap> キーで選択されたオプションの値を変更します。<keycap>Enter</keycap> キーで画面の下部にある選択状態のボタンを押します。さらに <guibutton>Select</guibutton> ボタンで選択されたサブメニューを返します。さらに <guibutton>Exit</guibutton> ボタンで現在の画面を閉じて階層を一段階上に戻ります。さらに <guibutton>Help</guibutton> ボタンで選択されたオプションの役割に関するより詳細な情報を表示します。矢印キーでオプションリストとボタンの間を移動します。設定プログラムを終了するには、メインメニューから <guibutton>Exit</guibutton> ボタンを選択してください。すると、このプログラムは変更を保存するよう提案します。そして変更内容に満足したら、保存してください。
			</para>
			 <para>
				他のインターフェースも同様の機能を持っていますが、より現代的なグラフィカルインターフェースで機能します。<command>make xconfig</command> は Qt グラフィカルインターフェース、<command>make gconfig</command> は GTK+ を使います。<command>make xconfig</command> には <emphasis role="pkg">libqt4-dev</emphasis> が必要で、<command>make gconfig</command> には <emphasis role="pkg">libglade2-dev</emphasis> と <emphasis role="pkg">libgtk2.0-dev</emphasis> が必要です。
			</para>
			 <para>
				これらの設定インターフェースのうち 1 つを使う場合、合理的なデフォルト設定から始めるのが良いアイディアです。カーネルのデフォルト設定は <filename>arch/<replaceable>arch</replaceable>/configs/*_defconfig</filename> に置かれています。この設定ファイルを適切な場所に置くには、<command>make x86_64_defconfig</command> (64 ビット PC の場合) や <command>make i386_defconfig</command> (32 ビット PC の場合) などのコマンドを使います。
			</para>
			 <sidebar> <title><emphasis>TIP</emphasis> 古い <filename>.config</filename> ファイルに対処する</title>
			 <para>
				他の (通常古い) カーネルバージョンで生成された <filename>.config</filename> ファイルを使う場合、内容を更新しなければいけません。内容を更新するには <command>make oldconfig</command> を使います。このコマンドは新しい設定オプションに関する質問を対話的に尋ねます。すべての質問に対してデフォルトの答えを使う場合、<command>make olddefconfig</command> を使ってください。すべての質問にデフォルトと反対の答えを使う場合、<command>make oldnoconfig</command> を使ってください。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-build">
			<title>パッケージのコンパイルとビルド</title>
			 <indexterm>
				<primary><command>make deb-pkg</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>NOTE</emphasis> 再ビルド前の片付け</title>
			 <para>
				既にそのディレクトリの中で 1 回コンパイルした状態で、(たとえばカーネル設定を大幅に変更したなどの理由で) すべてを最初から再ビルドしたい場合、<command>make clean</command> を実行してコンパイル済みファイルを削除しなければいけません。<command>make distclean</command> はさらに生成されたファイルも削除します。この中には <filename>.config</filename> ファイルも含まれますので、忘れずにバックアップしてください。
			</para>
			 </sidebar> <para>
				カーネル設定の準備が完了したら、<command>make deb-pkg</command> で 5 つの Debian パッケージが生成されます。具体的に言えば、カーネルイメージと関連モジュールを含む <emphasis role="pkg">linux-image-<replaceable>version</replaceable></emphasis>、外部モジュールのビルドに必要なヘッダファイルを含む <emphasis role="pkg">linux-headers-<replaceable>version</replaceable></emphasis>、一部のドライバから要求されるファームウェアファイルを含む <emphasis role="pkg">linux-firmware-image-<replaceable>version</replaceable></emphasis> (Debian の配布しているカーネルソースからカーネルをビルドする場合、このパッケージは生成されないかもしれません)、カーネルイメージとモジュールのデバッグシンボルを含む <emphasis role="pkg">linux-image-<replaceable>version</replaceable>-dbg</emphasis>、GNU glibc などのユーザ空間ライブラリに関連するヘッダを含む <emphasis role="pkg">linux-libc-dev</emphasis> が生成されます。
			</para>
			 <para>
				ここで <replaceable>version</replaceable> は上流開発バージョン (<filename>Makefile</filename> 中の <literal>VERSION</literal>、<literal>PATCHLEVEL</literal>、<literal>SUBLEVEL</literal>、<literal>EXTRAVERSION</literal> から定義されます)、<literal>LOCALVERSION</literal> 設定パラメータ、<literal>LOCALVERSION</literal> 環境変数を連結したものです。パッケージバージョンは <replaceable>version</replaceable> に規則正しく増え続けるリビジョン番号 (<filename>.version</filename> に保存されています) を付け加えたものになります。ただし、<literal>KDEB_PKGVERSION</literal> 環境変数を使えばパッケージバージョンを上書きすることも可能です。
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>make deb-pkg LOCALVERSION=-falcot KDEB_PKGVERSION=$(make kernelversion)-1
</userinput><computeroutput>[...]
$ </computeroutput><userinput>ls ../*.deb
</userinput><computeroutput>../linux-headers-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb
../linux-image-3.16.7-ckt4-falcot_3.16.7-1_amd64.deb
../linux-image-3.16.7-ckt4-falcot-dbg_3.16.7-1_amd64.deb
../linux-libc-dev_3.16.7-1_amd64.deb
</computeroutput></screen>

		</section>
		 <section id="sect.modules-build">
			<title>外部モジュールのコンパイル</title>
			 <indexterm>
				<primary>カーネル</primary>
				<secondary>外部モジュール</secondary>
			</indexterm>
			 <indexterm>
				<primary>モジュール</primary>
				<secondary>外部カーネルモジュール</secondary>
			</indexterm>
			 <indexterm>
				<primary><command>dkms</command></primary>
			</indexterm>
			 <para>
				いくつかのモジュールは公式の Linux カーネルの外でメンテナンスされています。このような外部モジュールを使うには、適合するカーネルと一緒にモジュールをコンパイルしなければいけません。Debian は専用パッケージの形で数多くのサードパーティ製の外部モジュールを配布しています。たとえば、<emphasis role="pkg">xtables-addons-source</emphasis> (iptables 用の追加モジュール)、<emphasis role="pkg">oss4-source</emphasis> (Open Sound System、代替音声ドライバ) などがその一例です。
			</para>
			 <para>
				これらの外部モジュール用パッケージは多種多様で、ここですべてを挙げることはできません。外部モジュール用パッケージを検索するには <command>apt-cache search source$</command> コマンドを使います。しかしながら、完全なリストがあったとしても、それは特に役立つわけではありません。なぜなら、外部モジュールが必要であるとわかっている場合を除いて、外部モジュールをコンパイルする特別な理由はないからです。デバイスの動作に外部モジュールが必要になる場合、デバイスの文書が Linux でそのデバイスを機能させるために必要な特定のモジュールについて詳しく説明している場合が多いです。
			</para>
			 <para>
				たとえば、<emphasis role="pkg">xtables-addons-source</emphasis> パッケージを見てみましょう。インストールの後、モジュールのソース <filename>.tar.bz2</filename> が <filename>/usr/src/</filename> に保存されます。手作業でこの tarball を展開してモジュールをビルドすることも可能ですが、実際のところ、DKMS を使ってビルド作業を自動化する方が良いです。多くのモジュールは、パッケージ名が <literal>-dkms</literal> サフィックスで終わるパッケージの中で、DKMS 統合に必要な要素を提供します。今回の場合、インストール済みカーネルに対応する <emphasis role="pkg">linux-headers-*</emphasis> パッケージを持っているならば、現在のカーネル用のカーネルモジュールをコンパイルするために必要な作業は <emphasis role="pkg">xtables-addons-dkms</emphasis> をインストールするだけです。たとえば、<emphasis role="pkg">linux-image-amd64</emphasis> を使っている場合、<emphasis role="pkg">linux-headers-amd64</emphasis> をインストールする必要があります。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>sudo apt install xtables-addons-dkms</userinput>
<computeroutput>
[...]
xtables-addons-dkms (2.6-1) を設定しています ...
Loading new xtables-addons-2.6 DKMS files...
First Installation: checking all kernels...
Building only for 3.16.0-4-amd64
Building initial module for 3.16.0-4-amd64
Done.

xt_ACCOUNT:
Running module version sanity check.
 - Original module
   - No original module exists within this kernel
 - Installation
   - Installing to /lib/modules/3.16.0-4-amd64/updates/dkms/
[...]
DKMS: install completed.
$ </computeroutput><userinput>sudo dkms status</userinput>
<computeroutput>xtables-addons, 2.6, 3.16.0-4-amd64, x86_64: installed
$ </computeroutput><userinput>sudo modinfo xt_ACCOUNT</userinput>
<computeroutput>filename:       /lib/modules/3.16.0-4-amd64/updates/dkms/xt_ACCOUNT.ko
license:        GPL
alias:          ipt_ACCOUNT
author:         Intra2net AG &lt;opensource@intra2net.com&gt;
description:    Xtables: per-IP accounting for large prefixes
[...]
</computeroutput></screen>
			 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> module-assistant</title>
			 <indexterm>
				<primary><emphasis role="pkg">module-assistant</emphasis></primary>
			</indexterm>
			 <para>
				DKMS 以前、カーネルモジュールをビルドして配置する最も簡単な解決策は <emphasis role="pkg">module-assistant</emphasis> でした。特に DKMS 統合されていないパッケージはまだ <emphasis role="pkg">module-assistant</emphasis> を使っています。このようなパッケージでは、単純なコマンド <command>module-assistant auto-install xtables-addons</command> (または短縮コマンドの <command>m-a a-i xtables-addons</command>) を使えば、モジュールを現在のカーネル用にコンパイルして新しい Debian パッケージを作成できます。作成したパッケージはその場でインストールできます。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.kernel-patch">
			<title>カーネルパッチの適用</title>
			 <indexterm>
				<primary>カーネル</primary>
				<secondary>パッチ</secondary>
			</indexterm>
			 <indexterm>
				<primary>カーネルのパッチ</primary>
			</indexterm>
			 <para>
				一部の機能は完成度の低さやカーネルメンテナとの意見の不一致が原因で標準的なカーネルに含まれていません。そのような機能をカーネルソースに対して自由に適用できるようにするために、これをパッチの形で配布する場合があります。
			</para>
			 <para>
				Debian はいくつかのパッチを <emphasis role="pkg">linux-patch-*</emphasis> や <emphasis role="pkg">kernel-patch-*</emphasis> パッケージの形で配布します (たとえば、<emphasis role="pkg">linux-patch-grsecurity2</emphasis> はカーネルのセキュリティポリシーを厳しくするパッチです)。これらのパッケージは <filename>/usr/src/kernel-patches/</filename> ディレクトリにファイルをインストールします。
			</para>
			 <para>
				インストール済みパッチをカーネルに適用するには、ソースディレクトリの中で <command>patch</command> コマンドを使い、上で述べた通り、カーネルのコンパイルを始めてください。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>cd ~/kernel/linux-source-3.16</userinput>
<computeroutput>$ </computeroutput><userinput>make clean</userinput>
<computeroutput>$ </computeroutput><userinput>zcat /usr/src/kernel-patches/diffs/grsecurity2/grsecurity-3.0-3.17.1-201410250027.patch.gz | patch -p1</userinput></screen>
			 <para>
				与えられたパッチがカーネルのどのバージョンでも動作するとは限らないことに注意してください。さらに、カーネルソースにパッチを適用する際に、<command>patch</command> が失敗することもあります。エラーメッセージが表示され、失敗に関する詳細が表示されるでしょう。この場合、そのパッチの Debian パッケージで利用できる文書 (<filename>/usr/share/doc/linux-patch-*/</filename> ディレクトリに含まれます) を参照してください。多くの場合、メンテナはそのパッチがどのカーネルバージョンを対象にしたものかを書いています。
			</para>

		</section>

	</section>
	 <section id="sect.kernel-installation">
		<title>カーネルのインストール</title>
		 <indexterm>
			<primary>インストール</primary>
			<secondary>カーネルのインストール</secondary>
		</indexterm>
		 <indexterm>
			<primary>カーネル</primary>
			<secondary>インストール</secondary>
		</indexterm>
		 <section id="sect.kernel-package">
			<title>Debian カーネルパッケージの特徴</title>
			 <indexterm>
				<primary><filename>vmlinuz</filename></primary>
			</indexterm>
			 <para>
				Debian カーネルパッケージはカーネルイメージ (<filename>vmlinuz-<replaceable>version</replaceable></filename>) をインストールします。カーネルの設定 (<filename>config-<replaceable>version</replaceable></filename>) とシンボルテーブル (<filename>System.map-<replaceable>version</replaceable></filename>) は <filename>/boot/</filename> に置かれます。シンボルテーブルは開発者がカーネルエラーメッセージの意味を理解する際の手助けになります。それどころかシンボルテーブルがなければ、カーネルの「oops」(「oops」とはカーネル空間で起こるユーザ空間プログラムのセグメンテーション違反に相当するエラーです。言い換えれば、不正なポインタを参照して値を取得したことで生成されるメッセージです) に含まれる情報は、数字で表したメモリアドレスだけになります。アドレスとシンボルや関数名を対応付けるテーブルがなければ、この情報は役に立ちません。モジュールは <filename>/lib/modules/<replaceable>version</replaceable>/</filename> ディレクトリにインストールされます。
			</para>
			 <para>
				カーネルパッケージの設定スクリプトは自動的に initrd イメージを生成します。initrd はブートローダによってメモリに読み込まれる小さなシステムで (このため「init RAM ディスク」と名付けられています)、Linux カーネルは initrd を使って完全な Debian システムを含むデバイス (たとえば SATA ディスクのドライバ) にアクセスするために必要なモジュールを読み込みます。最後に、カーネルパッケージの post-installation スクリプトが <filename>/vmlinuz</filename>、<filename>/vmlinuz.old</filename>、<filename>/initrd.img</filename>、<filename>/initrd.img.old</filename> のシンボリックリンクを更新します。これらはそれぞれインストールされた最新の 2 つのカーネルとカーネルに対応する initrd イメージを指します。
			</para>
			 <para>
				これらの作業のほとんどは <filename>/etc/kernel/*.d/</filename> ディレクトリの中にあるフックスクリプトが担っています。たとえば、<command>grub</command> との統合は、カーネルがインストールまたは削除された際に <command>update-grub</command> を呼び出す <filename>/etc/kernel/postinst.d/zz-update-grub</filename> と <filename>/etc/kernel/postrm.d/zz-update-grub</filename> が担っています。
			</para>

		</section>
		 <section id="sect.kernel-installation-with-dpkg">
			<title><command>dpkg</command> を使ったインストール</title>
			 <para>
				<command>apt</command> はとても便利なので、簡単に低レベルツールについて忘れてしまいます。しかし、コンパイルされたカーネルをインストールする最も簡単な方法は <command>dpkg -i <replaceable>package</replaceable>.deb</command> などのコマンドを使うやり方です。ここで <literal><replaceable>package</replaceable>.deb</literal> は <emphasis role="pkg">linux-image</emphasis> パッケージの名前で、たとえば <filename>linux-image-3.16.7-ckt4-falcot_1_amd64.deb</filename> です。
			</para>
			 <para>
				この章で説明されている設定手順は基本であり、サーバシステムにもワークステーションにも適用でき、半自動化された方法で広く適用できます。しかしながら、この設定手順だけで完全に設定されたシステムを十分に提供することは不可能です。「Unix サービス」として知られている低レベルプログラムを初めとする、いくつかの要素に対する設定がまだ必要です。
			</para>

		</section>

	</section>
</chapter>

