<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>
<chapter id="network-services" lang="ja-JP">
	<chapterinfo>
		 <keywordset>
			<keyword>Postfix</keyword>
			 <keyword>Apache</keyword>
			 <keyword>NFS</keyword>
			 <keyword>Samba</keyword>
			 <keyword>Squid</keyword>
			 <keyword>OpenLDAP</keyword>
			 <keyword>SIP</keyword>

		</keywordset>

	</chapterinfo>
	 <title>ネットワークサービス、Postfix、Apache、NFS、Samba、Squid、LDAP、SIP、XMPP、TURN</title>
	 <highlights> <para>
		ネットワークサービスはユーザが毎日の仕事で直接使用するプログラムです。ネットワークサービスは情報システムの氷山の一角で、この章ではネットワークサービスに注目します。そして、水面下に隠された部分は既に説明したインフラに依存しています。
	</para>
	 <para>
		多くの現代的なネットワークサービスは信頼性と安全性を確保して運用するために暗号化技術を必要としています。特に公開インターネットでは暗号化技術が必要不可欠です。X.509 証明書 (SSL 証明書および TLS 証明書とも呼ばれる場合もあります) は暗号化という目的を果たす際に最もよく使われています。特定のドメインに対する証明書はこの章で紹介するサービス間で共有される場合が多いです。
	</para>
	 <indexterm>
		<primary>TLS</primary>
	</indexterm>
	 <indexterm>
		<primary>X.509</primary>
	</indexterm>
	 <indexterm>
		<primary sortas="ショウメイショ">証明書</primary>
	</indexterm>
	 </highlights> <section id="sect.smtp-mail-server">
		<title>メールサーバ</title>
		 <para>
			Falcot Corp の管理者は信頼性と設定の容易さから電子メールサーバに Postfix を選びました。実際、Postfix の設計によりそれぞれのタスクは必要な最低限のパーミッションを持つ単独のプロセスとして実装されることが強制されます。この制限によりセキュリティ問題を大きく軽減させることが可能です。
		</para>
		 <indexterm>
			<primary sortas="デンシメール">電子メール</primary>
			<secondary>サーバ</secondary>
		</indexterm>
		 <indexterm>
			<primary>メールサーバ</primary>
		</indexterm>
		 <indexterm>
			<primary>Postfix</primary>
		</indexterm>
		 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> Exim4 サーバ</title>
		 <indexterm>
			<primary>Exim</primary>
		</indexterm>
		 <para>
			Debian はデフォルト電子メールサーバとして Exim4 を使います (そのため Exim4 は Debian の初回インストール時に導入されます)。Exim4 の設定は別のパッケージ <emphasis role="pkg">exim4-config</emphasis> で提供され、Debconf を使った一連の質問に答えることで自動的にカスタマイズされます。この質問は <emphasis role="pkg">postfix</emphasis> パッケージの行う質問とよく似ています。
		</para>
		 <para>
			設定は単独の設定ファイル (<filename>/etc/exim4/exim4.conf.template</filename>) か <filename>/etc/exim4/conf.d/</filename> の下に保存された数多くの設定ファイルを通じて行われます。どちらの場合も、<command>update-exim4.conf</command> が設定ファイルをテンプレートとして利用して <filename>/var/lib/exim4/config.autogenerated</filename> を生成します。実際 Exim4 が使うファイルが <filename>/var/lib/exim4/config.autogenerated</filename> です。このメカニズムのおかげで、debconf を通じて Exim に設定した値 (<filename>/etc/exim4/update-exim4.conf.conf</filename> に保存されている値) は管理者や他のパッケージがデフォルトの Exim 設定を変更した場合でも Exim の設定ファイルに反映されます。
		</para>
		 <para>
			Exim4 設定ファイルの構文は特殊で、構文の学習曲線も特殊です。しかしながら、その特殊性を理解すれば、Exim4 は数百ページにおよぶ文書からも明らかな通りとても完全で強力な電子メールサーバです。<ulink type="block" url="http://www.exim.org/docs.html" />
		</para>
		 </sidebar> <section>
			<title>Postfix のインストール</title>
			 <para>
				<emphasis role="pkg">postfix</emphasis> パッケージには主要な SMTP デーモンが含まれます。別のパッケージ (たとえば <emphasis role="pkg">postfix-ldap</emphasis> と <emphasis role="pkg">postfix-pgsql</emphasis> など) は特別な機能を Postfix に追加します。これらのパッケージはマッピングデータベースへのアクセスを可能にします。これらのパッケージは、それが必要と分かっている場合を除いて、インストールするべきではありません。
			</para>
			 <sidebar id="sidebar.smtp"> <title><emphasis>BACK TO BASICS</emphasis> SMTP</title>
			 <indexterm>
				<primary>SMTP</primary>
			</indexterm>
			 <indexterm>
				<primary>Simple Mail Transfer Protocol</primary>
			</indexterm>
			 <indexterm>
				<primary>サーバ</primary>
				<secondary>SMTP</secondary>
			</indexterm>
			 <para>
				メールサーバは SMTP (<emphasis>Simple Mail Transfer Protocol</emphasis>) を使ってメールを交換したり配送したりします。
			</para>
			 </sidebar> <para>
				Debconf はパッケージのインストール中にいくつかの質問を行います。これに答えることで、<filename>/etc/postfix/main.cf</filename> 設定ファイルの最初のバージョンが作成されます。
			</para>
			 <para>
				最初の質問はセットアップの形式に関するものです。インターネットに接続されたサーバに関連するのは提案された選択肢のうちの 2 種類だけです。「インターネットサイト」と「スマートホスト付きインターネット」です。「インターネットサイト」は入って来る電子メールを受け取り、外に出る電子メールを直接受信者に送信するサーバに適します。つまり Falcot Corp の場合にうまく適合します。「スマートホスト付きインターネット」は入って来る電子メールを通常通り受け取り、外に出る電子メールを直接受信者のサーバに送信するのではなく中間 SMTP サーバ「スマートホスト」を介して送信するサーバに適します。この選択肢は主に動的 IP アドレスを持つマシンで役に立ちます。なぜなら、多くの電子メールサーバは動的 IP アドレスを持つホストから配送されたメッセージを拒否するからです。この選択肢を選んだ場合、通常スマートホストに自分の ISP の SMTP サーバを設定します。ISP の SMTP サーバは自分の顧客からの電子メールを受け入れ、それを適切に転送するよう常に設定されています。この (スマートホストを使う) 選択肢はさらにインターネットから切断される可能性のあるサーバにも適しています。なぜなら、後から再試行する必要のある未配送メッセージのキューを管理する必要がなくなるからです。
			</para>
			 <sidebar> <title><emphasis>VOCABULARY</emphasis> ISP</title>
			 <indexterm>
				<primary>ISP、インターネットサービスプロバイダ</primary>
			</indexterm>
			 <para>
				ISP とは「Internet Service Provider」の頭字語です。ISP は通常営利企業で、インターネット接続と関連する基本的サービス (電子メール、ニュースなど) を提供します。
			</para>
			 <para>
			</para>
			 </sidebar> <para>
				2 番目の質問はマシンのフルネームに関するもので、これはローカルユーザの電子メールアドレスを生成するために使われます。従って、マシンのフルネームとはアットマーク (「@」) のすぐ後ろに付けられるものです。Falcot の場合、この質問には <literal>mail.falcot.com</literal> と答えるべきです。デフォルトで聞かれる質問は以上ですが、Falcot にとってこの状態の Postfix はまだ十分に設定されていません。このため、管理者は <command>dpkg-reconfigure postfix</command> を実行してさらに多くのパラメータをカスタマイズします。
			</para>
			 <para>
				<command>dpkg-reconfigure postfix</command> を実行したことで追加的に行われる質問の 1 つに、このマシンに関連するすべてのドメイン名を尋ねる質問があります。デフォルトで挙げられるドメイン名のリストには、マシンのフルネームといくつかの <literal>localhost</literal> の同義語が含まれていますが、主要なドメイン名である <literal>falcot.com</literal> を手作業で追加する必要があります。より一般的に言えば、この質問の回答には、通常 MX サーバを担当しているマシンに割り当てたすべてのドメイン名を含めるべきです。さらに言い換えれば、DNS の MX レコードを参照した際に電子メールを受け入れるサーバとして登録されているすべてのドメイン名を含めるべきです。この情報は最終的に Postfix 主要設定ファイル <filename>/etc/postfix/main.cf</filename> の <literal>mydestination</literal> 変数に設定されます。
			</para>
			 <indexterm>
				<primary>サーバ</primary>
				<secondary>MX</secondary>
			</indexterm>
			 <indexterm>
				<primary>MX</primary>
				<secondary>サーバ</secondary>
			</indexterm>
			 <figure>
				<title>メール送信における DNS <emphasis>MX</emphasis> レコードの役割</title>
				 <mediaobject>
					<imageobject>
						<imagedata fileref="images/mail-server.png" format="PNG" scalefit="1" width="60%" />
					</imageobject>

				</mediaobject>

			</figure>
			 <sidebar> <title><emphasis>EXTRA</emphasis> MX レコードの問い合わせ</title>
			 <para>
				宛先アドレスの DNS に MX レコードが含まれない場合、電子メールサーバは宛先アドレスの A レコード (IPv6 の場合 AAAA レコード) に送信することを試みます。
			</para>
			 </sidebar> <para>
				インストール中に、このサーバが電子メールの送信要求を受け入れるネットワークを尋ねられる場合があります。デフォルトの設定で、Postfix はマシン自身からの電子メールの送信要求だけを受け入れます。従って、通常はローカルネットワークからの送信要求も受け入れるように設定します。Falcot Corp の管理者はデフォルトの回答に <literal>192.168.0.0/16</literal> を追加しました。この質問が尋ねられなければ、以下の例に示す通り、設定ファイル中の関連する変数 <literal>mynetworks</literal> にローカルネットワークを追加します。
			</para>
			 <para>
				ローカル電子メールの配送に <command>procmail</command> を使うことも可能です。<command>procmail</command> を使うことで、ユーザは <filename>~/.procmailrc</filename> ファイルに書かれたルールに従って入って来る電子メールを仕分けすることが可能になります。
			</para>
			 <indexterm>
				<primary><command>procmail</command></primary>
			</indexterm>
			 <indexterm>
				<primary sortas="デンシメール">電子メール</primary>
				<secondary>フィルタ</secondary>
			</indexterm>
			 <indexterm>
				<primary>フィルタ</primary>
				<secondary sortas="デンシメール">電子メール</secondary>
			</indexterm>
			 <para>
				最初のステップの後、以下の設定ファイルが得られます。さらに次の節では、いくつかの特別な機能を追加するための足掛かりとしてこれを使います。
			</para>
			 <example>
				<title>最初の <filename>/etc/postfix/main.cf</filename> ファイル</title>
				 
<programlisting>
# より完全なコメント付きの設定ファイルは /usr/share/postfix/main.cf.dist を参照してください


# Debian 固有の設定方法になりますが、myorigin にファイル名を指定した場合、
# 指定ファイルの最初の行を値として使用します。Debian のデフォルトは
# /etc/mailname です。
#myorigin = /etc/mailname

smtpd_banner = $myhostname ESMTP $mail_name (Debian/GNU)
biff = no

# .domain の追加は MUA が行います。
append_dot_mydomain = no

# "delayed mail" 警告メールを送信するには以下の行を有効化してください
#delay_warning_time = 4h

readme_directory = no

# TLS パラメータ
smtpd_tls_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem
smtpd_tls_key_file=/etc/ssl/private/ssl-cert-snakeoil.key
smtpd_use_tls=yes
smtpd_tls_session_cache_database = btree:${data_directory}/smtpd_scache
smtp_tls_session_cache_database = btree:${data_directory}/smtp_scache

# smtp クライアントで SSL を有効化するための情報を見るには postfix-doc
# パッケージに含まれる /usr/share/doc/postfix/TLS_README.gz を参照してください。

smtpd_relay_restrictions = permit_mynetworks permit_sasl_authenticated defer_unauth_destination
myhostname = mail.falcot.com
alias_maps = hash:/etc/aliases
alias_database = hash:/etc/aliases
myorigin = /etc/mailname
mydestination = mail.falcot.com, falcot.com, localhost.localdomain, localhost
relayhost = 
mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 192.168.0.0/16
mailbox_command = procmail -a "$EXTENSION"
mailbox_size_limit = 0
recipient_delimiter = +
inet_interfaces = all
inet_protocols = all</programlisting>

			</example>
			 <sidebar> <title><emphasis>SECURITY</emphasis> <emphasis>Snake oil</emphasis> SSL 証明書</title>
			 <para>
				<emphasis>snake oil</emphasis> 証明書 (昔に悪徳医者によって販売された<emphasis>いんちき</emphasis>「薬」のようなもの) には全く価値がありません。すなわち、<emphasis>snake oil</emphasis> 証明書を信頼してはいけません。なぜなら、<emphasis>snake oil</emphasis> 証明書は自動生成された自己署名証明書に過ぎないからです。しかしながら、<emphasis>snake oil</emphasis> 証明書は交換される情報のプライバシーを向上させるという意味では有用です。
			</para>
			 <para>
				一般に <emphasis>snake oil</emphasis> 証明書の使用はテスト目的に限り、通常のサービスでは真の証明書を使うべきです。証明書の作成手順は<xref linkend="sect.easy-rsa" />で説明されています。
			</para>
			 </sidebar>
		</section>
		 <section id="sect.configuring-virtual-domains">
			<title>仮想ドメインの設定</title>
			 <indexterm>
				<primary>ドメイン</primary>
				<secondary sortas="カソウ">仮想</secondary>
			</indexterm>
			 <indexterm>
				<primary sortas="カソウドメイン">仮想ドメイン</primary>
			</indexterm>
			 <para>
				メールサーバは主要ドメインに加えて他のドメイン宛の電子メールを受け取ることが可能です。これらは仮想ドメインとして知られています。仮想ドメインを使う場合のほとんどは、電子メールが永久的にローカルユーザに配送されない場合です。Postfix は仮想ドメインを取り扱う 2 種類の興味深い機能を提供します。
			</para>
			 <sidebar> <title><emphasis>CAUTION</emphasis> 仮想ドメインとカノニカルドメイン</title>
			 <para>
				<literal>mydestination</literal> 変数の中で仮想ドメインを参照してはいけません。すなわち <literal>mydestination</literal> 変数に指定できるのはマシンとローカルユーザに直接的に関連付けられた「カノニカル」ドメインの名前だけです。
			</para>
			 </sidebar> <section>
				<title>仮想エイリアスドメイン</title>
				 <indexterm>
					<primary>エイリアス</primary>
					<secondary sortas="カソウエイリアスドメイン">仮想エイリアスドメイン</secondary>
				</indexterm>
				 <indexterm>
					<primary sortas="カソウドメイン">仮想ドメイン</primary>
					<secondary sortas="カソウエイリアスドメイン">仮想エイリアスドメイン</secondary>
				</indexterm>
				 <para>
					仮想エイリアスドメインにはエイリアスだけが含まれます。たとえば、電子メールを他のアドレスに転送するだけのアドレスがこれに該当します。
				</para>
				 <para>
					仮想エイリアスドメインを有効化するには、<literal>virtual_alias_domains</literal> 変数にそのドメイン名を追加し、<literal>virtual_alias_maps</literal> 変数でアドレスマッピングファイルを参照します。
				</para>
				 <example>
					<title><filename>/etc/postfix/main.cf</filename> ファイルに追加する指示文</title>
					 
<programlisting>
virtual_alias_domains = falcotsbrand.com
virtual_alias_maps = hash:/etc/postfix/virtual</programlisting>

				</example>
				 <para>
					<filename>/etc/postfix/virtual</filename> ファイルはかなり直接的な構文で対応付けを記述します。すなわち、各行には空白で分割された 2 つのフィールドが含まれます。最初のフィールドは仮想エイリアス名、2 番目のフィールドはリダイレクトする電子メールアドレスのリストです。<literal>@domain.com</literal> 特殊構文を使うことで、そのドメインに含まれるすべての残りの別名をカバーすることも可能です。
				</para>
				 <example>
					<title><filename>/etc/postfix/virtual</filename> ファイルの例</title>
					 
<programlisting>
webmaster@falcotsbrand.com  jean@falcot.com
contact@falcotsbrand.com    laure@falcot.com, sophie@falcot.com
# 以下の仮想エイリアスは一般的なエイリアスです。このファイルで
# 指定されていない falcotsbrand.com ドメインに含まれるすべての
# アドレスを指定したことになります。これらのアドレス宛の電子メール
# は falcot.com ドメインに存在する同名のユーザに転送されます。
@falcotsbrand.com           @falcot.com</programlisting>

				</example>

			</section>
			 <section>
				<title>仮想メールボックスドメイン</title>
				 <sidebar> <title><emphasis>CAUTION</emphasis> 統合された仮想ドメイン?</title>
				 <para>
					Postfix は <literal>virtual_alias_domains</literal> と <literal>virtual_mailbox_domains</literal> で同じドメインを使うことを許しません。しかしながら、<literal>virtual_mailbox_domains</literal> の各ドメインは明示せずとも <literal>virtual_alias_domains</literal> に含まれます。そのおかげで、仮想ドメインの中でエイリアスとメールボックスを混在させることが可能になります。
				</para>
				 </sidebar> <indexterm>
					<primary sortas="メールボックス、カソウドメイン">メールボックス、仮想ドメイン</primary>
				</indexterm>
				 <indexterm>
					<primary sortas="カソウドメイン">仮想ドメイン</primary>
					<secondary sortas="カソウメールボックスドメイン">仮想メールボックスドメイン</secondary>
				</indexterm>
				 <para>
					仮想メールボックスドメイン宛のメッセージはローカルシステムユーザに割り当てられていないメールボックスに保存されます。
				</para>
				 <para>
					仮想メールボックスドメインを有効化するには、<literal>virtual_mailbox_domains</literal> 変数にそのドメイン名を追加し、<literal>virtual_mailbox_maps</literal> 変数でメールボックスマッピングファイルを参照します。<literal>virtual_mailbox_base</literal> パラメータには、メールボックスが保存されるディレクトリを指定します。
				</para>
				 <para>
					<literal>virtual_uid_maps</literal> (および <literal>virtual_gid_maps</literal>) パラメータは電子メールアドレスとそれに対応するメールボックスを「所有する」システムユーザ (およびグループ) の対応関係を含むファイルを参照します。すべてのメールボックスを同じ所有者とグループによって所有されるようにするには <literal>static:5000</literal> 構文を使って固定された UID/GID (ここでは 5000) を割り当てるようにします。
				</para>
				 <example>
					<title><filename>/etc/postfix/main.cf</filename> ファイルに追加する指示文</title>
					 
<programlisting>
virtual_mailbox_domains = falcot.org
virtual_mailbox_maps = hash:/etc/postfix/vmailbox
virtual_mailbox_base = /var/mail/vhosts</programlisting>

				</example>
				 <para>
					繰り返しになりますが、<filename>/etc/postfix/vmailbox</filename> ファイルの構文はかなり直接的です。つまり、空白で分けられた 2 種類のフィールドで対応関係を表現します。最初のフィールドは仮想ドメインの 1 つに属する電子メールアドレスで、2 番目のフィールドは関連するメールボックスの場所です (これは <emphasis>virtual_mailbox_base</emphasis> 以下から見た相対ディレクトリパスを指定します)。メールボックスの名前がスラッシュ (<literal>/</literal>) で終わっていた場合、電子メールは <emphasis>maildir</emphasis> フォーマットで保存されます。一方、そうでなければ伝統的な <emphasis>mbox</emphasis> フォーマットで保存されます。<emphasis>maildir</emphasis> フォーマットはメールボックスを保存するためにディレクトリ全体を使い、それぞれのメッセージは 1 つのファイルとして保存されます。これに対して、<emphasis>mbox</emphasis> フォーマットでは、メールボックス全体が 1 つのファイルに保存されます。「<literal>From </literal>」(<literal>From</literal> の後に 1 つの空白) で始まる行が新しいメッセージの始まる目印です。
				</para>
				 <example>
					<title><filename>/etc/postfix/vmailbox</filename> ファイル</title>
					 
<programlisting>
# Jean 宛の電子メールは専用ディレクトリ内の 1 ファイルを
# 1 メールに対応付ける maildir フォーマットで保存されます
jean@falcot.org falcot.org/jean/
# Sophie 宛の電子メールは 1 ファイルにすべてのメールを
# 連結する伝統的な "mbox" ファイルに保存されます
sophie@falcot.org falcot.org/sophie</programlisting>

				</example>

			</section>

		</section>
		 <section id="sect.restrictions-for-receiving-and-sending">
			<title>受信と送信の制限</title>
			 <para>
				迷惑メール (<emphasis>スパム</emphasis>) の数が増加したことにより、サーバが受け入れる電子メールの判断基準をますます厳しくすることが要求されるようになっています。この節では Postfix が備えるいくつかの戦略を紹介します。
			</para>
			 <sidebar> <title><emphasis>CULTURE</emphasis> スパム問題</title>
			 <indexterm>
				<primary>スパム</primary>
			</indexterm>
			 <para>
				「スパム」は一般的な用語で、電子メールボックスを満杯にするすべての迷惑メール (UCE としても知られています) を指す場合に使われます。そしてスパムを送信する悪人はスパマーとして知られています。スパマーは自分のやっている迷惑行為にほとんど関心がありません。なぜなら、電子メールを送信する費用はとても安く、受信者の内とても少ない割合がスパム行為の提供物に魅力を感じて送信コストより多くのお金を生むからです。スパム行為はほとんど自動化されています。公開している電子メールアドレス (たとえばウェブフォーラム、メーリングリストのアーカイブ、ブログなどに載せられているメールアドレス) はスパマーのロボットによって発見され、迷惑メッセージを絶えず送りつけられます。
			</para>
			 <para>
				すべてのシステム管理者はスパムフィルタを使ってこの迷惑行為に立ち向かうことを試みます。しかし、もちろんスパマーはスパムフィルタを対処するように調整を続けます。一部のスパマーはさまざまな犯罪組織によりワームに感染させられたマシンのネットワークを借りるかもしれません。最近の統計によればインターネット上を流れるすべての電子メールの 95% 超がスパムであると推定されています!
			</para>
			 </sidebar> <section>
				<title>IP に基づくアクセス制限</title>
				 <para>
					<literal>smtpd_client_restrictions</literal> 指示文を使うことで、電子メールサーバと通信することを許すマシンを制御することが可能です。
				</para>
				 <example>
					<title>クライアントアドレスに基づく制限</title>
					 
<programlisting>
smtpd_client_restrictions = permit_mynetworks,
    warn_if_reject reject_unknown_client,
    check_client_access hash:/etc/postfix/access_clientip,
    reject_rbl_client sbl-xbl.spamhaus.org,
    reject_rbl_client list.dsbl.org</programlisting>

				</example>
				 <para>
					上に挙げた例のように、変数に複数のルールのリストを設定する場合、これらのルールは最初から最後まで順番に評価されます。それぞれのルールはメッセージを受け入れたり、拒否したり、次のルールに決定を任せたりすることが可能です。その結果、順番が重要になります。2 つのルールを入れ替えるだけで挙動が全く違うものになる場合があります。
				</para>
				 <para>
					最初のルールとして使われている <literal>permit_mynetworks</literal> 指示文により、ローカルネットワーク (<emphasis>mynetworks</emphasis> 設定変数によって定義されています) 内のマシンからのすべての電子メールを受け入れるようになります。
				</para>
				 <para>
					<literal>reject_unknown_client</literal> 指示文により、完全に適切な DNS 設定のないマシンからの電子メールを通常拒否するようになります。ここで適切な設定とは、IP アドレスが名前に解決でき、その名前が同じ IP アドレスに解決できることを意味しています。この基準は厳しすぎる場合が多いでしょう。なぜなら、多くの電子メールサーバは IP アドレスに対応する逆引き DNS を持っていないからです。このため、Falcot の管理者は <literal>warn_if_reject</literal> 修飾子を <literal>reject_unknown_client</literal> 指示文の前に置きました。<literal>warn_if_reject</literal> 修飾子を付けることで、拒否するのではなく警告をログに記録するようになります。管理者は、このルールが実際強制された場合に拒否されるかもしれないメッセージの数に目を光らせ、後から十分な情報に基づいてこのルールを強制するか否かを決断することが可能です。
				</para>
				 <sidebar> <title><emphasis>TIP</emphasis> <emphasis>access</emphasis> テーブル</title>
				 <para>
					管理者は送信者、IP アドレス、許可および拒否ホスト名を組み合わせたテーブルを作成し、制限基準としてこれを使うことが可能です。これらのテーブルは <filename>/usr/share/doc/postfix-doc/examples/access.gz</filename> ファイルを展開したコピーを使って作成することも可能です。このひな形には、説明がコメントとして書かれており、それぞれのテーブルがその構文を説明しています。
				</para>
				 <para>
					<filename>/etc/postfix/access_clientip</filename> テーブルは IP アドレスとネットワーク、<filename>/etc/postfix/access_helo</filename> テーブルはドメイン名、<filename>/etc/postfix/access_sender</filename> テーブルは送信者の電子メールアドレスをリストしています。これらのファイルを変更した場合、その後に必ず <command>postmap /etc/postfix/<replaceable>file</replaceable></command> コマンドを使ってファイルをハッシュテーブル (高速アクセスに最適化されたフォーマット) に変換する必要があります。
				</para>
				 </sidebar> <para>
					<literal>check_client_access</literal> 指示文を使うことで、管理者は <filename>/etc/postfix/access_clientip</filename> ファイルに保存された電子メールサーバのブラックリストとホワイトリストを設定することが可能になります。ホワイトリストに含まれるサーバは信頼され、このサーバから来る電子メールは以降のフィルタリングルールを適用されません。
				</para>
				 <para>
					<literal>reject_rbl_client</literal> 指示文を使うことで、指定したブラックリストに含まれるサーバからのメッセージを拒否するようになります。RBL は <emphasis>Remote Black List</emphasis> の頭字語です。ブラックリストは複数存在しますが、どのブラックリストにもスパマーが電子メールを中継するために使う下手に設定されたサーバ、ワームやウイルスに感染したマシンのような本来の意図と異なりメール中継させられているサーバがリストされています。
				</para>
				 <indexterm>
					<primary>RBL</primary>
				</indexterm>
				 <indexterm>
					<primary>Remote Black List</primary>
				</indexterm>
				 <sidebar> <title><emphasis>TIP</emphasis> ホワイトリストと RBL</title>
				 <para>
					ブラックリストには過去に異常が発生した正当なサーバが含まれることもあります。この場合、そのようなサーバからのすべての電子メールは拒否されます。これを受け入れるには <filename>/etc/postfix/access_clientip</filename> によって定義されたホワイトリストの中にそのサーバをリストするしかありません。
				</para>
				 <para>
					このため、よく考えた上で、通常電子メールを受け取るような信頼できるサーバはすべてホワイトリストの中に含めることを推奨します。
				</para>
				 </sidebar>
			</section>
			 <section>
				<title><literal>EHLO</literal> または <literal>HELO</literal> コマンドの妥当性確認</title>
				 <para>
					SMTP でメールを送信するには、最初にサーバへ <literal>HELO</literal> (または <literal>EHLO</literal>) の後に送信元の名前を付けたコマンドを送ります。送信元の名前の妥当性を確認することは興味深いです。
				</para>
				 <indexterm>
					<primary><literal>HELO</literal></primary>
				</indexterm>
				 <indexterm>
					<primary><literal>EHLO</literal></primary>
				</indexterm>
				 <example>
					<title><literal>EHLO</literal> の引数に与えられる名前の制限</title>
					 
<programlisting>
smtpd_helo_restrictions = permit_mynetworks,
    reject_invalid_hostname,
    check_helo_access hash:/etc/postfix/access_helo,
    reject_non_fqdn_hostname,
    warn_if_reject reject_unknown_hostname</programlisting>

				</example>
				 <para>
					最初の <literal>permit_mynetworks</literal> 指示文を使うことで、ローカルネットワーク上のすべてのマシンならば <literal>HELO</literal> コマンドの引数にどのような名前を使っても良いことになります。これは重要です。なぜなら、一部の電子メールプログラムは SMTP プロトコルのこの部分を十分適切に尊重せず <literal>HELO</literal> の引数に無意味な名前を使うからです。
				</para>
				 <para>
					<literal>reject_invalid_hostname</literal> ルールを使うことで、<literal>EHLO</literal> で申告されたホスト名が構文的に不正な電子メールを拒否するようになります。<literal>reject_non_fqdn_hostname</literal> ルールを使うことで、申告されたホスト名が完全修飾ドメイン名 (ホスト名まで含むドメイン名) でないメッセージを拒否するようになります。<literal>reject_unknown_hostname</literal> ルールを使うことで、申告された名前が DNS に存在しないメッセージを拒否するようになります。<literal>reject_unknown_hostname</literal> ルールを適用すると数多くの電子メールが拒否されることになるため、管理者は <literal>warn_if_reject</literal> 修飾子を付けて警告するだけにしています。管理者は <literal>reject_unknown_hostname</literal> ルールの結果を調査した後に、最後の段階で <literal>warn_if_reject</literal> 修飾子を削除するか判断します。
				</para>
				 <para>
					<literal>permit_mynetworks</literal> をルール群の先頭で使うと、面白い副作用があります。すなわち、それ以降のルールがローカルネットワークの外のホストにのみ適用されるようになります。これを使うことで、自分を <literal>falcot.com</literal> の一部と申告するすべてのホストをブラックリスト化できます。これを行うには、たとえば <literal>falcot.com REJECT You are not in our network!</literal> のような行を <filename>/etc/postfix/access_helo</filename> ファイルに追加します。
				</para>

			</section>
			 <section>
				<title>申告された送信者アドレスに基づく受け入れおよび拒否</title>
				 <para>
					各メッセージには送信者アドレスが必要です。送信者アドレスは SMTP プロトコルの <literal>MAIL FROM</literal> コマンドで申告されます。繰り返しになりますが、さまざまな異なる方法で送信者アドレスの有効性を判断します。
				</para>
				 <indexterm>
					<primary><literal>MAIL FROM</literal></primary>
				</indexterm>
				 <indexterm>
					<primary sortas="デンシメール">電子メール</primary>
					<secondary sortas="ソウシンシャアドレスニモトヅクフィルタリング">送信者アドレスに基づくフィルタリング</secondary>
				</indexterm>
				 <example>
					<title>送信者アドレスの確認</title>
					 
<programlisting>
smtpd_sender_restrictions = 
    check_sender_access hash:/etc/postfix/access_sender,
    reject_unknown_sender_domain, reject_unlisted_sender,
    reject_non_fqdn_sender</programlisting>

				</example>
				 <para>
					<literal>check_sender_access</literal> ルールを使うことで、<filename>/etc/postfix/access_sender</filename> テーブルで指定した一部の送信者を特別扱いすることが可能です。このルールは一部の送信者をホワイトリストやブラックリストに入れることを意味します。
				</para>
				 <para>
					<literal>reject_unknown_sender_domain</literal> ルールを使うことで、送信者アドレスに適切なドメインが含まれることを強制することが可能です。なぜなら、適切なアドレスならば必ず適切なドメインを含むからです。<literal>reject_unlisted_sender</literal> ルールを使うことで、アドレスが存在しないローカル送信者を拒否します。さらに <literal>reject_unlisted_sender</literal> ルールを使うことで、<literal>falcot.com</literal> ドメイン内の不正なアドレスから電子メールが送信されること避けることが可能になり、<literal>joe.bloggs@falcot.com</literal> などのアドレスが本当に存在する場合のみそのアドレスから送信されるメッセージを受け入れるようになります。
				</para>
				 <para>
					最後に、<literal>reject_non_fqdn_sender</literal> ルールを使うことで、完全修飾ドメイン名を持たないアドレスから送信されたと称する電子メールを拒否します。具体的には、<literal>user@machine</literal> からの電子メールを拒否します。すなわち、送信者アドレスは必ず <literal>user@machine.example.com</literal> または <literal>user@example.com</literal> の形で申告されなければいけないということです。
				</para>

			</section>
			 <section>
				<title>受信者アドレスに基づく受け入れおよび拒否</title>
				 <para>
					各メッセージには少なくとも 1 つの受信者アドレスが必要です。受信者アドレスは SMTP プロトコルの <literal>RCPT TO</literal> コマンドで申告されます。送信者アドレスに対して行った確認よりも関係性は低いとは言うものの、受信者アドレスの正当性を確認することは当然です。
				</para>
				 <indexterm>
					<primary>RCPT TO</primary>
				</indexterm>
				 <indexterm>
					<primary sortas="デンシメール">電子メール</primary>
					<secondary sortas="ジュシンシャアドレスニモトヅクフィルタリング">受信者アドレスに基づくフィルタリング</secondary>
				</indexterm>
				 <example>
					<title>受信者アドレスの確認</title>
					 
<programlisting>
smtpd_recipient_restrictions = permit_mynetworks, 
    reject_unauth_destination, reject_unlisted_recipient, 
    reject_non_fqdn_recipient</programlisting>

				</example>
				 <para>
					<literal>reject_unauth_destination</literal> は基本的なルールで、受け入れ要求のあったメッセージが自分の管理するユーザ宛であることを確認します。すなわち、このサーバにないアドレス宛のメッセージを拒否するということです。このルールを指定しなかった場合、サーバがスパマーによって迷惑メールを送信するための第三者中継サーバとして使われる可能性が出てきます。このため <literal>reject_unauth_destination</literal> ルールは必須で、ルールリストの先頭に近い位置に置くのが最良です。そうすれば、メッセージの宛先をチェックする前に、他のルールがそのメッセージの受け入れを許可することを避けられます。
				</para>
				 <para>
					<literal>reject_unlisted_recipient</literal> ルールを使うことで、存在しないローカルユーザ宛のメッセージを拒否するようになります。これは道理に適ったルールです。最後に、<literal>reject_non_fqdn_recipient</literal> ルールを使うことで、完全修飾ドメイン名でないアドレスを拒否するようになります。さらに <literal>reject_non_fqdn_recipient</literal> ルールを使った場合、<literal>jean</literal> や <literal>jean@machine</literal> 宛の電子メールは送信できず、その代わりに <literal>jean@machine.falcot.com</literal> や <literal>jean@falcot.com</literal> などの完全なアドレスを使うことが要求されます。
				</para>

			</section>
			 <section>
				<title><literal>DATA</literal> コマンドに関連付けられた制限</title>
				 <para>
					SMTP の <literal>DATA</literal> コマンドはメッセージ内容の前に送信されます。<literal>DATA</literal> コマンドの後に送信されるメッセージ内容はさておき、厳密な意味では <literal>DATA</literal> コマンドはいかなる情報も提供しません。とは言っても、確認することは可能です。
				</para>
				 <indexterm>
					<primary><literal>DATA</literal></primary>
				</indexterm>
				 <example>
					<title><literal>DATA</literal> の確認</title>
					 
<programlisting>
smtpd_data_restrictions = reject_unauth_pipelining</programlisting>

				</example>
				 <para>
					<literal>reject_unauth_pipelining</literal> 指示文を使うことで、1 つ前に送信されたコマンドに応答する前に送信者が次のコマンドを送ったメッセージを拒否するようになります。この防御はスパマーロボットの使う一般的な最適化に対抗するものです。なぜなら、スパマーはサーバからの応答の結果を気にせず、可能な限り短い時間で可能な限り大量の電子メールを送信することだけに注目しているからです。
				</para>

			</section>
			 <section>
				<title>拒否応答の送信段階</title>
				 <para>
					上のコマンドを使うことで SMTP 交換のさまざまな段階で情報が検査されるにも関わらず、Postfix が実際の拒否を送信するのは <literal>RCPT TO</literal> コマンドに対する応答の段階です。
				</para>
				 <para>
					これは不正な <literal>EHLO</literal> コマンドが原因でメッセージを拒否する場合でも、Postfix はメッセージの送信者と受信者を知った後に拒否応答を送信することを意味しています。こうすることで、すぐにトランザクションを拒否するよりも明確なログを残すことが可能です。加えて、多くの SMTP クライアントはトランザクションの最初の方の SMTP コマンドの失敗を予期していませんから、<literal>RCPT TO</literal> の後に拒否応答を返したとしても問題になることは少ないです。
				</para>
				 <para>
					こうすることによる最後の利点は SMTP 交換のさまざまなステージの間にやり取りした情報を総合的に検討することが可能であるという点です。これにより、パーミッションをきめ細かく調整することが可能です。たとえば、ローカル送信者のふりをする外部接続を拒否することなどが可能です。
				</para>

			</section>
			 <section>
				<title>メッセージ内容に基づくフィルタリング</title>
				 <para>
					メッセージ内容を確認することにより、妥当性確認と制限システムが完成します。Postfix は電子メール本文や電子メールヘッダの内容に対して確認を適用し、その妥当性を識別することが可能です。
				</para>
				 <example>
					<title>内容に基づくフィルタの有効化</title>
					 
<programlisting>
header_checks = regexp:/etc/postfix/header_checks
body_checks = regexp:/etc/postfix/body_checks</programlisting>

				</example>
				 <indexterm>
					<primary sortas="デンシメール">電子メール</primary>
					<secondary sortas="ナイヨウニモトヅクフィルタリング">内容に基づくフィルタリング</secondary>
				</indexterm>
				 <para>
					どちらのファイルにも、正規表現 (<emphasis>regexp</emphasis> または <emphasis>regex</emphasis> としても知られます) のリストおよび、電子メールヘッダ (または本文) がその正規表現にマッチする場合に実行する動作の対応リストが含まれます。
				</para>
				 <sidebar> <title><emphasis>QUICK LOOK</emphasis> 正規表現テーブル</title>
				 <para>
					<filename>/usr/share/doc/postfix-doc/examples/header_checks.gz</filename> ファイルには多くの説明的なコメントが含まれます。またこのファイルを <filename>/etc/postfix/header_checks</filename> と <filename>/etc/postfix/body_checks</filename> ファイルの足掛かりとして使うことも可能です。
				</para>
				 </sidebar> <example>
					<title><filename>/etc/postfix/header_checks</filename> ファイルの例</title>
					 
<programlisting>
/^X-Mailer: GOTO Sarbacane/ REJECT I fight spam (GOTO Sarbacane)
/^Subject: *Your email contains VIRUSES/ DISCARD virus notification</programlisting>

				</example>
				 <sidebar id="sidebar.regexp"> <title><emphasis>BACK TO BASICS</emphasis> 正規表現</title>
				 <para>
					<emphasis>正規表現</emphasis> (<emphasis>regexp</emphasis> または <emphasis>regex</emphasis> のように略されます) という用語は内容の説明や文字列の構造を表現する一般的な記法です。特別な文字を使って選択肢 (たとえば、<literal>foo|bar</literal> は「foo」または「bar」にマッチします)、許容する文字 (たとえば、<literal>[0-9]</literal> は任意の数字を意味し、単独のドット <literal>.</literal> は任意の文字を意味します)、数量 (<literal>s?</literal> は <literal>s</literal> または空文字列にマッチします。言い換えれば <literal>s</literal> が 0 または 1 回出現したらマッチします。<literal>s+</literal> は 1 つかそれ以上の連続する <literal>s</literal> 文字にマッチします) を表現します。丸括弧を使うことで検索結果のグループ化が可能です。
				</para>
				 <para>
					正規表現の正確な構文は正規表現を取り扱うツールに依存しますが、基本的な機能は似ています。<ulink type="block" url="http://en.wikipedia.org/wiki/Regular_expression" />
				</para>
				 </sidebar> <para>
					最初の正規表現は電子メールソフトウェアに関するヘッダを確認します。そして <literal>GOTO Sarbacane</literal> (大量の電子メールを送信するソフトウェア) が見つかったら、メッセージを拒否します。2 番目の正規表現はメッセージの件名を操作します。そしてメッセージの件名にウイルス通知が含まれる場合、そのメッセージを拒否しない代わりにすぐに捨てます。
				</para>
				 <para>
					これらのフィルタを使うことは諸刃の剣です。なぜなら、一般的過ぎるルールを設定すれば結果的に適切なメールを失うことになるからです。そのような場合、メッセージが失われるだけでなく、送信者は望まない (そして煩い) エラーメッセージを受け取ることになるでしょう。
				</para>

			</section>

		</section>
		 <section id="sect.setting-up-greylisting">
			<title><foreignphrase>greylisting</foreignphrase> の設定</title>
			 <indexterm>
				<primary>greylisting</primary>
			</indexterm>
			 <para>
				「greylisting」はフィルタリング技術です。「greylisting」を使うことで、最初にメッセージを一時的なエラーコードとともに拒否し、少しの遅延の後に何回か試行すれば許可するというような挙動が可能です。「greylisting」は特にワームとウイルスに侵された数多くのマシンが送信するスパムに対して効果的です。なぜなら、ワームやウイルスは完全な SMTP エージェントとして振る舞うことはほとんどない (エラーコードを確認して失敗したメッセージを後から再試行することはほとんどない) ですし、特に収集されたアドレスのほとんどは実際のところ無価値なアドレスであるという点を考慮すると、再試行は時間の無駄にしかならないからです。
			</para>
			 <para>
				Postfix それ自身は greylisting 機能を提供しませんが、あるメッセージを受け入れるか拒否するかの決定を外部プログラムに委任する機能を提供します。<emphasis role="pkg">postgrey</emphasis> パッケージには greylisting 機能を提供するプログラムが含まれ、このプログラムはアクセスポリシー委任サービスへのインターフェースとして設計されています。
			</para>
			 <para>
				<emphasis role="pkg">postgrey</emphasis> がインストールされると、<command>postgrey</command> はデーモンとして実行され、ポート 10023 番をリッスンします。この後 Postfix の設定に <literal>check_policy_service</literal> ルールを追加することで、Postfix は <command>postgrey</command> デーモンを使うようになります。
			</para>
			 
<programlisting>
smtpd_recipient_restrictions = permit_mynetworks,
    [...]
    check_policy_service inet:127.0.0.1:10023</programlisting>
			 <para>
				Postfix はルールセットの中にあるこのルールに到達したら、<command>postgrey</command> デーモンに接続し、対応するメッセージに関する情報をデーモンに送信します。Postgrey は IP アドレス/送信者/受信者の三つぞろいを考慮し、同じ三つぞろいが最近データベースに登録されたか否かをデータベースで確認します。最近登録されていた場合、Postgrey はメッセージを受け入れるべきであると応答します。さらに、最近登録されていなかった場合、Postgrey はメッセージを一時的に拒否するべきであると応答し、三つぞろいをデータベースに登録します。
			</para>
			 <para>
				greylisting の主な不都合は正当なメッセージの配送が遅れる点です。この欠点が許容できない場合もあります。さらに、送信するメールのほとんどが正当な場合、greylisting はサーバの負荷を増加させます。
			</para>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> greylisting の欠点</title>
			 <para>
				理論上 greylisting はある送信者からある受信者に送信される最初のメールだけを対象にしており、greylisting による典型的な遅延時間はほぼ数分程度です。しかしながら、実際は少し違います。一部の大きな ISP は複数の SMTP サーバを運用します。このようなサーバ群からメッセージを送信することを考えます。1 回目の送信要求を出すサーバはその送信要求を拒否されますが、2 回目の送信要求を出すサーバは 1 回目のサーバと違う可能性があります。これが起きた場合、2 回目の送信要求を出すサーバは greylisting のおかげでもう一度一時的なエラーメッセージを受け取ります。同様に、3 回目の送信要求を出すサーバが既に受信側の greylisting データベースに登録済みのサーバに一致するのには数時間かかる可能性があります。なぜなら、通常 SMTP サーバは再試行が失敗した場合に遅延時間を増やすからです。
			</para>
			 <para>
				その結果、同じ送信者からであっても送信要求を行う IP アドレスは毎回変わるかもしれません。もっと言えば、送信者アドレスさえも変わる可能性があります。たとえば、多くのメーリングリストサーバはエラーメッセージ (<emphasis>bounce</emphasis> として知られます) を取り扱うために送信者アドレス内の追加的な情報を符号化します。メーリングリスト宛に送信される新しいメッセージは greylisting を通過することが必要かもしれません。これは新しいメッセージが送信者のサーバに (一時的に) 保存されることを意味します。とても巨大な (数万人が登録する) メーリングリストの場合、これは問題になることがあります。
			</para>
			 <para>
				これらの欠点を軽減するために、Postgrey は複数の SMTP サーバを運用するサイトのホワイトリストを管理しています。ホワイトリストに登録されている送信者から送信要求のあったメッセージは greylisting を通過することなしにすぐに受け入れられます。このリストを自分の要求に適用することは簡単です。なぜなら、ホワイトリストは <filename>/etc/postgrey/whitelist_clients</filename> ファイルに保存されているからです。
			</para>
			 </sidebar> <sidebar> <title><emphasis>GOING FURTHER</emphasis> <emphasis role="pkg">milter-greylist</emphasis> を使った選択的 greylisting</title>
			 <para>
				メール配送の遅延時間が長くなるという greylisting の欠点を低減するには、既にスパムの発生源と考えられている (DNS ブラックリストに載せられている) サブネットのクライアントだけを対象に greylisting を使います。<emphasis role="pkg">postgrey</emphasis> ではこの機能を使うことができませんが、<emphasis role="pkg">milter-greylist</emphasis> でこの機能を使います。
			</para>
			 <para>
				この機能を利用する場合、DNS ブラックリストに載っていたからと言って必ず拒否されるわけではなくなるので、より広範囲におよぶブラックリスト (たとえば <literal>pbl.spamhaus.org</literal> や <literal>dul.dnsbl.sorbs.net</literal> など) を使うことが妥当です。そのようなブラックリストには、ISP クライアントからのすべての動的 IP アドレスも含まれます。
			</para>
			 <para>
				milter-greylist は Sendmail の milter インターフェースを使うため、postfix 側からは「<literal>smtpd_milters = unix:/var/run/milter-greylist/milter-greylist.sock</literal>」と設定する以上のことができません。<citerefentry><refentrytitle>greylist.conf</refentrytitle>
				<manvolnum>5</manvolnum></citerefentry> マニュアルページには、<filename>/etc/milter-greylist/greylist.conf</filename> と milter-greylist を設定するさまざまな方法が書かれています。実際にサービスを有効化するにはさらに <filename>/etc/default/milter-greylist</filename> を編集する必要があるでしょう。
			</para>
			 </sidebar>
		</section>
		 <section>
			<title>受信者アドレスに基づくフィルタのカスタマイズ</title>
			 <para>
				<xref linkend="sect.restrictions-for-receiving-and-sending" />と<xref linkend="sect.setting-up-greylisting" />では、さまざまな制限方法を見直しました。これらの制限方法はスパムの受信量を減らすためのものですが、欠点もあります。このため、受信者ごとにフィルタのセットをカスタマイズすることが普通のやり方になりつつあります。Falcot Corp では、greylisting は多くのユーザからすると興味深いものですが、電子メールを素早く受け取りたい一部のユーザ (たとえば技術サポートサービスを担当しているユーザ) からすると仕事の妨げになります。同様に、商業サービス担当からするとブラックリストに載っているかもしれない一部のアジアプロバイダから送信された電子メールを受信できない点は問題となります。従って、商業サービス用のアドレスに対してはフィルタリングを行わず、この種の送信者と連絡が取れるようにするほうが好都合でしょう。
			</para>
			 <para>
				Postfix は「制限クラス」の概念を使ってフィルタをカスタマイズします。制限クラスは <literal>smtpd_restriction_classes</literal> パラメータの中で宣言され、<literal>smtpd_recipient_restrictions</literal> と同じやり方で使用されます。<literal>check_recipient_access</literal> 指示文は与えられた受信者と制限の適切なセットを対応付けるテーブルを定義します。
			</para>
			 <example>
				<title><filename>main.cf</filename> における制限クラスの定義</title>
				 
<programlisting>smtpd_restriction_classes = greylisting, aggressive, permissive

greylisting = check_policy_service inet:127.0.0.1:10023
aggressive = reject_rbl_client sbl-xbl.spamhaus.org,
        check_policy_service inet:127.0.0.1:10023
permissive = permit

smtpd_recipient_restrictions = permit_mynetworks,
        reject_unauth_destination,
        check_recipient_access hash:/etc/postfix/recipient_access</programlisting>

			</example>
			 <example>
				<title><filename>/etc/postfix/recipient_access</filename> ファイル</title>
				 
<programlisting>
# 無制限に受信するアドレス
postmaster@falcot.com  permissive
support@falcot.com     permissive
sales-asia@falcot.com  permissive

# 特権ユーザに対する積極的なフィルタリング
joe@falcot.com         aggressive

# メーリングリスト管理者用の特別なルール
sympa@falcot.com       reject_unverified_sender

# デフォルトの greylisting 設定
falcot.com             greylisting</programlisting>

			</example>

		</section>
		 <section id="sect.postfix-antivirus">
			<title>アンチウイルスの統合</title>
			 <indexterm>
				<primary>antivirus</primary>
			</indexterm>
			 <para>
				数多くのウイルスが電子メールの添付ファイルとして配布されているため、会社のネットワークの入口にアンチウイルスをセットアップすることは重要です。なぜなら、啓発活動にも関わらず、明らかに疑わしいメッセージの添付ファイルを開けてしまうユーザがいるからです。
			</para>
			 <para>
				Falcot の管理者は自由なアンチウイルスとして <command>clamav</command> を選びました。<command>clamav</command> の主パッケージは <emphasis role="pkg">clamav</emphasis> ですが、<emphasis role="pkg">arj</emphasis>、<emphasis role="pkg">unzoo</emphasis>、<emphasis role="pkg">unrar</emphasis>、<emphasis role="pkg">lha</emphasis> などのいくつかのパッケージを追加でインストールしました。なぜなら、これらのパッケージはアンチウイルスがそれらのフォーマットで圧縮された添付ファイルを解析する際に必要だからです。
			</para>
			 <indexterm>
				<primary><command>clamav</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>clamav-milter</command></primary>
			</indexterm>
			 <para>
				<command>clamav-milter</command> はアンチウイルスと電子メールサーバのやり取りを仲介する作業を担当します。<emphasis>milter</emphasis> (<emphasis>mail filter</emphasis> の略) は電子メールサーバに対するインターフェースとして特別に設計されたフィルタプログラムです。milter は標準的なアプリケーションプログラミングインターフェース (API) を使います。API を使うことで電子メールサーバの外にあるフィルタを使うよりも性能が向上します。milter は 最初 <emphasis>Sendmail</emphasis> に導入されましたが、すぐ後に <emphasis>Postfix</emphasis> にも導入されました。
			</para>
			 <sidebar> <title><emphasis>QUICK LOOK</emphasis> SpamAssassin 用の milter</title>
			 <indexterm>
				<primary><emphasis role="pkg">spamass-milter</emphasis></primary>
			</indexterm>
			 <para>
				<emphasis role="pkg">spamass-milter</emphasis> パッケージは有名な迷惑メール検出ソフトウェアである <emphasis>SpamAssassin</emphasis> に基づく milter を提供します。これは、(ヘッダを追加することで) スパムと思われるメッセージを注意するために使うことが可能です。さらにスパム度のスコアが指定されたしきい値を超えたらメッセージを拒否することも可能です。
			</para>
			 </sidebar> <para>
				<emphasis role="pkg">clamav-milter</emphasis> パッケージをインストールしたら、milter をデフォルトのポートではない適当な TCP ポートで実行するように再設定するべきです。これを行うには、<command>dpkg-reconfigure clamav-milter</command> を実行します。そして「Sendmail とのコミュニケーションインターフェイス」が表示されたら「<literal>inet:10002@127.0.0.1</literal>」と答えます。
			</para>
			 <sidebar> <title><emphasis>NOTE</emphasis> 真の TCP ポート vs 名前付きソケット</title>
			 <para>
				名前付きソケットではなく実在する TCP ポートを使う理由は、postfix デーモンは chroot された状態で実行されることが多く、その場合名前付きソケットの存在するディレクトリにアクセスできないからです。名前付きソケットを使い、これを chroot 中 (<filename>/var/spool/postfix/</filename>) に入れておくことも可能です。
			</para>
			 </sidebar> <para>
				ClamAV の標準的な設定は多くの状況に適合しますが、<command>dpkg-reconfigure clamav-base</command> を使えばいくつかの重要なパラメータをカスタマイズすることも可能です。
			</para>
			 <para>
				最後の段階で、最近設定したフィルタを使うように Postfix を設定します。これは <filename>/etc/postfix/main.cf</filename> に以下の指示文を追加するだけで簡単に設定できます。
			</para>
			 
<programlisting>
# clamav-milter を使ったウイルスチェック
smtpd_milters = inet:[127.0.0.1]:10002</programlisting>
			 <para>
				アンチウイルスによって問題が起こる場合、この行をコメントアウトして <command>service postfix reload</command> を実行します。こうすることでアンチウイルスが無効化されます。
			</para>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> アンチウイルスのテスト</title>
			 <para>
				アンチウイルスをセットアップしたら、正常な挙動をテストするべきです。最も簡単にテストするには、<filename>eicar.com</filename> (または <filename>eicar.com.zip</filename>) を添付したテストメールを送信します。このファイルはオンラインからダウンロードできます。<ulink type="block" url="http://www.eicar.org/86-0-Intended-use.html" />
			</para>
			 <para>
				このファイルは、本物のウイルスではなくテストファイルです。市場に出ているすべてのアンチウイルスソフトウェアはこのファイルをウイルスと判定しますから、これを使うことでインストールの正しさを確認できます。
			</para>
			 </sidebar> <para>
				これで Postfix を介して送信されるすべてのメッセージはアンチウイルスフィルタを通過するようになります。
			</para>

		</section>
		 <section id="sect.authenticated-smtp">
			<title>SMTP 認証</title>
			 <para>
				電子メールを送信するには SMTP サーバにアクセスできなければいけません。さらに、電子メールを送信するには上で設定した SMTP サーバが必要です。ローミングユーザの場合、SMTP クライアントの設定を定期的に変更する必要があるかもしれません。なぜなら、Falcot の SMTP サーバは明らかに会社に所属しない IP アドレスから受け取ったメッセージを拒否するからです。これに対して 2 つの解決策が存在します。すなわち、ローミングユーザが自分のコンピュータに SMTP サーバをインストールするか、雇用者としての認証を済ませた後に会社のサーバを使うかのどちらか一方です。自分の SMTP サーバをインストールするという解決策は推奨されません。なぜなら、ローミングユーザのコンピュータは永久的にネットワークに接続されているわけではありませんし、問題の起きた際にメッセージを再送信することができないからです。ここでは認証を行うという解決策に注目します。
			</para>
			 <para>
				Postfix の SMTP 認証は SASL (<emphasis>Simple Authentication and Security Layer</emphasis>) を使っています。SASL を使うには、<emphasis role="pkg">libsasl2-modules</emphasis> と <emphasis role="pkg">sasl2-bin</emphasis> パッケージをインストールして、SASL データベースに SMTP サーバの認証に必要なパスワードをユーザごとに登録する必要があります。パスワードを登録するには、<command>saslpasswd2</command> コマンドを使います。<command>saslpasswd2</command> コマンドはいくつかのパラメータを取ります。<literal>-u</literal> オプションは認証するドメインを定義します。これは Postfix 設定の <literal>smtpd_sasl_local_domain</literal> パラメータと一致しなければいけません。<literal>-c</literal> オプションはユーザを作成します。<literal>-f</literal> オプションは SASL データベースをデフォルト (<filename>/etc/sasldb2</filename>) とは異なる場所に保存することが必要な場合にデータベースファイルの位置を指定します。
			</para>
			 
<screen role="scale">
<computeroutput># </computeroutput><userinput>saslpasswd2 -u `postconf -h myhostname` -f /var/spool/postfix/etc/sasldb2 -c jean</userinput>
<computeroutput>[... jean のパスワードを 2 回入力します ...]</computeroutput></screen>
			 <para>
				SASL データベースは Postfix のディレクトリの中に作成されなければいけない点に注意してください。整合性を確保するために、<command>ln -sf /var/spool/postfix/etc/sasldb2 /etc/sasldb2</command> コマンドを使って <filename>/etc/sasldb2</filename> を Postfix の使うデータベースを指すシンボリックリンクにします。
			</para>
			 <para>
				この後に Postfix が SASL を使うように設定します。<literal>postfix</literal> ユーザを <literal>sasl</literal> グループに追加して、SASL アカウントデータベースにアクセスできるようにします。Postfix で SASL を有効化するには、いくつかの新しいパラメータが必要です。また、SASL 認証されたクライアントが自由に電子メールを送信することを許可するには、<literal>smtpd_recipient_restrictions</literal> パラメータを設定します。
			</para>
			 <example>
				<title><filename>/etc/postfix/main.cf</filename> の中で SASL を有効化</title>
				 
<programlisting>
# SASL 認証を有効化します
smtpd_sasl_auth_enable = yes
# SASL 認証を適用するドメインを定義します
smtpd_sasl_local_domain = $myhostname
[...]
# reject_unauth_destination の前に permit_sasl_authenticated を
# 追加すれば、SASL 認証済みユーザが送信したメールの中継が許可されます
smtpd_recipient_restrictions = permit_mynetworks,
    permit_sasl_authenticated,
    reject_unauth_destination,
[...]</programlisting>

			</example>
			 <sidebar> <title><emphasis>EXTRA</emphasis> 認証済み SMTP クライアント</title>
			 <para>
				多くの電子メールクライアントはメッセージを送信する前に SMTP サーバに対して認証依頼する機能を持っており、適切なパラメータを設定するだけで簡単に SASL 認証機能を使うことが可能です。クライアントが SASL 認証機能を持たない場合、ローカル Postfix サーバを使い、リモート SMTP サーバに電子メールを中継するようにローカル Postfix サーバを設定することが次善策です。この場合、ローカル Postfix が SASL を使って認証するクライアントになります。以下に必要なパラメータを示します。
			</para>
			 
<programlisting>
smtp_sasl_auth_enable = yes
smtp_sasl_password_maps = hash:/etc/postfix/sasl_passwd
relay_host = [mail.falcot.com]</programlisting>
			 <para>
				<filename>/etc/postfix/sasl_passwd</filename> ファイルには、<literal>mail.falcot.com</literal> サーバに認証を依頼する際に使うユーザ名とパスワードを含めます。以下に例を示します。
			</para>
			 
<programlisting>
[mail.falcot.com]   joe:LyinIsji</programlisting>
			 <para>
				すべての Postfix のマッピングファイルについて言えることですが、<command>postmap</command> コマンドを使ってこのファイルを <filename>/etc/postfix/sasl_passwd.db</filename> に変換しなければいけません。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.http-web-server">
		<title>ウェブサーバ (HTTP)</title>
		 <para>
			Falcot Corp の管理者は Debian <emphasis role="distribution">Jessie</emphasis> に含まれるバージョン 2.4.10 の Apache HTTP サーバを使うことに決めました。
		</para>
		 <indexterm>
			<primary><command>apache</command></primary>
		</indexterm>
		 <indexterm>
			<primary>サーバ</primary>
			<secondary>ウェブ</secondary>
		</indexterm>
		 <indexterm>
			<primary>ウェブサーバ</primary>
		</indexterm>
		 <indexterm>
			<primary>サーバ</primary>
			<secondary>HTTP</secondary>
		</indexterm>
		 <indexterm>
			<primary>HTTP</primary>
			<secondary>サーバ</secondary>
		</indexterm>
		 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> 他のウェブサーバ</title>
		 <para>
			Apache は最も広く知られている (最も広く使われている) ウェブサーバですが、他にもウェブサーバは存在します。これらのサーバはわずかな負荷で高い性能を発揮しますが、利用できる機能やモジュールが少ないという欠点も持っています。しかしながら、静的ファイルを提供する用途やプロキシ用途にウェブサーバを使う場合、<emphasis role="pkg">nginx</emphasis> や <emphasis role="pkg">lighttpd</emphasis> などの代替品は調査する価値があります。
		</para>
		 <indexterm>
			<primary><emphasis role="pkg">nginx</emphasis></primary>
		</indexterm>
		 <indexterm>
			<primary><emphasis role="pkg">lighttpd</emphasis></primary>
		</indexterm>
		 </sidebar> <section>
			<title>Apache のインストール</title>
			 <para>
				<emphasis role="pkg">apache2</emphasis> パッケージをインストールするだけで、Apache に必要な物はすべてインストールされます。パッケージには <emphasis>Multi-Processing Modules</emphasis> (MPMs) も含まれており、MPM は Apache が多くの要求の並列処理を取り扱う方法に影響をおよぼします (以前の MPM はそれぞれ対応する <emphasis role="pkg">apache2-mpm-*</emphasis> パッケージから提供されていました)。<emphasis role="pkg">apache2</emphasis> パッケージは <emphasis role="pkg">apache2-utils</emphasis> パッケージに依存しており、<emphasis role="pkg">apache2-utils</emphasis> パッケージには後に使うコマンドラインユーティリティが含まれます。
			</para>
			 <para>
				MPM は Apache が同時要求を処理する方法に大きな影響をおよぼします。<emphasis>worker</emphasis> MPM を選んだ場合、<emphasis>スレッド</emphasis> (軽量プロセス) で同時要求を処理します。これに対して <emphasis>prefork</emphasis> MPM を選んだ場合、あらかじめ生成したプロセスプールで同時要求を処理します。<emphasis>event</emphasis> MPM を選んだ場合、スレッドで同時要求を処理しますが、非アクティブ接続 (特に HTTP <emphasis>keep-alive</emphasis> 機能を使ってオープン状態を維持された接続) に対しては専用の管理スレッドで処理します。
			</para>
			 <para>
				Falcot の管理者はさらに Apache の PHP サポートを有効化するために <emphasis role="pkg">libapache2-mod-php5</emphasis> をインストールしています。<emphasis role="pkg">libapache2-mod-php5</emphasis> をインストールすると、デフォルトの <emphasis>event</emphasis> MPM は無効化され、代わりに <emphasis>prefork</emphasis> MPM を使うようになります。なぜなら、PHP は <emphasis>prefork</emphasis> MPM の下でしか動かないからです。
			</para>
			 <sidebar> <title><emphasis>SECURITY</emphasis> <literal>www-data</literal> ユーザ下の実行</title>
			 <indexterm>
				<primary><literal>www-data</literal></primary>
			</indexterm>
			 <indexterm>
				<primary>suexec</primary>
			</indexterm>
			 <para>
				デフォルトで、Apache は入って来るリクエストを <literal>www-data</literal> ユーザからのリクエストとして取り扱います。これは Apache が実行する CGI スクリプト (動的ページ) の持つセキュリティ脆弱性によってシステム全体が被害を受けることを避け、特定のユーザが所有するファイルだけに被害を留めることが可能であることを意味しています。
			</para>
			 <para>
				<emphasis>suexec</emphasis> モジュールを使うことで、このルールを迂回することが可能です。こうすることで、一部の CGI スクリプトを別のユーザの権限で実行することが可能です。設定を行うには、Apache 設定ファイルの <literal>SuexecUserGroup <replaceable>user</replaceable><replaceable>group</replaceable></literal> 指示文を使います。
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">libapache2-mpm-itk</emphasis></primary>
			</indexterm>
			 <para>
				もう一つの可能性はたとえば <emphasis role="pkg">libapache2-mpm-itk</emphasis> の提供する MPM などの専用 MPM を使うことです。<emphasis role="pkg">libapache2-mpm-itk</emphasis> の挙動は普通の MPM と少し異なります。すなわち、この MPM は仮想ホスト (実質的にはページ群) を「隔離」して各仮想ホストを異なるユーザの権限で実行するための MPM です。このため、あるウェブサイトの持つ脆弱性によって他のウェブサイトの所有者の持つファイルが危険にさらされることがなくなります。
			</para>
			 </sidebar> <sidebar> <title><emphasis>QUICK LOOK</emphasis> モジュールのリスト</title>
			 <para>
				Apache の標準的なモジュールをオンラインで見ることが可能です。<ulink type="block" url="http://httpd.apache.org/docs/2.4/mod/index.html" />
			</para>
			 </sidebar> <para>
				Apache はモジュール式サーバで、多くの機能が外部モジュールによって実装されており、主プログラムは初期化の際に外部モジュールを読み込みます。デフォルト設定では、最も一般的なモジュールだけが有効化されていますが、新しいモジュールの有効化は <command>a2enmod <replaceable>module</replaceable></command> を実行するだけで簡単に行うことが可能です。これに対して、モジュールを無効化するコマンドは <command>a2dismod <replaceable>module</replaceable></command> です。実際のところ、これらのプログラムは <filename>/etc/apache2/mods-enabled/</filename> 内に実際のファイル (<filename>/etc/apache2/mods-available/</filename> 内に保存されています) を指すシンボリックリンクを作成 (または削除) しているだけです。
			</para>
			 <para>
				Apache のデフォルト設定では、ウェブサーバはポート 80 番をリッスンし (<filename>/etc/apache2/ports.conf</filename> の中で設定されています)、<filename>/var/www/html/</filename> ディレクトリに含まれるページを公開します (<filename>/etc/apache2/sites-enabled/000-default.conf</filename> の中で設定されています)。
			</para>
			 <sidebar> <title><emphasis>GOING FURTHER</emphasis> SSL サポートの追加</title>
			 <indexterm>
				<primary>HTTPS</primary>
			</indexterm>
			 <indexterm>
				<primary>HTTP</primary>
				<secondary>secure</secondary>
			</indexterm>
			 <para>
				Apache 2.4 には、すぐに使える安全な HTTP (HTTPS) に必要な SSL モジュールが含まれます。SSL モジュールを有効化するには、<command>a2enmod ssl</command> を使い、さらに必要な指示文を設定ファイルに追加しなければいけません。設定例は <filename>/etc/apache2/sites-available/default-ssl.conf</filename> で提供されています。<ulink type="block" url="http://httpd.apache.org/docs/2.4/mod/mod_ssl.html" />
			</para>
			 <para>
				<emphasis>Perfect Forward Secrecy</emphasis> を使った SSL 接続を優先したい場合、いくつかの特別な注意が必要です (これらの接続は一過性のセッション鍵を使います。こうすることでサーバの秘密鍵が漏洩した場合でも、ネットワークのスニッフィングを行うことで保存された過去に暗号化されたトラフィックの内容が漏洩することがなくなります)。以下のページには特に Mozilla の推奨する設定例が載せられています。<ulink type="block" url="https://wiki.mozilla.org/Security/Server_Side_TLS#Apache" />
			</para>
			 <indexterm>
				<primary><emphasis>Perfect Forward Secrecy</emphasis></primary>
			</indexterm>
			 </sidebar>
		</section>
		 <section>
			<title>仮想ホストの設定</title>
			 <para>
				仮想ホスト機能を使うことで、単独のウェブサーバで複数のサイトを運用することが可能です。
			</para>
			 <indexterm>
				<primary sortas="カソウホスト">仮想ホスト</primary>
			</indexterm>
			 <para>
				Apache は異なる 2 種類の仮想ホストを取り扱うことが可能です。具体的に言えば、IP アドレス (またはポート番号) とウェブサーバのドメイン名に基づいて仮想ホスト機能が実装されています。IP アドレスに基づく仮想ホスト機能を使う場合、各サイトに異なる IP アドレス (またはポート番号) を割り当てることが必要です。これに対して、ドメイン名に基づく仮想ホスト機能を使う場合、単一の IP アドレス (またはポート番号) で複数のサイトを運用することが可能で、HTTP クライアントの送信するホスト名によってサイトを識別します (こちらの方法は HTTP プロトコルのバージョン 1.1 で動作します。幸いなことに、HTTP バージョン 1.1 はすべてのクライアントが対応していると考えて良い程度に古いプロトコルです)。
			</para>
			 <para>
				IPv4 アドレスの枯渇は (ますます) 進んでいるため、通常は単一の IP アドレスで複数のサイトを運用する方法が好まれます。しかしながら仮想ホストで HTTPS を提供する必要がある場合、ドメイン名に基づく仮想ホスト機能を使うには複雑な設定が必要になります。なぜなら、SSL プロトコルはドメイン名に基づく仮想ホストを必ず考慮するとは限らないからです。SNI 拡張 (<emphasis>Server Name Indication</emphasis>) を使うことで仮想ホスト上でも SSL プロトコルを使うことが可能になりますが、SNI 拡張はすべてのブラウザで正しく使えるとは限りません。1 つのサーバで複数の HTTPS サイトを運用する必要がある場合、HTTPS サイトは通常異なるポートを使うか異なる IP アドレスを使う (IPv6 が役立ちます) ことで識別されます。
			</para>
			 <para>
				Apache 2 のデフォルト設定では、ドメイン名に基づく仮想ホスト機能が有効にされています。加えて、<literal>/etc/apache2/sites-enabled/000-default.conf</literal> ファイルの中でデフォルトの仮想ホストが定義されています。この仮想ホストはクライアントによって送信された要求に一致するホストが見つからない場合に使われます。
			</para>
			 <sidebar> <title><emphasis>CAUTION</emphasis> 最初に定義された仮想ホスト</title>
			 <para>
				不明な仮想ホストに関する要求は最初に定義された仮想ホストへの要求として処理されます。このため管理者は <literal>www.falcot.com</literal> を最初に定義しています。
			</para>
			 </sidebar> <sidebar> <title><emphasis>QUICK LOOK</emphasis> Apache の SNI サポート</title>
			 <indexterm>
				<primary>Server Name Indication</primary>
			</indexterm>
			 <para>
				Apache サーバは <emphasis>Server Name Indication</emphasis> (SNI) と呼ばれる SSL プロトコル拡張をサポートします。SNI 拡張を使うことで、ブラウザは SSL 接続を確立する間の HTTP 要求よりもずっと前にウェブサーバのホスト名を送信することが可能になり、同じサーバ (同じ IP アドレスとポート番号を使うサーバ) で運用されている複数の仮想ホストから要求された仮想ホストを識別します。SNI 拡張を使うことで、Apache は以降のトランザクションで最も適切な SSL 証明書を選びます。
			</para>
			 <para>
				Apache とクライアントの間で通信対象の仮想ホストが決定される前は、Apache は常にデフォルトの仮想ホストの定める証明書を使うでしょう。デフォルトの仮想ホスト以外の仮想ホストへのアクセスを試行するクライアントは警告を表示するかもしれません。なぜなら、クライアントが受け取った証明書はアクセスしようとしているウェブサイトと一致しないからです。幸いなことに、多くのブラウザは SNI を取り扱うことが可能です。具体的に言えば、Microsoft Internet Explorer バージョン 7.0 以降 (かつ Vista 以降)、Mozilla Firefox バージョン 2.0 以降、Apple Safari バージョン 3.2.1 以降、Google Chrome のすべてのバージョンは SNI を取り扱うことが可能です。
			</para>
			 <para>
				Debian の提供する Apache パッケージは SNI サポートを有効化した状態でビルドされています。このため、特別な設定は不要です。
			</para>
			 <para>
				最初に定義された仮想ホスト (デフォルトの仮想ホスト) に対する設定で TLSv1 を有効化することを忘れないでください。なぜなら、Apache は安全な接続を確立するために最初に定義された仮想ホストのパラメータを使うため、最初に定義された仮想ホストのパラメータで安全な接続を有効化しなければいけません!
			</para>
			 </sidebar> <para>
				仮想ホストを追加するには、<filename>/etc/apache2/sites-available/</filename> にファイルを追加します。<literal>falcot.org</literal> ドメインで運用されるウェブサイトをセットアップするには、以下のファイルを作成し、<command>a2ensite www.falcot.org</command> を使って仮想ホストを有効化するだけで簡単に可能です。
			</para>
			 <example>
				<title><filename>/etc/apache2/sites-available/www.falcot.org.conf</filename> ファイル</title>
				 
<programlisting>
&lt;VirtualHost *:80&gt;
ServerName www.falcot.org
ServerAlias falcot.org
DocumentRoot /srv/www/www.falcot.org
&lt;/VirtualHost&gt;</programlisting>

			</example>
			 <para>
				ここまでの設定に従うと、Apache サーバはすべての仮想ホストに対して同じログファイルを使います (仮想ホストの定義に <literal>CustomLog</literal> 指示文を追加すればこの挙動を変えることが可能です)。そのため、ログファイルのフォーマットをカスタマイズして、仮想ホストの名前を含むようにすることが道理に適っています。これを行うには、<filename>/etc/apache2/conf-available/customlog.conf</filename> ファイルを作成してすべてのログファイルに対する新しいフォーマットを定義し (<literal>LogFormat</literal> 指示文を使います)、さらに <command>a2enconf customlog</command> を有効化します。また、<filename>/etc/apache2/sites-available/000-default.conf</filename> ファイルから <literal>CustomLog</literal> 指示文を削除 (またはコメントアウト) しなければいけません。
			</para>
			 <example>
				<title><filename>/etc/apache2/conf.d/customlog.conf</filename> ファイル</title>
				 
<programlisting role="scale">
# (仮想) ホスト名を含む新しいログフォーマット
LogFormat "%v %h %l %u %t \"%r\" %&gt;s %b \"%{Referer}i\" \"%{User-Agent}i\"" vhost

# 上で定義した "vhost" フォーマットを使用します
CustomLog /var/log/apache2/access.log vhost</programlisting>

			</example>

		</section>
		 <section>
			<title>よく使われる指示文</title>
			 <para>
				この節では、いくつかのよく使われる Apache 設定指示文を簡単に見直します。
			</para>
			 <indexterm>
				<primary sortas="Apache シジブン">Apache 指示文</primary>
			</indexterm>
			 <indexterm>
				<primary sortas="シジブン、Apache">指示文、Apache</primary>
			</indexterm>
			 <para>
				主要設定ファイルにはいくつかの <literal>Directory</literal> ブロックが含まれます。<literal>Directory</literal> ブロックを使うことで、提供されるファイルの位置に従って、サーバの挙動を変えることが可能です。<literal>Directory</literal> ブロックには通常 <literal>Options</literal> と <literal>AllowOverride</literal> 指示文が含まれます。
			</para>
			 <indexterm>
				<primary sortas="Apache シジブン">Apache 指示文</primary>
				<secondary><literal>Options</literal></secondary>
			</indexterm>
			 <indexterm>
				<primary sortas="Apache シジブン">Apache 指示文</primary>
				<secondary><literal>AllowOverride</literal></secondary>
			</indexterm>
			 <example>
				<title>Directory ブロック</title>
				 
<programlisting>
&lt;Directory /var/www&gt;
Options Includes FollowSymlinks
AllowOverride All
DirectoryIndex index.php index.html index.htm
&lt;/Directory&gt;</programlisting>

			</example>
			 <para>
				<literal>DirectoryIndex</literal> 指示文には、クライアントからディレクトリを要求された場合に応答として送信するファイルのリストを指定します。リスト内の最初に見つかったファイルが応答として使われます。
			</para>
			 <indexterm>
				<primary sortas="Apache シジブン">Apache 指示文</primary>
				<secondary><literal>DirectoryIndex</literal></secondary>
			</indexterm>
			 <para>
				<literal>Options</literal> 指示文には、有効化するオプションを指定します。<literal>None</literal> を指定するとすべてのオプションが無効化されます。それに対して <literal>All</literal> を指定すると <literal>MultiViews</literal> を除いたすべてのオプションが有効化されます。以下に利用できるオプションを挙げます。
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						<literal>ExecCGI</literal>。サーバは CGI スクリプトの実行を許可されます。<indexterm><primary sortas="Apache シジブン">Apache 指示文</primary><secondary><literal>ExecCGI</literal></secondary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>FollowSymlinks</literal>。サーバはシンボリックリンクをたどってリンク先の内容を応答として返すことを許可されます。<indexterm><primary sortas="Apache シジブン">Apache 指示文</primary><secondary><literal>FollowSymlinks</literal></secondary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>SymlinksIfOwnerMatch</literal>。サーバはシンボリックリンクとリンク先が同じ所有者の場合に限りシンボリックリンクをたどることを許可されます。<indexterm><primary sortas="Apache シジブン">Apache 指示文</primary><secondary><literal>SymlinksIfOwnerMatch</literal></secondary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>Includes</literal>。サーバは <emphasis>Server Side Includes</emphasis> (略して <emphasis>SSI</emphasis>) を使うことを許可されます。SSI とは HTML ページの中に埋め込まれた要求ごとにその場で処理される指示です。<indexterm><primary sortas="Apache シジブン">Apache 指示文</primary><secondary><literal>Includes</literal></secondary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>Indexes</literal>。サーバはクライアントの送信した HTTP 要求が index ファイルの含まれないディレクトリを指している場合 (たとえば <literal>DirectoryIndex</literal> 指示文でリストされているファイルがこのディレクトリ内に存在しない場合) にディレクトリの内容をリストすることを許可されます。<indexterm><primary sortas="Apache シジブン">Apache 指示文</primary><secondary><literal>Indexes</literal></secondary></indexterm>
					</para>

				</listitem>
				 <listitem>
					<para>
						<literal>MultiViews</literal>。サーバはコンテンツネゴシエーションを使うことを許可されます。コンテンツネゴシエーションを使うことで、サーバはブラウザで設定した優先言語に一致するウェブページを返します。<indexterm><primary sortas="Apache シジブン">Apache 指示文</primary><secondary><literal>MultiViews</literal></secondary></indexterm>
					</para>

				</listitem>

			</itemizedlist>
			 <para>
			</para>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> <filename>.htaccess</filename> ファイル</title>
			 <para>
				<filename>.htaccess</filename> ファイルには、Apache 設定指示文が含まれます。<filename>.htaccess</filename> ファイル内の設定は <filename>.htaccess</filename> ファイルが保存されているディレクトリに含まれる要素が要求された時に強制されます。指示文の有効範囲は <filename>.htaccess</filename> が保存されているディレクトリ以下すべてのサブディレクトリです。
			</para>
			 <indexterm>
				<primary><filename>.htaccess</filename></primary>
			</indexterm>
			 <para>
				<literal>Directory</literal> ブロック内に書かれたほとんどの指示文は <filename>.htaccess</filename> ファイル内でも使うことが可能です。
			</para>
			 </sidebar> <para>
				<literal>AllowOverride</literal> 指示文には、<filename>.htaccess</filename> ファイルを使って有効化または無効化することを許可するすべてのオプションをリストします。<literal>AllowOverride</literal> 指示文は一般に <literal>ExecCGI</literal> を制限するために使われることが多いです。こうすることで、管理者はウェブサーバ (<literal>www-data</literal> ユーザ) の権限でプログラムを実行することを許可するユーザを選択します。
			</para>
			 <indexterm>
				<primary sortas="Apache シジブン">Apache 指示文</primary>
				<secondary><literal>AllowOverride</literal></secondary>
			</indexterm>
			 <section>
				<title>認証要求</title>
				 <indexterm>
					<primary sortas="ウェブニンショウ">ウェブ認証</primary>
				</indexterm>
				 <para>
					ウェブサイトのある部分へのアクセスを制限し、ユーザ名とパスワードに基づく正当なユーザだけが内容にアクセスできるように設定する必要があるかもしれません。
				</para>
				 <example>
					<title>認証要求を行う <filename>.htaccess</filename> ファイル</title>
					 
<programlisting>
Require valid-user
AuthName "Private directory"
AuthType Basic
AuthUserFile /etc/apache2/authfiles/htpasswd-private</programlisting>

				</example>
				 <sidebar> <title><emphasis>SECURITY</emphasis> 無意味なセキュリティ</title>
				 <para>
					上の例で使われている <literal>Basic</literal> 認証システムは最低限のセキュリティを提供します。パスワードは平文で送信されます (パスワードは暗号化よりも単純な符号化である <emphasis>base64</emphasis> で符号化されるだけです)。<literal>Basic</literal> 認証システムで「保護」されている文書はネットワークを平文で送信される点も注意するべきです。セキュリティが重要な場合、HTTP 接続全体を SSL で暗号化するべきです。
				</para>
				 </sidebar> <para>
					<filename>/etc/apache2/authfiles/htpasswd-private</filename> ファイルには、ユーザとパスワードのリストが含まれます。このファイルを操作するには通常 <command>htpasswd</command> コマンドを使います。たとえば、以下のコマンドを使うことで、ユーザを追加するかユーザのパスワードを変更します。<indexterm><primary><command>htpasswd</command></primary></indexterm>
				</para>
				 
<screen>
<computeroutput># </computeroutput><userinput>htpasswd /etc/apache2/authfiles/htpasswd-private <replaceable>user</replaceable>
</userinput><computeroutput>New password:
Re-type new password:
Adding password for user <replaceable>user</replaceable>
</computeroutput></screen>

			</section>
			 <section>
				<title>アクセス制限</title>
				 <indexterm>
					<primary sortas="ウェブアクセスセイゲン">ウェブアクセス制限</primary>
				</indexterm>
				 <para>
					<literal>Require</literal> 指示文を使うことで、あるディレクトリへのアクセスを制御 (とサブディレクトリへのアクセスを再帰的に制御) します。
				</para>
				 <indexterm>
					<primary sortas="Apache シジブン">Apache 指示文</primary>
				</indexterm>
				 <indexterm>
					<primary sortas="シジブン、Apache">指示文、Apache</primary>
				</indexterm>
				 <indexterm>
					<primary sortas="Apache シジブン">Apache 指示文</primary>
					<secondary><literal>Require</literal></secondary>
				</indexterm>
				 <para>
					<literal>Require</literal> 指示文は多くの基準を基にアクセスを制限するために使われます。ここではクライアントの IP アドレスに基づいてアクセス制限の基準を定義するのではなく、特にいくつかの <literal>Require</literal> 指示文を <literal>RequireAll</literal> ブロックと組み合わせることでより強力なアクセス制限の基準を表現します。
				</para>
				 <example>
					<title>ローカルネットワークからのアクセスだけを許可する例</title>
					 
<programlisting>Require ip 192.168.0.0/16</programlisting>

				</example>
				 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> 古い構文</title>
				 <para>
					<literal>Require</literal> 指示文を使って IP アドレスに基づく制限を行う機能は Apache 2.4 (<emphasis role="distribution">Jessie</emphasis> で提供されるバージョン) でのみ利用できます。<emphasis role="distribution">Wheezy</emphasis> のユーザ向けの説明になりますが、Apache 2.2 で IP アドレスに基づく制限を行うには別の構文を使います。ここでは主に参照用として Apache 2.2 の構文を説明しますが、この構文は <literal>mod_access_compat</literal> モジュールを使えば Apache 2.4 でも利用できます。
				</para>
				 <para>
					<literal>Allow from</literal> と <literal>Deny from</literal> 指示文を使うことで、あるディレクトリへのアクセスを制御 (とサブディレクトリへのアクセスを再帰的に制御) します。
				</para>
				 <indexterm>
					<primary sortas="Apache シジブン">Apache 指示文</primary>
					<secondary><literal>Allow from</literal></secondary>
				</indexterm>
				 <indexterm>
					<primary sortas="Apache シジブン">Apache 指示文</primary>
					<secondary><literal>Deny from</literal></secondary>
				</indexterm>
				 <indexterm>
					<primary sortas="Apache シジブン">Apache 指示文</primary>
					<secondary><literal>Order</literal></secondary>
				</indexterm>
				 <para>
					<literal>Order</literal> 指示文を使うことで、<literal>Allow from</literal> と <literal>Deny from</literal> 指示文を評価する順番をサーバに伝えます。ここでは最後に一致したものが優先されます。具体的に言えば、<literal>Order deny,allow</literal> を使うと、<literal>Deny from</literal> に一致しないホストまたは <literal>Allow from</literal> に一致するホストからのアクセスを許可します。反対に、<literal>Order allow,deny</literal> を使うと、<literal>Allow from</literal> に一致しないホストまたは <literal>Deny from</literal> に一致するホストからのアクセスを拒否します。
				</para>
				 <para>
					<literal>Allow from</literal> と <literal>Deny from</literal> 指示文には、IP アドレス、ネットワーク (たとえば <literal>192.168.0.0/255.255.255.0</literal>、<literal>192.168.0.0/24</literal>、<literal>192.168.0</literal> など)、ホスト名、ドメイン名、全員を意味する <literal>all</literal> キーワードを使うことが可能です。
				</para>
				 <para>
					たとえば、デフォルトですべてのアクセスを拒否してローカルネットワークからのアクセスだけを許可するには以下の通り設定します。
				</para>
				 
<programlisting>
Order deny,allow
Allow from 192.168.0.0/16
Deny from all</programlisting>
				 </sidebar>
			</section>

		</section>
		 <section>
			<title>ログ解析ソフトウェア</title>
			 <para>
				ウェブサーバには、通常ログ解析ソフトウェアがインストールされます。なぜなら、ログ解析ソフトウェアを使うことで管理者はウェブサーバの使用形態に関する正確な知見を得ることが可能だからです。
			</para>
			 <para>
				Falcot Corp の管理者は <emphasis>AWStats</emphasis> (<emphasis>Advanced Web Statistics</emphasis>) を使って Apache ログファイルを解析することに決めました。
			</para>
			 <indexterm>
				<primary><emphasis>AWStats</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary sortas="ウェブログカイセキソフトウェア">ウェブログ解析ソフトウェア</primary>
			</indexterm>
			 <indexterm>
				<primary>ログ</primary>
				<secondary sortas="ウェブログカイセキソフトウェア">ウェブログ解析ソフトウェア</secondary>
			</indexterm>
			 <indexterm>
				<primary sortas="ウェブログカイセキソフトウェア">ウェブログ解析ソフトウェア</primary>
			</indexterm>
			 <para>
				最初に <filename>/etc/awstats/awstats.conf</filename> ファイルをカスタマイズして設定を行います。Falcot の管理者は以下のパラメータだけを修正し、他はそのままの状態にしています。
			</para>
			 
<programlisting>
LogFile="/var/log/apache2/access.log"
LogFormat = "%virtualname %host %other %logname %time1 %methodurl %code %bytesd %refererquot %uaquot"
SiteDomain="www.falcot.com"
HostAliases="falcot.com REGEX[^.*\.falcot\.com$]"
DNSLookup=1
LoadPlugin="tooltips"</programlisting>
			 <para>
				これらのパラメータに関する説明はテンプレートファイルにコメントとして書かれています。特に、<varname>LogFile</varname> と <varname>LogFormat</varname> パラメータを使って、ログファイルの場所とログファイルに含まれる情報の書式を指定します。さらに <varname>SiteDomain</varname> と <varname>HostAliases</varname> は主要ウェブサイトに割り当てている複数の名前をリストします。
			</para>
			 <para>
				トラフックの多いサイトでは通常 <varname>DNSLookup</varname> を <literal>1</literal> に設定するべきではありません。トラフィックの少ないサイトでは Falcot の設定と同様に <varname>DNSLookup</varname> を設定することで、解析結果に生 IP アドレスではなく完全なマシン名が含まれるようになり、解析結果を読みやすくなります。
			</para>
			 <sidebar> <title><emphasis>SECURITY</emphasis> 統計へのアクセス</title>
			 <para>
				AWStats は統計をウェブサイト上で利用できるようにしており、デフォルトでは統計へのアクセスは制限されていません。しかし、ごく少数の (おそらく内部の) IP アドレスだけが統計にアクセスできるように制限をかけることも可能です。アクセスを許可する IP アドレスのリストは <varname>AllowAccessFromWebToFollowingIPAddresses</varname> パラメータで定義する必要があります。
			</para>
			 </sidebar> <para>
				他の仮想ホストに対して AWStats を有効化することも可能です。その場合、各仮想ホストに対して <filename>/etc/awstats/awstats.www.falcot.org.conf</filename> などの設定ファイルを作ってください。
			</para>
			 <example>
				<title>仮想ホスト用の AWStats 設定ファイル</title>
				 
<programlisting>
Include "/etc/awstats/awstats.conf"
SiteDomain="www.falcot.org"
HostAliases="falcot.org"</programlisting>

			</example>
			 <para>
				AWStats は <filename>/usr/share/awstats/icon/</filename> ディレクトリに保存されている多くのアイコンを使います。ウェブサイトでこれらのアイコンを使えるようにするためには、以下の指示文を Apache の設定に追加する必要があります。
			</para>
			 
<programlisting>
Alias /awstats-icon/ /usr/share/awstats/icon/</programlisting>
			 <para>
				数分後 (スクリプトを複数回実行した後)、結果をオンラインで見ることが可能になります。<ulink type="block" url="http://www.falcot.com/cgi-bin/awstats.pl" /><ulink type="block" url="http://www.falcot.org/cgi-bin/awstats.pl" />
			</para>
			 <sidebar> <title><emphasis>CAUTION</emphasis> ログファイルの循環</title>
			 <para>
				統計はすべてのログに対して取られるため、Apache ログファイルが循環される直前に <emphasis>AWStats</emphasis> を実行する必要があります。<filename>/etc/logrotate.d/apache2</filename> ファイルの <literal>prerotate</literal> 指示文から判断すると、これを解決するには、<filename>/usr/share/awstats/tools/update.sh</filename> へのシンボリックリンクを <filename>/etc/logrotate.d/httpd-prerotate</filename> に作成します。
			</para>
			 
<screen><computeroutput>$ </computeroutput><userinput>cat /etc/logrotate.d/apache2
</userinput><computeroutput>/var/log/apache2/*.log {
  daily
  missingok
  rotate 14
  compress
  delaycompress
  notifempty
  create 644 root adm
  sharedscripts
  postrotate
    if /etc/init.d/apache2 status &gt; /dev/null ; then \
      /etc/init.d/apache2 reload &gt; /dev/null; \
    fi;
  endscript
  prerotate
    if [ -d /etc/logrotate.d/httpd-prerotate ]; then \
      run-parts /etc/logrotate.d/httpd-prerotate; \
    fi; \
  endscript
}
$ </computeroutput><userinput>sudo mkdir -p /etc/logrotate.d/httpd-prerotate
</userinput><computeroutput>$ </computeroutput><userinput>sudo ln -sf /usr/share/awstats/tools/update.sh \
  /etc/logrotate.d/httpd-prerotate/awstats
</userinput></screen>
			 <para>
				<command>logrotate</command> によって作成されたログファイルは誰でも (特に AWStats から) 読み取り可能にしておく必要があります。上の例では、(デフォルトの <literal>640</literal> パーミッションの代わりに) <literal>create 644 root adm</literal> 行を追加することでこれを実現しています。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.ftp-file-server">
		<title>FTP ファイルサーバ</title>
		 <indexterm>
			<primary>FTP (<emphasis>File Transfer Protocol</emphasis>)</primary>
		</indexterm>
		 <para>
			FTP (<emphasis>File Transfer Protocol</emphasis>) はインターネットにおける最初のプロトコルの 1 つです (RFC 959 は 1985 年に発行されました!)。FTP はウェブが生まれる前にファイルを配布するために使われました (HTTP プロトコルは 1990 年に作られ、1996 年の RFC 1945 でバージョン 1.0 が正式に定義されました)。
		</para>
		 <para>
			FTP を使うことで、ファイルのアップロードとダウンロードが可能です。そしてこの理由から、現在でもインターネットサービスプロバイダによってホストされているウェブサイト (およびウェブサイトを構成する要素) を更新するために広く使われています。この際に、ユーザ識別子とパスワードを使って安全なアクセスが強制されます。そして認証に成功したら、FTP サーバはそのユーザのホームディレクトリに対する読み書きアクセスを許可します。
		</para>
		 <para>
			また、FTP サーバは主に一般のユーザがダウンロードできるファイルを配布するために使われることもあります。この用途の良い例が Debian パッケージです。サーバの内容は地理的に離れている別のサーバから取得され、サーバの近郊にいるユーザに向けて内容を提供します。これはクライアント認証が不要になることを意味します。結果的に、この挙動は「匿名 FTP」として知られています。完全に正しく言えば、クライアントは <literal>anonymous</literal> というユーザ名で認証します。パスワードは慣例的にユーザの電子メールアドレスを使いますが、サーバはこのパスワードを無視します。
		</para>
		 <para>
			Debian には多くの FTP サーバ (<emphasis role="pkg">ftpd</emphasis>、<emphasis role="pkg">proftpd-basic</emphasis>、<emphasis role="pkg">pyftpd</emphasis> など) が含まれます。Falcot Corp の管理者は <emphasis role="pkg">vsftpd</emphasis> を選びました。なぜなら、FTP サーバを使ってファイルを配布するのは管理者だけだからです (FTP サーバを Debian パッケージリポジトリとしても使います)。すなわち、この用途では高度な機能が不要で、セキュリティの観点が重要だからです。
		</para>
		 <indexterm>
			<primary><emphasis role="pkg">vsftpd</emphasis></primary>
		</indexterm>
		 <para>
			<emphasis role="pkg">vsftpd</emphasis> パッケージをインストールすると、<literal>ftp</literal> システムユーザが作成されます。<literal>ftp</literal> ユーザは匿名 FTP 接続の際に常に使われるものです。FTP サービスに接続するユーザは <literal>ftp</literal> システムユーザアカウントのホームディレクトリ (<filename>/srv/ftp/</filename>) を利用できます。巨大なファイルを誰でもダウンロード可能にするという単純な要求を満足させるにはデフォルト設定 (<filename>/etc/vsftpd.conf</filename>) に変更を加える必要があります。つまり、匿名アクセスを有効化し (<literal>anonymous_enable=YES</literal>)、ローカルユーザの読み込み専用アクセスを無効化する (<literal>local_enable=NO</literal>) 必要があります。ローカルユーザの読み込み専用アクセスを無効化するのは特に重要です。なぜなら FTP プロトコルはいかなる種類の暗号化も行わないため、デフォルト設定のままではネットワーク越しにユーザパスワードを横取りされる可能性があるからです。
		</para>

	</section>
	 <section id="sect.nfs-file-server">
		<title>NFS ファイルサーバ</title>
		 <para>
			NFS (<emphasis>Network File System</emphasis>) はネットワークを介したファイルシステムへのリモートアクセスをつかさどるプロトコルです。すべての Unix システムは NFS プロトコルを取り扱うことが可能です。一方で Windows システムを参加させる場合、代わりに Samba を使わなければいけません。
		</para>
		 <indexterm>
			<primary>NFS</primary>
		</indexterm>
		 <indexterm>
			<primary><emphasis>Network</emphasis></primary>
			<secondary><emphasis>File System</emphasis></secondary>
		</indexterm>
		 <indexterm>
			<primary>ファイルシステム</primary>
			<secondary>ネットワーク</secondary>
		</indexterm>
		 <indexterm>
			<primary>ファイル</primary>
			<secondary>サーバ</secondary>
		</indexterm>
		 <indexterm>
			<primary>サーバ</primary>
			<secondary>ファイル</secondary>
		</indexterm>
		 <para>
			NFS はとても役に立つツールです。しかし、歴史的に言えば NFS には数多くの制約があり、NFS プロトコルのバージョン 4 になってほとんどの制約がなくなりました。制約がなくなったことによる欠点として、NFS の最新版では認証や暗号化などの基本的なセキュリティ機能を有効化するよう設定するのがさらに難しくなったという点が挙げられます。なぜなら、NFS の最新版ではこれらの機能は Kerberos に依存しているからです。認証や暗号化機能を有効化しない場合、NFS プロトコルを使うのは信用できるローカルネットワークだけに留めるべきです。なぜなら、ネットワークを流れるデータは暗号化されませんし (<emphasis>スニファ</emphasis>を使えば内容を傍受することが可能ですし)、アクセス権はクライアントの IP アドレスに基づいて決定されるからです (IP アドレスはなりすまし可能です)。
		</para>
		 <sidebar> <title><emphasis>DOCUMENTATION</emphasis> NFS の HOWTO 文書</title>
		 <para>
			NFSv4 を配備する際に参考になる文書はまだ多くありません。以下に挙げた文書の品質はさまざまですが、これらの文書では最低限やるべき内容に関するいくつかのヒントが載せられています。<ulink type="block" url="https://help.ubuntu.com/community/NFSv4Howto" /><ulink type="block" url="http://wiki.linux-nfs.org/wiki/index.php/Nfsv4_configuration" />
		</para>
		 </sidebar> <section>
			<title>NFS の安全確保</title>
			 <indexterm>
				<primary>NFS</primary>
				<secondary>セキュリティ</secondary>
			</indexterm>
			 <para>
				Kerberos に基づくセキュリティ機能を使わない場合、NFS の利用を許可されたマシンだけが種々の要求された RPC サーバに接続できるような制限を加えることが不可欠です。なぜなら、NFS の基本的なプロトコルはネットワークから受け取った情報を信頼するからです。ファイアウォールは外部のマシンが内部のマシンのように振る舞うことを避けるために <emphasis>IP なりすまし</emphasis>をブロックし、NFS 共有にアクセスするように意図されたマシンだけが適切なポートにアクセスするように制限しなければいけません。
			</para>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> RPC</title>
			 <para>
				RPC (<emphasis>Remote Procedure Call</emphasis>) はリモートサービスに関する Unix 標準です。NFS は RPC サービスの 1 つです。
			</para>
			 <indexterm>
				<primary>RPC</primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>Remote Procedure Call</emphasis></primary>
			</indexterm>
			 <para>
				ディレクトリに登録する RPC サービスは <emphasis>portmapper</emphasis> としても知られています。NFS 問い合わせを実行することを望むクライアントは最初に <emphasis>portmapper</emphasis> (ポート 111 番、TCP または UDP) を呼び出し、NFS サーバの情報を要求します。通常、応答には NFS サーバのポート 2049 番 (NFS のデフォルト) が含まれます。すべての RPC サービスが必ず固定されたポートで使われる必要があるわけではありません。
			</para>
			 </sidebar> <para>
				NFS プロトコルの古いバージョンでは他の RPC サービスが必要で、この RPC サービスは動的に割り当てられたポートを使います。幸いなことに、NFS バージョン 4 ではポート 2049 番 (NFS 用) と 111 番 (portmapper 用) が固定されており、そのため簡単にポートにファイアウォールをかませることが可能です。
			</para>
			 <indexterm>
				<primary><command>portmapper</command></primary>
			</indexterm>

		</section>
		 <section>
			<title>NFS サーバ</title>
			 <para>
				NFS サーバは Linux カーネルの一部です。そして Debian の提供するカーネルでは、NFS サーバをカーネルモジュールとしてビルドしています。NFS サーバを起動時に自動的に実行するには、<emphasis role="pkg">nfs-kernel-server</emphasis> パッケージをインストールしてください。このパッケージには、対応する起動スクリプトが含まれます。
			</para>
			 <para>
				NFS サーバの設定ファイル <filename>/etc/exports</filename> には、ネットワークを介して利用できるようにする (<emphasis>エクスポートされる</emphasis>) ディレクトリをリストします。各 NFS 共有について、リストされたマシンだけがアクセスを許可されます。よりきめ細かなアクセス制御を行うには、いくつかのオプションを使います。<filename>/etc/exports</filename> ファイルの構文はとても単純です。
			</para>
			 <indexterm>
				<primary><filename>exports</filename></primary>
			</indexterm>
			 <indexterm>
				<primary><filename>/etc/exports</filename></primary>
			</indexterm>
			 
<programlisting>
/directory/to/share machine1(option1,option2,...) machine2(...) ...</programlisting>
			 <para>
				NFSv4 では、すべてのエクスポートされるディレクトリは一つの基準ディレクトリの下位に属さなければいけません。また、その基準ディレクトリは必ずエクスポートされ、オプション <literal>fsid=0</literal> または <literal>fsid=root</literal> で識別されなければいけません。これらの点に注意してください。
			</para>
			 <para>
				各マシンは DNS 名か IP アドレスのどちらか一方を使って識別されます。マシン群全体を指定するには、<literal>*.falcot.com</literal> などの構文を使うか <literal>192.168.0.0/255.255.255.0</literal> や <literal>192.168.0.0/24</literal> などの IP アドレス範囲を使います。
			</para>
			 <para>
				ディレクトリはデフォルトで (または <literal>ro</literal> オプションを使えば) 読み込み専用として利用できるようにされます。<literal>rw</literal> オプションを使えば読み書きアクセスが許可されます。典型的に NFS クライアントは root だけが使えるポート (言い換えれば、1024 番よりも低い番号のポート) から接続します。高いポート番号を使うクライアントからの接続を受け入れるには、<literal>insecure</literal> オプションを使います (<literal>secure</literal> オプションは暗黙的に有効化されていますが、明示する必要があればオプションを明示することも可能です)。
			</para>
			 <indexterm>
				<primary>NFS</primary>
				<secondary>オプション</secondary>
			</indexterm>
			 <para>
				デフォルトの状態では、サーバが NFS 問い合わせに応答するのは、現在のディスク操作が完了した (<literal>sync</literal> オプション) 後です。これを無効化するには、<literal>async</literal> オプションを使います。非同期書き込みを使うことで、性能はほんの少し向上しますが、信頼性は低下します。なぜなら、書き込み確認とディスクへの実際の書き込みの間にサーバがクラッシュした場合に、データを損失する危険性があるからです。デフォルト値が <literal>sync</literal> に変更されたのは最近なので (NFS バージョンによってデフォルト値が違うので)、明確に <literal>sync</literal> オプションを設定することを推奨します。
			</para>
			 <para>
				NFS クライアントがファイルシステムに root 権限でアクセスすることを許可しないために、サーバは root ユーザからのすべての問い合わせを <literal>nobody</literal> ユーザからの問い合わせとして処理します。この挙動は <literal>root_squash</literal> オプションを使った場合の挙動に対応し、<literal>root_squash</literal> オプションはデフォルトで有効化されています。<literal>no_root_squash</literal> オプションを使うことで、この挙動は無効化されますが、<literal>no_root_squash</literal> オプションは危険であり管理されない環境で使うべきではありません。<literal>anonuid=<replaceable>uid</replaceable></literal> と <literal>anongid=<replaceable>gid</replaceable></literal> オプションを使うことで、UID/GID 65534 (これは <literal>nobody</literal> ユーザと <literal>nogroup</literal> グループに対応します) の代わりに使う別の偽ユーザを指定することが可能です。
			</para>
			 <para>
				NFSv4 では <literal>sec</literal> オプションを追加してセキュリティレベルを指定することが可能です。デフォルト設定の <literal>sec=sys</literal> は特別なセキュリティ機能を有効化しません。<literal>sec=krb5</literal> は認証機能だけを有効化します。<literal>sec=krb5i</literal> は認証と整合性保護機能を有効化します。<literal>sec=krb5p</literal> はすべての機能、すなわち認証、整合性保護、プライバシー保護機能 (データ暗号化機能を含みます) を有効化します。これらを使うには、Kerberos サービスを動作させる必要があります (Kerberos サービスについては本書で解説されていません)。
			</para>
			 <para>
				他のオプションも利用できます。オプションは <citerefentry><refentrytitle>exports</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry> マニュアルページで説明されています。
			</para>
			 <sidebar> <title><emphasis>CAUTION</emphasis> 初回インストール</title>
			 <para>
				<filename>/etc/init.d/nfs-kernel-server</filename> 起動スクリプトは <filename>/etc/exports</filename> に 1 つ以上の NFS 共有が含まれる場合にサーバを起動しますが、初期状態の <filename>/etc/exports</filename> には NFS 共有エントリが含まれないので、初回インストール時に NFS サーバは起動されません。<filename>/etc/exports</filename> ファイルを編集して適切なエントリを含めたら、NFS サーバを以下のコマンドで起動するべきです。
			</para>
			 
<screen>
<computeroutput># </computeroutput><userinput>service nfs-kernel-server start</userinput></screen>
			 </sidebar>
		</section>
		 <section>
			<title>NFS クライアント</title>
			 <indexterm>
				<primary>クライアント</primary>
				<secondary>NFS</secondary>
			</indexterm>
			 <indexterm>
				<primary>NFS</primary>
				<secondary>クライアント</secondary>
			</indexterm>
			 <para>
				他のファイルシステムと同様、NFS 共有をシステムの階層構造に統合するにはマウント作業が必要です。NFS 共有ファイルシステムは特殊なので、<command>mount</command> コマンドと <filename>/etc/fstab</filename> ファイルにいくつかの調整を行うパラメータを含める必要があります。
			</para>
			 <example>
				<title><command>mount</command> コマンドを用いた手作業によるマウント</title>
				 
<screen>
<computeroutput># </computeroutput><userinput>mount -t nfs4 -o rw,nosuid arrakis.internal.falcot.com:/shared /srv/shared</userinput></screen>

			</example>
			 <example>
				<title><filename>/etc/fstab</filename> ファイルの NFS エントリ</title>
				 
<programlisting>
arrakis.internal.falcot.com:/shared /srv/shared nfs4 rw,nosuid 0 0</programlisting>

			</example>
			 <para>
				上の例で示したエントリを使うことで、システム起動時に <literal>arrakis</literal> サーバの <filename>/shared/</filename> NFS ディレクトリがローカルの <filename>/srv/shared/</filename> ディレクトリにマウントされます。ここでは読み書きアクセスを要求しています (このため <literal>rw</literal> パラメータを追加しています)。<literal>nosuid</literal> オプションは一種の保護手段で、共有ディレクトリに保存されているプログラムに設定された <literal>setuid</literal> または <literal>setgid</literal> ビットを無効化します。文書を保存するだけの目的で NFS 共有を使っている場合、<literal>noexec</literal> オプションを追加することを推奨します。これは共有ディレクトリに含まれるプログラムの実行を避けるものです。NFS サーバ上では <filename>shared</filename> ディレクトリは NFSv4 ルートエクスポート (たとえば <filename>/export/shared</filename>) の下位に属すディレクトリであり、最上位ディレクトリではありません。この点に注意してください。
			</para>
			 <para>
				<citerefentry><refentrytitle>nfs</refentrytitle>
				 <manvolnum>5</manvolnum></citerefentry> マニュアルページでは、すべてのオプションをについて詳しく説明されています。
			</para>

		</section>

	</section>
	 <section id="sect.windows-file-server-with-samba">
		<title>Samba を使った Windows 共有のセットアップ</title>
		 <para>
			Samba は Linux 上で SMB プロトコル (「CIFS」としても知られています) を取り扱う一連のツールを指します。Windows はネットワーク共有と共有プリンタを使うために SMB プロトコルを使います。
		</para>
		 <indexterm>
			<primary sortas="Windows キョウユウ">Windows 共有</primary>
		</indexterm>
		 <indexterm>
			<primary>Samba</primary>
		</indexterm>
		 <indexterm>
			<primary>SMB</primary>
		</indexterm>
		 <indexterm>
			<primary>CIFS</primary>
		</indexterm>
		 <indexterm>
			<primary>サーバ</primary>
			<secondary>ファイル</secondary>
		</indexterm>
		 <para>
			さらに Samba は Windows ドメインコントローラとして振る舞うことも可能です。Samba は Linux サーバと Windows が実行されているオフィスデスクトップマシンを完璧に統合する卓越したツールです。
		</para>
		 <section>
			<title>Samba サーバ</title>
			 <para>
				<emphasis role="pkg">samba</emphasis> パッケージには、Samba 4 の主要な 2 種類のサーバ <command>smbd</command> と <command>nmbd</command> が含まれます。
			</para>
			 <indexterm>
				<primary><command>smbd</command></primary>
			</indexterm>
			 <indexterm>
				<primary><command>nmbd</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>DOCUMENTATION</emphasis> 詳細情報</title>
			 <para>
				Samba サーバは非常に細かく設定できますし、多目的に使えます。そして、Samba は全く異なる要求やネットワークアーキテクチャに応じてさまざまな用途に使われます。本書では、Samba を独立型サーバとして使う用途に注目します。しかし、Samba を NT4 ドメインコントローラとして使ったり、完全な Active Directory ドメインコントローラとして使ったり、既存のドメイン (Windows サーバによってこれを管理することも可能です) の単なるメンバとして使ったりすることも可能です。
			</para>
			 <indexterm>
				<primary>ドメインコントローラ</primary>
			</indexterm>
			 <indexterm>
				<primary>Windows ドメイン</primary>
			</indexterm>
			 <para>
				<emphasis role="pkg">samba-doc</emphasis> パッケージには大量のコメント済み例ファイルが含まれ、これらは <filename>/usr/share/doc/samba-doc/examples/</filename> に保存されています。
			</para>
			 </sidebar> <sidebar> <title><emphasis>TOOL</emphasis> 認証に Windows サーバを使う</title>
			 <para>
				Winbind を使うことで、システム管理者は Windows サーバを認証サーバとして使う選択肢を与えられます。Winbind は PAM と NSS をうまく統合します。このことにより、Windows ドメインの全ユーザが自動的にアカウントを取得できる Linux マシン群をセットアップすることが可能です。
			</para>
			 <indexterm>
				<primary>Winbind</primary>
			</indexterm>
			 <para>
				より詳しい情報は <filename>/usr/share/doc/samba-doc/examples/pam_winbind/</filename> ディレクトリに含まれるファイルで説明されています。
			</para>
			 </sidebar> <section>
				<title><command>debconf</command> を使った設定</title>
				 <para>
					<emphasis role="pkg">samba</emphasis> パッケージは初回インストール時に最低限の設定を行いますが、設定を適用するには実際に <command>dpkg-reconfigure samba-common</command> を実行するべきです。
				</para>
				 <para>
					最初の質問で、Samba サーバが所属するワークグループの名前を尋ねられます (Falcot Corp の場合、この質問に対する回答は <literal>FALCOTNET</literal> です)。
				</para>
				 <para>
					次の質問で、DHCP デーモンによって提供される情報を使って WINS サーバを識別するか否かを尋ねられます。Falcot Corp の管理者はこのオプションを拒否しました。なぜなら、管理者は Samba サーバ自体を WINS サーバとして利用する予定だからです。
				</para>
				 <indexterm>
					<primary>WINS</primary>
				</indexterm>

			</section>
			 <section>
				<title>手作業による設定</title>
				 <section>
					<title><filename>smb.conf</filename> の変更</title>
					 <para>
						Falcot の用途に対応させるためには、<filename>/etc/samba/smb.conf</filename> 設定ファイルに含まれる他のオプションを変更することが必要です。以下の抜粋は <literal>[global]</literal> セクションに対する変更点を要約したものです。
					</para>
					 
<programlisting>
[global]

## 閲覧および身元確認 ###

# Samba サーバが所属するワークグループおよび NT ドメイン名に変更してください。
   workgroup = FALCOTNET

# 以下は Windows Internet Name Serving サポートを設定します。WINS Support
# オプションを yes に設定すると Samba の NMBD が WINS サーバとして機能します。
   wins support = yes <co id="smb.conf.wins"></co>

[...]

####### 認証 #######

# Server role オプションは Samba の動作モードを設定します。
# 設定できる値は "standalone server"、"member server"、"classic primary
# domain controller"、"classic backup domain controller"、"active
# directory domain controller" のうちどれか 1 つです。
#
# 多くの場合 "standalone sever" または "member server" を設定すると
# 良いでしょう。"active directory domain controller" を設定する場合、
# 事前に "samba-tool domain provision" を実行し、
# データベースを消去して新しいドメインを作成する必要があります。
   server role = standalone server

# security オプションの推奨設定は "security = user" です。この場合、Samba サーバ
# にアクセスするユーザはこのサーバの Unix アカウントを持っていなければいけません。
   security = user <co id="smb.conf.security"></co>

[...]</programlisting>
					 <calloutlist>
						<callout arearefs="smb.conf.wins">
							<para>
								Samba がローカルネットワークの Netbios ネームサーバ (WINS) として振る舞うことを意味します。
							</para>

						</callout>
						 <callout arearefs="smb.conf.security">
							<para>
								これは security パラメータのデフォルト値です。しかしながら、security パラメータは Samba 設定の要ですから、明示的に指定することをお勧めします。各ユーザは、共有の種類に関わらず必ず共有にアクセスする前に認証を必要とします。
							</para>

						</callout>

					</calloutlist>

				</section>
				 <section>
					<title>ユーザの追加</title>
					 <para>
						各 Samba ユーザはサーバにアカウントを持っていなければいけません。このため管理者は最初に Unix アカウントを作成し、そのアカウントを Samba のデータベースに登録する必要があります。Unix アカウントを作成する段階は通常通り行います (たとえば <command>adduser</command> を使います)。
					</para>
					 <para>
						既存のユーザを Samba データベースに追加するには、<command>smbpasswd -a <replaceable>user</replaceable></command> コマンドを実行します。コマンドは対話的にパスワードを尋ねます。
					</para>
					 <para>
						ユーザを削除するには、<command>smbpasswd -x <replaceable>user</replaceable></command> コマンドを実行します。Samba アカウントを一時的に利用できなくしたり (<command>smbpasswd -d <replaceable>user</replaceable></command> を使います)、もう一度利用できるようにしたり (<command>smbpasswd -e <replaceable>user</replaceable></command> を使います) することも可能です。
					</para>

				</section>

			</section>

		</section>
		 <section>
			<title>Samba クライアント</title>
			 <para>
				Samba のクライアント機能を使うことで、Linux マシンは Windows 共有と共有プリンタへアクセスすることが可能になります。必要なプログラムは <emphasis role="pkg">cifs-utils</emphasis> と <emphasis role="pkg">smbclient</emphasis> パッケージに含まれます。
			</para>
			 <indexterm>
				<primary><emphasis>smbclient</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary><emphasis>cifs-utils</emphasis></primary>
			</indexterm>
			 <section>
				<title><command>smbclient</command> プログラム</title>
				 <para>
					<command>smbclient</command> プログラムは SMB サーバに問い合わせを行います。特定のユーザ名を使ってサーバに接続するには <literal>-U <replaceable>user</replaceable></literal> オプションを使います。<command>smbclient //<replaceable>server</replaceable>/<replaceable>share</replaceable></command> はコマンドライン FTP クライアントに類似した対話的方法を使って共有にアクセスします。<command>smbclient -L <replaceable>server</replaceable></command> は対象のサーバで利用できる (見える) 共有を全部リストします。
				</para>

			</section>
			 <section>
				<title>Windows 共有のマウント</title>
				 <para>
					<command>mount</command> コマンドを使うことで、Windows 共有を Linux ファイルシステム階層にマウントすることが可能になります (<emphasis role="pkg">cifs-utils</emphasis> の提供する <command>mount.cifs</command> の助けを借ります)。
				</para>
				 <indexterm>
					<primary><command>mount.cifs</command></primary>
				</indexterm>
				 <indexterm>
					<primary sortas="Windows キョウユウ">Windows 共有</primary>
					<secondary>マウント</secondary>
				</indexterm>
				 <example>
					<title>Windows 共有をマウントする</title>
					 
<programlisting>
mount -t cifs //arrakis/shared /shared \
      -o credentials=/etc/smb-credentials</programlisting>

				</example>
				 <para>
					<filename>/etc/smb-credentials</filename> ファイル (ユーザはこのファイルを読み込むことはできません) は以下の書式で書かれています。
				</para>
				 
<programlisting>
username = <replaceable>user</replaceable>
password = <replaceable>password</replaceable></programlisting>
				 <para>
					コマンドラインで指定できるオプションは他にも存在します。オプションの完全なリストは <citerefentry><refentrytitle>mount.cifs</refentrytitle>
					 <manvolnum>8</manvolnum></citerefentry> マニュアルページに書かれています。オプションの中でも特に次の 2 種類は興味深いです。<literal>uid</literal> と <literal>gid</literal> を使うことで、マウントされたことで利用できるようになったファイルの所有者とグループを指定したものに強制することが可能になります。これを指定することで、root 以外のユーザもマウント先にアクセスできるようになります。
				</para>
				 <para>
					<filename>/etc/fstab</filename> の中に設定を書いて、Windows 共有をマウントすることも可能です。
				</para>
				 
<programlisting>
//<replaceable>server</replaceable>/shared /shared cifs credentials=/etc/smb-credentials</programlisting>
				 <para>
					SMB/CIFS 共有をアンマウントするには、標準的な <command>umount</command> コマンドを使います。
				</para>

			</section>
			 <section>
				<title>共有プリンタを用いた印刷</title>
				 <para>
					CUPS は Linux ワークステーションから Windows マシンによって共有されているプリンタに印刷を行う洗練された解決策です。<emphasis role="pkg">smbclient</emphasis> がインストールされている場合、CUPS を使うことで、Windows 共有プリンタを自動的にインストールすることが可能です。
				</para>
				 <indexterm>
					<primary sortas="インサツ">印刷</primary>
					<secondary>ネットワーク</secondary>
				</indexterm>
				 <para>
					以下に必要な各段階を示します。
				</para>
				 <itemizedlist>
					<listitem>
						<para>
							CUPS 設定インターフェース <literal>http://localhost:631/admin</literal> にアクセスします。
						</para>

					</listitem>
					 <listitem>
						<para>
							「Add Printer」をクリックします。
						</para>

					</listitem>
					 <listitem>
						<para>
							プリンタデバイスを選択し、「Windows Printer via SAMBA」を選んでください。
						</para>

					</listitem>
					 <listitem>
						<para>
							ネットワークプリンタの接続 URI を入力します。URI は以下の書式を使うべきです。
						</para>
						 <para>
							<literal>smb://<replaceable>user</replaceable>:<replaceable>password</replaceable>@<replaceable>server</replaceable>/<replaceable>printer</replaceable></literal>
						</para>

					</listitem>
					 <listitem>
						<para>
							プリンタを一意に識別する名前を入力してください。その後、プリンタの説明と場所を入力してください。これらは、プリンタの利用者が印刷に使うプリンタを識別できるように、利用者に表示される文字列です。
						</para>

					</listitem>
					 <listitem>
						<para>
							プリンタの製造者/モデルを指示するか、使用するプリンタの説明ファイル (PPD) を直接提供します。
						</para>

					</listitem>

				</itemizedlist>
				 <para>
					これで、プリンタが利用できるようになりました!
				</para>

			</section>

		</section>

	</section>
	 <section id="sect.http-ftp-proxy">
		<title>HTTP/FTP プロキシ</title>
		 <para>
			HTTP/FTP プロキシは HTTP または FTP 接続の仲介者として機能します。HTTP/FTP プロキシの役割は 2 種類あります。
		</para>
		 <itemizedlist>
			<listitem>
				<para>
					キャッシュ。最近ダウンロードされた文書をローカルにコピーします。これはダウンロードを重複して行うことを避ける役割を果たします。
				</para>

			</listitem>
			 <listitem>
				<para>
					サーバのフィルタリング。プロキシの利用が強制されている場合 (そしてプロキシを介さない外部への接続がブロックされる場合)、プロキシは接続要求を許可するか否かを決定することが可能です。
				</para>

			</listitem>

		</itemizedlist>
		 <indexterm>
			<primary>HTTP/FTP プロキシ</primary>
		</indexterm>
		 <indexterm>
			<primary>プロキシキャッシュ</primary>
		</indexterm>
		 <para>
			Falcot Corp はプロキシサーバとして Squid を選びました。
		</para>
		 <indexterm>
			<primary>Squid</primary>
		</indexterm>
		 <section>
			<title>インストール</title>
			 <para>
				<emphasis role="pkg">squid3</emphasis> Debian パッケージには、モジュール式 (キャッシュ) プロキシだけが含まれます。Squid をフィルタリングサーバとして使うには、追加で <emphasis role="pkg">squidguard</emphasis> パッケージをインストールする必要があります。加えて、<emphasis role="pkg">squid-cgi</emphasis> には、Squid プロキシ用の問い合わせおよび管理インターフェースが含まれます。
			</para>
			 <para>
				インストールの前に、システムが自分の完全な名前を識別できるか確認することを忘れないでください。すなわち <command>hostname -f</command> が完全修飾名 (ドメイン名を含むホスト名) を返すことを確認してください。これに失敗した場合、<filename>/etc/hosts</filename> ファイルを編集して、システムの完全な名前 (たとえば <literal>arrakis.falcot.com</literal> など) を書き込むべきです。潜在的な名前の衝突を避けるには、ネットワーク管理者に公認コンピュータ名の妥当性を確認するべきです。
			</para>

		</section>
		 <section>
			<title>キャッシュの設定</title>
			 <para>
				キャッシュサーバを有効化するには、<filename>/etc/squid3/squid.conf</filename> 設定ファイルを編集し、ローカルネットワークからのマシンがプロキシを介して問い合わせを実行することを許可するだけで簡単に可能です。以下の例は Falcot Corp の管理者の行った変更を表しています。
			</para>
			 <example>
				<title><filename>/etc/squid3/squid.conf</filename> ファイル (抜粋)</title>
				 
<programlisting>
# クライアントからのアクセスを許可するにはここにルールを書いてください

# 以下はローカルネットワークからのアクセスを許可するルール
# の一例です。IP アドレスリストを HTTP アクセスを許可する
# (内部) IP ネットワークに合わたものに変更してください。
acl our_networks src 192.168.1.0/24 192.168.2.0/24
http_access allow our_networks
http_access allow localhost
# 最後にその他のクライアントがプロキシへアクセスすることを拒否します。
http_access deny all</programlisting>

			</example>

		</section>
		 <section>
			<title>フィルタの設定</title>
			 <para>
				<command>squid</command> 自身はフィルタリングを実行しません。フィルタリング作業は <command>squidGuard</command> に委任されています。<command>squid</command> を設定して <command>squidGuard</command> と協力するようにしなければいけません。これを行うには、以下の指示文を <filename>/etc/squid3/squid.conf</filename> ファイルに追加します。
			</para>
			 <indexterm>
				<primary><command>squidGuard</command></primary>
			</indexterm>
			 
<programlisting>
url_rewrite_program /usr/bin/squidGuard -c /etc/squid3/squidGuard.conf</programlisting>
			 <para>
				<filename>/usr/share/doc/squidguard/examples/squidGuard.cgi.gz</filename> をたたき台として使い、<filename>/usr/lib/cgi-bin/squidGuard.cgi</filename> CGI プログラムをインストールすることが必要です。このスクリプトの <varname>$proxy</varname> と <varname>$proxymaster</varname> 変数 (それぞれプロキシの名前と管理者の連絡用電子メールアドレスです) を変更する必要があります。<varname>$image</varname> と <varname>$redirect</varname> 変数は問い合わせが拒否されたことを表現する既存の画像を設定します。
			</para>
			 <para>
				このフィルタを有効化するには、<command>service squid3 reload</command> コマンドを使います。しかしながら、<emphasis role="pkg">squidguard</emphasis> パッケージはデフォルトで何もフィルタリングしません。フィルタリングポリシーを定義するのは管理者の仕事です。これを行うには、<filename>/etc/squid3/squidGuard.conf</filename> ファイルを作成します (必要ならば <filename>/etc/squidguard/squidGuard.conf.default</filename> をテンプレートとして使います)。
			</para>
			 <para>
				<command>squidGuard</command> 設定ファイル (またはその中で言及しているドメインまたは URL のリストの 1 つ) を変更したら、毎回 <command>update-squidguard</command> を使って作業データベースを再生成しなければいけません。設定ファイルの構文は以下のウェブサイトで説明されています。<ulink type="block" url="http://www.squidguard.org/Doc/configure.html" />
			</para>
			 <indexterm>
				<primary><command>update-squidguard</command></primary>
			</indexterm>
			 <sidebar> <title><emphasis>ALTERNATIVE</emphasis> DansGuardian</title>
			 <indexterm>
				<primary><emphasis role="pkg">dansguardian</emphasis></primary>
			</indexterm>
			 <indexterm>
				<primary>PICS</primary>
			</indexterm>
			 <para>
				<emphasis role="pkg">dansguardian</emphasis> パッケージは <emphasis>squidguard</emphasis> の代替品です。dansguardian は単純に禁止された URL のブラックリストを取り扱うだけではありません。PICS システム (<emphasis>Platform for Internet Content Selection</emphasis>) の利点を駆使してページ内容を動的に解析することで、ページを許可するか否かを判断することが可能です。
			</para>
			 </sidebar>
		</section>

	</section>
	 <section id="sect.ldap-directory">
		<title>LDAP ディレクトリ</title>
		 <indexterm>
			<primary>LDAP</primary>
		</indexterm>
		 <indexterm>
			<primary>OpenLDAP</primary>
		</indexterm>
		 <indexterm>
			<primary>ディレクトリ、LDAP</primary>
		</indexterm>
		 <para>
			OpenLDAP は LDAP プロトコルの実装です。言い換えれば、OpenLDAP はディレクトリを保存するために設計された特製データベースです。OpenLDAP が最もよく使われる用途は、LDAP サーバを使ってユーザアカウントと関連するパーミッションの中央管理を行う場合です。さらに、LDAP データベースは簡単に複製できるので、複数の同期された LDAP サーバをセットアップすることが可能になります。ネットワークとユーザの数が急速に多くなった場合でも、複数のサーバ間で負荷のバランスをとることが可能です。
		</para>
		 <para>
			LDAP データは階層的に構造化されています。LDAP データの構造は「スキーマ」によって定義され、スキーマはデータベースに保存できるオブジェクトの種類をその属性リストと一緒に説明するものです。データベース内の特定のオブジェクトを参照するために使われる構文はデータ構造に依存し、構文の複雑さはデータ構造の複雑さに対応します。
		</para>
		 <section>
			<title>インストール</title>
			 <para>
				OpenLDAP サーバは <emphasis role="pkg">slapd</emphasis> パッケージに含まれます。LDAP サーバと情報をやり取りするためのコマンドラインツールは <emphasis role="pkg">ldap-utils</emphasis> パッケージに含まれます。
			</para>
			 <indexterm>
				<primary><emphasis>slapd</emphasis></primary>
			</indexterm>
			 <para>
				通常 <emphasis role="pkg">slapd</emphasis> のインストール時に質問される事項の数は少ないので、作られたデータベースは要求を満足するものにはならないでしょう。幸いなことに <command>dpkg-reconfigure slapd</command> を使えば簡単に LDAP データベースをより詳細に再設定することが可能です。
			</para>
			 <itemizedlist>
				<listitem>
					<para>
						OpenLDAP サーバの設定を省略しますか? LDAP サービスを設定するので当然「いいえ」を選びます。
					</para>

				</listitem>
				 <listitem>
					<para>
						DNS ドメイン名。「<literal>falcot.com</literal>」と入力します。
					</para>

				</listitem>
				 <listitem>
					<para>
						組織名。「Falcot Corp」と入力します。
					</para>

				</listitem>
				 <listitem>
					<para>
						管理者のパスワードを入力します。
					</para>

				</listitem>
				 <listitem>
					<para>
						利用するデータベースバックエンド。「MDB」を選びます。
					</para>

				</listitem>
				 <listitem>
					<para>
						<emphasis role="pkg">slapd</emphasis> をパージした時にデータベースを削除しますか? 間違ってデータベースを失う危険性を増やすのは得策ではありませんから「いいえ」を選びます。
					</para>

				</listitem>
				 <listitem>
					<para>
						古いデータベースを移動しますか? この質問はデータベースが既に存在するにも関わらず設定を行おうとした場合に表示されます。たとえば最初のインストールの直後に <command>dpkg-reconfigure slapd</command> を実行する場合など、空っぽのデータベースから設定を再開したい場合、「はい」を選びます。
					</para>

				</listitem>
				 <listitem>
					<para>
						LDAPv2 プロトコルを許可しますか? 許可する意味がないので「いいえ」を選びます。本書で使うツールはすべて LDAPv3 プロトコルを理解します。
					</para>

				</listitem>

			</itemizedlist>
			 <sidebar> <title><emphasis>BACK TO BASICS</emphasis> LDIF フォーマット</title>
			 <para>
				LDIF ファイル (<emphasis>LDAP Data Interchange Format</emphasis>) は移植可能なテキストファイルで、LDAP データベース (またはデータベースの一部) の内容を説明しています。LDIF ファイルを使って、他の LDAP サーバにデータを投入することが可能です。
			</para>
			 <indexterm>
				<primary>LDIF</primary>
			</indexterm>
			 </sidebar> <para>
				以下の問い合わせによって実例を示す通り、最低限のデータベースが設定されています。
			</para>
			 
<screen>
<computeroutput>$ </computeroutput><userinput>ldapsearch -x -b dc=falcot,dc=com</userinput>
<computeroutput># extended LDIF
#
# LDAPv3
# base &lt;dc=falcot,dc=com&gt; with scope subtree
# filter: (objectclass=*)
# requesting: ALL
#

# falcot.com
dn: dc=falcot,dc=com
objectClass: top
objectClass: dcObject
objectClass: organization
o: Falcot Corp
dc: falcot

# admin, falcot.com
dn: cn=admin,dc=falcot,dc=com
objectClass: simpleSecurityObject
objectClass: organizationalRole
cn: admin
description: LDAP administrator

# search result
search: 2
result: 0 Success

# numResponses: 3
# numEntries: 2
</computeroutput></screen>
			 <para>
				この問い合わせの結果 2 種類のオブジェクトが返されました。具体的に言えば、組織自身と管理ユーザが返されました。
			</para>

		</section>
		 <section>
			<title>ディレクトリへの書き込み</title>
			 <para>
				空っぽのデータベースは全く役に立たないので、すべての存在するディレクトリをデータベースに投入することにします。ここで存在するディレクトリとはユーザ、グループ、サービス、ホスト名データベースなどを指します。
			</para>
			 <para>
				<emphasis role="pkg">migrationtools</emphasis> パッケージには、標準的な Unix ディレクトリ (<filename>/etc/passwd</filename>、<filename>/etc/group</filename>、<filename>/etc/services</filename>、<filename>/etc/hosts</filename> など) からのデータを展開するための一連のスクリプトが含まれます。スクリプトを使ってデータを変換し、LDAP データベースに投入します。
			</para>
			 <indexterm>
				<primary><emphasis role="pkg">migrationtools</emphasis></primary>
			</indexterm>
			 <para>
				<emphasis role="pkg">migrationtools</emphasis> パッケージをインストールしたら、必ず <filename>/etc/migrationtools/migrate_common.ph</filename> を編集してください。つまり、<varname>IGNORE_UID_BELOW</varname> と <varname>IGNORE_GID_BELOW</varname> オプションを編集して (コメント解除するだけで十分です)、<varname>DEFAULT_MAIL_DOMAIN</varname> と <varname>DEFAULT_BASE</varname> を更新する必要があります。
			</para>
			 <para>
				実際の移行操作は以下の通り <command>migrate_all_online.sh</command> コマンドを使って行います。
			</para>
			 
<screen>
<computeroutput># </computeroutput><userinput>cd /usr/share/migrationtools</userinput>
<computeroutput># </computeroutput><userinput>LDAPADD="/usr/bin/ldapadd -c" ETC_ALIASES=/dev/null ./migrate_all_online.sh</userinput></screen>
			 <para>
				<command>migrate_all_online.sh</command> から LDAP データベースに移行するデータの種類に関する数個の質問を尋ねられます。<xref linkend="tab-migrate-all" xrefstyle="select: label nopage" /> には Falcot の使用例で使った回答がまとめられています。
			</para>
			 <table colsep="1" id="tab-migrate-all">
				<title><command>migrate_all_online.sh</command> スクリプトからの質問に対する回答</title>
				 <tgroup cols="2">
					<colspec align="justify"></colspec>
					<colspec align="justify"></colspec>
					 <thead>
						<row>
							<entry>質問</entry>
							<entry>回答</entry>
						</row>

					</thead>
					 <tbody>
						<row>
							<entry>X.500 命名コンテキスト</entry>
							 <entry><literal>dc=falcot,dc=com</literal></entry>

						</row>
						 <row>
							<entry>LDAP サーバのホスト名</entry>
							 <entry><literal>localhost</literal></entry>

						</row>
						 <row>
							<entry>管理者の識別名</entry>
							 <entry><literal>cn=admin,dc=falcot,dc=com</literal></entry>

						</row>
						 <row>
							<entry>認証情報の紐付け</entry>
							 <entry>LDAP データベース管理用パスワード</entry>

						</row>
						 <row>
							<entry>DUAConfigProfile を作成</entry>
							 <entry>no</entry>

						</row>

					</tbody>

				</tgroup>

			</table>
			 <para>
				上の例では <literal>ETC_ALIASES=/dev/null</literal> を指定することで意図的に <filename>/etc/aliases</filename> ファイルの移行を行いませんでした。なぜなら、Debian の提供する標準的なスキーマには、このスクリプトが電子メールアドレスを表現するために使う構造が含まれないからです。このデータをディレクトリに統合したい場合、標準的なスキーマに <filename>/etc/ldap/schema/misc.schema</filename> ファイルを追加するべきです。
			</para>
			 <sidebar> <title><emphasis>TOOL</emphasis> LDAP ディレクトリの閲覧</title>
			 <para>
				<command>jxplorer</command> コマンド (同名のパッケージに含まれます) は LDAP データベースを閲覧および編集することが可能なグラフィカルツールです。<command>jxplorer</command> コマンドは興味深いツールで、このツールを使うことで管理者は LDAP データの階層構造をわかりやすく概観することが可能です。
			</para>
			 <indexterm>
				<primary><command>jxplorer</command></primary>
			</indexterm>
			 </sidebar> <para>
				<command>ldapadd</command> コマンドの <literal>-c</literal> オプションの利用について触れておきます。このオプションはエラーが起きた場合に処理を停止しないように要求するものです。このオプションを使うことが必要です。なぜなら、<filename>/etc/services</filename> を変換する際に、無視しても問題ない数個のエラーが起きることが多いからです。
			</para>

		</section>
		 <section>
			<title>LDAP を用いたアカウントの管理</title>
			 <para>
				これで LDAP データベースにいくつかの実用的な情報が含まれるようになりましたので、このデータを使うように設定します。この節では、さまざまなシステムディレクトリが LDAP データベースを使うように Linux システムを設定する方法に注目します。
			</para>
			 <section id="sect.config-nss">
				<title>NSS の設定</title>
				 <para>
					NSS システム (Name Service Switch、補注<xref linkend="sidebar.intro-nss" />を参照してください) はシステムディレクトリの情報を定義したり取得したりするために設計されたモジュール式システムです。NSS 用のデータ参照元として LDAP を使うには、<emphasis role="pkg">libnss-ldap</emphasis> パッケージをインストールする必要があります。<emphasis role="pkg">libnss-ldap</emphasis> パッケージのインストール中に数個の質問が行われます。ここで使った回答は<xref linkend="tab-libnss-ldap" xrefstyle="select: label nopage" /> にまとめられています。
				</para>
				 <indexterm>
					<primary><emphasis>libnss-ldap</emphasis></primary>
				</indexterm>
				 <table colsep="1" id="tab-libnss-ldap">
					<title><emphasis role="pkg">libnss-ldap</emphasis> パッケージの設定</title>
					 <tgroup cols="2">
						<colspec align="justify"></colspec>
						 <colspec align="justify"></colspec>
						 <thead>
							<row>
								<entry>質問</entry>
								 <entry>回答</entry>

							</row>

						</thead>
						 <tbody>
							<row>
								<entry>LDAP サーバの Uniform Resource Identifier</entry>
								 <entry><literal>ldap://ldap.falcot.com</literal></entry>

							</row>
							 <row>
								<entry>検索ベースの識別名</entry>
								 <entry><literal>dc=falcot,dc=com</literal></entry>

							</row>
							 <row>
								<entry>使用する LDAP バージョン</entry>
								 <entry><literal>3</literal></entry>

							</row>
							 <row>
								<entry>LDAP データベースはログインを必要としますか?</entry>
								 <entry>no</entry>

							</row>
							 <row>
								<entry>root への特別な LDAP 権限</entry>
								 <entry>はい</entry>

							</row>
							 <row>
								<entry>オーナのみ設定ファイルの読み書きができるようにしますか</entry>
								 <entry>no</entry>

							</row>
							 <row>
								<entry>LDAP 管理用アカウント</entry>
								 <entry><literal>cn=admin,dc=falcot,dc=com</literal></entry>

							</row>
							 <row>
								<entry>LDAP 管理用パスワード</entry>
								 <entry>LDAP データベース管理用パスワード</entry>

							</row>

						</tbody>

					</tgroup>

				</table>
				 <para>
					そして、<filename>/etc/nsswitch.conf</filename> ファイルを変更し、最近インストールした <command>ldap</command> モジュールを使うように NSS を設定する必要があります。
				</para>
				 <example>
					<title><filename>/etc/nsswitch.conf</filename> ファイル</title>
					 
<programlisting>
# /etc/nsswitch.conf
#
# 以下は GNU Name Service Switch 機能の設定例です。
# `glibc-doc' と `info' パッケージをインストール済みならば、
# `info libc "Name Service Switch"' で詳細情報を参照できます。

passwd: ldap compat
group: ldap compat
shadow: ldap compat

hosts: files dns ldap
networks: ldap files

protocols: ldap db files
services: ldap db files
ethers: ldap db files
rpc: ldap db files

netgroup: ldap files</programlisting>

				</example>
				 <para>
					通常 <command>ldap</command> モジュールは他のモジュールよりも前に書き込みます。こうすることで、問い合わせの際に <command>ldap</command> モジュールが優先して使われます。注目すべき除外例が <literal>hosts</literal> サービスです。なぜなら、LDAP サーバに接続するには (<literal>ldap.falcot.com</literal> の名前解決を行うためには) 先に DNS を調べる必要があるからです。<literal>hosts</literal> サービスで最初 <command>ldap</command> モジュールを使うようにすると、LDAP サーバにホスト名を問い合わせることになります。しかし、名前解決を担当している LDAP サーバに接続するには LDAP サーバの名前解決が必要なので、無限ループすることになります。
				</para>
				 <para>
					LDAP サーバからの応答を正式な回答として取り扱う場合 (そして特殊な状況が起きない限り <command>files</command> モジュールの使うローカルファイルからの応答を無視する場合)、以下の構文を使ってサービスを設定します。
				</para>
				 <para>
					<literal><replaceable>service</replaceable>: ldap [NOTFOUND=return] files</literal>.
				</para>
				 <para>
					LDAP サービスを利用して問い合わせたエントリが LDAP データベースに存在しない場合、問い合わせに対する応答は「not existing」になるでしょう。これは問い合わせたエントリがローカルファイルに存在するか否かに依存しません。しかし LDAP サービスが利用できない場合に限り、ローカルファイルにエントリを問い合わせます。
				</para>

			</section>
			 <section id="sect.config-pam">
				<title>PAM の設定</title>
				 <para>
					この節では、PAM 設定 (補注<xref linkend="sidebar.intro-pam" />を参照してください) を説明します。ここで説明した PAM 設定を使うことで、アプリケーションは LDAP データベースに向けて認証を要求することが可能になります。
				</para>
				 <sidebar> <title><emphasis>CAUTION</emphasis> 破壊された認証</title>
				 <para>
					さまざまなプログラムが使う標準的な PAM 設定の変更は慎重に行うべきです。1 つの間違いが認証を破壊し、ログインを不可能にする場合があります。このため root シェルを開いた状態を保ちながら作業を行うことが良い予防策です。こうしておけば、設定エラーが起きた場合、設定を修正して最小限の努力でサービスを再起動することが可能です。
				</para>
				 </sidebar> <para>
					PAM 用の LDAP モジュールは <emphasis role="pkg">libpam-ldap</emphasis> パッケージに含まれます。<emphasis role="pkg">libpam-ldap</emphasis> パッケージをインストールする際に、<emphasis role="pkg">libnss-ldap</emphasis> をインストールした際にされた質問と良く似た数個の質問を尋ねられます。いくつかの設定パラメータ (LDAP サーバの URI など) は <emphasis role="pkg">libnss-ldap</emphasis> パッケージと共有されます。ここで使った回答は<xref linkend="tab-libpam-ldap" xrefstyle="select: label nopage" /> にまとめられています。
				</para>
				 <indexterm>
					<primary><emphasis>libpam-ldap</emphasis></primary>
				</indexterm>
				 <table colsep="1" id="tab-libpam-ldap">
					<title><emphasis>libpam-ldap</emphasis> の設定</title>
					 <tgroup cols="2">
						<colspec align="justify"></colspec>
						 <colspec align="justify"></colspec>
						 <thead>
							<row>
								<entry>質問</entry>
								 <entry>回答</entry>

							</row>

						</thead>
						 <tbody>
							<row>
								<entry>LDAP 管理アカウントがローカルの root のように振る舞うことを許しますか?</entry>
								 <entry>はい。こうすることで、通常の <command>passwd</command> コマンドから LDAP データベースに保存されているパスワードを変更することが可能になります。</entry>

							</row>
							 <row>
								<entry>LDAP データベースはログインを必要としますか?</entry>
								 <entry>no</entry>

							</row>
							 <row>
								<entry>LDAP 管理用アカウント</entry>
								 <entry><literal>cn=admin,dc=falcot,dc=com</literal></entry>

							</row>
							 <row>
								<entry>LDAP 管理用パスワード</entry>
								 <entry>LDAP 管理用パスワード</entry>

							</row>
							 <row>
								<entry>パスワードに使うローカル暗号化アルゴリズム</entry>
								 <entry>crypt</entry>

							</row>

						</tbody>

					</tgroup>

				</table>
				 <para>
					<emphasis role="pkg">libpam-ldap</emphasis> をインストールすると自動的に <filename>/etc/pam.d/common-auth</filename>、<filename>/etc/pam.d/common-password</filename>、<filename>/etc/pam.d/common-account</filename> ファイルで定義されたデフォルトの PAM 設定が適用されます。このメカニズムは専用の <command>pam-auth-update</command> ツール (<emphasis role="pkg">libpam-runtime</emphasis> パッケージから提供される) を使います。<command>pam-auth-update</command> ツールは PAM モジュールを有効化または無効化したい管理者によって実行される場合もあります。
				</para>
				 <indexterm>
					<primary><filename>common-auth</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/pam.d/common-auth</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>common-password</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/pam.d/common-password</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>common-account</filename></primary>
				</indexterm>
				 <indexterm>
					<primary><filename>/etc/pam.d/common-account</filename></primary>
				</indexterm>

			</section>
			 <section>
				<title>安全な LDAP データ交換</title>
				 <indexterm>
					<primary>LDAP</primary>
					<secondary sortas="アンゼンナ LDAP">安全な LDAP</secondary>
				</indexterm>
				 <para>
					デフォルトで、LDAP プロトコルはネットワークを平文で通信します。従って、(暗号化された) パスワードがネットワーク上をそのまま流れます。暗号化されたパスワードをネットワークから抽出することが可能ですから、パスワードは辞書型攻撃に弱いということになります。暗号化層を追加することで、このような危険性を避けることが可能です。この節のテーマは暗号化層を有効化することです。
				</para>
				 <section>
					<title>サーバの設定</title>
					 <indexterm>
						<primary><foreignphrase>OpenSSL</foreignphrase></primary>
						<secondary sortas="カギサクセイ">鍵作成</secondary>
					</indexterm>
					 <indexterm>
						<primary sortas="カギペア">鍵ペア</primary>
					</indexterm>
					 <para>
						最初に LDAP サーバ用の (公開鍵と秘密鍵から成る) 鍵ペアを作成します。Falcot の管理者は鍵ペアを生成するために <emphasis>easy-rsa</emphasis> を再利用します (<xref linkend="sect.easy-rsa" />を参照してください)。<command>./build-key-server ldap.falcot.com</command> を実行すると、数個の一般的な (場所、組織名などに関する) 質問を尋ねられます。「Common Name」に対する回答は<emphasis>必ず</emphasis> LDAP サーバの完全修飾ホスト名にしてください。今回の場合 <literal>ldap.falcot.com</literal> にしてください。
					</para>
					 <para>
						<command>./build-key-server ldap.falcot.com</command> は証明書を作成し、<filename>keys/ldap.falcot.com.crt</filename> ファイルに保存します。さらに対応する秘密鍵は <filename>keys/ldap.falcot.com.key</filename> に保存されます。
					</para>
					 <para>
						さらに、これらの鍵を標準的な場所にインストールし、<literal>openldap</literal> ユーザ権限で実行されている LDAP サーバが秘密鍵を読み込み可能であることを保証しなければいけません。これを行うために以下の通り実行します。
					</para>
					 
<screen><computeroutput># </computeroutput><userinput>adduser openldap ssl-cert
</userinput><computeroutput>ユーザ `openldap' をグループ `ssl-cert' に追加しています...
ユーザ openldap をグループ ssl-cert に追加
完了。
# </computeroutput><userinput>mv keys/ldap.falcot.com.key /etc/ssl/private/ldap.falcot.com.key
</userinput><computeroutput># </computeroutput><userinput>chown root:ssl-cert /etc/ssl/private/ldap.falcot.com.key
</userinput><computeroutput># </computeroutput><userinput>chmod 0640 /etc/ssl/private/ldap.falcot.com.key
</userinput><computeroutput># </computeroutput><userinput>mv newcert.pem /etc/ssl/certs/ldap.falcot.com.pem
</userinput></screen>
					 <para>
						<command>slapd</command> デーモンにこれらの鍵を暗号化に使うように伝えることも必要です。LDAP サーバの設定は動的に管理されます。つまり、設定は <literal>cn=config</literal> オブジェクト階層に対する通常の LDAP 操作によって更新され、サーバは設定を永続的なものにするために <filename>/etc/ldap/slapd.d</filename> をリアルタイムで更新します。このため、設定を更新するには <command>ldapmodify</command> ツールを使ってください。
					</para>
					 <example>
						<title>暗号化用の <command>slapd</command> の設定</title>
						 
<screen><computeroutput># </computeroutput><userinput>cat &gt;ssl.ldif &lt;&lt;END
dn: cn=config
changetype: modify
add: olcTLSCertificateFile
olcTLSCertificateFile: /etc/ssl/certs/ldap.falcot.com.pem
-
add: olcTLSCertificateKeyFile
olcTLSCertificateKeyFile: /etc/ssl/private/ldap.falcot.com.key
-
END
</userinput><computeroutput># </computeroutput><userinput>ldapmodify -Y EXTERNAL -H ldapi:/// -f ssl.ldif
</userinput><computeroutput>SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0
modifying entry "cn=config"
</computeroutput></screen>

					</example>
					 <sidebar> <title><emphasis>TOOL</emphasis> <command>ldapvi</command> で LDAP ディレクトリを編集する</title>
					 <indexterm>
						<primary><command>ldapvi</command></primary>
					</indexterm>
					 <para>
						<command>ldapvi</command> を使うことで、LDAP ディレクトリの任意の部分に対する LDIF 出力を表示したり、テキストエディタでそれを変更したり、対応する LDAP 操作を実行したりすることが可能です。
					</para>
					 <para>
						このため、LDAP サーバの設定を更新するには <command>ldapvi</command> を使って <literal>cn=config</literal> 階層を編集する方法が便利です。
					</para>
					 
<screen><computeroutput># </computeroutput><userinput>ldapvi -Y EXTERNAL -h ldapi:/// -b cn=config
</userinput></screen>
					 </sidebar> <para>
						暗号化を有効化するための最後の作業が <filename>/etc/default/slapd</filename> ファイル内の <varname>SLAPD_SERVICES</varname> 変数を変更することです。ここでは慎重を期して、安全対策されていない LDAP を無効化しています。
					</para>
					 <example>
						<title><filename>/etc/default/slapd</filename> ファイル</title>
						 
<programlisting>
# slapd.conf ファイルまたは slapd.d cn=config ディレクトリの
# デフォルト位置を指定してください。空の場合、コンパイル時のデフォルト値
# (/etc/ldap/slapd.d およびその代替の /etc/ldap/slapd.conf) が使われます。
SLAPD_CONF=

# slapd サーバを実行するシステムアカウントを指定してください。
# 空の場合、root 権限で実行します。
SLAPD_USER="openldap"

# slapd サーバを実行するシステムグループを指定してください。
# 空の場合、SLAPD_USER のメイングループ権限で実行します。
SLAPD_GROUP="openldap"

# slapd サーバの pid ファイルのパスを指定してください。未指定の場合、
# init.d スクリプトは $SLAPD_CONF (デフォルト値は /etc/ldap/slapd.conf
# です) を評価してパスを指定しようとします。
SLAPD_PIDFILE=

# 通常 slapd は TCP ポート 389 番だけにサービスを提供します。
# さらに slapd は TCP ポート 636 番 (ldaps) および unix ソケット
# にもサービスを提供できます。
# 以下はその使用例です。
# SLAPD_SERVICES="ldap://127.0.0.1:389/ ldaps:/// ldapi:///"
SLAPD_SERVICES="ldaps:/// ldapi:///"

# SLAPD_NO_START を設定した場合、init スクリプトは
# slapd を開始および再開しません (停止だけは実行されます)。
# 別の手段で slapd を実行している場合や、通常はマシンの起動時に
# slapd を開始したくない場合、以下の行を有効化してください。
#SLAPD_NO_START=1

# SLAPD_SENTINEL_FILE がファイルへのパスに設定され、設定されたファイル
# が存在する場合、init スクリプトは slapd を開始および再開しません
# (停止だけは実行されます)。設定ファイルを編集したくない場合
# (たとえば、メンテナンス中または設定管理システムの使用中などの場合)、
# ここで指定したファイルを使って一時的に slapd の開始を無効化します。
SLAPD_SENTINEL_FILE=/etc/ldap/noslapd

# slapd は (SASL を介した) Kerberos 認証の際にデフォルトでシステムの
# keytab ファイル (/etc/krb5.keytab) を使います。別の keytab ファイルを
# 使うには、以下の行でそのファイルを指定し、以下の行を有効化してください。
#export KRB5_KTNAME=/etc/krb5.keytab

# 以下では slapd に渡す追加の引数を指定します。
SLAPD_OPTIONS=""</programlisting>

					</example>

				</section>
				 <section>
					<title>クライアントの設定</title>
					 <para>
						クライアント側では <emphasis>libpam-ldap</emphasis> と <emphasis>libnss-ldap</emphasis> モジュールの設定を修正し、<literal>ldaps://</literal> URI を使うように設定する作業が必要です。
					</para>
					 <para>
						LDAP クライアントはサーバから認証を受ける必要があります。X.509 公開鍵基盤において、公開証明書は認証局 (CA) の鍵で署名されます。<emphasis>easy-rsa</emphasis> を使うことで、Falcot の管理者は自分自身の CA を作成しました。さらに管理者は Falcot の CA の署名を信頼するようにシステムを設定する必要があります。これを行うには、CA 証明書を <filename>/usr/local/share/ca-certificates</filename> に配置して <command>update-ca-certificates</command> を実行します。
					</para>
					 
<screen><computeroutput># </computeroutput><userinput>cp keys/ca.crt /usr/local/share/ca-certificates/falcot.crt
</userinput><computeroutput># </computeroutput><userinput>update-ca-certificates
</userinput><computeroutput>Updating certificates in /etc/ssl/certs... 1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....
Adding debian:falcot.pem
done.
done.
</computeroutput></screen>
					 <para>
						最後に重要なことですが、さまざまなコマンドラインツールで使われるデフォルトの LDAP URI とデフォルトのベース識別名は <filename>/etc/ldap/ldap.conf</filename> を編集すれば変更することが可能です。こうすることで、入力する量を激減させることが可能です。
					</para>
					 <example>
						<title><filename>/etc/ldap/ldap.conf</filename> ファイル</title>
						 
<programlisting>#
# LDAP のデフォルト設定
#

# 詳細は ldap.conf(5) を参照してください。全ユーザに対して
# このファイルの読み込みを許可し、書き込みを禁止してください。

BASE   dc=falcot,dc=com
URI    ldaps://ldap.falcot.com

#SIZELIMIT      12
#TIMELIMIT      15
#DEREF          never

# TLS 証明書 (これは GnuTLS を使う場合に必要です)
TLS_CACERT      /etc/ssl/certs/ca-certificates.crt</programlisting>

					</example>

				</section>

			</section>

		</section>

	</section>
	 <section id="sect.rtc-services">
		<title>リアルタイムコミュニケーションサービス</title>
		 <para>
			リアルタイムコミュニケーション (RTC) サービスには音声、動画/ウェブカメラ、インスタントメッセージ (IM) およびデスクトップ共有などがあります。この節では RTC を活用するために必要な 3 種類のサービスである TURN サーバ、SIP サーバ、XMPP サーバについて簡単に紹介します。これらのサービスを準備、インストール、管理するための包括的かつ詳細な情報を参照するには、リアルタイムコミュニケーションクイックスタートガイドをご覧ください。これには Debian 固有の例も含まれています。<ulink type="block" url="http://rtcquickstart.org" />
		</para>
		 <indexterm>
			<primary>VoIP</primary>
			<secondary>サーバ</secondary>
		</indexterm>
		 <indexterm>
			<primary>RTC</primary>
			<secondary>サーバ</secondary>
		</indexterm>
		 <indexterm>
			<primary>インスタントメッセージ</primary>
			<secondary>サーバ</secondary>
		</indexterm>
		 <indexterm>
			<primary>チャット</primary>
			<secondary>サーバ</secondary>
		</indexterm>
		 <para>
			SIP と XMPP はどちらも同じ機能を持っています。SIP は音声と動画用としてよく知られています。これに対して XMPP は伝統的に IM プロトコル用と考えられています。しかし実際のところ SIP と XMPP のどちらを使っても音声、動画、IM サービスを提供することが可能です。ただし、さまざまな方法で接続できるようにするためには SIP と XMPP の両方を同時に運用することを推奨します。
		</para>
		 <indexterm>
			<primary>SIP</primary>
		</indexterm>
		 <indexterm>
			<primary>XMPP</primary>
		</indexterm>
		 <para>
			SIP サービスおよび XMPP サービスでは認証と秘匿性を保持する目的で X.509 証明書を使います。X.509 証明書を作成する方法の詳細は<xref linkend="sect.easy-rsa" />を参照してください。また、<emphasis>リアルタイムコミュニケーションクイックスタートガイド</emphasis>にも有益な情報が含まれています。<ulink type="block" url="http://rtcquickstart.org/guide/multi/tls.html" />
		</para>
		 <section id="sect.rtc-dns-settings">
			<title>RTC サービス用の DNS 設定</title>
			 <para>
				RTC サービスを提供するには DNS SRV および NAPTR レコードが必要です。<literal>falcot.com</literal> 用のゾーンファイルに含める設定の見本は以下の通りです。
			</para>
			 <indexterm>
				<primary>DNS</primary>
				<secondary>SRV レコード</secondary>
			</indexterm>
			 <indexterm>
				<primary>DNS</primary>
				<secondary>NAPTR レコード</secondary>
			</indexterm>
			 
<programlisting>
; すべてのサービスが実行されるサーバ
server1            IN     A      198.51.100.19
server1            IN     AAAA   2001:DB8:1000:2000::19

; 一部の TURN クライアントは IPv6 の取り扱いにバグがあるので TURN サービスは IPv4 アドレスのみ
turn-server        IN     A      198.51.100.19

; SIP サービス用の IPv4 と IPv6 アドレス。
sip-proxy          IN     A      198.51.100.19
sip-proxy          IN     AAAA   2001:DB8:1000:2000::19

; XMPP サービス用の IPv4 と IPv6 アドレス。
xmpp-gw            IN     A      198.51.100.19
xmpp-gw            IN     AAAA   2001:DB8:1000:2000::19

; STUN と TURN サービス用の DNS SRV および NAPTR レコード
_stun._udp  IN SRV    0 1 3467 turn-server.falcot.com.
_turn._udp  IN SRV    0 1 3467 turn-server.falcot.com.
@           IN NAPTR  10 0 "s" "RELAY:turn.udp" "" _turn._udp.falcot.com.

; SIP サービス用の DNS SRV および NAPTR レコード
_sips._tcp  IN SRV    0 1 5061 sip-proxy.falcot.com.
@           IN NAPTR  10 0 "s" "SIPS+D2T" "" _sips._tcp.falcot.com.

; XMPP サーバとクライアント用の DNS SRV レコード
_xmpp-client._tcp  IN     SRV    5 0 5222 xmpp-gw.falcot.com.
_xmpp-server._tcp  IN     SRV    5 0 5269 xmpp-gw.falcot.com.</programlisting>

		</section>
		 <section id="sect.turn-server">
			<title>TURN サーバ</title>
			 <para>
				TURN は NAT ルータの背後にいるクライアントを助けるサービスです。さらに TURN は他のクライアントと通信するための最も適切な方法、直接のメディアパスが見つからない状態でメディアストリームを中継するための最も適切な方法を発見するファイアウォールでもあります。エンドユーザに提供する RTC サービスをインストールする前に TURN サーバをインストールすることを強く推奨します。
			</para>
			 <indexterm>
				<primary>TURN</primary>
				<secondary>サーバ</secondary>
			</indexterm>
			 <para>
				TURN とそれに関連する ICE プロトコルはオープン標準です。TURN および ICE プロトコルからの恩恵を受け、数多くの接続方法を提供してユーザの不満を低減するには、すべてのクライアントソフトウェアが ICE および TURN をサポートしている点を確認することが重要です。
			</para>
			 <indexterm>
				<primary>ICE</primary>
			</indexterm>
			 <para>
				ICE アルゴリズムを効果的に動作させるには、サーバが 2 種類の公開 IPv4 アドレスを持つ必要があります。
			</para>
			 <section id="sect.turn-server-install">
				<title>TURN サーバのインストール</title>
				 <para>
					最初に <emphasis role="pkg">resiprocate-turn-server</emphasis> パッケージをインストールします。
				</para>
				 <para>
					その後 <filename>/etc/reTurn/reTurnServer.config</filename> 設定ファイルを編集します。ここで忘れてはいけないのはサーバの IP アドレスを書き込むことです。
				</para>
				 
<programlisting>
# 以下でサーバの IP アドレスを指定します。
TurnAddress = 198.51.100.19
TurnV6Address = 2001:DB8:1000:2000::19
AltStunAddress = 198.51.100.20
# 以下で認証レルム名を指定します。既にパスワードが HA1
# アルゴリズムでハッシュ化されているならば、この値はハッシュ化
# の際に使った認証レルム名と一致しなければいけません。
AuthenticationRealm = myrealm

UserDatabaseFile = /etc/reTurn/users.txt
UserDatabaseHashedPasswords = true</programlisting>
				 <para>
					その後サービスを再起動してください。
				</para>

			</section>
			 <section id="sect.turn-server-management">
				<title>TURN ユーザの管理</title>
				 <para>
					TURN サーバのユーザリストを管理するには htdigest ユーティリティを使います。
				</para>
				
<screen><computeroutput># </computeroutput><userinput>htdigest /etc/reTurn/users.txt myrealm joe</userinput></screen>
				 <para>
					サーバに <filename>/etc/reTurn/users.txt</filename> ファイルを再読み込みさせるにはファイル編集後に HUP シグナルを送信するか、<filename>/etc/reTurn/reTurnServer.config</filename> 内の自動再読み込み機能を有効化します。
				</para>

			</section>

		</section>
		 <section id="sect.sip-server">
			<title>SIP プロキシサーバ</title>
			 <para>
				SIP プロキシサーバはさまざまな組織、SIP トンネルプロバイダ、Asterisk などの SIP PBX、SIP フォン、SIP を使うソフトフォン、WebRTC アプリケーションなどの間での SIP 接続の着信および発信を管理します。
			</para>
			 <indexterm>
				<primary>SIP</primary>
				<secondary>サーバ</secondary>
			</indexterm>
			 <indexterm>
				<primary>SIP</primary>
				<secondary>プロキシ</secondary>
			</indexterm>
			 <indexterm>
				<primary>SIP</primary>
				<secondary>PBX</secondary>
			</indexterm>
			 <indexterm>
				<primary>SIP</primary>
				<secondary>トランク</secondary>
			</indexterm>
			 <para>
				SIP PBX のセットアップを試みる前に SIP プロキシをインストールおよび設定することを強く推奨します。SIP プロキシは PBX に到達する数多くのトラフィックを正常化し、高い接続性能と復元性能をもたらします。
			</para>
			 <section id="sect.sip-server-install">
				<title>SIP プロキシのインストール</title>
				 <para>
					最初に <emphasis role="pkg">repro</emphasis> パッケージをインストールします。<emphasis role="pkg">repro</emphasis> パッケージは <emphasis role="distribution">jessie-backports</emphasis> のパッケージを使うことを強く推奨します。なぜなら、<emphasis role="distribution">jessie-backports</emphasis> のパッケージには接続性能と復元性能を最大化する最新の改良がなされているからです。
				</para>
				 <indexterm>
					<primary>repro</primary>
				</indexterm>
				 <para>
					次に <filename>/etc/repro/repro.config</filename> 設定ファイルを編集します。ここでは必ず SIP プロキシサーバの IP アドレスを記入してください。以下の例では TLS、IPv4、IPv6 を使う標準的な SIP および WebSockets/WebRTC を設定しています。
				</para>
				 
<programlisting>
# 以下では TLS 上の SIP 接続用に Transport1 を設定しています。ポート
# 5061 番を指定していますが、ファイアウォールの背後にいるクライアント
# を考慮する必要があるならば、ポート 443 番を指定することも可能です。 
Transport1Interface = 198.51.100.19:5061
Transport1Type = TLS
Transport1TlsDomain = falcot.com
Transport1TlsClientVerification = Optional
Transport1RecordRouteUri = sip:falcot.com;transport=TLS
Transport1TlsPrivateKey = /etc/ssl/private/falcot.com-key.pem
Transport1TlsCertificate = /etc/ssl/public/falcot.com.pem

# Transport2 は IPv6 向けの Transport1 です。
Transport2Interface = 2001:DB8:1000:2000::19:5061
Transport2Type = TLS
Transport2TlsDomain = falcot.com
Transport2TlsClientVerification = Optional
Transport2RecordRouteUri = sip:falcot.com;transport=TLS
Transport2TlsPrivateKey = /etc/ssl/private/falcot.com-key.pem
Transport2TlsCertificate = /etc/ssl/public/falcot.com.pem

# 以下では WebSocket (WebRTC) 上の SIP 接続用に Transport3 を設定
# しています。ポート 8443 番の代わりに 443 番を使うことも可能です。
Transport3Interface = 198.51.100.19:8443
Transport3Type = WSS
Transport3TlsDomain = falcot.com
# ブラウザに証明書を送信するよう要求しますが、現在これをサポートする
# ブラウザは存在しませんので None のままにしておいてください。
Transport3TlsClientVerification = None
Transport3RecordRouteUri = sip:falcot.com;transport=WSS
Transport3TlsPrivateKey = /etc/ssl/private/falcot.com-key.pem
Transport3TlsCertificate = /etc/ssl/public/falcot.com.pem

# Transport4 は IPv6 向けの Transport3 です。
Transport4Interface = 2001:DB8:1000:2000::19:8443
Transport4Type = WSS
Transport4TlsDomain = falcot.com
Transport4TlsClientVerification = None
Transport4RecordRouteUri = sip:falcot.com;transport=WSS
Transport4TlsPrivateKey = /etc/ssl/private/falcot.com-key.pem
Transport4TlsCertificate = /etc/ssl/public/falcot.com.pem

# Transport5 は内部ネットワーク上の Asterisk サーバに対する
# TCP 接続を可能にするものです。ファイアウォールを設定して、
# ポート 5060 番を通過する通信を外部に漏らさないようにしてください。
Transport5Interface = 198.51.100.19:5060
Transport5Type = TCP
Transport5RecordRouteUri = sip:198.51.100.19:5060;transport=TCP

HttpBindAddress = 198.51.100.19, 2001:DB8:1000:2000::19
HttpAdminUserFile = /etc/repro/users.txt

RecordRouteUri = sip:falcot.com;transport=tls
ForceRecordRouting = true
EnumSuffixes = e164.arpa, sip5060.net, e164.org
DisableOutbound = false
EnableFlowTokens = true
EnableCertificateAuthenticator = True</programlisting>
				 <para>
					さらに <command>htdigest</command> ユーティリティを使ってウェブインターフェース用の管理者パスワードを管理します。ユーザ名は <emphasis>admin</emphasis> でなければいけません。また、レルム名は <filename>repro.config</filename> 設定ファイルで指定したものに一致しなければいけません。
				</para>
				 
<screen><computeroutput># </computeroutput><userinput>htdigest /etc/repro/users.txt repro admin</userinput></screen>
				 <para>
					その後、新しい設定を使ってサービスを再起動します。
				</para>

			</section>
			 <section id="sect.sip-server-management">
				<title>SIP プロキシの管理</title>
				 <para>
					それではウェブインターフェース <literal>http://sip-proxy.falcot.com:5080</literal> にアクセスして、ドメイン、ローカルユーザ、静的ルーティングを追加して設定を完了させましょう。
				</para>
				 <para>
					最初にローカルドメインを追加します。リストからドメインを追加したり削除したら、必ずこの作業をやり直す必要があります。
				</para>
				 <para>
					SIP プロキシはローカルユーザと完全な SIP アドレスの間で電話呼び出しをルーティングする方法を知っています。デフォルト設定を上書きする必要がある場合のみルーティング設定を行う必要があります。たとえば電話番号を認識させたり、プレフィックスを追加したり、SIP プロバイダに電話番号をルーティングする場合などがこれに相当します。
				</para>

			</section>

		</section>
		 <section id="sect.xmpp-server">
			<title>XMPP サーバ</title>
			 <para>
				XMPP サーバはローカル XMPP ユーザと公開インターネット上の他のドメインに所属する XMPP ユーザの間の接続を管理します。
			</para>
			 <indexterm>
				<primary>XMPP</primary>
				<secondary>サーバ</secondary>
			</indexterm>
			 <sidebar> <title><emphasis>VOCABULARY</emphasis> XMPP か Jabber か?</title>
			 <indexterm>
				<primary>Jabber</primary>
			</indexterm>
			 <para>
				XMPP は Jabber と呼ばれることがあります。実際のところ、Jabber とは商標であり、XMPP は標準規格の公式名です。
			</para>
			 <indexterm>
				<primary>Jabber</primary>
			</indexterm>
			 </sidebar> <para>
				Prosody は人気の XMPP サーバであり、Debian サーバ上で安定動作します。
			</para>
			 <indexterm>
				<primary>Prosody</primary>
			</indexterm>
			 <section id="sect.xmpp-server-install">
				<title>XMPP サーバのインストール</title>
				 <para>
					最初に <emphasis role="pkg">prosody</emphasis> パッケージをインストールします。<emphasis role="pkg">prosody</emphasis> パッケージは <emphasis role="distribution">jessie-backports</emphasis> のパッケージを使うことを強く推奨します。なぜなら、<emphasis role="distribution">jessie-backports</emphasis> のパッケージには接続性能と復元性能を最大化する最新の改良がなされているからです。
				</para>
				 <indexterm>
					<primary>Prosody</primary>
				</indexterm>
				 <para>
					次に <filename>/etc/prosody/prosody.cfg.lua</filename> 設定ファイルを検査します。ここではサーバを管理することを許可するユーザの JID を書き込むことを忘れないでください。
				</para>
				 
<programlisting>
admins = { "joe@falcot.com" }</programlisting>
				 <para>
					また、各ドメインに対する設定ファイルも必要です。<filename>/etc/prosody/conf.avail/example.com.cfg.lua</filename> からサンプルをコピーして、これを足掛かりとして使ってください。以下は <literal>falcot.com.cfg.lua</literal> の例です。
				</para>
				 
<programlisting>
VirtualHost "falcot.com"
        enabled = true
        ssl = {
                key = "/etc/ssl/private/falcot.com-key.pem";
                certificate = "/etc/ssl/public/falcot.com.pem";
                }</programlisting>
				 <para>
					<literal>falcot.com</literal> ドメインを有効化するには、このファイルへのシンボリックリンクを <filename>/etc/prosody/conf.d/</filename> の中に作ってください。これを行うには以下のコマンドを実行します。
				</para>
				 
<screen><computeroutput># </computeroutput><userinput>ln -s /etc/prosody/conf.avail/falcot.com.cfg.lua /etc/prosody/conf.d/</userinput></screen>
				 <para>
					その後、新しい設定を使ってサービスを再起動します。
				</para>

			</section>
			 <section id="sect.xmpp-server-management">
				<title>XMPP サーバの管理</title>
				 <para>
					一部の管理操作は <literal>prosodyctl</literal> コマンドラインユーティリティを使って実行することが可能です。たとえば、<filename>/etc/prosody/prosody.cfg.lua</filename> の中で指定した管理者アカウントをユーザアカウントに追加するには、以下のコマンドを実行します。
				</para>
				
<programlisting>
# prosodyctl adduser joe@falcot.com</programlisting>
				 <para>
					設定をカスタマイズする方法に関する詳しい情報を参照するには <ulink url="http://prosody.im/doc/configure">Prosody のオンライン文書</ulink>をご覧ください。
				</para>

			</section>

		</section>
		 <section id="sect.rtc-port-443">
			<title>ポート 443 番でサービスを実行する</title>
			 <para>
				すべての RTC サービスをポート 443 番で実行したいと思う管理者がいるかもしれません。こうすることで、他のポートがふさがれていたり HTTP プロキシサーバを通じてインターネットトラフィックをルーティングしているような、ホテルや空港などのリモート場所から接続するユーザを受け入れることが可能になります。
			</para>
			 <para>
				この方針を採用する場合、それぞれのサービス (SIP、XMPP、TURN) に別々の IP アドレスを設定する必要があります。しかし、すべてのサービスは同じホスト上で運用することが可能です。なぜなら Linux は 1 台のホスト上で複数の IP アドレスを取り扱うことが可能だからです。この場合、それぞれのサービスに対する設定ファイルおよび DNS SRV レコードの中でポート番号 (今回の場合 443 番) を指定しなければいけません。
			</para>

		</section>
		 <section id="sect.rtc-webrtc">
			<title>WebRTC の追加</title>
			 <para>
				Falcot は顧客がウェブサイトから電話をかけることができるようしたいと思っています。また Falcot の管理者は障害復旧策の一部として WebRTC を使いたいと思っています。こうすることでスタッフは自宅からウェブブラウザを使って会社の電話システムにログインし、緊急時にも通常と同じ環境で作業を行うことが可能になります。
			</para>
			 <indexterm>
				<primary>WebRTC</primary>
			</indexterm>
			 <indexterm>
				<primary>SIP</primary>
				<secondary>WebSockets</secondary>
			</indexterm>
			 <sidebar> <title><emphasis>IN PRACTICE</emphasis> WebRTC を試す</title>
			 <indexterm>
				<primary>WebRTC</primary>
				<secondary>デモ</secondary>
			</indexterm>
			 <para>
				これまでに WebRTC を試した経験がないのなら、オンラインデモおよび設備テストを提供するさまざまなサイトが存在します。<ulink type="block" url="http://www.sip5060.net/test-calls" />
			</para>
			 </sidebar> <para>
				WebRTC は急速に進化している技術で、<emphasis role="distribution">jessie-backports</emphasis> または<emphasis role="distribution">テスト版</emphasis>ディストリビューションに含まれるパッケージを使うことが不可欠です。
			</para>
			 <para>
				JSCommunicator は包括的かつノーブランドの WebRTC 電話で、PHP などのスクリプトサポートをサーバ側で用意する必要がありません。JSCommunicator はもっぱら HTML、CSS、JavaScript だけで作られています。JSCommunicator は他の数多くの WebRTC サービスの基盤となっており、先進的なウェブパブリッシングフレームワークの部品でもあります。<ulink type="block" url="http://jscommunicator.org" />
			</para>
			 <indexterm>
				<primary>JSCommunicator</primary>
			</indexterm>
			 <para>
				<emphasis role="pkg">jscommunicator-web-phone</emphasis> パッケージをインストールすることは WebRTC 電話をウェブサイトにインストールする最も素早い方法です。<emphasis role="pkg">jscommunicator-web-phone</emphasis> パッケージを使うには WebSocket 転送をサポートする SIP プロキシが必要です。<emphasis role="pkg">repro</emphasis> SIP プロキシで WebSocket 転送を有効化するために必要な詳細除法を参照するには<xref linkend="sect.sip-server-install" />をご覧ください。
			</para>
			 <para>
				<emphasis role="pkg">jscommunicator-web-phone</emphasis> をインストールしたら、これを使う方法はさまざまあります。最も簡単な方法は、Apache 仮想ホスト設定ファイルから <filename>/etc/jscommunicator-web-phone/apache.conf</filename> を読みこんだり、Apache 仮想ホスト設定ファイルにこれをコピーする方法です。
			</para>
			 <para>
				この web-phone ファイルがウェブサーバから利用できるようになったら、<filename>/etc/jscommunicator-web-phone/config.js</filename> をカスタマイズして、TURN サーバと SIP プロキシを指定します。以下はその例です。
			</para>
			 
<programlisting>
JSCommSettings = {

  // ウェブサーバ環境
  webserver: {
    url_prefix: null            // 設定済みならば、その値を sounds/ 以下の URL に前置します
  },

  // STUN/TURN メディアリレー
  stun_servers: [],
  turn_servers: [
    { server:"turn:turn-server.falcot.com?transport=udp", username:"joe", password:"j0Ep455d" }
  ],

  // WebSocket 接続
  websocket: {
      // ここでは falcot.com ドメイン証明書とポート 8443 番を
      // 指定しています。これは falcot.com 用 repro.config
      // ファイルの Transport3 および Transport4 に相当します
    servers: 'wss://falcot.com:8443',
    connection_recovery_min_interval: 2,
    connection_recovery_max_interval: 30
  },

  ...</programlisting>
			 <para>
				クリックして電話をかける機能を備えたウェブサイトの中でもさらに先進的なサイトでは、典型的にサーバ側スクリプトを使って <literal>config.js</literal> ファイルを動的に生成しています。<ulink url="http://drucall.org">DruCall</ulink> のソースコードを読むと PHP を使って <literal>config.js</literal> ファイルを動的に生成する方法がわかります。
			</para>
			 <indexterm>
				<primary>DruCall</primary>
			</indexterm>
			 <para>
				この章では、利用できるサーバソフトウェアのうちのほんのわずかなソフトウェアだけに注目しました。しかしながら、ほとんどの一般的なネットワークサービスについて言及しました。今や、より技術的な章に入る準備が整ったと言えます。具体的に言えば、一部の概念に関してより詳細を解説し、大規模な配備と仮想化について説明します。
			</para>

		</section>

	</section>
</chapter>

